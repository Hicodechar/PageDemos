
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.52 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.52</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 2, 2018, 1:36 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180102133657.GV2971@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10140541/mbox/"
   >mbox</a>
|
   <a href="/patch/10140541/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10140541/">/patch/10140541/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9D58060362 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  2 Jan 2018 13:38:09 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4B43D28AC8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  2 Jan 2018 13:38:09 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 3E2A228B27; Tue,  2 Jan 2018 13:38:09 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-5.9 required=2.0 tests=BAYES_00,HEXHASH_WORD,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DDDC328AC8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  2 Jan 2018 13:37:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753340AbeABNhf (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 2 Jan 2018 08:37:35 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:37308 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751550AbeABNhO (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 2 Jan 2018 08:37:14 -0500
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1eWMkT-0007x0-9e; Tue, 02 Jan 2018 13:37:09 +0000
Date: Tue, 2 Jan 2018 13:36:57 +0000
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20180102133657.GV2971@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;fkwCrey//1f/3EP1&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.16.52
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Jan. 2, 2018, 1:36 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.52 kernel.

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.51 is attached to this message.

Ben.

------------

 Makefile                                           |   2 +-
 arch/alpha/kernel/ptrace.c                         |   2 +-
 arch/arm/boot/dts/da850-evm.dts                    |   7 ++
 arch/arm/include/asm/Kbuild                        |   1 -
 arch/arm/include/asm/unaligned.h                   |  27 +++++
 arch/arm/kernel/traps.c                            |  28 ++++--
 arch/arm/kvm/emulate.c                             |   5 +-
 arch/arm/kvm/mmio.c                                |   4 +-
 arch/arm64/kernel/head.S                           |   1 +
 arch/arm64/kernel/traps.c                          |  28 +++---
 arch/arm64/kvm/inject_fault.c                      |  16 ++-
 arch/arm64/mm/fault.c                              |   2 +-
 arch/blackfin/kernel/ptrace.c                      |   4 +-
 arch/cris/arch-v32/kernel/ptrace.c                 |   2 +-
 arch/ia64/kernel/ptrace.c                          |   2 +-
 arch/mips/ar7/platform.c                           |   1 +
 arch/mips/include/asm/mips-cm.h                    |   4 +-
 arch/mips/kernel/ptrace32.c                        |   4 +-
 arch/mips/mm/uasm-micromips.c                      |   2 +-
 arch/parisc/kernel/syscall.S                       |   6 +-
 arch/powerpc/kernel/ptrace32.c                     |   4 +-
 arch/powerpc/perf/core-book3s.c                    |   5 +
 arch/powerpc/platforms/pseries/mobility.c          |   4 +-
 arch/s390/mm/gup.c                                 |   7 +-
 arch/sh/include/cpu-sh2a/cpu/sh7264.h              |   4 +-
 arch/sh/include/cpu-sh2a/cpu/sh7269.h              |   4 +-
 arch/sh/include/cpu-sh4/cpu/sh7722.h               |   2 +-
 arch/sh/include/cpu-sh4/cpu/sh7757.h               |   8 +-
 arch/tile/kernel/setup.c                           |   2 +-
 arch/x86/crypto/salsa20_glue.c                     |   7 --
 arch/x86/include/asm/uaccess.h                     |  14 ++-
 arch/x86/kernel/amd_nb.c                           |  48 +++++++++
 arch/x86/kernel/cpu/microcode/intel.c              |  18 ++++
 arch/x86/kvm/vmx.c                                 |   7 +-
 arch/x86/kvm/x86.c                                 |   8 +-
 arch/x86/oprofile/op_model_ppro.c                  |   4 +-
 block/bio.c                                        |  14 ++-
 crypto/hmac.c                                      |   6 +-
 crypto/salsa20_generic.c                           |   7 --
 crypto/shash.c                                     |  13 ++-
 drivers/block/rbd.c                                |   4 +-
 drivers/bus/mvebu-mbus.c                           |   2 +-
 drivers/crypto/talitos.c                           |   7 +-
 drivers/gpio/gpiolib-acpi.c                        |   2 +-
 drivers/gpu/drm/i915/intel_bios.c                  |   7 ++
 drivers/hid/i2c-hid/i2c-hid.c                      |   3 +-
 drivers/iio/adc/ad7793.c                           |   4 +-
 drivers/iio/adc/ad_sigma_delta.c                   |  28 ++++++
 drivers/iio/adc/mcp320x.c                          |   1 +
 drivers/iio/industrialio-core.c                    |   4 +-
 drivers/infiniband/hw/mlx5/mem.c                   |  49 ++++-----
 drivers/infiniband/hw/ocrdma/ocrdma_hw.c           |   3 +
 drivers/infiniband/ulp/ipoib/ipoib_ib.c            |  13 ---
 drivers/input/ff-core.c                            |  13 ++-
 drivers/input/misc/ims-pcu.c                       |  16 ++-
 drivers/input/misc/uinput.c                        |  57 +++++++----
 drivers/input/touchscreen/ti_am335x_tsc.c          |   2 +-
 drivers/iommu/amd_iommu.c                          |   1 +
 drivers/iommu/exynos-iommu.c                       |   2 +-
 drivers/net/can/c_can/c_can_pci.c                  |   1 -
 drivers/net/can/c_can/c_can_platform.c             |   1 -
 drivers/net/can/usb/esd_usb2.c                     |   2 +-
 drivers/net/can/usb/gs_usb.c                       |  10 +-
 drivers/net/can/usb/kvaser_usb.c                   |   3 +-
 drivers/net/macvtap.c                              |   6 +-
 drivers/net/tun.c                                  |   7 ++
 drivers/net/wireless/brcm80211/brcmfmac/fweh.c     |  58 +++--------
 drivers/net/wireless/brcm80211/brcmfmac/fweh.h     |  68 ++++++++++---
 drivers/net/wireless/brcm80211/brcmfmac/p2p.c      |  10 ++
 .../net/wireless/brcm80211/brcmfmac/wl_cfg80211.c  |   5 +
 drivers/net/wireless/iwlwifi/mvm/mac80211.c        |  10 +-
 drivers/pci/pci-sysfs.c                            |  11 ++-
 drivers/s390/scsi/zfcp_aux.c                       |   5 +
 drivers/s390/scsi/zfcp_erp.c                       |  18 ++--
 drivers/s390/scsi/zfcp_scsi.c                      |   5 +
 drivers/scsi/libiscsi.c                            |   2 +-
 drivers/scsi/lpfc/lpfc_init.c                      |   1 +
 drivers/scsi/scsi_scan.c                           |   3 +
 drivers/scsi/sd.c                                  |  16 ++-
 drivers/staging/iio/adc/ad7192.c                   |   4 +-
 drivers/staging/iio/meter/ade7759.c                |   2 +-
 drivers/usb/class/cdc-acm.c                        |   3 +
 drivers/usb/core/config.c                          |   6 +-
 drivers/usb/core/hub.c                             |  13 ++-
 drivers/usb/core/quirks.c                          |   4 +
 drivers/usb/gadget/composite.c                     |   5 +
 drivers/usb/gadget/dummy_hcd.c                     |  81 +++++++++++----
 drivers/usb/gadget/f_mass_storage.c                |  31 ++----
 drivers/usb/gadget/f_mass_storage.h                |  14 ---
 drivers/usb/gadget/inode.c                         |  55 +++++++++--
 drivers/usb/gadget/mass_storage.c                  |  20 +---
 drivers/usb/gadget/net2280.c                       |   5 +-
 drivers/usb/host/pci-quirks.c                      |   8 +-
 drivers/usb/host/xhci-hub.c                        |  22 ++++-
 drivers/usb/host/xhci.h                            |   2 +-
 drivers/usb/renesas_usbhs/fifo.c                   |  23 ++++-
 drivers/usb/serial/cp210x.c                        |   1 +
 drivers/usb/serial/ftdi_sio.c                      |   2 +
 drivers/usb/serial/ftdi_sio_ids.h                  |   7 ++
 drivers/usb/serial/metro-usb.c                     |   1 +
 drivers/usb/serial/option.c                        |   2 +
 drivers/usb/serial/qcserial.c                      |   4 +
 drivers/usb/storage/transport.c                    |  14 ++-
 drivers/usb/storage/unusual_devs.h                 |   7 ++
 drivers/uwb/hwa-rc.c                               |   2 +
 drivers/uwb/uwbd.c                                 |  12 ++-
 fs/block_dev.c                                     |   6 +-
 fs/btrfs/ioctl.c                                   |  10 +-
 fs/cifs/cifsfs.c                                   |   2 +-
 fs/cifs/connect.c                                  |   8 ++
 fs/cifs/file.c                                     |   7 ++
 fs/cifs/smb2pdu.c                                  |  34 +++++--
 fs/direct-io.c                                     |   3 +-
 fs/ecryptfs/ecryptfs_kernel.h                      |  25 +++--
 fs/ecryptfs/keystore.c                             |   9 +-
 fs/exec.c                                          |  22 ++++-
 fs/fscache/object-list.c                           |   7 ++
 fs/fuse/dir.c                                      |   3 +-
 fs/mpage.c                                         |  14 ++-
 fs/ocfs2/alloc.c                                   |  24 +++--
 fs/read_write.c                                    |   4 +-
 fs/xattr.c                                         |   2 +-
 include/crypto/internal/hash.h                     |   8 ++
 include/linux/buffer_head.h                        |   1 +
 include/linux/capability.h                         |   2 +
 include/linux/iio/adc/ad_sigma_delta.h             |   3 +
 include/linux/input.h                              |   1 +
 include/linux/key.h                                |   2 +
 include/linux/mbus.h                               |   4 +-
 include/linux/mm.h                                 |   2 +
 include/linux/mm_types.h                           |   1 +
 include/linux/mmzone.h                             |  10 +-
 include/linux/netdevice.h                          |   3 +
 include/linux/of.h                                 |  10 ++
 include/linux/pci_ids.h                            |   2 +
 include/linux/preempt_mask.h                       |  21 ++--
 include/linux/ptrace.h                             |  11 ++-
 include/linux/sched.h                              |   1 +
 include/linux/skbuff.h                             |   7 ++
 include/net/protocol.h                             |   2 +-
 include/net/route.h                                |   4 +-
 include/net/tcp.h                                  |   8 +-
 include/net/udp.h                                  |   2 +-
 include/scsi/scsi_device.h                         |   1 +
 include/scsi/scsi_devinfo.h                        |   1 +
 include/sound/seq_kernel.h                         |   3 +-
 include/sound/seq_virmidi.h                        |   1 +
 include/sound/timer.h                              |   2 +
 include/trace/events/kvm.h                         |   7 +-
 include/uapi/linux/spi/spidev.h                    |   1 +
 kernel/capability.c                                |  36 ++++++-
 kernel/fork.c                                      |   9 +-
 kernel/params.c                                    |   2 +-
 kernel/ptrace.c                                    |  91 +++++++++++------
 kernel/sched/core.c                                |  21 ++--
 kernel/sched/features.h                            |   1 -
 kernel/sysctl.c                                    |   3 +-
 kernel/trace/trace.c                               |  12 ++-
 kernel/workqueue.c                                 |  37 +++----
 kernel/workqueue_internal.h                        |   3 +-
 lib/asn1_decoder.c                                 |   7 +-
 lib/digsig.c                                       |   6 ++
 mm/huge_memory.c                                   |  14 +--
 mm/init-mm.c                                       |   2 +
 mm/memory.c                                        |   2 +-
 mm/memory_hotplug.c                                |   6 +-
 mm/nommu.c                                         |   2 +-
 net/8021q/vlan.c                                   |   6 +-
 net/bluetooth/bnep/core.c                          |   3 +
 net/bluetooth/cmtp/core.c                          |   3 +
 net/core/dev.c                                     |   6 +-
 net/core/rtnetlink.c                               |   5 +-
 net/core/skbuff.c                                  |   1 +
 net/dccp/proto.c                                   |   5 +
 net/ipv4/ip_input.c                                |  22 +++--
 net/ipv4/ip_vti.c                                  |   3 +-
 net/ipv4/route.c                                   |  44 +++++----
 net/ipv4/tcp_ipv4.c                                |   9 +-
 net/ipv4/tcp_output.c                              |  12 ++-
 net/ipv4/udp.c                                     |  30 ++++--
 net/ipv6/ip6_gre.c                                 |  41 ++++----
 net/ipv6/ip6_vti.c                                 |   3 +-
 net/l2tp/l2tp_core.c                               |  10 +-
 net/l2tp/l2tp_core.h                               |   5 +-
 net/l2tp/l2tp_eth.c                                |  51 +---------
 net/l2tp/l2tp_ip.c                                 |  20 ++--
 net/l2tp/l2tp_ip6.c                                |  21 ++--
 net/l2tp/l2tp_ppp.c                                |  10 +-
 net/netfilter/ipset/ip_set_core.c                  |  23 +++--
 net/netfilter/nfnetlink_cthelper.c                 |  10 ++
 net/netfilter/x_tables.c                           |   4 +-
 net/netfilter/xt_osf.c                             |   7 ++
 net/netlink/af_netlink.c                           |   3 +
 net/packet/af_packet.c                             |   4 +-
 net/sched/sch_generic.c                            |   1 +
 net/sctp/input.c                                   |   2 +-
 net/sctp/sm_sideeffect.c                           |   4 +-
 net/unix/diag.c                                    |   2 +
 net/wireless/nl80211.c                             |  12 ++-
 net/xfrm/xfrm_state.c                              |   1 +
 net/xfrm/xfrm_user.c                               |   3 +-
 security/keys/big_key.c                            |   2 +-
 security/keys/encrypted-keys/encrypted.c           |   7 ++
 security/keys/internal.h                           |   2 +-
 security/keys/key.c                                |   2 +
 security/keys/keyctl.c                             |   8 +-
 security/keys/keyring.c                            |  72 +++++++-------
 security/keys/process_keys.c                       |   8 +-
 security/keys/request_key.c                        |  46 +++++++--
 security/keys/request_key_auth.c                   |  69 ++++++-------
 security/keys/trusted.c                            |  69 ++++++-------
 security/smack/smack_lsm.c                         |  65 ++++++------
 security/yama/yama_lsm.c                           |   4 +-
 sound/core/hrtimer.c                               |   1 +
 sound/core/seq/oss/seq_oss_midi.c                  |   4 +-
 sound/core/seq/oss/seq_oss_readq.c                 |  29 ++++++
 sound/core/seq/oss/seq_oss_readq.h                 |   2 +
 sound/core/seq/seq_clientmgr.c                     |   2 +-
 sound/core/seq/seq_virmidi.c                       |  27 +++--
 sound/core/timer.c                                 | 109 ++++++++++++++-------
 sound/core/timer_compat.c                          |  17 +++-
 sound/pci/hda/hda_codec.c                          |   2 +-
 sound/soc/codecs/adau17x1.c                        |  24 ++++-
 sound/soc/codecs/adau17x1.h                        |   2 +
 sound/usb/caiaq/device.c                           |  12 ++-
 sound/usb/usx2y/usb_stream.c                       |   6 +-
 226 files changed, 1732 insertions(+), 944 deletions(-)

Adrian Salido (1):
      HID: i2c-hid: allocate hid buffers for real worst case

Al Viro (3):
      more bio_map_user_iov() leak fixes
      Bluetooth: cmtp: cmtp_add_connection() should verify that it&#39;s dealing with l2cap socket
      Bluetooth: bnep: bnep_add_connection() should verify that it&#39;s dealing with l2cap socket

Alan Stern (11):
      usb-storage: fix bogus hardware error messages for ATA pass-thru devices
      usb-storage: unusual_devs entry to fix write-access regression for Seagate external drives
      USB: gadgetfs: fix copy_to_user while holding spinlock
      USB: gadgetfs: Fix crash caused by inadequate synchronization
      USB: g_mass_storage: Fix deadlock when driver is unbound
      USB: dummy-hcd: fix connection failures (wrong speed)
      USB: dummy-hcd: fix infinite-loop resubmission bug
      USB: gadgetfs, dummy-hcd, net2280: fix locking for callbacks
      USB: dummy-hcd: Fix erroneous synchronization change
      USB: dummy-hcd: Fix deadlock caused by disconnect detection
      USB: core: prevent malicious bNumInterfaces overflow

Alex Estrin (1):
      Revert &quot;IB/ipoib: Update broadcast object if PKey value was changed in index 0&quot;

Alexey Kodanev (1):
      vti: fix use after free in vti_tunnel_xmit/vti6_tnl_xmit

Andreas Engel (1):
      USB: serial: cp210x: add support for ELV TFD500

Andreas Gruenbacher (2):
      vfs: Return -ENXIO for negative SEEK_HOLE / SEEK_DATA offsets
      direct-io: Prevent NULL pointer access in submit_page_section

Andrei Vagin (1):
      net/unix: don&#39;t show information about sockets from other namespaces

Andrew Gabbasov (1):
      usb: gadget: composite: Fix use-after-free in usb_composite_overwrite_options

Andrew Honig (1):
      KVM: VMX: remove I/O port 0x80 bypass on Intel hosts

Andrey Konovalov (2):
      uwb: ensure that endpoint is interrupt
      uwb: properly check kthread_run return value

Aravind Gopalakrishnan (2):
      pci_ids: Add PCI device IDs for F15h M60h
      x86, amd_nb: Add device IDs to NB tables for F15h M60h

Arnd Bergmann (4):
      gpio: acpi: work around false-positive -Wstring-overflow warning
      usb: gadget: dummy: fix nonsensical comparisons
      include/linux/of.h: provide of_n_{addr,size}_cells wrappers for !CONFIG_OF
      ARM: 8715/1: add a private asm/unaligned.h

Ashish Samant (1):
      ocfs2: fstrim: Fix start offset of first cluster group during fstrim

Baruch Siach (1):
      spi: uapi: spidev: add missing ioctl header

Ben Hutchings (2):
      ipsec: Fix aborted xfrm policy dump crash
      Linux 3.16.52

Bo Yan (1):
      tracing: Erase irqsoff trace with empty write

Borislav Petkov (3):
      x86/microcode/intel: Disable late loading on model 79
      x86/cpu/AMD: Apply the Erratum 688 fix when the BIOS doesn&#39;t
      x86/oprofile/ppro: Do not use __this_cpu*() in preemptible context

Casey Schaufler (1):
      lsm: fix smack_inode_removexattr and xattr_getsecurity memleak

Christophe Jaillet (1):
      IB/mlx5: Fix the size parameter to find_first_bit

Colin Ian King (2):
      IB/ocrdma: fix incorrect fall-through on switch statement
      staging: iio: ade7759: fix signed extension bug on shift of a u8

Cong Wang (2):
      tun: call dev_get_valid_name() before register_netdevice()
      vlan: fix a use-after-free in vlan_device_event()

Craig Gallek (1):
      tun/tap: sanitize TUNSETSNDBUF input

Dan Carpenter (1):
      tile: array underflow in setup_maxnodemem()

David Disseldorp (2):
      SMB: fix leak of validate negotiate info response buffer
      SMB: fix validate negotiate info uninitialised memory use

Dmitry Fleytman (1):
      usb: Increase quirk delay for USB devices

Dmitry Torokhov (3):
      Input: uinput - avoid FF flush when destroying device
      Input: uinput - avoid crash when sending FF request to device going away
      Input: ims-psu - check if CDC union descriptor is sane

Dongjiu Geng (1):
      arm/arm64: KVM: set right LR register value for 32 bit guest when inject abort

Dragos Bogdan (2):
      iio: ad_sigma_delta: Implement a dedicated reset function
      iio: ad7793: Fix the serial interface reset

Eric Biggers (18):
      KEYS: fix cred refcount leak in request_key_auth_new()
      KEYS: don&#39;t revoke uninstantiated key in request_key_auth_new()
      KEYS: fix key refcount leak in keyctl_assume_authority()
      KEYS: fix key refcount leak in keyctl_read_key()
      KEYS: fix writing past end of user-supplied buffer in keyring_read()
      KEYS: prevent creating a different user&#39;s keyrings
      KEYS: encrypted: fix dereference of NULL user_key_payload
      FS-Cache: fix dereference of NULL user_key_payload
      lib/digsig: fix dereference of NULL user_key_payload
      ecryptfs: fix dereference of NULL user_key_payload
      KEYS: return full count in keyring_read() if buffer is too small
      KEYS: trusted: sanitize all key material
      KEYS: trusted: fix writing past end of buffer in trusted_read()
      KEYS: fix out-of-bounds read during ASN.1 parsing
      KEYS: fix NULL pointer dereference during ASN.1 parsing [ver #2]
      crypto: salsa20 - fix blkcipher_walk API usage
      crypto: hmac - require that the underlying hash algorithm is unkeyed
      KEYS: add missing permission check for request_key() destination

Eric Dumazet (3):
      tcp: fastopen: fix on syn-data transmit failure
      netfilter: x_tables: avoid stack-out-of-bounds read in xt_copy_counters_from_user
      tcp: fix tcp_mtu_probe() vs highest_sack

Eric W. Biederman (5):
      mm: Add a user_ns owner to mm_struct and fix ptrace permission checks
      ptrace: Capture the ptracer&#39;s creds not PT_PTRACE_CAP
      exec: Ensure mm-&gt;user_ns contains the execed files
      ptrace: Don&#39;t allow accessing an undumpable mm
      ptrace: Properly initialize ptracer_cred on fork

Ethan Zhao (1):
      sched/sysctl: Check user input value of sysctl_sched_time_avg

Felipe Balbi (1):
      usb: quirks: add quirk for WORLDE MINI MIDI keyboard

Florian Westphal (1):
      netfilter: ipset: pernet ops must be unregistered last

Geert Uytterhoeven (4):
      sh: sh7722: remove nonexistent GPIO_PTQ7 to fix pinctrl registration
      sh: sh7757: remove nonexistent GPIO_PT[JLNQ]7_RESV to fix pinctrl registration
      sh: sh7264: remove nonexistent GPIO_PH[0-7] to fix pinctrl registration
      sh: sh7269: remove nonexistent GPIO_PH[0-7] to fix pinctrl registration

Gerald Schaefer (1):
      s390/mm: fix write access check in gup_huge_pmd()

Guillaume Nault (6):
      l2tp: fix l2tp_eth module loading
      l2tp: check ps-&gt;sock before running pppol2tp_session_ioctl()
      l2tp: hold tunnel in pppol2tp_connect()
      l2tp: hold socket before dropping lock in l2tp_ip{, 6}_recv()
      l2tp: hold tunnel socket when handling control frames in l2tp_ip and l2tp_ip6
      l2tp: don&#39;t use l2tp_tunnel_find() in l2tp_ip and l2tp_ip6

Gustavo A. R. Silva (1):
      MIPS: microMIPS: Fix incorrect mask in insn_table_MM

Hante Meuleman (1):
      brcmfmac: Add length checks on firmware events

Haozhong Zhang (1):
      KVM: nVMX: fix guest CR4 loading when emulating L2 to L1 exit

Henryk Heisig (1):
      USB: serial: option: add support for TP-Link LTE module

Herbert Xu (1):
      crypto: shash - Fix zero-length shash ahash digest crash

Ilya Dryomov (1):
      rbd: use GFP_NOIO for parent stat and data requests

Ilya Lesokhin (1):
      IB/mlx5: Simplify mlx5_ib_cont_pages

Jan Luebbe (1):
      bus: mbus: fix window size calculation for 4GB windows

Jani Nikula (1):
      drm/i915/bios: ignore HDMI on port A

Jann Horn (1):
      security: let security modules use PTRACE_MODE_* with bitmasks

Jason A. Donenfeld (1):
      security/keys: properly zero out sensitive key material in big_key

Jean Delvare (1):
      kernel/params.c: align add_sysfs_param documentation with code

Jeff Lance (1):
      Input: ti_am335x_tsc - fix incorrect step config for 5 wire touchscreen

Jeffrey Chu (1):
      USB: serial: ftdi_sio: add id for Cypress WICED dev board

Jim Dickerson (1):
      usb: pci-quirks.c: Corrected timeout values used in handshake

Jimmy Assarsson (1):
      can: kvaser_usb: Correct return value in printout

Joerg Roedel (1):
      iommu/amd: Finish TLB flush in amd_iommu_unmap()

Johan Hovold (1):
      USB: serial: metro-usb: add MS7820 device id

Johannes Thumshirn (1):
      scsi: libiscsi: fix shifting of DID_REQUEUE host byte

John David Anglin (1):
      parisc: Fix double-word compare and exchange in LWS code on 32-bit kernels

Jonathan Basseri (1):
      xfrm: Clear sk_dst_cache when applying per-socket policy.

Kazuya Mizuguchi (1):
      usb: renesas_usbhs: Fix DMAC sequence for receiving zero-length packet

Kevin Cernekee (4):
      brcmfmac: Add check for short event packets
      netfilter: nfnetlink_cthelper: Add missing permission checks
      netlink: Add netns check on taps
      netfilter: xt_osf: Add missing permission checks

Kirill A. Shutemov (1):
      mm, thp: Do not make page table dirty unconditionally in touch_p[mu]d()

Konstantin Khlebnikov (2):
      net_sched: always reset qdisc backlog in qdisc_reset()
      Smack: remove unneeded NULL-termination from securtity label

LEROY Christophe (2):
      crypto: talitos - fix sha224
      crypto: talitos - Don&#39;t provide setkey for non hmac hashing algs.

Lauro Ramos Venancio (1):
      sched/topology: Optimize build_group_mask()

Li Bin (1):
      workqueue: Fix NULL pointer dereference

Luca Coelho (1):
      iwlwifi: mvm: use IWL_HCMD_NOCOPY for MCAST_FILTER_CMD

Lukas Wunner (1):
      iio: adc: mcp320x: Fix oops on module unload

Maksim Salau (1):
      usb: cdc_acm: Add quirk for Elatec TWN3

Marc Zyngier (1):
      arm64: Make sure SPsel is always set

Marek Szyprowski (1):
      iommu/exynos: Remove initconst attribute to avoid potential kernel oops

Mark Rutland (3):
      arm64: fix dump_instr when PAN and UAO are in use
      arm64: ensure __dump_instr() checks addr_limit
      ARM: 8720/1: ensure dump_instr() checks addr_limit

Martin K. Petersen (1):
      scsi: sd: Implement blacklist option for WRITE SAME w/ UNMAP

Mathias Nyman (2):
      xhci: fix finding correct bus_state structure for USB 3.1 hosts
      usb: hub: Allow reset retry for USB2 devices on connect bounce

Matt Bennett (1):
      ip6_gre: Reduce log level in ip6gre_err() to debug

Matt Fornero (1):
      iio: core: Return error for failed read_reg

Matthew Wilcox (1):
      fs/mpage.c: fix mpage_writepage() for pages with buffers

Mayank Rana (1):
      usb: xhci: Handle error condition in xhci_stop_device()

Michael S. Tsirkin (1):
      macvtap: fix TUNSETSNDBUF values &gt; 64k

Miklos Szeredi (1):
      fuse: fix READDIRPLUS skipping an entry

Mohamed Ghannam (1):
      dccp: CVE-2017-8824: use-after-free in DCCP code

Nicolai Stange (1):
      PCI: Fix race condition with driver_override

Nicolas Dichtel (1):
      net: enable interface alias removal via rtnl

Oleg Nesterov (1):
      ptrace: change __ptrace_unlink() to clear -&gt;ptrace under -&gt;siglock

Omar Sandoval (1):
      Btrfs: fix incorrect {node,sector}size endianness from BTRFS_IOC_FS_INFO

Oswald Buddenhagen (1):
      MIPS: AR7: Ensure that serial ports are properly set up

Paolo Abeni (4):
      ipv4: fix broadcast packets reception
      IPv4: early demux can return an error code
      udp: perform source validation for mcast early demux
      udp: fix bcast packet reception

Paul Burton (1):
      MIPS: Fix CM region target definitions

Peng Xu (1):
      nl80211: Define policy for packet pattern attributes

Peter Zijlstra (3):
      x86/uaccess, sched/preempt: Verify access_ok() context
      sched/topology: Remove FORCE_SD_OVERLAP
      sched/topology: Simplify build_overlap_sched_groups()

Ravi Bangoria (1):
      powerpc/sysrq: Fix oops whem ppmu is not registered

Ricard Wanderlof (1):
      ASoC: adau17x1: Workaround for noise bug in ADC

Richard Schütz (1):
      can: c_can: don&#39;t indicate triple sampling support for D_CAN

Ronnie Sahlberg (1):
      cifs: check rsp for NULL before dereferencing in SMB2_open

Sabrina Dubroca (1):
      l2tp: fix race condition in l2tp_tunnel_delete

Sekhar Nori (1):
      ARM: dts: da850-evm: add serial and ethernet aliases

Shrirang Bagul (1):
      USB: serial: qcserial: add Dell DW5818, DW5819

Shu Wang (2):
      cifs: release cifs root_cred after exit_cifs
      cifs: release auth_key.response for reconnect.

Stefan Mätje (1):
      can: esd_usb2: Fix can_dlc value for received RTR, frames

Stefan Popa (1):
      staging: iio: ad7192: Fix - use the dedicated reset function avoiding dma from stack.

Stefano Brivio (1):
      scsi: lpfc: Don&#39;t return internal MBXERR_ERROR code from probe function

Steffen Maier (1):
      scsi: zfcp: fix erp_action use-before-initialize in REC action trace

Steve French (3):
      SMB: Validate negotiate (to protect against downgrade) even if signing off
      SMB3: Don&#39;t ignore O_SYNC/O_DSYNC and O_DIRECT flags
      SMB3: Validate negotiate request must always be signed

Tahsin Erdogan (1):
      tracing: Fix trace_pipe behavior for instance traces

Takashi Iwai (10):
      ALSA: usx2y: Suppress kernel warning at page allocation failures
      ALSA: seq: Fix copy_from_user() call inside lock
      ALSA: caiaq: Fix stray URB at probe error path
      ALSA: hda: Remove superfluous &#39;-&#39; added by printk conversion
      ALSA: timer: Add missing mutex lock for compat ioctls
      ALSA: seq: Fix nested rwsem annotation for lockdep splat
      ALSA: timer: Protect the whole snd_timer_close() with open race
      ALSA: timer: Limit max instances per timer
      ALSA: seq: Avoid invalid lockdep class warning
      ALSA: seq: Fix OSS sysex delivery in OSS emulation

Tejun Heo (1):
      workqueue: replace pool-&gt;manager_arb mutex with a flag

Tyrel Datwyler (1):
      powerpc/pseries: Fix parent_dn reference leak in add_dt_node()

Wanpeng Li (1):
      KVM: Fix stack-out-of-bounds read in write_mmio

Will Deacon (1):
      arm64: fault: Route pte translation faults via do_translation_fault

Willem de Bruijn (1):
      packet: only test po-&gt;has_vnet_hdr once in packet_snd

Wolfgang Grandegger (1):
      can: gs_usb: fix busy loop if no more TX context is available

Xin Long (4):
      ip6_gre: skb_push ipv6hdr before packing the header in ip6gre_header
      sctp: add the missing sock_owned_by_user check in sctp_icmp_redirect
      ip6_gre: only increase err_count for some certain type icmpv6 in ip6gre_err
      sctp: fix a type cast warnings that causes a_rwnd gets the wrong value

YASUAKI ISHIMATSU (2):
      mm/memory_hotplug: change pfn_to_section_nr/section_nr_to_pfn macro to inline function
      mm/memory_hotplug: define find_{smallest|biggest}_section_pfn as unsigned long

Yazen Ghannam (1):
      x86/amd_nb: Add Fam17h Data Fabric as &quot;Northbridge&quot;

Ye Yin (1):
      netfilter/ipvs: clear ipvs_property flag when SKB net namespace changed

Yoshihiro Shimoda (2):
      usb: renesas_usbhs: fix the BCLR setting condition for non-DCP pipe
      usb: renesas_usbhs: fix usbhsf_fifo_clear() for RX direction

satoru takeuchi (1):
      btrfs: prevent to set invalid default subvolid
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index fc9df28cecf1..5cf074eb43ed 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 51</span>
<span class="p_add">+SUBLEVEL = 52</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_header">diff --git a/arch/alpha/kernel/ptrace.c b/arch/alpha/kernel/ptrace.c</span>
<span class="p_header">index 86d835157b54..292e6cae1d10 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/ptrace.c</span>
<span class="p_chunk">@@ -281,7 +281,7 @@</span> <span class="p_context"> long arch_ptrace(struct task_struct *child, long request,</span>
 	/* When I and D space are separate, these will need to be fixed.  */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
 	case PTRACE_PEEKDATA:
<span class="p_del">-		copied = access_process_vm(child, addr, &amp;tmp, sizeof(tmp), 0);</span>
<span class="p_add">+		copied = ptrace_access_vm(child, addr, &amp;tmp, sizeof(tmp), 0);</span>
 		ret = -EIO;
 		if (copied != sizeof(tmp))
 			break;
<span class="p_header">diff --git a/arch/arm/boot/dts/da850-evm.dts b/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_header">index 21342ab78ff5..c2f242d122f0 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_chunk">@@ -14,6 +14,13 @@</span> <span class="p_context"></span>
 	compatible = &quot;ti,da850-evm&quot;, &quot;ti,da850&quot;;
 	model = &quot;DA850/AM1808/OMAP-L138 EVM&quot;;
 
<span class="p_add">+	aliases {</span>
<span class="p_add">+		serial0 = &amp;serial0;</span>
<span class="p_add">+		serial1 = &amp;serial1;</span>
<span class="p_add">+		serial2 = &amp;serial2;</span>
<span class="p_add">+		ethernet0 = &amp;eth0;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
 	soc {
 		pmx_core: pinmux@1c14120 {
 			status = &quot;okay&quot;;
<span class="p_header">diff --git a/arch/arm/include/asm/Kbuild b/arch/arm/include/asm/Kbuild</span>
<span class="p_header">index f5a357601983..4d9849d22357 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/Kbuild</span>
<span class="p_header">+++ b/arch/arm/include/asm/Kbuild</span>
<span class="p_chunk">@@ -36,4 +36,3 @@</span> <span class="p_context"> generic-y += termbits.h</span>
 generic-y += termios.h
 generic-y += timex.h
 generic-y += trace_clock.h
<span class="p_del">-generic-y += unaligned.h</span>
<span class="p_header">diff --git a/arch/arm/include/asm/unaligned.h b/arch/arm/include/asm/unaligned.h</span>
new file mode 100644
<span class="p_header">index 000000000000..ab905ffcf193</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/include/asm/unaligned.h</span>
<span class="p_chunk">@@ -0,0 +1,27 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __ASM_ARM_UNALIGNED_H</span>
<span class="p_add">+#define __ASM_ARM_UNALIGNED_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We generally want to set CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS on ARMv6+,</span>
<span class="p_add">+ * but we don&#39;t want to use linux/unaligned/access_ok.h since that can lead</span>
<span class="p_add">+ * to traps on unaligned stm/ldm or strd/ldrd.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;asm/byteorder.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#if defined(__LITTLE_ENDIAN)</span>
<span class="p_add">+# include &lt;linux/unaligned/le_struct.h&gt;</span>
<span class="p_add">+# include &lt;linux/unaligned/be_byteshift.h&gt;</span>
<span class="p_add">+# include &lt;linux/unaligned/generic.h&gt;</span>
<span class="p_add">+# define get_unaligned	__get_unaligned_le</span>
<span class="p_add">+# define put_unaligned	__put_unaligned_le</span>
<span class="p_add">+#elif defined(__BIG_ENDIAN)</span>
<span class="p_add">+# include &lt;linux/unaligned/be_struct.h&gt;</span>
<span class="p_add">+# include &lt;linux/unaligned/le_byteshift.h&gt;</span>
<span class="p_add">+# include &lt;linux/unaligned/generic.h&gt;</span>
<span class="p_add">+# define get_unaligned	__get_unaligned_be</span>
<span class="p_add">+# define put_unaligned	__put_unaligned_be</span>
<span class="p_add">+#else</span>
<span class="p_add">+# error need to define endianess</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASM_ARM_UNALIGNED_H */</span>
<span class="p_header">diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c</span>
<span class="p_header">index 8dffc57a9f71..cba3cb0b1a47 100644</span>
<span class="p_header">--- a/arch/arm/kernel/traps.c</span>
<span class="p_header">+++ b/arch/arm/kernel/traps.c</span>
<span class="p_chunk">@@ -129,30 +129,26 @@</span> <span class="p_context"> static void dump_mem(const char *lvl, const char *str, unsigned long bottom,</span>
 	set_fs(fs);
 }
 
<span class="p_del">-static void dump_instr(const char *lvl, struct pt_regs *regs)</span>
<span class="p_add">+static void __dump_instr(const char *lvl, struct pt_regs *regs)</span>
 {
 	unsigned long addr = instruction_pointer(regs);
 	const int thumb = thumb_mode(regs);
 	const int width = thumb ? 4 : 8;
<span class="p_del">-	mm_segment_t fs;</span>
 	char str[sizeof(&quot;00000000 &quot;) * 5 + 2 + 1], *p = str;
 	int i;
 
 	/*
<span class="p_del">-	 * We need to switch to kernel mode so that we can use __get_user</span>
<span class="p_del">-	 * to safely read from kernel space.  Note that we now dump the</span>
<span class="p_del">-	 * code first, just in case the backtrace kills us.</span>
<span class="p_add">+	 * Note that we now dump the code first, just in case the backtrace</span>
<span class="p_add">+	 * kills us.</span>
 	 */
<span class="p_del">-	fs = get_fs();</span>
<span class="p_del">-	set_fs(KERNEL_DS);</span>
 
 	for (i = -4; i &lt; 1 + !!thumb; i++) {
 		unsigned int val, bad;
 
 		if (thumb)
<span class="p_del">-			bad = __get_user(val, &amp;((u16 *)addr)[i]);</span>
<span class="p_add">+			bad = get_user(val, &amp;((u16 *)addr)[i]);</span>
 		else
<span class="p_del">-			bad = __get_user(val, &amp;((u32 *)addr)[i]);</span>
<span class="p_add">+			bad = get_user(val, &amp;((u32 *)addr)[i]);</span>
 
 		if (!bad)
 			p += sprintf(p, i == 0 ? &quot;(%0*x) &quot; : &quot;%0*x &quot;,
<span class="p_chunk">@@ -163,8 +159,20 @@</span> <span class="p_context"> static void dump_instr(const char *lvl, struct pt_regs *regs)</span>
 		}
 	}
 	printk(&quot;%sCode: %s\n&quot;, lvl, str);
<span class="p_add">+}</span>
 
<span class="p_del">-	set_fs(fs);</span>
<span class="p_add">+static void dump_instr(const char *lvl, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mm_segment_t fs;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!user_mode(regs)) {</span>
<span class="p_add">+		fs = get_fs();</span>
<span class="p_add">+		set_fs(KERNEL_DS);</span>
<span class="p_add">+		__dump_instr(lvl, regs);</span>
<span class="p_add">+		set_fs(fs);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		__dump_instr(lvl, regs);</span>
<span class="p_add">+	}</span>
 }
 
 #ifdef CONFIG_ARM_UNWIND
<span class="p_header">diff --git a/arch/arm/kvm/emulate.c b/arch/arm/kvm/emulate.c</span>
<span class="p_header">index d6c005283678..ef0a11f8a9d1 100644</span>
<span class="p_header">--- a/arch/arm/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/arm/kvm/emulate.c</span>
<span class="p_chunk">@@ -295,7 +295,7 @@</span> <span class="p_context"> void kvm_inject_undefined(struct kvm_vcpu *vcpu)</span>
 	u32 return_offset = (is_thumb) ? 2 : 4;
 
 	new_spsr_value = cpsr;
<span class="p_del">-	new_lr_value = *vcpu_pc(vcpu) - return_offset;</span>
<span class="p_add">+	new_lr_value = *vcpu_pc(vcpu) + return_offset;</span>
 
 	*vcpu_cpsr(vcpu) = (cpsr &amp; ~MODE_MASK) | UND_MODE;
 	*vcpu_cpsr(vcpu) |= PSR_I_BIT;
<span class="p_chunk">@@ -324,9 +324,8 @@</span> <span class="p_context"> static void inject_abt(struct kvm_vcpu *vcpu, bool is_pabt, unsigned long addr)</span>
 	unsigned long new_spsr_value;
 	unsigned long cpsr = *vcpu_cpsr(vcpu);
 	u32 sctlr = vcpu-&gt;arch.cp15[c1_SCTLR];
<span class="p_del">-	bool is_thumb = (cpsr &amp; PSR_T_BIT);</span>
 	u32 vect_offset;
<span class="p_del">-	u32 return_offset = (is_thumb) ? 4 : 0;</span>
<span class="p_add">+	u32 return_offset = (is_pabt) ? 4 : 8;</span>
 	bool is_lpae;
 
 	new_spsr_value = cpsr;
<span class="p_header">diff --git a/arch/arm/kvm/mmio.c b/arch/arm/kvm/mmio.c</span>
<span class="p_header">index 4cb5a93182e9..c47f108c2b8a 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmio.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmio.c</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> int kvm_handle_mmio_return(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 		}
 
 		trace_kvm_mmio(KVM_TRACE_MMIO_READ, len, run-&gt;mmio.phys_addr,
<span class="p_del">-			       data);</span>
<span class="p_add">+			       &amp;data);</span>
 		data = vcpu_data_host_to_guest(vcpu, data, len);
 		*vcpu_reg(vcpu, vcpu-&gt;arch.mmio_decode.rt) = data;
 	}
<span class="p_chunk">@@ -192,7 +192,7 @@</span> <span class="p_context"> int io_mem_abort(struct kvm_vcpu *vcpu, struct kvm_run *run,</span>
 	trace_kvm_mmio((mmio.is_write) ? KVM_TRACE_MMIO_WRITE :
 					 KVM_TRACE_MMIO_READ_UNSATISFIED,
 			mmio.len, fault_ipa,
<span class="p_del">-			(mmio.is_write) ? data : 0);</span>
<span class="p_add">+			(mmio.is_write) ? &amp;data : NULL);</span>
 
 	if (mmio.is_write)
 		mmio_write_buf(mmio.data, mmio.len, data);
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index cb83c1aabae8..d15ed089bb83 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -269,6 +269,7 @@</span> <span class="p_context"> ENDPROC(stext)</span>
  * booted in EL1 or EL2 respectively.
  */
 ENTRY(el2_setup)
<span class="p_add">+	msr	SPsel, #1			// We want to use SP_EL{1,2}</span>
 	mrs	x0, CurrentEL
 	cmp	x0, #CurrentEL_EL2
 	b.ne	1f
<span class="p_header">diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c</span>
<span class="p_header">index c1c2ad6a1c94..ec1e323060e0 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/traps.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/traps.c</span>
<span class="p_chunk">@@ -59,8 +59,7 @@</span> <span class="p_context"> static void dump_mem(const char *lvl, const char *str, unsigned long bottom,</span>
 
 	/*
 	 * We need to switch to kernel mode so that we can use __get_user
<span class="p_del">-	 * to safely read from kernel space.  Note that we now dump the</span>
<span class="p_del">-	 * code first, just in case the backtrace kills us.</span>
<span class="p_add">+	 * to safely read from kernel space.</span>
 	 */
 	fs = get_fs();
 	set_fs(KERNEL_DS);
<span class="p_chunk">@@ -97,25 +96,16 @@</span> <span class="p_context"> static void dump_backtrace_entry(unsigned long where, unsigned long stack)</span>
 			 stack + sizeof(struct pt_regs));
 }
 
<span class="p_del">-static void dump_instr(const char *lvl, struct pt_regs *regs)</span>
<span class="p_add">+static void __dump_instr(const char *lvl, struct pt_regs *regs)</span>
 {
 	unsigned long addr = instruction_pointer(regs);
<span class="p_del">-	mm_segment_t fs;</span>
 	char str[sizeof(&quot;00000000 &quot;) * 5 + 2 + 1], *p = str;
 	int i;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to switch to kernel mode so that we can use __get_user</span>
<span class="p_del">-	 * to safely read from kernel space.  Note that we now dump the</span>
<span class="p_del">-	 * code first, just in case the backtrace kills us.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	fs = get_fs();</span>
<span class="p_del">-	set_fs(KERNEL_DS);</span>
<span class="p_del">-</span>
 	for (i = -4; i &lt; 1; i++) {
 		unsigned int val, bad;
 
<span class="p_del">-		bad = __get_user(val, &amp;((u32 *)addr)[i]);</span>
<span class="p_add">+		bad = get_user(val, &amp;((u32 *)addr)[i]);</span>
 
 		if (!bad)
 			p += sprintf(p, i == 0 ? &quot;(%08x) &quot; : &quot;%08x &quot;, val);
<span class="p_chunk">@@ -125,8 +115,18 @@</span> <span class="p_context"> static void dump_instr(const char *lvl, struct pt_regs *regs)</span>
 		}
 	}
 	printk(&quot;%sCode: %s\n&quot;, lvl, str);
<span class="p_add">+}</span>
 
<span class="p_del">-	set_fs(fs);</span>
<span class="p_add">+static void dump_instr(const char *lvl, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!user_mode(regs)) {</span>
<span class="p_add">+		mm_segment_t fs = get_fs();</span>
<span class="p_add">+		set_fs(KERNEL_DS);</span>
<span class="p_add">+		__dump_instr(lvl, regs);</span>
<span class="p_add">+		set_fs(fs);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		__dump_instr(lvl, regs);</span>
<span class="p_add">+	}</span>
 }
 
 static void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)
<span class="p_header">diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">index f527a37ac979..595d311affe8 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_chunk">@@ -29,12 +29,26 @@</span> <span class="p_context"></span>
 				 PSR_I_BIT | PSR_D_BIT)
 #define EL1_EXCEPT_SYNC_OFFSET	0x200
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Table taken from ARMv8 ARM DDI0487B-B, table G1-10.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static const u8 return_offsets[8][2] = {</span>
<span class="p_add">+	[0] = { 0, 0 },		/* Reset, unused */</span>
<span class="p_add">+	[1] = { 4, 2 },		/* Undefined */</span>
<span class="p_add">+	[2] = { 0, 0 },		/* SVC, unused */</span>
<span class="p_add">+	[3] = { 4, 4 },		/* Prefetch abort */</span>
<span class="p_add">+	[4] = { 8, 8 },		/* Data abort */</span>
<span class="p_add">+	[5] = { 0, 0 },		/* HVC, unused */</span>
<span class="p_add">+	[6] = { 4, 4 },		/* IRQ, unused */</span>
<span class="p_add">+	[7] = { 4, 4 },		/* FIQ, unused */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void prepare_fault32(struct kvm_vcpu *vcpu, u32 mode, u32 vect_offset)
 {
 	unsigned long cpsr;
 	unsigned long new_spsr_value = *vcpu_cpsr(vcpu);
 	bool is_thumb = (new_spsr_value &amp; COMPAT_PSR_T_BIT);
<span class="p_del">-	u32 return_offset = (is_thumb) ? 4 : 0;</span>
<span class="p_add">+	u32 return_offset = return_offsets[vect_offset &gt;&gt; 2][is_thumb];</span>
 	u32 sctlr = vcpu_cp15(vcpu, c1_SCTLR);
 
 	cpsr = mode | COMPAT_PSR_I_BIT;
<span class="p_header">diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c</span>
<span class="p_header">index 8fd2315bdf4d..ca1b882bc9e1 100644</span>
<span class="p_header">--- a/arch/arm64/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm64/mm/fault.c</span>
<span class="p_chunk">@@ -386,7 +386,7 @@</span> <span class="p_context"> static struct fault_info {</span>
 	{ do_translation_fault,	SIGSEGV, SEGV_MAPERR,	&quot;input address range fault&quot;	},
 	{ do_translation_fault,	SIGSEGV, SEGV_MAPERR,	&quot;level 1 translation fault&quot;	},
 	{ do_translation_fault,	SIGSEGV, SEGV_MAPERR,	&quot;level 2 translation fault&quot;	},
<span class="p_del">-	{ do_page_fault,	SIGSEGV, SEGV_MAPERR,	&quot;level 3 translation fault&quot;	},</span>
<span class="p_add">+	{ do_translation_fault,	SIGSEGV, SEGV_MAPERR,	&quot;level 3 translation fault&quot;	},</span>
 	{ do_bad,		SIGBUS,  0,		&quot;reserved access flag fault&quot;	},
 	{ do_page_fault,	SIGSEGV, SEGV_ACCERR,	&quot;level 1 access flag fault&quot;	},
 	{ do_page_fault,	SIGSEGV, SEGV_ACCERR,	&quot;level 2 access flag fault&quot;	},
<span class="p_header">diff --git a/arch/blackfin/kernel/ptrace.c b/arch/blackfin/kernel/ptrace.c</span>
<span class="p_header">index 8b8fe671b1a6..7d8ece6a93fb 100644</span>
<span class="p_header">--- a/arch/blackfin/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/blackfin/kernel/ptrace.c</span>
<span class="p_chunk">@@ -270,7 +270,7 @@</span> <span class="p_context"> long arch_ptrace(struct task_struct *child, long request,</span>
 			switch (bfin_mem_access_type(addr, to_copy)) {
 			case BFIN_MEM_ACCESS_CORE:
 			case BFIN_MEM_ACCESS_CORE_ONLY:
<span class="p_del">-				copied = access_process_vm(child, addr, &amp;tmp,</span>
<span class="p_add">+				copied = ptrace_access_vm(child, addr, &amp;tmp,</span>
 				                           to_copy, 0);
 				if (copied)
 					break;
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"> long arch_ptrace(struct task_struct *child, long request,</span>
 			switch (bfin_mem_access_type(addr, to_copy)) {
 			case BFIN_MEM_ACCESS_CORE:
 			case BFIN_MEM_ACCESS_CORE_ONLY:
<span class="p_del">-				copied = access_process_vm(child, addr, &amp;data,</span>
<span class="p_add">+				copied = ptrace_access_vm(child, addr, &amp;data,</span>
 				                           to_copy, 1);
 				break;
 			case BFIN_MEM_ACCESS_DMA:
<span class="p_header">diff --git a/arch/cris/arch-v32/kernel/ptrace.c b/arch/cris/arch-v32/kernel/ptrace.c</span>
<span class="p_header">index f085229cf870..04251c6cb5f9 100644</span>
<span class="p_header">--- a/arch/cris/arch-v32/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/cris/arch-v32/kernel/ptrace.c</span>
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> long arch_ptrace(struct task_struct *child, long request,</span>
 				/* The trampoline page is globally mapped, no page table to traverse.*/
 				tmp = *(unsigned long*)addr;
 			} else {
<span class="p_del">-				copied = access_process_vm(child, addr, &amp;tmp, sizeof(tmp), 0);</span>
<span class="p_add">+				copied = ptrace_access_vm(child, addr, &amp;tmp, sizeof(tmp), 0);</span>
 
 				if (copied != sizeof(tmp))
 					break;
<span class="p_header">diff --git a/arch/ia64/kernel/ptrace.c b/arch/ia64/kernel/ptrace.c</span>
<span class="p_header">index b7a5fffe0924..c218249c4792 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/ptrace.c</span>
<span class="p_chunk">@@ -1156,7 +1156,7 @@</span> <span class="p_context"> arch_ptrace (struct task_struct *child, long request,</span>
 	case PTRACE_PEEKTEXT:
 	case PTRACE_PEEKDATA:
 		/* read word at location addr */
<span class="p_del">-		if (access_process_vm(child, addr, &amp;data, sizeof(data), 0)</span>
<span class="p_add">+		if (ptrace_access_vm(child, addr, &amp;data, sizeof(data), 0)</span>
 		    != sizeof(data))
 			return -EIO;
 		/* ensure return value is not mistaken for error code */
<span class="p_header">diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c</span>
<span class="p_header">index 7e2356fd5fd6..e4f47d3e55bb 100644</span>
<span class="p_header">--- a/arch/mips/ar7/platform.c</span>
<span class="p_header">+++ b/arch/mips/ar7/platform.c</span>
<span class="p_chunk">@@ -581,6 +581,7 @@</span> <span class="p_context"> static int __init ar7_register_uarts(void)</span>
 	uart_port.type		= PORT_AR7;
 	uart_port.uartclk	= clk_get_rate(bus_clk) / 2;
 	uart_port.iotype	= UPIO_MEM32;
<span class="p_add">+	uart_port.flags		= UPF_FIXED_TYPE;</span>
 	uart_port.regshift	= 2;
 
 	uart_port.line		= 0;
<span class="p_header">diff --git a/arch/mips/include/asm/mips-cm.h b/arch/mips/include/asm/mips-cm.h</span>
<span class="p_header">index 6a9d2dd005ca..79c882be9d17 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mips-cm.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mips-cm.h</span>
<span class="p_chunk">@@ -173,8 +173,8 @@</span> <span class="p_context"> BUILD_CM_Cx_R_(tcid_8_priority,	0x80)</span>
 #define CM_GCR_BASE_GCRBASE_MSK			(_ULCAST_(0x1ffff) &lt;&lt; 15)
 #define CM_GCR_BASE_CMDEFTGT_SHF		0
 #define CM_GCR_BASE_CMDEFTGT_MSK		(_ULCAST_(0x3) &lt;&lt; 0)
<span class="p_del">-#define  CM_GCR_BASE_CMDEFTGT_DISABLED		0</span>
<span class="p_del">-#define  CM_GCR_BASE_CMDEFTGT_MEM		1</span>
<span class="p_add">+#define  CM_GCR_BASE_CMDEFTGT_MEM		0</span>
<span class="p_add">+#define  CM_GCR_BASE_CMDEFTGT_RESERVED		1</span>
 #define  CM_GCR_BASE_CMDEFTGT_IOCU0		2
 #define  CM_GCR_BASE_CMDEFTGT_IOCU1		3
 
<span class="p_header">diff --git a/arch/mips/kernel/ptrace32.c b/arch/mips/kernel/ptrace32.c</span>
<span class="p_header">index a83fb730b387..fdd26c104c6c 100644</span>
<span class="p_header">--- a/arch/mips/kernel/ptrace32.c</span>
<span class="p_header">+++ b/arch/mips/kernel/ptrace32.c</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> long compat_arch_ptrace(struct task_struct *child, compat_long_t request,</span>
 		if (get_user(addrOthers, (u32 __user * __user *) (unsigned long) addr) != 0)
 			break;
 
<span class="p_del">-		copied = access_process_vm(child, (u64)addrOthers, &amp;tmp,</span>
<span class="p_add">+		copied = ptrace_access_vm(child, (u64)addrOthers, &amp;tmp,</span>
 				sizeof(tmp), 0);
 		if (copied != sizeof(tmp))
 			break;
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"> long compat_arch_ptrace(struct task_struct *child, compat_long_t request,</span>
 		if (get_user(addrOthers, (u32 __user * __user *) (unsigned long) addr) != 0)
 			break;
 		ret = 0;
<span class="p_del">-		if (access_process_vm(child, (u64)addrOthers, &amp;data,</span>
<span class="p_add">+		if (ptrace_access_vm(child, (u64)addrOthers, &amp;data,</span>
 					sizeof(data), 1) == sizeof(data))
 			break;
 		ret = -EIO;
<span class="p_header">diff --git a/arch/mips/mm/uasm-micromips.c b/arch/mips/mm/uasm-micromips.c</span>
<span class="p_header">index 8399ddf03a02..cab124e0572d 100644</span>
<span class="p_header">--- a/arch/mips/mm/uasm-micromips.c</span>
<span class="p_header">+++ b/arch/mips/mm/uasm-micromips.c</span>
<span class="p_chunk">@@ -83,7 +83,7 @@</span> <span class="p_context"> static struct insn insn_table_MM[] = {</span>
 	{ insn_jr, M(mm_pool32a_op, 0, 0, 0, mm_jalr_op, mm_pool32axf_op), RS },
 	{ insn_lb, M(mm_lb32_op, 0, 0, 0, 0, 0), RT | RS | SIMM },
 	{ insn_ld, 0, 0 },
<span class="p_del">-	{ insn_lh, M(mm_lh32_op, 0, 0, 0, 0, 0), RS | RS | SIMM },</span>
<span class="p_add">+	{ insn_lh, M(mm_lh32_op, 0, 0, 0, 0, 0), RT | RS | SIMM },</span>
 	{ insn_ll, M(mm_pool32c_op, 0, 0, (mm_ll_func &lt;&lt; 1), 0, 0), RS | RT | SIMM },
 	{ insn_lld, 0, 0 },
 	{ insn_lui, M(mm_pool32i_op, mm_lui_op, 0, 0, 0, 0), RS | SIMM },
<span class="p_header">diff --git a/arch/parisc/kernel/syscall.S b/arch/parisc/kernel/syscall.S</span>
<span class="p_header">index f716e9e65a49..df6ff75c03ce 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/syscall.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/syscall.S</span>
<span class="p_chunk">@@ -742,7 +742,7 @@</span> <span class="p_context"> ENTRY(linux_gateway_page)</span>
 10:	ldd	0(%sr3,%r25), %r25
 11:	ldd	0(%sr3,%r24), %r24
 #else
<span class="p_del">-	/* Load new value into r22/r23 - high/low */</span>
<span class="p_add">+	/* Load old value into r22/r23 - high/low */</span>
 10:	ldw	0(%sr3,%r25), %r22
 11:	ldw	4(%sr3,%r25), %r23
 	/* Load new value into fr4 for atomic store later */
<span class="p_chunk">@@ -834,11 +834,11 @@</span> <span class="p_context"> ENTRY(linux_gateway_page)</span>
 	copy	%r0, %r28
 #else
 	/* Compare first word */
<span class="p_del">-19:	ldw,ma	0(%sr3,%r26), %r29</span>
<span class="p_add">+19:	ldw	0(%sr3,%r26), %r29</span>
 	sub,=	%r29, %r22, %r0
 	b,n	cas2_end
 	/* Compare second word */
<span class="p_del">-20:	ldw,ma	4(%sr3,%r26), %r29</span>
<span class="p_add">+20:	ldw	4(%sr3,%r26), %r29</span>
 	sub,=	%r29, %r23, %r0
 	b,n	cas2_end
 	/* Perform the store */
<span class="p_header">diff --git a/arch/powerpc/kernel/ptrace32.c b/arch/powerpc/kernel/ptrace32.c</span>
<span class="p_header">index f52b7db327c8..2e4f01dc9d64 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/ptrace32.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/ptrace32.c</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> long compat_arch_ptrace(struct task_struct *child, compat_long_t request,</span>
 		if (get_user(addrOthers, (u32 __user * __user *)addr) != 0)
 			break;
 
<span class="p_del">-		copied = access_process_vm(child, (u64)addrOthers, &amp;tmp,</span>
<span class="p_add">+		copied = ptrace_access_vm(child, (u64)addrOthers, &amp;tmp,</span>
 				sizeof(tmp), 0);
 		if (copied != sizeof(tmp))
 			break;
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"> long compat_arch_ptrace(struct task_struct *child, compat_long_t request,</span>
 		if (get_user(addrOthers, (u32 __user * __user *)addr) != 0)
 			break;
 		ret = 0;
<span class="p_del">-		if (access_process_vm(child, (u64)addrOthers, &amp;tmp,</span>
<span class="p_add">+		if (ptrace_access_vm(child, (u64)addrOthers, &amp;tmp,</span>
 					sizeof(tmp), 1) == sizeof(tmp))
 			break;
 		ret = -EIO;
<span class="p_header">diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">index 97579de6853b..6b989c2d6e31 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_chunk">@@ -755,6 +755,11 @@</span> <span class="p_context"> void perf_event_print_debug(void)</span>
 	u32 pmcs[MAX_HWEVENTS];
 	int i;
 
<span class="p_add">+	if (!ppmu) {</span>
<span class="p_add">+		pr_info(&quot;Performance monitor hardware not registered.\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!ppmu-&gt;n_counter)
 		return;
 
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/mobility.c b/arch/powerpc/platforms/pseries/mobility.c</span>
<span class="p_header">index c70762e0daf1..eb4b07f3a505 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/mobility.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/mobility.c</span>
<span class="p_chunk">@@ -224,8 +224,10 @@</span> <span class="p_context"> static int add_dt_node(__be32 parent_phandle, __be32 drc_index)</span>
 		return -ENOENT;
 
 	dn = dlpar_configure_connector(drc_index, parent_dn);
<span class="p_del">-	if (!dn)</span>
<span class="p_add">+	if (!dn) {</span>
<span class="p_add">+		of_node_put(parent_dn);</span>
 		return -ENOENT;
<span class="p_add">+	}</span>
 
 	rc = dlpar_attach_node(dn);
 	if (rc)
<span class="p_header">diff --git a/arch/s390/mm/gup.c b/arch/s390/mm/gup.c</span>
<span class="p_header">index 639fce464008..21e925e9845a 100644</span>
<span class="p_header">--- a/arch/s390/mm/gup.c</span>
<span class="p_header">+++ b/arch/s390/mm/gup.c</span>
<span class="p_chunk">@@ -51,13 +51,12 @@</span> <span class="p_context"> static inline int gup_pte_range(pmd_t *pmdp, pmd_t pmd, unsigned long addr,</span>
 static inline int gup_huge_pmd(pmd_t *pmdp, pmd_t pmd, unsigned long addr,
 		unsigned long end, int write, struct page **pages, int *nr)
 {
<span class="p_del">-	unsigned long mask, result;</span>
 	struct page *head, *page, *tail;
<span class="p_add">+	unsigned long mask;</span>
 	int refs;
 
<span class="p_del">-	result = write ? 0 : _SEGMENT_ENTRY_PROTECT;</span>
<span class="p_del">-	mask = result | _SEGMENT_ENTRY_INVALID;</span>
<span class="p_del">-	if ((pmd_val(pmd) &amp; mask) != result)</span>
<span class="p_add">+	mask = (write ? _SEGMENT_ENTRY_PROTECT : 0) | _SEGMENT_ENTRY_INVALID;</span>
<span class="p_add">+	if ((pmd_val(pmd) &amp; mask) != 0)</span>
 		return 0;
 	VM_BUG_ON(!pfn_valid(pmd_val(pmd) &gt;&gt; PAGE_SHIFT));
 
<span class="p_header">diff --git a/arch/sh/include/cpu-sh2a/cpu/sh7264.h b/arch/sh/include/cpu-sh2a/cpu/sh7264.h</span>
<span class="p_header">index 4d1ef6d74bd6..2ae0e938b657 100644</span>
<span class="p_header">--- a/arch/sh/include/cpu-sh2a/cpu/sh7264.h</span>
<span class="p_header">+++ b/arch/sh/include/cpu-sh2a/cpu/sh7264.h</span>
<span class="p_chunk">@@ -43,9 +43,7 @@</span> <span class="p_context"> enum {</span>
 	GPIO_PG7, GPIO_PG6, GPIO_PG5, GPIO_PG4,
 	GPIO_PG3, GPIO_PG2, GPIO_PG1, GPIO_PG0,
 
<span class="p_del">-	/* Port H */</span>
<span class="p_del">-	GPIO_PH7, GPIO_PH6, GPIO_PH5, GPIO_PH4,</span>
<span class="p_del">-	GPIO_PH3, GPIO_PH2, GPIO_PH1, GPIO_PH0,</span>
<span class="p_add">+	/* Port H - Port H does not have a Data Register */</span>
 
 	/* Port I - not on device */
 
<span class="p_header">diff --git a/arch/sh/include/cpu-sh2a/cpu/sh7269.h b/arch/sh/include/cpu-sh2a/cpu/sh7269.h</span>
<span class="p_header">index 2a0ca8780f0d..13c495a9fc00 100644</span>
<span class="p_header">--- a/arch/sh/include/cpu-sh2a/cpu/sh7269.h</span>
<span class="p_header">+++ b/arch/sh/include/cpu-sh2a/cpu/sh7269.h</span>
<span class="p_chunk">@@ -45,9 +45,7 @@</span> <span class="p_context"> enum {</span>
 	GPIO_PG7, GPIO_PG6, GPIO_PG5, GPIO_PG4,
 	GPIO_PG3, GPIO_PG2, GPIO_PG1, GPIO_PG0,
 
<span class="p_del">-	/* Port H */</span>
<span class="p_del">-	GPIO_PH7, GPIO_PH6, GPIO_PH5, GPIO_PH4,</span>
<span class="p_del">-	GPIO_PH3, GPIO_PH2, GPIO_PH1, GPIO_PH0,</span>
<span class="p_add">+	/* Port H - Port H does not have a Data Register */</span>
 
 	/* Port I - not on device */
 
<span class="p_header">diff --git a/arch/sh/include/cpu-sh4/cpu/sh7722.h b/arch/sh/include/cpu-sh4/cpu/sh7722.h</span>
<span class="p_header">index 3bb74e534d0f..78961ab78a5a 100644</span>
<span class="p_header">--- a/arch/sh/include/cpu-sh4/cpu/sh7722.h</span>
<span class="p_header">+++ b/arch/sh/include/cpu-sh4/cpu/sh7722.h</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> enum {</span>
 	GPIO_PTN3, GPIO_PTN2, GPIO_PTN1, GPIO_PTN0,
 
 	/* PTQ */
<span class="p_del">-	GPIO_PTQ7, GPIO_PTQ6, GPIO_PTQ5, GPIO_PTQ4,</span>
<span class="p_add">+	GPIO_PTQ6, GPIO_PTQ5, GPIO_PTQ4,</span>
 	GPIO_PTQ3, GPIO_PTQ2, GPIO_PTQ1, GPIO_PTQ0,
 
 	/* PTR */
<span class="p_header">diff --git a/arch/sh/include/cpu-sh4/cpu/sh7757.h b/arch/sh/include/cpu-sh4/cpu/sh7757.h</span>
<span class="p_header">index 5340f3bc1863..b40fb541e72a 100644</span>
<span class="p_header">--- a/arch/sh/include/cpu-sh4/cpu/sh7757.h</span>
<span class="p_header">+++ b/arch/sh/include/cpu-sh4/cpu/sh7757.h</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* PTJ */
 	GPIO_PTJ0, GPIO_PTJ1, GPIO_PTJ2, GPIO_PTJ3,
<span class="p_del">-	GPIO_PTJ4, GPIO_PTJ5, GPIO_PTJ6, GPIO_PTJ7_RESV,</span>
<span class="p_add">+	GPIO_PTJ4, GPIO_PTJ5, GPIO_PTJ6,</span>
 
 	/* PTK */
 	GPIO_PTK0, GPIO_PTK1, GPIO_PTK2, GPIO_PTK3,
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* PTL */
 	GPIO_PTL0, GPIO_PTL1, GPIO_PTL2, GPIO_PTL3,
<span class="p_del">-	GPIO_PTL4, GPIO_PTL5, GPIO_PTL6, GPIO_PTL7_RESV,</span>
<span class="p_add">+	GPIO_PTL4, GPIO_PTL5, GPIO_PTL6,</span>
 
 	/* PTM */
 	GPIO_PTM0, GPIO_PTM1, GPIO_PTM2, GPIO_PTM3,
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* PTN */
 	GPIO_PTN0, GPIO_PTN1, GPIO_PTN2, GPIO_PTN3,
<span class="p_del">-	GPIO_PTN4, GPIO_PTN5, GPIO_PTN6, GPIO_PTN7_RESV,</span>
<span class="p_add">+	GPIO_PTN4, GPIO_PTN5, GPIO_PTN6,</span>
 
 	/* PTO */
 	GPIO_PTO0, GPIO_PTO1, GPIO_PTO2, GPIO_PTO3,
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* PTQ */
 	GPIO_PTQ0, GPIO_PTQ1, GPIO_PTQ2, GPIO_PTQ3,
<span class="p_del">-	GPIO_PTQ4, GPIO_PTQ5, GPIO_PTQ6, GPIO_PTQ7_RESV,</span>
<span class="p_add">+	GPIO_PTQ4, GPIO_PTQ5, GPIO_PTQ6,</span>
 
 	/* PTR */
 	GPIO_PTR0, GPIO_PTR1, GPIO_PTR2, GPIO_PTR3,
<span class="p_header">diff --git a/arch/tile/kernel/setup.c b/arch/tile/kernel/setup.c</span>
<span class="p_header">index d8a9df999da3..0ac4de510b42 100644</span>
<span class="p_header">--- a/arch/tile/kernel/setup.c</span>
<span class="p_header">+++ b/arch/tile/kernel/setup.c</span>
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"> static int __init setup_maxnodemem(char *str)</span>
 {
 	char *endp;
 	unsigned long long maxnodemem;
<span class="p_del">-	long node;</span>
<span class="p_add">+	unsigned long node;</span>
 
 	node = str ? simple_strtoul(str, &amp;endp, 0) : INT_MAX;
 	if (node &gt;= MAX_NUMNODES || *endp != &#39;:&#39;)
<span class="p_header">diff --git a/arch/x86/crypto/salsa20_glue.c b/arch/x86/crypto/salsa20_glue.c</span>
<span class="p_header">index 399a29d067d6..cb91a64a99e7 100644</span>
<span class="p_header">--- a/arch/x86/crypto/salsa20_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/salsa20_glue.c</span>
<span class="p_chunk">@@ -59,13 +59,6 @@</span> <span class="p_context"> static int encrypt(struct blkcipher_desc *desc,</span>
 
 	salsa20_ivsetup(ctx, walk.iv);
 
<span class="p_del">-	if (likely(walk.nbytes == nbytes))</span>
<span class="p_del">-	{</span>
<span class="p_del">-		salsa20_encrypt_bytes(ctx, walk.src.virt.addr,</span>
<span class="p_del">-				      walk.dst.virt.addr, nbytes);</span>
<span class="p_del">-		return blkcipher_walk_done(desc, &amp;walk, 0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	while (walk.nbytes &gt;= 64) {
 		salsa20_encrypt_bytes(ctx, walk.src.virt.addr,
 				      walk.dst.virt.addr,
<span class="p_header">diff --git a/arch/x86/include/asm/uaccess.h b/arch/x86/include/asm/uaccess.h</span>
<span class="p_header">index 465504609869..887c0ea365a7 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/compiler.h&gt;
 #include &lt;linux/thread_info.h&gt;
 #include &lt;linux/string.h&gt;
<span class="p_add">+#include &lt;linux/preempt_mask.h&gt;</span>
 #include &lt;asm/asm.h&gt;
 #include &lt;asm/page.h&gt;
 #include &lt;asm/smap.h&gt;
<span class="p_chunk">@@ -66,6 +67,12 @@</span> <span class="p_context"> static inline bool __chk_range_not_ok(unsigned long addr, unsigned long size, un</span>
 	__chk_range_not_ok((unsigned long __force)(addr), size, limit); \
 })
 
<span class="p_add">+#ifdef CONFIG_DEBUG_ATOMIC_SLEEP</span>
<span class="p_add">+# define WARN_ON_IN_IRQ()	WARN_ON_ONCE(!in_task())</span>
<span class="p_add">+#else</span>
<span class="p_add">+# define WARN_ON_IN_IRQ()</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /**
  * access_ok: - Checks if a user space pointer is valid
  * @type: Type of access: %VERIFY_READ or %VERIFY_WRITE.  Note that
<span class="p_chunk">@@ -85,8 +92,11 @@</span> <span class="p_context"> static inline bool __chk_range_not_ok(unsigned long addr, unsigned long size, un</span>
  * checks that the pointer is in the user space range - after calling
  * this function, memory access functions may still return -EFAULT.
  */
<span class="p_del">-#define access_ok(type, addr, size) \</span>
<span class="p_del">-	likely(!__range_not_ok(addr, size, user_addr_max()))</span>
<span class="p_add">+#define access_ok(type, addr, size)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	WARN_ON_IN_IRQ();						\</span>
<span class="p_add">+	likely(!__range_not_ok(addr, size, user_addr_max()));		\</span>
<span class="p_add">+})</span>
 
 /*
  * The exception table consists of pairs of addresses relative to the
<span class="p_header">diff --git a/arch/x86/kernel/amd_nb.c b/arch/x86/kernel/amd_nb.c</span>
<span class="p_header">index 29f0c55d6efc..3c9d268939af 100644</span>
<span class="p_header">--- a/arch/x86/kernel/amd_nb.c</span>
<span class="p_header">+++ b/arch/x86/kernel/amd_nb.c</span>
<span class="p_chunk">@@ -13,16 +13,24 @@</span> <span class="p_context"></span>
 #include &lt;linux/spinlock.h&gt;
 #include &lt;asm/amd_nb.h&gt;
 
<span class="p_add">+#define PCI_DEVICE_ID_AMD_17H_DF_F3	0x1463</span>
<span class="p_add">+#define PCI_DEVICE_ID_AMD_17H_DF_F4	0x1464</span>
<span class="p_add">+</span>
 static u32 *flush_words;
 
<span class="p_add">+#define PCI_DEVICE_ID_AMD_CNB17H_F4     0x1704</span>
<span class="p_add">+</span>
 const struct pci_device_id amd_nb_misc_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB_MISC) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_10H_NB_MISC) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_NB_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M10H_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M30H_NB_F3) },
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F3) },</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F3) },
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F3) },</span>
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CNB17H_F3) },</span>
 	{}
 };
 EXPORT_SYMBOL(amd_nb_misc_ids);
<span class="p_chunk">@@ -30,8 +38,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(amd_nb_misc_ids);</span>
 static const struct pci_device_id amd_nb_link_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_NB_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M30H_NB_F4) },
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F4) },</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F4) },
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F4) },</span>
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CNB17H_F4) },</span>
 	{}
 };
 
<span class="p_chunk">@@ -278,6 +289,41 @@</span> <span class="p_context"> void amd_flush_garts(void)</span>
 }
 EXPORT_SYMBOL_GPL(amd_flush_garts);
 
<span class="p_add">+static void __fix_erratum_688(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+#define MSR_AMD64_IC_CFG 0xC0011021</span>
<span class="p_add">+</span>
<span class="p_add">+	msr_set_bit(MSR_AMD64_IC_CFG, 3);</span>
<span class="p_add">+	msr_set_bit(MSR_AMD64_IC_CFG, 14);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Apply erratum 688 fix so machines without a BIOS fix work. */</span>
<span class="p_add">+static __init void fix_erratum_688(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *F4;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (boot_cpu_data.x86 != 0x14)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!amd_northbridges.num)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	F4 = node_to_amd_nb(0)-&gt;link;</span>
<span class="p_add">+	if (!F4)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pci_read_config_dword(F4, 0x164, &amp;val))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (val &amp; BIT(2))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	on_each_cpu(__fix_erratum_688, NULL, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;x86/cpu/AMD: CPU erratum 688 worked around\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __init int init_amd_nbs(void)
 {
 	int err = 0;
<span class="p_chunk">@@ -290,6 +336,8 @@</span> <span class="p_context"> static __init int init_amd_nbs(void)</span>
 	if (amd_cache_gart() &lt; 0)
 		pr_notice(&quot;Cannot initialize GART flush words, GART support disabled\n&quot;);
 
<span class="p_add">+	fix_erratum_688();</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">index a276fa75d9b5..8eaa571cb5f6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_chunk">@@ -267,6 +267,18 @@</span> <span class="p_context"> static int get_ucode_fw(void *to, const void *from, size_t n)</span>
 	return 0;
 }
 
<span class="p_add">+static bool is_blacklisted(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpuinfo_x86 *c = &amp;cpu_data(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (c-&gt;x86 == 6 &amp;&amp; c-&gt;x86_model == 0x4F) {</span>
<span class="p_add">+		pr_err_once(&quot;late loading on model 79 is disabled.\n&quot;);</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static enum ucode_state request_microcode_fw(int cpu, struct device *device,
 					     bool refresh_fw)
 {
<span class="p_chunk">@@ -275,6 +287,9 @@</span> <span class="p_context"> static enum ucode_state request_microcode_fw(int cpu, struct device *device,</span>
 	const struct firmware *firmware;
 	enum ucode_state ret;
 
<span class="p_add">+	if (is_blacklisted(cpu))</span>
<span class="p_add">+		return UCODE_NFOUND;</span>
<span class="p_add">+</span>
 	sprintf(name, &quot;intel-ucode/%02x-%02x-%02x&quot;,
 		c-&gt;x86, c-&gt;x86_model, c-&gt;x86_mask);
 
<span class="p_chunk">@@ -299,6 +314,9 @@</span> <span class="p_context"> static int get_ucode_user(void *to, const void *from, size_t n)</span>
 static enum ucode_state
 request_microcode_user(int cpu, const void __user *buf, size_t size)
 {
<span class="p_add">+	if (is_blacklisted(cpu))</span>
<span class="p_add">+		return UCODE_NFOUND;</span>
<span class="p_add">+</span>
 	return generic_load_microcode(cpu, (void *)buf, size, &amp;get_ucode_user);
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 50a1d48b1419..f9a6d8d68720 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -8670,7 +8670,7 @@</span> <span class="p_context"> static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,</span>
 	 * (KVM doesn&#39;t change it)- no reason to call set_cr4_guest_host_mask();
 	 */
 	vcpu-&gt;arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);
<span class="p_del">-	kvm_set_cr4(vcpu, vmcs12-&gt;host_cr4);</span>
<span class="p_add">+	vmx_set_cr4(vcpu, vmcs12-&gt;host_cr4);</span>
 
 	nested_ept_uninit_mmu_context(vcpu);
 
<span class="p_chunk">@@ -9029,12 +9029,7 @@</span> <span class="p_context"> static int __init vmx_init(void)</span>
 	memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);
 	memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Allow direct access to the PC debug port (it is often used for I/O</span>
<span class="p_del">-	 * delays, but the vmexits simply slow things down).</span>
<span class="p_del">-	 */</span>
 	memset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);
<span class="p_del">-	clear_bit(0x80, vmx_io_bitmap_a);</span>
 
 	memset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 77edfa6d0b54..2d7ccb5a2bdd 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -4052,7 +4052,7 @@</span> <span class="p_context"> static int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)</span>
 		      !kvm_iodevice_read(&amp;vcpu-&gt;arch.apic-&gt;dev, addr, n, v))
 		    &amp;&amp; kvm_io_bus_read(vcpu-&gt;kvm, KVM_MMIO_BUS, addr, n, v))
 			break;
<span class="p_del">-		trace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);</span>
<span class="p_add">+		trace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, v);</span>
 		handled += n;
 		addr += n;
 		len -= n;
<span class="p_chunk">@@ -4276,7 +4276,7 @@</span> <span class="p_context"> static int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)</span>
 {
 	if (vcpu-&gt;mmio_read_completed) {
 		trace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,
<span class="p_del">-			       vcpu-&gt;mmio_fragments[0].gpa, *(u64 *)val);</span>
<span class="p_add">+			       vcpu-&gt;mmio_fragments[0].gpa, val);</span>
 		vcpu-&gt;mmio_read_completed = 0;
 		return 1;
 	}
<span class="p_chunk">@@ -4298,14 +4298,14 @@</span> <span class="p_context"> static int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 
 static int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)
 {
<span class="p_del">-	trace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);</span>
<span class="p_add">+	trace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);</span>
 	return vcpu_mmio_write(vcpu, gpa, bytes, val);
 }
 
 static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,
 			  void *val, int bytes)
 {
<span class="p_del">-	trace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);</span>
<span class="p_add">+	trace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);</span>
 	return X86EMUL_IO_NEEDED;
 }
 
<span class="p_header">diff --git a/arch/x86/oprofile/op_model_ppro.c b/arch/x86/oprofile/op_model_ppro.c</span>
<span class="p_header">index d90528ea5412..12c051d19e4b 100644</span>
<span class="p_header">--- a/arch/x86/oprofile/op_model_ppro.c</span>
<span class="p_header">+++ b/arch/x86/oprofile/op_model_ppro.c</span>
<span class="p_chunk">@@ -212,8 +212,8 @@</span> <span class="p_context"> static void arch_perfmon_setup_counters(void)</span>
 	eax.full = cpuid_eax(0xa);
 
 	/* Workaround for BIOS bugs in 6/15. Taken from perfmon2 */
<span class="p_del">-	if (eax.split.version_id == 0 &amp;&amp; __this_cpu_read(cpu_info.x86) == 6 &amp;&amp;</span>
<span class="p_del">-		__this_cpu_read(cpu_info.x86_model) == 15) {</span>
<span class="p_add">+	if (eax.split.version_id == 0 &amp;&amp; boot_cpu_data.x86 == 6 &amp;&amp;</span>
<span class="p_add">+	    boot_cpu_data.x86_model == 15) {</span>
 		eax.split.version_id = 2;
 		eax.split.num_counters = 2;
 		eax.split.bit_width = 40;
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index dcc6365bcc11..4218dab2bb47 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -1286,6 +1286,7 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 	struct bio *bio;
 	int cur_page = 0;
 	int ret, offset;
<span class="p_add">+	struct bio_vec *bvec;</span>
 
 	for (i = 0; i &lt; iov_count; i++) {
 		unsigned long uaddr = (unsigned long)iov[i].iov_base;
<span class="p_chunk">@@ -1329,7 +1330,12 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 
 		ret = get_user_pages_fast(uaddr, local_nr_pages,
 				write_to_vm, &amp;pages[cur_page]);
<span class="p_del">-		if (ret &lt; local_nr_pages) {</span>
<span class="p_add">+		if (unlikely(ret &lt; local_nr_pages)) {</span>
<span class="p_add">+			for (j = cur_page; j &lt; page_limit; j++) {</span>
<span class="p_add">+				if (!pages[j])</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				put_page(pages[j]);</span>
<span class="p_add">+			}</span>
 			ret = -EFAULT;
 			goto out_unmap;
 		}
<span class="p_chunk">@@ -1384,10 +1390,8 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 	return bio;
 
  out_unmap:
<span class="p_del">-	for (i = 0; i &lt; nr_pages; i++) {</span>
<span class="p_del">-		if(!pages[i])</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		page_cache_release(pages[i]);</span>
<span class="p_add">+	bio_for_each_segment_all(bvec, bio, j) {</span>
<span class="p_add">+		put_page(bvec-&gt;bv_page);</span>
 	}
  out:
 	kfree(pages);
<span class="p_header">diff --git a/crypto/hmac.c b/crypto/hmac.c</span>
<span class="p_header">index ade790b454e9..758688b4bc6b 100644</span>
<span class="p_header">--- a/crypto/hmac.c</span>
<span class="p_header">+++ b/crypto/hmac.c</span>
<span class="p_chunk">@@ -197,11 +197,15 @@</span> <span class="p_context"> static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)</span>
 	salg = shash_attr_alg(tb[1], 0, 0);
 	if (IS_ERR(salg))
 		return PTR_ERR(salg);
<span class="p_add">+	alg = &amp;salg-&gt;base;</span>
 
<span class="p_add">+	/* The underlying hash algorithm must be unkeyed */</span>
 	err = -EINVAL;
<span class="p_add">+	if (crypto_shash_alg_has_setkey(salg))</span>
<span class="p_add">+		goto out_put_alg;</span>
<span class="p_add">+</span>
 	ds = salg-&gt;digestsize;
 	ss = salg-&gt;statesize;
<span class="p_del">-	alg = &amp;salg-&gt;base;</span>
 	if (ds &gt; alg-&gt;cra_blocksize ||
 	    ss &lt; alg-&gt;cra_blocksize)
 		goto out_put_alg;
<span class="p_header">diff --git a/crypto/salsa20_generic.c b/crypto/salsa20_generic.c</span>
<span class="p_header">index f550b5d94630..d7da0eea5622 100644</span>
<span class="p_header">--- a/crypto/salsa20_generic.c</span>
<span class="p_header">+++ b/crypto/salsa20_generic.c</span>
<span class="p_chunk">@@ -188,13 +188,6 @@</span> <span class="p_context"> static int encrypt(struct blkcipher_desc *desc,</span>
 
 	salsa20_ivsetup(ctx, walk.iv);
 
<span class="p_del">-	if (likely(walk.nbytes == nbytes))</span>
<span class="p_del">-	{</span>
<span class="p_del">-		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,</span>
<span class="p_del">-				      walk.src.virt.addr, nbytes);</span>
<span class="p_del">-		return blkcipher_walk_done(desc, &amp;walk, 0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	while (walk.nbytes &gt;= 64) {
 		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
 				      walk.src.virt.addr,
<span class="p_header">diff --git a/crypto/shash.c b/crypto/shash.c</span>
<span class="p_header">index 03fbcd4a82c4..73c065321867 100644</span>
<span class="p_header">--- a/crypto/shash.c</span>
<span class="p_header">+++ b/crypto/shash.c</span>
<span class="p_chunk">@@ -24,11 +24,12 @@</span> <span class="p_context"></span>
 
 static const struct crypto_type crypto_shash_type;
 
<span class="p_del">-static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,</span>
<span class="p_del">-			   unsigned int keylen)</span>
<span class="p_add">+int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,</span>
<span class="p_add">+		    unsigned int keylen)</span>
 {
 	return -ENOSYS;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(shash_no_setkey);</span>
 
 static int shash_setkey_unaligned(struct crypto_shash *tfm, const u8 *key,
 				  unsigned int keylen)
<span class="p_chunk">@@ -274,12 +275,14 @@</span> <span class="p_context"> static int shash_async_finup(struct ahash_request *req)</span>
 
 int shash_ahash_digest(struct ahash_request *req, struct shash_desc *desc)
 {
<span class="p_del">-	struct scatterlist *sg = req-&gt;src;</span>
<span class="p_del">-	unsigned int offset = sg-&gt;offset;</span>
 	unsigned int nbytes = req-&gt;nbytes;
<span class="p_add">+	struct scatterlist *sg;</span>
<span class="p_add">+	unsigned int offset;</span>
 	int err;
 
<span class="p_del">-	if (nbytes &lt; min(sg-&gt;length, ((unsigned int)(PAGE_SIZE)) - offset)) {</span>
<span class="p_add">+	if (nbytes &amp;&amp;</span>
<span class="p_add">+	    (sg = req-&gt;src, offset = sg-&gt;offset,</span>
<span class="p_add">+	     nbytes &lt; min(sg-&gt;length, ((unsigned int)(PAGE_SIZE)) - offset))) {</span>
 		void *data;
 
 		data = kmap_atomic(sg_page(sg));
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index 6eea35b05f6a..d1c04f0f79b6 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -2584,7 +2584,7 @@</span> <span class="p_context"> static int rbd_img_obj_parent_read_full(struct rbd_obj_request *obj_request)</span>
 	 * from the parent.
 	 */
 	page_count = (u32)calc_pages_for(0, length);
<span class="p_del">-	pages = ceph_alloc_page_vector(page_count, GFP_KERNEL);</span>
<span class="p_add">+	pages = ceph_alloc_page_vector(page_count, GFP_NOIO);</span>
 	if (IS_ERR(pages)) {
 		result = PTR_ERR(pages);
 		pages = NULL;
<span class="p_chunk">@@ -2711,7 +2711,7 @@</span> <span class="p_context"> static int rbd_img_obj_exists_submit(struct rbd_obj_request *obj_request)</span>
 	 */
 	size = sizeof (__le64) + sizeof (__le32) + sizeof (__le32);
 	page_count = (u32)calc_pages_for(0, size);
<span class="p_del">-	pages = ceph_alloc_page_vector(page_count, GFP_KERNEL);</span>
<span class="p_add">+	pages = ceph_alloc_page_vector(page_count, GFP_NOIO);</span>
 	if (IS_ERR(pages))
 		return PTR_ERR(pages);
 
<span class="p_header">diff --git a/drivers/bus/mvebu-mbus.c b/drivers/bus/mvebu-mbus.c</span>
<span class="p_header">index d29f5ffdb0f4..d729c1cc7542 100644</span>
<span class="p_header">--- a/drivers/bus/mvebu-mbus.c</span>
<span class="p_header">+++ b/drivers/bus/mvebu-mbus.c</span>
<span class="p_chunk">@@ -523,7 +523,7 @@</span> <span class="p_context"> mvebu_mbus_default_setup_cpu_target(struct mvebu_mbus_state *mbus)</span>
 			if (mbus-&gt;hw_io_coherency)
 				w-&gt;mbus_attr |= ATTR_HW_COHERENCY;
 			w-&gt;base = base &amp; DDR_BASE_CS_LOW_MASK;
<span class="p_del">-			w-&gt;size = (size | ~DDR_SIZE_MASK) + 1;</span>
<span class="p_add">+			w-&gt;size = (u64)(size | ~DDR_SIZE_MASK) + 1;</span>
 		}
 	}
 	mvebu_mbus_dram_info.num_cs = cs;
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index c6bd28c59d65..0d3f3af79bde 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -1581,9 +1581,9 @@</span> <span class="p_context"> static int common_nonsnoop_hash(struct talitos_edesc *edesc,</span>
 		req_ctx-&gt;swinit = 0;
 	} else {
 		desc-&gt;ptr[1] = zero_entry;
<span class="p_del">-		/* Indicate next op is not the first. */</span>
<span class="p_del">-		req_ctx-&gt;first = 0;</span>
 	}
<span class="p_add">+	/* Indicate next op is not the first. */</span>
<span class="p_add">+	req_ctx-&gt;first = 0;</span>
 
 	/* HMAC key */
 	if (ctx-&gt;keylen)
<span class="p_chunk">@@ -2550,7 +2550,8 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		t_alg-&gt;algt.alg.hash.final = ahash_final;
 		t_alg-&gt;algt.alg.hash.finup = ahash_finup;
 		t_alg-&gt;algt.alg.hash.digest = ahash_digest;
<span class="p_del">-		t_alg-&gt;algt.alg.hash.setkey = ahash_setkey;</span>
<span class="p_add">+		if (!strncmp(alg-&gt;cra_name, &quot;hmac&quot;, 4))</span>
<span class="p_add">+			t_alg-&gt;algt.alg.hash.setkey = ahash_setkey;</span>
 
 		if (!(priv-&gt;features &amp; TALITOS_FTR_HMAC_OK) &amp;&amp;
 		    !strncmp(alg-&gt;cra_name, &quot;hmac&quot;, 4)) {
<span class="p_header">diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c</span>
<span class="p_header">index 86608585ec00..5b38f5aede59 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib-acpi.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib-acpi.c</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,</span>
 
 	if (pin &lt;= 255) {
 		char ev_name[5];
<span class="p_del">-		sprintf(ev_name, &quot;_%c%02X&quot;,</span>
<span class="p_add">+		sprintf(ev_name, &quot;_%c%02hhX&quot;,</span>
 			agpio-&gt;triggering == ACPI_EDGE_SENSITIVE ? &#39;E&#39; : &#39;L&#39;,
 			pin);
 		if (ACPI_SUCCESS(acpi_get_handle(handle, ev_name, &amp;evt_handle)))
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_bios.c b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">index 07d72573fc60..e03526a10340 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_chunk">@@ -939,6 +939,13 @@</span> <span class="p_context"> static void parse_ddi_port(struct drm_i915_private *dev_priv, enum port port,</span>
 	is_hdmi = is_dvi &amp;&amp; (child-&gt;common.device_type &amp; DEVICE_TYPE_NOT_HDMI_OUTPUT) == 0;
 	is_edp = is_dp &amp;&amp; (child-&gt;common.device_type &amp; DEVICE_TYPE_INTERNAL_CONNECTOR);
 
<span class="p_add">+	if (port == PORT_A &amp;&amp; is_dvi) {</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;VBT claims port A supports DVI%s, ignoring\n&quot;,</span>
<span class="p_add">+			      is_hdmi ? &quot;/HDMI&quot; : &quot;&quot;);</span>
<span class="p_add">+		is_dvi = false;</span>
<span class="p_add">+		is_hdmi = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	info-&gt;supports_dvi = is_dvi;
 	info-&gt;supports_hdmi = is_hdmi;
 	info-&gt;supports_dp = is_dp;
<span class="p_header">diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">index 23eebb7f31aa..149d1da033c0 100644</span>
<span class="p_header">--- a/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">+++ b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_chunk">@@ -526,7 +526,8 @@</span> <span class="p_context"> static int i2c_hid_alloc_buffers(struct i2c_hid *ihid, size_t report_size)</span>
 {
 	/* the worst case is computed from the set_report command with a
 	 * reportID &gt; 15 and the maximum report length */
<span class="p_del">-	int args_len = sizeof(__u8) + /* optional ReportID byte */</span>
<span class="p_add">+	int args_len = sizeof(__u8) + /* ReportID */</span>
<span class="p_add">+		       sizeof(__u8) + /* optional ReportID byte */</span>
 		       sizeof(__u16) + /* data register */
 		       sizeof(__u16) + /* size of the report */
 		       report_size; /* report */
<span class="p_header">diff --git a/drivers/iio/adc/ad7793.c b/drivers/iio/adc/ad7793.c</span>
<span class="p_header">index 5da07546e182..05ab5ad07df1 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ad7793.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ad7793.c</span>
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> static int ad7793_setup(struct iio_dev *indio_dev,</span>
 	unsigned int vref_mv)
 {
 	struct ad7793_state *st = iio_priv(indio_dev);
<span class="p_del">-	int i, ret = -1;</span>
<span class="p_add">+	int i, ret;</span>
 	unsigned long long scale_uv;
 	u32 id;
 
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static int ad7793_setup(struct iio_dev *indio_dev,</span>
 		return ret;
 
 	/* reset the serial interface */
<span class="p_del">-	ret = spi_write(st-&gt;sd.spi, (u8 *)&amp;ret, sizeof(ret));</span>
<span class="p_add">+	ret = ad_sd_reset(&amp;st-&gt;sd, 32);</span>
 	if (ret &lt; 0)
 		goto out;
 	usleep_range(500, 2000); /* Wait for at least 500us */
<span class="p_header">diff --git a/drivers/iio/adc/ad_sigma_delta.c b/drivers/iio/adc/ad_sigma_delta.c</span>
<span class="p_header">index eb799a43aef0..dbcea7941059 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ad_sigma_delta.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ad_sigma_delta.c</span>
<span class="p_chunk">@@ -177,6 +177,34 @@</span> <span class="p_context"> int ad_sd_read_reg(struct ad_sigma_delta *sigma_delta,</span>
 }
 EXPORT_SYMBOL_GPL(ad_sd_read_reg);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * ad_sd_reset() - Reset the serial interface</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @sigma_delta: The sigma delta device</span>
<span class="p_add">+ * @reset_length: Number of SCLKs with DIN = 1</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns 0 on success, an error code otherwise.</span>
<span class="p_add">+ **/</span>
<span class="p_add">+int ad_sd_reset(struct ad_sigma_delta *sigma_delta,</span>
<span class="p_add">+	unsigned int reset_length)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint8_t *buf;</span>
<span class="p_add">+	unsigned int size;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = DIV_ROUND_UP(reset_length, 8);</span>
<span class="p_add">+	buf = kcalloc(size, sizeof(*buf), GFP_KERNEL);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(buf, 0xff, size);</span>
<span class="p_add">+	ret = spi_write(sigma_delta-&gt;spi, buf, size);</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(ad_sd_reset);</span>
<span class="p_add">+</span>
 static int ad_sd_calibrate(struct ad_sigma_delta *sigma_delta,
 	unsigned int mode, unsigned int channel)
 {
<span class="p_header">diff --git a/drivers/iio/adc/mcp320x.c b/drivers/iio/adc/mcp320x.c</span>
<span class="p_header">index 28a086e48776..662c930fb1c3 100644</span>
<span class="p_header">--- a/drivers/iio/adc/mcp320x.c</span>
<span class="p_header">+++ b/drivers/iio/adc/mcp320x.c</span>
<span class="p_chunk">@@ -180,6 +180,7 @@</span> <span class="p_context"> static int mcp320x_probe(struct spi_device *spi)</span>
 	indio_dev-&gt;name = spi_get_device_id(spi)-&gt;name;
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;mcp320x_info;
<span class="p_add">+	spi_set_drvdata(spi, indio_dev);</span>
 
 	chip_info = &amp;mcp3208_chip_infos[spi_get_device_id(spi)-&gt;driver_data];
 	indio_dev-&gt;channels = chip_info-&gt;channels;
<span class="p_header">diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c</span>
<span class="p_header">index c6b0f1503366..4d1b400ed260 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-core.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-core.c</span>
<span class="p_chunk">@@ -184,8 +184,10 @@</span> <span class="p_context"> static ssize_t iio_debugfs_read_reg(struct file *file, char __user *userbuf,</span>
 	ret = indio_dev-&gt;info-&gt;debugfs_reg_access(indio_dev,
 						  indio_dev-&gt;cached_reg_addr,
 						  0, &amp;val);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
 		dev_err(indio_dev-&gt;dev.parent, &quot;%s: read failed\n&quot;, __func__);
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
 	len = snprintf(buf, sizeof(buf), &quot;0x%X\n&quot;, val);
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mem.c b/drivers/infiniband/hw/mlx5/mem.c</span>
<span class="p_header">index deff377934ff..474bcafe0684 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mem.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mem.c</span>
<span class="p_chunk">@@ -46,46 +46,33 @@</span> <span class="p_context"> void mlx5_ib_cont_pages(struct ib_umem *umem, u64 addr, int *count, int *shift,</span>
 {
 	unsigned long tmp;
 	unsigned long m;
<span class="p_del">-	int i, k;</span>
<span class="p_del">-	u64 base = 0;</span>
<span class="p_del">-	int p = 0;</span>
<span class="p_del">-	int skip;</span>
<span class="p_del">-	int mask;</span>
<span class="p_del">-	u64 len;</span>
<span class="p_del">-	u64 pfn;</span>
<span class="p_add">+	u64 base = ~0, p = 0;</span>
<span class="p_add">+	u64 len, pfn;</span>
<span class="p_add">+	int i = 0;</span>
 	struct scatterlist *sg;
 	int entry;
 
 	addr = addr &gt;&gt; PAGE_SHIFT;
 	tmp = (unsigned long)addr;
<span class="p_del">-	m = find_first_bit(&amp;tmp, sizeof(tmp));</span>
<span class="p_del">-	skip = 1 &lt;&lt; m;</span>
<span class="p_del">-	mask = skip - 1;</span>
<span class="p_del">-	i = 0;</span>
<span class="p_add">+	m = find_first_bit(&amp;tmp, BITS_PER_LONG);</span>
<span class="p_add">+</span>
 	for_each_sg(umem-&gt;sg_head.sgl, sg, umem-&gt;nmap, entry) {
 		len = sg_dma_len(sg) &gt;&gt; PAGE_SHIFT;
 		pfn = sg_dma_address(sg) &gt;&gt; PAGE_SHIFT;
<span class="p_del">-		for (k = 0; k &lt; len; k++) {</span>
<span class="p_del">-			if (!(i &amp; mask)) {</span>
<span class="p_del">-				tmp = (unsigned long)pfn;</span>
<span class="p_del">-				m = min_t(unsigned long, m, find_first_bit(&amp;tmp, sizeof(tmp)));</span>
<span class="p_del">-				skip = 1 &lt;&lt; m;</span>
<span class="p_del">-				mask = skip - 1;</span>
<span class="p_del">-				base = pfn;</span>
<span class="p_del">-				p = 0;</span>
<span class="p_del">-			} else {</span>
<span class="p_del">-				if (base + p != pfn) {</span>
<span class="p_del">-					tmp = (unsigned long)p;</span>
<span class="p_del">-					m = find_first_bit(&amp;tmp, sizeof(tmp));</span>
<span class="p_del">-					skip = 1 &lt;&lt; m;</span>
<span class="p_del">-					mask = skip - 1;</span>
<span class="p_del">-					base = pfn;</span>
<span class="p_del">-					p = 0;</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_del">-			p++;</span>
<span class="p_del">-			i++;</span>
<span class="p_add">+		if (base + p != pfn) {</span>
<span class="p_add">+			/* If either the offset or the new</span>
<span class="p_add">+			 * base are unaligned update m</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tmp = (unsigned long)(pfn | p);</span>
<span class="p_add">+			if (!IS_ALIGNED(tmp, 1 &lt;&lt; m))</span>
<span class="p_add">+				m = find_first_bit(&amp;tmp, BITS_PER_LONG);</span>
<span class="p_add">+</span>
<span class="p_add">+			base = pfn;</span>
<span class="p_add">+			p = 0;</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		p += len;</span>
<span class="p_add">+		i += len;</span>
 	}
 
 	if (i) {
<span class="p_header">diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_hw.c b/drivers/infiniband/hw/ocrdma/ocrdma_hw.c</span>
<span class="p_header">index 3bbf2010a821..e682c79c41c1 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/ocrdma/ocrdma_hw.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/ocrdma/ocrdma_hw.c</span>
<span class="p_chunk">@@ -235,7 +235,10 @@</span> <span class="p_context"> static int ocrdma_get_mbx_errno(u32 status)</span>
 		case OCRDMA_MBX_ADDI_STATUS_INSUFFICIENT_RESOURCES:
 			err_num = -EAGAIN;
 			break;
<span class="p_add">+		default:</span>
<span class="p_add">+			err_num = -EFAULT;</span>
 		}
<span class="p_add">+		break;</span>
 	default:
 		err_num = -EFAULT;
 	}
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ib.c b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">index 27fe62e2fd95..fcbfdda0e585 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_chunk">@@ -961,19 +961,6 @@</span> <span class="p_context"> static inline int update_parent_pkey(struct ipoib_dev_priv *priv)</span>
 		 */
 		priv-&gt;dev-&gt;broadcast[8] = priv-&gt;pkey &gt;&gt; 8;
 		priv-&gt;dev-&gt;broadcast[9] = priv-&gt;pkey &amp; 0xff;
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Update the broadcast address in the priv-&gt;broadcast object,</span>
<span class="p_del">-		 * in case it already exists, otherwise no one will do that.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (priv-&gt;broadcast) {</span>
<span class="p_del">-			spin_lock_irq(&amp;priv-&gt;lock);</span>
<span class="p_del">-			memcpy(priv-&gt;broadcast-&gt;mcmember.mgid.raw,</span>
<span class="p_del">-			       priv-&gt;dev-&gt;broadcast + 4,</span>
<span class="p_del">-			sizeof(union ib_gid));</span>
<span class="p_del">-			spin_unlock_irq(&amp;priv-&gt;lock);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c</span>
<span class="p_header">index f50f6dd92274..b0e2de131b76 100644</span>
<span class="p_header">--- a/drivers/input/ff-core.c</span>
<span class="p_header">+++ b/drivers/input/ff-core.c</span>
<span class="p_chunk">@@ -239,9 +239,15 @@</span> <span class="p_context"> int input_ff_erase(struct input_dev *dev, int effect_id, struct file *file)</span>
 EXPORT_SYMBOL_GPL(input_ff_erase);
 
 /*
<span class="p_del">- * flush_effects - erase all effects owned by a file handle</span>
<span class="p_add">+ * input_ff_flush - erase all effects owned by a file handle</span>
<span class="p_add">+ * @dev: input device to erase effect from</span>
<span class="p_add">+ * @file: purported owner of the effects</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function erases all force-feedback effects associated with</span>
<span class="p_add">+ * the given owner from specified device. Note that @file may be %NULL,</span>
<span class="p_add">+ * in which case all effects will be erased.</span>
  */
<span class="p_del">-static int flush_effects(struct input_dev *dev, struct file *file)</span>
<span class="p_add">+int input_ff_flush(struct input_dev *dev, struct file *file)</span>
 {
 	struct ff_device *ff = dev-&gt;ff;
 	int i;
<span class="p_chunk">@@ -257,6 +263,7 @@</span> <span class="p_context"> static int flush_effects(struct input_dev *dev, struct file *file)</span>
 
 	return 0;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(input_ff_flush);</span>
 
 /**
  * input_ff_event() - generic handler for force-feedback events
<span class="p_chunk">@@ -340,7 +347,7 @@</span> <span class="p_context"> int input_ff_create(struct input_dev *dev, unsigned int max_effects)</span>
 	mutex_init(&amp;ff-&gt;mutex);
 
 	dev-&gt;ff = ff;
<span class="p_del">-	dev-&gt;flush = flush_effects;</span>
<span class="p_add">+	dev-&gt;flush = input_ff_flush;</span>
 	dev-&gt;event = input_ff_event;
 	__set_bit(EV_FF, dev-&gt;evbit);
 
<span class="p_header">diff --git a/drivers/input/misc/ims-pcu.c b/drivers/input/misc/ims-pcu.c</span>
<span class="p_header">index f19375acfeec..ea8c48a9e09d 100644</span>
<span class="p_header">--- a/drivers/input/misc/ims-pcu.c</span>
<span class="p_header">+++ b/drivers/input/misc/ims-pcu.c</span>
<span class="p_chunk">@@ -1635,13 +1635,25 @@</span> <span class="p_context"> ims_pcu_get_cdc_union_desc(struct usb_interface *intf)</span>
 		return NULL;
 	}
 
<span class="p_del">-	while (buflen &gt; 0) {</span>
<span class="p_add">+	while (buflen &gt;= sizeof(*union_desc)) {</span>
 		union_desc = (struct usb_cdc_union_desc *)buf;
 
<span class="p_add">+		if (union_desc-&gt;bLength &gt; buflen) {</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev, &quot;Too large descriptor\n&quot;);</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (union_desc-&gt;bDescriptorType == USB_DT_CS_INTERFACE &amp;&amp;
 		    union_desc-&gt;bDescriptorSubType == USB_CDC_UNION_TYPE) {
 			dev_dbg(&amp;intf-&gt;dev, &quot;Found union header\n&quot;);
<span class="p_del">-			return union_desc;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (union_desc-&gt;bLength &gt;= sizeof(*union_desc))</span>
<span class="p_add">+				return union_desc;</span>
<span class="p_add">+</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev,</span>
<span class="p_add">+				&quot;Union descriptor to short (%d vs %zd\n)&quot;,</span>
<span class="p_add">+				union_desc-&gt;bLength, sizeof(*union_desc));</span>
<span class="p_add">+			return NULL;</span>
 		}
 
 		buflen -= union_desc-&gt;bLength;
<span class="p_header">diff --git a/drivers/input/misc/uinput.c b/drivers/input/misc/uinput.c</span>
<span class="p_header">index 5a63c274ae1c..08cf73e92cb3 100644</span>
<span class="p_header">--- a/drivers/input/misc/uinput.c</span>
<span class="p_header">+++ b/drivers/input/misc/uinput.c</span>
<span class="p_chunk">@@ -98,14 +98,15 @@</span> <span class="p_context"> static int uinput_request_reserve_slot(struct uinput_device *udev,</span>
 					uinput_request_alloc_id(udev, request));
 }
 
<span class="p_del">-static void uinput_request_done(struct uinput_device *udev,</span>
<span class="p_del">-				struct uinput_request *request)</span>
<span class="p_add">+static void uinput_request_release_slot(struct uinput_device *udev,</span>
<span class="p_add">+					unsigned int id)</span>
 {
 	/* Mark slot as available */
<span class="p_del">-	udev-&gt;requests[request-&gt;id] = NULL;</span>
<span class="p_del">-	wake_up(&amp;udev-&gt;requests_waitq);</span>
<span class="p_add">+	spin_lock(&amp;udev-&gt;requests_lock);</span>
<span class="p_add">+	udev-&gt;requests[id] = NULL;</span>
<span class="p_add">+	spin_unlock(&amp;udev-&gt;requests_lock);</span>
 
<span class="p_del">-	complete(&amp;request-&gt;done);</span>
<span class="p_add">+	wake_up(&amp;udev-&gt;requests_waitq);</span>
 }
 
 static int uinput_request_send(struct uinput_device *udev,
<span class="p_chunk">@@ -138,20 +139,22 @@</span> <span class="p_context"> static int uinput_request_send(struct uinput_device *udev,</span>
 static int uinput_request_submit(struct uinput_device *udev,
 				 struct uinput_request *request)
 {
<span class="p_del">-	int error;</span>
<span class="p_add">+	int retval;</span>
 
<span class="p_del">-	error = uinput_request_reserve_slot(udev, request);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_add">+	retval = uinput_request_reserve_slot(udev, request);</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		return retval;</span>
 
<span class="p_del">-	error = uinput_request_send(udev, request);</span>
<span class="p_del">-	if (error) {</span>
<span class="p_del">-		uinput_request_done(udev, request);</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	retval = uinput_request_send(udev, request);</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		goto out;</span>
 
 	wait_for_completion(&amp;request-&gt;done);
<span class="p_del">-	return request-&gt;retval;</span>
<span class="p_add">+	retval = request-&gt;retval;</span>
<span class="p_add">+</span>
<span class="p_add">+ out:</span>
<span class="p_add">+	uinput_request_release_slot(udev, request-&gt;id);</span>
<span class="p_add">+	return retval;</span>
 }
 
 /*
<span class="p_chunk">@@ -169,7 +172,7 @@</span> <span class="p_context"> static void uinput_flush_requests(struct uinput_device *udev)</span>
 		request = udev-&gt;requests[i];
 		if (request) {
 			request-&gt;retval = -ENODEV;
<span class="p_del">-			uinput_request_done(udev, request);</span>
<span class="p_add">+			complete(&amp;request-&gt;done);</span>
 		}
 	}
 
<span class="p_chunk">@@ -230,6 +233,18 @@</span> <span class="p_context"> static int uinput_dev_erase_effect(struct input_dev *dev, int effect_id)</span>
 	return uinput_request_submit(udev, &amp;request);
 }
 
<span class="p_add">+static int uinput_dev_flush(struct input_dev *dev, struct file *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we are called with file == NULL that means we are tearing</span>
<span class="p_add">+	 * down the device, and therefore we can not handle FF erase</span>
<span class="p_add">+	 * requests: either we are handling UI_DEV_DESTROY (and holding</span>
<span class="p_add">+	 * the udev-&gt;mutex), or the file descriptor is closed and there is</span>
<span class="p_add">+	 * nobody on the other side anymore.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return file ? input_ff_flush(dev, file) : 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void uinput_destroy_device(struct uinput_device *udev)
 {
 	const char *name, *phys;
<span class="p_chunk">@@ -273,6 +288,12 @@</span> <span class="p_context"> static int uinput_create_device(struct uinput_device *udev)</span>
 		dev-&gt;ff-&gt;playback = uinput_dev_playback;
 		dev-&gt;ff-&gt;set_gain = uinput_dev_set_gain;
 		dev-&gt;ff-&gt;set_autocenter = uinput_dev_set_autocenter;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The standard input_ff_flush() implementation does</span>
<span class="p_add">+		 * not quite work for uinput as we can&#39;t reasonably</span>
<span class="p_add">+		 * handle FF requests during device teardown.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		dev-&gt;flush = uinput_dev_flush;</span>
 	}
 
 	error = input_register_device(udev-&gt;dev);
<span class="p_chunk">@@ -840,7 +861,7 @@</span> <span class="p_context"> static long uinput_ioctl_handler(struct file *file, unsigned int cmd,</span>
 			}
 
 			req-&gt;retval = ff_up.retval;
<span class="p_del">-			uinput_request_done(udev, req);</span>
<span class="p_add">+			complete(&amp;req-&gt;done);</span>
 			goto out;
 
 		case UI_END_FF_ERASE:
<span class="p_chunk">@@ -856,7 +877,7 @@</span> <span class="p_context"> static long uinput_ioctl_handler(struct file *file, unsigned int cmd,</span>
 			}
 
 			req-&gt;retval = ff_erase.retval;
<span class="p_del">-			uinput_request_done(udev, req);</span>
<span class="p_add">+			complete(&amp;req-&gt;done);</span>
 			goto out;
 	}
 
<span class="p_header">diff --git a/drivers/input/touchscreen/ti_am335x_tsc.c b/drivers/input/touchscreen/ti_am335x_tsc.c</span>
<span class="p_header">index 2ce649520fe0..092fa8b31c67 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/ti_am335x_tsc.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/ti_am335x_tsc.c</span>
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> static void titsc_step_config(struct titsc *ts_dev)</span>
 		break;
 	case 5:
 		config |= ts_dev-&gt;bit_xp | STEPCONFIG_INP_AN4 |
<span class="p_del">-				ts_dev-&gt;bit_xn | ts_dev-&gt;bit_yp;</span>
<span class="p_add">+				STEPCONFIG_XNP | STEPCONFIG_YPN;</span>
 		break;
 	case 8:
 		config |= ts_dev-&gt;bit_yp | STEPCONFIG_INP(ts_dev-&gt;inp_xp);
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 07af55cc2dcc..353417c95502 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -3440,6 +3440,7 @@</span> <span class="p_context"> static size_t amd_iommu_unmap(struct iommu_domain *dom, unsigned long iova,</span>
 	mutex_unlock(&amp;domain-&gt;api_lock);
 
 	domain_flush_tlb_pde(domain);
<span class="p_add">+	domain_flush_complete(domain);</span>
 
 	return unmap_size;
 }
<span class="p_header">diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">index 99054d2c040d..e7434b1b1d62 100644</span>
<span class="p_header">--- a/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/exynos-iommu.c</span>
<span class="p_chunk">@@ -676,7 +676,7 @@</span> <span class="p_context"> static int __init exynos_sysmmu_probe(struct platform_device *pdev)</span>
 	return 0;
 }
 
<span class="p_del">-static const struct of_device_id sysmmu_of_match[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id sysmmu_of_match[] = {</span>
 	{ .compatible	= &quot;samsung,exynos-sysmmu&quot;, },
 	{ },
 };
<span class="p_header">diff --git a/drivers/net/can/c_can/c_can_pci.c b/drivers/net/can/c_can/c_can_pci.c</span>
<span class="p_header">index b997508ea7c6..913a1c5ad1b4 100644</span>
<span class="p_header">--- a/drivers/net/can/c_can/c_can_pci.c</span>
<span class="p_header">+++ b/drivers/net/can/c_can/c_can_pci.c</span>
<span class="p_chunk">@@ -178,7 +178,6 @@</span> <span class="p_context"> static int c_can_pci_probe(struct pci_dev *pdev,</span>
 		break;
 	case BOSCH_D_CAN:
 		priv-&gt;regs = reg_map_d_can;
<span class="p_del">-		priv-&gt;can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;</span>
 		break;
 	default:
 		ret = -EINVAL;
<span class="p_header">diff --git a/drivers/net/can/c_can/c_can_platform.c b/drivers/net/can/c_can/c_can_platform.c</span>
<span class="p_header">index 12430be6448a..660404f5ebac 100644</span>
<span class="p_header">--- a/drivers/net/can/c_can/c_can_platform.c</span>
<span class="p_header">+++ b/drivers/net/can/c_can/c_can_platform.c</span>
<span class="p_chunk">@@ -266,7 +266,6 @@</span> <span class="p_context"> static int c_can_plat_probe(struct platform_device *pdev)</span>
 		break;
 	case BOSCH_D_CAN:
 		priv-&gt;regs = reg_map_d_can;
<span class="p_del">-		priv-&gt;can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;</span>
 		priv-&gt;read_reg = c_can_plat_read_reg_aligned_to_16bit;
 		priv-&gt;write_reg = c_can_plat_write_reg_aligned_to_16bit;
 		priv-&gt;read_reg32 = d_can_plat_read_reg32;
<span class="p_header">diff --git a/drivers/net/can/usb/esd_usb2.c b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">index 7a90075529c3..0cbf2d7eeb7c 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_chunk">@@ -334,7 +334,7 @@</span> <span class="p_context"> static void esd_usb2_rx_can_msg(struct esd_usb2_net_priv *priv,</span>
 		}
 
 		cf-&gt;can_id = id &amp; ESD_IDMASK;
<span class="p_del">-		cf-&gt;can_dlc = get_can_dlc(msg-&gt;msg.rx.dlc);</span>
<span class="p_add">+		cf-&gt;can_dlc = get_can_dlc(msg-&gt;msg.rx.dlc &amp; ~ESD_RTR);</span>
 
 		if (id &amp; ESD_EXTID)
 			cf-&gt;can_id |= CAN_EFF_FLAG;
<span class="p_header">diff --git a/drivers/net/can/usb/gs_usb.c b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">index b16c5a2d92fb..a864951dfc43 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_chunk">@@ -356,6 +356,8 @@</span> <span class="p_context"> static void gs_usb_recieve_bulk_callback(struct urb *urb)</span>
 
 		gs_free_tx_context(txc);
 
<span class="p_add">+		atomic_dec(&amp;dev-&gt;active_tx_urbs);</span>
<span class="p_add">+</span>
 		netif_wake_queue(netdev);
 	}
 
<span class="p_chunk">@@ -444,14 +446,6 @@</span> <span class="p_context"> static void gs_usb_xmit_callback(struct urb *urb)</span>
 			  urb-&gt;transfer_buffer_length,
 			  urb-&gt;transfer_buffer,
 			  urb-&gt;transfer_dma);
<span class="p_del">-</span>
<span class="p_del">-	atomic_dec(&amp;dev-&gt;active_tx_urbs);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!netif_device_present(netdev))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (netif_queue_stopped(netdev))</span>
<span class="p_del">-		netif_wake_queue(netdev);</span>
 }
 
 static netdev_tx_t gs_can_start_xmit(struct sk_buff *skb, struct net_device *netdev)
<span class="p_header">diff --git a/drivers/net/can/usb/kvaser_usb.c b/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_header">index 4d47f224d705..0c2c23c7dfe0 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_chunk">@@ -1263,7 +1263,8 @@</span> <span class="p_context"> static int kvaser_usb_close(struct net_device *netdev)</span>
 	if (err)
 		netdev_warn(netdev, &quot;Cannot flush queue, error %d\n&quot;, err);
 
<span class="p_del">-	if (kvaser_usb_send_simple_msg(dev, CMD_RESET_CHIP, priv-&gt;channel))</span>
<span class="p_add">+	err = kvaser_usb_send_simple_msg(dev, CMD_RESET_CHIP, priv-&gt;channel);</span>
<span class="p_add">+	if (err)</span>
 		netdev_warn(netdev, &quot;Cannot reset card, error %d\n&quot;, err);
 
 	err = kvaser_usb_stop_chip(priv);
<span class="p_header">diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c</span>
<span class="p_header">index b787d1ceeba6..47eba38ae526 100644</span>
<span class="p_header">--- a/drivers/net/macvtap.c</span>
<span class="p_header">+++ b/drivers/net/macvtap.c</span>
<span class="p_chunk">@@ -1051,10 +1051,12 @@</span> <span class="p_context"> static long macvtap_ioctl(struct file *file, unsigned int cmd,</span>
 		return 0;
 
 	case TUNSETSNDBUF:
<span class="p_del">-		if (get_user(u, up))</span>
<span class="p_add">+		if (get_user(s, sp))</span>
 			return -EFAULT;
<span class="p_add">+		if (s &lt;= 0)</span>
<span class="p_add">+			return -EINVAL;</span>
 
<span class="p_del">-		q-&gt;sk.sk_sndbuf = u;</span>
<span class="p_add">+		q-&gt;sk.sk_sndbuf = s;</span>
 		return 0;
 
 	case TUNGETVNETHDRSZ:
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 1c843a4ac7a4..a87b76341502 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -1647,6 +1647,9 @@</span> <span class="p_context"> static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)</span>
 
 		if (!dev)
 			return -ENOMEM;
<span class="p_add">+		err = dev_get_valid_name(net, dev, name);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto err_free_dev;</span>
 
 		dev_net_set(dev, net);
 		dev-&gt;rtnl_link_ops = &amp;tun_link_ops;
<span class="p_chunk">@@ -2051,6 +2054,10 @@</span> <span class="p_context"> static long __tun_chr_ioctl(struct file *file, unsigned int cmd,</span>
 			ret = -EFAULT;
 			break;
 		}
<span class="p_add">+		if (sndbuf &lt;= 0) {</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
 		tun-&gt;sndbuf = sndbuf;
 		tun_set_sndbuf(tun);
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/fweh.c b/drivers/net/wireless/brcm80211/brcmfmac/fweh.c</span>
<span class="p_header">index 3f9cb894d001..b53ba992767b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/fweh.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/fweh.c</span>
<span class="p_chunk">@@ -25,50 +25,6 @@</span> <span class="p_context"></span>
 #include &quot;fweh.h&quot;
 #include &quot;fwil.h&quot;
 
<span class="p_del">-/**</span>
<span class="p_del">- * struct brcm_ethhdr - broadcom specific ether header.</span>
<span class="p_del">- *</span>
<span class="p_del">- * @subtype: subtype for this packet.</span>
<span class="p_del">- * @length: TODO: length of appended data.</span>
<span class="p_del">- * @version: version indication.</span>
<span class="p_del">- * @oui: OUI of this packet.</span>
<span class="p_del">- * @usr_subtype: subtype for this OUI.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct brcm_ethhdr {</span>
<span class="p_del">-	__be16 subtype;</span>
<span class="p_del">-	__be16 length;</span>
<span class="p_del">-	u8 version;</span>
<span class="p_del">-	u8 oui[3];</span>
<span class="p_del">-	__be16 usr_subtype;</span>
<span class="p_del">-} __packed;</span>
<span class="p_del">-</span>
<span class="p_del">-struct brcmf_event_msg_be {</span>
<span class="p_del">-	__be16 version;</span>
<span class="p_del">-	__be16 flags;</span>
<span class="p_del">-	__be32 event_type;</span>
<span class="p_del">-	__be32 status;</span>
<span class="p_del">-	__be32 reason;</span>
<span class="p_del">-	__be32 auth_type;</span>
<span class="p_del">-	__be32 datalen;</span>
<span class="p_del">-	u8 addr[ETH_ALEN];</span>
<span class="p_del">-	char ifname[IFNAMSIZ];</span>
<span class="p_del">-	u8 ifidx;</span>
<span class="p_del">-	u8 bsscfgidx;</span>
<span class="p_del">-} __packed;</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * struct brcmf_event - contents of broadcom event packet.</span>
<span class="p_del">- *</span>
<span class="p_del">- * @eth: standard ether header.</span>
<span class="p_del">- * @hdr: broadcom specific ether header.</span>
<span class="p_del">- * @msg: common part of the actual event message.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct brcmf_event {</span>
<span class="p_del">-	struct ethhdr eth;</span>
<span class="p_del">-	struct brcm_ethhdr hdr;</span>
<span class="p_del">-	struct brcmf_event_msg_be msg;</span>
<span class="p_del">-} __packed;</span>
<span class="p_del">-</span>
 /**
  * struct brcmf_fweh_queue_item - event item on event queue.
  *
<span class="p_chunk">@@ -85,6 +41,7 @@</span> <span class="p_context"> struct brcmf_fweh_queue_item {</span>
 	u8 ifidx;
 	u8 ifaddr[ETH_ALEN];
 	struct brcmf_event_msg_be emsg;
<span class="p_add">+	u32 datalen;</span>
 	u8 data[0];
 };
 
<span class="p_chunk">@@ -292,6 +249,11 @@</span> <span class="p_context"> static void brcmf_fweh_event_worker(struct work_struct *work)</span>
 		brcmf_dbg_hex_dump(BRCMF_EVENT_ON(), event-&gt;data,
 				   min_t(u32, emsg.datalen, 64),
 				   &quot;event payload, len=%d\n&quot;, emsg.datalen);
<span class="p_add">+		if (emsg.datalen &gt; event-&gt;datalen) {</span>
<span class="p_add">+			brcmf_err(&quot;event invalid length header=%d, msg=%d\n&quot;,</span>
<span class="p_add">+				  event-&gt;datalen, emsg.datalen);</span>
<span class="p_add">+			goto event_free;</span>
<span class="p_add">+		}</span>
 
 		/* special handling of interface event */
 		if (event-&gt;code == BRCMF_E_IF) {
<span class="p_chunk">@@ -423,7 +385,8 @@</span> <span class="p_context"> int brcmf_fweh_activate_events(struct brcmf_if *ifp)</span>
  * dispatch the event to a registered handler (using worker).
  */
 void brcmf_fweh_process_event(struct brcmf_pub *drvr,
<span class="p_del">-			      struct brcmf_event *event_packet)</span>
<span class="p_add">+			      struct brcmf_event *event_packet,</span>
<span class="p_add">+			      u32 packet_len)</span>
 {
 	enum brcmf_fweh_event_code code;
 	struct brcmf_fweh_info *fweh = &amp;drvr-&gt;fweh;
<span class="p_chunk">@@ -443,6 +406,10 @@</span> <span class="p_context"> void brcmf_fweh_process_event(struct brcmf_pub *drvr,</span>
 	if (code != BRCMF_E_IF &amp;&amp; !fweh-&gt;evt_handler[code])
 		return;
 
<span class="p_add">+	if (datalen &gt; BRCMF_DCMD_MAXLEN ||</span>
<span class="p_add">+	    datalen + sizeof(*event_packet) &gt; packet_len)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (in_interrupt())
 		alloc_flag = GFP_ATOMIC;
 
<span class="p_chunk">@@ -456,6 +423,7 @@</span> <span class="p_context"> void brcmf_fweh_process_event(struct brcmf_pub *drvr,</span>
 	/* use memcpy to get aligned event message */
 	memcpy(&amp;event-&gt;emsg, &amp;event_packet-&gt;msg, sizeof(event-&gt;emsg));
 	memcpy(event-&gt;data, data, datalen);
<span class="p_add">+	event-&gt;datalen = datalen;</span>
 	memcpy(event-&gt;ifaddr, event_packet-&gt;eth.h_dest, ETH_ALEN);
 
 	brcmf_fweh_queue_event(fweh, event);
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/fweh.h b/drivers/net/wireless/brcm80211/brcmfmac/fweh.h</span>
<span class="p_header">index d26b47698f68..9b5416193bf6 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/fweh.h</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/fweh.h</span>
<span class="p_chunk">@@ -27,7 +27,6 @@</span> <span class="p_context"></span>
 struct brcmf_pub;
 struct brcmf_if;
 struct brcmf_cfg80211_info;
<span class="p_del">-struct brcmf_event;</span>
 
 /* list of firmware events */
 #define BRCMF_FWEH_EVENT_ENUM_DEFLIST \
<span class="p_chunk">@@ -173,12 +172,54 @@</span> <span class="p_context"> enum brcmf_fweh_event_code {</span>
 /**
  * definitions for event packet validation.
  */
<span class="p_del">-#define BRCMF_EVENT_OUI_OFFSET		19</span>
<span class="p_del">-#define BRCM_OUI			&quot;\x00\x10\x18&quot;</span>
<span class="p_del">-#define DOT11_OUI_LEN			3</span>
<span class="p_del">-#define BCMILCP_BCM_SUBTYPE_EVENT	1</span>
<span class="p_add">+#define BRCM_OUI				&quot;\x00\x10\x18&quot;</span>
<span class="p_add">+#define BCMILCP_BCM_SUBTYPE_EVENT		1</span>
 
 
<span class="p_add">+/**</span>
<span class="p_add">+ * struct brcm_ethhdr - broadcom specific ether header.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @subtype: subtype for this packet.</span>
<span class="p_add">+ * @length: TODO: length of appended data.</span>
<span class="p_add">+ * @version: version indication.</span>
<span class="p_add">+ * @oui: OUI of this packet.</span>
<span class="p_add">+ * @usr_subtype: subtype for this OUI.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct brcm_ethhdr {</span>
<span class="p_add">+	__be16 subtype;</span>
<span class="p_add">+	__be16 length;</span>
<span class="p_add">+	u8 version;</span>
<span class="p_add">+	u8 oui[3];</span>
<span class="p_add">+	__be16 usr_subtype;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
<span class="p_add">+struct brcmf_event_msg_be {</span>
<span class="p_add">+	__be16 version;</span>
<span class="p_add">+	__be16 flags;</span>
<span class="p_add">+	__be32 event_type;</span>
<span class="p_add">+	__be32 status;</span>
<span class="p_add">+	__be32 reason;</span>
<span class="p_add">+	__be32 auth_type;</span>
<span class="p_add">+	__be32 datalen;</span>
<span class="p_add">+	u8 addr[ETH_ALEN];</span>
<span class="p_add">+	char ifname[IFNAMSIZ];</span>
<span class="p_add">+	u8 ifidx;</span>
<span class="p_add">+	u8 bsscfgidx;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * struct brcmf_event - contents of broadcom event packet.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @eth: standard ether header.</span>
<span class="p_add">+ * @hdr: broadcom specific ether header.</span>
<span class="p_add">+ * @msg: common part of the actual event message.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct brcmf_event {</span>
<span class="p_add">+	struct ethhdr eth;</span>
<span class="p_add">+	struct brcm_ethhdr hdr;</span>
<span class="p_add">+	struct brcmf_event_msg_be msg;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
 /**
  * struct brcmf_event_msg - firmware event message.
  *
<span class="p_chunk">@@ -247,33 +288,34 @@</span> <span class="p_context"> void brcmf_fweh_unregister(struct brcmf_pub *drvr,</span>
 			   enum brcmf_fweh_event_code code);
 int brcmf_fweh_activate_events(struct brcmf_if *ifp);
 void brcmf_fweh_process_event(struct brcmf_pub *drvr,
<span class="p_del">-			      struct brcmf_event *event_packet);</span>
<span class="p_add">+			      struct brcmf_event *event_packet,</span>
<span class="p_add">+			      u32 packet_len);</span>
 
 static inline void brcmf_fweh_process_skb(struct brcmf_pub *drvr,
 					  struct sk_buff *skb)
 {
 	struct brcmf_event *event_packet;
<span class="p_del">-	u8 *data;</span>
 	u16 usr_stype;
 
 	/* only process events when protocol matches */
 	if (skb-&gt;protocol != cpu_to_be16(ETH_P_LINK_CTL))
 		return;
 
<span class="p_add">+	if ((skb-&gt;len + ETH_HLEN) &lt; sizeof(*event_packet))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* check for BRCM oui match */
 	event_packet = (struct brcmf_event *)skb_mac_header(skb);
<span class="p_del">-	data = (u8 *)event_packet;</span>
<span class="p_del">-	data += BRCMF_EVENT_OUI_OFFSET;</span>
<span class="p_del">-	if (memcmp(BRCM_OUI, data, DOT11_OUI_LEN))</span>
<span class="p_add">+	if (memcmp(BRCM_OUI, &amp;event_packet-&gt;hdr.oui[0],</span>
<span class="p_add">+		   sizeof(event_packet-&gt;hdr.oui)))</span>
 		return;
 
 	/* final match on usr_subtype */
<span class="p_del">-	data += DOT11_OUI_LEN;</span>
<span class="p_del">-	usr_stype = get_unaligned_be16(data);</span>
<span class="p_add">+	usr_stype = get_unaligned_be16(&amp;event_packet-&gt;hdr.usr_subtype);</span>
 	if (usr_stype != BCMILCP_BCM_SUBTYPE_EVENT)
 		return;
 
<span class="p_del">-	brcmf_fweh_process_event(drvr, event_packet);</span>
<span class="p_add">+	brcmf_fweh_process_event(drvr, event_packet, skb-&gt;len + ETH_HLEN);</span>
 }
 
 #endif /* FWEH_H_ */
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/p2p.c b/drivers/net/wireless/brcm80211/brcmfmac/p2p.c</span>
<span class="p_header">index f3445ac627e4..b489476532df 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/p2p.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/p2p.c</span>
<span class="p_chunk">@@ -1363,6 +1363,11 @@</span> <span class="p_context"> int brcmf_p2p_notify_action_frame_rx(struct brcmf_if *ifp,</span>
 	u16 mgmt_type;
 	u8 action;
 
<span class="p_add">+	if (e-&gt;datalen &lt; sizeof(*rxframe)) {</span>
<span class="p_add">+		brcmf_dbg(SCAN, &quot;Event data to small. Ignore\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ch.chspec = be16_to_cpu(rxframe-&gt;chanspec);
 	cfg-&gt;d11inf.decchspec(&amp;ch);
 	/* Check if wpa_supplicant has registered for this frame */
<span class="p_chunk">@@ -1861,6 +1866,11 @@</span> <span class="p_context"> s32 brcmf_p2p_notify_rx_mgmt_p2p_probereq(struct brcmf_if *ifp,</span>
 	brcmf_dbg(INFO, &quot;Enter: event %d reason %d\n&quot;, e-&gt;event_code,
 		  e-&gt;reason);
 
<span class="p_add">+	if (e-&gt;datalen &lt; sizeof(*rxframe)) {</span>
<span class="p_add">+		brcmf_dbg(SCAN, &quot;Event data to small. Ignore\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ch.chspec = be16_to_cpu(rxframe-&gt;chanspec);
 	cfg-&gt;d11inf.decchspec(&amp;ch);
 
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c b/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c</span>
<span class="p_header">index 26c5f3bdf2c5..c3e0a9aecd42 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c</span>
<span class="p_chunk">@@ -3036,6 +3036,11 @@</span> <span class="p_context"> brcmf_notify_sched_scan_results(struct brcmf_if *ifp,</span>
 
 	brcmf_dbg(SCAN, &quot;Enter\n&quot;);
 
<span class="p_add">+	if (e-&gt;datalen &lt; (sizeof(*pfn_result) + sizeof(*netinfo))) {</span>
<span class="p_add">+		brcmf_dbg(SCAN, &quot;Event data to small. Ignore\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (e-&gt;event_code == BRCMF_E_PFN_NET_LOST) {
 		brcmf_dbg(SCAN, &quot;PFN NET LOST event. Do Nothing\n&quot;);
 		return 0;
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index e83644dfaa6c..15175dd0cf86 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -1004,6 +1004,11 @@</span> <span class="p_context"> static void iwl_mvm_mc_iface_iterator(void *_data, u8 *mac,</span>
 	struct iwl_mvm_mc_iter_data *data = _data;
 	struct iwl_mvm *mvm = data-&gt;mvm;
 	struct iwl_mcast_filter_cmd *cmd = mvm-&gt;mcast_filter_cmd;
<span class="p_add">+	struct iwl_host_cmd hcmd = {</span>
<span class="p_add">+		.id = MCAST_FILTER_CMD,</span>
<span class="p_add">+		.flags = CMD_ASYNC,</span>
<span class="p_add">+		.dataflags[0] = IWL_HCMD_DFL_NOCOPY,</span>
<span class="p_add">+	};</span>
 	int ret, len;
 
 	/* if we don&#39;t have free ports, mcast frames will be dropped */
<span class="p_chunk">@@ -1018,7 +1023,10 @@</span> <span class="p_context"> static void iwl_mvm_mc_iface_iterator(void *_data, u8 *mac,</span>
 	memcpy(cmd-&gt;bssid, vif-&gt;bss_conf.bssid, ETH_ALEN);
 	len = roundup(sizeof(*cmd) + cmd-&gt;count * ETH_ALEN, 4);
 
<span class="p_del">-	ret = iwl_mvm_send_cmd_pdu(mvm, MCAST_FILTER_CMD, CMD_ASYNC, len, cmd);</span>
<span class="p_add">+	hcmd.len[0] = len;</span>
<span class="p_add">+	hcmd.data[0] = cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = iwl_mvm_send_cmd(mvm, &amp;hcmd);</span>
 	if (ret)
 		IWL_ERR(mvm, &quot;mcast filter cmd error. ret=%d\n&quot;, ret);
 }
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index 0ca2961a56a2..a8c9a4a361fb 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -514,7 +514,7 @@</span> <span class="p_context"> static ssize_t driver_override_store(struct device *dev,</span>
 				     const char *buf, size_t count)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
<span class="p_del">-	char *driver_override, *old = pdev-&gt;driver_override, *cp;</span>
<span class="p_add">+	char *driver_override, *old, *cp;</span>
 
 	/* We need to keep extra room for a newline */
 	if (count &gt;= (PAGE_SIZE - 1))
<span class="p_chunk">@@ -528,12 +528,15 @@</span> <span class="p_context"> static ssize_t driver_override_store(struct device *dev,</span>
 	if (cp)
 		*cp = &#39;\0&#39;;
 
<span class="p_add">+	device_lock(dev);</span>
<span class="p_add">+	old = pdev-&gt;driver_override;</span>
 	if (strlen(driver_override)) {
 		pdev-&gt;driver_override = driver_override;
 	} else {
 		kfree(driver_override);
 		pdev-&gt;driver_override = NULL;
 	}
<span class="p_add">+	device_unlock(dev);</span>
 
 	kfree(old);
 
<span class="p_chunk">@@ -544,8 +547,12 @@</span> <span class="p_context"> static ssize_t driver_override_show(struct device *dev,</span>
 				    struct device_attribute *attr, char *buf)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
<span class="p_add">+	ssize_t len;</span>
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, pdev-&gt;driver_override);</span>
<span class="p_add">+	device_lock(dev);</span>
<span class="p_add">+	len = snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, pdev-&gt;driver_override);</span>
<span class="p_add">+	device_unlock(dev);</span>
<span class="p_add">+	return len;</span>
 }
 static DEVICE_ATTR_RW(driver_override);
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_aux.c b/drivers/s390/scsi/zfcp_aux.c</span>
<span class="p_header">index 8004b071a9f2..a7a0b3e4f5ea 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_aux.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_aux.c</span>
<span class="p_chunk">@@ -356,6 +356,8 @@</span> <span class="p_context"> struct zfcp_adapter *zfcp_adapter_enqueue(struct ccw_device *ccw_device)</span>
 	INIT_WORK(&amp;adapter-&gt;scan_work, zfcp_fc_scan_ports);
 	INIT_WORK(&amp;adapter-&gt;ns_up_work, zfcp_fc_sym_name_update);
 
<span class="p_add">+	adapter-&gt;erp_action.adapter = adapter;</span>
<span class="p_add">+</span>
 	if (zfcp_qdio_setup(adapter))
 		goto failed;
 
<span class="p_chunk">@@ -512,6 +514,9 @@</span> <span class="p_context"> struct zfcp_port *zfcp_port_enqueue(struct zfcp_adapter *adapter, u64 wwpn,</span>
 	port-&gt;dev.groups = zfcp_port_attr_groups;
 	port-&gt;dev.release = zfcp_port_release;
 
<span class="p_add">+	port-&gt;erp_action.adapter = adapter;</span>
<span class="p_add">+	port-&gt;erp_action.port = port;</span>
<span class="p_add">+</span>
 	if (dev_set_name(&amp;port-&gt;dev, &quot;0x%016llx&quot;, (unsigned long long)wwpn)) {
 		kfree(port);
 		goto err_out;
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_erp.c b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">index acb0b8c3989d..d9b2949de543 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_chunk">@@ -193,9 +193,8 @@</span> <span class="p_context"> static struct zfcp_erp_action *zfcp_erp_setup_act(int need, u32 act_status,</span>
 		atomic_set_mask(ZFCP_STATUS_COMMON_ERP_INUSE,
 				&amp;zfcp_sdev-&gt;status);
 		erp_action = &amp;zfcp_sdev-&gt;erp_action;
<span class="p_del">-		memset(erp_action, 0, sizeof(struct zfcp_erp_action));</span>
<span class="p_del">-		erp_action-&gt;port = port;</span>
<span class="p_del">-		erp_action-&gt;sdev = sdev;</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;port != port);</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;sdev != sdev);</span>
 		if (!(atomic_read(&amp;zfcp_sdev-&gt;status) &amp;
 		      ZFCP_STATUS_COMMON_RUNNING))
 			act_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;
<span class="p_chunk">@@ -208,8 +207,8 @@</span> <span class="p_context"> static struct zfcp_erp_action *zfcp_erp_setup_act(int need, u32 act_status,</span>
 		zfcp_erp_action_dismiss_port(port);
 		atomic_set_mask(ZFCP_STATUS_COMMON_ERP_INUSE, &amp;port-&gt;status);
 		erp_action = &amp;port-&gt;erp_action;
<span class="p_del">-		memset(erp_action, 0, sizeof(struct zfcp_erp_action));</span>
<span class="p_del">-		erp_action-&gt;port = port;</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;port != port);</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;sdev != NULL);</span>
 		if (!(atomic_read(&amp;port-&gt;status) &amp; ZFCP_STATUS_COMMON_RUNNING))
 			act_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;
 		break;
<span class="p_chunk">@@ -219,7 +218,8 @@</span> <span class="p_context"> static struct zfcp_erp_action *zfcp_erp_setup_act(int need, u32 act_status,</span>
 		zfcp_erp_action_dismiss_adapter(adapter);
 		atomic_set_mask(ZFCP_STATUS_COMMON_ERP_INUSE, &amp;adapter-&gt;status);
 		erp_action = &amp;adapter-&gt;erp_action;
<span class="p_del">-		memset(erp_action, 0, sizeof(struct zfcp_erp_action));</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;port != NULL);</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;sdev != NULL);</span>
 		if (!(atomic_read(&amp;adapter-&gt;status) &amp;
 		      ZFCP_STATUS_COMMON_RUNNING))
 			act_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;
<span class="p_chunk">@@ -229,7 +229,11 @@</span> <span class="p_context"> static struct zfcp_erp_action *zfcp_erp_setup_act(int need, u32 act_status,</span>
 		return NULL;
 	}
 
<span class="p_del">-	erp_action-&gt;adapter = adapter;</span>
<span class="p_add">+	WARN_ON_ONCE(erp_action-&gt;adapter != adapter);</span>
<span class="p_add">+	memset(&amp;erp_action-&gt;list, 0, sizeof(erp_action-&gt;list));</span>
<span class="p_add">+	memset(&amp;erp_action-&gt;timer, 0, sizeof(erp_action-&gt;timer));</span>
<span class="p_add">+	erp_action-&gt;step = ZFCP_ERP_STEP_UNINITIALIZED;</span>
<span class="p_add">+	erp_action-&gt;fsf_req_id = 0;</span>
 	erp_action-&gt;action = need;
 	erp_action-&gt;status = act_status;
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">index b495c085a0b5..0c03ae19b689 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_chunk">@@ -136,10 +136,15 @@</span> <span class="p_context"> static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)</span>
 	struct zfcp_unit *unit;
 	int npiv = adapter-&gt;connection_features &amp; FSF_FEATURE_NPIV_MODE;
 
<span class="p_add">+	zfcp_sdev-&gt;erp_action.adapter = adapter;</span>
<span class="p_add">+	zfcp_sdev-&gt;erp_action.sdev = sdev;</span>
<span class="p_add">+</span>
 	port = zfcp_get_port_by_wwpn(adapter, rport-&gt;port_name);
 	if (!port)
 		return -ENXIO;
 
<span class="p_add">+	zfcp_sdev-&gt;erp_action.port = port;</span>
<span class="p_add">+</span>
 	unit = zfcp_unit_find(port, zfcp_scsi_dev_lun(sdev));
 	if (unit)
 		put_device(&amp;unit-&gt;dev);
<span class="p_header">diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c</span>
<span class="p_header">index 877fd93766ce..fc6801fe134e 100644</span>
<span class="p_header">--- a/drivers/scsi/libiscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/libiscsi.c</span>
<span class="p_chunk">@@ -1727,7 +1727,7 @@</span> <span class="p_context"> int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc)</span>
 
 	if (test_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx)) {
 		reason = FAILURE_SESSION_IN_RECOVERY;
<span class="p_del">-		sc-&gt;result = DID_REQUEUE;</span>
<span class="p_add">+		sc-&gt;result = DID_REQUEUE &lt;&lt; 16;</span>
 		goto fault;
 	}
 
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">index 0813a2dcd3d1..83ff6cba873e 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_chunk">@@ -5242,6 +5242,7 @@</span> <span class="p_context"> lpfc_sli4_driver_resource_setup(struct lpfc_hba *phba)</span>
 			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
 				&quot;2999 Unsupported SLI4 Parameters &quot;
 				&quot;Extents and RPI headers enabled.\n&quot;);
<span class="p_add">+			rc = -EIO;</span>
 			goto out_free_bsmbx;
 		}
 	}
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index c31e1cb009af..cf13b561af83 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -962,6 +962,9 @@</span> <span class="p_context"> static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,</span>
 	if (*bflags &amp; BLIST_NO_DIF)
 		sdev-&gt;no_dif = 1;
 
<span class="p_add">+	if (*bflags &amp; BLIST_UNMAP_LIMIT_WS)</span>
<span class="p_add">+		sdev-&gt;unmap_limit_for_ws = 1;</span>
<span class="p_add">+</span>
 	sdev-&gt;eh_timeout = SCSI_DEFAULT_EH_TIMEOUT;
 
 	if (*bflags &amp; BLIST_TRY_VPD_PAGES)
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 3dcb3c080c1e..c50cfd16a976 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -651,13 +651,21 @@</span> <span class="p_context"> static void sd_config_discard(struct scsi_disk *sdkp, unsigned int mode)</span>
 		break;
 
 	case SD_LBP_WS16:
<span class="p_del">-		max_blocks = min_not_zero(sdkp-&gt;max_ws_blocks,</span>
<span class="p_del">-					  (u32)SD_MAX_WS16_BLOCKS);</span>
<span class="p_add">+		if (sdkp-&gt;device-&gt;unmap_limit_for_ws)</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_unmap_blocks;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_ws_blocks;</span>
<span class="p_add">+</span>
<span class="p_add">+		max_blocks = min_not_zero(max_blocks, (u32)SD_MAX_WS16_BLOCKS);</span>
 		break;
 
 	case SD_LBP_WS10:
<span class="p_del">-		max_blocks = min_not_zero(sdkp-&gt;max_ws_blocks,</span>
<span class="p_del">-					  (u32)SD_MAX_WS10_BLOCKS);</span>
<span class="p_add">+		if (sdkp-&gt;device-&gt;unmap_limit_for_ws)</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_unmap_blocks;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_ws_blocks;</span>
<span class="p_add">+</span>
<span class="p_add">+		max_blocks = min_not_zero(max_blocks, (u32)SD_MAX_WS10_BLOCKS);</span>
 		break;
 
 	case SD_LBP_ZERO:
<span class="p_header">diff --git a/drivers/staging/iio/adc/ad7192.c b/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_header">index 26b2cdca29ad..c7aaf2bb1018 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_chunk">@@ -206,11 +206,9 @@</span> <span class="p_context"> static int ad7192_setup(struct ad7192_state *st,</span>
 	struct iio_dev *indio_dev = spi_get_drvdata(st-&gt;sd.spi);
 	unsigned long long scale_uv;
 	int i, ret, id;
<span class="p_del">-	u8 ones[6];</span>
 
 	/* reset the serial interface */
<span class="p_del">-	memset(&amp;ones, 0xFF, 6);</span>
<span class="p_del">-	ret = spi_write(st-&gt;sd.spi, &amp;ones, 6);</span>
<span class="p_add">+	ret = ad_sd_reset(&amp;st-&gt;sd, 48);</span>
 	if (ret &lt; 0)
 		goto out;
 	msleep(1); /* Wait for at least 500us */
<span class="p_header">diff --git a/drivers/staging/iio/meter/ade7759.c b/drivers/staging/iio/meter/ade7759.c</span>
<span class="p_header">index ea0c9debf8bf..14e3eca3ff35 100644</span>
<span class="p_header">--- a/drivers/staging/iio/meter/ade7759.c</span>
<span class="p_header">+++ b/drivers/staging/iio/meter/ade7759.c</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> static int ade7759_spi_read_reg_40(struct device *dev,</span>
 				reg_address);
 		goto error_ret;
 	}
<span class="p_del">-	*val = ((u64)st-&gt;rx[1] &lt;&lt; 32) | (st-&gt;rx[2] &lt;&lt; 24) |</span>
<span class="p_add">+	*val = ((u64)st-&gt;rx[1] &lt;&lt; 32) | ((u64)st-&gt;rx[2] &lt;&lt; 24) |</span>
 		(st-&gt;rx[3] &lt;&lt; 16) | (st-&gt;rx[4] &lt;&lt; 8) | st-&gt;rx[5];
 
 error_ret:
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index ef71827f92a3..58034df6351b 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1775,6 +1775,9 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	{ USB_DEVICE(0xfff0, 0x0100), /* DATECS FP-2000 */
 	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
 	},
<span class="p_add">+	{ USB_DEVICE(0x09d8, 0x0320), /* Elatec GmbH TWN3 */</span>
<span class="p_add">+	.driver_info = NO_UNION_NORMAL, /* has misplaced union descriptor */</span>
<span class="p_add">+	},</span>
 
 	{ USB_DEVICE(0x2912, 0x0001), /* ATOL FPrint */
 	.driver_info = CLEAR_HALT_CONDITIONS,
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 063d9767d6fe..13d31422d6b7 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -519,6 +519,9 @@</span> <span class="p_context"> static int usb_parse_configuration(struct usb_device *dev, int cfgidx,</span>
 	unsigned iad_num = 0;
 
 	memcpy(&amp;config-&gt;desc, buffer, USB_DT_CONFIG_SIZE);
<span class="p_add">+	nintf = nintf_orig = config-&gt;desc.bNumInterfaces;</span>
<span class="p_add">+	config-&gt;desc.bNumInterfaces = 0;	// Adjusted later</span>
<span class="p_add">+</span>
 	if (config-&gt;desc.bDescriptorType != USB_DT_CONFIG ||
 	    config-&gt;desc.bLength &lt; USB_DT_CONFIG_SIZE ||
 	    config-&gt;desc.bLength &gt; size) {
<span class="p_chunk">@@ -532,7 +535,6 @@</span> <span class="p_context"> static int usb_parse_configuration(struct usb_device *dev, int cfgidx,</span>
 	buffer += config-&gt;desc.bLength;
 	size -= config-&gt;desc.bLength;
 
<span class="p_del">-	nintf = nintf_orig = config-&gt;desc.bNumInterfaces;</span>
 	if (nintf &gt; USB_MAXINTERFACES) {
 		dev_warn(ddev, &quot;config %d has too many interfaces: %d, &quot;
 		    &quot;using maximum allowed: %d\n&quot;,
<span class="p_chunk">@@ -824,7 +826,7 @@</span> <span class="p_context"> int usb_get_configuration(struct usb_device *dev)</span>
 		}
 
 		if (dev-&gt;quirks &amp; USB_QUIRK_DELAY_INIT)
<span class="p_del">-			msleep(100);</span>
<span class="p_add">+			msleep(200);</span>
 
 		result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,
 		    bigbuffer, length);
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 598e9adf8858..b4dd4821d1fd 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -2625,13 +2625,16 @@</span> <span class="p_context"> static int hub_port_wait_reset(struct usb_hub *hub, int port1,</span>
 	if (!(portstatus &amp; USB_PORT_STAT_CONNECTION))
 		return -ENOTCONN;
 
<span class="p_del">-	/* bomb out completely if the connection bounced.  A USB 3.0</span>
<span class="p_del">-	 * connection may bounce if multiple warm resets were issued,</span>
<span class="p_add">+	/* Retry if connect change is set but status is still connected.</span>
<span class="p_add">+	 * A USB 3.0 connection may bounce if multiple warm resets were issued,</span>
 	 * but the device may have successfully re-connected. Ignore it.
 	 */
 	if (!hub_is_superspeed(hub-&gt;hdev) &amp;&amp;
<span class="p_del">-			(portchange &amp; USB_PORT_STAT_C_CONNECTION))</span>
<span class="p_del">-		return -ENOTCONN;</span>
<span class="p_add">+	    (portchange &amp; USB_PORT_STAT_C_CONNECTION)) {</span>
<span class="p_add">+		usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+				       USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_add">+		return -EAGAIN;</span>
<span class="p_add">+	}</span>
 
 	if (!(portstatus &amp; USB_PORT_STAT_ENABLE))
 		return -EBUSY;
<span class="p_chunk">@@ -4699,7 +4702,7 @@</span> <span class="p_context"> static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,</span>
 			goto loop;
 
 		if (udev-&gt;quirks &amp; USB_QUIRK_DELAY_INIT)
<span class="p_del">-			msleep(1000);</span>
<span class="p_add">+			msleep(2000);</span>
 
 		/* consecutive bus-powered hubs aren&#39;t reliable; they can
 		 * violate the voltage drop budget.  if the new child has
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index c9b564e362c8..25d0eed708a3 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -218,6 +218,10 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Corsair Strafe RGB */
 	{ USB_DEVICE(0x1b1c, 0x1b20), .driver_info = USB_QUIRK_DELAY_INIT },
 
<span class="p_add">+	/* MIDI keyboard WORLDE MINI */</span>
<span class="p_add">+	{ USB_DEVICE(0x1c75, 0x0204), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_CONFIG_INTF_STRINGS },</span>
<span class="p_add">+</span>
 	/* Acer C120 LED Projector */
 	{ USB_DEVICE(0x1de1, 0xc102), .driver_info = USB_QUIRK_NO_LPM },
 
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index b8a961ba1d2b..38042f6d9c04 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -1815,6 +1815,8 @@</span> <span class="p_context"> static DEVICE_ATTR_RO(suspended);</span>
 static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
<span class="p_add">+	struct usb_gadget_strings	*gstr = cdev-&gt;driver-&gt;strings[0];</span>
<span class="p_add">+	struct usb_string		*dev_str = gstr-&gt;strings;</span>
 
 	/* composite_disconnect() must already have been called
 	 * by the underlying peripheral controller driver!
<span class="p_chunk">@@ -1834,6 +1836,9 @@</span> <span class="p_context"> static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)</span>
 
 	composite_dev_cleanup(cdev);
 
<span class="p_add">+	if (dev_str[USB_GADGET_MANUFACTURER_IDX].s == cdev-&gt;def_manufacturer)</span>
<span class="p_add">+		dev_str[USB_GADGET_MANUFACTURER_IDX].s = &quot;&quot;;</span>
<span class="p_add">+</span>
 	kfree(cdev-&gt;def_manufacturer);
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);
<span class="p_header">diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c</span>
<span class="p_header">index d20222e56419..8c73186fc0e8 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/dummy_hcd.c</span>
<span class="p_chunk">@@ -173,6 +173,8 @@</span> <span class="p_context"> struct dummy_hcd {</span>
 
 	struct usb_device		*udev;
 	struct list_head		urbp_list;
<span class="p_add">+	struct urbp			*next_frame_urbp;</span>
<span class="p_add">+</span>
 	u32				stream_en_ep;
 	u8				num_stream[30 / 2];
 
<span class="p_chunk">@@ -189,11 +191,13 @@</span> <span class="p_context"> struct dummy {</span>
 	 */
 	struct dummy_ep			ep[DUMMY_ENDPOINTS];
 	int				address;
<span class="p_add">+	int				callback_usage;</span>
 	struct usb_gadget		gadget;
 	struct usb_gadget_driver	*driver;
 	struct dummy_request		fifo_req;
 	u8				fifo_buf[FIFO_SIZE];
 	u16				devstatus;
<span class="p_add">+	unsigned			ints_enabled:1;</span>
 	unsigned			udc_suspended:1;
 	unsigned			pullup:1;
 
<span class="p_chunk">@@ -311,11 +315,10 @@</span> <span class="p_context"> static void set_link_state_by_speed(struct dummy_hcd *dum_hcd)</span>
 			     USB_PORT_STAT_CONNECTION) == 0)
 				dum_hcd-&gt;port_status |=
 					(USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
<span class="p_del">-			if ((dum_hcd-&gt;port_status &amp;</span>
<span class="p_del">-			     USB_PORT_STAT_ENABLE) == 1 &amp;&amp;</span>
<span class="p_del">-				(dum_hcd-&gt;port_status &amp;</span>
<span class="p_del">-				 USB_SS_PORT_LS_U0) == 1 &amp;&amp;</span>
<span class="p_del">-				dum_hcd-&gt;rh_state != DUMMY_RH_SUSPENDED)</span>
<span class="p_add">+			if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_ENABLE) &amp;&amp;</span>
<span class="p_add">+			    (dum_hcd-&gt;port_status &amp;</span>
<span class="p_add">+			     USB_PORT_STAT_LINK_STATE) == USB_SS_PORT_LS_U0 &amp;&amp;</span>
<span class="p_add">+			    dum_hcd-&gt;rh_state != DUMMY_RH_SUSPENDED)</span>
 				dum_hcd-&gt;active = 1;
 		}
 	} else {
<span class="p_chunk">@@ -352,6 +355,7 @@</span> <span class="p_context"> static void set_link_state_by_speed(struct dummy_hcd *dum_hcd)</span>
 static void set_link_state(struct dummy_hcd *dum_hcd)
 {
 	struct dummy *dum = dum_hcd-&gt;dum;
<span class="p_add">+	unsigned int power_bit;</span>
 
 	dum_hcd-&gt;active = 0;
 	if (dum-&gt;pullup)
<span class="p_chunk">@@ -362,36 +366,40 @@</span> <span class="p_context"> static void set_link_state(struct dummy_hcd *dum_hcd)</span>
 			return;
 
 	set_link_state_by_speed(dum_hcd);
<span class="p_add">+	power_bit = (dummy_hcd_to_hcd(dum_hcd)-&gt;speed == HCD_USB3 ?</span>
<span class="p_add">+			USB_SS_PORT_STAT_POWER : USB_PORT_STAT_POWER);</span>
 
 	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0 ||
 	     dum_hcd-&gt;active)
 		dum_hcd-&gt;resuming = 0;
 
 	/* if !connected or reset */
<span class="p_del">-	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0 ||</span>
<span class="p_add">+	if ((dum_hcd-&gt;port_status &amp; power_bit) == 0 ||</span>
 			(dum_hcd-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0) {
 		/*
 		 * We&#39;re connected and not reset (reset occurred now),
 		 * and driver attached - disconnect!
 		 */
<span class="p_del">-		if ((dum_hcd-&gt;old_status &amp; USB_PORT_STAT_CONNECTION) != 0 &amp;&amp;</span>
<span class="p_add">+		if ((dum_hcd-&gt;old_status &amp; power_bit) != 0 &amp;&amp;</span>
 		    (dum_hcd-&gt;old_status &amp; USB_PORT_STAT_RESET) == 0 &amp;&amp;
<span class="p_del">-		    dum-&gt;driver) {</span>
<span class="p_add">+		    dum-&gt;ints_enabled) {</span>
 			stop_activity(dum);
<span class="p_add">+			++dum-&gt;callback_usage;</span>
 			spin_unlock(&amp;dum-&gt;lock);
 			dum-&gt;driver-&gt;disconnect(&amp;dum-&gt;gadget);
 			spin_lock(&amp;dum-&gt;lock);
<span class="p_add">+			--dum-&gt;callback_usage;</span>
 		}
<span class="p_del">-	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active) {</span>
<span class="p_del">-		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active &amp;&amp;</span>
<span class="p_add">+			dum-&gt;ints_enabled) {</span>
<span class="p_add">+		++dum-&gt;callback_usage;</span>
<span class="p_add">+		spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend)</span>
 			dum-&gt;driver-&gt;suspend(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		} else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume)</span>
 			dum-&gt;driver-&gt;resume(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		--dum-&gt;callback_usage;</span>
 	}
 
 	dum_hcd-&gt;old_status = dum_hcd-&gt;port_status;
<span class="p_chunk">@@ -907,9 +915,12 @@</span> <span class="p_context"> static int dummy_udc_start(struct usb_gadget *g,</span>
 	 * can&#39;t enumerate without help from the driver we&#39;re binding.
 	 */
 
<span class="p_add">+	spin_lock_irq(&amp;dum-&gt;lock);</span>
 	dum-&gt;devstatus = 0;
 
 	dum-&gt;driver = driver;
<span class="p_add">+	dum-&gt;ints_enabled = 1;</span>
<span class="p_add">+	spin_unlock_irq(&amp;dum-&gt;lock);</span>
 	dev_dbg(udc_dev(dum), &quot;binding gadget driver &#39;%s&#39;\n&quot;,
 			driver-&gt;driver.name);
 	return 0;
<span class="p_chunk">@@ -925,7 +936,19 @@</span> <span class="p_context"> static int dummy_udc_stop(struct usb_gadget *g,</span>
 		dev_dbg(udc_dev(dum), &quot;unregister gadget driver &#39;%s&#39;\n&quot;,
 				driver-&gt;driver.name);
 
<span class="p_add">+	spin_lock_irq(&amp;dum-&gt;lock);</span>
<span class="p_add">+	dum-&gt;ints_enabled = 0;</span>
<span class="p_add">+	stop_activity(dum);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* emulate synchronize_irq(): wait for callbacks to finish */</span>
<span class="p_add">+	while (dum-&gt;callback_usage &gt; 0) {</span>
<span class="p_add">+		spin_unlock_irq(&amp;dum-&gt;lock);</span>
<span class="p_add">+		usleep_range(1000, 2000);</span>
<span class="p_add">+		spin_lock_irq(&amp;dum-&gt;lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dum-&gt;driver = NULL;
<span class="p_add">+	spin_unlock_irq(&amp;dum-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -974,7 +997,12 @@</span> <span class="p_context"> static int dummy_udc_probe(struct platform_device *pdev)</span>
 	dum = *((void **)dev_get_platdata(&amp;pdev-&gt;dev));
 	dum-&gt;gadget.name = gadget_name;
 	dum-&gt;gadget.ops = &amp;dummy_ops;
<span class="p_del">-	dum-&gt;gadget.max_speed = USB_SPEED_SUPER;</span>
<span class="p_add">+	if (mod_data.is_super_speed)</span>
<span class="p_add">+		dum-&gt;gadget.max_speed = USB_SPEED_SUPER;</span>
<span class="p_add">+	else if (mod_data.is_high_speed)</span>
<span class="p_add">+		dum-&gt;gadget.max_speed = USB_SPEED_HIGH;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		dum-&gt;gadget.max_speed = USB_SPEED_FULL;</span>
 
 	dum-&gt;gadget.dev.parent = &amp;pdev-&gt;dev;
 	init_dummy_udc_hw(dum);
<span class="p_chunk">@@ -1184,6 +1212,8 @@</span> <span class="p_context"> static int dummy_urb_enqueue(</span>
 
 	list_add_tail(&amp;urbp-&gt;urbp_list, &amp;dum_hcd-&gt;urbp_list);
 	urb-&gt;hcpriv = urbp;
<span class="p_add">+	if (!dum_hcd-&gt;next_frame_urbp)</span>
<span class="p_add">+		dum_hcd-&gt;next_frame_urbp = urbp;</span>
 	if (usb_pipetype(urb-&gt;pipe) == PIPE_CONTROL)
 		urb-&gt;error_count = 1;		/* mark as a new urb */
 
<span class="p_chunk">@@ -1446,6 +1476,8 @@</span> <span class="p_context"> static struct dummy_ep *find_endpoint(struct dummy *dum, u8 address)</span>
 	if (!is_active((dum-&gt;gadget.speed == USB_SPEED_SUPER ?
 			dum-&gt;ss_hcd : dum-&gt;hs_hcd)))
 		return NULL;
<span class="p_add">+	if (!dum-&gt;ints_enabled)</span>
<span class="p_add">+		return NULL;</span>
 	if ((address &amp; ~USB_DIR_IN) == 0)
 		return &amp;dum-&gt;ep[0];
 	for (i = 1; i &lt; DUMMY_ENDPOINTS; i++) {
<span class="p_chunk">@@ -1687,6 +1719,7 @@</span> <span class="p_context"> static void dummy_timer(unsigned long _dum_hcd)</span>
 		spin_unlock_irqrestore(&amp;dum-&gt;lock, flags);
 		return;
 	}
<span class="p_add">+	dum_hcd-&gt;next_frame_urbp = NULL;</span>
 
 	for (i = 0; i &lt; DUMMY_ENDPOINTS; i++) {
 		if (!ep_name[i])
<span class="p_chunk">@@ -1703,6 +1736,10 @@</span> <span class="p_context"> static void dummy_timer(unsigned long _dum_hcd)</span>
 		int			type;
 		int			status = -EINPROGRESS;
 
<span class="p_add">+		/* stop when we reach URBs queued after the timer interrupt */</span>
<span class="p_add">+		if (urbp == dum_hcd-&gt;next_frame_urbp)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		urb = urbp-&gt;urb;
 		if (urb-&gt;unlinked)
 			goto return_urb;
<span class="p_chunk">@@ -1782,10 +1819,12 @@</span> <span class="p_context"> static void dummy_timer(unsigned long _dum_hcd)</span>
 			 * until setup() returns; no reentrancy issues etc.
 			 */
 			if (value &gt; 0) {
<span class="p_add">+				++dum-&gt;callback_usage;</span>
 				spin_unlock(&amp;dum-&gt;lock);
 				value = dum-&gt;driver-&gt;setup(&amp;dum-&gt;gadget,
 						&amp;setup);
 				spin_lock(&amp;dum-&gt;lock);
<span class="p_add">+				--dum-&gt;callback_usage;</span>
 
 				if (value &gt;= 0) {
 					/* no delays (max 64KB data stage) */
<span class="p_chunk">@@ -2490,8 +2529,6 @@</span> <span class="p_context"> static struct hc_driver dummy_hcd = {</span>
 	.product_desc =		&quot;Dummy host controller&quot;,
 	.hcd_priv_size =	sizeof(struct dummy_hcd),
 
<span class="p_del">-	.flags =		HCD_USB3 | HCD_SHARED,</span>
<span class="p_del">-</span>
 	.reset =		dummy_setup,
 	.start =		dummy_start,
 	.stop =			dummy_stop,
<span class="p_chunk">@@ -2520,8 +2557,12 @@</span> <span class="p_context"> static int dummy_hcd_probe(struct platform_device *pdev)</span>
 	dev_info(&amp;pdev-&gt;dev, &quot;%s, driver &quot; DRIVER_VERSION &quot;\n&quot;, driver_desc);
 	dum = *((void **)dev_get_platdata(&amp;pdev-&gt;dev));
 
<span class="p_del">-	if (!mod_data.is_super_speed)</span>
<span class="p_add">+	if (mod_data.is_super_speed)</span>
<span class="p_add">+		dummy_hcd.flags = HCD_USB3 | HCD_SHARED;</span>
<span class="p_add">+	else if (mod_data.is_high_speed)</span>
 		dummy_hcd.flags = HCD_USB2;
<span class="p_add">+	else</span>
<span class="p_add">+		dummy_hcd.flags = HCD_USB11;</span>
 	hs_hcd = usb_create_hcd(&amp;dummy_hcd, &amp;pdev-&gt;dev, dev_name(&amp;pdev-&gt;dev));
 	if (!hs_hcd)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c</span>
<span class="p_header">index 2234c3a5ed8e..f0db2ca816c0 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/f_mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/f_mass_storage.c</span>
<span class="p_chunk">@@ -307,8 +307,6 @@</span> <span class="p_context"> struct fsg_common {</span>
 	struct completion	thread_notifier;
 	struct task_struct	*thread_task;
 
<span class="p_del">-	/* Callback functions. */</span>
<span class="p_del">-	const struct fsg_operations	*ops;</span>
 	/* Gadget&#39;s private data. */
 	void			*private_data;
 
<span class="p_chunk">@@ -2498,6 +2496,8 @@</span> <span class="p_context"> static void handle_exception(struct fsg_common *common)</span>
 static int fsg_main_thread(void *common_)
 {
 	struct fsg_common	*common = common_;
<span class="p_add">+	struct fsg_lun		**curlun_it;</span>
<span class="p_add">+	unsigned		i;</span>
 
 	/*
 	 * Allow the thread to be killed by a signal, but set the signal mask
<span class="p_chunk">@@ -2559,22 +2559,18 @@</span> <span class="p_context"> static int fsg_main_thread(void *common_)</span>
 	common-&gt;thread_task = NULL;
 	spin_unlock_irq(&amp;common-&gt;lock);
 
<span class="p_del">-	if (!common-&gt;ops || !common-&gt;ops-&gt;thread_exits</span>
<span class="p_del">-	 || common-&gt;ops-&gt;thread_exits(common) &lt; 0) {</span>
<span class="p_del">-		struct fsg_lun **curlun_it = common-&gt;luns;</span>
<span class="p_del">-		unsigned i = common-&gt;nluns;</span>
<span class="p_add">+	/* Eject media from all LUNs */</span>
<span class="p_add">+	curlun_it = common-&gt;luns;</span>
<span class="p_add">+	i = common-&gt;nluns;</span>
 
<span class="p_del">-		down_write(&amp;common-&gt;filesem);</span>
<span class="p_del">-		for (; i--; ++curlun_it) {</span>
<span class="p_del">-			struct fsg_lun *curlun = *curlun_it;</span>
<span class="p_del">-			if (!curlun || !fsg_lun_is_open(curlun))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+	down_write(&amp;common-&gt;filesem);</span>
<span class="p_add">+	for (; i--; ++curlun_it) {</span>
<span class="p_add">+		struct fsg_lun *curlun = *curlun_it;</span>
 
<span class="p_add">+		if (curlun &amp;&amp; fsg_lun_is_open(curlun))</span>
 			fsg_lun_close(curlun);
<span class="p_del">-			curlun-&gt;unit_attention_data = SS_MEDIUM_NOT_PRESENT;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		up_write(&amp;common-&gt;filesem);</span>
 	}
<span class="p_add">+	up_write(&amp;common-&gt;filesem);</span>
 
 	/* Let fsg_unbind() know the thread has exited */
 	complete_and_exit(&amp;common-&gt;thread_notifier, 0);
<span class="p_chunk">@@ -2842,13 +2838,6 @@</span> <span class="p_context"> int fsg_common_set_nluns(struct fsg_common *common, int nluns)</span>
 }
 EXPORT_SYMBOL_GPL(fsg_common_set_nluns);
 
<span class="p_del">-void fsg_common_set_ops(struct fsg_common *common,</span>
<span class="p_del">-			const struct fsg_operations *ops)</span>
<span class="p_del">-{</span>
<span class="p_del">-	common-&gt;ops = ops;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(fsg_common_set_ops);</span>
<span class="p_del">-</span>
 void fsg_common_free_buffers(struct fsg_common *common)
 {
 	_fsg_common_free_buffers(common-&gt;buffhds, common-&gt;fsg_num_buffers);
<span class="p_header">diff --git a/drivers/usb/gadget/f_mass_storage.h b/drivers/usb/gadget/f_mass_storage.h</span>
<span class="p_header">index b4866fcef30b..bf0fe5cda863 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/f_mass_storage.h</span>
<span class="p_header">+++ b/drivers/usb/gadget/f_mass_storage.h</span>
<span class="p_chunk">@@ -60,17 +60,6 @@</span> <span class="p_context"> struct fsg_module_parameters {</span>
 struct fsg_common;
 
 /* FSF callback functions */
<span class="p_del">-struct fsg_operations {</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Callback function to call when thread exits.  If no</span>
<span class="p_del">-	 * callback is set or it returns value lower then zero MSF</span>
<span class="p_del">-	 * will force eject all LUNs it operates on (including those</span>
<span class="p_del">-	 * marked as non-removable or with prevent_medium_removal flag</span>
<span class="p_del">-	 * set).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	int (*thread_exits)(struct fsg_common *common);</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 struct fsg_lun_opts {
 	struct config_group group;
 	struct fsg_lun *lun;
<span class="p_chunk">@@ -145,9 +134,6 @@</span> <span class="p_context"> void fsg_common_free_luns(struct fsg_common *common);</span>
 
 int fsg_common_set_nluns(struct fsg_common *common, int nluns);
 
<span class="p_del">-void fsg_common_set_ops(struct fsg_common *common,</span>
<span class="p_del">-			const struct fsg_operations *ops);</span>
<span class="p_del">-</span>
 int fsg_common_create_lun(struct fsg_common *common, struct fsg_lun_config *cfg,
 			  unsigned int id, const char *name,
 			  const char **name_pfx);
<span class="p_header">diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c</span>
<span class="p_header">index ac3c91c7e627..0225e6dafaad 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/inode.c</span>
<span class="p_chunk">@@ -26,7 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/poll.h&gt;
 #include &lt;linux/mmu_context.h&gt;
 #include &lt;linux/aio.h&gt;
<span class="p_del">-</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/device.h&gt;
 #include &lt;linux/moduleparam.h&gt;
 
<span class="p_chunk">@@ -113,6 +113,7 @@</span> <span class="p_context"> enum ep0_state {</span>
 struct dev_data {
 	spinlock_t			lock;
 	atomic_t			count;
<span class="p_add">+	int				udc_usage;</span>
 	enum ep0_state			state;		/* P: lock */
 	struct usb_gadgetfs_event	event [N_EVENT];
 	unsigned			ev_next;
<span class="p_chunk">@@ -620,9 +621,9 @@</span> <span class="p_context"> static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)</span>
 		priv-&gt;actual = req-&gt;actual;
 		schedule_work(&amp;priv-&gt;work);
 	}
<span class="p_del">-	spin_unlock(&amp;epdata-&gt;dev-&gt;lock);</span>
 
 	usb_ep_free_request(ep, req);
<span class="p_add">+	spin_unlock(&amp;epdata-&gt;dev-&gt;lock);</span>
 	put_ep(epdata);
 }
 
<span class="p_chunk">@@ -1011,9 +1012,11 @@</span> <span class="p_context"> ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)</span>
 			struct usb_request	*req = dev-&gt;req;
 
 			if ((retval = setup_req (ep, req, 0)) == 0) {
<span class="p_add">+				++dev-&gt;udc_usage;</span>
 				spin_unlock_irq (&amp;dev-&gt;lock);
 				retval = usb_ep_queue (ep, req, GFP_KERNEL);
 				spin_lock_irq (&amp;dev-&gt;lock);
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 			}
 			dev-&gt;state = STATE_DEV_CONNECTED;
 
<span class="p_chunk">@@ -1055,11 +1058,14 @@</span> <span class="p_context"> ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)</span>
 				retval = -EIO;
 			else {
 				len = min (len, (size_t)dev-&gt;req-&gt;actual);
<span class="p_del">-// FIXME don&#39;t call this with the spinlock held ...</span>
<span class="p_add">+				++dev-&gt;udc_usage;</span>
<span class="p_add">+				spin_unlock_irq(&amp;dev-&gt;lock);</span>
 				if (copy_to_user (buf, dev-&gt;req-&gt;buf, len))
 					retval = -EFAULT;
 				else
 					retval = len;
<span class="p_add">+				spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 				clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
 				/* NOTE userspace can&#39;t yet choose to stall */
 			}
<span class="p_chunk">@@ -1205,6 +1211,7 @@</span> <span class="p_context"> ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 			retval = setup_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req, len);
 			if (retval == 0) {
 				dev-&gt;state = STATE_DEV_CONNECTED;
<span class="p_add">+				++dev-&gt;udc_usage;</span>
 				spin_unlock_irq (&amp;dev-&gt;lock);
 				if (copy_from_user (dev-&gt;req-&gt;buf, buf, len))
 					retval = -EFAULT;
<span class="p_chunk">@@ -1215,12 +1222,13 @@</span> <span class="p_context"> ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 						dev-&gt;gadget-&gt;ep0, dev-&gt;req,
 						GFP_KERNEL);
 				}
<span class="p_add">+				spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 				if (retval &lt; 0) {
<span class="p_del">-					spin_lock_irq (&amp;dev-&gt;lock);</span>
 					clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
<span class="p_del">-					spin_unlock_irq (&amp;dev-&gt;lock);</span>
 				} else
 					retval = len;
<span class="p_add">+				spin_unlock_irq(&amp;dev-&gt;lock);</span>
 
 				return retval;
 			}
<span class="p_chunk">@@ -1313,9 +1321,21 @@</span> <span class="p_context"> static long dev_ioctl (struct file *fd, unsigned code, unsigned long value)</span>
 	struct usb_gadget	*gadget = dev-&gt;gadget;
 	long ret = -ENOTTY;
 
<span class="p_del">-	if (gadget-&gt;ops-&gt;ioctl)</span>
<span class="p_add">+	spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+	if (dev-&gt;state == STATE_DEV_OPENED ||</span>
<span class="p_add">+			dev-&gt;state == STATE_DEV_UNBOUND) {</span>
<span class="p_add">+		/* Not bound to a UDC */</span>
<span class="p_add">+	} else if (gadget-&gt;ops-&gt;ioctl) {</span>
<span class="p_add">+		++dev-&gt;udc_usage;</span>
<span class="p_add">+		spin_unlock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+</span>
 		ret = gadget-&gt;ops-&gt;ioctl (gadget, code, value);
 
<span class="p_add">+		spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+		--dev-&gt;udc_usage;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1546,10 +1566,12 @@</span> <span class="p_context"> gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 				if (value &lt; 0)
 					break;
 
<span class="p_add">+				++dev-&gt;udc_usage;</span>
 				spin_unlock (&amp;dev-&gt;lock);
 				value = usb_ep_queue (gadget-&gt;ep0, dev-&gt;req,
 							GFP_KERNEL);
 				spin_lock (&amp;dev-&gt;lock);
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 				if (value &lt; 0) {
 					clean_req (gadget-&gt;ep0, dev-&gt;req);
 					break;
<span class="p_chunk">@@ -1573,8 +1595,12 @@</span> <span class="p_context"> gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 		req-&gt;length = value;
 		req-&gt;zero = value &lt; w_length;
 
<span class="p_add">+		++dev-&gt;udc_usage;</span>
 		spin_unlock (&amp;dev-&gt;lock);
 		value = usb_ep_queue (gadget-&gt;ep0, req, GFP_KERNEL);
<span class="p_add">+		spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_add">+		--dev-&gt;udc_usage;</span>
<span class="p_add">+		spin_unlock(&amp;dev-&gt;lock);</span>
 		if (value &lt; 0) {
 			DBG (dev, &quot;ep_queue --&gt; %d\n&quot;, value);
 			req-&gt;status = 0;
<span class="p_chunk">@@ -1601,21 +1627,24 @@</span> <span class="p_context"> static void destroy_ep_files (struct dev_data *dev)</span>
 		/* break link to FS */
 		ep = list_first_entry (&amp;dev-&gt;epfiles, struct ep_data, epfiles);
 		list_del_init (&amp;ep-&gt;epfiles);
<span class="p_add">+		spin_unlock_irq (&amp;dev-&gt;lock);</span>
<span class="p_add">+</span>
 		dentry = ep-&gt;dentry;
 		ep-&gt;dentry = NULL;
 		parent = dentry-&gt;d_parent-&gt;d_inode;
 
 		/* break link to controller */
<span class="p_add">+		mutex_lock(&amp;ep-&gt;lock);</span>
 		if (ep-&gt;state == STATE_EP_ENABLED)
 			(void) usb_ep_disable (ep-&gt;ep);
 		ep-&gt;state = STATE_EP_UNBOUND;
 		usb_ep_free_request (ep-&gt;ep, ep-&gt;req);
 		ep-&gt;ep = NULL;
<span class="p_add">+		mutex_unlock(&amp;ep-&gt;lock);</span>
<span class="p_add">+</span>
 		wake_up (&amp;ep-&gt;wait);
 		put_ep (ep);
 
<span class="p_del">-		spin_unlock_irq (&amp;dev-&gt;lock);</span>
<span class="p_del">-</span>
 		/* break link to dcache */
 		mutex_lock (&amp;parent-&gt;i_mutex);
 		d_delete (dentry);
<span class="p_chunk">@@ -1688,6 +1717,11 @@</span> <span class="p_context"> gadgetfs_unbind (struct usb_gadget *gadget)</span>
 
 	spin_lock_irq (&amp;dev-&gt;lock);
 	dev-&gt;state = STATE_DEV_UNBOUND;
<span class="p_add">+	while (dev-&gt;udc_usage &gt; 0) {</span>
<span class="p_add">+		spin_unlock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+		usleep_range(1000, 2000);</span>
<span class="p_add">+		spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irq (&amp;dev-&gt;lock);
 
 	destroy_ep_files (dev);
<span class="p_chunk">@@ -1764,9 +1798,10 @@</span> <span class="p_context"> static void</span>
 gadgetfs_suspend (struct usb_gadget *gadget)
 {
 	struct dev_data		*dev = get_gadget_data (gadget);
<span class="p_add">+	unsigned long		flags;</span>
 
 	INFO (dev, &quot;suspended from state %d\n&quot;, dev-&gt;state);
<span class="p_del">-	spin_lock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dev-&gt;lock, flags);</span>
 	switch (dev-&gt;state) {
 	case STATE_DEV_SETUP:		// VERY odd... host died??
 	case STATE_DEV_CONNECTED:
<span class="p_chunk">@@ -1777,7 +1812,7 @@</span> <span class="p_context"> gadgetfs_suspend (struct usb_gadget *gadget)</span>
 	default:
 		break;
 	}
<span class="p_del">-	spin_unlock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</span>
 }
 
 static struct usb_gadget_driver gadgetfs_driver = {
<span class="p_header">diff --git a/drivers/usb/gadget/mass_storage.c b/drivers/usb/gadget/mass_storage.c</span>
<span class="p_header">index 8e27a8c96444..c7ca12a109e1 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/mass_storage.c</span>
<span class="p_chunk">@@ -121,15 +121,6 @@</span> <span class="p_context"> static unsigned int fsg_num_buffers = CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS;</span>
 
 FSG_MODULE_PARAMETERS(/* no prefix */, mod_data);
 
<span class="p_del">-static unsigned long msg_registered;</span>
<span class="p_del">-static void msg_cleanup(void);</span>
<span class="p_del">-</span>
<span class="p_del">-static int msg_thread_exits(struct fsg_common *common)</span>
<span class="p_del">-{</span>
<span class="p_del">-	msg_cleanup();</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int __init msg_do_config(struct usb_configuration *c)
 {
 	struct fsg_opts *opts;
<span class="p_chunk">@@ -172,9 +163,6 @@</span> <span class="p_context"> static struct usb_configuration msg_config_driver = {</span>
 
 static int __init msg_bind(struct usb_composite_dev *cdev)
 {
<span class="p_del">-	static const struct fsg_operations ops = {</span>
<span class="p_del">-		.thread_exits = msg_thread_exits,</span>
<span class="p_del">-	};</span>
 	struct fsg_opts *opts;
 	struct fsg_config config;
 	int status;
<span class="p_chunk">@@ -195,8 +183,6 @@</span> <span class="p_context"> static int __init msg_bind(struct usb_composite_dev *cdev)</span>
 	if (status)
 		goto fail_set_nluns;
 
<span class="p_del">-	fsg_common_set_ops(opts-&gt;common, &amp;ops);</span>
<span class="p_del">-</span>
 	status = fsg_common_set_cdev(opts-&gt;common, cdev, config.can_stall);
 	if (status)
 		goto fail_set_cdev;
<span class="p_chunk">@@ -221,7 +207,6 @@</span> <span class="p_context"> static int __init msg_bind(struct usb_composite_dev *cdev)</span>
 	usb_composite_overwrite_options(cdev, &amp;coverwrite);
 	dev_info(&amp;cdev-&gt;gadget-&gt;dev,
 		 DRIVER_DESC &quot;, version: &quot; DRIVER_VERSION &quot;\n&quot;);
<span class="p_del">-	set_bit(0, &amp;msg_registered);</span>
 	return 0;
 
 fail_string_ids:
<span class="p_chunk">@@ -268,9 +253,8 @@</span> <span class="p_context"> static int __init msg_init(void)</span>
 }
 module_init(msg_init);
 
<span class="p_del">-static void msg_cleanup(void)</span>
<span class="p_add">+static void __exit msg_cleanup(void)</span>
 {
<span class="p_del">-	if (test_and_clear_bit(0, &amp;msg_registered))</span>
<span class="p_del">-		usb_composite_unregister(&amp;msg_driver);</span>
<span class="p_add">+	usb_composite_unregister(&amp;msg_driver);</span>
 }
 module_exit(msg_cleanup);
<span class="p_header">diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c</span>
<span class="p_header">index 300b3a71383b..b464ed5e129e 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/net2280.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/net2280.c</span>
<span class="p_chunk">@@ -1941,11 +1941,8 @@</span> <span class="p_context"> stop_activity (struct net2280 *dev, struct usb_gadget_driver *driver)</span>
 		nuke (&amp;dev-&gt;ep [i]);
 
 	/* report disconnect; the driver is already quiesced */
<span class="p_del">-	if (driver) {</span>
<span class="p_del">-		spin_unlock(&amp;dev-&gt;lock);</span>
<span class="p_add">+	if (driver)</span>
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
<span class="p_del">-		spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_del">-	}</span>
 
 	usb_reinit (dev);
 }
<span class="p_header">diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">index 677b3714557e..67733f044c22 100644</span>
<span class="p_header">--- a/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">+++ b/drivers/usb/host/pci-quirks.c</span>
<span class="p_chunk">@@ -1024,7 +1024,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(usb_disable_xhci_ports);</span>
  *
  * Takes care of the handoff between the Pre-OS (i.e. BIOS) and the OS.
  * It signals to the BIOS that the OS wants control of the host controller,
<span class="p_del">- * and then waits 5 seconds for the BIOS to hand over control.</span>
<span class="p_add">+ * and then waits 1 second for the BIOS to hand over control.</span>
  * If we timeout, assume the BIOS is broken and take control anyway.
  */
 static void quirk_usb_handoff_xhci(struct pci_dev *pdev)
<span class="p_chunk">@@ -1070,9 +1070,9 @@</span> <span class="p_context"> static void quirk_usb_handoff_xhci(struct pci_dev *pdev)</span>
 	if (val &amp; XHCI_HC_BIOS_OWNED) {
 		writel(val | XHCI_HC_OS_OWNED, base + ext_cap_offset);
 
<span class="p_del">-		/* Wait for 5 seconds with 10 microsecond polling interval */</span>
<span class="p_add">+		/* Wait for 1 second with 10 microsecond polling interval */</span>
 		timeout = handshake(base + ext_cap_offset, XHCI_HC_BIOS_OWNED,
<span class="p_del">-				0, 5000, 10);</span>
<span class="p_add">+				0, 1000000, 10);</span>
 
 		/* Assume a buggy BIOS and take HC ownership anyway */
 		if (timeout) {
<span class="p_chunk">@@ -1100,7 +1100,7 @@</span> <span class="p_context"> static void quirk_usb_handoff_xhci(struct pci_dev *pdev)</span>
 	 * operational or runtime registers.  Wait 5 seconds and no more.
 	 */
 	timeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_CNR, 0,
<span class="p_del">-			5000, 10);</span>
<span class="p_add">+			5000000, 10);</span>
 	/* Assume a buggy HC and start HC initialization anyway */
 	if (timeout) {
 		val = readl(op_reg_base + XHCI_STS_OFFSET);
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 76628f9e39ba..f16bf70b54ba 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -293,15 +293,25 @@</span> <span class="p_context"> static int xhci_stop_device(struct xhci_hcd *xhci, int slot_id, int suspend)</span>
 						     GFP_NOWAIT);
 			if (!command) {
 				spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_del">-				xhci_free_command(xhci, cmd);</span>
<span class="p_del">-				return -ENOMEM;</span>
<span class="p_add">+				ret = -ENOMEM;</span>
<span class="p_add">+				goto cmd_cleanup;</span>
<span class="p_add">+			}</span>
 
<span class="p_add">+			ret = xhci_queue_stop_endpoint(xhci, command, slot_id,</span>
<span class="p_add">+						       i, suspend);</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_add">+				xhci_free_command(xhci, command);</span>
<span class="p_add">+				goto cmd_cleanup;</span>
 			}
<span class="p_del">-			xhci_queue_stop_endpoint(xhci, command, slot_id, i,</span>
<span class="p_del">-						 suspend);</span>
 		}
 	}
<span class="p_del">-	xhci_queue_stop_endpoint(xhci, cmd, slot_id, 0, suspend);</span>
<span class="p_add">+	ret = xhci_queue_stop_endpoint(xhci, cmd, slot_id, 0, suspend);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_add">+		goto cmd_cleanup;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	xhci_ring_cmd_db(xhci);
 	spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
 
<span class="p_chunk">@@ -312,6 +322,8 @@</span> <span class="p_context"> static int xhci_stop_device(struct xhci_hcd *xhci, int slot_id, int suspend)</span>
 		xhci_warn(xhci, &quot;Timeout while waiting for stop endpoint command\n&quot;);
 		ret = -ETIME;
 	}
<span class="p_add">+</span>
<span class="p_add">+cmd_cleanup:</span>
 	xhci_free_command(xhci, cmd);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 746ffa720ae4..08057459c8e6 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1437,7 +1437,7 @@</span> <span class="p_context"> struct xhci_bus_state {</span>
 
 static inline unsigned int hcd_index(struct usb_hcd *hcd)
 {
<span class="p_del">-	if (hcd-&gt;speed == HCD_USB3)</span>
<span class="p_add">+	if (hcd-&gt;speed &gt;= HCD_USB3)</span>
 		return 0;
 	else
 		return 1;
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index 2a540e4b5c61..70d4b6ed21a3 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -261,11 +261,26 @@</span> <span class="p_context"> static void usbhsf_fifo_clear(struct usbhs_pipe *pipe,</span>
 			      struct usbhs_fifo *fifo)
 {
 	struct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);
<span class="p_add">+	int ret = 0;</span>
 
<span class="p_del">-	if (!usbhs_pipe_is_dcp(pipe))</span>
<span class="p_del">-		usbhsf_fifo_barrier(priv, fifo);</span>
<span class="p_add">+	if (!usbhs_pipe_is_dcp(pipe)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This driver checks the pipe condition first to avoid -EBUSY</span>
<span class="p_add">+		 * from usbhsf_fifo_barrier() with about 10 msec delay in</span>
<span class="p_add">+		 * the interrupt handler if the pipe is RX direction and empty.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (usbhs_pipe_is_dir_in(pipe))</span>
<span class="p_add">+			ret = usbhs_pipe_is_accessible(pipe);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			ret = usbhsf_fifo_barrier(priv, fifo);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	usbhs_write(priv, fifo-&gt;ctr, BCLR);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * if non-DCP pipe, this driver should set BCLR when</span>
<span class="p_add">+	 * usbhsf_fifo_barrier() returns 0.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		usbhs_write(priv, fifo-&gt;ctr, BCLR);</span>
 }
 
 static int usbhsf_fifo_rcv_len(struct usbhs_priv *priv,
<span class="p_chunk">@@ -813,9 +828,9 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 	dev_dbg(dev, &quot;  %s %d (%d/ %d)\n&quot;,
 		fifo-&gt;name, usbhs_pipe_number(pipe), pkt-&gt;length, pkt-&gt;zero);
 
<span class="p_del">-	usbhsf_dma_start(pipe, fifo);</span>
 	usbhs_pipe_set_trans_count_if_bulk(pipe, pkt-&gt;trans);
 	dma_async_issue_pending(chan);
<span class="p_add">+	usbhsf_dma_start(pipe, fifo);</span>
 	usbhs_pipe_enable(pipe);
 
 xfer_work_end:
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 8f8f4aed5fbb..13395320f9bc 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -170,6 +170,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
 	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */
<span class="p_add">+	{ USB_DEVICE(0x18EF, 0xE032) }, /* ELV TFD500 Data Logger */</span>
 	{ USB_DEVICE(0x1901, 0x0190) }, /* GE B850 CP2105 Recorder interface */
 	{ USB_DEVICE(0x1901, 0x0193) }, /* GE B650 CP2104 PMC interface */
 	{ USB_DEVICE(0x1901, 0x0194) },	/* GE Healthcare Remote Alarm Box */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 9c0cfba2c803..bf2fbb0798fb 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -1028,6 +1028,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },
 	{ USB_DEVICE(TI_VID, TI_CC3200_LAUNCHPAD_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
<span class="p_add">+	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_BT_USB_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_WL_USB_PID) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index f34bc435d90a..c03449e3665a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -609,6 +609,13 @@</span> <span class="p_context"></span>
 #define ADI_GNICE_PID		0xF000
 #define ADI_GNICEPLUS_PID	0xF001
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Cypress WICED USB UART</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define CYPRESS_VID			0x04B4</span>
<span class="p_add">+#define CYPRESS_WICED_BT_USB_PID	0x009B</span>
<span class="p_add">+#define CYPRESS_WICED_WL_USB_PID	0xF900</span>
<span class="p_add">+</span>
 /*
  * Microchip Technology, Inc.
  *
<span class="p_header">diff --git a/drivers/usb/serial/metro-usb.c b/drivers/usb/serial/metro-usb.c</span>
<span class="p_header">index 39e683096e94..45182c65fa1f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/metro-usb.c</span>
<span class="p_header">+++ b/drivers/usb/serial/metro-usb.c</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> struct metrousb_private {</span>
 static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(FOCUS_VENDOR_ID, FOCUS_PRODUCT_ID_BI) },
 	{ USB_DEVICE(FOCUS_VENDOR_ID, FOCUS_PRODUCT_ID_UNI) },
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x0c2e, 0x0730, 0xff) },	/* MS7820 */</span>
 	{ }, /* Terminating entry. */
 };
 MODULE_DEVICE_TABLE(usb, id_table);
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 17d28273e03c..ed203e1a4d96 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -524,6 +524,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 
 /* TP-LINK Incorporated products */
 #define TPLINK_VENDOR_ID			0x2357
<span class="p_add">+#define TPLINK_PRODUCT_LTE			0x000D</span>
 #define TPLINK_PRODUCT_MA180			0x0201
 
 /* Changhong products */
<span class="p_chunk">@@ -2022,6 +2023,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(CELLIENT_VENDOR_ID, CELLIENT_PRODUCT_MEN200) },
 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T_600A) },
 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T_600E) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(TPLINK_VENDOR_ID, TPLINK_PRODUCT_LTE, 0xff, 0x00, 0x00) },	/* TP-Link LTE Module */</span>
 	{ USB_DEVICE(TPLINK_VENDOR_ID, TPLINK_PRODUCT_MA180),
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE(TPLINK_VENDOR_ID, 0x9000),					/* TP-Link MA260 */
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 23c303b2a3a2..996dc09b00b8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -172,6 +172,10 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x413c, 0x81b3)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card (rev3) */
 	{DEVICE_SWI(0x413c, 0x81b5)},	/* Dell Wireless 5811e QDL */
 	{DEVICE_SWI(0x413c, 0x81b6)},	/* Dell Wireless 5811e QDL */
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81cf)},   /* Dell Wireless 5819 */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81d0)},   /* Dell Wireless 5819 */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81d1)},   /* Dell Wireless 5818 */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81d2)},   /* Dell Wireless 5818 */</span>
 
 	/* Huawei devices */
 	{DEVICE_HWI(0x03f0, 0x581d)},	/* HP lt4112 LTE/HSPA+ Gobi 4G Modem (Huawei me906e) */
<span class="p_header">diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c</span>
<span class="p_header">index 8988b268a69a..f848f52a756e 100644</span>
<span class="p_header">--- a/drivers/usb/storage/transport.c</span>
<span class="p_header">+++ b/drivers/usb/storage/transport.c</span>
<span class="p_chunk">@@ -808,12 +808,24 @@</span> <span class="p_context"> void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)</span>
 			if (result == USB_STOR_TRANSPORT_GOOD) {
 				srb-&gt;result = SAM_STAT_GOOD;
 				srb-&gt;sense_buffer[0] = 0x0;
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * ATA-passthru commands use sense data to report</span>
<span class="p_add">+			 * the command completion status, and often devices</span>
<span class="p_add">+			 * return Check Condition status when nothing is</span>
<span class="p_add">+			 * wrong.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			else if (srb-&gt;cmnd[0] == ATA_16 ||</span>
<span class="p_add">+					srb-&gt;cmnd[0] == ATA_12) {</span>
<span class="p_add">+				/* leave the data alone */</span>
<span class="p_add">+			}</span>
 
 			/* If there was a problem, report an unspecified
 			 * hardware error to prevent the higher layers from
 			 * entering an infinite retry loop.
 			 */
<span class="p_del">-			} else {</span>
<span class="p_add">+			else {</span>
 				srb-&gt;result = DID_ERROR &lt;&lt; 16;
 				if ((sshdr.response_code &amp; 0x72) == 0x72)
 					srb-&gt;sense_buffer[1] = HARDWARE_ERROR;
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 96379e715d4b..825625d62982 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -1360,6 +1360,13 @@</span> <span class="p_context"> UNUSUAL_DEV( 0x0bc2, 0x3010, 0x0000, 0x0000,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_SANE_SENSE ),
 
<span class="p_add">+/* Reported by Kris Lindgren &lt;kris.lindgren@gmail.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV( 0x0bc2, 0x3332, 0x0000, 0x9999,</span>
<span class="p_add">+		&quot;Seagate&quot;,</span>
<span class="p_add">+		&quot;External&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_WP_DETECT ),</span>
<span class="p_add">+</span>
 UNUSUAL_DEV(  0x0d49, 0x7310, 0x0000, 0x9999,
 		&quot;Maxtor&quot;,
 		&quot;USB to SATA&quot;,
<span class="p_header">diff --git a/drivers/uwb/hwa-rc.c b/drivers/uwb/hwa-rc.c</span>
<span class="p_header">index e75bbe5a10cd..1212b4b3c5a9 100644</span>
<span class="p_header">--- a/drivers/uwb/hwa-rc.c</span>
<span class="p_header">+++ b/drivers/uwb/hwa-rc.c</span>
<span class="p_chunk">@@ -827,6 +827,8 @@</span> <span class="p_context"> static int hwarc_probe(struct usb_interface *iface,</span>
 
 	if (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)
 		return -ENODEV;
<span class="p_add">+	if (!usb_endpoint_xfer_int(&amp;iface-&gt;cur_altsetting-&gt;endpoint[0].desc))</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	result = -ENOMEM;
 	uwb_rc = uwb_rc_alloc();
<span class="p_header">diff --git a/drivers/uwb/uwbd.c b/drivers/uwb/uwbd.c</span>
<span class="p_header">index bdcb13cc1d54..5c9828370217 100644</span>
<span class="p_header">--- a/drivers/uwb/uwbd.c</span>
<span class="p_header">+++ b/drivers/uwb/uwbd.c</span>
<span class="p_chunk">@@ -303,18 +303,22 @@</span> <span class="p_context"> static int uwbd(void *param)</span>
 /** Start the UWB daemon */
 void uwbd_start(struct uwb_rc *rc)
 {
<span class="p_del">-	rc-&gt;uwbd.task = kthread_run(uwbd, rc, &quot;uwbd&quot;);</span>
<span class="p_del">-	if (rc-&gt;uwbd.task == NULL)</span>
<span class="p_add">+	struct task_struct *task = kthread_run(uwbd, rc, &quot;uwbd&quot;);</span>
<span class="p_add">+	if (IS_ERR(task)) {</span>
<span class="p_add">+		rc-&gt;uwbd.task = NULL;</span>
 		printk(KERN_ERR &quot;UWB: Cannot start management daemon; &quot;
 		       &quot;UWB won&#39;t work\n&quot;);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		rc-&gt;uwbd.task = task;</span>
 		rc-&gt;uwbd.pid = rc-&gt;uwbd.task-&gt;pid;
<span class="p_add">+	}</span>
 }
 
 /* Stop the UWB daemon and free any unprocessed events */
 void uwbd_stop(struct uwb_rc *rc)
 {
<span class="p_del">-	kthread_stop(rc-&gt;uwbd.task);</span>
<span class="p_add">+	if (rc-&gt;uwbd.task)</span>
<span class="p_add">+		kthread_stop(rc-&gt;uwbd.task);</span>
 	uwbd_flush(rc);
 }
 
<span class="p_header">diff --git a/fs/block_dev.c b/fs/block_dev.c</span>
<span class="p_header">index ab8652b89577..6b9811823b72 100644</span>
<span class="p_header">--- a/fs/block_dev.c</span>
<span class="p_header">+++ b/fs/block_dev.c</span>
<span class="p_chunk">@@ -419,10 +419,12 @@</span> <span class="p_context"> int bdev_write_page(struct block_device *bdev, sector_t sector,</span>
 		return -EOPNOTSUPP;
 	set_page_writeback(page);
 	result = ops-&gt;rw_page(bdev, sector + get_start_sect(bdev), page, rw);
<span class="p_del">-	if (result)</span>
<span class="p_add">+	if (result) {</span>
 		end_page_writeback(page);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		clean_page_buffers(page);</span>
 		unlock_page(page);
<span class="p_add">+	}</span>
 	return result;
 }
 EXPORT_SYMBOL_GPL(bdev_write_page);
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 04972508c98b..10d36d0dae33 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2745,9 +2745,9 @@</span> <span class="p_context"> static long btrfs_ioctl_fs_info(struct btrfs_root *root, void __user *arg)</span>
 	}
 	mutex_unlock(&amp;fs_devices-&gt;device_list_mutex);
 
<span class="p_del">-	fi_args-&gt;nodesize = root-&gt;fs_info-&gt;super_copy-&gt;nodesize;</span>
<span class="p_del">-	fi_args-&gt;sectorsize = root-&gt;fs_info-&gt;super_copy-&gt;sectorsize;</span>
<span class="p_del">-	fi_args-&gt;clone_alignment = root-&gt;fs_info-&gt;super_copy-&gt;sectorsize;</span>
<span class="p_add">+	fi_args-&gt;nodesize = root-&gt;nodesize;</span>
<span class="p_add">+	fi_args-&gt;sectorsize = root-&gt;sectorsize;</span>
<span class="p_add">+	fi_args-&gt;clone_alignment = root-&gt;sectorsize;</span>
 
 	if (copy_to_user(arg, fi_args, sizeof(*fi_args)))
 		ret = -EFAULT;
<span class="p_chunk">@@ -3980,6 +3980,10 @@</span> <span class="p_context"> static long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)</span>
 		ret = PTR_ERR(new_root);
 		goto out;
 	}
<span class="p_add">+	if (!is_fstree(new_root-&gt;objectid)) {</span>
<span class="p_add">+		ret = -ENOENT;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	path = btrfs_alloc_path();
 	if (!path) {
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index 281358942b64..a0bf3f135a92 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -1294,7 +1294,7 @@</span> <span class="p_context"> exit_cifs(void)</span>
 	exit_cifs_idmap();
 #endif
 #ifdef CONFIG_CIFS_UPCALL
<span class="p_del">-	unregister_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	exit_cifs_spnego();</span>
 #endif
 	cifs_destroy_request_bufs();
 	cifs_destroy_mids();
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 2959522238c5..d7be06289ff8 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -3956,6 +3956,14 @@</span> <span class="p_context"> cifs_setup_session(const unsigned int xid, struct cifs_ses *ses,</span>
 	cifs_dbg(FYI, &quot;Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\n&quot;,
 		 server-&gt;sec_mode, server-&gt;capabilities, server-&gt;timeAdj);
 
<span class="p_add">+	if (ses-&gt;auth_key.response) {</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;Free previous auth_key.response = %p\n&quot;,</span>
<span class="p_add">+			 ses-&gt;auth_key.response);</span>
<span class="p_add">+		kfree(ses-&gt;auth_key.response);</span>
<span class="p_add">+		ses-&gt;auth_key.response = NULL;</span>
<span class="p_add">+		ses-&gt;auth_key.len = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (server-&gt;ops-&gt;sess_setup)
 		rc = server-&gt;ops-&gt;sess_setup(xid, ses, nls_info);
 
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index 0ae3f55290e9..a1feb13c7590 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -225,6 +225,13 @@</span> <span class="p_context"> cifs_nt_open(char *full_path, struct inode *inode, struct cifs_sb_info *cifs_sb,</span>
 	if (backup_cred(cifs_sb))
 		create_options |= CREATE_OPEN_BACKUP_INTENT;
 
<span class="p_add">+	/* O_SYNC also has bit for O_DSYNC so following check picks up either */</span>
<span class="p_add">+	if (f_flags &amp; O_SYNC)</span>
<span class="p_add">+		create_options |= CREATE_WRITE_THROUGH;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (f_flags &amp; O_DIRECT)</span>
<span class="p_add">+		create_options |= CREATE_NO_BUFFER;</span>
<span class="p_add">+</span>
 	oparms.tcon = tcon;
 	oparms.cifs_sb = cifs_sb;
 	oparms.desired_access = desired_access;
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 8add863a81fd..038e428b5173 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -479,22 +479,29 @@</span> <span class="p_context"> int smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)</span>
 {
 	int rc = 0;
 	struct validate_negotiate_info_req vneg_inbuf;
<span class="p_del">-	struct validate_negotiate_info_rsp *pneg_rsp;</span>
<span class="p_add">+	struct validate_negotiate_info_rsp *pneg_rsp = NULL;</span>
 	u32 rsplen;
 
 	cifs_dbg(FYI, &quot;validate negotiate\n&quot;);
 
 	/*
 	 * validation ioctl must be signed, so no point sending this if we
<span class="p_del">-	 * can not sign it.  We could eventually change this to selectively</span>
<span class="p_add">+	 * can not sign it (ie are not known user).  Even if signing is not</span>
<span class="p_add">+	 * required (enabled but not negotiated), in those cases we selectively</span>
 	 * sign just this, the first and only signed request on a connection.
<span class="p_del">-	 * This is good enough for now since a user who wants better security</span>
<span class="p_del">-	 * would also enable signing on the mount. Having validation of</span>
<span class="p_del">-	 * negotiate info for signed connections helps reduce attack vectors</span>
<span class="p_add">+	 * Having validation of negotiate info  helps reduce attack vectors.</span>
 	 */
<span class="p_del">-	if (tcon-&gt;ses-&gt;server-&gt;sign == false)</span>
<span class="p_add">+	if (tcon-&gt;ses-&gt;session_flags &amp; SMB2_SESSION_FLAG_IS_GUEST)</span>
 		return 0; /* validation requires signing */
 
<span class="p_add">+	if (tcon-&gt;ses-&gt;user_name == NULL) {</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;Can&#39;t validate negotiate: null user mount\n&quot;);</span>
<span class="p_add">+		return 0; /* validation requires signing */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tcon-&gt;ses-&gt;session_flags &amp; SMB2_SESSION_FLAG_IS_NULL)</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;Unexpected null user (anonymous) auth flag sent by server\n&quot;);</span>
<span class="p_add">+</span>
 	vneg_inbuf.Capabilities =
 			cpu_to_le32(tcon-&gt;ses-&gt;server-&gt;vals-&gt;req_capabilities);
 	memcpy(vneg_inbuf.Guid, tcon-&gt;ses-&gt;server-&gt;client_guid,
<span class="p_chunk">@@ -528,8 +535,9 @@</span> <span class="p_context"> int smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)</span>
 			 rsplen);
 
 		/* relax check since Mac returns max bufsize allowed on ioctl */
<span class="p_del">-		if (rsplen &gt; CIFSMaxBufSize)</span>
<span class="p_del">-			return -EIO;</span>
<span class="p_add">+		if ((rsplen &gt; CIFSMaxBufSize)</span>
<span class="p_add">+		     || (rsplen &lt; sizeof(struct validate_negotiate_info_rsp)))</span>
<span class="p_add">+			goto err_rsp_free;</span>
 	}
 
 	/* check validate negotiate info response matches what we got earlier */
<span class="p_chunk">@@ -548,10 +556,13 @@</span> <span class="p_context"> int smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)</span>
 
 	/* validate negotiate successful */
 	cifs_dbg(FYI, &quot;validate negotiate info successful\n&quot;);
<span class="p_add">+	kfree(pneg_rsp);</span>
 	return 0;
 
 vneg_out:
 	cifs_dbg(VFS, &quot;protocol revalidation - security settings mismatch\n&quot;);
<span class="p_add">+err_rsp_free:</span>
<span class="p_add">+	kfree(pneg_rsp);</span>
 	return -EIO;
 }
 
<span class="p_chunk">@@ -1114,7 +1125,7 @@</span> <span class="p_context"> SMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,</span>
 	struct TCP_Server_Info *server;
 	struct cifs_tcon *tcon = oparms-&gt;tcon;
 	struct cifs_ses *ses = tcon-&gt;ses;
<span class="p_del">-	struct kvec iov[4];</span>
<span class="p_add">+	struct kvec iov[4] = {{NULL, 0}};</span>
 	int resp_buftype;
 	int uni_path_len;
 	__le16 *copy_path = NULL;
<span class="p_chunk">@@ -1215,7 +1226,7 @@</span> <span class="p_context"> SMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,</span>
 
 	if (rc != 0) {
 		cifs_stats_fail_inc(tcon, SMB2_CREATE_HE);
<span class="p_del">-		if (err_buf)</span>
<span class="p_add">+		if (err_buf &amp;&amp; rsp)</span>
 			*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,
 					   GFP_KERNEL);
 		goto creat_exit;
<span class="p_chunk">@@ -1331,6 +1342,9 @@</span> <span class="p_context"> SMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,</span>
 	} else
 		iov[0].iov_len = get_rfc1002_length(req) + 4;
 
<span class="p_add">+	/* validate negotiate request must be signed - see MS-SMB2 3.2.5.5 */</span>
<span class="p_add">+	if (opcode == FSCTL_VALIDATE_NEGOTIATE_INFO)</span>
<span class="p_add">+		req-&gt;hdr.Flags |= SMB2_FLAGS_SIGNED;</span>
 
 	rc = SendReceive2(xid, ses, iov, num_iovecs, &amp;resp_buftype, 0);
 	rsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;
<span class="p_header">diff --git a/fs/direct-io.c b/fs/direct-io.c</span>
<span class="p_header">index e181b6b2e297..a325d8c5ec2d 100644</span>
<span class="p_header">--- a/fs/direct-io.c</span>
<span class="p_header">+++ b/fs/direct-io.c</span>
<span class="p_chunk">@@ -812,7 +812,8 @@</span> <span class="p_context"> submit_page_section(struct dio *dio, struct dio_submit *sdio, struct page *page,</span>
 	 */
 	if (sdio-&gt;boundary) {
 		ret = dio_send_cur_page(dio, sdio, map_bh);
<span class="p_del">-		dio_bio_submit(dio, sdio);</span>
<span class="p_add">+		if (sdio-&gt;bio)</span>
<span class="p_add">+			dio_bio_submit(dio, sdio);</span>
 		page_cache_release(sdio-&gt;cur_page);
 		sdio-&gt;cur_page = NULL;
 	}
<span class="p_header">diff --git a/fs/ecryptfs/ecryptfs_kernel.h b/fs/ecryptfs/ecryptfs_kernel.h</span>
<span class="p_header">index 90d1882b306f..4682bef34bb6 100644</span>
<span class="p_header">--- a/fs/ecryptfs/ecryptfs_kernel.h</span>
<span class="p_header">+++ b/fs/ecryptfs/ecryptfs_kernel.h</span>
<span class="p_chunk">@@ -84,11 +84,16 @@</span> <span class="p_context"> struct ecryptfs_page_crypt_context {</span>
 static inline struct ecryptfs_auth_tok *
 ecryptfs_get_encrypted_key_payload_data(struct key *key)
 {
<span class="p_del">-	if (key-&gt;type == &amp;key_type_encrypted)</span>
<span class="p_del">-		return (struct ecryptfs_auth_tok *)</span>
<span class="p_del">-			(&amp;((struct encrypted_key_payload *)key-&gt;payload.data)-&gt;payload_data);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	struct encrypted_key_payload *payload;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (key-&gt;type != &amp;key_type_encrypted)</span>
 		return NULL;
<span class="p_add">+</span>
<span class="p_add">+	payload = key-&gt;payload.data;</span>
<span class="p_add">+	if (!payload)</span>
<span class="p_add">+		return ERR_PTR(-EKEYREVOKED);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (struct ecryptfs_auth_tok *)payload-&gt;payload_data;</span>
 }
 
 static inline struct key *ecryptfs_get_encrypted_key(char *sig)
<span class="p_chunk">@@ -114,13 +119,17 @@</span> <span class="p_context"> static inline struct ecryptfs_auth_tok *</span>
 ecryptfs_get_key_payload_data(struct key *key)
 {
 	struct ecryptfs_auth_tok *auth_tok;
<span class="p_add">+	struct user_key_payload *ukp;</span>
 
 	auth_tok = ecryptfs_get_encrypted_key_payload_data(key);
<span class="p_del">-	if (!auth_tok)</span>
<span class="p_del">-		return (struct ecryptfs_auth_tok *)</span>
<span class="p_del">-			(((struct user_key_payload *)key-&gt;payload.data)-&gt;data);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (auth_tok)</span>
 		return auth_tok;
<span class="p_add">+</span>
<span class="p_add">+	ukp = key-&gt;payload.data;</span>
<span class="p_add">+	if (!ukp)</span>
<span class="p_add">+		return ERR_PTR(-EKEYREVOKED);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (struct ecryptfs_auth_tok *)ukp-&gt;data;</span>
 }
 
 #define ECRYPTFS_MAX_KEYSET_SIZE 1024
<span class="p_header">diff --git a/fs/ecryptfs/keystore.c b/fs/ecryptfs/keystore.c</span>
<span class="p_header">index 4725a07f003c..bb10b3158b49 100644</span>
<span class="p_header">--- a/fs/ecryptfs/keystore.c</span>
<span class="p_header">+++ b/fs/ecryptfs/keystore.c</span>
<span class="p_chunk">@@ -459,7 +459,8 @@</span> <span class="p_context"> static int ecryptfs_verify_version(u16 version)</span>
  * @auth_tok_key: key containing the authentication token
  * @auth_tok: authentication token
  *
<span class="p_del">- * Returns zero on valid auth tok; -EINVAL otherwise</span>
<span class="p_add">+ * Returns zero on valid auth tok; -EINVAL if the payload is invalid; or</span>
<span class="p_add">+ * -EKEYREVOKED if the key was revoked before we acquired its semaphore.</span>
  */
 static int
 ecryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,
<span class="p_chunk">@@ -468,6 +469,12 @@</span> <span class="p_context"> ecryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,</span>
 	int rc = 0;
 
 	(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);
<span class="p_add">+	if (IS_ERR(*auth_tok)) {</span>
<span class="p_add">+		rc = PTR_ERR(*auth_tok);</span>
<span class="p_add">+		*auth_tok = NULL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (ecryptfs_verify_version((*auth_tok)-&gt;version)) {
 		printk(KERN_ERR &quot;Data structure version mismatch. Userspace &quot;
 		       &quot;tools must match eCryptfs kernel module with major &quot;
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index fa3604731bae..70c31796a314 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -56,6 +56,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/pipe_fs_i.h&gt;
 #include &lt;linux/oom.h&gt;
 #include &lt;linux/compat.h&gt;
<span class="p_add">+#include &lt;linux/user_namespace.h&gt;</span>
 
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/mmu_context.h&gt;
<span class="p_chunk">@@ -1129,8 +1130,22 @@</span> <span class="p_context"> EXPORT_SYMBOL(flush_old_exec);</span>
 
 void would_dump(struct linux_binprm *bprm, struct file *file)
 {
<span class="p_del">-	if (inode_permission(file_inode(file), MAY_READ) &lt; 0)</span>
<span class="p_add">+	struct inode *inode = file_inode(file);</span>
<span class="p_add">+	if (inode_permission(inode, MAY_READ) &lt; 0) {</span>
<span class="p_add">+		struct user_namespace *old, *user_ns;</span>
 		bprm-&gt;interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;
<span class="p_add">+</span>
<span class="p_add">+		/* Ensure mm-&gt;user_ns contains the executable */</span>
<span class="p_add">+		user_ns = old = bprm-&gt;mm-&gt;user_ns;</span>
<span class="p_add">+		while ((user_ns != &amp;init_user_ns) &amp;&amp;</span>
<span class="p_add">+		       !privileged_wrt_inode_uidgid(user_ns, inode))</span>
<span class="p_add">+			user_ns = user_ns-&gt;parent;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (old != user_ns) {</span>
<span class="p_add">+			bprm-&gt;mm-&gt;user_ns = get_user_ns(user_ns);</span>
<span class="p_add">+			put_user_ns(old);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 }
 EXPORT_SYMBOL(would_dump);
 
<span class="p_chunk">@@ -1160,7 +1175,6 @@</span> <span class="p_context"> void setup_new_exec(struct linux_binprm * bprm)</span>
 	    !gid_eq(bprm-&gt;cred-&gt;gid, current_egid())) {
 		current-&gt;pdeath_signal = 0;
 	} else {
<span class="p_del">-		would_dump(bprm, bprm-&gt;file);</span>
 		if (bprm-&gt;interp_flags &amp; BINPRM_FLAGS_ENFORCE_NONDUMP)
 			set_dumpable(current-&gt;mm, suid_dumpable);
 	}
<span class="p_chunk">@@ -1259,7 +1273,7 @@</span> <span class="p_context"> static void check_unsafe_exec(struct linux_binprm *bprm)</span>
 	unsigned n_fs;
 
 	if (p-&gt;ptrace) {
<span class="p_del">-		if (p-&gt;ptrace &amp; PT_PTRACE_CAP)</span>
<span class="p_add">+		if (ptracer_capable(p, current_user_ns()))</span>
 			bprm-&gt;unsafe |= LSM_UNSAFE_PTRACE_CAP;
 		else
 			bprm-&gt;unsafe |= LSM_UNSAFE_PTRACE;
<span class="p_chunk">@@ -1564,6 +1578,8 @@</span> <span class="p_context"> static int do_execve_common(struct filename *filename,</span>
 	if (retval &lt; 0)
 		goto out;
 
<span class="p_add">+	would_dump(bprm, bprm-&gt;file);</span>
<span class="p_add">+</span>
 	retval = exec_binprm(bprm);
 	if (retval &lt; 0)
 		goto out;
<span class="p_header">diff --git a/fs/fscache/object-list.c b/fs/fscache/object-list.c</span>
<span class="p_header">index b8179ca6bf9d..8a96aeb2391f 100644</span>
<span class="p_header">--- a/fs/fscache/object-list.c</span>
<span class="p_header">+++ b/fs/fscache/object-list.c</span>
<span class="p_chunk">@@ -330,6 +330,13 @@</span> <span class="p_context"> static void fscache_objlist_config(struct fscache_objlist_data *data)</span>
 	rcu_read_lock();
 
 	confkey = key-&gt;payload.data;
<span class="p_add">+	if (!confkey) {</span>
<span class="p_add">+		/* key was revoked */</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+		key_put(key);</span>
<span class="p_add">+		goto no_config;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	buf = confkey-&gt;data;
 
 	for (len = confkey-&gt;datalen - 1; len &gt;= 0; len--) {
<span class="p_header">diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c</span>
<span class="p_header">index a5c32420bfc8..373494f247b1 100644</span>
<span class="p_header">--- a/fs/fuse/dir.c</span>
<span class="p_header">+++ b/fs/fuse/dir.c</span>
<span class="p_chunk">@@ -1382,7 +1382,8 @@</span> <span class="p_context"> static int parse_dirplusfile(char *buf, size_t nbytes, struct file *file,</span>
 			*/
 			over = !dir_emit(ctx, dirent-&gt;name, dirent-&gt;namelen,
 				       dirent-&gt;ino, dirent-&gt;type);
<span class="p_del">-			ctx-&gt;pos = dirent-&gt;off;</span>
<span class="p_add">+			if (!over)</span>
<span class="p_add">+				ctx-&gt;pos = dirent-&gt;off;</span>
 		}
 
 		buf += reclen;
<span class="p_header">diff --git a/fs/mpage.c b/fs/mpage.c</span>
<span class="p_header">index 5f9ed622274f..895ee9af5be3 100644</span>
<span class="p_header">--- a/fs/mpage.c</span>
<span class="p_header">+++ b/fs/mpage.c</span>
<span class="p_chunk">@@ -457,6 +457,16 @@</span> <span class="p_context"> static void clean_buffers(struct page *page, unsigned first_unmapped)</span>
 		try_to_free_buffers(page);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * For situations where we want to clean all buffers attached to a page.</span>
<span class="p_add">+ * We don&#39;t need to calculate how many buffers are attached to the page,</span>
<span class="p_add">+ * we just need to specify a number larger than the maximum number of buffers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void clean_page_buffers(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	clean_buffers(page, ~0U);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __mpage_writepage(struct page *page, struct writeback_control *wbc,
 		      void *data)
 {
<span class="p_chunk">@@ -594,10 +604,8 @@</span> <span class="p_context"> static int __mpage_writepage(struct page *page, struct writeback_control *wbc,</span>
 	if (bio == NULL) {
 		if (first_unmapped == blocks_per_page) {
 			if (!bdev_write_page(bdev, blocks[0] &lt;&lt; (blkbits - 9),
<span class="p_del">-								page, wbc)) {</span>
<span class="p_del">-				clean_buffers(page, first_unmapped);</span>
<span class="p_add">+								page, wbc))</span>
 				goto out;
<span class="p_del">-			}</span>
 		}
 		bio = mpage_alloc(bdev, blocks[0] &lt;&lt; (blkbits - 9),
 				bio_get_nr_vecs(bdev), GFP_NOFS|__GFP_HIGH);
<span class="p_header">diff --git a/fs/ocfs2/alloc.c b/fs/ocfs2/alloc.c</span>
<span class="p_header">index 9d8fcf2f3b94..296f48c6f43d 100644</span>
<span class="p_header">--- a/fs/ocfs2/alloc.c</span>
<span class="p_header">+++ b/fs/ocfs2/alloc.c</span>
<span class="p_chunk">@@ -7226,13 +7226,24 @@</span> <span class="p_context"> int ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,</span>
 
 static int ocfs2_trim_extent(struct super_block *sb,
 			     struct ocfs2_group_desc *gd,
<span class="p_del">-			     u32 start, u32 count)</span>
<span class="p_add">+			     u64 group, u32 start, u32 count)</span>
 {
 	u64 discard, bcount;
<span class="p_add">+	struct ocfs2_super *osb = OCFS2_SB(sb);</span>
 
 	bcount = ocfs2_clusters_to_blocks(sb, count);
<span class="p_del">-	discard = le64_to_cpu(gd-&gt;bg_blkno) +</span>
<span class="p_del">-			ocfs2_clusters_to_blocks(sb, start);</span>
<span class="p_add">+	discard = ocfs2_clusters_to_blocks(sb, start);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For the first cluster group, the gd-&gt;bg_blkno is not at the start</span>
<span class="p_add">+	 * of the group, but at an offset from the start. If we add it while</span>
<span class="p_add">+	 * calculating discard for first group, we will wrongly start fstrim a</span>
<span class="p_add">+	 * few blocks after the desried start block and the range can cross</span>
<span class="p_add">+	 * over into the next cluster group. So, add it only if this is not</span>
<span class="p_add">+	 * the first cluster group.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (group != osb-&gt;first_cluster_group_blkno)</span>
<span class="p_add">+		discard += le64_to_cpu(gd-&gt;bg_blkno);</span>
 
 	trace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);
 
<span class="p_chunk">@@ -7240,7 +7251,7 @@</span> <span class="p_context"> static int ocfs2_trim_extent(struct super_block *sb,</span>
 }
 
 static int ocfs2_trim_group(struct super_block *sb,
<span class="p_del">-			    struct ocfs2_group_desc *gd,</span>
<span class="p_add">+			    struct ocfs2_group_desc *gd, u64 group,</span>
 			    u32 start, u32 max, u32 minbits)
 {
 	int ret = 0, count = 0, next;
<span class="p_chunk">@@ -7259,7 +7270,7 @@</span> <span class="p_context"> static int ocfs2_trim_group(struct super_block *sb,</span>
 		next = ocfs2_find_next_bit(bitmap, max, start);
 
 		if ((next - start) &gt;= minbits) {
<span class="p_del">-			ret = ocfs2_trim_extent(sb, gd,</span>
<span class="p_add">+			ret = ocfs2_trim_extent(sb, gd, group,</span>
 						start, next - start);
 			if (ret &lt; 0) {
 				mlog_errno(ret);
<span class="p_chunk">@@ -7357,7 +7368,8 @@</span> <span class="p_context"> int ocfs2_trim_fs(struct super_block *sb, struct fstrim_range *range)</span>
 		}
 
 		gd = (struct ocfs2_group_desc *)gd_bh-&gt;b_data;
<span class="p_del">-		cnt = ocfs2_trim_group(sb, gd, first_bit, last_bit, minlen);</span>
<span class="p_add">+		cnt = ocfs2_trim_group(sb, gd, group,</span>
<span class="p_add">+				       first_bit, last_bit, minlen);</span>
 		brelse(gd_bh);
 		gd_bh = NULL;
 		if (cnt &lt; 0) {
<span class="p_header">diff --git a/fs/read_write.c b/fs/read_write.c</span>
<span class="p_header">index 009d8542a889..07053752c148 100644</span>
<span class="p_header">--- a/fs/read_write.c</span>
<span class="p_header">+++ b/fs/read_write.c</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> generic_file_llseek_size(struct file *file, loff_t offset, int whence,</span>
 		 * In the generic case the entire file is data, so as long as
 		 * offset isn&#39;t at the end of the file then the offset is data.
 		 */
<span class="p_del">-		if (offset &gt;= eof)</span>
<span class="p_add">+		if ((unsigned long long)offset &gt;= eof)</span>
 			return -ENXIO;
 		break;
 	case SEEK_HOLE:
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> generic_file_llseek_size(struct file *file, loff_t offset, int whence,</span>
 		 * There is a virtual hole at the end of the file, so as long as
 		 * offset isn&#39;t i_size or larger, return i_size.
 		 */
<span class="p_del">-		if (offset &gt;= eof)</span>
<span class="p_add">+		if ((unsigned long long)offset &gt;= eof)</span>
 			return -ENXIO;
 		offset = eof;
 		break;
<span class="p_header">diff --git a/fs/xattr.c b/fs/xattr.c</span>
<span class="p_header">index 7325e2ecbae9..6b57cbd8c962 100644</span>
<span class="p_header">--- a/fs/xattr.c</span>
<span class="p_header">+++ b/fs/xattr.c</span>
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> xattr_getsecurity(struct inode *inode, const char *name, void *value,</span>
 	}
 	memcpy(value, buffer, len);
 out:
<span class="p_del">-	security_release_secctx(buffer, len);</span>
<span class="p_add">+	kfree(buffer);</span>
 out_noalloc:
 	return len;
 }
<span class="p_header">diff --git a/include/crypto/internal/hash.h b/include/crypto/internal/hash.h</span>
<span class="p_header">index 66fc42c57aff..27f5fa488ad0 100644</span>
<span class="p_header">--- a/include/crypto/internal/hash.h</span>
<span class="p_header">+++ b/include/crypto/internal/hash.h</span>
<span class="p_chunk">@@ -83,6 +83,14 @@</span> <span class="p_context"> int ahash_register_instance(struct crypto_template *tmpl,</span>
 			    struct ahash_instance *inst);
 void ahash_free_instance(struct crypto_instance *inst);
 
<span class="p_add">+int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,</span>
<span class="p_add">+		    unsigned int keylen);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool crypto_shash_alg_has_setkey(struct shash_alg *alg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return alg-&gt;setkey != shash_no_setkey;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int crypto_init_ahash_spawn(struct crypto_ahash_spawn *spawn,
 			    struct hash_alg_common *alg,
 			    struct crypto_instance *inst);
<span class="p_header">diff --git a/include/linux/buffer_head.h b/include/linux/buffer_head.h</span>
<span class="p_header">index e6797ded700e..f8d39f7a56f2 100644</span>
<span class="p_header">--- a/include/linux/buffer_head.h</span>
<span class="p_header">+++ b/include/linux/buffer_head.h</span>
<span class="p_chunk">@@ -222,6 +222,7 @@</span> <span class="p_context"> int generic_write_end(struct file *, struct address_space *,</span>
 				loff_t, unsigned, unsigned,
 				struct page *, void *);
 void page_zero_new_buffers(struct page *page, unsigned from, unsigned to);
<span class="p_add">+void clean_page_buffers(struct page *page);</span>
 int cont_write_begin(struct file *, struct address_space *, loff_t,
 			unsigned, unsigned, struct page **, void **,
 			get_block_t *, loff_t *);
<span class="p_header">diff --git a/include/linux/capability.h b/include/linux/capability.h</span>
<span class="p_header">index aa93e5ef594c..4a12b8d51f1b 100644</span>
<span class="p_header">--- a/include/linux/capability.h</span>
<span class="p_header">+++ b/include/linux/capability.h</span>
<span class="p_chunk">@@ -213,8 +213,10 @@</span> <span class="p_context"> extern bool has_ns_capability_noaudit(struct task_struct *t,</span>
 				      struct user_namespace *ns, int cap);
 extern bool capable(int cap);
 extern bool ns_capable(struct user_namespace *ns, int cap);
<span class="p_add">+extern bool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode);</span>
 extern bool capable_wrt_inode_uidgid(const struct inode *inode, int cap);
 extern bool file_ns_capable(const struct file *file, struct user_namespace *ns, int cap);
<span class="p_add">+extern bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns);</span>
 
 /* audit system wants to get cap info from files as well */
 extern int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps);
<span class="p_header">diff --git a/include/linux/iio/adc/ad_sigma_delta.h b/include/linux/iio/adc/ad_sigma_delta.h</span>
<span class="p_header">index e7fdec4db9da..6cc48ac55fd2 100644</span>
<span class="p_header">--- a/include/linux/iio/adc/ad_sigma_delta.h</span>
<span class="p_header">+++ b/include/linux/iio/adc/ad_sigma_delta.h</span>
<span class="p_chunk">@@ -111,6 +111,9 @@</span> <span class="p_context"> int ad_sd_write_reg(struct ad_sigma_delta *sigma_delta, unsigned int reg,</span>
 int ad_sd_read_reg(struct ad_sigma_delta *sigma_delta, unsigned int reg,
 	unsigned int size, unsigned int *val);
 
<span class="p_add">+int ad_sd_reset(struct ad_sigma_delta *sigma_delta,</span>
<span class="p_add">+	unsigned int reset_length);</span>
<span class="p_add">+</span>
 int ad_sigma_delta_single_conversion(struct iio_dev *indio_dev,
 	const struct iio_chan_spec *chan, int *val);
 int ad_sd_calibrate_all(struct ad_sigma_delta *sigma_delta,
<span class="p_header">diff --git a/include/linux/input.h b/include/linux/input.h</span>
<span class="p_header">index 82ce323b9986..25476b19ea54 100644</span>
<span class="p_header">--- a/include/linux/input.h</span>
<span class="p_header">+++ b/include/linux/input.h</span>
<span class="p_chunk">@@ -527,6 +527,7 @@</span> <span class="p_context"> int input_ff_event(struct input_dev *dev, unsigned int type, unsigned int code,</span>
 
 int input_ff_upload(struct input_dev *dev, struct ff_effect *effect, struct file *file);
 int input_ff_erase(struct input_dev *dev, int effect_id, struct file *file);
<span class="p_add">+int input_ff_flush(struct input_dev *dev, struct file *file);</span>
 
 int input_ff_create_memless(struct input_dev *dev, void *data,
 		int (*play_effect)(struct input_dev *, void *, struct ff_effect *));
<span class="p_header">diff --git a/include/linux/key.h b/include/linux/key.h</span>
<span class="p_header">index 017b0826642f..f04f6dd6c6f7 100644</span>
<span class="p_header">--- a/include/linux/key.h</span>
<span class="p_header">+++ b/include/linux/key.h</span>
<span class="p_chunk">@@ -170,6 +170,7 @@</span> <span class="p_context"> struct key {</span>
 #define KEY_FLAG_INVALIDATED	7	/* set if key has been invalidated */
 #define KEY_FLAG_TRUSTED	8	/* set if key is trusted */
 #define KEY_FLAG_TRUSTED_ONLY	9	/* set if keyring only accepts links to trusted keys */
<span class="p_add">+#define KEY_FLAG_UID_KEYRING	11	/* set if key is a user or user session keyring */</span>
 
 	/* the key type and key description string
 	 * - the desc is used to match a key against search criteria
<span class="p_chunk">@@ -221,6 +222,7 @@</span> <span class="p_context"> extern struct key *key_alloc(struct key_type *type,</span>
 #define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
 #define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
 #define KEY_ALLOC_TRUSTED	0x0004	/* Key should be flagged as trusted */
<span class="p_add">+#define KEY_ALLOC_UID_KEYRING		0x0010	/* allocating a user or user session keyring */</span>
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);
<span class="p_header">diff --git a/include/linux/mbus.h b/include/linux/mbus.h</span>
<span class="p_header">index 550c88fb0267..0ae20395bf5a 100644</span>
<span class="p_header">--- a/include/linux/mbus.h</span>
<span class="p_header">+++ b/include/linux/mbus.h</span>
<span class="p_chunk">@@ -29,8 +29,8 @@</span> <span class="p_context"> struct mbus_dram_target_info</span>
 	struct mbus_dram_window {
 		u8	cs_index;
 		u8	mbus_attr;
<span class="p_del">-		u32	base;</span>
<span class="p_del">-		u32	size;</span>
<span class="p_add">+		u64	base;</span>
<span class="p_add">+		u64	size;</span>
 	} cs[4];
 };
 
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 35f8b59b37a7..65a4dc2da9de 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1209,6 +1209,8 @@</span> <span class="p_context"> static inline int fixup_user_fault(struct task_struct *tsk,</span>
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
 extern int access_remote_vm(struct mm_struct *mm, unsigned long addr,
 		void *buf, int len, int write);
<span class="p_add">+extern int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span>
<span class="p_add">+		unsigned long addr, void *buf, int len, int write);</span>
 
 long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 		      unsigned long start, unsigned long nr_pages,
<span class="p_header">diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h</span>
<span class="p_header">index 761fc630f150..489c1307f81e 100644</span>
<span class="p_header">--- a/include/linux/mm_types.h</span>
<span class="p_header">+++ b/include/linux/mm_types.h</span>
<span class="p_chunk">@@ -419,6 +419,7 @@</span> <span class="p_context"> struct mm_struct {</span>
 	 */
 	struct task_struct __rcu *owner;
 #endif
<span class="p_add">+	struct user_namespace *user_ns;</span>
 
 	/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */
 	struct file *exe_file;
<span class="p_header">diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h</span>
<span class="p_header">index 6cbd1b6c3d20..c7eb42235fbe 100644</span>
<span class="p_header">--- a/include/linux/mmzone.h</span>
<span class="p_header">+++ b/include/linux/mmzone.h</span>
<span class="p_chunk">@@ -1094,8 +1094,14 @@</span> <span class="p_context"> static inline unsigned long early_pfn_to_nid(unsigned long pfn)</span>
 #error Allocator MAX_ORDER exceeds SECTION_SIZE
 #endif
 
<span class="p_del">-#define pfn_to_section_nr(pfn) ((pfn) &gt;&gt; PFN_SECTION_SHIFT)</span>
<span class="p_del">-#define section_nr_to_pfn(sec) ((sec) &lt;&lt; PFN_SECTION_SHIFT)</span>
<span class="p_add">+static inline unsigned long pfn_to_section_nr(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return pfn &gt;&gt; PFN_SECTION_SHIFT;</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline unsigned long section_nr_to_pfn(unsigned long sec)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return sec &lt;&lt; PFN_SECTION_SHIFT;</span>
<span class="p_add">+}</span>
 
 #define SECTION_ALIGN_UP(pfn)	(((pfn) + PAGES_PER_SECTION - 1) &amp; PAGE_SECTION_MASK)
 #define SECTION_ALIGN_DOWN(pfn)	((pfn) &amp; PAGE_SECTION_MASK)
<span class="p_header">diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h</span>
<span class="p_header">index e5145f8e4004..1d2c25984890 100644</span>
<span class="p_header">--- a/include/linux/netdevice.h</span>
<span class="p_header">+++ b/include/linux/netdevice.h</span>
<span class="p_chunk">@@ -3000,6 +3000,9 @@</span> <span class="p_context"> void ether_setup(struct net_device *dev);</span>
 struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,
 				    void (*setup)(struct net_device *),
 				    unsigned int txqs, unsigned int rxqs);
<span class="p_add">+int dev_get_valid_name(struct net *net, struct net_device *dev,</span>
<span class="p_add">+		       const char *name);</span>
<span class="p_add">+</span>
 #define alloc_netdev(sizeof_priv, name, setup) \
 	alloc_netdev_mqs(sizeof_priv, name, setup, 1, 1)
 
<span class="p_header">diff --git a/include/linux/of.h b/include/linux/of.h</span>
<span class="p_header">index 55452d38ae06..0c220cf91e92 100644</span>
<span class="p_header">--- a/include/linux/of.h</span>
<span class="p_header">+++ b/include/linux/of.h</span>
<span class="p_chunk">@@ -503,6 +503,16 @@</span> <span class="p_context"> static inline struct device_node *of_get_cpu_node(int cpu,</span>
 	return NULL;
 }
 
<span class="p_add">+static inline int of_n_addr_cells(struct device_node *np)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline int of_n_size_cells(struct device_node *np)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int of_property_read_u64(const struct device_node *np,
 				       const char *propname, u64 *out_value)
 {
<span class="p_header">diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h</span>
<span class="p_header">index 32709bcecfdd..0117cdf84e95 100644</span>
<span class="p_header">--- a/include/linux/pci_ids.h</span>
<span class="p_header">+++ b/include/linux/pci_ids.h</span>
<span class="p_chunk">@@ -520,6 +520,8 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_AMD_15H_M10H_F3	0x1403
 #define PCI_DEVICE_ID_AMD_15H_M30H_NB_F3 0x141d
 #define PCI_DEVICE_ID_AMD_15H_M30H_NB_F4 0x141e
<span class="p_add">+#define PCI_DEVICE_ID_AMD_15H_M60H_NB_F3 0x1573</span>
<span class="p_add">+#define PCI_DEVICE_ID_AMD_15H_M60H_NB_F4 0x1574</span>
 #define PCI_DEVICE_ID_AMD_15H_NB_F0	0x1600
 #define PCI_DEVICE_ID_AMD_15H_NB_F1	0x1601
 #define PCI_DEVICE_ID_AMD_15H_NB_F2	0x1602
<span class="p_header">diff --git a/include/linux/preempt_mask.h b/include/linux/preempt_mask.h</span>
<span class="p_header">index 5cb25f17331a..7ee3562f70f4 100644</span>
<span class="p_header">--- a/include/linux/preempt_mask.h</span>
<span class="p_header">+++ b/include/linux/preempt_mask.h</span>
<span class="p_chunk">@@ -57,19 +57,24 @@</span> <span class="p_context"></span>
 
 /*
  * Are we doing bottom half or hardware interrupt processing?
<span class="p_del">- * Are we in a softirq context? Interrupt context?</span>
<span class="p_del">- * in_softirq - Are we currently processing softirq or have bh disabled?</span>
<span class="p_del">- * in_serving_softirq - Are we currently processing softirq?</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * in_irq()       - We&#39;re in (hard) IRQ context</span>
<span class="p_add">+ * in_softirq()   - We have BH disabled, or are processing softirqs</span>
<span class="p_add">+ * in_interrupt() - We&#39;re in NMI,IRQ,SoftIRQ context or have BH disabled</span>
<span class="p_add">+ * in_serving_softirq() - We&#39;re in softirq context</span>
<span class="p_add">+ * in_nmi()       - We&#39;re in NMI context</span>
<span class="p_add">+ * in_task()	  - We&#39;re in task context</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note: due to the BH disabled confusion: in_softirq(),in_interrupt() really</span>
<span class="p_add">+ *       should not be used in new code.</span>
  */
 #define in_irq()		(hardirq_count())
 #define in_softirq()		(softirq_count())
 #define in_interrupt()		(irq_count())
 #define in_serving_softirq()	(softirq_count() &amp; SOFTIRQ_OFFSET)
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Are we in NMI context?</span>
<span class="p_del">- */</span>
<span class="p_del">-#define in_nmi()	(preempt_count() &amp; NMI_MASK)</span>
<span class="p_add">+#define in_nmi()		(preempt_count() &amp; NMI_MASK)</span>
<span class="p_add">+#define in_task()		(!(preempt_count() &amp; \</span>
<span class="p_add">+				   (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET)))</span>
 
 /*
  * The preempt_count offset after preempt_disable();
<span class="p_header">diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h</span>
<span class="p_header">index 608d90444b6f..5af4994cac23 100644</span>
<span class="p_header">--- a/include/linux/ptrace.h</span>
<span class="p_header">+++ b/include/linux/ptrace.h</span>
<span class="p_chunk">@@ -8,6 +8,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/pid_namespace.h&gt;	/* For task_active_pid_ns.  */
 #include &lt;uapi/linux/ptrace.h&gt;
 
<span class="p_add">+extern int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,</span>
<span class="p_add">+			    void *buf, int len, int write);</span>
<span class="p_add">+</span>
 /*
  * Ptrace flags
  *
<span class="p_chunk">@@ -19,7 +22,6 @@</span> <span class="p_context"></span>
 #define PT_SEIZED	0x00010000	/* SEIZE used, enable new behavior */
 #define PT_PTRACED	0x00000001
 #define PT_DTRACE	0x00000002	/* delayed trace (used on m68k, i386) */
<span class="p_del">-#define PT_PTRACE_CAP	0x00000004	/* ptracer can follow suid-exec */</span>
 
 #define PT_OPT_FLAG_SHIFT	3
 /* PT_TRACE_* event enable flags */
<span class="p_chunk">@@ -50,7 +52,8 @@</span> <span class="p_context"> extern int ptrace_request(struct task_struct *child, long request,</span>
 			  unsigned long addr, unsigned long data);
 extern void ptrace_notify(int exit_code);
 extern void __ptrace_link(struct task_struct *child,
<span class="p_del">-			  struct task_struct *new_parent);</span>
<span class="p_add">+			  struct task_struct *new_parent,</span>
<span class="p_add">+			  const struct cred *ptracer_cred);</span>
 extern void __ptrace_unlink(struct task_struct *child);
 extern void exit_ptrace(struct task_struct *tracer);
 #define PTRACE_MODE_READ	0x01
<span class="p_chunk">@@ -202,7 +205,7 @@</span> <span class="p_context"> static inline void ptrace_init_task(struct task_struct *child, bool ptrace)</span>
 
 	if (unlikely(ptrace) &amp;&amp; current-&gt;ptrace) {
 		child-&gt;ptrace = current-&gt;ptrace;
<span class="p_del">-		__ptrace_link(child, current-&gt;parent);</span>
<span class="p_add">+		__ptrace_link(child, current-&gt;parent, current-&gt;ptracer_cred);</span>
 
 		if (child-&gt;ptrace &amp; PT_SEIZED)
 			task_set_jobctl_pending(child, JOBCTL_TRAP_STOP);
<span class="p_chunk">@@ -211,6 +214,8 @@</span> <span class="p_context"> static inline void ptrace_init_task(struct task_struct *child, bool ptrace)</span>
 
 		set_tsk_thread_flag(child, TIF_SIGPENDING);
 	}
<span class="p_add">+	else</span>
<span class="p_add">+		child-&gt;ptracer_cred = NULL;</span>
 }
 
 /**
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index 25ad8f0bbdcb..ca9589027893 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -1385,6 +1385,7 @@</span> <span class="p_context"> struct task_struct {</span>
 	struct list_head cpu_timers[3];
 
 /* process credentials */
<span class="p_add">+	const struct cred __rcu *ptracer_cred; /* Tracer&#39;s credentials at attach */</span>
 	const struct cred __rcu *real_cred; /* objective and real subjective task
 					 * credentials (COW) */
 	const struct cred __rcu *cred;	/* effective (overridable) subjective task
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index 63c9d381e0d9..93431a42f2f9 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -2965,6 +2965,13 @@</span> <span class="p_context"> static inline void nf_reset_trace(struct sk_buff *skb)</span>
 #endif
 }
 
<span class="p_add">+static inline void ipvs_reset(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_IP_VS)</span>
<span class="p_add">+	skb-&gt;ipvs_property = 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Note: This doesn&#39;t put any conntrack and bridge info in dst. */
 static inline void __nf_copy(struct sk_buff *dst, const struct sk_buff *src)
 {
<span class="p_header">diff --git a/include/net/protocol.h b/include/net/protocol.h</span>
<span class="p_header">index d6fcc1fcdb5b..035971919ced 100644</span>
<span class="p_header">--- a/include/net/protocol.h</span>
<span class="p_header">+++ b/include/net/protocol.h</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"></span>
 
 /* This is used to register protocols. */
 struct net_protocol {
<span class="p_del">-	void			(*early_demux)(struct sk_buff *skb);</span>
<span class="p_add">+	int			(*early_demux)(struct sk_buff *skb);</span>
 	int			(*handler)(struct sk_buff *skb);
 	void			(*err_handler)(struct sk_buff *skb, u32 info);
 	unsigned int		no_policy:1,
<span class="p_header">diff --git a/include/net/route.h b/include/net/route.h</span>
<span class="p_header">index b17cf28f996e..671d5b1c813b 100644</span>
<span class="p_header">--- a/include/net/route.h</span>
<span class="p_header">+++ b/include/net/route.h</span>
<span class="p_chunk">@@ -159,7 +159,9 @@</span> <span class="p_context"> static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4</span>
 	fl4-&gt;fl4_gre_key = gre_key;
 	return ip_route_output_key(net, fl4);
 }
<span class="p_del">-</span>
<span class="p_add">+int ip_mc_validate_source(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
<span class="p_add">+			  u8 tos, struct net_device *dev,</span>
<span class="p_add">+			  struct in_device *in_dev, u32 *itag);</span>
 int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
 			 u8 tos, struct net_device *devin);
 
<span class="p_header">diff --git a/include/net/tcp.h b/include/net/tcp.h</span>
<span class="p_header">index ceaa03fdccf2..6f404e98876a 100644</span>
<span class="p_header">--- a/include/net/tcp.h</span>
<span class="p_header">+++ b/include/net/tcp.h</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> void tcp_v4_err(struct sk_buff *skb, u32);</span>
 
 void tcp_shutdown(struct sock *sk, int how);
 
<span class="p_del">-void tcp_v4_early_demux(struct sk_buff *skb);</span>
<span class="p_add">+int tcp_v4_early_demux(struct sk_buff *skb);</span>
 int tcp_v4_rcv(struct sk_buff *skb);
 
 int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
<span class="p_chunk">@@ -1515,12 +1515,12 @@</span> <span class="p_context"> static inline void tcp_highest_sack_reset(struct sock *sk)</span>
 	tcp_sk(sk)-&gt;highest_sack = tcp_write_queue_head(sk);
 }
 
<span class="p_del">-/* Called when old skb is about to be deleted (to be combined with new skb) */</span>
<span class="p_del">-static inline void tcp_highest_sack_combine(struct sock *sk,</span>
<span class="p_add">+/* Called when old skb is about to be deleted and replaced by new skb */</span>
<span class="p_add">+static inline void tcp_highest_sack_replace(struct sock *sk,</span>
 					    struct sk_buff *old,
 					    struct sk_buff *new)
 {
<span class="p_del">-	if (tcp_sk(sk)-&gt;sacked_out &amp;&amp; (old == tcp_sk(sk)-&gt;highest_sack))</span>
<span class="p_add">+	if (old == tcp_highest_sack(sk))</span>
 		tcp_sk(sk)-&gt;highest_sack = new;
 }
 
<span class="p_header">diff --git a/include/net/udp.h b/include/net/udp.h</span>
<span class="p_header">index 68a1fefe3dfe..12f4f5b02986 100644</span>
<span class="p_header">--- a/include/net/udp.h</span>
<span class="p_header">+++ b/include/net/udp.h</span>
<span class="p_chunk">@@ -177,7 +177,7 @@</span> <span class="p_context"> int udp_lib_get_port(struct sock *sk, unsigned short snum,</span>
 		     unsigned int hash2_nulladdr);
 
 /* net/ipv4/udp.c */
<span class="p_del">-void udp_v4_early_demux(struct sk_buff *skb);</span>
<span class="p_add">+int udp_v4_early_demux(struct sk_buff *skb);</span>
 int udp_get_port(struct sock *sk, unsigned short snum,
 		 int (*saddr_cmp)(const struct sock *,
 				  const struct sock *));
<span class="p_header">diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h</span>
<span class="p_header">index 6868a5ca183c..ab5bfaa8f9de 100644</span>
<span class="p_header">--- a/include/scsi/scsi_device.h</span>
<span class="p_header">+++ b/include/scsi/scsi_device.h</span>
<span class="p_chunk">@@ -175,6 +175,7 @@</span> <span class="p_context"> struct scsi_device {</span>
 	unsigned wce_default_on:1;	/* Cache is ON by default */
 	unsigned no_dif:1;	/* T10 PI (DIF) should be disabled */
 	unsigned broken_fua:1;		/* Don&#39;t set FUA bit */
<span class="p_add">+	unsigned unmap_limit_for_ws:1;	/* Use the UNMAP limit for WRITE SAME */</span>
 
 	atomic_t disk_events_disable_depth; /* disable depth for disk events */
 
<span class="p_header">diff --git a/include/scsi/scsi_devinfo.h b/include/scsi/scsi_devinfo.h</span>
<span class="p_header">index 96e3f56519e7..b29faa3471ed 100644</span>
<span class="p_header">--- a/include/scsi/scsi_devinfo.h</span>
<span class="p_header">+++ b/include/scsi/scsi_devinfo.h</span>
<span class="p_chunk">@@ -37,5 +37,6 @@</span> <span class="p_context"></span>
 #define BLIST_TRY_VPD_PAGES	0x10000000 /* Attempt to read VPD pages */
 #define BLIST_NO_RSOC		0x20000000 /* don&#39;t try to issue RSOC */
 #define BLIST_MAX_1024		0x40000000 /* maximum 1024 sector cdb length */
<span class="p_add">+#define BLIST_UNMAP_LIMIT_WS	0x80000000 /* Use UNMAP limit for WRITE SAME */</span>
 
 #endif
<span class="p_header">diff --git a/include/sound/seq_kernel.h b/include/sound/seq_kernel.h</span>
<span class="p_header">index 2398521f0998..d06bb8109cdc 100644</span>
<span class="p_header">--- a/include/sound/seq_kernel.h</span>
<span class="p_header">+++ b/include/sound/seq_kernel.h</span>
<span class="p_chunk">@@ -55,7 +55,8 @@</span> <span class="p_context"> typedef union snd_seq_timestamp snd_seq_timestamp_t;</span>
 #define SNDRV_SEQ_DEFAULT_CLIENT_EVENTS	200
 
 /* max delivery path length */
<span class="p_del">-#define SNDRV_SEQ_MAX_HOPS		10</span>
<span class="p_add">+/* NOTE: this shouldn&#39;t be greater than MAX_LOCKDEP_SUBCLASSES */</span>
<span class="p_add">+#define SNDRV_SEQ_MAX_HOPS		8</span>
 
 /* max size of event size */
 #define SNDRV_SEQ_MAX_EVENT_LEN		0x3fffffff
<span class="p_header">diff --git a/include/sound/seq_virmidi.h b/include/sound/seq_virmidi.h</span>
<span class="p_header">index a03acd0d398a..695257ae64ac 100644</span>
<span class="p_header">--- a/include/sound/seq_virmidi.h</span>
<span class="p_header">+++ b/include/sound/seq_virmidi.h</span>
<span class="p_chunk">@@ -60,6 +60,7 @@</span> <span class="p_context"> struct snd_virmidi_dev {</span>
 	int port;			/* created/attached port */
 	unsigned int flags;		/* SNDRV_VIRMIDI_* */
 	rwlock_t filelist_lock;
<span class="p_add">+	struct rw_semaphore filelist_sem;</span>
 	struct list_head filelist;
 };
 
<span class="p_header">diff --git a/include/sound/timer.h b/include/sound/timer.h</span>
<span class="p_header">index 7990469a44ce..b0489b850c93 100644</span>
<span class="p_header">--- a/include/sound/timer.h</span>
<span class="p_header">+++ b/include/sound/timer.h</span>
<span class="p_chunk">@@ -90,6 +90,8 @@</span> <span class="p_context"> struct snd_timer {</span>
 	struct list_head ack_list_head;
 	struct list_head sack_list_head; /* slow ack list head */
 	struct tasklet_struct task_queue;
<span class="p_add">+	int max_instances;	/* upper limit of timer instances */</span>
<span class="p_add">+	int num_instances;	/* current number of timer instances */</span>
 };
 
 struct snd_timer_instance {
<span class="p_header">diff --git a/include/trace/events/kvm.h b/include/trace/events/kvm.h</span>
<span class="p_header">index 131a0bda7aec..bb71db2d884d 100644</span>
<span class="p_header">--- a/include/trace/events/kvm.h</span>
<span class="p_header">+++ b/include/trace/events/kvm.h</span>
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> TRACE_EVENT(kvm_ack_irq,</span>
 	{ KVM_TRACE_MMIO_WRITE, &quot;write&quot; }
 
 TRACE_EVENT(kvm_mmio,
<span class="p_del">-	TP_PROTO(int type, int len, u64 gpa, u64 val),</span>
<span class="p_add">+	TP_PROTO(int type, int len, u64 gpa, void *val),</span>
 	TP_ARGS(type, len, gpa, val),
 
 	TP_STRUCT__entry(
<span class="p_chunk">@@ -177,7 +177,10 @@</span> <span class="p_context"> TRACE_EVENT(kvm_mmio,</span>
 		__entry-&gt;type		= type;
 		__entry-&gt;len		= len;
 		__entry-&gt;gpa		= gpa;
<span class="p_del">-		__entry-&gt;val		= val;</span>
<span class="p_add">+		__entry-&gt;val		= 0;</span>
<span class="p_add">+		if (val)</span>
<span class="p_add">+			memcpy(&amp;__entry-&gt;val, val,</span>
<span class="p_add">+			       min_t(u32, sizeof(__entry-&gt;val), len));</span>
 	),
 
 	TP_printk(&quot;mmio %s len %u gpa 0x%llx val 0x%llx&quot;,
<span class="p_header">diff --git a/include/uapi/linux/spi/spidev.h b/include/uapi/linux/spi/spidev.h</span>
<span class="p_header">index dd5f21e75805..856de39d0b89 100644</span>
<span class="p_header">--- a/include/uapi/linux/spi/spidev.h</span>
<span class="p_header">+++ b/include/uapi/linux/spi/spidev.h</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #define SPIDEV_H
 
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;linux/ioctl.h&gt;</span>
 
 /* User space versions of kernel symbols for SPI clocking modes,
  * matching &lt;linux/spi/spi.h&gt;
<span class="p_header">diff --git a/kernel/capability.c b/kernel/capability.c</span>
<span class="p_header">index 989f5bfc57dc..4a840b038303 100644</span>
<span class="p_header">--- a/kernel/capability.c</span>
<span class="p_header">+++ b/kernel/capability.c</span>
<span class="p_chunk">@@ -427,6 +427,19 @@</span> <span class="p_context"> bool capable(int cap)</span>
 }
 EXPORT_SYMBOL(capable);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * privileged_wrt_inode_uidgid - Do capabilities in the namespace work over the inode?</span>
<span class="p_add">+ * @ns: The user namespace in question</span>
<span class="p_add">+ * @inode: The inode in question</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return true if the inode uid and gid are within the namespace.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kuid_has_mapping(ns, inode-&gt;i_uid) &amp;&amp;</span>
<span class="p_add">+		kgid_has_mapping(ns, inode-&gt;i_gid);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * capable_wrt_inode_uidgid - Check nsown_capable and uid and gid mapped
  * @inode: The inode in question
<span class="p_chunk">@@ -440,7 +453,26 @@</span> <span class="p_context"> bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)</span>
 {
 	struct user_namespace *ns = current_user_ns();
 
<span class="p_del">-	return ns_capable(ns, cap) &amp;&amp; kuid_has_mapping(ns, inode-&gt;i_uid) &amp;&amp;</span>
<span class="p_del">-		kgid_has_mapping(ns, inode-&gt;i_gid);</span>
<span class="p_add">+	return ns_capable(ns, cap) &amp;&amp; privileged_wrt_inode_uidgid(ns, inode);</span>
 }
 EXPORT_SYMBOL(capable_wrt_inode_uidgid);
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * ptracer_capable - Determine if the ptracer holds CAP_SYS_PTRACE in the namespace</span>
<span class="p_add">+ * @tsk: The task that may be ptraced</span>
<span class="p_add">+ * @ns: The user namespace to search for CAP_SYS_PTRACE in</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return true if the task that is ptracing the current task had CAP_SYS_PTRACE</span>
<span class="p_add">+ * in the specified user namespace.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;  /* An absent tracer adds no restrictions */</span>
<span class="p_add">+	const struct cred *cred;</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	cred = rcu_dereference(tsk-&gt;ptracer_cred);</span>
<span class="p_add">+	if (cred)</span>
<span class="p_add">+		ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return (ret == 0);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index f6422f07d133..0a2f907b1302 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -527,7 +527,8 @@</span> <span class="p_context"> static void mm_init_aio(struct mm_struct *mm)</span>
 #endif
 }
 
<span class="p_del">-static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p)</span>
<span class="p_add">+static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,</span>
<span class="p_add">+	struct user_namespace *user_ns)</span>
 {
 	atomic_set(&amp;mm-&gt;mm_users, 1);
 	atomic_set(&amp;mm-&gt;mm_count, 1);
<span class="p_chunk">@@ -551,6 +552,7 @@</span> <span class="p_context"> static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p)</span>
 
 	if (likely(!mm_alloc_pgd(mm))) {
 		mmu_notifier_mm_init(mm);
<span class="p_add">+		mm-&gt;user_ns = get_user_ns(user_ns);</span>
 		return mm;
 	}
 
<span class="p_chunk">@@ -588,7 +590,7 @@</span> <span class="p_context"> struct mm_struct *mm_alloc(void)</span>
 
 	memset(mm, 0, sizeof(*mm));
 	mm_init_cpumask(mm);
<span class="p_del">-	return mm_init(mm, current);</span>
<span class="p_add">+	return mm_init(mm, current, current_user_ns());</span>
 }
 
 /*
<span class="p_chunk">@@ -603,6 +605,7 @@</span> <span class="p_context"> void __mmdrop(struct mm_struct *mm)</span>
 	destroy_context(mm);
 	mmu_notifier_mm_destroy(mm);
 	check_mm(mm);
<span class="p_add">+	put_user_ns(mm-&gt;user_ns);</span>
 	free_mm(mm);
 }
 EXPORT_SYMBOL_GPL(__mmdrop);
<span class="p_chunk">@@ -822,7 +825,7 @@</span> <span class="p_context"> static struct mm_struct *dup_mm(struct task_struct *tsk)</span>
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; !USE_SPLIT_PMD_PTLOCKS
 	mm-&gt;pmd_huge_pte = NULL;
 #endif
<span class="p_del">-	if (!mm_init(mm, tsk))</span>
<span class="p_add">+	if (!mm_init(mm, tsk, mm-&gt;user_ns))</span>
 		goto fail_nomem;
 
 	if (init_new_context(tsk, mm))
<span class="p_header">diff --git a/kernel/params.c b/kernel/params.c</span>
<span class="p_header">index 1e52ca233fd9..20b5f8fe7eef 100644</span>
<span class="p_header">--- a/kernel/params.c</span>
<span class="p_header">+++ b/kernel/params.c</span>
<span class="p_chunk">@@ -581,7 +581,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(__kernel_param_unlock);</span>
 /*
  * add_sysfs_param - add a parameter to sysfs
  * @mk: struct module_kobject
<span class="p_del">- * @kparam: the actual parameter definition to add to sysfs</span>
<span class="p_add">+ * @kp: the actual parameter definition to add to sysfs</span>
  * @name: name of parameter
  *
  * Create a kobject if for a (per-module) parameter if mp NULL, and
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index 7660e8eae6f6..96a418e507e6 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -27,6 +27,35 @@</span> <span class="p_context"></span>
 #include &lt;linux/cn_proc.h&gt;
 #include &lt;linux/compat.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Access another process&#39; address space via ptrace.</span>
<span class="p_add">+ * Source/target buffer must be kernel space,</span>
<span class="p_add">+ * Do not walk the page table directly, use get_user_pages</span>
<span class="p_add">+ */</span>
<span class="p_add">+int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,</span>
<span class="p_add">+		     void *buf, int len, int write)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mm = get_task_mm(tsk);</span>
<span class="p_add">+	if (!mm)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tsk-&gt;ptrace ||</span>
<span class="p_add">+	    (current != tsk-&gt;parent) ||</span>
<span class="p_add">+	    ((get_dumpable(mm) != SUID_DUMP_USER) &amp;&amp;</span>
<span class="p_add">+	     !ptracer_capable(tsk, mm-&gt;user_ns))) {</span>
<span class="p_add">+		mmput(mm);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = __access_remote_vm(tsk, mm, addr, buf, len, write);</span>
<span class="p_add">+	mmput(mm);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 
 static int ptrace_trapping_sleep_fn(void *flags)
 {
<span class="p_chunk">@@ -34,17 +63,26 @@</span> <span class="p_context"> static int ptrace_trapping_sleep_fn(void *flags)</span>
 	return 0;
 }
 
<span class="p_add">+void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span>
<span class="p_add">+		   const struct cred *ptracer_cred)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(!list_empty(&amp;child-&gt;ptrace_entry));</span>
<span class="p_add">+	list_add(&amp;child-&gt;ptrace_entry, &amp;new_parent-&gt;ptraced);</span>
<span class="p_add">+	child-&gt;parent = new_parent;</span>
<span class="p_add">+	child-&gt;ptracer_cred = get_cred(ptracer_cred);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * ptrace a task: make the debugger its new parent and
  * move it to the ptrace list.
  *
  * Must be called with the tasklist lock write-held.
  */
<span class="p_del">-void __ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span>
<span class="p_add">+static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span>
 {
<span class="p_del">-	BUG_ON(!list_empty(&amp;child-&gt;ptrace_entry));</span>
<span class="p_del">-	list_add(&amp;child-&gt;ptrace_entry, &amp;new_parent-&gt;ptraced);</span>
<span class="p_del">-	child-&gt;parent = new_parent;</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	__ptrace_link(child, new_parent, __task_cred(new_parent));</span>
<span class="p_add">+	rcu_read_unlock();</span>
 }
 
 /**
<span class="p_chunk">@@ -77,14 +115,17 @@</span> <span class="p_context"> void __ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span>
  */
 void __ptrace_unlink(struct task_struct *child)
 {
<span class="p_add">+	const struct cred *old_cred;</span>
 	BUG_ON(!child-&gt;ptrace);
 
<span class="p_del">-	child-&gt;ptrace = 0;</span>
 	child-&gt;parent = child-&gt;real_parent;
 	list_del_init(&amp;child-&gt;ptrace_entry);
<span class="p_add">+	old_cred = child-&gt;ptracer_cred;</span>
<span class="p_add">+	child-&gt;ptracer_cred = NULL;</span>
<span class="p_add">+	put_cred(old_cred);</span>
 
 	spin_lock(&amp;child-&gt;sighand-&gt;siglock);
<span class="p_del">-</span>
<span class="p_add">+	child-&gt;ptrace = 0;</span>
 	/*
 	 * Clear all pending traps and TRAPPING.  TRAPPING should be
 	 * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.
<span class="p_chunk">@@ -231,7 +272,7 @@</span> <span class="p_context"> static int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)</span>
 static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 {
 	const struct cred *cred = current_cred(), *tcred;
<span class="p_del">-	int dumpable = 0;</span>
<span class="p_add">+	struct mm_struct *mm;</span>
 	kuid_t caller_uid;
 	kgid_t caller_gid;
 
<span class="p_chunk">@@ -282,16 +323,11 @@</span> <span class="p_context"> static int __ptrace_may_access(struct task_struct *task, unsigned int mode)</span>
 	return -EPERM;
 ok:
 	rcu_read_unlock();
<span class="p_del">-	smp_rmb();</span>
<span class="p_del">-	if (task-&gt;mm)</span>
<span class="p_del">-		dumpable = get_dumpable(task-&gt;mm);</span>
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	if (dumpable != SUID_DUMP_USER &amp;&amp;</span>
<span class="p_del">-	    !ptrace_has_cap(__task_cred(task)-&gt;user_ns, mode)) {</span>
<span class="p_del">-		rcu_read_unlock();</span>
<span class="p_del">-		return -EPERM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_add">+	mm = task-&gt;mm;</span>
<span class="p_add">+	if (mm &amp;&amp;</span>
<span class="p_add">+	    ((get_dumpable(mm) != SUID_DUMP_USER) &amp;&amp;</span>
<span class="p_add">+	     !ptrace_has_cap(mm-&gt;user_ns, mode)))</span>
<span class="p_add">+	    return -EPERM;</span>
 
 	return security_ptrace_access_check(task, mode);
 }
<span class="p_chunk">@@ -355,13 +391,9 @@</span> <span class="p_context"> static int ptrace_attach(struct task_struct *task, long request,</span>
 
 	if (seize)
 		flags |= PT_SEIZED;
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	if (ns_capable(__task_cred(task)-&gt;user_ns, CAP_SYS_PTRACE))</span>
<span class="p_del">-		flags |= PT_PTRACE_CAP;</span>
<span class="p_del">-	rcu_read_unlock();</span>
 	task-&gt;ptrace = flags;
 
<span class="p_del">-	__ptrace_link(task, current);</span>
<span class="p_add">+	ptrace_link(task, current);</span>
 
 	/* SEIZE doesn&#39;t trap tracee on attach */
 	if (!seize)
<span class="p_chunk">@@ -428,7 +460,7 @@</span> <span class="p_context"> static int ptrace_traceme(void)</span>
 		 */
 		if (!ret &amp;&amp; !(current-&gt;real_parent-&gt;flags &amp; PF_EXITING)) {
 			current-&gt;ptrace = PT_PTRACED;
<span class="p_del">-			__ptrace_link(current, current-&gt;real_parent);</span>
<span class="p_add">+			ptrace_link(current, current-&gt;real_parent);</span>
 		}
 	}
 	write_unlock_irq(&amp;tasklist_lock);
<span class="p_chunk">@@ -561,7 +593,8 @@</span> <span class="p_context"> int ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst</span>
 		int this_len, retval;
 
 		this_len = (len &gt; sizeof(buf)) ? sizeof(buf) : len;
<span class="p_del">-		retval = access_process_vm(tsk, src, buf, this_len, 0);</span>
<span class="p_add">+		retval = ptrace_access_vm(tsk, src, buf, this_len, 0);</span>
<span class="p_add">+</span>
 		if (!retval) {
 			if (copied)
 				break;
<span class="p_chunk">@@ -588,7 +621,7 @@</span> <span class="p_context"> int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long ds</span>
 		this_len = (len &gt; sizeof(buf)) ? sizeof(buf) : len;
 		if (copy_from_user(buf, src, this_len))
 			return -EFAULT;
<span class="p_del">-		retval = access_process_vm(tsk, dst, buf, this_len, 1);</span>
<span class="p_add">+		retval = ptrace_access_vm(tsk, dst, buf, this_len, 1);</span>
 		if (!retval) {
 			if (copied)
 				break;
<span class="p_chunk">@@ -1133,7 +1166,7 @@</span> <span class="p_context"> int generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,</span>
 	unsigned long tmp;
 	int copied;
 
<span class="p_del">-	copied = access_process_vm(tsk, addr, &amp;tmp, sizeof(tmp), 0);</span>
<span class="p_add">+	copied = ptrace_access_vm(tsk, addr, &amp;tmp, sizeof(tmp), 0);</span>
 	if (copied != sizeof(tmp))
 		return -EIO;
 	return put_user(tmp, (unsigned long __user *)data);
<span class="p_chunk">@@ -1144,7 +1177,7 @@</span> <span class="p_context"> int generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,</span>
 {
 	int copied;
 
<span class="p_del">-	copied = access_process_vm(tsk, addr, &amp;data, sizeof(data), 1);</span>
<span class="p_add">+	copied = ptrace_access_vm(tsk, addr, &amp;data, sizeof(data), 1);</span>
 	return (copied == sizeof(data)) ? 0 : -EIO;
 }
 
<span class="p_chunk">@@ -1162,7 +1195,7 @@</span> <span class="p_context"> int compat_ptrace_request(struct task_struct *child, compat_long_t request,</span>
 	switch (request) {
 	case PTRACE_PEEKTEXT:
 	case PTRACE_PEEKDATA:
<span class="p_del">-		ret = access_process_vm(child, addr, &amp;word, sizeof(word), 0);</span>
<span class="p_add">+		ret = ptrace_access_vm(child, addr, &amp;word, sizeof(word), 0);</span>
 		if (ret != sizeof(word))
 			ret = -EIO;
 		else
<span class="p_chunk">@@ -1171,7 +1204,7 @@</span> <span class="p_context"> int compat_ptrace_request(struct task_struct *child, compat_long_t request,</span>
 
 	case PTRACE_POKETEXT:
 	case PTRACE_POKEDATA:
<span class="p_del">-		ret = access_process_vm(child, addr, &amp;data, sizeof(data), 1);</span>
<span class="p_add">+		ret = ptrace_access_vm(child, addr, &amp;data, sizeof(data), 1);</span>
 		ret = (ret != sizeof(data) ? -EIO : 0);
 		break;
 
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 0940ee9603ae..e6c9458f4b49 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -5782,14 +5782,14 @@</span> <span class="p_context"> enum s_alloc {</span>
 static void
 build_group_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)
 {
<span class="p_del">-	const struct cpumask *span = sched_domain_span(sd);</span>
<span class="p_add">+	const struct cpumask *sg_span = sched_group_cpus(sg);</span>
 	struct sd_data *sdd = sd-&gt;private;
 	struct sched_domain *sibling;
 	int i;
 
 	cpumask_clear(mask);
 
<span class="p_del">-	for_each_cpu(i, span) {</span>
<span class="p_add">+	for_each_cpu(i, sg_span) {</span>
 		sibling = *per_cpu_ptr(sdd-&gt;sd, i);
 
 		/*
<span class="p_chunk">@@ -5801,7 +5801,7 @@</span> <span class="p_context"> build_group_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask</span>
 			continue;
 
 		/* If we would not end up here, we can&#39;t continue from here */
<span class="p_del">-		if (!cpumask_equal(span, sched_domain_span(sibling-&gt;child)))</span>
<span class="p_add">+		if (!cpumask_equal(sg_span, sched_domain_span(sibling-&gt;child)))</span>
 			continue;
 
 		cpumask_set_cpu(i, mask);
<span class="p_chunk">@@ -5869,7 +5869,7 @@</span> <span class="p_context"> static void init_overlap_sched_group(struct sched_domain *sd,</span>
 static int
 build_overlap_sched_groups(struct sched_domain *sd, int cpu)
 {
<span class="p_del">-	struct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg;</span>
<span class="p_add">+	struct sched_group *first = NULL, *last = NULL, *sg;</span>
 	const struct cpumask *span = sched_domain_span(sd);
 	struct cpumask *covered = sched_domains_tmpmask;
 	struct sd_data *sdd = sd-&gt;private;
<span class="p_chunk">@@ -5899,15 +5899,6 @@</span> <span class="p_context"> build_overlap_sched_groups(struct sched_domain *sd, int cpu)</span>
 
 		init_overlap_sched_group(sd, sg);
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Make sure the first group of this domain contains the</span>
<span class="p_del">-		 * canonical balance cpu. Otherwise the sched_domain iteration</span>
<span class="p_del">-		 * breaks. See update_sg_lb_stats().</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if ((!groups &amp;&amp; cpumask_test_cpu(cpu, sg_span)) ||</span>
<span class="p_del">-		    group_balance_cpu(sg) == cpu)</span>
<span class="p_del">-			groups = sg;</span>
<span class="p_del">-</span>
 		if (!first)
 			first = sg;
 		if (last)
<span class="p_chunk">@@ -5915,7 +5906,7 @@</span> <span class="p_context"> build_overlap_sched_groups(struct sched_domain *sd, int cpu)</span>
 		last = sg;
 		last-&gt;next = first;
 	}
<span class="p_del">-	sd-&gt;groups = groups;</span>
<span class="p_add">+	sd-&gt;groups = first;</span>
 
 	return 0;
 
<span class="p_chunk">@@ -6631,7 +6622,7 @@</span> <span class="p_context"> static int build_sched_domains(const struct cpumask *cpu_map,</span>
 			sd = build_sched_domain(tl, cpu_map, attr, sd, i);
 			if (tl == sched_domain_topology)
 				*per_cpu_ptr(d.sd, i) = sd;
<span class="p_del">-			if (tl-&gt;flags &amp; SDTL_OVERLAP || sched_feat(FORCE_SD_OVERLAP))</span>
<span class="p_add">+			if (tl-&gt;flags &amp; SDTL_OVERLAP)</span>
 				sd-&gt;flags |= SD_OVERLAP;
 			if (cpumask_equal(cpu_map, sched_domain_span(sd)))
 				break;
<span class="p_header">diff --git a/kernel/sched/features.h b/kernel/sched/features.h</span>
<span class="p_header">index 90284d117fe6..79bad00ea840 100644</span>
<span class="p_header">--- a/kernel/sched/features.h</span>
<span class="p_header">+++ b/kernel/sched/features.h</span>
<span class="p_chunk">@@ -56,7 +56,6 @@</span> <span class="p_context"> SCHED_FEAT(NONTASK_CAPACITY, true)</span>
  */
 SCHED_FEAT(TTWU_QUEUE, true)
 
<span class="p_del">-SCHED_FEAT(FORCE_SD_OVERLAP, false)</span>
 SCHED_FEAT(RT_RUNTIME_SHARE, true)
 SCHED_FEAT(LB_MIN, false)
 
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index 3a3172559b22..e918a641b1a0 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -342,7 +342,8 @@</span> <span class="p_context"> static struct ctl_table kern_table[] = {</span>
 		.data		= &amp;sysctl_sched_time_avg,
 		.maxlen		= sizeof(unsigned int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec,</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;one,</span>
 	},
 	{
 		.procname	= &quot;sched_shares_window_ns&quot;,
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 591bbffc2384..99b46db656e0 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -3191,11 +3191,17 @@</span> <span class="p_context"> static int tracing_open(struct inode *inode, struct file *file)</span>
 	/* If this file was open for write, then erase contents */
 	if ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; (file-&gt;f_flags &amp; O_TRUNC)) {
 		int cpu = tracing_get_cpu(inode);
<span class="p_add">+		struct trace_buffer *trace_buf = &amp;tr-&gt;trace_buffer;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_TRACER_MAX_TRACE</span>
<span class="p_add">+		if (tr-&gt;current_trace-&gt;print_max)</span>
<span class="p_add">+			trace_buf = &amp;tr-&gt;max_buffer;</span>
<span class="p_add">+#endif</span>
 
 		if (cpu == RING_BUFFER_ALL_CPUS)
<span class="p_del">-			tracing_reset_online_cpus(&amp;tr-&gt;trace_buffer);</span>
<span class="p_add">+			tracing_reset_online_cpus(trace_buf);</span>
 		else
<span class="p_del">-			tracing_reset(&amp;tr-&gt;trace_buffer, cpu);</span>
<span class="p_add">+			tracing_reset(trace_buf, cpu);</span>
 	}
 
 	if (file-&gt;f_mode &amp; FMODE_READ) {
<span class="p_chunk">@@ -4408,7 +4414,7 @@</span> <span class="p_context"> static int tracing_wait_pipe(struct file *filp)</span>
 		 *
 		 * iter-&gt;pos will be 0 if we haven&#39;t read anything.
 		 */
<span class="p_del">-		if (!tracing_is_on() &amp;&amp; iter-&gt;pos)</span>
<span class="p_add">+		if (!tracer_tracing_is_on(iter-&gt;tr) &amp;&amp; iter-&gt;pos)</span>
 			break;
 
 		mutex_unlock(&amp;iter-&gt;mutex);
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index 146fb7784900..9bf0b4bd3cc7 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -68,6 +68,7 @@</span> <span class="p_context"> enum {</span>
 	 * attach_mutex to avoid changing binding state while
 	 * worker_attach_to_pool() is in progress.
 	 */
<span class="p_add">+	POOL_MANAGER_ACTIVE	= 1 &lt;&lt; 0,	/* being managed */</span>
 	POOL_DISASSOCIATED	= 1 &lt;&lt; 2,	/* cpu can&#39;t serve workers */
 
 	/* worker flags */
<span class="p_chunk">@@ -158,7 +159,6 @@</span> <span class="p_context"> struct worker_pool {</span>
 						/* L: hash of busy workers */
 
 	/* see manage_workers() for details on the two manager mutexes */
<span class="p_del">-	struct mutex		manager_arb;	/* manager arbitration */</span>
 	struct mutex		attach_mutex;	/* attach/detach exclusion */
 	struct list_head	workers;	/* A: attached workers */
 	struct completion	*detach_completion; /* all workers detached */
<span class="p_chunk">@@ -288,6 +288,7 @@</span> <span class="p_context"> static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;</span>
 
 static DEFINE_MUTEX(wq_pool_mutex);	/* protects pools and workqueues list */
 static DEFINE_SPINLOCK(wq_mayday_lock);	/* protects wq-&gt;maydays list */
<span class="p_add">+static DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait); /* wait for manager to go away */</span>
 
 static LIST_HEAD(workqueues);		/* PL: list of all workqueues */
 static bool workqueue_freezing;		/* PL: have wqs started freezing? */
<span class="p_chunk">@@ -793,7 +794,7 @@</span> <span class="p_context"> static bool need_to_create_worker(struct worker_pool *pool)</span>
 /* Do we have too many workers and should some go away? */
 static bool too_many_workers(struct worker_pool *pool)
 {
<span class="p_del">-	bool managing = mutex_is_locked(&amp;pool-&gt;manager_arb);</span>
<span class="p_add">+	bool managing = pool-&gt;flags &amp; POOL_MANAGER_ACTIVE;</span>
 	int nr_idle = pool-&gt;nr_idle + managing; /* manager is considered idle */
 	int nr_busy = pool-&gt;nr_workers - nr_idle;
 
<span class="p_chunk">@@ -1996,22 +1997,15 @@</span> <span class="p_context"> static bool manage_workers(struct worker *worker)</span>
 {
 	struct worker_pool *pool = worker-&gt;pool;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Anyone who successfully grabs manager_arb wins the arbitration</span>
<span class="p_del">-	 * and becomes the manager.  mutex_trylock() on pool-&gt;manager_arb</span>
<span class="p_del">-	 * failure while holding pool-&gt;lock reliably indicates that someone</span>
<span class="p_del">-	 * else is managing the pool and the worker which failed trylock</span>
<span class="p_del">-	 * can proceed to executing work items.  This means that anyone</span>
<span class="p_del">-	 * grabbing manager_arb is responsible for actually performing</span>
<span class="p_del">-	 * manager duties.  If manager_arb is grabbed and released without</span>
<span class="p_del">-	 * actual management, the pool may stall indefinitely.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!mutex_trylock(&amp;pool-&gt;manager_arb))</span>
<span class="p_add">+	if (pool-&gt;flags &amp; POOL_MANAGER_ACTIVE)</span>
 		return false;
 
<span class="p_add">+	pool-&gt;flags |= POOL_MANAGER_ACTIVE;</span>
<span class="p_add">+</span>
 	maybe_create_worker(pool);
 
<span class="p_del">-	mutex_unlock(&amp;pool-&gt;manager_arb);</span>
<span class="p_add">+	pool-&gt;flags &amp;= ~POOL_MANAGER_ACTIVE;</span>
<span class="p_add">+	wake_up(&amp;wq_manager_wait);</span>
 	return true;
 }
 
<span class="p_chunk">@@ -3490,7 +3484,6 @@</span> <span class="p_context"> static int init_worker_pool(struct worker_pool *pool)</span>
 	setup_timer(&amp;pool-&gt;mayday_timer, pool_mayday_timeout,
 		    (unsigned long)pool);
 
<span class="p_del">-	mutex_init(&amp;pool-&gt;manager_arb);</span>
 	mutex_init(&amp;pool-&gt;attach_mutex);
 	INIT_LIST_HEAD(&amp;pool-&gt;workers);
 
<span class="p_chunk">@@ -3546,13 +3539,15 @@</span> <span class="p_context"> static void put_unbound_pool(struct worker_pool *pool)</span>
 	hash_del(&amp;pool-&gt;hash_node);
 
 	/*
<span class="p_del">-	 * Become the manager and destroy all workers.  Grabbing</span>
<span class="p_del">-	 * manager_arb prevents @pool&#39;s workers from blocking on</span>
<span class="p_del">-	 * attach_mutex.</span>
<span class="p_add">+	 * Become the manager and destroy all workers.  This prevents</span>
<span class="p_add">+	 * @pool&#39;s workers from blocking on attach_mutex.  We&#39;re the last</span>
<span class="p_add">+	 * manager and @pool gets freed with the flag set.</span>
 	 */
<span class="p_del">-	mutex_lock(&amp;pool-&gt;manager_arb);</span>
<span class="p_del">-</span>
 	spin_lock_irq(&amp;pool-&gt;lock);
<span class="p_add">+	wait_event_lock_irq(wq_manager_wait,</span>
<span class="p_add">+			    !(pool-&gt;flags &amp; POOL_MANAGER_ACTIVE), pool-&gt;lock);</span>
<span class="p_add">+	pool-&gt;flags |= POOL_MANAGER_ACTIVE;</span>
<span class="p_add">+</span>
 	while ((worker = first_idle_worker(pool)))
 		destroy_worker(worker);
 	WARN_ON(pool-&gt;nr_workers || pool-&gt;nr_idle);
<span class="p_chunk">@@ -3566,8 +3561,6 @@</span> <span class="p_context"> static void put_unbound_pool(struct worker_pool *pool)</span>
 	if (pool-&gt;detach_completion)
 		wait_for_completion(pool-&gt;detach_completion);
 
<span class="p_del">-	mutex_unlock(&amp;pool-&gt;manager_arb);</span>
<span class="p_del">-</span>
 	/* shut down the timers */
 	del_timer_sync(&amp;pool-&gt;idle_timer);
 	del_timer_sync(&amp;pool-&gt;mayday_timer);
<span class="p_header">diff --git a/kernel/workqueue_internal.h b/kernel/workqueue_internal.h</span>
<span class="p_header">index 45215870ac6c..3fa9c146fccb 100644</span>
<span class="p_header">--- a/kernel/workqueue_internal.h</span>
<span class="p_header">+++ b/kernel/workqueue_internal.h</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/workqueue.h&gt;
 #include &lt;linux/kthread.h&gt;
<span class="p_add">+#include &lt;linux/preempt.h&gt;</span>
 
 struct worker_pool;
 
<span class="p_chunk">@@ -59,7 +60,7 @@</span> <span class="p_context"> struct worker {</span>
  */
 static inline struct worker *current_wq_worker(void)
 {
<span class="p_del">-	if (current-&gt;flags &amp; PF_WQ_WORKER)</span>
<span class="p_add">+	if (in_task() &amp;&amp; (current-&gt;flags &amp; PF_WQ_WORKER))</span>
 		return kthread_data(current);
 	return NULL;
 }
<span class="p_header">diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c</span>
<span class="p_header">index 806c5b6b4b3a..162b6d290622 100644</span>
<span class="p_header">--- a/lib/asn1_decoder.c</span>
<span class="p_header">+++ b/lib/asn1_decoder.c</span>
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> int asn1_ber_decoder(const struct asn1_decoder *decoder,</span>
 		hdr = 2;
 
 		/* Extract a tag from the data */
<span class="p_del">-		if (unlikely(dp &gt;= datalen - 1))</span>
<span class="p_add">+		if (unlikely(datalen - dp &lt; 2))</span>
 			goto data_overrun_error;
 		tag = data[dp++];
 		if (unlikely((tag &amp; 0x1f) == ASN1_LONG_TAG))
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> int asn1_ber_decoder(const struct asn1_decoder *decoder,</span>
 				int n = len - 0x80;
 				if (unlikely(n &gt; 2))
 					goto length_too_long;
<span class="p_del">-				if (unlikely(dp &gt;= datalen - n))</span>
<span class="p_add">+				if (unlikely(n &gt; datalen - dp))</span>
 					goto data_overrun_error;
 				hdr += n;
 				for (len = 0; n &gt; 0; n--) {
<span class="p_chunk">@@ -276,6 +276,9 @@</span> <span class="p_context"> int asn1_ber_decoder(const struct asn1_decoder *decoder,</span>
 				if (unlikely(len &gt; datalen - dp))
 					goto data_overrun_error;
 			}
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (unlikely(len &gt; datalen - dp))</span>
<span class="p_add">+				goto data_overrun_error;</span>
 		}
 
 		if (flags &amp; FLAG_CONS) {
<span class="p_header">diff --git a/lib/digsig.c b/lib/digsig.c</span>
<span class="p_header">index ae05ea393fc8..4b8ef0bd315b 100644</span>
<span class="p_header">--- a/lib/digsig.c</span>
<span class="p_header">+++ b/lib/digsig.c</span>
<span class="p_chunk">@@ -86,6 +86,12 @@</span> <span class="p_context"> static int digsig_verify_rsa(struct key *key,</span>
 	down_read(&amp;key-&gt;sem);
 	ukp = key-&gt;payload.data;
 
<span class="p_add">+	if (!ukp) {</span>
<span class="p_add">+		/* key was revoked before we acquired its semaphore */</span>
<span class="p_add">+		err = -EKEYREVOKED;</span>
<span class="p_add">+		goto err1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (ukp-&gt;datalen &lt; sizeof(*pkh))
 		goto err1;
 
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index e1a6dce055a0..47c8bb45e781 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1230,17 +1230,11 @@</span> <span class="p_context"> struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,</span>
 
 	if (flags &amp; FOLL_TOUCH) {
 		pmd_t _pmd;
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We should set the dirty bit only for FOLL_WRITE but</span>
<span class="p_del">-		 * for now the dirty bit in the pmd is meaningless.</span>
<span class="p_del">-		 * And if the dirty bit will become meaningful and</span>
<span class="p_del">-		 * we&#39;ll only set it with FOLL_WRITE, an atomic</span>
<span class="p_del">-		 * set_bit will be required on the pmd to set the</span>
<span class="p_del">-		 * young bit, instead of the current set_pmd_at.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		_pmd = pmd_mkyoung(pmd_mkdirty(*pmd));</span>
<span class="p_add">+		_pmd = pmd_mkyoung(*pmd);</span>
<span class="p_add">+		if (flags &amp; FOLL_WRITE)</span>
<span class="p_add">+			_pmd = pmd_mkdirty(_pmd);</span>
 		if (pmdp_set_access_flags(vma, addr &amp; HPAGE_PMD_MASK,
<span class="p_del">-					  pmd, _pmd,  1))</span>
<span class="p_add">+					  pmd, _pmd, flags &amp; FOLL_WRITE))</span>
 			update_mmu_cache_pmd(vma, addr, pmd);
 	}
 	if ((flags &amp; FOLL_MLOCK) &amp;&amp; (vma-&gt;vm_flags &amp; VM_LOCKED)) {
<span class="p_header">diff --git a/mm/init-mm.c b/mm/init-mm.c</span>
<span class="p_header">index a56a851908d2..975e49f00f34 100644</span>
<span class="p_header">--- a/mm/init-mm.c</span>
<span class="p_header">+++ b/mm/init-mm.c</span>
<span class="p_chunk">@@ -6,6 +6,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/cpumask.h&gt;
 
 #include &lt;linux/atomic.h&gt;
<span class="p_add">+#include &lt;linux/user_namespace.h&gt;</span>
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/mmu.h&gt;
 
<span class="p_chunk">@@ -21,5 +22,6 @@</span> <span class="p_context"> struct mm_struct init_mm = {</span>
 	.mmap_sem	= __RWSEM_INITIALIZER(init_mm.mmap_sem),
 	.page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),
 	.mmlist		= LIST_HEAD_INIT(init_mm.mmlist),
<span class="p_add">+	.user_ns	= &amp;init_user_ns,</span>
 	INIT_MM_CONTEXT(init_mm)
 };
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index e1bde862d6d3..4ab5b0c55f4a 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -3560,7 +3560,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(generic_access_phys);</span>
  * Access another process&#39; address space as given in mm.  If non-NULL, use the
  * given task for page fault accounting.
  */
<span class="p_del">-static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span>
<span class="p_add">+int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span>
 		unsigned long addr, void *buf, int len, int write)
 {
 	struct vm_area_struct *vma;
<span class="p_header">diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c</span>
<span class="p_header">index 4174487a1261..1e0ec777523e 100644</span>
<span class="p_header">--- a/mm/memory_hotplug.c</span>
<span class="p_header">+++ b/mm/memory_hotplug.c</span>
<span class="p_chunk">@@ -520,7 +520,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(__add_pages);</span>
 
 #ifdef CONFIG_MEMORY_HOTREMOVE
 /* find the smallest valid pfn in the range [start_pfn, end_pfn) */
<span class="p_del">-static int find_smallest_section_pfn(int nid, struct zone *zone,</span>
<span class="p_add">+static unsigned long find_smallest_section_pfn(int nid, struct zone *zone,</span>
 				     unsigned long start_pfn,
 				     unsigned long end_pfn)
 {
<span class="p_chunk">@@ -545,7 +545,7 @@</span> <span class="p_context"> static int find_smallest_section_pfn(int nid, struct zone *zone,</span>
 }
 
 /* find the biggest valid pfn in the range [start_pfn, end_pfn). */
<span class="p_del">-static int find_biggest_section_pfn(int nid, struct zone *zone,</span>
<span class="p_add">+static unsigned long find_biggest_section_pfn(int nid, struct zone *zone,</span>
 				    unsigned long start_pfn,
 				    unsigned long end_pfn)
 {
<span class="p_chunk">@@ -735,7 +735,7 @@</span> <span class="p_context"> static int __remove_section(struct zone *zone, struct mem_section *ms)</span>
 		return ret;
 
 	scn_nr = __section_nr(ms);
<span class="p_del">-	start_pfn = section_nr_to_pfn(scn_nr);</span>
<span class="p_add">+	start_pfn = section_nr_to_pfn((unsigned long)scn_nr);</span>
 	__remove_zone(zone, start_pfn);
 
 	sparse_remove_one_section(zone, ms);
<span class="p_header">diff --git a/mm/nommu.c b/mm/nommu.c</span>
<span class="p_header">index 53a59f41e2e5..7f2c901c555e 100644</span>
<span class="p_header">--- a/mm/nommu.c</span>
<span class="p_header">+++ b/mm/nommu.c</span>
<span class="p_chunk">@@ -2007,7 +2007,7 @@</span> <span class="p_context"> int generic_file_remap_pages(struct vm_area_struct *vma, unsigned long addr,</span>
 }
 EXPORT_SYMBOL(generic_file_remap_pages);
 
<span class="p_del">-static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span>
<span class="p_add">+int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span>
 		unsigned long addr, void *buf, int len, int write)
 {
 	struct vm_area_struct *vma;
<span class="p_header">diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c</span>
<span class="p_header">index 44ebd5c2cd4a..dcd897f9f95c 100644</span>
<span class="p_header">--- a/net/8021q/vlan.c</span>
<span class="p_header">+++ b/net/8021q/vlan.c</span>
<span class="p_chunk">@@ -364,6 +364,9 @@</span> <span class="p_context"> static int vlan_device_event(struct notifier_block *unused, unsigned long event,</span>
 			dev-&gt;name);
 		vlan_vid_add(dev, htons(ETH_P_8021Q), 0);
 	}
<span class="p_add">+	if (event == NETDEV_DOWN &amp;&amp;</span>
<span class="p_add">+	    (dev-&gt;features &amp; NETIF_F_HW_VLAN_CTAG_FILTER))</span>
<span class="p_add">+		vlan_vid_del(dev, htons(ETH_P_8021Q), 0);</span>
 
 	vlan_info = rtnl_dereference(dev-&gt;vlan_info);
 	if (!vlan_info)
<span class="p_chunk">@@ -408,9 +411,6 @@</span> <span class="p_context"> static int vlan_device_event(struct notifier_block *unused, unsigned long event,</span>
 		break;
 
 	case NETDEV_DOWN:
<span class="p_del">-		if (dev-&gt;features &amp; NETIF_F_HW_VLAN_CTAG_FILTER)</span>
<span class="p_del">-			vlan_vid_del(dev, htons(ETH_P_8021Q), 0);</span>
<span class="p_del">-</span>
 		/* Put all VLANs for this dev in the down state too.  */
 		vlan_group_for_each_dev(grp, i, vlandev) {
 			flgs = vlandev-&gt;flags;
<span class="p_header">diff --git a/net/bluetooth/bnep/core.c b/net/bluetooth/bnep/core.c</span>
<span class="p_header">index a841d3e776c5..c7a19a15d760 100644</span>
<span class="p_header">--- a/net/bluetooth/bnep/core.c</span>
<span class="p_header">+++ b/net/bluetooth/bnep/core.c</span>
<span class="p_chunk">@@ -533,6 +533,9 @@</span> <span class="p_context"> int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)</span>
 
 	BT_DBG(&quot;&quot;);
 
<span class="p_add">+	if (!l2cap_is_socket(sock))</span>
<span class="p_add">+		return -EBADFD;</span>
<span class="p_add">+</span>
 	baswap((void *) dst, &amp;l2cap_pi(sock-&gt;sk)-&gt;chan-&gt;dst);
 	baswap((void *) src, &amp;l2cap_pi(sock-&gt;sk)-&gt;chan-&gt;src);
 
<span class="p_header">diff --git a/net/bluetooth/cmtp/core.c b/net/bluetooth/cmtp/core.c</span>
<span class="p_header">index 67fe5e84e68f..278a194e6af4 100644</span>
<span class="p_header">--- a/net/bluetooth/cmtp/core.c</span>
<span class="p_header">+++ b/net/bluetooth/cmtp/core.c</span>
<span class="p_chunk">@@ -334,6 +334,9 @@</span> <span class="p_context"> int cmtp_add_connection(struct cmtp_connadd_req *req, struct socket *sock)</span>
 
 	BT_DBG(&quot;&quot;);
 
<span class="p_add">+	if (!l2cap_is_socket(sock))</span>
<span class="p_add">+		return -EBADFD;</span>
<span class="p_add">+</span>
 	session = kzalloc(sizeof(struct cmtp_session), GFP_KERNEL);
 	if (!session)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index ee2177c0b186..37e2e5423af0 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -1056,9 +1056,8 @@</span> <span class="p_context"> static int dev_alloc_name_ns(struct net *net,</span>
 	return ret;
 }
 
<span class="p_del">-static int dev_get_valid_name(struct net *net,</span>
<span class="p_del">-			      struct net_device *dev,</span>
<span class="p_del">-			      const char *name)</span>
<span class="p_add">+int dev_get_valid_name(struct net *net, struct net_device *dev,</span>
<span class="p_add">+		       const char *name)</span>
 {
 	BUG_ON(!net);
 
<span class="p_chunk">@@ -1074,6 +1073,7 @@</span> <span class="p_context"> static int dev_get_valid_name(struct net *net,</span>
 
 	return 0;
 }
<span class="p_add">+EXPORT_SYMBOL(dev_get_valid_name);</span>
 
 /**
  *	dev_change_name - change name of a device
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 66498c948405..a3ce3f2d7e98 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -1187,7 +1187,10 @@</span> <span class="p_context"> static const struct nla_policy ifla_policy[IFLA_MAX+1] = {</span>
 	[IFLA_LINKINFO]		= { .type = NLA_NESTED },
 	[IFLA_NET_NS_PID]	= { .type = NLA_U32 },
 	[IFLA_NET_NS_FD]	= { .type = NLA_U32 },
<span class="p_del">-	[IFLA_IFALIAS]	        = { .type = NLA_STRING, .len = IFALIASZ-1 },</span>
<span class="p_add">+	/* IFLA_IFALIAS is a string, but policy is set to NLA_BINARY to</span>
<span class="p_add">+	 * allow 0-length string (needed to remove an alias).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	[IFLA_IFALIAS]	        = { .type = NLA_BINARY, .len = IFALIASZ - 1 },</span>
 	[IFLA_VFINFO_LIST]	= {. type = NLA_NESTED },
 	[IFLA_VF_PORTS]		= { .type = NLA_NESTED },
 	[IFLA_PORT_SELF]	= { .type = NLA_NESTED },
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index 8c5409067930..235c639d370b 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -3961,6 +3961,7 @@</span> <span class="p_context"> void skb_scrub_packet(struct sk_buff *skb, bool xnet)</span>
 	if (!xnet)
 		return;
 
<span class="p_add">+	ipvs_reset(skb);</span>
 	skb_orphan(skb);
 	skb-&gt;mark = 0;
 }
<span class="p_header">diff --git a/net/dccp/proto.c b/net/dccp/proto.c</span>
<span class="p_header">index f8fa2d15115e..82068e0d9891 100644</span>
<span class="p_header">--- a/net/dccp/proto.c</span>
<span class="p_header">+++ b/net/dccp/proto.c</span>
<span class="p_chunk">@@ -252,6 +252,7 @@</span> <span class="p_context"> int dccp_disconnect(struct sock *sk, int flags)</span>
 {
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct inet_sock *inet = inet_sk(sk);
<span class="p_add">+	struct dccp_sock *dp = dccp_sk(sk);</span>
 	int err = 0;
 	const int old_state = sk-&gt;sk_state;
 
<span class="p_chunk">@@ -271,6 +272,10 @@</span> <span class="p_context"> int dccp_disconnect(struct sock *sk, int flags)</span>
 		sk-&gt;sk_err = ECONNRESET;
 
 	dccp_clear_xmit_timers(sk);
<span class="p_add">+	ccid_hc_rx_delete(dp-&gt;dccps_hc_rx_ccid, sk);</span>
<span class="p_add">+	ccid_hc_tx_delete(dp-&gt;dccps_hc_tx_ccid, sk);</span>
<span class="p_add">+	dp-&gt;dccps_hc_rx_ccid = NULL;</span>
<span class="p_add">+	dp-&gt;dccps_hc_tx_ccid = NULL;</span>
 
 	__skb_queue_purge(&amp;sk-&gt;sk_receive_queue);
 	__skb_queue_purge(&amp;sk-&gt;sk_write_queue);
<span class="p_header">diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c</span>
<span class="p_header">index 3d4da2c16b6a..1a04ea201f3b 100644</span>
<span class="p_header">--- a/net/ipv4/ip_input.c</span>
<span class="p_header">+++ b/net/ipv4/ip_input.c</span>
<span class="p_chunk">@@ -313,6 +313,7 @@</span> <span class="p_context"> static int ip_rcv_finish(struct sk_buff *skb)</span>
 {
 	const struct iphdr *iph = ip_hdr(skb);
 	struct rtable *rt;
<span class="p_add">+	int err;</span>
 
 	if (sysctl_ip_early_demux &amp;&amp; !skb_dst(skb) &amp;&amp; skb-&gt;sk == NULL) {
 		const struct net_protocol *ipprot;
<span class="p_chunk">@@ -320,7 +321,9 @@</span> <span class="p_context"> static int ip_rcv_finish(struct sk_buff *skb)</span>
 
 		ipprot = rcu_dereference(inet_protos[protocol]);
 		if (ipprot &amp;&amp; ipprot-&gt;early_demux) {
<span class="p_del">-			ipprot-&gt;early_demux(skb);</span>
<span class="p_add">+			err = ipprot-&gt;early_demux(skb);</span>
<span class="p_add">+			if (unlikely(err))</span>
<span class="p_add">+				goto drop_error;</span>
 			/* must reload iph, skb-&gt;head might have changed */
 			iph = ip_hdr(skb);
 		}
<span class="p_chunk">@@ -331,14 +334,10 @@</span> <span class="p_context"> static int ip_rcv_finish(struct sk_buff *skb)</span>
 	 *	how the packet travels inside Linux networking.
 	 */
 	if (!skb_dst(skb)) {
<span class="p_del">-		int err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_del">-					       iph-&gt;tos, skb-&gt;dev);</span>
<span class="p_del">-		if (unlikely(err)) {</span>
<span class="p_del">-			if (err == -EXDEV)</span>
<span class="p_del">-				NET_INC_STATS_BH(dev_net(skb-&gt;dev),</span>
<span class="p_del">-						 LINUX_MIB_IPRPFILTER);</span>
<span class="p_del">-			goto drop;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_add">+					   iph-&gt;tos, skb-&gt;dev);</span>
<span class="p_add">+		if (unlikely(err))</span>
<span class="p_add">+			goto drop_error;</span>
 	}
 
 #ifdef CONFIG_IP_ROUTE_CLASSID
<span class="p_chunk">@@ -368,6 +367,11 @@</span> <span class="p_context"> static int ip_rcv_finish(struct sk_buff *skb)</span>
 drop:
 	kfree_skb(skb);
 	return NET_RX_DROP;
<span class="p_add">+</span>
<span class="p_add">+drop_error:</span>
<span class="p_add">+	if (err == -EXDEV)</span>
<span class="p_add">+		NET_INC_STATS_BH(dev_net(skb-&gt;dev), LINUX_MIB_IPRPFILTER);</span>
<span class="p_add">+	goto drop;</span>
 }
 
 /*
<span class="p_header">diff --git a/net/ipv4/ip_vti.c b/net/ipv4/ip_vti.c</span>
<span class="p_header">index ea7525b1f996..ca0b7408614c 100644</span>
<span class="p_header">--- a/net/ipv4/ip_vti.c</span>
<span class="p_header">+++ b/net/ipv4/ip_vti.c</span>
<span class="p_chunk">@@ -151,6 +151,7 @@</span> <span class="p_context"> static netdev_tx_t vti_xmit(struct sk_buff *skb, struct net_device *dev,</span>
 	struct ip_tunnel_parm *parms = &amp;tunnel-&gt;parms;
 	struct dst_entry *dst = skb_dst(skb);
 	struct net_device *tdev;	/* Device to other host */
<span class="p_add">+	int pkt_len = skb-&gt;len;</span>
 	int err;
 
 	if (!dst) {
<span class="p_chunk">@@ -194,7 +195,7 @@</span> <span class="p_context"> static netdev_tx_t vti_xmit(struct sk_buff *skb, struct net_device *dev,</span>
 
 	err = dst_output(skb);
 	if (net_xmit_eval(err) == 0)
<span class="p_del">-		err = skb-&gt;len;</span>
<span class="p_add">+		err = pkt_len;</span>
 	iptunnel_xmit_stats(err, &amp;dev-&gt;stats, dev-&gt;tstats);
 	return NETDEV_TX_OK;
 
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 75b122645188..d0c1d3781b1d 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -1440,40 +1440,53 @@</span> <span class="p_context"> static struct rtable *rt_dst_alloc(struct net_device *dev,</span>
 }
 
 /* called in rcu_read_lock() section */
<span class="p_del">-static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
<span class="p_del">-				u8 tos, struct net_device *dev, int our)</span>
<span class="p_add">+int ip_mc_validate_source(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
<span class="p_add">+			  u8 tos, struct net_device *dev,</span>
<span class="p_add">+			  struct in_device *in_dev, u32 *itag)</span>
 {
<span class="p_del">-	struct rtable *rth;</span>
<span class="p_del">-	struct in_device *in_dev = __in_dev_get_rcu(dev);</span>
<span class="p_del">-	u32 itag = 0;</span>
 	int err;
 
 	/* Primary sanity checks. */
<span class="p_del">-</span>
 	if (in_dev == NULL)
 		return -EINVAL;
 
 	if (ipv4_is_multicast(saddr) || ipv4_is_lbcast(saddr) ||
 	    skb-&gt;protocol != htons(ETH_P_IP))
<span class="p_del">-		goto e_inval;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (likely(!IN_DEV_ROUTE_LOCALNET(in_dev)))
 		if (ipv4_is_loopback(saddr))
<span class="p_del">-			goto e_inval;</span>
<span class="p_add">+			return -EINVAL;</span>
 
 	if (ipv4_is_zeronet(saddr)) {
 		if (!ipv4_is_local_multicast(daddr))
<span class="p_del">-			goto e_inval;</span>
<span class="p_add">+			return -EINVAL;</span>
 	} else {
 		err = fib_validate_source(skb, saddr, 0, tos, 0, dev,
<span class="p_del">-					  in_dev, &amp;itag);</span>
<span class="p_add">+					  in_dev, itag);</span>
 		if (err &lt; 0)
<span class="p_del">-			goto e_err;</span>
<span class="p_add">+			return err;</span>
 	}
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* called in rcu_read_lock() section */</span>
<span class="p_add">+static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
<span class="p_add">+			     u8 tos, struct net_device *dev, int our)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct in_device *in_dev = __in_dev_get_rcu(dev);</span>
<span class="p_add">+	struct rtable *rth;</span>
<span class="p_add">+	u32 itag = 0;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = ip_mc_validate_source(skb, daddr, saddr, tos, dev, in_dev, &amp;itag);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	rth = rt_dst_alloc(dev_net(dev)-&gt;loopback_dev,
 			   IN_DEV_CONF_GET(in_dev, NOPOLICY), false, false);
 	if (!rth)
<span class="p_del">-		goto e_nobufs;</span>
<span class="p_add">+		return -ENOBUFS;</span>
 
 #ifdef CONFIG_IP_ROUTE_CLASSID
 	rth-&gt;dst.tclassid = itag;
<span class="p_chunk">@@ -1502,13 +1515,6 @@</span> <span class="p_context"> static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span>
 
 	skb_dst_set(skb, &amp;rth-&gt;dst);
 	return 0;
<span class="p_del">-</span>
<span class="p_del">-e_nobufs:</span>
<span class="p_del">-	return -ENOBUFS;</span>
<span class="p_del">-e_inval:</span>
<span class="p_del">-	return -EINVAL;</span>
<span class="p_del">-e_err:</span>
<span class="p_del">-	return err;</span>
 }
 
 
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index 4984da1a31b3..964064325681 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -1616,23 +1616,23 @@</span> <span class="p_context"> int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)</span>
 }
 EXPORT_SYMBOL(tcp_v4_do_rcv);
 
<span class="p_del">-void tcp_v4_early_demux(struct sk_buff *skb)</span>
<span class="p_add">+int tcp_v4_early_demux(struct sk_buff *skb)</span>
 {
 	const struct iphdr *iph;
 	const struct tcphdr *th;
 	struct sock *sk;
 
 	if (skb-&gt;pkt_type != PACKET_HOST)
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	if (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	iph = ip_hdr(skb);
 	th = tcp_hdr(skb);
 
 	if (th-&gt;doff &lt; sizeof(struct tcphdr) / 4)
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	sk = __inet_lookup_established(dev_net(skb-&gt;dev), &amp;tcp_hashinfo,
 				       iph-&gt;saddr, th-&gt;source,
<span class="p_chunk">@@ -1651,6 +1651,7 @@</span> <span class="p_context"> void tcp_v4_early_demux(struct sk_buff *skb)</span>
 				skb_dst_set_noref(skb, dst);
 		}
 	}
<span class="p_add">+	return 0;</span>
 }
 
 /* Packet is added to VJ-style prequeue for processing in process
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 6ad29aa904bf..52d89fc2b297 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -1817,6 +1817,7 @@</span> <span class="p_context"> static int tcp_mtu_probe(struct sock *sk)</span>
 	nskb-&gt;ip_summed = skb-&gt;ip_summed;
 
 	tcp_insert_write_queue_before(nskb, skb, sk);
<span class="p_add">+	tcp_highest_sack_replace(sk, skb, nskb);</span>
 
 	len = 0;
 	tcp_for_write_queue_from_safe(skb, next, sk) {
<span class="p_chunk">@@ -2327,7 +2328,7 @@</span> <span class="p_context"> static void tcp_collapse_retrans(struct sock *sk, struct sk_buff *skb)</span>
 
 	BUG_ON(tcp_skb_pcount(skb) != 1 || tcp_skb_pcount(next_skb) != 1);
 
<span class="p_del">-	tcp_highest_sack_combine(sk, next_skb, skb);</span>
<span class="p_add">+	tcp_highest_sack_replace(sk, next_skb, skb);</span>
 
 	tcp_unlink_write_queue(next_skb, sk);
 
<span class="p_chunk">@@ -3058,6 +3059,10 @@</span> <span class="p_context"> static int tcp_send_syn_data(struct sock *sk, struct sk_buff *syn)</span>
 		goto done;
 	}
 
<span class="p_add">+	/* data was not sent, this is our new send_head */</span>
<span class="p_add">+	sk-&gt;sk_send_head = syn_data;</span>
<span class="p_add">+	tp-&gt;packets_out -= tcp_skb_pcount(syn_data);</span>
<span class="p_add">+</span>
 fallback:
 	/* Send a regular SYN with Fast Open cookie request option */
 	if (fo-&gt;cookie.len &gt; 0)
<span class="p_chunk">@@ -3104,6 +3109,11 @@</span> <span class="p_context"> int tcp_connect(struct sock *sk)</span>
 	 */
 	tp-&gt;snd_nxt = tp-&gt;write_seq;
 	tp-&gt;pushed_seq = tp-&gt;write_seq;
<span class="p_add">+	buff = tcp_send_head(sk);</span>
<span class="p_add">+	if (unlikely(buff)) {</span>
<span class="p_add">+		tp-&gt;snd_nxt	= TCP_SKB_CB(buff)-&gt;seq;</span>
<span class="p_add">+		tp-&gt;pushed_seq	= TCP_SKB_CB(buff)-&gt;seq;</span>
<span class="p_add">+	}</span>
 	TCP_INC_STATS(sock_net(sk), TCP_MIB_ACTIVEOPENS);
 
 	/* Timer for repeating the SYN until an answer. */
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 0a9aaab17e00..5877d782bdc1 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1950,9 +1950,10 @@</span> <span class="p_context"> static struct sock *__udp4_lib_demux_lookup(struct net *net,</span>
 	return result;
 }
 
<span class="p_del">-void udp_v4_early_demux(struct sk_buff *skb)</span>
<span class="p_add">+int udp_v4_early_demux(struct sk_buff *skb)</span>
 {
 	struct net *net = dev_net(skb-&gt;dev);
<span class="p_add">+	struct in_device *in_dev = NULL;</span>
 	const struct iphdr *iph;
 	const struct udphdr *uh;
 	struct sock *sk;
<span class="p_chunk">@@ -1962,33 +1963,33 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 
 	/* validate the packet */
 	if (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct udphdr)))
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	iph = ip_hdr(skb);
 	uh = udp_hdr(skb);
 
<span class="p_del">-	if (skb-&gt;pkt_type == PACKET_BROADCAST ||</span>
<span class="p_del">-	    skb-&gt;pkt_type == PACKET_MULTICAST) {</span>
<span class="p_del">-		struct in_device *in_dev = __in_dev_get_rcu(skb-&gt;dev);</span>
<span class="p_add">+	if (skb-&gt;pkt_type == PACKET_MULTICAST) {</span>
<span class="p_add">+		in_dev = __in_dev_get_rcu(skb-&gt;dev);</span>
 
 		if (!in_dev)
<span class="p_del">-			return;</span>
<span class="p_add">+			return 0;</span>
 
 		ours = ip_check_mc_rcu(in_dev, iph-&gt;daddr, iph-&gt;saddr,
 				       iph-&gt;protocol);
 		if (!ours)
<span class="p_del">-			return;</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
 		sk = __udp4_lib_mcast_demux_lookup(net, uh-&gt;dest, iph-&gt;daddr,
 						   uh-&gt;source, iph-&gt;saddr, dif);
 	} else if (skb-&gt;pkt_type == PACKET_HOST) {
 		sk = __udp4_lib_demux_lookup(net, uh-&gt;dest, iph-&gt;daddr,
 					     uh-&gt;source, iph-&gt;saddr, dif);
 	} else {
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 	}
 
 	if (!sk)
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	skb-&gt;sk = sk;
 	skb-&gt;destructor = sock_edemux;
<span class="p_chunk">@@ -1997,6 +1998,8 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 	if (dst)
 		dst = dst_check(dst, 0);
 	if (dst) {
<span class="p_add">+		u32 itag = 0;</span>
<span class="p_add">+</span>
 		/* DST_NOCACHE can not be used without taking a reference */
 		if (dst-&gt;flags &amp; DST_NOCACHE) {
 			if (likely(atomic_inc_not_zero(&amp;dst-&gt;__refcnt)))
<span class="p_chunk">@@ -2004,7 +2007,16 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 		} else {
 			skb_dst_set_noref(skb, dst);
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* for unconnected multicast sockets we need to validate</span>
<span class="p_add">+		 * the source on each packet</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!inet_sk(sk)-&gt;inet_daddr &amp;&amp; in_dev)</span>
<span class="p_add">+			return ip_mc_validate_source(skb, iph-&gt;daddr,</span>
<span class="p_add">+						     iph-&gt;saddr, iph-&gt;tos,</span>
<span class="p_add">+						     skb-&gt;dev, in_dev, &amp;itag);</span>
 	}
<span class="p_add">+	return 0;</span>
 }
 
 int udp_rcv(struct sk_buff *skb)
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index f204efd21f50..b277098ed426 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -404,15 +404,18 @@</span> <span class="p_context"> static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,</span>
 		struct ipv6_tlv_tnl_enc_lim *tel;
 		__u32 mtu;
 	case ICMPV6_DEST_UNREACH:
<span class="p_del">-		net_warn_ratelimited(&quot;%s: Path to destination invalid or inactive!\n&quot;,</span>
<span class="p_del">-				     t-&gt;parms.name);</span>
<span class="p_del">-		break;</span>
<span class="p_add">+		net_dbg_ratelimited(&quot;%s: Path to destination invalid or inactive!\n&quot;,</span>
<span class="p_add">+				    t-&gt;parms.name);</span>
<span class="p_add">+		if (code != ICMPV6_PORT_UNREACH)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		return;</span>
 	case ICMPV6_TIME_EXCEED:
 		if (code == ICMPV6_EXC_HOPLIMIT) {
<span class="p_del">-			net_warn_ratelimited(&quot;%s: Too small hop limit or routing loop in tunnel!\n&quot;,</span>
<span class="p_del">-					     t-&gt;parms.name);</span>
<span class="p_add">+			net_dbg_ratelimited(&quot;%s: Too small hop limit or routing loop in tunnel!\n&quot;,</span>
<span class="p_add">+					    t-&gt;parms.name);</span>
<span class="p_add">+			break;</span>
 		}
<span class="p_del">-		break;</span>
<span class="p_add">+		return;</span>
 	case ICMPV6_PARAMPROB:
 		teli = 0;
 		if (code == ICMPV6_HDR_FIELD)
<span class="p_chunk">@@ -421,20 +424,20 @@</span> <span class="p_context"> static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,</span>
 		if (teli &amp;&amp; teli == be32_to_cpu(info) - 2) {
 			tel = (struct ipv6_tlv_tnl_enc_lim *) &amp;skb-&gt;data[teli];
 			if (tel-&gt;encap_limit == 0) {
<span class="p_del">-				net_warn_ratelimited(&quot;%s: Too small encapsulation limit or routing loop in tunnel!\n&quot;,</span>
<span class="p_del">-						     t-&gt;parms.name);</span>
<span class="p_add">+				net_dbg_ratelimited(&quot;%s: Too small encapsulation limit or routing loop in tunnel!\n&quot;,</span>
<span class="p_add">+						    t-&gt;parms.name);</span>
 			}
 		} else {
<span class="p_del">-			net_warn_ratelimited(&quot;%s: Recipient unable to parse tunneled packet!\n&quot;,</span>
<span class="p_del">-					     t-&gt;parms.name);</span>
<span class="p_add">+			net_dbg_ratelimited(&quot;%s: Recipient unable to parse tunneled packet!\n&quot;,</span>
<span class="p_add">+					    t-&gt;parms.name);</span>
 		}
<span class="p_del">-		break;</span>
<span class="p_add">+		return;</span>
 	case ICMPV6_PKT_TOOBIG:
 		mtu = be32_to_cpu(info) - offset;
 		if (mtu &lt; IPV6_MIN_MTU)
 			mtu = IPV6_MIN_MTU;
 		t-&gt;dev-&gt;mtu = mtu;
<span class="p_del">-		break;</span>
<span class="p_add">+		return;</span>
 	}
 
 	if (time_before(jiffies, t-&gt;err_time + IP6TUNNEL_ERR_TIMEO))
<span class="p_chunk">@@ -1172,21 +1175,23 @@</span> <span class="p_context"> static int ip6gre_tunnel_change_mtu(struct net_device *dev, int new_mtu)</span>
 }
 
 static int ip6gre_header(struct sk_buff *skb, struct net_device *dev,
<span class="p_del">-			unsigned short type,</span>
<span class="p_del">-			const void *daddr, const void *saddr, unsigned int len)</span>
<span class="p_add">+			 unsigned short type, const void *daddr,</span>
<span class="p_add">+			 const void *saddr, unsigned int len)</span>
 {
 	struct ip6_tnl *t = netdev_priv(dev);
<span class="p_del">-	struct ipv6hdr *ipv6h = (struct ipv6hdr *)skb_push(skb, t-&gt;hlen);</span>
<span class="p_del">-	__be16 *p = (__be16 *)(ipv6h+1);</span>
<span class="p_add">+	struct ipv6hdr *ipv6h;</span>
<span class="p_add">+	__be16 *p;</span>
 
<span class="p_add">+	ipv6h = (struct ipv6hdr *)skb_push(skb, t-&gt;hlen + sizeof(*ipv6h));</span>
 	ip6_flow_hdr(ipv6h, 0, t-&gt;fl.u.ip6.flowlabel);
 	ipv6h-&gt;hop_limit = t-&gt;parms.hop_limit;
 	ipv6h-&gt;nexthdr = NEXTHDR_GRE;
 	ipv6h-&gt;saddr = t-&gt;parms.laddr;
 	ipv6h-&gt;daddr = t-&gt;parms.raddr;
 
<span class="p_del">-	p[0]		= t-&gt;parms.o_flags;</span>
<span class="p_del">-	p[1]		= htons(type);</span>
<span class="p_add">+	p = (__be16 *)(ipv6h + 1);</span>
<span class="p_add">+	p[0] = t-&gt;parms.o_flags;</span>
<span class="p_add">+	p[1] = htons(type);</span>
 
 	/*
 	 *	Set the source hardware address.
<span class="p_header">diff --git a/net/ipv6/ip6_vti.c b/net/ipv6/ip6_vti.c</span>
<span class="p_header">index 4e083dab7445..de67f5bd9bf9 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_vti.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_vti.c</span>
<span class="p_chunk">@@ -407,6 +407,7 @@</span> <span class="p_context"> vti6_xmit(struct sk_buff *skb, struct net_device *dev, struct flowi *fl)</span>
 	struct net_device_stats *stats = &amp;t-&gt;dev-&gt;stats;
 	struct dst_entry *dst = skb_dst(skb);
 	struct net_device *tdev;
<span class="p_add">+	int pkt_len = skb-&gt;len;</span>
 	int err = -1;
 
 	if (!dst)
<span class="p_chunk">@@ -441,7 +442,7 @@</span> <span class="p_context"> vti6_xmit(struct sk_buff *skb, struct net_device *dev, struct flowi *fl)</span>
 		struct pcpu_sw_netstats *tstats = this_cpu_ptr(dev-&gt;tstats);
 
 		u64_stats_update_begin(&amp;tstats-&gt;syncp);
<span class="p_del">-		tstats-&gt;tx_bytes += skb-&gt;len;</span>
<span class="p_add">+		tstats-&gt;tx_bytes += pkt_len;</span>
 		tstats-&gt;tx_packets++;
 		u64_stats_update_end(&amp;tstats-&gt;syncp);
 	} else {
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index 35f97d9abc4b..1f3677610ad7 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -1771,14 +1771,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(l2tp_tunnel_create);</span>
 
 /* This function is used by the netlink TUNNEL_DELETE command.
  */
<span class="p_del">-int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)</span>
<span class="p_add">+void l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)</span>
 {
<span class="p_del">-	l2tp_tunnel_inc_refcount(tunnel);</span>
<span class="p_del">-	if (false == queue_work(l2tp_wq, &amp;tunnel-&gt;del_work)) {</span>
<span class="p_del">-		l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_del">-		return 1;</span>
<span class="p_add">+	if (!test_and_set_bit(0, &amp;tunnel-&gt;dead)) {</span>
<span class="p_add">+		l2tp_tunnel_inc_refcount(tunnel);</span>
<span class="p_add">+		queue_work(l2tp_wq, &amp;tunnel-&gt;del_work);</span>
 	}
<span class="p_del">-	return 0;</span>
 }
 EXPORT_SYMBOL_GPL(l2tp_tunnel_delete);
 
<span class="p_header">diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h</span>
<span class="p_header">index 36c25b14bc6f..b56ca9346038 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.h</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.h</span>
<span class="p_chunk">@@ -169,6 +169,9 @@</span> <span class="p_context"> struct l2tp_tunnel_cfg {</span>
 
 struct l2tp_tunnel {
 	int			magic;		/* Should be L2TP_TUNNEL_MAGIC */
<span class="p_add">+</span>
<span class="p_add">+	unsigned long		dead;</span>
<span class="p_add">+</span>
 	struct rcu_head rcu;
 	rwlock_t		hlist_lock;	/* protect session_hlist */
 	bool			acpt_newsess;	/* Indicates whether this
<span class="p_chunk">@@ -266,7 +269,7 @@</span> <span class="p_context"> int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id,</span>
 		       u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg,
 		       struct l2tp_tunnel **tunnelp);
 void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel);
<span class="p_del">-int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);</span>
<span class="p_add">+void l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);</span>
 struct l2tp_session *l2tp_session_create(int priv_size,
 					 struct l2tp_tunnel *tunnel,
 					 u32 session_id, u32 peer_session_id,
<span class="p_header">diff --git a/net/l2tp/l2tp_eth.c b/net/l2tp/l2tp_eth.c</span>
<span class="p_header">index ed819454a4e7..a719bf9afb04 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_eth.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_eth.c</span>
<span class="p_chunk">@@ -41,7 +41,6 @@</span> <span class="p_context"> struct l2tp_eth {</span>
 	struct net_device	*dev;
 	struct sock		*tunnel_sock;
 	struct l2tp_session	*session;
<span class="p_del">-	struct list_head	list;</span>
 	atomic_long_t		tx_bytes;
 	atomic_long_t		tx_packets;
 	atomic_long_t		tx_dropped;
<span class="p_chunk">@@ -55,17 +54,6 @@</span> <span class="p_context"> struct l2tp_eth_sess {</span>
 	struct net_device	*dev;
 };
 
<span class="p_del">-/* per-net private data for this module */</span>
<span class="p_del">-static unsigned int l2tp_eth_net_id;</span>
<span class="p_del">-struct l2tp_eth_net {</span>
<span class="p_del">-	struct list_head l2tp_eth_dev_list;</span>
<span class="p_del">-	spinlock_t l2tp_eth_lock;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static inline struct l2tp_eth_net *l2tp_eth_pernet(struct net *net)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return net_generic(net, l2tp_eth_net_id);</span>
<span class="p_del">-}</span>
 
 static struct lock_class_key l2tp_eth_tx_busylock;
 static int l2tp_eth_dev_init(struct net_device *dev)
<span class="p_chunk">@@ -81,12 +69,6 @@</span> <span class="p_context"> static int l2tp_eth_dev_init(struct net_device *dev)</span>
 
 static void l2tp_eth_dev_uninit(struct net_device *dev)
 {
<span class="p_del">-	struct l2tp_eth *priv = netdev_priv(dev);</span>
<span class="p_del">-	struct l2tp_eth_net *pn = l2tp_eth_pernet(dev_net(dev));</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock(&amp;pn-&gt;l2tp_eth_lock);</span>
<span class="p_del">-	list_del_init(&amp;priv-&gt;list);</span>
<span class="p_del">-	spin_unlock(&amp;pn-&gt;l2tp_eth_lock);</span>
 	dev_put(dev);
 }
 
<span class="p_chunk">@@ -216,7 +198,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 	struct l2tp_eth *priv;
 	struct l2tp_eth_sess *spriv;
 	int rc;
<span class="p_del">-	struct l2tp_eth_net *pn;</span>
 
 	if (cfg-&gt;ifname) {
 		dev = dev_get_by_name(net, cfg-&gt;ifname);
<span class="p_chunk">@@ -251,7 +232,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 	priv = netdev_priv(dev);
 	priv-&gt;dev = dev;
 	priv-&gt;session = session;
<span class="p_del">-	INIT_LIST_HEAD(&amp;priv-&gt;list);</span>
 
 	priv-&gt;tunnel_sock = tunnel-&gt;sock;
 	session-&gt;recv_skb = l2tp_eth_dev_recv;
<span class="p_chunk">@@ -272,10 +252,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 	strlcpy(session-&gt;ifname, dev-&gt;name, IFNAMSIZ);
 
 	dev_hold(dev);
<span class="p_del">-	pn = l2tp_eth_pernet(dev_net(dev));</span>
<span class="p_del">-	spin_lock(&amp;pn-&gt;l2tp_eth_lock);</span>
<span class="p_del">-	list_add(&amp;priv-&gt;list, &amp;pn-&gt;l2tp_eth_dev_list);</span>
<span class="p_del">-	spin_unlock(&amp;pn-&gt;l2tp_eth_lock);</span>
 
 	return 0;
 
<span class="p_chunk">@@ -288,22 +264,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 	return rc;
 }
 
<span class="p_del">-static __net_init int l2tp_eth_init_net(struct net *net)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct l2tp_eth_net *pn = net_generic(net, l2tp_eth_net_id);</span>
<span class="p_del">-</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;pn-&gt;l2tp_eth_dev_list);</span>
<span class="p_del">-	spin_lock_init(&amp;pn-&gt;l2tp_eth_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct pernet_operations l2tp_eth_net_ops = {</span>
<span class="p_del">-	.init = l2tp_eth_init_net,</span>
<span class="p_del">-	.id   = &amp;l2tp_eth_net_id,</span>
<span class="p_del">-	.size = sizeof(struct l2tp_eth_net),</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 
 static const struct l2tp_nl_cmd_ops l2tp_eth_nl_cmd_ops = {
 	.session_create	= l2tp_eth_create,
<span class="p_chunk">@@ -317,25 +277,18 @@</span> <span class="p_context"> static int __init l2tp_eth_init(void)</span>
 
 	err = l2tp_nl_register_ops(L2TP_PWTYPE_ETH, &amp;l2tp_eth_nl_cmd_ops);
 	if (err)
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	err = register_pernet_device(&amp;l2tp_eth_net_ops);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_unreg;</span>
<span class="p_add">+		goto err;</span>
 
 	pr_info(&quot;L2TP ethernet pseudowire support (L2TPv3)\n&quot;);
 
 	return 0;
 
<span class="p_del">-out_unreg:</span>
<span class="p_del">-	l2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);</span>
<span class="p_del">-out:</span>
<span class="p_add">+err:</span>
 	return err;
 }
 
 static void __exit l2tp_eth_exit(void)
 {
<span class="p_del">-	unregister_pernet_device(&amp;l2tp_eth_net_ops);</span>
 	l2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);
 }
 
<span class="p_header">diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c</span>
<span class="p_header">index d30f5c03d72f..67c59119d01d 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip.c</span>
<span class="p_chunk">@@ -122,6 +122,7 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 	unsigned char *ptr, *optr;
 	struct l2tp_session *session;
 	struct l2tp_tunnel *tunnel = NULL;
<span class="p_add">+	struct iphdr *iph;</span>
 	int length;
 
 	if (!pskb_may_pull(skb, 4))
<span class="p_chunk">@@ -177,21 +178,16 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 		goto discard;
 
 	tunnel_id = ntohl(*(__be32 *) &amp;skb-&gt;data[4]);
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (tunnel != NULL)</span>
<span class="p_del">-		sk = tunnel-&gt;sock;</span>
<span class="p_del">-	else {</span>
<span class="p_del">-		struct iphdr *iph = (struct iphdr *) skb_network_header(skb);</span>
<span class="p_del">-</span>
<span class="p_del">-		read_lock_bh(&amp;l2tp_ip_lock);</span>
<span class="p_del">-		sk = __l2tp_ip_bind_lookup(net, iph-&gt;daddr, 0, tunnel_id);</span>
<span class="p_del">-		read_unlock_bh(&amp;l2tp_ip_lock);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	iph = (struct iphdr *)skb_network_header(skb);</span>
 
<span class="p_del">-	if (sk == NULL)</span>
<span class="p_add">+	read_lock_bh(&amp;l2tp_ip_lock);</span>
<span class="p_add">+	sk = __l2tp_ip_bind_lookup(net, iph-&gt;daddr, 0, tunnel_id);</span>
<span class="p_add">+	if (!sk) {</span>
<span class="p_add">+		read_unlock_bh(&amp;l2tp_ip_lock);</span>
 		goto discard;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
 	sock_hold(sk);
<span class="p_add">+	read_unlock_bh(&amp;l2tp_ip_lock);</span>
 
 	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
 		goto discard_put;
<span class="p_header">diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">index c052d2991f84..1615cb38828d 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip6.c</span>
<span class="p_chunk">@@ -133,6 +133,7 @@</span> <span class="p_context"> static int l2tp_ip6_recv(struct sk_buff *skb)</span>
 	unsigned char *ptr, *optr;
 	struct l2tp_session *session;
 	struct l2tp_tunnel *tunnel = NULL;
<span class="p_add">+	struct ipv6hdr *iph;</span>
 	int length;
 
 	if (!pskb_may_pull(skb, 4))
<span class="p_chunk">@@ -189,22 +190,16 @@</span> <span class="p_context"> static int l2tp_ip6_recv(struct sk_buff *skb)</span>
 		goto discard;
 
 	tunnel_id = ntohl(*(__be32 *) &amp;skb-&gt;data[4]);
<span class="p_del">-	tunnel = l2tp_tunnel_find(&amp;init_net, tunnel_id);</span>
<span class="p_del">-	if (tunnel != NULL)</span>
<span class="p_del">-		sk = tunnel-&gt;sock;</span>
<span class="p_del">-	else {</span>
<span class="p_del">-		struct ipv6hdr *iph = ipv6_hdr(skb);</span>
<span class="p_del">-</span>
<span class="p_del">-		read_lock_bh(&amp;l2tp_ip6_lock);</span>
<span class="p_del">-		sk = __l2tp_ip6_bind_lookup(&amp;init_net, &amp;iph-&gt;daddr,</span>
<span class="p_del">-					    0, tunnel_id);</span>
<span class="p_del">-		read_unlock_bh(&amp;l2tp_ip6_lock);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	iph = ipv6_hdr(skb);</span>
 
<span class="p_del">-	if (sk == NULL)</span>
<span class="p_add">+	read_lock_bh(&amp;l2tp_ip6_lock);</span>
<span class="p_add">+	sk = __l2tp_ip6_bind_lookup(&amp;init_net, &amp;iph-&gt;daddr, 0, tunnel_id);</span>
<span class="p_add">+	if (!sk) {</span>
<span class="p_add">+		read_unlock_bh(&amp;l2tp_ip6_lock);</span>
 		goto discard;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
 	sock_hold(sk);
<span class="p_add">+	read_unlock_bh(&amp;l2tp_ip6_lock);</span>
 
 	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))
 		goto discard_put;
<span class="p_header">diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">index 80d4cfa9fe38..22d74e6b6461 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ppp.c</span>
<span class="p_chunk">@@ -603,6 +603,7 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 	u32 tunnel_id, peer_tunnel_id;
 	u32 session_id, peer_session_id;
 	bool drop_refcnt = false;
<span class="p_add">+	bool drop_tunnel = false;</span>
 	int ver = 2;
 	int fd;
 
<span class="p_chunk">@@ -671,7 +672,9 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 	if (tunnel_id == 0)
 		goto end;
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(sock_net(sk), tunnel_id);</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(sock_net(sk), tunnel_id);</span>
<span class="p_add">+	if (tunnel)</span>
<span class="p_add">+		drop_tunnel = true;</span>
 
 	/* Special case: create tunnel context if session_id and
 	 * peer_session_id is 0. Otherwise look up tunnel using supplied
<span class="p_chunk">@@ -800,6 +803,8 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 end:
 	if (drop_refcnt)
 		l2tp_session_dec_refcount(session);
<span class="p_add">+	if (drop_tunnel)</span>
<span class="p_add">+		l2tp_tunnel_dec_refcount(tunnel);</span>
 	release_sock(sk);
 
 	return error;
<span class="p_chunk">@@ -1007,6 +1012,9 @@</span> <span class="p_context"> static int pppol2tp_session_ioctl(struct l2tp_session *session,</span>
 		 session-&gt;name, cmd, arg);
 
 	sk = ps-&gt;sock;
<span class="p_add">+	if (!sk)</span>
<span class="p_add">+		return -EBADR;</span>
<span class="p_add">+</span>
 	sock_hold(sk);
 
 	switch (cmd) {
<span class="p_header">diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c</span>
<span class="p_header">index 6850c3c4d6d3..59aaa4159a36 100644</span>
<span class="p_header">--- a/net/netfilter/ipset/ip_set_core.c</span>
<span class="p_header">+++ b/net/netfilter/ipset/ip_set_core.c</span>
<span class="p_chunk">@@ -1982,24 +1982,28 @@</span> <span class="p_context"> static struct pernet_operations ip_set_net_ops = {</span>
 static int __init
 ip_set_init(void)
 {
<span class="p_del">-	int ret = nfnetlink_subsys_register(&amp;ip_set_netlink_subsys);</span>
<span class="p_add">+	int ret = register_pernet_subsys(&amp;ip_set_net_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;ip_set: cannot register pernet_subsys.\n&quot;);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = nfnetlink_subsys_register(&amp;ip_set_netlink_subsys);</span>
 	if (ret != 0) {
 		pr_err(&quot;ip_set: cannot register with nfnetlink.\n&quot;);
<span class="p_add">+		unregister_pernet_subsys(&amp;ip_set_net_ops);</span>
 		return ret;
 	}
<span class="p_add">+</span>
 	ret = nf_register_sockopt(&amp;so_set);
 	if (ret != 0) {
 		pr_err(&quot;SO_SET registry failed: %d\n&quot;, ret);
 		nfnetlink_subsys_unregister(&amp;ip_set_netlink_subsys);
<span class="p_add">+		unregister_pernet_subsys(&amp;ip_set_net_ops);</span>
 		return ret;
 	}
<span class="p_del">-	ret = register_pernet_subsys(&amp;ip_set_net_ops);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		pr_err(&quot;ip_set: cannot register pernet_subsys.\n&quot;);</span>
<span class="p_del">-		nf_unregister_sockopt(&amp;so_set);</span>
<span class="p_del">-		nfnetlink_subsys_unregister(&amp;ip_set_netlink_subsys);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+</span>
 	pr_info(&quot;ip_set: protocol %u\n&quot;, IPSET_PROTOCOL);
 	return 0;
 }
<span class="p_chunk">@@ -2007,9 +2011,10 @@</span> <span class="p_context"> ip_set_init(void)</span>
 static void __exit
 ip_set_fini(void)
 {
<span class="p_del">-	unregister_pernet_subsys(&amp;ip_set_net_ops);</span>
 	nf_unregister_sockopt(&amp;so_set);
 	nfnetlink_subsys_unregister(&amp;ip_set_netlink_subsys);
<span class="p_add">+</span>
<span class="p_add">+	unregister_pernet_subsys(&amp;ip_set_net_ops);</span>
 	pr_debug(&quot;these are the famous last words\n&quot;);
 }
 
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">index 54330fb5efaf..17d9c9df3129 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/types.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/errno.h&gt;
<span class="p_add">+#include &lt;linux/capability.h&gt;</span>
 #include &lt;net/netlink.h&gt;
 #include &lt;net/sock.h&gt;
 
<span class="p_chunk">@@ -295,6 +296,9 @@</span> <span class="p_context"> nfnl_cthelper_new(struct sock *nfnl, struct sk_buff *skb,</span>
 	struct nf_conntrack_tuple tuple;
 	int ret = 0, i;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (!tb[NFCTH_NAME] || !tb[NFCTH_TUPLE])
 		return -EINVAL;
 
<span class="p_chunk">@@ -509,6 +513,9 @@</span> <span class="p_context"> nfnl_cthelper_get(struct sock *nfnl, struct sk_buff *skb,</span>
 	struct nf_conntrack_tuple tuple;
 	bool tuple_set = false;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP) {
 		struct netlink_dump_control c = {
 			.dump = nfnl_cthelper_dump_table,
<span class="p_chunk">@@ -581,6 +588,9 @@</span> <span class="p_context"> nfnl_cthelper_del(struct sock *nfnl, struct sk_buff *skb,</span>
 	bool tuple_set = false, found = false;
 	int i, j = 0, ret;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (tb[NFCTH_NAME])
 		helper_name = nla_data(tb[NFCTH_NAME]);
 
<span class="p_header">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span>
<span class="p_header">index 3ca6db13af92..7a4e43a8acfa 100644</span>
<span class="p_header">--- a/net/netfilter/x_tables.c</span>
<span class="p_header">+++ b/net/netfilter/x_tables.c</span>
<span class="p_chunk">@@ -860,7 +860,7 @@</span> <span class="p_context"> void *xt_copy_counters_from_user(const void __user *user, unsigned int len,</span>
 		if (copy_from_user(&amp;compat_tmp, user, sizeof(compat_tmp)) != 0)
 			return ERR_PTR(-EFAULT);
 
<span class="p_del">-		strlcpy(info-&gt;name, compat_tmp.name, sizeof(info-&gt;name));</span>
<span class="p_add">+		memcpy(info-&gt;name, compat_tmp.name, sizeof(info-&gt;name) - 1);</span>
 		info-&gt;num_counters = compat_tmp.num_counters;
 		user += sizeof(compat_tmp);
 	} else
<span class="p_chunk">@@ -873,9 +873,9 @@</span> <span class="p_context"> void *xt_copy_counters_from_user(const void __user *user, unsigned int len,</span>
 		if (copy_from_user(info, user, sizeof(*info)) != 0)
 			return ERR_PTR(-EFAULT);
 
<span class="p_del">-		info-&gt;name[sizeof(info-&gt;name) - 1] = &#39;\0&#39;;</span>
 		user += sizeof(*info);
 	}
<span class="p_add">+	info-&gt;name[sizeof(info-&gt;name) - 1] = &#39;\0&#39;;</span>
 
 	size = sizeof(struct xt_counters);
 	size *= info-&gt;num_counters;
<span class="p_header">diff --git a/net/netfilter/xt_osf.c b/net/netfilter/xt_osf.c</span>
<span class="p_header">index c529161cdbf8..99f3146b7337 100644</span>
<span class="p_header">--- a/net/netfilter/xt_osf.c</span>
<span class="p_header">+++ b/net/netfilter/xt_osf.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
 
<span class="p_add">+#include &lt;linux/capability.h&gt;</span>
 #include &lt;linux/if.h&gt;
 #include &lt;linux/inetdevice.h&gt;
 #include &lt;linux/ip.h&gt;
<span class="p_chunk">@@ -69,6 +70,9 @@</span> <span class="p_context"> static int xt_osf_add_callback(struct sock *ctnl, struct sk_buff *skb,</span>
 	struct xt_osf_finger *kf = NULL, *sf;
 	int err = 0;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (!osf_attrs[OSF_ATTR_FINGER])
 		return -EINVAL;
 
<span class="p_chunk">@@ -112,6 +116,9 @@</span> <span class="p_context"> static int xt_osf_remove_callback(struct sock *ctnl, struct sk_buff *skb,</span>
 	struct xt_osf_finger *sf;
 	int err = -ENOENT;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (!osf_attrs[OSF_ATTR_FINGER])
 		return -EINVAL;
 
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 3bf0c16023ec..2eafcffb5f8e 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -216,6 +216,9 @@</span> <span class="p_context"> static int __netlink_deliver_tap_skb(struct sk_buff *skb,</span>
 	struct sock *sk = skb-&gt;sk;
 	int ret = -ENOMEM;
 
<span class="p_add">+	if (!net_eq(dev_net(dev), sock_net(sk)))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	dev_hold(dev);
 
 	if (is_vmalloc_addr(skb-&gt;head))
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index f5bf29c033bd..c7d91a0b51da 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -2432,6 +2432,7 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)</span>
 	int offset = 0;
 	int vnet_hdr_len;
 	struct packet_sock *po = pkt_sk(sk);
<span class="p_add">+	bool has_vnet_hdr = false;</span>
 	unsigned short gso_type = 0;
 	int hlen, tlen;
 	int extra_len = 0;
<span class="p_chunk">@@ -2466,6 +2467,7 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)</span>
 		reserve = dev-&gt;hard_header_len;
 	if (po-&gt;has_vnet_hdr) {
 		vnet_hdr_len = sizeof(vnet_hdr);
<span class="p_add">+		has_vnet_hdr = true;</span>
 
 		err = -EINVAL;
 		if (len &lt; vnet_hdr_len)
<span class="p_chunk">@@ -2557,7 +2559,7 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)</span>
 	skb-&gt;priority = sk-&gt;sk_priority;
 	skb-&gt;mark = sk-&gt;sk_mark;
 
<span class="p_del">-	if (po-&gt;has_vnet_hdr) {</span>
<span class="p_add">+	if (has_vnet_hdr) {</span>
 		if (vnet_hdr.flags &amp; VIRTIO_NET_HDR_F_NEEDS_CSUM) {
 			if (!skb_partial_csum_set(skb, vnet_hdr.csum_start,
 						  vnet_hdr.csum_offset)) {
<span class="p_header">diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c</span>
<span class="p_header">index c0bdd3bce189..c15c37370f5a 100644</span>
<span class="p_header">--- a/net/sched/sch_generic.c</span>
<span class="p_header">+++ b/net/sched/sch_generic.c</span>
<span class="p_chunk">@@ -621,6 +621,7 @@</span> <span class="p_context"> void qdisc_reset(struct Qdisc *qdisc)</span>
 		qdisc-&gt;gso_skb = NULL;
 		qdisc-&gt;q.qlen = 0;
 	}
<span class="p_add">+	qdisc-&gt;qstats.backlog = 0;</span>
 }
 EXPORT_SYMBOL(qdisc_reset);
 
<span class="p_header">diff --git a/net/sctp/input.c b/net/sctp/input.c</span>
<span class="p_header">index f2e2cbd2d750..adedd61e2bc4 100644</span>
<span class="p_header">--- a/net/sctp/input.c</span>
<span class="p_header">+++ b/net/sctp/input.c</span>
<span class="p_chunk">@@ -416,7 +416,7 @@</span> <span class="p_context"> void sctp_icmp_redirect(struct sock *sk, struct sctp_transport *t,</span>
 {
 	struct dst_entry *dst;
 
<span class="p_del">-	if (!t)</span>
<span class="p_add">+	if (sock_owned_by_user(sk) || !t)</span>
 		return;
 	dst = sctp_transport_dst_check(t);
 	if (dst)
<span class="p_header">diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c</span>
<span class="p_header">index 198ceb721794..4bfa6070ae68 100644</span>
<span class="p_header">--- a/net/sctp/sm_sideeffect.c</span>
<span class="p_header">+++ b/net/sctp/sm_sideeffect.c</span>
<span class="p_chunk">@@ -1627,8 +1627,8 @@</span> <span class="p_context"> static int sctp_cmd_interpreter(sctp_event_t event_type,</span>
 		case SCTP_CMD_PROCESS_CTSN:
 			/* Dummy up a SACK for processing. */
 			sackh.cum_tsn_ack = cmd-&gt;obj.be32;
<span class="p_del">-			sackh.a_rwnd = asoc-&gt;peer.rwnd +</span>
<span class="p_del">-					asoc-&gt;outqueue.outstanding_bytes;</span>
<span class="p_add">+			sackh.a_rwnd = htonl(asoc-&gt;peer.rwnd +</span>
<span class="p_add">+					     asoc-&gt;outqueue.outstanding_bytes);</span>
 			sackh.num_gap_ack_blocks = 0;
 			sackh.num_dup_tsns = 0;
 			chunk-&gt;subh.sack_hdr = &amp;sackh;
<span class="p_header">diff --git a/net/unix/diag.c b/net/unix/diag.c</span>
<span class="p_header">index 27dd3dcb7739..83b90b62b736 100644</span>
<span class="p_header">--- a/net/unix/diag.c</span>
<span class="p_header">+++ b/net/unix/diag.c</span>
<span class="p_chunk">@@ -256,6 +256,8 @@</span> <span class="p_context"> static int unix_diag_get_exact(struct sk_buff *in_skb,</span>
 	err = -ENOENT;
 	if (sk == NULL)
 		goto out_nosk;
<span class="p_add">+	if (!net_eq(sock_net(sk), net))</span>
<span class="p_add">+		goto out;</span>
 
 	err = sock_diag_check_cookie(sk, req-&gt;udiag_cookie);
 	if (err)
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 6fd21cab5ada..eb71b29eb647 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -464,6 +464,14 @@</span> <span class="p_context"> nl80211_match_policy[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1] = {</span>
 	[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI] = { .type = NLA_U32 },
 };
 
<span class="p_add">+/* policy for packet pattern attributes */</span>
<span class="p_add">+static const struct nla_policy</span>
<span class="p_add">+nl80211_packet_pattern_policy[MAX_NL80211_PKTPAT + 1] = {</span>
<span class="p_add">+	[NL80211_PKTPAT_MASK] = { .type = NLA_BINARY, },</span>
<span class="p_add">+	[NL80211_PKTPAT_PATTERN] = { .type = NLA_BINARY, },</span>
<span class="p_add">+	[NL80211_PKTPAT_OFFSET] = { .type = NLA_U32 },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int nl80211_prepare_wdev_dump(struct sk_buff *skb,
 				     struct netlink_callback *cb,
 				     struct cfg80211_registered_device **rdev,
<span class="p_chunk">@@ -8573,7 +8581,7 @@</span> <span class="p_context"> static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)</span>
 			u8 *mask_pat;
 
 			nla_parse(pat_tb, MAX_NL80211_PKTPAT, nla_data(pat),
<span class="p_del">-				  nla_len(pat), NULL);</span>
<span class="p_add">+				  nla_len(pat), nl80211_packet_pattern_policy);</span>
 			err = -EINVAL;
 			if (!pat_tb[NL80211_PKTPAT_MASK] ||
 			    !pat_tb[NL80211_PKTPAT_PATTERN])
<span class="p_chunk">@@ -8801,7 +8809,7 @@</span> <span class="p_context"> static int nl80211_parse_coalesce_rule(struct cfg80211_registered_device *rdev,</span>
 		u8 *mask_pat;
 
 		nla_parse(pat_tb, MAX_NL80211_PKTPAT, nla_data(pat),
<span class="p_del">-			  nla_len(pat), NULL);</span>
<span class="p_add">+			  nla_len(pat), nl80211_packet_pattern_policy);</span>
 		if (!pat_tb[NL80211_PKTPAT_MASK] ||
 		    !pat_tb[NL80211_PKTPAT_PATTERN])
 			return -EINVAL;
<span class="p_header">diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c</span>
<span class="p_header">index 725cf243860c..1f9558155e1e 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_state.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_state.c</span>
<span class="p_chunk">@@ -1877,6 +1877,7 @@</span> <span class="p_context"> int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen</span>
 	if (err &gt;= 0) {
 		xfrm_sk_policy_insert(sk, err, pol);
 		xfrm_pol_put(pol);
<span class="p_add">+		__sk_dst_reset(sk);</span>
 		err = 0;
 	}
 
<span class="p_header">diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c</span>
<span class="p_header">index c28716452211..316c27f70560 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_user.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_user.c</span>
<span class="p_chunk">@@ -1570,7 +1570,8 @@</span> <span class="p_context"> static int xfrm_dump_policy_done(struct netlink_callback *cb)</span>
 	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &amp;cb-&gt;args[1];
 	struct net *net = sock_net(cb-&gt;skb-&gt;sk);
 
<span class="p_del">-	xfrm_policy_walk_done(walk, net);</span>
<span class="p_add">+	if (cb-&gt;args[0])</span>
<span class="p_add">+		xfrm_policy_walk_done(walk, net);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/security/keys/big_key.c b/security/keys/big_key.c</span>
<span class="p_header">index 8137b27d641d..aa8f46f0918a 100644</span>
<span class="p_header">--- a/security/keys/big_key.c</span>
<span class="p_header">+++ b/security/keys/big_key.c</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> void big_key_destroy(struct key *key)</span>
 		path-&gt;mnt = NULL;
 		path-&gt;dentry = NULL;
 	} else {
<span class="p_del">-		kfree(key-&gt;payload.data);</span>
<span class="p_add">+		kzfree(key-&gt;payload.data);</span>
 		key-&gt;payload.data = NULL;
 	}
 }
<span class="p_header">diff --git a/security/keys/encrypted-keys/encrypted.c b/security/keys/encrypted-keys/encrypted.c</span>
<span class="p_header">index 9c321a25348f..cad4c1f415e3 100644</span>
<span class="p_header">--- a/security/keys/encrypted-keys/encrypted.c</span>
<span class="p_header">+++ b/security/keys/encrypted-keys/encrypted.c</span>
<span class="p_chunk">@@ -315,6 +315,13 @@</span> <span class="p_context"> static struct key *request_user_key(const char *master_desc, u8 **master_key,</span>
 
 	down_read(&amp;ukey-&gt;sem);
 	upayload = ukey-&gt;payload.data;
<span class="p_add">+	if (!upayload) {</span>
<span class="p_add">+		/* key was revoked before we acquired its semaphore */</span>
<span class="p_add">+		up_read(&amp;ukey-&gt;sem);</span>
<span class="p_add">+		key_put(ukey);</span>
<span class="p_add">+		ukey = ERR_PTR(-EKEYREVOKED);</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
 	*master_key = upayload-&gt;data;
 	*master_keylen = upayload-&gt;datalen;
 error:
<span class="p_header">diff --git a/security/keys/internal.h b/security/keys/internal.h</span>
<span class="p_header">index 5f20da01fd8d..31c70323cda9 100644</span>
<span class="p_header">--- a/security/keys/internal.h</span>
<span class="p_header">+++ b/security/keys/internal.h</span>
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,</span>
 extern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);
 extern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);
 
<span class="p_del">-extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);</span>
<span class="p_add">+extern struct key *find_keyring_by_name(const char *name, bool uid_keyring);</span>
 
 extern int install_user_keyrings(void);
 extern int install_thread_keyring_to_cred(struct cred *);
<span class="p_header">diff --git a/security/keys/key.c b/security/keys/key.c</span>
<span class="p_header">index 58ebea254519..c55a01471ea2 100644</span>
<span class="p_header">--- a/security/keys/key.c</span>
<span class="p_header">+++ b/security/keys/key.c</span>
<span class="p_chunk">@@ -298,6 +298,8 @@</span> <span class="p_context"> struct key *key_alloc(struct key_type *type, const char *desc,</span>
 		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_IN_QUOTA;
 	if (flags &amp; KEY_ALLOC_TRUSTED)
 		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_TRUSTED;
<span class="p_add">+	if (flags &amp; KEY_ALLOC_UID_KEYRING)</span>
<span class="p_add">+		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_UID_KEYRING;</span>
 
 #ifdef KEY_DEBUGGING
 	key-&gt;magic = KEY_DEBUG_MAGIC;
<span class="p_header">diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c</span>
<span class="p_header">index 4598617c66de..8cacd856d1ca 100644</span>
<span class="p_header">--- a/security/keys/keyctl.c</span>
<span class="p_header">+++ b/security/keys/keyctl.c</span>
<span class="p_chunk">@@ -745,7 +745,7 @@</span> <span class="p_context"> long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)</span>
 	if (ret == 0)
 		goto can_read_key;
 	if (ret != -EACCES)
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto error2;</span>
 
 	/* we can&#39;t; see if it&#39;s searchable from this process&#39;s keyrings
 	 * - we automatically take account of the fact that it may be
<span class="p_chunk">@@ -1401,11 +1401,9 @@</span> <span class="p_context"> long keyctl_assume_authority(key_serial_t id)</span>
 	}
 
 	ret = keyctl_change_reqkey_auth(authkey);
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		goto error;</span>
<span class="p_add">+	if (ret == 0)</span>
<span class="p_add">+		ret = authkey-&gt;serial;</span>
 	key_put(authkey);
<span class="p_del">-</span>
<span class="p_del">-	ret = authkey-&gt;serial;</span>
 error:
 	return ret;
 }
<span class="p_header">diff --git a/security/keys/keyring.c b/security/keys/keyring.c</span>
<span class="p_header">index 796256db1004..0fa27abd3777 100644</span>
<span class="p_header">--- a/security/keys/keyring.c</span>
<span class="p_header">+++ b/security/keys/keyring.c</span>
<span class="p_chunk">@@ -405,7 +405,7 @@</span> <span class="p_context"> static void keyring_describe(const struct key *keyring, struct seq_file *m)</span>
 }
 
 struct keyring_read_iterator_context {
<span class="p_del">-	size_t			qty;</span>
<span class="p_add">+	size_t			buflen;</span>
 	size_t			count;
 	key_serial_t __user	*buffer;
 };
<span class="p_chunk">@@ -417,9 +417,9 @@</span> <span class="p_context"> static int keyring_read_iterator(const void *object, void *data)</span>
 	int ret;
 
 	kenter(&quot;{%s,%d},,{%zu/%zu}&quot;,
<span class="p_del">-	       key-&gt;type-&gt;name, key-&gt;serial, ctx-&gt;count, ctx-&gt;qty);</span>
<span class="p_add">+	       key-&gt;type-&gt;name, key-&gt;serial, ctx-&gt;count, ctx-&gt;buflen);</span>
 
<span class="p_del">-	if (ctx-&gt;count &gt;= ctx-&gt;qty)</span>
<span class="p_add">+	if (ctx-&gt;count &gt;= ctx-&gt;buflen)</span>
 		return 1;
 
 	ret = put_user(key-&gt;serial, ctx-&gt;buffer);
<span class="p_chunk">@@ -441,38 +441,33 @@</span> <span class="p_context"> static long keyring_read(const struct key *keyring,</span>
 			 char __user *buffer, size_t buflen)
 {
 	struct keyring_read_iterator_context ctx;
<span class="p_del">-	unsigned long nr_keys;</span>
<span class="p_del">-	int ret;</span>
<span class="p_add">+	long ret;</span>
 
 	kenter(&quot;{%d},,%zu&quot;, key_serial(keyring), buflen);
 
 	if (buflen &amp; (sizeof(key_serial_t) - 1))
 		return -EINVAL;
 
<span class="p_del">-	nr_keys = keyring-&gt;keys.nr_leaves_on_tree;</span>
<span class="p_del">-	if (nr_keys == 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Calculate how much data we could return */</span>
<span class="p_del">-	ctx.qty = nr_keys * sizeof(key_serial_t);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!buffer || !buflen)</span>
<span class="p_del">-		return ctx.qty;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (buflen &gt; ctx.qty)</span>
<span class="p_del">-		ctx.qty = buflen;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Copy the IDs of the subscribed keys into the buffer */</span>
<span class="p_del">-	ctx.buffer = (key_serial_t __user *)buffer;</span>
<span class="p_del">-	ctx.count = 0;</span>
<span class="p_del">-	ret = assoc_array_iterate(&amp;keyring-&gt;keys, keyring_read_iterator, &amp;ctx);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		kleave(&quot; = %d [iterate]&quot;, ret);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	/* Copy as many key IDs as fit into the buffer */</span>
<span class="p_add">+	if (buffer &amp;&amp; buflen) {</span>
<span class="p_add">+		ctx.buffer = (key_serial_t __user *)buffer;</span>
<span class="p_add">+		ctx.buflen = buflen;</span>
<span class="p_add">+		ctx.count = 0;</span>
<span class="p_add">+		ret = assoc_array_iterate(&amp;keyring-&gt;keys,</span>
<span class="p_add">+					  keyring_read_iterator, &amp;ctx);</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			kleave(&quot; = %ld [iterate]&quot;, ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	kleave(&quot; = %zu [ok]&quot;, ctx.count);</span>
<span class="p_del">-	return ctx.count;</span>
<span class="p_add">+	/* Return the size of the buffer needed */</span>
<span class="p_add">+	ret = keyring-&gt;keys.nr_leaves_on_tree * sizeof(key_serial_t);</span>
<span class="p_add">+	if (ret &lt;= buflen)</span>
<span class="p_add">+		kleave(&quot;= %ld [ok]&quot;, ret);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		kleave(&quot;= %ld [buffer too small]&quot;, ret);</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_chunk">@@ -935,15 +930,15 @@</span> <span class="p_context"> key_ref_t find_key_to_update(key_ref_t keyring_ref,</span>
 /*
  * Find a keyring with the specified name.
  *
<span class="p_del">- * All named keyrings in the current user namespace are searched, provided they</span>
<span class="p_del">- * grant Search permission directly to the caller (unless this check is</span>
<span class="p_del">- * skipped).  Keyrings whose usage points have reached zero or who have been</span>
<span class="p_del">- * revoked are skipped.</span>
<span class="p_add">+ * Only keyrings that have nonzero refcount, are not revoked, and are owned by a</span>
<span class="p_add">+ * user in the current user namespace are considered.  If @uid_keyring is %true,</span>
<span class="p_add">+ * the keyring additionally must have been allocated as a user or user session</span>
<span class="p_add">+ * keyring; otherwise, it must grant Search permission directly to the caller.</span>
  *
  * Returns a pointer to the keyring with the keyring&#39;s refcount having being
  * incremented on success.  -ENOKEY is returned if a key could not be found.
  */
<span class="p_del">-struct key *find_keyring_by_name(const char *name, bool skip_perm_check)</span>
<span class="p_add">+struct key *find_keyring_by_name(const char *name, bool uid_keyring)</span>
 {
 	struct key *keyring;
 	int bucket;
<span class="p_chunk">@@ -971,10 +966,15 @@</span> <span class="p_context"> struct key *find_keyring_by_name(const char *name, bool skip_perm_check)</span>
 			if (strcmp(keyring-&gt;description, name) != 0)
 				continue;
 
<span class="p_del">-			if (!skip_perm_check &amp;&amp;</span>
<span class="p_del">-			    key_permission(make_key_ref(keyring, 0),</span>
<span class="p_del">-					   KEY_NEED_SEARCH) &lt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			if (uid_keyring) {</span>
<span class="p_add">+				if (!test_bit(KEY_FLAG_UID_KEYRING,</span>
<span class="p_add">+					      &amp;keyring-&gt;flags))</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if (key_permission(make_key_ref(keyring, 0),</span>
<span class="p_add">+						   KEY_NEED_SEARCH) &lt; 0)</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+			}</span>
 
 			/* we&#39;ve got a match but we might end up racing with
 			 * key_cleanup() if the keyring is currently &#39;dead&#39;
<span class="p_header">diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c</span>
<span class="p_header">index 18bad7caf602..e56b57f04cf9 100644</span>
<span class="p_header">--- a/security/keys/process_keys.c</span>
<span class="p_header">+++ b/security/keys/process_keys.c</span>
<span class="p_chunk">@@ -76,7 +76,9 @@</span> <span class="p_context"> int install_user_keyrings(void)</span>
 		if (IS_ERR(uid_keyring)) {
 			uid_keyring = keyring_alloc(buf, user-&gt;uid, INVALID_GID,
 						    cred, user_keyring_perm,
<span class="p_del">-						    KEY_ALLOC_IN_QUOTA, NULL);</span>
<span class="p_add">+						    KEY_ALLOC_UID_KEYRING |</span>
<span class="p_add">+							KEY_ALLOC_IN_QUOTA,</span>
<span class="p_add">+						    NULL);</span>
 			if (IS_ERR(uid_keyring)) {
 				ret = PTR_ERR(uid_keyring);
 				goto error;
<span class="p_chunk">@@ -92,7 +94,9 @@</span> <span class="p_context"> int install_user_keyrings(void)</span>
 			session_keyring =
 				keyring_alloc(buf, user-&gt;uid, INVALID_GID,
 					      cred, user_keyring_perm,
<span class="p_del">-					      KEY_ALLOC_IN_QUOTA, NULL);</span>
<span class="p_add">+					      KEY_ALLOC_UID_KEYRING |</span>
<span class="p_add">+						  KEY_ALLOC_IN_QUOTA,</span>
<span class="p_add">+					      NULL);</span>
 			if (IS_ERR(session_keyring)) {
 				ret = PTR_ERR(session_keyring);
 				goto error_release;
<span class="p_header">diff --git a/security/keys/request_key.c b/security/keys/request_key.c</span>
<span class="p_header">index 9ea60a7bac78..c120a393ff2d 100644</span>
<span class="p_header">--- a/security/keys/request_key.c</span>
<span class="p_header">+++ b/security/keys/request_key.c</span>
<span class="p_chunk">@@ -268,11 +268,12 @@</span> <span class="p_context"> static int construct_key(struct key *key, const void *callout_info,</span>
  * The keyring selected is returned with an extra reference upon it which the
  * caller must release.
  */
<span class="p_del">-static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
<span class="p_add">+static int construct_get_dest_keyring(struct key **_dest_keyring)</span>
 {
 	struct request_key_auth *rka;
 	const struct cred *cred = current_cred();
 	struct key *dest_keyring = *_dest_keyring, *authkey;
<span class="p_add">+	int ret;</span>
 
 	kenter(&quot;%p&quot;, dest_keyring);
 
<span class="p_chunk">@@ -281,6 +282,8 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 		/* the caller supplied one */
 		key_get(dest_keyring);
 	} else {
<span class="p_add">+		bool do_perm_check = true;</span>
<span class="p_add">+</span>
 		/* use a default keyring; falling through the cases until we
 		 * find one that we actually have */
 		switch (cred-&gt;jit_keyring) {
<span class="p_chunk">@@ -295,8 +298,10 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 					dest_keyring =
 						key_get(rka-&gt;dest_keyring);
 				up_read(&amp;authkey-&gt;sem);
<span class="p_del">-				if (dest_keyring)</span>
<span class="p_add">+				if (dest_keyring) {</span>
<span class="p_add">+					do_perm_check = false;</span>
 					break;
<span class="p_add">+				}</span>
 			}
 
 		case KEY_REQKEY_DEFL_THREAD_KEYRING:
<span class="p_chunk">@@ -331,11 +336,29 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 		default:
 			BUG();
 		}
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Require Write permission on the keyring.  This is essential</span>
<span class="p_add">+		 * because the default keyring may be the session keyring, and</span>
<span class="p_add">+		 * joining a keyring only requires Search permission.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * However, this check is skipped for the &quot;requestor keyring&quot; so</span>
<span class="p_add">+		 * that /sbin/request-key can itself use request_key() to add</span>
<span class="p_add">+		 * keys to the original requestor&#39;s destination keyring.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (dest_keyring &amp;&amp; do_perm_check) {</span>
<span class="p_add">+			ret = key_permission(make_key_ref(dest_keyring, 1),</span>
<span class="p_add">+					     KEY_NEED_WRITE);</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				key_put(dest_keyring);</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	*_dest_keyring = dest_keyring;
 	kleave(&quot; [dk %d]&quot;, key_serial(dest_keyring));
<span class="p_del">-	return;</span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -460,11 +483,15 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct keyring_search_context *ctx,</span>
 	if (ctx-&gt;index_key.type == &amp;key_type_keyring)
 		return ERR_PTR(-EPERM);
 	
<span class="p_del">-	user = key_user_lookup(current_fsuid());</span>
<span class="p_del">-	if (!user)</span>
<span class="p_del">-		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	ret = construct_get_dest_keyring(&amp;dest_keyring);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto error;</span>
 
<span class="p_del">-	construct_get_dest_keyring(&amp;dest_keyring);</span>
<span class="p_add">+	user = key_user_lookup(current_fsuid());</span>
<span class="p_add">+	if (!user) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto error_put_dest_keyring;</span>
<span class="p_add">+	}</span>
 
 	ret = construct_alloc_key(ctx, dest_keyring, flags, user, &amp;key);
 	key_user_put(user);
<span class="p_chunk">@@ -479,7 +506,7 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct keyring_search_context *ctx,</span>
 	} else if (ret == -EINPROGRESS) {
 		ret = 0;
 	} else {
<span class="p_del">-		goto couldnt_alloc_key;</span>
<span class="p_add">+		goto error_put_dest_keyring;</span>
 	}
 
 	key_put(dest_keyring);
<span class="p_chunk">@@ -489,8 +516,9 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct keyring_search_context *ctx,</span>
 construction_failed:
 	key_negate_and_link(key, key_negative_timeout, NULL, NULL);
 	key_put(key);
<span class="p_del">-couldnt_alloc_key:</span>
<span class="p_add">+error_put_dest_keyring:</span>
 	key_put(dest_keyring);
<span class="p_add">+error:</span>
 	kleave(&quot; = %d&quot;, ret);
 	return ERR_PTR(ret);
 }
<span class="p_header">diff --git a/security/keys/request_key_auth.c b/security/keys/request_key_auth.c</span>
<span class="p_header">index 7495a93b4b90..74e3fe9b47be 100644</span>
<span class="p_header">--- a/security/keys/request_key_auth.c</span>
<span class="p_header">+++ b/security/keys/request_key_auth.c</span>
<span class="p_chunk">@@ -107,6 +107,18 @@</span> <span class="p_context"> static void request_key_auth_revoke(struct key *key)</span>
 	}
 }
 
<span class="p_add">+static void free_request_key_auth(struct request_key_auth *rka)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!rka)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	key_put(rka-&gt;target_key);</span>
<span class="p_add">+	key_put(rka-&gt;dest_keyring);</span>
<span class="p_add">+	if (rka-&gt;cred)</span>
<span class="p_add">+		put_cred(rka-&gt;cred);</span>
<span class="p_add">+	kfree(rka-&gt;callout_info);</span>
<span class="p_add">+	kfree(rka);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Destroy an instantiation authorisation token key.
  */
<span class="p_chunk">@@ -116,15 +128,7 @@</span> <span class="p_context"> static void request_key_auth_destroy(struct key *key)</span>
 
 	kenter(&quot;{%d}&quot;, key-&gt;serial);
 
<span class="p_del">-	if (rka-&gt;cred) {</span>
<span class="p_del">-		put_cred(rka-&gt;cred);</span>
<span class="p_del">-		rka-&gt;cred = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	key_put(rka-&gt;target_key);</span>
<span class="p_del">-	key_put(rka-&gt;dest_keyring);</span>
<span class="p_del">-	kfree(rka-&gt;callout_info);</span>
<span class="p_del">-	kfree(rka);</span>
<span class="p_add">+	free_request_key_auth(rka);</span>
 }
 
 /*
<span class="p_chunk">@@ -138,22 +142,17 @@</span> <span class="p_context"> struct key *request_key_auth_new(struct key *target, const void *callout_info,</span>
 	const struct cred *cred = current-&gt;cred;
 	struct key *authkey = NULL;
 	char desc[20];
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = -ENOMEM;</span>
 
 	kenter(&quot;%d,&quot;, target-&gt;serial);
 
 	/* allocate a auth record */
<span class="p_del">-	rka = kmalloc(sizeof(*rka), GFP_KERNEL);</span>
<span class="p_del">-	if (!rka) {</span>
<span class="p_del">-		kleave(&quot; = -ENOMEM&quot;);</span>
<span class="p_del">-		return ERR_PTR(-ENOMEM);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	rka = kzalloc(sizeof(*rka), GFP_KERNEL);</span>
<span class="p_add">+	if (!rka)</span>
<span class="p_add">+		goto error;</span>
 	rka-&gt;callout_info = kmalloc(callout_len, GFP_KERNEL);
<span class="p_del">-	if (!rka-&gt;callout_info) {</span>
<span class="p_del">-		kleave(&quot; = -ENOMEM&quot;);</span>
<span class="p_del">-		kfree(rka);</span>
<span class="p_del">-		return ERR_PTR(-ENOMEM);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!rka-&gt;callout_info)</span>
<span class="p_add">+		goto error_free_rka;</span>
 
 	/* see if the calling process is already servicing the key request of
 	 * another process */
<span class="p_chunk">@@ -163,8 +162,12 @@</span> <span class="p_context"> struct key *request_key_auth_new(struct key *target, const void *callout_info,</span>
 
 		/* if the auth key has been revoked, then the key we&#39;re
 		 * servicing is already instantiated */
<span class="p_del">-		if (test_bit(KEY_FLAG_REVOKED, &amp;cred-&gt;request_key_auth-&gt;flags))</span>
<span class="p_del">-			goto auth_key_revoked;</span>
<span class="p_add">+		if (test_bit(KEY_FLAG_REVOKED,</span>
<span class="p_add">+			     &amp;cred-&gt;request_key_auth-&gt;flags)) {</span>
<span class="p_add">+			up_read(&amp;cred-&gt;request_key_auth-&gt;sem);</span>
<span class="p_add">+			ret = -EKEYREVOKED;</span>
<span class="p_add">+			goto error_free_rka;</span>
<span class="p_add">+		}</span>
 
 		irka = cred-&gt;request_key_auth-&gt;payload.data;
 		rka-&gt;cred = get_cred(irka-&gt;cred);
<span class="p_chunk">@@ -192,32 +195,22 @@</span> <span class="p_context"> struct key *request_key_auth_new(struct key *target, const void *callout_info,</span>
 			    KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA);
 	if (IS_ERR(authkey)) {
 		ret = PTR_ERR(authkey);
<span class="p_del">-		goto error_alloc;</span>
<span class="p_add">+		goto error_free_rka;</span>
 	}
 
 	/* construct the auth key */
 	ret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);
 	if (ret &lt; 0)
<span class="p_del">-		goto error_inst;</span>
<span class="p_add">+		goto error_put_authkey;</span>
 
 	kleave(&quot; = {%d,%d}&quot;, authkey-&gt;serial, atomic_read(&amp;authkey-&gt;usage));
 	return authkey;
 
<span class="p_del">-auth_key_revoked:</span>
<span class="p_del">-	up_read(&amp;cred-&gt;request_key_auth-&gt;sem);</span>
<span class="p_del">-	kfree(rka-&gt;callout_info);</span>
<span class="p_del">-	kfree(rka);</span>
<span class="p_del">-	kleave(&quot;= -EKEYREVOKED&quot;);</span>
<span class="p_del">-	return ERR_PTR(-EKEYREVOKED);</span>
<span class="p_del">-</span>
<span class="p_del">-error_inst:</span>
<span class="p_del">-	key_revoke(authkey);</span>
<span class="p_add">+error_put_authkey:</span>
 	key_put(authkey);
<span class="p_del">-error_alloc:</span>
<span class="p_del">-	key_put(rka-&gt;target_key);</span>
<span class="p_del">-	key_put(rka-&gt;dest_keyring);</span>
<span class="p_del">-	kfree(rka-&gt;callout_info);</span>
<span class="p_del">-	kfree(rka);</span>
<span class="p_add">+error_free_rka:</span>
<span class="p_add">+	free_request_key_auth(rka);</span>
<span class="p_add">+error:</span>
 	kleave(&quot;= %d&quot;, ret);
 	return ERR_PTR(ret);
 }
<span class="p_header">diff --git a/security/keys/trusted.c b/security/keys/trusted.c</span>
<span class="p_header">index 6b804aa4529a..2ee504a8c13f 100644</span>
<span class="p_header">--- a/security/keys/trusted.c</span>
<span class="p_header">+++ b/security/keys/trusted.c</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> static int TSS_sha1(const unsigned char *data, unsigned int datalen,</span>
 	}
 
 	ret = crypto_shash_digest(&amp;sdesc-&gt;shash, data, datalen, digest);
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static int TSS_rawhmac(unsigned char *digest, const unsigned char *key,</span>
 	if (!ret)
 		ret = crypto_shash_final(&amp;sdesc-&gt;shash, digest);
 out:
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static int TSS_authhmac(unsigned char *digest, const unsigned char *key,</span>
 				  paramdigest, TPM_NONCE_SIZE, h1,
 				  TPM_NONCE_SIZE, h2, 1, &amp;c, 0, 0);
 out:
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static int TSS_checkhmac1(unsigned char *buffer,</span>
 	if (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))
 		ret = -EINVAL;
 out:
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> static int TSS_checkhmac2(unsigned char *buffer,</span>
 	if (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))
 		ret = -EINVAL;
 out:
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -563,7 +563,7 @@</span> <span class="p_context"> static int tpm_seal(struct tpm_buf *tb, uint16_t keytype,</span>
 		*bloblen = storedsize;
 	}
 out:
<span class="p_del">-	kfree(td);</span>
<span class="p_add">+	kzfree(td);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -677,7 +677,7 @@</span> <span class="p_context"> static int key_seal(struct trusted_key_payload *p,</span>
 	if (ret &lt; 0)
 		pr_info(&quot;trusted_key: srkseal failed (%d)\n&quot;, ret);
 
<span class="p_del">-	kfree(tb);</span>
<span class="p_add">+	kzfree(tb);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -702,7 +702,7 @@</span> <span class="p_context"> static int key_unseal(struct trusted_key_payload *p,</span>
 		/* pull migratable flag out of sealed key */
 		p-&gt;migratable = p-&gt;key[--p-&gt;key_len];
 
<span class="p_del">-	kfree(tb);</span>
<span class="p_add">+	kzfree(tb);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -961,12 +961,12 @@</span> <span class="p_context"> static int trusted_instantiate(struct key *key,</span>
 	if (!ret &amp;&amp; options-&gt;pcrlock)
 		ret = pcrlock(options-&gt;pcrlock);
 out:
<span class="p_del">-	kfree(datablob);</span>
<span class="p_del">-	kfree(options);</span>
<span class="p_add">+	kzfree(datablob);</span>
<span class="p_add">+	kzfree(options);</span>
 	if (!ret)
 		rcu_assign_keypointer(key, payload);
 	else
<span class="p_del">-		kfree(payload);</span>
<span class="p_add">+		kzfree(payload);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -975,8 +975,7 @@</span> <span class="p_context"> static void trusted_rcu_free(struct rcu_head *rcu)</span>
 	struct trusted_key_payload *p;
 
 	p = container_of(rcu, struct trusted_key_payload, rcu);
<span class="p_del">-	memset(p-&gt;key, 0, p-&gt;key_len);</span>
<span class="p_del">-	kfree(p);</span>
<span class="p_add">+	kzfree(p);</span>
 }
 
 /*
<span class="p_chunk">@@ -1015,7 +1014,7 @@</span> <span class="p_context"> static int trusted_update(struct key *key, struct key_preparsed_payload *prep)</span>
 	ret = datablob_parse(datablob, new_p, new_o);
 	if (ret != Opt_update) {
 		ret = -EINVAL;
<span class="p_del">-		kfree(new_p);</span>
<span class="p_add">+		kzfree(new_p);</span>
 		goto out;
 	}
 	/* copy old key values, and reseal with new pcrs */
<span class="p_chunk">@@ -1028,22 +1027,22 @@</span> <span class="p_context"> static int trusted_update(struct key *key, struct key_preparsed_payload *prep)</span>
 	ret = key_seal(new_p, new_o);
 	if (ret &lt; 0) {
 		pr_info(&quot;trusted_key: key_seal failed (%d)\n&quot;, ret);
<span class="p_del">-		kfree(new_p);</span>
<span class="p_add">+		kzfree(new_p);</span>
 		goto out;
 	}
 	if (new_o-&gt;pcrlock) {
 		ret = pcrlock(new_o-&gt;pcrlock);
 		if (ret &lt; 0) {
 			pr_info(&quot;trusted_key: pcrlock failed (%d)\n&quot;, ret);
<span class="p_del">-			kfree(new_p);</span>
<span class="p_add">+			kzfree(new_p);</span>
 			goto out;
 		}
 	}
 	rcu_assign_keypointer(key, new_p);
 	call_rcu(&amp;p-&gt;rcu, trusted_rcu_free);
 out:
<span class="p_del">-	kfree(datablob);</span>
<span class="p_del">-	kfree(new_o);</span>
<span class="p_add">+	kzfree(datablob);</span>
<span class="p_add">+	kzfree(new_o);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1062,34 +1061,30 @@</span> <span class="p_context"> static long trusted_read(const struct key *key, char __user *buffer,</span>
 	p = rcu_dereference_key(key);
 	if (!p)
 		return -EINVAL;
<span class="p_del">-	if (!buffer || buflen &lt;= 0)</span>
<span class="p_del">-		return 2 * p-&gt;blob_len;</span>
<span class="p_del">-	ascii_buf = kmalloc(2 * p-&gt;blob_len, GFP_KERNEL);</span>
<span class="p_del">-	if (!ascii_buf)</span>
<span class="p_del">-		return -ENOMEM;</span>
 
<span class="p_del">-	bufp = ascii_buf;</span>
<span class="p_del">-	for (i = 0; i &lt; p-&gt;blob_len; i++)</span>
<span class="p_del">-		bufp = hex_byte_pack(bufp, p-&gt;blob[i]);</span>
<span class="p_del">-	if ((copy_to_user(buffer, ascii_buf, 2 * p-&gt;blob_len)) != 0) {</span>
<span class="p_del">-		kfree(ascii_buf);</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+	if (buffer &amp;&amp; buflen &gt;= 2 * p-&gt;blob_len) {</span>
<span class="p_add">+		ascii_buf = kmalloc(2 * p-&gt;blob_len, GFP_KERNEL);</span>
<span class="p_add">+		if (!ascii_buf)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		bufp = ascii_buf;</span>
<span class="p_add">+		for (i = 0; i &lt; p-&gt;blob_len; i++)</span>
<span class="p_add">+			bufp = hex_byte_pack(bufp, p-&gt;blob[i]);</span>
<span class="p_add">+		if (copy_to_user(buffer, ascii_buf, 2 * p-&gt;blob_len) != 0) {</span>
<span class="p_add">+			kzfree(ascii_buf);</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		kzfree(ascii_buf);</span>
 	}
<span class="p_del">-	kfree(ascii_buf);</span>
 	return 2 * p-&gt;blob_len;
 }
 
 /*
<span class="p_del">- * trusted_destroy - before freeing the key, clear the decrypted data</span>
<span class="p_add">+ * trusted_destroy - clear and free the key&#39;s payload</span>
  */
 static void trusted_destroy(struct key *key)
 {
<span class="p_del">-	struct trusted_key_payload *p = key-&gt;payload.data;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!p)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	memset(p-&gt;key, 0, p-&gt;key_len);</span>
<span class="p_del">-	kfree(key-&gt;payload.data);</span>
<span class="p_add">+	kzfree(key-&gt;payload.data);</span>
 }
 
 struct key_type key_type_trusted = {
<span class="p_header">diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c</span>
<span class="p_header">index 40cdee62097e..a6a3482e4d7e 100644</span>
<span class="p_header">--- a/security/smack/smack_lsm.c</span>
<span class="p_header">+++ b/security/smack/smack_lsm.c</span>
<span class="p_chunk">@@ -163,12 +163,10 @@</span> <span class="p_context"> static int smk_copy_rules(struct list_head *nhead, struct list_head *ohead,</span>
  */
 static inline unsigned int smk_ptrace_mode(unsigned int mode)
 {
<span class="p_del">-	switch (mode) {</span>
<span class="p_del">-	case PTRACE_MODE_READ:</span>
<span class="p_del">-		return MAY_READ;</span>
<span class="p_del">-	case PTRACE_MODE_ATTACH:</span>
<span class="p_add">+	if (mode &amp; PTRACE_MODE_ATTACH)</span>
 		return MAY_READWRITE;
<span class="p_del">-	}</span>
<span class="p_add">+	if (mode &amp; PTRACE_MODE_READ)</span>
<span class="p_add">+		return MAY_READ;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -674,7 +672,7 @@</span> <span class="p_context"> static int smack_inode_init_security(struct inode *inode, struct inode *dir,</span>
 	}
 
 	if (len)
<span class="p_del">-		*len = strlen(isp) + 1;</span>
<span class="p_add">+		*len = strlen(isp);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1060,7 +1058,7 @@</span> <span class="p_context"> static int smack_inode_removexattr(struct dentry *dentry, const char *name)</span>
  * @inode: the object
  * @name: attribute name
  * @buffer: where to put the result
<span class="p_del">- * @alloc: unused</span>
<span class="p_add">+ * @alloc: duplicate memory</span>
  *
  * Returns the size of the attribute or an error code
  */
<span class="p_chunk">@@ -1073,43 +1071,38 @@</span> <span class="p_context"> static int smack_inode_getsecurity(const struct inode *inode,</span>
 	struct super_block *sbp;
 	struct inode *ip = (struct inode *)inode;
 	char *isp;
<span class="p_del">-	int ilen;</span>
<span class="p_del">-	int rc = 0;</span>
 
<span class="p_del">-	if (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {</span>
<span class="p_add">+	if (strcmp(name, XATTR_SMACK_SUFFIX) == 0)</span>
 		isp = smk_of_inode(inode);
<span class="p_del">-		ilen = strlen(isp) + 1;</span>
<span class="p_del">-		*buffer = isp;</span>
<span class="p_del">-		return ilen;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The rest of the Smack xattrs are only on sockets.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	sbp = ip-&gt;i_sb;</span>
<span class="p_del">-	if (sbp-&gt;s_magic != SOCKFS_MAGIC)</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The rest of the Smack xattrs are only on sockets.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		sbp = ip-&gt;i_sb;</span>
<span class="p_add">+		if (sbp-&gt;s_magic != SOCKFS_MAGIC)</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
 
<span class="p_del">-	sock = SOCKET_I(ip);</span>
<span class="p_del">-	if (sock == NULL || sock-&gt;sk == NULL)</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+		sock = SOCKET_I(ip);</span>
<span class="p_add">+		if (sock == NULL || sock-&gt;sk == NULL)</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
 
<span class="p_del">-	ssp = sock-&gt;sk-&gt;sk_security;</span>
<span class="p_add">+		ssp = sock-&gt;sk-&gt;sk_security;</span>
 
<span class="p_del">-	if (strcmp(name, XATTR_SMACK_IPIN) == 0)</span>
<span class="p_del">-		isp = ssp-&gt;smk_in-&gt;smk_known;</span>
<span class="p_del">-	else if (strcmp(name, XATTR_SMACK_IPOUT) == 0)</span>
<span class="p_del">-		isp = ssp-&gt;smk_out-&gt;smk_known;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+		if (strcmp(name, XATTR_SMACK_IPIN) == 0)</span>
<span class="p_add">+			isp = ssp-&gt;smk_in-&gt;smk_known;</span>
<span class="p_add">+		else if (strcmp(name, XATTR_SMACK_IPOUT) == 0)</span>
<span class="p_add">+			isp = ssp-&gt;smk_out-&gt;smk_known;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	ilen = strlen(isp) + 1;</span>
<span class="p_del">-	if (rc == 0) {</span>
<span class="p_del">-		*buffer = isp;</span>
<span class="p_del">-		rc = ilen;</span>
<span class="p_add">+	if (alloc) {</span>
<span class="p_add">+		*buffer = kstrdup(isp, GFP_KERNEL);</span>
<span class="p_add">+		if (*buffer == NULL)</span>
<span class="p_add">+			return -ENOMEM;</span>
 	}
 
<span class="p_del">-	return rc;</span>
<span class="p_add">+	return strlen(isp);</span>
 }
 
 
<span class="p_header">diff --git a/security/yama/yama_lsm.c b/security/yama/yama_lsm.c</span>
<span class="p_header">index 13c88fbcf037..0038834b558e 100644</span>
<span class="p_header">--- a/security/yama/yama_lsm.c</span>
<span class="p_header">+++ b/security/yama/yama_lsm.c</span>
<span class="p_chunk">@@ -292,7 +292,7 @@</span> <span class="p_context"> int yama_ptrace_access_check(struct task_struct *child,</span>
 		return rc;
 
 	/* require ptrace target be a child of ptracer on attach */
<span class="p_del">-	if (mode == PTRACE_MODE_ATTACH) {</span>
<span class="p_add">+	if (mode &amp; PTRACE_MODE_ATTACH) {</span>
 		switch (ptrace_scope) {
 		case YAMA_SCOPE_DISABLED:
 			/* No additional restrictions. */
<span class="p_chunk">@@ -318,7 +318,7 @@</span> <span class="p_context"> int yama_ptrace_access_check(struct task_struct *child,</span>
 		}
 	}
 
<span class="p_del">-	if (rc) {</span>
<span class="p_add">+	if (rc &amp;&amp; (mode &amp; PTRACE_MODE_NOAUDIT) == 0) {</span>
 		printk_ratelimited(KERN_NOTICE
 			&quot;ptrace of pid %d was attempted by: %s (pid %d)\n&quot;,
 			child-&gt;pid, current-&gt;comm, current-&gt;pid);
<span class="p_header">diff --git a/sound/core/hrtimer.c b/sound/core/hrtimer.c</span>
<span class="p_header">index 38514ed6e55c..9b3445922645 100644</span>
<span class="p_header">--- a/sound/core/hrtimer.c</span>
<span class="p_header">+++ b/sound/core/hrtimer.c</span>
<span class="p_chunk">@@ -144,6 +144,7 @@</span> <span class="p_context"> static int __init snd_hrtimer_init(void)</span>
 	timer-&gt;hw = hrtimer_hw;
 	timer-&gt;hw.resolution = resolution;
 	timer-&gt;hw.ticks = NANO_SEC / resolution;
<span class="p_add">+	timer-&gt;max_instances = 100; /* lower the limit */</span>
 
 	err = snd_timer_global_register(timer);
 	if (err &lt; 0) {
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c</span>
<span class="p_header">index 3a4569669efa..86353dc0439c 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_midi.c</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_midi.c</span>
<span class="p_chunk">@@ -615,9 +615,7 @@</span> <span class="p_context"> send_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, struct seq</span>
 	if (!dp-&gt;timer-&gt;running)
 		len = snd_seq_oss_timer_start(dp-&gt;timer);
 	if (ev-&gt;type == SNDRV_SEQ_EVENT_SYSEX) {
<span class="p_del">-		if ((ev-&gt;flags &amp; SNDRV_SEQ_EVENT_LENGTH_MASK) == SNDRV_SEQ_EVENT_LENGTH_VARIABLE)</span>
<span class="p_del">-			snd_seq_oss_readq_puts(dp-&gt;readq, mdev-&gt;seq_device,</span>
<span class="p_del">-					       ev-&gt;data.ext.ptr, ev-&gt;data.ext.len);</span>
<span class="p_add">+		snd_seq_oss_readq_sysex(dp-&gt;readq, mdev-&gt;seq_device, ev);</span>
 	} else {
 		len = snd_midi_event_decode(mdev-&gt;coder, msg, sizeof(msg), ev);
 		if (len &gt; 0)
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_readq.c b/sound/core/seq/oss/seq_oss_readq.c</span>
<span class="p_header">index 654d17a5023c..dffc27374bdf 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_readq.c</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_readq.c</span>
<span class="p_chunk">@@ -119,6 +119,35 @@</span> <span class="p_context"> snd_seq_oss_readq_puts(struct seq_oss_readq *q, int dev, unsigned char *data, in</span>
 	return 0;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * put MIDI sysex bytes; the event buffer may be chained, thus it has</span>
<span class="p_add">+ * to be expanded via snd_seq_dump_var_event().</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct readq_sysex_ctx {</span>
<span class="p_add">+	struct seq_oss_readq *readq;</span>
<span class="p_add">+	int dev;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int readq_dump_sysex(void *ptr, void *buf, int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct readq_sysex_ctx *ctx = ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	return snd_seq_oss_readq_puts(ctx-&gt;readq, ctx-&gt;dev, buf, count);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int snd_seq_oss_readq_sysex(struct seq_oss_readq *q, int dev,</span>
<span class="p_add">+			    struct snd_seq_event *ev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct readq_sysex_ctx ctx = {</span>
<span class="p_add">+		.readq = q,</span>
<span class="p_add">+		.dev = dev</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ev-&gt;flags &amp; SNDRV_SEQ_EVENT_LENGTH_MASK) != SNDRV_SEQ_EVENT_LENGTH_VARIABLE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return snd_seq_dump_var_event(ev, readq_dump_sysex, &amp;ctx);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * copy an event to input queue:
  * return zero if enqueued
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_readq.h b/sound/core/seq/oss/seq_oss_readq.h</span>
<span class="p_header">index f1463f1f449e..8d033ca2d23f 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_readq.h</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_readq.h</span>
<span class="p_chunk">@@ -44,6 +44,8 @@</span> <span class="p_context"> void snd_seq_oss_readq_delete(struct seq_oss_readq *q);</span>
 void snd_seq_oss_readq_clear(struct seq_oss_readq *readq);
 unsigned int snd_seq_oss_readq_poll(struct seq_oss_readq *readq, struct file *file, poll_table *wait);
 int snd_seq_oss_readq_puts(struct seq_oss_readq *readq, int dev, unsigned char *data, int len);
<span class="p_add">+int snd_seq_oss_readq_sysex(struct seq_oss_readq *q, int dev,</span>
<span class="p_add">+			    struct snd_seq_event *ev);</span>
 int snd_seq_oss_readq_put_event(struct seq_oss_readq *readq, union evrec *ev);
 int snd_seq_oss_readq_put_timestamp(struct seq_oss_readq *readq, unsigned long curt, int seq_mode);
 int snd_seq_oss_readq_pick(struct seq_oss_readq *q, union evrec *rec);
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index a3988a4bcfd6..0a52e377a617 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -676,7 +676,7 @@</span> <span class="p_context"> static int deliver_to_subscribers(struct snd_seq_client *client,</span>
 	if (atomic)
 		read_lock(&amp;grp-&gt;list_lock);
 	else
<span class="p_del">-		down_read(&amp;grp-&gt;list_mutex);</span>
<span class="p_add">+		down_read_nested(&amp;grp-&gt;list_mutex, hop);</span>
 	list_for_each_entry(subs, &amp;grp-&gt;list_head, src_list) {
 		/* both ports ready? */
 		if (atomic_read(&amp;subs-&gt;ref_count) != 2)
<span class="p_header">diff --git a/sound/core/seq/seq_virmidi.c b/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">index 81134e067184..3b126af4a026 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_virmidi.c</span>
<span class="p_chunk">@@ -77,13 +77,17 @@</span> <span class="p_context"> static void snd_virmidi_init_event(struct snd_virmidi *vmidi,</span>
  * decode input event and put to read buffer of each opened file
  */
 static int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,
<span class="p_del">-					 struct snd_seq_event *ev)</span>
<span class="p_add">+					 struct snd_seq_event *ev,</span>
<span class="p_add">+					 bool atomic)</span>
 {
 	struct snd_virmidi *vmidi;
 	unsigned char msg[4];
 	int len;
 
<span class="p_del">-	read_lock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	if (atomic)</span>
<span class="p_add">+		read_lock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		down_read(&amp;rdev-&gt;filelist_sem);</span>
 	list_for_each_entry(vmidi, &amp;rdev-&gt;filelist, list) {
 		if (!vmidi-&gt;trigger)
 			continue;
<span class="p_chunk">@@ -97,7 +101,10 @@</span> <span class="p_context"> static int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,</span>
 				snd_rawmidi_receive(vmidi-&gt;substream, msg, len);
 		}
 	}
<span class="p_del">-	read_unlock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	if (atomic)</span>
<span class="p_add">+		read_unlock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		up_read(&amp;rdev-&gt;filelist_sem);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -115,7 +122,7 @@</span> <span class="p_context"> int snd_virmidi_receive(struct snd_rawmidi *rmidi, struct snd_seq_event *ev)</span>
 	struct snd_virmidi_dev *rdev;
 
 	rdev = rmidi-&gt;private_data;
<span class="p_del">-	return snd_virmidi_dev_receive_event(rdev, ev);</span>
<span class="p_add">+	return snd_virmidi_dev_receive_event(rdev, ev, true);</span>
 }
 #endif  /*  0  */
 
<span class="p_chunk">@@ -130,7 +137,7 @@</span> <span class="p_context"> static int snd_virmidi_event_input(struct snd_seq_event *ev, int direct,</span>
 	rdev = private_data;
 	if (!(rdev-&gt;flags &amp; SNDRV_VIRMIDI_USE))
 		return 0; /* ignored */
<span class="p_del">-	return snd_virmidi_dev_receive_event(rdev, ev);</span>
<span class="p_add">+	return snd_virmidi_dev_receive_event(rdev, ev, atomic);</span>
 }
 
 /*
<span class="p_chunk">@@ -209,7 +216,6 @@</span> <span class="p_context"> static int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)</span>
 	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
 	struct snd_virmidi *vmidi;
<span class="p_del">-	unsigned long flags;</span>
 
 	vmidi = kzalloc(sizeof(*vmidi), GFP_KERNEL);
 	if (vmidi == NULL)
<span class="p_chunk">@@ -223,9 +229,11 @@</span> <span class="p_context"> static int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)</span>
 	vmidi-&gt;client = rdev-&gt;client;
 	vmidi-&gt;port = rdev-&gt;port;	
 	runtime-&gt;private_data = vmidi;
<span class="p_del">-	write_lock_irqsave(&amp;rdev-&gt;filelist_lock, flags);</span>
<span class="p_add">+	down_write(&amp;rdev-&gt;filelist_sem);</span>
<span class="p_add">+	write_lock_irq(&amp;rdev-&gt;filelist_lock);</span>
 	list_add_tail(&amp;vmidi-&gt;list, &amp;rdev-&gt;filelist);
<span class="p_del">-	write_unlock_irqrestore(&amp;rdev-&gt;filelist_lock, flags);</span>
<span class="p_add">+	write_unlock_irq(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	up_write(&amp;rdev-&gt;filelist_sem);</span>
 	vmidi-&gt;rdev = rdev;
 	return 0;
 }
<span class="p_chunk">@@ -264,9 +272,11 @@</span> <span class="p_context"> static int snd_virmidi_input_close(struct snd_rawmidi_substream *substream)</span>
 	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;
 	struct snd_virmidi *vmidi = substream-&gt;runtime-&gt;private_data;
 
<span class="p_add">+	down_write(&amp;rdev-&gt;filelist_sem);</span>
 	write_lock_irq(&amp;rdev-&gt;filelist_lock);
 	list_del(&amp;vmidi-&gt;list);
 	write_unlock_irq(&amp;rdev-&gt;filelist_lock);
<span class="p_add">+	up_write(&amp;rdev-&gt;filelist_sem);</span>
 	snd_midi_event_free(vmidi-&gt;parser);
 	substream-&gt;runtime-&gt;private_data = NULL;
 	kfree(vmidi);
<span class="p_chunk">@@ -520,6 +530,7 @@</span> <span class="p_context"> int snd_virmidi_new(struct snd_card *card, int device, struct snd_rawmidi **rrmi</span>
 	rdev-&gt;rmidi = rmidi;
 	rdev-&gt;device = device;
 	rdev-&gt;client = -1;
<span class="p_add">+	init_rwsem(&amp;rdev-&gt;filelist_sem);</span>
 	rwlock_init(&amp;rdev-&gt;filelist_lock);
 	INIT_LIST_HEAD(&amp;rdev-&gt;filelist);
 	rdev-&gt;seq_mode = SNDRV_VIRMIDI_SEQ_DISPATCH;
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index 8bdfec237ada..762da0a59ba0 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"> static void snd_timer_request(struct snd_timer_id *tid)</span>
  *
  * call this with register_mutex down.
  */
<span class="p_del">-static void snd_timer_check_slave(struct snd_timer_instance *slave)</span>
<span class="p_add">+static int snd_timer_check_slave(struct snd_timer_instance *slave)</span>
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *master;
<span class="p_chunk">@@ -191,16 +191,21 @@</span> <span class="p_context"> static void snd_timer_check_slave(struct snd_timer_instance *slave)</span>
 		list_for_each_entry(master, &amp;timer-&gt;open_list_head, open_list) {
 			if (slave-&gt;slave_class == master-&gt;slave_class &amp;&amp;
 			    slave-&gt;slave_id == master-&gt;slave_id) {
<span class="p_add">+				if (master-&gt;timer-&gt;num_instances &gt;=</span>
<span class="p_add">+				    master-&gt;timer-&gt;max_instances)</span>
<span class="p_add">+					return -EBUSY;</span>
 				list_move_tail(&amp;slave-&gt;open_list,
 					       &amp;master-&gt;slave_list_head);
<span class="p_add">+				master-&gt;timer-&gt;num_instances++;</span>
 				spin_lock_irq(&amp;slave_active_lock);
 				slave-&gt;master = master;
 				slave-&gt;timer = master-&gt;timer;
 				spin_unlock_irq(&amp;slave_active_lock);
<span class="p_del">-				return;</span>
<span class="p_add">+				return 0;</span>
 			}
 		}
 	}
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -209,7 +214,7 @@</span> <span class="p_context"> static void snd_timer_check_slave(struct snd_timer_instance *slave)</span>
  *
  * call this with register_mutex down.
  */
<span class="p_del">-static void snd_timer_check_master(struct snd_timer_instance *master)</span>
<span class="p_add">+static int snd_timer_check_master(struct snd_timer_instance *master)</span>
 {
 	struct snd_timer_instance *slave, *tmp;
 
<span class="p_chunk">@@ -217,7 +222,11 @@</span> <span class="p_context"> static void snd_timer_check_master(struct snd_timer_instance *master)</span>
 	list_for_each_entry_safe(slave, tmp, &amp;snd_timer_slave_list, open_list) {
 		if (slave-&gt;slave_class == master-&gt;slave_class &amp;&amp;
 		    slave-&gt;slave_id == master-&gt;slave_id) {
<span class="p_add">+			if (master-&gt;timer-&gt;num_instances &gt;=</span>
<span class="p_add">+			    master-&gt;timer-&gt;max_instances)</span>
<span class="p_add">+				return -EBUSY;</span>
 			list_move_tail(&amp;slave-&gt;open_list, &amp;master-&gt;slave_list_head);
<span class="p_add">+			master-&gt;timer-&gt;num_instances++;</span>
 			spin_lock_irq(&amp;slave_active_lock);
 			spin_lock(&amp;master-&gt;timer-&gt;lock);
 			slave-&gt;master = master;
<span class="p_chunk">@@ -229,8 +238,11 @@</span> <span class="p_context"> static void snd_timer_check_master(struct snd_timer_instance *master)</span>
 			spin_unlock_irq(&amp;slave_active_lock);
 		}
 	}
<span class="p_add">+	return 0;</span>
 }
 
<span class="p_add">+static int snd_timer_close_locked(struct snd_timer_instance *timeri);</span>
<span class="p_add">+</span>
 /*
  * open a timer instance
  * when opening a master, the slave id must be here given.
<span class="p_chunk">@@ -241,6 +253,7 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *timeri = NULL;
<span class="p_add">+	int err;</span>
 
 	if (tid-&gt;dev_class == SNDRV_TIMER_CLASS_SLAVE) {
 		/* open a slave instance */
<span class="p_chunk">@@ -260,10 +273,14 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 		timeri-&gt;slave_id = tid-&gt;device;
 		timeri-&gt;flags |= SNDRV_TIMER_IFLG_SLAVE;
 		list_add_tail(&amp;timeri-&gt;open_list, &amp;snd_timer_slave_list);
<span class="p_del">-		snd_timer_check_slave(timeri);</span>
<span class="p_add">+		err = snd_timer_check_slave(timeri);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			snd_timer_close_locked(timeri);</span>
<span class="p_add">+			timeri = NULL;</span>
<span class="p_add">+		}</span>
 		mutex_unlock(&amp;register_mutex);
 		*ti = timeri;
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return err;</span>
 	}
 
 	/* open a master instance */
<span class="p_chunk">@@ -289,6 +306,10 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 			return -EBUSY;
 		}
 	}
<span class="p_add">+	if (timer-&gt;num_instances &gt;= timer-&gt;max_instances) {</span>
<span class="p_add">+		mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	}</span>
 	timeri = snd_timer_instance_new(owner, timer);
 	if (!timeri) {
 		mutex_unlock(&amp;register_mutex);
<span class="p_chunk">@@ -315,44 +336,36 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 	}
 
 	list_add_tail(&amp;timeri-&gt;open_list, &amp;timer-&gt;open_list_head);
<span class="p_del">-	snd_timer_check_master(timeri);</span>
<span class="p_add">+	timer-&gt;num_instances++;</span>
<span class="p_add">+	err = snd_timer_check_master(timeri);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		snd_timer_close_locked(timeri);</span>
<span class="p_add">+		timeri = NULL;</span>
<span class="p_add">+	}</span>
 	mutex_unlock(&amp;register_mutex);
 	*ti = timeri;
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 static int _snd_timer_stop(struct snd_timer_instance *timeri, int event);
 
 /*
  * close a timer instance
<span class="p_add">+ * call this with register_mutex down.</span>
  */
<span class="p_del">-int snd_timer_close(struct snd_timer_instance *timeri)</span>
<span class="p_add">+static int snd_timer_close_locked(struct snd_timer_instance *timeri)</span>
 {
 	struct snd_timer *timer = NULL;
 	struct snd_timer_instance *slave, *tmp;
 
<span class="p_del">-	if (snd_BUG_ON(!timeri))</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	list_del(&amp;timeri-&gt;open_list);</span>
 
 	/* force to stop the timer */
 	snd_timer_stop(timeri);
 
<span class="p_del">-	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE) {</span>
<span class="p_del">-		/* wait, until the active callback is finished */</span>
<span class="p_del">-		spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-		while (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_CALLBACK) {</span>
<span class="p_del">-			spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-			udelay(10);</span>
<span class="p_del">-			spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-		mutex_lock(&amp;register_mutex);</span>
<span class="p_del">-		list_del(&amp;timeri-&gt;open_list);</span>
<span class="p_del">-		mutex_unlock(&amp;register_mutex);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		timer = timeri-&gt;timer;</span>
<span class="p_del">-		if (snd_BUG_ON(!timer))</span>
<span class="p_del">-			goto out;</span>
<span class="p_add">+	timer = timeri-&gt;timer;</span>
<span class="p_add">+	if (timer) {</span>
<span class="p_add">+		timer-&gt;num_instances--;</span>
 		/* wait, until the active callback is finished */
 		spin_lock_irq(&amp;timer-&gt;lock);
 		while (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_CALLBACK) {
<span class="p_chunk">@@ -361,17 +374,14 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 			spin_lock_irq(&amp;timer-&gt;lock);
 		}
 		spin_unlock_irq(&amp;timer-&gt;lock);
<span class="p_del">-		mutex_lock(&amp;register_mutex);</span>
<span class="p_del">-		list_del(&amp;timeri-&gt;open_list);</span>
<span class="p_del">-		if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp;</span>
<span class="p_del">-		    timer-&gt;hw.close)</span>
<span class="p_del">-			timer-&gt;hw.close(timer);</span>
<span class="p_add">+</span>
 		/* remove slave links */
 		spin_lock_irq(&amp;slave_active_lock);
 		spin_lock(&amp;timer-&gt;lock);
 		list_for_each_entry_safe(slave, tmp, &amp;timeri-&gt;slave_list_head,
 					 open_list) {
 			list_move_tail(&amp;slave-&gt;open_list, &amp;snd_timer_slave_list);
<span class="p_add">+			timer-&gt;num_instances--;</span>
 			slave-&gt;master = NULL;
 			slave-&gt;timer = NULL;
 			list_del_init(&amp;slave-&gt;ack_list);
<span class="p_chunk">@@ -379,21 +389,45 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 		}
 		spin_unlock(&amp;timer-&gt;lock);
 		spin_unlock_irq(&amp;slave_active_lock);
<span class="p_del">-		/* release a card refcount for safe disconnection */</span>
<span class="p_del">-		if (timer-&gt;card)</span>
<span class="p_del">-			put_device(&amp;timer-&gt;card-&gt;card_dev);</span>
<span class="p_del">-		mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* slave doesn&#39;t need to release timer resources below */</span>
<span class="p_add">+		if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE)</span>
<span class="p_add">+			timer = NULL;</span>
 	}
<span class="p_del">- out:</span>
<span class="p_add">+</span>
 	if (timeri-&gt;private_free)
 		timeri-&gt;private_free(timeri);
 	kfree(timeri-&gt;owner);
 	kfree(timeri);
<span class="p_del">-	if (timer)</span>
<span class="p_add">+</span>
<span class="p_add">+	if (timer) {</span>
<span class="p_add">+		if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp; timer-&gt;hw.close)</span>
<span class="p_add">+			timer-&gt;hw.close(timer);</span>
<span class="p_add">+		/* release a card refcount for safe disconnection */</span>
<span class="p_add">+		if (timer-&gt;card)</span>
<span class="p_add">+			put_device(&amp;timer-&gt;card-&gt;card_dev);</span>
 		module_put(timer-&gt;module);
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * close a timer instance</span>
<span class="p_add">+ */</span>
<span class="p_add">+int snd_timer_close(struct snd_timer_instance *timeri)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (snd_BUG_ON(!timeri))</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;register_mutex);</span>
<span class="p_add">+	err = snd_timer_close_locked(timeri);</span>
<span class="p_add">+	mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 {
 	struct snd_timer * timer;
<span class="p_chunk">@@ -872,6 +906,7 @@</span> <span class="p_context"> int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,</span>
 	spin_lock_init(&amp;timer-&gt;lock);
 	tasklet_init(&amp;timer-&gt;task_queue, snd_timer_tasklet,
 		     (unsigned long)timer);
<span class="p_add">+	timer-&gt;max_instances = 1000; /* default limit per timer */</span>
 	if (card != NULL) {
 		timer-&gt;module = card-&gt;module;
 		err = snd_device_new(card, SNDRV_DEV_TIMER, timer, &amp;ops);
<span class="p_header">diff --git a/sound/core/timer_compat.c b/sound/core/timer_compat.c</span>
<span class="p_header">index 2e908225d754..0b4b028e8e98 100644</span>
<span class="p_header">--- a/sound/core/timer_compat.c</span>
<span class="p_header">+++ b/sound/core/timer_compat.c</span>
<span class="p_chunk">@@ -106,7 +106,8 @@</span> <span class="p_context"> enum {</span>
 #endif /* CONFIG_X86_X32 */
 };
 
<span class="p_del">-static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)</span>
<span class="p_add">+static long __snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd,</span>
<span class="p_add">+					  unsigned long arg)</span>
 {
 	void __user *argp = compat_ptr(arg);
 
<span class="p_chunk">@@ -127,7 +128,7 @@</span> <span class="p_context"> static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd, uns</span>
 	case SNDRV_TIMER_IOCTL_PAUSE:
 	case SNDRV_TIMER_IOCTL_PAUSE_OLD:
 	case SNDRV_TIMER_IOCTL_NEXT_DEVICE:
<span class="p_del">-		return snd_timer_user_ioctl(file, cmd, (unsigned long)argp);</span>
<span class="p_add">+		return __snd_timer_user_ioctl(file, cmd, (unsigned long)argp);</span>
 	case SNDRV_TIMER_IOCTL_INFO32:
 		return snd_timer_user_info_compat(file, argp);
 	case SNDRV_TIMER_IOCTL_STATUS32:
<span class="p_chunk">@@ -139,3 +140,15 @@</span> <span class="p_context"> static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd, uns</span>
 	}
 	return -ENOIOCTLCMD;
 }
<span class="p_add">+</span>
<span class="p_add">+static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd,</span>
<span class="p_add">+					unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_timer_user *tu = file-&gt;private_data;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	ret = __snd_timer_user_ioctl_compat(file, cmd, arg);</span>
<span class="p_add">+	mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c</span>
<span class="p_header">index 22b7038cff0d..fc1f09a8e5d3 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.c</span>
<span class="p_chunk">@@ -2791,7 +2791,7 @@</span> <span class="p_context"> static int get_kctl_0dB_offset(struct snd_kcontrol *kctl, int *step_to_check)</span>
 			return -1;
 		if (*step_to_check &amp;&amp; *step_to_check != step) {
 			snd_printk(KERN_ERR &quot;hda_codec: Mismatching dB step for vmaster slave (%d!=%d)\n&quot;,
<span class="p_del">--				   *step_to_check, step);</span>
<span class="p_add">+				   *step_to_check, step);</span>
 			return -1;
 		}
 		*step_to_check = step;
<span class="p_header">diff --git a/sound/soc/codecs/adau17x1.c b/sound/soc/codecs/adau17x1.c</span>
<span class="p_header">index 2961fae9670a..eb8e4065c4c5 100644</span>
<span class="p_header">--- a/sound/soc/codecs/adau17x1.c</span>
<span class="p_header">+++ b/sound/soc/codecs/adau17x1.c</span>
<span class="p_chunk">@@ -88,6 +88,27 @@</span> <span class="p_context"> static int adau17x1_pll_event(struct snd_soc_dapm_widget *w,</span>
 	return 0;
 }
 
<span class="p_add">+static int adau17x1_adc_fixup(struct snd_soc_dapm_widget *w,</span>
<span class="p_add">+	struct snd_kcontrol *kcontrol, int event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w-&gt;dapm);</span>
<span class="p_add">+	struct adau *adau = snd_soc_codec_get_drvdata(codec);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we are capturing, toggle the ADOSR bit in Converter Control 0 to</span>
<span class="p_add">+	 * avoid losing SNR (workaround from ADI). This must be done after</span>
<span class="p_add">+	 * the ADC(s) have been enabled. According to the data sheet, it is</span>
<span class="p_add">+	 * normally illegal to set this bit when the sampling rate is 96 kHz,</span>
<span class="p_add">+	 * but according to ADI it is acceptable for this workaround.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regmap_update_bits(adau-&gt;regmap, ADAU17X1_CONVERTER0,</span>
<span class="p_add">+		ADAU17X1_CONVERTER0_ADOSR, ADAU17X1_CONVERTER0_ADOSR);</span>
<span class="p_add">+	regmap_update_bits(adau-&gt;regmap, ADAU17X1_CONVERTER0,</span>
<span class="p_add">+		ADAU17X1_CONVERTER0_ADOSR, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const char * const adau17x1_mono_stereo_text[] = {
 	&quot;Stereo&quot;,
 	&quot;Mono Left Channel (L+R)&quot;,
<span class="p_chunk">@@ -119,7 +140,8 @@</span> <span class="p_context"> static const struct snd_soc_dapm_widget adau17x1_dapm_widgets[] = {</span>
 	SND_SOC_DAPM_MUX(&quot;Right DAC Mode Mux&quot;, SND_SOC_NOPM, 0, 0,
 		&amp;adau17x1_dac_mode_mux),
 
<span class="p_del">-	SND_SOC_DAPM_ADC(&quot;Left Decimator&quot;, NULL, ADAU17X1_ADC_CONTROL, 0, 0),</span>
<span class="p_add">+	SND_SOC_DAPM_ADC_E(&quot;Left Decimator&quot;, NULL, ADAU17X1_ADC_CONTROL, 0, 0,</span>
<span class="p_add">+			   adau17x1_adc_fixup, SND_SOC_DAPM_POST_PMU),</span>
 	SND_SOC_DAPM_ADC(&quot;Right Decimator&quot;, NULL, ADAU17X1_ADC_CONTROL, 1, 0),
 	SND_SOC_DAPM_DAC(&quot;Left DAC&quot;, NULL, ADAU17X1_DAC_CONTROL0, 0, 0),
 	SND_SOC_DAPM_DAC(&quot;Right DAC&quot;, NULL, ADAU17X1_DAC_CONTROL0, 1, 0),
<span class="p_header">diff --git a/sound/soc/codecs/adau17x1.h b/sound/soc/codecs/adau17x1.h</span>
<span class="p_header">index 3ffabaf4c7a8..664db5dd8c20 100644</span>
<span class="p_header">--- a/sound/soc/codecs/adau17x1.h</span>
<span class="p_header">+++ b/sound/soc/codecs/adau17x1.h</span>
<span class="p_chunk">@@ -120,5 +120,7 @@</span> <span class="p_context"> bool adau17x1_has_dsp(struct adau *adau);</span>
 
 #define ADAU17X1_CONVERTER0_CONVSR_MASK		0x7
 
<span class="p_add">+#define ADAU17X1_CONVERTER0_ADOSR		BIT(3)</span>
<span class="p_add">+</span>
 
 #endif
<span class="p_header">diff --git a/sound/usb/caiaq/device.c b/sound/usb/caiaq/device.c</span>
<span class="p_header">index b871ba407e4e..4458190149d1 100644</span>
<span class="p_header">--- a/sound/usb/caiaq/device.c</span>
<span class="p_header">+++ b/sound/usb/caiaq/device.c</span>
<span class="p_chunk">@@ -469,10 +469,12 @@</span> <span class="p_context"> static int init_card(struct snd_usb_caiaqdev *cdev)</span>
 
 	err = snd_usb_caiaq_send_command(cdev, EP1_CMD_GET_DEVICE_INFO, NULL, 0);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto err_kill_urb;</span>
 
<span class="p_del">-	if (!wait_event_timeout(cdev-&gt;ep1_wait_queue, cdev-&gt;spec_received, HZ))</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	if (!wait_event_timeout(cdev-&gt;ep1_wait_queue, cdev-&gt;spec_received, HZ)) {</span>
<span class="p_add">+		err = -ENODEV;</span>
<span class="p_add">+		goto err_kill_urb;</span>
<span class="p_add">+	}</span>
 
 	usb_string(usb_dev, usb_dev-&gt;descriptor.iManufacturer,
 		   cdev-&gt;vendor_name, CAIAQ_USB_STR_LEN);
<span class="p_chunk">@@ -507,6 +509,10 @@</span> <span class="p_context"> static int init_card(struct snd_usb_caiaqdev *cdev)</span>
 
 	setup_card(cdev);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+ err_kill_urb:</span>
<span class="p_add">+	usb_kill_urb(&amp;cdev-&gt;ep1_in_urb);</span>
<span class="p_add">+	return err;</span>
 }
 
 static int snd_probe(struct usb_interface *intf,
<span class="p_header">diff --git a/sound/usb/usx2y/usb_stream.c b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">index bf618e1500ac..e7b934f4d837 100644</span>
<span class="p_header">--- a/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">+++ b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_chunk">@@ -191,7 +191,8 @@</span> <span class="p_context"> struct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,</span>
 	}
 
 	pg = get_order(read_size);
<span class="p_del">-	sk-&gt;s = (void *) __get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
<span class="p_add">+	sk-&gt;s = (void *) __get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO|</span>
<span class="p_add">+					  __GFP_NOWARN, pg);</span>
 	if (!sk-&gt;s) {
 		snd_printk(KERN_WARNING &quot;couldn&#39;t __get_free_pages()\n&quot;);
 		goto out;
<span class="p_chunk">@@ -211,7 +212,8 @@</span> <span class="p_context"> struct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,</span>
 	pg = get_order(write_size);
 
 	sk-&gt;write_page =
<span class="p_del">-		(void *)__get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
<span class="p_add">+		(void *)__get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO|</span>
<span class="p_add">+					 __GFP_NOWARN, pg);</span>
 	if (!sk-&gt;write_page) {
 		snd_printk(KERN_WARNING &quot;couldn&#39;t __get_free_pages()\n&quot;);
 		usb_stream_free(sk);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



