
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>arch/x86: convert all printk(KERN_INFO ) to pr_info() - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    arch/x86: convert all printk(KERN_INFO ) to pr_info()</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=96691">Chen Yucong</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 22, 2016, 8:21 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1456129300-27006-1-git-send-email-slaoub@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8373191/mbox/"
   >mbox</a>
|
   <a href="/patch/8373191/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8373191/">/patch/8373191/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 11DEBC0553
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 22 Feb 2016 08:22:25 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id DF00E203AA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 22 Feb 2016 08:22:19 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 65A6A2039E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 22 Feb 2016 08:22:14 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753593AbcBVIV7 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 22 Feb 2016 03:21:59 -0500
Received: from mail-ig0-f193.google.com ([209.85.213.193]:32975 &quot;EHLO
	mail-ig0-f193.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750897AbcBVIVz (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 22 Feb 2016 03:21:55 -0500
Received: by mail-ig0-f193.google.com with SMTP id hb3so6470163igb.0
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 22 Feb 2016 00:21:55 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=from:to:cc:subject:date:message-id;
	bh=K/3LVA5KD42T+2rKA9YbZpa7pooSQd1f1Et3jIXehE0=;
	b=0m3CelYOR2eU+FUevx8CZkmzKbApgyCxxGUqhwyQ043u1xEVMuVIpfZetn0ud6Ygx/
	pIyr0CIZw4Bh1pZKQLgQ9UVnmJVEjlA+c5zdu7PmhqBLnP9t5ALHWMQS+sGUnlfov20L
	ah0EWiFulLTvQPVdmViLPMqhF7/eeD1NNe20PAsCpTfs6fb6X/U13+yfU15/v97IGzHy
	D6rc59NmMX+IqP11K0ti6i5lU2yVWmLin7V96S6TA3monNBPLb+eEOp6zPNYMW3zxmwm
	ddtLXwCNumvzK6MYiL9rYkt6QsVjoS98dRTf00Ut3Z5CoXo1eAVBbEsjYBRvZOgjj6Og
	z43A==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:from:to:cc:subject:date:message-id;
	bh=K/3LVA5KD42T+2rKA9YbZpa7pooSQd1f1Et3jIXehE0=;
	b=XL9KpB1sRF7ikP5UikTtLgdTQcbctSocDiehw5R0j4kLUBkdAUA/FL/RfsZaooRJRx
	gZRhUlJOZGN25OEd6CyK5C+qTcTPhqA6EtqDufJwUs/2Lh0qEiODPfDjQn2OEuNNh/kh
	SDlGy8XIUarZY9yJuiwhOV+Q47B0esjHxhYYsWA2WavUMoCxbOlucsj17Y3K2zHC78bt
	J7F5gs8fJlYuLlHrz6WLq6aScK6UPZNvXyCkcpoieKoU7xhD+r0MY8aF6Gx4RIe/7VFF
	fzBFsQITmeysJHV26IVmCTVTzpMOYv8fPdLd1aWJvFpp12M8cdjjFIdGZMIltaHXcXRI
	8Zcw==
X-Gm-Message-State: AG10YOQWSmCh8IcaF3iaVs17pIg76eiBLL+b9+HtRaxssPWXq0eys3yZht/sYkPTJkbwsw==
X-Received: by 10.50.57.106 with SMTP id h10mr9825312igq.28.1456129314859;
	Mon, 22 Feb 2016 00:21:54 -0800 (PST)
Received: from localhost.localdomain ([210.77.76.71])
	by smtp.googlemail.com with ESMTPSA id
	l94sm11088063iod.13.2016.02.22.00.21.51
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 22 Feb 2016 00:21:54 -0800 (PST)
From: Chen Yucong &lt;slaoub@gmail.com&gt;
To: mingo@kernel.org
Cc: tglx@linutronix.de, hpa@zytor.com, x86@kernel.org,
	linux-kernel@vger.kernel.org
Subject: [PATCH] arch/x86: convert all printk(KERN_INFO ) to pr_info()
Date: Mon, 22 Feb 2016 16:21:40 +0800
Message-Id: &lt;1456129300-27006-1-git-send-email-slaoub@gmail.com&gt;
X-Mailer: git-send-email 1.8.3.1
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.0 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, FREEMAIL_FROM, RCVD_IN_DNSWL_HI,
	RP_MATCHES_RCVD, 
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96691">Chen Yucong</a> - Feb. 22, 2016, 8:21 a.m.</div>
<pre class="content">
arch/x86/* use a mixture of printk(KERN_INFO ) and pr_info().
This patch converts all of printk(KERN_INFO ) to pr_info() for
arch/x86 directory.
<span class="signed-off-by">
Signed-off-by: Chen Yucong &lt;slaoub@gmail.com&gt;</span>
---
 arch/x86/crypto/blowfish_glue.c      |  5 +---
 arch/x86/crypto/camellia_glue.c      |  5 +---
 arch/x86/crypto/serpent_sse2_glue.c  |  2 +-
 arch/x86/crypto/twofish_glue_3way.c  |  5 +---
 arch/x86/include/asm/gart.h          |  8 ++---
 arch/x86/kernel/acpi/boot.c          | 22 +++++++-------
 arch/x86/kernel/acpi/sleep.c         |  2 +-
 arch/x86/kernel/apb_timer.c          | 11 ++++---
 arch/x86/kernel/apic/apic.c          | 12 ++++----
 arch/x86/kernel/apic/bigsmp_32.c     |  5 ++--
 arch/x86/kernel/apic/io_apic.c       | 34 ++++++++++-----------
 arch/x86/kernel/apic/probe_32.c      |  8 ++---
 arch/x86/kernel/apic/x2apic_uv_x.c   |  4 +--
 arch/x86/kernel/apm_32.c             | 57 ++++++++++++++++--------------------
 arch/x86/kernel/bootflag.c           |  2 +-
 arch/x86/kernel/check.c              |  7 +++--
 arch/x86/kernel/cpuid.c              |  4 +--
 arch/x86/kernel/e820.c               | 27 ++++++++---------
 arch/x86/kernel/early-quirks.c       | 38 +++++++++---------------
 arch/x86/kernel/fpu/init.c           |  3 +-
 arch/x86/kernel/fpu/xstate.c         |  3 +-
 arch/x86/kernel/hpet.c               | 23 +++++++--------
 arch/x86/kernel/i8259.c              |  2 +-
 arch/x86/kernel/kprobes/core.c       | 12 ++++----
 arch/x86/kernel/kvm.c                | 10 +++----
 arch/x86/kernel/kvmclock.c           | 10 +++----
 arch/x86/kernel/mmconf-fam10h_64.c   |  2 +-
 arch/x86/kernel/paravirt.c           |  3 +-
 arch/x86/kernel/pci-calgary_64.c     | 23 +++++++--------
 arch/x86/kernel/pci-swiotlb.c        |  3 +-
 arch/x86/kernel/quirks.c             |  3 +-
 arch/x86/kernel/setup.c              | 15 +++++-----
 arch/x86/kernel/smpboot.c            | 10 +++----
 arch/x86/kernel/sysfb_efi.c          |  7 ++---
 arch/x86/kernel/test_nx.c            |  2 +-
 arch/x86/kernel/vsmp_64.c            |  4 +--
 arch/x86/kvm/assigned-dev.c          | 21 +++++++------
 arch/x86/kvm/cpuid.c                 |  2 +-
 arch/x86/kvm/irq_comm.c              |  2 +-
 arch/x86/kvm/lapic.c                 |  6 ++--
 arch/x86/kvm/svm.c                   |  8 ++---
 arch/x86/kvm/vmx.c                   |  8 ++---
 arch/x86/kvm/x86.c                   |  4 +--
 arch/x86/lguest/boot.c               |  2 +-
 arch/x86/mm/highmem_32.c             |  4 +--
 arch/x86/mm/init.c                   |  2 +-
 arch/x86/mm/init_32.c                | 23 +++++++--------
 arch/x86/mm/init_64.c                |  8 ++---
 arch/x86/mm/kmemcheck/kmemcheck.c    |  7 ++---
 arch/x86/mm/numa.c                   | 14 ++++-----
 arch/x86/mm/numa_32.c                |  3 +-
 arch/x86/mm/numa_emulation.c         |  4 +--
 arch/x86/mm/pageattr-test.c          |  7 ++---
 arch/x86/mm/pgtable.c                |  4 +--
 arch/x86/mm/setup_nx.c               |  6 ++--
 arch/x86/mm/srat.c                   | 17 ++++++-----
 arch/x86/oprofile/nmi_int.c          | 10 +++----
 arch/x86/oprofile/op_model_amd.c     |  2 +-
 arch/x86/pci/acpi.c                  | 13 ++++----
 arch/x86/pci/amd_bus.c               |  4 +--
 arch/x86/pci/broadcom_bus.c          |  4 +--
 arch/x86/pci/common.c                | 14 ++++-----
 arch/x86/pci/direct.c                |  6 ++--
 arch/x86/pci/early.c                 |  3 +-
 arch/x86/pci/irq.c                   |  8 ++---
 arch/x86/pci/legacy.c                |  2 +-
 arch/x86/pci/mmconfig_32.c           |  2 +-
 arch/x86/pci/olpc.c                  |  2 +-
 arch/x86/pci/pcbios.c                |  6 ++--
 arch/x86/pci/xen.c                   |  4 +--
 arch/x86/platform/geode/alix.c       |  9 +++---
 arch/x86/platform/geode/geos.c       |  4 +--
 arch/x86/platform/geode/net5501.c    |  4 +--
 arch/x86/platform/iris/iris.c        |  4 +--
 arch/x86/platform/olpc/olpc-xo1-pm.c |  4 +--
 arch/x86/platform/olpc/olpc_ofw.c    |  2 +-
 arch/x86/platform/uv/bios_uv.c       |  2 +-
 arch/x86/platform/uv/tlb_uv.c        |  2 +-
 arch/x86/platform/uv/uv_time.c       |  8 ++---
 arch/x86/um/sysrq_64.c               | 30 +++++++++----------
 arch/x86/um/tls_32.c                 |  4 +--
 arch/x86/xen/enlighten.c             |  9 +++---
 arch/x86/xen/platform-pci-unplug.c   | 12 ++++----
 arch/x86/xen/setup.c                 |  2 +-
 arch/x86/xen/time.c                  |  5 ++--
 85 files changed, 332 insertions(+), 394 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Feb. 25, 2016, 8:22 a.m.</div>
<pre class="content">
* Chen Yucong &lt;slaoub@gmail.com&gt; wrote:
<span class="quote">
&gt; arch/x86/* use a mixture of printk(KERN_INFO ) and pr_info().</span>
<span class="quote">&gt; This patch converts all of printk(KERN_INFO ) to pr_info() for</span>
<span class="quote">&gt; arch/x86 directory.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Chen Yucong &lt;slaoub@gmail.com&gt;</span>
<span class="quote">
&gt;  85 files changed, 332 insertions(+), 394 deletions(-)</span>

So what this changelog is missing is how it was ensured that the printk output did 
not change.

Thanks,

	Ingo
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96691">Chen Yucong</a> - Feb. 25, 2016, 12:15 p.m.</div>
<pre class="content">
On Thu, 2016-02-25 at 09:22 +0100, Ingo Molnar wrote:
<span class="quote">&gt; * Chen Yucong &lt;slaoub@gmail.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; arch/x86/* use a mixture of printk(KERN_INFO ) and pr_info().</span>
<span class="quote">&gt; &gt; This patch converts all of printk(KERN_INFO ) to pr_info() for</span>
<span class="quote">&gt; &gt; arch/x86 directory.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Chen Yucong &lt;slaoub@gmail.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;  85 files changed, 332 insertions(+), 394 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So what this changelog is missing is how it was ensured that the printk output did </span>
<span class="quote">&gt; not change.</span>
<span class="quote">&gt; </span>
 The previously committed patch was applied to a particular directory.
This involved all printk(KERN_&lt;LEVEL&gt;), including `ugly` pr_debug().

However this patch are only related to printk(KERN_INFO ...), pr_info()
is less dangerous than pr_debug(). The macro body of pr_info() is
simple and definite, without any conditional options.

An theme to notice: this patch also refers to only a few pr_err(), and
if it is feasible, the next patch will covert all printk(KERN_ERR ) to
pr_err(). This might be a less risky way for conversion.

thx!
   cyc
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/crypto/blowfish_glue.c b/arch/x86/crypto/blowfish_glue.c</span>
<span class="p_header">index 17c0553..f8769cc 100644</span>
<span class="p_header">--- a/arch/x86/crypto/blowfish_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/blowfish_glue.c</span>
<span class="p_chunk">@@ -458,10 +458,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(force, &quot;Force module load, ignore CPU blacklist&quot;);</span>
 static int __init init(void)
 {
 	if (!force &amp;&amp; is_blacklisted_cpu()) {
<span class="p_del">-		printk(KERN_INFO</span>
<span class="p_del">-			&quot;blowfish-x86_64: performance on this CPU &quot;</span>
<span class="p_del">-			&quot;would be suboptimal: disabling &quot;</span>
<span class="p_del">-			&quot;blowfish-x86_64.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;blowfish-x86_64: performance on this CPU would be suboptimal: disabling blowfish-x86_64.\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_header">diff --git a/arch/x86/crypto/camellia_glue.c b/arch/x86/crypto/camellia_glue.c</span>
<span class="p_header">index aa76cad..aeeabf0 100644</span>
<span class="p_header">--- a/arch/x86/crypto/camellia_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/camellia_glue.c</span>
<span class="p_chunk">@@ -1701,10 +1701,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(force, &quot;Force module load, ignore CPU blacklist&quot;);</span>
 static int __init init(void)
 {
 	if (!force &amp;&amp; is_blacklisted_cpu()) {
<span class="p_del">-		printk(KERN_INFO</span>
<span class="p_del">-			&quot;camellia-x86_64: performance on this CPU &quot;</span>
<span class="p_del">-			&quot;would be suboptimal: disabling &quot;</span>
<span class="p_del">-			&quot;camellia-x86_64.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;camellia-x86_64: performance on this CPU would be suboptimal: disabling camellia-x86_64.\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_header">diff --git a/arch/x86/crypto/serpent_sse2_glue.c b/arch/x86/crypto/serpent_sse2_glue.c</span>
<span class="p_header">index 8943407..3f7a870 100644</span>
<span class="p_header">--- a/arch/x86/crypto/serpent_sse2_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/serpent_sse2_glue.c</span>
<span class="p_chunk">@@ -601,7 +601,7 @@</span> <span class="p_context"> static struct crypto_alg serpent_algs[10] = { {</span>
 static int __init serpent_sse2_init(void)
 {
 	if (!cpu_has_xmm2) {
<span class="p_del">-		printk(KERN_INFO &quot;SSE2 instructions are not detected.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;SSE2 instructions are not detected.\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_header">diff --git a/arch/x86/crypto/twofish_glue_3way.c b/arch/x86/crypto/twofish_glue_3way.c</span>
<span class="p_header">index 2ebb5e9..64dcbd3 100644</span>
<span class="p_header">--- a/arch/x86/crypto/twofish_glue_3way.c</span>
<span class="p_header">+++ b/arch/x86/crypto/twofish_glue_3way.c</span>
<span class="p_chunk">@@ -471,10 +471,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(force, &quot;Force module load, ignore CPU blacklist&quot;);</span>
 static int __init init(void)
 {
 	if (!force &amp;&amp; is_blacklisted_cpu()) {
<span class="p_del">-		printk(KERN_INFO</span>
<span class="p_del">-			&quot;twofish-x86_64-3way: performance on this CPU &quot;</span>
<span class="p_del">-			&quot;would be suboptimal: disabling &quot;</span>
<span class="p_del">-			&quot;twofish-x86_64-3way.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;twofish-x86_64-3way: performance on this CPU would be suboptimal: disabling twofish-x86_64-3way.\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_header">diff --git a/arch/x86/include/asm/gart.h b/arch/x86/include/asm/gart.h</span>
<span class="p_header">index 156cd5d..e1cc25b 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/gart.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/gart.h</span>
<span class="p_chunk">@@ -94,16 +94,16 @@</span> <span class="p_context"> static inline int aperture_valid(u64 aper_base, u32 aper_size, u32 min_size)</span>
 		return 0;
 
 	if (aper_base + aper_size &gt; 0x100000000ULL) {
<span class="p_del">-		printk(KERN_INFO &quot;Aperture beyond 4GB. Ignoring.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Aperture beyond 4GB. Ignoring.\n&quot;);</span>
 		return 0;
 	}
 	if (e820_any_mapped(aper_base, aper_base + aper_size, E820_RAM)) {
<span class="p_del">-		printk(KERN_INFO &quot;Aperture pointing to e820 RAM. Ignoring.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Aperture pointing to e820 RAM. Ignoring.\n&quot;);</span>
 		return 0;
 	}
 	if (aper_size &lt; min_size) {
<span class="p_del">-		printk(KERN_INFO &quot;Aperture too small (%d MB) than (%d MB)\n&quot;,</span>
<span class="p_del">-				 aper_size&gt;&gt;20, min_size&gt;&gt;20);</span>
<span class="p_add">+		pr_info(&quot;Aperture too small (%d MB) than (%d MB)\n&quot;,</span>
<span class="p_add">+			aper_size&gt;&gt;20, min_size&gt;&gt;20);</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">index e759076..b8bf5cf 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_chunk">@@ -57,6 +57,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(acpi_disabled);</span>
 
 #define PREFIX			&quot;ACPI: &quot;
 
<span class="p_add">+#undef pr_fmt</span>
<span class="p_add">+#define pr_fmt(fmt) &quot;ACPI: &quot; fmt</span>
<span class="p_add">+</span>
 int acpi_noirq;				/* skip ACPI IRQ initialization */
 int acpi_pci_disabled;		/* skip ACPI PCI scan and IRQ initialization */
 EXPORT_SYMBOL(acpi_pci_disabled);
<span class="p_chunk">@@ -170,7 +173,7 @@</span> <span class="p_context"> static int acpi_register_lapic(int id, u8 enabled)</span>
 	unsigned int ver = 0;
 
 	if (id &gt;= MAX_LOCAL_APIC) {
<span class="p_del">-		printk(KERN_INFO PREFIX &quot;skipped apicid that is too big\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;skipped apicid that is too big\n&quot;);</span>
 		return -EINVAL;
 	}
 
<span class="p_chunk">@@ -717,7 +720,7 @@</span> <span class="p_context"> int acpi_map_cpu(acpi_handle handle, phys_cpuid_t physid, int *pcpu)</span>
 
 	cpu = acpi_register_lapic(physid, ACPI_MADT_ENABLED);
 	if (cpu &lt; 0) {
<span class="p_del">-		pr_info(PREFIX &quot;Unable to map lapic to logical cpu number\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Unable to map lapic to logical cpu number\n&quot;);</span>
 		return cpu;
 	}
 
<span class="p_chunk">@@ -872,8 +875,7 @@</span> <span class="p_context"> static int __init acpi_parse_hpet(struct acpi_table_header *table)</span>
 		hpet_address &gt;&gt;= 32;
 	}
 #endif
<span class="p_del">-	printk(KERN_INFO PREFIX &quot;HPET id: %#x base: %#lx\n&quot;,</span>
<span class="p_del">-	       hpet_tbl-&gt;id, hpet_address);</span>
<span class="p_add">+	pr_info(&quot;HPET id: %#x base: %#lx\n&quot;, hpet_tbl-&gt;id, hpet_address);</span>
 
 	/*
 	 * Allocate and initialize the HPET firmware resource for adding into
<span class="p_chunk">@@ -935,8 +937,7 @@</span> <span class="p_context"> static int __init acpi_parse_fadt(struct acpi_table_header *table)</span>
 		pmtmr_ioport = acpi_gbl_FADT.pm_timer_block;
 	}
 	if (pmtmr_ioport)
<span class="p_del">-		printk(KERN_INFO PREFIX &quot;PM-Timer IO Port: %#x\n&quot;,</span>
<span class="p_del">-		       pmtmr_ioport);</span>
<span class="p_add">+		pr_info(&quot;PM-Timer IO Port: %#x\n&quot;, pmtmr_ioport);</span>
 #endif
 	return 0;
 }
<span class="p_chunk">@@ -1132,8 +1133,7 @@</span> <span class="p_context"> static int __init acpi_parse_madt_ioapic_entries(void)</span>
 	 * if &quot;noapic&quot; boot option, don&#39;t look for IO-APICs
 	 */
 	if (skip_ioapic_setup) {
<span class="p_del">-		printk(KERN_INFO PREFIX &quot;Skipping IOAPIC probe &quot;</span>
<span class="p_del">-		       &quot;due to &#39;noapic&#39; option.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Skipping IOAPIC probe due to &#39;noapic&#39; option.\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_chunk">@@ -1263,11 +1263,9 @@</span> <span class="p_context"> static void __init acpi_process_madt(void)</span>
 	 * processors, where MPS only supports physical.
 	 */
 	if (acpi_lapic &amp;&amp; acpi_ioapic)
<span class="p_del">-		printk(KERN_INFO &quot;Using ACPI (MADT) for SMP configuration &quot;</span>
<span class="p_del">-		       &quot;information\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Using ACPI (MADT) for SMP configuration information\n&quot;);</span>
 	else if (acpi_lapic)
<span class="p_del">-		printk(KERN_INFO &quot;Using ACPI for processor (LAPIC) &quot;</span>
<span class="p_del">-		       &quot;configuration information\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Using ACPI for processor (LAPIC) configuration information\n&quot;);</span>
 #endif
 	return;
 }
<span class="p_header">diff --git a/arch/x86/kernel/acpi/sleep.c b/arch/x86/kernel/acpi/sleep.c</span>
<span class="p_header">index d1daead..a850963 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/sleep.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/sleep.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> int x86_acpi_suspend_lowlevel(void)</span>
 		(struct wakeup_header *) __va(real_mode_header-&gt;wakeup_header);
 
 	if (header-&gt;signature != WAKEUP_HEADER_SIGNATURE) {
<span class="p_del">-		printk(KERN_ERR &quot;wakeup header does not match\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;wakeup header does not match\n&quot;);</span>
 		return -EINVAL;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/apb_timer.c b/arch/x86/kernel/apb_timer.c</span>
<span class="p_header">index 222a570..391229b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apb_timer.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apb_timer.c</span>
<span class="p_chunk">@@ -196,8 +196,8 @@</span> <span class="p_context"> void apbt_setup_secondary_clock(void)</span>
 		dw_apb_clockevent_resume(adev-&gt;timer);
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;Registering CPU %d clockevent device %s, cpu %08x\n&quot;,</span>
<span class="p_del">-	       cpu, adev-&gt;name, adev-&gt;cpu);</span>
<span class="p_add">+	pr_info(&quot;Registering CPU %d clockevent device %s, cpu %08x\n&quot;,</span>
<span class="p_add">+		cpu, adev-&gt;name, adev-&gt;cpu);</span>
 
 	apbt_setup_irq(adev);
 	dw_apb_clockevent_register(adev-&gt;timer);
<span class="p_chunk">@@ -327,7 +327,7 @@</span> <span class="p_context"> void __init apbt_time_init(void)</span>
 #ifdef CONFIG_SMP
 	/* kernel cmdline disable apb timer, so we will use lapic timers */
 	if (intel_mid_timer_options == INTEL_MID_TIMER_LAPIC_APBT) {
<span class="p_del">-		printk(KERN_INFO &quot;apbt: disabled per cpu timer\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;apbt: disabled per cpu timer\n&quot;);</span>
 		return;
 	}
 	pr_debug(&quot;%s: %d CPUs online\n&quot;, __func__, num_online_cpus());
<span class="p_chunk">@@ -400,13 +400,12 @@</span> <span class="p_context"> unsigned long apbt_quick_calibrate(void)</span>
 
 	shift = 5;
 	if (unlikely(loop &gt;&gt; shift == 0)) {
<span class="p_del">-		printk(KERN_INFO</span>
<span class="p_del">-		       &quot;APBT TSC calibration failed, not enough resolution\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;APBT TSC calibration failed, not enough resolution\n&quot;);</span>
 		return 0;
 	}
 	scale = (int)div_u64((t2 - t1), loop &gt;&gt; shift);
 	khz = (scale * (apbt_freq / 1000)) &gt;&gt; shift;
<span class="p_del">-	printk(KERN_INFO &quot;TSC freq calculated by APB timer is %lu khz\n&quot;, khz);</span>
<span class="p_add">+	pr_info(&quot;TSC freq calculated by APB timer is %lu khz\n&quot;, khz);</span>
 	return khz;
 failed:
 	return 0;
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">index 8a5cdda..ae42959 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic.c</span>
<span class="p_chunk">@@ -1306,8 +1306,8 @@</span> <span class="p_context"> void setup_local_APIC(void)</span>
 			}
 		}
 		if (acked &gt; 256) {
<span class="p_del">-			printk(KERN_ERR &quot;LAPIC pending interrupts after %d EOI\n&quot;,</span>
<span class="p_del">-			       acked);</span>
<span class="p_add">+			pr_err(&quot;LAPIC pending interrupts after %d EOI\n&quot;,</span>
<span class="p_add">+				acked);</span>
 			break;
 		}
 		if (queued) {
<span class="p_chunk">@@ -1454,7 +1454,7 @@</span> <span class="p_context"> static void __x2apic_disable(void)</span>
 	/* Disable xapic and x2apic first and then reenable xapic mode */
 	wrmsrl(MSR_IA32_APICBASE, msr &amp; ~(X2APIC_ENABLE | XAPIC_ENABLE));
 	wrmsrl(MSR_IA32_APICBASE, msr &amp; ~X2APIC_ENABLE);
<span class="p_del">-	printk_once(KERN_INFO &quot;x2apic disabled\n&quot;);</span>
<span class="p_add">+	pr_info_once(&quot;x2apic disabled\n&quot;);</span>
 }
 
 static void __x2apic_enable(void)
<span class="p_chunk">@@ -1465,7 +1465,7 @@</span> <span class="p_context"> static void __x2apic_enable(void)</span>
 	if (msr &amp; X2APIC_ENABLE)
 		return;
 	wrmsrl(MSR_IA32_APICBASE, msr | X2APIC_ENABLE);
<span class="p_del">-	printk_once(KERN_INFO &quot;x2apic enabled\n&quot;);</span>
<span class="p_add">+	pr_info_once(&quot;x2apic enabled\n&quot;);</span>
 }
 
 static int __init setup_nox2apic(char *str)
<span class="p_chunk">@@ -1474,8 +1474,8 @@</span> <span class="p_context"> static int __init setup_nox2apic(char *str)</span>
 		int apicid = native_apic_msr_read(APIC_ID);
 
 		if (apicid &gt;= 255) {
<span class="p_del">-			pr_warning(&quot;Apicid: %08x, cannot enforce nox2apic\n&quot;,</span>
<span class="p_del">-				   apicid);</span>
<span class="p_add">+			pr_warn(&quot;Apicid: %08x, cannot enforce nox2apic\n&quot;,</span>
<span class="p_add">+				apicid);</span>
 			return 0;
 		}
 		pr_warning(&quot;x2apic already enabled.\n&quot;);
<span class="p_header">diff --git a/arch/x86/kernel/apic/bigsmp_32.c b/arch/x86/kernel/apic/bigsmp_32.c</span>
<span class="p_header">index cf9bd89..52f0fb5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/bigsmp_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/bigsmp_32.c</span>
<span class="p_chunk">@@ -67,8 +67,7 @@</span> <span class="p_context"> static void bigsmp_init_apic_ldr(void)</span>
 
 static void bigsmp_setup_apic_routing(void)
 {
<span class="p_del">-	printk(KERN_INFO</span>
<span class="p_del">-		&quot;Enabling APIC mode:  Physflat.  Using %d I/O APICs\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Enabling APIC mode:  Physflat.  Using %d I/O APICs\n&quot;,</span>
 		nr_ioapics);
 }
 
<span class="p_chunk">@@ -110,7 +109,7 @@</span> <span class="p_context"> static int dmi_bigsmp; /* can be set by dmi scanners */</span>
 
 static int hp_ht_bigsmp(const struct dmi_system_id *d)
 {
<span class="p_del">-	printk(KERN_NOTICE &quot;%s detected: force use of apic=bigsmp\n&quot;, d-&gt;ident);</span>
<span class="p_add">+	pr_notice(&quot;%s detected: force use of apic=bigsmp\n&quot;, d-&gt;ident);</span>
 	dmi_bigsmp = 1;
 
 	return 0;
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index fdb0fbf..3f42c31 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -1347,7 +1347,7 @@</span> <span class="p_context"> void __init print_IO_APICs(void)</span>
 	 * We are a bit conservative about what we expect.  We have to
 	 * know about every hardware change ASAP.
 	 */
<span class="p_del">-	printk(KERN_INFO &quot;testing the IO APIC.......................\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;testing the IO APIC.......................\n&quot;);</span>
 
 	for_each_ioapic(ioapic_idx)
 		print_IO_APIC(ioapic_idx);
<span class="p_chunk">@@ -1373,7 +1373,7 @@</span> <span class="p_context"> void __init print_IO_APICs(void)</span>
 		pr_cont(&quot;\n&quot;);
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;.................................... done.\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;.................................... done.\n&quot;);</span>
 }
 
 /* Where if anywhere is the i8259 connect in external int mode */
<span class="p_chunk">@@ -1413,7 +1413,7 @@</span> <span class="p_context"> void __init enable_IO_APIC(void)</span>
 	i8259_apic = find_isa_irq_apic(0, mp_ExtINT);
 	/* Trust the MP table if nothing is setup in the hardware */
 	if ((ioapic_i8259.pin == -1) &amp;&amp; (i8259_pin &gt;= 0)) {
<span class="p_del">-		printk(KERN_WARNING &quot;ExtINT not setup in hardware but reported by MP table\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;ExtINT not setup in hardware but reported by MP table\n&quot;);</span>
 		ioapic_i8259.pin  = i8259_pin;
 		ioapic_i8259.apic = i8259_apic;
 	}
<span class="p_chunk">@@ -1421,7 +1421,7 @@</span> <span class="p_context"> void __init enable_IO_APIC(void)</span>
 	if (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) &amp;&amp;
 		(i8259_pin &gt;= 0) &amp;&amp; (ioapic_i8259.pin &gt;= 0))
 	{
<span class="p_del">-		printk(KERN_WARNING &quot;ExtINT in hardware and MP table differ\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;ExtINT in hardware and MP table differ\n&quot;);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -1508,9 +1508,9 @@</span> <span class="p_context"> void __init setup_ioapic_ids_from_mpc_nocheck(void)</span>
 		old_id = mpc_ioapic_id(ioapic_idx);
 
 		if (mpc_ioapic_id(ioapic_idx) &gt;= get_physical_broadcast()) {
<span class="p_del">-			printk(KERN_ERR &quot;BIOS bug, IO-APIC#%d ID is %d in the MPC table!...\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;BIOS bug, IO-APIC#%d ID is %d in the MPC table!...\n&quot;,</span>
 				ioapic_idx, mpc_ioapic_id(ioapic_idx));
<span class="p_del">-			printk(KERN_ERR &quot;... fixing up to %d. (tell your hw vendor)\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;... fixing up to %d. (tell your hw vendor)\n&quot;,</span>
 				reg_00.bits.ID);
 			ioapics[ioapic_idx].mp_config.apicid = reg_00.bits.ID;
 		}
<span class="p_chunk">@@ -1522,14 +1522,14 @@</span> <span class="p_context"> void __init setup_ioapic_ids_from_mpc_nocheck(void)</span>
 		 */
 		if (apic-&gt;check_apicid_used(&amp;phys_id_present_map,
 					    mpc_ioapic_id(ioapic_idx))) {
<span class="p_del">-			printk(KERN_ERR &quot;BIOS bug, IO-APIC#%d ID %d is already used!...\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;BIOS bug, IO-APIC#%d ID %d is already used!...\n&quot;,</span>
 				ioapic_idx, mpc_ioapic_id(ioapic_idx));
 			for (i = 0; i &lt; get_physical_broadcast(); i++)
 				if (!physid_isset(i, phys_id_present_map))
 					break;
 			if (i &gt;= get_physical_broadcast())
 				panic(&quot;Max APIC ID exceeded!\n&quot;);
<span class="p_del">-			printk(KERN_ERR &quot;... fixing up to %d. (tell your hw vendor)\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;... fixing up to %d. (tell your hw vendor)\n&quot;,</span>
 				i);
 			physid_set(i, phys_id_present_map);
 			ioapics[ioapic_idx].mp_config.apicid = i;
<span class="p_chunk">@@ -2369,8 +2369,8 @@</span> <span class="p_context"> static int io_apic_get_unique_id(int ioapic, int apic_id)</span>
 	raw_spin_unlock_irqrestore(&amp;ioapic_lock, flags);
 
 	if (apic_id &gt;= get_physical_broadcast()) {
<span class="p_del">-		printk(KERN_WARNING &quot;IOAPIC[%d]: Invalid apic_id %d, trying &quot;</span>
<span class="p_del">-			&quot;%d\n&quot;, ioapic, apic_id, reg_00.bits.ID);</span>
<span class="p_add">+		pr_warn(&quot;IOAPIC[%d]: Invalid apic_id %d, trying %d\n&quot;,</span>
<span class="p_add">+			ioapic, apic_id, reg_00.bits.ID);</span>
 		apic_id = reg_00.bits.ID;
 	}
 
<span class="p_chunk">@@ -2388,8 +2388,8 @@</span> <span class="p_context"> static int io_apic_get_unique_id(int ioapic, int apic_id)</span>
 		if (i == get_physical_broadcast())
 			panic(&quot;Max apic_id exceeded!\n&quot;);
 
<span class="p_del">-		printk(KERN_WARNING &quot;IOAPIC[%d]: apic_id %d already used, &quot;</span>
<span class="p_del">-			&quot;trying %d\n&quot;, ioapic, apic_id, i);</span>
<span class="p_add">+		pr_warn(&quot;IOAPIC[%d]: apic_id %d already used, trying %d\n&quot;,</span>
<span class="p_add">+			ioapic, apic_id, i);</span>
 
 		apic_id = i;
 	}
<span class="p_chunk">@@ -2609,10 +2609,7 @@</span> <span class="p_context"> void __init io_apic_init_mappings(void)</span>
 			ioapic_phys = mpc_ioapic_addr(i);
 #ifdef CONFIG_X86_32
 			if (!ioapic_phys) {
<span class="p_del">-				printk(KERN_ERR</span>
<span class="p_del">-				       &quot;WARNING: bogus zero IO-APIC &quot;</span>
<span class="p_del">-				       &quot;address found in MPTABLE, &quot;</span>
<span class="p_del">-				       &quot;disabling IO/APIC support!\n&quot;);</span>
<span class="p_add">+				pr_err(&quot;WARNING: bogus zero IO-APIC address found in MPTABLE, disabling IO/APIC support!\n&quot;);</span>
 				smp_found_config = 0;
 				skip_ioapic_setup = 1;
 				goto fake_ioapic_page;
<span class="p_chunk">@@ -2644,8 +2641,7 @@</span> <span class="p_context"> void __init ioapic_insert_resources(void)</span>
 
 	if (!r) {
 		if (nr_ioapics &gt; 0)
<span class="p_del">-			printk(KERN_ERR</span>
<span class="p_del">-				&quot;IO APIC resources couldn&#39;t be allocated.\n&quot;);</span>
<span class="p_add">+			pr_err(&quot;IO APIC resources couldn&#39;t be allocated.\n&quot;);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -2669,7 +2665,7 @@</span> <span class="p_context"> int mp_find_ioapic(u32 gsi)</span>
 			return i;
 	}
 
<span class="p_del">-	printk(KERN_ERR &quot;ERROR: Unable to locate IOAPIC for GSI %d\n&quot;, gsi);</span>
<span class="p_add">+	pr_err(&quot;ERROR: Unable to locate IOAPIC for GSI %d\n&quot;, gsi);</span>
 	return -1;
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/apic/probe_32.c b/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_header">index f316e34..92c1e2e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_chunk">@@ -60,8 +60,7 @@</span> <span class="p_context"> static int default_x86_32_early_logical_apicid(int cpu)</span>
 static void setup_apic_flat_routing(void)
 {
 #ifdef CONFIG_X86_IO_APIC
<span class="p_del">-	printk(KERN_INFO</span>
<span class="p_del">-		&quot;Enabling APIC mode:  Flat.  Using %d I/O APICs\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Enabling APIC mode:  Flat.  Using %d I/O APICs\n&quot;,</span>
 		nr_ioapics);
 #endif
 }
<span class="p_chunk">@@ -202,7 +201,7 @@</span> <span class="p_context"> void __init generic_apic_probe(void)</span>
 		if (drv == __apicdrivers_end)
 			panic(&quot;Didn&#39;t find an APIC driver&quot;);
 	}
<span class="p_del">-	printk(KERN_INFO &quot;Using APIC driver %s\n&quot;, apic-&gt;name);</span>
<span class="p_add">+	pr_info(&quot;Using APIC driver %s\n&quot;, apic-&gt;name);</span>
 }
 
 /* This function can switch the APIC even after the initial -&gt;probe() */
<span class="p_chunk">@@ -218,8 +217,7 @@</span> <span class="p_context"> int __init default_acpi_madt_oem_check(char *oem_id, char *oem_table_id)</span>
 
 		if (!cmdline_apic) {
 			apic = *drv;
<span class="p_del">-			printk(KERN_INFO &quot;Switched to APIC driver `%s&#39;.\n&quot;,</span>
<span class="p_del">-			       apic-&gt;name);</span>
<span class="p_add">+			pr_info(&quot;Switched to APIC driver `%s&#39;.\n&quot;, apic-&gt;name);</span>
 		}
 		return 1;
 	}
<span class="p_header">diff --git a/arch/x86/kernel/apic/x2apic_uv_x.c b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">index 624db005..e7cebce 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_chunk">@@ -725,9 +725,7 @@</span> <span class="p_context"> static __init void uv_rtc_init(void)</span>
 	status = uv_bios_freq_base(BIOS_FREQ_BASE_REALTIME_CLOCK,
 					&amp;ticks_per_sec);
 	if (status != BIOS_STATUS_SUCCESS || ticks_per_sec &lt; 100000) {
<span class="p_del">-		printk(KERN_WARNING</span>
<span class="p_del">-			&quot;unable to determine platform RTC clock frequency, &quot;</span>
<span class="p_del">-			&quot;guessing.\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;unable to determine platform RTC clock frequency, guessing.\n&quot;);</span>
 		/* BIOS gives wrong value for clock freq. so guess */
 		sn_rtc_cycles_per_second = 1000000000000UL / 30000UL;
 	} else
<span class="p_header">diff --git a/arch/x86/kernel/apm_32.c b/arch/x86/kernel/apm_32.c</span>
<span class="p_header">index 052c9c3..8363507 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apm_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apm_32.c</span>
<span class="p_chunk">@@ -1760,7 +1760,7 @@</span> <span class="p_context"> static int apm(void *unused)</span>
 	}
 
 	if (debug)
<span class="p_del">-		printk(KERN_INFO &quot;apm: Connection version %d.%d\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;apm: Connection version %d.%d\n&quot;,</span>
 			(apm_info.connection_version &gt;&gt; 8) &amp; 0xff,
 			apm_info.connection_version &amp; 0xff);
 
<span class="p_chunk">@@ -1791,7 +1791,7 @@</span> <span class="p_context"> static int apm(void *unused)</span>
 	if (debug &amp;&amp; (num_online_cpus() == 1 || smp)) {
 		error = apm_get_power_status(&amp;bx, &amp;cx, &amp;dx);
 		if (error)
<span class="p_del">-			printk(KERN_INFO &quot;apm: power status not available\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;apm: power status not available\n&quot;);</span>
 		else {
 			switch ((bx &gt;&gt; 8) &amp; 0xff) {
 			case 0:
<span class="p_chunk">@@ -1824,17 +1824,15 @@</span> <span class="p_context"> static int apm(void *unused)</span>
 				bat_stat = &quot;unknown&quot;;
 				break;
 			}
<span class="p_del">-			printk(KERN_INFO</span>
<span class="p_del">-			       &quot;apm: AC %s, battery status %s, battery life &quot;,</span>
<span class="p_del">-			       power_stat, bat_stat);</span>
<span class="p_add">+			pr_info(&quot;apm: AC %s, battery status %s, battery life &quot;,</span>
<span class="p_add">+				power_stat, bat_stat);</span>
 			if ((cx &amp; 0xff) == 0xff)
 				printk(&quot;unknown\n&quot;);
 			else
 				printk(&quot;%d%%\n&quot;, cx &amp; 0xff);
 			if (apm_info.connection_version &gt; 0x100) {
<span class="p_del">-				printk(KERN_INFO</span>
<span class="p_del">-				       &quot;apm: battery flag 0x%02x, battery life &quot;,</span>
<span class="p_del">-				       (cx &gt;&gt; 8) &amp; 0xff);</span>
<span class="p_add">+				pr_info(&quot;apm: battery flag 0x%02x, battery life &quot;,</span>
<span class="p_add">+					(cx &gt;&gt; 8) &amp; 0xff);</span>
 				if (dx == 0xffff)
 					printk(&quot;unknown\n&quot;);
 				else
<span class="p_chunk">@@ -1943,8 +1941,8 @@</span> <span class="p_context"> static int __init print_if_true(const struct dmi_system_id *d)</span>
  */
 static int __init broken_ps2_resume(const struct dmi_system_id *d)
 {
<span class="p_del">-	printk(KERN_INFO &quot;%s machine detected. Mousepad Resume Bug &quot;</span>
<span class="p_del">-	       &quot;workaround hopefully not needed.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+	pr_info(&quot;%s machine detected. Mousepad Resume Bug workaround hopefully not needed.\n&quot;,</span>
<span class="p_add">+		d-&gt;ident);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1953,8 +1951,8 @@</span> <span class="p_context"> static int __init set_realmode_power_off(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.realmode_power_off == 0) {
 		apm_info.realmode_power_off = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s bios detected. &quot;</span>
<span class="p_del">-		       &quot;Using realmode poweroff only.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;%s bios detected. Using realmode poweroff only.\n&quot;,</span>
<span class="p_add">+			d-&gt;ident);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1964,8 +1962,8 @@</span> <span class="p_context"> static int __init set_apm_ints(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.allow_ints == 0) {
 		apm_info.allow_ints = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s machine detected. &quot;</span>
<span class="p_del">-		       &quot;Enabling interrupts during APM calls.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;%s machine detected. Enabling interrupts during APM calls.\n&quot;,</span>
<span class="p_add">+			d-&gt;ident);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1975,8 +1973,7 @@</span> <span class="p_context"> static int __init apm_is_horked(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.disabled == 0) {
 		apm_info.disabled = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s machine detected. &quot;</span>
<span class="p_del">-		       &quot;Disabling APM.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;%s machine detected. Disabling APM.\n&quot;, d-&gt;ident);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1985,10 +1982,9 @@</span> <span class="p_context"> static int __init apm_is_horked_d850md(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.disabled == 0) {
 		apm_info.disabled = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s machine detected. &quot;</span>
<span class="p_del">-		       &quot;Disabling APM.\n&quot;, d-&gt;ident);</span>
<span class="p_del">-		printk(KERN_INFO &quot;This bug is fixed in bios P15 which is available for\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;download from support.intel.com\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;%s machine detected. Disabling APM.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;This bug is fixed in bios P15 which is available for\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;download from support.intel.com\n&quot;);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1998,8 +1994,8 @@</span> <span class="p_context"> static int __init apm_likes_to_melt(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.forbid_idle == 0) {
 		apm_info.forbid_idle = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s machine detected. &quot;</span>
<span class="p_del">-		       &quot;Disabling APM idle calls.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;%s machine detected. Disabling APM idle calls.\n&quot;,</span>
<span class="p_add">+			d-&gt;ident);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -2268,17 +2264,16 @@</span> <span class="p_context"> static int __init apm_init(void)</span>
 	dmi_check_system(apm_dmi_table);
 
 	if (apm_info.bios.version == 0 || paravirt_enabled() || machine_is_olpc()) {
<span class="p_del">-		printk(KERN_INFO &quot;apm: BIOS not found.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;apm: BIOS not found.\n&quot;);</span>
 		return -ENODEV;
 	}
<span class="p_del">-	printk(KERN_INFO</span>
<span class="p_del">-	       &quot;apm: BIOS version %d.%d Flags 0x%02x (Driver version %s)\n&quot;,</span>
<span class="p_del">-	       ((apm_info.bios.version &gt;&gt; 8) &amp; 0xff),</span>
<span class="p_del">-	       (apm_info.bios.version &amp; 0xff),</span>
<span class="p_del">-	       apm_info.bios.flags,</span>
<span class="p_del">-	       driver_version);</span>
<span class="p_add">+	pr_info(&quot;apm: BIOS version %d.%d Flags 0x%02x (Driver version %s)\n&quot;,</span>
<span class="p_add">+		((apm_info.bios.version &gt;&gt; 8) &amp; 0xff),</span>
<span class="p_add">+		(apm_info.bios.version &amp; 0xff),</span>
<span class="p_add">+		apm_info.bios.flags,</span>
<span class="p_add">+		driver_version);</span>
 	if ((apm_info.bios.flags &amp; APM_32_BIT_SUPPORT) == 0) {
<span class="p_del">-		printk(KERN_INFO &quot;apm: no 32 bit BIOS support\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;apm: no 32 bit BIOS support\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_chunk">@@ -2304,7 +2299,7 @@</span> <span class="p_context"> static int __init apm_init(void)</span>
 		apm_info.bios.cseg_16_len = 0; /* 64k */
 
 	if (debug) {
<span class="p_del">-		printk(KERN_INFO &quot;apm: entry %x:%x cseg16 %x dseg %x&quot;,</span>
<span class="p_add">+		pr_info(&quot;apm: entry %x:%x cseg16 %x dseg %x&quot;,</span>
 			apm_info.bios.cseg, apm_info.bios.offset,
 			apm_info.bios.cseg_16, apm_info.bios.dseg);
 		if (apm_info.bios.version &gt; 0x100)
<span class="p_header">diff --git a/arch/x86/kernel/bootflag.c b/arch/x86/kernel/bootflag.c</span>
<span class="p_header">index 52c8e3c..8056ed9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/bootflag.c</span>
<span class="p_header">+++ b/arch/x86/kernel/bootflag.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> static void __init sbf_write(u8 v)</span>
 		if (!parity(v))
 			v |= SBF_PARITY;
 
<span class="p_del">-		printk(KERN_INFO &quot;Simple Boot Flag at 0x%x set to 0x%x\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;Simple Boot Flag at 0x%x set to 0x%x\n&quot;,</span>
 			sbf_port, v);
 
 		spin_lock_irqsave(&amp;rtc_lock, flags);
<span class="p_header">diff --git a/arch/x86/kernel/check.c b/arch/x86/kernel/check.c</span>
<span class="p_header">index 145863d..8ad9da5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/check.c</span>
<span class="p_header">+++ b/arch/x86/kernel/check.c</span>
<span class="p_chunk">@@ -112,7 +112,8 @@</span> <span class="p_context"> void __init setup_bios_corruption_check(void)</span>
 	}
 
 	if (num_scan_areas)
<span class="p_del">-		printk(KERN_INFO &quot;Scanning %d areas for low memory corruption\n&quot;, num_scan_areas);</span>
<span class="p_add">+		pr_info(&quot;Scanning %d areas for low memory corruption\n&quot;,</span>
<span class="p_add">+			num_scan_areas);</span>
 }
 
 
<span class="p_chunk">@@ -156,8 +157,8 @@</span> <span class="p_context"> static int start_periodic_check_for_corruption(void)</span>
 	if (!num_scan_areas || !memory_corruption_check || corruption_check_period == 0)
 		return 0;
 
<span class="p_del">-	printk(KERN_INFO &quot;Scanning for low memory corruption every %d seconds\n&quot;,</span>
<span class="p_del">-	       corruption_check_period);</span>
<span class="p_add">+	pr_info(&quot;Scanning for low memory corruption every %d seconds\n&quot;,</span>
<span class="p_add">+		corruption_check_period);</span>
 
 	/* First time we run the checks right away */
 	schedule_delayed_work(&amp;bios_check_work, 0);
<span class="p_header">diff --git a/arch/x86/kernel/cpuid.c b/arch/x86/kernel/cpuid.c</span>
<span class="p_header">index 2836de3..ca403a5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpuid.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpuid.c</span>
<span class="p_chunk">@@ -165,8 +165,8 @@</span> <span class="p_context"> static int __init cpuid_init(void)</span>
 
 	if (__register_chrdev(CPUID_MAJOR, 0, NR_CPUS,
 			      &quot;cpu/cpuid&quot;, &amp;cpuid_fops)) {
<span class="p_del">-		printk(KERN_ERR &quot;cpuid: unable to get major %d for cpuid\n&quot;,</span>
<span class="p_del">-		       CPUID_MAJOR);</span>
<span class="p_add">+		pr_err(&quot;cpuid: unable to get major %d for cpuid\n&quot;,</span>
<span class="p_add">+			CPUID_MAJOR);</span>
 		err = -EBUSY;
 		goto out;
 	}
<span class="p_header">diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c</span>
<span class="p_header">index 621b501..f8e9f2e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/e820.c</span>
<span class="p_header">+++ b/arch/x86/kernel/e820.c</span>
<span class="p_chunk">@@ -165,10 +165,10 @@</span> <span class="p_context"> void __init e820_print_map(char *who)</span>
 	int i;
 
 	for (i = 0; i &lt; e820.nr_map; i++) {
<span class="p_del">-		printk(KERN_INFO &quot;%s: [mem %#018Lx-%#018Lx] &quot;, who,</span>
<span class="p_del">-		       (unsigned long long) e820.map[i].addr,</span>
<span class="p_del">-		       (unsigned long long)</span>
<span class="p_del">-		       (e820.map[i].addr + e820.map[i].size - 1));</span>
<span class="p_add">+		pr_info(&quot;%s: [mem %#018Lx-%#018Lx] &quot;, who,</span>
<span class="p_add">+			(unsigned long long) e820.map[i].addr,</span>
<span class="p_add">+			(unsigned long long)</span>
<span class="p_add">+			(e820.map[i].addr + e820.map[i].size - 1));</span>
 		e820_print_type(e820.map[i].type);
 		printk(KERN_CONT &quot;\n&quot;);
 	}
<span class="p_chunk">@@ -568,7 +568,7 @@</span> <span class="p_context"> void __init update_e820(void)</span>
 {
 	if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &amp;e820.nr_map))
 		return;
<span class="p_del">-	printk(KERN_INFO &quot;e820: modified physical RAM map:\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;e820: modified physical RAM map:\n&quot;);</span>
 	e820_print_map(&quot;modified&quot;);
 }
 static void __init update_e820_saved(void)
<span class="p_chunk">@@ -644,9 +644,8 @@</span> <span class="p_context"> __init void e820_setup_gap(void)</span>
 	 */
 	pci_mem_start = gapstart;
 
<span class="p_del">-	printk(KERN_INFO</span>
<span class="p_del">-	       &quot;e820: [mem %#010lx-%#010lx] available for PCI devices\n&quot;,</span>
<span class="p_del">-	       gapstart, gapstart + gapsize - 1);</span>
<span class="p_add">+	pr_info(&quot;e820: [mem %#010lx-%#010lx] available for PCI devices\n&quot;,</span>
<span class="p_add">+		gapstart, gapstart + gapsize - 1);</span>
 }
 
 /**
<span class="p_chunk">@@ -667,7 +666,7 @@</span> <span class="p_context"> void __init parse_e820_ext(u64 phys_addr, u32 data_len)</span>
 	__append_e820_map(extmap, entries);
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &amp;e820.nr_map);
 	early_memunmap(sdata, data_len);
<span class="p_del">-	printk(KERN_INFO &quot;e820: extended physical RAM map:\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;e820: extended physical RAM map:\n&quot;);</span>
 	e820_print_map(&quot;extended&quot;);
 }
 
<span class="p_chunk">@@ -734,7 +733,7 @@</span> <span class="p_context"> u64 __init early_reserve_e820(u64 size, u64 align)</span>
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
 		e820_update_range_saved(addr, size, E820_RAM, E820_RESERVED);
<span class="p_del">-		printk(KERN_INFO &quot;e820: update e820_saved for early_reserve_e820\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;e820: update e820_saved for early_reserve_e820\n&quot;);</span>
 		update_e820_saved();
 	}
 
<span class="p_chunk">@@ -788,8 +787,8 @@</span> <span class="p_context"> static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
 	if (last_pfn &gt; max_arch_pfn)
 		last_pfn = max_arch_pfn;
 
<span class="p_del">-	printk(KERN_INFO &quot;e820: last_pfn = %#lx max_arch_pfn = %#lx\n&quot;,</span>
<span class="p_del">-			 last_pfn, max_arch_pfn);</span>
<span class="p_add">+	pr_info(&quot;e820: last_pfn = %#lx max_arch_pfn = %#lx\n&quot;,</span>
<span class="p_add">+		last_pfn, max_arch_pfn);</span>
 	return last_pfn;
 }
 unsigned long __init e820_end_of_ram_pfn(void)
<span class="p_chunk">@@ -907,7 +906,7 @@</span> <span class="p_context"> void __init finish_e820_parsing(void)</span>
 					&amp;e820.nr_map) &lt; 0)
 			early_panic(&quot;Invalid user supplied memory map&quot;);
 
<span class="p_del">-		printk(KERN_INFO &quot;e820: user-defined physical RAM map:\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;e820: user-defined physical RAM map:\n&quot;);</span>
 		e820_print_map(&quot;user&quot;);
 	}
 }
<span class="p_chunk">@@ -1125,7 +1124,7 @@</span> <span class="p_context"> void __init setup_memory_map(void)</span>
 
 	who = x86_init.resources.memory_setup();
 	memcpy(&amp;e820_saved, &amp;e820, sizeof(struct e820map));
<span class="p_del">-	printk(KERN_INFO &quot;e820: BIOS-provided physical RAM map:\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;e820: BIOS-provided physical RAM map:\n&quot;);</span>
 	e820_print_map(who);
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">index bca14c8..e843f15 100644</span>
<span class="p_header">--- a/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/early-quirks.c</span>
<span class="p_chunk">@@ -33,13 +33,10 @@</span> <span class="p_context"> static void __init fix_hypertransport_config(int num, int slot, int func)</span>
 	 */
 	htcfg = read_pci_config(num, slot, func, 0x68);
 	if (htcfg &amp; (1 &lt;&lt; 18)) {
<span class="p_del">-		printk(KERN_INFO &quot;Detected use of extended apic ids &quot;</span>
<span class="p_del">-				 &quot;on hypertransport bus\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Detected use of extended apic ids on hypertransport bus\n&quot;);</span>
 		if ((htcfg &amp; (1 &lt;&lt; 17)) == 0) {
<span class="p_del">-			printk(KERN_INFO &quot;Enabling hypertransport extended &quot;</span>
<span class="p_del">-					 &quot;apic interrupt broadcast\n&quot;);</span>
<span class="p_del">-			printk(KERN_INFO &quot;Note this is a bios bug, &quot;</span>
<span class="p_del">-					 &quot;please contact your hw vendor\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;Enabling hypertransport extended apic interrupt broadcast\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;Note this is a bios bug, please contact your hw vendor\n&quot;);</span>
 			htcfg |= (1 &lt;&lt; 17);
 			write_pci_config(num, slot, func, 0x68, htcfg);
 		}
<span class="p_chunk">@@ -53,9 +50,7 @@</span> <span class="p_context"> static void __init via_bugs(int  num, int slot, int func)</span>
 #ifdef CONFIG_GART_IOMMU
 	if ((max_pfn &gt; MAX_DMA32_PFN ||  force_iommu) &amp;&amp;
 	    !gart_iommu_aperture_allowed) {
<span class="p_del">-		printk(KERN_INFO</span>
<span class="p_del">-		       &quot;Looks like a VIA chipset. Disabling IOMMU.&quot;</span>
<span class="p_del">-		       &quot; Override with iommu=allowed\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Looks like a VIA chipset. Disabling IOMMU. Override with iommu=allowed\n&quot;);</span>
 		gart_iommu_aperture_disabled = 1;
 	}
 #endif
<span class="p_chunk">@@ -87,11 +82,8 @@</span> <span class="p_context"> static void __init nvidia_bugs(int num, int slot, int func)</span>
 
 	if (acpi_table_parse(ACPI_SIG_HPET, nvidia_hpet_check)) {
 		acpi_skip_timer_override = 1;
<span class="p_del">-		printk(KERN_INFO &quot;Nvidia board &quot;</span>
<span class="p_del">-		       &quot;detected. Ignoring ACPI &quot;</span>
<span class="p_del">-		       &quot;timer override.\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;If you got timer trouble &quot;</span>
<span class="p_del">-			&quot;try acpi_use_timer_override\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Nvidia board detected. Ignoring ACPI timer override.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;If you got timer trouble try acpi_use_timer_override\n&quot;);</span>
 	}
 #endif
 #endif
<span class="p_chunk">@@ -137,10 +129,9 @@</span> <span class="p_context"> static void __init ati_bugs(int num, int slot, int func)</span>
 	}
 
 	if (acpi_skip_timer_override) {
<span class="p_del">-		printk(KERN_INFO &quot;SB4X0 revision 0x%x\n&quot;, d);</span>
<span class="p_del">-		printk(KERN_INFO &quot;Ignoring ACPI timer override.\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;If you got timer trouble &quot;</span>
<span class="p_del">-		       &quot;try acpi_use_timer_override\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;SB4X0 revision 0x%x\n&quot;, d);</span>
<span class="p_add">+		pr_info(&quot;Ignoring ACPI timer override.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;If you got timer trouble try acpi_use_timer_override\n&quot;);</span>
 	}
 }
 
<span class="p_chunk">@@ -179,10 +170,9 @@</span> <span class="p_context"> static void __init ati_bugs_contd(int num, int slot, int func)</span>
 		acpi_skip_timer_override = 1;
 
 	if (acpi_skip_timer_override) {
<span class="p_del">-		printk(KERN_INFO &quot;SB600 revision 0x%x\n&quot;, rev);</span>
<span class="p_del">-		printk(KERN_INFO &quot;Ignoring ACPI timer override.\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;If you got timer trouble &quot;</span>
<span class="p_del">-		       &quot;try acpi_use_timer_override\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;SB600 revision 0x%x\n&quot;, rev);</span>
<span class="p_add">+		pr_info(&quot;Ignoring ACPI timer override.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;If you got timer trouble try acpi_use_timer_override\n&quot;);</span>
 	}
 }
 #else
<span class="p_chunk">@@ -569,8 +559,8 @@</span> <span class="p_context"> static void __init intel_graphics_stolen(int num, int slot, int func)</span>
 			size = stolen_funcs-&gt;size(num, slot, func);
 			start = stolen_funcs-&gt;base(num, slot, func, size);
 			if (size &amp;&amp; start) {
<span class="p_del">-				printk(KERN_INFO &quot;Reserving Intel graphics stolen memory at 0x%x-0x%x\n&quot;,</span>
<span class="p_del">-				       start, start + (u32)size - 1);</span>
<span class="p_add">+				pr_info(&quot;Reserving Intel graphics stolen memory at 0x%x-0x%x\n&quot;,</span>
<span class="p_add">+					start, start + (u32)size - 1);</span>
 				/* Mark this space as reserved */
 				e820_add_region(start, size, E820_RESERVED);
 				sanitize_e820_map(e820.map,
<span class="p_header">diff --git a/arch/x86/kernel/fpu/init.c b/arch/x86/kernel/fpu/init.c</span>
<span class="p_header">index 471fe27..569fb61 100644</span>
<span class="p_header">--- a/arch/x86/kernel/fpu/init.c</span>
<span class="p_header">+++ b/arch/x86/kernel/fpu/init.c</span>
<span class="p_chunk">@@ -342,7 +342,8 @@</span> <span class="p_context"> static void __init fpu__init_system_ctx_switch(void)</span>
 	if (eagerfpu == ENABLE)
 		setup_force_cpu_cap(X86_FEATURE_EAGER_FPU);
 
<span class="p_del">-	printk(KERN_INFO &quot;x86/fpu: Using &#39;%s&#39; FPU context switches.\n&quot;, eagerfpu == ENABLE ? &quot;eager&quot; : &quot;lazy&quot;);</span>
<span class="p_add">+	pr_info(&quot;x86/fpu: Using &#39;%s&#39; FPU context switches.\n&quot;,</span>
<span class="p_add">+		eagerfpu == ENABLE ? &quot;eager&quot; : &quot;lazy&quot;);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c</span>
<span class="p_header">index d425cda5..4fb56f9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/fpu/xstate.c</span>
<span class="p_header">+++ b/arch/x86/kernel/fpu/xstate.c</span>
<span class="p_chunk">@@ -222,7 +222,8 @@</span> <span class="p_context"> static void __init setup_xstate_features(void)</span>
 			&quot;x86/fpu: misordered xstate at %d\n&quot;, last_good_offset);
 		last_good_offset = xstate_offsets[i];
 
<span class="p_del">-		printk(KERN_INFO &quot;x86/fpu: xstate_offset[%d]: %4d, xstate_sizes[%d]: %4d\n&quot;, i, ebx, i, eax);</span>
<span class="p_add">+		pr_info(&quot;x86/fpu: xstate_offset[%d]: %4d, xstate_sizes[%d]: %4d\n&quot;,</span>
<span class="p_add">+			i, ebx, i, eax);</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/hpet.c b/arch/x86/kernel/hpet.c</span>
<span class="p_header">index be0ebbb..152f3bd 100644</span>
<span class="p_header">--- a/arch/x86/kernel/hpet.c</span>
<span class="p_header">+++ b/arch/x86/kernel/hpet.c</span>
<span class="p_chunk">@@ -139,31 +139,28 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(is_hpet_enabled);</span>
 static void _hpet_print_config(const char *function, int line)
 {
 	u32 i, timers, l, h;
<span class="p_del">-	printk(KERN_INFO &quot;hpet: %s(%d):\n&quot;, function, line);</span>
<span class="p_add">+	pr_info(&quot;hpet: %s(%d):\n&quot;, function, line);</span>
 	l = hpet_readl(HPET_ID);
 	h = hpet_readl(HPET_PERIOD);
 	timers = ((l &amp; HPET_ID_NUMBER) &gt;&gt; HPET_ID_NUMBER_SHIFT) + 1;
<span class="p_del">-	printk(KERN_INFO &quot;hpet: ID: 0x%x, PERIOD: 0x%x\n&quot;, l, h);</span>
<span class="p_add">+	pr_info(&quot;hpet: ID: 0x%x, PERIOD: 0x%x\n&quot;, l, h);</span>
 	l = hpet_readl(HPET_CFG);
 	h = hpet_readl(HPET_STATUS);
<span class="p_del">-	printk(KERN_INFO &quot;hpet: CFG: 0x%x, STATUS: 0x%x\n&quot;, l, h);</span>
<span class="p_add">+	pr_info(&quot;hpet: CFG: 0x%x, STATUS: 0x%x\n&quot;, l, h);</span>
 	l = hpet_readl(HPET_COUNTER);
 	h = hpet_readl(HPET_COUNTER+4);
<span class="p_del">-	printk(KERN_INFO &quot;hpet: COUNTER_l: 0x%x, COUNTER_h: 0x%x\n&quot;, l, h);</span>
<span class="p_add">+	pr_info(&quot;hpet: COUNTER_l: 0x%x, COUNTER_h: 0x%x\n&quot;, l, h);</span>
 
 	for (i = 0; i &lt; timers; i++) {
 		l = hpet_readl(HPET_Tn_CFG(i));
 		h = hpet_readl(HPET_Tn_CFG(i)+4);
<span class="p_del">-		printk(KERN_INFO &quot;hpet: T%d: CFG_l: 0x%x, CFG_h: 0x%x\n&quot;,</span>
<span class="p_del">-		       i, l, h);</span>
<span class="p_add">+		pr_info(&quot;hpet: T%d: CFG_l: 0x%x, CFG_h: 0x%x\n&quot;, i, l, h);</span>
 		l = hpet_readl(HPET_Tn_CMP(i));
 		h = hpet_readl(HPET_Tn_CMP(i)+4);
<span class="p_del">-		printk(KERN_INFO &quot;hpet: T%d: CMP_l: 0x%x, CMP_h: 0x%x\n&quot;,</span>
<span class="p_del">-		       i, l, h);</span>
<span class="p_add">+		pr_info(&quot;hpet: T%d: CMP_l: 0x%x, CMP_h: 0x%x\n&quot;, i, l, h);</span>
 		l = hpet_readl(HPET_Tn_ROUTE(i));
 		h = hpet_readl(HPET_Tn_ROUTE(i)+4);
<span class="p_del">-		printk(KERN_INFO &quot;hpet: T%d ROUTE_l: 0x%x, ROUTE_h: 0x%x\n&quot;,</span>
<span class="p_del">-		       i, l, h);</span>
<span class="p_add">+		pr_info(&quot;hpet: T%d ROUTE_l: 0x%x, ROUTE_h: 0x%x\n&quot;, i, l, h);</span>
 	}
 }
 
<span class="p_chunk">@@ -526,8 +523,8 @@</span> <span class="p_context"> static irqreturn_t hpet_interrupt_handler(int irq, void *data)</span>
 	struct clock_event_device *hevt = &amp;dev-&gt;evt;
 
 	if (!hevt-&gt;event_handler) {
<span class="p_del">-		printk(KERN_INFO &quot;Spurious HPET timer interrupt on HPET timer %d\n&quot;,</span>
<span class="p_del">-				dev-&gt;num);</span>
<span class="p_add">+		pr_info(&quot;Spurious HPET timer interrupt on HPET timer %d\n&quot;,</span>
<span class="p_add">+			dev-&gt;num);</span>
 		return IRQ_HANDLED;
 	}
 
<span class="p_chunk">@@ -646,7 +643,7 @@</span> <span class="p_context"> static void hpet_msi_capability_lookup(unsigned int start_timer)</span>
 			break;
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;HPET: %d timers in total, %d timers will be used for per-cpu timer\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;HPET: %d timers in total, %d timers will be used for per-cpu timer\n&quot;,</span>
 		num_timers, num_timers_used);
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/i8259.c b/arch/x86/kernel/i8259.c</span>
<span class="p_header">index be22f5a..192c22e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/i8259.c</span>
<span class="p_header">+++ b/arch/x86/kernel/i8259.c</span>
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> static int probe_8259A(void)</span>
 	outb(probe_val, PIC_MASTER_IMR);
 	new_val = inb(PIC_MASTER_IMR);
 	if (new_val != probe_val) {
<span class="p_del">-		printk(KERN_INFO &quot;Using NULL legacy PIC\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Using NULL legacy PIC\n&quot;);</span>
 		legacy_pic = &amp;null_legacy_pic;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/kprobes/core.c b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">index 0f05dee..c684b200 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_chunk">@@ -581,8 +581,7 @@</span> <span class="p_context"> static int reenter_kprobe(struct kprobe *p, struct pt_regs *regs,</span>
 		 * Raise a BUG or we&#39;ll continue in an endless reentering loop
 		 * and eventually a stack overflow.
 		 */
<span class="p_del">-		printk(KERN_WARNING &quot;Unrecoverable kprobe detected at %p.\n&quot;,</span>
<span class="p_del">-		       p-&gt;addr);</span>
<span class="p_add">+		pr_warn(&quot;Unrecoverable kprobe detected at %p.\n&quot;, p-&gt;addr);</span>
 		dump_kprobe(p);
 		BUG();
 	default:
<span class="p_chunk">@@ -1092,12 +1091,11 @@</span> <span class="p_context"> int longjmp_break_handler(struct kprobe *p, struct pt_regs *regs)</span>
 	    (addr &lt; (u8 *) jprobe_return_end)) {
 		if (stack_addr(regs) != saved_sp) {
 			struct pt_regs *saved_regs = &amp;kcb-&gt;jprobe_saved_regs;
<span class="p_del">-			printk(KERN_ERR</span>
<span class="p_del">-			       &quot;current sp %p does not match saved sp %p\n&quot;,</span>
<span class="p_del">-			       stack_addr(regs), saved_sp);</span>
<span class="p_del">-			printk(KERN_ERR &quot;Saved registers for jprobe %p\n&quot;, jp);</span>
<span class="p_add">+			pr_err(&quot;current sp %p does not match saved sp %p\n&quot;,</span>
<span class="p_add">+				stack_addr(regs), saved_sp);</span>
<span class="p_add">+			pr_err(&quot;Saved registers for jprobe %p\n&quot;, jp);</span>
 			show_regs(saved_regs);
<span class="p_del">-			printk(KERN_ERR &quot;Current registers\n&quot;);</span>
<span class="p_add">+			pr_err(&quot;Current registers\n&quot;);</span>
 			show_regs(regs);
 			BUG();
 		}
<span class="p_header">diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c</span>
<span class="p_header">index 47190bd..620096e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvm.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvm.c</span>
<span class="p_chunk">@@ -344,8 +344,8 @@</span> <span class="p_context"> static void kvm_guest_cpu_init(void)</span>
 #endif
 		wrmsrl(MSR_KVM_ASYNC_PF_EN, pa | KVM_ASYNC_PF_ENABLED);
 		__this_cpu_write(apf_reason.enabled, 1);
<span class="p_del">-		printk(KERN_INFO&quot;KVM setup async PF for cpu %d\n&quot;,</span>
<span class="p_del">-		       smp_processor_id());</span>
<span class="p_add">+		pr_info(&quot;KVM setup async PF for cpu %d\n&quot;,</span>
<span class="p_add">+			smp_processor_id());</span>
 	}
 
 	if (kvm_para_has_feature(KVM_FEATURE_PV_EOI)) {
<span class="p_chunk">@@ -370,8 +370,8 @@</span> <span class="p_context"> static void kvm_pv_disable_apf(void)</span>
 	wrmsrl(MSR_KVM_ASYNC_PF_EN, 0);
 	__this_cpu_write(apf_reason.enabled, 0);
 
<span class="p_del">-	printk(KERN_INFO&quot;Unregister pv shared memory for cpu %d\n&quot;,</span>
<span class="p_del">-	       smp_processor_id());</span>
<span class="p_add">+	pr_info(&quot;Unregister pv shared memory for cpu %d\n&quot;,</span>
<span class="p_add">+		smp_processor_id());</span>
 }
 
 static void kvm_pv_guest_cpu_reboot(void *unused)
<span class="p_chunk">@@ -883,7 +883,7 @@</span> <span class="p_context"> static __init int kvm_spinlock_init_jump(void)</span>
 		return 0;
 
 	static_key_slow_inc(&amp;paravirt_ticketlocks_enabled);
<span class="p_del">-	printk(KERN_INFO &quot;KVM setup paravirtual spinlock\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;KVM setup paravirtual spinlock\n&quot;);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/x86/kernel/kvmclock.c b/arch/x86/kernel/kvmclock.c</span>
<span class="p_header">index 72cef58..553f9bd 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvmclock.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvmclock.c</span>
<span class="p_chunk">@@ -114,8 +114,8 @@</span> <span class="p_context"> static inline void kvm_sched_clock_init(bool stable)</span>
 	pv_time_ops.sched_clock = kvm_sched_clock_read;
 	set_sched_clock_stable();
 
<span class="p_del">-	printk(KERN_INFO &quot;kvm-clock: using sched offset of %llu cycles\n&quot;,</span>
<span class="p_del">-			kvm_sched_clock_offset);</span>
<span class="p_add">+	pr_info(&quot;kvm-clock: using sched offset of %llu cycles\n&quot;,</span>
<span class="p_add">+		kvm_sched_clock_offset);</span>
 
 	BUILD_BUG_ON(sizeof(kvm_sched_clock_offset) &gt;
 	         sizeof(((struct pvclock_vcpu_time_info *)NULL)-&gt;system_time));
<span class="p_chunk">@@ -195,8 +195,8 @@</span> <span class="p_context"> int kvm_register_clock(char *txt)</span>
 	low = (int)slow_virt_to_phys(src) | 1;
 	high = ((u64)slow_virt_to_phys(src) &gt;&gt; 32);
 	ret = native_write_msr_safe(msr_kvm_system_time, low, high);
<span class="p_del">-	printk(KERN_INFO &quot;kvm-clock: cpu %d, msr %x:%x, %s\n&quot;,</span>
<span class="p_del">-	       cpu, high, low, txt);</span>
<span class="p_add">+	pr_info(&quot;kvm-clock: cpu %d, msr %x:%x, %s\n&quot;,</span>
<span class="p_add">+		cpu, high, low, txt);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> void __init kvmclock_init(void)</span>
 	} else if (!(kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))
 		return;
 
<span class="p_del">-	printk(KERN_INFO &quot;kvm-clock: Using msrs %x and %x&quot;,</span>
<span class="p_add">+	pr_info(&quot;kvm-clock: Using msrs %x and %x&quot;,</span>
 		msr_kvm_system_time, msr_kvm_wall_clock);
 
 	mem = memblock_alloc(size, PAGE_SIZE);
<span class="p_header">diff --git a/arch/x86/kernel/mmconf-fam10h_64.c b/arch/x86/kernel/mmconf-fam10h_64.c</span>
<span class="p_header">index f4c886d..1e49af9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/mmconf-fam10h_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/mmconf-fam10h_64.c</span>
<span class="p_chunk">@@ -205,7 +205,7 @@</span> <span class="p_context"> void fam10h_check_enable_mmcfg(void)</span>
 		return;
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;Enable MMCONFIG on AMD Family 10h\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Enable MMCONFIG on AMD Family 10h\n&quot;);</span>
 	val &amp;= ~((FAM10H_MMIO_CONF_BASE_MASK&lt;&lt;FAM10H_MMIO_CONF_BASE_SHIFT) |
 	     (FAM10H_MMIO_CONF_BUSRANGE_MASK&lt;&lt;FAM10H_MMIO_CONF_BUSRANGE_SHIFT));
 	val |= fam10h_pci_mmconf_base | (8 &lt;&lt; FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |
<span class="p_header">diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c</span>
<span class="p_header">index f08ac28..554df0f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/paravirt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/paravirt.c</span>
<span class="p_chunk">@@ -67,8 +67,7 @@</span> <span class="p_context"> u64 _paravirt_ident_64(u64 x)</span>
 
 void __init default_banner(void)
 {
<span class="p_del">-	printk(KERN_INFO &quot;Booting paravirtualized kernel on %s\n&quot;,</span>
<span class="p_del">-	       pv_info.name);</span>
<span class="p_add">+	pr_info(&quot;Booting paravirtualized kernel on %s\n&quot;, pv_info.name);</span>
 }
 
 /* Undefined instruction for dealing with missing ops pointers. */
<span class="p_header">diff --git a/arch/x86/kernel/pci-calgary_64.c b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">index 833b1d3..f70c79c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_chunk">@@ -998,11 +998,10 @@</span> <span class="p_context"> static void __init calgary_enable_translation(struct pci_dev *dev)</span>
 	val32 = be32_to_cpu(readl(target));
 	val32 |= PHB_TCE_ENABLE | PHB_DAC_DISABLE | PHB_MCSR_ENABLE;
 
<span class="p_del">-	printk(KERN_INFO &quot;Calgary: enabling translation on %s PHB %#x\n&quot;,</span>
<span class="p_del">-	       (dev-&gt;device == PCI_DEVICE_ID_IBM_CALGARY) ?</span>
<span class="p_del">-	       &quot;Calgary&quot; : &quot;CalIOC2&quot;, busnum);</span>
<span class="p_del">-	printk(KERN_INFO &quot;Calgary: errant DMAs will now be prevented on this &quot;</span>
<span class="p_del">-	       &quot;bus.\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Calgary: enabling translation on %s PHB %#x\n&quot;,</span>
<span class="p_add">+		(dev-&gt;device == PCI_DEVICE_ID_IBM_CALGARY) ?</span>
<span class="p_add">+			&quot;Calgary&quot; : &quot;CalIOC2&quot;, busnum);</span>
<span class="p_add">+	pr_info(&quot;Calgary: errant DMAs will now be prevented on this bus.\n&quot;);</span>
 
 	writel(cpu_to_be32(val32), target);
 	readl(target); /* flush */
<span class="p_chunk">@@ -1030,7 +1029,7 @@</span> <span class="p_context"> static void __init calgary_disable_translation(struct pci_dev *dev)</span>
 	val32 = be32_to_cpu(readl(target));
 	val32 &amp;= ~(PHB_TCE_ENABLE | PHB_DAC_DISABLE | PHB_MCSR_ENABLE);
 
<span class="p_del">-	printk(KERN_INFO &quot;Calgary: disabling translation on PHB %#x!\n&quot;, busnum);</span>
<span class="p_add">+	pr_info(&quot;Calgary: disabling translation on PHB %#x!\n&quot;, busnum);</span>
 	writel(cpu_to_be32(val32), target);
 	readl(target); /* flush */
 
<span class="p_chunk">@@ -1359,7 +1358,7 @@</span> <span class="p_context"> static int __init calgary_iommu_init(void)</span>
 	int ret;
 
 	/* ok, we&#39;re trying to use Calgary - let&#39;s roll */
<span class="p_del">-	printk(KERN_INFO &quot;PCI-DMA: Using Calgary IOMMU\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;PCI-DMA: Using Calgary IOMMU\n&quot;);</span>
 
 	ret = calgary_init();
 	if (ret) {
<span class="p_chunk">@@ -1464,9 +1463,9 @@</span> <span class="p_context"> int __init detect_calgary(void)</span>
 	if (calgary_found) {
 		iommu_detected = 1;
 		calgary_detected = 1;
<span class="p_del">-		printk(KERN_INFO &quot;PCI-DMA: Calgary IOMMU detected.\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;PCI-DMA: Calgary TCE table spec is %d\n&quot;,</span>
<span class="p_del">-		       specified_table_size);</span>
<span class="p_add">+		pr_info(&quot;PCI-DMA: Calgary IOMMU detected.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;PCI-DMA: Calgary TCE table spec is %d\n&quot;,</span>
<span class="p_add">+			specified_table_size);</span>
 
 		x86_init.iommu.iommu_init = calgary_iommu_init;
 	}
<span class="p_chunk">@@ -1524,8 +1523,8 @@</span> <span class="p_context"> static int __init calgary_parse_options(char *p)</span>
 
 			bridge = val;
 			if (bridge &lt; MAX_PHB_BUS_NUM) {
<span class="p_del">-				printk(KERN_INFO &quot;Calgary: disabling &quot;</span>
<span class="p_del">-				       &quot;translation for PHB %#x\n&quot;, bridge);</span>
<span class="p_add">+				pr_info(&quot;Calgary: disabling translation for PHB %#x\n&quot;,</span>
<span class="p_add">+					bridge);</span>
 				bus_info[bridge].translation_disabled = 1;
 			}
 		}
<span class="p_header">diff --git a/arch/x86/kernel/pci-swiotlb.c b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">index 7c577a1..2cad97b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_chunk">@@ -112,8 +112,7 @@</span> <span class="p_context"> void __init pci_swiotlb_late_init(void)</span>
 	if (!swiotlb)
 		swiotlb_free();
 	else {
<span class="p_del">-		printk(KERN_INFO &quot;PCI-DMA: &quot;</span>
<span class="p_del">-		       &quot;Using software bounce buffering for IO (SWIOTLB)\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;PCI-DMA: Using software bounce buffering for IO (SWIOTLB)\n&quot;);</span>
 		swiotlb_print_info();
 	}
 }
<span class="p_header">diff --git a/arch/x86/kernel/quirks.c b/arch/x86/kernel/quirks.c</span>
<span class="p_header">index cc457ff..f55715f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/quirks.c</span>
<span class="p_chunk">@@ -177,8 +177,7 @@</span> <span class="p_context"> static struct pci_dev *cached_dev;</span>
 
 static void hpet_print_force_info(void)
 {
<span class="p_del">-	printk(KERN_INFO &quot;HPET not enabled in BIOS. &quot;</span>
<span class="p_del">-	       &quot;You might try hpet=force boot option\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;HPET not enabled in BIOS. You might try hpet=force boot option\n&quot;);</span>
 }
 
 static void old_ich_force_hpet_resume(void)
<span class="p_header">diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c</span>
<span class="p_header">index aa52c10..fddfa48 100644</span>
<span class="p_header">--- a/arch/x86/kernel/setup.c</span>
<span class="p_header">+++ b/arch/x86/kernel/setup.c</span>
<span class="p_chunk">@@ -338,13 +338,12 @@</span> <span class="p_context"> static void __init relocate_initrd(void)</span>
 	memblock_reserve(relocated_ramdisk, area_size);
 	initrd_start = relocated_ramdisk + PAGE_OFFSET;
 	initrd_end   = initrd_start + ramdisk_size;
<span class="p_del">-	printk(KERN_INFO &quot;Allocated new RAMDISK: [mem %#010llx-%#010llx]\n&quot;,</span>
<span class="p_del">-	       relocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);</span>
<span class="p_add">+	pr_info(&quot;Allocated new RAMDISK: [mem %#010llx-%#010llx]\n&quot;,</span>
<span class="p_add">+		relocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);</span>
 
 	copy_from_early_mem((void *)initrd_start, ramdisk_image, ramdisk_size);
 
<span class="p_del">-	printk(KERN_INFO &quot;Move RAMDISK from [mem %#010llx-%#010llx] to&quot;</span>
<span class="p_del">-		&quot; [mem %#010llx-%#010llx]\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Move RAMDISK from [mem %#010llx-%#010llx] to [mem %#010llx-%#010llx]\n&quot;,</span>
 		ramdisk_image, ramdisk_image + ramdisk_size - 1,
 		relocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);
 }
<span class="p_chunk">@@ -382,7 +381,7 @@</span> <span class="p_context"> static void __init reserve_initrd(void)</span>
 		       &quot;disabling initrd (%lld needed, %lld available)\n&quot;,
 		       ramdisk_size, mapped_size&gt;&gt;1);
 
<span class="p_del">-	printk(KERN_INFO &quot;RAMDISK: [mem %#010llx-%#010llx]\n&quot;, ramdisk_image,</span>
<span class="p_add">+	pr_info(&quot;RAMDISK: [mem %#010llx-%#010llx]\n&quot;, ramdisk_image,</span>
 			ramdisk_end - 1);
 
 	if (pfn_range_is_mapped(PFN_DOWN(ramdisk_image),
<span class="p_chunk">@@ -457,7 +456,7 @@</span> <span class="p_context"> static void __init e820_reserve_setup_data(void)</span>
 
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &amp;e820.nr_map);
 	memcpy(&amp;e820_saved, &amp;e820, sizeof(struct e820map));
<span class="p_del">-	printk(KERN_INFO &quot;extended physical RAM map:\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;extended physical RAM map:\n&quot;);</span>
 	e820_print_map(&quot;reserve setup_data&quot;);
 }
 
<span class="p_chunk">@@ -881,7 +880,7 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 	 */
 	__flush_tlb_all();
 #else
<span class="p_del">-	printk(KERN_INFO &quot;Command line: %s\n&quot;, boot_command_line);</span>
<span class="p_add">+	pr_info(&quot;Command line: %s\n&quot;, boot_command_line);</span>
 #endif
 
 	/*
<span class="p_chunk">@@ -1030,7 +1029,7 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 		e820_update_range(0x70000000ULL, 0x40000ULL, E820_RAM,
 				  E820_RESERVED);
 		sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &amp;e820.nr_map);
<span class="p_del">-		printk(KERN_INFO &quot;fixed physical RAM map:\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;fixed physical RAM map:\n&quot;);</span>
 		e820_print_map(&quot;bad_ppro&quot;);
 	}
 #else
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 24d57f7..92fba23 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -692,8 +692,8 @@</span> <span class="p_context"> void smp_announce(void)</span>
 {
 	int num_nodes = num_online_nodes();
 
<span class="p_del">-	printk(KERN_INFO &quot;x86: Booted up %d node%s, %d CPUs\n&quot;,</span>
<span class="p_del">-	       num_nodes, (num_nodes &gt; 1 ? &quot;s&quot; : &quot;&quot;), num_online_cpus());</span>
<span class="p_add">+	pr_info(&quot;x86: Booted up %d node%s, %d CPUs\n&quot;, num_nodes,</span>
<span class="p_add">+		(num_nodes &gt; 1 ? &quot;s&quot; : &quot;&quot;), num_online_cpus());</span>
 }
 
 /* reduce the number of lines printed when booting a large cpu count system */
<span class="p_chunk">@@ -710,7 +710,7 @@</span> <span class="p_context"> static void announce_cpu(int cpu, int apicid)</span>
 		node_width = num_digits(num_possible_nodes()) + 1; /* + &#39;#&#39; */
 
 	if (cpu == 1)
<span class="p_del">-		printk(KERN_INFO &quot;x86: Booting SMP configuration:\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;x86: Booting SMP configuration:\n&quot;);</span>
 
 	if (system_state == SYSTEM_BOOTING) {
 		if (node != current_node) {
<span class="p_chunk">@@ -718,8 +718,8 @@</span> <span class="p_context"> static void announce_cpu(int cpu, int apicid)</span>
 				pr_cont(&quot;\n&quot;);
 			current_node = node;
 
<span class="p_del">-			printk(KERN_INFO &quot;.... node %*s#%d, CPUs:  &quot;,</span>
<span class="p_del">-			       node_width - num_digits(node), &quot; &quot;, node);</span>
<span class="p_add">+			pr_info(&quot;.... node %*s#%d, CPUs:  &quot;,</span>
<span class="p_add">+				node_width - num_digits(node), &quot; &quot;, node);</span>
 		}
 
 		/* Add padding for the BSP */
<span class="p_header">diff --git a/arch/x86/kernel/sysfb_efi.c b/arch/x86/kernel/sysfb_efi.c</span>
<span class="p_header">index b285d4e..c659998 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sysfb_efi.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sysfb_efi.c</span>
<span class="p_chunk">@@ -142,10 +142,9 @@</span> <span class="p_context"> static int __init efifb_set_system(const struct dmi_system_id *id)</span>
 		return 0;
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;efifb: dmi detected %s - framebuffer at 0x%08x &quot;</span>
<span class="p_del">-			 &quot;(%dx%d, stride %d)\n&quot;, id-&gt;ident,</span>
<span class="p_del">-			 screen_info.lfb_base, screen_info.lfb_width,</span>
<span class="p_del">-			 screen_info.lfb_height, screen_info.lfb_linelength);</span>
<span class="p_add">+	pr_info(&quot;efifb: dmi detected %s - framebuffer at 0x%08x (%dx%d, stride %d)\n&quot;,</span>
<span class="p_add">+		id-&gt;ident, screen_info.lfb_base, screen_info.lfb_width,</span>
<span class="p_add">+		screen_info.lfb_height, screen_info.lfb_linelength);</span>
 
 	return 1;
 }
<span class="p_header">diff --git a/arch/x86/kernel/test_nx.c b/arch/x86/kernel/test_nx.c</span>
<span class="p_header">index 3f92ce0..ea4ad45 100644</span>
<span class="p_header">--- a/arch/x86/kernel/test_nx.c</span>
<span class="p_header">+++ b/arch/x86/kernel/test_nx.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> static int test_NX(void)</span>
 
 	test_data = 0xC3;
 
<span class="p_del">-	printk(KERN_INFO &quot;Testing NX protection\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Testing NX protection\n&quot;);</span>
 
 	/* Test 1: check if the stack is not executable */
 	if (test_address(&amp;stackcode)) {
<span class="p_header">diff --git a/arch/x86/kernel/vsmp_64.c b/arch/x86/kernel/vsmp_64.c</span>
<span class="p_header">index b034b1b..0d8b6a7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/vsmp_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/vsmp_64.c</span>
<span class="p_chunk">@@ -97,8 +97,8 @@</span> <span class="p_context"> static void __init set_vsmp_pv_ops(void)</span>
 	address = early_ioremap(cfg, 8);
 	cap = readl(address);
 	ctl = readl(address + 4);
<span class="p_del">-	printk(KERN_INFO &quot;vSMP CTL: capabilities:0x%08x  control:0x%08x\n&quot;,</span>
<span class="p_del">-	       cap, ctl);</span>
<span class="p_add">+	pr_info(&quot;vSMP CTL: capabilities:0x%08x  control:0x%08x\n&quot;,</span>
<span class="p_add">+		cap, ctl);</span>
 
 	/* If possible, let the vSMP foundation route the interrupt optimally */
 #ifdef CONFIG_SMP
<span class="p_header">diff --git a/arch/x86/kvm/assigned-dev.c b/arch/x86/kvm/assigned-dev.c</span>
<span class="p_header">index 9dc091a..80f62f6 100644</span>
<span class="p_header">--- a/arch/x86/kvm/assigned-dev.c</span>
<span class="p_header">+++ b/arch/x86/kvm/assigned-dev.c</span>
<span class="p_chunk">@@ -356,7 +356,7 @@</span> <span class="p_context"> static void kvm_free_assigned_device(struct kvm *kvm,</span>
 	pci_reset_function(assigned_dev-&gt;dev);
 	if (pci_load_and_free_saved_state(assigned_dev-&gt;dev,
 					  &amp;assigned_dev-&gt;pci_saved_state))
<span class="p_del">-		printk(KERN_INFO &quot;%s: Couldn&#39;t reload %s saved state\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;%s: Couldn&#39;t reload %s saved state\n&quot;,</span>
 		       __func__, dev_name(&amp;assigned_dev-&gt;dev-&gt;dev));
 	else
 		pci_restore_state(assigned_dev-&gt;dev);
<span class="p_chunk">@@ -725,8 +725,7 @@</span> <span class="p_context"> static int kvm_vm_ioctl_assign_device(struct kvm *kvm,</span>
 
 	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
 	if (match == NULL) {
<span class="p_del">-		printk(KERN_INFO &quot;%s: Couldn&#39;t allocate memory\n&quot;,</span>
<span class="p_del">-		       __func__);</span>
<span class="p_add">+		pr_info(&quot;%s: Couldn&#39;t allocate memory\n&quot;, __func__);</span>
 		r = -ENOMEM;
 		goto out;
 	}
<span class="p_chunk">@@ -734,7 +733,7 @@</span> <span class="p_context"> static int kvm_vm_ioctl_assign_device(struct kvm *kvm,</span>
 				   assigned_dev-&gt;busnr,
 				   assigned_dev-&gt;devfn);
 	if (!dev) {
<span class="p_del">-		printk(KERN_INFO &quot;%s: host device not found\n&quot;, __func__);</span>
<span class="p_add">+		pr_info(&quot;%s: host device not found\n&quot;, __func__);</span>
 		r = -EINVAL;
 		goto out_free;
 	}
<span class="p_chunk">@@ -750,14 +749,14 @@</span> <span class="p_context"> static int kvm_vm_ioctl_assign_device(struct kvm *kvm,</span>
 		goto out_put;
 
 	if (pci_enable_device(dev)) {
<span class="p_del">-		printk(KERN_INFO &quot;%s: Could not enable PCI device\n&quot;, __func__);</span>
<span class="p_add">+		pr_info(&quot;%s: Could not enable PCI device\n&quot;, __func__);</span>
 		r = -EBUSY;
 		goto out_put;
 	}
 	r = pci_request_regions(dev, &quot;kvm_assigned_device&quot;);
 	if (r) {
<span class="p_del">-		printk(KERN_INFO &quot;%s: Could not get access to device regions\n&quot;,</span>
<span class="p_del">-		       __func__);</span>
<span class="p_add">+		pr_info(&quot;%s: Could not get access to device regions\n&quot;,</span>
<span class="p_add">+			__func__);</span>
 		goto out_disable;
 	}
 
<span class="p_chunk">@@ -800,8 +799,8 @@</span> <span class="p_context"> out:</span>
 	return r;
 out_list_del:
 	if (pci_load_and_free_saved_state(dev, &amp;match-&gt;pci_saved_state))
<span class="p_del">-		printk(KERN_INFO &quot;%s: Couldn&#39;t reload %s saved state\n&quot;,</span>
<span class="p_del">-		       __func__, dev_name(&amp;dev-&gt;dev));</span>
<span class="p_add">+		pr_info(&quot;%s: Couldn&#39;t reload %s saved state\n&quot;, __func__,</span>
<span class="p_add">+			dev_name(&amp;dev-&gt;dev));</span>
 	list_del(&amp;match-&gt;list);
 	pci_release_regions(dev);
 out_disable:
<span class="p_chunk">@@ -826,8 +825,8 @@</span> <span class="p_context"> static int kvm_vm_ioctl_deassign_device(struct kvm *kvm,</span>
 	match = kvm_find_assigned_dev(&amp;kvm-&gt;arch.assigned_dev_head,
 				      assigned_dev-&gt;assigned_dev_id);
 	if (!match) {
<span class="p_del">-		printk(KERN_INFO &quot;%s: device hasn&#39;t been assigned before, &quot;</span>
<span class="p_del">-		  &quot;so cannot be deassigned\n&quot;, __func__);</span>
<span class="p_add">+		pr_info(&quot;%s: device hasn&#39;t been assigned before, so cannot be deassigned\n&quot;,</span>
<span class="p_add">+			__func__);</span>
 		r = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c</span>
<span class="p_header">index 6525e92..0bfd372 100644</span>
<span class="p_header">--- a/arch/x86/kvm/cpuid.c</span>
<span class="p_header">+++ b/arch/x86/kvm/cpuid.c</span>
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> static void cpuid_fix_nx_cap(struct kvm_vcpu *vcpu)</span>
 	}
 	if (entry &amp;&amp; (entry-&gt;edx &amp; F(NX)) &amp;&amp; !is_efer_nx()) {
 		entry-&gt;edx &amp;= ~F(NX);
<span class="p_del">-		printk(KERN_INFO &quot;kvm: guest NX capability removed\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;kvm: guest NX capability removed\n&quot;);</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/irq_comm.c b/arch/x86/kvm/irq_comm.c</span>
<span class="p_header">index 3721736..378f905 100644</span>
<span class="p_header">--- a/arch/x86/kvm/irq_comm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/irq_comm.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,</span>
 
 	if (irq-&gt;dest_mode == 0 &amp;&amp; irq-&gt;dest_id == 0xff &amp;&amp;
 			kvm_lowest_prio_delivery(irq)) {
<span class="p_del">-		printk(KERN_INFO &quot;kvm: apic: phys broadcast and lowest prio\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;kvm: apic: phys broadcast and lowest prio\n&quot;);</span>
 		irq-&gt;delivery_mode = APIC_DM_FIXED;
 	}
 
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 1482a58..b14f151 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -770,8 +770,7 @@</span> <span class="p_context"> bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,</span>
 			 */
 			if (!dst[idx] &amp;&amp; !kvm-&gt;arch.disabled_lapic_found) {
 				kvm-&gt;arch.disabled_lapic_found = true;
<span class="p_del">-				printk(KERN_INFO</span>
<span class="p_del">-					&quot;Disabled LAPIC found during irq injection\n&quot;);</span>
<span class="p_add">+				pr_info(&quot;Disabled LAPIC found during irq injection\n&quot;);</span>
 				goto out;
 			}
 
<span class="p_chunk">@@ -867,8 +866,7 @@</span> <span class="p_context"> bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,</span>
 			dst = map-&gt;logical_map[cid][idx];
 			if (!dst &amp;&amp; !kvm-&gt;arch.disabled_lapic_found) {
 				kvm-&gt;arch.disabled_lapic_found = true;
<span class="p_del">-				printk(KERN_INFO</span>
<span class="p_del">-					&quot;Disabled LAPIC found during irq injection\n&quot;);</span>
<span class="p_add">+				pr_info(&quot;Disabled LAPIC found during irq injection\n&quot;);</span>
 				goto out;
 			}
 
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index c13a64b..fe33b7e 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -621,7 +621,7 @@</span> <span class="p_context"> static int has_svm(void)</span>
 	const char *msg;
 
 	if (!cpu_has_svm(&amp;msg)) {
<span class="p_del">-		printk(KERN_INFO &quot;has_svm: %s\n&quot;, msg);</span>
<span class="p_add">+		pr_info(&quot;has_svm: %s\n&quot;, msg);</span>
 		return 0;
 	}
 
<span class="p_chunk">@@ -899,7 +899,7 @@</span> <span class="p_context"> static __init int svm_hardware_setup(void)</span>
 	}
 
 	if (nested) {
<span class="p_del">-		printk(KERN_INFO &quot;kvm: Nested Virtualization enabled\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;kvm: Nested Virtualization enabled\n&quot;);</span>
 		kvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);
 	}
 
<span class="p_chunk">@@ -913,12 +913,12 @@</span> <span class="p_context"> static __init int svm_hardware_setup(void)</span>
 		npt_enabled = false;
 
 	if (npt_enabled &amp;&amp; !npt) {
<span class="p_del">-		printk(KERN_INFO &quot;kvm: Nested Paging disabled\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;kvm: Nested Paging disabled\n&quot;);</span>
 		npt_enabled = false;
 	}
 
 	if (npt_enabled) {
<span class="p_del">-		printk(KERN_INFO &quot;kvm: Nested Paging enabled\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;kvm: Nested Paging enabled\n&quot;);</span>
 		kvm_enable_tdp();
 	} else
 		kvm_disable_tdp();
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 164eb9e..1b9fcfe 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -10771,9 +10771,8 @@</span> <span class="p_context"> static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,</span>
 			 */
 			ret = irq_set_vcpu_affinity(host_irq, NULL);
 			if (ret &lt; 0) {
<span class="p_del">-				printk(KERN_INFO</span>
<span class="p_del">-				   &quot;failed to back to remapped mode, irq: %u\n&quot;,</span>
<span class="p_del">-				   host_irq);</span>
<span class="p_add">+				pr_info(&quot;failed to back to remapped mode, irq: %u\n&quot;,</span>
<span class="p_add">+					host_irq);</span>
 				goto out;
 			}
 
<span class="p_chunk">@@ -10796,8 +10795,7 @@</span> <span class="p_context"> static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,</span>
 		}
 
 		if (ret &lt; 0) {
<span class="p_del">-			printk(KERN_INFO &quot;%s: failed to update PI IRTE\n&quot;,</span>
<span class="p_del">-					__func__);</span>
<span class="p_add">+			pr_info(&quot;%s: failed to update PI IRTE\n&quot;, __func__);</span>
 			goto out;
 		}
 	}
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index ee3e990..85a4fd8 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -8355,8 +8355,8 @@</span> <span class="p_context"> void kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *cons,</span>
 	*/
 	ret = kvm_x86_ops-&gt;update_pi_irte(irqfd-&gt;kvm, prod-&gt;irq, irqfd-&gt;gsi, 0);
 	if (ret)
<span class="p_del">-		printk(KERN_INFO &quot;irq bypass consumer (token %p) unregistration&quot;</span>
<span class="p_del">-		       &quot; fails: %d\n&quot;, irqfd-&gt;consumer.token, ret);</span>
<span class="p_add">+		pr_info(&quot;irq bypass consumer (token %p) unregistration fails: %d\n&quot;,</span>
<span class="p_add">+			irqfd-&gt;consumer.token, ret);</span>
 }
 
 int kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,
<span class="p_header">diff --git a/arch/x86/lguest/boot.c b/arch/x86/lguest/boot.c</span>
<span class="p_header">index fd57d3a..84c7e29 100644</span>
<span class="p_header">--- a/arch/x86/lguest/boot.c</span>
<span class="p_header">+++ b/arch/x86/lguest/boot.c</span>
<span class="p_chunk">@@ -1304,7 +1304,7 @@</span> <span class="p_context"> static void probe_pci_console(void)</span>
 	}
 
 	console_cfg_offset = device_offset;
<span class="p_del">-	printk(KERN_INFO &quot;lguest: Console via virtio-pci emerg_wr\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;lguest: Console via virtio-pci emerg_wr\n&quot;);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/mm/highmem_32.c b/arch/x86/mm/highmem_32.c</span>
<span class="p_header">index a6d7392..84ec14d 100644</span>
<span class="p_header">--- a/arch/x86/mm/highmem_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/highmem_32.c</span>
<span class="p_chunk">@@ -124,8 +124,8 @@</span> <span class="p_context"> void __init set_highmem_pages_init(void)</span>
 		zone_end_pfn = zone_start_pfn + zone-&gt;spanned_pages;
 
 		nid = zone_to_nid(zone);
<span class="p_del">-		printk(KERN_INFO &quot;Initializing %s for node %d (%08lx:%08lx)\n&quot;,</span>
<span class="p_del">-				zone-&gt;name, nid, zone_start_pfn, zone_end_pfn);</span>
<span class="p_add">+		pr_info(&quot;Initializing %s for node %d (%08lx:%08lx)\n&quot;,</span>
<span class="p_add">+			zone-&gt;name, nid, zone_start_pfn, zone_end_pfn);</span>
 
 		add_highpages_with_active_regions(nid, zone_start_pfn,
 				 zone_end_pfn);
<span class="p_header">diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c</span>
<span class="p_header">index 9d56f27..9ac3701 100644</span>
<span class="p_header">--- a/arch/x86/mm/init.c</span>
<span class="p_header">+++ b/arch/x86/mm/init.c</span>
<span class="p_chunk">@@ -174,7 +174,7 @@</span> <span class="p_context"> static void __init probe_page_size_mask(void)</span>
 
 	/* Enable 1 GB linear kernel mappings if available: */
 	if (direct_gbpages &amp;&amp; cpu_has_gbpages) {
<span class="p_del">-		printk(KERN_INFO &quot;Using GB pages for direct mapping\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Using GB pages for direct mapping\n&quot;);</span>
 		page_size_mask |= 1 &lt;&lt; PG_LEVEL_1G;
 	} else {
 		direct_gbpages = 0;
<span class="p_header">diff --git a/arch/x86/mm/init_32.c b/arch/x86/mm/init_32.c</span>
<span class="p_header">index a4bb1c7..a888792 100644</span>
<span class="p_header">--- a/arch/x86/mm/init_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/init_32.c</span>
<span class="p_chunk">@@ -680,9 +680,9 @@</span> <span class="p_context"> void __init initmem_init(void)</span>
 
 void __init setup_bootmem_allocator(void)
 {
<span class="p_del">-	printk(KERN_INFO &quot;  mapped low ram: 0 - %08lx\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;  mapped low ram: 0 - %08lx\n&quot;,</span>
 		 max_pfn_mapped&lt;&lt;PAGE_SHIFT);
<span class="p_del">-	printk(KERN_INFO &quot;  low ram: 0 - %08lx\n&quot;, max_low_pfn&lt;&lt;PAGE_SHIFT);</span>
<span class="p_add">+	pr_info(&quot;  low ram: 0 - %08lx\n&quot;, max_low_pfn&lt;&lt;PAGE_SHIFT);</span>
 }
 
 /*
<span class="p_chunk">@@ -717,8 +717,7 @@</span> <span class="p_context"> void __init paging_init(void)</span>
  */
 static void __init test_wp_bit(void)
 {
<span class="p_del">-	printk(KERN_INFO</span>
<span class="p_del">-  &quot;Checking if this processor honours the WP bit even in supervisor mode...&quot;);</span>
<span class="p_add">+	pr_info(&quot;Checking if this processor honours the WP bit even in supervisor mode...&quot;);</span>
 
 	/* Any page-aligned address will do, the test is non-destructive */
 	__set_fixmap(FIX_WP_TEST, __pa(&amp;swapper_pg_dir), PAGE_KERNEL_RO);
<span class="p_chunk">@@ -757,7 +756,7 @@</span> <span class="p_context"> void __init mem_init(void)</span>
 	after_bootmem = 1;
 
 	mem_init_print_info(NULL);
<span class="p_del">-	printk(KERN_INFO &quot;virtual kernel memory layout:\n&quot;</span>
<span class="p_add">+	pr_info(&quot;virtual kernel memory layout:\n&quot;</span>
 		&quot;    fixmap  : 0x%08lx - 0x%08lx   (%4ld kB)\n&quot;
 #ifdef CONFIG_HIGHMEM
 		&quot;    pkmap   : 0x%08lx - 0x%08lx   (%4ld kB)\n&quot;
<span class="p_chunk">@@ -915,7 +914,7 @@</span> <span class="p_context"> static void mark_nxdata_nx(void)</span>
 	unsigned long size = (((unsigned long)__init_end + HPAGE_SIZE) &amp; HPAGE_MASK) - start;
 
 	if (__supported_pte_mask &amp; _PAGE_NX)
<span class="p_del">-		printk(KERN_INFO &quot;NX-protecting the kernel data: %luk\n&quot;, size &gt;&gt; 10);</span>
<span class="p_add">+		pr_info(&quot;NX-protecting the kernel data: %luk\n&quot;, size &gt;&gt; 10);</span>
 	set_pages_nx(virt_to_page(start), size &gt;&gt; PAGE_SHIFT);
 }
 
<span class="p_chunk">@@ -925,32 +924,32 @@</span> <span class="p_context"> void mark_rodata_ro(void)</span>
 	unsigned long size = PFN_ALIGN(_etext) - start;
 
 	set_pages_ro(virt_to_page(start), size &gt;&gt; PAGE_SHIFT);
<span class="p_del">-	printk(KERN_INFO &quot;Write protecting the kernel text: %luk\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Write protecting the kernel text: %luk\n&quot;,</span>
 		size &gt;&gt; 10);
 
 	kernel_set_to_readonly = 1;
 
 #ifdef CONFIG_CPA_DEBUG
<span class="p_del">-	printk(KERN_INFO &quot;Testing CPA: Reverting %lx-%lx\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Testing CPA: Reverting %lx-%lx\n&quot;,</span>
 		start, start+size);
 	set_pages_rw(virt_to_page(start), size&gt;&gt;PAGE_SHIFT);
 
<span class="p_del">-	printk(KERN_INFO &quot;Testing CPA: write protecting again\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Testing CPA: write protecting again\n&quot;);</span>
 	set_pages_ro(virt_to_page(start), size&gt;&gt;PAGE_SHIFT);
 #endif
 
 	start += size;
 	size = (unsigned long)__end_rodata - start;
 	set_pages_ro(virt_to_page(start), size &gt;&gt; PAGE_SHIFT);
<span class="p_del">-	printk(KERN_INFO &quot;Write protecting the kernel read-only data: %luk\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Write protecting the kernel read-only data: %luk\n&quot;,</span>
 		size &gt;&gt; 10);
 	rodata_test();
 
 #ifdef CONFIG_CPA_DEBUG
<span class="p_del">-	printk(KERN_INFO &quot;Testing CPA: undo %lx-%lx\n&quot;, start, start + size);</span>
<span class="p_add">+	pr_info(&quot;Testing CPA: undo %lx-%lx\n&quot;, start, start + size);</span>
 	set_pages_rw(virt_to_page(start), size &gt;&gt; PAGE_SHIFT);
 
<span class="p_del">-	printk(KERN_INFO &quot;Testing CPA: write protecting again\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Testing CPA: write protecting again\n&quot;);</span>
 	set_pages_ro(virt_to_page(start), size &gt;&gt; PAGE_SHIFT);
 #endif
 	mark_nxdata_nx();
<span class="p_header">diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c</span>
<span class="p_header">index 9686535..bcc8873 100644</span>
<span class="p_header">--- a/arch/x86/mm/init_64.c</span>
<span class="p_header">+++ b/arch/x86/mm/init_64.c</span>
<span class="p_chunk">@@ -1126,8 +1126,8 @@</span> <span class="p_context"> void mark_rodata_ro(void)</span>
 	unsigned long rodata_end = PFN_ALIGN(&amp;__end_rodata);
 	unsigned long all_end;
 
<span class="p_del">-	printk(KERN_INFO &quot;Write protecting the kernel read-only data: %luk\n&quot;,</span>
<span class="p_del">-	       (end - start) &gt;&gt; 10);</span>
<span class="p_add">+	pr_info(&quot;Write protecting the kernel read-only data: %luk\n&quot;,</span>
<span class="p_add">+		(end - start) &gt;&gt; 10);</span>
 	set_memory_ro(start, (end - start) &gt;&gt; PAGE_SHIFT);
 
 	kernel_set_to_readonly = 1;
<span class="p_chunk">@@ -1150,10 +1150,10 @@</span> <span class="p_context"> void mark_rodata_ro(void)</span>
 	rodata_test();
 
 #ifdef CONFIG_CPA_DEBUG
<span class="p_del">-	printk(KERN_INFO &quot;Testing CPA: undo %lx-%lx\n&quot;, start, end);</span>
<span class="p_add">+	pr_info(&quot;Testing CPA: undo %lx-%lx\n&quot;, start, end);</span>
 	set_memory_rw(start, (end-start) &gt;&gt; PAGE_SHIFT);
 
<span class="p_del">-	printk(KERN_INFO &quot;Testing CPA: again\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Testing CPA: again\n&quot;);</span>
 	set_memory_ro(start, (end-start) &gt;&gt; PAGE_SHIFT);
 #endif
 
<span class="p_header">diff --git a/arch/x86/mm/kmemcheck/kmemcheck.c b/arch/x86/mm/kmemcheck/kmemcheck.c</span>
<span class="p_header">index b4f2e7e..018e1fa 100644</span>
<span class="p_header">--- a/arch/x86/mm/kmemcheck/kmemcheck.c</span>
<span class="p_header">+++ b/arch/x86/mm/kmemcheck/kmemcheck.c</span>
<span class="p_chunk">@@ -55,19 +55,18 @@</span> <span class="p_context"> int __init kmemcheck_init(void)</span>
 	 * runs before SMP is set up.
 	 */
 	if (setup_max_cpus &gt; 1) {
<span class="p_del">-		printk(KERN_INFO</span>
<span class="p_del">-			&quot;kmemcheck: Limiting number of CPUs to 1.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;kmemcheck: Limiting number of CPUs to 1.\n&quot;);</span>
 		setup_max_cpus = 1;
 	}
 #endif
 
 	if (!kmemcheck_selftest()) {
<span class="p_del">-		printk(KERN_INFO &quot;kmemcheck: self-tests failed; disabling\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;kmemcheck: self-tests failed; disabling\n&quot;);</span>
 		kmemcheck_enabled = 0;
 		return -EINVAL;
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;kmemcheck: Initialized\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;kmemcheck: Initialized\n&quot;);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/x86/mm/numa.c b/arch/x86/mm/numa.c</span>
<span class="p_header">index f70c1ff..a2cd371 100644</span>
<span class="p_header">--- a/arch/x86/mm/numa.c</span>
<span class="p_header">+++ b/arch/x86/mm/numa.c</span>
<span class="p_chunk">@@ -210,11 +210,11 @@</span> <span class="p_context"> static void __init alloc_node_data(int nid)</span>
 	nd = __va(nd_pa);
 
 	/* report and initialize */
<span class="p_del">-	printk(KERN_INFO &quot;NODE_DATA(%d) allocated [mem %#010Lx-%#010Lx]\n&quot;, nid,</span>
<span class="p_add">+	pr_info(&quot;NODE_DATA(%d) allocated [mem %#010Lx-%#010Lx]\n&quot;, nid,</span>
 	       nd_pa, nd_pa + nd_size - 1);
 	tnid = early_pfn_to_nid(nd_pa &gt;&gt; PAGE_SHIFT);
 	if (tnid != nid)
<span class="p_del">-		printk(KERN_INFO &quot;    NODE_DATA(%d) on node %d\n&quot;, nid, tnid);</span>
<span class="p_add">+		pr_info(&quot;    NODE_DATA(%d) on node %d\n&quot;, nid, tnid);</span>
 
 	node_data[nid] = nd;
 	memset(NODE_DATA(nid), 0, sizeof(pg_data_t));
<span class="p_chunk">@@ -297,7 +297,7 @@</span> <span class="p_context"> int __init numa_cleanup_meminfo(struct numa_meminfo *mi)</span>
 			}
 			if (k &lt; mi-&gt;nr_blks)
 				continue;
<span class="p_del">-			printk(KERN_INFO &quot;NUMA: Node %d [mem %#010Lx-%#010Lx] + [mem %#010Lx-%#010Lx] -&gt; [mem %#010Lx-%#010Lx]\n&quot;,</span>
<span class="p_add">+			pr_info(&quot;NUMA: Node %d [mem %#010Lx-%#010Lx] + [mem %#010Lx-%#010Lx] -&gt; [mem %#010Lx-%#010Lx]\n&quot;,</span>
 			       bi-&gt;nid, bi-&gt;start, bi-&gt;end - 1, bj-&gt;start,
 			       bj-&gt;end - 1, start, end - 1);
 			bi-&gt;start = start;
<span class="p_chunk">@@ -691,10 +691,10 @@</span> <span class="p_context"> static int __init numa_init(int (*init_func)(void))</span>
  */
 static int __init dummy_numa_init(void)
 {
<span class="p_del">-	printk(KERN_INFO &quot;%s\n&quot;,</span>
<span class="p_del">-	       numa_off ? &quot;NUMA turned off&quot; : &quot;No NUMA configuration found&quot;);</span>
<span class="p_del">-	printk(KERN_INFO &quot;Faking a node at [mem %#018Lx-%#018Lx]\n&quot;,</span>
<span class="p_del">-	       0LLU, PFN_PHYS(max_pfn) - 1);</span>
<span class="p_add">+	pr_info(&quot;%s\n&quot;, numa_off ?</span>
<span class="p_add">+			&quot;NUMA turned off&quot; : &quot;No NUMA configuration found&quot;);</span>
<span class="p_add">+	pr_info(&quot;Faking a node at [mem %#018Lx-%#018Lx]\n&quot;,</span>
<span class="p_add">+		0LLU, PFN_PHYS(max_pfn) - 1);</span>
 
 	node_set(0, numa_nodes_parsed);
 	numa_add_memblk(0, 0, PFN_PHYS(max_pfn));
<span class="p_header">diff --git a/arch/x86/mm/numa_32.c b/arch/x86/mm/numa_32.c</span>
<span class="p_header">index 47b6436..2fe137c 100644</span>
<span class="p_header">--- a/arch/x86/mm/numa_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/numa_32.c</span>
<span class="p_chunk">@@ -48,8 +48,7 @@</span> <span class="p_context"> void memory_present(int nid, unsigned long start, unsigned long end)</span>
 {
 	unsigned long pfn;
 
<span class="p_del">-	printk(KERN_INFO &quot;Node: %d, start_pfn: %lx, end_pfn: %lx\n&quot;,</span>
<span class="p_del">-			nid, start, end);</span>
<span class="p_add">+	pr_info(&quot;Node: %d, start_pfn: %lx, end_pfn: %lx\n&quot;, nid, start, end);</span>
 	printk(KERN_DEBUG &quot;  Setting physnode_map array to node %d for pfns:\n&quot;, nid);
 	printk(KERN_DEBUG &quot;  &quot;);
 	start = round_down(start, PAGES_PER_SECTION);
<span class="p_header">diff --git a/arch/x86/mm/numa_emulation.c b/arch/x86/mm/numa_emulation.c</span>
<span class="p_header">index a8f90ce..6465356 100644</span>
<span class="p_header">--- a/arch/x86/mm/numa_emulation.c</span>
<span class="p_header">+++ b/arch/x86/mm/numa_emulation.c</span>
<span class="p_chunk">@@ -68,8 +68,8 @@</span> <span class="p_context"> static int __init emu_setup_memblk(struct numa_meminfo *ei,</span>
 		numa_remove_memblk_from(phys_blk, pi);
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;Faking node %d at [mem %#018Lx-%#018Lx] (%LuMB)\n&quot;,</span>
<span class="p_del">-	       nid, eb-&gt;start, eb-&gt;end - 1, (eb-&gt;end - eb-&gt;start) &gt;&gt; 20);</span>
<span class="p_add">+	pr_info(&quot;Faking node %d at [mem %#018llx-%#018llx] (%lluMB)\n&quot;,</span>
<span class="p_add">+		nid, eb-&gt;start, eb-&gt;end - 1, (eb-&gt;end - eb-&gt;start) &gt;&gt; 20);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/x86/mm/pageattr-test.c b/arch/x86/mm/pageattr-test.c</span>
<span class="p_header">index 5f169d5..d70f73f 100644</span>
<span class="p_header">--- a/arch/x86/mm/pageattr-test.c</span>
<span class="p_header">+++ b/arch/x86/mm/pageattr-test.c</span>
<span class="p_chunk">@@ -90,8 +90,7 @@</span> <span class="p_context"> static int print_split(struct split_state *s)</span>
 		}
 	}
 	if (print) {
<span class="p_del">-		printk(KERN_INFO</span>
<span class="p_del">-			&quot; 4k %lu large %lu gb %lu x %lu[%lx-%lx] miss %lu\n&quot;,</span>
<span class="p_add">+		pr_info(&quot; 4k %lu large %lu gb %lu x %lu[%lx-%lx] miss %lu\n&quot;,</span>
 			s-&gt;spg, s-&gt;lpg, s-&gt;gpg, s-&gt;exec,
 			s-&gt;min_exec != ~0UL ? s-&gt;min_exec : 0,
 			s-&gt;max_exec, missed);
<span class="p_chunk">@@ -122,7 +121,7 @@</span> <span class="p_context"> static int pageattr_test(void)</span>
 	unsigned long test_addr;
 
 	if (print)
<span class="p_del">-		printk(KERN_INFO &quot;CPA self-test:\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;CPA self-test:\n&quot;);</span>
 
 	bm = vzalloc((max_pfn_mapped + 7) / 8);
 	if (!bm) {
<span class="p_chunk">@@ -227,7 +226,7 @@</span> <span class="p_context"> static int pageattr_test(void)</span>
 		return -EINVAL;
 	} else {
 		if (print)
<span class="p_del">-			printk(KERN_INFO &quot;ok.\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;ok.\n&quot;);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/arch/x86/mm/pgtable.c b/arch/x86/mm/pgtable.c</span>
<span class="p_header">index 4eb287e..d06ed8f 100644</span>
<span class="p_header">--- a/arch/x86/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/x86/mm/pgtable.c</span>
<span class="p_chunk">@@ -519,8 +519,8 @@</span> <span class="p_context"> void __init reserve_top_address(unsigned long reserve)</span>
 #ifdef CONFIG_X86_32
 	BUG_ON(fixmaps_set &gt; 0);
 	__FIXADDR_TOP = round_down(-reserve, 1 &lt;&lt; PMD_SHIFT) - PAGE_SIZE;
<span class="p_del">-	printk(KERN_INFO &quot;Reserving virtual address space above 0x%08lx (rounded to 0x%08lx)\n&quot;,</span>
<span class="p_del">-	       -reserve, __FIXADDR_TOP + PAGE_SIZE);</span>
<span class="p_add">+	pr_info(&quot;Reserving virtual address space above 0x%08lx (rounded to 0x%08lx)\n&quot;,</span>
<span class="p_add">+		-reserve, __FIXADDR_TOP + PAGE_SIZE);</span>
 #endif
 }
 
<span class="p_header">diff --git a/arch/x86/mm/setup_nx.c b/arch/x86/mm/setup_nx.c</span>
<span class="p_header">index 8bea847..4968790 100644</span>
<span class="p_header">--- a/arch/x86/mm/setup_nx.c</span>
<span class="p_header">+++ b/arch/x86/mm/setup_nx.c</span>
<span class="p_chunk">@@ -45,11 +45,9 @@</span> <span class="p_context"> void __init x86_report_nx(void)</span>
 	} else {
 #if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)
 		if (disable_nx) {
<span class="p_del">-			printk(KERN_INFO &quot;NX (Execute Disable) protection: &quot;</span>
<span class="p_del">-			       &quot;disabled by kernel command line option\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;NX (Execute Disable) protection: disabled by kernel command line option\n&quot;);</span>
 		} else {
<span class="p_del">-			printk(KERN_INFO &quot;NX (Execute Disable) protection: &quot;</span>
<span class="p_del">-			       &quot;active\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;NX (Execute Disable) protection: active\n&quot;);</span>
 		}
 #else
 		/* 32bit non-PAE kernel, NX cannot be used */
<span class="p_header">diff --git a/arch/x86/mm/srat.c b/arch/x86/mm/srat.c</span>
<span class="p_header">index b5f8218..0840092 100644</span>
<span class="p_header">--- a/arch/x86/mm/srat.c</span>
<span class="p_header">+++ b/arch/x86/mm/srat.c</span>
<span class="p_chunk">@@ -87,8 +87,8 @@</span> <span class="p_context"> acpi_numa_x2apic_affinity_init(struct acpi_srat_x2apic_cpu_affinity *pa)</span>
 	pxm = pa-&gt;proximity_domain;
 	apic_id = pa-&gt;apic_id;
 	if (!apic-&gt;apic_id_valid(apic_id)) {
<span class="p_del">-		printk(KERN_INFO &quot;SRAT: PXM %u -&gt; X2APIC 0x%04x ignored\n&quot;,</span>
<span class="p_del">-			 pxm, apic_id);</span>
<span class="p_add">+		pr_info(&quot;SRAT: PXM %u -&gt; X2APIC 0x%04x ignored\n&quot;,</span>
<span class="p_add">+			pxm, apic_id);</span>
 		return;
 	}
 	node = setup_node(pxm);
<span class="p_chunk">@@ -99,14 +99,15 @@</span> <span class="p_context"> acpi_numa_x2apic_affinity_init(struct acpi_srat_x2apic_cpu_affinity *pa)</span>
 	}
 
 	if (apic_id &gt;= MAX_LOCAL_APIC) {
<span class="p_del">-		printk(KERN_INFO &quot;SRAT: PXM %u -&gt; APIC 0x%04x -&gt; Node %u skipped apicid that is too big\n&quot;, pxm, apic_id, node);</span>
<span class="p_add">+		pr_info(&quot;SRAT: PXM %u -&gt; APIC 0x%04x -&gt; Node %u skipped apicid that is too big\n&quot;,</span>
<span class="p_add">+			pxm, apic_id, node);</span>
 		return;
 	}
 	set_apicid_to_node(apic_id, node);
 	node_set(node, numa_nodes_parsed);
 	acpi_numa = 1;
<span class="p_del">-	printk(KERN_INFO &quot;SRAT: PXM %u -&gt; APIC 0x%04x -&gt; Node %u\n&quot;,</span>
<span class="p_del">-	       pxm, apic_id, node);</span>
<span class="p_add">+	pr_info(&quot;SRAT: PXM %u -&gt; APIC 0x%04x -&gt; Node %u\n&quot;,</span>
<span class="p_add">+		pxm, apic_id, node);</span>
 }
 
 /* Callback for Proximity Domain -&gt; LAPIC mapping */
<span class="p_chunk">@@ -140,15 +141,15 @@</span> <span class="p_context"> acpi_numa_processor_affinity_init(struct acpi_srat_cpu_affinity *pa)</span>
 		apic_id = pa-&gt;apic_id;
 
 	if (apic_id &gt;= MAX_LOCAL_APIC) {
<span class="p_del">-		printk(KERN_INFO &quot;SRAT: PXM %u -&gt; APIC 0x%02x -&gt; Node %u skipped apicid that is too big\n&quot;, pxm, apic_id, node);</span>
<span class="p_add">+		pr_info(&quot;SRAT: PXM %u -&gt; APIC 0x%02x -&gt; Node %u skipped apicid that is too big\n&quot;,</span>
<span class="p_add">+			pxm, apic_id, node);</span>
 		return;
 	}
 
 	set_apicid_to_node(apic_id, node);
 	node_set(node, numa_nodes_parsed);
 	acpi_numa = 1;
<span class="p_del">-	printk(KERN_INFO &quot;SRAT: PXM %u -&gt; APIC 0x%02x -&gt; Node %u\n&quot;,</span>
<span class="p_del">-	       pxm, apic_id, node);</span>
<span class="p_add">+	pr_info(&quot;SRAT: PXM %u -&gt; APIC 0x%02x -&gt; Node %u\n&quot;, pxm, apic_id, node);</span>
 }
 
 #ifdef CONFIG_MEMORY_HOTPLUG
<span class="p_header">diff --git a/arch/x86/oprofile/nmi_int.c b/arch/x86/oprofile/nmi_int.c</span>
<span class="p_header">index 1d2e639..24634ed 100644</span>
<span class="p_header">--- a/arch/x86/oprofile/nmi_int.c</span>
<span class="p_header">+++ b/arch/x86/oprofile/nmi_int.c</span>
<span class="p_chunk">@@ -601,8 +601,8 @@</span> <span class="p_context"> static int __init p4_init(char **cpu_type)</span>
 	}
 #endif
 
<span class="p_del">-	printk(KERN_INFO &quot;oprofile: P4 HyperThreading detected with &gt; 2 threads\n&quot;);</span>
<span class="p_del">-	printk(KERN_INFO &quot;oprofile: Reverting to timer mode.\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;oprofile: P4 HyperThreading detected with &gt; 2 threads\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;oprofile: Reverting to timer mode.\n&quot;);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -618,10 +618,10 @@</span> <span class="p_context"> static int set_cpu_type(const char *str, struct kernel_param *kp)</span>
 {
 	if (!strcmp(str, &quot;timer&quot;)) {
 		force_cpu_type = timer;
<span class="p_del">-		printk(KERN_INFO &quot;oprofile: forcing NMI timer mode\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;oprofile: forcing NMI timer mode\n&quot;);</span>
 	} else if (!strcmp(str, &quot;arch_perfmon&quot;)) {
 		force_cpu_type = arch_perfmon;
<span class="p_del">-		printk(KERN_INFO &quot;oprofile: forcing architectural perfmon\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;oprofile: forcing architectural perfmon\n&quot;);</span>
 	} else {
 		force_cpu_type = 0;
 	}
<span class="p_chunk">@@ -792,7 +792,7 @@</span> <span class="p_context"> int __init op_nmi_init(struct oprofile_operations *ops)</span>
 
 	init_suspend_resume();
 
<span class="p_del">-	printk(KERN_INFO &quot;oprofile: using NMI interrupt.\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;oprofile: using NMI interrupt.\n&quot;);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/x86/oprofile/op_model_amd.c b/arch/x86/oprofile/op_model_amd.c</span>
<span class="p_header">index 660a83c..b661690 100644</span>
<span class="p_header">--- a/arch/x86/oprofile/op_model_amd.c</span>
<span class="p_header">+++ b/arch/x86/oprofile/op_model_amd.c</span>
<span class="p_chunk">@@ -450,7 +450,7 @@</span> <span class="p_context"> static void init_ibs(void)</span>
 	if (!ibs_caps)
 		return;
 
<span class="p_del">-	printk(KERN_INFO &quot;oprofile: AMD IBS detected (0x%08x)\n&quot;, ibs_caps);</span>
<span class="p_add">+	pr_info(&quot;oprofile: AMD IBS detected (0x%08x)\n&quot;, ibs_caps);</span>
 }
 
 static int (*create_arch_files)(struct dentry *root);
<span class="p_header">diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c</span>
<span class="p_header">index 3cd6983..a9e6b75 100644</span>
<span class="p_header">--- a/arch/x86/pci/acpi.c</span>
<span class="p_header">+++ b/arch/x86/pci/acpi.c</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> static int __init set_nouse_crs(const struct dmi_system_id *id)</span>
 
 static int __init set_ignore_seg(const struct dmi_system_id *id)
 {
<span class="p_del">-	printk(KERN_INFO &quot;PCI: %s detected: ignoring ACPI _SEG\n&quot;, id-&gt;ident);</span>
<span class="p_add">+	pr_info(&quot;PCI: %s detected: ignoring ACPI _SEG\n&quot;, id-&gt;ident);</span>
 	pci_ignore_seg = true;
 	return 0;
 }
<span class="p_chunk">@@ -147,10 +147,9 @@</span> <span class="p_context"> void __init pci_acpi_crs_quirks(void)</span>
 	else if (pci_probe &amp; PCI_USE__CRS)
 		pci_use_crs = true;
 
<span class="p_del">-	printk(KERN_INFO &quot;PCI: %s host bridge windows from ACPI; &quot;</span>
<span class="p_del">-	       &quot;if necessary, use \&quot;pci=%s\&quot; and report a bug\n&quot;,</span>
<span class="p_del">-	       pci_use_crs ? &quot;Using&quot; : &quot;Ignoring&quot;,</span>
<span class="p_del">-	       pci_use_crs ? &quot;nocrs&quot; : &quot;use_crs&quot;);</span>
<span class="p_add">+	pr_info(&quot;PCI: %s host bridge windows from ACPI; if necessary, use \&quot;pci=%s\&quot; and report a bug\n&quot;,</span>
<span class="p_add">+		pci_use_crs ? &quot;Using&quot; : &quot;Ignoring&quot;,</span>
<span class="p_add">+		pci_use_crs ? &quot;nocrs&quot; : &quot;use_crs&quot;);</span>
 }
 
 #ifdef	CONFIG_PCI_MMCONFIG
<span class="p_chunk">@@ -395,7 +394,7 @@</span> <span class="p_context"> int __init pci_acpi_init(void)</span>
 	if (acpi_noirq)
 		return -ENODEV;
 
<span class="p_del">-	printk(KERN_INFO &quot;PCI: Using ACPI for IRQ routing\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;PCI: Using ACPI for IRQ routing\n&quot;);</span>
 	acpi_irq_penalty_init();
 	pcibios_enable_irq = acpi_pci_irq_enable;
 	pcibios_disable_irq = acpi_pci_irq_disable;
<span class="p_chunk">@@ -407,7 +406,7 @@</span> <span class="p_context"> int __init pci_acpi_init(void)</span>
 		 * also do it here in case there are still broken drivers that
 		 * don&#39;t use pci_enable_device().
 		 */
<span class="p_del">-		printk(KERN_INFO &quot;PCI: Routing PCI interrupts for all devices because \&quot;pci=routeirq\&quot; specified\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;PCI: Routing PCI interrupts for all devices because \&quot;pci=routeirq\&quot; specified\n&quot;);</span>
 		for_each_pci_dev(dev)
 			acpi_pci_irq_enable(dev);
 	}
<span class="p_header">diff --git a/arch/x86/pci/amd_bus.c b/arch/x86/pci/amd_bus.c</span>
<span class="p_header">index c20d2cc..bbdae89 100644</span>
<span class="p_header">--- a/arch/x86/pci/amd_bus.c</span>
<span class="p_header">+++ b/arch/x86/pci/amd_bus.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> static int __init early_root_info_init(void)</span>
 	address = MSR_K8_TOP_MEM1;
 	rdmsrl(address, val);
 	end = (val &amp; 0xffffff800000ULL);
<span class="p_del">-	printk(KERN_INFO &quot;TOM: %016llx aka %lldM\n&quot;, end, end&gt;&gt;20);</span>
<span class="p_add">+	pr_info(&quot;TOM: %016llx aka %lldM\n&quot;, end, end&gt;&gt;20);</span>
 	if (end &lt; (1ULL&lt;&lt;32))
 		subtract_range(range, RANGE_NUM, 0, end);
 
<span class="p_chunk">@@ -290,7 +290,7 @@</span> <span class="p_context"> static int __init early_root_info_init(void)</span>
 		address = MSR_K8_TOP_MEM2;
 		rdmsrl(address, val);
 		end = (val &amp; 0xffffff800000ULL);
<span class="p_del">-		printk(KERN_INFO &quot;TOM2: %016llx aka %lldM\n&quot;, end, end&gt;&gt;20);</span>
<span class="p_add">+		pr_info(&quot;TOM2: %016llx aka %lldM\n&quot;, end, end&gt;&gt;20);</span>
 		subtract_range(range, RANGE_NUM, 1ULL&lt;&lt;32, end);
 	}
 
<span class="p_header">diff --git a/arch/x86/pci/broadcom_bus.c b/arch/x86/pci/broadcom_bus.c</span>
<span class="p_header">index bb461cf..b5c97fe 100644</span>
<span class="p_header">--- a/arch/x86/pci/broadcom_bus.c</span>
<span class="p_header">+++ b/arch/x86/pci/broadcom_bus.c</span>
<span class="p_chunk">@@ -80,10 +80,10 @@</span> <span class="p_context"> static void __init cnb20le_res(u8 bus, u8 slot, u8 func)</span>
 	res.start = fbus;
 	res.end   = lbus;
 	res.flags = IORESOURCE_BUS;
<span class="p_del">-	printk(KERN_INFO &quot;CNB20LE PCI Host Bridge (domain 0000 %pR)\n&quot;, &amp;res);</span>
<span class="p_add">+	pr_info(&quot;CNB20LE PCI Host Bridge (domain 0000 %pR)\n&quot;, &amp;res);</span>
 
 	list_for_each_entry(root_res, &amp;info-&gt;resources, list)
<span class="p_del">-		printk(KERN_INFO &quot;host bridge window %pR\n&quot;, &amp;root_res-&gt;res);</span>
<span class="p_add">+		pr_info(&quot;host bridge window %pR\n&quot;, &amp;root_res-&gt;res);</span>
 }
 
 static int __init broadcom_postcore_init(void)
<span class="p_header">diff --git a/arch/x86/pci/common.c b/arch/x86/pci/common.c</span>
<span class="p_header">index 381a43c..340c824 100644</span>
<span class="p_header">--- a/arch/x86/pci/common.c</span>
<span class="p_header">+++ b/arch/x86/pci/common.c</span>
<span class="p_chunk">@@ -83,7 +83,7 @@</span> <span class="p_context"> DEFINE_RAW_SPINLOCK(pci_config_lock);</span>
 static int __init can_skip_ioresource_align(const struct dmi_system_id *d)
 {
 	pci_probe |= PCI_CAN_SKIP_ISA_ALIGN;
<span class="p_del">-	printk(KERN_INFO &quot;PCI: %s detected, can skip ISA alignment\n&quot;, d-&gt;ident);</span>
<span class="p_add">+	pr_info(&quot;PCI: %s detected, can skip ISA alignment\n&quot;, d-&gt;ident);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -189,7 +189,7 @@</span> <span class="p_context"> static int __init set_bf_sort(const struct dmi_system_id *d)</span>
 {
 	if (pci_bf_sort == pci_bf_sort_default) {
 		pci_bf_sort = pci_dmi_bf;
<span class="p_del">-		printk(KERN_INFO &quot;PCI: %s detected, enabling pci=bfsort.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;PCI: %s detected, enabling pci=bfsort.\n&quot;, d-&gt;ident);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -203,7 +203,7 @@</span> <span class="p_context"> static void __init read_dmi_type_b1(const struct dmi_header *dm,</span>
 		return;
 	switch (((*(u32 *)d) &gt;&gt; 9) &amp; 0x03) {
 	case 0x00:
<span class="p_del">-		printk(KERN_INFO &quot;dmi type 0xB1 record - unknown flag\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;dmi type 0xB1 record - unknown flag\n&quot;);</span>
 		break;
 	case 0x01: /* set pci=bfsort */
 		smbios_type_b1_flag = 1;
<span class="p_chunk">@@ -234,16 +234,16 @@</span> <span class="p_context"> static int __init find_sort_method(const struct dmi_system_id *d)</span>
 static int __init assign_all_busses(const struct dmi_system_id *d)
 {
 	pci_probe |= PCI_ASSIGN_ALL_BUSSES;
<span class="p_del">-	printk(KERN_INFO &quot;%s detected: enabling PCI bus# renumbering&quot;</span>
<span class="p_del">-			&quot; (pci=assign-busses)\n&quot;, d-&gt;ident);</span>
<span class="p_add">+	pr_info(&quot;%s detected: enabling PCI bus# renumbering (pci=assign-busses)\n&quot;,</span>
<span class="p_add">+		d-&gt;ident);</span>
 	return 0;
 }
 #endif
 
 static int __init set_scan_all(const struct dmi_system_id *d)
 {
<span class="p_del">-	printk(KERN_INFO &quot;PCI: %s detected, enabling pci=pcie_scan_all\n&quot;,</span>
<span class="p_del">-	       d-&gt;ident);</span>
<span class="p_add">+	pr_info(&quot;PCI: %s detected, enabling pci=pcie_scan_all\n&quot;,</span>
<span class="p_add">+		d-&gt;ident);</span>
 	pci_add_flags(PCI_SCAN_ALL_PCIE_DEVS);
 	return 0;
 }
<span class="p_header">diff --git a/arch/x86/pci/direct.c b/arch/x86/pci/direct.c</span>
<span class="p_header">index 1546059..dd7acdc 100644</span>
<span class="p_header">--- a/arch/x86/pci/direct.c</span>
<span class="p_header">+++ b/arch/x86/pci/direct.c</span>
<span class="p_chunk">@@ -264,16 +264,14 @@</span> <span class="p_context"> void __init pci_direct_init(int type)</span>
 {
 	if (type == 0)
 		return;
<span class="p_del">-	printk(KERN_INFO &quot;PCI: Using configuration type %d for base access\n&quot;,</span>
<span class="p_del">-		 type);</span>
<span class="p_add">+	pr_info(&quot;PCI: Using configuration type %d for base access\n&quot;, type);</span>
 	if (type == 1) {
 		raw_pci_ops = &amp;pci_direct_conf1;
 		if (raw_pci_ext_ops)
 			return;
 		if (!(pci_probe &amp; PCI_HAS_IO_ECS))
 			return;
<span class="p_del">-		printk(KERN_INFO &quot;PCI: Using configuration type 1 &quot;</span>
<span class="p_del">-		       &quot;for extended access\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;PCI: Using configuration type 1 for extended access\n&quot;);</span>
 		raw_pci_ext_ops = &amp;pci_direct_conf1;
 		return;
 	}
<span class="p_header">diff --git a/arch/x86/pci/early.c b/arch/x86/pci/early.c</span>
<span class="p_header">index d1067d5..ec75ebc 100644</span>
<span class="p_header">--- a/arch/x86/pci/early.c</span>
<span class="p_header">+++ b/arch/x86/pci/early.c</span>
<span class="p_chunk">@@ -62,8 +62,7 @@</span> <span class="p_context"> void early_dump_pci_device(u8 bus, u8 slot, u8 func)</span>
 	int j;
 	u32 val;
 
<span class="p_del">-	printk(KERN_INFO &quot;pci 0000:%02x:%02x.%d config space:&quot;,</span>
<span class="p_del">-	       bus, slot, func);</span>
<span class="p_add">+	pr_info(&quot;pci 0000:%02x:%02x.%d config space:&quot;, bus, slot, func);</span>
 
 	for (i = 0; i &lt; 256; i += 4) {
 		if (!(i &amp; 0x0f))
<span class="p_header">diff --git a/arch/x86/pci/irq.c b/arch/x86/pci/irq.c</span>
<span class="p_header">index 9bd1154..372f149 100644</span>
<span class="p_header">--- a/arch/x86/pci/irq.c</span>
<span class="p_header">+++ b/arch/x86/pci/irq.c</span>
<span class="p_chunk">@@ -823,7 +823,7 @@</span> <span class="p_context"> static void __init pirq_find_router(struct irq_router *r)</span>
 
 #ifdef CONFIG_PCI_BIOS
 	if (!rt-&gt;signature) {
<span class="p_del">-		printk(KERN_INFO &quot;PCI: Using BIOS for IRQ routing\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;PCI: Using BIOS for IRQ routing\n&quot;);</span>
 		r-&gt;set = pirq_bios_set;
 		r-&gt;name = &quot;BIOS&quot;;
 		return;
<span class="p_chunk">@@ -1072,7 +1072,7 @@</span> <span class="p_context"> static int __init fix_broken_hp_bios_irq9(const struct dmi_system_id *d)</span>
 {
 	if (!broken_hp_bios_irq9) {
 		broken_hp_bios_irq9 = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s detected - fixing broken IRQ routing\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;%s detected - fixing broken IRQ routing\n&quot;,</span>
 			d-&gt;ident);
 	}
 	return 0;
<span class="p_chunk">@@ -1086,7 +1086,7 @@</span> <span class="p_context"> static int __init fix_acer_tm360_irqrouting(const struct dmi_system_id *d)</span>
 {
 	if (!acer_tm360_irqrouting) {
 		acer_tm360_irqrouting = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s detected - fixing broken IRQ routing\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;%s detected - fixing broken IRQ routing\n&quot;,</span>
 			d-&gt;ident);
 	}
 	return 0;
<span class="p_chunk">@@ -1156,7 +1156,7 @@</span> <span class="p_context"> void __init pcibios_irq_init(void)</span>
 		 * also do it here in case there are still broken drivers that
 		 * don&#39;t use pci_enable_device().
 		 */
<span class="p_del">-		printk(KERN_INFO &quot;PCI: Routing PCI interrupts for all devices because \&quot;pci=routeirq\&quot; specified\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;PCI: Routing PCI interrupts for all devices because \&quot;pci=routeirq\&quot; specified\n&quot;);</span>
 		for_each_pci_dev(dev)
 			pirq_enable_irq(dev);
 	}
<span class="p_header">diff --git a/arch/x86/pci/legacy.c b/arch/x86/pci/legacy.c</span>
<span class="p_header">index ea6f380..aceea71 100644</span>
<span class="p_header">--- a/arch/x86/pci/legacy.c</span>
<span class="p_header">+++ b/arch/x86/pci/legacy.c</span>
<span class="p_chunk">@@ -46,7 +46,7 @@</span> <span class="p_context"> void pcibios_scan_specific_bus(int busn)</span>
 		if (!raw_pci_read(0, busn, devfn, PCI_VENDOR_ID, 2, &amp;l) &amp;&amp;
 		    l != 0x0000 &amp;&amp; l != 0xffff) {
 			DBG(&quot;Found device at %02x:%02x [%04x]\n&quot;, busn, devfn, l);
<span class="p_del">-			printk(KERN_INFO &quot;PCI: Discovered peer bus %02x\n&quot;, busn);</span>
<span class="p_add">+			pr_info(&quot;PCI: Discovered peer bus %02x\n&quot;, busn);</span>
 			pcibios_scan_root(busn);
 			return;
 		}
<span class="p_header">diff --git a/arch/x86/pci/mmconfig_32.c b/arch/x86/pci/mmconfig_32.c</span>
<span class="p_header">index 43984bc..af4957d 100644</span>
<span class="p_header">--- a/arch/x86/pci/mmconfig_32.c</span>
<span class="p_header">+++ b/arch/x86/pci/mmconfig_32.c</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> const struct pci_raw_ops pci_mmcfg = {</span>
 
 int __init pci_mmcfg_arch_init(void)
 {
<span class="p_del">-	printk(KERN_INFO &quot;PCI: Using MMCONFIG for extended config space\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;PCI: Using MMCONFIG for extended config space\n&quot;);</span>
 	raw_pci_ext_ops = &amp;pci_mmcfg;
 	return 1;
 }
<span class="p_header">diff --git a/arch/x86/pci/olpc.c b/arch/x86/pci/olpc.c</span>
<span class="p_header">index 7043a4f..3a3f865 100644</span>
<span class="p_header">--- a/arch/x86/pci/olpc.c</span>
<span class="p_header">+++ b/arch/x86/pci/olpc.c</span>
<span class="p_chunk">@@ -308,7 +308,7 @@</span> <span class="p_context"> static const struct pci_raw_ops pci_olpc_conf = {</span>
 
 int __init pci_olpc_init(void)
 {
<span class="p_del">-	printk(KERN_INFO &quot;PCI: Using configuration type OLPC XO-1\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;PCI: Using configuration type OLPC XO-1\n&quot;);</span>
 	raw_pci_ops = &amp;pci_olpc_conf;
 	is_lx = is_geode_lx();
 	return 0;
<span class="p_header">diff --git a/arch/x86/pci/pcbios.c b/arch/x86/pci/pcbios.c</span>
<span class="p_header">index 9770e55..5ff6463 100644</span>
<span class="p_header">--- a/arch/x86/pci/pcbios.c</span>
<span class="p_header">+++ b/arch/x86/pci/pcbios.c</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static inline void set_bios_x(void)</span>
 	pcibios_enabled = 1;
 	set_memory_x(PAGE_OFFSET + BIOS_BEGIN, (BIOS_END - BIOS_BEGIN) &gt;&gt; PAGE_SHIFT);
 	if (__supported_pte_mask &amp; _PAGE_NX)
<span class="p_del">-		printk(KERN_INFO &quot;PCI : PCI BIOS area is rw and x. Use pci=nobios if you want it NX.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;PCI : PCI BIOS area is rw and x. Use pci=nobios if you want it NX.\n&quot;);</span>
 }
 
 /*
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> static int __init check_pcibios(void)</span>
 				status, signature);
 			return 0;
 		}
<span class="p_del">-		printk(KERN_INFO &quot;PCI: PCI BIOS revision %x.%02x entry at 0x%lx, last bus=%d\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;PCI: PCI BIOS revision %x.%02x entry at 0x%lx, last bus=%d\n&quot;,</span>
 			major_ver, minor_ver, pcibios_entry, pcibios_last_bus);
 #ifdef CONFIG_PCI_DIRECT
 		if (!(hw_mech &amp; PCIBIOS_HW_TYPE1))
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> struct irq_routing_table * pcibios_get_irq_routing_table(void)</span>
 			rt-&gt;size = opt.size + sizeof(struct irq_routing_table);
 			rt-&gt;exclusive_irqs = map;
 			memcpy(rt-&gt;slots, (void *) page, opt.size);
<span class="p_del">-			printk(KERN_INFO &quot;PCI: Using BIOS Interrupt Routing Table\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;PCI: Using BIOS Interrupt Routing Table\n&quot;);</span>
 		}
 	}
 	free_page(page);
<span class="p_header">diff --git a/arch/x86/pci/xen.c b/arch/x86/pci/xen.c</span>
<span class="p_header">index ff31ab4..7a9666c 100644</span>
<span class="p_header">--- a/arch/x86/pci/xen.c</span>
<span class="p_header">+++ b/arch/x86/pci/xen.c</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> static int xen_register_gsi(u32 gsi, int gsi_override, int triggering, int polar</span>
 
 	rc = HYPERVISOR_physdev_op(PHYSDEVOP_setup_gsi, &amp;setup_gsi);
 	if (rc == -EEXIST)
<span class="p_del">-		printk(KERN_INFO &quot;Already setup the GSI :%d\n&quot;, gsi);</span>
<span class="p_add">+		pr_info(&quot;Already setup the GSI :%d\n&quot;, gsi);</span>
 	else if (rc) {
 		printk(KERN_ERR &quot;Failed to setup GSI :%d, err_code:%d\n&quot;,
 				gsi, rc);
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> int __init pci_xen_init(void)</span>
 	if (!xen_pv_domain() || xen_initial_domain())
 		return -ENODEV;
 
<span class="p_del">-	printk(KERN_INFO &quot;PCI: setting up Xen PCI frontend stub\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;PCI: setting up Xen PCI frontend stub\n&quot;);</span>
 
 	pcibios_set_cache_line_size();
 
<span class="p_header">diff --git a/arch/x86/platform/geode/alix.c b/arch/x86/platform/geode/alix.c</span>
<span class="p_header">index 1865c19..841beab 100644</span>
<span class="p_header">--- a/arch/x86/platform/geode/alix.c</span>
<span class="p_header">+++ b/arch/x86/platform/geode/alix.c</span>
<span class="p_chunk">@@ -154,9 +154,8 @@</span> <span class="p_context"> static bool __init alix_present(unsigned long bios_phys,</span>
 
 		tail = p + alix_sig_len;
 		if ((tail[0] == &#39;2&#39; || tail[0] == &#39;3&#39; || tail[0] == &#39;6&#39;)) {
<span class="p_del">-			printk(KERN_INFO</span>
<span class="p_del">-			       &quot;%s: system is recognized as \&quot;%s\&quot;\n&quot;,</span>
<span class="p_del">-			       KBUILD_MODNAME, name);</span>
<span class="p_add">+			pr_info(&quot;%s: system is recognized as \&quot;%s\&quot;\n&quot;,</span>
<span class="p_add">+				KBUILD_MODNAME, name);</span>
 			return true;
 		}
 	}
<span class="p_chunk">@@ -176,8 +175,8 @@</span> <span class="p_context"> static bool __init alix_present_dmi(void)</span>
 	if (!product || (strcmp(product, &quot;ALIX.2D&quot;) &amp;&amp; strcmp(product, &quot;ALIX.6&quot;)))
 		return false;
 
<span class="p_del">-	printk(KERN_INFO &quot;%s: system is recognized as \&quot;%s %s\&quot;\n&quot;,</span>
<span class="p_del">-	       KBUILD_MODNAME, vendor, product);</span>
<span class="p_add">+	pr_info(&quot;%s: system is recognized as \&quot;%s %s\&quot;\n&quot;,</span>
<span class="p_add">+		KBUILD_MODNAME, vendor, product);</span>
 
 	return true;
 }
<span class="p_header">diff --git a/arch/x86/platform/geode/geos.c b/arch/x86/platform/geode/geos.c</span>
<span class="p_header">index 4fcdb91..b0900da 100644</span>
<span class="p_header">--- a/arch/x86/platform/geode/geos.c</span>
<span class="p_header">+++ b/arch/x86/platform/geode/geos.c</span>
<span class="p_chunk">@@ -112,8 +112,8 @@</span> <span class="p_context"> static int __init geos_init(void)</span>
 	if (!product || strcmp(product, &quot;Geos&quot;))
 		return 0;
 
<span class="p_del">-	printk(KERN_INFO &quot;%s: system is recognized as \&quot;%s %s\&quot;\n&quot;,</span>
<span class="p_del">-	       KBUILD_MODNAME, vendor, product);</span>
<span class="p_add">+	pr_info(&quot;%s: system is recognized as \&quot;%s %s\&quot;\n&quot;,</span>
<span class="p_add">+		KBUILD_MODNAME, vendor, product);</span>
 
 	register_geos();
 
<span class="p_header">diff --git a/arch/x86/platform/geode/net5501.c b/arch/x86/platform/geode/net5501.c</span>
<span class="p_header">index a2f6b98..d8a3f5f 100644</span>
<span class="p_header">--- a/arch/x86/platform/geode/net5501.c</span>
<span class="p_header">+++ b/arch/x86/platform/geode/net5501.c</span>
<span class="p_chunk">@@ -120,8 +120,8 @@</span> <span class="p_context"> static bool __init net5501_present(void)</span>
 		unsigned char *model = rombase + boards[i].offset;
 
 		if (!memcmp(model, boards[i].sig, boards[i].len)) {
<span class="p_del">-			printk(KERN_INFO &quot;%s: system is recognized as \&quot;%s\&quot;\n&quot;,</span>
<span class="p_del">-			       KBUILD_MODNAME, model);</span>
<span class="p_add">+			pr_info(&quot;%s: system is recognized as \&quot;%s\&quot;\n&quot;,</span>
<span class="p_add">+				KBUILD_MODNAME, model);</span>
 
 			found = true;
 			break;
<span class="p_header">diff --git a/arch/x86/platform/iris/iris.c b/arch/x86/platform/iris/iris.c</span>
<span class="p_header">index 735ba21..a37d837 100644</span>
<span class="p_header">--- a/arch/x86/platform/iris/iris.c</span>
<span class="p_header">+++ b/arch/x86/platform/iris/iris.c</span>
<span class="p_chunk">@@ -72,14 +72,14 @@</span> <span class="p_context"> static int iris_probe(struct platform_device *pdev)</span>
 	}
 	old_pm_power_off = pm_power_off;
 	pm_power_off = &amp;iris_power_off;
<span class="p_del">-	printk(KERN_INFO &quot;Iris power_off handler installed.\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Iris power_off handler installed.\n&quot;);</span>
 	return 0;
 }
 
 static int iris_remove(struct platform_device *pdev)
 {
 	pm_power_off = old_pm_power_off;
<span class="p_del">-	printk(KERN_INFO &quot;Iris power_off handler uninstalled.\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Iris power_off handler uninstalled.\n&quot;);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/x86/platform/olpc/olpc-xo1-pm.c b/arch/x86/platform/olpc/olpc-xo1-pm.c</span>
<span class="p_header">index c5350fd..dd884bd 100644</span>
<span class="p_header">--- a/arch/x86/platform/olpc/olpc-xo1-pm.c</span>
<span class="p_header">+++ b/arch/x86/platform/olpc/olpc-xo1-pm.c</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"> asmlinkage __visible int xo1_do_sleep(u8 sleep_state)</span>
 
 static void xo1_power_off(void)
 {
<span class="p_del">-	printk(KERN_INFO &quot;OLPC XO-1 power off sequence...\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;OLPC XO-1 power off sequence...\n&quot;);</span>
 
 	/* Enable all of these controls with 0 delay */
 	outl(0x40000000, pms_base + CS5536_PM_SCLK);
<span class="p_chunk">@@ -148,7 +148,7 @@</span> <span class="p_context"> static int xo1_pm_probe(struct platform_device *pdev)</span>
 	if (pms_base &amp;&amp; acpi_base) {
 		suspend_set_ops(&amp;xo1_suspend_ops);
 		pm_power_off = xo1_power_off;
<span class="p_del">-		printk(KERN_INFO &quot;OLPC XO-1 support registered\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;OLPC XO-1 support registered\n&quot;);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/arch/x86/platform/olpc/olpc_ofw.c b/arch/x86/platform/olpc/olpc_ofw.c</span>
<span class="p_header">index e7604f6..a3655fc 100644</span>
<span class="p_header">--- a/arch/x86/platform/olpc/olpc_ofw.c</span>
<span class="p_header">+++ b/arch/x86/platform/olpc/olpc_ofw.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> void __init olpc_ofw_detect(void)</span>
 
 	/* determine where OFW starts in memory */
 	start = round_down((unsigned long)olpc_ofw_cif, OFW_BOUND);
<span class="p_del">-	printk(KERN_INFO &quot;OFW detected in memory, cif @ 0x%lx (reserving top %ldMB)\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;OFW detected in memory, cif @ 0x%lx (reserving top %ldMB)\n&quot;,</span>
 			(unsigned long)olpc_ofw_cif, (-start) &gt;&gt; 20);
 	reserve_top_address(-start);
 }
<span class="p_header">diff --git a/arch/x86/platform/uv/bios_uv.c b/arch/x86/platform/uv/bios_uv.c</span>
<span class="p_header">index 1584cbe..0a00a49 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/bios_uv.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/bios_uv.c</span>
<span class="p_chunk">@@ -207,7 +207,7 @@</span> <span class="p_context"> void uv_bios_init(void)</span>
 	memcpy(&amp;uv_systab, tab, sizeof(struct uv_systab));
 	iounmap(tab);
 
<span class="p_del">-	printk(KERN_INFO &quot;EFI UV System Table Revision %d\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;EFI UV System Table Revision %d\n&quot;,</span>
 					uv_systab.revision);
 }
 #else	/* !CONFIG_EFI */
<span class="p_header">diff --git a/arch/x86/platform/uv/tlb_uv.c b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">index 3b6ec42..74090ac 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_chunk">@@ -1539,7 +1539,7 @@</span> <span class="p_context"> static int parse_tunables_write(struct bau_control *bcp, char *instr,</span>
 			break;
 	}
 	if (cnt != e) {
<span class="p_del">-		printk(KERN_INFO &quot;bau tunable error: should be %d values\n&quot;, e);</span>
<span class="p_add">+		pr_info(&quot;bau tunable error: should be %d values\n&quot;, e);</span>
 		return -EINVAL;
 	}
 
<span class="p_header">diff --git a/arch/x86/platform/uv/uv_time.c b/arch/x86/platform/uv/uv_time.c</span>
<span class="p_header">index 2b158a9..4d2c37e 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/uv_time.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/uv_time.c</span>
<span class="p_chunk">@@ -370,9 +370,9 @@</span> <span class="p_context"> static __init int uv_rtc_setup_clock(void)</span>
 
 	rc = clocksource_register_hz(&amp;clocksource_uv, sn_rtc_cycles_per_second);
 	if (rc)
<span class="p_del">-		printk(KERN_INFO &quot;UV RTC clocksource failed rc %d\n&quot;, rc);</span>
<span class="p_add">+		pr_info(&quot;UV RTC clocksource failed rc %d\n&quot;, rc);</span>
 	else
<span class="p_del">-		printk(KERN_INFO &quot;UV RTC clocksource registered freq %lu MHz\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;UV RTC clocksource registered freq %lu MHz\n&quot;,</span>
 			sn_rtc_cycles_per_second/(unsigned long)1E6);
 
 	if (rc || !uv_rtc_evt_enable || x86_platform_ipi_callback)
<span class="p_chunk">@@ -401,13 +401,13 @@</span> <span class="p_context"> static __init int uv_rtc_setup_clock(void)</span>
 		goto error;
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;UV RTC clockevents registered\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;UV RTC clockevents registered\n&quot;);</span>
 
 	return 0;
 
 error:
 	clocksource_unregister(&amp;clocksource_uv);
<span class="p_del">-	printk(KERN_INFO &quot;UV RTC clockevents failed rc %d\n&quot;, rc);</span>
<span class="p_add">+	pr_info(&quot;UV RTC clockevents failed rc %d\n&quot;, rc);</span>
 
 	return rc;
 }
<span class="p_header">diff --git a/arch/x86/um/sysrq_64.c b/arch/x86/um/sysrq_64.c</span>
<span class="p_header">index 38b4e4a..29869d8 100644</span>
<span class="p_header">--- a/arch/x86/um/sysrq_64.c</span>
<span class="p_header">+++ b/arch/x86/um/sysrq_64.c</span>
<span class="p_chunk">@@ -16,20 +16,20 @@</span> <span class="p_context"> void show_regs(struct pt_regs *regs)</span>
 {
 	printk(&quot;\n&quot;);
 	print_modules();
<span class="p_del">-	printk(KERN_INFO &quot;Pid: %d, comm: %.20s %s %s\n&quot;, task_pid_nr(current),</span>
<span class="p_add">+	pr_info(&quot;Pid: %d, comm: %.20s %s %s\n&quot;, task_pid_nr(current),</span>
 		current-&gt;comm, print_tainted(), init_utsname()-&gt;release);
<span class="p_del">-	printk(KERN_INFO &quot;RIP: %04lx:[&lt;%016lx&gt;]\n&quot;, PT_REGS_CS(regs) &amp; 0xffff,</span>
<span class="p_del">-	       PT_REGS_IP(regs));</span>
<span class="p_del">-	printk(KERN_INFO &quot;RSP: %016lx  EFLAGS: %08lx\n&quot;, PT_REGS_SP(regs),</span>
<span class="p_del">-	       PT_REGS_EFLAGS(regs));</span>
<span class="p_del">-	printk(KERN_INFO &quot;RAX: %016lx RBX: %016lx RCX: %016lx\n&quot;,</span>
<span class="p_del">-	       PT_REGS_AX(regs), PT_REGS_BX(regs), PT_REGS_CX(regs));</span>
<span class="p_del">-	printk(KERN_INFO &quot;RDX: %016lx RSI: %016lx RDI: %016lx\n&quot;,</span>
<span class="p_del">-	       PT_REGS_DX(regs), PT_REGS_SI(regs), PT_REGS_DI(regs));</span>
<span class="p_del">-	printk(KERN_INFO &quot;RBP: %016lx R08: %016lx R09: %016lx\n&quot;,</span>
<span class="p_del">-	       PT_REGS_BP(regs), PT_REGS_R8(regs), PT_REGS_R9(regs));</span>
<span class="p_del">-	printk(KERN_INFO &quot;R10: %016lx R11: %016lx R12: %016lx\n&quot;,</span>
<span class="p_del">-	       PT_REGS_R10(regs), PT_REGS_R11(regs), PT_REGS_R12(regs));</span>
<span class="p_del">-	printk(KERN_INFO &quot;R13: %016lx R14: %016lx R15: %016lx\n&quot;,</span>
<span class="p_del">-	       PT_REGS_R13(regs), PT_REGS_R14(regs), PT_REGS_R15(regs));</span>
<span class="p_add">+	pr_info(&quot;RIP: %04lx:[&lt;%016lx&gt;]\n&quot;, PT_REGS_CS(regs) &amp; 0xffff,</span>
<span class="p_add">+		PT_REGS_IP(regs));</span>
<span class="p_add">+	pr_info(&quot;RSP: %016lx  EFLAGS: %08lx\n&quot;, PT_REGS_SP(regs),</span>
<span class="p_add">+		PT_REGS_EFLAGS(regs));</span>
<span class="p_add">+	pr_info(&quot;RAX: %016lx RBX: %016lx RCX: %016lx\n&quot;,</span>
<span class="p_add">+		PT_REGS_AX(regs), PT_REGS_BX(regs), PT_REGS_CX(regs));</span>
<span class="p_add">+	pr_info(&quot;RDX: %016lx RSI: %016lx RDI: %016lx\n&quot;,</span>
<span class="p_add">+		PT_REGS_DX(regs), PT_REGS_SI(regs), PT_REGS_DI(regs));</span>
<span class="p_add">+	pr_info(&quot;RBP: %016lx R08: %016lx R09: %016lx\n&quot;,</span>
<span class="p_add">+		PT_REGS_BP(regs), PT_REGS_R8(regs), PT_REGS_R9(regs));</span>
<span class="p_add">+	pr_info(&quot;R10: %016lx R11: %016lx R12: %016lx\n&quot;,</span>
<span class="p_add">+		PT_REGS_R10(regs), PT_REGS_R11(regs), PT_REGS_R12(regs));</span>
<span class="p_add">+	pr_info(&quot;R13: %016lx R14: %016lx R15: %016lx\n&quot;,</span>
<span class="p_add">+		PT_REGS_R13(regs), PT_REGS_R14(regs), PT_REGS_R15(regs));</span>
 }
<span class="p_header">diff --git a/arch/x86/um/tls_32.c b/arch/x86/um/tls_32.c</span>
<span class="p_header">index 48e3858..e8092dd 100644</span>
<span class="p_header">--- a/arch/x86/um/tls_32.c</span>
<span class="p_header">+++ b/arch/x86/um/tls_32.c</span>
<span class="p_chunk">@@ -376,8 +376,8 @@</span> <span class="p_context"> static int __init __setup_host_supports_tls(void)</span>
 {
 	check_host_supports_tls(&amp;host_supports_tls, &amp;host_gdt_entry_tls_min);
 	if (host_supports_tls) {
<span class="p_del">-		printk(KERN_INFO &quot;Host TLS support detected\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;Detected host type: &quot;);</span>
<span class="p_add">+		pr_info(&quot;Host TLS support detected\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Detected host type: &quot;);</span>
 		switch (host_gdt_entry_tls_min) {
 		case GDT_ENTRY_TLS_MIN_I386:
 			printk(KERN_CONT &quot;i386&quot;);
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index 2c26108..a36683a 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -273,9 +273,10 @@</span> <span class="p_context"> static void __init xen_banner(void)</span>
 	pr_info(&quot;Booting paravirtualized kernel %son %s\n&quot;,
 		xen_feature(XENFEAT_auto_translated_physmap) ?
 			&quot;with PVH extensions &quot; : &quot;&quot;, pv_info.name);
<span class="p_del">-	printk(KERN_INFO &quot;Xen version: %d.%d%s%s\n&quot;,</span>
<span class="p_del">-	       version &gt;&gt; 16, version &amp; 0xffff, extra.extraversion,</span>
<span class="p_del">-	       xen_feature(XENFEAT_mmu_pt_update_preserve_ad) ? &quot; (preserve-AD)&quot; : &quot;&quot;);</span>
<span class="p_add">+	pr_info(&quot;Xen version: %d.%d%s%s\n&quot;,</span>
<span class="p_add">+		version &gt;&gt; 16, version &amp; 0xffff, extra.extraversion,</span>
<span class="p_add">+		xen_feature(XENFEAT_mmu_pt_update_preserve_ad) ?</span>
<span class="p_add">+			&quot; (preserve-AD)&quot; : &quot;&quot;);</span>
 }
 /* Check if running on Xen version (major, minor) or later */
 bool
<span class="p_chunk">@@ -1769,7 +1770,7 @@</span> <span class="p_context"> static void __init init_hvm_pv_info(void)</span>
 
 	major = eax &gt;&gt; 16;
 	minor = eax &amp; 0xffff;
<span class="p_del">-	printk(KERN_INFO &quot;Xen version %d.%d.\n&quot;, major, minor);</span>
<span class="p_add">+	pr_info(&quot;Xen version %d.%d.\n&quot;, major, minor);</span>
 
 	cpuid(base + 2, &amp;pages, &amp;msr, &amp;ecx, &amp;edx);
 
<span class="p_header">diff --git a/arch/x86/xen/platform-pci-unplug.c b/arch/x86/xen/platform-pci-unplug.c</span>
<span class="p_header">index 9586ff3..d948eaf 100644</span>
<span class="p_header">--- a/arch/x86/xen/platform-pci-unplug.c</span>
<span class="p_header">+++ b/arch/x86/xen/platform-pci-unplug.c</span>
<span class="p_chunk">@@ -163,16 +163,14 @@</span> <span class="p_context"> void xen_unplug_emulated_devices(void)</span>
 	 * been compiled for this kernel (modules or built-in are both OK). */
 	if (!xen_emul_unplug) {
 		if (xen_must_unplug_nics()) {
<span class="p_del">-			printk(KERN_INFO &quot;Netfront and the Xen platform PCI driver have &quot;</span>
<span class="p_del">-					&quot;been compiled for this kernel: unplug emulated NICs.\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;Netfront and the Xen platform PCI driver have been compiled for this kernel: unplug emulated NICs.\n&quot;);</span>
 			xen_emul_unplug |= XEN_UNPLUG_ALL_NICS;
 		}
 		if (xen_must_unplug_disks()) {
<span class="p_del">-			printk(KERN_INFO &quot;Blkfront and the Xen platform PCI driver have &quot;</span>
<span class="p_del">-					&quot;been compiled for this kernel: unplug emulated disks.\n&quot;</span>
<span class="p_del">-					&quot;You might have to change the root device\n&quot;</span>
<span class="p_del">-					&quot;from /dev/hd[a-d] to /dev/xvd[a-d]\n&quot;</span>
<span class="p_del">-					&quot;in your root= kernel command line option\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;Blkfront and the Xen platform PCI driver have been compiled for this kernel: unplug emulated disks.\n&quot;</span>
<span class="p_add">+				&quot;You might have to change the root device\n&quot;</span>
<span class="p_add">+				&quot;from /dev/hd[a-d] to /dev/xvd[a-d]\n&quot;</span>
<span class="p_add">+				&quot;in your root= kernel command line option\n&quot;);</span>
 			xen_emul_unplug |= XEN_UNPLUG_ALL_IDE_DISKS;
 		}
 	}
<span class="p_header">diff --git a/arch/x86/xen/setup.c b/arch/x86/xen/setup.c</span>
<span class="p_header">index 7ab2951..82f0733 100644</span>
<span class="p_header">--- a/arch/x86/xen/setup.c</span>
<span class="p_header">+++ b/arch/x86/xen/setup.c</span>
<span class="p_chunk">@@ -1050,7 +1050,7 @@</span> <span class="p_context"> void __init xen_arch_setup(void)</span>
 
 #ifdef CONFIG_ACPI
 	if (!(xen_start_info-&gt;flags &amp; SIF_INITDOMAIN)) {
<span class="p_del">-		printk(KERN_INFO &quot;ACPI in unprivileged domain disabled\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;ACPI in unprivileged domain disabled\n&quot;);</span>
 		disable_acpi();
 	}
 #endif
<span class="p_header">diff --git a/arch/x86/xen/time.c b/arch/x86/xen/time.c</span>
<span class="p_header">index a0a4e55..1333f76 100644</span>
<span class="p_header">--- a/arch/x86/xen/time.c</span>
<span class="p_header">+++ b/arch/x86/xen/time.c</span>
<span class="p_chunk">@@ -362,7 +362,7 @@</span> <span class="p_context"> void xen_setup_timer(int cpu)</span>
 	if (evt-&gt;irq &gt;= 0)
 		xen_teardown_timer(cpu);
 
<span class="p_del">-	printk(KERN_INFO &quot;installing Xen timer for CPU %d\n&quot;, cpu);</span>
<span class="p_add">+	pr_info(&quot;installing Xen timer for CPU %d\n&quot;, cpu);</span>
 
 	snprintf(xevt-&gt;name, sizeof(xevt-&gt;name), &quot;timer%d&quot;, cpu);
 
<span class="p_chunk">@@ -471,8 +471,7 @@</span> <span class="p_context"> void __init xen_hvm_init_time_ops(void)</span>
 	if (!xen_have_vector_callback)
 		return;
 	if (!xen_feature(XENFEAT_hvm_safe_pvclock)) {
<span class="p_del">-		printk(KERN_INFO &quot;Xen doesn&#39;t support pvclock on HVM,&quot;</span>
<span class="p_del">-				&quot;disable pv timer\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Xen doesn&#39;t support pvclock on HVM, disable pv timer\n&quot;);</span>
 		return;
 	}
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



