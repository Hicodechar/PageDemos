
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[19/19] COCCINELLE: treewide: kill off ACCESS_ONCE() - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [19/19] COCCINELLE: treewide: kill off ACCESS_ONCE()</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=61">Paul E. McKenney</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 23, 2017, 9:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1508792849-3115-19-git-send-email-paulmck@linux.vnet.ibm.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10023083/mbox/"
   >mbox</a>
|
   <a href="/patch/10023083/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10023083/">/patch/10023083/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	DF35A60381 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 23 Oct 2017 21:09:36 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id BFF5828927
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 23 Oct 2017 21:09:36 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id B2B3528945; Mon, 23 Oct 2017 21:09:36 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 648EF28927
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 23 Oct 2017 21:09:29 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751870AbdJWVJ1 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 23 Oct 2017 17:09:27 -0400
Received: from mx0a-001b2d01.pphosted.com ([148.163.156.1]:40460 &quot;EHLO
	mx0a-001b2d01.pphosted.com&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751657AbdJWVHo (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 23 Oct 2017 17:07:44 -0400
Received: from pps.filterd (m0098404.ppops.net [127.0.0.1])
	by mx0a-001b2d01.pphosted.com (8.16.0.21/8.16.0.21) with SMTP id
	v9NL7KdT124376
	for &lt;linux-kernel@vger.kernel.org&gt;; Mon, 23 Oct 2017 17:07:43 -0400
Received: from e15.ny.us.ibm.com (e15.ny.us.ibm.com [129.33.205.205])
	by mx0a-001b2d01.pphosted.com with ESMTP id 2dskcm4tu4-1
	(version=TLSv1.2 cipher=AES256-SHA bits=256 verify=NOT)
	for &lt;linux-kernel@vger.kernel.org&gt;; Mon, 23 Oct 2017 17:07:42 -0400
Received: from localhost
	by e15.ny.us.ibm.com with IBM ESMTP SMTP Gateway: Authorized Use
	Only! Violators will be prosecuted
	for &lt;linux-kernel@vger.kernel.org&gt; from &lt;paulmck@linux.vnet.ibm.com&gt;; 
	Mon, 23 Oct 2017 17:07:41 -0400
Received: from b01cxnp23032.gho.pok.ibm.com (9.57.198.27)
	by e15.ny.us.ibm.com (146.89.104.202) with IBM ESMTP SMTP Gateway:
	Authorized Use Only! Violators will be prosecuted; 
	Mon, 23 Oct 2017 17:07:36 -0400
Received: from b01ledav003.gho.pok.ibm.com (b01ledav003.gho.pok.ibm.com
	[9.57.199.108])
	by b01cxnp23032.gho.pok.ibm.com (8.14.9/8.14.9/NCO v10.0) with ESMTP
	id v9NL7WUr37879838; Mon, 23 Oct 2017 21:07:36 GMT
Received: from b01ledav003.gho.pok.ibm.com (unknown [127.0.0.1])
	by IMSVA (Postfix) with ESMTP id D0B10B2046;
	Mon, 23 Oct 2017 17:04:50 -0400 (EDT)
Received: from paulmck-ThinkPad-W541 (unknown [9.80.218.156])
	by b01ledav003.gho.pok.ibm.com (Postfix) with ESMTP id 4470DB204E;
	Mon, 23 Oct 2017 17:04:50 -0400 (EDT)
Received: by paulmck-ThinkPad-W541 (Postfix, from userid 1000)
	id EE1F416C4167; Mon, 23 Oct 2017 14:07:33 -0700 (PDT)
From: &quot;Paul E. McKenney&quot; &lt;paulmck@linux.vnet.ibm.com&gt;
To: mingo@kernel.org
Cc: linux-kernel@vger.kernel.org, linux-arch@vger.kernel.org,
	will.deacon@arm.com, mark.rutland@arm.com, snitzer@redhat.com,
	thor.thayer@linux.intel.com, viro@zeniv.linux.org.uk,
	davem@davemloft.net, shuah@kernel.org, mpe@ellerman.id.au,
	tj@kernel.org, torvalds@linux-foundation.org,
	&quot;Paul E. McKenney&quot; &lt;paulmck@linux.vnet.ibm.com&gt;
Subject: [PATCH 19/19] COCCINELLE: treewide: kill off ACCESS_ONCE()
Date: Mon, 23 Oct 2017 14:07:29 -0700
X-Mailer: git-send-email 2.5.2
In-Reply-To: &lt;20171023210408.GA2930@linux.vnet.ibm.com&gt;
References: &lt;20171023210408.GA2930@linux.vnet.ibm.com&gt;
X-TM-AS-GCONF: 00
x-cbid: 17102321-0036-0000-0000-0000027FF654
X-IBM-SpamModules-Scores: 
X-IBM-SpamModules-Versions: BY=3.00007941; HX=3.00000241; KW=3.00000007;
	PH=3.00000004; SC=3.00000239; SDB=6.00935454; UDB=6.00471299;
	IPR=6.00715720; 
	BA=6.00005656; NDR=6.00000001; ZLA=6.00000005; ZF=6.00000009;
	ZB=6.00000000; 
	ZP=6.00000000; ZH=6.00000000; ZU=6.00000002; MB=3.00017676;
	XFM=3.00000015; UTC=2017-10-23 21:07:40
X-IBM-AV-DETECTION: SAVI=unused REMOTE=unused XFE=unused
x-cbparentid: 17102321-0037-0000-0000-0000422B014D
Message-Id: &lt;1508792849-3115-19-git-send-email-paulmck@linux.vnet.ibm.com&gt;
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10432:, ,
	definitions=2017-10-23_11:, , signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
	spamscore=0 suspectscore=4
	malwarescore=0 phishscore=0 adultscore=0 bulkscore=0 classifier=spam
	adjust=0 reason=mlx scancount=1 engine=8.0.1-1707230000
	definitions=main-1710230296
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=61">Paul E. McKenney</a> - Oct. 23, 2017, 9:07 p.m.</div>
<pre class="content">
<span class="from">From: Mark Rutland &lt;mark.rutland@arm.com&gt;</span>

Please do not apply this to mainline directly, instead please re-run the
coccinelle script shown below and apply its output.

For several reasons, it is desirable to use {READ,WRITE}_ONCE() in
preference to ACCESS_ONCE(), and new code is expected to use one of the
former. So far, there&#39;s been no reason to change most existing uses of
ACCESS_ONCE(), as these aren&#39;t harmful, and changing them results in
churn.

However, for some features, the read/write distinction is critical to
correct operation. To distinguish these cases, separate read/write
accessors must be used. This patch migrates (most) remaining
ACCESS_ONCE() instances to {READ,WRITE}_ONCE(), using the following
coccinelle script:

----
// Convert trivial ACCESS_ONCE() uses to equivalent READ_ONCE() and
// WRITE_ONCE()

// $ make coccicheck COCCI=/home/mark/once.cocci SPFLAGS=&quot;--include-headers&quot; MODE=patch

virtual patch

@ depends on patch @
expression E1, E2;
@@

- ACCESS_ONCE(E1) = E2
+ WRITE_ONCE(E1, E2)

@ depends on patch @
expression E;
@@

- ACCESS_ONCE(E)
+ READ_ONCE(E)
----
<span class="signed-off-by">
Signed-off-by: Mark Rutland &lt;mark.rutland@arm.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Paul E. McKenney &lt;paulmck@linux.vnet.ibm.com&gt;</span>
---
 arch/arc/kernel/smp.c                              |  2 +-
 arch/arm/include/asm/spinlock.h                    |  6 ++--
 arch/arm/mach-tegra/cpuidle-tegra20.c              |  2 +-
 arch/arm/vdso/vgettimeofday.c                      |  2 +-
 arch/ia64/include/asm/spinlock.h                   |  8 ++---
 arch/mips/include/asm/vdso.h                       |  2 +-
 arch/mips/kernel/pm-cps.c                          |  2 +-
 arch/mn10300/kernel/mn10300-serial.c               |  4 +--
 arch/parisc/include/asm/atomic.h                   |  2 +-
 arch/powerpc/platforms/powernv/opal-msglog.c       |  2 +-
 arch/s390/include/asm/spinlock.h                   |  6 ++--
 arch/s390/lib/spinlock.c                           | 16 +++++-----
 arch/sparc/include/asm/atomic_32.h                 |  2 +-
 arch/tile/gxio/dma_queue.c                         |  4 +--
 arch/tile/include/gxio/dma_queue.h                 |  2 +-
 arch/tile/kernel/ptrace.c                          |  2 +-
 arch/x86/entry/common.c                            |  2 +-
 arch/x86/entry/vdso/vclock_gettime.c               |  2 +-
 arch/x86/events/core.c                             |  2 +-
 arch/x86/include/asm/vgtod.h                       |  2 +-
 arch/x86/kernel/espfix_64.c                        |  6 ++--
 arch/x86/kernel/nmi.c                              |  2 +-
 arch/x86/kvm/mmu.c                                 |  4 +--
 arch/x86/kvm/page_track.c                          |  2 +-
 arch/x86/xen/p2m.c                                 |  2 +-
 arch/xtensa/platforms/xtfpga/lcd.c                 | 14 ++++-----
 block/blk-wbt.c                                    |  2 +-
 drivers/base/core.c                                |  2 +-
 drivers/base/power/runtime.c                       |  4 +--
 drivers/char/random.c                              |  4 +--
 drivers/clocksource/bcm2835_timer.c                |  2 +-
 drivers/crypto/caam/jr.c                           |  4 +--
 drivers/crypto/nx/nx-842-powernv.c                 |  2 +-
 drivers/firewire/ohci.c                            | 10 +++---
 drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c          |  4 +--
 drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c            |  4 +--
 drivers/gpu/drm/amd/scheduler/gpu_scheduler.c      |  2 +-
 drivers/gpu/drm/radeon/radeon_gem.c                |  4 +--
 drivers/gpu/drm/vmwgfx/vmwgfx_surface.c            |  2 +-
 drivers/infiniband/hw/hfi1/file_ops.c              |  2 +-
 drivers/infiniband/hw/hfi1/pio.c                   |  6 ++--
 drivers/infiniband/hw/hfi1/ruc.c                   |  2 +-
 drivers/infiniband/hw/hfi1/sdma.c                  |  8 ++---
 drivers/infiniband/hw/hfi1/sdma.h                  |  2 +-
 drivers/infiniband/hw/hfi1/uc.c                    |  4 +--
 drivers/infiniband/hw/hfi1/ud.c                    |  4 +--
 drivers/infiniband/hw/hfi1/user_sdma.c             |  8 ++---
 drivers/infiniband/hw/qib/qib_ruc.c                |  2 +-
 drivers/infiniband/hw/qib/qib_uc.c                 |  4 +--
 drivers/infiniband/hw/qib/qib_ud.c                 |  4 +--
 drivers/infiniband/sw/rdmavt/qp.c                  |  6 ++--
 drivers/input/misc/regulator-haptic.c              |  2 +-
 drivers/md/dm-bufio.c                              | 10 +++---
 drivers/md/dm-kcopyd.c                             |  4 +--
 drivers/md/dm-stats.c                              | 36 +++++++++++-----------
 drivers/md/dm-switch.c                             |  2 +-
 drivers/md/dm-thin.c                               |  2 +-
 drivers/md/dm-verity-target.c                      |  2 +-
 drivers/md/dm.c                                    |  4 +--
 drivers/md/md.c                                    |  2 +-
 drivers/md/raid5.c                                 |  2 +-
 drivers/misc/mic/scif/scif_rb.c                    |  8 ++---
 drivers/misc/mic/scif/scif_rma_list.c              |  2 +-
 drivers/net/bonding/bond_alb.c                     |  2 +-
 drivers/net/bonding/bond_main.c                    |  6 ++--
 drivers/net/ethernet/chelsio/cxgb4/sge.c           |  4 +--
 drivers/net/ethernet/emulex/benet/be_main.c        |  2 +-
 drivers/net/ethernet/hisilicon/hip04_eth.c         |  4 +--
 drivers/net/ethernet/intel/i40e/i40e_debugfs.c     |  4 +--
 drivers/net/ethernet/intel/i40e/i40e_ethtool.c     |  2 +-
 drivers/net/ethernet/intel/i40e/i40e_main.c        |  4 +--
 drivers/net/ethernet/intel/i40e/i40e_ptp.c         |  4 +--
 drivers/net/ethernet/intel/igb/e1000_regs.h        |  2 +-
 drivers/net/ethernet/intel/igb/igb_main.c          |  2 +-
 drivers/net/ethernet/intel/ixgbe/ixgbe_common.h    |  4 +--
 drivers/net/ethernet/intel/ixgbe/ixgbe_main.c      |  8 ++---
 drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c       |  4 +--
 drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c  |  2 +-
 drivers/net/ethernet/intel/ixgbevf/vf.h            |  2 +-
 drivers/net/ethernet/mellanox/mlx4/en_tx.c         | 12 ++++----
 drivers/net/ethernet/neterion/vxge/vxge-main.c     |  2 +-
 drivers/net/ethernet/sfc/ef10.c                    | 10 +++---
 drivers/net/ethernet/sfc/efx.c                     |  4 +--
 drivers/net/ethernet/sfc/falcon/efx.c              |  4 +--
 drivers/net/ethernet/sfc/falcon/falcon.c           |  4 +--
 drivers/net/ethernet/sfc/falcon/farch.c            |  8 ++---
 drivers/net/ethernet/sfc/falcon/nic.h              |  6 ++--
 drivers/net/ethernet/sfc/falcon/tx.c               |  6 ++--
 drivers/net/ethernet/sfc/farch.c                   |  8 ++---
 drivers/net/ethernet/sfc/nic.h                     |  6 ++--
 drivers/net/ethernet/sfc/ptp.c                     | 10 +++---
 drivers/net/ethernet/sfc/tx.c                      |  6 ++--
 drivers/net/ethernet/sun/niu.c                     |  4 +--
 drivers/net/tap.c                                  |  2 +-
 drivers/net/tun.c                                  |  4 +--
 drivers/net/wireless/ath/ath5k/desc.c              |  8 ++---
 .../wireless/broadcom/brcm80211/brcmfmac/sdio.c    |  2 +-
 drivers/net/wireless/intel/iwlwifi/mvm/ops.c       |  2 +-
 drivers/net/wireless/intel/iwlwifi/mvm/tx.c        |  4 +--
 drivers/net/wireless/intel/iwlwifi/pcie/rx.c       |  2 +-
 drivers/net/wireless/intel/iwlwifi/pcie/trans.c    | 10 +++---
 drivers/net/wireless/mac80211_hwsim.c              |  4 +--
 drivers/scsi/qla2xxx/qla_target.c                  |  2 +-
 drivers/target/target_core_user.c                  |  2 +-
 drivers/usb/class/cdc-wdm.c                        |  2 +-
 drivers/usb/core/devio.c                           |  2 +-
 drivers/usb/core/sysfs.c                           |  4 +--
 drivers/usb/gadget/udc/gr_udc.c                    |  4 +--
 drivers/usb/host/ohci-hcd.c                        |  2 +-
 drivers/usb/host/uhci-hcd.h                        |  4 +--
 drivers/vfio/vfio.c                                |  2 +-
 drivers/vhost/scsi.c                               |  2 +-
 fs/aio.c                                           |  2 +-
 fs/buffer.c                                        |  3 +-
 fs/crypto/keyinfo.c                                |  2 +-
 fs/direct-io.c                                     |  2 +-
 fs/exec.c                                          |  2 +-
 fs/fcntl.c                                         |  2 +-
 fs/fs_pin.c                                        |  4 +--
 fs/fuse/dev.c                                      |  2 +-
 fs/inode.c                                         |  2 +-
 fs/namei.c                                         |  4 +--
 fs/namespace.c                                     |  2 +-
 fs/nfs/dir.c                                       |  8 ++---
 fs/proc/array.c                                    |  2 +-
 fs/proc_namespace.c                                |  2 +-
 fs/splice.c                                        |  2 +-
 fs/userfaultfd.c                                   |  8 ++---
 fs/xfs/xfs_log_priv.h                              |  4 +--
 include/linux/bitops.h                             |  4 +--
 include/linux/dynamic_queue_limits.h               |  2 +-
 include/linux/huge_mm.h                            |  2 +-
 include/linux/if_team.h                            |  2 +-
 include/linux/llist.h                              |  2 +-
 include/linux/pm_runtime.h                         |  2 +-
 include/net/ip_vs.h                                |  6 ++--
 kernel/acct.c                                      |  4 +--
 kernel/events/core.c                               |  6 ++--
 kernel/events/ring_buffer.c                        |  2 +-
 kernel/exit.c                                      |  2 +-
 kernel/trace/ring_buffer.c                         |  2 +-
 kernel/trace/trace.h                               |  2 +-
 kernel/trace/trace_stack.c                         |  2 +-
 kernel/user_namespace.c                            |  2 +-
 lib/assoc_array.c                                  | 20 ++++++------
 lib/dynamic_queue_limits.c                         |  2 +-
 lib/llist.c                                        |  2 +-
 lib/vsprintf.c                                     |  4 +--
 mm/huge_memory.c                                   |  2 +-
 net/core/dev.c                                     |  2 +-
 net/core/pktgen.c                                  |  2 +-
 net/ipv4/inet_fragment.c                           |  2 +-
 net/ipv4/route.c                                   |  2 +-
 net/ipv4/tcp_output.c                              |  2 +-
 net/ipv4/udp.c                                     |  4 +--
 net/ipv6/ip6_tunnel.c                              |  8 ++---
 net/ipv6/udp.c                                     |  4 +--
 net/llc/llc_input.c                                |  4 +--
 net/mac80211/sta_info.c                            |  2 +-
 net/netlabel/netlabel_calipso.c                    |  2 +-
 net/wireless/nl80211.c                             |  2 +-
 sound/firewire/amdtp-am824.c                       |  6 ++--
 sound/firewire/amdtp-stream.c                      | 23 +++++++-------
 sound/firewire/amdtp-stream.h                      |  2 +-
 sound/firewire/digi00x/amdtp-dot.c                 |  6 ++--
 sound/firewire/fireface/amdtp-ff.c                 |  4 +--
 sound/firewire/fireface/ff-midi.c                  | 10 +++---
 sound/firewire/fireface/ff-transaction.c           |  8 ++---
 sound/firewire/isight.c                            | 18 +++++------
 sound/firewire/motu/amdtp-motu.c                   |  4 +--
 sound/firewire/oxfw/oxfw-scs1x.c                   | 12 ++++----
 sound/firewire/tascam/amdtp-tascam.c               |  4 +--
 sound/firewire/tascam/tascam-transaction.c         |  6 ++--
 sound/soc/xtensa/xtfpga-i2s.c                      |  6 ++--
 sound/usb/bcd2000/bcd2000.c                        |  4 +--
 tools/arch/x86/include/asm/atomic.h                |  2 +-
 tools/include/asm-generic/atomic-gcc.h             |  2 +-
 tools/perf/util/auxtrace.h                         |  4 +--
 tools/perf/util/evlist.h                           |  2 +-
 tools/perf/util/session.h                          |  2 +-
 virt/kvm/kvm_main.c                                |  2 +-
 181 files changed, 386 insertions(+), 388 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arc/kernel/smp.c b/arch/arc/kernel/smp.c</span>
<span class="p_header">index f46267153ec2..94cabe73664b 100644</span>
<span class="p_header">--- a/arch/arc/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arc/kernel/smp.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static void ipi_send_msg_one(int cpu, enum ipi_msg_type msg)</span>
 	 * and read back old value
 	 */
 	do {
<span class="p_del">-		new = old = ACCESS_ONCE(*ipi_data_ptr);</span>
<span class="p_add">+		new = old = READ_ONCE(*ipi_data_ptr);</span>
 		new |= 1U &lt;&lt; msg;
 	} while (cmpxchg(ipi_data_ptr, old, new) != old);
 
<span class="p_header">diff --git a/arch/arm/include/asm/spinlock.h b/arch/arm/include/asm/spinlock.h</span>
<span class="p_header">index c030143c18c6..060e4ebb4e8a 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/spinlock.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/spinlock.h</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> static inline void arch_spin_lock(arch_spinlock_t *lock)</span>
 
 	while (lockval.tickets.next != lockval.tickets.owner) {
 		wfe();
<span class="p_del">-		lockval.tickets.owner = ACCESS_ONCE(lock-&gt;tickets.owner);</span>
<span class="p_add">+		lockval.tickets.owner = READ_ONCE(lock-&gt;tickets.owner);</span>
 	}
 
 	smp_mb();
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> static inline void arch_write_unlock(arch_rwlock_t *rw)</span>
 }
 
 /* write_can_lock - would write_trylock() succeed? */
<span class="p_del">-#define arch_write_can_lock(x)		(ACCESS_ONCE((x)-&gt;lock) == 0)</span>
<span class="p_add">+#define arch_write_can_lock(x)		(READ_ONCE((x)-&gt;lock) == 0)</span>
 
 /*
  * Read locks are a bit more hairy:
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> static inline int arch_read_trylock(arch_rwlock_t *rw)</span>
 }
 
 /* read_can_lock - would read_trylock() succeed? */
<span class="p_del">-#define arch_read_can_lock(x)		(ACCESS_ONCE((x)-&gt;lock) &lt; 0x80000000)</span>
<span class="p_add">+#define arch_read_can_lock(x)		(READ_ONCE((x)-&gt;lock) &lt; 0x80000000)</span>
 
 #define arch_read_lock_flags(lock, flags) arch_read_lock(lock)
 #define arch_write_lock_flags(lock, flags) arch_write_lock(lock)
<span class="p_header">diff --git a/arch/arm/mach-tegra/cpuidle-tegra20.c b/arch/arm/mach-tegra/cpuidle-tegra20.c</span>
<span class="p_header">index 76e4c83cd5c8..3f24addd7972 100644</span>
<span class="p_header">--- a/arch/arm/mach-tegra/cpuidle-tegra20.c</span>
<span class="p_header">+++ b/arch/arm/mach-tegra/cpuidle-tegra20.c</span>
<span class="p_chunk">@@ -179,7 +179,7 @@</span> <span class="p_context"> static int tegra20_idle_lp2_coupled(struct cpuidle_device *dev,</span>
 	bool entered_lp2 = false;
 
 	if (tegra_pending_sgi())
<span class="p_del">-		ACCESS_ONCE(abort_flag) = true;</span>
<span class="p_add">+		WRITE_ONCE(abort_flag, true);</span>
 
 	cpuidle_coupled_parallel_barrier(dev, &amp;abort_barrier);
 
<span class="p_header">diff --git a/arch/arm/vdso/vgettimeofday.c b/arch/arm/vdso/vgettimeofday.c</span>
<span class="p_header">index 79214d5ff097..a9dd619c6c29 100644</span>
<span class="p_header">--- a/arch/arm/vdso/vgettimeofday.c</span>
<span class="p_header">+++ b/arch/arm/vdso/vgettimeofday.c</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> static notrace u32 __vdso_read_begin(const struct vdso_data *vdata)</span>
 {
 	u32 seq;
 repeat:
<span class="p_del">-	seq = ACCESS_ONCE(vdata-&gt;seq_count);</span>
<span class="p_add">+	seq = READ_ONCE(vdata-&gt;seq_count);</span>
 	if (seq &amp; 1) {
 		cpu_relax();
 		goto repeat;
<span class="p_header">diff --git a/arch/ia64/include/asm/spinlock.h b/arch/ia64/include/asm/spinlock.h</span>
<span class="p_header">index df2c121164b8..9c1f0b3b7ef5 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/spinlock.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/spinlock.h</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"> static __always_inline void __ticket_spin_lock(arch_spinlock_t *lock)</span>
 
 static __always_inline int __ticket_spin_trylock(arch_spinlock_t *lock)
 {
<span class="p_del">-	int tmp = ACCESS_ONCE(lock-&gt;lock);</span>
<span class="p_add">+	int tmp = READ_ONCE(lock-&gt;lock);</span>
 
 	if (!(((tmp &gt;&gt; TICKET_SHIFT) ^ tmp) &amp; TICKET_MASK))
 		return ia64_cmpxchg(acq, &amp;lock-&gt;lock, tmp, tmp + 1, sizeof (tmp)) == tmp;
<span class="p_chunk">@@ -73,19 +73,19 @@</span> <span class="p_context"> static __always_inline void __ticket_spin_unlock(arch_spinlock_t *lock)</span>
 	unsigned short	*p = (unsigned short *)&amp;lock-&gt;lock + 1, tmp;
 
 	asm volatile (&quot;ld2.bias %0=[%1]&quot; : &quot;=r&quot;(tmp) : &quot;r&quot;(p));
<span class="p_del">-	ACCESS_ONCE(*p) = (tmp + 2) &amp; ~1;</span>
<span class="p_add">+	WRITE_ONCE(*p, (tmp + 2) &amp; ~1);</span>
 }
 
 static inline int __ticket_spin_is_locked(arch_spinlock_t *lock)
 {
<span class="p_del">-	long tmp = ACCESS_ONCE(lock-&gt;lock);</span>
<span class="p_add">+	long tmp = READ_ONCE(lock-&gt;lock);</span>
 
 	return !!(((tmp &gt;&gt; TICKET_SHIFT) ^ tmp) &amp; TICKET_MASK);
 }
 
 static inline int __ticket_spin_is_contended(arch_spinlock_t *lock)
 {
<span class="p_del">-	long tmp = ACCESS_ONCE(lock-&gt;lock);</span>
<span class="p_add">+	long tmp = READ_ONCE(lock-&gt;lock);</span>
 
 	return ((tmp - (tmp &gt;&gt; TICKET_SHIFT)) &amp; TICKET_MASK) &gt; 1;
 }
<span class="p_header">diff --git a/arch/mips/include/asm/vdso.h b/arch/mips/include/asm/vdso.h</span>
<span class="p_header">index b7cd6cf77b83..91bf0c2c265c 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/vdso.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/vdso.h</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> static inline u32 vdso_data_read_begin(const union mips_vdso_data *data)</span>
 	u32 seq;
 
 	while (true) {
<span class="p_del">-		seq = ACCESS_ONCE(data-&gt;seq_count);</span>
<span class="p_add">+		seq = READ_ONCE(data-&gt;seq_count);</span>
 		if (likely(!(seq &amp; 1))) {
 			/* Paired with smp_wmb() in vdso_data_write_*(). */
 			smp_rmb();
<span class="p_header">diff --git a/arch/mips/kernel/pm-cps.c b/arch/mips/kernel/pm-cps.c</span>
<span class="p_header">index 4655017f2377..1d2996cd58da 100644</span>
<span class="p_header">--- a/arch/mips/kernel/pm-cps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/pm-cps.c</span>
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> int cps_pm_enter_state(enum cps_pm_state state)</span>
 	nc_core_ready_count = nc_addr;
 
 	/* Ensure ready_count is zero-initialised before the assembly runs */
<span class="p_del">-	ACCESS_ONCE(*nc_core_ready_count) = 0;</span>
<span class="p_add">+	WRITE_ONCE(*nc_core_ready_count, 0);</span>
 	coupled_barrier(&amp;per_cpu(pm_barrier, core), online);
 
 	/* Run the generated entry code */
<span class="p_header">diff --git a/arch/mn10300/kernel/mn10300-serial.c b/arch/mn10300/kernel/mn10300-serial.c</span>
<span class="p_header">index 7ecf69879e2d..d7ef1232a82a 100644</span>
<span class="p_header">--- a/arch/mn10300/kernel/mn10300-serial.c</span>
<span class="p_header">+++ b/arch/mn10300/kernel/mn10300-serial.c</span>
<span class="p_chunk">@@ -543,7 +543,7 @@</span> <span class="p_context"> static void mn10300_serial_receive_interrupt(struct mn10300_serial_port *port)</span>
 
 try_again:
 	/* pull chars out of the hat */
<span class="p_del">-	ix = ACCESS_ONCE(port-&gt;rx_outp);</span>
<span class="p_add">+	ix = READ_ONCE(port-&gt;rx_outp);</span>
 	if (CIRC_CNT(port-&gt;rx_inp, ix, MNSC_BUFFER_SIZE) == 0) {
 		if (push &amp;&amp; !tport-&gt;low_latency)
 			tty_flip_buffer_push(tport);
<span class="p_chunk">@@ -1724,7 +1724,7 @@</span> <span class="p_context"> static int mn10300_serial_poll_get_char(struct uart_port *_port)</span>
 	if (mn10300_serial_int_tbl[port-&gt;rx_irq].port != NULL) {
 		do {
 			/* pull chars out of the hat */
<span class="p_del">-			ix = ACCESS_ONCE(port-&gt;rx_outp);</span>
<span class="p_add">+			ix = READ_ONCE(port-&gt;rx_outp);</span>
 			if (CIRC_CNT(port-&gt;rx_inp, ix, MNSC_BUFFER_SIZE) == 0)
 				return NO_POLL_CHAR;
 
<span class="p_header">diff --git a/arch/parisc/include/asm/atomic.h b/arch/parisc/include/asm/atomic.h</span>
<span class="p_header">index 17b98a87e5e2..c57d4e8307f2 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/atomic.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/atomic.h</span>
<span class="p_chunk">@@ -260,7 +260,7 @@</span> <span class="p_context"> atomic64_set(atomic64_t *v, s64 i)</span>
 static __inline__ s64
 atomic64_read(const atomic64_t *v)
 {
<span class="p_del">-	return ACCESS_ONCE((v)-&gt;counter);</span>
<span class="p_add">+	return READ_ONCE((v)-&gt;counter);</span>
 }
 
 #define atomic64_inc(v)		(atomic64_add(   1,(v)))
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal-msglog.c b/arch/powerpc/platforms/powernv/opal-msglog.c</span>
<span class="p_header">index 7a9cde0cfbd1..acd3206dfae3 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal-msglog.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal-msglog.c</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> ssize_t opal_msglog_copy(char *to, loff_t pos, size_t count)</span>
 	if (!opal_memcons)
 		return -ENODEV;
 
<span class="p_del">-	out_pos = be32_to_cpu(ACCESS_ONCE(opal_memcons-&gt;out_pos));</span>
<span class="p_add">+	out_pos = be32_to_cpu(READ_ONCE(opal_memcons-&gt;out_pos));</span>
 
 	/* Now we&#39;ve read out_pos, put a barrier in before reading the new
 	 * data it points to in conbuf. */
<span class="p_header">diff --git a/arch/s390/include/asm/spinlock.h b/arch/s390/include/asm/spinlock.h</span>
<span class="p_header">index 8182b521c42f..fc03f9dc7cd1 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/spinlock.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/spinlock.h</span>
<span class="p_chunk">@@ -130,14 +130,14 @@</span> <span class="p_context"> extern int _raw_write_trylock_retry(arch_rwlock_t *lp);</span>
 
 static inline int arch_read_trylock_once(arch_rwlock_t *rw)
 {
<span class="p_del">-	int old = ACCESS_ONCE(rw-&gt;lock);</span>
<span class="p_add">+	int old = READ_ONCE(rw-&gt;lock);</span>
 	return likely(old &gt;= 0 &amp;&amp;
 		      __atomic_cmpxchg_bool(&amp;rw-&gt;lock, old, old + 1));
 }
 
 static inline int arch_write_trylock_once(arch_rwlock_t *rw)
 {
<span class="p_del">-	int old = ACCESS_ONCE(rw-&gt;lock);</span>
<span class="p_add">+	int old = READ_ONCE(rw-&gt;lock);</span>
 	return likely(old == 0 &amp;&amp;
 		      __atomic_cmpxchg_bool(&amp;rw-&gt;lock, 0, 0x80000000));
 }
<span class="p_chunk">@@ -224,7 +224,7 @@</span> <span class="p_context"> static inline void arch_read_unlock(arch_rwlock_t *rw)</span>
 	int old;
 
 	do {
<span class="p_del">-		old = ACCESS_ONCE(rw-&gt;lock);</span>
<span class="p_add">+		old = READ_ONCE(rw-&gt;lock);</span>
 	} while (!__atomic_cmpxchg_bool(&amp;rw-&gt;lock, old, old - 1));
 }
 
<span class="p_header">diff --git a/arch/s390/lib/spinlock.c b/arch/s390/lib/spinlock.c</span>
<span class="p_header">index b12663d653d8..34e30b9ea234 100644</span>
<span class="p_header">--- a/arch/s390/lib/spinlock.c</span>
<span class="p_header">+++ b/arch/s390/lib/spinlock.c</span>
<span class="p_chunk">@@ -162,8 +162,8 @@</span> <span class="p_context"> void _raw_read_lock_wait(arch_rwlock_t *rw)</span>
 				smp_yield_cpu(~owner);
 			count = spin_retry;
 		}
<span class="p_del">-		old = ACCESS_ONCE(rw-&gt;lock);</span>
<span class="p_del">-		owner = ACCESS_ONCE(rw-&gt;owner);</span>
<span class="p_add">+		old = READ_ONCE(rw-&gt;lock);</span>
<span class="p_add">+		owner = READ_ONCE(rw-&gt;owner);</span>
 		if (old &lt; 0)
 			continue;
 		if (__atomic_cmpxchg_bool(&amp;rw-&gt;lock, old, old + 1))
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"> int _raw_read_trylock_retry(arch_rwlock_t *rw)</span>
 	int old;
 
 	while (count-- &gt; 0) {
<span class="p_del">-		old = ACCESS_ONCE(rw-&gt;lock);</span>
<span class="p_add">+		old = READ_ONCE(rw-&gt;lock);</span>
 		if (old &lt; 0)
 			continue;
 		if (__atomic_cmpxchg_bool(&amp;rw-&gt;lock, old, old + 1))
<span class="p_chunk">@@ -202,8 +202,8 @@</span> <span class="p_context"> void _raw_write_lock_wait(arch_rwlock_t *rw, int prev)</span>
 				smp_yield_cpu(~owner);
 			count = spin_retry;
 		}
<span class="p_del">-		old = ACCESS_ONCE(rw-&gt;lock);</span>
<span class="p_del">-		owner = ACCESS_ONCE(rw-&gt;owner);</span>
<span class="p_add">+		old = READ_ONCE(rw-&gt;lock);</span>
<span class="p_add">+		owner = READ_ONCE(rw-&gt;owner);</span>
 		smp_mb();
 		if (old &gt;= 0) {
 			prev = __RAW_LOCK(&amp;rw-&gt;lock, 0x80000000, __RAW_OP_OR);
<span class="p_chunk">@@ -230,8 +230,8 @@</span> <span class="p_context"> void _raw_write_lock_wait(arch_rwlock_t *rw)</span>
 				smp_yield_cpu(~owner);
 			count = spin_retry;
 		}
<span class="p_del">-		old = ACCESS_ONCE(rw-&gt;lock);</span>
<span class="p_del">-		owner = ACCESS_ONCE(rw-&gt;owner);</span>
<span class="p_add">+		old = READ_ONCE(rw-&gt;lock);</span>
<span class="p_add">+		owner = READ_ONCE(rw-&gt;owner);</span>
 		if (old &gt;= 0 &amp;&amp;
 		    __atomic_cmpxchg_bool(&amp;rw-&gt;lock, old, old | 0x80000000))
 			prev = old;
<span class="p_chunk">@@ -251,7 +251,7 @@</span> <span class="p_context"> int _raw_write_trylock_retry(arch_rwlock_t *rw)</span>
 	int old;
 
 	while (count-- &gt; 0) {
<span class="p_del">-		old = ACCESS_ONCE(rw-&gt;lock);</span>
<span class="p_add">+		old = READ_ONCE(rw-&gt;lock);</span>
 		if (old)
 			continue;
 		if (__atomic_cmpxchg_bool(&amp;rw-&gt;lock, 0, 0x80000000))
<span class="p_header">diff --git a/arch/sparc/include/asm/atomic_32.h b/arch/sparc/include/asm/atomic_32.h</span>
<span class="p_header">index 7643e979e333..e2f398e9456c 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/atomic_32.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/atomic_32.h</span>
<span class="p_chunk">@@ -31,7 +31,7 @@</span> <span class="p_context"> void atomic_set(atomic_t *, int);</span>
 
 #define atomic_set_release(v, i)	atomic_set((v), (i))
 
<span class="p_del">-#define atomic_read(v)          ACCESS_ONCE((v)-&gt;counter)</span>
<span class="p_add">+#define atomic_read(v)          READ_ONCE((v)-&gt;counter)</span>
 
 #define atomic_add(i, v)	((void)atomic_add_return( (int)(i), (v)))
 #define atomic_sub(i, v)	((void)atomic_add_return(-(int)(i), (v)))
<span class="p_header">diff --git a/arch/tile/gxio/dma_queue.c b/arch/tile/gxio/dma_queue.c</span>
<span class="p_header">index baa60357f8ba..b7ba577d82ca 100644</span>
<span class="p_header">--- a/arch/tile/gxio/dma_queue.c</span>
<span class="p_header">+++ b/arch/tile/gxio/dma_queue.c</span>
<span class="p_chunk">@@ -163,14 +163,14 @@</span> <span class="p_context"> int __gxio_dma_queue_is_complete(__gxio_dma_queue_t *dma_queue,</span>
 				 int64_t completion_slot, int update)
 {
 	if (update) {
<span class="p_del">-		if (ACCESS_ONCE(dma_queue-&gt;hw_complete_count) &gt;</span>
<span class="p_add">+		if (READ_ONCE(dma_queue-&gt;hw_complete_count) &gt;</span>
 		    completion_slot)
 			return 1;
 
 		__gxio_dma_queue_update_credits(dma_queue);
 	}
 
<span class="p_del">-	return ACCESS_ONCE(dma_queue-&gt;hw_complete_count) &gt; completion_slot;</span>
<span class="p_add">+	return READ_ONCE(dma_queue-&gt;hw_complete_count) &gt; completion_slot;</span>
 }
 
 EXPORT_SYMBOL_GPL(__gxio_dma_queue_is_complete);
<span class="p_header">diff --git a/arch/tile/include/gxio/dma_queue.h b/arch/tile/include/gxio/dma_queue.h</span>
<span class="p_header">index b9e45e37649e..c8fd47edba30 100644</span>
<span class="p_header">--- a/arch/tile/include/gxio/dma_queue.h</span>
<span class="p_header">+++ b/arch/tile/include/gxio/dma_queue.h</span>
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"> static inline int64_t __gxio_dma_queue_reserve(__gxio_dma_queue_t *dma_queue,</span>
 		 * if the result is LESS than &quot;hw_complete_count&quot;.
 		 */
 		uint64_t complete;
<span class="p_del">-		complete = ACCESS_ONCE(dma_queue-&gt;hw_complete_count);</span>
<span class="p_add">+		complete = READ_ONCE(dma_queue-&gt;hw_complete_count);</span>
 		slot |= (complete &amp; 0xffffffffff000000);
 		if (slot &lt; complete)
 			slot += 0x1000000;
<span class="p_header">diff --git a/arch/tile/kernel/ptrace.c b/arch/tile/kernel/ptrace.c</span>
<span class="p_header">index e1a078e6828e..d516d61751c2 100644</span>
<span class="p_header">--- a/arch/tile/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/tile/kernel/ptrace.c</span>
<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> long compat_arch_ptrace(struct task_struct *child, compat_long_t request,</span>
 
 int do_syscall_trace_enter(struct pt_regs *regs)
 {
<span class="p_del">-	u32 work = ACCESS_ONCE(current_thread_info()-&gt;flags);</span>
<span class="p_add">+	u32 work = READ_ONCE(current_thread_info()-&gt;flags);</span>
 
 	if ((work &amp; _TIF_SYSCALL_TRACE) &amp;&amp;
 	    tracehook_report_syscall_entry(regs)) {
<span class="p_header">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span>
<span class="p_header">index 03505ffbe1b6..eaa0ba66cf96 100644</span>
<span class="p_header">--- a/arch/x86/entry/common.c</span>
<span class="p_header">+++ b/arch/x86/entry/common.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> static long syscall_trace_enter(struct pt_regs *regs)</span>
 	if (IS_ENABLED(CONFIG_DEBUG_ENTRY))
 		BUG_ON(regs != task_pt_regs(current));
 
<span class="p_del">-	work = ACCESS_ONCE(ti-&gt;flags) &amp; _TIF_WORK_SYSCALL_ENTRY;</span>
<span class="p_add">+	work = READ_ONCE(ti-&gt;flags) &amp; _TIF_WORK_SYSCALL_ENTRY;</span>
 
 	if (unlikely(work &amp; _TIF_SYSCALL_EMU))
 		emulated = true;
<span class="p_header">diff --git a/arch/x86/entry/vdso/vclock_gettime.c b/arch/x86/entry/vdso/vclock_gettime.c</span>
<span class="p_header">index fa8dbfcf7ed3..11b13c4b43d5 100644</span>
<span class="p_header">--- a/arch/x86/entry/vdso/vclock_gettime.c</span>
<span class="p_header">+++ b/arch/x86/entry/vdso/vclock_gettime.c</span>
<span class="p_chunk">@@ -318,7 +318,7 @@</span> <span class="p_context"> int gettimeofday(struct timeval *, struct timezone *)</span>
 notrace time_t __vdso_time(time_t *t)
 {
 	/* This is atomic on x86 so we don&#39;t need any locks. */
<span class="p_del">-	time_t result = ACCESS_ONCE(gtod-&gt;wall_time_sec);</span>
<span class="p_add">+	time_t result = READ_ONCE(gtod-&gt;wall_time_sec);</span>
 
 	if (t)
 		*t = result;
<span class="p_header">diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c</span>
<span class="p_header">index 589af1eec7c1..140d33288e78 100644</span>
<span class="p_header">--- a/arch/x86/events/core.c</span>
<span class="p_header">+++ b/arch/x86/events/core.c</span>
<span class="p_chunk">@@ -2118,7 +2118,7 @@</span> <span class="p_context"> static int x86_pmu_event_init(struct perf_event *event)</span>
 			event-&gt;destroy(event);
 	}
 
<span class="p_del">-	if (ACCESS_ONCE(x86_pmu.attr_rdpmc))</span>
<span class="p_add">+	if (READ_ONCE(x86_pmu.attr_rdpmc))</span>
 		event-&gt;hw.flags |= PERF_X86_EVENT_RDPMC_ALLOWED;
 
 	return err;
<span class="p_header">diff --git a/arch/x86/include/asm/vgtod.h b/arch/x86/include/asm/vgtod.h</span>
<span class="p_header">index 022e59714562..53dd162576a8 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/vgtod.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/vgtod.h</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> static inline unsigned gtod_read_begin(const struct vsyscall_gtod_data *s)</span>
 	unsigned ret;
 
 repeat:
<span class="p_del">-	ret = ACCESS_ONCE(s-&gt;seq);</span>
<span class="p_add">+	ret = READ_ONCE(s-&gt;seq);</span>
 	if (unlikely(ret &amp; 1)) {
 		cpu_relax();
 		goto repeat;
<span class="p_header">diff --git a/arch/x86/kernel/espfix_64.c b/arch/x86/kernel/espfix_64.c</span>
<span class="p_header">index 9c4e7ba6870c..7d7715dde901 100644</span>
<span class="p_header">--- a/arch/x86/kernel/espfix_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/espfix_64.c</span>
<span class="p_chunk">@@ -155,14 +155,14 @@</span> <span class="p_context"> void init_espfix_ap(int cpu)</span>
 	page = cpu/ESPFIX_STACKS_PER_PAGE;
 
 	/* Did another CPU already set this up? */
<span class="p_del">-	stack_page = ACCESS_ONCE(espfix_pages[page]);</span>
<span class="p_add">+	stack_page = READ_ONCE(espfix_pages[page]);</span>
 	if (likely(stack_page))
 		goto done;
 
 	mutex_lock(&amp;espfix_init_mutex);
 
 	/* Did we race on the lock? */
<span class="p_del">-	stack_page = ACCESS_ONCE(espfix_pages[page]);</span>
<span class="p_add">+	stack_page = READ_ONCE(espfix_pages[page]);</span>
 	if (stack_page)
 		goto unlock_done;
 
<span class="p_chunk">@@ -200,7 +200,7 @@</span> <span class="p_context"> void init_espfix_ap(int cpu)</span>
 		set_pte(&amp;pte_p[n*PTE_STRIDE], pte);
 
 	/* Job is done for this CPU and any CPU which shares this page */
<span class="p_del">-	ACCESS_ONCE(espfix_pages[page]) = stack_page;</span>
<span class="p_add">+	WRITE_ONCE(espfix_pages[page], stack_page);</span>
 
 unlock_done:
 	mutex_unlock(&amp;espfix_init_mutex);
<span class="p_header">diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c</span>
<span class="p_header">index 35aafc95e4b8..18bc9b51ac9b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/nmi.c</span>
<span class="p_header">+++ b/arch/x86/kernel/nmi.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static void nmi_max_handler(struct irq_work *w)</span>
 {
 	struct nmiaction *a = container_of(w, struct nmiaction, irq_work);
 	int remainder_ns, decimal_msecs;
<span class="p_del">-	u64 whole_msecs = ACCESS_ONCE(a-&gt;max_duration);</span>
<span class="p_add">+	u64 whole_msecs = READ_ONCE(a-&gt;max_duration);</span>
 
 	remainder_ns = do_div(whole_msecs, (1000 * 1000));
 	decimal_msecs = remainder_ns / 1000;
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index 106d4a029a8a..af19a4291d54 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -443,7 +443,7 @@</span> <span class="p_context"> static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)</span>
 
 static u64 __get_spte_lockless(u64 *sptep)
 {
<span class="p_del">-	return ACCESS_ONCE(*sptep);</span>
<span class="p_add">+	return READ_ONCE(*sptep);</span>
 }
 #else
 union split_spte {
<span class="p_chunk">@@ -4818,7 +4818,7 @@</span> <span class="p_context"> static void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 	 * If we don&#39;t have indirect shadow pages, it means no page is
 	 * write-protected, so we can exit simply.
 	 */
<span class="p_del">-	if (!ACCESS_ONCE(vcpu-&gt;kvm-&gt;arch.indirect_shadow_pages))</span>
<span class="p_add">+	if (!READ_ONCE(vcpu-&gt;kvm-&gt;arch.indirect_shadow_pages))</span>
 		return;
 
 	remote_flush = local_flush = false;
<span class="p_header">diff --git a/arch/x86/kvm/page_track.c b/arch/x86/kvm/page_track.c</span>
<span class="p_header">index ea67dc876316..01c1371f39f8 100644</span>
<span class="p_header">--- a/arch/x86/kvm/page_track.c</span>
<span class="p_header">+++ b/arch/x86/kvm/page_track.c</span>
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> bool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,</span>
 		return false;
 
 	index = gfn_to_index(gfn, slot-&gt;base_gfn, PT_PAGE_TABLE_LEVEL);
<span class="p_del">-	return !!ACCESS_ONCE(slot-&gt;arch.gfn_track[mode][index]);</span>
<span class="p_add">+	return !!READ_ONCE(slot-&gt;arch.gfn_track[mode][index]);</span>
 }
 
 void kvm_page_track_cleanup(struct kvm *kvm)
<span class="p_header">diff --git a/arch/x86/xen/p2m.c b/arch/x86/xen/p2m.c</span>
<span class="p_header">index 6083ba462f35..13b4f19b9131 100644</span>
<span class="p_header">--- a/arch/x86/xen/p2m.c</span>
<span class="p_header">+++ b/arch/x86/xen/p2m.c</span>
<span class="p_chunk">@@ -547,7 +547,7 @@</span> <span class="p_context"> int xen_alloc_p2m_entry(unsigned long pfn)</span>
 	if (p2m_top_mfn &amp;&amp; pfn &lt; MAX_P2M_PFN) {
 		topidx = p2m_top_index(pfn);
 		top_mfn_p = &amp;p2m_top_mfn[topidx];
<span class="p_del">-		mid_mfn = ACCESS_ONCE(p2m_top_mfn_p[topidx]);</span>
<span class="p_add">+		mid_mfn = READ_ONCE(p2m_top_mfn_p[topidx]);</span>
 
 		BUG_ON(virt_to_mfn(mid_mfn) != *top_mfn_p);
 
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/lcd.c b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">index 4dc0c1b43f4b..2f7eb66c23ec 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_chunk">@@ -34,23 +34,23 @@</span> <span class="p_context"></span>
 static void lcd_put_byte(u8 *addr, u8 data)
 {
 #ifdef CONFIG_XTFPGA_LCD_8BIT_ACCESS
<span class="p_del">-	ACCESS_ONCE(*addr) = data;</span>
<span class="p_add">+	WRITE_ONCE(*addr, data);</span>
 #else
<span class="p_del">-	ACCESS_ONCE(*addr) = data &amp; 0xf0;</span>
<span class="p_del">-	ACCESS_ONCE(*addr) = (data &lt;&lt; 4) &amp; 0xf0;</span>
<span class="p_add">+	WRITE_ONCE(*addr, data &amp; 0xf0);</span>
<span class="p_add">+	WRITE_ONCE(*addr, (data &lt;&lt; 4) &amp; 0xf0);</span>
 #endif
 }
 
 static int __init lcd_init(void)
 {
<span class="p_del">-	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	WRITE_ONCE(*LCD_INSTR_ADDR, LCD_DISPLAY_MODE8BIT);</span>
 	mdelay(5);
<span class="p_del">-	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	WRITE_ONCE(*LCD_INSTR_ADDR, LCD_DISPLAY_MODE8BIT);</span>
 	udelay(200);
<span class="p_del">-	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	WRITE_ONCE(*LCD_INSTR_ADDR, LCD_DISPLAY_MODE8BIT);</span>
 	udelay(50);
 #ifndef CONFIG_XTFPGA_LCD_8BIT_ACCESS
<span class="p_del">-	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE4BIT;</span>
<span class="p_add">+	WRITE_ONCE(*LCD_INSTR_ADDR, LCD_DISPLAY_MODE4BIT);</span>
 	udelay(50);
 	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_MODE4BIT);
 	udelay(50);
<span class="p_header">diff --git a/block/blk-wbt.c b/block/blk-wbt.c</span>
<span class="p_header">index 6a9a0f03a67b..d822530e6aea 100644</span>
<span class="p_header">--- a/block/blk-wbt.c</span>
<span class="p_header">+++ b/block/blk-wbt.c</span>
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> static inline bool stat_sample_valid(struct blk_rq_stat *stat)</span>
 
 static u64 rwb_sync_issue_lat(struct rq_wb *rwb)
 {
<span class="p_del">-	u64 now, issue = ACCESS_ONCE(rwb-&gt;sync_issue);</span>
<span class="p_add">+	u64 now, issue = READ_ONCE(rwb-&gt;sync_issue);</span>
 
 	if (!issue || !rwb-&gt;sync_cookie)
 		return 0;
<span class="p_header">diff --git a/drivers/base/core.c b/drivers/base/core.c</span>
<span class="p_header">index 12ebd055724c..4b8ba2a75a4d 100644</span>
<span class="p_header">--- a/drivers/base/core.c</span>
<span class="p_header">+++ b/drivers/base/core.c</span>
<span class="p_chunk">@@ -668,7 +668,7 @@</span> <span class="p_context"> const char *dev_driver_string(const struct device *dev)</span>
 	 * so be careful about accessing it.  dev-&gt;bus and dev-&gt;class should
 	 * never change once they are set, so they don&#39;t need special care.
 	 */
<span class="p_del">-	drv = ACCESS_ONCE(dev-&gt;driver);</span>
<span class="p_add">+	drv = READ_ONCE(dev-&gt;driver);</span>
 	return drv ? drv-&gt;name :
 			(dev-&gt;bus ? dev-&gt;bus-&gt;name :
 			(dev-&gt;class ? dev-&gt;class-&gt;name : &quot;&quot;));
<span class="p_header">diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c</span>
<span class="p_header">index 7bcf80fa9ada..41d7c2b99f69 100644</span>
<span class="p_header">--- a/drivers/base/power/runtime.c</span>
<span class="p_header">+++ b/drivers/base/power/runtime.c</span>
<span class="p_chunk">@@ -134,11 +134,11 @@</span> <span class="p_context"> unsigned long pm_runtime_autosuspend_expiration(struct device *dev)</span>
 	if (!dev-&gt;power.use_autosuspend)
 		goto out;
 
<span class="p_del">-	autosuspend_delay = ACCESS_ONCE(dev-&gt;power.autosuspend_delay);</span>
<span class="p_add">+	autosuspend_delay = READ_ONCE(dev-&gt;power.autosuspend_delay);</span>
 	if (autosuspend_delay &lt; 0)
 		goto out;
 
<span class="p_del">-	last_busy = ACCESS_ONCE(dev-&gt;power.last_busy);</span>
<span class="p_add">+	last_busy = READ_ONCE(dev-&gt;power.last_busy);</span>
 	elapsed = jiffies - last_busy;
 	if (elapsed &lt; 0)
 		goto out;	/* jiffies has wrapped around. */
<span class="p_header">diff --git a/drivers/char/random.c b/drivers/char/random.c</span>
<span class="p_header">index 8ad92707e45f..6c7ccac2679e 100644</span>
<span class="p_header">--- a/drivers/char/random.c</span>
<span class="p_header">+++ b/drivers/char/random.c</span>
<span class="p_chunk">@@ -641,7 +641,7 @@</span> <span class="p_context"> static void credit_entropy_bits(struct entropy_store *r, int nbits)</span>
 		return;
 
 retry:
<span class="p_del">-	entropy_count = orig = ACCESS_ONCE(r-&gt;entropy_count);</span>
<span class="p_add">+	entropy_count = orig = READ_ONCE(r-&gt;entropy_count);</span>
 	if (nfrac &lt; 0) {
 		/* Debit */
 		entropy_count += nfrac;
<span class="p_chunk">@@ -1265,7 +1265,7 @@</span> <span class="p_context"> static size_t account(struct entropy_store *r, size_t nbytes, int min,</span>
 
 	/* Can we pull enough? */
 retry:
<span class="p_del">-	entropy_count = orig = ACCESS_ONCE(r-&gt;entropy_count);</span>
<span class="p_add">+	entropy_count = orig = READ_ONCE(r-&gt;entropy_count);</span>
 	ibytes = nbytes;
 	/* never pull more than available */
 	have_bytes = entropy_count &gt;&gt; (ENTROPY_SHIFT + 3);
<span class="p_header">diff --git a/drivers/clocksource/bcm2835_timer.c b/drivers/clocksource/bcm2835_timer.c</span>
<span class="p_header">index 39e489a96ad7..60da2537bef9 100644</span>
<span class="p_header">--- a/drivers/clocksource/bcm2835_timer.c</span>
<span class="p_header">+++ b/drivers/clocksource/bcm2835_timer.c</span>
<span class="p_chunk">@@ -71,7 +71,7 @@</span> <span class="p_context"> static irqreturn_t bcm2835_time_interrupt(int irq, void *dev_id)</span>
 	if (readl_relaxed(timer-&gt;control) &amp; timer-&gt;match_mask) {
 		writel_relaxed(timer-&gt;match_mask, timer-&gt;control);
 
<span class="p_del">-		event_handler = ACCESS_ONCE(timer-&gt;evt.event_handler);</span>
<span class="p_add">+		event_handler = READ_ONCE(timer-&gt;evt.event_handler);</span>
 		if (event_handler)
 			event_handler(&amp;timer-&gt;evt);
 		return IRQ_HANDLED;
<span class="p_header">diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c</span>
<span class="p_header">index d258953ff488..f4f258075b89 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/jr.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/jr.c</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> static void caam_jr_dequeue(unsigned long devarg)</span>
 
 	while (rd_reg32(&amp;jrp-&gt;rregs-&gt;outring_used)) {
 
<span class="p_del">-		head = ACCESS_ONCE(jrp-&gt;head);</span>
<span class="p_add">+		head = READ_ONCE(jrp-&gt;head);</span>
 
 		spin_lock(&amp;jrp-&gt;outlock);
 
<span class="p_chunk">@@ -341,7 +341,7 @@</span> <span class="p_context"> int caam_jr_enqueue(struct device *dev, u32 *desc,</span>
 	spin_lock_bh(&amp;jrp-&gt;inplock);
 
 	head = jrp-&gt;head;
<span class="p_del">-	tail = ACCESS_ONCE(jrp-&gt;tail);</span>
<span class="p_add">+	tail = READ_ONCE(jrp-&gt;tail);</span>
 
 	if (!rd_reg32(&amp;jrp-&gt;rregs-&gt;inpring_avail) ||
 	    CIRC_SPACE(head, tail, JOBR_DEPTH) &lt;= 0) {
<span class="p_header">diff --git a/drivers/crypto/nx/nx-842-powernv.c b/drivers/crypto/nx/nx-842-powernv.c</span>
<span class="p_header">index 874ddf5e9087..0f20f5ec9617 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-842-powernv.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-842-powernv.c</span>
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> static int wait_for_csb(struct nx842_workmem *wmem,</span>
 	ktime_t start = wmem-&gt;start, now = ktime_get();
 	ktime_t timeout = ktime_add_ms(start, CSB_WAIT_MAX);
 
<span class="p_del">-	while (!(ACCESS_ONCE(csb-&gt;flags) &amp; CSB_V)) {</span>
<span class="p_add">+	while (!(READ_ONCE(csb-&gt;flags) &amp; CSB_V)) {</span>
 		cpu_relax();
 		now = ktime_get();
 		if (ktime_after(now, timeout))
<span class="p_header">diff --git a/drivers/firewire/ohci.c b/drivers/firewire/ohci.c</span>
<span class="p_header">index 8bf89267dc25..ccf52368a073 100644</span>
<span class="p_header">--- a/drivers/firewire/ohci.c</span>
<span class="p_header">+++ b/drivers/firewire/ohci.c</span>
<span class="p_chunk">@@ -734,7 +734,7 @@</span> <span class="p_context"> static unsigned int ar_search_last_active_buffer(struct ar_context *ctx,</span>
 	__le16 res_count, next_res_count;
 
 	i = ar_first_buffer_index(ctx);
<span class="p_del">-	res_count = ACCESS_ONCE(ctx-&gt;descriptors[i].res_count);</span>
<span class="p_add">+	res_count = READ_ONCE(ctx-&gt;descriptors[i].res_count);</span>
 
 	/* A buffer that is not yet completely filled must be the last one. */
 	while (i != last &amp;&amp; res_count == 0) {
<span class="p_chunk">@@ -742,8 +742,7 @@</span> <span class="p_context"> static unsigned int ar_search_last_active_buffer(struct ar_context *ctx,</span>
 		/* Peek at the next descriptor. */
 		next_i = ar_next_buffer_index(i);
 		rmb(); /* read descriptors in order */
<span class="p_del">-		next_res_count = ACCESS_ONCE(</span>
<span class="p_del">-				ctx-&gt;descriptors[next_i].res_count);</span>
<span class="p_add">+		next_res_count = READ_ONCE(ctx-&gt;descriptors[next_i].res_count);</span>
 		/*
 		 * If the next descriptor is still empty, we must stop at this
 		 * descriptor.
<span class="p_chunk">@@ -759,8 +758,7 @@</span> <span class="p_context"> static unsigned int ar_search_last_active_buffer(struct ar_context *ctx,</span>
 			if (MAX_AR_PACKET_SIZE &gt; PAGE_SIZE &amp;&amp; i != last) {
 				next_i = ar_next_buffer_index(next_i);
 				rmb();
<span class="p_del">-				next_res_count = ACCESS_ONCE(</span>
<span class="p_del">-					ctx-&gt;descriptors[next_i].res_count);</span>
<span class="p_add">+				next_res_count = READ_ONCE(ctx-&gt;descriptors[next_i].res_count);</span>
 				if (next_res_count != cpu_to_le16(PAGE_SIZE))
 					goto next_buffer_is_active;
 			}
<span class="p_chunk">@@ -2812,7 +2810,7 @@</span> <span class="p_context"> static int handle_ir_buffer_fill(struct context *context,</span>
 	u32 buffer_dma;
 
 	req_count = le16_to_cpu(last-&gt;req_count);
<span class="p_del">-	res_count = le16_to_cpu(ACCESS_ONCE(last-&gt;res_count));</span>
<span class="p_add">+	res_count = le16_to_cpu(READ_ONCE(last-&gt;res_count));</span>
 	completed = req_count - res_count;
 	buffer_dma = le32_to_cpu(last-&gt;data_address);
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c</span>
<span class="p_header">index 333bad749067..303b5e099a98 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_fence.c</span>
<span class="p_chunk">@@ -260,7 +260,7 @@</span> <span class="p_context"> static void amdgpu_fence_fallback(unsigned long arg)</span>
  */
 int amdgpu_fence_wait_empty(struct amdgpu_ring *ring)
 {
<span class="p_del">-	uint64_t seq = ACCESS_ONCE(ring-&gt;fence_drv.sync_seq);</span>
<span class="p_add">+	uint64_t seq = READ_ONCE(ring-&gt;fence_drv.sync_seq);</span>
 	struct dma_fence *fence, **ptr;
 	int r;
 
<span class="p_chunk">@@ -300,7 +300,7 @@</span> <span class="p_context"> unsigned amdgpu_fence_count_emitted(struct amdgpu_ring *ring)</span>
 	amdgpu_fence_process(ring);
 	emitted = 0x100000000ull;
 	emitted -= atomic_read(&amp;ring-&gt;fence_drv.last_seq);
<span class="p_del">-	emitted += ACCESS_ONCE(ring-&gt;fence_drv.sync_seq);</span>
<span class="p_add">+	emitted += READ_ONCE(ring-&gt;fence_drv.sync_seq);</span>
 	return lower_32_bits(emitted);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c</span>
<span class="p_header">index 7171968f261e..6149a47fe63d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c</span>
<span class="p_chunk">@@ -788,11 +788,11 @@</span> <span class="p_context"> static int amdgpu_debugfs_gem_bo_info(int id, void *ptr, void *data)</span>
 	seq_printf(m, &quot;\t0x%08x: %12ld byte %s&quot;,
 		   id, amdgpu_bo_size(bo), placement);
 
<span class="p_del">-	offset = ACCESS_ONCE(bo-&gt;tbo.mem.start);</span>
<span class="p_add">+	offset = READ_ONCE(bo-&gt;tbo.mem.start);</span>
 	if (offset != AMDGPU_BO_INVALID_OFFSET)
 		seq_printf(m, &quot; @ 0x%010Lx&quot;, offset);
 
<span class="p_del">-	pin_count = ACCESS_ONCE(bo-&gt;pin_count);</span>
<span class="p_add">+	pin_count = READ_ONCE(bo-&gt;pin_count);</span>
 	if (pin_count)
 		seq_printf(m, &quot; pin count %d&quot;, pin_count);
 	seq_printf(m, &quot;\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/scheduler/gpu_scheduler.c b/drivers/gpu/drm/amd/scheduler/gpu_scheduler.c</span>
<span class="p_header">index 97c94f9683fa..46a5ec3eb438 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/scheduler/gpu_scheduler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/scheduler/gpu_scheduler.c</span>
<span class="p_chunk">@@ -187,7 +187,7 @@</span> <span class="p_context"> static bool amd_sched_entity_is_ready(struct amd_sched_entity *entity)</span>
 	if (kfifo_is_empty(&amp;entity-&gt;job_queue))
 		return false;
 
<span class="p_del">-	if (ACCESS_ONCE(entity-&gt;dependency))</span>
<span class="p_add">+	if (READ_ONCE(entity-&gt;dependency))</span>
 		return false;
 
 	return true;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_gem.c b/drivers/gpu/drm/radeon/radeon_gem.c</span>
<span class="p_header">index 3386452bd2f0..cf3deb283da5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_gem.c</span>
<span class="p_chunk">@@ -451,7 +451,7 @@</span> <span class="p_context"> int radeon_gem_busy_ioctl(struct drm_device *dev, void *data,</span>
 	else
 		r = 0;
 
<span class="p_del">-	cur_placement = ACCESS_ONCE(robj-&gt;tbo.mem.mem_type);</span>
<span class="p_add">+	cur_placement = READ_ONCE(robj-&gt;tbo.mem.mem_type);</span>
 	args-&gt;domain = radeon_mem_type_to_domain(cur_placement);
 	drm_gem_object_put_unlocked(gobj);
 	return r;
<span class="p_chunk">@@ -481,7 +481,7 @@</span> <span class="p_context"> int radeon_gem_wait_idle_ioctl(struct drm_device *dev, void *data,</span>
 		r = ret;
 
 	/* Flush HDP cache via MMIO if necessary */
<span class="p_del">-	cur_placement = ACCESS_ONCE(robj-&gt;tbo.mem.mem_type);</span>
<span class="p_add">+	cur_placement = READ_ONCE(robj-&gt;tbo.mem.mem_type);</span>
 	if (rdev-&gt;asic-&gt;mmio_hdp_flush &amp;&amp;
 	    radeon_mem_type_to_domain(cur_placement) == RADEON_GEM_DOMAIN_VRAM)
 		robj-&gt;rdev-&gt;asic-&gt;mmio_hdp_flush(rdev);
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">index a552e4ea5440..6ac094ee8983 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_chunk">@@ -904,7 +904,7 @@</span> <span class="p_context"> vmw_surface_handle_reference(struct vmw_private *dev_priv,</span>
 		if (unlikely(drm_is_render_client(file_priv)))
 			require_exist = true;
 
<span class="p_del">-		if (ACCESS_ONCE(vmw_fpriv(file_priv)-&gt;locked_master)) {</span>
<span class="p_add">+		if (READ_ONCE(vmw_fpriv(file_priv)-&gt;locked_master)) {</span>
 			DRM_ERROR(&quot;Locked master refused legacy &quot;
 				  &quot;surface reference.\n&quot;);
 			return -EACCES;
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/file_ops.c b/drivers/infiniband/hw/hfi1/file_ops.c</span>
<span class="p_header">index d9a1e9893136..97bea2e1aa6a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/file_ops.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/file_ops.c</span>
<span class="p_chunk">@@ -380,7 +380,7 @@</span> <span class="p_context"> static long hfi1_file_ioctl(struct file *fp, unsigned int cmd,</span>
 		if (sc-&gt;flags &amp; SCF_FROZEN) {
 			wait_event_interruptible_timeout(
 				dd-&gt;event_queue,
<span class="p_del">-				!(ACCESS_ONCE(dd-&gt;flags) &amp; HFI1_FROZEN),</span>
<span class="p_add">+				!(READ_ONCE(dd-&gt;flags) &amp; HFI1_FROZEN),</span>
 				msecs_to_jiffies(SEND_CTXT_HALT_TIMEOUT));
 			if (dd-&gt;flags &amp; HFI1_FROZEN)
 				return -ENOLCK;
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/pio.c b/drivers/infiniband/hw/hfi1/pio.c</span>
<span class="p_header">index 7108a4b5e94c..75e740780285 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/pio.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/pio.c</span>
<span class="p_chunk">@@ -1423,14 +1423,14 @@</span> <span class="p_context"> struct pio_buf *sc_buffer_alloc(struct send_context *sc, u32 dw_len,</span>
 			goto done;
 		}
 		/* copy from receiver cache line and recalculate */
<span class="p_del">-		sc-&gt;alloc_free = ACCESS_ONCE(sc-&gt;free);</span>
<span class="p_add">+		sc-&gt;alloc_free = READ_ONCE(sc-&gt;free);</span>
 		avail =
 			(unsigned long)sc-&gt;credits -
 			(sc-&gt;fill - sc-&gt;alloc_free);
 		if (blocks &gt; avail) {
 			/* still no room, actively update */
 			sc_release_update(sc);
<span class="p_del">-			sc-&gt;alloc_free = ACCESS_ONCE(sc-&gt;free);</span>
<span class="p_add">+			sc-&gt;alloc_free = READ_ONCE(sc-&gt;free);</span>
 			trycount++;
 			goto retry;
 		}
<span class="p_chunk">@@ -1667,7 +1667,7 @@</span> <span class="p_context"> void sc_release_update(struct send_context *sc)</span>
 
 	/* call sent buffer callbacks */
 	code = -1;				/* code not yet set */
<span class="p_del">-	head = ACCESS_ONCE(sc-&gt;sr_head);	/* snapshot the head */</span>
<span class="p_add">+	head = READ_ONCE(sc-&gt;sr_head);	/* snapshot the head */</span>
 	tail = sc-&gt;sr_tail;
 	while (head != tail) {
 		pbuf = &amp;sc-&gt;sr[tail].pbuf;
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/ruc.c b/drivers/infiniband/hw/hfi1/ruc.c</span>
<span class="p_header">index b3291f0fde9a..a7fc664f0d4e 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/ruc.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/ruc.c</span>
<span class="p_chunk">@@ -363,7 +363,7 @@</span> <span class="p_context"> static void ruc_loopback(struct rvt_qp *sqp)</span>
 
 again:
 	smp_read_barrier_depends(); /* see post_one_send() */
<span class="p_del">-	if (sqp-&gt;s_last == ACCESS_ONCE(sqp-&gt;s_head))</span>
<span class="p_add">+	if (sqp-&gt;s_last == READ_ONCE(sqp-&gt;s_head))</span>
 		goto clr_busy;
 	wqe = rvt_get_swqe_ptr(sqp, sqp-&gt;s_last);
 
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/sdma.c b/drivers/infiniband/hw/hfi1/sdma.c</span>
<span class="p_header">index 6781bcdb10b3..08346d25441c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/sdma.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/sdma.c</span>
<span class="p_chunk">@@ -1725,7 +1725,7 @@</span> <span class="p_context"> static inline u16 sdma_gethead(struct sdma_engine *sde)</span>
 
 		swhead = sde-&gt;descq_head &amp; sde-&gt;sdma_mask;
 		/* this code is really bad for cache line trading */
<span class="p_del">-		swtail = ACCESS_ONCE(sde-&gt;descq_tail) &amp; sde-&gt;sdma_mask;</span>
<span class="p_add">+		swtail = READ_ONCE(sde-&gt;descq_tail) &amp; sde-&gt;sdma_mask;</span>
 		cnt = sde-&gt;descq_cnt;
 
 		if (swhead &lt; swtail)
<span class="p_chunk">@@ -1872,7 +1872,7 @@</span> <span class="p_context"> static void sdma_make_progress(struct sdma_engine *sde, u64 status)</span>
 	if ((status &amp; sde-&gt;idle_mask) &amp;&amp; !idle_check_done) {
 		u16 swtail;
 
<span class="p_del">-		swtail = ACCESS_ONCE(sde-&gt;descq_tail) &amp; sde-&gt;sdma_mask;</span>
<span class="p_add">+		swtail = READ_ONCE(sde-&gt;descq_tail) &amp; sde-&gt;sdma_mask;</span>
 		if (swtail != hwhead) {
 			hwhead = (u16)read_sde_csr(sde, SD(HEAD));
 			idle_check_done = 1;
<span class="p_chunk">@@ -2222,7 +2222,7 @@</span> <span class="p_context"> void sdma_seqfile_dump_sde(struct seq_file *s, struct sdma_engine *sde)</span>
 	u16 len;
 
 	head = sde-&gt;descq_head &amp; sde-&gt;sdma_mask;
<span class="p_del">-	tail = ACCESS_ONCE(sde-&gt;descq_tail) &amp; sde-&gt;sdma_mask;</span>
<span class="p_add">+	tail = READ_ONCE(sde-&gt;descq_tail) &amp; sde-&gt;sdma_mask;</span>
 	seq_printf(s, SDE_FMT, sde-&gt;this_idx,
 		   sde-&gt;cpu,
 		   sdma_state_name(sde-&gt;state.current_state),
<span class="p_chunk">@@ -3305,7 +3305,7 @@</span> <span class="p_context"> int sdma_ahg_alloc(struct sdma_engine *sde)</span>
 		return -EINVAL;
 	}
 	while (1) {
<span class="p_del">-		nr = ffz(ACCESS_ONCE(sde-&gt;ahg_bits));</span>
<span class="p_add">+		nr = ffz(READ_ONCE(sde-&gt;ahg_bits));</span>
 		if (nr &gt; 31) {
 			trace_hfi1_ahg_allocate(sde, -ENOSPC);
 			return -ENOSPC;
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/sdma.h b/drivers/infiniband/hw/hfi1/sdma.h</span>
<span class="p_header">index 107011d8613b..374c59784950 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/sdma.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/sdma.h</span>
<span class="p_chunk">@@ -445,7 +445,7 @@</span> <span class="p_context"> static inline u16 sdma_descq_freecnt(struct sdma_engine *sde)</span>
 {
 	return sde-&gt;descq_cnt -
 		(sde-&gt;descq_tail -
<span class="p_del">-		 ACCESS_ONCE(sde-&gt;descq_head)) - 1;</span>
<span class="p_add">+		 READ_ONCE(sde-&gt;descq_head)) - 1;</span>
 }
 
 static inline u16 sdma_descq_inprocess(struct sdma_engine *sde)
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/uc.c b/drivers/infiniband/hw/hfi1/uc.c</span>
<span class="p_header">index 0b646173ca22..9a31c585427f 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/uc.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/uc.c</span>
<span class="p_chunk">@@ -80,7 +80,7 @@</span> <span class="p_context"> int hfi1_make_uc_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)</span>
 			goto bail;
 		/* We are in the error state, flush the work request. */
 		smp_read_barrier_depends(); /* see post_one_send() */
<span class="p_del">-		if (qp-&gt;s_last == ACCESS_ONCE(qp-&gt;s_head))</span>
<span class="p_add">+		if (qp-&gt;s_last == READ_ONCE(qp-&gt;s_head))</span>
 			goto bail;
 		/* If DMAs are in progress, we can&#39;t flush immediately. */
 		if (iowait_sdma_pending(&amp;priv-&gt;s_iowait)) {
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"> int hfi1_make_uc_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)</span>
 			goto bail;
 		/* Check if send work queue is empty. */
 		smp_read_barrier_depends(); /* see post_one_send() */
<span class="p_del">-		if (qp-&gt;s_cur == ACCESS_ONCE(qp-&gt;s_head)) {</span>
<span class="p_add">+		if (qp-&gt;s_cur == READ_ONCE(qp-&gt;s_head)) {</span>
 			clear_ahg(qp);
 			goto bail;
 		}
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/ud.c b/drivers/infiniband/hw/hfi1/ud.c</span>
<span class="p_header">index 2ba74fdd6f15..7fec6b984e3e 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/ud.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/ud.c</span>
<span class="p_chunk">@@ -487,7 +487,7 @@</span> <span class="p_context"> int hfi1_make_ud_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)</span>
 			goto bail;
 		/* We are in the error state, flush the work request. */
 		smp_read_barrier_depends(); /* see post_one_send */
<span class="p_del">-		if (qp-&gt;s_last == ACCESS_ONCE(qp-&gt;s_head))</span>
<span class="p_add">+		if (qp-&gt;s_last == READ_ONCE(qp-&gt;s_head))</span>
 			goto bail;
 		/* If DMAs are in progress, we can&#39;t flush immediately. */
 		if (iowait_sdma_pending(&amp;priv-&gt;s_iowait)) {
<span class="p_chunk">@@ -501,7 +501,7 @@</span> <span class="p_context"> int hfi1_make_ud_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)</span>
 
 	/* see post_one_send() */
 	smp_read_barrier_depends();
<span class="p_del">-	if (qp-&gt;s_cur == ACCESS_ONCE(qp-&gt;s_head))</span>
<span class="p_add">+	if (qp-&gt;s_cur == READ_ONCE(qp-&gt;s_head))</span>
 		goto bail;
 
 	wqe = rvt_get_swqe_ptr(qp, qp-&gt;s_cur);
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/user_sdma.c b/drivers/infiniband/hw/hfi1/user_sdma.c</span>
<span class="p_header">index c0c0e0445cbf..8ec6e8a8d6f7 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/user_sdma.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/user_sdma.c</span>
<span class="p_chunk">@@ -276,7 +276,7 @@</span> <span class="p_context"> int hfi1_user_sdma_free_queues(struct hfi1_filedata *fd,</span>
 		/* Wait until all requests have been freed. */
 		wait_event_interruptible(
 			pq-&gt;wait,
<span class="p_del">-			(ACCESS_ONCE(pq-&gt;state) == SDMA_PKT_Q_INACTIVE));</span>
<span class="p_add">+			(READ_ONCE(pq-&gt;state) == SDMA_PKT_Q_INACTIVE));</span>
 		kfree(pq-&gt;reqs);
 		kfree(pq-&gt;req_in_use);
 		kmem_cache_destroy(pq-&gt;txreq_cache);
<span class="p_chunk">@@ -591,7 +591,7 @@</span> <span class="p_context"> int hfi1_user_sdma_process_request(struct hfi1_filedata *fd,</span>
 			if (ret != -EBUSY) {
 				req-&gt;status = ret;
 				WRITE_ONCE(req-&gt;has_error, 1);
<span class="p_del">-				if (ACCESS_ONCE(req-&gt;seqcomp) ==</span>
<span class="p_add">+				if (READ_ONCE(req-&gt;seqcomp) ==</span>
 				    req-&gt;seqsubmitted - 1)
 					goto free_req;
 				return ret;
<span class="p_chunk">@@ -825,7 +825,7 @@</span> <span class="p_context"> static int user_sdma_send_pkts(struct user_sdma_request *req, unsigned maxpkts)</span>
 		 */
 		if (req-&gt;data_len) {
 			iovec = &amp;req-&gt;iovs[req-&gt;iov_idx];
<span class="p_del">-			if (ACCESS_ONCE(iovec-&gt;offset) == iovec-&gt;iov.iov_len) {</span>
<span class="p_add">+			if (READ_ONCE(iovec-&gt;offset) == iovec-&gt;iov.iov_len) {</span>
 				if (++req-&gt;iov_idx == req-&gt;data_iovs) {
 					ret = -EFAULT;
 					goto free_txreq;
<span class="p_chunk">@@ -1390,7 +1390,7 @@</span> <span class="p_context"> static void user_sdma_txreq_cb(struct sdma_txreq *txreq, int status)</span>
 	} else {
 		if (status != SDMA_TXREQ_S_OK)
 			req-&gt;status = status;
<span class="p_del">-		if (req-&gt;seqcomp == (ACCESS_ONCE(req-&gt;seqsubmitted) - 1) &amp;&amp;</span>
<span class="p_add">+		if (req-&gt;seqcomp == (READ_ONCE(req-&gt;seqsubmitted) - 1) &amp;&amp;</span>
 		    (READ_ONCE(req-&gt;done) ||
 		     READ_ONCE(req-&gt;has_error))) {
 			user_sdma_free_request(req, false);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_ruc.c b/drivers/infiniband/hw/qib/qib_ruc.c</span>
<span class="p_header">index 53efbb0b40c4..9a37e844d4c8 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_ruc.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_ruc.c</span>
<span class="p_chunk">@@ -368,7 +368,7 @@</span> <span class="p_context"> static void qib_ruc_loopback(struct rvt_qp *sqp)</span>
 
 again:
 	smp_read_barrier_depends(); /* see post_one_send() */
<span class="p_del">-	if (sqp-&gt;s_last == ACCESS_ONCE(sqp-&gt;s_head))</span>
<span class="p_add">+	if (sqp-&gt;s_last == READ_ONCE(sqp-&gt;s_head))</span>
 		goto clr_busy;
 	wqe = rvt_get_swqe_ptr(sqp, sqp-&gt;s_last);
 
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_uc.c b/drivers/infiniband/hw/qib/qib_uc.c</span>
<span class="p_header">index 498e2202e72c..bddcc37ace44 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_uc.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_uc.c</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"> int qib_make_uc_req(struct rvt_qp *qp, unsigned long *flags)</span>
 			goto bail;
 		/* We are in the error state, flush the work request. */
 		smp_read_barrier_depends(); /* see post_one_send() */
<span class="p_del">-		if (qp-&gt;s_last == ACCESS_ONCE(qp-&gt;s_head))</span>
<span class="p_add">+		if (qp-&gt;s_last == READ_ONCE(qp-&gt;s_head))</span>
 			goto bail;
 		/* If DMAs are in progress, we can&#39;t flush immediately. */
 		if (atomic_read(&amp;priv-&gt;s_dma_busy)) {
<span class="p_chunk">@@ -91,7 +91,7 @@</span> <span class="p_context"> int qib_make_uc_req(struct rvt_qp *qp, unsigned long *flags)</span>
 			goto bail;
 		/* Check if send work queue is empty. */
 		smp_read_barrier_depends(); /* see post_one_send() */
<span class="p_del">-		if (qp-&gt;s_cur == ACCESS_ONCE(qp-&gt;s_head))</span>
<span class="p_add">+		if (qp-&gt;s_cur == READ_ONCE(qp-&gt;s_head))</span>
 			goto bail;
 		/*
 		 * Start a new request.
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_ud.c b/drivers/infiniband/hw/qib/qib_ud.c</span>
<span class="p_header">index be4907453ac4..15962ed193ce 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_ud.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_ud.c</span>
<span class="p_chunk">@@ -253,7 +253,7 @@</span> <span class="p_context"> int qib_make_ud_req(struct rvt_qp *qp, unsigned long *flags)</span>
 			goto bail;
 		/* We are in the error state, flush the work request. */
 		smp_read_barrier_depends(); /* see post_one_send */
<span class="p_del">-		if (qp-&gt;s_last == ACCESS_ONCE(qp-&gt;s_head))</span>
<span class="p_add">+		if (qp-&gt;s_last == READ_ONCE(qp-&gt;s_head))</span>
 			goto bail;
 		/* If DMAs are in progress, we can&#39;t flush immediately. */
 		if (atomic_read(&amp;priv-&gt;s_dma_busy)) {
<span class="p_chunk">@@ -267,7 +267,7 @@</span> <span class="p_context"> int qib_make_ud_req(struct rvt_qp *qp, unsigned long *flags)</span>
 
 	/* see post_one_send() */
 	smp_read_barrier_depends();
<span class="p_del">-	if (qp-&gt;s_cur == ACCESS_ONCE(qp-&gt;s_head))</span>
<span class="p_add">+	if (qp-&gt;s_cur == READ_ONCE(qp-&gt;s_head))</span>
 		goto bail;
 
 	wqe = rvt_get_swqe_ptr(qp, qp-&gt;s_cur);
<span class="p_header">diff --git a/drivers/infiniband/sw/rdmavt/qp.c b/drivers/infiniband/sw/rdmavt/qp.c</span>
<span class="p_header">index 22df09ae809e..b670cb9d2006 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rdmavt/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rdmavt/qp.c</span>
<span class="p_chunk">@@ -1073,7 +1073,7 @@</span> <span class="p_context"> int rvt_error_qp(struct rvt_qp *qp, enum ib_wc_status err)</span>
 	rdi-&gt;driver_f.notify_error_qp(qp);
 
 	/* Schedule the sending tasklet to drain the send work queue. */
<span class="p_del">-	if (ACCESS_ONCE(qp-&gt;s_last) != qp-&gt;s_head)</span>
<span class="p_add">+	if (READ_ONCE(qp-&gt;s_last) != qp-&gt;s_head)</span>
 		rdi-&gt;driver_f.schedule_send(qp);
 
 	rvt_clear_mr_refs(qp, 0);
<span class="p_chunk">@@ -1686,7 +1686,7 @@</span> <span class="p_context"> static inline int rvt_qp_is_avail(</span>
 	if (likely(qp-&gt;s_avail))
 		return 0;
 	smp_read_barrier_depends(); /* see rc.c */
<span class="p_del">-	slast = ACCESS_ONCE(qp-&gt;s_last);</span>
<span class="p_add">+	slast = READ_ONCE(qp-&gt;s_last);</span>
 	if (qp-&gt;s_head &gt;= slast)
 		avail = qp-&gt;s_size - (qp-&gt;s_head - slast);
 	else
<span class="p_chunk">@@ -1917,7 +1917,7 @@</span> <span class="p_context"> int rvt_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,</span>
 	 * ahead and kick the send engine into gear. Otherwise we will always
 	 * just schedule the send to happen later.
 	 */
<span class="p_del">-	call_send = qp-&gt;s_head == ACCESS_ONCE(qp-&gt;s_last) &amp;&amp; !wr-&gt;next;</span>
<span class="p_add">+	call_send = qp-&gt;s_head == READ_ONCE(qp-&gt;s_last) &amp;&amp; !wr-&gt;next;</span>
 
 	for (; wr; wr = wr-&gt;next) {
 		err = rvt_post_one_wr(qp, wr, &amp;call_send);
<span class="p_header">diff --git a/drivers/input/misc/regulator-haptic.c b/drivers/input/misc/regulator-haptic.c</span>
<span class="p_header">index 2e8f801932be..a1db1e5040dc 100644</span>
<span class="p_header">--- a/drivers/input/misc/regulator-haptic.c</span>
<span class="p_header">+++ b/drivers/input/misc/regulator-haptic.c</span>
<span class="p_chunk">@@ -233,7 +233,7 @@</span> <span class="p_context"> static int __maybe_unused regulator_haptic_resume(struct device *dev)</span>
 
 	haptic-&gt;suspended = false;
 
<span class="p_del">-	magnitude = ACCESS_ONCE(haptic-&gt;magnitude);</span>
<span class="p_add">+	magnitude = READ_ONCE(haptic-&gt;magnitude);</span>
 	if (magnitude)
 		regulator_haptic_set_voltage(haptic, magnitude);
 
<span class="p_header">diff --git a/drivers/md/dm-bufio.c b/drivers/md/dm-bufio.c</span>
<span class="p_header">index d216a8f7bc22..33bb074d6941 100644</span>
<span class="p_header">--- a/drivers/md/dm-bufio.c</span>
<span class="p_header">+++ b/drivers/md/dm-bufio.c</span>
<span class="p_chunk">@@ -347,7 +347,7 @@</span> <span class="p_context"> static void __cache_size_refresh(void)</span>
 	BUG_ON(!mutex_is_locked(&amp;dm_bufio_clients_lock));
 	BUG_ON(dm_bufio_client_count &lt; 0);
 
<span class="p_del">-	dm_bufio_cache_size_latch = ACCESS_ONCE(dm_bufio_cache_size);</span>
<span class="p_add">+	dm_bufio_cache_size_latch = READ_ONCE(dm_bufio_cache_size);</span>
 
 	/*
 	 * Use default if set to 0 and report the actual cache size used.
<span class="p_chunk">@@ -960,7 +960,7 @@</span> <span class="p_context"> static void __get_memory_limit(struct dm_bufio_client *c,</span>
 {
 	unsigned long buffers;
 
<span class="p_del">-	if (unlikely(ACCESS_ONCE(dm_bufio_cache_size) != dm_bufio_cache_size_latch)) {</span>
<span class="p_add">+	if (unlikely(READ_ONCE(dm_bufio_cache_size) != dm_bufio_cache_size_latch)) {</span>
 		if (mutex_trylock(&amp;dm_bufio_clients_lock)) {
 			__cache_size_refresh();
 			mutex_unlock(&amp;dm_bufio_clients_lock);
<span class="p_chunk">@@ -1600,7 +1600,7 @@</span> <span class="p_context"> static bool __try_evict_buffer(struct dm_buffer *b, gfp_t gfp)</span>
 
 static unsigned long get_retain_buffers(struct dm_bufio_client *c)
 {
<span class="p_del">-        unsigned long retain_bytes = ACCESS_ONCE(dm_bufio_retain_bytes);</span>
<span class="p_add">+        unsigned long retain_bytes = READ_ONCE(dm_bufio_retain_bytes);</span>
         return retain_bytes &gt;&gt; (c-&gt;sectors_per_block_bits + SECTOR_SHIFT);
 }
 
<span class="p_chunk">@@ -1647,7 +1647,7 @@</span> <span class="p_context"> dm_bufio_shrink_count(struct shrinker *shrink, struct shrink_control *sc)</span>
 {
 	struct dm_bufio_client *c = container_of(shrink, struct dm_bufio_client, shrinker);
 
<span class="p_del">-	return ACCESS_ONCE(c-&gt;n_buffers[LIST_CLEAN]) + ACCESS_ONCE(c-&gt;n_buffers[LIST_DIRTY]);</span>
<span class="p_add">+	return READ_ONCE(c-&gt;n_buffers[LIST_CLEAN]) + READ_ONCE(c-&gt;n_buffers[LIST_DIRTY]);</span>
 }
 
 /*
<span class="p_chunk">@@ -1818,7 +1818,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(dm_bufio_set_sector_offset);</span>
 
 static unsigned get_max_age_hz(void)
 {
<span class="p_del">-	unsigned max_age = ACCESS_ONCE(dm_bufio_max_age);</span>
<span class="p_add">+	unsigned max_age = READ_ONCE(dm_bufio_max_age);</span>
 
 	if (max_age &gt; UINT_MAX / HZ)
 		max_age = UINT_MAX / HZ;
<span class="p_header">diff --git a/drivers/md/dm-kcopyd.c b/drivers/md/dm-kcopyd.c</span>
<span class="p_header">index cf2c67e35eaf..eb45cc3df31d 100644</span>
<span class="p_header">--- a/drivers/md/dm-kcopyd.c</span>
<span class="p_header">+++ b/drivers/md/dm-kcopyd.c</span>
<span class="p_chunk">@@ -107,7 +107,7 @@</span> <span class="p_context"> static void io_job_start(struct dm_kcopyd_throttle *t)</span>
 try_again:
 	spin_lock_irq(&amp;throttle_spinlock);
 
<span class="p_del">-	throttle = ACCESS_ONCE(t-&gt;throttle);</span>
<span class="p_add">+	throttle = READ_ONCE(t-&gt;throttle);</span>
 
 	if (likely(throttle &gt;= 100))
 		goto skip_limit;
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> static void io_job_finish(struct dm_kcopyd_throttle *t)</span>
 
 	t-&gt;num_io_jobs--;
 
<span class="p_del">-	if (likely(ACCESS_ONCE(t-&gt;throttle) &gt;= 100))</span>
<span class="p_add">+	if (likely(READ_ONCE(t-&gt;throttle) &gt;= 100))</span>
 		goto skip_limit;
 
 	if (!t-&gt;num_io_jobs) {
<span class="p_header">diff --git a/drivers/md/dm-stats.c b/drivers/md/dm-stats.c</span>
<span class="p_header">index 6028d8247f58..a1a5eec783cc 100644</span>
<span class="p_header">--- a/drivers/md/dm-stats.c</span>
<span class="p_header">+++ b/drivers/md/dm-stats.c</span>
<span class="p_chunk">@@ -431,7 +431,7 @@</span> <span class="p_context"> static int dm_stats_delete(struct dm_stats *stats, int id)</span>
 		synchronize_rcu_expedited();
 		dm_stat_free(&amp;s-&gt;rcu_head);
 	} else {
<span class="p_del">-		ACCESS_ONCE(dm_stat_need_rcu_barrier) = 1;</span>
<span class="p_add">+		WRITE_ONCE(dm_stat_need_rcu_barrier, 1);</span>
 		call_rcu(&amp;s-&gt;rcu_head, dm_stat_free);
 	}
 	return 0;
<span class="p_chunk">@@ -639,12 +639,12 @@</span> <span class="p_context"> void dm_stats_account_io(struct dm_stats *stats, unsigned long bi_rw,</span>
 		 */
 		last = raw_cpu_ptr(stats-&gt;last);
 		stats_aux-&gt;merged =
<span class="p_del">-			(bi_sector == (ACCESS_ONCE(last-&gt;last_sector) &amp;&amp;</span>
<span class="p_add">+			(bi_sector == (READ_ONCE(last-&gt;last_sector) &amp;&amp;</span>
 				       ((bi_rw == WRITE) ==
<span class="p_del">-					(ACCESS_ONCE(last-&gt;last_rw) == WRITE))</span>
<span class="p_add">+					(READ_ONCE(last-&gt;last_rw) == WRITE))</span>
 				       ));
<span class="p_del">-		ACCESS_ONCE(last-&gt;last_sector) = end_sector;</span>
<span class="p_del">-		ACCESS_ONCE(last-&gt;last_rw) = bi_rw;</span>
<span class="p_add">+		WRITE_ONCE(last-&gt;last_sector, end_sector);</span>
<span class="p_add">+		WRITE_ONCE(last-&gt;last_rw, bi_rw);</span>
 	}
 
 	rcu_read_lock();
<span class="p_chunk">@@ -693,22 +693,22 @@</span> <span class="p_context"> static void __dm_stat_init_temporary_percpu_totals(struct dm_stat_shared *shared</span>
 
 	for_each_possible_cpu(cpu) {
 		p = &amp;s-&gt;stat_percpu[cpu][x];
<span class="p_del">-		shared-&gt;tmp.sectors[READ] += ACCESS_ONCE(p-&gt;sectors[READ]);</span>
<span class="p_del">-		shared-&gt;tmp.sectors[WRITE] += ACCESS_ONCE(p-&gt;sectors[WRITE]);</span>
<span class="p_del">-		shared-&gt;tmp.ios[READ] += ACCESS_ONCE(p-&gt;ios[READ]);</span>
<span class="p_del">-		shared-&gt;tmp.ios[WRITE] += ACCESS_ONCE(p-&gt;ios[WRITE]);</span>
<span class="p_del">-		shared-&gt;tmp.merges[READ] += ACCESS_ONCE(p-&gt;merges[READ]);</span>
<span class="p_del">-		shared-&gt;tmp.merges[WRITE] += ACCESS_ONCE(p-&gt;merges[WRITE]);</span>
<span class="p_del">-		shared-&gt;tmp.ticks[READ] += ACCESS_ONCE(p-&gt;ticks[READ]);</span>
<span class="p_del">-		shared-&gt;tmp.ticks[WRITE] += ACCESS_ONCE(p-&gt;ticks[WRITE]);</span>
<span class="p_del">-		shared-&gt;tmp.io_ticks[READ] += ACCESS_ONCE(p-&gt;io_ticks[READ]);</span>
<span class="p_del">-		shared-&gt;tmp.io_ticks[WRITE] += ACCESS_ONCE(p-&gt;io_ticks[WRITE]);</span>
<span class="p_del">-		shared-&gt;tmp.io_ticks_total += ACCESS_ONCE(p-&gt;io_ticks_total);</span>
<span class="p_del">-		shared-&gt;tmp.time_in_queue += ACCESS_ONCE(p-&gt;time_in_queue);</span>
<span class="p_add">+		shared-&gt;tmp.sectors[READ] += READ_ONCE(p-&gt;sectors[READ]);</span>
<span class="p_add">+		shared-&gt;tmp.sectors[WRITE] += READ_ONCE(p-&gt;sectors[WRITE]);</span>
<span class="p_add">+		shared-&gt;tmp.ios[READ] += READ_ONCE(p-&gt;ios[READ]);</span>
<span class="p_add">+		shared-&gt;tmp.ios[WRITE] += READ_ONCE(p-&gt;ios[WRITE]);</span>
<span class="p_add">+		shared-&gt;tmp.merges[READ] += READ_ONCE(p-&gt;merges[READ]);</span>
<span class="p_add">+		shared-&gt;tmp.merges[WRITE] += READ_ONCE(p-&gt;merges[WRITE]);</span>
<span class="p_add">+		shared-&gt;tmp.ticks[READ] += READ_ONCE(p-&gt;ticks[READ]);</span>
<span class="p_add">+		shared-&gt;tmp.ticks[WRITE] += READ_ONCE(p-&gt;ticks[WRITE]);</span>
<span class="p_add">+		shared-&gt;tmp.io_ticks[READ] += READ_ONCE(p-&gt;io_ticks[READ]);</span>
<span class="p_add">+		shared-&gt;tmp.io_ticks[WRITE] += READ_ONCE(p-&gt;io_ticks[WRITE]);</span>
<span class="p_add">+		shared-&gt;tmp.io_ticks_total += READ_ONCE(p-&gt;io_ticks_total);</span>
<span class="p_add">+		shared-&gt;tmp.time_in_queue += READ_ONCE(p-&gt;time_in_queue);</span>
 		if (s-&gt;n_histogram_entries) {
 			unsigned i;
 			for (i = 0; i &lt; s-&gt;n_histogram_entries + 1; i++)
<span class="p_del">-				shared-&gt;tmp.histogram[i] += ACCESS_ONCE(p-&gt;histogram[i]);</span>
<span class="p_add">+				shared-&gt;tmp.histogram[i] += READ_ONCE(p-&gt;histogram[i]);</span>
 		}
 	}
 }
<span class="p_header">diff --git a/drivers/md/dm-switch.c b/drivers/md/dm-switch.c</span>
<span class="p_header">index 4c8de1ff78ca..8d0ba879777e 100644</span>
<span class="p_header">--- a/drivers/md/dm-switch.c</span>
<span class="p_header">+++ b/drivers/md/dm-switch.c</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static unsigned switch_region_table_read(struct switch_ctx *sctx, unsigned long</span>
 
 	switch_get_position(sctx, region_nr, &amp;region_index, &amp;bit);
 
<span class="p_del">-	return (ACCESS_ONCE(sctx-&gt;region_table[region_index]) &gt;&gt; bit) &amp;</span>
<span class="p_add">+	return (READ_ONCE(sctx-&gt;region_table[region_index]) &gt;&gt; bit) &amp;</span>
 		((1 &lt;&lt; sctx-&gt;region_table_entry_bits) - 1);
 }
 
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index 1e25705209c2..89e5dff9b4cf 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -2431,7 +2431,7 @@</span> <span class="p_context"> static void set_pool_mode(struct pool *pool, enum pool_mode new_mode)</span>
 	struct pool_c *pt = pool-&gt;ti-&gt;private;
 	bool needs_check = dm_pool_metadata_needs_check(pool-&gt;pmd);
 	enum pool_mode old_mode = get_pool_mode(pool);
<span class="p_del">-	unsigned long no_space_timeout = ACCESS_ONCE(no_space_timeout_secs) * HZ;</span>
<span class="p_add">+	unsigned long no_space_timeout = READ_ONCE(no_space_timeout_secs) * HZ;</span>
 
 	/*
 	 * Never allow the pool to transition to PM_WRITE mode if user
<span class="p_header">diff --git a/drivers/md/dm-verity-target.c b/drivers/md/dm-verity-target.c</span>
<span class="p_header">index bda3caca23ca..fba93237a780 100644</span>
<span class="p_header">--- a/drivers/md/dm-verity-target.c</span>
<span class="p_header">+++ b/drivers/md/dm-verity-target.c</span>
<span class="p_chunk">@@ -589,7 +589,7 @@</span> <span class="p_context"> static void verity_prefetch_io(struct work_struct *work)</span>
 		verity_hash_at_level(v, pw-&gt;block, i, &amp;hash_block_start, NULL);
 		verity_hash_at_level(v, pw-&gt;block + pw-&gt;n_blocks - 1, i, &amp;hash_block_end, NULL);
 		if (!i) {
<span class="p_del">-			unsigned cluster = ACCESS_ONCE(dm_verity_prefetch_cluster);</span>
<span class="p_add">+			unsigned cluster = READ_ONCE(dm_verity_prefetch_cluster);</span>
 
 			cluster &gt;&gt;= v-&gt;data_dev_block_bits;
 			if (unlikely(!cluster))
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 4be85324f44d..8aaffa19b29a 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> static unsigned reserved_bio_based_ios = RESERVED_BIO_BASED_IOS;</span>
 
 static int __dm_get_module_param_int(int *module_param, int min, int max)
 {
<span class="p_del">-	int param = ACCESS_ONCE(*module_param);</span>
<span class="p_add">+	int param = READ_ONCE(*module_param);</span>
 	int modified_param = 0;
 	bool modified = true;
 
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> static int __dm_get_module_param_int(int *module_param, int min, int max)</span>
 unsigned __dm_get_module_param(unsigned *module_param,
 			       unsigned def, unsigned max)
 {
<span class="p_del">-	unsigned param = ACCESS_ONCE(*module_param);</span>
<span class="p_add">+	unsigned param = READ_ONCE(*module_param);</span>
 	unsigned modified_param = 0;
 
 	if (!param)
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 0ff1bbf6c90e..447ddcbc9566 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -2651,7 +2651,7 @@</span> <span class="p_context"> state_show(struct md_rdev *rdev, char *page)</span>
 {
 	char *sep = &quot;,&quot;;
 	size_t len = 0;
<span class="p_del">-	unsigned long flags = ACCESS_ONCE(rdev-&gt;flags);</span>
<span class="p_add">+	unsigned long flags = READ_ONCE(rdev-&gt;flags);</span>
 
 	if (test_bit(Faulty, &amp;flags) ||
 	    (!test_bit(ExternalBbl, &amp;flags) &amp;&amp;
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 928e24a07133..7d9a50eed9db 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -6072,7 +6072,7 @@</span> <span class="p_context"> static inline sector_t raid5_sync_request(struct mddev *mddev, sector_t sector_n</span>
 	 */
 	rcu_read_lock();
 	for (i = 0; i &lt; conf-&gt;raid_disks; i++) {
<span class="p_del">-		struct md_rdev *rdev = ACCESS_ONCE(conf-&gt;disks[i].rdev);</span>
<span class="p_add">+		struct md_rdev *rdev = READ_ONCE(conf-&gt;disks[i].rdev);</span>
 
 		if (rdev == NULL || test_bit(Faulty, &amp;rdev-&gt;flags))
 			still_degraded = 1;
<span class="p_header">diff --git a/drivers/misc/mic/scif/scif_rb.c b/drivers/misc/mic/scif/scif_rb.c</span>
<span class="p_header">index 637cc4686742..b665757ca89a 100644</span>
<span class="p_header">--- a/drivers/misc/mic/scif/scif_rb.c</span>
<span class="p_header">+++ b/drivers/misc/mic/scif/scif_rb.c</span>
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"> void scif_rb_commit(struct scif_rb *rb)</span>
 	 * the read barrier in scif_rb_count(..)
 	 */
 	wmb();
<span class="p_del">-	ACCESS_ONCE(*rb-&gt;write_ptr) = rb-&gt;current_write_offset;</span>
<span class="p_add">+	WRITE_ONCE(*rb-&gt;write_ptr, rb-&gt;current_write_offset);</span>
 #ifdef CONFIG_INTEL_MIC_CARD
 	/*
 	 * X100 Si bug: For the case where a Core is performing an EXT_WR
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> void scif_rb_commit(struct scif_rb *rb)</span>
 	 * This way, if ordering is violated for the Interrupt Message, it will
 	 * fall just behind the first Posted associated with the first EXT_WR.
 	 */
<span class="p_del">-	ACCESS_ONCE(*rb-&gt;write_ptr) = rb-&gt;current_write_offset;</span>
<span class="p_add">+	WRITE_ONCE(*rb-&gt;write_ptr, rb-&gt;current_write_offset);</span>
 #endif
 }
 
<span class="p_chunk">@@ -210,7 +210,7 @@</span> <span class="p_context"> void scif_rb_update_read_ptr(struct scif_rb *rb)</span>
 	 * scif_rb_space(..)
 	 */
 	mb();
<span class="p_del">-	ACCESS_ONCE(*rb-&gt;read_ptr) = new_offset;</span>
<span class="p_add">+	WRITE_ONCE(*rb-&gt;read_ptr, new_offset);</span>
 #ifdef CONFIG_INTEL_MIC_CARD
 	/*
 	 * X100 Si Bug: For the case where a Core is performing an EXT_WR
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> void scif_rb_update_read_ptr(struct scif_rb *rb)</span>
 	 * This way, if ordering is violated for the Interrupt Message, it will
 	 * fall just behind the first Posted associated with the first EXT_WR.
 	 */
<span class="p_del">-	ACCESS_ONCE(*rb-&gt;read_ptr) = new_offset;</span>
<span class="p_add">+	WRITE_ONCE(*rb-&gt;read_ptr, new_offset);</span>
 #endif
 }
 
<span class="p_header">diff --git a/drivers/misc/mic/scif/scif_rma_list.c b/drivers/misc/mic/scif/scif_rma_list.c</span>
<span class="p_header">index e1ef8daedd5a..a036dbb4101e 100644</span>
<span class="p_header">--- a/drivers/misc/mic/scif/scif_rma_list.c</span>
<span class="p_header">+++ b/drivers/misc/mic/scif/scif_rma_list.c</span>
<span class="p_chunk">@@ -277,7 +277,7 @@</span> <span class="p_context"> int scif_unregister_all_windows(scif_epd_t epd)</span>
 		 * Need to restart list traversal if there has been
 		 * an asynchronous list entry deletion.
 		 */
<span class="p_del">-		if (ACCESS_ONCE(ep-&gt;rma_info.async_list_del))</span>
<span class="p_add">+		if (READ_ONCE(ep-&gt;rma_info.async_list_del))</span>
 			goto retry;
 	}
 	mutex_unlock(&amp;ep-&gt;rma_info.rma_lock);
<span class="p_header">diff --git a/drivers/net/bonding/bond_alb.c b/drivers/net/bonding/bond_alb.c</span>
<span class="p_header">index c02cc817a490..1ed9529e7bd1 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_alb.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_alb.c</span>
<span class="p_chunk">@@ -1378,7 +1378,7 @@</span> <span class="p_context"> int bond_tlb_xmit(struct sk_buff *skb, struct net_device *bond_dev)</span>
 				unsigned int count;
 
 				slaves = rcu_dereference(bond-&gt;slave_arr);
<span class="p_del">-				count = slaves ? ACCESS_ONCE(slaves-&gt;count) : 0;</span>
<span class="p_add">+				count = slaves ? READ_ONCE(slaves-&gt;count) : 0;</span>
 				if (likely(count))
 					tx_slave = slaves-&gt;arr[hash_index %
 							       count];
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index c99dc59d729b..af51b90cecbb 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -1167,7 +1167,7 @@</span> <span class="p_context"> static rx_handler_result_t bond_handle_frame(struct sk_buff **pskb)</span>
 	slave = bond_slave_get_rcu(skb-&gt;dev);
 	bond = slave-&gt;bond;
 
<span class="p_del">-	recv_probe = ACCESS_ONCE(bond-&gt;recv_probe);</span>
<span class="p_add">+	recv_probe = READ_ONCE(bond-&gt;recv_probe);</span>
 	if (recv_probe) {
 		ret = recv_probe(skb, bond, slave);
 		if (ret == RX_HANDLER_CONSUMED) {
<span class="p_chunk">@@ -3810,7 +3810,7 @@</span> <span class="p_context"> static int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *bond_dev</span>
 		else
 			bond_xmit_slave_id(bond, skb, 0);
 	} else {
<span class="p_del">-		int slave_cnt = ACCESS_ONCE(bond-&gt;slave_cnt);</span>
<span class="p_add">+		int slave_cnt = READ_ONCE(bond-&gt;slave_cnt);</span>
 
 		if (likely(slave_cnt)) {
 			slave_id = bond_rr_gen_slave_id(bond);
<span class="p_chunk">@@ -3972,7 +3972,7 @@</span> <span class="p_context"> static int bond_3ad_xor_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	unsigned int count;
 
 	slaves = rcu_dereference(bond-&gt;slave_arr);
<span class="p_del">-	count = slaves ? ACCESS_ONCE(slaves-&gt;count) : 0;</span>
<span class="p_add">+	count = slaves ? READ_ONCE(slaves-&gt;count) : 0;</span>
 	if (likely(count)) {
 		slave = slaves-&gt;arr[bond_xmit_hash(bond, skb) % count];
 		bond_dev_queue_xmit(bond, skb, slave-&gt;dev);
<span class="p_header">diff --git a/drivers/net/ethernet/chelsio/cxgb4/sge.c b/drivers/net/ethernet/chelsio/cxgb4/sge.c</span>
<span class="p_header">index 4ef68f69b58c..43f52a8fe708 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c</span>
<span class="p_chunk">@@ -405,7 +405,7 @@</span> <span class="p_context"> void free_tx_desc(struct adapter *adap, struct sge_txq *q,</span>
  */
 static inline int reclaimable(const struct sge_txq *q)
 {
<span class="p_del">-	int hw_cidx = ntohs(ACCESS_ONCE(q-&gt;stat-&gt;cidx));</span>
<span class="p_add">+	int hw_cidx = ntohs(READ_ONCE(q-&gt;stat-&gt;cidx));</span>
 	hw_cidx -= q-&gt;cidx;
 	return hw_cidx &lt; 0 ? hw_cidx + q-&gt;size : hw_cidx;
 }
<span class="p_chunk">@@ -1375,7 +1375,7 @@</span> <span class="p_context"> out_free:	dev_kfree_skb_any(skb);</span>
  */
 static inline void reclaim_completed_tx_imm(struct sge_txq *q)
 {
<span class="p_del">-	int hw_cidx = ntohs(ACCESS_ONCE(q-&gt;stat-&gt;cidx));</span>
<span class="p_add">+	int hw_cidx = ntohs(READ_ONCE(q-&gt;stat-&gt;cidx));</span>
 	int reclaim = hw_cidx - q-&gt;cidx;
 
 	if (reclaim &lt; 0)
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">index 0e3d9f39a807..c6e859a27ee6 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_chunk">@@ -605,7 +605,7 @@</span> <span class="p_context"> static void accumulate_16bit_val(u32 *acc, u16 val)</span>
 
 	if (wrapped)
 		newacc += 65536;
<span class="p_del">-	ACCESS_ONCE(*acc) = newacc;</span>
<span class="p_add">+	WRITE_ONCE(*acc, newacc);</span>
 }
 
 static void populate_erx_stats(struct be_adapter *adapter,
<span class="p_header">diff --git a/drivers/net/ethernet/hisilicon/hip04_eth.c b/drivers/net/ethernet/hisilicon/hip04_eth.c</span>
<span class="p_header">index 0cec06bec63e..340e28211135 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/hisilicon/hip04_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/hisilicon/hip04_eth.c</span>
<span class="p_chunk">@@ -373,7 +373,7 @@</span> <span class="p_context"> static int hip04_tx_reclaim(struct net_device *ndev, bool force)</span>
 	unsigned int count;
 
 	smp_rmb();
<span class="p_del">-	count = tx_count(ACCESS_ONCE(priv-&gt;tx_head), tx_tail);</span>
<span class="p_add">+	count = tx_count(READ_ONCE(priv-&gt;tx_head), tx_tail);</span>
 	if (count == 0)
 		goto out;
 
<span class="p_chunk">@@ -431,7 +431,7 @@</span> <span class="p_context"> static int hip04_mac_start_xmit(struct sk_buff *skb, struct net_device *ndev)</span>
 	dma_addr_t phys;
 
 	smp_rmb();
<span class="p_del">-	count = tx_count(tx_head, ACCESS_ONCE(priv-&gt;tx_tail));</span>
<span class="p_add">+	count = tx_count(tx_head, READ_ONCE(priv-&gt;tx_tail));</span>
 	if (count == (TX_DESC_NUM - 1)) {
 		netif_stop_queue(ndev);
 		return NETDEV_TX_BUSY;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c</span>
<span class="p_header">index 8f326f87a815..2cb9539c931e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c</span>
<span class="p_chunk">@@ -264,7 +264,7 @@</span> <span class="p_context"> static void i40e_dbg_dump_vsi_seid(struct i40e_pf *pf, int seid)</span>
 		 vsi-&gt;rx_buf_failed, vsi-&gt;rx_page_failed);
 	rcu_read_lock();
 	for (i = 0; i &lt; vsi-&gt;num_queue_pairs; i++) {
<span class="p_del">-		struct i40e_ring *rx_ring = ACCESS_ONCE(vsi-&gt;rx_rings[i]);</span>
<span class="p_add">+		struct i40e_ring *rx_ring = READ_ONCE(vsi-&gt;rx_rings[i]);</span>
 
 		if (!rx_ring)
 			continue;
<span class="p_chunk">@@ -320,7 +320,7 @@</span> <span class="p_context"> static void i40e_dbg_dump_vsi_seid(struct i40e_pf *pf, int seid)</span>
 			 ITR_IS_DYNAMIC(rx_ring-&gt;rx_itr_setting) ? &quot;dynamic&quot; : &quot;fixed&quot;);
 	}
 	for (i = 0; i &lt; vsi-&gt;num_queue_pairs; i++) {
<span class="p_del">-		struct i40e_ring *tx_ring = ACCESS_ONCE(vsi-&gt;tx_rings[i]);</span>
<span class="p_add">+		struct i40e_ring *tx_ring = READ_ONCE(vsi-&gt;tx_rings[i]);</span>
 
 		if (!tx_ring)
 			continue;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c</span>
<span class="p_header">index 05e89864f781..e9e04a485e0a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c</span>
<span class="p_chunk">@@ -1570,7 +1570,7 @@</span> <span class="p_context"> static void i40e_get_ethtool_stats(struct net_device *netdev,</span>
 	}
 	rcu_read_lock();
 	for (j = 0; j &lt; vsi-&gt;num_queue_pairs; j++) {
<span class="p_del">-		tx_ring = ACCESS_ONCE(vsi-&gt;tx_rings[j]);</span>
<span class="p_add">+		tx_ring = READ_ONCE(vsi-&gt;tx_rings[j]);</span>
 
 		if (!tx_ring)
 			continue;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">index 6498da8806cb..de1fcac7834d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_chunk">@@ -455,7 +455,7 @@</span> <span class="p_context"> static void i40e_get_netdev_stats_struct(struct net_device *netdev,</span>
 		u64 bytes, packets;
 		unsigned int start;
 
<span class="p_del">-		tx_ring = ACCESS_ONCE(vsi-&gt;tx_rings[i]);</span>
<span class="p_add">+		tx_ring = READ_ONCE(vsi-&gt;tx_rings[i]);</span>
 		if (!tx_ring)
 			continue;
 		i40e_get_netdev_stats_struct_tx(tx_ring, stats);
<span class="p_chunk">@@ -791,7 +791,7 @@</span> <span class="p_context"> static void i40e_update_vsi_stats(struct i40e_vsi *vsi)</span>
 	rcu_read_lock();
 	for (q = 0; q &lt; vsi-&gt;num_queue_pairs; q++) {
 		/* locate Tx ring */
<span class="p_del">-		p = ACCESS_ONCE(vsi-&gt;tx_rings[q]);</span>
<span class="p_add">+		p = READ_ONCE(vsi-&gt;tx_rings[q]);</span>
 
 		do {
 			start = u64_stats_fetch_begin_irq(&amp;p-&gt;syncp);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_ptp.c b/drivers/net/ethernet/intel/i40e/i40e_ptp.c</span>
<span class="p_header">index d8456c381c99..97381238eb7c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_ptp.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_ptp.c</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static int i40e_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)</span>
 	}
 
 	smp_mb(); /* Force any pending update before accessing. */
<span class="p_del">-	adj = ACCESS_ONCE(pf-&gt;ptp_base_adj);</span>
<span class="p_add">+	adj = READ_ONCE(pf-&gt;ptp_base_adj);</span>
 
 	freq = adj;
 	freq *= ppb;
<span class="p_chunk">@@ -499,7 +499,7 @@</span> <span class="p_context"> void i40e_ptp_set_increment(struct i40e_pf *pf)</span>
 	wr32(hw, I40E_PRTTSYN_INC_H, incval &gt;&gt; 32);
 
 	/* Update the base adjustement value. */
<span class="p_del">-	ACCESS_ONCE(pf-&gt;ptp_base_adj) = incval;</span>
<span class="p_add">+	WRITE_ONCE(pf-&gt;ptp_base_adj, incval);</span>
 	smp_mb(); /* Force the above update. */
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/e1000_regs.h b/drivers/net/ethernet/intel/igb/e1000_regs.h</span>
<span class="p_header">index 58adbf234e07..31a3f09df9f7 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/e1000_regs.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/e1000_regs.h</span>
<span class="p_chunk">@@ -375,7 +375,7 @@</span> <span class="p_context"> u32 igb_rd32(struct e1000_hw *hw, u32 reg);</span>
 /* write operations, indexed using DWORDS */
 #define wr32(reg, val) \
 do { \
<span class="p_del">-	u8 __iomem *hw_addr = ACCESS_ONCE((hw)-&gt;hw_addr); \</span>
<span class="p_add">+	u8 __iomem *hw_addr = READ_ONCE((hw)-&gt;hw_addr); \</span>
 	if (!E1000_REMOVED(hw_addr)) \
 		writel((val), &amp;hw_addr[(reg)]); \
 } while (0)
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index fd4a46b03cc8..6bccc2be2b91 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -750,7 +750,7 @@</span> <span class="p_context"> static void igb_cache_ring_register(struct igb_adapter *adapter)</span>
 u32 igb_rd32(struct e1000_hw *hw, u32 reg)
 {
 	struct igb_adapter *igb = container_of(hw, struct igb_adapter, hw);
<span class="p_del">-	u8 __iomem *hw_addr = ACCESS_ONCE(hw-&gt;hw_addr);</span>
<span class="p_add">+	u8 __iomem *hw_addr = READ_ONCE(hw-&gt;hw_addr);</span>
 	u32 value = 0;
 
 	if (E1000_REMOVED(hw_addr))
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h</span>
<span class="p_header">index e083732adf64..a01409e2e06c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> static inline bool ixgbe_removed(void __iomem *addr)</span>
 
 static inline void ixgbe_write_reg(struct ixgbe_hw *hw, u32 reg, u32 value)
 {
<span class="p_del">-	u8 __iomem *reg_addr = ACCESS_ONCE(hw-&gt;hw_addr);</span>
<span class="p_add">+	u8 __iomem *reg_addr = READ_ONCE(hw-&gt;hw_addr);</span>
 
 	if (ixgbe_removed(reg_addr))
 		return;
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static inline void writeq(u64 val, void __iomem *addr)</span>
 
 static inline void ixgbe_write_reg64(struct ixgbe_hw *hw, u32 reg, u64 value)
 {
<span class="p_del">-	u8 __iomem *reg_addr = ACCESS_ONCE(hw-&gt;hw_addr);</span>
<span class="p_add">+	u8 __iomem *reg_addr = READ_ONCE(hw-&gt;hw_addr);</span>
 
 	if (ixgbe_removed(reg_addr))
 		return;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">index d962368d08d0..df2c8ecafcf4 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_chunk">@@ -380,7 +380,7 @@</span> <span class="p_context"> static void ixgbe_check_remove(struct ixgbe_hw *hw, u32 reg)</span>
  */
 u32 ixgbe_read_reg(struct ixgbe_hw *hw, u32 reg)
 {
<span class="p_del">-	u8 __iomem *reg_addr = ACCESS_ONCE(hw-&gt;hw_addr);</span>
<span class="p_add">+	u8 __iomem *reg_addr = READ_ONCE(hw-&gt;hw_addr);</span>
 	u32 value;
 
 	if (ixgbe_removed(reg_addr))
<span class="p_chunk">@@ -8626,7 +8626,7 @@</span> <span class="p_context"> static void ixgbe_get_stats64(struct net_device *netdev,</span>
 
 	rcu_read_lock();
 	for (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<span class="p_del">-		struct ixgbe_ring *ring = ACCESS_ONCE(adapter-&gt;rx_ring[i]);</span>
<span class="p_add">+		struct ixgbe_ring *ring = READ_ONCE(adapter-&gt;rx_ring[i]);</span>
 		u64 bytes, packets;
 		unsigned int start;
 
<span class="p_chunk">@@ -8642,12 +8642,12 @@</span> <span class="p_context"> static void ixgbe_get_stats64(struct net_device *netdev,</span>
 	}
 
 	for (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<span class="p_del">-		struct ixgbe_ring *ring = ACCESS_ONCE(adapter-&gt;tx_ring[i]);</span>
<span class="p_add">+		struct ixgbe_ring *ring = READ_ONCE(adapter-&gt;tx_ring[i]);</span>
 
 		ixgbe_get_ring_stats64(stats, ring);
 	}
 	for (i = 0; i &lt; adapter-&gt;num_xdp_queues; i++) {
<span class="p_del">-		struct ixgbe_ring *ring = ACCESS_ONCE(adapter-&gt;xdp_ring[i]);</span>
<span class="p_add">+		struct ixgbe_ring *ring = READ_ONCE(adapter-&gt;xdp_ring[i]);</span>
 
 		ixgbe_get_ring_stats64(stats, ring);
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c</span>
<span class="p_header">index 86d6924a2b71..ae312c45696a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c</span>
<span class="p_chunk">@@ -378,7 +378,7 @@</span> <span class="p_context"> static int ixgbe_ptp_adjfreq_82599(struct ptp_clock_info *ptp, s32 ppb)</span>
 	}
 
 	smp_mb();
<span class="p_del">-	incval = ACCESS_ONCE(adapter-&gt;base_incval);</span>
<span class="p_add">+	incval = READ_ONCE(adapter-&gt;base_incval);</span>
 
 	freq = incval;
 	freq *= ppb;
<span class="p_chunk">@@ -1159,7 +1159,7 @@</span> <span class="p_context"> void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter)</span>
 	}
 
 	/* update the base incval used to calculate frequency adjustment */
<span class="p_del">-	ACCESS_ONCE(adapter-&gt;base_incval) = incval;</span>
<span class="p_add">+	WRITE_ONCE(adapter-&gt;base_incval, incval);</span>
 	smp_mb();
 
 	/* need lock to prevent incorrect read while modifying cyclecounter */
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">index 032f8ac06357..cacb30682434 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static void ixgbevf_check_remove(struct ixgbe_hw *hw, u32 reg)</span>
 
 u32 ixgbevf_read_reg(struct ixgbe_hw *hw, u32 reg)
 {
<span class="p_del">-	u8 __iomem *reg_addr = ACCESS_ONCE(hw-&gt;hw_addr);</span>
<span class="p_add">+	u8 __iomem *reg_addr = READ_ONCE(hw-&gt;hw_addr);</span>
 	u32 value;
 
 	if (IXGBE_REMOVED(reg_addr))
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbevf/vf.h b/drivers/net/ethernet/intel/ixgbevf/vf.h</span>
<span class="p_header">index 04d8d4ee4f04..c651fefcc3d2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbevf/vf.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbevf/vf.h</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> struct ixgbevf_info {</span>
 
 static inline void ixgbe_write_reg(struct ixgbe_hw *hw, u32 reg, u32 value)
 {
<span class="p_del">-	u8 __iomem *reg_addr = ACCESS_ONCE(hw-&gt;hw_addr);</span>
<span class="p_add">+	u8 __iomem *reg_addr = READ_ONCE(hw-&gt;hw_addr);</span>
 
 	if (IXGBE_REMOVED(reg_addr))
 		return;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">index 8a32a8f7f9c0..3541a7f9d12e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_chunk">@@ -414,8 +414,8 @@</span> <span class="p_context"> bool mlx4_en_process_tx_cq(struct net_device *dev,</span>
 
 	index = cons_index &amp; size_mask;
 	cqe = mlx4_en_get_cqe(buf, index, priv-&gt;cqe_size) + factor;
<span class="p_del">-	last_nr_txbb = ACCESS_ONCE(ring-&gt;last_nr_txbb);</span>
<span class="p_del">-	ring_cons = ACCESS_ONCE(ring-&gt;cons);</span>
<span class="p_add">+	last_nr_txbb = READ_ONCE(ring-&gt;last_nr_txbb);</span>
<span class="p_add">+	ring_cons = READ_ONCE(ring-&gt;cons);</span>
 	ring_index = ring_cons &amp; size_mask;
 	stamp_index = ring_index;
 
<span class="p_chunk">@@ -479,8 +479,8 @@</span> <span class="p_context"> bool mlx4_en_process_tx_cq(struct net_device *dev,</span>
 	wmb();
 
 	/* we want to dirty this cache line once */
<span class="p_del">-	ACCESS_ONCE(ring-&gt;last_nr_txbb) = last_nr_txbb;</span>
<span class="p_del">-	ACCESS_ONCE(ring-&gt;cons) = ring_cons + txbbs_skipped;</span>
<span class="p_add">+	WRITE_ONCE(ring-&gt;last_nr_txbb, last_nr_txbb);</span>
<span class="p_add">+	WRITE_ONCE(ring-&gt;cons, ring_cons + txbbs_skipped);</span>
 
 	if (cq-&gt;type == TX_XDP)
 		return done &lt; budget;
<span class="p_chunk">@@ -858,7 +858,7 @@</span> <span class="p_context"> netdev_tx_t mlx4_en_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		goto tx_drop;
 
 	/* fetch ring-&gt;cons far ahead before needing it to avoid stall */
<span class="p_del">-	ring_cons = ACCESS_ONCE(ring-&gt;cons);</span>
<span class="p_add">+	ring_cons = READ_ONCE(ring-&gt;cons);</span>
 
 	real_size = get_real_size(skb, shinfo, dev, &amp;lso_header_size,
 				  &amp;inline_ok, &amp;fragptr);
<span class="p_chunk">@@ -1066,7 +1066,7 @@</span> <span class="p_context"> netdev_tx_t mlx4_en_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		 */
 		smp_rmb();
 
<span class="p_del">-		ring_cons = ACCESS_ONCE(ring-&gt;cons);</span>
<span class="p_add">+		ring_cons = READ_ONCE(ring-&gt;cons);</span>
 		if (unlikely(!mlx4_en_is_tx_ring_full(ring))) {
 			netif_tx_wake_queue(ring-&gt;tx_queue);
 			ring-&gt;wake_queue++;
<span class="p_header">diff --git a/drivers/net/ethernet/neterion/vxge/vxge-main.c b/drivers/net/ethernet/neterion/vxge/vxge-main.c</span>
<span class="p_header">index 50ea69d88480..5dd5f61e1114 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/neterion/vxge/vxge-main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/neterion/vxge/vxge-main.c</span>
<span class="p_chunk">@@ -2629,7 +2629,7 @@</span> <span class="p_context"> static void vxge_poll_vp_lockup(unsigned long data)</span>
 		ring = &amp;vdev-&gt;vpaths[i].ring;
 
 		/* Truncated to machine word size number of frames */
<span class="p_del">-		rx_frms = ACCESS_ONCE(ring-&gt;stats.rx_frms);</span>
<span class="p_add">+		rx_frms = READ_ONCE(ring-&gt;stats.rx_frms);</span>
 
 		/* Did this vpath received any packets */
 		if (ring-&gt;stats.prev_rx_frms == rx_frms) {
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/ef10.c b/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_header">index 13f72f5b18d2..a95a46bcd339 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_chunk">@@ -2073,7 +2073,7 @@</span> <span class="p_context"> static irqreturn_t efx_ef10_msi_interrupt(int irq, void *dev_id)</span>
 	netif_vdbg(efx, intr, efx-&gt;net_dev,
 		   &quot;IRQ %d on CPU %d\n&quot;, irq, raw_smp_processor_id());
 
<span class="p_del">-	if (likely(ACCESS_ONCE(efx-&gt;irq_soft_enabled))) {</span>
<span class="p_add">+	if (likely(READ_ONCE(efx-&gt;irq_soft_enabled))) {</span>
 		/* Note test interrupts */
 		if (context-&gt;index == efx-&gt;irq_level)
 			efx-&gt;last_irq_cpu = raw_smp_processor_id();
<span class="p_chunk">@@ -2088,7 +2088,7 @@</span> <span class="p_context"> static irqreturn_t efx_ef10_msi_interrupt(int irq, void *dev_id)</span>
 static irqreturn_t efx_ef10_legacy_interrupt(int irq, void *dev_id)
 {
 	struct efx_nic *efx = dev_id;
<span class="p_del">-	bool soft_enabled = ACCESS_ONCE(efx-&gt;irq_soft_enabled);</span>
<span class="p_add">+	bool soft_enabled = READ_ONCE(efx-&gt;irq_soft_enabled);</span>
 	struct efx_channel *channel;
 	efx_dword_t reg;
 	u32 queues;
<span class="p_chunk">@@ -3291,7 +3291,7 @@</span> <span class="p_context"> static int efx_ef10_handle_rx_event(struct efx_channel *channel,</span>
 	bool rx_cont;
 	u16 flags = 0;
 
<span class="p_del">-	if (unlikely(ACCESS_ONCE(efx-&gt;reset_pending)))</span>
<span class="p_add">+	if (unlikely(READ_ONCE(efx-&gt;reset_pending)))</span>
 		return 0;
 
 	/* Basic packet information */
<span class="p_chunk">@@ -3428,7 +3428,7 @@</span> <span class="p_context"> efx_ef10_handle_tx_event(struct efx_channel *channel, efx_qword_t *event)</span>
 	unsigned int tx_ev_q_label;
 	int tx_descs = 0;
 
<span class="p_del">-	if (unlikely(ACCESS_ONCE(efx-&gt;reset_pending)))</span>
<span class="p_add">+	if (unlikely(READ_ONCE(efx-&gt;reset_pending)))</span>
 		return 0;
 
 	if (unlikely(EFX_QWORD_FIELD(*event, ESF_DZ_TX_DROP_EVENT)))
<span class="p_chunk">@@ -5316,7 +5316,7 @@</span> <span class="p_context"> static void efx_ef10_filter_remove_old(struct efx_nic *efx)</span>
 	int i;
 
 	for (i = 0; i &lt; HUNT_FILTER_TBL_ROWS; i++) {
<span class="p_del">-		if (ACCESS_ONCE(table-&gt;entry[i].spec) &amp;</span>
<span class="p_add">+		if (READ_ONCE(table-&gt;entry[i].spec) &amp;</span>
 		    EFX_EF10_FILTER_FLAG_AUTO_OLD) {
 			rc = efx_ef10_filter_remove_internal(efx,
 					1U &lt;&lt; EFX_FILTER_PRI_AUTO, i, true);
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/efx.c b/drivers/net/ethernet/sfc/efx.c</span>
<span class="p_header">index b9cb697b2818..016616a63880 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/efx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/efx.c</span>
<span class="p_chunk">@@ -2809,7 +2809,7 @@</span> <span class="p_context"> static void efx_reset_work(struct work_struct *data)</span>
 	unsigned long pending;
 	enum reset_type method;
 
<span class="p_del">-	pending = ACCESS_ONCE(efx-&gt;reset_pending);</span>
<span class="p_add">+	pending = READ_ONCE(efx-&gt;reset_pending);</span>
 	method = fls(pending) - 1;
 
 	if (method == RESET_TYPE_MC_BIST)
<span class="p_chunk">@@ -2874,7 +2874,7 @@</span> <span class="p_context"> void efx_schedule_reset(struct efx_nic *efx, enum reset_type type)</span>
 	/* If we&#39;re not READY then just leave the flags set as the cue
 	 * to abort probing or reschedule the reset later.
 	 */
<span class="p_del">-	if (ACCESS_ONCE(efx-&gt;state) != STATE_READY)</span>
<span class="p_add">+	if (READ_ONCE(efx-&gt;state) != STATE_READY)</span>
 		return;
 
 	/* efx_process_channel() will no longer read events once a
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/falcon/efx.c b/drivers/net/ethernet/sfc/falcon/efx.c</span>
<span class="p_header">index 29614da91cbf..7263275fde4a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/falcon/efx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/falcon/efx.c</span>
<span class="p_chunk">@@ -2545,7 +2545,7 @@</span> <span class="p_context"> static void ef4_reset_work(struct work_struct *data)</span>
 	unsigned long pending;
 	enum reset_type method;
 
<span class="p_del">-	pending = ACCESS_ONCE(efx-&gt;reset_pending);</span>
<span class="p_add">+	pending = READ_ONCE(efx-&gt;reset_pending);</span>
 	method = fls(pending) - 1;
 
 	if ((method == RESET_TYPE_RECOVER_OR_DISABLE ||
<span class="p_chunk">@@ -2605,7 +2605,7 @@</span> <span class="p_context"> void ef4_schedule_reset(struct ef4_nic *efx, enum reset_type type)</span>
 	/* If we&#39;re not READY then just leave the flags set as the cue
 	 * to abort probing or reschedule the reset later.
 	 */
<span class="p_del">-	if (ACCESS_ONCE(efx-&gt;state) != STATE_READY)</span>
<span class="p_add">+	if (READ_ONCE(efx-&gt;state) != STATE_READY)</span>
 		return;
 
 	queue_work(reset_workqueue, &amp;efx-&gt;reset_work);
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/falcon/falcon.c b/drivers/net/ethernet/sfc/falcon/falcon.c</span>
<span class="p_header">index 93c713c1f627..cd8bb472d758 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/falcon/falcon.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/falcon/falcon.c</span>
<span class="p_chunk">@@ -452,7 +452,7 @@</span> <span class="p_context"> static irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)</span>
 		   &quot;IRQ %d on CPU %d status &quot; EF4_OWORD_FMT &quot;\n&quot;,
 		   irq, raw_smp_processor_id(), EF4_OWORD_VAL(*int_ker));
 
<span class="p_del">-	if (!likely(ACCESS_ONCE(efx-&gt;irq_soft_enabled)))</span>
<span class="p_add">+	if (!likely(READ_ONCE(efx-&gt;irq_soft_enabled)))</span>
 		return IRQ_HANDLED;
 
 	/* Check to see if we have a serious error condition */
<span class="p_chunk">@@ -1372,7 +1372,7 @@</span> <span class="p_context"> static void falcon_reconfigure_mac_wrapper(struct ef4_nic *efx)</span>
 	ef4_oword_t reg;
 	int link_speed, isolate;
 
<span class="p_del">-	isolate = !!ACCESS_ONCE(efx-&gt;reset_pending);</span>
<span class="p_add">+	isolate = !!READ_ONCE(efx-&gt;reset_pending);</span>
 
 	switch (link_state-&gt;speed) {
 	case 10000: link_speed = 3; break;
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/falcon/farch.c b/drivers/net/ethernet/sfc/falcon/farch.c</span>
<span class="p_header">index 05916c710d8c..494884f6af4a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/falcon/farch.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/falcon/farch.c</span>
<span class="p_chunk">@@ -834,7 +834,7 @@</span> <span class="p_context"> ef4_farch_handle_tx_event(struct ef4_channel *channel, ef4_qword_t *event)</span>
 	struct ef4_nic *efx = channel-&gt;efx;
 	int tx_packets = 0;
 
<span class="p_del">-	if (unlikely(ACCESS_ONCE(efx-&gt;reset_pending)))</span>
<span class="p_add">+	if (unlikely(READ_ONCE(efx-&gt;reset_pending)))</span>
 		return 0;
 
 	if (likely(EF4_QWORD_FIELD(*event, FSF_AZ_TX_EV_COMP))) {
<span class="p_chunk">@@ -990,7 +990,7 @@</span> <span class="p_context"> ef4_farch_handle_rx_event(struct ef4_channel *channel, const ef4_qword_t *event)</span>
 	struct ef4_rx_queue *rx_queue;
 	struct ef4_nic *efx = channel-&gt;efx;
 
<span class="p_del">-	if (unlikely(ACCESS_ONCE(efx-&gt;reset_pending)))</span>
<span class="p_add">+	if (unlikely(READ_ONCE(efx-&gt;reset_pending)))</span>
 		return;
 
 	rx_ev_cont = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_JUMBO_CONT);
<span class="p_chunk">@@ -1504,7 +1504,7 @@</span> <span class="p_context"> irqreturn_t ef4_farch_fatal_interrupt(struct ef4_nic *efx)</span>
 irqreturn_t ef4_farch_legacy_interrupt(int irq, void *dev_id)
 {
 	struct ef4_nic *efx = dev_id;
<span class="p_del">-	bool soft_enabled = ACCESS_ONCE(efx-&gt;irq_soft_enabled);</span>
<span class="p_add">+	bool soft_enabled = READ_ONCE(efx-&gt;irq_soft_enabled);</span>
 	ef4_oword_t *int_ker = efx-&gt;irq_status.addr;
 	irqreturn_t result = IRQ_NONE;
 	struct ef4_channel *channel;
<span class="p_chunk">@@ -1596,7 +1596,7 @@</span> <span class="p_context"> irqreturn_t ef4_farch_msi_interrupt(int irq, void *dev_id)</span>
 		   &quot;IRQ %d on CPU %d status &quot; EF4_OWORD_FMT &quot;\n&quot;,
 		   irq, raw_smp_processor_id(), EF4_OWORD_VAL(*int_ker));
 
<span class="p_del">-	if (!likely(ACCESS_ONCE(efx-&gt;irq_soft_enabled)))</span>
<span class="p_add">+	if (!likely(READ_ONCE(efx-&gt;irq_soft_enabled)))</span>
 		return IRQ_HANDLED;
 
 	/* Handle non-event-queue sources */
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/falcon/nic.h b/drivers/net/ethernet/sfc/falcon/nic.h</span>
<span class="p_header">index a4c4592f6023..54ca457cdb15 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/falcon/nic.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/falcon/nic.h</span>
<span class="p_chunk">@@ -83,7 +83,7 @@</span> <span class="p_context"> static inline struct ef4_tx_queue *ef4_tx_queue_partner(struct ef4_tx_queue *tx_</span>
 static inline bool __ef4_nic_tx_is_empty(struct ef4_tx_queue *tx_queue,
 					 unsigned int write_count)
 {
<span class="p_del">-	unsigned int empty_read_count = ACCESS_ONCE(tx_queue-&gt;empty_read_count);</span>
<span class="p_add">+	unsigned int empty_read_count = READ_ONCE(tx_queue-&gt;empty_read_count);</span>
 
 	if (empty_read_count == 0)
 		return false;
<span class="p_chunk">@@ -464,11 +464,11 @@</span> <span class="p_context"> irqreturn_t ef4_farch_fatal_interrupt(struct ef4_nic *efx);</span>
 
 static inline int ef4_nic_event_test_irq_cpu(struct ef4_channel *channel)
 {
<span class="p_del">-	return ACCESS_ONCE(channel-&gt;event_test_cpu);</span>
<span class="p_add">+	return READ_ONCE(channel-&gt;event_test_cpu);</span>
 }
 static inline int ef4_nic_irq_test_irq_cpu(struct ef4_nic *efx)
 {
<span class="p_del">-	return ACCESS_ONCE(efx-&gt;last_irq_cpu);</span>
<span class="p_add">+	return READ_ONCE(efx-&gt;last_irq_cpu);</span>
 }
 
 /* Global Resources */
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/falcon/tx.c b/drivers/net/ethernet/sfc/falcon/tx.c</span>
<span class="p_header">index 6a75f4140a4b..6486814e97dc 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/falcon/tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/falcon/tx.c</span>
<span class="p_chunk">@@ -134,8 +134,8 @@</span> <span class="p_context"> static void ef4_tx_maybe_stop_queue(struct ef4_tx_queue *txq1)</span>
 	 */
 	netif_tx_stop_queue(txq1-&gt;core_txq);
 	smp_mb();
<span class="p_del">-	txq1-&gt;old_read_count = ACCESS_ONCE(txq1-&gt;read_count);</span>
<span class="p_del">-	txq2-&gt;old_read_count = ACCESS_ONCE(txq2-&gt;read_count);</span>
<span class="p_add">+	txq1-&gt;old_read_count = READ_ONCE(txq1-&gt;read_count);</span>
<span class="p_add">+	txq2-&gt;old_read_count = READ_ONCE(txq2-&gt;read_count);</span>
 
 	fill_level = max(txq1-&gt;insert_count - txq1-&gt;old_read_count,
 			 txq2-&gt;insert_count - txq2-&gt;old_read_count);
<span class="p_chunk">@@ -524,7 +524,7 @@</span> <span class="p_context"> void ef4_xmit_done(struct ef4_tx_queue *tx_queue, unsigned int index)</span>
 
 	/* Check whether the hardware queue is now empty */
 	if ((int)(tx_queue-&gt;read_count - tx_queue-&gt;old_write_count) &gt;= 0) {
<span class="p_del">-		tx_queue-&gt;old_write_count = ACCESS_ONCE(tx_queue-&gt;write_count);</span>
<span class="p_add">+		tx_queue-&gt;old_write_count = READ_ONCE(tx_queue-&gt;write_count);</span>
 		if (tx_queue-&gt;read_count == tx_queue-&gt;old_write_count) {
 			smp_mb();
 			tx_queue-&gt;empty_read_count =
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/farch.c b/drivers/net/ethernet/sfc/farch.c</span>
<span class="p_header">index ba45150f53c7..86454d25a405 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/farch.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/farch.c</span>
<span class="p_chunk">@@ -827,7 +827,7 @@</span> <span class="p_context"> efx_farch_handle_tx_event(struct efx_channel *channel, efx_qword_t *event)</span>
 	struct efx_nic *efx = channel-&gt;efx;
 	int tx_packets = 0;
 
<span class="p_del">-	if (unlikely(ACCESS_ONCE(efx-&gt;reset_pending)))</span>
<span class="p_add">+	if (unlikely(READ_ONCE(efx-&gt;reset_pending)))</span>
 		return 0;
 
 	if (likely(EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_COMP))) {
<span class="p_chunk">@@ -979,7 +979,7 @@</span> <span class="p_context"> efx_farch_handle_rx_event(struct efx_channel *channel, const efx_qword_t *event)</span>
 	struct efx_rx_queue *rx_queue;
 	struct efx_nic *efx = channel-&gt;efx;
 
<span class="p_del">-	if (unlikely(ACCESS_ONCE(efx-&gt;reset_pending)))</span>
<span class="p_add">+	if (unlikely(READ_ONCE(efx-&gt;reset_pending)))</span>
 		return;
 
 	rx_ev_cont = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_JUMBO_CONT);
<span class="p_chunk">@@ -1520,7 +1520,7 @@</span> <span class="p_context"> irqreturn_t efx_farch_fatal_interrupt(struct efx_nic *efx)</span>
 irqreturn_t efx_farch_legacy_interrupt(int irq, void *dev_id)
 {
 	struct efx_nic *efx = dev_id;
<span class="p_del">-	bool soft_enabled = ACCESS_ONCE(efx-&gt;irq_soft_enabled);</span>
<span class="p_add">+	bool soft_enabled = READ_ONCE(efx-&gt;irq_soft_enabled);</span>
 	efx_oword_t *int_ker = efx-&gt;irq_status.addr;
 	irqreturn_t result = IRQ_NONE;
 	struct efx_channel *channel;
<span class="p_chunk">@@ -1612,7 +1612,7 @@</span> <span class="p_context"> irqreturn_t efx_farch_msi_interrupt(int irq, void *dev_id)</span>
 		   &quot;IRQ %d on CPU %d status &quot; EFX_OWORD_FMT &quot;\n&quot;,
 		   irq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));
 
<span class="p_del">-	if (!likely(ACCESS_ONCE(efx-&gt;irq_soft_enabled)))</span>
<span class="p_add">+	if (!likely(READ_ONCE(efx-&gt;irq_soft_enabled)))</span>
 		return IRQ_HANDLED;
 
 	/* Handle non-event-queue sources */
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/nic.h b/drivers/net/ethernet/sfc/nic.h</span>
<span class="p_header">index 4d7fb8af880d..7b51b6371724 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/nic.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/nic.h</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> static struct efx_tx_queue *efx_tx_queue_partner(struct efx_tx_queue *tx_queue)</span>
 static inline bool __efx_nic_tx_is_empty(struct efx_tx_queue *tx_queue,
 					 unsigned int write_count)
 {
<span class="p_del">-	unsigned int empty_read_count = ACCESS_ONCE(tx_queue-&gt;empty_read_count);</span>
<span class="p_add">+	unsigned int empty_read_count = READ_ONCE(tx_queue-&gt;empty_read_count);</span>
 
 	if (empty_read_count == 0)
 		return false;
<span class="p_chunk">@@ -617,11 +617,11 @@</span> <span class="p_context"> irqreturn_t efx_farch_fatal_interrupt(struct efx_nic *efx);</span>
 
 static inline int efx_nic_event_test_irq_cpu(struct efx_channel *channel)
 {
<span class="p_del">-	return ACCESS_ONCE(channel-&gt;event_test_cpu);</span>
<span class="p_add">+	return READ_ONCE(channel-&gt;event_test_cpu);</span>
 }
 static inline int efx_nic_irq_test_irq_cpu(struct efx_nic *efx)
 {
<span class="p_del">-	return ACCESS_ONCE(efx-&gt;last_irq_cpu);</span>
<span class="p_add">+	return READ_ONCE(efx-&gt;last_irq_cpu);</span>
 }
 
 /* Global Resources */
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/ptp.c b/drivers/net/ethernet/sfc/ptp.c</span>
<span class="p_header">index 60cdb97f58e2..56c2db398def 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/ptp.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/ptp.c</span>
<span class="p_chunk">@@ -658,7 +658,7 @@</span> <span class="p_context"> static void efx_ptp_send_times(struct efx_nic *efx,</span>
 
 	/* Write host time for specified period or until MC is done */
 	while ((timespec64_compare(&amp;now.ts_real, &amp;limit) &lt; 0) &amp;&amp;
<span class="p_del">-	       ACCESS_ONCE(*mc_running)) {</span>
<span class="p_add">+	       READ_ONCE(*mc_running)) {</span>
 		struct timespec64 update_time;
 		unsigned int host_time;
 
<span class="p_chunk">@@ -668,7 +668,7 @@</span> <span class="p_context"> static void efx_ptp_send_times(struct efx_nic *efx,</span>
 		do {
 			pps_get_ts(&amp;now);
 		} while ((timespec64_compare(&amp;now.ts_real, &amp;update_time) &lt; 0) &amp;&amp;
<span class="p_del">-			 ACCESS_ONCE(*mc_running));</span>
<span class="p_add">+			 READ_ONCE(*mc_running));</span>
 
 		/* Synchronise NIC with single word of time only */
 		host_time = (now.ts_real.tv_sec &lt;&lt; MC_NANOSECOND_BITS |
<span class="p_chunk">@@ -832,14 +832,14 @@</span> <span class="p_context"> static int efx_ptp_synchronize(struct efx_nic *efx, unsigned int num_readings)</span>
 		       ptp-&gt;start.dma_addr);
 
 	/* Clear flag that signals MC ready */
<span class="p_del">-	ACCESS_ONCE(*start) = 0;</span>
<span class="p_add">+	WRITE_ONCE(*start, 0);</span>
 	rc = efx_mcdi_rpc_start(efx, MC_CMD_PTP, synch_buf,
 				MC_CMD_PTP_IN_SYNCHRONIZE_LEN);
 	EFX_WARN_ON_ONCE_PARANOID(rc);
 
 	/* Wait for start from MCDI (or timeout) */
 	timeout = jiffies + msecs_to_jiffies(MAX_SYNCHRONISE_WAIT_MS);
<span class="p_del">-	while (!ACCESS_ONCE(*start) &amp;&amp; (time_before(jiffies, timeout))) {</span>
<span class="p_add">+	while (!READ_ONCE(*start) &amp;&amp; (time_before(jiffies, timeout))) {</span>
 		udelay(20);	/* Usually start MCDI execution quickly */
 		loops++;
 	}
<span class="p_chunk">@@ -849,7 +849,7 @@</span> <span class="p_context"> static int efx_ptp_synchronize(struct efx_nic *efx, unsigned int num_readings)</span>
 	if (!time_before(jiffies, timeout))
 		++ptp-&gt;sync_timeouts;
 
<span class="p_del">-	if (ACCESS_ONCE(*start))</span>
<span class="p_add">+	if (READ_ONCE(*start))</span>
 		efx_ptp_send_times(efx, &amp;last_time);
 
 	/* Collect results */
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/tx.c b/drivers/net/ethernet/sfc/tx.c</span>
<span class="p_header">index 32bf1fecf864..efb66ea21f27 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/tx.c</span>
<span class="p_chunk">@@ -136,8 +136,8 @@</span> <span class="p_context"> static void efx_tx_maybe_stop_queue(struct efx_tx_queue *txq1)</span>
 	 */
 	netif_tx_stop_queue(txq1-&gt;core_txq);
 	smp_mb();
<span class="p_del">-	txq1-&gt;old_read_count = ACCESS_ONCE(txq1-&gt;read_count);</span>
<span class="p_del">-	txq2-&gt;old_read_count = ACCESS_ONCE(txq2-&gt;read_count);</span>
<span class="p_add">+	txq1-&gt;old_read_count = READ_ONCE(txq1-&gt;read_count);</span>
<span class="p_add">+	txq2-&gt;old_read_count = READ_ONCE(txq2-&gt;read_count);</span>
 
 	fill_level = max(txq1-&gt;insert_count - txq1-&gt;old_read_count,
 			 txq2-&gt;insert_count - txq2-&gt;old_read_count);
<span class="p_chunk">@@ -752,7 +752,7 @@</span> <span class="p_context"> void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index)</span>
 
 	/* Check whether the hardware queue is now empty */
 	if ((int)(tx_queue-&gt;read_count - tx_queue-&gt;old_write_count) &gt;= 0) {
<span class="p_del">-		tx_queue-&gt;old_write_count = ACCESS_ONCE(tx_queue-&gt;write_count);</span>
<span class="p_add">+		tx_queue-&gt;old_write_count = READ_ONCE(tx_queue-&gt;write_count);</span>
 		if (tx_queue-&gt;read_count == tx_queue-&gt;old_write_count) {
 			smp_mb();
 			tx_queue-&gt;empty_read_count =
<span class="p_header">diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">index 6a4e8e1bbd90..8ab0fb6892d5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_chunk">@@ -6245,7 +6245,7 @@</span> <span class="p_context"> static void niu_get_rx_stats(struct niu *np,</span>
 
 	pkts = dropped = errors = bytes = 0;
 
<span class="p_del">-	rx_rings = ACCESS_ONCE(np-&gt;rx_rings);</span>
<span class="p_add">+	rx_rings = READ_ONCE(np-&gt;rx_rings);</span>
 	if (!rx_rings)
 		goto no_rings;
 
<span class="p_chunk">@@ -6276,7 +6276,7 @@</span> <span class="p_context"> static void niu_get_tx_stats(struct niu *np,</span>
 
 	pkts = errors = bytes = 0;
 
<span class="p_del">-	tx_rings = ACCESS_ONCE(np-&gt;tx_rings);</span>
<span class="p_add">+	tx_rings = READ_ONCE(np-&gt;tx_rings);</span>
 	if (!tx_rings)
 		goto no_rings;
 
<span class="p_header">diff --git a/drivers/net/tap.c b/drivers/net/tap.c</span>
<span class="p_header">index 21b71ae947fd..b55b29b90b88 100644</span>
<span class="p_header">--- a/drivers/net/tap.c</span>
<span class="p_header">+++ b/drivers/net/tap.c</span>
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> static struct tap_queue *tap_get_queue(struct tap_dev *tap,</span>
 	 * and validate that the result isn&#39;t NULL - in case we are
 	 * racing against queue removal.
 	 */
<span class="p_del">-	int numvtaps = ACCESS_ONCE(tap-&gt;numvtaps);</span>
<span class="p_add">+	int numvtaps = READ_ONCE(tap-&gt;numvtaps);</span>
 	__u32 rxq;
 
 	if (!numvtaps)
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 5ce580f413b9..6aee2afb1f69 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -469,7 +469,7 @@</span> <span class="p_context"> static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb,</span>
 	u32 numqueues = 0;
 
 	rcu_read_lock();
<span class="p_del">-	numqueues = ACCESS_ONCE(tun-&gt;numqueues);</span>
<span class="p_add">+	numqueues = READ_ONCE(tun-&gt;numqueues);</span>
 
 	txq = __skb_get_hash_symmetric(skb);
 	if (txq) {
<span class="p_chunk">@@ -864,7 +864,7 @@</span> <span class="p_context"> static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 
 	rcu_read_lock();
 	tfile = rcu_dereference(tun-&gt;tfiles[txq]);
<span class="p_del">-	numqueues = ACCESS_ONCE(tun-&gt;numqueues);</span>
<span class="p_add">+	numqueues = READ_ONCE(tun-&gt;numqueues);</span>
 
 	/* Drop packet if interface is not attached */
 	if (txq &gt;= numqueues)
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath5k/desc.c b/drivers/net/wireless/ath/ath5k/desc.c</span>
<span class="p_header">index bd8d4392d68b..80f75139495f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath5k/desc.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath5k/desc.c</span>
<span class="p_chunk">@@ -500,13 +500,13 @@</span> <span class="p_context"> ath5k_hw_proc_4word_tx_status(struct ath5k_hw *ah,</span>
 
 	tx_status = &amp;desc-&gt;ud.ds_tx5212.tx_stat;
 
<span class="p_del">-	txstat1 = ACCESS_ONCE(tx_status-&gt;tx_status_1);</span>
<span class="p_add">+	txstat1 = READ_ONCE(tx_status-&gt;tx_status_1);</span>
 
 	/* No frame has been send or error */
 	if (unlikely(!(txstat1 &amp; AR5K_DESC_TX_STATUS1_DONE)))
 		return -EINPROGRESS;
 
<span class="p_del">-	txstat0 = ACCESS_ONCE(tx_status-&gt;tx_status_0);</span>
<span class="p_add">+	txstat0 = READ_ONCE(tx_status-&gt;tx_status_0);</span>
 
 	/*
 	 * Get descriptor status
<span class="p_chunk">@@ -700,14 +700,14 @@</span> <span class="p_context"> ath5k_hw_proc_5212_rx_status(struct ath5k_hw *ah,</span>
 	u32 rxstat0, rxstat1;
 
 	rx_status = &amp;desc-&gt;ud.ds_rx.rx_stat;
<span class="p_del">-	rxstat1 = ACCESS_ONCE(rx_status-&gt;rx_status_1);</span>
<span class="p_add">+	rxstat1 = READ_ONCE(rx_status-&gt;rx_status_1);</span>
 
 	/* No frame received / not ready */
 	if (unlikely(!(rxstat1 &amp; AR5K_5212_RX_DESC_STATUS1_DONE)))
 		return -EINPROGRESS;
 
 	memset(rs, 0, sizeof(struct ath5k_rx_status));
<span class="p_del">-	rxstat0 = ACCESS_ONCE(rx_status-&gt;rx_status_0);</span>
<span class="p_add">+	rxstat0 = READ_ONCE(rx_status-&gt;rx_status_0);</span>
 
 	/*
 	 * Frame receive status
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">index 613caca7dc02..785a0f33b7e6 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_chunk">@@ -3628,7 +3628,7 @@</span> <span class="p_context"> static void brcmf_sdio_dataworker(struct work_struct *work)</span>
 
 	bus-&gt;dpc_running = true;
 	wmb();
<span class="p_del">-	while (ACCESS_ONCE(bus-&gt;dpc_triggered)) {</span>
<span class="p_add">+	while (READ_ONCE(bus-&gt;dpc_triggered)) {</span>
 		bus-&gt;dpc_triggered = false;
 		brcmf_sdio_dpc(bus);
 		bus-&gt;idlecount = 0;
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/ops.c b/drivers/net/wireless/intel/iwlwifi/mvm/ops.c</span>
<span class="p_header">index 231878969332..0f45f34e39d3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/ops.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/ops.c</span>
<span class="p_chunk">@@ -1118,7 +1118,7 @@</span> <span class="p_context"> void iwl_mvm_set_hw_ctkill_state(struct iwl_mvm *mvm, bool state)</span>
 static bool iwl_mvm_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
 {
 	struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
<span class="p_del">-	bool calibrating = ACCESS_ONCE(mvm-&gt;calibrating);</span>
<span class="p_add">+	bool calibrating = READ_ONCE(mvm-&gt;calibrating);</span>
 
 	if (state)
 		set_bit(IWL_MVM_STATUS_HW_RFKILL, &amp;mvm-&gt;status);
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">index 6f2e2af23219..6e9d3289b9d0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_chunk">@@ -652,7 +652,7 @@</span> <span class="p_context"> int iwl_mvm_tx_skb_non_sta(struct iwl_mvm *mvm, struct sk_buff *skb)</span>
 				return -1;
 		} else if (info.control.vif-&gt;type == NL80211_IFTYPE_STATION &amp;&amp;
 			   is_multicast_ether_addr(hdr-&gt;addr1)) {
<span class="p_del">-			u8 ap_sta_id = ACCESS_ONCE(mvmvif-&gt;ap_sta_id);</span>
<span class="p_add">+			u8 ap_sta_id = READ_ONCE(mvmvif-&gt;ap_sta_id);</span>
 
 			if (ap_sta_id != IWL_MVM_INVALID_STA)
 				sta_id = ap_sta_id;
<span class="p_chunk">@@ -700,7 +700,7 @@</span> <span class="p_context"> static int iwl_mvm_tx_tso(struct iwl_mvm *mvm, struct sk_buff *skb,</span>
 	snap_ip_tcp = 8 + skb_transport_header(skb) - skb_network_header(skb) +
 		tcp_hdrlen(skb);
 
<span class="p_del">-	dbg_max_amsdu_len = ACCESS_ONCE(mvm-&gt;max_amsdu_len);</span>
<span class="p_add">+	dbg_max_amsdu_len = READ_ONCE(mvm-&gt;max_amsdu_len);</span>
 
 	if (!sta-&gt;max_amsdu_len ||
 	    !ieee80211_is_data_qos(hdr-&gt;frame_control) ||
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/rx.c b/drivers/net/wireless/intel/iwlwifi/pcie/rx.c</span>
<span class="p_header">index a06b6612b658..f25ce3a1ea50 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/pcie/rx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/pcie/rx.c</span>
<span class="p_chunk">@@ -1247,7 +1247,7 @@</span> <span class="p_context"> static void iwl_pcie_rx_handle(struct iwl_trans *trans, int queue)</span>
 	spin_lock(&amp;rxq-&gt;lock);
 	/* uCode&#39;s read index (stored in shared DRAM) indicates the last Rx
 	 * buffer that the driver may process (last buffer filled by ucode). */
<span class="p_del">-	r = le16_to_cpu(ACCESS_ONCE(rxq-&gt;rb_stts-&gt;closed_rb_num)) &amp; 0x0FFF;</span>
<span class="p_add">+	r = le16_to_cpu(READ_ONCE(rxq-&gt;rb_stts-&gt;closed_rb_num)) &amp; 0x0FFF;</span>
 	i = rxq-&gt;read;
 
 	/* W/A 9000 device step A0 wrap-around bug */
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c</span>
<span class="p_header">index 2e3e013ec95a..9ad3f4fe5894 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c</span>
<span class="p_chunk">@@ -2076,12 +2076,12 @@</span> <span class="p_context"> static int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans, int txq_idx)</span>
 
 	IWL_DEBUG_TX_QUEUES(trans, &quot;Emptying queue %d...\n&quot;, txq_idx);
 	txq = trans_pcie-&gt;txq[txq_idx];
<span class="p_del">-	wr_ptr = ACCESS_ONCE(txq-&gt;write_ptr);</span>
<span class="p_add">+	wr_ptr = READ_ONCE(txq-&gt;write_ptr);</span>
 
<span class="p_del">-	while (txq-&gt;read_ptr != ACCESS_ONCE(txq-&gt;write_ptr) &amp;&amp;</span>
<span class="p_add">+	while (txq-&gt;read_ptr != READ_ONCE(txq-&gt;write_ptr) &amp;&amp;</span>
 	       !time_after(jiffies,
 			   now + msecs_to_jiffies(IWL_FLUSH_WAIT_MS))) {
<span class="p_del">-		u8 write_ptr = ACCESS_ONCE(txq-&gt;write_ptr);</span>
<span class="p_add">+		u8 write_ptr = READ_ONCE(txq-&gt;write_ptr);</span>
 
 		if (WARN_ONCE(wr_ptr != write_ptr,
 			      &quot;WR pointer moved while flushing %d -&gt; %d\n&quot;,
<span class="p_chunk">@@ -2553,7 +2553,7 @@</span> <span class="p_context"> static u32 iwl_trans_pcie_dump_rbs(struct iwl_trans *trans,</span>
 
 	spin_lock(&amp;rxq-&gt;lock);
 
<span class="p_del">-	r = le16_to_cpu(ACCESS_ONCE(rxq-&gt;rb_stts-&gt;closed_rb_num)) &amp; 0x0FFF;</span>
<span class="p_add">+	r = le16_to_cpu(READ_ONCE(rxq-&gt;rb_stts-&gt;closed_rb_num)) &amp; 0x0FFF;</span>
 
 	for (i = rxq-&gt;read, j = 0;
 	     i != r &amp;&amp; j &lt; allocated_rb_nums;
<span class="p_chunk">@@ -2814,7 +2814,7 @@</span> <span class="p_context"> static struct iwl_trans_dump_data</span>
 		/* Dump RBs is supported only for pre-9000 devices (1 queue) */
 		struct iwl_rxq *rxq = &amp;trans_pcie-&gt;rxq[0];
 		/* RBs */
<span class="p_del">-		num_rbs = le16_to_cpu(ACCESS_ONCE(rxq-&gt;rb_stts-&gt;closed_rb_num))</span>
<span class="p_add">+		num_rbs = le16_to_cpu(READ_ONCE(rxq-&gt;rb_stts-&gt;closed_rb_num))</span>
 				      &amp; 0x0FFF;
 		num_rbs = (num_rbs - rxq-&gt;read) &amp; RX_QUEUE_MASK;
 		len += num_rbs * (sizeof(*data) +
<span class="p_header">diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">index 6467ffac9811..d2b3d6177a55 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_chunk">@@ -1380,7 +1380,7 @@</span> <span class="p_context"> static void mac80211_hwsim_tx(struct ieee80211_hw *hw,</span>
 	mac80211_hwsim_monitor_rx(hw, skb, channel);
 
 	/* wmediumd mode check */
<span class="p_del">-	_portid = ACCESS_ONCE(data-&gt;wmediumd);</span>
<span class="p_add">+	_portid = READ_ONCE(data-&gt;wmediumd);</span>
 
 	if (_portid)
 		return mac80211_hwsim_tx_frame_nl(hw, skb, _portid);
<span class="p_chunk">@@ -1477,7 +1477,7 @@</span> <span class="p_context"> static void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,</span>
 				    struct ieee80211_channel *chan)
 {
 	struct mac80211_hwsim_data *data = hw-&gt;priv;
<span class="p_del">-	u32 _pid = ACCESS_ONCE(data-&gt;wmediumd);</span>
<span class="p_add">+	u32 _pid = READ_ONCE(data-&gt;wmediumd);</span>
 
 	if (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE)) {
 		struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">index f05cfc83c9c8..f946bf889015 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_chunk">@@ -996,7 +996,7 @@</span> <span class="p_context"> static void qlt_free_session_done(struct work_struct *work)</span>
 	if (logout_started) {
 		bool traced = false;
 
<span class="p_del">-		while (!ACCESS_ONCE(sess-&gt;logout_completed)) {</span>
<span class="p_add">+		while (!READ_ONCE(sess-&gt;logout_completed)) {</span>
 			if (!traced) {
 				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf086,
 					&quot;%s: waiting for sess %p logout\n&quot;,
<span class="p_header">diff --git a/drivers/target/target_core_user.c b/drivers/target/target_core_user.c</span>
<span class="p_header">index 942d094269fb..9469695f5871 100644</span>
<span class="p_header">--- a/drivers/target/target_core_user.c</span>
<span class="p_header">+++ b/drivers/target/target_core_user.c</span>
<span class="p_chunk">@@ -985,7 +985,7 @@</span> <span class="p_context"> static unsigned int tcmu_handle_completions(struct tcmu_dev *udev)</span>
 	mb = udev-&gt;mb_addr;
 	tcmu_flush_dcache_range(mb, sizeof(*mb));
 
<span class="p_del">-	while (udev-&gt;cmdr_last_cleaned != ACCESS_ONCE(mb-&gt;cmd_tail)) {</span>
<span class="p_add">+	while (udev-&gt;cmdr_last_cleaned != READ_ONCE(mb-&gt;cmd_tail)) {</span>
 
 		struct tcmu_cmd_entry *entry = (void *) mb + CMDR_OFF + udev-&gt;cmdr_last_cleaned;
 		struct tcmu_cmd *cmd;
<span class="p_header">diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">index 3e865dbf878c..fbaa2a90d25d 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_chunk">@@ -483,7 +483,7 @@</span> <span class="p_context"> static ssize_t wdm_read</span>
 	if (rv &lt; 0)
 		return -ERESTARTSYS;
 
<span class="p_del">-	cntr = ACCESS_ONCE(desc-&gt;length);</span>
<span class="p_add">+	cntr = READ_ONCE(desc-&gt;length);</span>
 	if (cntr == 0) {
 		desc-&gt;read = 0;
 retry:
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 4664e543cf2f..07cd2d245e65 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static int usbfs_increase_memory_usage(u64 amount)</span>
 {
 	u64 lim;
 
<span class="p_del">-	lim = ACCESS_ONCE(usbfs_memory_mb);</span>
<span class="p_add">+	lim = READ_ONCE(usbfs_memory_mb);</span>
 	lim &lt;&lt;= 20;
 
 	atomic64_add(amount, &amp;usbfs_memory_usage);
<span class="p_header">diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c</span>
<span class="p_header">index d930bfda4010..58d59c5f8592 100644</span>
<span class="p_header">--- a/drivers/usb/core/sysfs.c</span>
<span class="p_header">+++ b/drivers/usb/core/sysfs.c</span>
<span class="p_chunk">@@ -973,7 +973,7 @@</span> <span class="p_context"> static ssize_t interface_show(struct device *dev, struct device_attribute *attr,</span>
 	char *string;
 
 	intf = to_usb_interface(dev);
<span class="p_del">-	string = ACCESS_ONCE(intf-&gt;cur_altsetting-&gt;string);</span>
<span class="p_add">+	string = READ_ONCE(intf-&gt;cur_altsetting-&gt;string);</span>
 	if (!string)
 		return 0;
 	return sprintf(buf, &quot;%s\n&quot;, string);
<span class="p_chunk">@@ -989,7 +989,7 @@</span> <span class="p_context"> static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,</span>
 
 	intf = to_usb_interface(dev);
 	udev = interface_to_usbdev(intf);
<span class="p_del">-	alt = ACCESS_ONCE(intf-&gt;cur_altsetting);</span>
<span class="p_add">+	alt = READ_ONCE(intf-&gt;cur_altsetting);</span>
 
 	return sprintf(buf, &quot;usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02X&quot;
 			&quot;ic%02Xisc%02Xip%02Xin%02X\n&quot;,
<span class="p_header">diff --git a/drivers/usb/gadget/udc/gr_udc.c b/drivers/usb/gadget/udc/gr_udc.c</span>
<span class="p_header">index 1f9941145746..0b59fa50aa30 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/gr_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/gr_udc.c</span>
<span class="p_chunk">@@ -1261,7 +1261,7 @@</span> <span class="p_context"> static int gr_handle_in_ep(struct gr_ep *ep)</span>
 	if (!req-&gt;last_desc)
 		return 0;
 
<span class="p_del">-	if (ACCESS_ONCE(req-&gt;last_desc-&gt;ctrl) &amp; GR_DESC_IN_CTRL_EN)</span>
<span class="p_add">+	if (READ_ONCE(req-&gt;last_desc-&gt;ctrl) &amp; GR_DESC_IN_CTRL_EN)</span>
 		return 0; /* Not put in hardware buffers yet */
 
 	if (gr_read32(&amp;ep-&gt;regs-&gt;epstat) &amp; (GR_EPSTAT_B1 | GR_EPSTAT_B0))
<span class="p_chunk">@@ -1290,7 +1290,7 @@</span> <span class="p_context"> static int gr_handle_out_ep(struct gr_ep *ep)</span>
 	if (!req-&gt;curr_desc)
 		return 0;
 
<span class="p_del">-	ctrl = ACCESS_ONCE(req-&gt;curr_desc-&gt;ctrl);</span>
<span class="p_add">+	ctrl = READ_ONCE(req-&gt;curr_desc-&gt;ctrl);</span>
 	if (ctrl &amp; GR_DESC_OUT_CTRL_EN)
 		return 0; /* Not received yet */
 
<span class="p_header">diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c</span>
<span class="p_header">index 44924824fa41..c86f89babd57 100644</span>
<span class="p_header">--- a/drivers/usb/host/ohci-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/ohci-hcd.c</span>
<span class="p_chunk">@@ -785,7 +785,7 @@</span> <span class="p_context"> static void io_watchdog_func(unsigned long _ohci)</span>
 		}
 
 		/* find the last TD processed by the controller. */
<span class="p_del">-		head = hc32_to_cpu(ohci, ACCESS_ONCE(ed-&gt;hwHeadP)) &amp; TD_MASK;</span>
<span class="p_add">+		head = hc32_to_cpu(ohci, READ_ONCE(ed-&gt;hwHeadP)) &amp; TD_MASK;</span>
 		td_start = td;
 		td_next = list_prepare_entry(td, &amp;ed-&gt;td_list, td_list);
 		list_for_each_entry_continue(td_next, &amp;ed-&gt;td_list, td_list) {
<span class="p_header">diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h</span>
<span class="p_header">index 91b22b2ea3aa..09a2a259941b 100644</span>
<span class="p_header">--- a/drivers/usb/host/uhci-hcd.h</span>
<span class="p_header">+++ b/drivers/usb/host/uhci-hcd.h</span>
<span class="p_chunk">@@ -186,7 +186,7 @@</span> <span class="p_context"> struct uhci_qh {</span>
  * We need a special accessor for the element pointer because it is
  * subject to asynchronous updates by the controller.
  */
<span class="p_del">-#define qh_element(qh)		ACCESS_ONCE((qh)-&gt;element)</span>
<span class="p_add">+#define qh_element(qh)		READ_ONCE((qh)-&gt;element)</span>
 
 #define LINK_TO_QH(uhci, qh)	(UHCI_PTR_QH((uhci)) | \
 				cpu_to_hc32((uhci), (qh)-&gt;dma_handle))
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> struct uhci_td {</span>
  * subject to asynchronous updates by the controller.
  */
 #define td_status(uhci, td)		hc32_to_cpu((uhci), \
<span class="p_del">-						ACCESS_ONCE((td)-&gt;status))</span>
<span class="p_add">+						READ_ONCE((td)-&gt;status))</span>
 
 #define LINK_TO_TD(uhci, td)		(cpu_to_hc32((uhci), (td)-&gt;dma_handle))
 
<span class="p_header">diff --git a/drivers/vfio/vfio.c b/drivers/vfio/vfio.c</span>
<span class="p_header">index f5a86f651f38..2bc3705a99bd 100644</span>
<span class="p_header">--- a/drivers/vfio/vfio.c</span>
<span class="p_header">+++ b/drivers/vfio/vfio.c</span>
<span class="p_chunk">@@ -665,7 +665,7 @@</span> <span class="p_context"> static int vfio_dev_viable(struct device *dev, void *data)</span>
 {
 	struct vfio_group *group = data;
 	struct vfio_device *device;
<span class="p_del">-	struct device_driver *drv = ACCESS_ONCE(dev-&gt;driver);</span>
<span class="p_add">+	struct device_driver *drv = READ_ONCE(dev-&gt;driver);</span>
 	struct vfio_unbound_dev *unbound;
 	int ret = -EINVAL;
 
<span class="p_header">diff --git a/drivers/vhost/scsi.c b/drivers/vhost/scsi.c</span>
<span class="p_header">index 046f6d280af5..35e929f132e8 100644</span>
<span class="p_header">--- a/drivers/vhost/scsi.c</span>
<span class="p_header">+++ b/drivers/vhost/scsi.c</span>
<span class="p_chunk">@@ -929,7 +929,7 @@</span> <span class="p_context"> vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)</span>
 			continue;
 		}
 
<span class="p_del">-		tpg = ACCESS_ONCE(vs_tpg[*target]);</span>
<span class="p_add">+		tpg = READ_ONCE(vs_tpg[*target]);</span>
 		if (unlikely(!tpg)) {
 			/* Target does not exist, fail the request */
 			vhost_scsi_send_bad_target(vs, vq, head, out);
<span class="p_header">diff --git a/fs/aio.c b/fs/aio.c</span>
<span class="p_header">index 5a2487217072..e6de7715228c 100644</span>
<span class="p_header">--- a/fs/aio.c</span>
<span class="p_header">+++ b/fs/aio.c</span>
<span class="p_chunk">@@ -576,7 +576,7 @@</span> <span class="p_context"> static int kiocb_cancel(struct aio_kiocb *kiocb)</span>
 	 * actually has a cancel function, hence the cmpxchg()
 	 */
 
<span class="p_del">-	cancel = ACCESS_ONCE(kiocb-&gt;ki_cancel);</span>
<span class="p_add">+	cancel = READ_ONCE(kiocb-&gt;ki_cancel);</span>
 	do {
 		if (!cancel || cancel == KIOCB_CANCELLED)
 			return -EINVAL;
<span class="p_header">diff --git a/fs/buffer.c b/fs/buffer.c</span>
<span class="p_header">index 170df856bdb9..32ce01f0f95f 100644</span>
<span class="p_header">--- a/fs/buffer.c</span>
<span class="p_header">+++ b/fs/buffer.c</span>
<span class="p_chunk">@@ -1692,7 +1692,8 @@</span> <span class="p_context"> static struct buffer_head *create_page_buffers(struct page *page, struct inode *</span>
 	BUG_ON(!PageLocked(page));
 
 	if (!page_has_buffers(page))
<span class="p_del">-		create_empty_buffers(page, 1 &lt;&lt; ACCESS_ONCE(inode-&gt;i_blkbits), b_state);</span>
<span class="p_add">+		create_empty_buffers(page, 1 &lt;&lt; READ_ONCE(inode-&gt;i_blkbits),</span>
<span class="p_add">+				     b_state);</span>
 	return page_buffers(page);
 }
 
<span class="p_header">diff --git a/fs/crypto/keyinfo.c b/fs/crypto/keyinfo.c</span>
<span class="p_header">index 018c588c7ac3..768263c2d077 100644</span>
<span class="p_header">--- a/fs/crypto/keyinfo.c</span>
<span class="p_header">+++ b/fs/crypto/keyinfo.c</span>
<span class="p_chunk">@@ -368,7 +368,7 @@</span> <span class="p_context"> void fscrypt_put_encryption_info(struct inode *inode, struct fscrypt_info *ci)</span>
 	struct fscrypt_info *prev;
 
 	if (ci == NULL)
<span class="p_del">-		ci = ACCESS_ONCE(inode-&gt;i_crypt_info);</span>
<span class="p_add">+		ci = READ_ONCE(inode-&gt;i_crypt_info);</span>
 	if (ci == NULL)
 		return;
 
<span class="p_header">diff --git a/fs/direct-io.c b/fs/direct-io.c</span>
<span class="p_header">index 62cf812ed0e5..066cf268694f 100644</span>
<span class="p_header">--- a/fs/direct-io.c</span>
<span class="p_header">+++ b/fs/direct-io.c</span>
<span class="p_chunk">@@ -1140,7 +1140,7 @@</span> <span class="p_context"> do_blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,</span>
 		      get_block_t get_block, dio_iodone_t end_io,
 		      dio_submit_t submit_io, int flags)
 {
<span class="p_del">-	unsigned i_blkbits = ACCESS_ONCE(inode-&gt;i_blkbits);</span>
<span class="p_add">+	unsigned i_blkbits = READ_ONCE(inode-&gt;i_blkbits);</span>
 	unsigned blkbits = i_blkbits;
 	unsigned blocksize_mask = (1 &lt;&lt; blkbits) - 1;
 	ssize_t retval = -EINVAL;
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 5470d3c1892a..13331bc42454 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -1910,7 +1910,7 @@</span> <span class="p_context"> void set_dumpable(struct mm_struct *mm, int value)</span>
 		return;
 
 	do {
<span class="p_del">-		old = ACCESS_ONCE(mm-&gt;flags);</span>
<span class="p_add">+		old = READ_ONCE(mm-&gt;flags);</span>
 		new = (old &amp; ~MMF_DUMPABLE_MASK) | value;
 	} while (cmpxchg(&amp;mm-&gt;flags, old, new) != old);
 }
<span class="p_header">diff --git a/fs/fcntl.c b/fs/fcntl.c</span>
<span class="p_header">index 448a1119f0be..57bf2964bb83 100644</span>
<span class="p_header">--- a/fs/fcntl.c</span>
<span class="p_header">+++ b/fs/fcntl.c</span>
<span class="p_chunk">@@ -724,7 +724,7 @@</span> <span class="p_context"> static void send_sigio_to_task(struct task_struct *p,</span>
 	 * F_SETSIG can change -&gt;signum lockless in parallel, make
 	 * sure we read it once and use the same value throughout.
 	 */
<span class="p_del">-	int signum = ACCESS_ONCE(fown-&gt;signum);</span>
<span class="p_add">+	int signum = READ_ONCE(fown-&gt;signum);</span>
 
 	if (!sigio_perm(p, fown, signum))
 		return;
<span class="p_header">diff --git a/fs/fs_pin.c b/fs/fs_pin.c</span>
<span class="p_header">index e747b3d720ee..2d07f292b625 100644</span>
<span class="p_header">--- a/fs/fs_pin.c</span>
<span class="p_header">+++ b/fs/fs_pin.c</span>
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> void mnt_pin_kill(struct mount *m)</span>
 	while (1) {
 		struct hlist_node *p;
 		rcu_read_lock();
<span class="p_del">-		p = ACCESS_ONCE(m-&gt;mnt_pins.first);</span>
<span class="p_add">+		p = READ_ONCE(m-&gt;mnt_pins.first);</span>
 		if (!p) {
 			rcu_read_unlock();
 			break;
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> void group_pin_kill(struct hlist_head *p)</span>
 	while (1) {
 		struct hlist_node *q;
 		rcu_read_lock();
<span class="p_del">-		q = ACCESS_ONCE(p-&gt;first);</span>
<span class="p_add">+		q = READ_ONCE(p-&gt;first);</span>
 		if (!q) {
 			rcu_read_unlock();
 			break;
<span class="p_header">diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c</span>
<span class="p_header">index 13c65dd2d37d..a42d89371748 100644</span>
<span class="p_header">--- a/fs/fuse/dev.c</span>
<span class="p_header">+++ b/fs/fuse/dev.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"> static struct fuse_dev *fuse_get_dev(struct file *file)</span>
 	 * Lockless access is OK, because file-&gt;private data is set
 	 * once during mount and is valid until the file is released.
 	 */
<span class="p_del">-	return ACCESS_ONCE(file-&gt;private_data);</span>
<span class="p_add">+	return READ_ONCE(file-&gt;private_data);</span>
 }
 
 static void fuse_request_init(struct fuse_req *req, struct page **pages,
<span class="p_header">diff --git a/fs/inode.c b/fs/inode.c</span>
<span class="p_header">index d1e35b53bb23..fd401028a309 100644</span>
<span class="p_header">--- a/fs/inode.c</span>
<span class="p_header">+++ b/fs/inode.c</span>
<span class="p_chunk">@@ -2090,7 +2090,7 @@</span> <span class="p_context"> void inode_set_flags(struct inode *inode, unsigned int flags,</span>
 
 	WARN_ON_ONCE(flags &amp; ~mask);
 	do {
<span class="p_del">-		old_flags = ACCESS_ONCE(inode-&gt;i_flags);</span>
<span class="p_add">+		old_flags = READ_ONCE(inode-&gt;i_flags);</span>
 		new_flags = (old_flags &amp; ~mask) | flags;
 	} while (unlikely(cmpxchg(&amp;inode-&gt;i_flags, old_flags,
 				  new_flags) != old_flags));
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index c75ea03ca147..40a0f34bf990 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1209,7 +1209,7 @@</span> <span class="p_context"> static int follow_managed(struct path *path, struct nameidata *nd)</span>
 	/* Given that we&#39;re not holding a lock here, we retain the value in a
 	 * local variable for each dentry as we look at it so that we don&#39;t see
 	 * the components of that value change under us */
<span class="p_del">-	while (managed = ACCESS_ONCE(path-&gt;dentry-&gt;d_flags),</span>
<span class="p_add">+	while (managed = READ_ONCE(path-&gt;dentry-&gt;d_flags),</span>
 	       managed &amp;= DCACHE_MANAGED_DENTRY,
 	       unlikely(managed != 0)) {
 		/* Allow the filesystem to manage the transit without i_mutex
<span class="p_chunk">@@ -1394,7 +1394,7 @@</span> <span class="p_context"> int follow_down(struct path *path)</span>
 	unsigned managed;
 	int ret;
 
<span class="p_del">-	while (managed = ACCESS_ONCE(path-&gt;dentry-&gt;d_flags),</span>
<span class="p_add">+	while (managed = READ_ONCE(path-&gt;dentry-&gt;d_flags),</span>
 	       unlikely(managed &amp; DCACHE_MANAGED_DENTRY)) {
 		/* Allow the filesystem to manage the transit without i_mutex
 		 * being held.
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 3b601f115b6c..f65f2dc786cf 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -353,7 +353,7 @@</span> <span class="p_context"> int __mnt_want_write(struct vfsmount *m)</span>
 	 * incremented count after it has set MNT_WRITE_HOLD.
 	 */
 	smp_mb();
<span class="p_del">-	while (ACCESS_ONCE(mnt-&gt;mnt.mnt_flags) &amp; MNT_WRITE_HOLD)</span>
<span class="p_add">+	while (READ_ONCE(mnt-&gt;mnt.mnt_flags) &amp; MNT_WRITE_HOLD)</span>
 		cpu_relax();
 	/*
 	 * After the slowpath clears MNT_WRITE_HOLD, mnt_is_readonly will
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index 5ceaeb1f6fb6..f439f1c45008 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -1081,7 +1081,7 @@</span> <span class="p_context"> static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags)</span>
 	int error;
 
 	if (flags &amp; LOOKUP_RCU) {
<span class="p_del">-		parent = ACCESS_ONCE(dentry-&gt;d_parent);</span>
<span class="p_add">+		parent = READ_ONCE(dentry-&gt;d_parent);</span>
 		dir = d_inode_rcu(parent);
 		if (!dir)
 			return -ECHILD;
<span class="p_chunk">@@ -1168,7 +1168,7 @@</span> <span class="p_context"> static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags)</span>
 	nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
  out_valid:
 	if (flags &amp; LOOKUP_RCU) {
<span class="p_del">-		if (parent != ACCESS_ONCE(dentry-&gt;d_parent))</span>
<span class="p_add">+		if (parent != READ_ONCE(dentry-&gt;d_parent))</span>
 			return -ECHILD;
 	} else
 		dput(parent);
<span class="p_chunk">@@ -1582,7 +1582,7 @@</span> <span class="p_context"> static int nfs4_lookup_revalidate(struct dentry *dentry, unsigned int flags)</span>
 		struct inode *dir;
 
 		if (flags &amp; LOOKUP_RCU) {
<span class="p_del">-			parent = ACCESS_ONCE(dentry-&gt;d_parent);</span>
<span class="p_add">+			parent = READ_ONCE(dentry-&gt;d_parent);</span>
 			dir = d_inode_rcu(parent);
 			if (!dir)
 				return -ECHILD;
<span class="p_chunk">@@ -1596,7 +1596,7 @@</span> <span class="p_context"> static int nfs4_lookup_revalidate(struct dentry *dentry, unsigned int flags)</span>
 			ret = -ECHILD;
 		if (!(flags &amp; LOOKUP_RCU))
 			dput(parent);
<span class="p_del">-		else if (parent != ACCESS_ONCE(dentry-&gt;d_parent))</span>
<span class="p_add">+		else if (parent != READ_ONCE(dentry-&gt;d_parent))</span>
 			return -ECHILD;
 		goto out;
 	}
<span class="p_header">diff --git a/fs/proc/array.c b/fs/proc/array.c</span>
<span class="p_header">index 77a8eacbe032..375e8bf0dd24 100644</span>
<span class="p_header">--- a/fs/proc/array.c</span>
<span class="p_header">+++ b/fs/proc/array.c</span>
<span class="p_chunk">@@ -453,7 +453,7 @@</span> <span class="p_context"> static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,</span>
 		cutime = sig-&gt;cutime;
 		cstime = sig-&gt;cstime;
 		cgtime = sig-&gt;cgtime;
<span class="p_del">-		rsslim = ACCESS_ONCE(sig-&gt;rlim[RLIMIT_RSS].rlim_cur);</span>
<span class="p_add">+		rsslim = READ_ONCE(sig-&gt;rlim[RLIMIT_RSS].rlim_cur);</span>
 
 		/* add up live thread stats at the group level */
 		if (whole) {
<span class="p_header">diff --git a/fs/proc_namespace.c b/fs/proc_namespace.c</span>
<span class="p_header">index 99dff222fe67..03afd5150916 100644</span>
<span class="p_header">--- a/fs/proc_namespace.c</span>
<span class="p_header">+++ b/fs/proc_namespace.c</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"> static unsigned mounts_poll(struct file *file, poll_table *wait)</span>
 
 	poll_wait(file, &amp;p-&gt;ns-&gt;poll, wait);
 
<span class="p_del">-	event = ACCESS_ONCE(ns-&gt;event);</span>
<span class="p_add">+	event = READ_ONCE(ns-&gt;event);</span>
 	if (m-&gt;poll_event != event) {
 		m-&gt;poll_event = event;
 		res |= POLLERR | POLLPRI;
<span class="p_header">diff --git a/fs/splice.c b/fs/splice.c</span>
<span class="p_header">index f3084cce0ea6..39e2dc01ac12 100644</span>
<span class="p_header">--- a/fs/splice.c</span>
<span class="p_header">+++ b/fs/splice.c</span>
<span class="p_chunk">@@ -253,7 +253,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(add_to_pipe);</span>
  */
 int splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)
 {
<span class="p_del">-	unsigned int buffers = ACCESS_ONCE(pipe-&gt;buffers);</span>
<span class="p_add">+	unsigned int buffers = READ_ONCE(pipe-&gt;buffers);</span>
 
 	spd-&gt;nr_pages_max = buffers;
 	if (buffers &lt;= PIPE_DEF_BUFFERS)
<span class="p_header">diff --git a/fs/userfaultfd.c b/fs/userfaultfd.c</span>
<span class="p_header">index 1c713fd5b3e6..f46d133c0949 100644</span>
<span class="p_header">--- a/fs/userfaultfd.c</span>
<span class="p_header">+++ b/fs/userfaultfd.c</span>
<span class="p_chunk">@@ -381,7 +381,7 @@</span> <span class="p_context"> int handle_userfault(struct vm_fault *vmf, unsigned long reason)</span>
 	 * in __get_user_pages if userfaultfd_release waits on the
 	 * caller of handle_userfault to release the mmap_sem.
 	 */
<span class="p_del">-	if (unlikely(ACCESS_ONCE(ctx-&gt;released))) {</span>
<span class="p_add">+	if (unlikely(READ_ONCE(ctx-&gt;released))) {</span>
 		/*
 		 * Don&#39;t return VM_FAULT_SIGBUS in this case, so a non
 		 * cooperative manager can close the uffd after the
<span class="p_chunk">@@ -477,7 +477,7 @@</span> <span class="p_context"> int handle_userfault(struct vm_fault *vmf, unsigned long reason)</span>
 						       vmf-&gt;flags, reason);
 	up_read(&amp;mm-&gt;mmap_sem);
 
<span class="p_del">-	if (likely(must_wait &amp;&amp; !ACCESS_ONCE(ctx-&gt;released) &amp;&amp;</span>
<span class="p_add">+	if (likely(must_wait &amp;&amp; !READ_ONCE(ctx-&gt;released) &amp;&amp;</span>
 		   (return_to_userland ? !signal_pending(current) :
 		    !fatal_signal_pending(current)))) {
 		wake_up_poll(&amp;ctx-&gt;fd_wqh, POLLIN);
<span class="p_chunk">@@ -586,7 +586,7 @@</span> <span class="p_context"> static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,</span>
 		set_current_state(TASK_KILLABLE);
 		if (ewq-&gt;msg.event == 0)
 			break;
<span class="p_del">-		if (ACCESS_ONCE(ctx-&gt;released) ||</span>
<span class="p_add">+		if (READ_ONCE(ctx-&gt;released) ||</span>
 		    fatal_signal_pending(current)) {
 			/*
 			 * &amp;ewq-&gt;wq may be queued in fork_event, but
<span class="p_chunk">@@ -833,7 +833,7 @@</span> <span class="p_context"> static int userfaultfd_release(struct inode *inode, struct file *file)</span>
 	struct userfaultfd_wake_range range = { .len = 0, };
 	unsigned long new_flags;
 
<span class="p_del">-	ACCESS_ONCE(ctx-&gt;released) = true;</span>
<span class="p_add">+	WRITE_ONCE(ctx-&gt;released, true);</span>
 
 	if (!mmget_not_zero(mm))
 		goto wakeup;
<span class="p_header">diff --git a/fs/xfs/xfs_log_priv.h b/fs/xfs/xfs_log_priv.h</span>
<span class="p_header">index 51bf7b827387..129975970d99 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_log_priv.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_log_priv.h</span>
<span class="p_chunk">@@ -592,9 +592,9 @@</span> <span class="p_context"> xlog_valid_lsn(</span>
 	 * a transiently forward state. Instead, we can see the LSN in a
 	 * transiently behind state if we happen to race with a cycle wrap.
 	 */
<span class="p_del">-	cur_cycle = ACCESS_ONCE(log-&gt;l_curr_cycle);</span>
<span class="p_add">+	cur_cycle = READ_ONCE(log-&gt;l_curr_cycle);</span>
 	smp_rmb();
<span class="p_del">-	cur_block = ACCESS_ONCE(log-&gt;l_curr_block);</span>
<span class="p_add">+	cur_block = READ_ONCE(log-&gt;l_curr_block);</span>
 
 	if ((CYCLE_LSN(lsn) &gt; cur_cycle) ||
 	    (CYCLE_LSN(lsn) == cur_cycle &amp;&amp; BLOCK_LSN(lsn) &gt; cur_block)) {
<span class="p_header">diff --git a/include/linux/bitops.h b/include/linux/bitops.h</span>
<span class="p_header">index 8fbe259b197c..0a7ce668f8e0 100644</span>
<span class="p_header">--- a/include/linux/bitops.h</span>
<span class="p_header">+++ b/include/linux/bitops.h</span>
<span class="p_chunk">@@ -236,7 +236,7 @@</span> <span class="p_context"> static inline unsigned long __ffs64(u64 word)</span>
 	typeof(*ptr) old, new;					\
 								\
 	do {							\
<span class="p_del">-		old = ACCESS_ONCE(*ptr);			\</span>
<span class="p_add">+		old = READ_ONCE(*ptr);			\</span>
 		new = (old &amp; ~mask) | bits;			\
 	} while (cmpxchg(ptr, old, new) != old);		\
 								\
<span class="p_chunk">@@ -251,7 +251,7 @@</span> <span class="p_context"> static inline unsigned long __ffs64(u64 word)</span>
 	typeof(*ptr) old, new;					\
 								\
 	do {							\
<span class="p_del">-		old = ACCESS_ONCE(*ptr);			\</span>
<span class="p_add">+		old = READ_ONCE(*ptr);			\</span>
 		new = old &amp; ~clear;				\
 	} while (!(old &amp; test) &amp;&amp;				\
 		 cmpxchg(ptr, old, new) != old);		\
<span class="p_header">diff --git a/include/linux/dynamic_queue_limits.h b/include/linux/dynamic_queue_limits.h</span>
<span class="p_header">index a4be70398ce1..36dd4ffb5715 100644</span>
<span class="p_header">--- a/include/linux/dynamic_queue_limits.h</span>
<span class="p_header">+++ b/include/linux/dynamic_queue_limits.h</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> static inline void dql_queued(struct dql *dql, unsigned int count)</span>
 /* Returns how many objects can be queued, &lt; 0 indicates over limit. */
 static inline int dql_avail(const struct dql *dql)
 {
<span class="p_del">-	return ACCESS_ONCE(dql-&gt;adj_limit) - ACCESS_ONCE(dql-&gt;num_queued);</span>
<span class="p_add">+	return READ_ONCE(dql-&gt;adj_limit) - READ_ONCE(dql-&gt;num_queued);</span>
 }
 
 /* Record number of completed objects and recalculate the limit. */
<span class="p_header">diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h</span>
<span class="p_header">index 14bc21c2ee7f..785a00ca4628 100644</span>
<span class="p_header">--- a/include/linux/huge_mm.h</span>
<span class="p_header">+++ b/include/linux/huge_mm.h</span>
<span class="p_chunk">@@ -221,7 +221,7 @@</span> <span class="p_context"> extern struct page *huge_zero_page;</span>
 
 static inline bool is_huge_zero_page(struct page *page)
 {
<span class="p_del">-	return ACCESS_ONCE(huge_zero_page) == page;</span>
<span class="p_add">+	return READ_ONCE(huge_zero_page) == page;</span>
 }
 
 static inline bool is_huge_zero_pmd(pmd_t pmd)
<span class="p_header">diff --git a/include/linux/if_team.h b/include/linux/if_team.h</span>
<span class="p_header">index 30294603526f..d95cae09dea0 100644</span>
<span class="p_header">--- a/include/linux/if_team.h</span>
<span class="p_header">+++ b/include/linux/if_team.h</span>
<span class="p_chunk">@@ -247,7 +247,7 @@</span> <span class="p_context"> static inline struct team_port *team_get_port_by_index(struct team *team,</span>
 
 static inline int team_num_to_port_index(struct team *team, unsigned int num)
 {
<span class="p_del">-	int en_port_count = ACCESS_ONCE(team-&gt;en_port_count);</span>
<span class="p_add">+	int en_port_count = READ_ONCE(team-&gt;en_port_count);</span>
 
 	if (unlikely(!en_port_count))
 		return 0;
<span class="p_header">diff --git a/include/linux/llist.h b/include/linux/llist.h</span>
<span class="p_header">index 1957635e6d5f..85abc2915e8d 100644</span>
<span class="p_header">--- a/include/linux/llist.h</span>
<span class="p_header">+++ b/include/linux/llist.h</span>
<span class="p_chunk">@@ -198,7 +198,7 @@</span> <span class="p_context"> static inline void init_llist_head(struct llist_head *list)</span>
  */
 static inline bool llist_empty(const struct llist_head *head)
 {
<span class="p_del">-	return ACCESS_ONCE(head-&gt;first) == NULL;</span>
<span class="p_add">+	return READ_ONCE(head-&gt;first) == NULL;</span>
 }
 
 static inline struct llist_node *llist_next(struct llist_node *node)
<span class="p_header">diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h</span>
<span class="p_header">index 2efb08a60e63..f0fc4700b6ff 100644</span>
<span class="p_header">--- a/include/linux/pm_runtime.h</span>
<span class="p_header">+++ b/include/linux/pm_runtime.h</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static inline bool pm_runtime_callbacks_present(struct device *dev)</span>
 
 static inline void pm_runtime_mark_last_busy(struct device *dev)
 {
<span class="p_del">-	ACCESS_ONCE(dev-&gt;power.last_busy) = jiffies;</span>
<span class="p_add">+	WRITE_ONCE(dev-&gt;power.last_busy, jiffies);</span>
 }
 
 static inline bool pm_runtime_is_irq_safe(struct device *dev)
<span class="p_header">diff --git a/include/net/ip_vs.h b/include/net/ip_vs.h</span>
<span class="p_header">index 4f4f786255ef..3fadb6f9982b 100644</span>
<span class="p_header">--- a/include/net/ip_vs.h</span>
<span class="p_header">+++ b/include/net/ip_vs.h</span>
<span class="p_chunk">@@ -983,12 +983,12 @@</span> <span class="p_context"> static inline int sysctl_sync_threshold(struct netns_ipvs *ipvs)</span>
 
 static inline int sysctl_sync_period(struct netns_ipvs *ipvs)
 {
<span class="p_del">-	return ACCESS_ONCE(ipvs-&gt;sysctl_sync_threshold[1]);</span>
<span class="p_add">+	return READ_ONCE(ipvs-&gt;sysctl_sync_threshold[1]);</span>
 }
 
 static inline unsigned int sysctl_sync_refresh_period(struct netns_ipvs *ipvs)
 {
<span class="p_del">-	return ACCESS_ONCE(ipvs-&gt;sysctl_sync_refresh_period);</span>
<span class="p_add">+	return READ_ONCE(ipvs-&gt;sysctl_sync_refresh_period);</span>
 }
 
 static inline int sysctl_sync_retries(struct netns_ipvs *ipvs)
<span class="p_chunk">@@ -1013,7 +1013,7 @@</span> <span class="p_context"> static inline int sysctl_sloppy_sctp(struct netns_ipvs *ipvs)</span>
 
 static inline int sysctl_sync_ports(struct netns_ipvs *ipvs)
 {
<span class="p_del">-	return ACCESS_ONCE(ipvs-&gt;sysctl_sync_ports);</span>
<span class="p_add">+	return READ_ONCE(ipvs-&gt;sysctl_sync_ports);</span>
 }
 
 static inline int sysctl_sync_persist_mode(struct netns_ipvs *ipvs)
<span class="p_header">diff --git a/kernel/acct.c b/kernel/acct.c</span>
<span class="p_header">index 5e72af29ab73..21eedd0dd81a 100644</span>
<span class="p_header">--- a/kernel/acct.c</span>
<span class="p_header">+++ b/kernel/acct.c</span>
<span class="p_chunk">@@ -146,7 +146,7 @@</span> <span class="p_context"> static struct bsd_acct_struct *acct_get(struct pid_namespace *ns)</span>
 again:
 	smp_rmb();
 	rcu_read_lock();
<span class="p_del">-	res = to_acct(ACCESS_ONCE(ns-&gt;bacct));</span>
<span class="p_add">+	res = to_acct(READ_ONCE(ns-&gt;bacct));</span>
 	if (!res) {
 		rcu_read_unlock();
 		return NULL;
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> static struct bsd_acct_struct *acct_get(struct pid_namespace *ns)</span>
 	}
 	rcu_read_unlock();
 	mutex_lock(&amp;res-&gt;lock);
<span class="p_del">-	if (res != to_acct(ACCESS_ONCE(ns-&gt;bacct))) {</span>
<span class="p_add">+	if (res != to_acct(READ_ONCE(ns-&gt;bacct))) {</span>
 		mutex_unlock(&amp;res-&gt;lock);
 		acct_put(res);
 		goto again;
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 417812ce0099..a1322e855e9f 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -1200,7 +1200,7 @@</span> <span class="p_context"> perf_event_ctx_lock_nested(struct perf_event *event, int nesting)</span>
 
 again:
 	rcu_read_lock();
<span class="p_del">-	ctx = ACCESS_ONCE(event-&gt;ctx);</span>
<span class="p_add">+	ctx = READ_ONCE(event-&gt;ctx);</span>
 	if (!atomic_inc_not_zero(&amp;ctx-&gt;refcount)) {
 		rcu_read_unlock();
 		goto again;
<span class="p_chunk">@@ -5302,8 +5302,8 @@</span> <span class="p_context"> static int perf_mmap(struct file *file, struct vm_area_struct *vma)</span>
 		if (!rb)
 			goto aux_unlock;
 
<span class="p_del">-		aux_offset = ACCESS_ONCE(rb-&gt;user_page-&gt;aux_offset);</span>
<span class="p_del">-		aux_size = ACCESS_ONCE(rb-&gt;user_page-&gt;aux_size);</span>
<span class="p_add">+		aux_offset = READ_ONCE(rb-&gt;user_page-&gt;aux_offset);</span>
<span class="p_add">+		aux_size = READ_ONCE(rb-&gt;user_page-&gt;aux_size);</span>
 
 		if (aux_offset &lt; perf_data_size(rb) + PAGE_SIZE)
 			goto aux_unlock;
<span class="p_header">diff --git a/kernel/events/ring_buffer.c b/kernel/events/ring_buffer.c</span>
<span class="p_header">index f684d8e5fa2b..f3e37971c842 100644</span>
<span class="p_header">--- a/kernel/events/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/events/ring_buffer.c</span>
<span class="p_chunk">@@ -381,7 +381,7 @@</span> <span class="p_context"> void *perf_aux_output_begin(struct perf_output_handle *handle,</span>
 	 * (B) &lt;-&gt; (C) ordering is still observed by the pmu driver.
 	 */
 	if (!rb-&gt;aux_overwrite) {
<span class="p_del">-		aux_tail = ACCESS_ONCE(rb-&gt;user_page-&gt;aux_tail);</span>
<span class="p_add">+		aux_tail = READ_ONCE(rb-&gt;user_page-&gt;aux_tail);</span>
 		handle-&gt;wakeup = rb-&gt;aux_wakeup + rb-&gt;aux_watermark;
 		if (aux_head - aux_tail &lt; perf_aux_size(rb))
 			handle-&gt;size = CIRC_SPACE(aux_head, aux_tail, perf_aux_size(rb));
<span class="p_header">diff --git a/kernel/exit.c b/kernel/exit.c</span>
<span class="p_header">index f2cd53e92147..e4fee98803b3 100644</span>
<span class="p_header">--- a/kernel/exit.c</span>
<span class="p_header">+++ b/kernel/exit.c</span>
<span class="p_chunk">@@ -1339,7 +1339,7 @@</span> <span class="p_context"> static int wait_consider_task(struct wait_opts *wo, int ptrace,</span>
 	 * Ensure that EXIT_ZOMBIE -&gt; EXIT_DEAD/EXIT_TRACE transition
 	 * can&#39;t confuse the checks below.
 	 */
<span class="p_del">-	int exit_state = ACCESS_ONCE(p-&gt;exit_state);</span>
<span class="p_add">+	int exit_state = READ_ONCE(p-&gt;exit_state);</span>
 	int ret;
 
 	if (unlikely(exit_state == EXIT_DEAD))
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 81279c6602ff..845f3805c73d 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -2724,7 +2724,7 @@</span> <span class="p_context"> rb_reserve_next_event(struct ring_buffer *buffer,</span>
 	 * if it happened, we have to fail the write.
 	 */
 	barrier();
<span class="p_del">-	if (unlikely(ACCESS_ONCE(cpu_buffer-&gt;buffer) != buffer)) {</span>
<span class="p_add">+	if (unlikely(READ_ONCE(cpu_buffer-&gt;buffer) != buffer)) {</span>
 		local_dec(&amp;cpu_buffer-&gt;committing);
 		local_dec(&amp;cpu_buffer-&gt;commits);
 		return NULL;
<span class="p_header">diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h</span>
<span class="p_header">index 652c682707cd..9050c8b3ccde 100644</span>
<span class="p_header">--- a/kernel/trace/trace.h</span>
<span class="p_header">+++ b/kernel/trace/trace.h</span>
<span class="p_chunk">@@ -1459,7 +1459,7 @@</span> <span class="p_context"> extern struct trace_event_file *find_event_file(struct trace_array *tr,</span>
 
 static inline void *event_file_data(struct file *filp)
 {
<span class="p_del">-	return ACCESS_ONCE(file_inode(filp)-&gt;i_private);</span>
<span class="p_add">+	return READ_ONCE(file_inode(filp)-&gt;i_private);</span>
 }
 
 extern struct mutex event_mutex;
<span class="p_header">diff --git a/kernel/trace/trace_stack.c b/kernel/trace/trace_stack.c</span>
<span class="p_header">index 49cb41412eec..780262210c9a 100644</span>
<span class="p_header">--- a/kernel/trace/trace_stack.c</span>
<span class="p_header">+++ b/kernel/trace/trace_stack.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> check_stack(unsigned long ip, unsigned long *stack)</span>
 {
 	unsigned long this_size, flags; unsigned long *p, *top, *start;
 	static int tracer_frame;
<span class="p_del">-	int frame_size = ACCESS_ONCE(tracer_frame);</span>
<span class="p_add">+	int frame_size = READ_ONCE(tracer_frame);</span>
 	int i, x;
 
 	this_size = ((unsigned long)stack) &amp; (THREAD_SIZE-1);
<span class="p_header">diff --git a/kernel/user_namespace.c b/kernel/user_namespace.c</span>
<span class="p_header">index c490f1e4313b..d32b45662fb6 100644</span>
<span class="p_header">--- a/kernel/user_namespace.c</span>
<span class="p_header">+++ b/kernel/user_namespace.c</span>
<span class="p_chunk">@@ -894,7 +894,7 @@</span> <span class="p_context"> static bool new_idmap_permitted(const struct file *file,</span>
 int proc_setgroups_show(struct seq_file *seq, void *v)
 {
 	struct user_namespace *ns = seq-&gt;private;
<span class="p_del">-	unsigned long userns_flags = ACCESS_ONCE(ns-&gt;flags);</span>
<span class="p_add">+	unsigned long userns_flags = READ_ONCE(ns-&gt;flags);</span>
 
 	seq_printf(seq, &quot;%s\n&quot;,
 		   (userns_flags &amp; USERNS_SETGROUPS_ALLOWED) ?
<span class="p_header">diff --git a/lib/assoc_array.c b/lib/assoc_array.c</span>
<span class="p_header">index 155c55d8db5f..fe7953aead82 100644</span>
<span class="p_header">--- a/lib/assoc_array.c</span>
<span class="p_header">+++ b/lib/assoc_array.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"> static int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,</span>
 		/* Descend through a shortcut */
 		shortcut = assoc_array_ptr_to_shortcut(cursor);
 		smp_read_barrier_depends();
<span class="p_del">-		cursor = ACCESS_ONCE(shortcut-&gt;next_node);</span>
<span class="p_add">+		cursor = READ_ONCE(shortcut-&gt;next_node);</span>
 	}
 
 	node = assoc_array_ptr_to_node(cursor);
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> static int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,</span>
 	 */
 	has_meta = 0;
 	for (; slot &lt; ASSOC_ARRAY_FAN_OUT; slot++) {
<span class="p_del">-		ptr = ACCESS_ONCE(node-&gt;slots[slot]);</span>
<span class="p_add">+		ptr = READ_ONCE(node-&gt;slots[slot]);</span>
 		has_meta |= (unsigned long)ptr;
 		if (ptr &amp;&amp; assoc_array_ptr_is_leaf(ptr)) {
 			/* We need a barrier between the read of the pointer
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> static int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,</span>
 	smp_read_barrier_depends();
 
 	for (; slot &lt; ASSOC_ARRAY_FAN_OUT; slot++) {
<span class="p_del">-		ptr = ACCESS_ONCE(node-&gt;slots[slot]);</span>
<span class="p_add">+		ptr = READ_ONCE(node-&gt;slots[slot]);</span>
 		if (assoc_array_ptr_is_meta(ptr)) {
 			cursor = ptr;
 			goto begin_node;
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> static int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,</span>
 
 finished_node:
 	/* Move up to the parent (may need to skip back over a shortcut) */
<span class="p_del">-	parent = ACCESS_ONCE(node-&gt;back_pointer);</span>
<span class="p_add">+	parent = READ_ONCE(node-&gt;back_pointer);</span>
 	slot = node-&gt;parent_slot;
 	if (parent == stop)
 		return 0;
<span class="p_chunk">@@ -107,7 +107,7 @@</span> <span class="p_context"> static int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,</span>
 		shortcut = assoc_array_ptr_to_shortcut(parent);
 		smp_read_barrier_depends();
 		cursor = parent;
<span class="p_del">-		parent = ACCESS_ONCE(shortcut-&gt;back_pointer);</span>
<span class="p_add">+		parent = READ_ONCE(shortcut-&gt;back_pointer);</span>
 		slot = shortcut-&gt;parent_slot;
 		if (parent == stop)
 			return 0;
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> int assoc_array_iterate(const struct assoc_array *array,</span>
 					void *iterator_data),
 			void *iterator_data)
 {
<span class="p_del">-	struct assoc_array_ptr *root = ACCESS_ONCE(array-&gt;root);</span>
<span class="p_add">+	struct assoc_array_ptr *root = READ_ONCE(array-&gt;root);</span>
 
 	if (!root)
 		return 0;
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> assoc_array_walk(const struct assoc_array *array,</span>
 
 	pr_devel(&quot;--&gt;%s()\n&quot;, __func__);
 
<span class="p_del">-	cursor = ACCESS_ONCE(array-&gt;root);</span>
<span class="p_add">+	cursor = READ_ONCE(array-&gt;root);</span>
 	if (!cursor)
 		return assoc_array_walk_tree_empty;
 
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> assoc_array_walk(const struct assoc_array *array,</span>
 
 	slot = segments &gt;&gt; (level &amp; ASSOC_ARRAY_KEY_CHUNK_MASK);
 	slot &amp;= ASSOC_ARRAY_FAN_MASK;
<span class="p_del">-	ptr = ACCESS_ONCE(node-&gt;slots[slot]);</span>
<span class="p_add">+	ptr = READ_ONCE(node-&gt;slots[slot]);</span>
 
 	pr_devel(&quot;consider slot %x [ix=%d type=%lu]\n&quot;,
 		 slot, level, (unsigned long)ptr &amp; 3);
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> assoc_array_walk(const struct assoc_array *array,</span>
 	} while (sc_level &lt; shortcut-&gt;skip_to_level);
 
 	/* The shortcut matches the leaf&#39;s index to this point. */
<span class="p_del">-	cursor = ACCESS_ONCE(shortcut-&gt;next_node);</span>
<span class="p_add">+	cursor = READ_ONCE(shortcut-&gt;next_node);</span>
 	if (((level ^ sc_level) &amp; ~ASSOC_ARRAY_KEY_CHUNK_MASK) != 0) {
 		level = sc_level;
 		goto jumped;
<span class="p_chunk">@@ -337,7 +337,7 @@</span> <span class="p_context"> void *assoc_array_find(const struct assoc_array *array,</span>
 	 * the terminal node.
 	 */
 	for (slot = 0; slot &lt; ASSOC_ARRAY_FAN_OUT; slot++) {
<span class="p_del">-		ptr = ACCESS_ONCE(node-&gt;slots[slot]);</span>
<span class="p_add">+		ptr = READ_ONCE(node-&gt;slots[slot]);</span>
 		if (ptr &amp;&amp; assoc_array_ptr_is_leaf(ptr)) {
 			/* We need a barrier between the read of the pointer
 			 * and dereferencing the pointer - but only if we are
<span class="p_header">diff --git a/lib/dynamic_queue_limits.c b/lib/dynamic_queue_limits.c</span>
<span class="p_header">index f346715e2255..81770a55cb16 100644</span>
<span class="p_header">--- a/lib/dynamic_queue_limits.c</span>
<span class="p_header">+++ b/lib/dynamic_queue_limits.c</span>
<span class="p_chunk">@@ -20,7 +20,7 @@</span> <span class="p_context"> void dql_completed(struct dql *dql, unsigned int count)</span>
 	unsigned int ovlimit, completed, num_queued;
 	bool all_prev_completed;
 
<span class="p_del">-	num_queued = ACCESS_ONCE(dql-&gt;num_queued);</span>
<span class="p_add">+	num_queued = READ_ONCE(dql-&gt;num_queued);</span>
 
 	/* Can&#39;t complete more than what&#39;s in queue */
 	BUG_ON(count &gt; num_queued - dql-&gt;num_completed);
<span class="p_header">diff --git a/lib/llist.c b/lib/llist.c</span>
<span class="p_header">index ae5872b1df0c..7062e931a7bb 100644</span>
<span class="p_header">--- a/lib/llist.c</span>
<span class="p_header">+++ b/lib/llist.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> bool llist_add_batch(struct llist_node *new_first, struct llist_node *new_last,</span>
 	struct llist_node *first;
 
 	do {
<span class="p_del">-		new_last-&gt;next = first = ACCESS_ONCE(head-&gt;first);</span>
<span class="p_add">+		new_last-&gt;next = first = READ_ONCE(head-&gt;first);</span>
 	} while (cmpxchg(&amp;head-&gt;first, first, new_first) != first);
 
 	return !first;
<span class="p_header">diff --git a/lib/vsprintf.c b/lib/vsprintf.c</span>
<span class="p_header">index 86c3385b9eb3..1746bae94d41 100644</span>
<span class="p_header">--- a/lib/vsprintf.c</span>
<span class="p_header">+++ b/lib/vsprintf.c</span>
<span class="p_chunk">@@ -620,8 +620,8 @@</span> <span class="p_context"> char *dentry_name(char *buf, char *end, const struct dentry *d, struct printf_sp</span>
 
 	rcu_read_lock();
 	for (i = 0; i &lt; depth; i++, d = p) {
<span class="p_del">-		p = ACCESS_ONCE(d-&gt;d_parent);</span>
<span class="p_del">-		array[i] = ACCESS_ONCE(d-&gt;d_name.name);</span>
<span class="p_add">+		p = READ_ONCE(d-&gt;d_parent);</span>
<span class="p_add">+		array[i] = READ_ONCE(d-&gt;d_name.name);</span>
 		if (p == d) {
 			if (i)
 				array[i] = &quot;&quot;;
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 269b5df58543..c3bf907a03ee 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -2715,7 +2715,7 @@</span> <span class="p_context"> static unsigned long deferred_split_count(struct shrinker *shrink,</span>
 		struct shrink_control *sc)
 {
 	struct pglist_data *pgdata = NODE_DATA(sc-&gt;nid);
<span class="p_del">-	return ACCESS_ONCE(pgdata-&gt;split_queue_len);</span>
<span class="p_add">+	return READ_ONCE(pgdata-&gt;split_queue_len);</span>
 }
 
 static unsigned long deferred_split_scan(struct shrinker *shrink,
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 588b473194a8..648be63520c6 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -3725,7 +3725,7 @@</span> <span class="p_context"> bool rps_may_expire_flow(struct net_device *dev, u16 rxq_index,</span>
 	flow_table = rcu_dereference(rxqueue-&gt;rps_flow_table);
 	if (flow_table &amp;&amp; flow_id &lt;= flow_table-&gt;mask) {
 		rflow = &amp;flow_table-&gt;flows[flow_id];
<span class="p_del">-		cpu = ACCESS_ONCE(rflow-&gt;cpu);</span>
<span class="p_add">+		cpu = READ_ONCE(rflow-&gt;cpu);</span>
 		if (rflow-&gt;filter == filter_id &amp;&amp; cpu &lt; nr_cpu_ids &amp;&amp;
 		    ((int)(per_cpu(softnet_data, cpu).input_queue_head -
 			   rflow-&gt;last_qtail) &lt;
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index 6e1e10ff433a..3b2034f6d49d 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -3377,7 +3377,7 @@</span> <span class="p_context"> static void pktgen_wait_for_skb(struct pktgen_dev *pkt_dev)</span>
 
 static void pktgen_xmit(struct pktgen_dev *pkt_dev)
 {
<span class="p_del">-	unsigned int burst = ACCESS_ONCE(pkt_dev-&gt;burst);</span>
<span class="p_add">+	unsigned int burst = READ_ONCE(pkt_dev-&gt;burst);</span>
 	struct net_device *odev = pkt_dev-&gt;odev;
 	struct netdev_queue *txq;
 	struct sk_buff *skb;
<span class="p_header">diff --git a/net/ipv4/inet_fragment.c b/net/ipv4/inet_fragment.c</span>
<span class="p_header">index af74d0433453..f9597ba26599 100644</span>
<span class="p_header">--- a/net/ipv4/inet_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/inet_fragment.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static void inet_frag_worker(struct work_struct *work)</span>
 
 	local_bh_disable();
 
<span class="p_del">-	for (i = ACCESS_ONCE(f-&gt;next_bucket); budget; --budget) {</span>
<span class="p_add">+	for (i = READ_ONCE(f-&gt;next_bucket); budget; --budget) {</span>
 		evicted += inet_evict_bucket(f, &amp;f-&gt;hash[i]);
 		i = (i + 1) &amp; (INETFRAGS_HASHSZ - 1);
 		if (evicted &gt; INETFRAGS_EVICT_MAX)
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index ac6fde5d45f1..ea67e330be9e 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -495,7 +495,7 @@</span> <span class="p_context"> u32 ip_idents_reserve(u32 hash, int segs)</span>
 {
 	u32 *p_tstamp = ip_tstamps + hash % IP_IDENTS_SZ;
 	atomic_t *p_id = ip_idents + hash % IP_IDENTS_SZ;
<span class="p_del">-	u32 old = ACCESS_ONCE(*p_tstamp);</span>
<span class="p_add">+	u32 old = READ_ONCE(*p_tstamp);</span>
 	u32 now = (u32)jiffies;
 	u32 new, delta = 0;
 
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 0bc9e46a5369..48531da1aba6 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -1908,7 +1908,7 @@</span> <span class="p_context"> static bool tcp_tso_should_defer(struct sock *sk, struct sk_buff *skb,</span>
 	if ((skb != tcp_write_queue_tail(sk)) &amp;&amp; (limit &gt;= skb-&gt;len))
 		goto send_now;
 
<span class="p_del">-	win_divisor = ACCESS_ONCE(sysctl_tcp_tso_win_divisor);</span>
<span class="p_add">+	win_divisor = READ_ONCE(sysctl_tcp_tso_win_divisor);</span>
 	if (win_divisor) {
 		u32 chunk = min(tp-&gt;snd_wnd, tp-&gt;snd_cwnd * tp-&gt;mss_cache);
 
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 5676237d2b0f..1049347f2fbc 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1856,7 +1856,7 @@</span> <span class="p_context"> static int udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
 		 */
 
 		/* if we&#39;re overly short, let UDP handle it */
<span class="p_del">-		encap_rcv = ACCESS_ONCE(up-&gt;encap_rcv);</span>
<span class="p_add">+		encap_rcv = READ_ONCE(up-&gt;encap_rcv);</span>
 		if (encap_rcv) {
 			int ret;
 
<span class="p_chunk">@@ -2305,7 +2305,7 @@</span> <span class="p_context"> void udp_destroy_sock(struct sock *sk)</span>
 	unlock_sock_fast(sk, slow);
 	if (static_key_false(&amp;udp_encap_needed) &amp;&amp; up-&gt;encap_type) {
 		void (*encap_destroy)(struct sock *sk);
<span class="p_del">-		encap_destroy = ACCESS_ONCE(up-&gt;encap_destroy);</span>
<span class="p_add">+		encap_destroy = READ_ONCE(up-&gt;encap_destroy);</span>
 		if (encap_destroy)
 			encap_destroy(sk);
 	}
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index a1c24443cd9e..dab946554157 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -490,7 +490,7 @@</span> <span class="p_context"> ip6_tnl_err(struct sk_buff *skb, __u8 ipproto, struct inet6_skb_parm *opt,</span>
 	if (!t)
 		goto out;
 
<span class="p_del">-	tproto = ACCESS_ONCE(t-&gt;parms.proto);</span>
<span class="p_add">+	tproto = READ_ONCE(t-&gt;parms.proto);</span>
 	if (tproto != ipproto &amp;&amp; tproto != 0)
 		goto out;
 
<span class="p_chunk">@@ -899,7 +899,7 @@</span> <span class="p_context"> static int ipxip6_rcv(struct sk_buff *skb, u8 ipproto,</span>
 	t = ip6_tnl_lookup(dev_net(skb-&gt;dev), &amp;ipv6h-&gt;saddr, &amp;ipv6h-&gt;daddr);
 
 	if (t) {
<span class="p_del">-		u8 tproto = ACCESS_ONCE(t-&gt;parms.proto);</span>
<span class="p_add">+		u8 tproto = READ_ONCE(t-&gt;parms.proto);</span>
 
 		if (tproto != ipproto &amp;&amp; tproto != 0)
 			goto drop;
<span class="p_chunk">@@ -1233,7 +1233,7 @@</span> <span class="p_context"> ip4ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 
 	memset(&amp;(IPCB(skb)-&gt;opt), 0, sizeof(IPCB(skb)-&gt;opt));
 
<span class="p_del">-	tproto = ACCESS_ONCE(t-&gt;parms.proto);</span>
<span class="p_add">+	tproto = READ_ONCE(t-&gt;parms.proto);</span>
 	if (tproto != IPPROTO_IPIP &amp;&amp; tproto != 0)
 		return -1;
 
<span class="p_chunk">@@ -1303,7 +1303,7 @@</span> <span class="p_context"> ip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	u8 tproto;
 	int err;
 
<span class="p_del">-	tproto = ACCESS_ONCE(t-&gt;parms.proto);</span>
<span class="p_add">+	tproto = READ_ONCE(t-&gt;parms.proto);</span>
 	if ((tproto != IPPROTO_IPV6 &amp;&amp; tproto != 0) ||
 	    ip6_tnl_addr_conflict(t, ipv6h))
 		return -1;
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index 40d7234c27b9..3f30fa313bf2 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -606,7 +606,7 @@</span> <span class="p_context"> static int udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
 		 */
 
 		/* if we&#39;re overly short, let UDP handle it */
<span class="p_del">-		encap_rcv = ACCESS_ONCE(up-&gt;encap_rcv);</span>
<span class="p_add">+		encap_rcv = READ_ONCE(up-&gt;encap_rcv);</span>
 		if (encap_rcv) {
 			int ret;
 
<span class="p_chunk">@@ -1432,7 +1432,7 @@</span> <span class="p_context"> void udpv6_destroy_sock(struct sock *sk)</span>
 
 	if (static_key_false(&amp;udpv6_encap_needed) &amp;&amp; up-&gt;encap_type) {
 		void (*encap_destroy)(struct sock *sk);
<span class="p_del">-		encap_destroy = ACCESS_ONCE(up-&gt;encap_destroy);</span>
<span class="p_add">+		encap_destroy = READ_ONCE(up-&gt;encap_destroy);</span>
 		if (encap_destroy)
 			encap_destroy(sk);
 	}
<span class="p_header">diff --git a/net/llc/llc_input.c b/net/llc/llc_input.c</span>
<span class="p_header">index dd3e83328ad5..82cb93f66b9b 100644</span>
<span class="p_header">--- a/net/llc/llc_input.c</span>
<span class="p_header">+++ b/net/llc/llc_input.c</span>
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> int llc_rcv(struct sk_buff *skb, struct net_device *dev,</span>
 	 */
 	rcv = rcu_dereference(sap-&gt;rcv_func);
 	dest = llc_pdu_type(skb);
<span class="p_del">-	sap_handler = dest ? ACCESS_ONCE(llc_type_handlers[dest - 1]) : NULL;</span>
<span class="p_add">+	sap_handler = dest ? READ_ONCE(llc_type_handlers[dest - 1]) : NULL;</span>
 	if (unlikely(!sap_handler)) {
 		if (rcv)
 			rcv(skb, dev, pt, orig_dev);
<span class="p_chunk">@@ -214,7 +214,7 @@</span> <span class="p_context"> int llc_rcv(struct sk_buff *skb, struct net_device *dev,</span>
 	kfree_skb(skb);
 	goto out;
 handle_station:
<span class="p_del">-	sta_handler = ACCESS_ONCE(llc_station_handler);</span>
<span class="p_add">+	sta_handler = READ_ONCE(llc_station_handler);</span>
 	if (!sta_handler)
 		goto drop;
 	sta_handler(skb);
<span class="p_header">diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c</span>
<span class="p_header">index 69615016d5bf..214d2ba02877 100644</span>
<span class="p_header">--- a/net/mac80211/sta_info.c</span>
<span class="p_header">+++ b/net/mac80211/sta_info.c</span>
<span class="p_chunk">@@ -2008,7 +2008,7 @@</span> <span class="p_context"> static void sta_stats_decode_rate(struct ieee80211_local *local, u16 rate,</span>
 
 static int sta_set_rate_info_rx(struct sta_info *sta, struct rate_info *rinfo)
 {
<span class="p_del">-	u16 rate = ACCESS_ONCE(sta_get_last_rx_stats(sta)-&gt;last_rate);</span>
<span class="p_add">+	u16 rate = READ_ONCE(sta_get_last_rx_stats(sta)-&gt;last_rate);</span>
 
 	if (rate == STA_STATS_RATE_INVALID)
 		return -EINVAL;
<span class="p_header">diff --git a/net/netlabel/netlabel_calipso.c b/net/netlabel/netlabel_calipso.c</span>
<span class="p_header">index d177dd066504..4d748975117d 100644</span>
<span class="p_header">--- a/net/netlabel/netlabel_calipso.c</span>
<span class="p_header">+++ b/net/netlabel/netlabel_calipso.c</span>
<span class="p_chunk">@@ -393,7 +393,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(netlbl_calipso_ops_register);</span>
 
 static const struct netlbl_calipso_ops *netlbl_calipso_ops_get(void)
 {
<span class="p_del">-	return ACCESS_ONCE(calipso_ops);</span>
<span class="p_add">+	return READ_ONCE(calipso_ops);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 690874293cfc..fe63060e8c1b 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -14191,7 +14191,7 @@</span> <span class="p_context"> static bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,</span>
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev-&gt;wiphy);
 	struct sk_buff *msg;
 	void *hdr;
<span class="p_del">-	u32 nlportid = ACCESS_ONCE(wdev-&gt;ap_unexpected_nlportid);</span>
<span class="p_add">+	u32 nlportid = READ_ONCE(wdev-&gt;ap_unexpected_nlportid);</span>
 
 	if (!nlportid)
 		return false;
<span class="p_header">diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c</span>
<span class="p_header">index 23ccddb20de1..4210e5c6262e 100644</span>
<span class="p_header">--- a/sound/firewire/amdtp-am824.c</span>
<span class="p_header">+++ b/sound/firewire/amdtp-am824.c</span>
<span class="p_chunk">@@ -247,7 +247,7 @@</span> <span class="p_context"> void amdtp_am824_midi_trigger(struct amdtp_stream *s, unsigned int port,</span>
 	struct amdtp_am824 *p = s-&gt;protocol;
 
 	if (port &lt; p-&gt;midi_ports)
<span class="p_del">-		ACCESS_ONCE(p-&gt;midi[port]) = midi;</span>
<span class="p_add">+		WRITE_ONCE(p-&gt;midi[port], midi);</span>
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_midi_trigger);
 
<span class="p_chunk">@@ -336,7 +336,7 @@</span> <span class="p_context"> static unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffe</span>
 					   unsigned int data_blocks, unsigned int *syt)
 {
 	struct amdtp_am824 *p = s-&gt;protocol;
<span class="p_del">-	struct snd_pcm_substream *pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	struct snd_pcm_substream *pcm = READ_ONCE(s-&gt;pcm);</span>
 	unsigned int pcm_frames;
 
 	if (pcm) {
<span class="p_chunk">@@ -357,7 +357,7 @@</span> <span class="p_context"> static unsigned int process_tx_data_blocks(struct amdtp_stream *s, __be32 *buffe</span>
 					   unsigned int data_blocks, unsigned int *syt)
 {
 	struct amdtp_am824 *p = s-&gt;protocol;
<span class="p_del">-	struct snd_pcm_substream *pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	struct snd_pcm_substream *pcm = READ_ONCE(s-&gt;pcm);</span>
 	unsigned int pcm_frames;
 
 	if (pcm) {
<span class="p_header">diff --git a/sound/firewire/amdtp-stream.c b/sound/firewire/amdtp-stream.c</span>
<span class="p_header">index 3fc581a5ad62..4a1dc145327b 100644</span>
<span class="p_header">--- a/sound/firewire/amdtp-stream.c</span>
<span class="p_header">+++ b/sound/firewire/amdtp-stream.c</span>
<span class="p_chunk">@@ -376,7 +376,7 @@</span> <span class="p_context"> static void update_pcm_pointers(struct amdtp_stream *s,</span>
 	ptr = s-&gt;pcm_buffer_pointer + frames;
 	if (ptr &gt;= pcm-&gt;runtime-&gt;buffer_size)
 		ptr -= pcm-&gt;runtime-&gt;buffer_size;
<span class="p_del">-	ACCESS_ONCE(s-&gt;pcm_buffer_pointer) = ptr;</span>
<span class="p_add">+	WRITE_ONCE(s-&gt;pcm_buffer_pointer, ptr);</span>
 
 	s-&gt;pcm_period_pointer += frames;
 	if (s-&gt;pcm_period_pointer &gt;= pcm-&gt;runtime-&gt;period_size) {
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static void update_pcm_pointers(struct amdtp_stream *s,</span>
 static void pcm_period_tasklet(unsigned long data)
 {
 	struct amdtp_stream *s = (void *)data;
<span class="p_del">-	struct snd_pcm_substream *pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	struct snd_pcm_substream *pcm = READ_ONCE(s-&gt;pcm);</span>
 
 	if (pcm)
 		snd_pcm_period_elapsed(pcm);
<span class="p_chunk">@@ -453,7 +453,7 @@</span> <span class="p_context"> static int handle_out_packet(struct amdtp_stream *s,</span>
 		s-&gt;data_block_counter =
 				(s-&gt;data_block_counter + data_blocks) &amp; 0xff;
 
<span class="p_del">-	buffer[0] = cpu_to_be32(ACCESS_ONCE(s-&gt;source_node_id_field) |</span>
<span class="p_add">+	buffer[0] = cpu_to_be32(READ_ONCE(s-&gt;source_node_id_field) |</span>
 				(s-&gt;data_block_quadlets &lt;&lt; CIP_DBS_SHIFT) |
 				((s-&gt;sph &lt;&lt; CIP_SPH_SHIFT) &amp; CIP_SPH_MASK) |
 				s-&gt;data_block_counter);
<span class="p_chunk">@@ -472,7 +472,7 @@</span> <span class="p_context"> static int handle_out_packet(struct amdtp_stream *s,</span>
 	if (queue_out_packet(s, payload_length) &lt; 0)
 		return -EIO;
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (pcm &amp;&amp; pcm_frames &gt; 0)
 		update_pcm_pointers(s, pcm, pcm_frames);
 
<span class="p_chunk">@@ -504,7 +504,7 @@</span> <span class="p_context"> static int handle_out_packet_without_header(struct amdtp_stream *s,</span>
 	if (queue_out_packet(s, payload_length) &lt; 0)
 		return -EIO;
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (pcm &amp;&amp; pcm_frames &gt; 0)
 		update_pcm_pointers(s, pcm, pcm_frames);
 
<span class="p_chunk">@@ -621,7 +621,7 @@</span> <span class="p_context"> static int handle_in_packet(struct amdtp_stream *s,</span>
 	if (queue_in_packet(s) &lt; 0)
 		return -EIO;
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (pcm &amp;&amp; pcm_frames &gt; 0)
 		update_pcm_pointers(s, pcm, pcm_frames);
 
<span class="p_chunk">@@ -649,7 +649,7 @@</span> <span class="p_context"> static int handle_in_packet_without_header(struct amdtp_stream *s,</span>
 	if (queue_in_packet(s) &lt; 0)
 		return -EIO;
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (pcm &amp;&amp; pcm_frames &gt; 0)
 		update_pcm_pointers(s, pcm, pcm_frames);
 
<span class="p_chunk">@@ -947,7 +947,7 @@</span> <span class="p_context"> unsigned long amdtp_stream_pcm_pointer(struct amdtp_stream *s)</span>
 	if (!in_interrupt() &amp;&amp; amdtp_stream_running(s))
 		fw_iso_context_flush_completions(s-&gt;context);
 
<span class="p_del">-	return ACCESS_ONCE(s-&gt;pcm_buffer_pointer);</span>
<span class="p_add">+	return READ_ONCE(s-&gt;pcm_buffer_pointer);</span>
 }
 EXPORT_SYMBOL(amdtp_stream_pcm_pointer);
 
<span class="p_chunk">@@ -977,9 +977,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(amdtp_stream_pcm_ack);</span>
 void amdtp_stream_update(struct amdtp_stream *s)
 {
 	/* Precomputing. */
<span class="p_del">-	ACCESS_ONCE(s-&gt;source_node_id_field) =</span>
<span class="p_del">-		(fw_parent_device(s-&gt;unit)-&gt;card-&gt;node_id &lt;&lt; CIP_SID_SHIFT) &amp;</span>
<span class="p_del">-								CIP_SID_MASK;</span>
<span class="p_add">+	WRITE_ONCE(s-&gt;source_node_id_field,</span>
<span class="p_add">+                   (fw_parent_device(s-&gt;unit)-&gt;card-&gt;node_id &lt;&lt; CIP_SID_SHIFT) &amp; CIP_SID_MASK);</span>
 }
 EXPORT_SYMBOL(amdtp_stream_update);
 
<span class="p_chunk">@@ -1022,7 +1021,7 @@</span> <span class="p_context"> void amdtp_stream_pcm_abort(struct amdtp_stream *s)</span>
 {
 	struct snd_pcm_substream *pcm;
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (pcm)
 		snd_pcm_stop_xrun(pcm);
 }
<span class="p_header">diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h</span>
<span class="p_header">index ed6eafd10992..f9abd8b07ce6 100644</span>
<span class="p_header">--- a/sound/firewire/amdtp-stream.h</span>
<span class="p_header">+++ b/sound/firewire/amdtp-stream.h</span>
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> static inline bool amdtp_stream_pcm_running(struct amdtp_stream *s)</span>
 static inline void amdtp_stream_pcm_trigger(struct amdtp_stream *s,
 					    struct snd_pcm_substream *pcm)
 {
<span class="p_del">-	ACCESS_ONCE(s-&gt;pcm) = pcm;</span>
<span class="p_add">+	WRITE_ONCE(s-&gt;pcm, pcm);</span>
 }
 
 static inline bool cip_sfc_is_base_44100(enum cip_sfc sfc)
<span class="p_header">diff --git a/sound/firewire/digi00x/amdtp-dot.c b/sound/firewire/digi00x/amdtp-dot.c</span>
<span class="p_header">index 1453c34ce99f..4a884a335248 100644</span>
<span class="p_header">--- a/sound/firewire/digi00x/amdtp-dot.c</span>
<span class="p_header">+++ b/sound/firewire/digi00x/amdtp-dot.c</span>
<span class="p_chunk">@@ -327,7 +327,7 @@</span> <span class="p_context"> void amdtp_dot_midi_trigger(struct amdtp_stream *s, unsigned int port,</span>
 	struct amdtp_dot *p = s-&gt;protocol;
 
 	if (port &lt; MAX_MIDI_PORTS)
<span class="p_del">-		ACCESS_ONCE(p-&gt;midi[port]) = midi;</span>
<span class="p_add">+		WRITE_ONCE(p-&gt;midi[port], midi);</span>
 }
 
 static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
<span class="p_chunk">@@ -338,7 +338,7 @@</span> <span class="p_context"> static unsigned int process_tx_data_blocks(struct amdtp_stream *s,</span>
 	struct snd_pcm_substream *pcm;
 	unsigned int pcm_frames;
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (pcm) {
 		read_pcm_s32(s, pcm, buffer, data_blocks);
 		pcm_frames = data_blocks;
<span class="p_chunk">@@ -359,7 +359,7 @@</span> <span class="p_context"> static unsigned int process_rx_data_blocks(struct amdtp_stream *s,</span>
 	struct snd_pcm_substream *pcm;
 	unsigned int pcm_frames;
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (pcm) {
 		write_pcm_s32(s, pcm, buffer, data_blocks);
 		pcm_frames = data_blocks;
<span class="p_header">diff --git a/sound/firewire/fireface/amdtp-ff.c b/sound/firewire/fireface/amdtp-ff.c</span>
<span class="p_header">index 780da9deb2f0..77c7598b61ab 100644</span>
<span class="p_header">--- a/sound/firewire/fireface/amdtp-ff.c</span>
<span class="p_header">+++ b/sound/firewire/fireface/amdtp-ff.c</span>
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> static unsigned int process_rx_data_blocks(struct amdtp_stream *s,</span>
 					   unsigned int data_blocks,
 					   unsigned int *syt)
 {
<span class="p_del">-	struct snd_pcm_substream *pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	struct snd_pcm_substream *pcm = READ_ONCE(s-&gt;pcm);</span>
 	unsigned int pcm_frames;
 
 	if (pcm) {
<span class="p_chunk">@@ -127,7 +127,7 @@</span> <span class="p_context"> static unsigned int process_tx_data_blocks(struct amdtp_stream *s,</span>
 					   unsigned int data_blocks,
 					   unsigned int *syt)
 {
<span class="p_del">-	struct snd_pcm_substream *pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	struct snd_pcm_substream *pcm = READ_ONCE(s-&gt;pcm);</span>
 	unsigned int pcm_frames;
 
 	if (pcm) {
<span class="p_header">diff --git a/sound/firewire/fireface/ff-midi.c b/sound/firewire/fireface/ff-midi.c</span>
<span class="p_header">index 949ee56b4e0e..6a49611ee462 100644</span>
<span class="p_header">--- a/sound/firewire/fireface/ff-midi.c</span>
<span class="p_header">+++ b/sound/firewire/fireface/ff-midi.c</span>
<span class="p_chunk">@@ -22,7 +22,7 @@</span> <span class="p_context"> static int midi_playback_open(struct snd_rawmidi_substream *substream)</span>
 	ff-&gt;running_status[substream-&gt;number] = 0;
 	ff-&gt;rx_midi_error[substream-&gt;number] = false;
 
<span class="p_del">-	ACCESS_ONCE(ff-&gt;rx_midi_substreams[substream-&gt;number]) = substream;</span>
<span class="p_add">+	WRITE_ONCE(ff-&gt;rx_midi_substreams[substream-&gt;number], substream);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> static int midi_playback_close(struct snd_rawmidi_substream *substream)</span>
 	struct snd_ff *ff = substream-&gt;rmidi-&gt;private_data;
 
 	cancel_work_sync(&amp;ff-&gt;rx_midi_work[substream-&gt;number]);
<span class="p_del">-	ACCESS_ONCE(ff-&gt;rx_midi_substreams[substream-&gt;number]) = NULL;</span>
<span class="p_add">+	WRITE_ONCE(ff-&gt;rx_midi_substreams[substream-&gt;number], NULL);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -52,10 +52,10 @@</span> <span class="p_context"> static void midi_capture_trigger(struct snd_rawmidi_substream *substream,</span>
 	spin_lock_irqsave(&amp;ff-&gt;lock, flags);
 
 	if (up)
<span class="p_del">-		ACCESS_ONCE(ff-&gt;tx_midi_substreams[substream-&gt;number]) =</span>
<span class="p_del">-								substream;</span>
<span class="p_add">+		WRITE_ONCE(ff-&gt;tx_midi_substreams[substream-&gt;number],</span>
<span class="p_add">+			   substream);</span>
 	else
<span class="p_del">-		ACCESS_ONCE(ff-&gt;tx_midi_substreams[substream-&gt;number]) = NULL;</span>
<span class="p_add">+		WRITE_ONCE(ff-&gt;tx_midi_substreams[substream-&gt;number], NULL);</span>
 
 	spin_unlock_irqrestore(&amp;ff-&gt;lock, flags);
 }
<span class="p_header">diff --git a/sound/firewire/fireface/ff-transaction.c b/sound/firewire/fireface/ff-transaction.c</span>
<span class="p_header">index dd6c8e839647..332b29f8ed75 100644</span>
<span class="p_header">--- a/sound/firewire/fireface/ff-transaction.c</span>
<span class="p_header">+++ b/sound/firewire/fireface/ff-transaction.c</span>
<span class="p_chunk">@@ -12,7 +12,7 @@</span> <span class="p_context"> static void finish_transmit_midi_msg(struct snd_ff *ff, unsigned int port,</span>
 				     int rcode)
 {
 	struct snd_rawmidi_substream *substream =
<span class="p_del">-				ACCESS_ONCE(ff-&gt;rx_midi_substreams[port]);</span>
<span class="p_add">+				READ_ONCE(ff-&gt;rx_midi_substreams[port]);</span>
 
 	if (rcode_is_permanent_error(rcode)) {
 		ff-&gt;rx_midi_error[port] = true;
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> static inline void fill_midi_buf(struct snd_ff *ff, unsigned int port,</span>
 static void transmit_midi_msg(struct snd_ff *ff, unsigned int port)
 {
 	struct snd_rawmidi_substream *substream =
<span class="p_del">-			ACCESS_ONCE(ff-&gt;rx_midi_substreams[port]);</span>
<span class="p_add">+			READ_ONCE(ff-&gt;rx_midi_substreams[port]);</span>
 	u8 *buf = (u8 *)ff-&gt;msg_buf[port];
 	int i, len;
 
<span class="p_chunk">@@ -159,7 +159,7 @@</span> <span class="p_context"> static void handle_midi_msg(struct fw_card *card, struct fw_request *request,</span>
 		 */
 		index = (quad &gt;&gt; 8) &amp; 0xff;
 		if (index &gt; 0) {
<span class="p_del">-			substream = ACCESS_ONCE(ff-&gt;tx_midi_substreams[0]);</span>
<span class="p_add">+			substream = READ_ONCE(ff-&gt;tx_midi_substreams[0]);</span>
 			if (substream != NULL) {
 				byte = quad &amp; 0xff;
 				snd_rawmidi_receive(substream, &amp;byte, 1);
<span class="p_chunk">@@ -169,7 +169,7 @@</span> <span class="p_context"> static void handle_midi_msg(struct fw_card *card, struct fw_request *request,</span>
 		/* Message in second port. */
 		index = (quad &gt;&gt; 24) &amp; 0xff;
 		if (index &gt; 0) {
<span class="p_del">-			substream = ACCESS_ONCE(ff-&gt;tx_midi_substreams[1]);</span>
<span class="p_add">+			substream = READ_ONCE(ff-&gt;tx_midi_substreams[1]);</span>
 			if (substream != NULL) {
 				byte = (quad &gt;&gt; 16) &amp; 0xff;
 				snd_rawmidi_receive(substream, &amp;byte, 1);
<span class="p_header">diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c</span>
<span class="p_header">index 5826aa8362f1..46092fa3ff9b 100644</span>
<span class="p_header">--- a/sound/firewire/isight.c</span>
<span class="p_header">+++ b/sound/firewire/isight.c</span>
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> static void isight_update_pointers(struct isight *isight, unsigned int count)</span>
 	ptr += count;
 	if (ptr &gt;= runtime-&gt;buffer_size)
 		ptr -= runtime-&gt;buffer_size;
<span class="p_del">-	ACCESS_ONCE(isight-&gt;buffer_pointer) = ptr;</span>
<span class="p_add">+	WRITE_ONCE(isight-&gt;buffer_pointer, ptr);</span>
 
 	isight-&gt;period_counter += count;
 	if (isight-&gt;period_counter &gt;= runtime-&gt;period_size) {
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> static void isight_samples(struct isight *isight,</span>
 	struct snd_pcm_runtime *runtime;
 	unsigned int count1;
 
<span class="p_del">-	if (!ACCESS_ONCE(isight-&gt;pcm_running))</span>
<span class="p_add">+	if (!READ_ONCE(isight-&gt;pcm_running))</span>
 		return;
 
 	runtime = isight-&gt;pcm-&gt;runtime;
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> static void isight_samples(struct isight *isight,</span>
 
 static void isight_pcm_abort(struct isight *isight)
 {
<span class="p_del">-	if (ACCESS_ONCE(isight-&gt;pcm_active))</span>
<span class="p_add">+	if (READ_ONCE(isight-&gt;pcm_active))</span>
 		snd_pcm_stop_xrun(isight-&gt;pcm);
 }
 
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> static void isight_dropped_samples(struct isight *isight, unsigned int total)</span>
 	u32 dropped;
 	unsigned int count1;
 
<span class="p_del">-	if (!ACCESS_ONCE(isight-&gt;pcm_running))</span>
<span class="p_add">+	if (!READ_ONCE(isight-&gt;pcm_running))</span>
 		return;
 
 	runtime = isight-&gt;pcm-&gt;runtime;
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> static int isight_hw_params(struct snd_pcm_substream *substream,</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	ACCESS_ONCE(isight-&gt;pcm_active) = true;</span>
<span class="p_add">+	WRITE_ONCE(isight-&gt;pcm_active, true);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -331,7 +331,7 @@</span> <span class="p_context"> static int isight_hw_free(struct snd_pcm_substream *substream)</span>
 {
 	struct isight *isight = substream-&gt;private_data;
 
<span class="p_del">-	ACCESS_ONCE(isight-&gt;pcm_active) = false;</span>
<span class="p_add">+	WRITE_ONCE(isight-&gt;pcm_active, false);</span>
 
 	mutex_lock(&amp;isight-&gt;mutex);
 	isight_stop_streaming(isight);
<span class="p_chunk">@@ -424,10 +424,10 @@</span> <span class="p_context"> static int isight_trigger(struct snd_pcm_substream *substream, int cmd)</span>
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
<span class="p_del">-		ACCESS_ONCE(isight-&gt;pcm_running) = true;</span>
<span class="p_add">+		WRITE_ONCE(isight-&gt;pcm_running, true);</span>
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
<span class="p_del">-		ACCESS_ONCE(isight-&gt;pcm_running) = false;</span>
<span class="p_add">+		WRITE_ONCE(isight-&gt;pcm_running, false);</span>
 		break;
 	default:
 		return -EINVAL;
<span class="p_chunk">@@ -439,7 +439,7 @@</span> <span class="p_context"> static snd_pcm_uframes_t isight_pointer(struct snd_pcm_substream *substream)</span>
 {
 	struct isight *isight = substream-&gt;private_data;
 
<span class="p_del">-	return ACCESS_ONCE(isight-&gt;buffer_pointer);</span>
<span class="p_add">+	return READ_ONCE(isight-&gt;buffer_pointer);</span>
 }
 
 static int isight_create_pcm(struct isight *isight)
<span class="p_header">diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c</span>
<span class="p_header">index 96f0091144bb..f0555a24d90e 100644</span>
<span class="p_header">--- a/sound/firewire/motu/amdtp-motu.c</span>
<span class="p_header">+++ b/sound/firewire/motu/amdtp-motu.c</span>
<span class="p_chunk">@@ -310,7 +310,7 @@</span> <span class="p_context"> static unsigned int process_tx_data_blocks(struct amdtp_stream *s,</span>
 	if (p-&gt;midi_ports)
 		read_midi_messages(s, buffer, data_blocks);
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (data_blocks &gt; 0 &amp;&amp; pcm)
 		read_pcm_s32(s, pcm-&gt;runtime, buffer, data_blocks);
 
<span class="p_chunk">@@ -374,7 +374,7 @@</span> <span class="p_context"> static unsigned int process_rx_data_blocks(struct amdtp_stream *s,</span>
 	if (p-&gt;midi_ports)
 		write_midi_messages(s, buffer, data_blocks);
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (pcm)
 		write_pcm_s32(s, pcm-&gt;runtime, buffer, data_blocks);
 	else
<span class="p_header">diff --git a/sound/firewire/oxfw/oxfw-scs1x.c b/sound/firewire/oxfw/oxfw-scs1x.c</span>
<span class="p_header">index 02d595665898..f33497cdc706 100644</span>
<span class="p_header">--- a/sound/firewire/oxfw/oxfw-scs1x.c</span>
<span class="p_header">+++ b/sound/firewire/oxfw/oxfw-scs1x.c</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> static void handle_hss(struct fw_card *card, struct fw_request *request,</span>
 	}
 
 	if (length &gt;= 1) {
<span class="p_del">-		stream = ACCESS_ONCE(scs-&gt;input);</span>
<span class="p_add">+		stream = READ_ONCE(scs-&gt;input);</span>
 		if (stream)
 			midi_input_packet(scs, stream, data, length);
 	}
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static void scs_output_work(struct work_struct *work)</span>
 	if (scs-&gt;transaction_running)
 		return;
 
<span class="p_del">-	stream = ACCESS_ONCE(scs-&gt;output);</span>
<span class="p_add">+	stream = READ_ONCE(scs-&gt;output);</span>
 	if (!stream || scs-&gt;error) {
 		scs-&gt;output_idle = true;
 		wake_up(&amp;scs-&gt;idle_wait);
<span class="p_chunk">@@ -291,9 +291,9 @@</span> <span class="p_context"> static void midi_capture_trigger(struct snd_rawmidi_substream *stream, int up)</span>
 
 	if (up) {
 		scs-&gt;input_escape_count = 0;
<span class="p_del">-		ACCESS_ONCE(scs-&gt;input) = stream;</span>
<span class="p_add">+		WRITE_ONCE(scs-&gt;input, stream);</span>
 	} else {
<span class="p_del">-		ACCESS_ONCE(scs-&gt;input) = NULL;</span>
<span class="p_add">+		WRITE_ONCE(scs-&gt;input, NULL);</span>
 	}
 }
 
<span class="p_chunk">@@ -319,10 +319,10 @@</span> <span class="p_context"> static void midi_playback_trigger(struct snd_rawmidi_substream *stream, int up)</span>
 		scs-&gt;transaction_bytes = 0;
 		scs-&gt;error = false;
 
<span class="p_del">-		ACCESS_ONCE(scs-&gt;output) = stream;</span>
<span class="p_add">+		WRITE_ONCE(scs-&gt;output, stream);</span>
 		schedule_work(&amp;scs-&gt;work);
 	} else {
<span class="p_del">-		ACCESS_ONCE(scs-&gt;output) = NULL;</span>
<span class="p_add">+		WRITE_ONCE(scs-&gt;output, NULL);</span>
 	}
 }
 static void midi_playback_drain(struct snd_rawmidi_substream *stream)
<span class="p_header">diff --git a/sound/firewire/tascam/amdtp-tascam.c b/sound/firewire/tascam/amdtp-tascam.c</span>
<span class="p_header">index 6aff1fc1c72d..ab482423c165 100644</span>
<span class="p_header">--- a/sound/firewire/tascam/amdtp-tascam.c</span>
<span class="p_header">+++ b/sound/firewire/tascam/amdtp-tascam.c</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> static unsigned int process_tx_data_blocks(struct amdtp_stream *s,</span>
 {
 	struct snd_pcm_substream *pcm;
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (data_blocks &gt; 0 &amp;&amp; pcm)
 		read_pcm_s32(s, pcm, buffer, data_blocks);
 
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> static unsigned int process_rx_data_blocks(struct amdtp_stream *s,</span>
 	/* This field is not used. */
 	*syt = 0x0000;
 
<span class="p_del">-	pcm = ACCESS_ONCE(s-&gt;pcm);</span>
<span class="p_add">+	pcm = READ_ONCE(s-&gt;pcm);</span>
 	if (pcm)
 		write_pcm_s32(s, pcm, buffer, data_blocks);
 	else
<span class="p_header">diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c</span>
<span class="p_header">index 8967c52f5032..2ad692dd4b13 100644</span>
<span class="p_header">--- a/sound/firewire/tascam/tascam-transaction.c</span>
<span class="p_header">+++ b/sound/firewire/tascam/tascam-transaction.c</span>
<span class="p_chunk">@@ -148,7 +148,7 @@</span> <span class="p_context"> static void async_midi_port_callback(struct fw_card *card, int rcode,</span>
 				     void *callback_data)
 {
 	struct snd_fw_async_midi_port *port = callback_data;
<span class="p_del">-	struct snd_rawmidi_substream *substream = ACCESS_ONCE(port-&gt;substream);</span>
<span class="p_add">+	struct snd_rawmidi_substream *substream = READ_ONCE(port-&gt;substream);</span>
 
 	/* This port is closed. */
 	if (substream == NULL)
<span class="p_chunk">@@ -173,7 +173,7 @@</span> <span class="p_context"> static void midi_port_work(struct work_struct *work)</span>
 {
 	struct snd_fw_async_midi_port *port =
 			container_of(work, struct snd_fw_async_midi_port, work);
<span class="p_del">-	struct snd_rawmidi_substream *substream = ACCESS_ONCE(port-&gt;substream);</span>
<span class="p_add">+	struct snd_rawmidi_substream *substream = READ_ONCE(port-&gt;substream);</span>
 	int generation;
 
 	/* Under transacting or error state. */
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static void handle_midi_tx(struct fw_card *card, struct fw_request *request,</span>
 				bytes = 3;
 		}
 
<span class="p_del">-		substream = ACCESS_ONCE(tscm-&gt;tx_midi_substreams[port]);</span>
<span class="p_add">+		substream = READ_ONCE(tscm-&gt;tx_midi_substreams[port]);</span>
 		if (substream != NULL)
 			snd_rawmidi_receive(substream, b + 1, bytes);
 	}
<span class="p_header">diff --git a/sound/soc/xtensa/xtfpga-i2s.c b/sound/soc/xtensa/xtfpga-i2s.c</span>
<span class="p_header">index 8382ffa3bcaf..2472144b329e 100644</span>
<span class="p_header">--- a/sound/soc/xtensa/xtfpga-i2s.c</span>
<span class="p_header">+++ b/sound/soc/xtensa/xtfpga-i2s.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static bool xtfpga_pcm_push_tx(struct xtfpga_i2s *i2s)</span>
 	tx_substream = rcu_dereference(i2s-&gt;tx_substream);
 	tx_active = tx_substream &amp;&amp; snd_pcm_running(tx_substream);
 	if (tx_active) {
<span class="p_del">-		unsigned tx_ptr = ACCESS_ONCE(i2s-&gt;tx_ptr);</span>
<span class="p_add">+		unsigned tx_ptr = READ_ONCE(i2s-&gt;tx_ptr);</span>
 		unsigned new_tx_ptr = i2s-&gt;tx_fn(i2s, tx_substream-&gt;runtime,
 						 tx_ptr);
 
<span class="p_chunk">@@ -437,7 +437,7 @@</span> <span class="p_context"> static int xtfpga_pcm_trigger(struct snd_pcm_substream *substream, int cmd)</span>
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
<span class="p_del">-		ACCESS_ONCE(i2s-&gt;tx_ptr) = 0;</span>
<span class="p_add">+		WRITE_ONCE(i2s-&gt;tx_ptr, 0);</span>
 		rcu_assign_pointer(i2s-&gt;tx_substream, substream);
 		xtfpga_pcm_refill_fifo(i2s);
 		break;
<span class="p_chunk">@@ -459,7 +459,7 @@</span> <span class="p_context"> static snd_pcm_uframes_t xtfpga_pcm_pointer(struct snd_pcm_substream *substream)</span>
 {
 	struct snd_pcm_runtime *runtime = substream-&gt;runtime;
 	struct xtfpga_i2s *i2s = runtime-&gt;private_data;
<span class="p_del">-	snd_pcm_uframes_t pos = ACCESS_ONCE(i2s-&gt;tx_ptr);</span>
<span class="p_add">+	snd_pcm_uframes_t pos = READ_ONCE(i2s-&gt;tx_ptr);</span>
 
 	return pos &lt; runtime-&gt;buffer_size ? pos : 0;
 }
<span class="p_header">diff --git a/sound/usb/bcd2000/bcd2000.c b/sound/usb/bcd2000/bcd2000.c</span>
<span class="p_header">index 7371e5b06035..fc579f330601 100644</span>
<span class="p_header">--- a/sound/usb/bcd2000/bcd2000.c</span>
<span class="p_header">+++ b/sound/usb/bcd2000/bcd2000.c</span>
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> static void bcd2000_midi_handle_input(struct bcd2000 *bcd2k,</span>
 	unsigned int payload_length, tocopy;
 	struct snd_rawmidi_substream *midi_receive_substream;
 
<span class="p_del">-	midi_receive_substream = ACCESS_ONCE(bcd2k-&gt;midi_receive_substream);</span>
<span class="p_add">+	midi_receive_substream = READ_ONCE(bcd2k-&gt;midi_receive_substream);</span>
 	if (!midi_receive_substream)
 		return;
 
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"> static void bcd2000_midi_send(struct bcd2000 *bcd2k)</span>
 
 	BUILD_BUG_ON(sizeof(device_cmd_prefix) &gt;= BUFSIZE);
 
<span class="p_del">-	midi_out_substream = ACCESS_ONCE(bcd2k-&gt;midi_out_substream);</span>
<span class="p_add">+	midi_out_substream = READ_ONCE(bcd2k-&gt;midi_out_substream);</span>
 	if (!midi_out_substream)
 		return;
 
<span class="p_header">diff --git a/tools/arch/x86/include/asm/atomic.h b/tools/arch/x86/include/asm/atomic.h</span>
<span class="p_header">index 328eeceec709..96e2d06cb031 100644</span>
<span class="p_header">--- a/tools/arch/x86/include/asm/atomic.h</span>
<span class="p_header">+++ b/tools/arch/x86/include/asm/atomic.h</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"></span>
  */
 static inline int atomic_read(const atomic_t *v)
 {
<span class="p_del">-	return ACCESS_ONCE((v)-&gt;counter);</span>
<span class="p_add">+	return READ_ONCE((v)-&gt;counter);</span>
 }
 
 /**
<span class="p_header">diff --git a/tools/include/asm-generic/atomic-gcc.h b/tools/include/asm-generic/atomic-gcc.h</span>
<span class="p_header">index 5e9738f97bf3..97427e700e3b 100644</span>
<span class="p_header">--- a/tools/include/asm-generic/atomic-gcc.h</span>
<span class="p_header">+++ b/tools/include/asm-generic/atomic-gcc.h</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"></span>
  */
 static inline int atomic_read(const atomic_t *v)
 {
<span class="p_del">-	return ACCESS_ONCE((v)-&gt;counter);</span>
<span class="p_add">+	return READ_ONCE((v)-&gt;counter);</span>
 }
 
 /**
<span class="p_header">diff --git a/tools/perf/util/auxtrace.h b/tools/perf/util/auxtrace.h</span>
<span class="p_header">index 33b5e6cdf38c..d19e11b68de7 100644</span>
<span class="p_header">--- a/tools/perf/util/auxtrace.h</span>
<span class="p_header">+++ b/tools/perf/util/auxtrace.h</span>
<span class="p_chunk">@@ -378,7 +378,7 @@</span> <span class="p_context"> struct addr_filters {</span>
 static inline u64 auxtrace_mmap__read_snapshot_head(struct auxtrace_mmap *mm)
 {
 	struct perf_event_mmap_page *pc = mm-&gt;userpg;
<span class="p_del">-	u64 head = ACCESS_ONCE(pc-&gt;aux_head);</span>
<span class="p_add">+	u64 head = READ_ONCE(pc-&gt;aux_head);</span>
 
 	/* Ensure all reads are done after we read the head */
 	rmb();
<span class="p_chunk">@@ -389,7 +389,7 @@</span> <span class="p_context"> static inline u64 auxtrace_mmap__read_head(struct auxtrace_mmap *mm)</span>
 {
 	struct perf_event_mmap_page *pc = mm-&gt;userpg;
 #if BITS_PER_LONG == 64 || !defined(HAVE_SYNC_COMPARE_AND_SWAP_SUPPORT)
<span class="p_del">-	u64 head = ACCESS_ONCE(pc-&gt;aux_head);</span>
<span class="p_add">+	u64 head = READ_ONCE(pc-&gt;aux_head);</span>
 #else
 	u64 head = __sync_val_compare_and_swap(&amp;pc-&gt;aux_head, 0, 0);
 #endif
<span class="p_header">diff --git a/tools/perf/util/evlist.h b/tools/perf/util/evlist.h</span>
<span class="p_header">index bf2c4936e35f..b6767855d916 100644</span>
<span class="p_header">--- a/tools/perf/util/evlist.h</span>
<span class="p_header">+++ b/tools/perf/util/evlist.h</span>
<span class="p_chunk">@@ -288,7 +288,7 @@</span> <span class="p_context"> int perf_evlist__strerror_mmap(struct perf_evlist *evlist, int err, char *buf, s</span>
 static inline u64 perf_mmap__read_head(struct perf_mmap *mm)
 {
 	struct perf_event_mmap_page *pc = mm-&gt;base;
<span class="p_del">-	u64 head = ACCESS_ONCE(pc-&gt;data_head);</span>
<span class="p_add">+	u64 head = READ_ONCE(pc-&gt;data_head);</span>
 	rmb();
 	return head;
 }
<span class="p_header">diff --git a/tools/perf/util/session.h b/tools/perf/util/session.h</span>
<span class="p_header">index 47b5e7dbcb18..aae9645c7122 100644</span>
<span class="p_header">--- a/tools/perf/util/session.h</span>
<span class="p_header">+++ b/tools/perf/util/session.h</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> int __perf_session__set_tracepoints_handlers(struct perf_session *session,</span>
 
 extern volatile int session_done;
 
<span class="p_del">-#define session_done()	ACCESS_ONCE(session_done)</span>
<span class="p_add">+#define session_done()	READ_ONCE(session_done)</span>
 
 int perf_session__deliver_synth_event(struct perf_session *session,
 				      union perf_event *event,
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 9deb5a245b83..ce507ae1d4f5 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -2302,7 +2302,7 @@</span> <span class="p_context"> void kvm_vcpu_on_spin(struct kvm_vcpu *me, bool yield_to_kernel_mode)</span>
 				continue;
 			} else if (pass &amp;&amp; i &gt; last_boosted_vcpu)
 				break;
<span class="p_del">-			if (!ACCESS_ONCE(vcpu-&gt;preempted))</span>
<span class="p_add">+			if (!READ_ONCE(vcpu-&gt;preempted))</span>
 				continue;
 			if (vcpu == me)
 				continue;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



