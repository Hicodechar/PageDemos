
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[5/5] scripts/gdb: Add meminfo command - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [5/5] scripts/gdb: Add meminfo command</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=150871">Kieran Bingham</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 20, 2016, 11:15 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1453288550-4706-6-git-send-email-kieran.bingham@linaro.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8071221/mbox/"
   >mbox</a>
|
   <a href="/patch/8071221/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8071221/">/patch/8071221/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 18611BEEE5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 20 Jan 2016 11:17:07 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 080C320437
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 20 Jan 2016 11:17:06 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 7AA3520456
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 20 Jan 2016 11:17:04 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S935339AbcATLRB (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 20 Jan 2016 06:17:01 -0500
Received: from mail-wm0-f50.google.com ([74.125.82.50]:32967 &quot;EHLO
	mail-wm0-f50.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S935298AbcATLQa (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 20 Jan 2016 06:16:30 -0500
Received: by mail-wm0-f50.google.com with SMTP id 123so128217609wmz.0
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Wed, 20 Jan 2016 03:16:29 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=linaro.org; s=google;
	h=from:to:cc:subject:date:message-id:in-reply-to:references;
	bh=EHZ9G2jw6FfzKy44RtXh0ViWDRp0vS60odOj8C2dv0c=;
	b=GtQadnmimeBM0kEgS9KOJ7ntmEuWWOV1xv4+j8jjJjDdbJMRLBVlCNVu+UzYZ6wzcN
	nZ4egXJSe2GWnQj68Ve/CYCbwo+ndA8mL6Z6SoVhQgJ0L1kv3HQtISMmbEuxCSESimJP
	VQXQPwc2cpCX+9q3ErXq5i/Sgbp9/XsGq7QuY=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references;
	bh=EHZ9G2jw6FfzKy44RtXh0ViWDRp0vS60odOj8C2dv0c=;
	b=THgHfsP0tqgCV44/SOwjjojLx95a9WWXgeGBIy3NK7z4CXx/G7O+/ktX1bVQFVHeoY
	FbVuuxI3giFDDsL7SCaCOLKk6djR4UVsXFzRPnDUmoVHINP8Z6RWduNLz6g0S4AOfCwO
	/DyJRQOAXsFfxKKdmP9LevrFfKUPWN/n9wYkk4MHdY9GheR4znJmAEBCjyUUqdkNrFTz
	0w2kbj0vEcaomE6TiK93GcyE6ovP1Ixzl3/EJaVMsG/6TUAMQvHHH7HKKtMEuVYZjWfm
	ldAT3fJoaU7PyNp5WvsMTiwPFMVYm4Fuet1hqduE4AMv/0OeGK6/f/0s+EIWfmf+xc5R
	ODtw==
X-Gm-Message-State: AG10YORP319CSLwDHQjO8QIcwsp61/SD/EnFVzd3hpOuMNnJKv5Zd3gLtpkRlituku1Tz6OY
X-Received: by 10.28.214.76 with SMTP id n73mr3634296wmg.52.1453288588953;
	Wed, 20 Jan 2016 03:16:28 -0800 (PST)
Received: from localhost.localdomain
	(cpc87017-aztw30-2-0-cust65.18-1.cable.virginm.net.
	[92.232.232.66]) by smtp.gmail.com with ESMTPSA id
	bg1sm28398065wjc.27.2016.01.20.03.16.28
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-SHA bits=128/128);
	Wed, 20 Jan 2016 03:16:28 -0800 (PST)
From: Kieran Bingham &lt;kieran.bingham@linaro.org&gt;
To: jan.kiszka@siemens.com
Cc: Kieran Bingham &lt;kieran.bingham@linaro.org&gt;,
	linux-kernel@vger.kernel.org, maxime.coquelin@st.com,
	peter.griffin@linaro.org, lee.jones@linaro.org
Subject: [PATCH 5/5] scripts/gdb: Add meminfo command
Date: Wed, 20 Jan 2016 11:15:50 +0000
Message-Id: &lt;1453288550-4706-6-git-send-email-kieran.bingham@linaro.org&gt;
X-Mailer: git-send-email 2.5.0
In-Reply-To: &lt;1453288550-4706-1-git-send-email-kieran.bingham@linaro.org&gt;
References: &lt;1453288550-4706-1-git-send-email-kieran.bingham@linaro.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.0 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, RCVD_IN_DNSWL_HI, RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=ham version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=150871">Kieran Bingham</a> - Jan. 20, 2016, 11:15 a.m.</div>
<pre class="content">
Provide an equivalent of /proc/meminfo which should be available from
core dumps, or crashed kernels. This should allow a debugger to identify
if memory pressures were applicable in the instance of their issue
<span class="signed-off-by">
Signed-off-by: Kieran Bingham &lt;kieran.bingham@linaro.org&gt;</span>
---

This command has proved to be much more difficult that I first thought it
would be!

It also poses a couple of interesting issues, which is why I submit this
patch in a much more unfinished form.

The meminfo implementation at fs/proc/meminfo.c makes several function calls
to collate information, which makes duplicating here more difficult.

I suspect the best option here is to not present lines of which we can not
obtain accurate data for, (much better than presenting inaccurate information)

Would this go in agreement with you?

Finally, do you have any ideas on the best way to manage code which
is #ifdef&#39;d on kernel config options? (#ifdef CONFIG_HIGHMEM for example).

In a similar vein to the constants.py, I considered that we could iterate all
of the kernel configuration options and store them in a dictionary some how.

That may be awkward, however, and I wondered what ideas anyone had!


 scripts/gdb/linux/constants.py.in |  22 +++++
 scripts/gdb/linux/proc.py         | 173 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 195 insertions(+)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=659">Jan Kiszka</a> - Jan. 23, 2016, 3:21 p.m.</div>
<pre class="content">
On 2016-01-20 12:15, Kieran Bingham wrote:
<span class="quote">&gt; Provide an equivalent of /proc/meminfo which should be available from</span>
<span class="quote">&gt; core dumps, or crashed kernels. This should allow a debugger to identify</span>
<span class="quote">&gt; if memory pressures were applicable in the instance of their issue</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Kieran Bingham &lt;kieran.bingham@linaro.org&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This command has proved to be much more difficult that I first thought it</span>
<span class="quote">&gt; would be!</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It also poses a couple of interesting issues, which is why I submit this</span>
<span class="quote">&gt; patch in a much more unfinished form.</span>

Yeah, seems so - see below ;)
<span class="quote">
&gt; </span>
<span class="quote">&gt; The meminfo implementation at fs/proc/meminfo.c makes several function calls</span>
<span class="quote">&gt; to collate information, which makes duplicating here more difficult.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I suspect the best option here is to not present lines of which we can not</span>
<span class="quote">&gt; obtain accurate data for, (much better than presenting inaccurate information)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Would this go in agreement with you?</span>

I didn&#39;t grab the use cases yet, so just a general suggestion: if the
inaccurate information may still have some value, you can mark it as
inaccurate and still print it.
<span class="quote">
&gt; </span>
<span class="quote">&gt; Finally, do you have any ideas on the best way to manage code which</span>
<span class="quote">&gt; is #ifdef&#39;d on kernel config options? (#ifdef CONFIG_HIGHMEM for example).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In a similar vein to the constants.py, I considered that we could iterate all</span>
<span class="quote">&gt; of the kernel configuration options and store them in a dictionary some how.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That may be awkward, however, and I wondered what ideas anyone had!</span>

Why not convert the (relevant) configs inside constants.py into a
python variable? CONFIG_IS_ENABLED should make this easy.
<span class="quote">
&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  scripts/gdb/linux/constants.py.in |  22 +++++</span>
<span class="quote">&gt;  scripts/gdb/linux/proc.py         | 173 ++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  2 files changed, 195 insertions(+)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/scripts/gdb/linux/constants.py.in b/scripts/gdb/linux/constants.py.in</span>
<span class="quote">&gt; index 739a15d2e984..306bd601ae4e 100644</span>
<span class="quote">&gt; --- a/scripts/gdb/linux/constants.py.in</span>
<span class="quote">&gt; +++ b/scripts/gdb/linux/constants.py.in</span>
<span class="quote">&gt; @@ -12,8 +12,15 @@</span>
<span class="quote">&gt;   *</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#include &lt;asm/page.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/thread_info.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  #include &lt;linux/fs.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/swap.h&gt;</span>
<span class="quote">&gt;  #include &lt;linux/mount.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/vmalloc.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* We need to stringify expanded macros so that they can be parsed */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -41,3 +48,18 @@ LX_MNT_NOATIME = MNT_NOATIME</span>
<span class="quote">&gt;  LX_MNT_NODIRATIME = MNT_NODIRATIME</span>
<span class="quote">&gt;  LX_MNT_RELATIME = MNT_RELATIME</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/* asm/page.h */</span>
<span class="quote">&gt; +LX_PAGE_SHIFT = XSTRING(PAGE_SHIFT)</span>
<span class="quote">&gt; +lx_page_shift = gdb.parse_and_eval(LX_PAGE_SHIFT)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* asm/thread_info.h */</span>
<span class="quote">&gt; +LX_THREAD_SIZE = XSTRING(THREAD_SIZE)</span>
<span class="quote">&gt; +lx_thread_size = gdb.parse_and_eval(LX_THREAD_SIZE)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* linux/vmalloc.h */</span>
<span class="quote">&gt; +LX_VMALLOC_TOTAL = XSTRING(VMALLOC_TOTAL)</span>
<span class="quote">&gt; +lx_vmalloc_total = gdb.parse_and_eval(LX_VMALLOC_TOTAL)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* linux/swap.h */</span>
<span class="quote">&gt; +LX_MAX_SWAPFILES = XSTRING(MAX_SWAPFILES)</span>
<span class="quote">&gt; +lx_max_swapfiles = gdb.parse_and_eval(LX_MAX_SWAPFILES)</span>
<span class="quote">&gt; diff --git a/scripts/gdb/linux/proc.py b/scripts/gdb/linux/proc.py</span>
<span class="quote">&gt; index b79ce2a33a3d..ac9e1aac2403 100644</span>
<span class="quote">&gt; --- a/scripts/gdb/linux/proc.py</span>
<span class="quote">&gt; +++ b/scripts/gdb/linux/proc.py</span>
<span class="quote">&gt; @@ -206,3 +206,176 @@ values of that process namespace&quot;&quot;&quot;</span>
<span class="quote">&gt;                          info_opts(MNT_INFO, m_flags)))</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  LxMounts()</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +bdev_type = utils.CachedType(&quot;struct block_device&quot;)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +class LxMeminfo(gdb.Command):</span>
<span class="quote">&gt; +    &quot;&quot;&quot; Identify the memory usage, statistics, and availability</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +Equivalent to cat /proc/meminfo on a running target &quot;&quot;&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +    def __init__(self):</span>
<span class="quote">&gt; +        super(LxMeminfo, self).__init__(&quot;lx-meminfo&quot;, gdb.COMMAND_DATA)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +    def K(self, val):</span>
<span class="quote">&gt; +        # Convert from PAGES to KB</span>
<span class="quote">&gt; +        return int(val &lt;&lt; (constants.lx_page_shift - 10))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +    def page_K(self, remote_value):</span>
<span class="quote">&gt; +        # Obtain page value, and Convert from PAGES to KB</span>
<span class="quote">&gt; +        val = int(gdb.parse_and_eval(remote_value))</span>
<span class="quote">&gt; +        return self.K(val)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +    def gps(self, enum_zone_stat_item):</span>
<span class="quote">&gt; +        # Access the Global Page State structure</span>
<span class="quote">&gt; +        # I would prefer to read this structure in one go and then index</span>
<span class="quote">&gt; +        # from the enum. But we can&#39;t determine the enum values with out</span>
<span class="quote">&gt; +        # a call to GDB anyway so we may as well take the easy route and</span>
<span class="quote">&gt; +        # get the value.</span>
<span class="quote">&gt; +        remote_value = &quot;vm_stat[&quot; + enum_zone_stat_item + &quot;].counter&quot;</span>
<span class="quote">&gt; +        return int(gdb.parse_and_eval(remote_value))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +    def gps_K(self, enum_zone_stat_item):</span>
<span class="quote">&gt; +        return self.K(self.gps(enum_zone_stat_item))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +    def nr_blockdev_pages(self):</span>
<span class="quote">&gt; +        bdevs_head = gdb.parse_and_eval(&quot;all_bdevs&quot;)</span>
<span class="quote">&gt; +        pages = 0</span>
<span class="quote">&gt; +        for bdev in lists.items(bdev_type, &quot;bd_list&quot;, bdevs_head):</span>
<span class="quote">&gt; +            pages += bdev[&#39;bd_inode&#39;][&#39;i_mapping&#39;][&#39;nrpages&#39;]</span>
<span class="quote">&gt; +        return pages</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +    def total_swapcache_pages(self):</span>
<span class="quote">&gt; +        pages = 0</span>
<span class="quote">&gt; +        for i in range(0, constants.lx_max_swapfiles):</span>
<span class="quote">&gt; +            swap_space = &quot;swapper_spaces[&quot; + str(i) + &quot;].nrpages&quot;</span>
<span class="quote">&gt; +            pages += int(gdb.parse_and_eval(swap_space))</span>
<span class="quote">&gt; +        return pages</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +    def vm_commit_limit(self, totalram_pages):</span>
<span class="quote">&gt; +        overcommit = int(gdb.parse_and_eval(&quot;sysctl_overcommit_kbytes&quot;))</span>
<span class="quote">&gt; +        overcommit_ratio = int(gdb.parse_and_eval(&quot;sysctl_overcommit_ratio&quot;))</span>
<span class="quote">&gt; +        total_swap_pages = int(gdb.parse_and_eval(&quot;total_swap_pages&quot;))</span>
<span class="quote">&gt; +        hugetlb_total_pages = 0  # hugetlb_total_pages()!!</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        if overcommit:</span>
<span class="quote">&gt; +            allowed = overcommit &gt;&gt; (constants.lx_page_shift - 10)</span>
<span class="quote">&gt; +        else:</span>
<span class="quote">&gt; +            allowed = ((totalram_pages - hugetlb_total_pages *</span>
<span class="quote">&gt; +                       overcommit_ratio / 100))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        allowed += total_swap_pages</span>
<span class="quote">&gt; +        return allowed</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +    # Main lx-meminfo command execution</span>
<span class="quote">&gt; +    def invoke(self, arg, from_tty):</span>
<span class="quote">&gt; +        totalram = int(gdb.parse_and_eval(&quot;totalram_pages&quot;))</span>
<span class="quote">&gt; +        freeram = self.gps(&quot;NR_FREE_PAGES&quot;)</span>
<span class="quote">&gt; +        reclaimable = self.gps(&quot;NR_SLAB_RECLAIMABLE&quot;)</span>
<span class="quote">&gt; +        unreclaimable = self.gps(&quot;NR_SLAB_UNRECLAIMABLE&quot;)</span>
<span class="quote">&gt; +        slab = reclaimable + unreclaimable</span>
<span class="quote">&gt; +        # for_each_zone(zone)</span>
<span class="quote">&gt; +        #     wmark_low += zone-&gt;watermark[WMARK_LOW];</span>
<span class="quote">&gt; +        wmark_low = 0   # Zone parsing is unimplemented</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        available = freeram - wmark_low</span>
<span class="quote">&gt; +        available += reclaimable - min(reclaimable / 2, wmark_low)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        bufferram = self.nr_blockdev_pages()</span>

Something goes wrong here:

(gdb) lx-meminfo 
Traceback (most recent call last):
  File &quot;/data/linux/build-dbg/scripts/gdb/linux/proc.py&quot;, line 286, in invoke
    bufferram = self.nr_blockdev_pages()
  File &quot;/data/linux/build-dbg/scripts/gdb/linux/proc.py&quot;, line 246, in nr_blockdev_pages
    for bdev in lists.items(bdev_type, &quot;bd_list&quot;, bdevs_head):
  File &quot;/data/linux/build-dbg/scripts/gdb/linux/lists.py&quot;, line 26, in items
    yield utils.container_of(next_item, list_type, list_location)
  File &quot;/data/linux/build-dbg/scripts/gdb/linux/utils.py&quot;, line 52, in container_of
    offset_of(typeobj, member)).cast(typeobj)
  File &quot;/data/linux/build-dbg/scripts/gdb/linux/utils.py&quot;, line 46, in offset_of
    element = gdb.Value(0).cast(typeobj)
RuntimeError: Argument must be a type.
Error occurred in Python command: Argument must be a type.

If you need my kernel config to reproduce, just let me know.
<span class="quote">
&gt; +        total_swapcache_pages = self.total_swapcache_pages()</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        file_pages = self.gps(&quot;NR_FILE_PAGES&quot;)</span>
<span class="quote">&gt; +        cached = file_pages - total_swapcache_pages - bufferram</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        # LRU Pages</span>
<span class="quote">&gt; +        active_pages_anon = self.gps(&quot;NR_ACTIVE_ANON&quot;)</span>
<span class="quote">&gt; +        inactive_pages_anon = self.gps(&quot;NR_INACTIVE_ANON&quot;)</span>
<span class="quote">&gt; +        active_pages_file = self.gps(&quot;NR_ACTIVE_FILE&quot;)</span>
<span class="quote">&gt; +        inactive_pages_file = self.gps(&quot;NR_INACTIVE_FILE&quot;)</span>
<span class="quote">&gt; +        unevictable_pages = self.gps(&quot;NR_UNEVICTABLE&quot;)</span>
<span class="quote">&gt; +        active_pages = active_pages_anon + active_pages_file</span>
<span class="quote">&gt; +        inactive_pages = inactive_pages_anon + inactive_pages_file</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        totalhigh = int(gdb.parse_and_eval(&quot;totalhigh_pages&quot;))</span>
<span class="quote">&gt; +        # We can&#39;t run this on a core dump file ...</span>
<span class="quote">&gt; +        # if running target ()</span>
<span class="quote">&gt; +        freehigh = int(gdb.parse_and_eval(&quot;nr_free_highpages()&quot;))</span>
<span class="quote">&gt; +        # else freehigh = 0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        kernelstack = int(self.gps(&quot;NR_KERNEL_STACK&quot;) *</span>
<span class="quote">&gt; +                          constants.lx_thread_size / 1024)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        commitlimit = self.vm_commit_limit(totalram)</span>
<span class="quote">&gt; +        committed_as = int(gdb.parse_and_eval(&quot;vm_committed_as.count&quot;))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        vmalloc_total = int(constants.lx_vmalloc_total &gt;&gt; 10)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        gdb.write(</span>
<span class="quote">&gt; +            &quot;MemTotal:       {:8d} kB\n&quot;.format(self.K(totalram)) +</span>
<span class="quote">&gt; +            &quot;MemFree:        {:8d} kB\n&quot;.format(self.K(freeram)) +</span>
<span class="quote">&gt; +            &quot;MemAvailable:   {:8d} kB\n&quot;.format(self.K(available)) +</span>
<span class="quote">&gt; +            &quot;Buffers:        {:8d} kB\n&quot;.format(self.K(bufferram)) +</span>
<span class="quote">&gt; +            &quot;Cached:         {:8d} kB\n&quot;.format(self.K(cached)) +</span>
<span class="quote">&gt; +            &quot;SwapCached:     {:8d} kB\n&quot;.format(self.K(total_swapcache_pages)) +</span>
<span class="quote">&gt; +            &quot;Active:         {:8d} kB\n&quot;.format(self.K(active_pages)) +</span>
<span class="quote">&gt; +            &quot;Inactive:       {:8d} kB\n&quot;.format(self.K(inactive_pages)) +</span>
<span class="quote">&gt; +            &quot;Active(anon):   {:8d} kB\n&quot;.format(self.K(active_pages_anon)) +</span>
<span class="quote">&gt; +            &quot;Inactive(anon): {:8d} kB\n&quot;.format(self.K(inactive_pages_anon)) +</span>
<span class="quote">&gt; +            &quot;Active(file):   {:8d} kB\n&quot;.format(self.K(active_pages_file)) +</span>
<span class="quote">&gt; +            &quot;Inactive(file): {:8d} kB\n&quot;.format(self.K(inactive_pages_file)) +</span>
<span class="quote">&gt; +            &quot;Unevictable:    {:8d} kB\n&quot;.format(self.K(unevictable_pages)) +</span>
<span class="quote">&gt; +            &quot;Mlocked:        {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_MLOCK&quot;))</span>
<span class="quote">&gt; +            )</span>
<span class="quote">&gt; +        # ifdef CONFIG_HIGHMEM || core dump?</span>
<span class="quote">&gt; +        gdb.write(</span>
<span class="quote">&gt; +            &quot;HighTotal:      {:8d} kB\n&quot;.format(self.K(totalhigh)) +</span>
<span class="quote">&gt; +            &quot;HighFree:       {:8d} kB\n&quot;.format(self.K(freehigh)) +</span>
<span class="quote">&gt; +            &quot;LowTotal:       {:8d} kB\n&quot;.format(self.K(totalram-totalhigh)) +</span>
<span class="quote">&gt; +            &quot;LowFree:        {:8d} kB\n&quot;.format(self.K(freeram-freehigh))</span>
<span class="quote">&gt; +            )</span>
<span class="quote">&gt; +        # endif</span>
<span class="quote">&gt; +        # ifndef CONFIG_MMU</span>
<span class="quote">&gt; +        # gdb.write(</span>
<span class="quote">&gt; +        #    mmap_pages_allocated</span>
<span class="quote">&gt; +        #    )</span>
<span class="quote">&gt; +        # endif</span>
<span class="quote">&gt; +        gdb.write(</span>
<span class="quote">&gt; +            &quot;SwapTotal:      {:8d} kB\n&quot;.format(self.K(0)) +</span>
<span class="quote">&gt; +            &quot;SwapFree:       {:8d} kB\n&quot;.format(self.K(0)) +</span>
<span class="quote">&gt; +            &quot;Dirty:          {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_FILE_DIRTY&quot;)) +</span>
<span class="quote">&gt; +            &quot;Writeback:      {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_WRITEBACK&quot;)) +</span>
<span class="quote">&gt; +            &quot;AnonPages:      {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_ANON_PAGES&quot;)) +</span>
<span class="quote">&gt; +            &quot;Mapped:         {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_FILE_MAPPED&quot;)) +</span>
<span class="quote">&gt; +            &quot;Shmem:          {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_SHMEM&quot;)) +</span>
<span class="quote">&gt; +            &quot;Slab:           {:8d} kB\n&quot;.format(self.K(slab)) +</span>
<span class="quote">&gt; +            &quot;SReclaimable:   {:8d} kB\n&quot;.format(self.K(reclaimable)) +</span>
<span class="quote">&gt; +            &quot;SUnreclaim:     {:8d} kB\n&quot;.format(self.K(unreclaimable)) +</span>
<span class="quote">&gt; +            &quot;KernelStack:    {:8d} kB\n&quot;.format(kernelstack) +</span>
<span class="quote">&gt; +            &quot;PageTables:     {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_PAGETABLE&quot;))</span>
<span class="quote">&gt; +            )</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        #  if CONFIG_QUICKLIST</span>
<span class="quote">&gt; +        #   &quot;Quicklists:     {:8d} kB\n&quot;.format(self.K(quicklist)))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        gdb.write(</span>
<span class="quote">&gt; +            &quot;NFS_Unstable:   {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_UNSTABLE_NFS&quot;)) +</span>
<span class="quote">&gt; +            &quot;Bounce:         {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_BOUNCE&quot;)) +</span>
<span class="quote">&gt; +            &quot;WritebackTmp:   {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_WRITEBACK_TEMP&quot;)) +</span>
<span class="quote">&gt; +            &quot;CommitLimit:    {:8d} kB\n&quot;.format(self.K(commitlimit)) +</span>
<span class="quote">&gt; +            &quot;Committed_AS:   {:8d} kB\n&quot;.format(self.K(committed_as)) +</span>
<span class="quote">&gt; +            &quot;VmallocTotal:   {:8d} kB\n&quot;.format(vmalloc_total) +</span>
<span class="quote">&gt; +            &quot;VmallocUsed:    {:8d} kB\n&quot;.format(0) +</span>
<span class="quote">&gt; +            &quot;VmallocChunk:   {:8d} kB\n&quot;.format(0)</span>
<span class="quote">&gt; +            )</span>
<span class="quote">&gt; +        # if CONFIG_MEMORY_FAILURE</span>
<span class="quote">&gt; +        #   &quot;HardwareCorrupted: %5lu kB\n&quot;</span>
<span class="quote">&gt; +        # ifdef CONFIG_CMA</span>
<span class="quote">&gt; +        totalcma_pages = int(gdb.parse_and_eval(&quot;totalcma_pages&quot;))</span>
<span class="quote">&gt; +        gdb.write(</span>
<span class="quote">&gt; +            &quot;CmaTotal:       {:8d} kB\n&quot;.format(self.K(totalcma_pages)) +</span>
<span class="quote">&gt; +            &quot;CmaFree:        {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_FREE_CMA_PAGES&quot;))</span>
<span class="quote">&gt; +            )</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +LxMeminfo()</span>
<span class="quote">&gt; </span>

Jan
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=150871">Kieran Bingham</a> - Jan. 24, 2016, 12:30 a.m.</div>
<pre class="content">
On 23/01/16 15:21, Jan Kiszka wrote:
<span class="quote">&gt; On 2016-01-20 12:15, Kieran Bingham wrote:</span>
<span class="quote">&gt;&gt; Provide an equivalent of /proc/meminfo which should be available from</span>
<span class="quote">&gt;&gt; core dumps, or crashed kernels. This should allow a debugger to identify</span>
<span class="quote">&gt;&gt; if memory pressures were applicable in the instance of their issue</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Kieran Bingham &lt;kieran.bingham@linaro.org&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This command has proved to be much more difficult that I first thought it</span>
<span class="quote">&gt;&gt; would be!</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; It also poses a couple of interesting issues, which is why I submit this</span>
<span class="quote">&gt;&gt; patch in a much more unfinished form.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yeah, seems so - see below ;)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The meminfo implementation at fs/proc/meminfo.c makes several function calls</span>
<span class="quote">&gt;&gt; to collate information, which makes duplicating here more difficult.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I suspect the best option here is to not present lines of which we can not</span>
<span class="quote">&gt;&gt; obtain accurate data for, (much better than presenting inaccurate information)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Would this go in agreement with you?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I didn&#39;t grab the use cases yet, so just a general suggestion: if the</span>
<span class="quote">&gt; inaccurate information may still have some value, you can mark it as</span>
<span class="quote">&gt; inaccurate and still print it.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Finally, do you have any ideas on the best way to manage code which</span>
<span class="quote">&gt;&gt; is #ifdef&#39;d on kernel config options? (#ifdef CONFIG_HIGHMEM for example).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; In a similar vein to the constants.py, I considered that we could iterate all</span>
<span class="quote">&gt;&gt; of the kernel configuration options and store them in a dictionary some how.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; That may be awkward, however, and I wondered what ideas anyone had!</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why not convert the (relevant) configs inside constants.py into a</span>
<span class="quote">&gt; python variable? CONFIG_IS_ENABLED should make this easy.</span>


Aha, Excellent. I think I must not have seen the wood-for-the-trees on
this one!

Had a play, and I can&#39;t use IS_ENABLED(x) directly, as it generates (0
|| 1) from IS_BUILTIN and IS_MODULE - and which is not compatible with
python. However, in our use-case - we actually only want to switch on
BUILTIN&#39;s anyway, so I will use that.

If other use cases come up later, we can always extend to create our own
Python version of IS_ENABLED
<span class="quote">
&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  scripts/gdb/linux/constants.py.in |  22 +++++</span>
<span class="quote">&gt;&gt;  scripts/gdb/linux/proc.py         | 173 ++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  2 files changed, 195 insertions(+)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/scripts/gdb/linux/constants.py.in b/scripts/gdb/linux/constants.py.in</span>
<span class="quote">&gt;&gt; index 739a15d2e984..306bd601ae4e 100644</span>
<span class="quote">&gt;&gt; --- a/scripts/gdb/linux/constants.py.in</span>
<span class="quote">&gt;&gt; +++ b/scripts/gdb/linux/constants.py.in</span>
<span class="quote">&gt;&gt; @@ -12,8 +12,15 @@</span>
<span class="quote">&gt;&gt;   *</span>
<span class="quote">&gt;&gt;   */</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +#include &lt;asm/page.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/thread_info.h&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  #include &lt;linux/fs.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/swap.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;linux/mount.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/vmalloc.h&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  /* We need to stringify expanded macros so that they can be parsed */</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; @@ -41,3 +48,18 @@ LX_MNT_NOATIME = MNT_NOATIME</span>
<span class="quote">&gt;&gt;  LX_MNT_NODIRATIME = MNT_NODIRATIME</span>
<span class="quote">&gt;&gt;  LX_MNT_RELATIME = MNT_RELATIME</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +/* asm/page.h */</span>
<span class="quote">&gt;&gt; +LX_PAGE_SHIFT = XSTRING(PAGE_SHIFT)</span>
<span class="quote">&gt;&gt; +lx_page_shift = gdb.parse_and_eval(LX_PAGE_SHIFT)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +/* asm/thread_info.h */</span>
<span class="quote">&gt;&gt; +LX_THREAD_SIZE = XSTRING(THREAD_SIZE)</span>
<span class="quote">&gt;&gt; +lx_thread_size = gdb.parse_and_eval(LX_THREAD_SIZE)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +/* linux/vmalloc.h */</span>
<span class="quote">&gt;&gt; +LX_VMALLOC_TOTAL = XSTRING(VMALLOC_TOTAL)</span>
<span class="quote">&gt;&gt; +lx_vmalloc_total = gdb.parse_and_eval(LX_VMALLOC_TOTAL)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +/* linux/swap.h */</span>
<span class="quote">&gt;&gt; +LX_MAX_SWAPFILES = XSTRING(MAX_SWAPFILES)</span>
<span class="quote">&gt;&gt; +lx_max_swapfiles = gdb.parse_and_eval(LX_MAX_SWAPFILES)</span>
<span class="quote">&gt;&gt; diff --git a/scripts/gdb/linux/proc.py b/scripts/gdb/linux/proc.py</span>
<span class="quote">&gt;&gt; index b79ce2a33a3d..ac9e1aac2403 100644</span>
<span class="quote">&gt;&gt; --- a/scripts/gdb/linux/proc.py</span>
<span class="quote">&gt;&gt; +++ b/scripts/gdb/linux/proc.py</span>
<span class="quote">&gt;&gt; @@ -206,3 +206,176 @@ values of that process namespace&quot;&quot;&quot;</span>
<span class="quote">&gt;&gt;                          info_opts(MNT_INFO, m_flags)))</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  LxMounts()</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +bdev_type = utils.CachedType(&quot;struct block_device&quot;)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +class LxMeminfo(gdb.Command):</span>
<span class="quote">&gt;&gt; +    &quot;&quot;&quot; Identify the memory usage, statistics, and availability</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +Equivalent to cat /proc/meminfo on a running target &quot;&quot;&quot;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +    def __init__(self):</span>
<span class="quote">&gt;&gt; +        super(LxMeminfo, self).__init__(&quot;lx-meminfo&quot;, gdb.COMMAND_DATA)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +    def K(self, val):</span>
<span class="quote">&gt;&gt; +        # Convert from PAGES to KB</span>
<span class="quote">&gt;&gt; +        return int(val &lt;&lt; (constants.lx_page_shift - 10))</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +    def page_K(self, remote_value):</span>
<span class="quote">&gt;&gt; +        # Obtain page value, and Convert from PAGES to KB</span>
<span class="quote">&gt;&gt; +        val = int(gdb.parse_and_eval(remote_value))</span>
<span class="quote">&gt;&gt; +        return self.K(val)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +    def gps(self, enum_zone_stat_item):</span>
<span class="quote">&gt;&gt; +        # Access the Global Page State structure</span>
<span class="quote">&gt;&gt; +        # I would prefer to read this structure in one go and then index</span>
<span class="quote">&gt;&gt; +        # from the enum. But we can&#39;t determine the enum values with out</span>
<span class="quote">&gt;&gt; +        # a call to GDB anyway so we may as well take the easy route and</span>
<span class="quote">&gt;&gt; +        # get the value.</span>
<span class="quote">&gt;&gt; +        remote_value = &quot;vm_stat[&quot; + enum_zone_stat_item + &quot;].counter&quot;</span>
<span class="quote">&gt;&gt; +        return int(gdb.parse_and_eval(remote_value))</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +    def gps_K(self, enum_zone_stat_item):</span>
<span class="quote">&gt;&gt; +        return self.K(self.gps(enum_zone_stat_item))</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +    def nr_blockdev_pages(self):</span>
<span class="quote">&gt;&gt; +        bdevs_head = gdb.parse_and_eval(&quot;all_bdevs&quot;)</span>
<span class="quote">&gt;&gt; +        pages = 0</span>
<span class="quote">&gt;&gt; +        for bdev in lists.items(bdev_type, &quot;bd_list&quot;, bdevs_head):</span>
<span class="quote">&gt;&gt; +            pages += bdev[&#39;bd_inode&#39;][&#39;i_mapping&#39;][&#39;nrpages&#39;]</span>
<span class="quote">&gt;&gt; +        return pages</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +    def total_swapcache_pages(self):</span>
<span class="quote">&gt;&gt; +        pages = 0</span>
<span class="quote">&gt;&gt; +        for i in range(0, constants.lx_max_swapfiles):</span>
<span class="quote">&gt;&gt; +            swap_space = &quot;swapper_spaces[&quot; + str(i) + &quot;].nrpages&quot;</span>
<span class="quote">&gt;&gt; +            pages += int(gdb.parse_and_eval(swap_space))</span>
<span class="quote">&gt;&gt; +        return pages</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +    def vm_commit_limit(self, totalram_pages):</span>
<span class="quote">&gt;&gt; +        overcommit = int(gdb.parse_and_eval(&quot;sysctl_overcommit_kbytes&quot;))</span>
<span class="quote">&gt;&gt; +        overcommit_ratio = int(gdb.parse_and_eval(&quot;sysctl_overcommit_ratio&quot;))</span>
<span class="quote">&gt;&gt; +        total_swap_pages = int(gdb.parse_and_eval(&quot;total_swap_pages&quot;))</span>
<span class="quote">&gt;&gt; +        hugetlb_total_pages = 0  # hugetlb_total_pages()!!</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        if overcommit:</span>
<span class="quote">&gt;&gt; +            allowed = overcommit &gt;&gt; (constants.lx_page_shift - 10)</span>
<span class="quote">&gt;&gt; +        else:</span>
<span class="quote">&gt;&gt; +            allowed = ((totalram_pages - hugetlb_total_pages *</span>
<span class="quote">&gt;&gt; +                       overcommit_ratio / 100))</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        allowed += total_swap_pages</span>
<span class="quote">&gt;&gt; +        return allowed</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +    # Main lx-meminfo command execution</span>
<span class="quote">&gt;&gt; +    def invoke(self, arg, from_tty):</span>
<span class="quote">&gt;&gt; +        totalram = int(gdb.parse_and_eval(&quot;totalram_pages&quot;))</span>
<span class="quote">&gt;&gt; +        freeram = self.gps(&quot;NR_FREE_PAGES&quot;)</span>
<span class="quote">&gt;&gt; +        reclaimable = self.gps(&quot;NR_SLAB_RECLAIMABLE&quot;)</span>
<span class="quote">&gt;&gt; +        unreclaimable = self.gps(&quot;NR_SLAB_UNRECLAIMABLE&quot;)</span>
<span class="quote">&gt;&gt; +        slab = reclaimable + unreclaimable</span>
<span class="quote">&gt;&gt; +        # for_each_zone(zone)</span>
<span class="quote">&gt;&gt; +        #     wmark_low += zone-&gt;watermark[WMARK_LOW];</span>
<span class="quote">&gt;&gt; +        wmark_low = 0   # Zone parsing is unimplemented</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        available = freeram - wmark_low</span>
<span class="quote">&gt;&gt; +        available += reclaimable - min(reclaimable / 2, wmark_low)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        bufferram = self.nr_blockdev_pages()</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Something goes wrong here:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; (gdb) lx-meminfo </span>
<span class="quote">&gt; Traceback (most recent call last):</span>
<span class="quote">&gt;   File &quot;/data/linux/build-dbg/scripts/gdb/linux/proc.py&quot;, line 286, in invoke</span>
<span class="quote">&gt;     bufferram = self.nr_blockdev_pages()</span>
<span class="quote">&gt;   File &quot;/data/linux/build-dbg/scripts/gdb/linux/proc.py&quot;, line 246, in nr_blockdev_pages</span>
<span class="quote">&gt;     for bdev in lists.items(bdev_type, &quot;bd_list&quot;, bdevs_head):</span>
<span class="quote">&gt;   File &quot;/data/linux/build-dbg/scripts/gdb/linux/lists.py&quot;, line 26, in items</span>
<span class="quote">&gt;     yield utils.container_of(next_item, list_type, list_location)</span>
<span class="quote">&gt;   File &quot;/data/linux/build-dbg/scripts/gdb/linux/utils.py&quot;, line 52, in container_of</span>
<span class="quote">&gt;     offset_of(typeobj, member)).cast(typeobj)</span>
<span class="quote">&gt;   File &quot;/data/linux/build-dbg/scripts/gdb/linux/utils.py&quot;, line 46, in offset_of</span>
<span class="quote">&gt;     element = gdb.Value(0).cast(typeobj)</span>
<span class="quote">&gt; RuntimeError: Argument must be a type.</span>
<span class="quote">&gt; Error occurred in Python command: Argument must be a type.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you need my kernel config to reproduce, just let me know.</span>


Yes please, send me a config, and I&#39;ll try to reproduce.


What is your test environment by the way?
I am running in QEmu for convenience mostly at the moment.

I hope to set up some automated scripts to test on different arch&#39;s too.

--
Kieran
<span class="quote">

&gt; </span>
<span class="quote">&gt;&gt; +        total_swapcache_pages = self.total_swapcache_pages()</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        file_pages = self.gps(&quot;NR_FILE_PAGES&quot;)</span>
<span class="quote">&gt;&gt; +        cached = file_pages - total_swapcache_pages - bufferram</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        # LRU Pages</span>
<span class="quote">&gt;&gt; +        active_pages_anon = self.gps(&quot;NR_ACTIVE_ANON&quot;)</span>
<span class="quote">&gt;&gt; +        inactive_pages_anon = self.gps(&quot;NR_INACTIVE_ANON&quot;)</span>
<span class="quote">&gt;&gt; +        active_pages_file = self.gps(&quot;NR_ACTIVE_FILE&quot;)</span>
<span class="quote">&gt;&gt; +        inactive_pages_file = self.gps(&quot;NR_INACTIVE_FILE&quot;)</span>
<span class="quote">&gt;&gt; +        unevictable_pages = self.gps(&quot;NR_UNEVICTABLE&quot;)</span>
<span class="quote">&gt;&gt; +        active_pages = active_pages_anon + active_pages_file</span>
<span class="quote">&gt;&gt; +        inactive_pages = inactive_pages_anon + inactive_pages_file</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        totalhigh = int(gdb.parse_and_eval(&quot;totalhigh_pages&quot;))</span>
<span class="quote">&gt;&gt; +        # We can&#39;t run this on a core dump file ...</span>
<span class="quote">&gt;&gt; +        # if running target ()</span>
<span class="quote">&gt;&gt; +        freehigh = int(gdb.parse_and_eval(&quot;nr_free_highpages()&quot;))</span>
<span class="quote">&gt;&gt; +        # else freehigh = 0</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        kernelstack = int(self.gps(&quot;NR_KERNEL_STACK&quot;) *</span>
<span class="quote">&gt;&gt; +                          constants.lx_thread_size / 1024)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        commitlimit = self.vm_commit_limit(totalram)</span>
<span class="quote">&gt;&gt; +        committed_as = int(gdb.parse_and_eval(&quot;vm_committed_as.count&quot;))</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        vmalloc_total = int(constants.lx_vmalloc_total &gt;&gt; 10)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        gdb.write(</span>
<span class="quote">&gt;&gt; +            &quot;MemTotal:       {:8d} kB\n&quot;.format(self.K(totalram)) +</span>
<span class="quote">&gt;&gt; +            &quot;MemFree:        {:8d} kB\n&quot;.format(self.K(freeram)) +</span>
<span class="quote">&gt;&gt; +            &quot;MemAvailable:   {:8d} kB\n&quot;.format(self.K(available)) +</span>
<span class="quote">&gt;&gt; +            &quot;Buffers:        {:8d} kB\n&quot;.format(self.K(bufferram)) +</span>
<span class="quote">&gt;&gt; +            &quot;Cached:         {:8d} kB\n&quot;.format(self.K(cached)) +</span>
<span class="quote">&gt;&gt; +            &quot;SwapCached:     {:8d} kB\n&quot;.format(self.K(total_swapcache_pages)) +</span>
<span class="quote">&gt;&gt; +            &quot;Active:         {:8d} kB\n&quot;.format(self.K(active_pages)) +</span>
<span class="quote">&gt;&gt; +            &quot;Inactive:       {:8d} kB\n&quot;.format(self.K(inactive_pages)) +</span>
<span class="quote">&gt;&gt; +            &quot;Active(anon):   {:8d} kB\n&quot;.format(self.K(active_pages_anon)) +</span>
<span class="quote">&gt;&gt; +            &quot;Inactive(anon): {:8d} kB\n&quot;.format(self.K(inactive_pages_anon)) +</span>
<span class="quote">&gt;&gt; +            &quot;Active(file):   {:8d} kB\n&quot;.format(self.K(active_pages_file)) +</span>
<span class="quote">&gt;&gt; +            &quot;Inactive(file): {:8d} kB\n&quot;.format(self.K(inactive_pages_file)) +</span>
<span class="quote">&gt;&gt; +            &quot;Unevictable:    {:8d} kB\n&quot;.format(self.K(unevictable_pages)) +</span>
<span class="quote">&gt;&gt; +            &quot;Mlocked:        {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_MLOCK&quot;))</span>
<span class="quote">&gt;&gt; +            )</span>
<span class="quote">&gt;&gt; +        # ifdef CONFIG_HIGHMEM || core dump?</span>
<span class="quote">&gt;&gt; +        gdb.write(</span>
<span class="quote">&gt;&gt; +            &quot;HighTotal:      {:8d} kB\n&quot;.format(self.K(totalhigh)) +</span>
<span class="quote">&gt;&gt; +            &quot;HighFree:       {:8d} kB\n&quot;.format(self.K(freehigh)) +</span>
<span class="quote">&gt;&gt; +            &quot;LowTotal:       {:8d} kB\n&quot;.format(self.K(totalram-totalhigh)) +</span>
<span class="quote">&gt;&gt; +            &quot;LowFree:        {:8d} kB\n&quot;.format(self.K(freeram-freehigh))</span>
<span class="quote">&gt;&gt; +            )</span>
<span class="quote">&gt;&gt; +        # endif</span>
<span class="quote">&gt;&gt; +        # ifndef CONFIG_MMU</span>
<span class="quote">&gt;&gt; +        # gdb.write(</span>
<span class="quote">&gt;&gt; +        #    mmap_pages_allocated</span>
<span class="quote">&gt;&gt; +        #    )</span>
<span class="quote">&gt;&gt; +        # endif</span>
<span class="quote">&gt;&gt; +        gdb.write(</span>
<span class="quote">&gt;&gt; +            &quot;SwapTotal:      {:8d} kB\n&quot;.format(self.K(0)) +</span>
<span class="quote">&gt;&gt; +            &quot;SwapFree:       {:8d} kB\n&quot;.format(self.K(0)) +</span>
<span class="quote">&gt;&gt; +            &quot;Dirty:          {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_FILE_DIRTY&quot;)) +</span>
<span class="quote">&gt;&gt; +            &quot;Writeback:      {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_WRITEBACK&quot;)) +</span>
<span class="quote">&gt;&gt; +            &quot;AnonPages:      {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_ANON_PAGES&quot;)) +</span>
<span class="quote">&gt;&gt; +            &quot;Mapped:         {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_FILE_MAPPED&quot;)) +</span>
<span class="quote">&gt;&gt; +            &quot;Shmem:          {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_SHMEM&quot;)) +</span>
<span class="quote">&gt;&gt; +            &quot;Slab:           {:8d} kB\n&quot;.format(self.K(slab)) +</span>
<span class="quote">&gt;&gt; +            &quot;SReclaimable:   {:8d} kB\n&quot;.format(self.K(reclaimable)) +</span>
<span class="quote">&gt;&gt; +            &quot;SUnreclaim:     {:8d} kB\n&quot;.format(self.K(unreclaimable)) +</span>
<span class="quote">&gt;&gt; +            &quot;KernelStack:    {:8d} kB\n&quot;.format(kernelstack) +</span>
<span class="quote">&gt;&gt; +            &quot;PageTables:     {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_PAGETABLE&quot;))</span>
<span class="quote">&gt;&gt; +            )</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        #  if CONFIG_QUICKLIST</span>
<span class="quote">&gt;&gt; +        #   &quot;Quicklists:     {:8d} kB\n&quot;.format(self.K(quicklist)))</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +        gdb.write(</span>
<span class="quote">&gt;&gt; +            &quot;NFS_Unstable:   {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_UNSTABLE_NFS&quot;)) +</span>
<span class="quote">&gt;&gt; +            &quot;Bounce:         {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_BOUNCE&quot;)) +</span>
<span class="quote">&gt;&gt; +            &quot;WritebackTmp:   {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_WRITEBACK_TEMP&quot;)) +</span>
<span class="quote">&gt;&gt; +            &quot;CommitLimit:    {:8d} kB\n&quot;.format(self.K(commitlimit)) +</span>
<span class="quote">&gt;&gt; +            &quot;Committed_AS:   {:8d} kB\n&quot;.format(self.K(committed_as)) +</span>
<span class="quote">&gt;&gt; +            &quot;VmallocTotal:   {:8d} kB\n&quot;.format(vmalloc_total) +</span>
<span class="quote">&gt;&gt; +            &quot;VmallocUsed:    {:8d} kB\n&quot;.format(0) +</span>
<span class="quote">&gt;&gt; +            &quot;VmallocChunk:   {:8d} kB\n&quot;.format(0)</span>
<span class="quote">&gt;&gt; +            )</span>
<span class="quote">&gt;&gt; +        # if CONFIG_MEMORY_FAILURE</span>
<span class="quote">&gt;&gt; +        #   &quot;HardwareCorrupted: %5lu kB\n&quot;</span>
<span class="quote">&gt;&gt; +        # ifdef CONFIG_CMA</span>
<span class="quote">&gt;&gt; +        totalcma_pages = int(gdb.parse_and_eval(&quot;totalcma_pages&quot;))</span>
<span class="quote">&gt;&gt; +        gdb.write(</span>
<span class="quote">&gt;&gt; +            &quot;CmaTotal:       {:8d} kB\n&quot;.format(self.K(totalcma_pages)) +</span>
<span class="quote">&gt;&gt; +            &quot;CmaFree:        {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_FREE_CMA_PAGES&quot;))</span>
<span class="quote">&gt;&gt; +            )</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +LxMeminfo()</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Jan</span>
<span class="quote">&gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/scripts/gdb/linux/constants.py.in b/scripts/gdb/linux/constants.py.in</span>
<span class="p_header">index 739a15d2e984..306bd601ae4e 100644</span>
<span class="p_header">--- a/scripts/gdb/linux/constants.py.in</span>
<span class="p_header">+++ b/scripts/gdb/linux/constants.py.in</span>
<span class="p_chunk">@@ -12,8 +12,15 @@</span> <span class="p_context"></span>
  *
  */
 
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+</span>
 #include &lt;linux/fs.h&gt;
<span class="p_add">+#include &lt;linux/swap.h&gt;</span>
 #include &lt;linux/mount.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+</span>
 
 /* We need to stringify expanded macros so that they can be parsed */
 
<span class="p_chunk">@@ -41,3 +48,18 @@</span> <span class="p_context"> LX_MNT_NOATIME = MNT_NOATIME</span>
 LX_MNT_NODIRATIME = MNT_NODIRATIME
 LX_MNT_RELATIME = MNT_RELATIME
 
<span class="p_add">+/* asm/page.h */</span>
<span class="p_add">+LX_PAGE_SHIFT = XSTRING(PAGE_SHIFT)</span>
<span class="p_add">+lx_page_shift = gdb.parse_and_eval(LX_PAGE_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+/* asm/thread_info.h */</span>
<span class="p_add">+LX_THREAD_SIZE = XSTRING(THREAD_SIZE)</span>
<span class="p_add">+lx_thread_size = gdb.parse_and_eval(LX_THREAD_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+/* linux/vmalloc.h */</span>
<span class="p_add">+LX_VMALLOC_TOTAL = XSTRING(VMALLOC_TOTAL)</span>
<span class="p_add">+lx_vmalloc_total = gdb.parse_and_eval(LX_VMALLOC_TOTAL)</span>
<span class="p_add">+</span>
<span class="p_add">+/* linux/swap.h */</span>
<span class="p_add">+LX_MAX_SWAPFILES = XSTRING(MAX_SWAPFILES)</span>
<span class="p_add">+lx_max_swapfiles = gdb.parse_and_eval(LX_MAX_SWAPFILES)</span>
<span class="p_header">diff --git a/scripts/gdb/linux/proc.py b/scripts/gdb/linux/proc.py</span>
<span class="p_header">index b79ce2a33a3d..ac9e1aac2403 100644</span>
<span class="p_header">--- a/scripts/gdb/linux/proc.py</span>
<span class="p_header">+++ b/scripts/gdb/linux/proc.py</span>
<span class="p_chunk">@@ -206,3 +206,176 @@</span> <span class="p_context"> values of that process namespace&quot;&quot;&quot;</span>
                         info_opts(MNT_INFO, m_flags)))
 
 LxMounts()
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+bdev_type = utils.CachedType(&quot;struct block_device&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+class LxMeminfo(gdb.Command):</span>
<span class="p_add">+    &quot;&quot;&quot; Identify the memory usage, statistics, and availability</span>
<span class="p_add">+</span>
<span class="p_add">+Equivalent to cat /proc/meminfo on a running target &quot;&quot;&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+    def __init__(self):</span>
<span class="p_add">+        super(LxMeminfo, self).__init__(&quot;lx-meminfo&quot;, gdb.COMMAND_DATA)</span>
<span class="p_add">+</span>
<span class="p_add">+    def K(self, val):</span>
<span class="p_add">+        # Convert from PAGES to KB</span>
<span class="p_add">+        return int(val &lt;&lt; (constants.lx_page_shift - 10))</span>
<span class="p_add">+</span>
<span class="p_add">+    def page_K(self, remote_value):</span>
<span class="p_add">+        # Obtain page value, and Convert from PAGES to KB</span>
<span class="p_add">+        val = int(gdb.parse_and_eval(remote_value))</span>
<span class="p_add">+        return self.K(val)</span>
<span class="p_add">+</span>
<span class="p_add">+    def gps(self, enum_zone_stat_item):</span>
<span class="p_add">+        # Access the Global Page State structure</span>
<span class="p_add">+        # I would prefer to read this structure in one go and then index</span>
<span class="p_add">+        # from the enum. But we can&#39;t determine the enum values with out</span>
<span class="p_add">+        # a call to GDB anyway so we may as well take the easy route and</span>
<span class="p_add">+        # get the value.</span>
<span class="p_add">+        remote_value = &quot;vm_stat[&quot; + enum_zone_stat_item + &quot;].counter&quot;</span>
<span class="p_add">+        return int(gdb.parse_and_eval(remote_value))</span>
<span class="p_add">+</span>
<span class="p_add">+    def gps_K(self, enum_zone_stat_item):</span>
<span class="p_add">+        return self.K(self.gps(enum_zone_stat_item))</span>
<span class="p_add">+</span>
<span class="p_add">+    def nr_blockdev_pages(self):</span>
<span class="p_add">+        bdevs_head = gdb.parse_and_eval(&quot;all_bdevs&quot;)</span>
<span class="p_add">+        pages = 0</span>
<span class="p_add">+        for bdev in lists.items(bdev_type, &quot;bd_list&quot;, bdevs_head):</span>
<span class="p_add">+            pages += bdev[&#39;bd_inode&#39;][&#39;i_mapping&#39;][&#39;nrpages&#39;]</span>
<span class="p_add">+        return pages</span>
<span class="p_add">+</span>
<span class="p_add">+    def total_swapcache_pages(self):</span>
<span class="p_add">+        pages = 0</span>
<span class="p_add">+        for i in range(0, constants.lx_max_swapfiles):</span>
<span class="p_add">+            swap_space = &quot;swapper_spaces[&quot; + str(i) + &quot;].nrpages&quot;</span>
<span class="p_add">+            pages += int(gdb.parse_and_eval(swap_space))</span>
<span class="p_add">+        return pages</span>
<span class="p_add">+</span>
<span class="p_add">+    def vm_commit_limit(self, totalram_pages):</span>
<span class="p_add">+        overcommit = int(gdb.parse_and_eval(&quot;sysctl_overcommit_kbytes&quot;))</span>
<span class="p_add">+        overcommit_ratio = int(gdb.parse_and_eval(&quot;sysctl_overcommit_ratio&quot;))</span>
<span class="p_add">+        total_swap_pages = int(gdb.parse_and_eval(&quot;total_swap_pages&quot;))</span>
<span class="p_add">+        hugetlb_total_pages = 0  # hugetlb_total_pages()!!</span>
<span class="p_add">+</span>
<span class="p_add">+        if overcommit:</span>
<span class="p_add">+            allowed = overcommit &gt;&gt; (constants.lx_page_shift - 10)</span>
<span class="p_add">+        else:</span>
<span class="p_add">+            allowed = ((totalram_pages - hugetlb_total_pages *</span>
<span class="p_add">+                       overcommit_ratio / 100))</span>
<span class="p_add">+</span>
<span class="p_add">+        allowed += total_swap_pages</span>
<span class="p_add">+        return allowed</span>
<span class="p_add">+</span>
<span class="p_add">+    # Main lx-meminfo command execution</span>
<span class="p_add">+    def invoke(self, arg, from_tty):</span>
<span class="p_add">+        totalram = int(gdb.parse_and_eval(&quot;totalram_pages&quot;))</span>
<span class="p_add">+        freeram = self.gps(&quot;NR_FREE_PAGES&quot;)</span>
<span class="p_add">+        reclaimable = self.gps(&quot;NR_SLAB_RECLAIMABLE&quot;)</span>
<span class="p_add">+        unreclaimable = self.gps(&quot;NR_SLAB_UNRECLAIMABLE&quot;)</span>
<span class="p_add">+        slab = reclaimable + unreclaimable</span>
<span class="p_add">+        # for_each_zone(zone)</span>
<span class="p_add">+        #     wmark_low += zone-&gt;watermark[WMARK_LOW];</span>
<span class="p_add">+        wmark_low = 0   # Zone parsing is unimplemented</span>
<span class="p_add">+</span>
<span class="p_add">+        available = freeram - wmark_low</span>
<span class="p_add">+        available += reclaimable - min(reclaimable / 2, wmark_low)</span>
<span class="p_add">+</span>
<span class="p_add">+        bufferram = self.nr_blockdev_pages()</span>
<span class="p_add">+        total_swapcache_pages = self.total_swapcache_pages()</span>
<span class="p_add">+</span>
<span class="p_add">+        file_pages = self.gps(&quot;NR_FILE_PAGES&quot;)</span>
<span class="p_add">+        cached = file_pages - total_swapcache_pages - bufferram</span>
<span class="p_add">+</span>
<span class="p_add">+        # LRU Pages</span>
<span class="p_add">+        active_pages_anon = self.gps(&quot;NR_ACTIVE_ANON&quot;)</span>
<span class="p_add">+        inactive_pages_anon = self.gps(&quot;NR_INACTIVE_ANON&quot;)</span>
<span class="p_add">+        active_pages_file = self.gps(&quot;NR_ACTIVE_FILE&quot;)</span>
<span class="p_add">+        inactive_pages_file = self.gps(&quot;NR_INACTIVE_FILE&quot;)</span>
<span class="p_add">+        unevictable_pages = self.gps(&quot;NR_UNEVICTABLE&quot;)</span>
<span class="p_add">+        active_pages = active_pages_anon + active_pages_file</span>
<span class="p_add">+        inactive_pages = inactive_pages_anon + inactive_pages_file</span>
<span class="p_add">+</span>
<span class="p_add">+        totalhigh = int(gdb.parse_and_eval(&quot;totalhigh_pages&quot;))</span>
<span class="p_add">+        # We can&#39;t run this on a core dump file ...</span>
<span class="p_add">+        # if running target ()</span>
<span class="p_add">+        freehigh = int(gdb.parse_and_eval(&quot;nr_free_highpages()&quot;))</span>
<span class="p_add">+        # else freehigh = 0</span>
<span class="p_add">+</span>
<span class="p_add">+        kernelstack = int(self.gps(&quot;NR_KERNEL_STACK&quot;) *</span>
<span class="p_add">+                          constants.lx_thread_size / 1024)</span>
<span class="p_add">+</span>
<span class="p_add">+        commitlimit = self.vm_commit_limit(totalram)</span>
<span class="p_add">+        committed_as = int(gdb.parse_and_eval(&quot;vm_committed_as.count&quot;))</span>
<span class="p_add">+</span>
<span class="p_add">+        vmalloc_total = int(constants.lx_vmalloc_total &gt;&gt; 10)</span>
<span class="p_add">+</span>
<span class="p_add">+        gdb.write(</span>
<span class="p_add">+            &quot;MemTotal:       {:8d} kB\n&quot;.format(self.K(totalram)) +</span>
<span class="p_add">+            &quot;MemFree:        {:8d} kB\n&quot;.format(self.K(freeram)) +</span>
<span class="p_add">+            &quot;MemAvailable:   {:8d} kB\n&quot;.format(self.K(available)) +</span>
<span class="p_add">+            &quot;Buffers:        {:8d} kB\n&quot;.format(self.K(bufferram)) +</span>
<span class="p_add">+            &quot;Cached:         {:8d} kB\n&quot;.format(self.K(cached)) +</span>
<span class="p_add">+            &quot;SwapCached:     {:8d} kB\n&quot;.format(self.K(total_swapcache_pages)) +</span>
<span class="p_add">+            &quot;Active:         {:8d} kB\n&quot;.format(self.K(active_pages)) +</span>
<span class="p_add">+            &quot;Inactive:       {:8d} kB\n&quot;.format(self.K(inactive_pages)) +</span>
<span class="p_add">+            &quot;Active(anon):   {:8d} kB\n&quot;.format(self.K(active_pages_anon)) +</span>
<span class="p_add">+            &quot;Inactive(anon): {:8d} kB\n&quot;.format(self.K(inactive_pages_anon)) +</span>
<span class="p_add">+            &quot;Active(file):   {:8d} kB\n&quot;.format(self.K(active_pages_file)) +</span>
<span class="p_add">+            &quot;Inactive(file): {:8d} kB\n&quot;.format(self.K(inactive_pages_file)) +</span>
<span class="p_add">+            &quot;Unevictable:    {:8d} kB\n&quot;.format(self.K(unevictable_pages)) +</span>
<span class="p_add">+            &quot;Mlocked:        {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_MLOCK&quot;))</span>
<span class="p_add">+            )</span>
<span class="p_add">+        # ifdef CONFIG_HIGHMEM || core dump?</span>
<span class="p_add">+        gdb.write(</span>
<span class="p_add">+            &quot;HighTotal:      {:8d} kB\n&quot;.format(self.K(totalhigh)) +</span>
<span class="p_add">+            &quot;HighFree:       {:8d} kB\n&quot;.format(self.K(freehigh)) +</span>
<span class="p_add">+            &quot;LowTotal:       {:8d} kB\n&quot;.format(self.K(totalram-totalhigh)) +</span>
<span class="p_add">+            &quot;LowFree:        {:8d} kB\n&quot;.format(self.K(freeram-freehigh))</span>
<span class="p_add">+            )</span>
<span class="p_add">+        # endif</span>
<span class="p_add">+        # ifndef CONFIG_MMU</span>
<span class="p_add">+        # gdb.write(</span>
<span class="p_add">+        #    mmap_pages_allocated</span>
<span class="p_add">+        #    )</span>
<span class="p_add">+        # endif</span>
<span class="p_add">+        gdb.write(</span>
<span class="p_add">+            &quot;SwapTotal:      {:8d} kB\n&quot;.format(self.K(0)) +</span>
<span class="p_add">+            &quot;SwapFree:       {:8d} kB\n&quot;.format(self.K(0)) +</span>
<span class="p_add">+            &quot;Dirty:          {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_FILE_DIRTY&quot;)) +</span>
<span class="p_add">+            &quot;Writeback:      {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_WRITEBACK&quot;)) +</span>
<span class="p_add">+            &quot;AnonPages:      {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_ANON_PAGES&quot;)) +</span>
<span class="p_add">+            &quot;Mapped:         {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_FILE_MAPPED&quot;)) +</span>
<span class="p_add">+            &quot;Shmem:          {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_SHMEM&quot;)) +</span>
<span class="p_add">+            &quot;Slab:           {:8d} kB\n&quot;.format(self.K(slab)) +</span>
<span class="p_add">+            &quot;SReclaimable:   {:8d} kB\n&quot;.format(self.K(reclaimable)) +</span>
<span class="p_add">+            &quot;SUnreclaim:     {:8d} kB\n&quot;.format(self.K(unreclaimable)) +</span>
<span class="p_add">+            &quot;KernelStack:    {:8d} kB\n&quot;.format(kernelstack) +</span>
<span class="p_add">+            &quot;PageTables:     {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_PAGETABLE&quot;))</span>
<span class="p_add">+            )</span>
<span class="p_add">+</span>
<span class="p_add">+        #  if CONFIG_QUICKLIST</span>
<span class="p_add">+        #   &quot;Quicklists:     {:8d} kB\n&quot;.format(self.K(quicklist)))</span>
<span class="p_add">+</span>
<span class="p_add">+        gdb.write(</span>
<span class="p_add">+            &quot;NFS_Unstable:   {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_UNSTABLE_NFS&quot;)) +</span>
<span class="p_add">+            &quot;Bounce:         {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_BOUNCE&quot;)) +</span>
<span class="p_add">+            &quot;WritebackTmp:   {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_WRITEBACK_TEMP&quot;)) +</span>
<span class="p_add">+            &quot;CommitLimit:    {:8d} kB\n&quot;.format(self.K(commitlimit)) +</span>
<span class="p_add">+            &quot;Committed_AS:   {:8d} kB\n&quot;.format(self.K(committed_as)) +</span>
<span class="p_add">+            &quot;VmallocTotal:   {:8d} kB\n&quot;.format(vmalloc_total) +</span>
<span class="p_add">+            &quot;VmallocUsed:    {:8d} kB\n&quot;.format(0) +</span>
<span class="p_add">+            &quot;VmallocChunk:   {:8d} kB\n&quot;.format(0)</span>
<span class="p_add">+            )</span>
<span class="p_add">+        # if CONFIG_MEMORY_FAILURE</span>
<span class="p_add">+        #   &quot;HardwareCorrupted: %5lu kB\n&quot;</span>
<span class="p_add">+        # ifdef CONFIG_CMA</span>
<span class="p_add">+        totalcma_pages = int(gdb.parse_and_eval(&quot;totalcma_pages&quot;))</span>
<span class="p_add">+        gdb.write(</span>
<span class="p_add">+            &quot;CmaTotal:       {:8d} kB\n&quot;.format(self.K(totalcma_pages)) +</span>
<span class="p_add">+            &quot;CmaFree:        {:8d} kB\n&quot;.format(self.gps_K(&quot;NR_FREE_CMA_PAGES&quot;))</span>
<span class="p_add">+            )</span>
<span class="p_add">+</span>
<span class="p_add">+LxMeminfo()</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



