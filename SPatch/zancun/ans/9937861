
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] x86/platform changes for v4.14 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] x86/platform changes for v4.14</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 5, 2017, 6:19 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170905061946.vdq3ukwqpy5e3pve@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9937861/mbox/"
   >mbox</a>
|
   <a href="/patch/9937861/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9937861/">/patch/9937861/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	61EE76038C for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Sep 2017 06:20:21 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3FFEC2887A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Sep 2017 06:20:21 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 32B9328894; Tue,  5 Sep 2017 06:20:21 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.3 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI, RCVD_IN_SORBS_SPAM,
	T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CE7932887A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Sep 2017 06:20:08 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1750946AbdIEGTz (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 5 Sep 2017 02:19:55 -0400
Received: from mail-wm0-f46.google.com ([74.125.82.46]:34947 &quot;EHLO
	mail-wm0-f46.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750762AbdIEGTw (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 5 Sep 2017 02:19:52 -0400
Received: by mail-wm0-f46.google.com with SMTP id h144so9074wme.0
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 04 Sep 2017 23:19:51 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=TWwfABqfVaFhlj/UTQljRMphDTyafEESSsI8eAJrynY=;
	b=rIS+QYCYNZ0wa1vSeKTjaOAaVSUe2pIiY5Pt09PTXebnG/mWqQQ3q/OZg+pfPblj3U
	xEAPvGUU+ZgxwFId8tDgywmfxAjyBqdgNFQrb/RgzGTWrfVig1Od0aKNAHTH3yQsOndn
	pcXtiy8S3nvkemrMJZDDOEm+3TEkJvHBq7L9iugw7ZSkLyjh+EM1evlHVrxUijpJYvDs
	cBNB+xMD2VWWZT9pKAwOlfdHDyC2b0CSD1cRFHankpnbOdPPLwWa9VFIjnXNSOQ/z/XG
	XT25npske/IVmMxpSLAfIEaKmAWAZ5kbE2yLS+sQ2Qi7ZvqmYFJzr/cTKoKXfNfNa67X
	JU5Q==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=TWwfABqfVaFhlj/UTQljRMphDTyafEESSsI8eAJrynY=;
	b=DO5tT3Ps3sPtZ1C6ZYnGNc9jksBnI4tkMIwzvoR2mdryrb39YUkZHSWmlxNCyPnQ5K
	0X/vbDnpkY9P2WX1nW5/Me9mwgS/1oi1/ud1tk89YwJgo69zFvEe1ZY0bgKkT9k1xYKH
	e9c1C7/I3e1KL4B2ou4iLejE2LQfQ1A9/83DMmUZXP9CIbsIl3M+tpe/9zkvrvClT7SL
	g0/7FpDXbWa2MrmoFzUsfHK46hrRS7uCTYw0fXkXNFSVLcu7nH7ZuiNhS8xTBXwVuv/r
	cVF4FsTeuscIrRAj0y2r6I6vYCEf8M3IB9SGR8hvS6qPB+NJBT5LDCRRbNxfeDHAJEhM
	M0eA==
X-Gm-Message-State: AHPjjUheHi6JXoVP5UShzuzZeASpxF+vHh53tlLkA4O9jUEmntaXQPkG
	NhIrUXhsSqOYJw==
X-Google-Smtp-Source: ADKCNb5zjOCLrao93cLJRGWGLuzmLlczBcDHSNr0HnlsI/rIs5Vtid38yZ+QE+yHAduqiVBV63JyOw==
X-Received: by 10.28.206.207 with SMTP id e198mr1523730wmg.28.1504592389924; 
	Mon, 04 Sep 2017 23:19:49 -0700 (PDT)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	f65sm2445029wmd.41.2017.09.04.23.19.48
	(version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
	Mon, 04 Sep 2017 23:19:49 -0700 (PDT)
Date: Tue, 5 Sep 2017 08:19:47 +0200
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;, Borislav Petkov &lt;bp@alien8.de&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;
Subject: [GIT PULL] x86/platform changes for v4.14
Message-ID: &lt;20170905061946.vdq3ukwqpy5e3pve@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: NeoMutt/20170113 (1.7.2)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Sept. 5, 2017, 6:19 a.m.</div>
<pre class="content">
Linus,

Please pull the latest x86-platform-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git x86-platform-for-linus

   # HEAD: 773b79f7a7c7839fb9d09c0e206734173a8b0a6b tracing/hyper-v: Trace hyperv_mmu_flush_tlb_others()

The main changes include various Hyper-V optimizations such as faster hypercalls 
and faster/better TLB flushes - and there&#39;s also some Intel-MID cleanups.


  out-of-topic modifications in x86-platform-for-linus:
  -------------------------------------------------------
  MAINTAINERS                        # 773b79f7a7c7: tracing/hyper-v: Trace hyper
                                   # db46e14f8a3c: MAINTAINERS: Add missed file
  drivers/hv/Kconfig                 # 2ffd9e33ce4a: x86/hyper-v: Use hypercall f
  drivers/hv/channel_mgmt.c          # 7415aea6072b: hyper-v: Globalize vp_index
                                   # 057841713cff: hyper-v: Use fast hypercall 
  drivers/hv/connection.c            # 7415aea6072b: hyper-v: Globalize vp_index
                                   # 057841713cff: hyper-v: Use fast hypercall 
                                   # fc53662f13b8: x86/hyper-v: Make hv_do_hype
  drivers/hv/hv.c                    # 7415aea6072b: hyper-v: Globalize vp_index
  drivers/hv/hyperv_vmbus.h          # 7415aea6072b: hyper-v: Globalize vp_index
  drivers/hv/vmbus_drv.c             # 7415aea6072b: hyper-v: Globalize vp_index
  drivers/pci/host/pci-hyperv.c      # 7415aea6072b: hyper-v: Globalize vp_index
  include/linux/hyperv.h             # 7415aea6072b: hyper-v: Globalize vp_index
                                   # 057841713cff: hyper-v: Use fast hypercall 
                                   # fc53662f13b8: x86/hyper-v: Make hv_do_hype

 Thanks,

	Ingo

------------------&gt;
Andy Shevchenko (3):
      x86/platform/intel-mid: Group timers callbacks together
      x86/platform/intel-mid: Make IRQ allocation a bit more flexible
      MAINTAINERS: Add missed file for Hyper-V

Bhumika Goyal (1):
      x86/platform/intel-mid: Make &#39;bt_sfi_data&#39; const

Colin Ian King (1):
      x86/platform/intel-mid: Make several arrays static, to make code smaller

Vitaly Kuznetsov (9):
      x86/hyper-v: Include hyperv/ only when CONFIG_HYPERV is set
      x86/hyper-v: Make hv_do_hypercall() inline
      x86/hyper-v: Introduce fast hypercall implementation
      hyper-v: Use fast hypercall for HVCALL_SIGNAL_EVENT
      x86/hyper-v: Implement rep hypercalls
      hyper-v: Globalize vp_index
      x86/hyper-v: Use hypercall for remote TLB flush
      x86/hyper-v: Support extended CPU ranges for TLB flush hypercalls
      tracing/hyper-v: Trace hyperv_mmu_flush_tlb_others()


 MAINTAINERS                                        |   2 +
 arch/x86/Kbuild                                    |   2 +-
 arch/x86/hyperv/Makefile                           |   2 +-
 arch/x86/hyperv/hv_init.c                          |  90 +++----
 arch/x86/hyperv/mmu.c                              | 272 +++++++++++++++++++++
 arch/x86/include/asm/mshyperv.h                    | 147 ++++++++++-
 arch/x86/include/asm/trace/hyperv.h                |  40 +++
 arch/x86/include/uapi/asm/hyperv.h                 |  17 ++
 arch/x86/kernel/cpu/mshyperv.c                     |   1 +
 arch/x86/pci/intel_mid_pci.c                       |  12 +-
 .../platform/intel-mid/device_libs/platform_bt.c   |   2 +-
 .../intel-mid/device_libs/platform_mrfld_wdt.c     |   6 +-
 arch/x86/platform/intel-mid/intel-mid.c            |   2 +-
 arch/x86/platform/intel-mid/pwr.c                  |   4 +-
 drivers/hv/Kconfig                                 |   1 +
 drivers/hv/channel_mgmt.c                          |  20 +-
 drivers/hv/connection.c                            |   7 +-
 drivers/hv/hv.c                                    |   9 -
 drivers/hv/hyperv_vmbus.h                          |  11 -
 drivers/hv/vmbus_drv.c                             |  17 --
 drivers/pci/host/pci-hyperv.c                      |  54 +---
 include/linux/hyperv.h                             |  17 +-
 22 files changed, 552 insertions(+), 183 deletions(-)
 create mode 100644 arch/x86/hyperv/mmu.c
 create mode 100644 arch/x86/include/asm/trace/hyperv.h
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index 1c3feffb1c1c..9fcffdfcb09d 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -6258,6 +6258,7 @@</span> <span class="p_context"> M:	Stephen Hemminger &lt;sthemmin@microsoft.com&gt;</span>
 L:	devel@linuxdriverproject.org
 S:	Maintained
 F:	arch/x86/include/asm/mshyperv.h
<span class="p_add">+F:	arch/x86/include/asm/trace/hyperv.h</span>
 F:	arch/x86/include/uapi/asm/hyperv.h
 F:	arch/x86/kernel/cpu/mshyperv.c
 F:	arch/x86/hyperv
<span class="p_chunk">@@ -6270,6 +6271,7 @@</span> <span class="p_context"> F:	drivers/scsi/storvsc_drv.c</span>
 F:	drivers/uio/uio_hv_generic.c
 F:	drivers/video/fbdev/hyperv_fb.c
 F:	include/linux/hyperv.h
<span class="p_add">+F:	include/uapi/linux/hyperv.h</span>
 F:	tools/hv/
 F:	Documentation/ABI/stable/sysfs-bus-vmbus
 
<span class="p_header">diff --git a/arch/x86/Kbuild b/arch/x86/Kbuild</span>
<span class="p_header">index 586b786b3edf..3e6f64073005 100644</span>
<span class="p_header">--- a/arch/x86/Kbuild</span>
<span class="p_header">+++ b/arch/x86/Kbuild</span>
<span class="p_chunk">@@ -8,7 +8,7 @@</span> <span class="p_context"> obj-$(CONFIG_KVM) += kvm/</span>
 obj-$(CONFIG_XEN) += xen/
 
 # Hyper-V paravirtualization support
<span class="p_del">-obj-$(CONFIG_HYPERVISOR_GUEST) += hyperv/</span>
<span class="p_add">+obj-$(subst m,y,$(CONFIG_HYPERV)) += hyperv/</span>
 
 # lguest paravirtualization support
 obj-$(CONFIG_LGUEST_GUEST) += lguest/
<span class="p_header">diff --git a/arch/x86/hyperv/Makefile b/arch/x86/hyperv/Makefile</span>
<span class="p_header">index 171ae09864d7..367a8203cfcf 100644</span>
<span class="p_header">--- a/arch/x86/hyperv/Makefile</span>
<span class="p_header">+++ b/arch/x86/hyperv/Makefile</span>
<span class="p_chunk">@@ -1 +1 @@</span> <span class="p_context"></span>
<span class="p_del">-obj-y		:= hv_init.o</span>
<span class="p_add">+obj-y		:= hv_init.o mmu.o</span>
<span class="p_header">diff --git a/arch/x86/hyperv/hv_init.c b/arch/x86/hyperv/hv_init.c</span>
<span class="p_header">index 5b882cc0c0e9..1a8eb550c40f 100644</span>
<span class="p_header">--- a/arch/x86/hyperv/hv_init.c</span>
<span class="p_header">+++ b/arch/x86/hyperv/hv_init.c</span>
<span class="p_chunk">@@ -26,6 +26,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/clockchips.h&gt;
 #include &lt;linux/hyperv.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpuhotplug.h&gt;</span>
 
 #ifdef CONFIG_HYPERV_TSCPAGE
 
<span class="p_chunk">@@ -75,10 +77,25 @@</span> <span class="p_context"> static struct clocksource hyperv_cs_msr = {</span>
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
<span class="p_del">-static void *hypercall_pg;</span>
<span class="p_add">+void *hv_hypercall_pg;</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(hv_hypercall_pg);</span>
 struct clocksource *hyperv_cs;
 EXPORT_SYMBOL_GPL(hyperv_cs);
 
<span class="p_add">+u32 *hv_vp_index;</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(hv_vp_index);</span>
<span class="p_add">+</span>
<span class="p_add">+static int hv_cpu_init(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 msr_vp_index;</span>
<span class="p_add">+</span>
<span class="p_add">+	hv_get_vp_index(msr_vp_index);</span>
<span class="p_add">+</span>
<span class="p_add">+	hv_vp_index[smp_processor_id()] = msr_vp_index;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * This function is to be invoked early in the boot sequence after the
  * hypervisor has been detected.
<span class="p_chunk">@@ -94,6 +111,16 @@</span> <span class="p_context"> void hyperv_init(void)</span>
 	if (x86_hyper != &amp;x86_hyper_ms_hyperv)
 		return;
 
<span class="p_add">+	/* Allocate percpu VP index */</span>
<span class="p_add">+	hv_vp_index = kmalloc_array(num_possible_cpus(), sizeof(*hv_vp_index),</span>
<span class="p_add">+				    GFP_KERNEL);</span>
<span class="p_add">+	if (!hv_vp_index)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, &quot;x86/hyperv_init:online&quot;,</span>
<span class="p_add">+			      hv_cpu_init, NULL) &lt; 0)</span>
<span class="p_add">+		goto free_vp_index;</span>
<span class="p_add">+</span>
 	/*
 	 * Setup the hypercall page and enable hypercalls.
 	 * 1. Register the guest ID
<span class="p_chunk">@@ -102,17 +129,19 @@</span> <span class="p_context"> void hyperv_init(void)</span>
 	guest_id = generate_guest_id(0, LINUX_VERSION_CODE, 0);
 	wrmsrl(HV_X64_MSR_GUEST_OS_ID, guest_id);
 
<span class="p_del">-	hypercall_pg  = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL_RX);</span>
<span class="p_del">-	if (hypercall_pg == NULL) {</span>
<span class="p_add">+	hv_hypercall_pg  = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL_RX);</span>
<span class="p_add">+	if (hv_hypercall_pg == NULL) {</span>
 		wrmsrl(HV_X64_MSR_GUEST_OS_ID, 0);
<span class="p_del">-		return;</span>
<span class="p_add">+		goto free_vp_index;</span>
 	}
 
 	rdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 	hypercall_msr.enable = 1;
<span class="p_del">-	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hypercall_pg);</span>
<span class="p_add">+	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hv_hypercall_pg);</span>
 	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 
<span class="p_add">+	hyper_alloc_mmu();</span>
<span class="p_add">+</span>
 	/*
 	 * Register Hyper-V specific clocksource.
 	 */
<span class="p_chunk">@@ -148,6 +177,12 @@</span> <span class="p_context"> void hyperv_init(void)</span>
 	hyperv_cs = &amp;hyperv_cs_msr;
 	if (ms_hyperv.features &amp; HV_X64_MSR_TIME_REF_COUNT_AVAILABLE)
 		clocksource_register_hz(&amp;hyperv_cs_msr, NSEC_PER_SEC/100);
<span class="p_add">+</span>
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+free_vp_index:</span>
<span class="p_add">+	kfree(hv_vp_index);</span>
<span class="p_add">+	hv_vp_index = NULL;</span>
 }
 
 /*
<span class="p_chunk">@@ -170,51 +205,6 @@</span> <span class="p_context"> void hyperv_cleanup(void)</span>
 }
 EXPORT_SYMBOL_GPL(hyperv_cleanup);
 
<span class="p_del">-/*</span>
<span class="p_del">- * hv_do_hypercall- Invoke the specified hypercall</span>
<span class="p_del">- */</span>
<span class="p_del">-u64 hv_do_hypercall(u64 control, void *input, void *output)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u64 input_address = (input) ? virt_to_phys(input) : 0;</span>
<span class="p_del">-	u64 output_address = (output) ? virt_to_phys(output) : 0;</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	u64 hv_status = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!hypercall_pg)</span>
<span class="p_del">-		return (u64)ULLONG_MAX;</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(&quot;mov %0, %%r8&quot; : : &quot;r&quot; (output_address) : &quot;r8&quot;);</span>
<span class="p_del">-	__asm__ __volatile__(&quot;call *%3&quot; : &quot;=a&quot; (hv_status) :</span>
<span class="p_del">-			     &quot;c&quot; (control), &quot;d&quot; (input_address),</span>
<span class="p_del">-			     &quot;m&quot; (hypercall_pg));</span>
<span class="p_del">-</span>
<span class="p_del">-	return hv_status;</span>
<span class="p_del">-</span>
<span class="p_del">-#else</span>
<span class="p_del">-</span>
<span class="p_del">-	u32 control_hi = control &gt;&gt; 32;</span>
<span class="p_del">-	u32 control_lo = control &amp; 0xFFFFFFFF;</span>
<span class="p_del">-	u32 hv_status_hi = 1;</span>
<span class="p_del">-	u32 hv_status_lo = 1;</span>
<span class="p_del">-	u32 input_address_hi = input_address &gt;&gt; 32;</span>
<span class="p_del">-	u32 input_address_lo = input_address &amp; 0xFFFFFFFF;</span>
<span class="p_del">-	u32 output_address_hi = output_address &gt;&gt; 32;</span>
<span class="p_del">-	u32 output_address_lo = output_address &amp; 0xFFFFFFFF;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!hypercall_pg)</span>
<span class="p_del">-		return (u64)ULLONG_MAX;</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__ (&quot;call *%8&quot; : &quot;=d&quot;(hv_status_hi),</span>
<span class="p_del">-			      &quot;=a&quot;(hv_status_lo) : &quot;d&quot; (control_hi),</span>
<span class="p_del">-			      &quot;a&quot; (control_lo), &quot;b&quot; (input_address_hi),</span>
<span class="p_del">-			      &quot;c&quot; (input_address_lo), &quot;D&quot;(output_address_hi),</span>
<span class="p_del">-			      &quot;S&quot;(output_address_lo), &quot;m&quot; (hypercall_pg));</span>
<span class="p_del">-</span>
<span class="p_del">-	return hv_status_lo | ((u64)hv_status_hi &lt;&lt; 32);</span>
<span class="p_del">-#endif /* !x86_64 */</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(hv_do_hypercall);</span>
<span class="p_del">-</span>
 void hyperv_report_panic(struct pt_regs *regs)
 {
 	static bool panic_reported;
<span class="p_header">diff --git a/arch/x86/hyperv/mmu.c b/arch/x86/hyperv/mmu.c</span>
new file mode 100644
<span class="p_header">index 000000000000..39e7f6e50919</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/hyperv/mmu.c</span>
<span class="p_chunk">@@ -0,0 +1,272 @@</span> <span class="p_context"></span>
<span class="p_add">+#define pr_fmt(fmt)  &quot;Hyper-V: &quot; fmt</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/hyperv.h&gt;</span>
<span class="p_add">+#include &lt;linux/log2.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/fpu/api.h&gt;</span>
<span class="p_add">+#include &lt;asm/mshyperv.h&gt;</span>
<span class="p_add">+#include &lt;asm/msr.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define CREATE_TRACE_POINTS</span>
<span class="p_add">+#include &lt;asm/trace/hyperv.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* HvFlushVirtualAddressSpace, HvFlushVirtualAddressList hypercalls */</span>
<span class="p_add">+struct hv_flush_pcpu {</span>
<span class="p_add">+	u64 address_space;</span>
<span class="p_add">+	u64 flags;</span>
<span class="p_add">+	u64 processor_mask;</span>
<span class="p_add">+	u64 gva_list[];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* HvFlushVirtualAddressSpaceEx, HvFlushVirtualAddressListEx hypercalls */</span>
<span class="p_add">+struct hv_flush_pcpu_ex {</span>
<span class="p_add">+	u64 address_space;</span>
<span class="p_add">+	u64 flags;</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		u64 format;</span>
<span class="p_add">+		u64 valid_bank_mask;</span>
<span class="p_add">+		u64 bank_contents[];</span>
<span class="p_add">+	} hv_vp_set;</span>
<span class="p_add">+	u64 gva_list[];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Each gva in gva_list encodes up to 4096 pages to flush */</span>
<span class="p_add">+#define HV_TLB_FLUSH_UNIT (4096 * PAGE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+static struct hv_flush_pcpu __percpu *pcpu_flush;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct hv_flush_pcpu_ex __percpu *pcpu_flush_ex;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Fills in gva_list starting from offset. Returns the number of items added.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int fill_gva_list(u64 gva_list[], int offset,</span>
<span class="p_add">+				unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int gva_n = offset;</span>
<span class="p_add">+	unsigned long cur = start, diff;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		diff = end &gt; cur ? end - cur : 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		gva_list[gva_n] = cur &amp; PAGE_MASK;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Lower 12 bits encode the number of additional</span>
<span class="p_add">+		 * pages to flush (in addition to the &#39;cur&#39; page).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (diff &gt;= HV_TLB_FLUSH_UNIT)</span>
<span class="p_add">+			gva_list[gva_n] |= ~PAGE_MASK;</span>
<span class="p_add">+		else if (diff)</span>
<span class="p_add">+			gva_list[gva_n] |= (diff - 1) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+		cur += HV_TLB_FLUSH_UNIT;</span>
<span class="p_add">+		gva_n++;</span>
<span class="p_add">+</span>
<span class="p_add">+	} while (cur &lt; end);</span>
<span class="p_add">+</span>
<span class="p_add">+	return gva_n - offset;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Return the number of banks in the resulting vp_set */</span>
<span class="p_add">+static inline int cpumask_to_vp_set(struct hv_flush_pcpu_ex *flush,</span>
<span class="p_add">+				    const struct cpumask *cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu, vcpu, vcpu_bank, vcpu_offset, nr_bank = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some banks may end up being empty but this is acceptable.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for_each_cpu(cpu, cpus) {</span>
<span class="p_add">+		vcpu = hv_cpu_number_to_vp_number(cpu);</span>
<span class="p_add">+		vcpu_bank = vcpu / 64;</span>
<span class="p_add">+		vcpu_offset = vcpu % 64;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* valid_bank_mask can represent up to 64 banks */</span>
<span class="p_add">+		if (vcpu_bank &gt;= 64)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		__set_bit(vcpu_offset, (unsigned long *)</span>
<span class="p_add">+			  &amp;flush-&gt;hv_vp_set.bank_contents[vcpu_bank]);</span>
<span class="p_add">+		if (vcpu_bank &gt;= nr_bank)</span>
<span class="p_add">+			nr_bank = vcpu_bank + 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	flush-&gt;hv_vp_set.valid_bank_mask = GENMASK_ULL(nr_bank - 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return nr_bank;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hyperv_flush_tlb_others(const struct cpumask *cpus,</span>
<span class="p_add">+				    const struct flush_tlb_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu, vcpu, gva_n, max_gvas;</span>
<span class="p_add">+	struct hv_flush_pcpu *flush;</span>
<span class="p_add">+	u64 status = U64_MAX;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_hyperv_mmu_flush_tlb_others(cpus, info);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pcpu_flush || !hv_hypercall_pg)</span>
<span class="p_add">+		goto do_native;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpumask_empty(cpus))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	flush = this_cpu_ptr(pcpu_flush);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (info-&gt;mm) {</span>
<span class="p_add">+		flush-&gt;address_space = virt_to_phys(info-&gt;mm-&gt;pgd);</span>
<span class="p_add">+		flush-&gt;flags = 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		flush-&gt;address_space = 0;</span>
<span class="p_add">+		flush-&gt;flags = HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	flush-&gt;processor_mask = 0;</span>
<span class="p_add">+	if (cpumask_equal(cpus, cpu_present_mask)) {</span>
<span class="p_add">+		flush-&gt;flags |= HV_FLUSH_ALL_PROCESSORS;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		for_each_cpu(cpu, cpus) {</span>
<span class="p_add">+			vcpu = hv_cpu_number_to_vp_number(cpu);</span>
<span class="p_add">+			if (vcpu &gt;= 64)</span>
<span class="p_add">+				goto do_native;</span>
<span class="p_add">+</span>
<span class="p_add">+			__set_bit(vcpu, (unsigned long *)</span>
<span class="p_add">+				  &amp;flush-&gt;processor_mask);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We can flush not more than max_gvas with one hypercall. Flush the</span>
<span class="p_add">+	 * whole address space if we were asked to do more.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	max_gvas = (PAGE_SIZE - sizeof(*flush)) / sizeof(flush-&gt;gva_list[0]);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (info-&gt;end == TLB_FLUSH_ALL) {</span>
<span class="p_add">+		flush-&gt;flags |= HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY;</span>
<span class="p_add">+		status = hv_do_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE,</span>
<span class="p_add">+					 flush, NULL);</span>
<span class="p_add">+	} else if (info-&gt;end &amp;&amp;</span>
<span class="p_add">+		   ((info-&gt;end - info-&gt;start)/HV_TLB_FLUSH_UNIT) &gt; max_gvas) {</span>
<span class="p_add">+		status = hv_do_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE,</span>
<span class="p_add">+					 flush, NULL);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		gva_n = fill_gva_list(flush-&gt;gva_list, 0,</span>
<span class="p_add">+				      info-&gt;start, info-&gt;end);</span>
<span class="p_add">+		status = hv_do_rep_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST,</span>
<span class="p_add">+					     gva_n, 0, flush, NULL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(status &amp; HV_HYPERCALL_RESULT_MASK))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+do_native:</span>
<span class="p_add">+	native_flush_tlb_others(cpus, info);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hyperv_flush_tlb_others_ex(const struct cpumask *cpus,</span>
<span class="p_add">+				       const struct flush_tlb_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int nr_bank = 0, max_gvas, gva_n;</span>
<span class="p_add">+	struct hv_flush_pcpu_ex *flush;</span>
<span class="p_add">+	u64 status = U64_MAX;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_hyperv_mmu_flush_tlb_others(cpus, info);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pcpu_flush_ex || !hv_hypercall_pg)</span>
<span class="p_add">+		goto do_native;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpumask_empty(cpus))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	flush = this_cpu_ptr(pcpu_flush_ex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (info-&gt;mm) {</span>
<span class="p_add">+		flush-&gt;address_space = virt_to_phys(info-&gt;mm-&gt;pgd);</span>
<span class="p_add">+		flush-&gt;flags = 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		flush-&gt;address_space = 0;</span>
<span class="p_add">+		flush-&gt;flags = HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	flush-&gt;hv_vp_set.valid_bank_mask = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpumask_equal(cpus, cpu_present_mask)) {</span>
<span class="p_add">+		flush-&gt;hv_vp_set.format = HV_GENERIC_SET_SPARCE_4K;</span>
<span class="p_add">+		nr_bank = cpumask_to_vp_set(flush, cpus);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!nr_bank) {</span>
<span class="p_add">+		flush-&gt;hv_vp_set.format = HV_GENERIC_SET_ALL;</span>
<span class="p_add">+		flush-&gt;flags |= HV_FLUSH_ALL_PROCESSORS;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We can flush not more than max_gvas with one hypercall. Flush the</span>
<span class="p_add">+	 * whole address space if we were asked to do more.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	max_gvas =</span>
<span class="p_add">+		(PAGE_SIZE - sizeof(*flush) - nr_bank *</span>
<span class="p_add">+		 sizeof(flush-&gt;hv_vp_set.bank_contents[0])) /</span>
<span class="p_add">+		sizeof(flush-&gt;gva_list[0]);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (info-&gt;end == TLB_FLUSH_ALL) {</span>
<span class="p_add">+		flush-&gt;flags |= HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY;</span>
<span class="p_add">+		status = hv_do_rep_hypercall(</span>
<span class="p_add">+			HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX,</span>
<span class="p_add">+			0, nr_bank + 2, flush, NULL);</span>
<span class="p_add">+	} else if (info-&gt;end &amp;&amp;</span>
<span class="p_add">+		   ((info-&gt;end - info-&gt;start)/HV_TLB_FLUSH_UNIT) &gt; max_gvas) {</span>
<span class="p_add">+		status = hv_do_rep_hypercall(</span>
<span class="p_add">+			HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX,</span>
<span class="p_add">+			0, nr_bank + 2, flush, NULL);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		gva_n = fill_gva_list(flush-&gt;gva_list, nr_bank,</span>
<span class="p_add">+				      info-&gt;start, info-&gt;end);</span>
<span class="p_add">+		status = hv_do_rep_hypercall(</span>
<span class="p_add">+			HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX,</span>
<span class="p_add">+			gva_n, nr_bank + 2, flush, NULL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(status &amp; HV_HYPERCALL_RESULT_MASK))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+do_native:</span>
<span class="p_add">+	native_flush_tlb_others(cpus, info);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hyperv_setup_mmu_ops(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!(ms_hyperv.hints &amp; HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_clear_cpu_cap(X86_FEATURE_PCID);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(ms_hyperv.hints &amp; HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED)) {</span>
<span class="p_add">+		pr_info(&quot;Using hypercall for remote TLB flush\n&quot;);</span>
<span class="p_add">+		pv_mmu_ops.flush_tlb_others = hyperv_flush_tlb_others;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pr_info(&quot;Using ext hypercall for remote TLB flush\n&quot;);</span>
<span class="p_add">+		pv_mmu_ops.flush_tlb_others = hyperv_flush_tlb_others_ex;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hyper_alloc_mmu(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!(ms_hyperv.hints &amp; HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(ms_hyperv.hints &amp; HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED))</span>
<span class="p_add">+		pcpu_flush = __alloc_percpu(PAGE_SIZE, PAGE_SIZE);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		pcpu_flush_ex = __alloc_percpu(PAGE_SIZE, PAGE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h</span>
<span class="p_header">index 2b58c8c1eeaa..0d4b01c5e438 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mshyperv.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mshyperv.h</span>
<span class="p_chunk">@@ -3,6 +3,8 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/types.h&gt;
 #include &lt;linux/atomic.h&gt;
<span class="p_add">+#include &lt;linux/nmi.h&gt;</span>
<span class="p_add">+#include &lt;asm/io.h&gt;</span>
 #include &lt;asm/hyperv.h&gt;
 
 /*
<span class="p_chunk">@@ -168,12 +170,155 @@</span> <span class="p_context"> void hv_remove_crash_handler(void);</span>
 
 #if IS_ENABLED(CONFIG_HYPERV)
 extern struct clocksource *hyperv_cs;
<span class="p_add">+extern void *hv_hypercall_pg;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline u64 hv_do_hypercall(u64 control, void *input, void *output)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 input_address = input ? virt_to_phys(input) : 0;</span>
<span class="p_add">+	u64 output_address = output ? virt_to_phys(output) : 0;</span>
<span class="p_add">+	u64 hv_status;</span>
<span class="p_add">+	register void *__sp asm(_ASM_SP);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	if (!hv_hypercall_pg)</span>
<span class="p_add">+		return U64_MAX;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ __volatile__(&quot;mov %4, %%r8\n&quot;</span>
<span class="p_add">+			     &quot;call *%5&quot;</span>
<span class="p_add">+			     : &quot;=a&quot; (hv_status), &quot;+r&quot; (__sp),</span>
<span class="p_add">+			       &quot;+c&quot; (control), &quot;+d&quot; (input_address)</span>
<span class="p_add">+			     :  &quot;r&quot; (output_address), &quot;m&quot; (hv_hypercall_pg)</span>
<span class="p_add">+			     : &quot;cc&quot;, &quot;memory&quot;, &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	u32 input_address_hi = upper_32_bits(input_address);</span>
<span class="p_add">+	u32 input_address_lo = lower_32_bits(input_address);</span>
<span class="p_add">+	u32 output_address_hi = upper_32_bits(output_address);</span>
<span class="p_add">+	u32 output_address_lo = lower_32_bits(output_address);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hv_hypercall_pg)</span>
<span class="p_add">+		return U64_MAX;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ __volatile__(&quot;call *%7&quot;</span>
<span class="p_add">+			     : &quot;=A&quot; (hv_status),</span>
<span class="p_add">+			       &quot;+c&quot; (input_address_lo), &quot;+r&quot; (__sp)</span>
<span class="p_add">+			     : &quot;A&quot; (control),</span>
<span class="p_add">+			       &quot;b&quot; (input_address_hi),</span>
<span class="p_add">+			       &quot;D&quot;(output_address_hi), &quot;S&quot;(output_address_lo),</span>
<span class="p_add">+			       &quot;m&quot; (hv_hypercall_pg)</span>
<span class="p_add">+			     : &quot;cc&quot;, &quot;memory&quot;);</span>
<span class="p_add">+#endif /* !x86_64 */</span>
<span class="p_add">+	return hv_status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define HV_HYPERCALL_RESULT_MASK	GENMASK_ULL(15, 0)</span>
<span class="p_add">+#define HV_HYPERCALL_FAST_BIT		BIT(16)</span>
<span class="p_add">+#define HV_HYPERCALL_VARHEAD_OFFSET	17</span>
<span class="p_add">+#define HV_HYPERCALL_REP_COMP_OFFSET	32</span>
<span class="p_add">+#define HV_HYPERCALL_REP_COMP_MASK	GENMASK_ULL(43, 32)</span>
<span class="p_add">+#define HV_HYPERCALL_REP_START_OFFSET	48</span>
<span class="p_add">+#define HV_HYPERCALL_REP_START_MASK	GENMASK_ULL(59, 48)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Fast hypercall with 8 bytes of input and no output */</span>
<span class="p_add">+static inline u64 hv_do_fast_hypercall8(u16 code, u64 input1)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 hv_status, control = (u64)code | HV_HYPERCALL_FAST_BIT;</span>
<span class="p_add">+	register void *__sp asm(_ASM_SP);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	{</span>
<span class="p_add">+		__asm__ __volatile__(&quot;call *%4&quot;</span>
<span class="p_add">+				     : &quot;=a&quot; (hv_status), &quot;+r&quot; (__sp),</span>
<span class="p_add">+				       &quot;+c&quot; (control), &quot;+d&quot; (input1)</span>
<span class="p_add">+				     : &quot;m&quot; (hv_hypercall_pg)</span>
<span class="p_add">+				     : &quot;cc&quot;, &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#else</span>
<span class="p_add">+	{</span>
<span class="p_add">+		u32 input1_hi = upper_32_bits(input1);</span>
<span class="p_add">+		u32 input1_lo = lower_32_bits(input1);</span>
<span class="p_add">+</span>
<span class="p_add">+		__asm__ __volatile__ (&quot;call *%5&quot;</span>
<span class="p_add">+				      : &quot;=A&quot;(hv_status),</span>
<span class="p_add">+					&quot;+c&quot;(input1_lo),</span>
<span class="p_add">+					&quot;+r&quot;(__sp)</span>
<span class="p_add">+				      :	&quot;A&quot; (control),</span>
<span class="p_add">+					&quot;b&quot; (input1_hi),</span>
<span class="p_add">+					&quot;m&quot; (hv_hypercall_pg)</span>
<span class="p_add">+				      : &quot;cc&quot;, &quot;edi&quot;, &quot;esi&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		return hv_status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Rep hypercalls. Callers of this functions are supposed to ensure that</span>
<span class="p_add">+ * rep_count and varhead_size comply with Hyper-V hypercall definition.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline u64 hv_do_rep_hypercall(u16 code, u16 rep_count, u16 varhead_size,</span>
<span class="p_add">+				      void *input, void *output)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 control = code;</span>
<span class="p_add">+	u64 status;</span>
<span class="p_add">+	u16 rep_comp;</span>
<span class="p_add">+</span>
<span class="p_add">+	control |= (u64)varhead_size &lt;&lt; HV_HYPERCALL_VARHEAD_OFFSET;</span>
<span class="p_add">+	control |= (u64)rep_count &lt;&lt; HV_HYPERCALL_REP_COMP_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		status = hv_do_hypercall(control, input, output);</span>
<span class="p_add">+		if ((status &amp; HV_HYPERCALL_RESULT_MASK) != HV_STATUS_SUCCESS)</span>
<span class="p_add">+			return status;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Bits 32-43 of status have &#39;Reps completed&#39; data. */</span>
<span class="p_add">+		rep_comp = (status &amp; HV_HYPERCALL_REP_COMP_MASK) &gt;&gt;</span>
<span class="p_add">+			HV_HYPERCALL_REP_COMP_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+		control &amp;= ~HV_HYPERCALL_REP_START_MASK;</span>
<span class="p_add">+		control |= (u64)rep_comp &lt;&lt; HV_HYPERCALL_REP_START_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+		touch_nmi_watchdog();</span>
<span class="p_add">+	} while (rep_comp &lt; rep_count);</span>
<span class="p_add">+</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Hypervisor&#39;s notion of virtual processor ID is different from</span>
<span class="p_add">+ * Linux&#39; notion of CPU ID. This information can only be retrieved</span>
<span class="p_add">+ * in the context of the calling CPU. Setup a map for easy access</span>
<span class="p_add">+ * to this information.</span>
<span class="p_add">+ */</span>
<span class="p_add">+extern u32 *hv_vp_index;</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * hv_cpu_number_to_vp_number() - Map CPU to VP.</span>
<span class="p_add">+ * @cpu_number: CPU number in Linux terms</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function returns the mapping between the Linux processor</span>
<span class="p_add">+ * number and the hypervisor&#39;s virtual processor number, useful</span>
<span class="p_add">+ * in making hypercalls and such that talk about specific</span>
<span class="p_add">+ * processors.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: Virtual processor number in Hyper-V terms</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int hv_cpu_number_to_vp_number(int cpu_number)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return hv_vp_index[cpu_number];</span>
<span class="p_add">+}</span>
 
 void hyperv_init(void);
<span class="p_add">+void hyperv_setup_mmu_ops(void);</span>
<span class="p_add">+void hyper_alloc_mmu(void);</span>
 void hyperv_report_panic(struct pt_regs *regs);
 bool hv_is_hypercall_page_setup(void);
 void hyperv_cleanup(void);
<span class="p_del">-#endif</span>
<span class="p_add">+#else /* CONFIG_HYPERV */</span>
<span class="p_add">+static inline void hyperv_init(void) {}</span>
<span class="p_add">+static inline bool hv_is_hypercall_page_setup(void) { return false; }</span>
<span class="p_add">+static inline void hyperv_cleanup(void) {}</span>
<span class="p_add">+static inline void hyperv_setup_mmu_ops(void) {}</span>
<span class="p_add">+#endif /* CONFIG_HYPERV */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_HYPERV_TSCPAGE
 struct ms_hyperv_tsc_page *hv_get_tsc_page(void);
 static inline u64 hv_read_tsc_page(const struct ms_hyperv_tsc_page *tsc_pg)
<span class="p_header">diff --git a/arch/x86/include/asm/trace/hyperv.h b/arch/x86/include/asm/trace/hyperv.h</span>
new file mode 100644
<span class="p_header">index 000000000000..4253bca99989</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/include/asm/trace/hyperv.h</span>
<span class="p_chunk">@@ -0,0 +1,40 @@</span> <span class="p_context"></span>
<span class="p_add">+#undef TRACE_SYSTEM</span>
<span class="p_add">+#define TRACE_SYSTEM hyperv</span>
<span class="p_add">+</span>
<span class="p_add">+#if !defined(_TRACE_HYPERV_H) || defined(TRACE_HEADER_MULTI_READ)</span>
<span class="p_add">+#define _TRACE_HYPERV_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/tracepoint.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_HYPERV)</span>
<span class="p_add">+</span>
<span class="p_add">+TRACE_EVENT(hyperv_mmu_flush_tlb_others,</span>
<span class="p_add">+	    TP_PROTO(const struct cpumask *cpus,</span>
<span class="p_add">+		     const struct flush_tlb_info *info),</span>
<span class="p_add">+	    TP_ARGS(cpus, info),</span>
<span class="p_add">+	    TP_STRUCT__entry(</span>
<span class="p_add">+		    __field(unsigned int, ncpus)</span>
<span class="p_add">+		    __field(struct mm_struct *, mm)</span>
<span class="p_add">+		    __field(unsigned long, addr)</span>
<span class="p_add">+		    __field(unsigned long, end)</span>
<span class="p_add">+		    ),</span>
<span class="p_add">+	    TP_fast_assign(__entry-&gt;ncpus = cpumask_weight(cpus);</span>
<span class="p_add">+			   __entry-&gt;mm = info-&gt;mm;</span>
<span class="p_add">+			   __entry-&gt;addr = info-&gt;start;</span>
<span class="p_add">+			   __entry-&gt;end = info-&gt;end;</span>
<span class="p_add">+		    ),</span>
<span class="p_add">+	    TP_printk(&quot;ncpus %d mm %p addr %lx, end %lx&quot;,</span>
<span class="p_add">+		      __entry-&gt;ncpus, __entry-&gt;mm,</span>
<span class="p_add">+		      __entry-&gt;addr, __entry-&gt;end)</span>
<span class="p_add">+	);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_HYPERV */</span>
<span class="p_add">+</span>
<span class="p_add">+#undef TRACE_INCLUDE_PATH</span>
<span class="p_add">+#define TRACE_INCLUDE_PATH asm/trace/</span>
<span class="p_add">+#undef TRACE_INCLUDE_FILE</span>
<span class="p_add">+#define TRACE_INCLUDE_FILE hyperv</span>
<span class="p_add">+#endif /* _TRACE_HYPERV_H */</span>
<span class="p_add">+</span>
<span class="p_add">+/* This part must be outside protection */</span>
<span class="p_add">+#include &lt;trace/define_trace.h&gt;</span>
<span class="p_header">diff --git a/arch/x86/include/uapi/asm/hyperv.h b/arch/x86/include/uapi/asm/hyperv.h</span>
<span class="p_header">index 127ddadee1a5..7032f4d8dff3 100644</span>
<span class="p_header">--- a/arch/x86/include/uapi/asm/hyperv.h</span>
<span class="p_header">+++ b/arch/x86/include/uapi/asm/hyperv.h</span>
<span class="p_chunk">@@ -149,6 +149,9 @@</span> <span class="p_context"></span>
  */
 #define HV_X64_DEPRECATING_AEOI_RECOMMENDED	(1 &lt;&lt; 9)
 
<span class="p_add">+/* Recommend using the newer ExProcessorMasks interface */</span>
<span class="p_add">+#define HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED	(1 &lt;&lt; 11)</span>
<span class="p_add">+</span>
 /*
  * HV_VP_SET available
  */
<span class="p_chunk">@@ -242,7 +245,11 @@</span> <span class="p_context"></span>
 		(~((1ull &lt;&lt; HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT) - 1))
 
 /* Declare the various hypercall operations. */
<span class="p_add">+#define HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE	0x0002</span>
<span class="p_add">+#define HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST	0x0003</span>
 #define HVCALL_NOTIFY_LONG_SPIN_WAIT		0x0008
<span class="p_add">+#define HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX  0x0013</span>
<span class="p_add">+#define HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX   0x0014</span>
 #define HVCALL_POST_MESSAGE			0x005c
 #define HVCALL_SIGNAL_EVENT			0x005d
 
<span class="p_chunk">@@ -259,6 +266,16 @@</span> <span class="p_context"></span>
 #define HV_PROCESSOR_POWER_STATE_C2		2
 #define HV_PROCESSOR_POWER_STATE_C3		3
 
<span class="p_add">+#define HV_FLUSH_ALL_PROCESSORS			BIT(0)</span>
<span class="p_add">+#define HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES	BIT(1)</span>
<span class="p_add">+#define HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY	BIT(2)</span>
<span class="p_add">+#define HV_FLUSH_USE_EXTENDED_RANGE_FORMAT	BIT(3)</span>
<span class="p_add">+</span>
<span class="p_add">+enum HV_GENERIC_SET_FORMAT {</span>
<span class="p_add">+	HV_GENERIC_SET_SPARCE_4K,</span>
<span class="p_add">+	HV_GENERIC_SET_ALL,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /* hypercall status code */
 #define HV_STATUS_SUCCESS			0
 #define HV_STATUS_INVALID_HYPERCALL_CODE	2
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mshyperv.c b/arch/x86/kernel/cpu/mshyperv.c</span>
<span class="p_header">index 70e717fccdd6..daefd67a66c7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mshyperv.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mshyperv.c</span>
<span class="p_chunk">@@ -249,6 +249,7 @@</span> <span class="p_context"> static void __init ms_hyperv_init_platform(void)</span>
 	 * Setup the hook to get control post apic initialization.
 	 */
 	x86_platform.apic_post_init = hyperv_init;
<span class="p_add">+	hyperv_setup_mmu_ops();</span>
 #endif
 }
 
<span class="p_header">diff --git a/arch/x86/pci/intel_mid_pci.c b/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_header">index 5a18aedcb341..b901ece278dd 100644</span>
<span class="p_header">--- a/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_header">+++ b/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_chunk">@@ -215,16 +215,23 @@</span> <span class="p_context"> static int intel_mid_pci_irq_enable(struct pci_dev *dev)</span>
 	struct irq_alloc_info info;
 	int polarity;
 	int ret;
<span class="p_add">+	u8 gsi;</span>
 
 	if (dev-&gt;irq_managed &amp;&amp; dev-&gt;irq &gt; 0)
 		return 0;
 
<span class="p_add">+	ret = pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &amp;gsi);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		dev_warn(&amp;dev-&gt;dev, &quot;Failed to read interrupt line: %d\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	switch (intel_mid_identify_cpu()) {
 	case INTEL_MID_CPU_CHIP_TANGIER:
 		polarity = IOAPIC_POL_HIGH;
 
 		/* Special treatment for IRQ0 */
<span class="p_del">-		if (dev-&gt;irq == 0) {</span>
<span class="p_add">+		if (gsi == 0) {</span>
 			/*
 			 * Skip HS UART common registers device since it has
 			 * IRQ0 assigned and not used by the kernel.
<span class="p_chunk">@@ -253,10 +260,11 @@</span> <span class="p_context"> static int intel_mid_pci_irq_enable(struct pci_dev *dev)</span>
 	 * MRST only have IOAPIC, the PCI irq lines are 1:1 mapped to
 	 * IOAPIC RTE entries, so we just enable RTE for the device.
 	 */
<span class="p_del">-	ret = mp_map_gsi_to_irq(dev-&gt;irq, IOAPIC_MAP_ALLOC, &amp;info);</span>
<span class="p_add">+	ret = mp_map_gsi_to_irq(gsi, IOAPIC_MAP_ALLOC, &amp;info);</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_add">+	dev-&gt;irq = ret;</span>
 	dev-&gt;irq_managed = 1;
 
 	return 0;
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_bt.c b/arch/x86/platform/intel-mid/device_libs/platform_bt.c</span>
<span class="p_header">index 5a0483e7bf66..dc036e511f48 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_bt.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_bt.c</span>
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> static int __init tng_bt_sfi_setup(struct bt_sfi_data *ddata)</span>
 	return 0;
 }
 
<span class="p_del">-static struct bt_sfi_data tng_bt_sfi_data __initdata = {</span>
<span class="p_add">+static const struct bt_sfi_data tng_bt_sfi_data __initdata = {</span>
 	.setup	= tng_bt_sfi_setup,
 };
 
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfld_wdt.c b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_wdt.c</span>
<span class="p_header">index 9e304e2ea4f5..4f5fa65a1011 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_mrfld_wdt.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_wdt.c</span>
<span class="p_chunk">@@ -30,13 +30,13 @@</span> <span class="p_context"> static int tangier_probe(struct platform_device *pdev)</span>
 {
 	struct irq_alloc_info info;
 	struct intel_mid_wdt_pdata *pdata = pdev-&gt;dev.platform_data;
<span class="p_del">-	int gsi, irq;</span>
<span class="p_add">+	int gsi = TANGIER_EXT_TIMER0_MSI;</span>
<span class="p_add">+	int irq;</span>
 
 	if (!pdata)
 		return -EINVAL;
 
 	/* IOAPIC builds identity mapping between GSI and IRQ on MID */
<span class="p_del">-	gsi = pdata-&gt;irq;</span>
 	ioapic_set_alloc_attr(&amp;info, cpu_to_node(0), 1, 0);
 	irq = mp_map_gsi_to_irq(gsi, IOAPIC_MAP_ALLOC, &amp;info);
 	if (irq &lt; 0) {
<span class="p_chunk">@@ -44,11 +44,11 @@</span> <span class="p_context"> static int tangier_probe(struct platform_device *pdev)</span>
 		return irq;
 	}
 
<span class="p_add">+	pdata-&gt;irq = irq;</span>
 	return 0;
 }
 
 static struct intel_mid_wdt_pdata tangier_pdata = {
<span class="p_del">-	.irq = TANGIER_EXT_TIMER0_MSI,</span>
 	.probe = tangier_probe,
 };
 
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/intel-mid.c b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">index 12a272582cdc..86676cec99a1 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_chunk">@@ -183,6 +183,7 @@</span> <span class="p_context"> void __init x86_intel_mid_early_setup(void)</span>
 
 	x86_init.timers.timer_init = intel_mid_time_init;
 	x86_init.timers.setup_percpu_clockev = x86_init_noop;
<span class="p_add">+	x86_init.timers.wallclock_init = intel_mid_rtc_init;</span>
 
 	x86_init.irqs.pre_vector_init = x86_init_noop;
 
<span class="p_chunk">@@ -191,7 +192,6 @@</span> <span class="p_context"> void __init x86_intel_mid_early_setup(void)</span>
 	x86_cpuinit.setup_percpu_clockev = apbt_setup_secondary_clock;
 
 	x86_platform.calibrate_tsc = intel_mid_calibrate_tsc;
<span class="p_del">-	x86_init.timers.wallclock_init = intel_mid_rtc_init;</span>
 	x86_platform.get_nmi_reason = intel_mid_get_nmi_reason;
 
 	x86_init.pci.init = intel_mid_pci_init;
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/pwr.c b/arch/x86/platform/intel-mid/pwr.c</span>
<span class="p_header">index ef03852ea6e8..49ec5b94c71f 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/pwr.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/pwr.c</span>
<span class="p_chunk">@@ -444,7 +444,7 @@</span> <span class="p_context"> static int mid_set_initial_state(struct mid_pwr *pwr, const u32 *states)</span>
 static int pnw_set_initial_state(struct mid_pwr *pwr)
 {
 	/* On Penwell SRAM must stay powered on */
<span class="p_del">-	const u32 states[] = {</span>
<span class="p_add">+	static const u32 states[] = {</span>
 		0xf00fffff,		/* PM_SSC(0) */
 		0xffffffff,		/* PM_SSC(1) */
 		0xffffffff,		/* PM_SSC(2) */
<span class="p_chunk">@@ -455,7 +455,7 @@</span> <span class="p_context"> static int pnw_set_initial_state(struct mid_pwr *pwr)</span>
 
 static int tng_set_initial_state(struct mid_pwr *pwr)
 {
<span class="p_del">-	const u32 states[] = {</span>
<span class="p_add">+	static const u32 states[] = {</span>
 		0xffffffff,		/* PM_SSC(0) */
 		0xffffffff,		/* PM_SSC(1) */
 		0xffffffff,		/* PM_SSC(2) */
<span class="p_header">diff --git a/drivers/hv/Kconfig b/drivers/hv/Kconfig</span>
<span class="p_header">index c29cd5387a35..50b89ea0e60f 100644</span>
<span class="p_header">--- a/drivers/hv/Kconfig</span>
<span class="p_header">+++ b/drivers/hv/Kconfig</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"> menu &quot;Microsoft Hyper-V guest support&quot;</span>
 config HYPERV
 	tristate &quot;Microsoft Hyper-V client drivers&quot;
 	depends on X86 &amp;&amp; ACPI &amp;&amp; PCI &amp;&amp; X86_LOCAL_APIC &amp;&amp; HYPERVISOR_GUEST
<span class="p_add">+	select PARAVIRT</span>
 	help
 	  Select this option to run Linux as a Hyper-V client operating
 	  system.
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index 4bbb8dea4727..dc590195a74e 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -599,7 +599,7 @@</span> <span class="p_context"> static void init_vp_index(struct vmbus_channel *channel, u16 dev_type)</span>
 		 */
 		channel-&gt;numa_node = 0;
 		channel-&gt;target_cpu = 0;
<span class="p_del">-		channel-&gt;target_vp = hv_context.vp_index[0];</span>
<span class="p_add">+		channel-&gt;target_vp = hv_cpu_number_to_vp_number(0);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -683,7 +683,7 @@</span> <span class="p_context"> static void init_vp_index(struct vmbus_channel *channel, u16 dev_type)</span>
 	}
 
 	channel-&gt;target_cpu = cur_cpu;
<span class="p_del">-	channel-&gt;target_vp = hv_context.vp_index[cur_cpu];</span>
<span class="p_add">+	channel-&gt;target_vp = hv_cpu_number_to_vp_number(cur_cpu);</span>
 }
 
 static void vmbus_wait_for_unload(void)
<span class="p_chunk">@@ -805,21 +805,12 @@</span> <span class="p_context"> static void vmbus_onoffer(struct vmbus_channel_message_header *hdr)</span>
 	/*
 	 * Setup state for signalling the host.
 	 */
<span class="p_del">-	newchannel-&gt;sig_event = (struct hv_input_signal_event *)</span>
<span class="p_del">-				(ALIGN((unsigned long)</span>
<span class="p_del">-				&amp;newchannel-&gt;sig_buf,</span>
<span class="p_del">-				HV_HYPERCALL_PARAM_ALIGN));</span>
<span class="p_del">-</span>
<span class="p_del">-	newchannel-&gt;sig_event-&gt;connectionid.asu32 = 0;</span>
<span class="p_del">-	newchannel-&gt;sig_event-&gt;connectionid.u.id = VMBUS_EVENT_CONNECTION_ID;</span>
<span class="p_del">-	newchannel-&gt;sig_event-&gt;flag_number = 0;</span>
<span class="p_del">-	newchannel-&gt;sig_event-&gt;rsvdz = 0;</span>
<span class="p_add">+	newchannel-&gt;sig_event = VMBUS_EVENT_CONNECTION_ID;</span>
 
 	if (vmbus_proto_version != VERSION_WS2008) {
 		newchannel-&gt;is_dedicated_interrupt =
 				(offer-&gt;is_dedicated_interrupt != 0);
<span class="p_del">-		newchannel-&gt;sig_event-&gt;connectionid.u.id =</span>
<span class="p_del">-				offer-&gt;connection_id;</span>
<span class="p_add">+		newchannel-&gt;sig_event = offer-&gt;connection_id;</span>
 	}
 
 	memcpy(&amp;newchannel-&gt;offermsg, offer,
<span class="p_chunk">@@ -1228,8 +1219,7 @@</span> <span class="p_context"> struct vmbus_channel *vmbus_get_outgoing_channel(struct vmbus_channel *primary)</span>
 		return outgoing_channel;
 	}
 
<span class="p_del">-	cur_cpu = hv_context.vp_index[get_cpu()];</span>
<span class="p_del">-	put_cpu();</span>
<span class="p_add">+	cur_cpu = hv_cpu_number_to_vp_number(smp_processor_id());</span>
 	list_for_each_safe(cur, tmp, &amp;primary-&gt;sc_list) {
 		cur_channel = list_entry(cur, struct vmbus_channel, sc_list);
 		if (cur_channel-&gt;state != CHANNEL_OPENED_STATE)
<span class="p_header">diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c</span>
<span class="p_header">index 59c11ff90d12..f41901f80b64 100644</span>
<span class="p_header">--- a/drivers/hv/connection.c</span>
<span class="p_header">+++ b/drivers/hv/connection.c</span>
<span class="p_chunk">@@ -32,6 +32,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/hyperv.h&gt;
 #include &lt;linux/export.h&gt;
 #include &lt;asm/hyperv.h&gt;
<span class="p_add">+#include &lt;asm/mshyperv.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;hyperv_vmbus.h&quot;
 
 
<span class="p_chunk">@@ -94,7 +96,8 @@</span> <span class="p_context"> static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,</span>
 	 * the CPU attempting to connect may not be CPU 0.
 	 */
 	if (version &gt;= VERSION_WIN8_1) {
<span class="p_del">-		msg-&gt;target_vcpu = hv_context.vp_index[smp_processor_id()];</span>
<span class="p_add">+		msg-&gt;target_vcpu =</span>
<span class="p_add">+			hv_cpu_number_to_vp_number(smp_processor_id());</span>
 		vmbus_connection.connect_cpu = smp_processor_id();
 	} else {
 		msg-&gt;target_vcpu = 0;
<span class="p_chunk">@@ -406,6 +409,6 @@</span> <span class="p_context"> void vmbus_set_event(struct vmbus_channel *channel)</span>
 	if (!channel-&gt;is_dedicated_interrupt)
 		vmbus_send_interrupt(child_relid);
 
<span class="p_del">-	hv_do_hypercall(HVCALL_SIGNAL_EVENT, channel-&gt;sig_event, NULL);</span>
<span class="p_add">+	hv_do_fast_hypercall8(HVCALL_SIGNAL_EVENT, channel-&gt;sig_event);</span>
 }
 EXPORT_SYMBOL_GPL(vmbus_set_event);
<span class="p_header">diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c</span>
<span class="p_header">index 2ea12207caa0..8267439dd1ee 100644</span>
<span class="p_header">--- a/drivers/hv/hv.c</span>
<span class="p_header">+++ b/drivers/hv/hv.c</span>
<span class="p_chunk">@@ -234,7 +234,6 @@</span> <span class="p_context"> int hv_synic_init(unsigned int cpu)</span>
 	union hv_synic_siefp siefp;
 	union hv_synic_sint shared_sint;
 	union hv_synic_scontrol sctrl;
<span class="p_del">-	u64 vp_index;</span>
 
 	/* Setup the Synic&#39;s message page */
 	hv_get_simp(simp.as_uint64);
<span class="p_chunk">@@ -276,14 +275,6 @@</span> <span class="p_context"> int hv_synic_init(unsigned int cpu)</span>
 	hv_context.synic_initialized = true;
 
 	/*
<span class="p_del">-	 * Setup the mapping between Hyper-V&#39;s notion</span>
<span class="p_del">-	 * of cpuid and Linux&#39; notion of cpuid.</span>
<span class="p_del">-	 * This array will be indexed using Linux cpuid.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	hv_get_vp_index(vp_index);</span>
<span class="p_del">-	hv_context.vp_index[cpu] = (u32)vp_index;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
 	 * Register the per-cpu clockevent source.
 	 */
 	if (ms_hyperv.features &amp; HV_X64_MSR_SYNTIMER_AVAILABLE)
<span class="p_header">diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h</span>
<span class="p_header">index 1b6a5e0dfa75..49569f8fe038 100644</span>
<span class="p_header">--- a/drivers/hv/hyperv_vmbus.h</span>
<span class="p_header">+++ b/drivers/hv/hyperv_vmbus.h</span>
<span class="p_chunk">@@ -229,17 +229,6 @@</span> <span class="p_context"> struct hv_context {</span>
 	struct hv_per_cpu_context __percpu *cpu_context;
 
 	/*
<span class="p_del">-	 * Hypervisor&#39;s notion of virtual processor ID is different from</span>
<span class="p_del">-	 * Linux&#39; notion of CPU ID. This information can only be retrieved</span>
<span class="p_del">-	 * in the context of the calling CPU. Setup a map for easy access</span>
<span class="p_del">-	 * to this information:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * vp_index[a] is the Hyper-V&#39;s processor ID corresponding to</span>
<span class="p_del">-	 * Linux cpuid &#39;a&#39;.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	u32 vp_index[NR_CPUS];</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
 	 * To manage allocations in a NUMA node.
 	 * Array indexed by numa node ID.
 	 */
<span class="p_header">diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c</span>
<span class="p_header">index ed84e96715a0..c7e7d6db2d21 100644</span>
<span class="p_header">--- a/drivers/hv/vmbus_drv.c</span>
<span class="p_header">+++ b/drivers/hv/vmbus_drv.c</span>
<span class="p_chunk">@@ -1451,23 +1451,6 @@</span> <span class="p_context"> void vmbus_free_mmio(resource_size_t start, resource_size_t size)</span>
 }
 EXPORT_SYMBOL_GPL(vmbus_free_mmio);
 
<span class="p_del">-/**</span>
<span class="p_del">- * vmbus_cpu_number_to_vp_number() - Map CPU to VP.</span>
<span class="p_del">- * @cpu_number: CPU number in Linux terms</span>
<span class="p_del">- *</span>
<span class="p_del">- * This function returns the mapping between the Linux processor</span>
<span class="p_del">- * number and the hypervisor&#39;s virtual processor number, useful</span>
<span class="p_del">- * in making hypercalls and such that talk about specific</span>
<span class="p_del">- * processors.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Return: Virtual processor number in Hyper-V terms</span>
<span class="p_del">- */</span>
<span class="p_del">-int vmbus_cpu_number_to_vp_number(int cpu_number)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return hv_context.vp_index[cpu_number];</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(vmbus_cpu_number_to_vp_number);</span>
<span class="p_del">-</span>
 static int vmbus_acpi_add(struct acpi_device *device)
 {
 	acpi_status result;
<span class="p_header">diff --git a/drivers/pci/host/pci-hyperv.c b/drivers/pci/host/pci-hyperv.c</span>
<span class="p_header">index 415dcc69a502..aba041438566 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-hyperv.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-hyperv.c</span>
<span class="p_chunk">@@ -562,52 +562,6 @@</span> <span class="p_context"> static void put_pcichild(struct hv_pci_dev *hv_pcidev,</span>
 static void get_hvpcibus(struct hv_pcibus_device *hv_pcibus);
 static void put_hvpcibus(struct hv_pcibus_device *hv_pcibus);
 
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Temporary CPU to vCPU mapping to address transitioning</span>
<span class="p_del">- * vmbus_cpu_number_to_vp_number() being migrated to</span>
<span class="p_del">- * hv_cpu_number_to_vp_number() in a separate patch. Once that patch</span>
<span class="p_del">- * has been picked up in the main line, remove this code here and use</span>
<span class="p_del">- * the official code.</span>
<span class="p_del">- */</span>
<span class="p_del">-static struct hv_tmpcpumap</span>
<span class="p_del">-{</span>
<span class="p_del">-	bool initialized;</span>
<span class="p_del">-	u32 vp_index[NR_CPUS];</span>
<span class="p_del">-} hv_tmpcpumap;</span>
<span class="p_del">-</span>
<span class="p_del">-static void hv_tmpcpumap_init_cpu(void *_unused)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int cpu = smp_processor_id();</span>
<span class="p_del">-	u64 vp_index;</span>
<span class="p_del">-</span>
<span class="p_del">-	hv_get_vp_index(vp_index);</span>
<span class="p_del">-</span>
<span class="p_del">-	hv_tmpcpumap.vp_index[cpu] = vp_index;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void hv_tmpcpumap_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (hv_tmpcpumap.initialized)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(hv_tmpcpumap.vp_index, -1, sizeof(hv_tmpcpumap.vp_index));</span>
<span class="p_del">-	on_each_cpu(hv_tmpcpumap_init_cpu, NULL, true);</span>
<span class="p_del">-	hv_tmpcpumap.initialized = true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * hv_tmp_cpu_nr_to_vp_nr() - Convert Linux CPU nr to Hyper-V vCPU nr</span>
<span class="p_del">- *</span>
<span class="p_del">- * Remove once vmbus_cpu_number_to_vp_number() has been converted to</span>
<span class="p_del">- * hv_cpu_number_to_vp_number() and replace callers appropriately.</span>
<span class="p_del">- */</span>
<span class="p_del">-static u32 hv_tmp_cpu_nr_to_vp_nr(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return hv_tmpcpumap.vp_index[cpu];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 /**
  * devfn_to_wslot() - Convert from Linux PCI slot to Windows
  * @devfn:	The Linux representation of PCI slot
<span class="p_chunk">@@ -971,7 +925,7 @@</span> <span class="p_context"> static void hv_irq_unmask(struct irq_data *data)</span>
 		var_size = 1 + HV_VP_SET_BANK_COUNT_MAX;
 
 		for_each_cpu_and(cpu, dest, cpu_online_mask) {
<span class="p_del">-			cpu_vmbus = hv_tmp_cpu_nr_to_vp_nr(cpu);</span>
<span class="p_add">+			cpu_vmbus = hv_cpu_number_to_vp_number(cpu);</span>
 
 			if (cpu_vmbus &gt;= HV_VP_SET_BANK_COUNT_MAX * 64) {
 				dev_err(&amp;hbus-&gt;hdev-&gt;device,
<span class="p_chunk">@@ -986,7 +940,7 @@</span> <span class="p_context"> static void hv_irq_unmask(struct irq_data *data)</span>
 	} else {
 		for_each_cpu_and(cpu, dest, cpu_online_mask) {
 			params-&gt;int_target.vp_mask |=
<span class="p_del">-				(1ULL &lt;&lt; hv_tmp_cpu_nr_to_vp_nr(cpu));</span>
<span class="p_add">+				(1ULL &lt;&lt; hv_cpu_number_to_vp_number(cpu));</span>
 		}
 	}
 
<span class="p_chunk">@@ -1063,7 +1017,7 @@</span> <span class="p_context"> static u32 hv_compose_msi_req_v2(</span>
 	 */
 	cpu = cpumask_first_and(affinity, cpu_online_mask);
 	int_pkt-&gt;int_desc.processor_array[0] =
<span class="p_del">-		hv_tmp_cpu_nr_to_vp_nr(cpu);</span>
<span class="p_add">+		hv_cpu_number_to_vp_number(cpu);</span>
 	int_pkt-&gt;int_desc.processor_count = 1;
 
 	return sizeof(*int_pkt);
<span class="p_chunk">@@ -2490,8 +2444,6 @@</span> <span class="p_context"> static int hv_pci_probe(struct hv_device *hdev,</span>
 		return -ENOMEM;
 	hbus-&gt;state = hv_pcibus_init;
 
<span class="p_del">-	hv_tmpcpumap_init();</span>
<span class="p_del">-</span>
 	/*
 	 * The PCI bus &quot;domain&quot; is what is called &quot;segment&quot; in ACPI and
 	 * other specs.  Pull it from the instance ID, to get something
<span class="p_header">diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h</span>
<span class="p_header">index b7d7bbec74e0..e2a4fa57f110 100644</span>
<span class="p_header">--- a/include/linux/hyperv.h</span>
<span class="p_header">+++ b/include/linux/hyperv.h</span>
<span class="p_chunk">@@ -677,18 +677,6 @@</span> <span class="p_context"> union hv_connection_id {</span>
 	} u;
 };
 
<span class="p_del">-/* Definition of the hv_signal_event hypercall input structure. */</span>
<span class="p_del">-struct hv_input_signal_event {</span>
<span class="p_del">-	union hv_connection_id connectionid;</span>
<span class="p_del">-	u16 flag_number;</span>
<span class="p_del">-	u16 rsvdz;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct hv_input_signal_event_buffer {</span>
<span class="p_del">-	u64 align8;</span>
<span class="p_del">-	struct hv_input_signal_event event;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 enum hv_numa_policy {
 	HV_BALANCED = 0,
 	HV_LOCALIZED,
<span class="p_chunk">@@ -770,8 +758,7 @@</span> <span class="p_context"> struct vmbus_channel {</span>
 	} callback_mode;
 
 	bool is_dedicated_interrupt;
<span class="p_del">-	struct hv_input_signal_event_buffer sig_buf;</span>
<span class="p_del">-	struct hv_input_signal_event *sig_event;</span>
<span class="p_add">+	u64 sig_event;</span>
 
 	/*
 	 * Starting with win8, this field will be used to specify
<span class="p_chunk">@@ -1186,8 +1173,6 @@</span> <span class="p_context"> int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,</span>
 			resource_size_t size, resource_size_t align,
 			bool fb_overlap_ok);
 void vmbus_free_mmio(resource_size_t start, resource_size_t size);
<span class="p_del">-int vmbus_cpu_number_to_vp_number(int cpu_number);</span>
<span class="p_del">-u64 hv_do_hypercall(u64 control, void *input, void *output);</span>
 
 /*
  * GUID definitions of various offer types - services offered to the guest.

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



