
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3] x86/power/64: Fix kernel text mapping corruption during image restoration - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3] x86/power/64: Fix kernel text mapping corruption during image restoration</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=68541">Rafael Wysocki</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 30, 2016, 2:55 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1829549.Og2FdTtl4p@vostro.rjw.lan&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9206537/mbox/"
   >mbox</a>
|
   <a href="/patch/9206537/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9206537/">/patch/9206537/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	012A96075F for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Jun 2016 02:51:19 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E7FE92856F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Jun 2016 02:51:18 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id DC4222860B; Thu, 30 Jun 2016 02:51:18 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=unavailable version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0D3F6285FD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Jun 2016 02:51:17 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751757AbcF3Cu6 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 29 Jun 2016 22:50:58 -0400
Received: from cloudserver094114.home.net.pl ([79.96.170.134]:47792 &quot;HELO
	cloudserver094114.home.net.pl&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with SMTP id S1751450AbcF3Cu5 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 29 Jun 2016 22:50:57 -0400
Received: from 217.96.253.192.ipv4.supernova.orange.pl (217.96.253.192)
	(HELO vostro.rjw.lan)
	by serwer1319399.home.pl (79.96.170.134) with SMTP (IdeaSmtpServer
	v0.80.2) id fcaaea41e0fbd4c5; Thu, 30 Jun 2016 04:50:54 +0200
From: &quot;Rafael J. Wysocki&quot; &lt;rjw@rjwysocki.net&gt;
To: Logan Gunthorpe &lt;logang@deltatee.com&gt;
Cc: Kees Cook &lt;keescook@chromium.org&gt;, Borislav Petkov &lt;bp@alien8.de&gt;,
	Linus Torvalds &lt;torvalds@linux-foundation.org&gt;,
	&quot;Rafael J. Wysocki&quot; &lt;rafael@kernel.org&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Ingo Molnar &lt;mingo@kernel.org&gt;,
	Peter Zijlstra &lt;peterz@infradead.org&gt;,
	lkml &lt;linux-kernel@vger.kernel.org&gt;,
	&quot;Rafael J. Wysocki&quot; &lt;rafael.j.wysocki@intel.com&gt;,
	Andy Lutomirski &lt;luto@kernel.org&gt;, Brian Gerst &lt;brgerst@gmail.com&gt;,
	Denys Vlasenko &lt;dvlasenk@redhat.com&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Linux PM list &lt;linux-pm@vger.kernel.org&gt;,
	Stephen Smalley &lt;sds@tycho.nsa.gov&gt;
Subject: Re: [PATCH v3] x86/power/64: Fix kernel text mapping corruption
	during image restoration
Date: Thu, 30 Jun 2016 04:55:24 +0200
Message-ID: &lt;1829549.Og2FdTtl4p@vostro.rjw.lan&gt;
User-Agent: KMail/4.11.5 (Linux/4.5.0-rc1+; KDE/4.11.5; x86_64; ; )
In-Reply-To: &lt;2398306.qXx6AZtdS5@vostro.rjw.lan&gt;
References: &lt;20160617105435.GB15997@pd.tnic&gt;
	&lt;65d98ad4-124b-64e4-84e5-877af71a1d44@deltatee.com&gt;
	&lt;2398306.qXx6AZtdS5@vostro.rjw.lan&gt;
MIME-Version: 1.0
Content-Transfer-Encoding: 7Bit
Content-Type: text/plain; charset=&quot;utf-8&quot;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=68541">Rafael Wysocki</a> - June 30, 2016, 2:55 a.m.</div>
<pre class="content">
On Thursday, June 30, 2016 04:20:43 AM Rafael J. Wysocki wrote:
<span class="quote">&gt; On Wednesday, June 29, 2016 07:52:18 PM Logan Gunthorpe wrote:</span>
<span class="quote">&gt; &gt; Hey Raf,</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Sorry to report that although the patch works the majority of the time, </span>
<span class="quote">&gt; &gt; I just got a suspicious kernel panic during resume.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; It said:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &quot;kernel tried to execute NX protected page - exploit attempt? (uid: 0)&quot;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; You can find a photo of the panic here:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; http://staff.deltatee.com/~logang/panic.jpg</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks for the report!</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That&#39;s not what Boris was seeing at least.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It looks like clearing the NX bit for relocated_restore_code in</span>
<span class="quote">&gt; relocate_restore_code() didn&#39;t work for some reason.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t see why it may not work ATM, I need to have a fresh look at that</span>
<span class="quote">&gt; tomorrow.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I had hoped to be able to fix this bug for 4.7, but it looks like it will</span>
<span class="quote">&gt; miss the mark after all.  Oh well.</span>

The only thing that comes to mind at this point is that TLBs should be flushed
after page tables changes, so please apply the appended and let me know
if you see this panic any more with it.

Thanks,
Rafael


---
 arch/x86/power/hibernate_64.c     |   92 +++++++++++++++++++++++++++++++++-----
 arch/x86/power/hibernate_asm_64.S |   55 +++++++++-------------
 2 files changed, 104 insertions(+), 43 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131441">Logan Gunthorpe</a> - June 30, 2016, 3:56 a.m.</div>
<pre class="content">
On 29/06/16 08:55 PM, Rafael J. Wysocki wrote:
<span class="quote">
&gt; The only thing that comes to mind at this point is that TLBs should be flushed</span>
<span class="quote">&gt; after page tables changes, so please apply the appended and let me know</span>
<span class="quote">&gt; if you see this panic any more with it.</span>


Ok, I&#39;ll build a new kernel tomorrow. But keep in mind the panic is 
pretty rare as I&#39;ve only seen it once so far after a couple dozen or so 
hibernates. So it may be hard to get a concrete yes or no on whether it 
fixes the issue.

I&#39;ve got a script to run a bunch of hibernates in a row. I usually only 
run it for a handful of iterations, but I&#39;ll try running it for much 
longer with this patch and let you know in a couple days.

Logan
<span class="quote">

&gt; Thanks,</span>
<span class="quote">&gt; Rafael</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/power/hibernate_64.c     |   92 +++++++++++++++++++++++++++++++++-----</span>
<span class="quote">&gt;  arch/x86/power/hibernate_asm_64.S |   55 +++++++++-------------</span>
<span class="quote">&gt;  2 files changed, 104 insertions(+), 43 deletions(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Index: linux-pm/arch/x86/power/hibernate_64.c</span>
<span class="quote">&gt; ===================================================================</span>
<span class="quote">&gt; --- linux-pm.orig/arch/x86/power/hibernate_64.c</span>
<span class="quote">&gt; +++ linux-pm/arch/x86/power/hibernate_64.c</span>
<span class="quote">&gt; @@ -19,6 +19,7 @@</span>
<span class="quote">&gt;  #include &lt;asm/mtrr.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/sections.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/suspend.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  /* Defined in hibernate_asm_64.S */</span>
<span class="quote">&gt;  extern asmlinkage __visible int restore_image(void);</span>
<span class="quote">&gt; @@ -28,6 +29,7 @@ extern asmlinkage __visible int restore_</span>
<span class="quote">&gt;   * kernel&#39;s text (this value is passed in the image header).</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  unsigned long restore_jump_address __visible;</span>
<span class="quote">&gt; +unsigned long jump_address_phys;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Value of the cr3 register from before the hibernation (this value is passed</span>
<span class="quote">&gt; @@ -37,7 +39,43 @@ unsigned long restore_cr3 __visible;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  pgd_t *temp_level4_pgt __visible;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -void *relocated_restore_code __visible;</span>
<span class="quote">&gt; +unsigned long relocated_restore_code __visible;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int set_up_temporary_text_mapping(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pmd_t *pmd;</span>
<span class="quote">&gt; +	pud_t *pud;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * The new mapping only has to cover the page containing the image</span>
<span class="quote">&gt; +	 * kernel&#39;s entry point (jump_address_phys), because the switch over to</span>
<span class="quote">&gt; +	 * it is carried out by relocated code running from a page allocated</span>
<span class="quote">&gt; +	 * specifically for this purpose and covered by the identity mapping, so</span>
<span class="quote">&gt; +	 * the temporary kernel text mapping is only needed for the final jump.</span>
<span class="quote">&gt; +	 * Moreover, in that mapping the virtual address of the image kernel&#39;s</span>
<span class="quote">&gt; +	 * entry point must be the same as its virtual address in the image</span>
<span class="quote">&gt; +	 * kernel (restore_jump_address), so the image kernel&#39;s</span>
<span class="quote">&gt; +	 * restore_registers() code doesn&#39;t find itself in a different area of</span>
<span class="quote">&gt; +	 * the virtual address space after switching over to the original page</span>
<span class="quote">&gt; +	 * tables used by the image kernel.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	pud = (pud_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="quote">&gt; +	if (!pud)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pmd = (pmd_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="quote">&gt; +	if (!pmd)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	set_pmd(pmd + pmd_index(restore_jump_address),</span>
<span class="quote">&gt; +		__pmd((jump_address_phys &amp; PMD_MASK) | __PAGE_KERNEL_LARGE_EXEC));</span>
<span class="quote">&gt; +	set_pud(pud + pud_index(restore_jump_address),</span>
<span class="quote">&gt; +		__pud(__pa(pmd) | _KERNPG_TABLE));</span>
<span class="quote">&gt; +	set_pgd(temp_level4_pgt + pgd_index(restore_jump_address),</span>
<span class="quote">&gt; +		__pgd(__pa(pud) | _KERNPG_TABLE));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  static void *alloc_pgt_page(void *context)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; @@ -59,9 +97,10 @@ static int set_up_temporary_mappings(voi</span>
<span class="quote">&gt;  	if (!temp_level4_pgt)</span>
<span class="quote">&gt;  		return -ENOMEM;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -	/* It is safe to reuse the original kernel mapping */</span>
<span class="quote">&gt; -	set_pgd(temp_level4_pgt + pgd_index(__START_KERNEL_map),</span>
<span class="quote">&gt; -		init_level4_pgt[pgd_index(__START_KERNEL_map)]);</span>
<span class="quote">&gt; +	/* Prepare a temporary mapping for the kernel text */</span>
<span class="quote">&gt; +	result = set_up_temporary_text_mapping();</span>
<span class="quote">&gt; +	if (result)</span>
<span class="quote">&gt; +		return result;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	/* Set up the direct mapping from scratch */</span>
<span class="quote">&gt;  	for (i = 0; i &lt; nr_pfn_mapped; i++) {</span>
<span class="quote">&gt; @@ -78,19 +117,45 @@ static int set_up_temporary_mappings(voi</span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +static int relocate_restore_code(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pgd_t *pgd;</span>
<span class="quote">&gt; +	pmd_t *pmd;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	relocated_restore_code = get_safe_page(GFP_ATOMIC);</span>
<span class="quote">&gt; +	if (!relocated_restore_code)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	memcpy((void *)relocated_restore_code, &amp;core_restore_code, PAGE_SIZE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Make the page containing the relocated code executable */</span>
<span class="quote">&gt; +	pgd = (pgd_t *)__va(read_cr3()) + pgd_index(relocated_restore_code);</span>
<span class="quote">&gt; +	pmd = pmd_offset(pud_offset(pgd, relocated_restore_code),</span>
<span class="quote">&gt; +			 relocated_restore_code);</span>
<span class="quote">&gt; +	if (pmd_large(*pmd)) {</span>
<span class="quote">&gt; +		set_pmd(pmd, __pmd(pmd_val(*pmd) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		pte_t *pte = pte_offset_kernel(pmd, relocated_restore_code);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	flush_tlb_all();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  int swsusp_arch_resume(void)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	int error;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	/* We have got enough memory and from now on we cannot recover */</span>
<span class="quote">&gt; -	if ((error = set_up_temporary_mappings()))</span>
<span class="quote">&gt; +	error = set_up_temporary_mappings();</span>
<span class="quote">&gt; +	if (error)</span>
<span class="quote">&gt;  		return error;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -	relocated_restore_code = (void *)get_safe_page(GFP_ATOMIC);</span>
<span class="quote">&gt; -	if (!relocated_restore_code)</span>
<span class="quote">&gt; -		return -ENOMEM;</span>
<span class="quote">&gt; -	memcpy(relocated_restore_code, &amp;core_restore_code,</span>
<span class="quote">&gt; -	       &amp;restore_registers - &amp;core_restore_code);</span>
<span class="quote">&gt; +	error = relocate_restore_code();</span>
<span class="quote">&gt; +	if (error)</span>
<span class="quote">&gt; +		return error;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	restore_image();</span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt; @@ -109,11 +174,12 @@ int pfn_is_nosave(unsigned long pfn)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  struct restore_data_record {</span>
<span class="quote">&gt;  	unsigned long jump_address;</span>
<span class="quote">&gt; +	unsigned long jump_address_phys;</span>
<span class="quote">&gt;  	unsigned long cr3;</span>
<span class="quote">&gt;  	unsigned long magic;</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -#define RESTORE_MAGIC	0x0123456789ABCDEFUL</span>
<span class="quote">&gt; +#define RESTORE_MAGIC	0x123456789ABCDEF0UL</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  /**</span>
<span class="quote">&gt;   *	arch_hibernation_header_save - populate the architecture specific part</span>
<span class="quote">&gt; @@ -126,7 +192,8 @@ int arch_hibernation_header_save(void *a</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	if (max_size &lt; sizeof(struct restore_data_record))</span>
<span class="quote">&gt;  		return -EOVERFLOW;</span>
<span class="quote">&gt; -	rdr-&gt;jump_address = restore_jump_address;</span>
<span class="quote">&gt; +	rdr-&gt;jump_address = (unsigned long)&amp;restore_registers;</span>
<span class="quote">&gt; +	rdr-&gt;jump_address_phys = __pa_symbol(&amp;restore_registers);</span>
<span class="quote">&gt;  	rdr-&gt;cr3 = restore_cr3;</span>
<span class="quote">&gt;  	rdr-&gt;magic = RESTORE_MAGIC;</span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt; @@ -142,6 +209,7 @@ int arch_hibernation_header_restore(void</span>
<span class="quote">&gt;  	struct restore_data_record *rdr = addr;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	restore_jump_address = rdr-&gt;jump_address;</span>
<span class="quote">&gt; +	jump_address_phys = rdr-&gt;jump_address_phys;</span>
<span class="quote">&gt;  	restore_cr3 = rdr-&gt;cr3;</span>
<span class="quote">&gt;  	return (rdr-&gt;magic == RESTORE_MAGIC) ? 0 : -EINVAL;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt; Index: linux-pm/arch/x86/power/hibernate_asm_64.S</span>
<span class="quote">&gt; ===================================================================</span>
<span class="quote">&gt; --- linux-pm.orig/arch/x86/power/hibernate_asm_64.S</span>
<span class="quote">&gt; +++ linux-pm/arch/x86/power/hibernate_asm_64.S</span>
<span class="quote">&gt; @@ -44,9 +44,6 @@ ENTRY(swsusp_arch_suspend)</span>
<span class="quote">&gt;  	pushfq</span>
<span class="quote">&gt;  	popq	pt_regs_flags(%rax)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -	/* save the address of restore_registers */</span>
<span class="quote">&gt; -	movq	$restore_registers, %rax</span>
<span class="quote">&gt; -	movq	%rax, restore_jump_address(%rip)</span>
<span class="quote">&gt;  	/* save cr3 */</span>
<span class="quote">&gt;  	movq	%cr3, %rax</span>
<span class="quote">&gt;  	movq	%rax, restore_cr3(%rip)</span>
<span class="quote">&gt; @@ -57,31 +54,34 @@ ENTRY(swsusp_arch_suspend)</span>
<span class="quote">&gt;  ENDPROC(swsusp_arch_suspend)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  ENTRY(restore_image)</span>
<span class="quote">&gt; -	/* switch to temporary page tables */</span>
<span class="quote">&gt; -	movq	$__PAGE_OFFSET, %rdx</span>
<span class="quote">&gt; -	movq	temp_level4_pgt(%rip), %rax</span>
<span class="quote">&gt; -	subq	%rdx, %rax</span>
<span class="quote">&gt; -	movq	%rax, %cr3</span>
<span class="quote">&gt; -	/* Flush TLB */</span>
<span class="quote">&gt; -	movq	mmu_cr4_features(%rip), %rax</span>
<span class="quote">&gt; -	movq	%rax, %rdx</span>
<span class="quote">&gt; -	andq	$~(X86_CR4_PGE), %rdx</span>
<span class="quote">&gt; -	movq	%rdx, %cr4;  # turn off PGE</span>
<span class="quote">&gt; -	movq	%cr3, %rcx;  # flush TLB</span>
<span class="quote">&gt; -	movq	%rcx, %cr3;</span>
<span class="quote">&gt; -	movq	%rax, %cr4;  # turn PGE back on</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  	/* prepare to jump to the image kernel */</span>
<span class="quote">&gt; -	movq	restore_jump_address(%rip), %rax</span>
<span class="quote">&gt; -	movq	restore_cr3(%rip), %rbx</span>
<span class="quote">&gt; +	movq	restore_jump_address(%rip), %r8</span>
<span class="quote">&gt; +	movq	restore_cr3(%rip), %r9</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* prepare to switch to temporary page tables */</span>
<span class="quote">&gt; +	movq	temp_level4_pgt(%rip), %rax</span>
<span class="quote">&gt; +	movq	mmu_cr4_features(%rip), %rbx</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	/* prepare to copy image data to their original locations */</span>
<span class="quote">&gt;  	movq	restore_pblist(%rip), %rdx</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* jump to relocated restore code */</span>
<span class="quote">&gt;  	movq	relocated_restore_code(%rip), %rcx</span>
<span class="quote">&gt;  	jmpq	*%rcx</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	/* code below has been relocated to a safe page */</span>
<span class="quote">&gt;  ENTRY(core_restore_code)</span>
<span class="quote">&gt; +	/* switch to temporary page tables */</span>
<span class="quote">&gt; +	movq	$__PAGE_OFFSET, %rcx</span>
<span class="quote">&gt; +	subq	%rcx, %rax</span>
<span class="quote">&gt; +	movq	%rax, %cr3</span>
<span class="quote">&gt; +	/* flush TLB */</span>
<span class="quote">&gt; +	movq	%rbx, %rcx</span>
<span class="quote">&gt; +	andq	$~(X86_CR4_PGE), %rcx</span>
<span class="quote">&gt; +	movq	%rcx, %cr4;  # turn off PGE</span>
<span class="quote">&gt; +	movq	%cr3, %rcx;  # flush TLB</span>
<span class="quote">&gt; +	movq	%rcx, %cr3;</span>
<span class="quote">&gt; +	movq	%rbx, %cr4;  # turn PGE back on</span>
<span class="quote">&gt;  .Lloop:</span>
<span class="quote">&gt;  	testq	%rdx, %rdx</span>
<span class="quote">&gt;  	jz	.Ldone</span>
<span class="quote">&gt; @@ -96,24 +96,17 @@ ENTRY(core_restore_code)</span>
<span class="quote">&gt;  	/* progress to the next pbe */</span>
<span class="quote">&gt;  	movq	pbe_next(%rdx), %rdx</span>
<span class="quote">&gt;  	jmp	.Lloop</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  .Ldone:</span>
<span class="quote">&gt;  	/* jump to the restore_registers address from the image header */</span>
<span class="quote">&gt; -	jmpq	*%rax</span>
<span class="quote">&gt; -	/*</span>
<span class="quote">&gt; -	 * NOTE: This assumes that the boot kernel&#39;s text mapping covers the</span>
<span class="quote">&gt; -	 * image kernel&#39;s page containing restore_registers and the address of</span>
<span class="quote">&gt; -	 * this page is the same as in the image kernel&#39;s text mapping (it</span>
<span class="quote">&gt; -	 * should always be true, because the text mapping is linear, starting</span>
<span class="quote">&gt; -	 * from 0, and is supposed to cover the entire kernel text for every</span>
<span class="quote">&gt; -	 * kernel).</span>
<span class="quote">&gt; -	 *</span>
<span class="quote">&gt; -	 * code below belongs to the image kernel</span>
<span class="quote">&gt; -	 */</span>
<span class="quote">&gt; +	jmpq	*%r8</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +	 /* code below belongs to the image kernel */</span>
<span class="quote">&gt; +	.align PAGE_SIZE</span>
<span class="quote">&gt;  ENTRY(restore_registers)</span>
<span class="quote">&gt;  	FRAME_BEGIN</span>
<span class="quote">&gt;  	/* go back to the original page tables */</span>
<span class="quote">&gt; -	movq    %rbx, %cr3</span>
<span class="quote">&gt; +	movq    %r9, %cr3</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	/* Flush TLB, including &quot;global&quot; things (vmalloc) */</span>
<span class="quote">&gt;  	movq	mmu_cr4_features(%rip), %rax</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=99561">Rafael J. Wysocki</a> - June 30, 2016, 12:16 p.m.</div>
<pre class="content">
On Thu, Jun 30, 2016 at 5:56 AM, Logan Gunthorpe &lt;logang@deltatee.com&gt; wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On 29/06/16 08:55 PM, Rafael J. Wysocki wrote:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; The only thing that comes to mind at this point is that TLBs should be</span>
<span class="quote">&gt;&gt; flushed</span>
<span class="quote">&gt;&gt; after page tables changes, so please apply the appended and let me know</span>
<span class="quote">&gt;&gt; if you see this panic any more with it.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Ok, I&#39;ll build a new kernel tomorrow.</span>

Well, please wait for a while.

I&#39;m looking at the panic log right now and the picture is a bit clearer now.
<span class="quote">
&gt; But keep in mind the panic is pretty</span>
<span class="quote">&gt; rare as I&#39;ve only seen it once so far after a couple dozen or so hibernates.</span>
<span class="quote">&gt; So it may be hard to get a concrete yes or no on whether it fixes the issue.</span>

Right.
<span class="quote">
&gt; I&#39;ve got a script to run a bunch of hibernates in a row. I usually only run</span>
<span class="quote">&gt; it for a handful of iterations, but I&#39;ll try running it for much longer with</span>
<span class="quote">&gt; this patch and let you know in a couple days.</span>

As I said, please wait a bit, there may be updates in the meantime. :-)

From looking at your panic log, the exception happened in
swsusp_arch_resume(), which probably covers restore_image() too,
because that is likely to go into swsusp_arch_resume() in line.

Next, the address in RIP (a) clearly is a page start and (b) is
relative to the identity mapping, so it most likely is the address
from relocated_restore_code.  Moreover, the RCX value is the same
address and the values in the other registers also match exactly the
situation before the jump to relocated_restore_code.  Thus the
exception was triggered by that jump beyond doubt.

Now, if you look above the Oops line, it becomes quite clear what
happened.  Namely, dump_pagetable() (arch/x86/mm/fault.c, line 524 in
4.6) prints the PGD, the PUD, the PMD and the PTE in that order,
unless the lower levels (PTE, PMD) are not present.  In your panic
log, only the PGD and PUD are present, meaning that this is a 1G page
and sure enough it has the NX bit set.

This case was clearly overlooked by relocate_restore_code(), so
updated patch will follow.

Thanks,
Rafael
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">Index: linux-pm/arch/x86/power/hibernate_64.c</span>
===================================================================
<span class="p_header">--- linux-pm.orig/arch/x86/power/hibernate_64.c</span>
<span class="p_header">+++ linux-pm/arch/x86/power/hibernate_64.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/mtrr.h&gt;
 #include &lt;asm/sections.h&gt;
 #include &lt;asm/suspend.h&gt;
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
 
 /* Defined in hibernate_asm_64.S */
 extern asmlinkage __visible int restore_image(void);
<span class="p_chunk">@@ -28,6 +29,7 @@</span> <span class="p_context"> extern asmlinkage __visible int restore_</span>
  * kernel&#39;s text (this value is passed in the image header).
  */
 unsigned long restore_jump_address __visible;
<span class="p_add">+unsigned long jump_address_phys;</span>
 
 /*
  * Value of the cr3 register from before the hibernation (this value is passed
<span class="p_chunk">@@ -37,7 +39,43 @@</span> <span class="p_context"> unsigned long restore_cr3 __visible;</span>
 
 pgd_t *temp_level4_pgt __visible;
 
<span class="p_del">-void *relocated_restore_code __visible;</span>
<span class="p_add">+unsigned long relocated_restore_code __visible;</span>
<span class="p_add">+</span>
<span class="p_add">+static int set_up_temporary_text_mapping(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The new mapping only has to cover the page containing the image</span>
<span class="p_add">+	 * kernel&#39;s entry point (jump_address_phys), because the switch over to</span>
<span class="p_add">+	 * it is carried out by relocated code running from a page allocated</span>
<span class="p_add">+	 * specifically for this purpose and covered by the identity mapping, so</span>
<span class="p_add">+	 * the temporary kernel text mapping is only needed for the final jump.</span>
<span class="p_add">+	 * Moreover, in that mapping the virtual address of the image kernel&#39;s</span>
<span class="p_add">+	 * entry point must be the same as its virtual address in the image</span>
<span class="p_add">+	 * kernel (restore_jump_address), so the image kernel&#39;s</span>
<span class="p_add">+	 * restore_registers() code doesn&#39;t find itself in a different area of</span>
<span class="p_add">+	 * the virtual address space after switching over to the original page</span>
<span class="p_add">+	 * tables used by the image kernel.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pud = (pud_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!pud)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd = (pmd_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!pmd)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_pmd(pmd + pmd_index(restore_jump_address),</span>
<span class="p_add">+		__pmd((jump_address_phys &amp; PMD_MASK) | __PAGE_KERNEL_LARGE_EXEC));</span>
<span class="p_add">+	set_pud(pud + pud_index(restore_jump_address),</span>
<span class="p_add">+		__pud(__pa(pmd) | _KERNPG_TABLE));</span>
<span class="p_add">+	set_pgd(temp_level4_pgt + pgd_index(restore_jump_address),</span>
<span class="p_add">+		__pgd(__pa(pud) | _KERNPG_TABLE));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
 static void *alloc_pgt_page(void *context)
 {
<span class="p_chunk">@@ -59,9 +97,10 @@</span> <span class="p_context"> static int set_up_temporary_mappings(voi</span>
 	if (!temp_level4_pgt)
 		return -ENOMEM;
 
<span class="p_del">-	/* It is safe to reuse the original kernel mapping */</span>
<span class="p_del">-	set_pgd(temp_level4_pgt + pgd_index(__START_KERNEL_map),</span>
<span class="p_del">-		init_level4_pgt[pgd_index(__START_KERNEL_map)]);</span>
<span class="p_add">+	/* Prepare a temporary mapping for the kernel text */</span>
<span class="p_add">+	result = set_up_temporary_text_mapping();</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		return result;</span>
 
 	/* Set up the direct mapping from scratch */
 	for (i = 0; i &lt; nr_pfn_mapped; i++) {
<span class="p_chunk">@@ -78,19 +117,45 @@</span> <span class="p_context"> static int set_up_temporary_mappings(voi</span>
 	return 0;
 }
 
<span class="p_add">+static int relocate_restore_code(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	relocated_restore_code = get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!relocated_restore_code)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy((void *)relocated_restore_code, &amp;core_restore_code, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make the page containing the relocated code executable */</span>
<span class="p_add">+	pgd = (pgd_t *)__va(read_cr3()) + pgd_index(relocated_restore_code);</span>
<span class="p_add">+	pmd = pmd_offset(pud_offset(pgd, relocated_restore_code),</span>
<span class="p_add">+			 relocated_restore_code);</span>
<span class="p_add">+	if (pmd_large(*pmd)) {</span>
<span class="p_add">+		set_pmd(pmd, __pmd(pmd_val(*pmd) &amp; ~_PAGE_NX));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pte_t *pte = pte_offset_kernel(pmd, relocated_restore_code);</span>
<span class="p_add">+</span>
<span class="p_add">+		set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_NX));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	flush_tlb_all();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int swsusp_arch_resume(void)
 {
 	int error;
 
 	/* We have got enough memory and from now on we cannot recover */
<span class="p_del">-	if ((error = set_up_temporary_mappings()))</span>
<span class="p_add">+	error = set_up_temporary_mappings();</span>
<span class="p_add">+	if (error)</span>
 		return error;
 
<span class="p_del">-	relocated_restore_code = (void *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_del">-	if (!relocated_restore_code)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	memcpy(relocated_restore_code, &amp;core_restore_code,</span>
<span class="p_del">-	       &amp;restore_registers - &amp;core_restore_code);</span>
<span class="p_add">+	error = relocate_restore_code();</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
 
 	restore_image();
 	return 0;
<span class="p_chunk">@@ -109,11 +174,12 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 
 struct restore_data_record {
 	unsigned long jump_address;
<span class="p_add">+	unsigned long jump_address_phys;</span>
 	unsigned long cr3;
 	unsigned long magic;
 };
 
<span class="p_del">-#define RESTORE_MAGIC	0x0123456789ABCDEFUL</span>
<span class="p_add">+#define RESTORE_MAGIC	0x123456789ABCDEF0UL</span>
 
 /**
  *	arch_hibernation_header_save - populate the architecture specific part
<span class="p_chunk">@@ -126,7 +192,8 @@</span> <span class="p_context"> int arch_hibernation_header_save(void *a</span>
 
 	if (max_size &lt; sizeof(struct restore_data_record))
 		return -EOVERFLOW;
<span class="p_del">-	rdr-&gt;jump_address = restore_jump_address;</span>
<span class="p_add">+	rdr-&gt;jump_address = (unsigned long)&amp;restore_registers;</span>
<span class="p_add">+	rdr-&gt;jump_address_phys = __pa_symbol(&amp;restore_registers);</span>
 	rdr-&gt;cr3 = restore_cr3;
 	rdr-&gt;magic = RESTORE_MAGIC;
 	return 0;
<span class="p_chunk">@@ -142,6 +209,7 @@</span> <span class="p_context"> int arch_hibernation_header_restore(void</span>
 	struct restore_data_record *rdr = addr;
 
 	restore_jump_address = rdr-&gt;jump_address;
<span class="p_add">+	jump_address_phys = rdr-&gt;jump_address_phys;</span>
 	restore_cr3 = rdr-&gt;cr3;
 	return (rdr-&gt;magic == RESTORE_MAGIC) ? 0 : -EINVAL;
 }
<span class="p_header">Index: linux-pm/arch/x86/power/hibernate_asm_64.S</span>
===================================================================
<span class="p_header">--- linux-pm.orig/arch/x86/power/hibernate_asm_64.S</span>
<span class="p_header">+++ linux-pm/arch/x86/power/hibernate_asm_64.S</span>
<span class="p_chunk">@@ -44,9 +44,6 @@</span> <span class="p_context"> ENTRY(swsusp_arch_suspend)</span>
 	pushfq
 	popq	pt_regs_flags(%rax)
 
<span class="p_del">-	/* save the address of restore_registers */</span>
<span class="p_del">-	movq	$restore_registers, %rax</span>
<span class="p_del">-	movq	%rax, restore_jump_address(%rip)</span>
 	/* save cr3 */
 	movq	%cr3, %rax
 	movq	%rax, restore_cr3(%rip)
<span class="p_chunk">@@ -57,31 +54,34 @@</span> <span class="p_context"> ENTRY(swsusp_arch_suspend)</span>
 ENDPROC(swsusp_arch_suspend)
 
 ENTRY(restore_image)
<span class="p_del">-	/* switch to temporary page tables */</span>
<span class="p_del">-	movq	$__PAGE_OFFSET, %rdx</span>
<span class="p_del">-	movq	temp_level4_pgt(%rip), %rax</span>
<span class="p_del">-	subq	%rdx, %rax</span>
<span class="p_del">-	movq	%rax, %cr3</span>
<span class="p_del">-	/* Flush TLB */</span>
<span class="p_del">-	movq	mmu_cr4_features(%rip), %rax</span>
<span class="p_del">-	movq	%rax, %rdx</span>
<span class="p_del">-	andq	$~(X86_CR4_PGE), %rdx</span>
<span class="p_del">-	movq	%rdx, %cr4;  # turn off PGE</span>
<span class="p_del">-	movq	%cr3, %rcx;  # flush TLB</span>
<span class="p_del">-	movq	%rcx, %cr3;</span>
<span class="p_del">-	movq	%rax, %cr4;  # turn PGE back on</span>
<span class="p_del">-</span>
 	/* prepare to jump to the image kernel */
<span class="p_del">-	movq	restore_jump_address(%rip), %rax</span>
<span class="p_del">-	movq	restore_cr3(%rip), %rbx</span>
<span class="p_add">+	movq	restore_jump_address(%rip), %r8</span>
<span class="p_add">+	movq	restore_cr3(%rip), %r9</span>
<span class="p_add">+</span>
<span class="p_add">+	/* prepare to switch to temporary page tables */</span>
<span class="p_add">+	movq	temp_level4_pgt(%rip), %rax</span>
<span class="p_add">+	movq	mmu_cr4_features(%rip), %rbx</span>
 
 	/* prepare to copy image data to their original locations */
 	movq	restore_pblist(%rip), %rdx
<span class="p_add">+</span>
<span class="p_add">+	/* jump to relocated restore code */</span>
 	movq	relocated_restore_code(%rip), %rcx
 	jmpq	*%rcx
 
 	/* code below has been relocated to a safe page */
 ENTRY(core_restore_code)
<span class="p_add">+	/* switch to temporary page tables */</span>
<span class="p_add">+	movq	$__PAGE_OFFSET, %rcx</span>
<span class="p_add">+	subq	%rcx, %rax</span>
<span class="p_add">+	movq	%rax, %cr3</span>
<span class="p_add">+	/* flush TLB */</span>
<span class="p_add">+	movq	%rbx, %rcx</span>
<span class="p_add">+	andq	$~(X86_CR4_PGE), %rcx</span>
<span class="p_add">+	movq	%rcx, %cr4;  # turn off PGE</span>
<span class="p_add">+	movq	%cr3, %rcx;  # flush TLB</span>
<span class="p_add">+	movq	%rcx, %cr3;</span>
<span class="p_add">+	movq	%rbx, %cr4;  # turn PGE back on</span>
 .Lloop:
 	testq	%rdx, %rdx
 	jz	.Ldone
<span class="p_chunk">@@ -96,24 +96,17 @@</span> <span class="p_context"> ENTRY(core_restore_code)</span>
 	/* progress to the next pbe */
 	movq	pbe_next(%rdx), %rdx
 	jmp	.Lloop
<span class="p_add">+</span>
 .Ldone:
 	/* jump to the restore_registers address from the image header */
<span class="p_del">-	jmpq	*%rax</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * NOTE: This assumes that the boot kernel&#39;s text mapping covers the</span>
<span class="p_del">-	 * image kernel&#39;s page containing restore_registers and the address of</span>
<span class="p_del">-	 * this page is the same as in the image kernel&#39;s text mapping (it</span>
<span class="p_del">-	 * should always be true, because the text mapping is linear, starting</span>
<span class="p_del">-	 * from 0, and is supposed to cover the entire kernel text for every</span>
<span class="p_del">-	 * kernel).</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * code below belongs to the image kernel</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	jmpq	*%r8</span>
 
<span class="p_add">+	 /* code below belongs to the image kernel */</span>
<span class="p_add">+	.align PAGE_SIZE</span>
 ENTRY(restore_registers)
 	FRAME_BEGIN
 	/* go back to the original page tables */
<span class="p_del">-	movq    %rbx, %cr3</span>
<span class="p_add">+	movq    %r9, %cr3</span>
 
 	/* Flush TLB, including &quot;global&quot; things (vmalloc) */
 	movq	mmu_cr4_features(%rip), %rax

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



