
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.76 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.76</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 5, 2017, 2:09 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170705140907.GB32215@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9826589/mbox/"
   >mbox</a>
|
   <a href="/patch/9826589/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9826589/">/patch/9826589/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	7865E60317 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Jul 2017 14:09:25 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4E5D2283C0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Jul 2017 14:09:25 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 41E742850D; Wed,  5 Jul 2017 14:09:25 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B73D7283C0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Jul 2017 14:09:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751892AbdGEOJQ (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 5 Jul 2017 10:09:16 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:59652 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751797AbdGEOJK (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 5 Jul 2017 10:09:10 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id CAF34BEA;
	Wed,  5 Jul 2017 14:09:07 +0000 (UTC)
Date: Wed, 5 Jul 2017 16:09:07 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.76
Message-ID: &lt;20170705140907.GB32215@kroah.com&gt;
References: &lt;20170705140903.GA32215@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170705140903.GA32215@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - July 5, 2017, 2:09 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/sysctl/kernel.txt b/Documentation/sysctl/kernel.txt</span>
<span class="p_header">index af70d1541d3a..be61d53e997f 100644</span>
<span class="p_header">--- a/Documentation/sysctl/kernel.txt</span>
<span class="p_header">+++ b/Documentation/sysctl/kernel.txt</span>
<span class="p_chunk">@@ -810,14 +810,13 @@</span> <span class="p_context"> via the /proc/sys interface:</span>
        Each write syscall must fully contain the sysctl value to be
        written, and multiple writes on the same sysctl file descriptor
        will rewrite the sysctl value, regardless of file position.
<span class="p_del">-   0 - (default) Same behavior as above, but warn about processes that</span>
<span class="p_del">-       perform writes to a sysctl file descriptor when the file position</span>
<span class="p_del">-       is not 0.</span>
<span class="p_del">-   1 - Respect file position when writing sysctl strings. Multiple writes</span>
<span class="p_del">-       will append to the sysctl value buffer. Anything past the max length</span>
<span class="p_del">-       of the sysctl value buffer will be ignored. Writes to numeric sysctl</span>
<span class="p_del">-       entries must always be at file position 0 and the value must be</span>
<span class="p_del">-       fully contained in the buffer sent in the write syscall.</span>
<span class="p_add">+   0 - Same behavior as above, but warn about processes that perform writes</span>
<span class="p_add">+       to a sysctl file descriptor when the file position is not 0.</span>
<span class="p_add">+   1 - (default) Respect file position when writing sysctl strings. Multiple</span>
<span class="p_add">+       writes will append to the sysctl value buffer. Anything past the max</span>
<span class="p_add">+       length of the sysctl value buffer will be ignored. Writes to numeric</span>
<span class="p_add">+       sysctl entries must always be at file position 0 and the value must</span>
<span class="p_add">+       be fully contained in the buffer sent in the write syscall.</span>
 
 ==============================================================
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 696d15d8ad5d..902ab134446e 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 75</span>
<span class="p_add">+SUBLEVEL = 76</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_chunk">@@ -633,6 +633,12 @@</span> <span class="p_context"> endif</span>
 # Tell gcc to never replace conditional load with a non-conditional one
 KBUILD_CFLAGS	+= $(call cc-option,--param=allow-store-data-races=0)
 
<span class="p_add">+# check for &#39;asm goto&#39;</span>
<span class="p_add">+ifeq ($(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-goto.sh $(CC) $(KBUILD_CFLAGS)), y)</span>
<span class="p_add">+	KBUILD_CFLAGS += -DCC_HAVE_ASM_GOTO</span>
<span class="p_add">+	KBUILD_AFLAGS += -DCC_HAVE_ASM_GOTO</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 ifdef CONFIG_READABLE_ASM
 # Disable optimizations that make assembler listings hard to read.
 # reorder blocks reorders the control in the function
<span class="p_chunk">@@ -788,12 +794,6 @@</span> <span class="p_context"> KBUILD_CFLAGS   += $(call cc-option,-Werror=date-time)</span>
 # use the deterministic mode of AR if available
 KBUILD_ARFLAGS := $(call ar-option,D)
 
<span class="p_del">-# check for &#39;asm goto&#39;</span>
<span class="p_del">-ifeq ($(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-goto.sh $(CC) $(KBUILD_CFLAGS)), y)</span>
<span class="p_del">-	KBUILD_CFLAGS += -DCC_HAVE_ASM_GOTO</span>
<span class="p_del">-	KBUILD_AFLAGS += -DCC_HAVE_ASM_GOTO</span>
<span class="p_del">-endif</span>
<span class="p_del">-</span>
 include scripts/Makefile.kasan
 include scripts/Makefile.extrawarn
 
<span class="p_header">diff --git a/arch/arm/boot/dts/bcm5301x.dtsi b/arch/arm/boot/dts/bcm5301x.dtsi</span>
<span class="p_header">index 6f50f672efbd..de8ac998604d 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/bcm5301x.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/bcm5301x.dtsi</span>
<span class="p_chunk">@@ -54,14 +54,14 @@</span> <span class="p_context"></span>
 		timer@0200 {
 			compatible = &quot;arm,cortex-a9-global-timer&quot;;
 			reg = &lt;0x0200 0x100&gt;;
<span class="p_del">-			interrupts = &lt;GIC_PPI 11 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
<span class="p_add">+			interrupts = &lt;GIC_PPI 11 IRQ_TYPE_EDGE_RISING&gt;;</span>
 			clocks = &lt;&amp;clk_periph&gt;;
 		};
 
 		local-timer@0600 {
 			compatible = &quot;arm,cortex-a9-twd-timer&quot;;
 			reg = &lt;0x0600 0x100&gt;;
<span class="p_del">-			interrupts = &lt;GIC_PPI 13 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
<span class="p_add">+			interrupts = &lt;GIC_PPI 13 IRQ_TYPE_EDGE_RISING&gt;;</span>
 			clocks = &lt;&amp;clk_periph&gt;;
 		};
 
<span class="p_header">diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c</span>
<span class="p_header">index 4867f5daf82c..e47cffd25c6c 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmu.c</span>
<span class="p_chunk">@@ -1184,15 +1184,15 @@</span> <span class="p_context"> void __init sanity_check_meminfo(void)</span>
 
 	high_memory = __va(arm_lowmem_limit - 1) + 1;
 
<span class="p_add">+	if (!memblock_limit)</span>
<span class="p_add">+		memblock_limit = arm_lowmem_limit;</span>
<span class="p_add">+</span>
 	/*
 	 * Round the memblock limit down to a pmd size.  This
 	 * helps to ensure that we will allocate memory from the
 	 * last full pmd, which should be mapped.
 	 */
<span class="p_del">-	if (memblock_limit)</span>
<span class="p_del">-		memblock_limit = round_down(memblock_limit, PMD_SIZE);</span>
<span class="p_del">-	if (!memblock_limit)</span>
<span class="p_del">-		memblock_limit = arm_lowmem_limit;</span>
<span class="p_add">+	memblock_limit = round_down(memblock_limit, PMD_SIZE);</span>
 
 	memblock_set_current_limit(memblock_limit);
 }
<span class="p_header">diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">index caafd63b8092..40d1351e7573 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/acpi.h</span>
<span class="p_chunk">@@ -22,9 +22,9 @@</span> <span class="p_context"></span>
 #define ACPI_MADT_GICC_LENGTH	\
 	(acpi_gbl_FADT.header.revision &lt; 6 ? 76 : 80)
 
<span class="p_del">-#define BAD_MADT_GICC_ENTRY(entry, end)						\</span>
<span class="p_del">-	(!(entry) || (unsigned long)(entry) + sizeof(*(entry)) &gt; (end) ||	\</span>
<span class="p_del">-	 (entry)-&gt;header.length != ACPI_MADT_GICC_LENGTH)</span>
<span class="p_add">+#define BAD_MADT_GICC_ENTRY(entry, end)					\</span>
<span class="p_add">+	(!(entry) || (entry)-&gt;header.length != ACPI_MADT_GICC_LENGTH ||	\</span>
<span class="p_add">+	(unsigned long)(entry) + ACPI_MADT_GICC_LENGTH &gt; (end))</span>
 
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI
<span class="p_header">diff --git a/arch/mips/ath79/common.c b/arch/mips/ath79/common.c</span>
<span class="p_header">index 3cedd1f95e0f..8ae4067a5eda 100644</span>
<span class="p_header">--- a/arch/mips/ath79/common.c</span>
<span class="p_header">+++ b/arch/mips/ath79/common.c</span>
<span class="p_chunk">@@ -76,14 +76,14 @@</span> <span class="p_context"> void ath79_ddr_set_pci_windows(void)</span>
 {
 	BUG_ON(!ath79_ddr_pci_win_base);
 
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN0_OFFS, ath79_ddr_pci_win_base + 0);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN1_OFFS, ath79_ddr_pci_win_base + 1);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN2_OFFS, ath79_ddr_pci_win_base + 2);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN3_OFFS, ath79_ddr_pci_win_base + 3);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN4_OFFS, ath79_ddr_pci_win_base + 4);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN5_OFFS, ath79_ddr_pci_win_base + 5);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN6_OFFS, ath79_ddr_pci_win_base + 6);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN7_OFFS, ath79_ddr_pci_win_base + 7);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN0_OFFS, ath79_ddr_pci_win_base + 0x0);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN1_OFFS, ath79_ddr_pci_win_base + 0x4);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN2_OFFS, ath79_ddr_pci_win_base + 0x8);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN3_OFFS, ath79_ddr_pci_win_base + 0xc);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN4_OFFS, ath79_ddr_pci_win_base + 0x10);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN5_OFFS, ath79_ddr_pci_win_base + 0x14);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN6_OFFS, ath79_ddr_pci_win_base + 0x18);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN7_OFFS, ath79_ddr_pci_win_base + 0x1c);</span>
 }
 EXPORT_SYMBOL_GPL(ath79_ddr_set_pci_windows);
 
<span class="p_header">diff --git a/arch/mips/kernel/entry.S b/arch/mips/kernel/entry.S</span>
<span class="p_header">index 7791840cf22c..db07793f7b43 100644</span>
<span class="p_header">--- a/arch/mips/kernel/entry.S</span>
<span class="p_header">+++ b/arch/mips/kernel/entry.S</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/asm.h&gt;
 #include &lt;asm/asmmacro.h&gt;
 #include &lt;asm/compiler.h&gt;
<span class="p_add">+#include &lt;asm/irqflags.h&gt;</span>
 #include &lt;asm/regdef.h&gt;
 #include &lt;asm/mipsregs.h&gt;
 #include &lt;asm/stackframe.h&gt;
<span class="p_chunk">@@ -137,6 +138,7 @@</span> <span class="p_context"> work_pending:</span>
 	andi	t0, a2, _TIF_NEED_RESCHED # a2 is preloaded with TI_FLAGS
 	beqz	t0, work_notifysig
 work_resched:
<span class="p_add">+	TRACE_IRQS_OFF</span>
 	jal	schedule
 
 	local_irq_disable		# make sure need_resched and
<span class="p_chunk">@@ -173,6 +175,7 @@</span> <span class="p_context"> syscall_exit_work:</span>
 	beqz	t0, work_pending	# trace bit set?
 	local_irq_enable		# could let syscall_trace_leave()
 					# call schedule() instead
<span class="p_add">+	TRACE_IRQS_ON</span>
 	move	a0, sp
 	jal	syscall_trace_leave
 	b	resume_userspace
<span class="p_header">diff --git a/arch/mips/kernel/pm-cps.c b/arch/mips/kernel/pm-cps.c</span>
<span class="p_header">index f63a289977cc..0b3e58a3189f 100644</span>
<span class="p_header">--- a/arch/mips/kernel/pm-cps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/pm-cps.c</span>
<span class="p_chunk">@@ -55,7 +55,6 @@</span> <span class="p_context"> DECLARE_BITMAP(state_support, CPS_PM_STATE_COUNT);</span>
  * state. Actually per-core rather than per-CPU.
  */
 static DEFINE_PER_CPU_ALIGNED(u32*, ready_count);
<span class="p_del">-static DEFINE_PER_CPU_ALIGNED(void*, ready_count_alloc);</span>
 
 /* Indicates online CPUs coupled with the current CPU */
 static DEFINE_PER_CPU_ALIGNED(cpumask_t, online_coupled);
<span class="p_chunk">@@ -625,7 +624,6 @@</span> <span class="p_context"> static int __init cps_gen_core_entries(unsigned cpu)</span>
 {
 	enum cps_pm_state state;
 	unsigned core = cpu_data[cpu].core;
<span class="p_del">-	unsigned dlinesz = cpu_data[cpu].dcache.linesz;</span>
 	void *entry_fn, *core_rc;
 
 	for (state = CPS_PM_NC_WAIT; state &lt; CPS_PM_STATE_COUNT; state++) {
<span class="p_chunk">@@ -645,16 +643,11 @@</span> <span class="p_context"> static int __init cps_gen_core_entries(unsigned cpu)</span>
 	}
 
 	if (!per_cpu(ready_count, core)) {
<span class="p_del">-		core_rc = kmalloc(dlinesz * 2, GFP_KERNEL);</span>
<span class="p_add">+		core_rc = kmalloc(sizeof(u32), GFP_KERNEL);</span>
 		if (!core_rc) {
 			pr_err(&quot;Failed allocate core %u ready_count\n&quot;, core);
 			return -ENOMEM;
 		}
<span class="p_del">-		per_cpu(ready_count_alloc, core) = core_rc;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Ensure ready_count is aligned to a cacheline boundary */</span>
<span class="p_del">-		core_rc += dlinesz - 1;</span>
<span class="p_del">-		core_rc = (void *)((unsigned long)core_rc &amp; ~(dlinesz - 1));</span>
 		per_cpu(ready_count, core) = core_rc;
 	}
 
<span class="p_header">diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c</span>
<span class="p_header">index 99a402231f4d..31ca2edd7218 100644</span>
<span class="p_header">--- a/arch/mips/kernel/traps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/traps.c</span>
<span class="p_chunk">@@ -194,6 +194,8 @@</span> <span class="p_context"> void show_stack(struct task_struct *task, unsigned long *sp)</span>
 {
 	struct pt_regs regs;
 	mm_segment_t old_fs = get_fs();
<span class="p_add">+</span>
<span class="p_add">+	regs.cp0_status = KSU_KERNEL;</span>
 	if (sp) {
 		regs.regs[29] = (unsigned long)sp;
 		regs.regs[31] = 0;
<span class="p_header">diff --git a/arch/mips/ralink/mt7620.c b/arch/mips/ralink/mt7620.c</span>
<span class="p_header">index dfb04fcedb04..48d6349fd9d7 100644</span>
<span class="p_header">--- a/arch/mips/ralink/mt7620.c</span>
<span class="p_header">+++ b/arch/mips/ralink/mt7620.c</span>
<span class="p_chunk">@@ -107,31 +107,31 @@</span> <span class="p_context"> static struct rt2880_pmx_group mt7620a_pinmux_data[] = {</span>
 };
 
 static struct rt2880_pmx_func pwm1_grp_mt7628[] = {
<span class="p_del">-	FUNC(&quot;sdcx&quot;, 3, 19, 1),</span>
<span class="p_add">+	FUNC(&quot;sdxc d6&quot;, 3, 19, 1),</span>
 	FUNC(&quot;utif&quot;, 2, 19, 1),
 	FUNC(&quot;gpio&quot;, 1, 19, 1),
<span class="p_del">-	FUNC(&quot;pwm&quot;, 0, 19, 1),</span>
<span class="p_add">+	FUNC(&quot;pwm1&quot;, 0, 19, 1),</span>
 };
 
 static struct rt2880_pmx_func pwm0_grp_mt7628[] = {
<span class="p_del">-	FUNC(&quot;sdcx&quot;, 3, 18, 1),</span>
<span class="p_add">+	FUNC(&quot;sdxc d7&quot;, 3, 18, 1),</span>
 	FUNC(&quot;utif&quot;, 2, 18, 1),
 	FUNC(&quot;gpio&quot;, 1, 18, 1),
<span class="p_del">-	FUNC(&quot;pwm&quot;, 0, 18, 1),</span>
<span class="p_add">+	FUNC(&quot;pwm0&quot;, 0, 18, 1),</span>
 };
 
 static struct rt2880_pmx_func uart2_grp_mt7628[] = {
<span class="p_del">-	FUNC(&quot;sdcx&quot;, 3, 20, 2),</span>
<span class="p_add">+	FUNC(&quot;sdxc d5 d4&quot;, 3, 20, 2),</span>
 	FUNC(&quot;pwm&quot;, 2, 20, 2),
 	FUNC(&quot;gpio&quot;, 1, 20, 2),
<span class="p_del">-	FUNC(&quot;uart&quot;, 0, 20, 2),</span>
<span class="p_add">+	FUNC(&quot;uart2&quot;, 0, 20, 2),</span>
 };
 
 static struct rt2880_pmx_func uart1_grp_mt7628[] = {
<span class="p_del">-	FUNC(&quot;sdcx&quot;, 3, 45, 2),</span>
<span class="p_add">+	FUNC(&quot;sw_r&quot;, 3, 45, 2),</span>
 	FUNC(&quot;pwm&quot;, 2, 45, 2),
 	FUNC(&quot;gpio&quot;, 1, 45, 2),
<span class="p_del">-	FUNC(&quot;uart&quot;, 0, 45, 2),</span>
<span class="p_add">+	FUNC(&quot;uart1&quot;, 0, 45, 2),</span>
 };
 
 static struct rt2880_pmx_func i2c_grp_mt7628[] = {
<span class="p_chunk">@@ -143,21 +143,21 @@</span> <span class="p_context"> static struct rt2880_pmx_func i2c_grp_mt7628[] = {</span>
 
 static struct rt2880_pmx_func refclk_grp_mt7628[] = { FUNC(&quot;reclk&quot;, 0, 36, 1) };
 static struct rt2880_pmx_func perst_grp_mt7628[] = { FUNC(&quot;perst&quot;, 0, 37, 1) };
<span class="p_del">-static struct rt2880_pmx_func wdt_grp_mt7628[] = { FUNC(&quot;wdt&quot;, 0, 15, 38) };</span>
<span class="p_add">+static struct rt2880_pmx_func wdt_grp_mt7628[] = { FUNC(&quot;wdt&quot;, 0, 38, 1) };</span>
 static struct rt2880_pmx_func spi_grp_mt7628[] = { FUNC(&quot;spi&quot;, 0, 7, 4) };
 
 static struct rt2880_pmx_func sd_mode_grp_mt7628[] = {
 	FUNC(&quot;jtag&quot;, 3, 22, 8),
 	FUNC(&quot;utif&quot;, 2, 22, 8),
 	FUNC(&quot;gpio&quot;, 1, 22, 8),
<span class="p_del">-	FUNC(&quot;sdcx&quot;, 0, 22, 8),</span>
<span class="p_add">+	FUNC(&quot;sdxc&quot;, 0, 22, 8),</span>
 };
 
 static struct rt2880_pmx_func uart0_grp_mt7628[] = {
 	FUNC(&quot;-&quot;, 3, 12, 2),
 	FUNC(&quot;-&quot;, 2, 12, 2),
 	FUNC(&quot;gpio&quot;, 1, 12, 2),
<span class="p_del">-	FUNC(&quot;uart&quot;, 0, 12, 2),</span>
<span class="p_add">+	FUNC(&quot;uart0&quot;, 0, 12, 2),</span>
 };
 
 static struct rt2880_pmx_func i2s_grp_mt7628[] = {
<span class="p_chunk">@@ -171,7 +171,7 @@</span> <span class="p_context"> static struct rt2880_pmx_func spi_cs1_grp_mt7628[] = {</span>
 	FUNC(&quot;-&quot;, 3, 6, 1),
 	FUNC(&quot;refclk&quot;, 2, 6, 1),
 	FUNC(&quot;gpio&quot;, 1, 6, 1),
<span class="p_del">-	FUNC(&quot;spi&quot;, 0, 6, 1),</span>
<span class="p_add">+	FUNC(&quot;spi cs1&quot;, 0, 6, 1),</span>
 };
 
 static struct rt2880_pmx_func spis_grp_mt7628[] = {
<span class="p_chunk">@@ -188,28 +188,44 @@</span> <span class="p_context"> static struct rt2880_pmx_func gpio_grp_mt7628[] = {</span>
 	FUNC(&quot;gpio&quot;, 0, 11, 1),
 };
 
<span class="p_del">-#define MT7628_GPIO_MODE_MASK	0x3</span>
<span class="p_del">-</span>
<span class="p_del">-#define MT7628_GPIO_MODE_PWM1	30</span>
<span class="p_del">-#define MT7628_GPIO_MODE_PWM0	28</span>
<span class="p_del">-#define MT7628_GPIO_MODE_UART2	26</span>
<span class="p_del">-#define MT7628_GPIO_MODE_UART1	24</span>
<span class="p_del">-#define MT7628_GPIO_MODE_I2C	20</span>
<span class="p_del">-#define MT7628_GPIO_MODE_REFCLK	18</span>
<span class="p_del">-#define MT7628_GPIO_MODE_PERST	16</span>
<span class="p_del">-#define MT7628_GPIO_MODE_WDT	14</span>
<span class="p_del">-#define MT7628_GPIO_MODE_SPI	12</span>
<span class="p_del">-#define MT7628_GPIO_MODE_SDMODE	10</span>
<span class="p_del">-#define MT7628_GPIO_MODE_UART0	8</span>
<span class="p_del">-#define MT7628_GPIO_MODE_I2S	6</span>
<span class="p_del">-#define MT7628_GPIO_MODE_CS1	4</span>
<span class="p_del">-#define MT7628_GPIO_MODE_SPIS	2</span>
<span class="p_del">-#define MT7628_GPIO_MODE_GPIO	0</span>
<span class="p_add">+static struct rt2880_pmx_func wled_kn_grp_mt7628[] = {</span>
<span class="p_add">+	FUNC(&quot;rsvd&quot;, 3, 35, 1),</span>
<span class="p_add">+	FUNC(&quot;rsvd&quot;, 2, 35, 1),</span>
<span class="p_add">+	FUNC(&quot;gpio&quot;, 1, 35, 1),</span>
<span class="p_add">+	FUNC(&quot;wled_kn&quot;, 0, 35, 1),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct rt2880_pmx_func wled_an_grp_mt7628[] = {</span>
<span class="p_add">+	FUNC(&quot;rsvd&quot;, 3, 44, 1),</span>
<span class="p_add">+	FUNC(&quot;rsvd&quot;, 2, 44, 1),</span>
<span class="p_add">+	FUNC(&quot;gpio&quot;, 1, 44, 1),</span>
<span class="p_add">+	FUNC(&quot;wled_an&quot;, 0, 44, 1),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define MT7628_GPIO_MODE_MASK		0x3</span>
<span class="p_add">+</span>
<span class="p_add">+#define MT7628_GPIO_MODE_WLED_KN	48</span>
<span class="p_add">+#define MT7628_GPIO_MODE_WLED_AN	32</span>
<span class="p_add">+#define MT7628_GPIO_MODE_PWM1		30</span>
<span class="p_add">+#define MT7628_GPIO_MODE_PWM0		28</span>
<span class="p_add">+#define MT7628_GPIO_MODE_UART2		26</span>
<span class="p_add">+#define MT7628_GPIO_MODE_UART1		24</span>
<span class="p_add">+#define MT7628_GPIO_MODE_I2C		20</span>
<span class="p_add">+#define MT7628_GPIO_MODE_REFCLK		18</span>
<span class="p_add">+#define MT7628_GPIO_MODE_PERST		16</span>
<span class="p_add">+#define MT7628_GPIO_MODE_WDT		14</span>
<span class="p_add">+#define MT7628_GPIO_MODE_SPI		12</span>
<span class="p_add">+#define MT7628_GPIO_MODE_SDMODE		10</span>
<span class="p_add">+#define MT7628_GPIO_MODE_UART0		8</span>
<span class="p_add">+#define MT7628_GPIO_MODE_I2S		6</span>
<span class="p_add">+#define MT7628_GPIO_MODE_CS1		4</span>
<span class="p_add">+#define MT7628_GPIO_MODE_SPIS		2</span>
<span class="p_add">+#define MT7628_GPIO_MODE_GPIO		0</span>
 
 static struct rt2880_pmx_group mt7628an_pinmux_data[] = {
<span class="p_del">-	GRP_G(&quot;pmw1&quot;, pwm1_grp_mt7628, MT7628_GPIO_MODE_MASK,</span>
<span class="p_add">+	GRP_G(&quot;pwm1&quot;, pwm1_grp_mt7628, MT7628_GPIO_MODE_MASK,</span>
 				1, MT7628_GPIO_MODE_PWM1),
<span class="p_del">-	GRP_G(&quot;pmw1&quot;, pwm0_grp_mt7628, MT7628_GPIO_MODE_MASK,</span>
<span class="p_add">+	GRP_G(&quot;pwm0&quot;, pwm0_grp_mt7628, MT7628_GPIO_MODE_MASK,</span>
 				1, MT7628_GPIO_MODE_PWM0),
 	GRP_G(&quot;uart2&quot;, uart2_grp_mt7628, MT7628_GPIO_MODE_MASK,
 				1, MT7628_GPIO_MODE_UART2),
<span class="p_chunk">@@ -233,6 +249,10 @@</span> <span class="p_context"> static struct rt2880_pmx_group mt7628an_pinmux_data[] = {</span>
 				1, MT7628_GPIO_MODE_SPIS),
 	GRP_G(&quot;gpio&quot;, gpio_grp_mt7628, MT7628_GPIO_MODE_MASK,
 				1, MT7628_GPIO_MODE_GPIO),
<span class="p_add">+	GRP_G(&quot;wled_an&quot;, wled_an_grp_mt7628, MT7628_GPIO_MODE_MASK,</span>
<span class="p_add">+				1, MT7628_GPIO_MODE_WLED_AN),</span>
<span class="p_add">+	GRP_G(&quot;wled_kn&quot;, wled_kn_grp_mt7628, MT7628_GPIO_MODE_MASK,</span>
<span class="p_add">+				1, MT7628_GPIO_MODE_WLED_KN),</span>
 	{ 0 }
 };
 
<span class="p_chunk">@@ -439,7 +459,7 @@</span> <span class="p_context"> void __init ralink_clk_init(void)</span>
 	ralink_clk_add(&quot;10000c00.uartlite&quot;, periph_rate);
 	ralink_clk_add(&quot;10180000.wmac&quot;, xtal_rate);
 
<span class="p_del">-	if (IS_ENABLED(CONFIG_USB) &amp;&amp; is_mt76x8()) {</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_USB) &amp;&amp; !is_mt76x8()) {</span>
 		/*
 		 * When the CPU goes into sleep mode, the BUS clock will be
 		 * too low for USB to function properly. Adjust the busses
<span class="p_header">diff --git a/arch/mips/ralink/rt288x.c b/arch/mips/ralink/rt288x.c</span>
<span class="p_header">index 15506a1ff22a..9dd67749c592 100644</span>
<span class="p_header">--- a/arch/mips/ralink/rt288x.c</span>
<span class="p_header">+++ b/arch/mips/ralink/rt288x.c</span>
<span class="p_chunk">@@ -109,5 +109,5 @@</span> <span class="p_context"> void prom_soc_init(struct ralink_soc_info *soc_info)</span>
 	soc_info-&gt;mem_size_max = RT2880_MEM_SIZE_MAX;
 
 	rt2880_pinmux_data = rt2880_pinmux_data_act;
<span class="p_del">-	ralink_soc == RT2880_SOC;</span>
<span class="p_add">+	ralink_soc = RT2880_SOC;</span>
 }
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh.c b/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">index 98949b0df00a..6696c1986844 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh.c</span>
<span class="p_chunk">@@ -304,9 +304,17 @@</span> <span class="p_context"> void eeh_slot_error_detail(struct eeh_pe *pe, int severity)</span>
 	 *
 	 * For pHyp, we have to enable IO for log retrieval. Otherwise,
 	 * 0xFF&#39;s is always returned from PCI config space.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * When the @severity is EEH_LOG_PERM, the PE is going to be</span>
<span class="p_add">+	 * removed. Prior to that, the drivers for devices included in</span>
<span class="p_add">+	 * the PE will be closed. The drivers rely on working IO path</span>
<span class="p_add">+	 * to bring the devices to quiet state. Otherwise, PCI traffic</span>
<span class="p_add">+	 * from those devices after they are removed is like to cause</span>
<span class="p_add">+	 * another unexpected EEH error.</span>
 	 */
 	if (!(pe-&gt;type &amp; EEH_PE_PHB)) {
<span class="p_del">-		if (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG))</span>
<span class="p_add">+		if (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG) ||</span>
<span class="p_add">+		    severity == EEH_LOG_PERM)</span>
 			eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);
 
 		/*
<span class="p_header">diff --git a/arch/s390/include/asm/ctl_reg.h b/arch/s390/include/asm/ctl_reg.h</span>
<span class="p_header">index d7697ab802f6..8e136b88cdf4 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/ctl_reg.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/ctl_reg.h</span>
<span class="p_chunk">@@ -15,7 +15,9 @@</span> <span class="p_context"></span>
 	BUILD_BUG_ON(sizeof(addrtype) != (high - low + 1) * sizeof(long));\
 	asm volatile(							\
 		&quot;	lctlg	%1,%2,%0\n&quot;				\
<span class="p_del">-		: : &quot;Q&quot; (*(addrtype *)(&amp;array)), &quot;i&quot; (low), &quot;i&quot; (high));\</span>
<span class="p_add">+		:							\</span>
<span class="p_add">+		: &quot;Q&quot; (*(addrtype *)(&amp;array)), &quot;i&quot; (low), &quot;i&quot; (high)	\</span>
<span class="p_add">+		: &quot;memory&quot;);						\</span>
 }
 
 #define __ctl_store(array, low, high) {					\
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_emulate.h b/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_header">index e9cd7befcb76..19d14ac23ef9 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -221,6 +221,9 @@</span> <span class="p_context"> struct x86_emulate_ops {</span>
 	void (*get_cpuid)(struct x86_emulate_ctxt *ctxt,
 			  u32 *eax, u32 *ebx, u32 *ecx, u32 *edx);
 	void (*set_nmi_mask)(struct x86_emulate_ctxt *ctxt, bool masked);
<span class="p_add">+</span>
<span class="p_add">+	unsigned (*get_hflags)(struct x86_emulate_ctxt *ctxt);</span>
<span class="p_add">+	void (*set_hflags)(struct x86_emulate_ctxt *ctxt, unsigned hflags);</span>
 };
 
 typedef u32 __attribute__((vector_size(16))) sse128_t;
<span class="p_chunk">@@ -290,7 +293,6 @@</span> <span class="p_context"> struct x86_emulate_ctxt {</span>
 
 	/* interruptibility state, as a result of execution of STI or MOV SS */
 	int interruptibility;
<span class="p_del">-	int emul_flags;</span>
 
 	bool perm_ok; /* do not check permissions if true */
 	bool ud;	/* inject an #UD if host doesn&#39;t support insn */
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index 1dcea225977d..04b2f3cad7ba 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -2531,7 +2531,7 @@</span> <span class="p_context"> static int em_rsm(struct x86_emulate_ctxt *ctxt)</span>
 	u64 smbase;
 	int ret;
 
<span class="p_del">-	if ((ctxt-&gt;emul_flags &amp; X86EMUL_SMM_MASK) == 0)</span>
<span class="p_add">+	if ((ctxt-&gt;ops-&gt;get_hflags(ctxt) &amp; X86EMUL_SMM_MASK) == 0)</span>
 		return emulate_ud(ctxt);
 
 	/*
<span class="p_chunk">@@ -2580,11 +2580,11 @@</span> <span class="p_context"> static int em_rsm(struct x86_emulate_ctxt *ctxt)</span>
 		return X86EMUL_UNHANDLEABLE;
 	}
 
<span class="p_del">-	if ((ctxt-&gt;emul_flags &amp; X86EMUL_SMM_INSIDE_NMI_MASK) == 0)</span>
<span class="p_add">+	if ((ctxt-&gt;ops-&gt;get_hflags(ctxt) &amp; X86EMUL_SMM_INSIDE_NMI_MASK) == 0)</span>
 		ctxt-&gt;ops-&gt;set_nmi_mask(ctxt, false);
 
<span class="p_del">-	ctxt-&gt;emul_flags &amp;= ~X86EMUL_SMM_INSIDE_NMI_MASK;</span>
<span class="p_del">-	ctxt-&gt;emul_flags &amp;= ~X86EMUL_SMM_MASK;</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;set_hflags(ctxt, ctxt-&gt;ops-&gt;get_hflags(ctxt) &amp;</span>
<span class="p_add">+		~(X86EMUL_SMM_INSIDE_NMI_MASK | X86EMUL_SMM_MASK));</span>
 	return X86EMUL_CONTINUE;
 }
 
<span class="p_chunk">@@ -5296,6 +5296,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 	const struct x86_emulate_ops *ops = ctxt-&gt;ops;
 	int rc = X86EMUL_CONTINUE;
 	int saved_dst_type = ctxt-&gt;dst.type;
<span class="p_add">+	unsigned emul_flags;</span>
 
 	ctxt-&gt;mem_read.pos = 0;
 
<span class="p_chunk">@@ -5310,6 +5311,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 		goto done;
 	}
 
<span class="p_add">+	emul_flags = ctxt-&gt;ops-&gt;get_hflags(ctxt);</span>
 	if (unlikely(ctxt-&gt;d &amp;
 		     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {
 		if ((ctxt-&gt;mode == X86EMUL_MODE_PROT64 &amp;&amp; (ctxt-&gt;d &amp; No64)) ||
<span class="p_chunk">@@ -5343,7 +5345,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 				fetch_possible_mmx_operand(ctxt, &amp;ctxt-&gt;dst);
 		}
 
<span class="p_del">-		if (unlikely(ctxt-&gt;emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; ctxt-&gt;intercept) {</span>
<span class="p_add">+		if (unlikely(emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; ctxt-&gt;intercept) {</span>
 			rc = emulator_check_intercept(ctxt, ctxt-&gt;intercept,
 						      X86_ICPT_PRE_EXCEPT);
 			if (rc != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -5372,7 +5374,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 				goto done;
 		}
 
<span class="p_del">-		if (unlikely(ctxt-&gt;emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
<span class="p_add">+		if (unlikely(emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
 			rc = emulator_check_intercept(ctxt, ctxt-&gt;intercept,
 						      X86_ICPT_POST_EXCEPT);
 			if (rc != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -5426,7 +5428,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 
 special_insn:
 
<span class="p_del">-	if (unlikely(ctxt-&gt;emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
<span class="p_add">+	if (unlikely(emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
 		rc = emulator_check_intercept(ctxt, ctxt-&gt;intercept,
 					      X86_ICPT_POST_MEMACCESS);
 		if (rc != X86EMUL_CONTINUE)
<span class="p_header">diff --git a/arch/x86/kvm/pmu_intel.c b/arch/x86/kvm/pmu_intel.c</span>
<span class="p_header">index ab38af4f4947..23a7c7ba377a 100644</span>
<span class="p_header">--- a/arch/x86/kvm/pmu_intel.c</span>
<span class="p_header">+++ b/arch/x86/kvm/pmu_intel.c</span>
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> static void intel_pmu_refresh(struct kvm_vcpu *vcpu)</span>
 			((u64)1 &lt;&lt; edx.split.bit_width_fixed) - 1;
 	}
 
<span class="p_del">-	pmu-&gt;global_ctrl = ((1 &lt;&lt; pmu-&gt;nr_arch_gp_counters) - 1) |</span>
<span class="p_add">+	pmu-&gt;global_ctrl = ((1ull &lt;&lt; pmu-&gt;nr_arch_gp_counters) - 1) |</span>
 		(((1ull &lt;&lt; pmu-&gt;nr_arch_fixed_counters) - 1) &lt;&lt; INTEL_PMC_IDX_FIXED);
 	pmu-&gt;global_ctrl_mask = ~pmu-&gt;global_ctrl;
 
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 50ca8f409a7c..bbaa11f4e74b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -2264,7 +2264,7 @@</span> <span class="p_context"> static int nested_vmx_check_exception(struct kvm_vcpu *vcpu, unsigned nr)</span>
 	if (!(vmcs12-&gt;exception_bitmap &amp; (1u &lt;&lt; nr)))
 		return 0;
 
<span class="p_del">-	nested_vmx_vmexit(vcpu, to_vmx(vcpu)-&gt;exit_reason,</span>
<span class="p_add">+	nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,</span>
 			  vmcs_read32(VM_EXIT_INTR_INFO),
 			  vmcs_readl(EXIT_QUALIFICATION));
 	return 1;
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 6c82792487e9..8e526c6fd784 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -4844,6 +4844,8 @@</span> <span class="p_context"> static bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,</span>
 
 	if (var.unusable) {
 		memset(desc, 0, sizeof(*desc));
<span class="p_add">+		if (base3)</span>
<span class="p_add">+			*base3 = 0;</span>
 		return false;
 	}
 
<span class="p_chunk">@@ -4999,6 +5001,16 @@</span> <span class="p_context"> static void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)</span>
 	kvm_x86_ops-&gt;set_nmi_mask(emul_to_vcpu(ctxt), masked);
 }
 
<span class="p_add">+static unsigned emulator_get_hflags(struct x86_emulate_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return emul_to_vcpu(ctxt)-&gt;arch.hflags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void emulator_set_hflags(struct x86_emulate_ctxt *ctxt, unsigned emul_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kvm_set_hflags(emul_to_vcpu(ctxt), emul_flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct x86_emulate_ops emulate_ops = {
 	.read_gpr            = emulator_read_gpr,
 	.write_gpr           = emulator_write_gpr,
<span class="p_chunk">@@ -5038,6 +5050,8 @@</span> <span class="p_context"> static const struct x86_emulate_ops emulate_ops = {</span>
 	.intercept           = emulator_intercept,
 	.get_cpuid           = emulator_get_cpuid,
 	.set_nmi_mask        = emulator_set_nmi_mask,
<span class="p_add">+	.get_hflags          = emulator_get_hflags,</span>
<span class="p_add">+	.set_hflags          = emulator_set_hflags,</span>
 };
 
 static void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)
<span class="p_chunk">@@ -5090,7 +5104,6 @@</span> <span class="p_context"> static void init_emulate_ctxt(struct kvm_vcpu *vcpu)</span>
 	BUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);
 	BUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);
 	BUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);
<span class="p_del">-	ctxt-&gt;emul_flags = vcpu-&gt;arch.hflags;</span>
 
 	init_decode_cache(ctxt);
 	vcpu-&gt;arch.emulate_regs_need_sync_from_vcpu = false;
<span class="p_chunk">@@ -5486,8 +5499,6 @@</span> <span class="p_context"> restart:</span>
 		unsigned long rflags = kvm_x86_ops-&gt;get_rflags(vcpu);
 		toggle_interruptibility(vcpu, ctxt-&gt;interruptibility);
 		vcpu-&gt;arch.emulate_regs_need_sync_to_vcpu = false;
<span class="p_del">-		if (vcpu-&gt;arch.hflags != ctxt-&gt;emul_flags)</span>
<span class="p_del">-			kvm_set_hflags(vcpu, ctxt-&gt;emul_flags);</span>
 		kvm_rip_write(vcpu, ctxt-&gt;eip);
 		if (r == EMULATE_DONE)
 			kvm_vcpu_check_singlestep(vcpu, rflags, &amp;r);
<span class="p_chunk">@@ -5974,7 +5985,8 @@</span> <span class="p_context"> static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)</span>
 
 	kvm_x86_ops-&gt;patch_hypercall(vcpu, instruction);
 
<span class="p_del">-	return emulator_write_emulated(ctxt, rip, instruction, 3, NULL);</span>
<span class="p_add">+	return emulator_write_emulated(ctxt, rip, instruction, 3,</span>
<span class="p_add">+		&amp;ctxt-&gt;exception);</span>
 }
 
 static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)
<span class="p_header">diff --git a/arch/x86/mm/mpx.c b/arch/x86/mm/mpx.c</span>
<span class="p_header">index ef05755a1900..7ed47b1e6f42 100644</span>
<span class="p_header">--- a/arch/x86/mm/mpx.c</span>
<span class="p_header">+++ b/arch/x86/mm/mpx.c</span>
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> siginfo_t *mpx_generate_siginfo(struct pt_regs *regs)</span>
 	 * We were not able to extract an address from the instruction,
 	 * probably because there was something invalid in it.
 	 */
<span class="p_del">-	if (info-&gt;si_addr == (void *)-1) {</span>
<span class="p_add">+	if (info-&gt;si_addr == (void __user *)-1) {</span>
 		err = -EINVAL;
 		goto err_out;
 	}
<span class="p_chunk">@@ -525,15 +525,7 @@</span> <span class="p_context"> int mpx_handle_bd_fault(void)</span>
 	if (!kernel_managing_mpx_tables(current-&gt;mm))
 		return -EINVAL;
 
<span class="p_del">-	if (do_mpx_bt_fault()) {</span>
<span class="p_del">-		force_sig(SIGSEGV, current);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The force_sig() is essentially &quot;handling&quot; this</span>
<span class="p_del">-		 * exception, so we do not pass up the error</span>
<span class="p_del">-		 * from do_mpx_bt_fault().</span>
<span class="p_del">-		 */</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return do_mpx_bt_fault();</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 5fb6adaaa796..5a760fd66bec 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -134,8 +134,6 @@</span> <span class="p_context"> void native_flush_tlb_others(const struct cpumask *cpumask,</span>
 {
 	struct flush_tlb_info info;
 
<span class="p_del">-	if (end == 0)</span>
<span class="p_del">-		end = start + PAGE_SIZE;</span>
 	info.flush_mm = mm;
 	info.flush_start = start;
 	info.flush_end = end;
<span class="p_chunk">@@ -264,7 +262,7 @@</span> <span class="p_context"> void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)</span>
 	}
 
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
<span class="p_del">-		flush_tlb_others(mm_cpumask(mm), mm, start, 0UL);</span>
<span class="p_add">+		flush_tlb_others(mm_cpumask(mm), mm, start, start + PAGE_SIZE);</span>
 
 	preempt_enable();
 }
<span class="p_header">diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c</span>
<span class="p_header">index 9d359e05fad7..8161090a1970 100644</span>
<span class="p_header">--- a/block/blk-cgroup.c</span>
<span class="p_header">+++ b/block/blk-cgroup.c</span>
<span class="p_chunk">@@ -788,6 +788,7 @@</span> <span class="p_context"> int blkg_conf_prep(struct blkcg *blkcg, const struct blkcg_policy *pol,</span>
 {
 	struct gendisk *disk;
 	struct blkcg_gq *blkg;
<span class="p_add">+	struct module *owner;</span>
 	unsigned int major, minor;
 	int key_len, part, ret;
 	char *body;
<span class="p_chunk">@@ -804,7 +805,9 @@</span> <span class="p_context"> int blkg_conf_prep(struct blkcg *blkcg, const struct blkcg_policy *pol,</span>
 	if (!disk)
 		return -ENODEV;
 	if (part) {
<span class="p_add">+		owner = disk-&gt;fops-&gt;owner;</span>
 		put_disk(disk);
<span class="p_add">+		module_put(owner);</span>
 		return -ENODEV;
 	}
 
<span class="p_chunk">@@ -820,7 +823,9 @@</span> <span class="p_context"> int blkg_conf_prep(struct blkcg *blkcg, const struct blkcg_policy *pol,</span>
 		ret = PTR_ERR(blkg);
 		rcu_read_unlock();
 		spin_unlock_irq(disk-&gt;queue-&gt;queue_lock);
<span class="p_add">+		owner = disk-&gt;fops-&gt;owner;</span>
 		put_disk(disk);
<span class="p_add">+		module_put(owner);</span>
 		/*
 		 * If queue was bypassing, we should retry.  Do so after a
 		 * short msleep().  It isn&#39;t strictly necessary but queue
<span class="p_chunk">@@ -851,9 +856,13 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(blkg_conf_prep);</span>
 void blkg_conf_finish(struct blkg_conf_ctx *ctx)
 	__releases(ctx-&gt;disk-&gt;queue-&gt;queue_lock) __releases(rcu)
 {
<span class="p_add">+	struct module *owner;</span>
<span class="p_add">+</span>
 	spin_unlock_irq(ctx-&gt;disk-&gt;queue-&gt;queue_lock);
 	rcu_read_unlock();
<span class="p_add">+	owner = ctx-&gt;disk-&gt;fops-&gt;owner;</span>
 	put_disk(ctx-&gt;disk);
<span class="p_add">+	module_put(owner);</span>
 }
 EXPORT_SYMBOL_GPL(blkg_conf_finish);
 
<span class="p_header">diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c</span>
<span class="p_header">index 31e8ae916ba0..be0b09a0fb44 100644</span>
<span class="p_header">--- a/drivers/char/virtio_console.c</span>
<span class="p_header">+++ b/drivers/char/virtio_console.c</span>
<span class="p_chunk">@@ -1864,7 +1864,7 @@</span> <span class="p_context"> static void config_work_handler(struct work_struct *work)</span>
 {
 	struct ports_device *portdev;
 
<span class="p_del">-	portdev = container_of(work, struct ports_device, control_work);</span>
<span class="p_add">+	portdev = container_of(work, struct ports_device, config_work);</span>
 	if (!use_multiport(portdev)) {
 		struct virtio_device *vdev;
 		struct port *port;
<span class="p_header">diff --git a/drivers/cpufreq/s3c2416-cpufreq.c b/drivers/cpufreq/s3c2416-cpufreq.c</span>
<span class="p_header">index d6d425773fa4..5b2db3c6568f 100644</span>
<span class="p_header">--- a/drivers/cpufreq/s3c2416-cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/s3c2416-cpufreq.c</span>
<span class="p_chunk">@@ -400,7 +400,6 @@</span> <span class="p_context"> static int s3c2416_cpufreq_driver_init(struct cpufreq_policy *policy)</span>
 	rate = clk_get_rate(s3c_freq-&gt;hclk);
 	if (rate &lt; 133 * 1000 * 1000) {
 		pr_err(&quot;cpufreq: HCLK not at 133MHz\n&quot;);
<span class="p_del">-		clk_put(s3c_freq-&gt;hclk);</span>
 		ret = -EINVAL;
 		goto err_armclk;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c</span>
<span class="p_header">index 25a3e2485cc2..2bc17a907ecf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c</span>
<span class="p_chunk">@@ -124,6 +124,13 @@</span> <span class="p_context"> int amdgpu_cs_get_ring(struct amdgpu_device *adev, u32 ip_type,</span>
 		}
 		break;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!(*out_ring &amp;&amp; (*out_ring)-&gt;adev)) {</span>
<span class="p_add">+		DRM_ERROR(&quot;Ring %d is not initialized on IP %d\n&quot;,</span>
<span class="p_add">+			  ring, ip_type);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_drv.h b/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_header">index b92139e9b9d8..b5c64edeb668 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_chunk">@@ -113,7 +113,11 @@</span> <span class="p_context"> struct ast_private {</span>
 	struct ttm_bo_kmap_obj cache_kmap;
 	int next_cursor;
 	bool support_wide_screen;
<span class="p_del">-	bool DisableP2A;</span>
<span class="p_add">+	enum {</span>
<span class="p_add">+		ast_use_p2a,</span>
<span class="p_add">+		ast_use_dt,</span>
<span class="p_add">+		ast_use_defaults</span>
<span class="p_add">+	} config_mode;</span>
 
 	enum ast_tx_chip tx_chip_type;
 	u8 dp501_maxclk;
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_main.c b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">index 6c021165ca67..498a94069e6b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_chunk">@@ -62,13 +62,84 @@</span> <span class="p_context"> uint8_t ast_get_index_reg_mask(struct ast_private *ast,</span>
 	return ret;
 }
 
<span class="p_add">+static void ast_detect_config_mode(struct drm_device *dev, u32 *scu_rev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *np = dev-&gt;pdev-&gt;dev.of_node;</span>
<span class="p_add">+	struct ast_private *ast = dev-&gt;dev_private;</span>
<span class="p_add">+	uint32_t data, jregd0, jregd1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Defaults */</span>
<span class="p_add">+	ast-&gt;config_mode = ast_use_defaults;</span>
<span class="p_add">+	*scu_rev = 0xffffffff;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if we have device-tree properties */</span>
<span class="p_add">+	if (np &amp;&amp; !of_property_read_u32(np, &quot;aspeed,scu-revision-id&quot;,</span>
<span class="p_add">+					scu_rev)) {</span>
<span class="p_add">+		/* We do, disable P2A access */</span>
<span class="p_add">+		ast-&gt;config_mode = ast_use_dt;</span>
<span class="p_add">+		DRM_INFO(&quot;Using device-tree for configuration\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Not all families have a P2A bridge */</span>
<span class="p_add">+	if (dev-&gt;pdev-&gt;device != PCI_CHIP_AST2000)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The BMC will set SCU 0x40 D[12] to 1 if the P2 bridge</span>
<span class="p_add">+	 * is disabled. We force using P2A if VGA only mode bit</span>
<span class="p_add">+	 * is set D[7]</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	jregd0 = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);</span>
<span class="p_add">+	jregd1 = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);</span>
<span class="p_add">+	if (!(jregd0 &amp; 0x80) || !(jregd1 &amp; 0x10)) {</span>
<span class="p_add">+		/* Double check it&#39;s actually working */</span>
<span class="p_add">+		data = ast_read32(ast, 0xf004);</span>
<span class="p_add">+		if (data != 0xFFFFFFFF) {</span>
<span class="p_add">+			/* P2A works, grab silicon revision */</span>
<span class="p_add">+			ast-&gt;config_mode = ast_use_p2a;</span>
<span class="p_add">+</span>
<span class="p_add">+			DRM_INFO(&quot;Using P2A bridge for configuration\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Read SCU7c (silicon revision register) */</span>
<span class="p_add">+			ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_add">+			ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_add">+			*scu_rev = ast_read32(ast, 0x1207c);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We have a P2A bridge but it&#39;s disabled */</span>
<span class="p_add">+	DRM_INFO(&quot;P2A bridge disabled, using default configuration\n&quot;);</span>
<span class="p_add">+}</span>
 
 static int ast_detect_chip(struct drm_device *dev, bool *need_post)
 {
 	struct ast_private *ast = dev-&gt;dev_private;
<span class="p_del">-	uint32_t data, jreg;</span>
<span class="p_add">+	uint32_t jreg, scu_rev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If VGA isn&#39;t enabled, we need to enable now or subsequent</span>
<span class="p_add">+	 * access to the scratch registers will fail. We also inform</span>
<span class="p_add">+	 * our caller that it needs to POST the chip</span>
<span class="p_add">+	 * (Assumption: VGA not enabled -&gt; need to POST)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ast_is_vga_enabled(dev)) {</span>
<span class="p_add">+		ast_enable_vga(dev);</span>
<span class="p_add">+		DRM_INFO(&quot;VGA not enabled on entry, requesting chip POST\n&quot;);</span>
<span class="p_add">+		*need_post = true;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		*need_post = false;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable extended register access */</span>
<span class="p_add">+	ast_enable_mmio(dev);</span>
 	ast_open_key(ast);
 
<span class="p_add">+	/* Find out whether P2A works or whether to use device-tree */</span>
<span class="p_add">+	ast_detect_config_mode(dev, &amp;scu_rev);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Identify chipset */</span>
 	if (dev-&gt;pdev-&gt;device == PCI_CHIP_AST1180) {
 		ast-&gt;chip = AST1100;
 		DRM_INFO(&quot;AST 1180 detected\n&quot;);
<span class="p_chunk">@@ -80,12 +151,7 @@</span> <span class="p_context"> static int ast_detect_chip(struct drm_device *dev, bool *need_post)</span>
 			ast-&gt;chip = AST2300;
 			DRM_INFO(&quot;AST 2300 detected\n&quot;);
 		} else if (dev-&gt;pdev-&gt;revision &gt;= 0x10) {
<span class="p_del">-			uint32_t data;</span>
<span class="p_del">-			ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_del">-			ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_del">-</span>
<span class="p_del">-			data = ast_read32(ast, 0x1207c);</span>
<span class="p_del">-			switch (data &amp; 0x0300) {</span>
<span class="p_add">+			switch (scu_rev &amp; 0x0300) {</span>
 			case 0x0200:
 				ast-&gt;chip = AST1100;
 				DRM_INFO(&quot;AST 1100 detected\n&quot;);
<span class="p_chunk">@@ -110,26 +176,6 @@</span> <span class="p_context"> static int ast_detect_chip(struct drm_device *dev, bool *need_post)</span>
 		}
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If VGA isn&#39;t enabled, we need to enable now or subsequent</span>
<span class="p_del">-	 * access to the scratch registers will fail. We also inform</span>
<span class="p_del">-	 * our caller that it needs to POST the chip</span>
<span class="p_del">-	 * (Assumption: VGA not enabled -&gt; need to POST)</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!ast_is_vga_enabled(dev)) {</span>
<span class="p_del">-		ast_enable_vga(dev);</span>
<span class="p_del">-		ast_enable_mmio(dev);</span>
<span class="p_del">-		DRM_INFO(&quot;VGA not enabled on entry, requesting chip POST\n&quot;);</span>
<span class="p_del">-		*need_post = true;</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		*need_post = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Check P2A Access */</span>
<span class="p_del">-	ast-&gt;DisableP2A = true;</span>
<span class="p_del">-	data = ast_read32(ast, 0xf004);</span>
<span class="p_del">-	if (data != 0xFFFFFFFF)</span>
<span class="p_del">-		ast-&gt;DisableP2A = false;</span>
<span class="p_del">-</span>
 	/* Check if we support wide screen */
 	switch (ast-&gt;chip) {
 	case AST1180:
<span class="p_chunk">@@ -146,17 +192,12 @@</span> <span class="p_context"> static int ast_detect_chip(struct drm_device *dev, bool *need_post)</span>
 			ast-&gt;support_wide_screen = true;
 		else {
 			ast-&gt;support_wide_screen = false;
<span class="p_del">-			if (ast-&gt;DisableP2A == false) {</span>
<span class="p_del">-				/* Read SCU7c (silicon revision register) */</span>
<span class="p_del">-				ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_del">-				ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_del">-				data = ast_read32(ast, 0x1207c);</span>
<span class="p_del">-				data &amp;= 0x300;</span>
<span class="p_del">-				if (ast-&gt;chip == AST2300 &amp;&amp; data == 0x0) /* ast1300 */</span>
<span class="p_del">-					ast-&gt;support_wide_screen = true;</span>
<span class="p_del">-				if (ast-&gt;chip == AST2400 &amp;&amp; data == 0x100) /* ast1400 */</span>
<span class="p_del">-					ast-&gt;support_wide_screen = true;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			if (ast-&gt;chip == AST2300 &amp;&amp;</span>
<span class="p_add">+			    (scu_rev &amp; 0x300) == 0x0) /* ast1300 */</span>
<span class="p_add">+				ast-&gt;support_wide_screen = true;</span>
<span class="p_add">+			if (ast-&gt;chip == AST2400 &amp;&amp;</span>
<span class="p_add">+			    (scu_rev &amp; 0x300) == 0x100) /* ast1400 */</span>
<span class="p_add">+				ast-&gt;support_wide_screen = true;</span>
 		}
 		break;
 	}
<span class="p_chunk">@@ -220,85 +261,102 @@</span> <span class="p_context"> static int ast_detect_chip(struct drm_device *dev, bool *need_post)</span>
 
 static int ast_get_dram_info(struct drm_device *dev)
 {
<span class="p_add">+	struct device_node *np = dev-&gt;pdev-&gt;dev.of_node;</span>
 	struct ast_private *ast = dev-&gt;dev_private;
<span class="p_del">-	uint32_t data, data2;</span>
<span class="p_del">-	uint32_t denum, num, div, ref_pll;</span>
<span class="p_add">+	uint32_t mcr_cfg, mcr_scu_mpll, mcr_scu_strap;</span>
<span class="p_add">+	uint32_t denum, num, div, ref_pll, dsel;</span>
 
<span class="p_del">-	if (ast-&gt;DisableP2A)</span>
<span class="p_del">-	{</span>
<span class="p_add">+	switch (ast-&gt;config_mode) {</span>
<span class="p_add">+	case ast_use_dt:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If some properties are missing, use reasonable</span>
<span class="p_add">+		 * defaults for AST2400</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;aspeed,mcr-configuration&quot;,</span>
<span class="p_add">+					 &amp;mcr_cfg))</span>
<span class="p_add">+			mcr_cfg = 0x00000577;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;aspeed,mcr-scu-mpll&quot;,</span>
<span class="p_add">+					 &amp;mcr_scu_mpll))</span>
<span class="p_add">+			mcr_scu_mpll = 0x000050C0;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;aspeed,mcr-scu-strap&quot;,</span>
<span class="p_add">+					 &amp;mcr_scu_strap))</span>
<span class="p_add">+			mcr_scu_strap = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case ast_use_p2a:</span>
<span class="p_add">+		ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_add">+		ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_add">+		mcr_cfg = ast_read32(ast, 0x10004);</span>
<span class="p_add">+		mcr_scu_mpll = ast_read32(ast, 0x10120);</span>
<span class="p_add">+		mcr_scu_strap = ast_read32(ast, 0x10170);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case ast_use_defaults:</span>
<span class="p_add">+	default:</span>
 		ast-&gt;dram_bus_width = 16;
 		ast-&gt;dram_type = AST_DRAM_1Gx16;
 		ast-&gt;mclk = 396;
<span class="p_add">+		return 0;</span>
 	}
<span class="p_del">-	else</span>
<span class="p_del">-	{</span>
<span class="p_del">-		ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_del">-		ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_del">-		data = ast_read32(ast, 0x10004);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (data &amp; 0x40)</span>
<span class="p_del">-			ast-&gt;dram_bus_width = 16;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ast-&gt;dram_bus_width = 32;</span>
 
<span class="p_del">-		if (ast-&gt;chip == AST2300 || ast-&gt;chip == AST2400) {</span>
<span class="p_del">-			switch (data &amp; 0x03) {</span>
<span class="p_del">-			case 0:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_512Mx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			default:</span>
<span class="p_del">-			case 1:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_1Gx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 2:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_2Gx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 3:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_4Gx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			switch (data &amp; 0x0c) {</span>
<span class="p_del">-			case 0:</span>
<span class="p_del">-			case 4:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_512Mx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 8:</span>
<span class="p_del">-				if (data &amp; 0x40)</span>
<span class="p_del">-					ast-&gt;dram_type = AST_DRAM_1Gx16;</span>
<span class="p_del">-				else</span>
<span class="p_del">-					ast-&gt;dram_type = AST_DRAM_512Mx32;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 0xc:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_1Gx32;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (mcr_cfg &amp; 0x40)</span>
<span class="p_add">+		ast-&gt;dram_bus_width = 16;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ast-&gt;dram_bus_width = 32;</span>
 
<span class="p_del">-		data = ast_read32(ast, 0x10120);</span>
<span class="p_del">-		data2 = ast_read32(ast, 0x10170);</span>
<span class="p_del">-		if (data2 &amp; 0x2000)</span>
<span class="p_del">-			ref_pll = 14318;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ref_pll = 12000;</span>
<span class="p_del">-</span>
<span class="p_del">-		denum = data &amp; 0x1f;</span>
<span class="p_del">-		num = (data &amp; 0x3fe0) &gt;&gt; 5;</span>
<span class="p_del">-		data = (data &amp; 0xc000) &gt;&gt; 14;</span>
<span class="p_del">-		switch (data) {</span>
<span class="p_del">-		case 3:</span>
<span class="p_del">-			div = 0x4;</span>
<span class="p_add">+	if (ast-&gt;chip == AST2300 || ast-&gt;chip == AST2400) {</span>
<span class="p_add">+		switch (mcr_cfg &amp; 0x03) {</span>
<span class="p_add">+		case 0:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_512Mx16;</span>
 			break;
<span class="p_del">-		case 2:</span>
<span class="p_add">+		default:</span>
 		case 1:
<span class="p_del">-			div = 0x2;</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_1Gx16;</span>
 			break;
<span class="p_del">-		default:</span>
<span class="p_del">-			div = 0x1;</span>
<span class="p_add">+		case 2:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_2Gx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 3:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_4Gx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		switch (mcr_cfg &amp; 0x0c) {</span>
<span class="p_add">+		case 0:</span>
<span class="p_add">+		case 4:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_512Mx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 8:</span>
<span class="p_add">+			if (mcr_cfg &amp; 0x40)</span>
<span class="p_add">+				ast-&gt;dram_type = AST_DRAM_1Gx16;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				ast-&gt;dram_type = AST_DRAM_512Mx32;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0xc:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_1Gx32;</span>
 			break;
 		}
<span class="p_del">-		ast-&gt;mclk = ref_pll * (num + 2) / (denum + 2) * (div * 1000);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (mcr_scu_strap &amp; 0x2000)</span>
<span class="p_add">+		ref_pll = 14318;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ref_pll = 12000;</span>
<span class="p_add">+</span>
<span class="p_add">+	denum = mcr_scu_mpll &amp; 0x1f;</span>
<span class="p_add">+	num = (mcr_scu_mpll &amp; 0x3fe0) &gt;&gt; 5;</span>
<span class="p_add">+	dsel = (mcr_scu_mpll &amp; 0xc000) &gt;&gt; 14;</span>
<span class="p_add">+	switch (dsel) {</span>
<span class="p_add">+	case 3:</span>
<span class="p_add">+		div = 0x4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		div = 0x2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		div = 0x1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ast-&gt;mclk = ref_pll * (num + 2) / (denum + 2) * (div * 1000);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_post.c b/drivers/gpu/drm/ast/ast_post.c</span>
<span class="p_header">index 270e8fb2803f..c7c58becb25d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_post.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_post.c</span>
<span class="p_chunk">@@ -375,17 +375,14 @@</span> <span class="p_context"> void ast_post_gpu(struct drm_device *dev)</span>
 	ast_enable_mmio(dev);
 	ast_set_def_ext_reg(dev);
 
<span class="p_del">-	if (ast-&gt;DisableP2A == false)</span>
<span class="p_del">-	{</span>
<span class="p_add">+	if (ast-&gt;config_mode == ast_use_p2a) {</span>
 		if (ast-&gt;chip == AST2300 || ast-&gt;chip == AST2400)
 			ast_init_dram_2300(dev);
 		else
 			ast_init_dram_reg(dev);
 
 		ast_init_3rdtx(dev);
<span class="p_del">-	}</span>
<span class="p_del">-	else</span>
<span class="p_del">-	{</span>
<span class="p_add">+	} else {</span>
 		if (ast-&gt;tx_chip_type != AST_TX_NONE)
 			ast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xcf, 0x80);	/* Enable DVO */
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c b/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c</span>
<span class="p_header">index 13db8a2851ed..1f013d45c9e9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c</span>
<span class="p_chunk">@@ -321,6 +321,7 @@</span> <span class="p_context"> void vmw_cmdbuf_res_man_destroy(struct vmw_cmdbuf_res_manager *man)</span>
 	list_for_each_entry_safe(entry, next, &amp;man-&gt;list, head)
 		vmw_cmdbuf_res_free(man, entry);
 
<span class="p_add">+	drm_ht_remove(&amp;man-&gt;resources);</span>
 	kfree(man);
 }
 
<span class="p_header">diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">index 0b80633bae91..d4d655a10df1 100644</span>
<span class="p_header">--- a/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">+++ b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_chunk">@@ -364,6 +364,15 @@</span> <span class="p_context"> static int i2c_hid_hwreset(struct i2c_client *client)</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The HID over I2C specification states that if a DEVICE needs time</span>
<span class="p_add">+	 * after the PWR_ON request, it should utilise CLOCK stretching.</span>
<span class="p_add">+	 * However, it has been observered that the Windows driver provides a</span>
<span class="p_add">+	 * 1ms sleep between the PWR_ON and RESET requests and that some devices</span>
<span class="p_add">+	 * rely on this.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	usleep_range(1000, 5000);</span>
<span class="p_add">+</span>
 	i2c_hid_dbg(ihid, &quot;resetting...\n&quot;);
 
 	ret = i2c_hid_command(client, &amp;hid_reset_cmd, NULL, 0);
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_v2.c b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">index 4831eb910fc7..22160e481794 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_chunk">@@ -699,9 +699,9 @@</span> <span class="p_context"> out_clear_state:</span>
 
 out_unregister:
 	mmu_notifier_unregister(&amp;pasid_state-&gt;mn, mm);
<span class="p_add">+	mmput(mm);</span>
 
 out_free:
<span class="p_del">-	mmput(mm);</span>
 	free_pasid_state(pasid_state);
 
 out:
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index b92b8a724efb..f9711aceef54 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -1137,7 +1137,7 @@</span> <span class="p_context"> static void dma_pte_free_level(struct dmar_domain *domain, int level,</span>
 		if (!dma_pte_present(pte) || dma_pte_superpage(pte))
 			goto next;
 
<span class="p_del">-		level_pfn = pfn &amp; level_mask(level - 1);</span>
<span class="p_add">+		level_pfn = pfn &amp; level_mask(level);</span>
 		level_pte = phys_to_virt(dma_pte_addr(pte));
 
 		if (level &gt; 2)
<span class="p_header">diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="p_header">index 515bb8b80952..a070fa39521a 100644</span>
<span class="p_header">--- a/drivers/iommu/iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/iommu.c</span>
<span class="p_chunk">@@ -391,36 +391,30 @@</span> <span class="p_context"> int iommu_group_add_device(struct iommu_group *group, struct device *dev)</span>
 	device-&gt;dev = dev;
 
 	ret = sysfs_create_link(&amp;dev-&gt;kobj, &amp;group-&gt;kobj, &quot;iommu_group&quot;);
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		kfree(device);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto err_free_device;</span>
 
 	device-&gt;name = kasprintf(GFP_KERNEL, &quot;%s&quot;, kobject_name(&amp;dev-&gt;kobj));
 rename:
 	if (!device-&gt;name) {
<span class="p_del">-		sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="p_del">-		kfree(device);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto err_remove_link;</span>
 	}
 
 	ret = sysfs_create_link_nowarn(group-&gt;devices_kobj,
 				       &amp;dev-&gt;kobj, device-&gt;name);
 	if (ret) {
<span class="p_del">-		kfree(device-&gt;name);</span>
 		if (ret == -EEXIST &amp;&amp; i &gt;= 0) {
 			/*
 			 * Account for the slim chance of collision
 			 * and append an instance to the name.
 			 */
<span class="p_add">+			kfree(device-&gt;name);</span>
 			device-&gt;name = kasprintf(GFP_KERNEL, &quot;%s.%d&quot;,
 						 kobject_name(&amp;dev-&gt;kobj), i++);
 			goto rename;
 		}
<span class="p_del">-</span>
<span class="p_del">-		sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="p_del">-		kfree(device);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err_free_name;</span>
 	}
 
 	kobject_get(group-&gt;devices_kobj);
<span class="p_chunk">@@ -432,8 +426,10 @@</span> <span class="p_context"> rename:</span>
 	mutex_lock(&amp;group-&gt;mutex);
 	list_add_tail(&amp;device-&gt;list, &amp;group-&gt;devices);
 	if (group-&gt;domain)
<span class="p_del">-		__iommu_attach_device(group-&gt;domain, dev);</span>
<span class="p_add">+		ret = __iommu_attach_device(group-&gt;domain, dev);</span>
 	mutex_unlock(&amp;group-&gt;mutex);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto err_put_group;</span>
 
 	/* Notify any listeners about change to group. */
 	blocking_notifier_call_chain(&amp;group-&gt;notifier,
<span class="p_chunk">@@ -444,6 +440,21 @@</span> <span class="p_context"> rename:</span>
 	pr_info(&quot;Adding device %s to group %d\n&quot;, dev_name(dev), group-&gt;id);
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err_put_group:</span>
<span class="p_add">+	mutex_lock(&amp;group-&gt;mutex);</span>
<span class="p_add">+	list_del(&amp;device-&gt;list);</span>
<span class="p_add">+	mutex_unlock(&amp;group-&gt;mutex);</span>
<span class="p_add">+	dev-&gt;iommu_group = NULL;</span>
<span class="p_add">+	kobject_put(group-&gt;devices_kobj);</span>
<span class="p_add">+err_free_name:</span>
<span class="p_add">+	kfree(device-&gt;name);</span>
<span class="p_add">+err_remove_link:</span>
<span class="p_add">+	sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="p_add">+err_free_device:</span>
<span class="p_add">+	kfree(device);</span>
<span class="p_add">+	pr_err(&quot;Failed to add device %s to group %d: %d\n&quot;, dev_name(dev), group-&gt;id, ret);</span>
<span class="p_add">+	return ret;</span>
 }
 EXPORT_SYMBOL_GPL(iommu_group_add_device);
 
<span class="p_header">diff --git a/drivers/mtd/bcm47xxpart.c b/drivers/mtd/bcm47xxpart.c</span>
<span class="p_header">index 5abab8800891..9190057535e6 100644</span>
<span class="p_header">--- a/drivers/mtd/bcm47xxpart.c</span>
<span class="p_header">+++ b/drivers/mtd/bcm47xxpart.c</span>
<span class="p_chunk">@@ -66,11 +66,13 @@</span> <span class="p_context"> static const char *bcm47xxpart_trx_data_part_name(struct mtd_info *master,</span>
 {
 	uint32_t buf;
 	size_t bytes_read;
<span class="p_add">+	int err;</span>
 
<span class="p_del">-	if (mtd_read(master, offset, sizeof(buf), &amp;bytes_read,</span>
<span class="p_del">-		     (uint8_t *)&amp;buf) &lt; 0) {</span>
<span class="p_del">-		pr_err(&quot;mtd_read error while parsing (offset: 0x%X)!\n&quot;,</span>
<span class="p_del">-			offset);</span>
<span class="p_add">+	err  = mtd_read(master, offset, sizeof(buf), &amp;bytes_read,</span>
<span class="p_add">+			(uint8_t *)&amp;buf);</span>
<span class="p_add">+	if (err &amp;&amp; !mtd_is_bitflip(err)) {</span>
<span class="p_add">+		pr_err(&quot;mtd_read error while parsing (offset: 0x%X): %d\n&quot;,</span>
<span class="p_add">+			offset, err);</span>
 		goto out_default;
 	}
 
<span class="p_chunk">@@ -95,6 +97,7 @@</span> <span class="p_context"> static int bcm47xxpart_parse(struct mtd_info *master,</span>
 	int trx_part = -1;
 	int last_trx_part = -1;
 	int possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };
<span class="p_add">+	int err;</span>
 
 	/*
 	 * Some really old flashes (like AT45DB*) had smaller erasesize-s, but
<span class="p_chunk">@@ -118,8 +121,8 @@</span> <span class="p_context"> static int bcm47xxpart_parse(struct mtd_info *master,</span>
 	/* Parse block by block looking for magics */
 	for (offset = 0; offset &lt;= master-&gt;size - blocksize;
 	     offset += blocksize) {
<span class="p_del">-		/* Nothing more in higher memory */</span>
<span class="p_del">-		if (offset &gt;= 0x2000000)</span>
<span class="p_add">+		/* Nothing more in higher memory on BCM47XX (MIPS) */</span>
<span class="p_add">+		if (config_enabled(CONFIG_BCM47XX) &amp;&amp; offset &gt;= 0x2000000)</span>
 			break;
 
 		if (curr_part &gt;= BCM47XXPART_MAX_PARTS) {
<span class="p_chunk">@@ -128,10 +131,11 @@</span> <span class="p_context"> static int bcm47xxpart_parse(struct mtd_info *master,</span>
 		}
 
 		/* Read beginning of the block */
<span class="p_del">-		if (mtd_read(master, offset, BCM47XXPART_BYTES_TO_READ,</span>
<span class="p_del">-			     &amp;bytes_read, (uint8_t *)buf) &lt; 0) {</span>
<span class="p_del">-			pr_err(&quot;mtd_read error while parsing (offset: 0x%X)!\n&quot;,</span>
<span class="p_del">-			       offset);</span>
<span class="p_add">+		err = mtd_read(master, offset, BCM47XXPART_BYTES_TO_READ,</span>
<span class="p_add">+			       &amp;bytes_read, (uint8_t *)buf);</span>
<span class="p_add">+		if (err &amp;&amp; !mtd_is_bitflip(err)) {</span>
<span class="p_add">+			pr_err(&quot;mtd_read error while parsing (offset: 0x%X): %d\n&quot;,</span>
<span class="p_add">+			       offset, err);</span>
 			continue;
 		}
 
<span class="p_chunk">@@ -252,10 +256,11 @@</span> <span class="p_context"> static int bcm47xxpart_parse(struct mtd_info *master,</span>
 		}
 
 		/* Read middle of the block */
<span class="p_del">-		if (mtd_read(master, offset + 0x8000, 0x4,</span>
<span class="p_del">-			     &amp;bytes_read, (uint8_t *)buf) &lt; 0) {</span>
<span class="p_del">-			pr_err(&quot;mtd_read error while parsing (offset: 0x%X)!\n&quot;,</span>
<span class="p_del">-			       offset);</span>
<span class="p_add">+		err = mtd_read(master, offset + 0x8000, 0x4, &amp;bytes_read,</span>
<span class="p_add">+			       (uint8_t *)buf);</span>
<span class="p_add">+		if (err &amp;&amp; !mtd_is_bitflip(err)) {</span>
<span class="p_add">+			pr_err(&quot;mtd_read error while parsing (offset: 0x%X): %d\n&quot;,</span>
<span class="p_add">+			       offset, err);</span>
 			continue;
 		}
 
<span class="p_chunk">@@ -275,10 +280,11 @@</span> <span class="p_context"> static int bcm47xxpart_parse(struct mtd_info *master,</span>
 		}
 
 		offset = master-&gt;size - possible_nvram_sizes[i];
<span class="p_del">-		if (mtd_read(master, offset, 0x4, &amp;bytes_read,</span>
<span class="p_del">-			     (uint8_t *)buf) &lt; 0) {</span>
<span class="p_del">-			pr_err(&quot;mtd_read error while reading at offset 0x%X!\n&quot;,</span>
<span class="p_del">-			       offset);</span>
<span class="p_add">+		err = mtd_read(master, offset, 0x4, &amp;bytes_read,</span>
<span class="p_add">+			       (uint8_t *)buf);</span>
<span class="p_add">+		if (err &amp;&amp; !mtd_is_bitflip(err)) {</span>
<span class="p_add">+			pr_err(&quot;mtd_read error while reading (offset 0x%X): %d\n&quot;,</span>
<span class="p_add">+			       offset, err);</span>
 			continue;
 		}
 
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">index 5e6238e0b2bd..75e6e7e6baed 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_chunk">@@ -2732,8 +2732,10 @@</span> <span class="p_context"> static int xgbe_init(struct xgbe_prv_data *pdata)</span>
 
 	/* Flush Tx queues */
 	ret = xgbe_flush_tx_queues(pdata);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		netdev_err(pdata-&gt;netdev, &quot;error flushing TX queues\n&quot;);</span>
 		return ret;
<span class="p_add">+	}</span>
 
 	/*
 	 * Initialize DMA related features
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_header">index 865b7e0b133b..64034ff081a0 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_chunk">@@ -877,7 +877,9 @@</span> <span class="p_context"> static int xgbe_start(struct xgbe_prv_data *pdata)</span>
 
 	DBGPR(&quot;--&gt;xgbe_start\n&quot;);
 
<span class="p_del">-	hw_if-&gt;init(pdata);</span>
<span class="p_add">+	ret = hw_if-&gt;init(pdata);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	ret = phy_if-&gt;phy_start(pdata);
 	if (ret)
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bgmac.c b/drivers/net/ethernet/broadcom/bgmac.c</span>
<span class="p_header">index b56c9c581359..70da30095b89 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bgmac.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bgmac.c</span>
<span class="p_chunk">@@ -255,15 +255,16 @@</span> <span class="p_context"> static void bgmac_dma_tx_free(struct bgmac *bgmac, struct bgmac_dma_ring *ring)</span>
 	while (ring-&gt;start != ring-&gt;end) {
 		int slot_idx = ring-&gt;start % BGMAC_TX_RING_SLOTS;
 		struct bgmac_slot_info *slot = &amp;ring-&gt;slots[slot_idx];
<span class="p_del">-		u32 ctl1;</span>
<span class="p_add">+		u32 ctl0, ctl1;</span>
 		int len;
 
 		if (slot_idx == empty_slot)
 			break;
 
<span class="p_add">+		ctl0 = le32_to_cpu(ring-&gt;cpu_base[slot_idx].ctl0);</span>
 		ctl1 = le32_to_cpu(ring-&gt;cpu_base[slot_idx].ctl1);
 		len = ctl1 &amp; BGMAC_DESC_CTL1_LEN;
<span class="p_del">-		if (ctl1 &amp; BGMAC_DESC_CTL0_SOF)</span>
<span class="p_add">+		if (ctl0 &amp; BGMAC_DESC_CTL0_SOF)</span>
 			/* Unmap no longer used buffer */
 			dma_unmap_single(dma_dev, slot-&gt;dma_addr, len,
 					 DMA_TO_DEVICE);
<span class="p_chunk">@@ -469,6 +470,11 @@</span> <span class="p_context"> static int bgmac_dma_rx_read(struct bgmac *bgmac, struct bgmac_dma_ring *ring,</span>
 			len -= ETH_FCS_LEN;
 
 			skb = build_skb(buf, BGMAC_RX_ALLOC_SIZE);
<span class="p_add">+			if (unlikely(!skb)) {</span>
<span class="p_add">+				bgmac_err(bgmac, &quot;build_skb failed\n&quot;);</span>
<span class="p_add">+				put_page(virt_to_head_page(buf));</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 			skb_put(skb, BGMAC_RX_FRAME_OFFSET +
 				BGMAC_RX_BUF_OFFSET + len);
 			skb_pull(skb, BGMAC_RX_FRAME_OFFSET +
<span class="p_chunk">@@ -1302,7 +1308,8 @@</span> <span class="p_context"> static int bgmac_open(struct net_device *net_dev)</span>
 
 	phy_start(bgmac-&gt;phy_dev);
 
<span class="p_del">-	netif_carrier_on(net_dev);</span>
<span class="p_add">+	netif_start_queue(net_dev);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">index 1795c935ff02..7b8638ddb673 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_chunk">@@ -1052,7 +1052,7 @@</span> <span class="p_context"> int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,</span>
 err:
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
 
<span class="p_del">-	 if (status == MCC_STATUS_UNAUTHORIZED_REQUEST)</span>
<span class="p_add">+	 if (base_status(status) == MCC_STATUS_UNAUTHORIZED_REQUEST)</span>
 		status = -EPERM;
 
 	return status;
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">index 6a061f17a44f..4cd2a7d0124f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_chunk">@@ -2939,7 +2939,7 @@</span> <span class="p_context"> static bool gfar_add_rx_frag(struct gfar_rx_buff *rxb, u32 lstatus,</span>
 				size, GFAR_RXB_TRUESIZE);
 
 	/* try reuse page */
<span class="p_del">-	if (unlikely(page_count(page) != 1))</span>
<span class="p_add">+	if (unlikely(page_count(page) != 1 || page_is_pfmemalloc(page)))</span>
 		return false;
 
 	/* change offset to the other half */
<span class="p_header">diff --git a/drivers/net/ethernet/ibm/ibmveth.c b/drivers/net/ethernet/ibm/ibmveth.c</span>
<span class="p_header">index f9e4988ea30e..2f9b12cf9ee5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ibm/ibmveth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ibm/ibmveth.c</span>
<span class="p_chunk">@@ -1602,8 +1602,11 @@</span> <span class="p_context"> static int ibmveth_probe(struct vio_dev *dev, const struct vio_device_id *id)</span>
 	netdev-&gt;netdev_ops = &amp;ibmveth_netdev_ops;
 	netdev-&gt;ethtool_ops = &amp;netdev_ethtool_ops;
 	SET_NETDEV_DEV(netdev, &amp;dev-&gt;dev);
<span class="p_del">-	netdev-&gt;hw_features = NETIF_F_SG | NETIF_F_RXCSUM |</span>
<span class="p_del">-		NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;</span>
<span class="p_add">+	netdev-&gt;hw_features = NETIF_F_SG;</span>
<span class="p_add">+	if (vio_get_attribute(dev, &quot;ibm,illan-options&quot;, NULL) != NULL) {</span>
<span class="p_add">+		netdev-&gt;hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |</span>
<span class="p_add">+				       NETIF_F_RXCSUM;</span>
<span class="p_add">+	}</span>
 
 	netdev-&gt;features |= netdev-&gt;hw_features;
 
<span class="p_header">diff --git a/drivers/net/ethernet/korina.c b/drivers/net/ethernet/korina.c</span>
<span class="p_header">index d74f5f4e5782..07eabf72c480 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/korina.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/korina.c</span>
<span class="p_chunk">@@ -900,10 +900,10 @@</span> <span class="p_context"> static void korina_restart_task(struct work_struct *work)</span>
 				DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR,
 				&amp;lp-&gt;rx_dma_regs-&gt;dmasm);
 
<span class="p_del">-	korina_free_ring(dev);</span>
<span class="p_del">-</span>
 	napi_disable(&amp;lp-&gt;napi);
 
<span class="p_add">+	korina_free_ring(dev);</span>
<span class="p_add">+</span>
 	if (korina_init(dev) &lt; 0) {
 		printk(KERN_ERR &quot;%s: cannot restart device\n&quot;, dev-&gt;name);
 		return;
<span class="p_chunk">@@ -1064,12 +1064,12 @@</span> <span class="p_context"> static int korina_close(struct net_device *dev)</span>
 	tmp = tmp | DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR;
 	writel(tmp, &amp;lp-&gt;rx_dma_regs-&gt;dmasm);
 
<span class="p_del">-	korina_free_ring(dev);</span>
<span class="p_del">-</span>
 	napi_disable(&amp;lp-&gt;napi);
 
 	cancel_work_sync(&amp;lp-&gt;restart_task);
 
<span class="p_add">+	korina_free_ring(dev);</span>
<span class="p_add">+</span>
 	free_irq(lp-&gt;rx_irq, dev);
 	free_irq(lp-&gt;tx_irq, dev);
 	free_irq(lp-&gt;ovr_irq, dev);
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 71ec9cb08e06..15056f06754a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -2446,7 +2446,7 @@</span> <span class="p_context"> static void mvneta_start_dev(struct mvneta_port *pp)</span>
 	mvneta_port_enable(pp);
 
 	/* Enable polling on the port */
<span class="p_del">-	for_each_present_cpu(cpu) {</span>
<span class="p_add">+	for_each_online_cpu(cpu) {</span>
 		struct mvneta_pcpu_port *port = per_cpu_ptr(pp-&gt;ports, cpu);
 
 		napi_enable(&amp;port-&gt;napi);
<span class="p_chunk">@@ -2472,7 +2472,7 @@</span> <span class="p_context"> static void mvneta_stop_dev(struct mvneta_port *pp)</span>
 
 	phy_stop(pp-&gt;phy_dev);
 
<span class="p_del">-	for_each_present_cpu(cpu) {</span>
<span class="p_add">+	for_each_online_cpu(cpu) {</span>
 		struct mvneta_pcpu_port *port = per_cpu_ptr(pp-&gt;ports, cpu);
 
 		napi_disable(&amp;port-&gt;napi);
<span class="p_chunk">@@ -2902,13 +2902,11 @@</span> <span class="p_context"> err_cleanup_rxqs:</span>
 static int mvneta_stop(struct net_device *dev)
 {
 	struct mvneta_port *pp = netdev_priv(dev);
<span class="p_del">-	int cpu;</span>
 
 	mvneta_stop_dev(pp);
 	mvneta_mdio_remove(pp);
 	unregister_cpu_notifier(&amp;pp-&gt;cpu_notifier);
<span class="p_del">-	for_each_present_cpu(cpu)</span>
<span class="p_del">-		smp_call_function_single(cpu, mvneta_percpu_disable, pp, true);</span>
<span class="p_add">+	on_each_cpu(mvneta_percpu_disable, pp, true);</span>
 	free_percpu_irq(dev-&gt;irq, pp-&gt;ports);
 	mvneta_cleanup_rxqs(pp);
 	mvneta_cleanup_txqs(pp);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">index 603d1c3d3b2e..ff77b8b608bd 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_chunk">@@ -542,8 +542,9 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 			break;
 
 		case MLX4_EVENT_TYPE_SRQ_LIMIT:
<span class="p_del">-			mlx4_dbg(dev, &quot;%s: MLX4_EVENT_TYPE_SRQ_LIMIT\n&quot;,</span>
<span class="p_del">-				 __func__);</span>
<span class="p_add">+			mlx4_dbg(dev, &quot;%s: MLX4_EVENT_TYPE_SRQ_LIMIT. srq_no=0x%x, eq 0x%x\n&quot;,</span>
<span class="p_add">+				 __func__, be32_to_cpu(eqe-&gt;event.srq.srqn),</span>
<span class="p_add">+				 eq-&gt;eqn);</span>
 		case MLX4_EVENT_TYPE_SRQ_CATAS_ERROR:
 			if (mlx4_is_master(dev)) {
 				/* forward only to slave owning the SRQ */
<span class="p_chunk">@@ -558,15 +559,19 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 						  eq-&gt;eqn, eq-&gt;cons_index, ret);
 					break;
 				}
<span class="p_del">-				mlx4_warn(dev, &quot;%s: slave:%d, srq_no:0x%x, event: %02x(%02x)\n&quot;,</span>
<span class="p_del">-					  __func__, slave,</span>
<span class="p_del">-					  be32_to_cpu(eqe-&gt;event.srq.srqn),</span>
<span class="p_del">-					  eqe-&gt;type, eqe-&gt;subtype);</span>
<span class="p_add">+				if (eqe-&gt;type ==</span>
<span class="p_add">+				    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)</span>
<span class="p_add">+					mlx4_warn(dev, &quot;%s: slave:%d, srq_no:0x%x, event: %02x(%02x)\n&quot;,</span>
<span class="p_add">+						  __func__, slave,</span>
<span class="p_add">+						  be32_to_cpu(eqe-&gt;event.srq.srqn),</span>
<span class="p_add">+						  eqe-&gt;type, eqe-&gt;subtype);</span>
 
 				if (!ret &amp;&amp; slave != dev-&gt;caps.function) {
<span class="p_del">-					mlx4_warn(dev, &quot;%s: sending event %02x(%02x) to slave:%d\n&quot;,</span>
<span class="p_del">-						  __func__, eqe-&gt;type,</span>
<span class="p_del">-						  eqe-&gt;subtype, slave);</span>
<span class="p_add">+					if (eqe-&gt;type ==</span>
<span class="p_add">+					    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)</span>
<span class="p_add">+						mlx4_warn(dev, &quot;%s: sending event %02x(%02x) to slave:%d\n&quot;,</span>
<span class="p_add">+							  __func__, eqe-&gt;type,</span>
<span class="p_add">+							  eqe-&gt;subtype, slave);</span>
 					mlx4_slave_event(dev, slave, eqe);
 					break;
 				}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">index 1e611980cf99..f5c1f4acc57b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_chunk">@@ -153,8 +153,9 @@</span> <span class="p_context"> static struct mlx5_profile profile[] = {</span>
 	},
 };
 
<span class="p_del">-#define FW_INIT_TIMEOUT_MILI	2000</span>
<span class="p_del">-#define FW_INIT_WAIT_MS		2</span>
<span class="p_add">+#define FW_INIT_TIMEOUT_MILI		2000</span>
<span class="p_add">+#define FW_INIT_WAIT_MS			2</span>
<span class="p_add">+#define FW_PRE_INIT_TIMEOUT_MILI	10000</span>
 
 static int wait_fw_init(struct mlx5_core_dev *dev, u32 max_wait_mili)
 {
<span class="p_chunk">@@ -934,6 +935,15 @@</span> <span class="p_context"> static int mlx5_load_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv)</span>
 	 */
 	dev-&gt;state = MLX5_DEVICE_STATE_UP;
 
<span class="p_add">+	/* wait for firmware to accept initialization segments configurations</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = wait_fw_init(dev, FW_PRE_INIT_TIMEOUT_MILI);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;pdev-&gt;dev, &quot;Firmware over %d MS in pre-initializing state, aborting\n&quot;,</span>
<span class="p_add">+			FW_PRE_INIT_TIMEOUT_MILI);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = mlx5_cmd_init(dev);
 	if (err) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed initializing command interface, aborting\n&quot;);
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/ravb_main.c b/drivers/net/ethernet/renesas/ravb_main.c</span>
<span class="p_header">index 1e61d4da72db..585e90f8341d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/ravb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/ravb_main.c</span>
<span class="p_chunk">@@ -221,18 +221,6 @@</span> <span class="p_context"> static void ravb_ring_free(struct net_device *ndev, int q)</span>
 	int ring_size;
 	int i;
 
<span class="p_del">-	/* Free RX skb ringbuffer */</span>
<span class="p_del">-	if (priv-&gt;rx_skb[q]) {</span>
<span class="p_del">-		for (i = 0; i &lt; priv-&gt;num_rx_ring[q]; i++)</span>
<span class="p_del">-			dev_kfree_skb(priv-&gt;rx_skb[q][i]);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	kfree(priv-&gt;rx_skb[q]);</span>
<span class="p_del">-	priv-&gt;rx_skb[q] = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Free aligned TX buffers */</span>
<span class="p_del">-	kfree(priv-&gt;tx_align[q]);</span>
<span class="p_del">-	priv-&gt;tx_align[q] = NULL;</span>
<span class="p_del">-</span>
 	if (priv-&gt;rx_ring[q]) {
 		for (i = 0; i &lt; priv-&gt;num_rx_ring[q]; i++) {
 			struct ravb_ex_rx_desc *desc = &amp;priv-&gt;rx_ring[q][i];
<span class="p_chunk">@@ -261,6 +249,18 @@</span> <span class="p_context"> static void ravb_ring_free(struct net_device *ndev, int q)</span>
 		priv-&gt;tx_ring[q] = NULL;
 	}
 
<span class="p_add">+	/* Free RX skb ringbuffer */</span>
<span class="p_add">+	if (priv-&gt;rx_skb[q]) {</span>
<span class="p_add">+		for (i = 0; i &lt; priv-&gt;num_rx_ring[q]; i++)</span>
<span class="p_add">+			dev_kfree_skb(priv-&gt;rx_skb[q][i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kfree(priv-&gt;rx_skb[q]);</span>
<span class="p_add">+	priv-&gt;rx_skb[q] = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Free aligned TX buffers */</span>
<span class="p_add">+	kfree(priv-&gt;tx_align[q]);</span>
<span class="p_add">+	priv-&gt;tx_align[q] = NULL;</span>
<span class="p_add">+</span>
 	/* Free TX skb ringbuffer.
 	 * SKBs are freed by ravb_tx_free() call above.
 	 */
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/falcon.c b/drivers/net/ethernet/sfc/falcon.c</span>
<span class="p_header">index d790cb8d9db3..8e832ba8ab24 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/falcon.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/falcon.c</span>
<span class="p_chunk">@@ -2796,6 +2796,11 @@</span> <span class="p_context"> const struct efx_nic_type falcon_a1_nic_type = {</span>
 	.timer_period_max =  1 &lt;&lt; FRF_AB_TC_TIMER_VAL_WIDTH,
 	.offload_features = NETIF_F_IP_CSUM,
 	.mcdi_max_ver = -1,
<span class="p_add">+#ifdef CONFIG_SFC_SRIOV</span>
<span class="p_add">+	.vswitching_probe = efx_port_dummy_op_int,</span>
<span class="p_add">+	.vswitching_restore = efx_port_dummy_op_int,</span>
<span class="p_add">+	.vswitching_remove = efx_port_dummy_op_void,</span>
<span class="p_add">+#endif</span>
 };
 
 const struct efx_nic_type falcon_b0_nic_type = {
<span class="p_chunk">@@ -2897,4 +2902,9 @@</span> <span class="p_context"> const struct efx_nic_type falcon_b0_nic_type = {</span>
 	.offload_features = NETIF_F_IP_CSUM | NETIF_F_RXHASH | NETIF_F_NTUPLE,
 	.mcdi_max_ver = -1,
 	.max_rx_ip_filters = FR_BZ_RX_FILTER_TBL0_ROWS,
<span class="p_add">+#ifdef CONFIG_SFC_SRIOV</span>
<span class="p_add">+	.vswitching_probe = efx_port_dummy_op_int,</span>
<span class="p_add">+	.vswitching_restore = efx_port_dummy_op_int,</span>
<span class="p_add">+	.vswitching_remove = efx_port_dummy_op_void,</span>
<span class="p_add">+#endif</span>
 };
<span class="p_header">diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c</span>
<span class="p_header">index 7f7c87762bc6..8dfc75250583 100644</span>
<span class="p_header">--- a/drivers/net/virtio_net.c</span>
<span class="p_header">+++ b/drivers/net/virtio_net.c</span>
<span class="p_chunk">@@ -47,8 +47,16 @@</span> <span class="p_context"> module_param(gso, bool, 0444);</span>
  */
 DECLARE_EWMA(pkt_len, 1, 64)
 
<span class="p_add">+/* With mergeable buffers we align buffer address and use the low bits to</span>
<span class="p_add">+ * encode its true size. Buffer size is up to 1 page so we need to align to</span>
<span class="p_add">+ * square root of page size to ensure we reserve enough bits to encode the true</span>
<span class="p_add">+ * size.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MERGEABLE_BUFFER_MIN_ALIGN_SHIFT ((PAGE_SHIFT + 1) / 2)</span>
<span class="p_add">+</span>
 /* Minimum alignment for mergeable packet buffers. */
<span class="p_del">-#define MERGEABLE_BUFFER_ALIGN max(L1_CACHE_BYTES, 256)</span>
<span class="p_add">+#define MERGEABLE_BUFFER_ALIGN max(L1_CACHE_BYTES, \</span>
<span class="p_add">+				   1 &lt;&lt; MERGEABLE_BUFFER_MIN_ALIGN_SHIFT)</span>
 
 #define VIRTNET_DRIVER_VERSION &quot;1.0.0&quot;
 
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index 9a986ccd42e5..dab3bf6649e6 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -2240,7 +2240,7 @@</span> <span class="p_context"> static void vxlan_cleanup(unsigned long arg)</span>
 				= container_of(p, struct vxlan_fdb, hlist);
 			unsigned long timeout;
 
<span class="p_del">-			if (f-&gt;state &amp; NUD_PERMANENT)</span>
<span class="p_add">+			if (f-&gt;state &amp; (NUD_PERMANENT | NUD_NOARP))</span>
 				continue;
 
 			timeout = f-&gt;used + vxlan-&gt;cfg.age_interval * HZ;
<span class="p_header">diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c</span>
<span class="p_header">index 888e9cfef51a..34a062ccb11d 100644</span>
<span class="p_header">--- a/drivers/net/xen-netfront.c</span>
<span class="p_header">+++ b/drivers/net/xen-netfront.c</span>
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> static void xennet_alloc_rx_buffers(struct netfront_queue *queue)</span>
 	queue-&gt;rx.req_prod_pvt = req_prod;
 
 	/* Not enough requests? Try again later. */
<span class="p_del">-	if (req_prod - queue-&gt;rx.rsp_cons &lt; NET_RX_SLOTS_MIN) {</span>
<span class="p_add">+	if (req_prod - queue-&gt;rx.sring-&gt;req_prod &lt; NET_RX_SLOTS_MIN) {</span>
 		mod_timer(&amp;queue-&gt;rx_refill_timer, jiffies + (HZ/10));
 		return;
 	}
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index be3bc2f4edd4..09cc64b3b695 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -807,6 +807,7 @@</span> <span class="p_context"> static void ideapad_acpi_notify(acpi_handle handle, u32 event, void *data)</span>
 			case 11:
 			case 7:
 			case 6:
<span class="p_add">+			case 1:</span>
 				ideapad_input_report(priv, vpc_bit);
 				break;
 			case 5:
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">index 59ced8864b2f..0e6aaef9a038 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_chunk">@@ -3563,12 +3563,14 @@</span> <span class="p_context"> lpfc_els_free_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *elsiocb)</span>
 		} else {
 			buf_ptr1 = (struct lpfc_dmabuf *) elsiocb-&gt;context2;
 			lpfc_els_free_data(phba, buf_ptr1);
<span class="p_add">+			elsiocb-&gt;context2 = NULL;</span>
 		}
 	}
 
 	if (elsiocb-&gt;context3) {
 		buf_ptr = (struct lpfc_dmabuf *) elsiocb-&gt;context3;
 		lpfc_els_free_bpl(phba, buf_ptr);
<span class="p_add">+		elsiocb-&gt;context3 = NULL;</span>
 	}
 	lpfc_sli_release_iocbq(phba, elsiocb);
 	return 0;
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">index f5aeda8f014f..38e90d9c2ced 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_chunk">@@ -5887,18 +5887,25 @@</span> <span class="p_context"> lpfc_sli4_alloc_resource_identifiers(struct lpfc_hba *phba)</span>
 
  free_vfi_bmask:
 	kfree(phba-&gt;sli4_hba.vfi_bmask);
<span class="p_add">+	phba-&gt;sli4_hba.vfi_bmask = NULL;</span>
  free_xri_ids:
 	kfree(phba-&gt;sli4_hba.xri_ids);
<span class="p_add">+	phba-&gt;sli4_hba.xri_ids = NULL;</span>
  free_xri_bmask:
 	kfree(phba-&gt;sli4_hba.xri_bmask);
<span class="p_add">+	phba-&gt;sli4_hba.xri_bmask = NULL;</span>
  free_vpi_ids:
 	kfree(phba-&gt;vpi_ids);
<span class="p_add">+	phba-&gt;vpi_ids = NULL;</span>
  free_vpi_bmask:
 	kfree(phba-&gt;vpi_bmask);
<span class="p_add">+	phba-&gt;vpi_bmask = NULL;</span>
  free_rpi_ids:
 	kfree(phba-&gt;sli4_hba.rpi_ids);
<span class="p_add">+	phba-&gt;sli4_hba.rpi_ids = NULL;</span>
  free_rpi_bmask:
 	kfree(phba-&gt;sli4_hba.rpi_bmask);
<span class="p_add">+	phba-&gt;sli4_hba.rpi_bmask = NULL;</span>
  err_exit:
 	return rc;
 }
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">index 0e59731f95ad..1f6a3b86965f 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_chunk">@@ -2466,6 +2466,10 @@</span> <span class="p_context"> qla2x00_error_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, sts_entry_t *pkt)</span>
 	if (pkt-&gt;entry_status &amp; RF_BUSY)
 		res = DID_BUS_BUSY &lt;&lt; 16;
 
<span class="p_add">+	if (pkt-&gt;entry_type == NOTIFY_ACK_TYPE &amp;&amp;</span>
<span class="p_add">+	    pkt-&gt;handle == QLA_TGT_SKIP_HANDLE)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	sp = qla2x00_get_sp_from_handle(vha, func, req, pkt);
 	if (sp) {
 		sp-&gt;done(ha, sp, res);
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">index f57d96984ae4..e6faa0b050d1 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_chunk">@@ -2865,7 +2865,7 @@</span> <span class="p_context"> static int __qlt_send_term_imm_notif(struct scsi_qla_host *vha,</span>
 
 	pkt-&gt;entry_type = NOTIFY_ACK_TYPE;
 	pkt-&gt;entry_count = 1;
<span class="p_del">-	pkt-&gt;handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;</span>
<span class="p_add">+	pkt-&gt;handle = QLA_TGT_SKIP_HANDLE;</span>
 
 	nack = (struct nack_to_isp *)pkt;
 	nack-&gt;ox_id = ntfy-&gt;ox_id;
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 4d5207dff960..8750c86f95f9 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -2566,7 +2566,8 @@</span> <span class="p_context"> sd_read_cache_type(struct scsi_disk *sdkp, unsigned char *buffer)</span>
 		if (sdp-&gt;broken_fua) {
 			sd_first_printk(KERN_NOTICE, sdkp, &quot;Disabling FUA\n&quot;);
 			sdkp-&gt;DPOFUA = 0;
<span class="p_del">-		} else if (sdkp-&gt;DPOFUA &amp;&amp; !sdkp-&gt;device-&gt;use_10_for_rw) {</span>
<span class="p_add">+		} else if (sdkp-&gt;DPOFUA &amp;&amp; !sdkp-&gt;device-&gt;use_10_for_rw &amp;&amp;</span>
<span class="p_add">+			   !sdkp-&gt;device-&gt;use_16_for_rw) {</span>
 			sd_first_printk(KERN_NOTICE, sdkp,
 				  &quot;Uses READ/WRITE(6), disabling FUA\n&quot;);
 			sdkp-&gt;DPOFUA = 0;
<span class="p_header">diff --git a/drivers/scsi/virtio_scsi.c b/drivers/scsi/virtio_scsi.c</span>
<span class="p_header">index 7dbbb29d24c6..03a2aadf0d3c 100644</span>
<span class="p_header">--- a/drivers/scsi/virtio_scsi.c</span>
<span class="p_header">+++ b/drivers/scsi/virtio_scsi.c</span>
<span class="p_chunk">@@ -533,7 +533,9 @@</span> <span class="p_context"> static int virtscsi_queuecommand(struct virtio_scsi *vscsi,</span>
 {
 	struct Scsi_Host *shost = virtio_scsi_host(vscsi-&gt;vdev);
 	struct virtio_scsi_cmd *cmd = scsi_cmd_priv(sc);
<span class="p_add">+	unsigned long flags;</span>
 	int req_size;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(scsi_sg_count(sc) &gt; shost-&gt;sg_tablesize);
 
<span class="p_chunk">@@ -561,8 +563,15 @@</span> <span class="p_context"> static int virtscsi_queuecommand(struct virtio_scsi *vscsi,</span>
 		req_size = sizeof(cmd-&gt;req.cmd);
 	}
 
<span class="p_del">-	if (virtscsi_kick_cmd(req_vq, cmd, req_size, sizeof(cmd-&gt;resp.cmd)) != 0)</span>
<span class="p_add">+	ret = virtscsi_kick_cmd(req_vq, cmd, req_size, sizeof(cmd-&gt;resp.cmd));</span>
<span class="p_add">+	if (ret == -EIO) {</span>
<span class="p_add">+		cmd-&gt;resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;</span>
<span class="p_add">+		spin_lock_irqsave(&amp;req_vq-&gt;vq_lock, flags);</span>
<span class="p_add">+		virtscsi_complete_cmd(vscsi, cmd);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;req_vq-&gt;vq_lock, flags);</span>
<span class="p_add">+	} else if (ret != 0) {</span>
 		return SCSI_MLQUEUE_HOST_BUSY;
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/spi/spi-davinci.c b/drivers/spi/spi-davinci.c</span>
<span class="p_header">index 7d3af3eacf57..1ddba9ae8c0f 100644</span>
<span class="p_header">--- a/drivers/spi/spi-davinci.c</span>
<span class="p_header">+++ b/drivers/spi/spi-davinci.c</span>
<span class="p_chunk">@@ -651,7 +651,7 @@</span> <span class="p_context"> static int davinci_spi_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 			buf = t-&gt;rx_buf;
 		t-&gt;rx_dma = dma_map_single(&amp;spi-&gt;dev, buf,
 				t-&gt;len, DMA_FROM_DEVICE);
<span class="p_del">-		if (!t-&gt;rx_dma) {</span>
<span class="p_add">+		if (dma_mapping_error(&amp;spi-&gt;dev, !t-&gt;rx_dma)) {</span>
 			ret = -EFAULT;
 			goto err_rx_map;
 		}
<span class="p_chunk">@@ -665,7 +665,7 @@</span> <span class="p_context"> static int davinci_spi_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 			buf = (void *)t-&gt;tx_buf;
 		t-&gt;tx_dma = dma_map_single(&amp;spi-&gt;dev, buf,
 				t-&gt;len, DMA_TO_DEVICE);
<span class="p_del">-		if (!t-&gt;tx_dma) {</span>
<span class="p_add">+		if (dma_mapping_error(&amp;spi-&gt;dev, t-&gt;tx_dma)) {</span>
 			ret = -EFAULT;
 			goto err_tx_map;
 		}
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index 6d8f865a2fb7..732e6ed5d7b4 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -3463,6 +3463,7 @@</span> <span class="p_context"> static void ffs_closed(struct ffs_data *ffs)</span>
 {
 	struct ffs_dev *ffs_obj;
 	struct f_fs_opts *opts;
<span class="p_add">+	struct config_item *ci;</span>
 
 	ENTER();
 	ffs_dev_lock();
<span class="p_chunk">@@ -3486,8 +3487,11 @@</span> <span class="p_context"> static void ffs_closed(struct ffs_data *ffs)</span>
 	    || !atomic_read(&amp;opts-&gt;func_inst.group.cg_item.ci_kref.refcount))
 		goto done;
 
<span class="p_del">-	unregister_gadget_item(ffs_obj-&gt;opts-&gt;</span>
<span class="p_del">-			       func_inst.group.cg_item.ci_parent-&gt;ci_parent);</span>
<span class="p_add">+	ci = opts-&gt;func_inst.group.cg_item.ci_parent-&gt;ci_parent;</span>
<span class="p_add">+	ffs_dev_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	unregister_gadget_item(ci);</span>
<span class="p_add">+	return;</span>
 done:
 	ffs_dev_unlock();
 }
<span class="p_header">diff --git a/drivers/vfio/vfio_iommu_spapr_tce.c b/drivers/vfio/vfio_iommu_spapr_tce.c</span>
<span class="p_header">index 1a9f18b40be6..34e4b3ad8b92 100644</span>
<span class="p_header">--- a/drivers/vfio/vfio_iommu_spapr_tce.c</span>
<span class="p_header">+++ b/drivers/vfio/vfio_iommu_spapr_tce.c</span>
<span class="p_chunk">@@ -1163,6 +1163,10 @@</span> <span class="p_context"> static int tce_iommu_attach_group(void *iommu_data,</span>
 	/* pr_debug(&quot;tce_vfio: Attaching group #%u to iommu %p\n&quot;,
 			iommu_group_id(iommu_group), iommu_group); */
 	table_group = iommu_group_get_iommudata(iommu_group);
<span class="p_add">+	if (!table_group) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto unlock_exit;</span>
<span class="p_add">+	}</span>
 
 	if (tce_groups_attached(container) &amp;&amp; (!table_group-&gt;ops ||
 			!table_group-&gt;ops-&gt;take_ownership ||
<span class="p_header">diff --git a/drivers/watchdog/bcm_kona_wdt.c b/drivers/watchdog/bcm_kona_wdt.c</span>
<span class="p_header">index e0c98423f2c9..11a72bc2c71b 100644</span>
<span class="p_header">--- a/drivers/watchdog/bcm_kona_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/bcm_kona_wdt.c</span>
<span class="p_chunk">@@ -304,6 +304,8 @@</span> <span class="p_context"> static int bcm_kona_wdt_probe(struct platform_device *pdev)</span>
 	if (!wdt)
 		return -ENOMEM;
 
<span class="p_add">+	spin_lock_init(&amp;wdt-&gt;lock);</span>
<span class="p_add">+</span>
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	wdt-&gt;base = devm_ioremap_resource(dev, res);
 	if (IS_ERR(wdt-&gt;base))
<span class="p_chunk">@@ -316,7 +318,6 @@</span> <span class="p_context"> static int bcm_kona_wdt_probe(struct platform_device *pdev)</span>
 		return ret;
 	}
 
<span class="p_del">-	spin_lock_init(&amp;wdt-&gt;lock);</span>
 	platform_set_drvdata(pdev, wdt);
 	watchdog_set_drvdata(&amp;bcm_kona_wdt_wdd, wdt);
 	bcm_kona_wdt_wdd.parent = &amp;pdev-&gt;dev;
<span class="p_header">diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">index 7399782c0998..8a58bbc14de2 100644</span>
<span class="p_header">--- a/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">+++ b/drivers/xen/swiotlb-xen.c</span>
<span class="p_chunk">@@ -409,9 +409,9 @@</span> <span class="p_context"> dma_addr_t xen_swiotlb_map_page(struct device *dev, struct page *page,</span>
 	if (map == SWIOTLB_MAP_ERROR)
 		return DMA_ERROR_CODE;
 
<span class="p_add">+	dev_addr = xen_phys_to_bus(map);</span>
 	xen_dma_map_page(dev, pfn_to_page(map &gt;&gt; PAGE_SHIFT),
 					dev_addr, map &amp; ~PAGE_MASK, size, dir, attrs);
<span class="p_del">-	dev_addr = xen_phys_to_bus(map);</span>
 
 	/*
 	 * Ensure that the address returned is DMA&#39;ble
<span class="p_chunk">@@ -567,13 +567,14 @@</span> <span class="p_context"> xen_swiotlb_map_sg_attrs(struct device *hwdev, struct scatterlist *sgl,</span>
 				sg_dma_len(sgl) = 0;
 				return 0;
 			}
<span class="p_add">+			dev_addr = xen_phys_to_bus(map);</span>
 			xen_dma_map_page(hwdev, pfn_to_page(map &gt;&gt; PAGE_SHIFT),
 						dev_addr,
 						map &amp; ~PAGE_MASK,
 						sg-&gt;length,
 						dir,
 						attrs);
<span class="p_del">-			sg-&gt;dma_address = xen_phys_to_bus(map);</span>
<span class="p_add">+			sg-&gt;dma_address = dev_addr;</span>
 		} else {
 			/* we are not interested in the dma_addr returned by
 			 * xen_dma_map_page, only in the potential cache flushes executed
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 3a93755e880f..29ef427c0652 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -2295,6 +2295,7 @@</span> <span class="p_context"> static int elf_core_dump(struct coredump_params *cprm)</span>
 				goto end_coredump;
 		}
 	}
<span class="p_add">+	dump_truncate(cprm);</span>
 
 	if (!elf_core_write_extra_data(cprm))
 		goto end_coredump;
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index 863fa0f1972b..a61926cb01c0 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -4397,8 +4397,19 @@</span> <span class="p_context"> search_again:</span>
 		if (found_type &gt; min_type) {
 			del_item = 1;
 		} else {
<span class="p_del">-			if (item_end &lt; new_size)</span>
<span class="p_add">+			if (item_end &lt; new_size) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * With NO_HOLES mode, for the following mapping</span>
<span class="p_add">+				 *</span>
<span class="p_add">+				 * [0-4k][hole][8k-12k]</span>
<span class="p_add">+				 *</span>
<span class="p_add">+				 * if truncating isize down to 6k, it ends up</span>
<span class="p_add">+				 * isize being 8k.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (btrfs_fs_incompat(root-&gt;fs_info, NO_HOLES))</span>
<span class="p_add">+					last_size = new_size;</span>
 				break;
<span class="p_add">+			}</span>
 			if (found_key.offset &gt;= new_size)
 				del_item = 1;
 			else
<span class="p_header">diff --git a/fs/coredump.c b/fs/coredump.c</span>
<span class="p_header">index 5d15c4975ba1..a8852293038a 100644</span>
<span class="p_header">--- a/fs/coredump.c</span>
<span class="p_header">+++ b/fs/coredump.c</span>
<span class="p_chunk">@@ -810,3 +810,21 @@</span> <span class="p_context"> int dump_align(struct coredump_params *cprm, int align)</span>
 	return mod ? dump_skip(cprm, align - mod) : 1;
 }
 EXPORT_SYMBOL(dump_align);
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Ensures that file size is big enough to contain the current file</span>
<span class="p_add">+ * postion. This prevents gdb from complaining about a truncated file</span>
<span class="p_add">+ * if the last &quot;write&quot; to the file was dump_skip.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void dump_truncate(struct coredump_params *cprm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct file *file = cprm-&gt;file;</span>
<span class="p_add">+	loff_t offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (file-&gt;f_op-&gt;llseek &amp;&amp; file-&gt;f_op-&gt;llseek != no_llseek) {</span>
<span class="p_add">+		offset = file-&gt;f_op-&gt;llseek(file, 0, SEEK_CUR);</span>
<span class="p_add">+		if (i_size_read(file-&gt;f_mapping-&gt;host) &lt; offset)</span>
<span class="p_add">+			do_truncate(file-&gt;f_path.dentry, offset, 0, file);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(dump_truncate);</span>
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 4e3679b25b9b..8e425f2c5ddd 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -2188,8 +2188,6 @@</span> <span class="p_context"> static int nfs4_opendata_access(struct rpc_cred *cred,</span>
 	if ((mask &amp; ~cache.mask &amp; (MAY_READ | MAY_EXEC)) == 0)
 		return 0;
 
<span class="p_del">-	/* even though OPEN succeeded, access is denied. Close the file */</span>
<span class="p_del">-	nfs4_close_state(state, fmode);</span>
 	return -EACCES;
 }
 
<span class="p_header">diff --git a/fs/ocfs2/cluster/heartbeat.c b/fs/ocfs2/cluster/heartbeat.c</span>
<span class="p_header">index 709fbbd44c65..acebc350e98d 100644</span>
<span class="p_header">--- a/fs/ocfs2/cluster/heartbeat.c</span>
<span class="p_header">+++ b/fs/ocfs2/cluster/heartbeat.c</span>
<span class="p_chunk">@@ -2070,13 +2070,13 @@</span> <span class="p_context"> unlock:</span>
 	spin_unlock(&amp;o2hb_live_lock);
 }
 
<span class="p_del">-static ssize_t o2hb_heartbeat_group_threshold_show(struct config_item *item,</span>
<span class="p_add">+static ssize_t o2hb_heartbeat_group_dead_threshold_show(struct config_item *item,</span>
 		char *page)
 {
 	return sprintf(page, &quot;%u\n&quot;, o2hb_dead_threshold);
 }
 
<span class="p_del">-static ssize_t o2hb_heartbeat_group_threshold_store(struct config_item *item,</span>
<span class="p_add">+static ssize_t o2hb_heartbeat_group_dead_threshold_store(struct config_item *item,</span>
 		const char *page, size_t count)
 {
 	unsigned long tmp;
<span class="p_chunk">@@ -2125,11 +2125,11 @@</span> <span class="p_context"> static ssize_t o2hb_heartbeat_group_mode_store(struct config_item *item,</span>
 
 }
 
<span class="p_del">-CONFIGFS_ATTR(o2hb_heartbeat_group_, threshold);</span>
<span class="p_add">+CONFIGFS_ATTR(o2hb_heartbeat_group_, dead_threshold);</span>
 CONFIGFS_ATTR(o2hb_heartbeat_group_, mode);
 
 static struct configfs_attribute *o2hb_heartbeat_group_attrs[] = {
<span class="p_del">-	&amp;o2hb_heartbeat_group_attr_threshold,</span>
<span class="p_add">+	&amp;o2hb_heartbeat_group_attr_dead_threshold,</span>
 	&amp;o2hb_heartbeat_group_attr_mode,
 	NULL,
 };
<span class="p_header">diff --git a/include/linux/coredump.h b/include/linux/coredump.h</span>
<span class="p_header">index d016a121a8c4..28ffa94aed6b 100644</span>
<span class="p_header">--- a/include/linux/coredump.h</span>
<span class="p_header">+++ b/include/linux/coredump.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"> struct coredump_params;</span>
 extern int dump_skip(struct coredump_params *cprm, size_t nr);
 extern int dump_emit(struct coredump_params *cprm, const void *addr, int nr);
 extern int dump_align(struct coredump_params *cprm, int align);
<span class="p_add">+extern void dump_truncate(struct coredump_params *cprm);</span>
 #ifdef CONFIG_COREDUMP
 extern void do_coredump(const siginfo_t *siginfo);
 #else
<span class="p_header">diff --git a/include/net/xfrm.h b/include/net/xfrm.h</span>
<span class="p_header">index d6f6e5006ee9..185fb037b332 100644</span>
<span class="p_header">--- a/include/net/xfrm.h</span>
<span class="p_header">+++ b/include/net/xfrm.h</span>
<span class="p_chunk">@@ -948,10 +948,6 @@</span> <span class="p_context"> struct xfrm_dst {</span>
 	struct flow_cache_object flo;
 	struct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];
 	int num_pols, num_xfrms;
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	struct flowi *origin;</span>
<span class="p_del">-	struct xfrm_selector *partner;</span>
<span class="p_del">-#endif</span>
 	u32 xfrm_genid;
 	u32 policy_genid;
 	u32 route_mtu_cached;
<span class="p_chunk">@@ -967,12 +963,6 @@</span> <span class="p_context"> static inline void xfrm_dst_destroy(struct xfrm_dst *xdst)</span>
 	dst_release(xdst-&gt;route);
 	if (likely(xdst-&gt;u.dst.xfrm))
 		xfrm_state_put(xdst-&gt;u.dst.xfrm);
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	kfree(xdst-&gt;origin);</span>
<span class="p_del">-	xdst-&gt;origin = NULL;</span>
<span class="p_del">-	kfree(xdst-&gt;partner);</span>
<span class="p_del">-	xdst-&gt;partner = NULL;</span>
<span class="p_del">-#endif</span>
 }
 #endif
 
<span class="p_header">diff --git a/kernel/panic.c b/kernel/panic.c</span>
<span class="p_header">index 41e2b54f36b5..1d07cf9af849 100644</span>
<span class="p_header">--- a/kernel/panic.c</span>
<span class="p_header">+++ b/kernel/panic.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> void panic(const char *fmt, ...)</span>
 		 * Delay timeout seconds before rebooting the machine.
 		 * We can&#39;t use the &quot;normal&quot; timers since we just panicked.
 		 */
<span class="p_del">-		pr_emerg(&quot;Rebooting in %d seconds..&quot;, panic_timeout);</span>
<span class="p_add">+		pr_emerg(&quot;Rebooting in %d seconds..\n&quot;, panic_timeout);</span>
 
 		for (i = 0; i &lt; panic_timeout * 1000; i += PANIC_TIMER_STEP) {
 			touch_nmi_watchdog();
<span class="p_header">diff --git a/kernel/sched/loadavg.c b/kernel/sched/loadavg.c</span>
<span class="p_header">index b0b93fd33af9..f8e8d68ed3fd 100644</span>
<span class="p_header">--- a/kernel/sched/loadavg.c</span>
<span class="p_header">+++ b/kernel/sched/loadavg.c</span>
<span class="p_chunk">@@ -201,8 +201,9 @@</span> <span class="p_context"> void calc_load_exit_idle(void)</span>
 	struct rq *this_rq = this_rq();
 
 	/*
<span class="p_del">-	 * If we&#39;re still before the sample window, we&#39;re done.</span>
<span class="p_add">+	 * If we&#39;re still before the pending sample window, we&#39;re done.</span>
 	 */
<span class="p_add">+	this_rq-&gt;calc_load_update = calc_load_update;</span>
 	if (time_before(jiffies, this_rq-&gt;calc_load_update))
 		return;
 
<span class="p_chunk">@@ -211,7 +212,6 @@</span> <span class="p_context"> void calc_load_exit_idle(void)</span>
 	 * accounted through the nohz accounting, so skip the entire deal and
 	 * sync up for the next window.
 	 */
<span class="p_del">-	this_rq-&gt;calc_load_update = calc_load_update;</span>
 	if (time_before(jiffies, this_rq-&gt;calc_load_update + 10))
 		this_rq-&gt;calc_load_update += LOAD_FREQ;
 }
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index 300d64162aff..464a7864e4c5 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -174,7 +174,7 @@</span> <span class="p_context"> extern int no_unaligned_warning;</span>
 #define SYSCTL_WRITES_WARN	 0
 #define SYSCTL_WRITES_STRICT	 1
 
<span class="p_del">-static int sysctl_writes_strict = SYSCTL_WRITES_WARN;</span>
<span class="p_add">+static int sysctl_writes_strict = SYSCTL_WRITES_STRICT;</span>
 
 static int proc_do_cad_pid(struct ctl_table *table, int write,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
<span class="p_header">diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="p_header">index 76f29ecba8f4..771234d050c7 100644</span>
<span class="p_header">--- a/lib/swiotlb.c</span>
<span class="p_header">+++ b/lib/swiotlb.c</span>
<span class="p_chunk">@@ -452,11 +452,11 @@</span> <span class="p_context"> phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,</span>
 		    : 1UL &lt;&lt; (BITS_PER_LONG - IO_TLB_SHIFT);
 
 	/*
<span class="p_del">-	 * For mappings greater than a page, we limit the stride (and</span>
<span class="p_del">-	 * hence alignment) to a page size.</span>
<span class="p_add">+	 * For mappings greater than or equal to a page, we limit the stride</span>
<span class="p_add">+	 * (and hence alignment) to a page size.</span>
 	 */
 	nslots = ALIGN(size, 1 &lt;&lt; IO_TLB_SHIFT) &gt;&gt; IO_TLB_SHIFT;
<span class="p_del">-	if (size &gt; PAGE_SIZE)</span>
<span class="p_add">+	if (size &gt;= PAGE_SIZE)</span>
 		stride = (1 &lt;&lt; (PAGE_SHIFT - IO_TLB_SHIFT));
 	else
 		stride = 1;
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 47b469663822..6c6f5ccfcda1 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1363,8 +1363,11 @@</span> <span class="p_context"> int do_huge_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	 */
 	if (unlikely(pmd_trans_migrating(*pmdp))) {
 		page = pmd_page(*pmdp);
<span class="p_add">+		if (!get_page_unless_zero(page))</span>
<span class="p_add">+			goto out_unlock;</span>
 		spin_unlock(ptl);
 		wait_on_page_locked(page);
<span class="p_add">+		put_page(page);</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -1396,8 +1399,11 @@</span> <span class="p_context"> int do_huge_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 
 	/* Migration could have started since the pmd_trans_migrating check */
 	if (!page_locked) {
<span class="p_add">+		if (!get_page_unless_zero(page))</span>
<span class="p_add">+			goto out_unlock;</span>
 		spin_unlock(ptl);
 		wait_on_page_locked(page);
<span class="p_add">+		put_page(page);</span>
 		page_nid = -1;
 		goto out;
 	}
<span class="p_header">diff --git a/mm/swap_cgroup.c b/mm/swap_cgroup.c</span>
<span class="p_header">index 40dd0f9b00d6..09f733b0424a 100644</span>
<span class="p_header">--- a/mm/swap_cgroup.c</span>
<span class="p_header">+++ b/mm/swap_cgroup.c</span>
<span class="p_chunk">@@ -205,6 +205,8 @@</span> <span class="p_context"> void swap_cgroup_swapoff(int type)</span>
 			struct page *page = map[i];
 			if (page)
 				__free_page(page);
<span class="p_add">+			if (!(i % SWAP_CLUSTER_MAX))</span>
<span class="p_add">+				cond_resched();</span>
 		}
 		vfree(map);
 	}
<span class="p_header">diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c</span>
<span class="p_header">index ad8d6e6b87ca..e20ae2d3c498 100644</span>
<span class="p_header">--- a/net/8021q/vlan.c</span>
<span class="p_header">+++ b/net/8021q/vlan.c</span>
<span class="p_chunk">@@ -278,7 +278,8 @@</span> <span class="p_context"> static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)</span>
 	return 0;
 
 out_free_newdev:
<span class="p_del">-	free_netdev(new_dev);</span>
<span class="p_add">+	if (new_dev-&gt;reg_state == NETREG_UNINITIALIZED)</span>
<span class="p_add">+		free_netdev(new_dev);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/net/caif/cfpkt_skbuff.c b/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">index 59ce1fcc220c..71b6ab240dea 100644</span>
<span class="p_header">--- a/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">+++ b/net/caif/cfpkt_skbuff.c</span>
<span class="p_chunk">@@ -81,11 +81,7 @@</span> <span class="p_context"> static struct cfpkt *cfpkt_create_pfx(u16 len, u16 pfx)</span>
 {
 	struct sk_buff *skb;
 
<span class="p_del">-	if (likely(in_interrupt()))</span>
<span class="p_del">-		skb = alloc_skb(len + pfx, GFP_ATOMIC);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		skb = alloc_skb(len + pfx, GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_add">+	skb = alloc_skb(len + pfx, GFP_ATOMIC);</span>
 	if (unlikely(skb == NULL))
 		return NULL;
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 87b8754f34ac..524d8b28e690 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -1246,8 +1246,9 @@</span> <span class="p_context"> int dev_set_alias(struct net_device *dev, const char *alias, size_t len)</span>
 	if (!new_ifalias)
 		return -ENOMEM;
 	dev-&gt;ifalias = new_ifalias;
<span class="p_add">+	memcpy(dev-&gt;ifalias, alias, len);</span>
<span class="p_add">+	dev-&gt;ifalias[len] = 0;</span>
 
<span class="p_del">-	strlcpy(dev-&gt;ifalias, alias, len+1);</span>
 	return len;
 }
 
<span class="p_header">diff --git a/net/core/dst.c b/net/core/dst.c</span>
<span class="p_header">index d7ad628bf64e..e72d706f8d0c 100644</span>
<span class="p_header">--- a/net/core/dst.c</span>
<span class="p_header">+++ b/net/core/dst.c</span>
<span class="p_chunk">@@ -462,6 +462,20 @@</span> <span class="p_context"> static int dst_dev_event(struct notifier_block *this, unsigned long event,</span>
 		spin_lock_bh(&amp;dst_garbage.lock);
 		dst = dst_garbage.list;
 		dst_garbage.list = NULL;
<span class="p_add">+		/* The code in dst_ifdown places a hold on the loopback device.</span>
<span class="p_add">+		 * If the gc entry processing is set to expire after a lengthy</span>
<span class="p_add">+		 * interval, this hold can cause netdev_wait_allrefs() to hang</span>
<span class="p_add">+		 * out and wait for a long time -- until the the loopback</span>
<span class="p_add">+		 * interface is released.  If we&#39;re really unlucky, it&#39;ll emit</span>
<span class="p_add">+		 * pr_emerg messages to console too.  Reset the interval here,</span>
<span class="p_add">+		 * so dst cleanups occur in a more timely fashion.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (dst_garbage.timer_inc &gt; DST_GC_INC) {</span>
<span class="p_add">+			dst_garbage.timer_inc = DST_GC_INC;</span>
<span class="p_add">+			dst_garbage.timer_expires = DST_GC_MIN;</span>
<span class="p_add">+			mod_delayed_work(system_wq, &amp;dst_gc_work,</span>
<span class="p_add">+					 dst_garbage.timer_expires);</span>
<span class="p_add">+		}</span>
 		spin_unlock_bh(&amp;dst_garbage.lock);
 
 		if (last)
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index d43544ce7550..2ec5324a7ff7 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -897,6 +897,7 @@</span> <span class="p_context"> static noinline size_t if_nlmsg_size(const struct net_device *dev,</span>
 	       + nla_total_size(1) /* IFLA_LINKMODE */
 	       + nla_total_size(4) /* IFLA_CARRIER_CHANGES */
 	       + nla_total_size(4) /* IFLA_LINK_NETNSID */
<span class="p_add">+	       + nla_total_size(4) /* IFLA_GROUP */</span>
 	       + nla_total_size(ext_filter_mask
 			        &amp; RTEXT_FILTER_VF ? 4 : 0) /* IFLA_NUM_VF */
 	       + rtnl_vfinfo_size(dev, ext_filter_mask) /* IFLA_VFINFO_LIST */
<span class="p_chunk">@@ -1089,6 +1090,8 @@</span> <span class="p_context"> static noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,</span>
 	struct ifla_vf_mac vf_mac;
 	struct ifla_vf_info ivi;
 
<span class="p_add">+	memset(&amp;ivi, 0, sizeof(ivi));</span>
<span class="p_add">+</span>
 	/* Not all SR-IOV capable drivers support the
 	 * spoofcheck and &quot;RSS query enable&quot; query.  Preset to
 	 * -1 so the user space tool can detect that the driver
<span class="p_chunk">@@ -1097,7 +1100,6 @@</span> <span class="p_context"> static noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,</span>
 	ivi.spoofchk = -1;
 	ivi.rss_query_en = -1;
 	ivi.trusted = -1;
<span class="p_del">-	memset(ivi.mac, 0, sizeof(ivi.mac));</span>
 	/* The default value for VF link state is &quot;auto&quot;
 	 * IFLA_VF_LINK_STATE_AUTO which equals zero
 	 */
<span class="p_chunk">@@ -1370,6 +1372,7 @@</span> <span class="p_context"> static const struct nla_policy ifla_policy[IFLA_MAX+1] = {</span>
 	[IFLA_PHYS_SWITCH_ID]	= { .type = NLA_BINARY, .len = MAX_PHYS_ITEM_ID_LEN },
 	[IFLA_LINK_NETNSID]	= { .type = NLA_S32 },
 	[IFLA_PROTO_DOWN]	= { .type = NLA_U8 },
<span class="p_add">+	[IFLA_GROUP]		= { .type = NLA_U32 },</span>
 };
 
 static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {
<span class="p_header">diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c</span>
<span class="p_header">index b1dc096d22f8..403593bd2b83 100644</span>
<span class="p_header">--- a/net/decnet/dn_route.c</span>
<span class="p_header">+++ b/net/decnet/dn_route.c</span>
<span class="p_chunk">@@ -188,12 +188,6 @@</span> <span class="p_context"> static inline void dnrt_free(struct dn_route *rt)</span>
 	call_rcu_bh(&amp;rt-&gt;dst.rcu_head, dst_rcu_free);
 }
 
<span class="p_del">-static inline void dnrt_drop(struct dn_route *rt)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dst_release(&amp;rt-&gt;dst);</span>
<span class="p_del">-	call_rcu_bh(&amp;rt-&gt;dst.rcu_head, dst_rcu_free);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void dn_dst_check_expire(unsigned long dummy)
 {
 	int i;
<span class="p_chunk">@@ -248,7 +242,7 @@</span> <span class="p_context"> static int dn_dst_gc(struct dst_ops *ops)</span>
 			}
 			*rtp = rt-&gt;dst.dn_next;
 			rt-&gt;dst.dn_next = NULL;
<span class="p_del">-			dnrt_drop(rt);</span>
<span class="p_add">+			dnrt_free(rt);</span>
 			break;
 		}
 		spin_unlock_bh(&amp;dn_rt_hash_table[i].lock);
<span class="p_chunk">@@ -350,7 +344,7 @@</span> <span class="p_context"> static int dn_insert_route(struct dn_route *rt, unsigned int hash, struct dn_rou</span>
 			dst_use(&amp;rth-&gt;dst, now);
 			spin_unlock_bh(&amp;dn_rt_hash_table[hash].lock);
 
<span class="p_del">-			dnrt_drop(rt);</span>
<span class="p_add">+			dst_free(&amp;rt-&gt;dst);</span>
 			*rp = rth;
 			return 0;
 		}
<span class="p_chunk">@@ -380,7 +374,7 @@</span> <span class="p_context"> static void dn_run_flush(unsigned long dummy)</span>
 		for(; rt; rt = next) {
 			next = rcu_dereference_raw(rt-&gt;dst.dn_next);
 			RCU_INIT_POINTER(rt-&gt;dst.dn_next, NULL);
<span class="p_del">-			dst_free((struct dst_entry *)rt);</span>
<span class="p_add">+			dnrt_free(rt);</span>
 		}
 
 nothing_to_declare:
<span class="p_chunk">@@ -1187,7 +1181,7 @@</span> <span class="p_context"> make_route:</span>
 	if (dev_out-&gt;flags &amp; IFF_LOOPBACK)
 		flags |= RTCF_LOCAL;
 
<span class="p_del">-	rt = dst_alloc(&amp;dn_dst_ops, dev_out, 1, DST_OBSOLETE_NONE, DST_HOST);</span>
<span class="p_add">+	rt = dst_alloc(&amp;dn_dst_ops, dev_out, 0, DST_OBSOLETE_NONE, DST_HOST);</span>
 	if (rt == NULL)
 		goto e_nobufs;
 
<span class="p_header">diff --git a/net/decnet/netfilter/dn_rtmsg.c b/net/decnet/netfilter/dn_rtmsg.c</span>
<span class="p_header">index 85f2fdc360c2..29246bc9a7b4 100644</span>
<span class="p_header">--- a/net/decnet/netfilter/dn_rtmsg.c</span>
<span class="p_header">+++ b/net/decnet/netfilter/dn_rtmsg.c</span>
<span class="p_chunk">@@ -102,7 +102,9 @@</span> <span class="p_context"> static inline void dnrmg_receive_user_skb(struct sk_buff *skb)</span>
 {
 	struct nlmsghdr *nlh = nlmsg_hdr(skb);
 
<span class="p_del">-	if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) || skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span>
<span class="p_add">+	if (skb-&gt;len &lt; sizeof(*nlh) ||</span>
<span class="p_add">+	    nlh-&gt;nlmsg_len &lt; sizeof(*nlh) ||</span>
<span class="p_add">+	    skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span>
 		return;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
<span class="p_header">diff --git a/net/dsa/slave.c b/net/dsa/slave.c</span>
<span class="p_header">index 8dfe9fb7ad36..554c2a961ad5 100644</span>
<span class="p_header">--- a/net/dsa/slave.c</span>
<span class="p_header">+++ b/net/dsa/slave.c</span>
<span class="p_chunk">@@ -1006,10 +1006,8 @@</span> <span class="p_context"> static int dsa_slave_phy_connect(struct dsa_slave_priv *p,</span>
 	/* Use already configured phy mode */
 	if (p-&gt;phy_interface == PHY_INTERFACE_MODE_NA)
 		p-&gt;phy_interface = p-&gt;phy-&gt;interface;
<span class="p_del">-	phy_connect_direct(slave_dev, p-&gt;phy, dsa_slave_adjust_link,</span>
<span class="p_del">-			   p-&gt;phy_interface);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return phy_connect_direct(slave_dev, p-&gt;phy, dsa_slave_adjust_link,</span>
<span class="p_add">+				  p-&gt;phy_interface);</span>
 }
 
 static int dsa_slave_phy_setup(struct dsa_slave_priv *p,
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 17adfdaf5795..3809d523d012 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -1102,6 +1102,7 @@</span> <span class="p_context"> static void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im)</span>
 	pmc = kzalloc(sizeof(*pmc), GFP_KERNEL);
 	if (!pmc)
 		return;
<span class="p_add">+	spin_lock_init(&amp;pmc-&gt;lock);</span>
 	spin_lock_bh(&amp;im-&gt;lock);
 	pmc-&gt;interface = im-&gt;interface;
 	in_dev_hold(in_dev);
<span class="p_chunk">@@ -2026,21 +2027,26 @@</span> <span class="p_context"> static int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,</span>
 
 static void ip_mc_clear_src(struct ip_mc_list *pmc)
 {
<span class="p_del">-	struct ip_sf_list *psf, *nextpsf;</span>
<span class="p_add">+	struct ip_sf_list *psf, *nextpsf, *tomb, *sources;</span>
 
<span class="p_del">-	for (psf = pmc-&gt;tomb; psf; psf = nextpsf) {</span>
<span class="p_add">+	spin_lock_bh(&amp;pmc-&gt;lock);</span>
<span class="p_add">+	tomb = pmc-&gt;tomb;</span>
<span class="p_add">+	pmc-&gt;tomb = NULL;</span>
<span class="p_add">+	sources = pmc-&gt;sources;</span>
<span class="p_add">+	pmc-&gt;sources = NULL;</span>
<span class="p_add">+	pmc-&gt;sfmode = MCAST_EXCLUDE;</span>
<span class="p_add">+	pmc-&gt;sfcount[MCAST_INCLUDE] = 0;</span>
<span class="p_add">+	pmc-&gt;sfcount[MCAST_EXCLUDE] = 1;</span>
<span class="p_add">+	spin_unlock_bh(&amp;pmc-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (psf = tomb; psf; psf = nextpsf) {</span>
 		nextpsf = psf-&gt;sf_next;
 		kfree(psf);
 	}
<span class="p_del">-	pmc-&gt;tomb = NULL;</span>
<span class="p_del">-	for (psf = pmc-&gt;sources; psf; psf = nextpsf) {</span>
<span class="p_add">+	for (psf = sources; psf; psf = nextpsf) {</span>
 		nextpsf = psf-&gt;sf_next;
 		kfree(psf);
 	}
<span class="p_del">-	pmc-&gt;sources = NULL;</span>
<span class="p_del">-	pmc-&gt;sfmode = MCAST_EXCLUDE;</span>
<span class="p_del">-	pmc-&gt;sfcount[MCAST_INCLUDE] = 0;</span>
<span class="p_del">-	pmc-&gt;sfcount[MCAST_EXCLUDE] = 1;</span>
 }
 
 /* Join a multicast group
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 8cf3fc7c2932..03dadbf6cc5e 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -291,9 +291,9 @@</span> <span class="p_context"> static void addrconf_mod_rs_timer(struct inet6_dev *idev,</span>
 static void addrconf_mod_dad_work(struct inet6_ifaddr *ifp,
 				   unsigned long delay)
 {
<span class="p_del">-	if (!delayed_work_pending(&amp;ifp-&gt;dad_work))</span>
<span class="p_del">-		in6_ifa_hold(ifp);</span>
<span class="p_del">-	mod_delayed_work(addrconf_wq, &amp;ifp-&gt;dad_work, delay);</span>
<span class="p_add">+	in6_ifa_hold(ifp);</span>
<span class="p_add">+	if (mod_delayed_work(addrconf_wq, &amp;ifp-&gt;dad_work, delay))</span>
<span class="p_add">+		in6_ifa_put(ifp);</span>
 }
 
 static int snmp6_alloc_dev(struct inet6_dev *idev)
<span class="p_header">diff --git a/net/ipv6/fib6_rules.c b/net/ipv6/fib6_rules.c</span>
<span class="p_header">index ed33abf57abd..9ac4f0cef27d 100644</span>
<span class="p_header">--- a/net/ipv6/fib6_rules.c</span>
<span class="p_header">+++ b/net/ipv6/fib6_rules.c</span>
<span class="p_chunk">@@ -32,7 +32,6 @@</span> <span class="p_context"> struct fib6_rule {</span>
 struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
 				   int flags, pol_lookup_t lookup)
 {
<span class="p_del">-	struct rt6_info *rt;</span>
 	struct fib_lookup_arg arg = {
 		.lookup_ptr = lookup,
 		.flags = FIB_LOOKUP_NOREF,
<span class="p_chunk">@@ -41,21 +40,11 @@</span> <span class="p_context"> struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,</span>
 	fib_rules_lookup(net-&gt;ipv6.fib6_rules_ops,
 			 flowi6_to_flowi(fl6), flags, &amp;arg);
 
<span class="p_del">-	rt = arg.result;</span>
<span class="p_add">+	if (arg.result)</span>
<span class="p_add">+		return arg.result;</span>
 
<span class="p_del">-	if (!rt) {</span>
<span class="p_del">-		dst_hold(&amp;net-&gt;ipv6.ip6_null_entry-&gt;dst);</span>
<span class="p_del">-		return &amp;net-&gt;ipv6.ip6_null_entry-&gt;dst;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (rt-&gt;rt6i_flags &amp; RTF_REJECT &amp;&amp;</span>
<span class="p_del">-	    rt-&gt;dst.error == -EAGAIN) {</span>
<span class="p_del">-		ip6_rt_put(rt);</span>
<span class="p_del">-		rt = net-&gt;ipv6.ip6_null_entry;</span>
<span class="p_del">-		dst_hold(&amp;rt-&gt;dst);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return &amp;rt-&gt;dst;</span>
<span class="p_add">+	dst_hold(&amp;net-&gt;ipv6.ip6_null_entry-&gt;dst);</span>
<span class="p_add">+	return &amp;net-&gt;ipv6.ip6_null_entry-&gt;dst;</span>
 }
 
 static int fib6_rule_action(struct fib_rule *rule, struct flowi *flp,
<span class="p_chunk">@@ -116,7 +105,8 @@</span> <span class="p_context"> static int fib6_rule_action(struct fib_rule *rule, struct flowi *flp,</span>
 			flp6-&gt;saddr = saddr;
 		}
 		err = rt-&gt;dst.error;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		if (err != -EAGAIN)</span>
<span class="p_add">+			goto out;</span>
 	}
 again:
 	ip6_rt_put(rt);
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index 85bf86458706..1ac06723f0d7 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -290,8 +290,7 @@</span> <span class="p_context"> struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,</span>
 	struct rt6_info *rt;
 
 	rt = lookup(net, net-&gt;ipv6.fib6_main_tbl, fl6, flags);
<span class="p_del">-	if (rt-&gt;rt6i_flags &amp; RTF_REJECT &amp;&amp;</span>
<span class="p_del">-	    rt-&gt;dst.error == -EAGAIN) {</span>
<span class="p_add">+	if (rt-&gt;dst.error == -EAGAIN) {</span>
 		ip6_rt_put(rt);
 		rt = net-&gt;ipv6.ip6_null_entry;
 		dst_hold(&amp;rt-&gt;dst);
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 19c0d67ce8c4..7d339fc1057f 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1005,8 +1005,10 @@</span> <span class="p_context"> static int ip6_dst_lookup_tail(struct net *net, const struct sock *sk,</span>
 	}
 #endif
 	if (ipv6_addr_v4mapped(&amp;fl6-&gt;saddr) &amp;&amp;
<span class="p_del">-	    !(ipv6_addr_v4mapped(&amp;fl6-&gt;daddr) || ipv6_addr_any(&amp;fl6-&gt;daddr)))</span>
<span class="p_del">-		return -EAFNOSUPPORT;</span>
<span class="p_add">+	    !(ipv6_addr_v4mapped(&amp;fl6-&gt;daddr) || ipv6_addr_any(&amp;fl6-&gt;daddr))) {</span>
<span class="p_add">+		err = -EAFNOSUPPORT;</span>
<span class="p_add">+		goto out_err_release;</span>
<span class="p_add">+	}</span>
 
 	return 0;
 
<span class="p_header">diff --git a/net/key/af_key.c b/net/key/af_key.c</span>
<span class="p_header">index f9c9ecb0cdd3..e67c28e614b9 100644</span>
<span class="p_header">--- a/net/key/af_key.c</span>
<span class="p_header">+++ b/net/key/af_key.c</span>
<span class="p_chunk">@@ -1135,6 +1135,7 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 			goto out;
 	}
 
<span class="p_add">+	err = -ENOBUFS;</span>
 	key = ext_hdrs[SADB_EXT_KEY_AUTH - 1];
 	if (sa-&gt;sadb_sa_auth) {
 		int keysize = 0;
<span class="p_chunk">@@ -1146,8 +1147,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 		if (key)
 			keysize = (key-&gt;sadb_key_bits + 7) / 8;
 		x-&gt;aalg = kmalloc(sizeof(*x-&gt;aalg) + keysize, GFP_KERNEL);
<span class="p_del">-		if (!x-&gt;aalg)</span>
<span class="p_add">+		if (!x-&gt;aalg) {</span>
<span class="p_add">+			err = -ENOMEM;</span>
 			goto out;
<span class="p_add">+		}</span>
 		strcpy(x-&gt;aalg-&gt;alg_name, a-&gt;name);
 		x-&gt;aalg-&gt;alg_key_len = 0;
 		if (key) {
<span class="p_chunk">@@ -1166,8 +1169,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 				goto out;
 			}
 			x-&gt;calg = kmalloc(sizeof(*x-&gt;calg), GFP_KERNEL);
<span class="p_del">-			if (!x-&gt;calg)</span>
<span class="p_add">+			if (!x-&gt;calg) {</span>
<span class="p_add">+				err = -ENOMEM;</span>
 				goto out;
<span class="p_add">+			}</span>
 			strcpy(x-&gt;calg-&gt;alg_name, a-&gt;name);
 			x-&gt;props.calgo = sa-&gt;sadb_sa_encrypt;
 		} else {
<span class="p_chunk">@@ -1181,8 +1186,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 			if (key)
 				keysize = (key-&gt;sadb_key_bits + 7) / 8;
 			x-&gt;ealg = kmalloc(sizeof(*x-&gt;ealg) + keysize, GFP_KERNEL);
<span class="p_del">-			if (!x-&gt;ealg)</span>
<span class="p_add">+			if (!x-&gt;ealg) {</span>
<span class="p_add">+				err = -ENOMEM;</span>
 				goto out;
<span class="p_add">+			}</span>
 			strcpy(x-&gt;ealg-&gt;alg_name, a-&gt;name);
 			x-&gt;ealg-&gt;alg_key_len = 0;
 			if (key) {
<span class="p_chunk">@@ -1227,8 +1234,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 		struct xfrm_encap_tmpl *natt;
 
 		x-&gt;encap = kmalloc(sizeof(*x-&gt;encap), GFP_KERNEL);
<span class="p_del">-		if (!x-&gt;encap)</span>
<span class="p_add">+		if (!x-&gt;encap) {</span>
<span class="p_add">+			err = -ENOMEM;</span>
 			goto out;
<span class="p_add">+		}</span>
 
 		natt = x-&gt;encap;
 		n_type = ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1];
<span class="p_header">diff --git a/net/mac80211/main.c b/net/mac80211/main.c</span>
<span class="p_header">index 175ffcf7fb06..2ee53dc1ddf7 100644</span>
<span class="p_header">--- a/net/mac80211/main.c</span>
<span class="p_header">+++ b/net/mac80211/main.c</span>
<span class="p_chunk">@@ -891,12 +891,17 @@</span> <span class="p_context"> int ieee80211_register_hw(struct ieee80211_hw *hw)</span>
 		supp_ht = supp_ht || sband-&gt;ht_cap.ht_supported;
 		supp_vht = supp_vht || sband-&gt;vht_cap.vht_supported;
 
<span class="p_del">-		if (sband-&gt;ht_cap.ht_supported)</span>
<span class="p_del">-			local-&gt;rx_chains =</span>
<span class="p_del">-				max(ieee80211_mcs_to_chains(&amp;sband-&gt;ht_cap.mcs),</span>
<span class="p_del">-				    local-&gt;rx_chains);</span>
<span class="p_add">+		if (!sband-&gt;ht_cap.ht_supported)</span>
<span class="p_add">+			continue;</span>
 
 		/* TODO: consider VHT for RX chains, hopefully it&#39;s the same */
<span class="p_add">+		local-&gt;rx_chains =</span>
<span class="p_add">+			max(ieee80211_mcs_to_chains(&amp;sband-&gt;ht_cap.mcs),</span>
<span class="p_add">+			    local-&gt;rx_chains);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* no need to mask, SM_PS_DISABLED has all bits set */</span>
<span class="p_add">+		sband-&gt;ht_cap.cap |= WLAN_HT_CAP_SM_PS_DISABLED &lt;&lt;</span>
<span class="p_add">+			             IEEE80211_HT_CAP_SM_PS_SHIFT;</span>
 	}
 
 	/* if low-level driver supports AP, we also support VLAN */
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">index 9f5272968abb..e565b2becb14 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_chunk">@@ -45,6 +45,8 @@</span> <span class="p_context"></span>
 #include &lt;net/netfilter/nf_conntrack_zones.h&gt;
 #include &lt;net/netfilter/nf_conntrack_timestamp.h&gt;
 #include &lt;net/netfilter/nf_conntrack_labels.h&gt;
<span class="p_add">+#include &lt;net/netfilter/nf_conntrack_seqadj.h&gt;</span>
<span class="p_add">+#include &lt;net/netfilter/nf_conntrack_synproxy.h&gt;</span>
 #ifdef CONFIG_NF_NAT_NEEDED
 #include &lt;net/netfilter/nf_nat_core.h&gt;
 #include &lt;net/netfilter/nf_nat_l4proto.h&gt;
<span class="p_chunk">@@ -1798,6 +1800,8 @@</span> <span class="p_context"> ctnetlink_create_conntrack(struct net *net,</span>
 	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
 	nf_ct_ecache_ext_add(ct, 0, 0, GFP_ATOMIC);
 	nf_ct_labels_ext_add(ct);
<span class="p_add">+	nfct_seqadj_ext_add(ct);</span>
<span class="p_add">+	nfct_synproxy_ext_add(ct);</span>
 
 	/* we must add conntrack extensions before confirmation. */
 	ct-&gt;status |= IPS_CONFIRMED;
<span class="p_header">diff --git a/net/netfilter/xt_TCPMSS.c b/net/netfilter/xt_TCPMSS.c</span>
<span class="p_header">index b7c43def0dc6..00f798b20b20 100644</span>
<span class="p_header">--- a/net/netfilter/xt_TCPMSS.c</span>
<span class="p_header">+++ b/net/netfilter/xt_TCPMSS.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> tcpmss_mangle_packet(struct sk_buff *skb,</span>
 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph-&gt;doff * 4;
 
<span class="p_del">-	if (len &lt; tcp_hdrlen)</span>
<span class="p_add">+	if (len &lt; tcp_hdrlen || tcp_hdrlen &lt; sizeof(struct tcphdr))</span>
 		return -1;
 
 	if (info-&gt;mss == XT_TCPMSS_CLAMP_PMTU) {
<span class="p_chunk">@@ -156,6 +156,10 @@</span> <span class="p_context"> tcpmss_mangle_packet(struct sk_buff *skb,</span>
 	if (len &gt; tcp_hdrlen)
 		return 0;
 
<span class="p_add">+	/* tcph-&gt;doff has 4 bits, do not wrap it to 0 */</span>
<span class="p_add">+	if (tcp_hdrlen &gt;= 15 * 4)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/*
 	 * MSS Option not found ?! add it..
 	 */
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 956141b71619..3ebf3b652d60 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -239,7 +239,7 @@</span> <span class="p_context"> static struct sctp_transport *sctp_addr_id2transport(struct sock *sk,</span>
 	union sctp_addr *laddr = (union sctp_addr *)addr;
 	struct sctp_transport *transport;
 
<span class="p_del">-	if (sctp_verify_addr(sk, laddr, af-&gt;sockaddr_len))</span>
<span class="p_add">+	if (!af || sctp_verify_addr(sk, laddr, af-&gt;sockaddr_len))</span>
 		return NULL;
 
 	addr_asoc = sctp_endpoint_lookup_assoc(sctp_sk(sk)-&gt;ep,
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index b2e934ff2448..e05ec54ac53f 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -997,7 +997,8 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	struct path path = { NULL, NULL };
 
 	err = -EINVAL;
<span class="p_del">-	if (sunaddr-&gt;sun_family != AF_UNIX)</span>
<span class="p_add">+	if (addr_len &lt; offsetofend(struct sockaddr_un, sun_family) ||</span>
<span class="p_add">+	    sunaddr-&gt;sun_family != AF_UNIX)</span>
 		goto out;
 
 	if (addr_len == sizeof(short)) {
<span class="p_chunk">@@ -1108,6 +1109,10 @@</span> <span class="p_context"> static int unix_dgram_connect(struct socket *sock, struct sockaddr *addr,</span>
 	unsigned int hash;
 	int err;
 
<span class="p_add">+	err = -EINVAL;</span>
<span class="p_add">+	if (alen &lt; offsetofend(struct sockaddr, sa_family))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (addr-&gt;sa_family != AF_UNSPEC) {
 		err = unix_mkname(sunaddr, alen, &amp;hash);
 		if (err &lt; 0)
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index 36a50ef9295d..8a0fdd870395 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -1776,43 +1776,6 @@</span> <span class="p_context"> free_dst:</span>
 	goto out;
 }
 
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-static int xfrm_dst_alloc_copy(void **target, const void *src, int size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!*target) {</span>
<span class="p_del">-		*target = kmalloc(size, GFP_ATOMIC);</span>
<span class="p_del">-		if (!*target)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy(*target, src, size);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static int xfrm_dst_update_parent(struct dst_entry *dst,</span>
<span class="p_del">-				  const struct xfrm_selector *sel)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	struct xfrm_dst *xdst = (struct xfrm_dst *)dst;</span>
<span class="p_del">-	return xfrm_dst_alloc_copy((void **)&amp;(xdst-&gt;partner),</span>
<span class="p_del">-				   sel, sizeof(*sel));</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int xfrm_dst_update_origin(struct dst_entry *dst,</span>
<span class="p_del">-				  const struct flowi *fl)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	struct xfrm_dst *xdst = (struct xfrm_dst *)dst;</span>
<span class="p_del">-	return xfrm_dst_alloc_copy((void **)&amp;(xdst-&gt;origin), fl, sizeof(*fl));</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int xfrm_expand_policies(const struct flowi *fl, u16 family,
 				struct xfrm_policy **pols,
 				int *num_pols, int *num_xfrms)
<span class="p_chunk">@@ -1884,16 +1847,6 @@</span> <span class="p_context"> xfrm_resolve_and_create_bundle(struct xfrm_policy **pols, int num_pols,</span>
 
 	xdst = (struct xfrm_dst *)dst;
 	xdst-&gt;num_xfrms = err;
<span class="p_del">-	if (num_pols &gt; 1)</span>
<span class="p_del">-		err = xfrm_dst_update_parent(dst, &amp;pols[1]-&gt;selector);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		err = xfrm_dst_update_origin(dst, fl);</span>
<span class="p_del">-	if (unlikely(err)) {</span>
<span class="p_del">-		dst_free(dst);</span>
<span class="p_del">-		XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTBUNDLECHECKERROR);</span>
<span class="p_del">-		return ERR_PTR(err);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	xdst-&gt;num_pols = num_pols;
 	memcpy(xdst-&gt;pols, pols, sizeof(struct xfrm_policy *) * num_pols);
 	xdst-&gt;policy_genid = atomic_read(&amp;pols[0]-&gt;genid);
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h</span>
<span class="p_header">index 373fcad840ea..776dffa88aee 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.h</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.h</span>
<span class="p_chunk">@@ -294,6 +294,8 @@</span> <span class="p_context"> struct hda_codec {</span>
 
 #define list_for_each_codec(c, bus) \
 	list_for_each_entry(c, &amp;(bus)-&gt;core.codec_list, core.list)
<span class="p_add">+#define list_for_each_codec_safe(c, n, bus)				\</span>
<span class="p_add">+	list_for_each_entry_safe(c, n, &amp;(bus)-&gt;core.codec_list, core.list)</span>
 
 /* snd_hda_codec_read/write optional flags */
 #define HDA_RW_NO_RESPONSE_FALLBACK	(1 &lt;&lt; 0)
<span class="p_header">diff --git a/sound/pci/hda/hda_controller.c b/sound/pci/hda/hda_controller.c</span>
<span class="p_header">index 5baf8b56b6e7..9c6e10fb479f 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_controller.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_controller.c</span>
<span class="p_chunk">@@ -1128,8 +1128,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(azx_probe_codecs);</span>
 /* configure each codec instance */
 int azx_codec_configure(struct azx *chip)
 {
<span class="p_del">-	struct hda_codec *codec;</span>
<span class="p_del">-	list_for_each_codec(codec, &amp;chip-&gt;bus) {</span>
<span class="p_add">+	struct hda_codec *codec, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* use _safe version here since snd_hda_codec_configure() deregisters</span>
<span class="p_add">+	 * the device upon error and deletes itself from the bus list.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	list_for_each_codec_safe(codec, next, &amp;chip-&gt;bus) {</span>
 		snd_hda_codec_configure(codec);
 	}
 	return 0;
<span class="p_header">diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c</span>
<span class="p_header">index dc2fa576d60d..689df78f640a 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_generic.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_generic.c</span>
<span class="p_chunk">@@ -3190,6 +3190,7 @@</span> <span class="p_context"> static int check_dyn_adc_switch(struct hda_codec *codec)</span>
 						spec-&gt;input_paths[i][nums]);
 					spec-&gt;input_paths[i][nums] =
 						spec-&gt;input_paths[i][n];
<span class="p_add">+					spec-&gt;input_paths[i][n] = 0;</span>
 				}
 			}
 			nums++;
<span class="p_header">diff --git a/tools/perf/util/probe-finder.c b/tools/perf/util/probe-finder.c</span>
<span class="p_header">index 05012bb178d7..fdd87c7e3e91 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-finder.c</span>
<span class="p_header">+++ b/tools/perf/util/probe-finder.c</span>
<span class="p_chunk">@@ -1460,16 +1460,12 @@</span> <span class="p_context"> int debuginfo__find_probe_point(struct debuginfo *dbg, unsigned long addr,</span>
 	Dwarf_Addr _addr = 0, baseaddr = 0;
 	const char *fname = NULL, *func = NULL, *basefunc = NULL, *tmp;
 	int baseline = 0, lineno = 0, ret = 0;
<span class="p_del">-	bool reloc = false;</span>
 
<span class="p_del">-retry:</span>
<span class="p_add">+	/* We always need to relocate the address for aranges */</span>
<span class="p_add">+	if (debuginfo__get_text_offset(dbg, &amp;baseaddr) == 0)</span>
<span class="p_add">+		addr += baseaddr;</span>
 	/* Find cu die */
 	if (!dwarf_addrdie(dbg-&gt;dbg, (Dwarf_Addr)addr, &amp;cudie)) {
<span class="p_del">-		if (!reloc &amp;&amp; debuginfo__get_text_offset(dbg, &amp;baseaddr) == 0) {</span>
<span class="p_del">-			addr += baseaddr;</span>
<span class="p_del">-			reloc = true;</span>
<span class="p_del">-			goto retry;</span>
<span class="p_del">-		}</span>
 		pr_warning(&quot;Failed to find debug information for address %lx\n&quot;,
 			   addr);
 		ret = -EINVAL;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



