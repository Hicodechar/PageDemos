
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.1.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.1.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 17, 2015, 2:36 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150817143624.GB5266@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7025311/mbox/"
   >mbox</a>
|
   <a href="/patch/7025311/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7025311/">/patch/7025311/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id E6C359F373
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 17 Aug 2015 14:36:57 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 33591205EC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 17 Aug 2015 14:36:50 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 3DF81205E7
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 17 Aug 2015 14:36:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755616AbbHQOgg (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 17 Aug 2015 10:36:36 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:58645 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755584AbbHQOg0 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 17 Aug 2015 10:36:26 -0400
Received: from localhost (mobile-166-176-184-134.mycingular.net
	[166.176.184.134])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id F37FB7AA;
	Mon, 17 Aug 2015 14:36:24 +0000 (UTC)
Date: Mon, 17 Aug 2015 07:36:24 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.1.6
Message-ID: &lt;20150817143624.GB5266@kroah.com&gt;
References: &lt;20150817143615.GA5266@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150817143615.GA5266@kroah.com&gt;
User-Agent: Mutt/1.5.23+102 (2ca89bed6448) (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.5 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 17, 2015, 2:36 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/clock/keystone-pll.txt b/Documentation/devicetree/bindings/clock/keystone-pll.txt</span>
<span class="p_header">index 225990f79b7c..47570d207215 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/clock/keystone-pll.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/clock/keystone-pll.txt</span>
<span class="p_chunk">@@ -15,8 +15,8 @@</span> <span class="p_context"> Required properties:</span>
 - compatible : shall be &quot;ti,keystone,main-pll-clock&quot; or &quot;ti,keystone,pll-clock&quot;
 - clocks : parent clock phandle
 - reg - pll control0 and pll multipler registers
<span class="p_del">-- reg-names : control and multiplier. The multiplier is applicable only for</span>
<span class="p_del">-		main pll clock</span>
<span class="p_add">+- reg-names : control, multiplier and post-divider. The multiplier and</span>
<span class="p_add">+		post-divider registers are applicable only for main pll clock</span>
 - fixed-postdiv : fixed post divider value. If absent, use clkod register bits
 		for postdiv
 
<span class="p_chunk">@@ -25,8 +25,8 @@</span> <span class="p_context"> Example:</span>
 		#clock-cells = &lt;0&gt;;
 		compatible = &quot;ti,keystone,main-pll-clock&quot;;
 		clocks = &lt;&amp;refclksys&gt;;
<span class="p_del">-		reg = &lt;0x02620350 4&gt;, &lt;0x02310110 4&gt;;</span>
<span class="p_del">-		reg-names = &quot;control&quot;, &quot;multiplier&quot;;</span>
<span class="p_add">+		reg = &lt;0x02620350 4&gt;, &lt;0x02310110 4&gt;, &lt;0x02310108 4&gt;;</span>
<span class="p_add">+		reg-names = &quot;control&quot;, &quot;multiplier&quot;, &quot;post-divider&quot;;</span>
 		fixed-postdiv = &lt;2&gt;;
 	};
 
<span class="p_header">diff --git a/Documentation/input/alps.txt b/Documentation/input/alps.txt</span>
<span class="p_header">index c86f2f1ae4f6..1fec1135791d 100644</span>
<span class="p_header">--- a/Documentation/input/alps.txt</span>
<span class="p_header">+++ b/Documentation/input/alps.txt</span>
<span class="p_chunk">@@ -119,8 +119,10 @@</span> <span class="p_context"> ALPS Absolute Mode - Protocol Version 2</span>
  byte 5:  0   z6   z5   z4   z3   z2   z1   z0
 
 Protocol Version 2 DualPoint devices send standard PS/2 mouse packets for
<span class="p_del">-the DualPoint Stick. For non interleaved dualpoint devices the pointingstick</span>
<span class="p_del">-buttons get reported separately in the PSM, PSR and PSL bits.</span>
<span class="p_add">+the DualPoint Stick. The M, R and L bits signal the combined status of both</span>
<span class="p_add">+the pointingstick and touchpad buttons, except for Dell dualpoint devices</span>
<span class="p_add">+where the pointingstick buttons get reported separately in the PSM, PSR</span>
<span class="p_add">+and PSL bits.</span>
 
 Dualpoint device -- interleaved packet format
 ---------------------------------------------
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 068dd690933d..838dabcb7f48 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 1
<span class="p_del">-SUBLEVEL = 5</span>
<span class="p_add">+SUBLEVEL = 6</span>
 EXTRAVERSION =
 NAME = Series 4800
 
<span class="p_header">diff --git a/arch/arm/boot/dts/imx35.dtsi b/arch/arm/boot/dts/imx35.dtsi</span>
<span class="p_header">index b6478e97d6a7..e6540b5cfa4c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx35.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx35.dtsi</span>
<span class="p_chunk">@@ -286,8 +286,8 @@</span> <span class="p_context"></span>
 			can1: can@53fe4000 {
 				compatible = &quot;fsl,imx35-flexcan&quot;, &quot;fsl,p1010-flexcan&quot;;
 				reg = &lt;0x53fe4000 0x1000&gt;;
<span class="p_del">-				clocks = &lt;&amp;clks 33&gt;;</span>
<span class="p_del">-				clock-names = &quot;ipg&quot;;</span>
<span class="p_add">+				clocks = &lt;&amp;clks 33&gt;, &lt;&amp;clks 33&gt;;</span>
<span class="p_add">+				clock-names = &quot;ipg&quot;, &quot;per&quot;;</span>
 				interrupts = &lt;43&gt;;
 				status = &quot;disabled&quot;;
 			};
<span class="p_chunk">@@ -295,8 +295,8 @@</span> <span class="p_context"></span>
 			can2: can@53fe8000 {
 				compatible = &quot;fsl,imx35-flexcan&quot;, &quot;fsl,p1010-flexcan&quot;;
 				reg = &lt;0x53fe8000 0x1000&gt;;
<span class="p_del">-				clocks = &lt;&amp;clks 34&gt;;</span>
<span class="p_del">-				clock-names = &quot;ipg&quot;;</span>
<span class="p_add">+				clocks = &lt;&amp;clks 34&gt;, &lt;&amp;clks 34&gt;;</span>
<span class="p_add">+				clock-names = &quot;ipg&quot;, &quot;per&quot;;</span>
 				interrupts = &lt;44&gt;;
 				status = &quot;disabled&quot;;
 			};
<span class="p_header">diff --git a/arch/arm/boot/dts/k2e-clocks.dtsi b/arch/arm/boot/dts/k2e-clocks.dtsi</span>
<span class="p_header">index 4773d6af66a0..d56d68fe7ffc 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/k2e-clocks.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/k2e-clocks.dtsi</span>
<span class="p_chunk">@@ -13,9 +13,8 @@</span> <span class="p_context"> clocks {</span>
 		#clock-cells = &lt;0&gt;;
 		compatible = &quot;ti,keystone,main-pll-clock&quot;;
 		clocks = &lt;&amp;refclksys&gt;;
<span class="p_del">-		reg = &lt;0x02620350 4&gt;, &lt;0x02310110 4&gt;;</span>
<span class="p_del">-		reg-names = &quot;control&quot;, &quot;multiplier&quot;;</span>
<span class="p_del">-		fixed-postdiv = &lt;2&gt;;</span>
<span class="p_add">+		reg = &lt;0x02620350 4&gt;, &lt;0x02310110 4&gt;, &lt;0x02310108 4&gt;;</span>
<span class="p_add">+		reg-names = &quot;control&quot;, &quot;multiplier&quot;, &quot;post-divider&quot;;</span>
 	};
 
 	papllclk: papllclk@2620358 {
<span class="p_header">diff --git a/arch/arm/boot/dts/k2hk-clocks.dtsi b/arch/arm/boot/dts/k2hk-clocks.dtsi</span>
<span class="p_header">index d5adee3c0067..af9b7190533a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/k2hk-clocks.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/k2hk-clocks.dtsi</span>
<span class="p_chunk">@@ -22,9 +22,8 @@</span> <span class="p_context"> clocks {</span>
 		#clock-cells = &lt;0&gt;;
 		compatible = &quot;ti,keystone,main-pll-clock&quot;;
 		clocks = &lt;&amp;refclksys&gt;;
<span class="p_del">-		reg = &lt;0x02620350 4&gt;, &lt;0x02310110 4&gt;;</span>
<span class="p_del">-		reg-names = &quot;control&quot;, &quot;multiplier&quot;;</span>
<span class="p_del">-		fixed-postdiv = &lt;2&gt;;</span>
<span class="p_add">+		reg = &lt;0x02620350 4&gt;, &lt;0x02310110 4&gt;, &lt;0x02310108 4&gt;;</span>
<span class="p_add">+		reg-names = &quot;control&quot;, &quot;multiplier&quot;, &quot;post-divider&quot;;</span>
 	};
 
 	papllclk: papllclk@2620358 {
<span class="p_header">diff --git a/arch/arm/boot/dts/k2l-clocks.dtsi b/arch/arm/boot/dts/k2l-clocks.dtsi</span>
<span class="p_header">index eb1e3e29f073..ef8464bb11ff 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/k2l-clocks.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/k2l-clocks.dtsi</span>
<span class="p_chunk">@@ -22,9 +22,8 @@</span> <span class="p_context"> clocks {</span>
 		#clock-cells = &lt;0&gt;;
 		compatible = &quot;ti,keystone,main-pll-clock&quot;;
 		clocks = &lt;&amp;refclksys&gt;;
<span class="p_del">-		reg = &lt;0x02620350 4&gt;, &lt;0x02310110 4&gt;;</span>
<span class="p_del">-		reg-names = &quot;control&quot;, &quot;multiplier&quot;;</span>
<span class="p_del">-		fixed-postdiv = &lt;2&gt;;</span>
<span class="p_add">+		reg = &lt;0x02620350 4&gt;, &lt;0x02310110 4&gt;, &lt;0x02310108 4&gt;;</span>
<span class="p_add">+		reg-names = &quot;control&quot;, &quot;multiplier&quot;, &quot;post-divider&quot;;</span>
 	};
 
 	papllclk: papllclk@2620358 {
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">index 752969ff9de0..5286e7773ed4 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_chunk">@@ -2373,6 +2373,9 @@</span> <span class="p_context"> static int of_dev_hwmod_lookup(struct device_node *np,</span>
  * registers.  This address is needed early so the OCP registers that
  * are part of the device&#39;s address space can be ioremapped properly.
  *
<span class="p_add">+ * If SYSC access is not needed, the registers will not be remapped</span>
<span class="p_add">+ * and non-availability of MPU access is not treated as an error.</span>
<span class="p_add">+ *</span>
  * Returns 0 on success, -EINVAL if an invalid hwmod is passed, and
  * -ENXIO on absent or invalid register target address space.
  */
<span class="p_chunk">@@ -2387,6 +2390,11 @@</span> <span class="p_context"> static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,</span>
 
 	_save_mpu_port_index(oh);
 
<span class="p_add">+	/* if we don&#39;t need sysc access we don&#39;t need to ioremap */</span>
<span class="p_add">+	if (!oh-&gt;class-&gt;sysc)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* we can&#39;t continue without MPU PORT if we need sysc access */</span>
 	if (oh-&gt;_int_flags &amp; _HWMOD_NO_MPU_PORT)
 		return -ENXIO;
 
<span class="p_chunk">@@ -2396,8 +2404,10 @@</span> <span class="p_context"> static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,</span>
 			 oh-&gt;name);
 
 		/* Extract the IO space from device tree blob */
<span class="p_del">-		if (!np)</span>
<span class="p_add">+		if (!np) {</span>
<span class="p_add">+			pr_err(&quot;omap_hwmod: %s: no dt node\n&quot;, oh-&gt;name);</span>
 			return -ENXIO;
<span class="p_add">+		}</span>
 
 		va_start = of_iomap(np, index + oh-&gt;mpu_rt_idx);
 	} else {
<span class="p_chunk">@@ -2456,13 +2466,11 @@</span> <span class="p_context"> static int __init _init(struct omap_hwmod *oh, void *data)</span>
 				oh-&gt;name, np-&gt;name);
 	}
 
<span class="p_del">-	if (oh-&gt;class-&gt;sysc) {</span>
<span class="p_del">-		r = _init_mpu_rt_base(oh, NULL, index, np);</span>
<span class="p_del">-		if (r &lt; 0) {</span>
<span class="p_del">-			WARN(1, &quot;omap_hwmod: %s: doesn&#39;t have mpu register target base\n&quot;,</span>
<span class="p_del">-			     oh-&gt;name);</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	r = _init_mpu_rt_base(oh, NULL, index, np);</span>
<span class="p_add">+	if (r &lt; 0) {</span>
<span class="p_add">+		WARN(1, &quot;omap_hwmod: %s: doesn&#39;t have mpu register target base\n&quot;,</span>
<span class="p_add">+		     oh-&gt;name);</span>
<span class="p_add">+		return 0;</span>
 	}
 
 	r = _init_clocks(oh, NULL);
<span class="p_header">diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c</span>
<span class="p_header">index d26fcd4cd6e6..c0cff3410166 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/signal32.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/signal32.c</span>
<span class="p_chunk">@@ -168,7 +168,8 @@</span> <span class="p_context"> int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)</span>
 		 * Other callers might not initialize the si_lsb field,
 		 * so check explicitely for the right codes here.
 		 */
<span class="p_del">-		if (from-&gt;si_code == BUS_MCEERR_AR || from-&gt;si_code == BUS_MCEERR_AO)</span>
<span class="p_add">+		if (from-&gt;si_signo == SIGBUS &amp;&amp;</span>
<span class="p_add">+		    (from-&gt;si_code == BUS_MCEERR_AR || from-&gt;si_code == BUS_MCEERR_AO))</span>
 			err |= __put_user(from-&gt;si_addr_lsb, &amp;to-&gt;si_addr_lsb);
 #endif
 		break;
<span class="p_chunk">@@ -201,8 +202,6 @@</span> <span class="p_context"> int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)</span>
 
 int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
 {
<span class="p_del">-	memset(to, 0, sizeof *to);</span>
<span class="p_del">-</span>
 	if (copy_from_user(to, from, __ARCH_SI_PREAMBLE_SIZE) ||
 	    copy_from_user(to-&gt;_sifields._pad,
 			   from-&gt;_sifields._pad, SI_PAD_SIZE))
<span class="p_header">diff --git a/arch/mips/ath79/setup.c b/arch/mips/ath79/setup.c</span>
<span class="p_header">index 7fc8397d16f2..fd2a36a79f97 100644</span>
<span class="p_header">--- a/arch/mips/ath79/setup.c</span>
<span class="p_header">+++ b/arch/mips/ath79/setup.c</span>
<span class="p_chunk">@@ -186,6 +186,7 @@</span> <span class="p_context"> int get_c0_perfcount_int(void)</span>
 {
 	return ATH79_MISC_IRQ(5);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(get_c0_perfcount_int);</span>
 
 unsigned int get_c0_compare_int(void)
 {
<span class="p_header">diff --git a/arch/mips/include/asm/mach-bcm63xx/dma-coherence.h b/arch/mips/include/asm/mach-bcm63xx/dma-coherence.h</span>
deleted file mode 100644
<span class="p_header">index 11d3b572b1b3..000000000000</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-bcm63xx/dma-coherence.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,10 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef __ASM_MACH_BCM63XX_DMA_COHERENCE_H</span>
<span class="p_del">-#define __ASM_MACH_BCM63XX_DMA_COHERENCE_H</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/bmips.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#define plat_post_dma_flush	bmips_post_dma_flush</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/mach-generic/dma-coherence.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* __ASM_MACH_BCM63XX_DMA_COHERENCE_H */</span>
<span class="p_header">diff --git a/arch/mips/include/asm/pgtable.h b/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">index 819af9d057a8..70f6e7f073b0 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -182,8 +182,39 @@</span> <span class="p_context"> static inline void set_pte(pte_t *ptep, pte_t pteval)</span>
 		 * Make sure the buddy is global too (if it&#39;s !none,
 		 * it better already be global)
 		 */
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * For SMP, multiple CPUs can race, so we need to do</span>
<span class="p_add">+		 * this atomically.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+#ifdef CONFIG_64BIT</span>
<span class="p_add">+#define LL_INSN &quot;lld&quot;</span>
<span class="p_add">+#define SC_INSN &quot;scd&quot;</span>
<span class="p_add">+#else /* CONFIG_32BIT */</span>
<span class="p_add">+#define LL_INSN &quot;ll&quot;</span>
<span class="p_add">+#define SC_INSN &quot;sc&quot;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		unsigned long page_global = _PAGE_GLOBAL;</span>
<span class="p_add">+		unsigned long tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		__asm__ __volatile__ (</span>
<span class="p_add">+			&quot;	.set	push\n&quot;</span>
<span class="p_add">+			&quot;	.set	noreorder\n&quot;</span>
<span class="p_add">+			&quot;1:	&quot; LL_INSN &quot;	%[tmp], %[buddy]\n&quot;</span>
<span class="p_add">+			&quot;	bnez	%[tmp], 2f\n&quot;</span>
<span class="p_add">+			&quot;	 or	%[tmp], %[tmp], %[global]\n&quot;</span>
<span class="p_add">+			&quot;	&quot; SC_INSN &quot;	%[tmp], %[buddy]\n&quot;</span>
<span class="p_add">+			&quot;	beqz	%[tmp], 1b\n&quot;</span>
<span class="p_add">+			&quot;	 nop\n&quot;</span>
<span class="p_add">+			&quot;2:\n&quot;</span>
<span class="p_add">+			&quot;	.set pop&quot;</span>
<span class="p_add">+			: [buddy] &quot;+m&quot; (buddy-&gt;pte),</span>
<span class="p_add">+			  [tmp] &quot;=&amp;r&quot; (tmp)</span>
<span class="p_add">+			: [global] &quot;r&quot; (page_global));</span>
<span class="p_add">+#else /* !CONFIG_SMP */</span>
 		if (pte_none(*buddy))
 			pte_val(*buddy) = pte_val(*buddy) | _PAGE_GLOBAL;
<span class="p_add">+#endif /* CONFIG_SMP */</span>
 	}
 #endif
 }
<span class="p_header">diff --git a/arch/mips/include/asm/stackframe.h b/arch/mips/include/asm/stackframe.h</span>
<span class="p_header">index 28d6d9364bd1..a71da576883c 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/stackframe.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/stackframe.h</span>
<span class="p_chunk">@@ -152,6 +152,31 @@</span> <span class="p_context"></span>
 		.set	noreorder
 		bltz	k0, 8f
 		 move	k1, sp
<span class="p_add">+#ifdef CONFIG_EVA</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Flush interAptiv&#39;s Return Prediction Stack (RPS) by writing</span>
<span class="p_add">+		 * EntryHi. Toggling Config7.RPS is slower and less portable.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * The RPS isn&#39;t automatically flushed when exceptions are</span>
<span class="p_add">+		 * taken, which can result in kernel mode speculative accesses</span>
<span class="p_add">+		 * to user addresses if the RPS mispredicts. That&#39;s harmless</span>
<span class="p_add">+		 * when user and kernel share the same address space, but with</span>
<span class="p_add">+		 * EVA the same user segments may be unmapped to kernel mode,</span>
<span class="p_add">+		 * even containing sensitive MMIO regions or invalid memory.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This can happen when the kernel sets the return address to</span>
<span class="p_add">+		 * ret_from_* and jr&#39;s to the exception handler, which looks</span>
<span class="p_add">+		 * more like a tail call than a function call. If nested calls</span>
<span class="p_add">+		 * don&#39;t evict the last user address in the RPS, it will</span>
<span class="p_add">+		 * mispredict the return and fetch from a user controlled</span>
<span class="p_add">+		 * address into the icache.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * More recent EVA-capable cores with MAAR to restrict</span>
<span class="p_add">+		 * speculative accesses aren&#39;t affected.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		MFC0	k0, CP0_ENTRYHI</span>
<span class="p_add">+		MTC0	k0, CP0_ENTRYHI</span>
<span class="p_add">+#endif</span>
 		.set	reorder
 		/* Called from user mode, new stack. */
 		get_saved_sp
<span class="p_header">diff --git a/arch/mips/kernel/mips-mt-fpaff.c b/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_header">index 3e4491aa6d6b..789d7bf4fef3 100644</span>
<span class="p_header">--- a/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_header">+++ b/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"> asmlinkage long mipsmt_sys_sched_getaffinity(pid_t pid, unsigned int len,</span>
 				      unsigned long __user *user_mask_ptr)
 {
 	unsigned int real_len;
<span class="p_del">-	cpumask_t mask;</span>
<span class="p_add">+	cpumask_t allowed, mask;</span>
 	int retval;
 	struct task_struct *p;
 
<span class="p_chunk">@@ -173,7 +173,8 @@</span> <span class="p_context"> asmlinkage long mipsmt_sys_sched_getaffinity(pid_t pid, unsigned int len,</span>
 	if (retval)
 		goto out_unlock;
 
<span class="p_del">-	cpumask_and(&amp;mask, &amp;p-&gt;thread.user_cpus_allowed, cpu_possible_mask);</span>
<span class="p_add">+	cpumask_or(&amp;allowed, &amp;p-&gt;thread.user_cpus_allowed, &amp;p-&gt;cpus_allowed);</span>
<span class="p_add">+	cpumask_and(&amp;mask, &amp;allowed, cpu_active_mask);</span>
 
 out_unlock:
 	read_unlock(&amp;tasklist_lock);
<span class="p_header">diff --git a/arch/mips/kernel/relocate_kernel.S b/arch/mips/kernel/relocate_kernel.S</span>
<span class="p_header">index 74bab9ddd0e1..c6bbf2165051 100644</span>
<span class="p_header">--- a/arch/mips/kernel/relocate_kernel.S</span>
<span class="p_header">+++ b/arch/mips/kernel/relocate_kernel.S</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"> LEAF(relocate_new_kernel)</span>
 
 process_entry:
 	PTR_L		s2, (s0)
<span class="p_del">-	PTR_ADD		s0, s0, SZREG</span>
<span class="p_add">+	PTR_ADDIU	s0, s0, SZREG</span>
 
 	/*
 	 * In case of a kdump/crash kernel, the indirection page is not
<span class="p_chunk">@@ -61,9 +61,9 @@</span> <span class="p_context"> copy_word:</span>
 	/* copy page word by word */
 	REG_L		s5, (s2)
 	REG_S		s5, (s4)
<span class="p_del">-	PTR_ADD		s4, s4, SZREG</span>
<span class="p_del">-	PTR_ADD		s2, s2, SZREG</span>
<span class="p_del">-	LONG_SUB	s6, s6, 1</span>
<span class="p_add">+	PTR_ADDIU	s4, s4, SZREG</span>
<span class="p_add">+	PTR_ADDIU	s2, s2, SZREG</span>
<span class="p_add">+	LONG_ADDIU	s6, s6, -1</span>
 	beq		s6, zero, process_entry
 	b		copy_word
 	b		process_entry
<span class="p_header">diff --git a/arch/mips/kernel/signal32.c b/arch/mips/kernel/signal32.c</span>
<span class="p_header">index 19a7705f2a01..5d7f2634996f 100644</span>
<span class="p_header">--- a/arch/mips/kernel/signal32.c</span>
<span class="p_header">+++ b/arch/mips/kernel/signal32.c</span>
<span class="p_chunk">@@ -409,8 +409,6 @@</span> <span class="p_context"> int copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)</span>
 
 int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
 {
<span class="p_del">-	memset(to, 0, sizeof *to);</span>
<span class="p_del">-</span>
 	if (copy_from_user(to, from, 3*sizeof(int)) ||
 	    copy_from_user(to-&gt;_sifields._pad,
 			   from-&gt;_sifields._pad, SI_PAD_SIZE32))
<span class="p_header">diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c</span>
<span class="p_header">index d2d1c1933bc9..5f5f44edc77d 100644</span>
<span class="p_header">--- a/arch/mips/kernel/traps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/traps.c</span>
<span class="p_chunk">@@ -192,6 +192,7 @@</span> <span class="p_context"> static void show_stacktrace(struct task_struct *task,</span>
 void show_stack(struct task_struct *task, unsigned long *sp)
 {
 	struct pt_regs regs;
<span class="p_add">+	mm_segment_t old_fs = get_fs();</span>
 	if (sp) {
 		regs.regs[29] = (unsigned long)sp;
 		regs.regs[31] = 0;
<span class="p_chunk">@@ -210,7 +211,13 @@</span> <span class="p_context"> void show_stack(struct task_struct *task, unsigned long *sp)</span>
 			prepare_frametrace(&amp;regs);
 		}
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * show_stack() deals exclusively with kernel mode, so be sure to access</span>
<span class="p_add">+	 * the stack in the kernel (not user) address space.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	set_fs(KERNEL_DS);</span>
 	show_stacktrace(task, &amp;regs);
<span class="p_add">+	set_fs(old_fs);</span>
 }
 
 static void show_code(unsigned int __user *pc)
<span class="p_chunk">@@ -1518,6 +1525,7 @@</span> <span class="p_context"> asmlinkage void do_mcheck(struct pt_regs *regs)</span>
 	const int field = 2 * sizeof(unsigned long);
 	int multi_match = regs-&gt;cp0_status &amp; ST0_TS;
 	enum ctx_state prev_state;
<span class="p_add">+	mm_segment_t old_fs = get_fs();</span>
 
 	prev_state = exception_enter();
 	show_regs(regs);
<span class="p_chunk">@@ -1539,8 +1547,13 @@</span> <span class="p_context"> asmlinkage void do_mcheck(struct pt_regs *regs)</span>
 		dump_tlb_all();
 	}
 
<span class="p_add">+	if (!user_mode(regs))</span>
<span class="p_add">+		set_fs(KERNEL_DS);</span>
<span class="p_add">+</span>
 	show_code((unsigned int __user *) regs-&gt;cp0_epc);
 
<span class="p_add">+	set_fs(old_fs);</span>
<span class="p_add">+</span>
 	/*
 	 * Some chips may have other causes of machine check (e.g. SB1
 	 * graduation timer)
<span class="p_header">diff --git a/arch/mips/kernel/unaligned.c b/arch/mips/kernel/unaligned.c</span>
<span class="p_header">index af84bef0c90d..eb3efd137fd1 100644</span>
<span class="p_header">--- a/arch/mips/kernel/unaligned.c</span>
<span class="p_header">+++ b/arch/mips/kernel/unaligned.c</span>
<span class="p_chunk">@@ -438,7 +438,7 @@</span> <span class="p_context"> do {                                                        \</span>
 		: &quot;memory&quot;);                                \
 } while(0)
 
<span class="p_del">-#define     StoreDW(addr, value, res) \</span>
<span class="p_add">+#define     _StoreDW(addr, value, res) \</span>
 do {                                                        \
 		__asm__ __volatile__ (                      \
 			&quot;.set\tpush\n\t&quot;		    \
<span class="p_header">diff --git a/arch/mips/lantiq/irq.c b/arch/mips/lantiq/irq.c</span>
<span class="p_header">index 6ab10573490d..d01ade63492f 100644</span>
<span class="p_header">--- a/arch/mips/lantiq/irq.c</span>
<span class="p_header">+++ b/arch/mips/lantiq/irq.c</span>
<span class="p_chunk">@@ -466,6 +466,7 @@</span> <span class="p_context"> int get_c0_perfcount_int(void)</span>
 {
 	return ltq_perfcount_irq;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(get_c0_perfcount_int);</span>
 
 unsigned int get_c0_compare_int(void)
 {
<span class="p_header">diff --git a/arch/mips/mti-malta/malta-time.c b/arch/mips/mti-malta/malta-time.c</span>
<span class="p_header">index 185e68261f45..a7f7d9ffb402 100644</span>
<span class="p_header">--- a/arch/mips/mti-malta/malta-time.c</span>
<span class="p_header">+++ b/arch/mips/mti-malta/malta-time.c</span>
<span class="p_chunk">@@ -148,6 +148,7 @@</span> <span class="p_context"> int get_c0_perfcount_int(void)</span>
 
 	return mips_cpu_perf_irq;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(get_c0_perfcount_int);</span>
 
 unsigned int get_c0_compare_int(void)
 {
<span class="p_chunk">@@ -165,14 +166,17 @@</span> <span class="p_context"> unsigned int get_c0_compare_int(void)</span>
 
 static void __init init_rtc(void)
 {
<span class="p_del">-	/* stop the clock whilst setting it up */</span>
<span class="p_del">-	CMOS_WRITE(RTC_SET | RTC_24H, RTC_CONTROL);</span>
<span class="p_add">+	unsigned char freq, ctrl;</span>
 
<span class="p_del">-	/* 32KHz time base */</span>
<span class="p_del">-	CMOS_WRITE(RTC_REF_CLCK_32KHZ, RTC_FREQ_SELECT);</span>
<span class="p_add">+	/* Set 32KHz time base if not already set */</span>
<span class="p_add">+	freq = CMOS_READ(RTC_FREQ_SELECT);</span>
<span class="p_add">+	if ((freq &amp; RTC_DIV_CTL) != RTC_REF_CLCK_32KHZ)</span>
<span class="p_add">+		CMOS_WRITE(RTC_REF_CLCK_32KHZ, RTC_FREQ_SELECT);</span>
 
<span class="p_del">-	/* start the clock */</span>
<span class="p_del">-	CMOS_WRITE(RTC_24H, RTC_CONTROL);</span>
<span class="p_add">+	/* Ensure SET bit is clear so RTC can run */</span>
<span class="p_add">+	ctrl = CMOS_READ(RTC_CONTROL);</span>
<span class="p_add">+	if (ctrl &amp; RTC_SET)</span>
<span class="p_add">+		CMOS_WRITE(ctrl &amp; ~RTC_SET, RTC_CONTROL);</span>
 }
 
 void __init plat_time_init(void)
<span class="p_header">diff --git a/arch/mips/mti-sead3/sead3-time.c b/arch/mips/mti-sead3/sead3-time.c</span>
<span class="p_header">index e1d69895fb1d..a120b7a5a8fe 100644</span>
<span class="p_header">--- a/arch/mips/mti-sead3/sead3-time.c</span>
<span class="p_header">+++ b/arch/mips/mti-sead3/sead3-time.c</span>
<span class="p_chunk">@@ -77,6 +77,7 @@</span> <span class="p_context"> int get_c0_perfcount_int(void)</span>
 		return MIPS_CPU_IRQ_BASE + cp0_perfcount_irq;
 	return -1;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(get_c0_perfcount_int);</span>
 
 unsigned int get_c0_compare_int(void)
 {
<span class="p_header">diff --git a/arch/mips/pistachio/time.c b/arch/mips/pistachio/time.c</span>
<span class="p_header">index 67889fcea8aa..ab73f6f405bb 100644</span>
<span class="p_header">--- a/arch/mips/pistachio/time.c</span>
<span class="p_header">+++ b/arch/mips/pistachio/time.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"> int get_c0_perfcount_int(void)</span>
 {
 	return gic_get_c0_perfcount_int();
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(get_c0_perfcount_int);</span>
 
 void __init plat_time_init(void)
 {
<span class="p_header">diff --git a/arch/mips/ralink/irq.c b/arch/mips/ralink/irq.c</span>
<span class="p_header">index 7cf91b92e9d1..199ace4ca1ad 100644</span>
<span class="p_header">--- a/arch/mips/ralink/irq.c</span>
<span class="p_header">+++ b/arch/mips/ralink/irq.c</span>
<span class="p_chunk">@@ -89,6 +89,7 @@</span> <span class="p_context"> int get_c0_perfcount_int(void)</span>
 {
 	return rt_perfcount_irq;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(get_c0_perfcount_int);</span>
 
 unsigned int get_c0_compare_int(void)
 {
<span class="p_header">diff --git a/arch/powerpc/kernel/signal_32.c b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">index d3a831ac0f92..da50e0c9c57e 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_chunk">@@ -966,8 +966,6 @@</span> <span class="p_context"> int copy_siginfo_to_user32(struct compat_siginfo __user *d, const siginfo_t *s)</span>
 
 int copy_siginfo_from_user32(siginfo_t *to, struct compat_siginfo __user *from)
 {
<span class="p_del">-	memset(to, 0, sizeof *to);</span>
<span class="p_del">-</span>
 	if (copy_from_user(to, from, 3*sizeof(int)) ||
 	    copy_from_user(to-&gt;_sifields._pad,
 			   from-&gt;_sifields._pad, SI_PAD_SIZE32))
<span class="p_header">diff --git a/arch/sparc/include/asm/visasm.h b/arch/sparc/include/asm/visasm.h</span>
<span class="p_header">index 1f0aa2024e94..6424249d5f78 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/visasm.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/visasm.h</span>
<span class="p_chunk">@@ -28,16 +28,10 @@</span> <span class="p_context"></span>
  * Must preserve %o5 between VISEntryHalf and VISExitHalf */
 
 #define VISEntryHalf					\
<span class="p_del">-	rd		%fprs, %o5;			\</span>
<span class="p_del">-	andcc		%o5, FPRS_FEF, %g0;		\</span>
<span class="p_del">-	be,pt		%icc, 297f;			\</span>
<span class="p_del">-	 sethi		%hi(298f), %g7;			\</span>
<span class="p_del">-	sethi		%hi(VISenterhalf), %g1;		\</span>
<span class="p_del">-	jmpl		%g1 + %lo(VISenterhalf), %g0;	\</span>
<span class="p_del">-	 or		%g7, %lo(298f), %g7;		\</span>
<span class="p_del">-	clr		%o5;				\</span>
<span class="p_del">-297:	wr		%o5, FPRS_FEF, %fprs;		\</span>
<span class="p_del">-298:</span>
<span class="p_add">+	VISEntry</span>
<span class="p_add">+</span>
<span class="p_add">+#define VISExitHalf					\</span>
<span class="p_add">+	VISExit</span>
 
 #define VISEntryHalfFast(fail_label)			\
 	rd		%fprs, %o5;			\
<span class="p_chunk">@@ -47,7 +41,7 @@</span> <span class="p_context"></span>
 	ba,a,pt		%xcc, fail_label;		\
 297:	wr		%o5, FPRS_FEF, %fprs;
 
<span class="p_del">-#define VISExitHalf					\</span>
<span class="p_add">+#define VISExitHalfFast					\</span>
 	wr		%o5, 0, %fprs;
 
 #ifndef __ASSEMBLY__
<span class="p_header">diff --git a/arch/sparc/lib/NG4memcpy.S b/arch/sparc/lib/NG4memcpy.S</span>
<span class="p_header">index 140527a20e7d..83aeeb1dffdb 100644</span>
<span class="p_header">--- a/arch/sparc/lib/NG4memcpy.S</span>
<span class="p_header">+++ b/arch/sparc/lib/NG4memcpy.S</span>
<span class="p_chunk">@@ -240,8 +240,11 @@</span> <span class="p_context"> FUNC_NAME:	/* %o0=dst, %o1=src, %o2=len */</span>
 	add		%o0, 0x40, %o0
 	bne,pt		%icc, 1b
 	 LOAD(prefetch, %g1 + 0x200, #n_reads_strong)
<span class="p_add">+#ifdef NON_USER_COPY</span>
<span class="p_add">+	VISExitHalfFast</span>
<span class="p_add">+#else</span>
 	VISExitHalf
<span class="p_del">-</span>
<span class="p_add">+#endif</span>
 	brz,pn		%o2, .Lexit
 	 cmp		%o2, 19
 	ble,pn		%icc, .Lsmall_unaligned
<span class="p_header">diff --git a/arch/sparc/lib/VISsave.S b/arch/sparc/lib/VISsave.S</span>
<span class="p_header">index b320ae9e2e2e..a063d84336d6 100644</span>
<span class="p_header">--- a/arch/sparc/lib/VISsave.S</span>
<span class="p_header">+++ b/arch/sparc/lib/VISsave.S</span>
<span class="p_chunk">@@ -44,9 +44,8 @@</span> <span class="p_context"> vis1:	ldub		[%g6 + TI_FPSAVED], %g3</span>
 
 	 stx		%g3, [%g6 + TI_GSR]
 2:	add		%g6, %g1, %g3
<span class="p_del">-	cmp		%o5, FPRS_DU</span>
<span class="p_del">-	be,pn		%icc, 6f</span>
<span class="p_del">-	 sll		%g1, 3, %g1</span>
<span class="p_add">+	mov		FPRS_DU | FPRS_DL | FPRS_FEF, %o5</span>
<span class="p_add">+	sll		%g1, 3, %g1</span>
 	stb		%o5, [%g3 + TI_FPSAVED]
 	rd		%gsr, %g2
 	add		%g6, %g1, %g3
<span class="p_chunk">@@ -80,65 +79,3 @@</span> <span class="p_context"> vis1:	ldub		[%g6 + TI_FPSAVED], %g3</span>
 	.align		32
 80:	jmpl		%g7 + %g0, %g0
 	 nop
<span class="p_del">-</span>
<span class="p_del">-6:	ldub		[%g3 + TI_FPSAVED], %o5</span>
<span class="p_del">-	or		%o5, FPRS_DU, %o5</span>
<span class="p_del">-	add		%g6, TI_FPREGS+0x80, %g2</span>
<span class="p_del">-	stb		%o5, [%g3 + TI_FPSAVED]</span>
<span class="p_del">-</span>
<span class="p_del">-	sll		%g1, 5, %g1</span>
<span class="p_del">-	add		%g6, TI_FPREGS+0xc0, %g3</span>
<span class="p_del">-	wr		%g0, FPRS_FEF, %fprs</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	stda		%f32, [%g2 + %g1] ASI_BLK_P</span>
<span class="p_del">-	stda		%f48, [%g3 + %g1] ASI_BLK_P</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	ba,pt		%xcc, 80f</span>
<span class="p_del">-	 nop</span>
<span class="p_del">-</span>
<span class="p_del">-	.align		32</span>
<span class="p_del">-80:	jmpl		%g7 + %g0, %g0</span>
<span class="p_del">-	 nop</span>
<span class="p_del">-</span>
<span class="p_del">-	.align		32</span>
<span class="p_del">-VISenterhalf:</span>
<span class="p_del">-	ldub		[%g6 + TI_FPDEPTH], %g1</span>
<span class="p_del">-	brnz,a,pn	%g1, 1f</span>
<span class="p_del">-	 cmp		%g1, 1</span>
<span class="p_del">-	stb		%g0, [%g6 + TI_FPSAVED]</span>
<span class="p_del">-	stx		%fsr, [%g6 + TI_XFSR]</span>
<span class="p_del">-	clr		%o5</span>
<span class="p_del">-	jmpl		%g7 + %g0, %g0</span>
<span class="p_del">-	 wr		%g0, FPRS_FEF, %fprs</span>
<span class="p_del">-</span>
<span class="p_del">-1:	bne,pn		%icc, 2f</span>
<span class="p_del">-	 srl		%g1, 1, %g1</span>
<span class="p_del">-	ba,pt		%xcc, vis1</span>
<span class="p_del">-	 sub		%g7, 8, %g7</span>
<span class="p_del">-2:	addcc		%g6, %g1, %g3</span>
<span class="p_del">-	sll		%g1, 3, %g1</span>
<span class="p_del">-	andn		%o5, FPRS_DU, %g2</span>
<span class="p_del">-	stb		%g2, [%g3 + TI_FPSAVED]</span>
<span class="p_del">-</span>
<span class="p_del">-	rd		%gsr, %g2</span>
<span class="p_del">-	add		%g6, %g1, %g3</span>
<span class="p_del">-	stx		%g2, [%g3 + TI_GSR]</span>
<span class="p_del">-	add		%g6, %g1, %g2</span>
<span class="p_del">-	stx		%fsr, [%g2 + TI_XFSR]</span>
<span class="p_del">-	sll		%g1, 5, %g1</span>
<span class="p_del">-3:	andcc		%o5, FPRS_DL, %g0</span>
<span class="p_del">-	be,pn		%icc, 4f</span>
<span class="p_del">-	 add		%g6, TI_FPREGS, %g2</span>
<span class="p_del">-</span>
<span class="p_del">-	add		%g6, TI_FPREGS+0x40, %g3</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	stda		%f0, [%g2 + %g1] ASI_BLK_P</span>
<span class="p_del">-	stda		%f16, [%g3 + %g1] ASI_BLK_P</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	ba,pt		%xcc, 4f</span>
<span class="p_del">-	 nop</span>
<span class="p_del">-</span>
<span class="p_del">-	.align		32</span>
<span class="p_del">-4:	and		%o5, FPRS_DU, %o5</span>
<span class="p_del">-	jmpl		%g7 + %g0, %g0</span>
<span class="p_del">-	 wr		%o5, FPRS_FEF, %fprs</span>
<span class="p_header">diff --git a/arch/sparc/lib/ksyms.c b/arch/sparc/lib/ksyms.c</span>
<span class="p_header">index 1d649a95660c..8069ce12f20b 100644</span>
<span class="p_header">--- a/arch/sparc/lib/ksyms.c</span>
<span class="p_header">+++ b/arch/sparc/lib/ksyms.c</span>
<span class="p_chunk">@@ -135,10 +135,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(copy_user_page);</span>
 void VISenter(void);
 EXPORT_SYMBOL(VISenter);
 
<span class="p_del">-/* CRYPTO code needs this */</span>
<span class="p_del">-void VISenterhalf(void);</span>
<span class="p_del">-EXPORT_SYMBOL(VISenterhalf);</span>
<span class="p_del">-</span>
 extern void xor_vis_2(unsigned long, unsigned long *, unsigned long *);
 extern void xor_vis_3(unsigned long, unsigned long *, unsigned long *,
 		unsigned long *);
<span class="p_header">diff --git a/arch/tile/kernel/compat_signal.c b/arch/tile/kernel/compat_signal.c</span>
<span class="p_header">index e8c2c04143cd..c667e104a0c2 100644</span>
<span class="p_header">--- a/arch/tile/kernel/compat_signal.c</span>
<span class="p_header">+++ b/arch/tile/kernel/compat_signal.c</span>
<span class="p_chunk">@@ -113,8 +113,6 @@</span> <span class="p_context"> int copy_siginfo_from_user32(siginfo_t *to, struct compat_siginfo __user *from)</span>
 	if (!access_ok(VERIFY_READ, from, sizeof(struct compat_siginfo)))
 		return -EFAULT;
 
<span class="p_del">-	memset(to, 0, sizeof(*to));</span>
<span class="p_del">-</span>
 	err = __get_user(to-&gt;si_signo, &amp;from-&gt;si_signo);
 	err |= __get_user(to-&gt;si_errno, &amp;from-&gt;si_errno);
 	err |= __get_user(to-&gt;si_code, &amp;from-&gt;si_code);
<span class="p_header">diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S</span>
<span class="p_header">index 02c2eff7478d..4bd6c197563d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/entry_64.S</span>
<span class="p_chunk">@@ -793,8 +793,6 @@</span> <span class="p_context"> retint_kernel:</span>
 restore_c_regs_and_iret:
 	RESTORE_C_REGS
 	REMOVE_PT_GPREGS_FROM_STACK 8
<span class="p_del">-</span>
<span class="p_del">-irq_return:</span>
 	INTERRUPT_RETURN
 
 ENTRY(native_iret)
<span class="p_chunk">@@ -1413,11 +1411,12 @@</span> <span class="p_context"> ENTRY(nmi)</span>
 	 *  If the variable is not set and the stack is not the NMI
 	 *  stack then:
 	 *    o Set the special variable on the stack
<span class="p_del">-	 *    o Copy the interrupt frame into a &quot;saved&quot; location on the stack</span>
<span class="p_del">-	 *    o Copy the interrupt frame into a &quot;copy&quot; location on the stack</span>
<span class="p_add">+	 *    o Copy the interrupt frame into an &quot;outermost&quot; location on the</span>
<span class="p_add">+	 *      stack</span>
<span class="p_add">+	 *    o Copy the interrupt frame into an &quot;iret&quot; location on the stack</span>
 	 *    o Continue processing the NMI
 	 *  If the variable is set or the previous stack is the NMI stack:
<span class="p_del">-	 *    o Modify the &quot;copy&quot; location to jump to the repeate_nmi</span>
<span class="p_add">+	 *    o Modify the &quot;iret&quot; location to jump to the repeat_nmi</span>
 	 *    o return back to the first NMI
 	 *
 	 * Now on exit of the first NMI, we first clear the stack variable
<span class="p_chunk">@@ -1426,32 +1425,151 @@</span> <span class="p_context"> ENTRY(nmi)</span>
 	 * a nested NMI that updated the copy interrupt stack frame, a
 	 * jump will be made to the repeat_nmi code that will handle the second
 	 * NMI.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However, espfix prevents us from directly returning to userspace</span>
<span class="p_add">+	 * with a single IRET instruction.  Similarly, IRET to user mode</span>
<span class="p_add">+	 * can fault.  We therefore handle NMIs from user space like</span>
<span class="p_add">+	 * other IST entries.</span>
 	 */
 
 	/* Use %rdx as our temp variable throughout */
 	pushq_cfi %rdx
 	CFI_REL_OFFSET rdx, 0
 
<span class="p_add">+	testb	$3, CS-RIP+8(%rsp)</span>
<span class="p_add">+	jz	.Lnmi_from_kernel</span>
<span class="p_add">+</span>
 	/*
<span class="p_del">-	 * If %cs was not the kernel segment, then the NMI triggered in user</span>
<span class="p_del">-	 * space, which means it is definitely not nested.</span>
<span class="p_add">+	 * NMI from user mode.  We need to run on the thread stack, but we</span>
<span class="p_add">+	 * can&#39;t go through the normal entry paths: NMIs are masked, and</span>
<span class="p_add">+	 * we don&#39;t want to enable interrupts, because then we&#39;ll end</span>
<span class="p_add">+	 * up in an awkward situation in which IRQs are on but NMIs</span>
<span class="p_add">+	 * are off.</span>
 	 */
<span class="p_del">-	cmpl $__KERNEL_CS, 16(%rsp)</span>
<span class="p_del">-	jne first_nmi</span>
<span class="p_add">+</span>
<span class="p_add">+	SWAPGS</span>
<span class="p_add">+	cld</span>
<span class="p_add">+	movq	%rsp, %rdx</span>
<span class="p_add">+	movq	PER_CPU_VAR(kernel_stack), %rsp</span>
<span class="p_add">+	pushq	5*8(%rdx)	/* pt_regs-&gt;ss */</span>
<span class="p_add">+	pushq	4*8(%rdx)	/* pt_regs-&gt;rsp */</span>
<span class="p_add">+	pushq	3*8(%rdx)	/* pt_regs-&gt;flags */</span>
<span class="p_add">+	pushq	2*8(%rdx)	/* pt_regs-&gt;cs */</span>
<span class="p_add">+	pushq	1*8(%rdx)	/* pt_regs-&gt;rip */</span>
<span class="p_add">+	pushq   $-1		/* pt_regs-&gt;orig_ax */</span>
<span class="p_add">+	pushq   %rdi		/* pt_regs-&gt;di */</span>
<span class="p_add">+	pushq   %rsi		/* pt_regs-&gt;si */</span>
<span class="p_add">+	pushq   (%rdx)		/* pt_regs-&gt;dx */</span>
<span class="p_add">+	pushq   %rcx		/* pt_regs-&gt;cx */</span>
<span class="p_add">+	pushq   %rax		/* pt_regs-&gt;ax */</span>
<span class="p_add">+	pushq   %r8		/* pt_regs-&gt;r8 */</span>
<span class="p_add">+	pushq   %r9		/* pt_regs-&gt;r9 */</span>
<span class="p_add">+	pushq   %r10		/* pt_regs-&gt;r10 */</span>
<span class="p_add">+	pushq   %r11		/* pt_regs-&gt;r11 */</span>
<span class="p_add">+	pushq	%rbx		/* pt_regs-&gt;rbx */</span>
<span class="p_add">+	pushq	%rbp		/* pt_regs-&gt;rbp */</span>
<span class="p_add">+	pushq	%r12		/* pt_regs-&gt;r12 */</span>
<span class="p_add">+	pushq	%r13		/* pt_regs-&gt;r13 */</span>
<span class="p_add">+	pushq	%r14		/* pt_regs-&gt;r14 */</span>
<span class="p_add">+	pushq	%r15		/* pt_regs-&gt;r15 */</span>
 
 	/*
<span class="p_del">-	 * Check the special variable on the stack to see if NMIs are</span>
<span class="p_del">-	 * executing.</span>
<span class="p_add">+	 * At this point we no longer need to worry about stack damage</span>
<span class="p_add">+	 * due to nesting -- we&#39;re on the normal thread stack and we&#39;re</span>
<span class="p_add">+	 * done with the NMI stack.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	movq	%rsp, %rdi</span>
<span class="p_add">+	movq	$-1, %rsi</span>
<span class="p_add">+	call	do_nmi</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Return back to user mode.  We must *not* do the normal exit</span>
<span class="p_add">+	 * work, because we don&#39;t want to enable interrupts.  Fortunately,</span>
<span class="p_add">+	 * do_nmi doesn&#39;t modify pt_regs.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	SWAPGS</span>
<span class="p_add">+	jmp	restore_c_regs_and_iret</span>
<span class="p_add">+</span>
<span class="p_add">+.Lnmi_from_kernel:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Here&#39;s what our stack frame will look like:</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | original SS                                             |</span>
<span class="p_add">+	 * | original Return RSP                                     |</span>
<span class="p_add">+	 * | original RFLAGS                                         |</span>
<span class="p_add">+	 * | original CS                                             |</span>
<span class="p_add">+	 * | original RIP                                            |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | temp storage for rdx                                    |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | &quot;NMI executing&quot; variable                                |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | iret SS          } Copied from &quot;outermost&quot; frame        |</span>
<span class="p_add">+	 * | iret Return RSP  } on each loop iteration; overwritten  |</span>
<span class="p_add">+	 * | iret RFLAGS      } by a nested NMI to force another     |</span>
<span class="p_add">+	 * | iret CS          } iteration if needed.                 |</span>
<span class="p_add">+	 * | iret RIP         }                                      |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | outermost SS          } initialized in first_nmi;       |</span>
<span class="p_add">+	 * | outermost Return RSP  } will not be changed before      |</span>
<span class="p_add">+	 * | outermost RFLAGS      } NMI processing is done.         |</span>
<span class="p_add">+	 * | outermost CS          } Copied to &quot;iret&quot; frame on each  |</span>
<span class="p_add">+	 * | outermost RIP         } iteration.                      |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | pt_regs                                                 |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The &quot;original&quot; frame is used by hardware.  Before re-enabling</span>
<span class="p_add">+	 * NMIs, we need to be done with it, and we need to leave enough</span>
<span class="p_add">+	 * space for the asm code here.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We return by executing IRET while RSP points to the &quot;iret&quot; frame.</span>
<span class="p_add">+	 * That will either return for real or it will loop back into NMI</span>
<span class="p_add">+	 * processing.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The &quot;outermost&quot; frame is copied to the &quot;iret&quot; frame on each</span>
<span class="p_add">+	 * iteration of the loop, so each iteration starts with the &quot;iret&quot;</span>
<span class="p_add">+	 * frame pointing to the final return target.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Determine whether we&#39;re a nested NMI.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If we interrupted kernel code between repeat_nmi and</span>
<span class="p_add">+	 * end_repeat_nmi, then we are a nested NMI.  We must not</span>
<span class="p_add">+	 * modify the &quot;iret&quot; frame because it&#39;s being written by</span>
<span class="p_add">+	 * the outer NMI.  That&#39;s okay; the outer NMI handler is</span>
<span class="p_add">+	 * about to about to call do_nmi anyway, so we can just</span>
<span class="p_add">+	 * resume the outer NMI.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	$repeat_nmi, %rdx</span>
<span class="p_add">+	cmpq	8(%rsp), %rdx</span>
<span class="p_add">+	ja	1f</span>
<span class="p_add">+	movq	$end_repeat_nmi, %rdx</span>
<span class="p_add">+	cmpq	8(%rsp), %rdx</span>
<span class="p_add">+	ja	nested_nmi_out</span>
<span class="p_add">+1:</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Now check &quot;NMI executing&quot;.  If it&#39;s set, then we&#39;re nested.</span>
<span class="p_add">+	 * This will not detect if we interrupted an outer NMI just</span>
<span class="p_add">+	 * before IRET.</span>
 	 */
 	cmpl $1, -8(%rsp)
 	je nested_nmi
 
 	/*
<span class="p_del">-	 * Now test if the previous stack was an NMI stack.</span>
<span class="p_del">-	 * We need the double check. We check the NMI stack to satisfy the</span>
<span class="p_del">-	 * race when the first NMI clears the variable before returning.</span>
<span class="p_del">-	 * We check the variable because the first NMI could be in a</span>
<span class="p_del">-	 * breakpoint routine using a breakpoint stack.</span>
<span class="p_add">+	 * Now test if the previous stack was an NMI stack.  This covers</span>
<span class="p_add">+	 * the case where we interrupt an outer NMI after it clears</span>
<span class="p_add">+	 * &quot;NMI executing&quot; but before IRET.  We need to be careful, though:</span>
<span class="p_add">+	 * there is one case in which RSP could point to the NMI stack</span>
<span class="p_add">+	 * despite there being no NMI active: naughty userspace controls</span>
<span class="p_add">+	 * RSP at the very beginning of the SYSCALL targets.  We can</span>
<span class="p_add">+	 * pull a fast one on naughty userspace, though: we program</span>
<span class="p_add">+	 * SYSCALL to mask DF, so userspace cannot cause DF to be set</span>
<span class="p_add">+	 * if it controls the kernel&#39;s RSP.  We set DF before we clear</span>
<span class="p_add">+	 * &quot;NMI executing&quot;.</span>
 	 */
 	lea	6*8(%rsp), %rdx
 	/* Compare the NMI stack (rdx) with the stack we came from (4*8(%rsp)) */
<span class="p_chunk">@@ -1462,25 +1580,21 @@</span> <span class="p_context"> ENTRY(nmi)</span>
 	cmpq	%rdx, 4*8(%rsp)
 	/* If it is below the NMI stack, it is a normal NMI */
 	jb	first_nmi
<span class="p_del">-	/* Ah, it is within the NMI stack, treat it as nested */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Ah, it is within the NMI stack. */</span>
<span class="p_add">+</span>
<span class="p_add">+	testb	$(X86_EFLAGS_DF &gt;&gt; 8), (3*8 + 1)(%rsp)</span>
<span class="p_add">+	jz	first_nmi	/* RSP was user controlled. */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* This is a nested NMI. */</span>
 
 	CFI_REMEMBER_STATE
 
 nested_nmi:
 	/*
<span class="p_del">-	 * Do nothing if we interrupted the fixup in repeat_nmi.</span>
<span class="p_del">-	 * It&#39;s about to repeat the NMI handler, so we are fine</span>
<span class="p_del">-	 * with ignoring this one.</span>
<span class="p_add">+	 * Modify the &quot;iret&quot; frame to point to repeat_nmi, forcing another</span>
<span class="p_add">+	 * iteration of NMI handling.</span>
 	 */
<span class="p_del">-	movq $repeat_nmi, %rdx</span>
<span class="p_del">-	cmpq 8(%rsp), %rdx</span>
<span class="p_del">-	ja 1f</span>
<span class="p_del">-	movq $end_repeat_nmi, %rdx</span>
<span class="p_del">-	cmpq 8(%rsp), %rdx</span>
<span class="p_del">-	ja nested_nmi_out</span>
<span class="p_del">-</span>
<span class="p_del">-1:</span>
<span class="p_del">-	/* Set up the interrupted NMIs stack to jump to repeat_nmi */</span>
 	leaq -1*8(%rsp), %rdx
 	movq %rdx, %rsp
 	CFI_ADJUST_CFA_OFFSET 1*8
<span class="p_chunk">@@ -1499,60 +1613,23 @@</span> <span class="p_context"> nested_nmi_out:</span>
 	popq_cfi %rdx
 	CFI_RESTORE rdx
 
<span class="p_del">-	/* No need to check faults here */</span>
<span class="p_add">+	/* We are returning to kernel mode, so this cannot result in a fault. */</span>
 	INTERRUPT_RETURN
 
 	CFI_RESTORE_STATE
 first_nmi:
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Because nested NMIs will use the pushed location that we</span>
<span class="p_del">-	 * stored in rdx, we must keep that space available.</span>
<span class="p_del">-	 * Here&#39;s what our stack frame will look like:</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | original SS             |</span>
<span class="p_del">-	 * | original Return RSP     |</span>
<span class="p_del">-	 * | original RFLAGS         |</span>
<span class="p_del">-	 * | original CS             |</span>
<span class="p_del">-	 * | original RIP            |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | temp storage for rdx    |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | NMI executing variable  |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | copied SS               |</span>
<span class="p_del">-	 * | copied Return RSP       |</span>
<span class="p_del">-	 * | copied RFLAGS           |</span>
<span class="p_del">-	 * | copied CS               |</span>
<span class="p_del">-	 * | copied RIP              |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | Saved SS                |</span>
<span class="p_del">-	 * | Saved Return RSP        |</span>
<span class="p_del">-	 * | Saved RFLAGS            |</span>
<span class="p_del">-	 * | Saved CS                |</span>
<span class="p_del">-	 * | Saved RIP               |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | pt_regs                 |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * The saved stack frame is used to fix up the copied stack frame</span>
<span class="p_del">-	 * that a nested NMI may change to make the interrupted NMI iret jump</span>
<span class="p_del">-	 * to the repeat_nmi. The original stack frame and the temp storage</span>
<span class="p_del">-	 * is also used by nested NMIs and can not be trusted on exit.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	/* Do not pop rdx, nested NMIs will corrupt that part of the stack */</span>
<span class="p_add">+	/* Restore rdx. */</span>
 	movq (%rsp), %rdx
 	CFI_RESTORE rdx
 
<span class="p_del">-	/* Set the NMI executing variable on the stack. */</span>
<span class="p_add">+	/* Set &quot;NMI executing&quot; on the stack. */</span>
 	pushq_cfi $1
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Leave room for the &quot;copied&quot; frame</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* Leave room for the &quot;iret&quot; frame */</span>
 	subq $(5*8), %rsp
 	CFI_ADJUST_CFA_OFFSET 5*8
 
<span class="p_del">-	/* Copy the stack frame to the Saved frame */</span>
<span class="p_add">+	/* Copy the &quot;original&quot; frame to the &quot;outermost&quot; frame */</span>
 	.rept 5
 	pushq_cfi 11*8(%rsp)
 	.endr
<span class="p_chunk">@@ -1560,6 +1637,7 @@</span> <span class="p_context"> first_nmi:</span>
 
 	/* Everything up to here is safe from nested NMIs */
 
<span class="p_add">+repeat_nmi:</span>
 	/*
 	 * If there was a nested NMI, the first NMI&#39;s iret will return
 	 * here. But NMIs are still enabled and we can take another
<span class="p_chunk">@@ -1568,16 +1646,21 @@</span> <span class="p_context"> first_nmi:</span>
 	 * it will just return, as we are about to repeat an NMI anyway.
 	 * This makes it safe to copy to the stack frame that a nested
 	 * NMI will update.
<span class="p_del">-	 */</span>
<span class="p_del">-repeat_nmi:</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Update the stack variable to say we are still in NMI (the update</span>
<span class="p_del">-	 * is benign for the non-repeat case, where 1 was pushed just above</span>
<span class="p_del">-	 * to this very stack slot).</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * RSP is pointing to &quot;outermost RIP&quot;.  gsbase is unknown, but, if</span>
<span class="p_add">+	 * we&#39;re repeating an NMI, gsbase has the same value that it had on</span>
<span class="p_add">+	 * the first iteration.  paranoid_entry will load the kernel</span>
<span class="p_add">+	 * gsbase if needed before we call do_nmi.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Set &quot;NMI executing&quot; in case we came back here via IRET.</span>
 	 */
 	movq $1, 10*8(%rsp)
 
<span class="p_del">-	/* Make another copy, this one may be modified by nested NMIs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Copy the &quot;outermost&quot; frame to the &quot;iret&quot; frame.  NMIs that nest</span>
<span class="p_add">+	 * here must not modify the &quot;iret&quot; frame while we&#39;re writing to</span>
<span class="p_add">+	 * it or it will end up containing garbage.</span>
<span class="p_add">+	 */</span>
 	addq $(10*8), %rsp
 	CFI_ADJUST_CFA_OFFSET -10*8
 	.rept 5
<span class="p_chunk">@@ -1588,9 +1671,9 @@</span> <span class="p_context"> repeat_nmi:</span>
 end_repeat_nmi:
 
 	/*
<span class="p_del">-	 * Everything below this point can be preempted by a nested</span>
<span class="p_del">-	 * NMI if the first NMI took an exception and reset our iret stack</span>
<span class="p_del">-	 * so that we repeat another NMI.</span>
<span class="p_add">+	 * Everything below this point can be preempted by a nested NMI.</span>
<span class="p_add">+	 * If this happens, then the inner NMI will change the &quot;iret&quot;</span>
<span class="p_add">+	 * frame to point back to repeat_nmi.</span>
 	 */
 	pushq_cfi $-1		/* ORIG_RAX: no syscall to restart */
 	ALLOC_PT_GPREGS_ON_STACK
<span class="p_chunk">@@ -1605,29 +1688,11 @@</span> <span class="p_context"> end_repeat_nmi:</span>
 	call paranoid_entry
 	DEFAULT_FRAME 0
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Save off the CR2 register. If we take a page fault in the NMI then</span>
<span class="p_del">-	 * it could corrupt the CR2 value. If the NMI preempts a page fault</span>
<span class="p_del">-	 * handler before it was able to read the CR2 register, and then the</span>
<span class="p_del">-	 * NMI itself takes a page fault, the page fault that was preempted</span>
<span class="p_del">-	 * will read the information from the NMI page fault and not the</span>
<span class="p_del">-	 * origin fault. Save it off and restore it if it changes.</span>
<span class="p_del">-	 * Use the r12 callee-saved register.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	movq %cr2, %r12</span>
<span class="p_del">-</span>
 	/* paranoidentry do_nmi, 0; without TRACE_IRQS_OFF */
 	movq %rsp,%rdi
 	movq $-1,%rsi
 	call do_nmi
 
<span class="p_del">-	/* Did the NMI take a page fault? Restore cr2 if it did */</span>
<span class="p_del">-	movq %cr2, %rcx</span>
<span class="p_del">-	cmpq %rcx, %r12</span>
<span class="p_del">-	je 1f</span>
<span class="p_del">-	movq %r12, %cr2</span>
<span class="p_del">-1:</span>
<span class="p_del">-	</span>
 	testl %ebx,%ebx				/* swapgs needed? */
 	jnz nmi_restore
 nmi_swapgs:
<span class="p_chunk">@@ -1635,12 +1700,27 @@</span> <span class="p_context"> nmi_swapgs:</span>
 nmi_restore:
 	RESTORE_EXTRA_REGS
 	RESTORE_C_REGS
<span class="p_del">-	/* Pop the extra iret frame at once */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Point RSP at the &quot;iret&quot; frame. */</span>
 	REMOVE_PT_GPREGS_FROM_STACK 6*8
 
<span class="p_del">-	/* Clear the NMI executing stack variable */</span>
<span class="p_del">-	movq $0, 5*8(%rsp)</span>
<span class="p_del">-	jmp irq_return</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear &quot;NMI executing&quot;.  Set DF first so that we can easily</span>
<span class="p_add">+	 * distinguish the remaining code between here and IRET from</span>
<span class="p_add">+	 * the SYSCALL entry and exit paths.  On a native kernel, we</span>
<span class="p_add">+	 * could just inspect RIP, but, on paravirt kernels,</span>
<span class="p_add">+	 * INTERRUPT_RETURN can translate into a jump into a</span>
<span class="p_add">+	 * hypercall page.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	std</span>
<span class="p_add">+	movq	$0, 5*8(%rsp)		/* clear &quot;NMI executing&quot; */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * INTERRUPT_RETURN reads the &quot;iret&quot; frame and exits the NMI</span>
<span class="p_add">+	 * stack in a single instruction.  We are returning to kernel</span>
<span class="p_add">+	 * mode, so this cannot result in a fault.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	INTERRUPT_RETURN</span>
 	CFI_ENDPROC
 END(nmi)
 
<span class="p_header">diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c</span>
<span class="p_header">index c3e985d1751c..d05bd2e2ee91 100644</span>
<span class="p_header">--- a/arch/x86/kernel/nmi.c</span>
<span class="p_header">+++ b/arch/x86/kernel/nmi.c</span>
<span class="p_chunk">@@ -408,15 +408,15 @@</span> <span class="p_context"> static void default_do_nmi(struct pt_regs *regs)</span>
 NOKPROBE_SYMBOL(default_do_nmi);
 
 /*
<span class="p_del">- * NMIs can hit breakpoints which will cause it to lose its</span>
<span class="p_del">- * NMI context with the CPU when the breakpoint does an iret.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-/*</span>
<span class="p_del">- * For i386, NMIs use the same stack as the kernel, and we can</span>
<span class="p_del">- * add a workaround to the iret problem in C (preventing nested</span>
<span class="p_del">- * NMIs if an NMI takes a trap). Simply have 3 states the NMI</span>
<span class="p_del">- * can be in:</span>
<span class="p_add">+ * NMIs can page fault or hit breakpoints which will cause it to lose</span>
<span class="p_add">+ * its NMI context with the CPU when the breakpoint or page fault does an IRET.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * As a result, NMIs can nest if NMIs get unmasked due an IRET during</span>
<span class="p_add">+ * NMI processing.  On x86_64, the asm glue protects us from nested NMIs</span>
<span class="p_add">+ * if the outer NMI came from kernel mode, but we can still nest if the</span>
<span class="p_add">+ * outer NMI came from user mode.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * To handle these nested NMIs, we have three states:</span>
  *
  *  1) not running
  *  2) executing
<span class="p_chunk">@@ -430,15 +430,14 @@</span> <span class="p_context"> NOKPROBE_SYMBOL(default_do_nmi);</span>
  * (Note, the latch is binary, thus multiple NMIs triggering,
  *  when one is running, are ignored. Only one NMI is restarted.)
  *
<span class="p_del">- * If an NMI hits a breakpoint that executes an iret, another</span>
<span class="p_del">- * NMI can preempt it. We do not want to allow this new NMI</span>
<span class="p_del">- * to run, but we want to execute it when the first one finishes.</span>
<span class="p_del">- * We set the state to &quot;latched&quot;, and the exit of the first NMI will</span>
<span class="p_del">- * perform a dec_return, if the result is zero (NOT_RUNNING), then</span>
<span class="p_del">- * it will simply exit the NMI handler. If not, the dec_return</span>
<span class="p_del">- * would have set the state to NMI_EXECUTING (what we want it to</span>
<span class="p_del">- * be when we are running). In this case, we simply jump back</span>
<span class="p_del">- * to rerun the NMI handler again, and restart the &#39;latched&#39; NMI.</span>
<span class="p_add">+ * If an NMI executes an iret, another NMI can preempt it. We do not</span>
<span class="p_add">+ * want to allow this new NMI to run, but we want to execute it when the</span>
<span class="p_add">+ * first one finishes.  We set the state to &quot;latched&quot;, and the exit of</span>
<span class="p_add">+ * the first NMI will perform a dec_return, if the result is zero</span>
<span class="p_add">+ * (NOT_RUNNING), then it will simply exit the NMI handler. If not, the</span>
<span class="p_add">+ * dec_return would have set the state to NMI_EXECUTING (what we want it</span>
<span class="p_add">+ * to be when we are running). In this case, we simply jump back to</span>
<span class="p_add">+ * rerun the NMI handler again, and restart the &#39;latched&#39; NMI.</span>
  *
  * No trap (breakpoint or page fault) should be hit before nmi_restart,
  * thus there is no race between the first check of state for NOT_RUNNING
<span class="p_chunk">@@ -461,49 +460,36 @@</span> <span class="p_context"> enum nmi_states {</span>
 static DEFINE_PER_CPU(enum nmi_states, nmi_state);
 static DEFINE_PER_CPU(unsigned long, nmi_cr2);
 
<span class="p_del">-#define nmi_nesting_preprocess(regs)					\</span>
<span class="p_del">-	do {								\</span>
<span class="p_del">-		if (this_cpu_read(nmi_state) != NMI_NOT_RUNNING) {	\</span>
<span class="p_del">-			this_cpu_write(nmi_state, NMI_LATCHED);		\</span>
<span class="p_del">-			return;						\</span>
<span class="p_del">-		}							\</span>
<span class="p_del">-		this_cpu_write(nmi_state, NMI_EXECUTING);		\</span>
<span class="p_del">-		this_cpu_write(nmi_cr2, read_cr2());			\</span>
<span class="p_del">-	} while (0);							\</span>
<span class="p_del">-	nmi_restart:</span>
<span class="p_del">-</span>
<span class="p_del">-#define nmi_nesting_postprocess()					\</span>
<span class="p_del">-	do {								\</span>
<span class="p_del">-		if (unlikely(this_cpu_read(nmi_cr2) != read_cr2()))	\</span>
<span class="p_del">-			write_cr2(this_cpu_read(nmi_cr2));		\</span>
<span class="p_del">-		if (this_cpu_dec_return(nmi_state))			\</span>
<span class="p_del">-			goto nmi_restart;				\</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-#else /* x86_64 */</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
 /*
<span class="p_del">- * In x86_64 things are a bit more difficult. This has the same problem</span>
<span class="p_del">- * where an NMI hitting a breakpoint that calls iret will remove the</span>
<span class="p_del">- * NMI context, allowing a nested NMI to enter. What makes this more</span>
<span class="p_del">- * difficult is that both NMIs and breakpoints have their own stack.</span>
<span class="p_del">- * When a new NMI or breakpoint is executed, the stack is set to a fixed</span>
<span class="p_del">- * point. If an NMI is nested, it will have its stack set at that same</span>
<span class="p_del">- * fixed address that the first NMI had, and will start corrupting the</span>
<span class="p_del">- * stack. This is handled in entry_64.S, but the same problem exists with</span>
<span class="p_del">- * the breakpoint stack.</span>
<span class="p_add">+ * In x86_64, we need to handle breakpoint -&gt; NMI -&gt; breakpoint.  Without</span>
<span class="p_add">+ * some care, the inner breakpoint will clobber the outer breakpoint&#39;s</span>
<span class="p_add">+ * stack.</span>
  *
<span class="p_del">- * If a breakpoint is being processed, and the debug stack is being used,</span>
<span class="p_del">- * if an NMI comes in and also hits a breakpoint, the stack pointer</span>
<span class="p_del">- * will be set to the same fixed address as the breakpoint that was</span>
<span class="p_del">- * interrupted, causing that stack to be corrupted. To handle this case,</span>
<span class="p_del">- * check if the stack that was interrupted is the debug stack, and if</span>
<span class="p_del">- * so, change the IDT so that new breakpoints will use the current stack</span>
<span class="p_del">- * and not switch to the fixed address. On return of the NMI, switch back</span>
<span class="p_del">- * to the original IDT.</span>
<span class="p_add">+ * If a breakpoint is being processed, and the debug stack is being</span>
<span class="p_add">+ * used, if an NMI comes in and also hits a breakpoint, the stack</span>
<span class="p_add">+ * pointer will be set to the same fixed address as the breakpoint that</span>
<span class="p_add">+ * was interrupted, causing that stack to be corrupted. To handle this</span>
<span class="p_add">+ * case, check if the stack that was interrupted is the debug stack, and</span>
<span class="p_add">+ * if so, change the IDT so that new breakpoints will use the current</span>
<span class="p_add">+ * stack and not switch to the fixed address. On return of the NMI,</span>
<span class="p_add">+ * switch back to the original IDT.</span>
  */
 static DEFINE_PER_CPU(int, update_debug_stack);
<span class="p_add">+#endif</span>
 
<span class="p_del">-static inline void nmi_nesting_preprocess(struct pt_regs *regs)</span>
<span class="p_add">+dotraplinkage notrace void</span>
<span class="p_add">+do_nmi(struct pt_regs *regs, long error_code)</span>
 {
<span class="p_add">+	if (this_cpu_read(nmi_state) != NMI_NOT_RUNNING) {</span>
<span class="p_add">+		this_cpu_write(nmi_state, NMI_LATCHED);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	this_cpu_write(nmi_state, NMI_EXECUTING);</span>
<span class="p_add">+	this_cpu_write(nmi_cr2, read_cr2());</span>
<span class="p_add">+nmi_restart:</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
 	/*
 	 * If we interrupted a breakpoint, it is possible that
 	 * the nmi handler will have breakpoints too. We need to
<span class="p_chunk">@@ -514,22 +500,8 @@</span> <span class="p_context"> static inline void nmi_nesting_preprocess(struct pt_regs *regs)</span>
 		debug_stack_set_zero();
 		this_cpu_write(update_debug_stack, 1);
 	}
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void nmi_nesting_postprocess(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (unlikely(this_cpu_read(update_debug_stack))) {</span>
<span class="p_del">-		debug_stack_reset();</span>
<span class="p_del">-		this_cpu_write(update_debug_stack, 0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
 #endif
 
<span class="p_del">-dotraplinkage notrace void</span>
<span class="p_del">-do_nmi(struct pt_regs *regs, long error_code)</span>
<span class="p_del">-{</span>
<span class="p_del">-	nmi_nesting_preprocess(regs);</span>
<span class="p_del">-</span>
 	nmi_enter();
 
 	inc_irq_stat(__nmi_count);
<span class="p_chunk">@@ -539,8 +511,17 @@</span> <span class="p_context"> do_nmi(struct pt_regs *regs, long error_code)</span>
 
 	nmi_exit();
 
<span class="p_del">-	/* On i386, may loop back to preprocess */</span>
<span class="p_del">-	nmi_nesting_postprocess();</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	if (unlikely(this_cpu_read(update_debug_stack))) {</span>
<span class="p_add">+		debug_stack_reset();</span>
<span class="p_add">+		this_cpu_write(update_debug_stack, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(this_cpu_read(nmi_cr2) != read_cr2()))</span>
<span class="p_add">+		write_cr2(this_cpu_read(nmi_cr2));</span>
<span class="p_add">+	if (this_cpu_dec_return(nmi_state))</span>
<span class="p_add">+		goto nmi_restart;</span>
 }
 NOKPROBE_SYMBOL(do_nmi);
 
<span class="p_header">diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h</span>
<span class="p_header">index 9d28383fc1e7..c4ea87eedf8a 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.h</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.h</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static inline bool kvm_apic_vid_enabled(struct kvm *kvm)</span>
 
 static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	return vcpu-&gt;arch.apic-&gt;pending_events;</span>
<span class="p_add">+	return kvm_vcpu_has_lapic(vcpu) &amp;&amp; vcpu-&gt;arch.apic-&gt;pending_events;</span>
 }
 
 bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector);
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index 46957ead3060..a671e837228d 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -483,6 +483,7 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 	pte_t pte;
 	unsigned long pfn;
 	struct page *page;
<span class="p_add">+	unsigned char dummy;</span>
 
 	ptep = lookup_address((unsigned long)v, &amp;level);
 	BUG_ON(ptep == NULL);
<span class="p_chunk">@@ -492,6 +493,32 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 
 	pte = pfn_pte(pfn, prot);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Careful: update_va_mapping() will fail if the virtual address</span>
<span class="p_add">+	 * we&#39;re poking isn&#39;t populated in the page tables.  We don&#39;t</span>
<span class="p_add">+	 * need to worry about the direct map (that&#39;s always in the page</span>
<span class="p_add">+	 * tables), but we need to be careful about vmap space.  In</span>
<span class="p_add">+	 * particular, the top level page table can lazily propagate</span>
<span class="p_add">+	 * entries between processes, so if we&#39;ve switched mms since we</span>
<span class="p_add">+	 * vmapped the target in the first place, we might not have the</span>
<span class="p_add">+	 * top-level page table entry populated.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We disable preemption because we want the same mm active when</span>
<span class="p_add">+	 * we probe the target and when we issue the hypercall.  We&#39;ll</span>
<span class="p_add">+	 * have the same nominal mm, but if we&#39;re a kernel thread, lazy</span>
<span class="p_add">+	 * mm dropping could change our pgd.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Out of an abundance of caution, this uses __get_user() to fault</span>
<span class="p_add">+	 * in the target address just in case there&#39;s some obscure case</span>
<span class="p_add">+	 * in which the target address isn&#39;t readable.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	pagefault_disable();	/* Avoid warnings due to being atomic. */</span>
<span class="p_add">+	__get_user(dummy, (unsigned char __user __force *)v);</span>
<span class="p_add">+	pagefault_enable();</span>
<span class="p_add">+</span>
 	if (HYPERVISOR_update_va_mapping((unsigned long)v, pte, 0))
 		BUG();
 
<span class="p_chunk">@@ -503,6 +530,8 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 				BUG();
 	} else
 		kmap_flush_unused();
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
 }
 
 static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)
<span class="p_chunk">@@ -510,6 +539,17 @@</span> <span class="p_context"> static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)</span>
 	const unsigned entries_per_page = PAGE_SIZE / LDT_ENTRY_SIZE;
 	int i;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to mark the all aliases of the LDT pages RO.  We</span>
<span class="p_add">+	 * don&#39;t need to call vm_flush_aliases(), though, since that&#39;s</span>
<span class="p_add">+	 * only responsible for flushing aliases out the TLBs, not the</span>
<span class="p_add">+	 * page tables, and Xen will flush the TLB for us if needed.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * To avoid confusing future readers: none of this is necessary</span>
<span class="p_add">+	 * to load the LDT.  The hypervisor only checks this when the</span>
<span class="p_add">+	 * LDT is faulted in due to subsequent descriptor access.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	for(i = 0; i &lt; entries; i += entries_per_page)
 		set_aliased_prot(ldt + i, PAGE_KERNEL_RO);
 }
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index 53f253574abe..010ce0b1f517 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -522,6 +522,7 @@</span> <span class="p_context"> void rbd_warn(struct rbd_device *rbd_dev, const char *fmt, ...)</span>
 #  define rbd_assert(expr)	((void) 0)
 #endif /* !RBD_DEBUG */
 
<span class="p_add">+static void rbd_osd_copyup_callback(struct rbd_obj_request *obj_request);</span>
 static int rbd_img_obj_request_submit(struct rbd_obj_request *obj_request);
 static void rbd_img_parent_read(struct rbd_obj_request *obj_request);
 static void rbd_dev_remove_parent(struct rbd_device *rbd_dev);
<span class="p_chunk">@@ -1797,6 +1798,16 @@</span> <span class="p_context"> static void rbd_osd_stat_callback(struct rbd_obj_request *obj_request)</span>
 	obj_request_done_set(obj_request);
 }
 
<span class="p_add">+static void rbd_osd_call_callback(struct rbd_obj_request *obj_request)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dout(&quot;%s: obj %p\n&quot;, __func__, obj_request);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (obj_request_img_data_test(obj_request))</span>
<span class="p_add">+		rbd_osd_copyup_callback(obj_request);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		obj_request_done_set(obj_request);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void rbd_osd_req_callback(struct ceph_osd_request *osd_req,
 				struct ceph_msg *msg)
 {
<span class="p_chunk">@@ -1845,6 +1856,8 @@</span> <span class="p_context"> static void rbd_osd_req_callback(struct ceph_osd_request *osd_req,</span>
 		rbd_osd_discard_callback(obj_request);
 		break;
 	case CEPH_OSD_OP_CALL:
<span class="p_add">+		rbd_osd_call_callback(obj_request);</span>
<span class="p_add">+		break;</span>
 	case CEPH_OSD_OP_NOTIFY_ACK:
 	case CEPH_OSD_OP_WATCH:
 		rbd_osd_trivial_callback(obj_request);
<span class="p_chunk">@@ -2509,13 +2522,15 @@</span> <span class="p_context"> out_unwind:</span>
 }
 
 static void
<span class="p_del">-rbd_img_obj_copyup_callback(struct rbd_obj_request *obj_request)</span>
<span class="p_add">+rbd_osd_copyup_callback(struct rbd_obj_request *obj_request)</span>
 {
 	struct rbd_img_request *img_request;
 	struct rbd_device *rbd_dev;
 	struct page **pages;
 	u32 page_count;
 
<span class="p_add">+	dout(&quot;%s: obj %p\n&quot;, __func__, obj_request);</span>
<span class="p_add">+</span>
 	rbd_assert(obj_request-&gt;type == OBJ_REQUEST_BIO ||
 		obj_request-&gt;type == OBJ_REQUEST_NODATA);
 	rbd_assert(obj_request_img_data_test(obj_request));
<span class="p_chunk">@@ -2542,9 +2557,7 @@</span> <span class="p_context"> rbd_img_obj_copyup_callback(struct rbd_obj_request *obj_request)</span>
 	if (!obj_request-&gt;result)
 		obj_request-&gt;xferred = obj_request-&gt;length;
 
<span class="p_del">-	/* Finish up with the normal image object callback */</span>
<span class="p_del">-</span>
<span class="p_del">-	rbd_img_obj_callback(obj_request);</span>
<span class="p_add">+	obj_request_done_set(obj_request);</span>
 }
 
 static void
<span class="p_chunk">@@ -2629,7 +2642,6 @@</span> <span class="p_context"> rbd_img_obj_parent_read_full_callback(struct rbd_img_request *img_request)</span>
 
 	/* All set, send it off. */
 
<span class="p_del">-	orig_request-&gt;callback = rbd_img_obj_copyup_callback;</span>
 	osdc = &amp;rbd_dev-&gt;rbd_client-&gt;client-&gt;osdc;
 	img_result = rbd_obj_request_submit(osdc, orig_request);
 	if (!img_result)
<span class="p_header">diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c</span>
<span class="p_header">index da8faf78536a..5643b65cee20 100644</span>
<span class="p_header">--- a/drivers/char/hw_random/core.c</span>
<span class="p_header">+++ b/drivers/char/hw_random/core.c</span>
<span class="p_chunk">@@ -429,7 +429,7 @@</span> <span class="p_context"> static int hwrng_fillfn(void *unused)</span>
 static void start_khwrngd(void)
 {
 	hwrng_fill = kthread_run(hwrng_fillfn, NULL, &quot;hwrng&quot;);
<span class="p_del">-	if (hwrng_fill == ERR_PTR(-ENOMEM)) {</span>
<span class="p_add">+	if (IS_ERR(hwrng_fill)) {</span>
 		pr_err(&quot;hwrng_fill thread creation failed&quot;);
 		hwrng_fill = NULL;
 	}
<span class="p_header">diff --git a/drivers/char/i8k.c b/drivers/char/i8k.c</span>
<span class="p_header">index a43048b5b05f..3c1a123f909c 100644</span>
<span class="p_header">--- a/drivers/char/i8k.c</span>
<span class="p_header">+++ b/drivers/char/i8k.c</span>
<span class="p_chunk">@@ -900,6 +900,21 @@</span> <span class="p_context"> static struct dmi_system_id i8k_dmi_table[] __initdata = {</span>
 
 MODULE_DEVICE_TABLE(dmi, i8k_dmi_table);
 
<span class="p_add">+static struct dmi_system_id i8k_blacklist_dmi_table[] __initdata = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * CPU fan speed going up and down on Dell Studio XPS 8100</span>
<span class="p_add">+		 * for unknown reasons.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		.ident = &quot;Dell Studio XPS 8100&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, &quot;Studio XPS 8100&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Probe for the presence of a supported laptop.
  */
<span class="p_chunk">@@ -911,7 +926,8 @@</span> <span class="p_context"> static int __init i8k_probe(void)</span>
 	/*
 	 * Get DMI information
 	 */
<span class="p_del">-	if (!dmi_check_system(i8k_dmi_table)) {</span>
<span class="p_add">+	if (!dmi_check_system(i8k_dmi_table) ||</span>
<span class="p_add">+	    dmi_check_system(i8k_blacklist_dmi_table)) {</span>
 		if (!ignore_dmi &amp;&amp; !force)
 			return -ENODEV;
 
<span class="p_header">diff --git a/drivers/clk/keystone/pll.c b/drivers/clk/keystone/pll.c</span>
<span class="p_header">index 0dd8a4b12747..4a375ead70e9 100644</span>
<span class="p_header">--- a/drivers/clk/keystone/pll.c</span>
<span class="p_header">+++ b/drivers/clk/keystone/pll.c</span>
<span class="p_chunk">@@ -37,7 +37,8 @@</span> <span class="p_context"></span>
  *	Main PLL or any other PLLs in the device such as ARM PLL, DDR PLL
  *	or PA PLL available on keystone2. These PLLs are controlled by
  *	this register. Main PLL is controlled by a PLL controller.
<span class="p_del">- * @pllm: PLL register map address</span>
<span class="p_add">+ * @pllm: PLL register map address for multiplier bits</span>
<span class="p_add">+ * @pllod: PLL register map address for post divider bits</span>
  * @pll_ctl0: PLL controller map address
  * @pllm_lower_mask: multiplier lower mask
  * @pllm_upper_mask: multiplier upper mask
<span class="p_chunk">@@ -53,6 +54,7 @@</span> <span class="p_context"> struct clk_pll_data {</span>
 	u32 phy_pllm;
 	u32 phy_pll_ctl0;
 	void __iomem *pllm;
<span class="p_add">+	void __iomem *pllod;</span>
 	void __iomem *pll_ctl0;
 	u32 pllm_lower_mask;
 	u32 pllm_upper_mask;
<span class="p_chunk">@@ -102,7 +104,11 @@</span> <span class="p_context"> static unsigned long clk_pllclk_recalc(struct clk_hw *hw,</span>
 		/* read post divider from od bits*/
 		postdiv = ((val &amp; pll_data-&gt;clkod_mask) &gt;&gt;
 				 pll_data-&gt;clkod_shift) + 1;
<span class="p_del">-	else</span>
<span class="p_add">+	else if (pll_data-&gt;pllod) {</span>
<span class="p_add">+		postdiv = readl(pll_data-&gt;pllod);</span>
<span class="p_add">+		postdiv = ((postdiv &amp; pll_data-&gt;clkod_mask) &gt;&gt;</span>
<span class="p_add">+				pll_data-&gt;clkod_shift) + 1;</span>
<span class="p_add">+	} else</span>
 		postdiv = pll_data-&gt;postdiv;
 
 	rate /= (prediv + 1);
<span class="p_chunk">@@ -172,12 +178,21 @@</span> <span class="p_context"> static void __init _of_pll_clk_init(struct device_node *node, bool pllctrl)</span>
 		/* assume the PLL has output divider register bits */
 		pll_data-&gt;clkod_mask = CLKOD_MASK;
 		pll_data-&gt;clkod_shift = CLKOD_SHIFT;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Check if there is an post-divider register. If not</span>
<span class="p_add">+		 * assume od bits are part of control register.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		i = of_property_match_string(node, &quot;reg-names&quot;,</span>
<span class="p_add">+					     &quot;post-divider&quot;);</span>
<span class="p_add">+		pll_data-&gt;pllod = of_iomap(node, i);</span>
 	}
 
 	i = of_property_match_string(node, &quot;reg-names&quot;, &quot;control&quot;);
 	pll_data-&gt;pll_ctl0 = of_iomap(node, i);
 	if (!pll_data-&gt;pll_ctl0) {
 		pr_err(&quot;%s: ioremap failed\n&quot;, __func__);
<span class="p_add">+		iounmap(pll_data-&gt;pllod);</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -193,6 +208,7 @@</span> <span class="p_context"> static void __init _of_pll_clk_init(struct device_node *node, bool pllctrl)</span>
 		pll_data-&gt;pllm = of_iomap(node, i);
 		if (!pll_data-&gt;pllm) {
 			iounmap(pll_data-&gt;pll_ctl0);
<span class="p_add">+			iounmap(pll_data-&gt;pllod);</span>
 			goto out;
 		}
 	}
<span class="p_header">diff --git a/drivers/crypto/ixp4xx_crypto.c b/drivers/crypto/ixp4xx_crypto.c</span>
<span class="p_header">index 48f453555f1f..ede9e9e3c419 100644</span>
<span class="p_header">--- a/drivers/crypto/ixp4xx_crypto.c</span>
<span class="p_header">+++ b/drivers/crypto/ixp4xx_crypto.c</span>
<span class="p_chunk">@@ -904,7 +904,6 @@</span> <span class="p_context"> static int ablk_perform(struct ablkcipher_request *req, int encrypt)</span>
 		crypt-&gt;mode |= NPE_OP_NOT_IN_PLACE;
 		/* This was never tested by Intel
 		 * for more than one dst buffer, I think. */
<span class="p_del">-		BUG_ON(req-&gt;dst-&gt;length &lt; nbytes);</span>
 		req_ctx-&gt;dst = NULL;
 		if (!chainup_buffers(dev, req-&gt;dst, nbytes, &amp;dst_hook,
 					flags, DMA_FROM_DEVICE))
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-ccm.c b/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_header">index 67f80813a06f..e4311ce0cd78 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_chunk">@@ -494,8 +494,9 @@</span> <span class="p_context"> out:</span>
 static int ccm4309_aes_nx_encrypt(struct aead_request *req)
 {
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req-&gt;base.tfm);
<span class="p_add">+	struct nx_gcm_rctx *rctx = aead_request_ctx(req);</span>
 	struct blkcipher_desc desc;
<span class="p_del">-	u8 *iv = nx_ctx-&gt;priv.ccm.iv;</span>
<span class="p_add">+	u8 *iv = rctx-&gt;iv;</span>
 
 	iv[0] = 3;
 	memcpy(iv + 1, nx_ctx-&gt;priv.ccm.nonce, 3);
<span class="p_chunk">@@ -525,8 +526,9 @@</span> <span class="p_context"> static int ccm_aes_nx_encrypt(struct aead_request *req)</span>
 static int ccm4309_aes_nx_decrypt(struct aead_request *req)
 {
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req-&gt;base.tfm);
<span class="p_add">+	struct nx_gcm_rctx *rctx = aead_request_ctx(req);</span>
 	struct blkcipher_desc desc;
<span class="p_del">-	u8 *iv = nx_ctx-&gt;priv.ccm.iv;</span>
<span class="p_add">+	u8 *iv = rctx-&gt;iv;</span>
 
 	iv[0] = 3;
 	memcpy(iv + 1, nx_ctx-&gt;priv.ccm.nonce, 3);
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-ctr.c b/drivers/crypto/nx/nx-aes-ctr.c</span>
<span class="p_header">index 2617cd4d54dd..dd7e9f3f5b6b 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-ctr.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-ctr.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> static int ctr3686_aes_nx_set_key(struct crypto_tfm *tfm,</span>
 	if (key_len &lt; CTR_RFC3686_NONCE_SIZE)
 		return -EINVAL;
 
<span class="p_del">-	memcpy(nx_ctx-&gt;priv.ctr.iv,</span>
<span class="p_add">+	memcpy(nx_ctx-&gt;priv.ctr.nonce,</span>
 	       in_key + key_len - CTR_RFC3686_NONCE_SIZE,
 	       CTR_RFC3686_NONCE_SIZE);
 
<span class="p_chunk">@@ -131,14 +131,15 @@</span> <span class="p_context"> static int ctr3686_aes_nx_crypt(struct blkcipher_desc *desc,</span>
 				unsigned int           nbytes)
 {
 	struct nx_crypto_ctx *nx_ctx = crypto_blkcipher_ctx(desc-&gt;tfm);
<span class="p_del">-	u8 *iv = nx_ctx-&gt;priv.ctr.iv;</span>
<span class="p_add">+	u8 iv[16];</span>
 
<span class="p_add">+	memcpy(iv, nx_ctx-&gt;priv.ctr.nonce, CTR_RFC3686_IV_SIZE);</span>
 	memcpy(iv + CTR_RFC3686_NONCE_SIZE,
 	       desc-&gt;info, CTR_RFC3686_IV_SIZE);
 	iv[12] = iv[13] = iv[14] = 0;
 	iv[15] = 1;
 
<span class="p_del">-	desc-&gt;info = nx_ctx-&gt;priv.ctr.iv;</span>
<span class="p_add">+	desc-&gt;info = iv;</span>
 
 	return ctr_aes_nx_crypt(desc, dst, src, nbytes);
 }
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-gcm.c b/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_header">index 88c562434bc0..c6ebeb644db4 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_chunk">@@ -330,6 +330,7 @@</span> <span class="p_context"> out:</span>
 static int gcm_aes_nx_crypt(struct aead_request *req, int enc)
 {
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req-&gt;base.tfm);
<span class="p_add">+	struct nx_gcm_rctx *rctx = aead_request_ctx(req);</span>
 	struct nx_csbcpb *csbcpb = nx_ctx-&gt;csbcpb;
 	struct blkcipher_desc desc;
 	unsigned int nbytes = req-&gt;cryptlen;
<span class="p_chunk">@@ -339,7 +340,7 @@</span> <span class="p_context"> static int gcm_aes_nx_crypt(struct aead_request *req, int enc)</span>
 
 	spin_lock_irqsave(&amp;nx_ctx-&gt;lock, irq_flags);
 
<span class="p_del">-	desc.info = nx_ctx-&gt;priv.gcm.iv;</span>
<span class="p_add">+	desc.info = rctx-&gt;iv;</span>
 	/* initialize the counter */
 	*(u32 *)(desc.info + NX_GCM_CTR_OFFSET) = 1;
 
<span class="p_chunk">@@ -434,8 +435,8 @@</span> <span class="p_context"> out:</span>
 
 static int gcm_aes_nx_encrypt(struct aead_request *req)
 {
<span class="p_del">-	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req-&gt;base.tfm);</span>
<span class="p_del">-	char *iv = nx_ctx-&gt;priv.gcm.iv;</span>
<span class="p_add">+	struct nx_gcm_rctx *rctx = aead_request_ctx(req);</span>
<span class="p_add">+	char *iv = rctx-&gt;iv;</span>
 
 	memcpy(iv, req-&gt;iv, 12);
 
<span class="p_chunk">@@ -444,8 +445,8 @@</span> <span class="p_context"> static int gcm_aes_nx_encrypt(struct aead_request *req)</span>
 
 static int gcm_aes_nx_decrypt(struct aead_request *req)
 {
<span class="p_del">-	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req-&gt;base.tfm);</span>
<span class="p_del">-	char *iv = nx_ctx-&gt;priv.gcm.iv;</span>
<span class="p_add">+	struct nx_gcm_rctx *rctx = aead_request_ctx(req);</span>
<span class="p_add">+	char *iv = rctx-&gt;iv;</span>
 
 	memcpy(iv, req-&gt;iv, 12);
 
<span class="p_chunk">@@ -455,7 +456,8 @@</span> <span class="p_context"> static int gcm_aes_nx_decrypt(struct aead_request *req)</span>
 static int gcm4106_aes_nx_encrypt(struct aead_request *req)
 {
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req-&gt;base.tfm);
<span class="p_del">-	char *iv = nx_ctx-&gt;priv.gcm.iv;</span>
<span class="p_add">+	struct nx_gcm_rctx *rctx = aead_request_ctx(req);</span>
<span class="p_add">+	char *iv = rctx-&gt;iv;</span>
 	char *nonce = nx_ctx-&gt;priv.gcm.nonce;
 
 	memcpy(iv, nonce, NX_GCM4106_NONCE_LEN);
<span class="p_chunk">@@ -467,7 +469,8 @@</span> <span class="p_context"> static int gcm4106_aes_nx_encrypt(struct aead_request *req)</span>
 static int gcm4106_aes_nx_decrypt(struct aead_request *req)
 {
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req-&gt;base.tfm);
<span class="p_del">-	char *iv = nx_ctx-&gt;priv.gcm.iv;</span>
<span class="p_add">+	struct nx_gcm_rctx *rctx = aead_request_ctx(req);</span>
<span class="p_add">+	char *iv = rctx-&gt;iv;</span>
 	char *nonce = nx_ctx-&gt;priv.gcm.nonce;
 
 	memcpy(iv, nonce, NX_GCM4106_NONCE_LEN);
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-xcbc.c b/drivers/crypto/nx/nx-aes-xcbc.c</span>
<span class="p_header">index 8c2faffab4a3..c2f7d4befb55 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-xcbc.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-xcbc.c</span>
<span class="p_chunk">@@ -42,6 +42,7 @@</span> <span class="p_context"> static int nx_xcbc_set_key(struct crypto_shash *desc,</span>
 			   unsigned int         key_len)
 {
 	struct nx_crypto_ctx *nx_ctx = crypto_shash_ctx(desc);
<span class="p_add">+	struct nx_csbcpb *csbcpb = nx_ctx-&gt;csbcpb;</span>
 
 	switch (key_len) {
 	case AES_KEYSIZE_128:
<span class="p_chunk">@@ -51,7 +52,7 @@</span> <span class="p_context"> static int nx_xcbc_set_key(struct crypto_shash *desc,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	memcpy(nx_ctx-&gt;priv.xcbc.key, in_key, key_len);</span>
<span class="p_add">+	memcpy(csbcpb-&gt;cpb.aes_xcbc.key, in_key, key_len);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -148,32 +149,29 @@</span> <span class="p_context"> out:</span>
 	return rc;
 }
 
<span class="p_del">-static int nx_xcbc_init(struct shash_desc *desc)</span>
<span class="p_add">+static int nx_crypto_ctx_aes_xcbc_init2(struct crypto_tfm *tfm)</span>
 {
<span class="p_del">-	struct xcbc_state *sctx = shash_desc_ctx(desc);</span>
<span class="p_del">-	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&amp;desc-&gt;tfm-&gt;base);</span>
<span class="p_add">+	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(tfm);</span>
 	struct nx_csbcpb *csbcpb = nx_ctx-&gt;csbcpb;
<span class="p_del">-	struct nx_sg *out_sg;</span>
<span class="p_del">-	int len;</span>
<span class="p_add">+	int err;</span>
 
<span class="p_del">-	nx_ctx_init(nx_ctx, HCOP_FC_AES);</span>
<span class="p_add">+	err = nx_crypto_ctx_aes_xcbc_init(tfm);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
<span class="p_del">-	memset(sctx, 0, sizeof *sctx);</span>
<span class="p_add">+	nx_ctx_init(nx_ctx, HCOP_FC_AES);</span>
 
 	NX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_128);
 	csbcpb-&gt;cpb.hdr.mode = NX_MODE_AES_XCBC_MAC;
 
<span class="p_del">-	memcpy(csbcpb-&gt;cpb.aes_xcbc.key, nx_ctx-&gt;priv.xcbc.key, AES_BLOCK_SIZE);</span>
<span class="p_del">-	memset(nx_ctx-&gt;priv.xcbc.key, 0, sizeof *nx_ctx-&gt;priv.xcbc.key);</span>
<span class="p_del">-</span>
<span class="p_del">-	len = AES_BLOCK_SIZE;</span>
<span class="p_del">-	out_sg = nx_build_sg_list(nx_ctx-&gt;out_sg, (u8 *)sctx-&gt;state,</span>
<span class="p_del">-				  &amp;len, nx_ctx-&gt;ap-&gt;sglen);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	if (len != AES_BLOCK_SIZE)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+static int nx_xcbc_init(struct shash_desc *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xcbc_state *sctx = shash_desc_ctx(desc);</span>
 
<span class="p_del">-	nx_ctx-&gt;op.outlen = (nx_ctx-&gt;out_sg - out_sg) * sizeof(struct nx_sg);</span>
<span class="p_add">+	memset(sctx, 0, sizeof *sctx);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -186,6 +184,7 @@</span> <span class="p_context"> static int nx_xcbc_update(struct shash_desc *desc,</span>
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&amp;desc-&gt;tfm-&gt;base);
 	struct nx_csbcpb *csbcpb = nx_ctx-&gt;csbcpb;
 	struct nx_sg *in_sg;
<span class="p_add">+	struct nx_sg *out_sg;</span>
 	u32 to_process = 0, leftover, total;
 	unsigned int max_sg_len;
 	unsigned long irq_flags;
<span class="p_chunk">@@ -213,6 +212,17 @@</span> <span class="p_context"> static int nx_xcbc_update(struct shash_desc *desc,</span>
 	max_sg_len = min_t(u64, max_sg_len,
 				nx_ctx-&gt;ap-&gt;databytelen/NX_PAGE_SIZE);
 
<span class="p_add">+	data_len = AES_BLOCK_SIZE;</span>
<span class="p_add">+	out_sg = nx_build_sg_list(nx_ctx-&gt;out_sg, (u8 *)sctx-&gt;state,</span>
<span class="p_add">+				  &amp;len, nx_ctx-&gt;ap-&gt;sglen);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data_len != AES_BLOCK_SIZE) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	nx_ctx-&gt;op.outlen = (nx_ctx-&gt;out_sg - out_sg) * sizeof(struct nx_sg);</span>
<span class="p_add">+</span>
 	do {
 		to_process = total - to_process;
 		to_process = to_process &amp; ~(AES_BLOCK_SIZE - 1);
<span class="p_chunk">@@ -235,8 +245,10 @@</span> <span class="p_context"> static int nx_xcbc_update(struct shash_desc *desc,</span>
 						(u8 *) sctx-&gt;buffer,
 						&amp;data_len,
 						max_sg_len);
<span class="p_del">-			if (data_len != sctx-&gt;count)</span>
<span class="p_del">-				return -EINVAL;</span>
<span class="p_add">+			if (data_len != sctx-&gt;count) {</span>
<span class="p_add">+				rc = -EINVAL;</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
 		}
 
 		data_len = to_process - sctx-&gt;count;
<span class="p_chunk">@@ -245,8 +257,10 @@</span> <span class="p_context"> static int nx_xcbc_update(struct shash_desc *desc,</span>
 					&amp;data_len,
 					max_sg_len);
 
<span class="p_del">-		if (data_len != to_process - sctx-&gt;count)</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+		if (data_len != to_process - sctx-&gt;count) {</span>
<span class="p_add">+			rc = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 
 		nx_ctx-&gt;op.inlen = (nx_ctx-&gt;in_sg - in_sg) *
 					sizeof(struct nx_sg);
<span class="p_chunk">@@ -325,15 +339,19 @@</span> <span class="p_context"> static int nx_xcbc_final(struct shash_desc *desc, u8 *out)</span>
 	in_sg = nx_build_sg_list(nx_ctx-&gt;in_sg, (u8 *)sctx-&gt;buffer,
 				 &amp;len, nx_ctx-&gt;ap-&gt;sglen);
 
<span class="p_del">-	if (len != sctx-&gt;count)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (len != sctx-&gt;count) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	len = AES_BLOCK_SIZE;
 	out_sg = nx_build_sg_list(nx_ctx-&gt;out_sg, out, &amp;len,
 				  nx_ctx-&gt;ap-&gt;sglen);
 
<span class="p_del">-	if (len != AES_BLOCK_SIZE)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (len != AES_BLOCK_SIZE) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	nx_ctx-&gt;op.inlen = (nx_ctx-&gt;in_sg - in_sg) * sizeof(struct nx_sg);
 	nx_ctx-&gt;op.outlen = (nx_ctx-&gt;out_sg - out_sg) * sizeof(struct nx_sg);
<span class="p_chunk">@@ -372,7 +390,7 @@</span> <span class="p_context"> struct shash_alg nx_shash_aes_xcbc_alg = {</span>
 		.cra_blocksize   = AES_BLOCK_SIZE,
 		.cra_module      = THIS_MODULE,
 		.cra_ctxsize     = sizeof(struct nx_crypto_ctx),
<span class="p_del">-		.cra_init        = nx_crypto_ctx_aes_xcbc_init,</span>
<span class="p_add">+		.cra_init        = nx_crypto_ctx_aes_xcbc_init2,</span>
 		.cra_exit        = nx_crypto_ctx_exit,
 	}
 };
<span class="p_header">diff --git a/drivers/crypto/nx/nx-sha256.c b/drivers/crypto/nx/nx-sha256.c</span>
<span class="p_header">index 23621da624c3..08f8d5cd6334 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-sha256.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-sha256.c</span>
<span class="p_chunk">@@ -29,30 +29,28 @@</span> <span class="p_context"></span>
 #include &quot;nx.h&quot;
 
 
<span class="p_del">-static int nx_sha256_init(struct shash_desc *desc)</span>
<span class="p_add">+static int nx_crypto_ctx_sha256_init(struct crypto_tfm *tfm)</span>
 {
<span class="p_del">-	struct sha256_state *sctx = shash_desc_ctx(desc);</span>
<span class="p_del">-	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&amp;desc-&gt;tfm-&gt;base);</span>
<span class="p_del">-	int len;</span>
<span class="p_del">-	int rc;</span>
<span class="p_add">+	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(tfm);</span>
<span class="p_add">+	int err;</span>
 
<span class="p_del">-	nx_ctx_init(nx_ctx, HCOP_FC_SHA);</span>
<span class="p_add">+	err = nx_crypto_ctx_sha_init(tfm);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
<span class="p_del">-	memset(sctx, 0, sizeof *sctx);</span>
<span class="p_add">+	nx_ctx_init(nx_ctx, HCOP_FC_SHA);</span>
 
 	nx_ctx-&gt;ap = &amp;nx_ctx-&gt;props[NX_PROPS_SHA256];
 
 	NX_CPB_SET_DIGEST_SIZE(nx_ctx-&gt;csbcpb, NX_DS_SHA256);
 
<span class="p_del">-	len = SHA256_DIGEST_SIZE;</span>
<span class="p_del">-	rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;out_sg,</span>
<span class="p_del">-				  &amp;nx_ctx-&gt;op.outlen,</span>
<span class="p_del">-				  &amp;len,</span>
<span class="p_del">-				  (u8 *) sctx-&gt;state,</span>
<span class="p_del">-				  NX_DS_SHA256);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+static int nx_sha256_init(struct shash_desc *desc) {</span>
<span class="p_add">+	struct sha256_state *sctx = shash_desc_ctx(desc);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(sctx, 0, sizeof *sctx);</span>
 
 	sctx-&gt;state[0] = __cpu_to_be32(SHA256_H0);
 	sctx-&gt;state[1] = __cpu_to_be32(SHA256_H1);
<span class="p_chunk">@@ -64,7 +62,6 @@</span> <span class="p_context"> static int nx_sha256_init(struct shash_desc *desc)</span>
 	sctx-&gt;state[7] = __cpu_to_be32(SHA256_H7);
 	sctx-&gt;count = 0;
 
<span class="p_del">-out:</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -74,10 +71,13 @@</span> <span class="p_context"> static int nx_sha256_update(struct shash_desc *desc, const u8 *data,</span>
 	struct sha256_state *sctx = shash_desc_ctx(desc);
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&amp;desc-&gt;tfm-&gt;base);
 	struct nx_csbcpb *csbcpb = (struct nx_csbcpb *)nx_ctx-&gt;csbcpb;
<span class="p_add">+	struct nx_sg *in_sg;</span>
<span class="p_add">+	struct nx_sg *out_sg;</span>
 	u64 to_process = 0, leftover, total;
 	unsigned long irq_flags;
 	int rc = 0;
 	int data_len;
<span class="p_add">+	u32 max_sg_len;</span>
 	u64 buf_len = (sctx-&gt;count % SHA256_BLOCK_SIZE);
 
 	spin_lock_irqsave(&amp;nx_ctx-&gt;lock, irq_flags);
<span class="p_chunk">@@ -97,6 +97,22 @@</span> <span class="p_context"> static int nx_sha256_update(struct shash_desc *desc, const u8 *data,</span>
 	NX_CPB_FDM(csbcpb) |= NX_FDM_INTERMEDIATE;
 	NX_CPB_FDM(csbcpb) |= NX_FDM_CONTINUATION;
 
<span class="p_add">+	in_sg = nx_ctx-&gt;in_sg;</span>
<span class="p_add">+	max_sg_len = min_t(u64, nx_ctx-&gt;ap-&gt;sglen,</span>
<span class="p_add">+			nx_driver.of.max_sg_len/sizeof(struct nx_sg));</span>
<span class="p_add">+	max_sg_len = min_t(u64, max_sg_len,</span>
<span class="p_add">+			nx_ctx-&gt;ap-&gt;databytelen/NX_PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	data_len = SHA256_DIGEST_SIZE;</span>
<span class="p_add">+	out_sg = nx_build_sg_list(nx_ctx-&gt;out_sg, (u8 *)sctx-&gt;state,</span>
<span class="p_add">+				  &amp;data_len, max_sg_len);</span>
<span class="p_add">+	nx_ctx-&gt;op.outlen = (nx_ctx-&gt;out_sg - out_sg) * sizeof(struct nx_sg);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data_len != SHA256_DIGEST_SIZE) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	do {
 		/*
 		 * to_process: the SHA256_BLOCK_SIZE data chunk to process in
<span class="p_chunk">@@ -108,25 +124,22 @@</span> <span class="p_context"> static int nx_sha256_update(struct shash_desc *desc, const u8 *data,</span>
 
 		if (buf_len) {
 			data_len = buf_len;
<span class="p_del">-			rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;in_sg,</span>
<span class="p_del">-						  &amp;nx_ctx-&gt;op.inlen,</span>
<span class="p_del">-						  &amp;data_len,</span>
<span class="p_del">-						  (u8 *) sctx-&gt;buf,</span>
<span class="p_del">-						  NX_DS_SHA256);</span>
<span class="p_add">+			in_sg = nx_build_sg_list(nx_ctx-&gt;in_sg,</span>
<span class="p_add">+						 (u8 *) sctx-&gt;buf,</span>
<span class="p_add">+						 &amp;data_len,</span>
<span class="p_add">+						 max_sg_len);</span>
 
<span class="p_del">-			if (rc || data_len != buf_len)</span>
<span class="p_add">+			if (data_len != buf_len) {</span>
<span class="p_add">+				rc = -EINVAL;</span>
 				goto out;
<span class="p_add">+			}</span>
 		}
 
 		data_len = to_process - buf_len;
<span class="p_del">-		rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;in_sg,</span>
<span class="p_del">-					  &amp;nx_ctx-&gt;op.inlen,</span>
<span class="p_del">-					  &amp;data_len,</span>
<span class="p_del">-					  (u8 *) data,</span>
<span class="p_del">-					  NX_DS_SHA256);</span>
<span class="p_add">+		in_sg = nx_build_sg_list(in_sg, (u8 *) data,</span>
<span class="p_add">+					 &amp;data_len, max_sg_len);</span>
 
<span class="p_del">-		if (rc)</span>
<span class="p_del">-			goto out;</span>
<span class="p_add">+		nx_ctx-&gt;op.inlen = (nx_ctx-&gt;in_sg - in_sg) * sizeof(struct nx_sg);</span>
 
 		to_process = (data_len + buf_len);
 		leftover = total - to_process;
<span class="p_chunk">@@ -173,12 +186,19 @@</span> <span class="p_context"> static int nx_sha256_final(struct shash_desc *desc, u8 *out)</span>
 	struct sha256_state *sctx = shash_desc_ctx(desc);
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&amp;desc-&gt;tfm-&gt;base);
 	struct nx_csbcpb *csbcpb = (struct nx_csbcpb *)nx_ctx-&gt;csbcpb;
<span class="p_add">+	struct nx_sg *in_sg, *out_sg;</span>
 	unsigned long irq_flags;
<span class="p_del">-	int rc;</span>
<span class="p_add">+	u32 max_sg_len;</span>
<span class="p_add">+	int rc = 0;</span>
 	int len;
 
 	spin_lock_irqsave(&amp;nx_ctx-&gt;lock, irq_flags);
 
<span class="p_add">+	max_sg_len = min_t(u64, nx_ctx-&gt;ap-&gt;sglen,</span>
<span class="p_add">+			nx_driver.of.max_sg_len/sizeof(struct nx_sg));</span>
<span class="p_add">+	max_sg_len = min_t(u64, max_sg_len,</span>
<span class="p_add">+			nx_ctx-&gt;ap-&gt;databytelen/NX_PAGE_SIZE);</span>
<span class="p_add">+</span>
 	/* final is represented by continuing the operation and indicating that
 	 * this is not an intermediate operation */
 	if (sctx-&gt;count &gt;= SHA256_BLOCK_SIZE) {
<span class="p_chunk">@@ -195,25 +215,24 @@</span> <span class="p_context"> static int nx_sha256_final(struct shash_desc *desc, u8 *out)</span>
 	csbcpb-&gt;cpb.sha256.message_bit_length = (u64) (sctx-&gt;count * 8);
 
 	len = sctx-&gt;count &amp; (SHA256_BLOCK_SIZE - 1);
<span class="p_del">-	rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;in_sg,</span>
<span class="p_del">-				  &amp;nx_ctx-&gt;op.inlen,</span>
<span class="p_del">-				  &amp;len,</span>
<span class="p_del">-				  (u8 *) sctx-&gt;buf,</span>
<span class="p_del">-				  NX_DS_SHA256);</span>
<span class="p_add">+	in_sg = nx_build_sg_list(nx_ctx-&gt;in_sg, (u8 *) sctx-&gt;buf,</span>
<span class="p_add">+				 &amp;len, max_sg_len);</span>
 
<span class="p_del">-	if (rc || len != (sctx-&gt;count &amp; (SHA256_BLOCK_SIZE - 1)))</span>
<span class="p_add">+	if (len != (sctx-&gt;count &amp; (SHA256_BLOCK_SIZE - 1))) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	len = SHA256_DIGEST_SIZE;
<span class="p_del">-	rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;out_sg,</span>
<span class="p_del">-				  &amp;nx_ctx-&gt;op.outlen,</span>
<span class="p_del">-				  &amp;len,</span>
<span class="p_del">-				  out,</span>
<span class="p_del">-				  NX_DS_SHA256);</span>
<span class="p_add">+	out_sg = nx_build_sg_list(nx_ctx-&gt;out_sg, out, &amp;len, max_sg_len);</span>
 
<span class="p_del">-	if (rc || len != SHA256_DIGEST_SIZE)</span>
<span class="p_add">+	if (len != SHA256_DIGEST_SIZE) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
 		goto out;
<span class="p_add">+	}</span>
 
<span class="p_add">+	nx_ctx-&gt;op.inlen = (nx_ctx-&gt;in_sg - in_sg) * sizeof(struct nx_sg);</span>
<span class="p_add">+	nx_ctx-&gt;op.outlen = (nx_ctx-&gt;out_sg - out_sg) * sizeof(struct nx_sg);</span>
 	if (!nx_ctx-&gt;op.outlen) {
 		rc = -EINVAL;
 		goto out;
<span class="p_chunk">@@ -268,7 +287,7 @@</span> <span class="p_context"> struct shash_alg nx_shash_sha256_alg = {</span>
 		.cra_blocksize   = SHA256_BLOCK_SIZE,
 		.cra_module      = THIS_MODULE,
 		.cra_ctxsize     = sizeof(struct nx_crypto_ctx),
<span class="p_del">-		.cra_init        = nx_crypto_ctx_sha_init,</span>
<span class="p_add">+		.cra_init        = nx_crypto_ctx_sha256_init,</span>
 		.cra_exit        = nx_crypto_ctx_exit,
 	}
 };
<span class="p_header">diff --git a/drivers/crypto/nx/nx-sha512.c b/drivers/crypto/nx/nx-sha512.c</span>
<span class="p_header">index b3adf1022673..aff0fe58eac0 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-sha512.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-sha512.c</span>
<span class="p_chunk">@@ -28,30 +28,29 @@</span> <span class="p_context"></span>
 #include &quot;nx.h&quot;
 
 
<span class="p_del">-static int nx_sha512_init(struct shash_desc *desc)</span>
<span class="p_add">+static int nx_crypto_ctx_sha512_init(struct crypto_tfm *tfm)</span>
 {
<span class="p_del">-	struct sha512_state *sctx = shash_desc_ctx(desc);</span>
<span class="p_del">-	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&amp;desc-&gt;tfm-&gt;base);</span>
<span class="p_del">-	int len;</span>
<span class="p_del">-	int rc;</span>
<span class="p_add">+	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(tfm);</span>
<span class="p_add">+	int err;</span>
 
<span class="p_del">-	nx_ctx_init(nx_ctx, HCOP_FC_SHA);</span>
<span class="p_add">+	err = nx_crypto_ctx_sha_init(tfm);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
<span class="p_del">-	memset(sctx, 0, sizeof *sctx);</span>
<span class="p_add">+	nx_ctx_init(nx_ctx, HCOP_FC_SHA);</span>
 
 	nx_ctx-&gt;ap = &amp;nx_ctx-&gt;props[NX_PROPS_SHA512];
 
 	NX_CPB_SET_DIGEST_SIZE(nx_ctx-&gt;csbcpb, NX_DS_SHA512);
 
<span class="p_del">-	len = SHA512_DIGEST_SIZE;</span>
<span class="p_del">-	rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;out_sg,</span>
<span class="p_del">-				  &amp;nx_ctx-&gt;op.outlen,</span>
<span class="p_del">-				  &amp;len,</span>
<span class="p_del">-				  (u8 *)sctx-&gt;state,</span>
<span class="p_del">-				  NX_DS_SHA512);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	if (rc || len != SHA512_DIGEST_SIZE)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+static int nx_sha512_init(struct shash_desc *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sha512_state *sctx = shash_desc_ctx(desc);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(sctx, 0, sizeof *sctx);</span>
 
 	sctx-&gt;state[0] = __cpu_to_be64(SHA512_H0);
 	sctx-&gt;state[1] = __cpu_to_be64(SHA512_H1);
<span class="p_chunk">@@ -63,7 +62,6 @@</span> <span class="p_context"> static int nx_sha512_init(struct shash_desc *desc)</span>
 	sctx-&gt;state[7] = __cpu_to_be64(SHA512_H7);
 	sctx-&gt;count[0] = 0;
 
<span class="p_del">-out:</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -73,10 +71,13 @@</span> <span class="p_context"> static int nx_sha512_update(struct shash_desc *desc, const u8 *data,</span>
 	struct sha512_state *sctx = shash_desc_ctx(desc);
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&amp;desc-&gt;tfm-&gt;base);
 	struct nx_csbcpb *csbcpb = (struct nx_csbcpb *)nx_ctx-&gt;csbcpb;
<span class="p_add">+	struct nx_sg *in_sg;</span>
<span class="p_add">+	struct nx_sg *out_sg;</span>
 	u64 to_process, leftover = 0, total;
 	unsigned long irq_flags;
 	int rc = 0;
 	int data_len;
<span class="p_add">+	u32 max_sg_len;</span>
 	u64 buf_len = (sctx-&gt;count[0] % SHA512_BLOCK_SIZE);
 
 	spin_lock_irqsave(&amp;nx_ctx-&gt;lock, irq_flags);
<span class="p_chunk">@@ -96,6 +97,22 @@</span> <span class="p_context"> static int nx_sha512_update(struct shash_desc *desc, const u8 *data,</span>
 	NX_CPB_FDM(csbcpb) |= NX_FDM_INTERMEDIATE;
 	NX_CPB_FDM(csbcpb) |= NX_FDM_CONTINUATION;
 
<span class="p_add">+	in_sg = nx_ctx-&gt;in_sg;</span>
<span class="p_add">+	max_sg_len = min_t(u64, nx_ctx-&gt;ap-&gt;sglen,</span>
<span class="p_add">+			nx_driver.of.max_sg_len/sizeof(struct nx_sg));</span>
<span class="p_add">+	max_sg_len = min_t(u64, max_sg_len,</span>
<span class="p_add">+			nx_ctx-&gt;ap-&gt;databytelen/NX_PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	data_len = SHA512_DIGEST_SIZE;</span>
<span class="p_add">+	out_sg = nx_build_sg_list(nx_ctx-&gt;out_sg, (u8 *)sctx-&gt;state,</span>
<span class="p_add">+				  &amp;data_len, max_sg_len);</span>
<span class="p_add">+	nx_ctx-&gt;op.outlen = (nx_ctx-&gt;out_sg - out_sg) * sizeof(struct nx_sg);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data_len != SHA512_DIGEST_SIZE) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	do {
 		/*
 		 * to_process: the SHA512_BLOCK_SIZE data chunk to process in
<span class="p_chunk">@@ -108,25 +125,26 @@</span> <span class="p_context"> static int nx_sha512_update(struct shash_desc *desc, const u8 *data,</span>
 
 		if (buf_len) {
 			data_len = buf_len;
<span class="p_del">-			rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;in_sg,</span>
<span class="p_del">-						  &amp;nx_ctx-&gt;op.inlen,</span>
<span class="p_del">-						  &amp;data_len,</span>
<span class="p_del">-						  (u8 *) sctx-&gt;buf,</span>
<span class="p_del">-						  NX_DS_SHA512);</span>
<span class="p_add">+			in_sg = nx_build_sg_list(nx_ctx-&gt;in_sg,</span>
<span class="p_add">+						 (u8 *) sctx-&gt;buf,</span>
<span class="p_add">+						 &amp;data_len, max_sg_len);</span>
 
<span class="p_del">-			if (rc || data_len != buf_len)</span>
<span class="p_add">+			if (data_len != buf_len) {</span>
<span class="p_add">+				rc = -EINVAL;</span>
 				goto out;
<span class="p_add">+			}</span>
 		}
 
 		data_len = to_process - buf_len;
<span class="p_del">-		rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;in_sg,</span>
<span class="p_del">-					  &amp;nx_ctx-&gt;op.inlen,</span>
<span class="p_del">-					  &amp;data_len,</span>
<span class="p_del">-					  (u8 *) data,</span>
<span class="p_del">-					  NX_DS_SHA512);</span>
<span class="p_add">+		in_sg = nx_build_sg_list(in_sg, (u8 *) data,</span>
<span class="p_add">+					 &amp;data_len, max_sg_len);</span>
<span class="p_add">+</span>
<span class="p_add">+		nx_ctx-&gt;op.inlen = (nx_ctx-&gt;in_sg - in_sg) * sizeof(struct nx_sg);</span>
 
<span class="p_del">-		if (rc || data_len != (to_process - buf_len))</span>
<span class="p_add">+		if (data_len != (to_process - buf_len)) {</span>
<span class="p_add">+			rc = -EINVAL;</span>
 			goto out;
<span class="p_add">+		}</span>
 
 		to_process = (data_len + buf_len);
 		leftover = total - to_process;
<span class="p_chunk">@@ -172,13 +190,20 @@</span> <span class="p_context"> static int nx_sha512_final(struct shash_desc *desc, u8 *out)</span>
 	struct sha512_state *sctx = shash_desc_ctx(desc);
 	struct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&amp;desc-&gt;tfm-&gt;base);
 	struct nx_csbcpb *csbcpb = (struct nx_csbcpb *)nx_ctx-&gt;csbcpb;
<span class="p_add">+	struct nx_sg *in_sg, *out_sg;</span>
<span class="p_add">+	u32 max_sg_len;</span>
 	u64 count0;
 	unsigned long irq_flags;
<span class="p_del">-	int rc;</span>
<span class="p_add">+	int rc = 0;</span>
 	int len;
 
 	spin_lock_irqsave(&amp;nx_ctx-&gt;lock, irq_flags);
 
<span class="p_add">+	max_sg_len = min_t(u64, nx_ctx-&gt;ap-&gt;sglen,</span>
<span class="p_add">+			nx_driver.of.max_sg_len/sizeof(struct nx_sg));</span>
<span class="p_add">+	max_sg_len = min_t(u64, max_sg_len,</span>
<span class="p_add">+			nx_ctx-&gt;ap-&gt;databytelen/NX_PAGE_SIZE);</span>
<span class="p_add">+</span>
 	/* final is represented by continuing the operation and indicating that
 	 * this is not an intermediate operation */
 	if (sctx-&gt;count[0] &gt;= SHA512_BLOCK_SIZE) {
<span class="p_chunk">@@ -200,24 +225,20 @@</span> <span class="p_context"> static int nx_sha512_final(struct shash_desc *desc, u8 *out)</span>
 	csbcpb-&gt;cpb.sha512.message_bit_length_lo = count0;
 
 	len = sctx-&gt;count[0] &amp; (SHA512_BLOCK_SIZE - 1);
<span class="p_del">-	rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;in_sg,</span>
<span class="p_del">-				  &amp;nx_ctx-&gt;op.inlen,</span>
<span class="p_del">-				  &amp;len,</span>
<span class="p_del">-				  (u8 *)sctx-&gt;buf,</span>
<span class="p_del">-				  NX_DS_SHA512);</span>
<span class="p_add">+	in_sg = nx_build_sg_list(nx_ctx-&gt;in_sg, sctx-&gt;buf, &amp;len,</span>
<span class="p_add">+				 max_sg_len);</span>
 
<span class="p_del">-	if (rc || len != (sctx-&gt;count[0] &amp; (SHA512_BLOCK_SIZE - 1)))</span>
<span class="p_add">+	if (len != (sctx-&gt;count[0] &amp; (SHA512_BLOCK_SIZE - 1))) {</span>
<span class="p_add">+		rc = -EINVAL;</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	len = SHA512_DIGEST_SIZE;
<span class="p_del">-	rc = nx_sha_build_sg_list(nx_ctx, nx_ctx-&gt;out_sg,</span>
<span class="p_del">-				  &amp;nx_ctx-&gt;op.outlen,</span>
<span class="p_del">-				  &amp;len,</span>
<span class="p_del">-				  out,</span>
<span class="p_del">-				  NX_DS_SHA512);</span>
<span class="p_add">+	out_sg = nx_build_sg_list(nx_ctx-&gt;out_sg, out, &amp;len,</span>
<span class="p_add">+				 max_sg_len);</span>
 
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	nx_ctx-&gt;op.inlen = (nx_ctx-&gt;in_sg - in_sg) * sizeof(struct nx_sg);</span>
<span class="p_add">+	nx_ctx-&gt;op.outlen = (nx_ctx-&gt;out_sg - out_sg) * sizeof(struct nx_sg);</span>
 
 	if (!nx_ctx-&gt;op.outlen) {
 		rc = -EINVAL;
<span class="p_chunk">@@ -273,7 +294,7 @@</span> <span class="p_context"> struct shash_alg nx_shash_sha512_alg = {</span>
 		.cra_blocksize   = SHA512_BLOCK_SIZE,
 		.cra_module      = THIS_MODULE,
 		.cra_ctxsize     = sizeof(struct nx_crypto_ctx),
<span class="p_del">-		.cra_init        = nx_crypto_ctx_sha_init,</span>
<span class="p_add">+		.cra_init        = nx_crypto_ctx_sha512_init,</span>
 		.cra_exit        = nx_crypto_ctx_exit,
 	}
 };
<span class="p_header">diff --git a/drivers/crypto/nx/nx.c b/drivers/crypto/nx/nx.c</span>
<span class="p_header">index 1da6dc59d0dd..737d33dc50b8 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx.c</span>
<span class="p_chunk">@@ -215,8 +215,15 @@</span> <span class="p_context"> struct nx_sg *nx_walk_and_build(struct nx_sg       *nx_dst,</span>
  * @delta:  is the amount we need to crop in order to bound the list.
  *
  */
<span class="p_del">-static long int trim_sg_list(struct nx_sg *sg, struct nx_sg *end, unsigned int delta)</span>
<span class="p_add">+static long int trim_sg_list(struct nx_sg *sg,</span>
<span class="p_add">+			     struct nx_sg *end,</span>
<span class="p_add">+			     unsigned int delta,</span>
<span class="p_add">+			     unsigned int *nbytes)</span>
 {
<span class="p_add">+	long int oplen;</span>
<span class="p_add">+	long int data_back;</span>
<span class="p_add">+	unsigned int is_delta = delta;</span>
<span class="p_add">+</span>
 	while (delta &amp;&amp; end &gt; sg) {
 		struct nx_sg *last = end - 1;
 
<span class="p_chunk">@@ -228,54 +235,20 @@</span> <span class="p_context"> static long int trim_sg_list(struct nx_sg *sg, struct nx_sg *end, unsigned int d</span>
 			delta -= last-&gt;len;
 		}
 	}
<span class="p_del">-	return (sg - end) * sizeof(struct nx_sg);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * nx_sha_build_sg_list - walk and build sg list to sha modes</span>
<span class="p_del">- *			  using right bounds and limits.</span>
<span class="p_del">- * @nx_ctx: NX crypto context for the lists we&#39;re building</span>
<span class="p_del">- * @nx_sg: current sg list in or out list</span>
<span class="p_del">- * @op_len: current op_len to be used in order to build a sg list</span>
<span class="p_del">- * @nbytes:  number or bytes to be processed</span>
<span class="p_del">- * @offset: buf offset</span>
<span class="p_del">- * @mode: SHA256 or SHA512</span>
<span class="p_del">- */</span>
<span class="p_del">-int nx_sha_build_sg_list(struct nx_crypto_ctx *nx_ctx,</span>
<span class="p_del">-			  struct nx_sg 	      *nx_in_outsg,</span>
<span class="p_del">-			  s64		      *op_len,</span>
<span class="p_del">-			  unsigned int        *nbytes,</span>
<span class="p_del">-			  u8 		      *offset,</span>
<span class="p_del">-			  u32		      mode)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int delta = 0;</span>
<span class="p_del">-	unsigned int total = *nbytes;</span>
<span class="p_del">-	struct nx_sg *nx_insg = nx_in_outsg;</span>
<span class="p_del">-	unsigned int max_sg_len;</span>
 
<span class="p_del">-	max_sg_len = min_t(u64, nx_ctx-&gt;ap-&gt;sglen,</span>
<span class="p_del">-			nx_driver.of.max_sg_len/sizeof(struct nx_sg));</span>
<span class="p_del">-	max_sg_len = min_t(u64, max_sg_len,</span>
<span class="p_del">-			nx_ctx-&gt;ap-&gt;databytelen/NX_PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	*nbytes = min_t(u64, *nbytes, nx_ctx-&gt;ap-&gt;databytelen);</span>
<span class="p_del">-	nx_insg = nx_build_sg_list(nx_insg, offset, nbytes, max_sg_len);</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (mode) {</span>
<span class="p_del">-	case NX_DS_SHA256:</span>
<span class="p_del">-		if (*nbytes &lt; total)</span>
<span class="p_del">-			delta = *nbytes - (*nbytes &amp; ~(SHA256_BLOCK_SIZE - 1));</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case NX_DS_SHA512:</span>
<span class="p_del">-		if (*nbytes &lt; total)</span>
<span class="p_del">-			delta = *nbytes - (*nbytes &amp; ~(SHA512_BLOCK_SIZE - 1));</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	/* There are cases where we need to crop list in order to make it</span>
<span class="p_add">+	 * a block size multiple, but we also need to align data. In order to</span>
<span class="p_add">+	 * that we need to calculate how much we need to put back to be</span>
<span class="p_add">+	 * processed</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	oplen = (sg - end) * sizeof(struct nx_sg);</span>
<span class="p_add">+	if (is_delta) {</span>
<span class="p_add">+		data_back = (abs(oplen) / AES_BLOCK_SIZE) *  sg-&gt;len;</span>
<span class="p_add">+		data_back = *nbytes - (data_back &amp; ~(AES_BLOCK_SIZE - 1));</span>
<span class="p_add">+		*nbytes -= data_back;</span>
 	}
<span class="p_del">-	*op_len = trim_sg_list(nx_in_outsg, nx_insg, delta);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return oplen;</span>
 }
 
 /**
<span class="p_chunk">@@ -330,8 +303,8 @@</span> <span class="p_context"> int nx_build_sg_lists(struct nx_crypto_ctx  *nx_ctx,</span>
 	/* these lengths should be negative, which will indicate to phyp that
 	 * the input and output parameters are scatterlists, not linear
 	 * buffers */
<span class="p_del">-	nx_ctx-&gt;op.inlen = trim_sg_list(nx_ctx-&gt;in_sg, nx_insg, delta);</span>
<span class="p_del">-	nx_ctx-&gt;op.outlen = trim_sg_list(nx_ctx-&gt;out_sg, nx_outsg, delta);</span>
<span class="p_add">+	nx_ctx-&gt;op.inlen = trim_sg_list(nx_ctx-&gt;in_sg, nx_insg, delta, nbytes);</span>
<span class="p_add">+	nx_ctx-&gt;op.outlen = trim_sg_list(nx_ctx-&gt;out_sg, nx_outsg, delta, nbytes);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -662,12 +635,14 @@</span> <span class="p_context"> static int nx_crypto_ctx_init(struct nx_crypto_ctx *nx_ctx, u32 fc, u32 mode)</span>
 /* entry points from the crypto tfm initializers */
 int nx_crypto_ctx_aes_ccm_init(struct crypto_tfm *tfm)
 {
<span class="p_add">+	tfm-&gt;crt_aead.reqsize = sizeof(struct nx_ccm_rctx);</span>
 	return nx_crypto_ctx_init(crypto_tfm_ctx(tfm), NX_FC_AES,
 				  NX_MODE_AES_CCM);
 }
 
 int nx_crypto_ctx_aes_gcm_init(struct crypto_tfm *tfm)
 {
<span class="p_add">+	tfm-&gt;crt_aead.reqsize = sizeof(struct nx_gcm_rctx);</span>
 	return nx_crypto_ctx_init(crypto_tfm_ctx(tfm), NX_FC_AES,
 				  NX_MODE_AES_GCM);
 }
<span class="p_header">diff --git a/drivers/crypto/nx/nx.h b/drivers/crypto/nx/nx.h</span>
<span class="p_header">index 6c9ecaaead52..c3ed83764fef 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx.h</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx.h</span>
<span class="p_chunk">@@ -2,6 +2,8 @@</span> <span class="p_context"></span>
 #ifndef __NX_H__
 #define __NX_H__
 
<span class="p_add">+#include &lt;crypto/ctr.h&gt;</span>
<span class="p_add">+</span>
 #define NX_NAME		&quot;nx-crypto&quot;
 #define NX_STRING	&quot;IBM Power7+ Nest Accelerator Crypto Driver&quot;
 #define NX_VERSION	&quot;1.0&quot;
<span class="p_chunk">@@ -91,8 +93,11 @@</span> <span class="p_context"> struct nx_crypto_driver {</span>
 
 #define NX_GCM4106_NONCE_LEN		(4)
 #define NX_GCM_CTR_OFFSET		(12)
<span class="p_del">-struct nx_gcm_priv {</span>
<span class="p_add">+struct nx_gcm_rctx {</span>
 	u8 iv[16];
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct nx_gcm_priv {</span>
 	u8 iauth_tag[16];
 	u8 nonce[NX_GCM4106_NONCE_LEN];
 };
<span class="p_chunk">@@ -100,8 +105,11 @@</span> <span class="p_context"> struct nx_gcm_priv {</span>
 #define NX_CCM_AES_KEY_LEN		(16)
 #define NX_CCM4309_AES_KEY_LEN		(19)
 #define NX_CCM4309_NONCE_LEN		(3)
<span class="p_del">-struct nx_ccm_priv {</span>
<span class="p_add">+struct nx_ccm_rctx {</span>
 	u8 iv[16];
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct nx_ccm_priv {</span>
 	u8 b0[16];
 	u8 iauth_tag[16];
 	u8 oauth_tag[16];
<span class="p_chunk">@@ -113,7 +121,7 @@</span> <span class="p_context"> struct nx_xcbc_priv {</span>
 };
 
 struct nx_ctr_priv {
<span class="p_del">-	u8 iv[16];</span>
<span class="p_add">+	u8 nonce[CTR_RFC3686_NONCE_SIZE];</span>
 };
 
 struct nx_crypto_ctx {
<span class="p_chunk">@@ -153,8 +161,6 @@</span> <span class="p_context"> void nx_crypto_ctx_exit(struct crypto_tfm *tfm);</span>
 void nx_ctx_init(struct nx_crypto_ctx *nx_ctx, unsigned int function);
 int nx_hcall_sync(struct nx_crypto_ctx *ctx, struct vio_pfo_op *op,
 		  u32 may_sleep);
<span class="p_del">-int nx_sha_build_sg_list(struct nx_crypto_ctx *, struct nx_sg *,</span>
<span class="p_del">-			 s64 *, unsigned int *, u8 *, u32);</span>
 struct nx_sg *nx_build_sg_list(struct nx_sg *, u8 *, unsigned int *, u32);
 int nx_build_sg_lists(struct nx_crypto_ctx *, struct blkcipher_desc *,
 		      struct scatterlist *, struct scatterlist *, unsigned int *,
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/qat_algs.c b/drivers/crypto/qat/qat_common/qat_algs.c</span>
<span class="p_header">index 1dc5b0a17cf7..34139a8894a0 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/qat_algs.c</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/qat_algs.c</span>
<span class="p_chunk">@@ -73,7 +73,8 @@</span> <span class="p_context"></span>
 				       ICP_QAT_HW_CIPHER_KEY_CONVERT, \
 				       ICP_QAT_HW_CIPHER_DECRYPT)
 
<span class="p_del">-static atomic_t active_dev;</span>
<span class="p_add">+static DEFINE_MUTEX(algs_lock);</span>
<span class="p_add">+static unsigned int active_devs;</span>
 
 struct qat_alg_buf {
 	uint32_t len;
<span class="p_chunk">@@ -1271,7 +1272,10 @@</span> <span class="p_context"> static struct crypto_alg qat_algs[] = { {</span>
 
 int qat_algs_register(void)
 {
<span class="p_del">-	if (atomic_add_return(1, &amp;active_dev) == 1) {</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;algs_lock);</span>
<span class="p_add">+	if (++active_devs == 1) {</span>
 		int i;
 
 		for (i = 0; i &lt; ARRAY_SIZE(qat_algs); i++)
<span class="p_chunk">@@ -1280,21 +1284,25 @@</span> <span class="p_context"> int qat_algs_register(void)</span>
 				CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC :
 				CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC;
 
<span class="p_del">-		return crypto_register_algs(qat_algs, ARRAY_SIZE(qat_algs));</span>
<span class="p_add">+		ret = crypto_register_algs(qat_algs, ARRAY_SIZE(qat_algs));</span>
 	}
<span class="p_del">-	return 0;</span>
<span class="p_add">+	mutex_unlock(&amp;algs_lock);</span>
<span class="p_add">+	return ret;</span>
 }
 
 int qat_algs_unregister(void)
 {
<span class="p_del">-	if (atomic_sub_return(1, &amp;active_dev) == 0)</span>
<span class="p_del">-		return crypto_unregister_algs(qat_algs, ARRAY_SIZE(qat_algs));</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;algs_lock);</span>
<span class="p_add">+	if (--active_devs == 0)</span>
<span class="p_add">+		ret = crypto_unregister_algs(qat_algs, ARRAY_SIZE(qat_algs));</span>
<span class="p_add">+	mutex_unlock(&amp;algs_lock);</span>
<span class="p_add">+	return ret;</span>
 }
 
 int qat_algs_init(void)
 {
<span class="p_del">-	atomic_set(&amp;active_dev, 0);</span>
 	crypto_get_default_rng();
 	return 0;
 }
<span class="p_header">diff --git a/drivers/dma/at_xdmac.c b/drivers/dma/at_xdmac.c</span>
<span class="p_header">index 7992164ea9ec..c89a7abb523f 100644</span>
<span class="p_header">--- a/drivers/dma/at_xdmac.c</span>
<span class="p_header">+++ b/drivers/dma/at_xdmac.c</span>
<span class="p_chunk">@@ -648,16 +648,17 @@</span> <span class="p_context"> at_xdmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,</span>
 			desc-&gt;lld.mbr_sa = mem;
 			desc-&gt;lld.mbr_da = atchan-&gt;sconfig.dst_addr;
 		}
<span class="p_del">-		desc-&gt;lld.mbr_cfg = atchan-&gt;cfg;</span>
<span class="p_del">-		dwidth = at_xdmac_get_dwidth(desc-&gt;lld.mbr_cfg);</span>
<span class="p_add">+		dwidth = at_xdmac_get_dwidth(atchan-&gt;cfg);</span>
 		fixed_dwidth = IS_ALIGNED(len, 1 &lt;&lt; dwidth)
<span class="p_del">-			       ? at_xdmac_get_dwidth(desc-&gt;lld.mbr_cfg)</span>
<span class="p_add">+			       ? dwidth</span>
 			       : AT_XDMAC_CC_DWIDTH_BYTE;
 		desc-&gt;lld.mbr_ubc = AT_XDMAC_MBR_UBC_NDV2			/* next descriptor view */
 			| AT_XDMAC_MBR_UBC_NDEN					/* next descriptor dst parameter update */
 			| AT_XDMAC_MBR_UBC_NSEN					/* next descriptor src parameter update */
 			| (i == sg_len - 1 ? 0 : AT_XDMAC_MBR_UBC_NDE)		/* descriptor fetch */
 			| (len &gt;&gt; fixed_dwidth);				/* microblock length */
<span class="p_add">+		desc-&gt;lld.mbr_cfg = (atchan-&gt;cfg &amp; ~AT_XDMAC_CC_DWIDTH_MASK) |</span>
<span class="p_add">+				    AT_XDMAC_CC_DWIDTH(fixed_dwidth);</span>
 		dev_dbg(chan2dev(chan),
 			 &quot;%s: lld: mbr_sa=%pad, mbr_da=%pad, mbr_ubc=0x%08x\n&quot;,
 			 __func__, &amp;desc-&gt;lld.mbr_sa, &amp;desc-&gt;lld.mbr_da, desc-&gt;lld.mbr_ubc);
<span class="p_header">diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.c</span>
<span class="p_header">index 340f9e607cd8..3dabc52b9615 100644</span>
<span class="p_header">--- a/drivers/dma/pl330.c</span>
<span class="p_header">+++ b/drivers/dma/pl330.c</span>
<span class="p_chunk">@@ -2328,7 +2328,7 @@</span> <span class="p_context"> static dma_cookie_t pl330_tx_submit(struct dma_async_tx_descriptor *tx)</span>
 			desc-&gt;txd.callback = last-&gt;txd.callback;
 			desc-&gt;txd.callback_param = last-&gt;txd.callback_param;
 		}
<span class="p_del">-		last-&gt;last = false;</span>
<span class="p_add">+		desc-&gt;last = false;</span>
 
 		dma_cookie_assign(&amp;desc-&gt;txd);
 
<span class="p_chunk">@@ -2621,6 +2621,7 @@</span> <span class="p_context"> pl330_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dst,</span>
 		desc-&gt;rqcfg.brst_len = 1;
 
 	desc-&gt;rqcfg.brst_len = get_burst_len(desc, len);
<span class="p_add">+	desc-&gt;bytes_requested = len;</span>
 
 	desc-&gt;txd.flags = flags;
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">index 778bbb6425b8..b0487c9f018c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_chunk">@@ -1294,7 +1294,6 @@</span> <span class="p_context"> retry:</span>
 				goto retry;
 			}
 			DRM_DEBUG_KMS(&quot;failed to dpcd write %d %d\n&quot;, tosend, ret);
<span class="p_del">-			WARN(1, &quot;fail\n&quot;);</span>
 
 			return -EIO;
 		}
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index 8ae6f7f06b3a..683a9b004c11 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -3190,15 +3190,14 @@</span> <span class="p_context"> int intel_freq_opcode(struct drm_i915_private *dev_priv, int val);</span>
 #define I915_READ64(reg)	dev_priv-&gt;uncore.funcs.mmio_readq(dev_priv, (reg), true)
 
 #define I915_READ64_2x32(lower_reg, upper_reg) ({			\
<span class="p_del">-		u32 upper = I915_READ(upper_reg);			\</span>
<span class="p_del">-		u32 lower = I915_READ(lower_reg);			\</span>
<span class="p_del">-		u32 tmp = I915_READ(upper_reg);				\</span>
<span class="p_del">-		if (upper != tmp) {					\</span>
<span class="p_del">-			upper = tmp;					\</span>
<span class="p_del">-			lower = I915_READ(lower_reg);			\</span>
<span class="p_del">-			WARN_ON(I915_READ(upper_reg) != upper);		\</span>
<span class="p_del">-		}							\</span>
<span class="p_del">-		(u64)upper &lt;&lt; 32 | lower; })</span>
<span class="p_add">+	u32 upper, lower, tmp;						\</span>
<span class="p_add">+	tmp = I915_READ(upper_reg);					\</span>
<span class="p_add">+	do {								\</span>
<span class="p_add">+		upper = tmp;						\</span>
<span class="p_add">+		lower = I915_READ(lower_reg);				\</span>
<span class="p_add">+		tmp = I915_READ(upper_reg);				\</span>
<span class="p_add">+	} while (upper != tmp);						\</span>
<span class="p_add">+	(u64)upper &lt;&lt; 32 | lower; })</span>
 
 #define POSTING_READ(reg)	(void)I915_READ_NOTRACE(reg)
 #define POSTING_READ16(reg)	(void)I915_READ16_NOTRACE(reg)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_tiling.c b/drivers/gpu/drm/i915/i915_gem_tiling.c</span>
<span class="p_header">index 6377b22269ad..7ee23d1d1e74 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_tiling.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_tiling.c</span>
<span class="p_chunk">@@ -464,7 +464,10 @@</span> <span class="p_context"> i915_gem_get_tiling(struct drm_device *dev, void *data,</span>
 	}
 
 	/* Hide bit 17 from the user -- see comment in i915_gem_set_tiling */
<span class="p_del">-	args-&gt;phys_swizzle_mode = args-&gt;swizzle_mode;</span>
<span class="p_add">+	if (dev_priv-&gt;quirks &amp; QUIRK_PIN_SWIZZLED_PAGES)</span>
<span class="p_add">+		args-&gt;phys_swizzle_mode = I915_BIT_6_SWIZZLE_UNKNOWN;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		args-&gt;phys_swizzle_mode = args-&gt;swizzle_mode;</span>
 	if (args-&gt;swizzle_mode == I915_BIT_6_SWIZZLE_9_17)
 		args-&gt;swizzle_mode = I915_BIT_6_SWIZZLE_9;
 	if (args-&gt;swizzle_mode == I915_BIT_6_SWIZZLE_9_10_17)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/dce6_afmt.c b/drivers/gpu/drm/radeon/dce6_afmt.c</span>
<span class="p_header">index 68fd9fc677e3..44480c1b9738 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/dce6_afmt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/dce6_afmt.c</span>
<span class="p_chunk">@@ -93,30 +93,26 @@</span> <span class="p_context"> void dce6_afmt_select_pin(struct drm_encoder *encoder)</span>
 	struct radeon_device *rdev = encoder-&gt;dev-&gt;dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;
<span class="p_del">-	u32 offset;</span>
 
<span class="p_del">-	if (!dig || !dig-&gt;afmt || !dig-&gt;afmt-&gt;pin)</span>
<span class="p_add">+	if (!dig || !dig-&gt;afmt || !dig-&gt;pin)</span>
 		return;
 
<span class="p_del">-	offset = dig-&gt;afmt-&gt;offset;</span>
<span class="p_del">-</span>
<span class="p_del">-	WREG32(AFMT_AUDIO_SRC_CONTROL + offset,</span>
<span class="p_del">-	       AFMT_AUDIO_SRC_SELECT(dig-&gt;afmt-&gt;pin-&gt;id));</span>
<span class="p_add">+	WREG32(AFMT_AUDIO_SRC_CONTROL +  dig-&gt;afmt-&gt;offset,</span>
<span class="p_add">+	       AFMT_AUDIO_SRC_SELECT(dig-&gt;pin-&gt;id));</span>
 }
 
 void dce6_afmt_write_latency_fields(struct drm_encoder *encoder,
<span class="p_del">-		struct drm_connector *connector, struct drm_display_mode *mode)</span>
<span class="p_add">+				    struct drm_connector *connector,</span>
<span class="p_add">+				    struct drm_display_mode *mode)</span>
 {
 	struct radeon_device *rdev = encoder-&gt;dev-&gt;dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;
<span class="p_del">-	u32 tmp = 0, offset;</span>
<span class="p_add">+	u32 tmp = 0;</span>
 
<span class="p_del">-	if (!dig || !dig-&gt;afmt || !dig-&gt;afmt-&gt;pin)</span>
<span class="p_add">+	if (!dig || !dig-&gt;afmt || !dig-&gt;pin)</span>
 		return;
 
<span class="p_del">-	offset = dig-&gt;afmt-&gt;pin-&gt;offset;</span>
<span class="p_del">-</span>
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE) {
 		if (connector-&gt;latency_present[1])
 			tmp = VIDEO_LIPSYNC(connector-&gt;video_latency[1]) |
<span class="p_chunk">@@ -130,24 +126,24 @@</span> <span class="p_context"> void dce6_afmt_write_latency_fields(struct drm_encoder *encoder,</span>
 		else
 			tmp = VIDEO_LIPSYNC(0) | AUDIO_LIPSYNC(0);
 	}
<span class="p_del">-	WREG32_ENDPOINT(offset, AZ_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC, tmp);</span>
<span class="p_add">+	WREG32_ENDPOINT(dig-&gt;pin-&gt;offset,</span>
<span class="p_add">+			AZ_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC, tmp);</span>
 }
 
 void dce6_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,
<span class="p_del">-	u8 *sadb, int sad_count)</span>
<span class="p_add">+					     u8 *sadb, int sad_count)</span>
 {
 	struct radeon_device *rdev = encoder-&gt;dev-&gt;dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;
<span class="p_del">-	u32 offset, tmp;</span>
<span class="p_add">+	u32 tmp;</span>
 
<span class="p_del">-	if (!dig || !dig-&gt;afmt || !dig-&gt;afmt-&gt;pin)</span>
<span class="p_add">+	if (!dig || !dig-&gt;afmt || !dig-&gt;pin)</span>
 		return;
 
<span class="p_del">-	offset = dig-&gt;afmt-&gt;pin-&gt;offset;</span>
<span class="p_del">-</span>
 	/* program the speaker allocation */
<span class="p_del">-	tmp = RREG32_ENDPOINT(offset, AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);</span>
<span class="p_add">+	tmp = RREG32_ENDPOINT(dig-&gt;pin-&gt;offset,</span>
<span class="p_add">+			      AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);</span>
 	tmp &amp;= ~(DP_CONNECTION | SPEAKER_ALLOCATION_MASK);
 	/* set HDMI mode */
 	tmp |= HDMI_CONNECTION;
<span class="p_chunk">@@ -155,24 +151,24 @@</span> <span class="p_context"> void dce6_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,</span>
 		tmp |= SPEAKER_ALLOCATION(sadb[0]);
 	else
 		tmp |= SPEAKER_ALLOCATION(5); /* stereo */
<span class="p_del">-	WREG32_ENDPOINT(offset, AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, tmp);</span>
<span class="p_add">+	WREG32_ENDPOINT(dig-&gt;pin-&gt;offset,</span>
<span class="p_add">+			AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, tmp);</span>
 }
 
 void dce6_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,
<span class="p_del">-	u8 *sadb, int sad_count)</span>
<span class="p_add">+					   u8 *sadb, int sad_count)</span>
 {
 	struct radeon_device *rdev = encoder-&gt;dev-&gt;dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;
<span class="p_del">-	u32 offset, tmp;</span>
<span class="p_add">+	u32 tmp;</span>
 
<span class="p_del">-	if (!dig || !dig-&gt;afmt || !dig-&gt;afmt-&gt;pin)</span>
<span class="p_add">+	if (!dig || !dig-&gt;afmt || !dig-&gt;pin)</span>
 		return;
 
<span class="p_del">-	offset = dig-&gt;afmt-&gt;pin-&gt;offset;</span>
<span class="p_del">-</span>
 	/* program the speaker allocation */
<span class="p_del">-	tmp = RREG32_ENDPOINT(offset, AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);</span>
<span class="p_add">+	tmp = RREG32_ENDPOINT(dig-&gt;pin-&gt;offset,</span>
<span class="p_add">+			      AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);</span>
 	tmp &amp;= ~(HDMI_CONNECTION | SPEAKER_ALLOCATION_MASK);
 	/* set DP mode */
 	tmp |= DP_CONNECTION;
<span class="p_chunk">@@ -180,13 +176,13 @@</span> <span class="p_context"> void dce6_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,</span>
 		tmp |= SPEAKER_ALLOCATION(sadb[0]);
 	else
 		tmp |= SPEAKER_ALLOCATION(5); /* stereo */
<span class="p_del">-	WREG32_ENDPOINT(offset, AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, tmp);</span>
<span class="p_add">+	WREG32_ENDPOINT(dig-&gt;pin-&gt;offset,</span>
<span class="p_add">+			AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, tmp);</span>
 }
 
 void dce6_afmt_write_sad_regs(struct drm_encoder *encoder,
<span class="p_del">-	struct cea_sad *sads, int sad_count)</span>
<span class="p_add">+			      struct cea_sad *sads, int sad_count)</span>
 {
<span class="p_del">-	u32 offset;</span>
 	int i;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;
<span class="p_chunk">@@ -206,11 +202,9 @@</span> <span class="p_context"> void dce6_afmt_write_sad_regs(struct drm_encoder *encoder,</span>
 		{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },
 	};
 
<span class="p_del">-	if (!dig || !dig-&gt;afmt || !dig-&gt;afmt-&gt;pin)</span>
<span class="p_add">+	if (!dig || !dig-&gt;afmt || !dig-&gt;pin)</span>
 		return;
 
<span class="p_del">-	offset = dig-&gt;afmt-&gt;pin-&gt;offset;</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; ARRAY_SIZE(eld_reg_to_type); i++) {
 		u32 value = 0;
 		u8 stereo_freqs = 0;
<span class="p_chunk">@@ -237,7 +231,7 @@</span> <span class="p_context"> void dce6_afmt_write_sad_regs(struct drm_encoder *encoder,</span>
 
 		value |= SUPPORTED_FREQUENCIES_STEREO(stereo_freqs);
 
<span class="p_del">-		WREG32_ENDPOINT(offset, eld_reg_to_type[i][0], value);</span>
<span class="p_add">+		WREG32_ENDPOINT(dig-&gt;pin-&gt;offset, eld_reg_to_type[i][0], value);</span>
 	}
 }
 
<span class="p_chunk">@@ -253,7 +247,7 @@</span> <span class="p_context"> void dce6_audio_enable(struct radeon_device *rdev,</span>
 }
 
 void dce6_hdmi_audio_set_dto(struct radeon_device *rdev,
<span class="p_del">-	struct radeon_crtc *crtc, unsigned int clock)</span>
<span class="p_add">+			     struct radeon_crtc *crtc, unsigned int clock)</span>
 {
 	/* Two dtos; generally use dto0 for HDMI */
 	u32 value = 0;
<span class="p_chunk">@@ -272,7 +266,7 @@</span> <span class="p_context"> void dce6_hdmi_audio_set_dto(struct radeon_device *rdev,</span>
 }
 
 void dce6_dp_audio_set_dto(struct radeon_device *rdev,
<span class="p_del">-	struct radeon_crtc *crtc, unsigned int clock)</span>
<span class="p_add">+			   struct radeon_crtc *crtc, unsigned int clock)</span>
 {
 	/* Two dtos; generally use dto1 for DP */
 	u32 value = 0;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">index fa719c53449b..59b3d3221294 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_chunk">@@ -245,6 +245,28 @@</span> <span class="p_context"> static struct radeon_audio_funcs dce6_dp_funcs = {</span>
 static void radeon_audio_enable(struct radeon_device *rdev,
 				struct r600_audio_pin *pin, u8 enable_mask)
 {
<span class="p_add">+	struct drm_encoder *encoder;</span>
<span class="p_add">+	struct radeon_encoder *radeon_encoder;</span>
<span class="p_add">+	struct radeon_encoder_atom_dig *dig;</span>
<span class="p_add">+	int pin_count = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pin)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rdev-&gt;mode_info.mode_config_initialized) {</span>
<span class="p_add">+		list_for_each_entry(encoder, &amp;rdev-&gt;ddev-&gt;mode_config.encoder_list, head) {</span>
<span class="p_add">+			if (radeon_encoder_is_digital(encoder)) {</span>
<span class="p_add">+				radeon_encoder = to_radeon_encoder(encoder);</span>
<span class="p_add">+				dig = radeon_encoder-&gt;enc_priv;</span>
<span class="p_add">+				if (dig-&gt;pin == pin)</span>
<span class="p_add">+					pin_count++;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((pin_count &gt; 1) &amp;&amp; (enable_mask == 0))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (rdev-&gt;audio.funcs-&gt;enable)
 		rdev-&gt;audio.funcs-&gt;enable(rdev, pin, enable_mask);
 }
<span class="p_chunk">@@ -336,24 +358,13 @@</span> <span class="p_context"> void radeon_audio_endpoint_wreg(struct radeon_device *rdev, u32 offset,</span>
 
 static void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
 {
<span class="p_del">-	struct radeon_encoder *radeon_encoder;</span>
<span class="p_del">-	struct drm_connector *connector;</span>
<span class="p_del">-	struct radeon_connector *radeon_connector = NULL;</span>
<span class="p_add">+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);</span>
<span class="p_add">+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);</span>
 	struct cea_sad *sads;
 	int sad_count;
 
<span class="p_del">-	list_for_each_entry(connector,</span>
<span class="p_del">-		&amp;encoder-&gt;dev-&gt;mode_config.connector_list, head) {</span>
<span class="p_del">-		if (connector-&gt;encoder == encoder) {</span>
<span class="p_del">-			radeon_connector = to_radeon_connector(connector);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!radeon_connector) {</span>
<span class="p_del">-		DRM_ERROR(&quot;Couldn&#39;t find encoder&#39;s connector\n&quot;);</span>
<span class="p_add">+	if (!connector)</span>
 		return;
<span class="p_del">-	}</span>
 
 	sad_count = drm_edid_to_sad(radeon_connector_edid(connector), &amp;sads);
 	if (sad_count &lt;= 0) {
<span class="p_chunk">@@ -362,8 +373,6 @@</span> <span class="p_context"> static void radeon_audio_write_sad_regs(struct drm_encoder *encoder)</span>
 	}
 	BUG_ON(!sads);
 
<span class="p_del">-	radeon_encoder = to_radeon_encoder(encoder);</span>
<span class="p_del">-</span>
 	if (radeon_encoder-&gt;audio &amp;&amp; radeon_encoder-&gt;audio-&gt;write_sad_regs)
 		radeon_encoder-&gt;audio-&gt;write_sad_regs(encoder, sads, sad_count);
 
<span class="p_chunk">@@ -372,27 +381,16 @@</span> <span class="p_context"> static void radeon_audio_write_sad_regs(struct drm_encoder *encoder)</span>
 
 static void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)
 {
<span class="p_add">+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);</span>
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
<span class="p_del">-	struct drm_connector *connector;</span>
<span class="p_del">-	struct radeon_connector *radeon_connector = NULL;</span>
 	u8 *sadb = NULL;
 	int sad_count;
 
<span class="p_del">-	list_for_each_entry(connector,</span>
<span class="p_del">-			    &amp;encoder-&gt;dev-&gt;mode_config.connector_list, head) {</span>
<span class="p_del">-		if (connector-&gt;encoder == encoder) {</span>
<span class="p_del">-			radeon_connector = to_radeon_connector(connector);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!radeon_connector) {</span>
<span class="p_del">-		DRM_ERROR(&quot;Couldn&#39;t find encoder&#39;s connector\n&quot;);</span>
<span class="p_add">+	if (!connector)</span>
 		return;
<span class="p_del">-	}</span>
 
<span class="p_del">-	sad_count = drm_edid_to_speaker_allocation(</span>
<span class="p_del">-		radeon_connector_edid(connector), &amp;sadb);</span>
<span class="p_add">+	sad_count = drm_edid_to_speaker_allocation(radeon_connector_edid(connector),</span>
<span class="p_add">+						   &amp;sadb);</span>
 	if (sad_count &lt; 0) {
 		DRM_DEBUG(&quot;Couldn&#39;t read Speaker Allocation Data Block: %d\n&quot;,
 			  sad_count);
<span class="p_chunk">@@ -406,26 +404,13 @@</span> <span class="p_context"> static void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)</span>
 }
 
 static void radeon_audio_write_latency_fields(struct drm_encoder *encoder,
<span class="p_del">-	struct drm_display_mode *mode)</span>
<span class="p_add">+					      struct drm_display_mode *mode)</span>
 {
<span class="p_del">-	struct radeon_encoder *radeon_encoder;</span>
<span class="p_del">-	struct drm_connector *connector;</span>
<span class="p_del">-	struct radeon_connector *radeon_connector = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(connector,</span>
<span class="p_del">-		&amp;encoder-&gt;dev-&gt;mode_config.connector_list, head) {</span>
<span class="p_del">-		if (connector-&gt;encoder == encoder) {</span>
<span class="p_del">-			radeon_connector = to_radeon_connector(connector);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);</span>
<span class="p_add">+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);</span>
 
<span class="p_del">-	if (!radeon_connector) {</span>
<span class="p_del">-		DRM_ERROR(&quot;Couldn&#39;t find encoder&#39;s connector\n&quot;);</span>
<span class="p_add">+	if (!connector)</span>
 		return;
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_encoder = to_radeon_encoder(encoder);</span>
 
 	if (radeon_encoder-&gt;audio &amp;&amp; radeon_encoder-&gt;audio-&gt;write_latency_fields)
 		radeon_encoder-&gt;audio-&gt;write_latency_fields(encoder, connector, mode);
<span class="p_chunk">@@ -451,29 +436,23 @@</span> <span class="p_context"> static void radeon_audio_select_pin(struct drm_encoder *encoder)</span>
 }
 
 void radeon_audio_detect(struct drm_connector *connector,
<span class="p_add">+			 struct drm_encoder *encoder,</span>
 			 enum drm_connector_status status)
 {
<span class="p_del">-	struct radeon_device *rdev;</span>
<span class="p_del">-	struct radeon_encoder *radeon_encoder;</span>
<span class="p_add">+	struct drm_device *dev = connector-&gt;dev;</span>
<span class="p_add">+	struct radeon_device *rdev = dev-&gt;dev_private;</span>
<span class="p_add">+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);</span>
 	struct radeon_encoder_atom_dig *dig;
 
<span class="p_del">-	if (!connector || !connector-&gt;encoder)</span>
<span class="p_add">+	if (!radeon_audio_chipset_supported(rdev))</span>
 		return;
 
<span class="p_del">-	rdev = connector-&gt;encoder-&gt;dev-&gt;dev_private;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!radeon_audio_chipset_supported(rdev))</span>
<span class="p_add">+	if (!radeon_encoder_is_digital(encoder))</span>
 		return;
 
<span class="p_del">-	radeon_encoder = to_radeon_encoder(connector-&gt;encoder);</span>
 	dig = radeon_encoder-&gt;enc_priv;
 
 	if (status == connector_status_connected) {
<span class="p_del">-		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
<span class="p_del">-			radeon_encoder-&gt;audio = NULL;</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
 			struct radeon_connector *radeon_connector = to_radeon_connector(connector);
 
<span class="p_chunk">@@ -486,11 +465,17 @@</span> <span class="p_context"> void radeon_audio_detect(struct drm_connector *connector,</span>
 			radeon_encoder-&gt;audio = rdev-&gt;audio.hdmi_funcs;
 		}
 
<span class="p_del">-		dig-&gt;afmt-&gt;pin = radeon_audio_get_pin(connector-&gt;encoder);</span>
<span class="p_del">-		radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0xf);</span>
<span class="p_add">+		if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
<span class="p_add">+			if (!dig-&gt;pin)</span>
<span class="p_add">+				dig-&gt;pin = radeon_audio_get_pin(encoder);</span>
<span class="p_add">+			radeon_audio_enable(rdev, dig-&gt;pin, 0xf);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			radeon_audio_enable(rdev, dig-&gt;pin, 0);</span>
<span class="p_add">+			dig-&gt;pin = NULL;</span>
<span class="p_add">+		}</span>
 	} else {
<span class="p_del">-		radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0);</span>
<span class="p_del">-		dig-&gt;afmt-&gt;pin = NULL;</span>
<span class="p_add">+		radeon_audio_enable(rdev, dig-&gt;pin, 0);</span>
<span class="p_add">+		dig-&gt;pin = NULL;</span>
 	}
 }
 
<span class="p_chunk">@@ -518,29 +503,18 @@</span> <span class="p_context"> static void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock</span>
 }
 
 static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
<span class="p_del">-	struct drm_display_mode *mode)</span>
<span class="p_add">+				       struct drm_display_mode *mode)</span>
 {
 	struct radeon_device *rdev = encoder-&gt;dev-&gt;dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;
<span class="p_del">-	struct drm_connector *connector;</span>
<span class="p_del">-	struct radeon_connector *radeon_connector = NULL;</span>
<span class="p_add">+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);</span>
 	u8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];
 	struct hdmi_avi_infoframe frame;
 	int err;
 
<span class="p_del">-	list_for_each_entry(connector,</span>
<span class="p_del">-		&amp;encoder-&gt;dev-&gt;mode_config.connector_list, head) {</span>
<span class="p_del">-		if (connector-&gt;encoder == encoder) {</span>
<span class="p_del">-			radeon_connector = to_radeon_connector(connector);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!radeon_connector) {</span>
<span class="p_del">-		DRM_ERROR(&quot;Couldn&#39;t find encoder&#39;s connector\n&quot;);</span>
<span class="p_del">-		return -ENOENT;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!connector)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	err = drm_hdmi_avi_infoframe_from_display_mode(&amp;frame, mode);
 	if (err &lt; 0) {
<span class="p_chunk">@@ -563,8 +537,8 @@</span> <span class="p_context"> static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,</span>
 		return err;
 	}
 
<span class="p_del">-	if (dig &amp;&amp; dig-&gt;afmt &amp;&amp;</span>
<span class="p_del">-		radeon_encoder-&gt;audio &amp;&amp; radeon_encoder-&gt;audio-&gt;set_avi_packet)</span>
<span class="p_add">+	if (dig &amp;&amp; dig-&gt;afmt &amp;&amp; radeon_encoder-&gt;audio &amp;&amp;</span>
<span class="p_add">+	    radeon_encoder-&gt;audio-&gt;set_avi_packet)</span>
 		radeon_encoder-&gt;audio-&gt;set_avi_packet(rdev, dig-&gt;afmt-&gt;offset,
 			buffer, sizeof(buffer));
 
<span class="p_chunk">@@ -745,7 +719,7 @@</span> <span class="p_context"> static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,</span>
 }
 
 static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
<span class="p_del">-	struct drm_display_mode *mode)</span>
<span class="p_add">+				     struct drm_display_mode *mode)</span>
 {
 	struct drm_device *dev = encoder-&gt;dev;
 	struct radeon_device *rdev = dev-&gt;dev_private;
<span class="p_chunk">@@ -756,6 +730,9 @@</span> <span class="p_context"> static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,</span>
 	struct radeon_connector_atom_dig *dig_connector =
 		radeon_connector-&gt;con_priv;
 
<span class="p_add">+	if (!connector)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (!dig || !dig-&gt;afmt)
 		return;
 
<span class="p_chunk">@@ -774,7 +751,7 @@</span> <span class="p_context"> static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,</span>
 }
 
 void radeon_audio_mode_set(struct drm_encoder *encoder,
<span class="p_del">-	struct drm_display_mode *mode)</span>
<span class="p_add">+			   struct drm_display_mode *mode)</span>
 {
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_audio.h b/drivers/gpu/drm/radeon/radeon_audio.h</span>
<span class="p_header">index 8438304f7139..059cc3012062 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_audio.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_audio.h</span>
<span class="p_chunk">@@ -68,7 +68,8 @@</span> <span class="p_context"> struct radeon_audio_funcs</span>
 
 int radeon_audio_init(struct radeon_device *rdev);
 void radeon_audio_detect(struct drm_connector *connector,
<span class="p_del">-	enum drm_connector_status status);</span>
<span class="p_add">+			 struct drm_encoder *encoder,</span>
<span class="p_add">+			 enum drm_connector_status status);</span>
 u32 radeon_audio_endpoint_rreg(struct radeon_device *rdev,
 	u32 offset, u32 reg);
 void radeon_audio_endpoint_wreg(struct radeon_device *rdev,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">index 3e5f6b71f3ad..c097d3a82bda 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_chunk">@@ -1255,10 +1255,15 @@</span> <span class="p_context"> struct radeon_encoder_lvds *radeon_combios_get_lvds_info(struct radeon_encoder</span>
 
 			if ((RBIOS16(tmp) == lvds-&gt;native_mode.hdisplay) &amp;&amp;
 			    (RBIOS16(tmp + 2) == lvds-&gt;native_mode.vdisplay)) {
<span class="p_add">+				u32 hss = (RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (hss &gt; lvds-&gt;native_mode.hdisplay)</span>
<span class="p_add">+					hss = (10 - 1) * 8;</span>
<span class="p_add">+</span>
 				lvds-&gt;native_mode.htotal = lvds-&gt;native_mode.hdisplay +
 					(RBIOS16(tmp + 17) - RBIOS16(tmp + 19)) * 8;
 				lvds-&gt;native_mode.hsync_start = lvds-&gt;native_mode.hdisplay +
<span class="p_del">-					(RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;</span>
<span class="p_add">+					hss;</span>
 				lvds-&gt;native_mode.hsync_end = lvds-&gt;native_mode.hsync_start +
 					(RBIOS8(tmp + 23) * 8);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index cebb65e07e1d..94b21ae70ef7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -1379,8 +1379,16 @@</span> <span class="p_context"> out:</span>
 	/* updated in get modes as well since we need to know if it&#39;s analog or digital */
 	radeon_connector_update_scratch_regs(connector, ret);
 
<span class="p_del">-	if (radeon_audio != 0)</span>
<span class="p_del">-		radeon_audio_detect(connector, ret);</span>
<span class="p_add">+	if ((radeon_audio != 0) &amp;&amp; radeon_connector-&gt;use_digital) {</span>
<span class="p_add">+		const struct drm_connector_helper_funcs *connector_funcs =</span>
<span class="p_add">+			connector-&gt;helper_private;</span>
<span class="p_add">+</span>
<span class="p_add">+		encoder = connector_funcs-&gt;best_encoder(connector);</span>
<span class="p_add">+		if (encoder &amp;&amp; (encoder-&gt;encoder_type == DRM_MODE_ENCODER_TMDS)) {</span>
<span class="p_add">+			radeon_connector_get_edid(connector);</span>
<span class="p_add">+			radeon_audio_detect(connector, encoder, ret);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 exit:
 	pm_runtime_mark_last_busy(connector-&gt;dev-&gt;dev);
<span class="p_chunk">@@ -1717,8 +1725,10 @@</span> <span class="p_context"> radeon_dp_detect(struct drm_connector *connector, bool force)</span>
 
 	radeon_connector_update_scratch_regs(connector, ret);
 
<span class="p_del">-	if (radeon_audio != 0)</span>
<span class="p_del">-		radeon_audio_detect(connector, ret);</span>
<span class="p_add">+	if ((radeon_audio != 0) &amp;&amp; encoder) {</span>
<span class="p_add">+		radeon_connector_get_edid(connector);</span>
<span class="p_add">+		radeon_audio_detect(connector, encoder, ret);</span>
<span class="p_add">+	}</span>
 
 out:
 	pm_runtime_mark_last_busy(connector-&gt;dev-&gt;dev);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_mode.h b/drivers/gpu/drm/radeon/radeon_mode.h</span>
<span class="p_header">index f01c797b78cf..9af2d8398e90 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_mode.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_mode.h</span>
<span class="p_chunk">@@ -237,7 +237,6 @@</span> <span class="p_context"> struct radeon_afmt {</span>
 	int offset;
 	bool last_buffer_filled_status;
 	int id;
<span class="p_del">-	struct r600_audio_pin *pin;</span>
 };
 
 struct radeon_mode_info {
<span class="p_chunk">@@ -439,6 +438,7 @@</span> <span class="p_context"> struct radeon_encoder_atom_dig {</span>
 	uint8_t backlight_level;
 	int panel_mode;
 	struct radeon_afmt *afmt;
<span class="p_add">+	struct r600_audio_pin *pin;</span>
 	int active_mst_links;
 };
 
<span class="p_header">diff --git a/drivers/hwmon/nct7904.c b/drivers/hwmon/nct7904.c</span>
<span class="p_header">index 6153df735e82..08ff89d222e5 100644</span>
<span class="p_header">--- a/drivers/hwmon/nct7904.c</span>
<span class="p_header">+++ b/drivers/hwmon/nct7904.c</span>
<span class="p_chunk">@@ -575,6 +575,7 @@</span> <span class="p_context"> static const struct i2c_device_id nct7904_id[] = {</span>
 	{&quot;nct7904&quot;, 0},
 	{}
 };
<span class="p_add">+MODULE_DEVICE_TABLE(i2c, nct7904_id);</span>
 
 static struct i2c_driver nct7904_driver = {
 	.class = I2C_CLASS_HWMON,
<span class="p_header">diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c</span>
<span class="p_header">index a353b7de6d22..bc7eed67998a 100644</span>
<span class="p_header">--- a/drivers/input/mouse/alps.c</span>
<span class="p_header">+++ b/drivers/input/mouse/alps.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/input/mt.h&gt;
 #include &lt;linux/serio.h&gt;
 #include &lt;linux/libps2.h&gt;
<span class="p_add">+#include &lt;linux/dmi.h&gt;</span>
 
 #include &quot;psmouse.h&quot;
 #include &quot;alps.h&quot;
<span class="p_chunk">@@ -99,6 +100,7 @@</span> <span class="p_context"> static const struct alps_nibble_commands alps_v6_nibble_commands[] = {</span>
 #define ALPS_FOUR_BUTTONS	0x40	/* 4 direction button present */
 #define ALPS_PS2_INTERLEAVED	0x80	/* 3-byte PS/2 packet interleaved with
 					   6-byte ALPS packet */
<span class="p_add">+#define ALPS_DELL		0x100	/* device is a Dell laptop */</span>
 #define ALPS_BUTTONPAD		0x200	/* device is a clickpad */
 
 static const struct alps_model_info alps_model_data[] = {
<span class="p_chunk">@@ -251,9 +253,9 @@</span> <span class="p_context"> static void alps_process_packet_v1_v2(struct psmouse *psmouse)</span>
 		return;
 	}
 
<span class="p_del">-	/* Non interleaved V2 dualpoint has separate stick button bits */</span>
<span class="p_add">+	/* Dell non interleaved V2 dualpoint has separate stick button bits */</span>
 	if (priv-&gt;proto_version == ALPS_PROTO_V2 &amp;&amp;
<span class="p_del">-	    priv-&gt;flags == (ALPS_PASS | ALPS_DUALPOINT)) {</span>
<span class="p_add">+	    priv-&gt;flags == (ALPS_DELL | ALPS_PASS | ALPS_DUALPOINT)) {</span>
 		left |= packet[0] &amp; 1;
 		right |= packet[0] &amp; 2;
 		middle |= packet[0] &amp; 4;
<span class="p_chunk">@@ -2542,6 +2544,8 @@</span> <span class="p_context"> static int alps_set_protocol(struct psmouse *psmouse,</span>
 	priv-&gt;byte0 = protocol-&gt;byte0;
 	priv-&gt;mask0 = protocol-&gt;mask0;
 	priv-&gt;flags = protocol-&gt;flags;
<span class="p_add">+	if (dmi_name_in_vendors(&quot;Dell&quot;))</span>
<span class="p_add">+		priv-&gt;flags |= ALPS_DELL;</span>
 
 	priv-&gt;x_max = 2000;
 	priv-&gt;y_max = 1400;
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index e8d84566f311..697f34fba06b 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -1719,7 +1719,8 @@</span> <span class="p_context"> static int dm_merge_bvec(struct request_queue *q,</span>
 	struct mapped_device *md = q-&gt;queuedata;
 	struct dm_table *map = dm_get_live_table_fast(md);
 	struct dm_target *ti;
<span class="p_del">-	sector_t max_sectors, max_size = 0;</span>
<span class="p_add">+	sector_t max_sectors;</span>
<span class="p_add">+	int max_size = 0;</span>
 
 	if (unlikely(!map))
 		goto out;
<span class="p_chunk">@@ -1732,18 +1733,10 @@</span> <span class="p_context"> static int dm_merge_bvec(struct request_queue *q,</span>
 	 * Find maximum amount of I/O that won&#39;t need splitting
 	 */
 	max_sectors = min(max_io_len(bvm-&gt;bi_sector, ti),
<span class="p_del">-			  (sector_t) queue_max_sectors(q));</span>
<span class="p_add">+			  (sector_t) BIO_MAX_SECTORS);</span>
 	max_size = (max_sectors &lt;&lt; SECTOR_SHIFT) - bvm-&gt;bi_size;
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * FIXME: this stop-gap fix _must_ be cleaned up (by passing a sector_t</span>
<span class="p_del">-	 * to the targets&#39; merge function since it holds sectors not bytes).</span>
<span class="p_del">-	 * Just doing this as an interim fix for stable@ because the more</span>
<span class="p_del">-	 * comprehensive cleanup of switching to sector_t will impact every</span>
<span class="p_del">-	 * DM target that implements a -&gt;merge hook.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (max_size &gt; INT_MAX)</span>
<span class="p_del">-		max_size = INT_MAX;</span>
<span class="p_add">+	if (max_size &lt; 0)</span>
<span class="p_add">+		max_size = 0;</span>
 
 	/*
 	 * merge_bvec_fn() returns number of bytes
<span class="p_chunk">@@ -1751,13 +1744,13 @@</span> <span class="p_context"> static int dm_merge_bvec(struct request_queue *q,</span>
 	 * max is precomputed maximal io size
 	 */
 	if (max_size &amp;&amp; ti-&gt;type-&gt;merge)
<span class="p_del">-		max_size = ti-&gt;type-&gt;merge(ti, bvm, biovec, (int) max_size);</span>
<span class="p_add">+		max_size = ti-&gt;type-&gt;merge(ti, bvm, biovec, max_size);</span>
 	/*
 	 * If the target doesn&#39;t support merge method and some of the devices
<span class="p_del">-	 * provided their merge_bvec method (we know this by looking for the</span>
<span class="p_del">-	 * max_hw_sectors that dm_set_device_limits may set), then we can&#39;t</span>
<span class="p_del">-	 * allow bios with multiple vector entries.  So always set max_size</span>
<span class="p_del">-	 * to 0, and the code below allows just one page.</span>
<span class="p_add">+	 * provided their merge_bvec method (we know this by looking at</span>
<span class="p_add">+	 * queue_max_hw_sectors), then we can&#39;t allow bios with multiple vector</span>
<span class="p_add">+	 * entries.  So always set max_size to 0, and the code below allows</span>
<span class="p_add">+	 * just one page.</span>
 	 */
 	else if (queue_max_hw_sectors(q) &lt;= PAGE_SIZE &gt;&gt; 9)
 		max_size = 0;
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index b9200282fd77..e4621511d118 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -5740,7 +5740,7 @@</span> <span class="p_context"> static int get_bitmap_file(struct mddev *mddev, void __user * arg)</span>
 	char *ptr;
 	int err;
 
<span class="p_del">-	file = kmalloc(sizeof(*file), GFP_NOIO);</span>
<span class="p_add">+	file = kzalloc(sizeof(*file), GFP_NOIO);</span>
 	if (!file)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index cd7b0c1e882d..5ce3cd5c4e1d 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -1475,6 +1475,7 @@</span> <span class="p_context"> static void error(struct mddev *mddev, struct md_rdev *rdev)</span>
 {
 	char b[BDEVNAME_SIZE];
 	struct r1conf *conf = mddev-&gt;private;
<span class="p_add">+	unsigned long flags;</span>
 
 	/*
 	 * If it is not operational, then we have already marked it as dead
<span class="p_chunk">@@ -1494,14 +1495,13 @@</span> <span class="p_context"> static void error(struct mddev *mddev, struct md_rdev *rdev)</span>
 		return;
 	}
 	set_bit(Blocked, &amp;rdev-&gt;flags);
<span class="p_add">+	spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 	if (test_and_clear_bit(In_sync, &amp;rdev-&gt;flags)) {
<span class="p_del">-		unsigned long flags;</span>
<span class="p_del">-		spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 		mddev-&gt;degraded++;
 		set_bit(Faulty, &amp;rdev-&gt;flags);
<span class="p_del">-		spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);</span>
 	} else
 		set_bit(Faulty, &amp;rdev-&gt;flags);
<span class="p_add">+	spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);</span>
 	/*
 	 * if recovery is running, make sure it aborts.
 	 */
<span class="p_chunk">@@ -1567,7 +1567,10 @@</span> <span class="p_context"> static int raid1_spare_active(struct mddev *mddev)</span>
 	 * Find all failed disks within the RAID1 configuration
 	 * and mark them readable.
 	 * Called under mddev lock, so rcu protection not needed.
<span class="p_add">+	 * device_lock used to avoid races with raid1_end_read_request</span>
<span class="p_add">+	 * which expects &#39;In_sync&#39; flags and -&gt;degraded to be consistent.</span>
 	 */
<span class="p_add">+	spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 	for (i = 0; i &lt; conf-&gt;raid_disks; i++) {
 		struct md_rdev *rdev = conf-&gt;mirrors[i].rdev;
 		struct md_rdev *repl = conf-&gt;mirrors[conf-&gt;raid_disks + i].rdev;
<span class="p_chunk">@@ -1598,7 +1601,6 @@</span> <span class="p_context"> static int raid1_spare_active(struct mddev *mddev)</span>
 			sysfs_notify_dirent_safe(rdev-&gt;sysfs_state);
 		}
 	}
<span class="p_del">-	spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 	mddev-&gt;degraded -= count;
 	spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/pci.c b/drivers/net/wireless/ath/ath10k/pci.c</span>
<span class="p_header">index 7681237fe298..ead543282128 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/pci.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/pci.c</span>
<span class="p_chunk">@@ -1524,12 +1524,11 @@</span> <span class="p_context"> static int ath10k_pci_get_num_banks(struct ath10k *ar)</span>
 		switch (MS(ar-&gt;chip_id, SOC_CHIP_ID_REV)) {
 		case QCA6174_HW_1_0_CHIP_ID_REV:
 		case QCA6174_HW_1_1_CHIP_ID_REV:
<span class="p_add">+		case QCA6174_HW_2_1_CHIP_ID_REV:</span>
<span class="p_add">+		case QCA6174_HW_2_2_CHIP_ID_REV:</span>
 			return 3;
 		case QCA6174_HW_1_3_CHIP_ID_REV:
 			return 2;
<span class="p_del">-		case QCA6174_HW_2_1_CHIP_ID_REV:</span>
<span class="p_del">-		case QCA6174_HW_2_2_CHIP_ID_REV:</span>
<span class="p_del">-			return 6;</span>
 		case QCA6174_HW_3_0_CHIP_ID_REV:
 		case QCA6174_HW_3_1_CHIP_ID_REV:
 		case QCA6174_HW_3_2_CHIP_ID_REV:
<span class="p_header">diff --git a/drivers/phy/phy-twl4030-usb.c b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">index 8882afbef688..6285f46f3ddb 100644</span>
<span class="p_header">--- a/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">+++ b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_chunk">@@ -144,6 +144,16 @@</span> <span class="p_context"></span>
 #define PMBR1				0x0D
 #define GPIO_USB_4PIN_ULPI_2430C	(3 &lt;&lt; 0)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * If VBUS is valid or ID is ground, then we know a</span>
<span class="p_add">+ * cable is present and we need to be runtime-enabled</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool cable_present(enum omap_musb_vbus_id_status stat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return stat == OMAP_MUSB_VBUS_VALID ||</span>
<span class="p_add">+		stat == OMAP_MUSB_ID_GROUND;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct twl4030_usb {
 	struct usb_phy		phy;
 	struct device		*dev;
<span class="p_chunk">@@ -536,8 +546,10 @@</span> <span class="p_context"> static irqreturn_t twl4030_usb_irq(int irq, void *_twl)</span>
 
 	mutex_lock(&amp;twl-&gt;lock);
 	if (status &gt;= 0 &amp;&amp; status != twl-&gt;linkstat) {
<span class="p_add">+		status_changed =</span>
<span class="p_add">+			cable_present(twl-&gt;linkstat) !=</span>
<span class="p_add">+			cable_present(status);</span>
 		twl-&gt;linkstat = status;
<span class="p_del">-		status_changed = true;</span>
 	}
 	mutex_unlock(&amp;twl-&gt;lock);
 
<span class="p_chunk">@@ -553,15 +565,11 @@</span> <span class="p_context"> static irqreturn_t twl4030_usb_irq(int irq, void *_twl)</span>
 		 * USB_LINK_VBUS state.  musb_hdrc won&#39;t care until it
 		 * starts to handle softconnect right.
 		 */
<span class="p_del">-		if ((status == OMAP_MUSB_VBUS_VALID) ||</span>
<span class="p_del">-		    (status == OMAP_MUSB_ID_GROUND)) {</span>
<span class="p_del">-			if (pm_runtime_suspended(twl-&gt;dev))</span>
<span class="p_del">-				pm_runtime_get_sync(twl-&gt;dev);</span>
<span class="p_add">+		if (cable_present(status)) {</span>
<span class="p_add">+			pm_runtime_get_sync(twl-&gt;dev);</span>
 		} else {
<span class="p_del">-			if (pm_runtime_active(twl-&gt;dev)) {</span>
<span class="p_del">-				pm_runtime_mark_last_busy(twl-&gt;dev);</span>
<span class="p_del">-				pm_runtime_put_autosuspend(twl-&gt;dev);</span>
<span class="p_del">-			}</span>
<span class="p_add">+			pm_runtime_mark_last_busy(twl-&gt;dev);</span>
<span class="p_add">+			pm_runtime_put_autosuspend(twl-&gt;dev);</span>
 		}
 		omap_musb_mailbox(status);
 	}
<span class="p_chunk">@@ -766,6 +774,9 @@</span> <span class="p_context"> static int twl4030_usb_remove(struct platform_device *pdev)</span>
 
 	/* disable complete OTG block */
 	twl4030_usb_clear_bits(twl, POWER_CTRL, POWER_CTRL_OTG_ENAB);
<span class="p_add">+</span>
<span class="p_add">+	if (cable_present(twl-&gt;linkstat))</span>
<span class="p_add">+		pm_runtime_put_noidle(twl-&gt;dev);</span>
 	pm_runtime_mark_last_busy(twl-&gt;dev);
 	pm_runtime_put(twl-&gt;dev);
 
<span class="p_header">diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c</span>
<span class="p_header">index 882744852aac..a9aa38903efe 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.c</span>
<span class="p_header">+++ b/drivers/scsi/ipr.c</span>
<span class="p_chunk">@@ -599,9 +599,10 @@</span> <span class="p_context"> static void ipr_trc_hook(struct ipr_cmnd *ipr_cmd,</span>
 {
 	struct ipr_trace_entry *trace_entry;
 	struct ipr_ioa_cfg *ioa_cfg = ipr_cmd-&gt;ioa_cfg;
<span class="p_add">+	unsigned int trace_index;</span>
 
<span class="p_del">-	trace_entry = &amp;ioa_cfg-&gt;trace[atomic_add_return</span>
<span class="p_del">-			(1, &amp;ioa_cfg-&gt;trace_index)%IPR_NUM_TRACE_ENTRIES];</span>
<span class="p_add">+	trace_index = atomic_add_return(1, &amp;ioa_cfg-&gt;trace_index) &amp; IPR_TRACE_INDEX_MASK;</span>
<span class="p_add">+	trace_entry = &amp;ioa_cfg-&gt;trace[trace_index];</span>
 	trace_entry-&gt;time = jiffies;
 	trace_entry-&gt;op_code = ipr_cmd-&gt;ioarcb.cmd_pkt.cdb[0];
 	trace_entry-&gt;type = type;
<span class="p_chunk">@@ -1051,10 +1052,15 @@</span> <span class="p_context"> static void ipr_send_blocking_cmd(struct ipr_cmnd *ipr_cmd,</span>
 
 static int ipr_get_hrrq_index(struct ipr_ioa_cfg *ioa_cfg)
 {
<span class="p_add">+	unsigned int hrrq;</span>
<span class="p_add">+</span>
 	if (ioa_cfg-&gt;hrrq_num == 1)
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return (atomic_add_return(1, &amp;ioa_cfg-&gt;hrrq_index) % (ioa_cfg-&gt;hrrq_num - 1)) + 1;</span>
<span class="p_add">+		hrrq = 0;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		hrrq = atomic_add_return(1, &amp;ioa_cfg-&gt;hrrq_index);</span>
<span class="p_add">+		hrrq = (hrrq % (ioa_cfg-&gt;hrrq_num - 1)) + 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return hrrq;</span>
 }
 
 /**
<span class="p_chunk">@@ -6263,21 +6269,23 @@</span> <span class="p_context"> static void ipr_scsi_done(struct ipr_cmnd *ipr_cmd)</span>
 	struct ipr_ioa_cfg *ioa_cfg = ipr_cmd-&gt;ioa_cfg;
 	struct scsi_cmnd *scsi_cmd = ipr_cmd-&gt;scsi_cmd;
 	u32 ioasc = be32_to_cpu(ipr_cmd-&gt;s.ioasa.hdr.ioasc);
<span class="p_del">-	unsigned long hrrq_flags;</span>
<span class="p_add">+	unsigned long lock_flags;</span>
 
 	scsi_set_resid(scsi_cmd, be32_to_cpu(ipr_cmd-&gt;s.ioasa.hdr.residual_data_len));
 
 	if (likely(IPR_IOASC_SENSE_KEY(ioasc) == 0)) {
 		scsi_dma_unmap(scsi_cmd);
 
<span class="p_del">-		spin_lock_irqsave(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_lock_irqsave(ipr_cmd-&gt;hrrq-&gt;lock, lock_flags);</span>
 		list_add_tail(&amp;ipr_cmd-&gt;queue, &amp;ipr_cmd-&gt;hrrq-&gt;hrrq_free_q);
 		scsi_cmd-&gt;scsi_done(scsi_cmd);
<span class="p_del">-		spin_unlock_irqrestore(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_unlock_irqrestore(ipr_cmd-&gt;hrrq-&gt;lock, lock_flags);</span>
 	} else {
<span class="p_del">-		spin_lock_irqsave(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_lock_irqsave(ioa_cfg-&gt;host-&gt;host_lock, lock_flags);</span>
<span class="p_add">+		spin_lock(&amp;ipr_cmd-&gt;hrrq-&gt;_lock);</span>
 		ipr_erp_start(ioa_cfg, ipr_cmd);
<span class="p_del">-		spin_unlock_irqrestore(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_unlock(&amp;ipr_cmd-&gt;hrrq-&gt;_lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(ioa_cfg-&gt;host-&gt;host_lock, lock_flags);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h</span>
<span class="p_header">index 73790a1d0969..6b97ee45c7b4 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.h</span>
<span class="p_header">+++ b/drivers/scsi/ipr.h</span>
<span class="p_chunk">@@ -1486,6 +1486,7 @@</span> <span class="p_context"> struct ipr_ioa_cfg {</span>
 
 #define IPR_NUM_TRACE_INDEX_BITS	8
 #define IPR_NUM_TRACE_ENTRIES		(1 &lt;&lt; IPR_NUM_TRACE_INDEX_BITS)
<span class="p_add">+#define IPR_TRACE_INDEX_MASK		(IPR_NUM_TRACE_ENTRIES - 1)</span>
 #define IPR_TRACE_SIZE	(sizeof(struct ipr_trace_entry) * IPR_NUM_TRACE_ENTRIES)
 	char trace_start[8];
 #define IPR_TRACE_START_LABEL			&quot;trace&quot;
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/obdclass/debug.c b/drivers/staging/lustre/lustre/obdclass/debug.c</span>
<span class="p_header">index 9c934e6d2ea1..c61add46b426 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/obdclass/debug.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/obdclass/debug.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"></span>
 
 #define DEBUG_SUBSYSTEM D_OTHER
 
<span class="p_del">-#include &lt;linux/unaligned/access_ok.h&gt;</span>
<span class="p_add">+#include &lt;asm/unaligned.h&gt;</span>
 
 #include &quot;../include/obd_support.h&quot;
 #include &quot;../include/lustre_debug.h&quot;
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index 15baacb126ad..376e4a0c15c6 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -1486,8 +1486,9 @@</span> <span class="p_context"> static void vnt_bss_info_changed(struct ieee80211_hw *hw,</span>
 		}
 	}
 
<span class="p_del">-	if (changed &amp; BSS_CHANGED_ASSOC &amp;&amp; priv-&gt;op_mode != NL80211_IFTYPE_AP) {</span>
<span class="p_del">-		if (conf-&gt;assoc) {</span>
<span class="p_add">+	if (changed &amp; (BSS_CHANGED_ASSOC | BSS_CHANGED_BEACON_INFO) &amp;&amp;</span>
<span class="p_add">+	    priv-&gt;op_mode != NL80211_IFTYPE_AP) {</span>
<span class="p_add">+		if (conf-&gt;assoc &amp;&amp; conf-&gt;beacon_rate) {</span>
 			CARDbUpdateTSF(priv, conf-&gt;beacon_rate-&gt;hw_value,
 				       conf-&gt;sync_tsf);
 
<span class="p_header">diff --git a/drivers/thermal/samsung/exynos_tmu.c b/drivers/thermal/samsung/exynos_tmu.c</span>
<span class="p_header">index 1d30b0975651..67098a8a7a02 100644</span>
<span class="p_header">--- a/drivers/thermal/samsung/exynos_tmu.c</span>
<span class="p_header">+++ b/drivers/thermal/samsung/exynos_tmu.c</span>
<span class="p_chunk">@@ -1209,6 +1209,8 @@</span> <span class="p_context"> err_clk_sec:</span>
 	if (!IS_ERR(data-&gt;clk_sec))
 		clk_unprepare(data-&gt;clk_sec);
 err_sensor:
<span class="p_add">+	if (!IS_ERR_OR_NULL(data-&gt;regulator))</span>
<span class="p_add">+		regulator_disable(data-&gt;regulator);</span>
 	thermal_zone_of_sensor_unregister(&amp;pdev-&gt;dev, data-&gt;tzd);
 
 	return ret;
<span class="p_header">diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c</span>
<span class="p_header">index 74fea4fa41b1..3ad48e1c0c57 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/core.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/core.c</span>
<span class="p_chunk">@@ -1024,7 +1024,18 @@</span> <span class="p_context"> static struct platform_driver ci_hdrc_driver = {</span>
 	},
 };
 
<span class="p_del">-module_platform_driver(ci_hdrc_driver);</span>
<span class="p_add">+static int __init ci_hdrc_platform_register(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ci_hdrc_host_driver_init();</span>
<span class="p_add">+	return platform_driver_register(&amp;ci_hdrc_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+module_init(ci_hdrc_platform_register);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit ci_hdrc_platform_unregister(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	platform_driver_unregister(&amp;ci_hdrc_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+module_exit(ci_hdrc_platform_unregister);</span>
 
 MODULE_ALIAS(&quot;platform:ci_hdrc&quot;);
 MODULE_LICENSE(&quot;GPL v2&quot;);
<span class="p_header">diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c</span>
<span class="p_header">index 21fe1a314313..2f8af40e87ca 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/host.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/host.c</span>
<span class="p_chunk">@@ -237,9 +237,12 @@</span> <span class="p_context"> int ci_hdrc_host_init(struct ci_hdrc *ci)</span>
 	rdrv-&gt;name	= &quot;host&quot;;
 	ci-&gt;roles[CI_ROLE_HOST] = rdrv;
 
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void ci_hdrc_host_driver_init(void)</span>
<span class="p_add">+{</span>
 	ehci_init_driver(&amp;ci_ehci_hc_driver, &amp;ehci_ci_overrides);
 	orig_bus_suspend = ci_ehci_hc_driver.bus_suspend;
 	ci_ehci_hc_driver.bus_suspend = ci_ehci_bus_suspend;
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
<span class="p_header">diff --git a/drivers/usb/chipidea/host.h b/drivers/usb/chipidea/host.h</span>
<span class="p_header">index 5707bf379bfb..0f12f131bdd3 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/host.h</span>
<span class="p_header">+++ b/drivers/usb/chipidea/host.h</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 
 int ci_hdrc_host_init(struct ci_hdrc *ci);
 void ci_hdrc_host_destroy(struct ci_hdrc *ci);
<span class="p_add">+void ci_hdrc_host_driver_init(void);</span>
 
 #else
 
<span class="p_chunk">@@ -18,6 +19,11 @@</span> <span class="p_context"> static inline void ci_hdrc_host_destroy(struct ci_hdrc *ci)</span>
 
 }
 
<span class="p_add">+static void ci_hdrc_host_driver_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif
 
 #endif /* __DRIVERS_USB_CHIPIDEA_HOST_H */
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_uac2.c b/drivers/usb/gadget/function/f_uac2.c</span>
<span class="p_header">index 6d3eb8b00a48..531861547253 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_uac2.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_uac2.c</span>
<span class="p_chunk">@@ -1162,14 +1162,14 @@</span> <span class="p_context"> afunc_set_alt(struct usb_function *fn, unsigned intf, unsigned alt)</span>
 			factor = 1000;
 		} else {
 			ep_desc = &amp;hs_epin_desc;
<span class="p_del">-			factor = 125;</span>
<span class="p_add">+			factor = 8000;</span>
 		}
 
 		/* pre-compute some values for iso_complete() */
 		uac2-&gt;p_framesize = opts-&gt;p_ssize *
 				    num_channels(opts-&gt;p_chmask);
 		rate = opts-&gt;p_srate * uac2-&gt;p_framesize;
<span class="p_del">-		uac2-&gt;p_interval = (1 &lt;&lt; (ep_desc-&gt;bInterval - 1)) * factor;</span>
<span class="p_add">+		uac2-&gt;p_interval = factor / (1 &lt;&lt; (ep_desc-&gt;bInterval - 1));</span>
 		uac2-&gt;p_pktsize = min_t(unsigned int, rate / uac2-&gt;p_interval,
 					prm-&gt;max_psize);
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/udc-core.c b/drivers/usb/gadget/udc/udc-core.c</span>
<span class="p_header">index d69c35558f68..7d69931cf45d 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/udc-core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/udc-core.c</span>
<span class="p_chunk">@@ -321,6 +321,7 @@</span> <span class="p_context"> err4:</span>
 
 err3:
 	put_device(&amp;udc-&gt;dev);
<span class="p_add">+	device_del(&amp;gadget-&gt;dev);</span>
 
 err2:
 	put_device(&amp;gadget-&gt;dev);
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 3e442f77a2b9..9a8c936cd42c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1792,7 +1792,8 @@</span> <span class="p_context"> void xhci_mem_cleanup(struct xhci_hcd *xhci)</span>
 	int size;
 	int i, j, num_ports;
 
<span class="p_del">-	del_timer_sync(&amp;xhci-&gt;cmd_timer);</span>
<span class="p_add">+	if (timer_pending(&amp;xhci-&gt;cmd_timer))</span>
<span class="p_add">+		del_timer_sync(&amp;xhci-&gt;cmd_timer);</span>
 
 	/* Free the Event Ring Segment Table and the actual Event Ring */
 	size = sizeof(struct xhci_erst_entry)*(xhci-&gt;erst.num_entries);
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index d095677a0702..b3a0a2275f5a 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg,</span>
 		return 0;
 	/* offset in TRBs */
 	segment_offset = trb - seg-&gt;trbs;
<span class="p_del">-	if (segment_offset &gt; TRBS_PER_SEGMENT)</span>
<span class="p_add">+	if (segment_offset &gt;= TRBS_PER_SEGMENT)</span>
 		return 0;
 	return seg-&gt;dma + (segment_offset * sizeof(*trb));
 }
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 19b85ee98a72..876423b8892c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -1099,6 +1099,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000)}, /* SIMCom SIM5218 */
 	{ USB_DEVICE_INTERFACE_CLASS(SIERRA_VENDOR_ID, 0x68c0, 0xff),
 	  .driver_info = (kernel_ulong_t)&amp;sierra_mc73xx_blacklist }, /* MC73xx */
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(SIERRA_VENDOR_ID, 0x9041, 0xff),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;sierra_mc73xx_blacklist }, /* MC7305/MC7355 */</span>
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_CMU_300) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6003),
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 9c63897b3a56..d156545728c2 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -145,7 +145,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x1199, 0x901c)},	/* Sierra Wireless EM7700 */
 	{DEVICE_SWI(0x1199, 0x901f)},	/* Sierra Wireless EM7355 */
 	{DEVICE_SWI(0x1199, 0x9040)},	/* Sierra Wireless Modem */
<span class="p_del">-	{DEVICE_SWI(0x1199, 0x9041)},	/* Sierra Wireless MC7305/MC7355 */</span>
 	{DEVICE_SWI(0x1199, 0x9051)},	/* Netgear AirCard 340U */
 	{DEVICE_SWI(0x1199, 0x9053)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9054)},	/* Sierra Wireless Modem */
<span class="p_chunk">@@ -158,6 +157,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x413c, 0x81a4)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a8)},	/* Dell Wireless 5808 Gobi(TM) 4G LTE Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a9)},	/* Dell Wireless 5808e Gobi(TM) 4G LTE Mobile Broadband Card */
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81b1)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card */</span>
 
 	/* Huawei devices */
 	{DEVICE_HWI(0x03f0, 0x581d)},	/* HP lt4112 LTE/HSPA+ Gobi 4G Modem (Huawei me906e) */
<span class="p_header">diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c</span>
<span class="p_header">index 46179a0828eb..07d1ecd564f7 100644</span>
<span class="p_header">--- a/drivers/usb/serial/sierra.c</span>
<span class="p_header">+++ b/drivers/usb/serial/sierra.c</span>
<span class="p_chunk">@@ -289,6 +289,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x68AA, 0xFF, 0xFF, 0xFF),
 	  .driver_info = (kernel_ulong_t)&amp;direct_ip_interface_blacklist
 	},
<span class="p_add">+	{ USB_DEVICE(0x1199, 0x68AB) }, /* Sierra Wireless AR8550 */</span>
 	/* AT&amp;T Direct IP LTE modems */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x0F3D, 0x68AA, 0xFF, 0xFF, 0xFF),
 	  .driver_info = (kernel_ulong_t)&amp;direct_ip_interface_blacklist
<span class="p_header">diff --git a/drivers/xen/gntdev.c b/drivers/xen/gntdev.c</span>
<span class="p_header">index 89274850741b..4bd23bba816f 100644</span>
<span class="p_header">--- a/drivers/xen/gntdev.c</span>
<span class="p_header">+++ b/drivers/xen/gntdev.c</span>
<span class="p_chunk">@@ -568,12 +568,14 @@</span> <span class="p_context"> static int gntdev_release(struct inode *inode, struct file *flip)</span>
 
 	pr_debug(&quot;priv %p\n&quot;, priv);
 
<span class="p_add">+	mutex_lock(&amp;priv-&gt;lock);</span>
 	while (!list_empty(&amp;priv-&gt;maps)) {
 		map = list_entry(priv-&gt;maps.next, struct grant_map, next);
 		list_del(&amp;map-&gt;next);
 		gntdev_put_map(NULL /* already removed */, map);
 	}
 	WARN_ON(!list_empty(&amp;priv-&gt;freeable_maps));
<span class="p_add">+	mutex_unlock(&amp;priv-&gt;lock);</span>
 
 	if (use_ptemod)
 		mmu_notifier_unregister(&amp;priv-&gt;mn, priv-&gt;mm);
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index 039f9c8a95e8..6e13504f736e 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -4397,9 +4397,9 @@</span> <span class="p_context"> laundromat_main(struct work_struct *laundry)</span>
 	queue_delayed_work(laundry_wq, &amp;nn-&gt;laundromat_work, t*HZ);
 }
 
<span class="p_del">-static inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_ol_stateid *stp)</span>
<span class="p_add">+static inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stid *stp)</span>
 {
<span class="p_del">-	if (!fh_match(&amp;fhp-&gt;fh_handle, &amp;stp-&gt;st_stid.sc_file-&gt;fi_fhandle))</span>
<span class="p_add">+	if (!fh_match(&amp;fhp-&gt;fh_handle, &amp;stp-&gt;sc_file-&gt;fi_fhandle))</span>
 		return nfserr_bad_stateid;
 	return nfs_ok;
 }
<span class="p_chunk">@@ -4574,20 +4574,48 @@</span> <span class="p_context"> nfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,</span>
 	return nfs_ok;
 }
 
<span class="p_add">+static struct file *</span>
<span class="p_add">+nfs4_find_file(struct nfs4_stid *s, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (s-&gt;sc_type) {</span>
<span class="p_add">+	case NFS4_DELEG_STID:</span>
<span class="p_add">+		if (WARN_ON_ONCE(!s-&gt;sc_file-&gt;fi_deleg_file))</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+		return get_file(s-&gt;sc_file-&gt;fi_deleg_file);</span>
<span class="p_add">+	case NFS4_OPEN_STID:</span>
<span class="p_add">+	case NFS4_LOCK_STID:</span>
<span class="p_add">+		if (flags &amp; RD_STATE)</span>
<span class="p_add">+			return find_readable_file(s-&gt;sc_file);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return find_writeable_file(s-&gt;sc_file);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static __be32</span>
<span class="p_add">+nfs4_check_olstateid(struct svc_fh *fhp, struct nfs4_ol_stateid *ols, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__be32 status;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = nfsd4_check_openowner_confirmed(ols);</span>
<span class="p_add">+	if (status)</span>
<span class="p_add">+		return status;</span>
<span class="p_add">+	return nfs4_check_openmode(ols, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
<span class="p_del">-* Checks for stateid operations</span>
<span class="p_del">-*/</span>
<span class="p_add">+ * Checks for stateid operations</span>
<span class="p_add">+ */</span>
 __be32
 nfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,
 			   stateid_t *stateid, int flags, struct file **filpp)
 {
<span class="p_del">-	struct nfs4_stid *s;</span>
<span class="p_del">-	struct nfs4_ol_stateid *stp = NULL;</span>
<span class="p_del">-	struct nfs4_delegation *dp = NULL;</span>
<span class="p_del">-	struct svc_fh *current_fh = &amp;cstate-&gt;current_fh;</span>
<span class="p_del">-	struct inode *ino = d_inode(current_fh-&gt;fh_dentry);</span>
<span class="p_add">+	struct svc_fh *fhp = &amp;cstate-&gt;current_fh;</span>
<span class="p_add">+	struct inode *ino = d_inode(fhp-&gt;fh_dentry);</span>
 	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
<span class="p_del">-	struct file *file = NULL;</span>
<span class="p_add">+	struct nfs4_stid *s;</span>
 	__be32 status;
 
 	if (filpp)
<span class="p_chunk">@@ -4597,60 +4625,39 @@</span> <span class="p_context"> nfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,</span>
 		return nfserr_grace;
 
 	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid))
<span class="p_del">-		return check_special_stateids(net, current_fh, stateid, flags);</span>
<span class="p_add">+		return check_special_stateids(net, fhp, stateid, flags);</span>
 
 	status = nfsd4_lookup_stateid(cstate, stateid,
 				NFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,
 				&amp;s, nn);
 	if (status)
 		return status;
<span class="p_del">-	status = check_stateid_generation(stateid, &amp;s-&gt;sc_stateid, nfsd4_has_session(cstate));</span>
<span class="p_add">+	status = check_stateid_generation(stateid, &amp;s-&gt;sc_stateid,</span>
<span class="p_add">+			nfsd4_has_session(cstate));</span>
 	if (status)
 		goto out;
<span class="p_add">+</span>
 	switch (s-&gt;sc_type) {
 	case NFS4_DELEG_STID:
<span class="p_del">-		dp = delegstateid(s);</span>
<span class="p_del">-		status = nfs4_check_delegmode(dp, flags);</span>
<span class="p_del">-		if (status)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		if (filpp) {</span>
<span class="p_del">-			file = dp-&gt;dl_stid.sc_file-&gt;fi_deleg_file;</span>
<span class="p_del">-			if (!file) {</span>
<span class="p_del">-				WARN_ON_ONCE(1);</span>
<span class="p_del">-				status = nfserr_serverfault;</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			get_file(file);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		status = nfs4_check_delegmode(delegstateid(s), flags);</span>
 		break;
 	case NFS4_OPEN_STID:
 	case NFS4_LOCK_STID:
<span class="p_del">-		stp = openlockstateid(s);</span>
<span class="p_del">-		status = nfs4_check_fh(current_fh, stp);</span>
<span class="p_del">-		if (status)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		status = nfsd4_check_openowner_confirmed(stp);</span>
<span class="p_del">-		if (status)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		status = nfs4_check_openmode(stp, flags);</span>
<span class="p_del">-		if (status)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		if (filpp) {</span>
<span class="p_del">-			struct nfs4_file *fp = stp-&gt;st_stid.sc_file;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (flags &amp; RD_STATE)</span>
<span class="p_del">-				file = find_readable_file(fp);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				file = find_writeable_file(fp);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		status = nfs4_check_olstateid(fhp, openlockstateid(s), flags);</span>
 		break;
 	default:
 		status = nfserr_bad_stateid;
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (status)</span>
 		goto out;
<span class="p_add">+	status = nfs4_check_fh(fhp, s);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!status &amp;&amp; filpp) {</span>
<span class="p_add">+		*filpp = nfs4_find_file(s, flags);</span>
<span class="p_add">+		if (!*filpp)</span>
<span class="p_add">+			status = nfserr_serverfault;</span>
 	}
<span class="p_del">-	status = nfs_ok;</span>
<span class="p_del">-	if (file)</span>
<span class="p_del">-		*filpp = file;</span>
 out:
 	nfs4_put_stid(s);
 	return status;
<span class="p_chunk">@@ -4754,7 +4761,7 @@</span> <span class="p_context"> static __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_</span>
 	status = check_stateid_generation(stateid, &amp;stp-&gt;st_stid.sc_stateid, nfsd4_has_session(cstate));
 	if (status)
 		return status;
<span class="p_del">-	return nfs4_check_fh(current_fh, stp);</span>
<span class="p_add">+	return nfs4_check_fh(current_fh, &amp;stp-&gt;st_stid);</span>
 }
 
 /* 
<span class="p_header">diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">index 158badf945df..d4d84451e0e6 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4xdr.c</span>
<span class="p_chunk">@@ -2142,6 +2142,7 @@</span> <span class="p_context"> nfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,</span>
 #define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \
 			      FATTR4_WORD0_RDATTR_ERROR)
 #define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID
<span class="p_add">+#define WORD2_ABSENT_FS_ATTRS 0</span>
 
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
 static inline __be32
<span class="p_chunk">@@ -2170,7 +2171,7 @@</span> <span class="p_context"> nfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,</span>
 { return 0; }
 #endif
 
<span class="p_del">-static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *rdattr_err)</span>
<span class="p_add">+static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *bmval2, u32 *rdattr_err)</span>
 {
 	/* As per referral draft:  */
 	if (*bmval0 &amp; ~WORD0_ABSENT_FS_ATTRS ||
<span class="p_chunk">@@ -2183,6 +2184,7 @@</span> <span class="p_context"> static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *rdattr_err)</span>
 	}
 	*bmval0 &amp;= WORD0_ABSENT_FS_ATTRS;
 	*bmval1 &amp;= WORD1_ABSENT_FS_ATTRS;
<span class="p_add">+	*bmval2 &amp;= WORD2_ABSENT_FS_ATTRS;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2246,8 +2248,7 @@</span> <span class="p_context"> nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,</span>
 	BUG_ON(bmval2 &amp; ~nfsd_suppattrs2(minorversion));
 
 	if (exp-&gt;ex_fslocs.migrated) {
<span class="p_del">-		BUG_ON(bmval[2]);</span>
<span class="p_del">-		status = fattr_handle_absent_fs(&amp;bmval0, &amp;bmval1, &amp;rdattr_err);</span>
<span class="p_add">+		status = fattr_handle_absent_fs(&amp;bmval0, &amp;bmval1, &amp;bmval2, &amp;rdattr_err);</span>
 		if (status)
 			goto out;
 	}
<span class="p_chunk">@@ -2290,8 +2291,8 @@</span> <span class="p_context"> nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,</span>
 	}
 
 #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
<span class="p_del">-	if ((bmval[2] &amp; FATTR4_WORD2_SECURITY_LABEL) ||</span>
<span class="p_del">-			bmval[0] &amp; FATTR4_WORD0_SUPPORTED_ATTRS) {</span>
<span class="p_add">+	if ((bmval2 &amp; FATTR4_WORD2_SECURITY_LABEL) ||</span>
<span class="p_add">+	     bmval0 &amp; FATTR4_WORD0_SUPPORTED_ATTRS) {</span>
 		err = security_inode_getsecctx(d_inode(dentry),
 						&amp;context, &amp;contextlen);
 		contextsupport = (err == 0);
<span class="p_header">diff --git a/fs/notify/mark.c b/fs/notify/mark.c</span>
<span class="p_header">index 92e48c70f0f0..39ddcaf0918f 100644</span>
<span class="p_header">--- a/fs/notify/mark.c</span>
<span class="p_header">+++ b/fs/notify/mark.c</span>
<span class="p_chunk">@@ -412,16 +412,36 @@</span> <span class="p_context"> void fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group,</span>
 					 unsigned int flags)
 {
 	struct fsnotify_mark *lmark, *mark;
<span class="p_add">+	LIST_HEAD(to_free);</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We have to be really careful here. Anytime we drop mark_mutex, e.g.</span>
<span class="p_add">+	 * fsnotify_clear_marks_by_inode() can come and free marks. Even in our</span>
<span class="p_add">+	 * to_free list so we have to use mark_mutex even when accessing that</span>
<span class="p_add">+	 * list. And freeing mark requires us to drop mark_mutex. So we can</span>
<span class="p_add">+	 * reliably free only the first mark in the list. That&#39;s why we first</span>
<span class="p_add">+	 * move marks to free to to_free list in one go and then free marks in</span>
<span class="p_add">+	 * to_free list one by one.</span>
<span class="p_add">+	 */</span>
 	mutex_lock_nested(&amp;group-&gt;mark_mutex, SINGLE_DEPTH_NESTING);
 	list_for_each_entry_safe(mark, lmark, &amp;group-&gt;marks_list, g_list) {
<span class="p_del">-		if (mark-&gt;flags &amp; flags) {</span>
<span class="p_del">-			fsnotify_get_mark(mark);</span>
<span class="p_del">-			fsnotify_destroy_mark_locked(mark, group);</span>
<span class="p_del">-			fsnotify_put_mark(mark);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (mark-&gt;flags &amp; flags)</span>
<span class="p_add">+			list_move(&amp;mark-&gt;g_list, &amp;to_free);</span>
 	}
 	mutex_unlock(&amp;group-&gt;mark_mutex);
<span class="p_add">+</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+		mutex_lock_nested(&amp;group-&gt;mark_mutex, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+		if (list_empty(&amp;to_free)) {</span>
<span class="p_add">+			mutex_unlock(&amp;group-&gt;mark_mutex);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mark = list_first_entry(&amp;to_free, struct fsnotify_mark, g_list);</span>
<span class="p_add">+		fsnotify_get_mark(mark);</span>
<span class="p_add">+		fsnotify_destroy_mark_locked(mark, group);</span>
<span class="p_add">+		mutex_unlock(&amp;group-&gt;mark_mutex);</span>
<span class="p_add">+		fsnotify_put_mark(mark);</span>
<span class="p_add">+	}</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/ocfs2/aops.c b/fs/ocfs2/aops.c</span>
<span class="p_header">index f906a250da6a..9ea70127074d 100644</span>
<span class="p_header">--- a/fs/ocfs2/aops.c</span>
<span class="p_header">+++ b/fs/ocfs2/aops.c</span>
<span class="p_chunk">@@ -686,7 +686,7 @@</span> <span class="p_context"> static int ocfs2_direct_IO_zero_extend(struct ocfs2_super *osb,</span>
 
 	if (p_cpos &amp;&amp; !(ext_flags &amp; OCFS2_EXT_UNWRITTEN)) {
 		u64 s = i_size_read(inode);
<span class="p_del">-		sector_t sector = (p_cpos &lt;&lt; (osb-&gt;s_clustersize_bits - 9)) +</span>
<span class="p_add">+		sector_t sector = ((u64)p_cpos &lt;&lt; (osb-&gt;s_clustersize_bits - 9)) +</span>
 			(do_div(s, osb-&gt;s_clustersize) &gt;&gt; 9);
 
 		ret = blkdev_issue_zeroout(osb-&gt;sb-&gt;s_bdev, sector,
<span class="p_chunk">@@ -911,7 +911,7 @@</span> <span class="p_context"> static ssize_t ocfs2_direct_IO_write(struct kiocb *iocb,</span>
 		BUG_ON(!p_cpos || (ext_flags &amp; OCFS2_EXT_UNWRITTEN));
 
 		ret = blkdev_issue_zeroout(osb-&gt;sb-&gt;s_bdev,
<span class="p_del">-				p_cpos &lt;&lt; (osb-&gt;s_clustersize_bits - 9),</span>
<span class="p_add">+				(u64)p_cpos &lt;&lt; (osb-&gt;s_clustersize_bits - 9),</span>
 				zero_len_head &gt;&gt; 9, GFP_NOFS, false);
 		if (ret &lt; 0)
 			mlog_errno(ret);
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index 8b23aa2f52dd..23157e40dd74 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -4025,9 +4025,13 @@</span> <span class="p_context"> static void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)</span>
 	osb-&gt;dc_work_sequence = osb-&gt;dc_wake_sequence;
 
 	processed = osb-&gt;blocked_lock_count;
<span class="p_del">-	while (processed) {</span>
<span class="p_del">-		BUG_ON(list_empty(&amp;osb-&gt;blocked_lock_list));</span>
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * blocked lock processing in this loop might call iput which can</span>
<span class="p_add">+	 * remove items off osb-&gt;blocked_lock_list. Downconvert up to</span>
<span class="p_add">+	 * &#39;processed&#39; number of locks, but stop short if we had some</span>
<span class="p_add">+	 * removed in ocfs2_mark_lockres_freeing when downconverting.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (processed &amp;&amp; !list_empty(&amp;osb-&gt;blocked_lock_list)) {</span>
 		lockres = list_entry(osb-&gt;blocked_lock_list.next,
 				     struct ocfs2_lock_res, l_blocked_list);
 		list_del_init(&amp;lockres-&gt;l_blocked_list);
<span class="p_header">diff --git a/fs/signalfd.c b/fs/signalfd.c</span>
<span class="p_header">index 7e412ad74836..270221fcef42 100644</span>
<span class="p_header">--- a/fs/signalfd.c</span>
<span class="p_header">+++ b/fs/signalfd.c</span>
<span class="p_chunk">@@ -121,8 +121,9 @@</span> <span class="p_context"> static int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,</span>
 		 * Other callers might not initialize the si_lsb field,
 		 * so check explicitly for the right codes here.
 		 */
<span class="p_del">-		if (kinfo-&gt;si_code == BUS_MCEERR_AR ||</span>
<span class="p_del">-		    kinfo-&gt;si_code == BUS_MCEERR_AO)</span>
<span class="p_add">+		if (kinfo-&gt;si_signo == SIGBUS &amp;&amp;</span>
<span class="p_add">+		    (kinfo-&gt;si_code == BUS_MCEERR_AR ||</span>
<span class="p_add">+		     kinfo-&gt;si_code == BUS_MCEERR_AO))</span>
 			err |= __put_user((short) kinfo-&gt;si_addr_lsb,
 					  &amp;uinfo-&gt;ssi_addr_lsb);
 #endif
<span class="p_header">diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h</span>
<span class="p_header">index 3d4ea7eb2b68..12b75f3ba0a0 100644</span>
<span class="p_header">--- a/include/linux/mtd/nand.h</span>
<span class="p_header">+++ b/include/linux/mtd/nand.h</span>
<span class="p_chunk">@@ -176,17 +176,17 @@</span> <span class="p_context"> typedef enum {</span>
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00040000
 /*
<span class="p_del">- * This option could be defined by controller drivers to protect against</span>
<span class="p_del">- * kmap&#39;ed, vmalloc&#39;ed highmem buffers being passed from upper layers</span>
<span class="p_del">- */</span>
<span class="p_del">-#define NAND_USE_BOUNCE_BUFFER	0x00080000</span>
<span class="p_del">-/*</span>
  * Autodetect nand buswidth with readid/onfi.
  * This suppose the driver will configure the hardware in 8 bits mode
  * when calling nand_scan_ident, and update its configuration
  * before calling nand_scan_tail.
  */
 #define NAND_BUSWIDTH_AUTO      0x00080000
<span class="p_add">+/*</span>
<span class="p_add">+ * This option could be defined by controller drivers to protect against</span>
<span class="p_add">+ * kmap&#39;ed, vmalloc&#39;ed highmem buffers being passed from upper layers</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define NAND_USE_BOUNCE_BUFFER	0x00100000</span>
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
<span class="p_header">diff --git a/include/uapi/linux/pci_regs.h b/include/uapi/linux/pci_regs.h</span>
<span class="p_header">index efe3443572ba..413417f3707b 100644</span>
<span class="p_header">--- a/include/uapi/linux/pci_regs.h</span>
<span class="p_header">+++ b/include/uapi/linux/pci_regs.h</span>
<span class="p_chunk">@@ -319,6 +319,7 @@</span> <span class="p_context"></span>
 #define PCI_MSIX_PBA		8	/* Pending Bit Array offset */
 #define  PCI_MSIX_PBA_BIR	0x00000007 /* BAR index */
 #define  PCI_MSIX_PBA_OFFSET	0xfffffff8 /* Offset into specified BAR */
<span class="p_add">+#define PCI_MSIX_FLAGS_BIRMASK	PCI_MSIX_PBA_BIR /* deprecated */</span>
 #define PCI_CAP_MSIX_SIZEOF	12	/* size of MSIX registers */
 
 /* MSI-X Table entry format */
<span class="p_header">diff --git a/ipc/mqueue.c b/ipc/mqueue.c</span>
<span class="p_header">index 3aaea7ffd077..c3fc5c2b63f3 100644</span>
<span class="p_header">--- a/ipc/mqueue.c</span>
<span class="p_header">+++ b/ipc/mqueue.c</span>
<span class="p_chunk">@@ -143,7 +143,6 @@</span> <span class="p_context"> static int msg_insert(struct msg_msg *msg, struct mqueue_inode_info *info)</span>
 		if (!leaf)
 			return -ENOMEM;
 		INIT_LIST_HEAD(&amp;leaf-&gt;msg_list);
<span class="p_del">-		info-&gt;qsize += sizeof(*leaf);</span>
 	}
 	leaf-&gt;priority = msg-&gt;m_type;
 	rb_link_node(&amp;leaf-&gt;rb_node, parent, p);
<span class="p_chunk">@@ -188,7 +187,6 @@</span> <span class="p_context"> try_again:</span>
 			     &quot;lazy leaf delete!\n&quot;);
 		rb_erase(&amp;leaf-&gt;rb_node, &amp;info-&gt;msg_tree);
 		if (info-&gt;node_cache) {
<span class="p_del">-			info-&gt;qsize -= sizeof(*leaf);</span>
 			kfree(leaf);
 		} else {
 			info-&gt;node_cache = leaf;
<span class="p_chunk">@@ -201,7 +199,6 @@</span> <span class="p_context"> try_again:</span>
 		if (list_empty(&amp;leaf-&gt;msg_list)) {
 			rb_erase(&amp;leaf-&gt;rb_node, &amp;info-&gt;msg_tree);
 			if (info-&gt;node_cache) {
<span class="p_del">-				info-&gt;qsize -= sizeof(*leaf);</span>
 				kfree(leaf);
 			} else {
 				info-&gt;node_cache = leaf;
<span class="p_chunk">@@ -1026,7 +1023,6 @@</span> <span class="p_context"> SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqdes, const char __user *, u_msg_ptr,</span>
 		/* Save our speculative allocation into the cache */
 		INIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);
 		info-&gt;node_cache = new_leaf;
<span class="p_del">-		info-&gt;qsize += sizeof(*new_leaf);</span>
 		new_leaf = NULL;
 	} else {
 		kfree(new_leaf);
<span class="p_chunk">@@ -1133,7 +1129,6 @@</span> <span class="p_context"> SYSCALL_DEFINE5(mq_timedreceive, mqd_t, mqdes, char __user *, u_msg_ptr,</span>
 		/* Save our speculative allocation into the cache */
 		INIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);
 		info-&gt;node_cache = new_leaf;
<span class="p_del">-		info-&gt;qsize += sizeof(*new_leaf);</span>
 	} else {
 		kfree(new_leaf);
 	}
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index d51c5ddd855c..0206be728dac 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -2753,12 +2753,15 @@</span> <span class="p_context"> int copy_siginfo_to_user(siginfo_t __user *to, const siginfo_t *from)</span>
 		 * Other callers might not initialize the si_lsb field,
 		 * so check explicitly for the right codes here.
 		 */
<span class="p_del">-		if (from-&gt;si_code == BUS_MCEERR_AR || from-&gt;si_code == BUS_MCEERR_AO)</span>
<span class="p_add">+		if (from-&gt;si_signo == SIGBUS &amp;&amp;</span>
<span class="p_add">+		    (from-&gt;si_code == BUS_MCEERR_AR || from-&gt;si_code == BUS_MCEERR_AO))</span>
 			err |= __put_user(from-&gt;si_addr_lsb, &amp;to-&gt;si_addr_lsb);
 #endif
 #ifdef SEGV_BNDERR
<span class="p_del">-		err |= __put_user(from-&gt;si_lower, &amp;to-&gt;si_lower);</span>
<span class="p_del">-		err |= __put_user(from-&gt;si_upper, &amp;to-&gt;si_upper);</span>
<span class="p_add">+		if (from-&gt;si_signo == SIGSEGV &amp;&amp; from-&gt;si_code == SEGV_BNDERR) {</span>
<span class="p_add">+			err |= __put_user(from-&gt;si_lower, &amp;to-&gt;si_lower);</span>
<span class="p_add">+			err |= __put_user(from-&gt;si_upper, &amp;to-&gt;si_upper);</span>
<span class="p_add">+		}</span>
 #endif
 		break;
 	case __SI_CHLD:
<span class="p_chunk">@@ -3022,7 +3025,7 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE3(rt_sigqueueinfo,</span>
 			int, sig,
 			struct compat_siginfo __user *, uinfo)
 {
<span class="p_del">-	siginfo_t info;</span>
<span class="p_add">+	siginfo_t info = {};</span>
 	int ret = copy_siginfo_from_user32(&amp;info, uinfo);
 	if (unlikely(ret))
 		return ret;
<span class="p_chunk">@@ -3066,7 +3069,7 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE4(rt_tgsigqueueinfo,</span>
 			int, sig,
 			struct compat_siginfo __user *, uinfo)
 {
<span class="p_del">-	siginfo_t info;</span>
<span class="p_add">+	siginfo_t info = {};</span>
 
 	if (copy_siginfo_from_user32(&amp;info, uinfo))
 		return -EFAULT;
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index 5e8eadd71bac..0d024fc8aa8e 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -937,21 +937,17 @@</span> <span class="p_context"> static unsigned long shrink_page_list(struct list_head *page_list,</span>
 		 *
 		 * 2) Global reclaim encounters a page, memcg encounters a
 		 *    page that is not marked for immediate reclaim or
<span class="p_del">-		 *    the caller does not have __GFP_IO. In this case mark</span>
<span class="p_add">+		 *    the caller does not have __GFP_FS (or __GFP_IO if it&#39;s</span>
<span class="p_add">+		 *    simply going to swap, not to fs). In this case mark</span>
 		 *    the page for immediate reclaim and continue scanning.
 		 *
<span class="p_del">-		 *    __GFP_IO is checked  because a loop driver thread might</span>
<span class="p_add">+		 *    Require may_enter_fs because we would wait on fs, which</span>
<span class="p_add">+		 *    may not have submitted IO yet. And the loop driver might</span>
 		 *    enter reclaim, and deadlock if it waits on a page for
 		 *    which it is needed to do the write (loop masks off
 		 *    __GFP_IO|__GFP_FS for this reason); but more thought
 		 *    would probably show more reasons.
 		 *
<span class="p_del">-		 *    Don&#39;t require __GFP_FS, since we&#39;re not going into the</span>
<span class="p_del">-		 *    FS, just waiting on its writeback completion. Worryingly,</span>
<span class="p_del">-		 *    ext4 gfs2 and xfs allocate pages with</span>
<span class="p_del">-		 *    grab_cache_page_write_begin(,,AOP_FLAG_NOFS), so testing</span>
<span class="p_del">-		 *    may_enter_fs here is liable to OOM on them.</span>
<span class="p_del">-		 *</span>
 		 * 3) memcg encounters a page that is not already marked
 		 *    PageReclaim. memcg does not have any dirty pages
 		 *    throttling so we could easily OOM just because too many
<span class="p_chunk">@@ -968,7 +964,7 @@</span> <span class="p_context"> static unsigned long shrink_page_list(struct list_head *page_list,</span>
 
 			/* Case 2 above */
 			} else if (global_reclaim(sc) ||
<span class="p_del">-			    !PageReclaim(page) || !(sc-&gt;gfp_mask &amp; __GFP_IO)) {</span>
<span class="p_add">+			    !PageReclaim(page) || !may_enter_fs) {</span>
 				/*
 				 * This is slightly racy - end_page_writeback()
 				 * might have just cleared PageReclaim, then
<span class="p_header">diff --git a/net/bluetooth/smp.c b/net/bluetooth/smp.c</span>
<span class="p_header">index 1ab3dc9c8f99..7b815bcc8c9b 100644</span>
<span class="p_header">--- a/net/bluetooth/smp.c</span>
<span class="p_header">+++ b/net/bluetooth/smp.c</span>
<span class="p_chunk">@@ -2295,6 +2295,10 @@</span> <span class="p_context"> int smp_conn_security(struct hci_conn *hcon, __u8 sec_level)</span>
 		return 1;
 
 	chan = conn-&gt;smp;
<span class="p_add">+	if (!chan) {</span>
<span class="p_add">+		BT_ERR(&quot;SMP security requested but not available&quot;);</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
 
 	if (!hci_dev_test_flag(hcon-&gt;hdev, HCI_LE_ENABLED))
 		return 1;
<span class="p_header">diff --git a/sound/firewire/amdtp.c b/sound/firewire/amdtp.c</span>
<span class="p_header">index e061355f535f..bf20593d3085 100644</span>
<span class="p_header">--- a/sound/firewire/amdtp.c</span>
<span class="p_header">+++ b/sound/firewire/amdtp.c</span>
<span class="p_chunk">@@ -730,8 +730,9 @@</span> <span class="p_context"> static void handle_in_packet(struct amdtp_stream *s,</span>
 	    s-&gt;data_block_counter != UINT_MAX)
 		data_block_counter = s-&gt;data_block_counter;
 
<span class="p_del">-	if (((s-&gt;flags &amp; CIP_SKIP_DBC_ZERO_CHECK) &amp;&amp; data_block_counter == 0) ||</span>
<span class="p_del">-	    (s-&gt;data_block_counter == UINT_MAX)) {</span>
<span class="p_add">+	if (((s-&gt;flags &amp; CIP_SKIP_DBC_ZERO_CHECK) &amp;&amp;</span>
<span class="p_add">+	     data_block_counter == s-&gt;tx_first_dbc) ||</span>
<span class="p_add">+	    s-&gt;data_block_counter == UINT_MAX) {</span>
 		lost = false;
 	} else if (!(s-&gt;flags &amp; CIP_DBC_IS_END_EVENT)) {
 		lost = data_block_counter != s-&gt;data_block_counter;
<span class="p_header">diff --git a/sound/firewire/amdtp.h b/sound/firewire/amdtp.h</span>
<span class="p_header">index 8a03a91e728b..25c905537658 100644</span>
<span class="p_header">--- a/sound/firewire/amdtp.h</span>
<span class="p_header">+++ b/sound/firewire/amdtp.h</span>
<span class="p_chunk">@@ -153,6 +153,8 @@</span> <span class="p_context"> struct amdtp_stream {</span>
 
 	/* quirk: fixed interval of dbc between previos/current packets. */
 	unsigned int tx_dbc_interval;
<span class="p_add">+	/* quirk: indicate the value of dbc field in a first packet. */</span>
<span class="p_add">+	unsigned int tx_first_dbc;</span>
 
 	bool callbacked;
 	wait_queue_head_t callback_wait;
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c</span>
<span class="p_header">index 2682e7e3e5c9..c94a432f7cc6 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks.c</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks.c</span>
<span class="p_chunk">@@ -248,8 +248,16 @@</span> <span class="p_context"> efw_probe(struct fw_unit *unit,</span>
 	err = get_hardware_info(efw);
 	if (err &lt; 0)
 		goto error;
<span class="p_add">+	/* AudioFire8 (since 2009) and AudioFirePre8 */</span>
 	if (entry-&gt;model_id == MODEL_ECHO_AUDIOFIRE_9)
 		efw-&gt;is_af9 = true;
<span class="p_add">+	/* These models uses the same firmware. */</span>
<span class="p_add">+	if (entry-&gt;model_id == MODEL_ECHO_AUDIOFIRE_2 ||</span>
<span class="p_add">+	    entry-&gt;model_id == MODEL_ECHO_AUDIOFIRE_4 ||</span>
<span class="p_add">+	    entry-&gt;model_id == MODEL_ECHO_AUDIOFIRE_9 ||</span>
<span class="p_add">+	    entry-&gt;model_id == MODEL_GIBSON_RIP ||</span>
<span class="p_add">+	    entry-&gt;model_id == MODEL_GIBSON_GOLDTOP)</span>
<span class="p_add">+		efw-&gt;is_fireworks3 = true;</span>
 
 	snd_efw_proc_init(efw);
 
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks.h b/sound/firewire/fireworks/fireworks.h</span>
<span class="p_header">index 4f0201a95222..084d414b228c 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks.h</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks.h</span>
<span class="p_chunk">@@ -71,6 +71,7 @@</span> <span class="p_context"> struct snd_efw {</span>
 
 	/* for quirks */
 	bool is_af9;
<span class="p_add">+	bool is_fireworks3;</span>
 	u32 firmware_version;
 
 	unsigned int midi_in_ports;
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks_stream.c b/sound/firewire/fireworks/fireworks_stream.c</span>
<span class="p_header">index c55db1bddc80..7e353f1f7bff 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks_stream.c</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks_stream.c</span>
<span class="p_chunk">@@ -172,6 +172,15 @@</span> <span class="p_context"> int snd_efw_stream_init_duplex(struct snd_efw *efw)</span>
 	efw-&gt;tx_stream.flags |= CIP_DBC_IS_END_EVENT;
 	/* Fireworks reset dbc at bus reset. */
 	efw-&gt;tx_stream.flags |= CIP_SKIP_DBC_ZERO_CHECK;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * But Recent firmwares starts packets with non-zero dbc.</span>
<span class="p_add">+	 * Driver version 5.7.6 installs firmware version 5.7.3.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (efw-&gt;is_fireworks3 &amp;&amp;</span>
<span class="p_add">+	    (efw-&gt;firmware_version == 0x5070000 ||</span>
<span class="p_add">+	     efw-&gt;firmware_version == 0x5070300 ||</span>
<span class="p_add">+	     efw-&gt;firmware_version == 0x5080000))</span>
<span class="p_add">+		efw-&gt;tx_stream.tx_first_dbc = 0x02;</span>
 	/* AudioFire9 always reports wrong dbs. */
 	if (efw-&gt;is_af9)
 		efw-&gt;tx_stream.flags |= CIP_WRONG_DBS;
<span class="p_header">diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">index 50e9dd675579..3a24f7739aaa 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_chunk">@@ -1001,9 +1001,7 @@</span> <span class="p_context"> static void cs4210_spdif_automute(struct hda_codec *codec,</span>
 
 	spec-&gt;spdif_present = spdif_present;
 	/* SPDIF TX on/off */
<span class="p_del">-	if (spdif_present)</span>
<span class="p_del">-		snd_hda_set_pin_ctl(codec, spdif_pin,</span>
<span class="p_del">-				    spdif_present ? PIN_OUT : 0);</span>
<span class="p_add">+	snd_hda_set_pin_ctl(codec, spdif_pin, spdif_present ? PIN_OUT : 0);</span>
 
 	cs_automute(codec);
 }
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 590bcfb0e82f..1e99f075a5ab 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5118,6 +5118,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x06c7, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06d9, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06da, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06de, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
 	SND_PCI_QUIRK(0x1028, 0x164a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x164b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1586, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC2),
<span class="p_header">diff --git a/sound/soc/codecs/pcm1681.c b/sound/soc/codecs/pcm1681.c</span>
<span class="p_header">index 477e13d30971..e7ba557979cb 100644</span>
<span class="p_header">--- a/sound/soc/codecs/pcm1681.c</span>
<span class="p_header">+++ b/sound/soc/codecs/pcm1681.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static int pcm1681_set_deemph(struct snd_soc_codec *codec)</span>
 
 	if (val != -1) {
 		regmap_update_bits(priv-&gt;regmap, PCM1681_DEEMPH_CONTROL,
<span class="p_del">-					PCM1681_DEEMPH_RATE_MASK, val);</span>
<span class="p_add">+				   PCM1681_DEEMPH_RATE_MASK, val &lt;&lt; 3);</span>
 		enable = 1;
 	} else
 		enable = 0;
<span class="p_header">diff --git a/sound/soc/codecs/ssm4567.c b/sound/soc/codecs/ssm4567.c</span>
<span class="p_header">index a984485108cd..f7549cc7ea85 100644</span>
<span class="p_header">--- a/sound/soc/codecs/ssm4567.c</span>
<span class="p_header">+++ b/sound/soc/codecs/ssm4567.c</span>
<span class="p_chunk">@@ -315,7 +315,13 @@</span> <span class="p_context"> static int ssm4567_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)</span>
 	if (invert_fclk)
 		ctrl1 |= SSM4567_SAI_CTRL_1_FSYNC;
 
<span class="p_del">-	return regmap_write(ssm4567-&gt;regmap, SSM4567_REG_SAI_CTRL_1, ctrl1);</span>
<span class="p_add">+	return regmap_update_bits(ssm4567-&gt;regmap, SSM4567_REG_SAI_CTRL_1,</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_BCLK |</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_FSYNC |</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_LJ |</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_TDM |</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_PDM,</span>
<span class="p_add">+			ctrl1);</span>
 }
 
 static int ssm4567_set_power(struct ssm4567 *ssm4567, bool enable)
<span class="p_header">diff --git a/sound/soc/intel/atom/sst/sst_drv_interface.c b/sound/soc/intel/atom/sst/sst_drv_interface.c</span>
<span class="p_header">index 7b50a9d17ec1..edc186908358 100644</span>
<span class="p_header">--- a/sound/soc/intel/atom/sst/sst_drv_interface.c</span>
<span class="p_header">+++ b/sound/soc/intel/atom/sst/sst_drv_interface.c</span>
<span class="p_chunk">@@ -42,6 +42,11 @@</span> <span class="p_context"></span>
 #define MIN_FRAGMENT_SIZE (50 * 1024)
 #define MAX_FRAGMENT_SIZE (1024 * 1024)
 #define SST_GET_BYTES_PER_SAMPLE(pcm_wd_sz)  (((pcm_wd_sz + 15) &gt;&gt; 4) &lt;&lt; 1)
<span class="p_add">+#ifdef CONFIG_PM</span>
<span class="p_add">+#define GET_USAGE_COUNT(dev) (atomic_read(&amp;dev-&gt;power.usage_count))</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define GET_USAGE_COUNT(dev) 1</span>
<span class="p_add">+#endif</span>
 
 int free_stream_context(struct intel_sst_drv *ctx, unsigned int str_id)
 {
<span class="p_chunk">@@ -141,15 +146,9 @@</span> <span class="p_context"> static int sst_power_control(struct device *dev, bool state)</span>
 	int ret = 0;
 	int usage_count = 0;
 
<span class="p_del">-#ifdef CONFIG_PM</span>
<span class="p_del">-	usage_count = atomic_read(&amp;dev-&gt;power.usage_count);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	usage_count = 1;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	if (state == true) {
 		ret = pm_runtime_get_sync(dev);
<span class="p_del">-</span>
<span class="p_add">+		usage_count = GET_USAGE_COUNT(dev);</span>
 		dev_dbg(ctx-&gt;dev, &quot;Enable: pm usage count: %d\n&quot;, usage_count);
 		if (ret &lt; 0) {
 			dev_err(ctx-&gt;dev, &quot;Runtime get failed with err: %d\n&quot;, ret);
<span class="p_chunk">@@ -164,6 +163,7 @@</span> <span class="p_context"> static int sst_power_control(struct device *dev, bool state)</span>
 			}
 		}
 	} else {
<span class="p_add">+		usage_count = GET_USAGE_COUNT(dev);</span>
 		dev_dbg(ctx-&gt;dev, &quot;Disable: pm usage count: %d\n&quot;, usage_count);
 		return sst_pm_runtime_put(ctx);
 	}
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index 158204d08924..b6c12dccb259 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -1811,6 +1811,7 @@</span> <span class="p_context"> static ssize_t dapm_widget_power_read_file(struct file *file,</span>
 					   size_t count, loff_t *ppos)
 {
 	struct snd_soc_dapm_widget *w = file-&gt;private_data;
<span class="p_add">+	struct snd_soc_card *card = w-&gt;dapm-&gt;card;</span>
 	char *buf;
 	int in, out;
 	ssize_t ret;
<span class="p_chunk">@@ -1820,6 +1821,8 @@</span> <span class="p_context"> static ssize_t dapm_widget_power_read_file(struct file *file,</span>
 	if (!buf)
 		return -ENOMEM;
 
<span class="p_add">+	mutex_lock(&amp;card-&gt;dapm_mutex);</span>
<span class="p_add">+</span>
 	/* Supply widgets are not handled by is_connected_{input,output}_ep() */
 	if (w-&gt;is_supply) {
 		in = 0;
<span class="p_chunk">@@ -1866,6 +1869,8 @@</span> <span class="p_context"> static ssize_t dapm_widget_power_read_file(struct file *file,</span>
 					p-&gt;sink-&gt;name);
 	}
 
<span class="p_add">+	mutex_unlock(&amp;card-&gt;dapm_mutex);</span>
<span class="p_add">+</span>
 	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
 	kfree(buf);
<span class="p_chunk">@@ -2140,11 +2145,15 @@</span> <span class="p_context"> static ssize_t dapm_widget_show(struct device *dev,</span>
 	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
 	int i, count = 0;
 
<span class="p_add">+	mutex_lock(&amp;rtd-&gt;card-&gt;dapm_mutex);</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; rtd-&gt;num_codecs; i++) {
 		struct snd_soc_codec *codec = rtd-&gt;codec_dais[i]-&gt;codec;
 		count += dapm_widget_show_codec(codec, buf + count);
 	}
 
<span class="p_add">+	mutex_unlock(&amp;rtd-&gt;card-&gt;dapm_mutex);</span>
<span class="p_add">+</span>
 	return count;
 }
 
<span class="p_chunk">@@ -3100,16 +3109,10 @@</span> <span class="p_context"> snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,</span>
 	}
 
 	prefix = soc_dapm_prefix(dapm);
<span class="p_del">-	if (prefix) {</span>
<span class="p_add">+	if (prefix)</span>
 		w-&gt;name = kasprintf(GFP_KERNEL, &quot;%s %s&quot;, prefix, widget-&gt;name);
<span class="p_del">-		if (widget-&gt;sname)</span>
<span class="p_del">-			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s %s&quot;, prefix,</span>
<span class="p_del">-					     widget-&gt;sname);</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	else</span>
 		w-&gt;name = kasprintf(GFP_KERNEL, &quot;%s&quot;, widget-&gt;name);
<span class="p_del">-		if (widget-&gt;sname)</span>
<span class="p_del">-			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s&quot;, widget-&gt;sname);</span>
<span class="p_del">-	}</span>
 	if (w-&gt;name == NULL) {
 		kfree(w);
 		return NULL;
<span class="p_chunk">@@ -3557,7 +3560,7 @@</span> <span class="p_context"> int snd_soc_dapm_link_dai_widgets(struct snd_soc_card *card)</span>
 				break;
 			}
 
<span class="p_del">-			if (!w-&gt;sname || !strstr(w-&gt;sname, dai_w-&gt;name))</span>
<span class="p_add">+			if (!w-&gt;sname || !strstr(w-&gt;sname, dai_w-&gt;sname))</span>
 				continue;
 
 			if (dai_w-&gt;id == snd_soc_dapm_dai_in) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



