
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4] x86/power/64: Fix kernel text mapping corruption during image restoration - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4] x86/power/64: Fix kernel text mapping corruption during image restoration</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=68541">Rafael Wysocki</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 30, 2016, 1:17 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1735143.jkZ4XHok9E@vostro.rjw.lan&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9207497/mbox/"
   >mbox</a>
|
   <a href="/patch/9207497/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9207497/">/patch/9207497/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	3EFBD6075F for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Jun 2016 13:13:07 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2C5FC284BF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Jun 2016 13:13:07 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1F6AC285A4; Thu, 30 Jun 2016 13:13:07 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=unavailable version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4108C284BF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Jun 2016 13:13:04 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752161AbcF3NMz (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 30 Jun 2016 09:12:55 -0400
Received: from cloudserver094114.home.net.pl ([79.96.170.134]:57560 &quot;HELO
	cloudserver094114.home.net.pl&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with SMTP id S1751424AbcF3NMx (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 30 Jun 2016 09:12:53 -0400
Received: from 89-65-65-74.dynamic.chello.pl (89.65.65.74) (HELO
	vostro.rjw.lan)
	by serwer1319399.home.pl (79.96.170.134) with SMTP (IdeaSmtpServer
	v0.80.2) id b4db5be1296cd94a; Thu, 30 Jun 2016 15:12:50 +0200
From: &quot;Rafael J. Wysocki&quot; &lt;rjw@rjwysocki.net&gt;
To: Logan Gunthorpe &lt;logang@deltatee.com&gt;,
	Borislav Petkov &lt;bp@alien8.de&gt;
Cc: Kees Cook &lt;keescook@chromium.org&gt;,
	Linus Torvalds &lt;torvalds@linux-foundation.org&gt;,
	&quot;Rafael J. Wysocki&quot; &lt;rafael@kernel.org&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Ingo Molnar &lt;mingo@kernel.org&gt;,
	Peter Zijlstra &lt;peterz@infradead.org&gt;,
	lkml &lt;linux-kernel@vger.kernel.org&gt;,
	&quot;Rafael J. Wysocki&quot; &lt;rafael.j.wysocki@intel.com&gt;,
	Andy Lutomirski &lt;luto@kernel.org&gt;, Brian Gerst &lt;brgerst@gmail.com&gt;,
	Denys Vlasenko &lt;dvlasenk@redhat.com&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Linux PM list &lt;linux-pm@vger.kernel.org&gt;,
	Stephen Smalley &lt;sds@tycho.nsa.gov&gt;
Subject: [PATCH v4] x86/power/64: Fix kernel text mapping corruption during
	image restoration
Date: Thu, 30 Jun 2016 15:17:20 +0200
Message-ID: &lt;1735143.jkZ4XHok9E@vostro.rjw.lan&gt;
User-Agent: KMail/4.11.5 (Linux/4.5.0-rc1+; KDE/4.11.5; x86_64; ; )
In-Reply-To: &lt;1735047.Yzv12qmPPB@vostro.rjw.lan&gt;
References: &lt;20160617105435.GB15997@pd.tnic&gt;
	&lt;CAGXu5j+1_06mKVsV2BeBZtitRk8GtjMPH8_zAxocfxtp7NeLXg@mail.gmail.com&gt;
	&lt;1735047.Yzv12qmPPB@vostro.rjw.lan&gt;
MIME-Version: 1.0
Content-Transfer-Encoding: 7Bit
Content-Type: text/plain; charset=&quot;utf-8&quot;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=68541">Rafael Wysocki</a> - June 30, 2016, 1:17 p.m.</div>
<pre class="content">
<span class="from">From: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;</span>

Logan Gunthorpe reports that hibernation stopped working reliably for
him after commit ab76f7b4ab23 (x86/mm: Set NX on gap between __ex_table
and rodata).

That turns out to be a consequence of a long-standing issue with the
64-bit image restoration code on x86, which is that the temporary
page tables set up by it to avoid page tables corruption when the
last bits of the image kernel&#39;s memory contents are copied into
their original page frames re-use the boot kernel&#39;s text mapping,
but that mapping may very well get corrupted just like any other
part of the page tables.  Of course, if that happens, the final
jump to the image kernel&#39;s entry point will go to nowhere.

The exact reason why commit ab76f7b4ab23 matters here is that it
sometimes causes a PMD of a large page to be split into PTEs
that are allocated dynamically and get corrupted during image
restoration as described above.

To fix that issue note that the code copying the last bits of the
image kernel&#39;s memory contents to the page frames occupied by them
previoulsy doesn&#39;t use the kernel text mapping, because it runs from
a special page covered by the identity mapping set up for that code
from scratch.  Hence, the kernel text mapping is only needed before
that code starts to run and then it will only be used just for the
final jump to the image kernel&#39;s entry point.

Accordingly, the temporary page tables set up in swsusp_arch_resume()
on x86-64 need to contain the kernel text mapping too.  That mapping
is only going to be used for the final jump to the image kernel, so
it only needs to cover the image kernel&#39;s entry point, because the
first thing the image kernel does after getting control back is to
switch over to its own original page tables.  Moreover, the virtual
address of the image kernel&#39;s entry point in that mapping has to be
the same as the one mapped by the image kernel&#39;s page tables.

With that in mind, modify the x86-64&#39;s arch_hibernation_header_save()
and arch_hibernation_header_restore() routines to pass the physical
address of the image kernel&#39;s entry point (in addition to its virtual
address) to the boot kernel (a small piece of assembly code involved
in passing the entry point&#39;s virtual address to the image kernel is
not necessary any more after that, so drop it).  Update RESTORE_MAGIC
too to reflect the image header format change.

Next, in set_up_temporary_mappings(), use the physical and virtual
addresses of the image kernel&#39;s entry point passed in the image
header to set up a minimum kernel text mapping (using memory pages
that won&#39;t be overwritten by the image kernel&#39;s memory contents) that
will map those addresses to each other as appropriate.

This makes the concern about the possible corruption of the original
boot kernel text mapping go away and if the the minimum kernel text
mapping used for the final jump marks the image kernel&#39;s entry point
memory as executable, the jump to it is guaraneed to succeed.

Fixes: ab76f7b4ab23 (x86/mm: Set NX on gap between __ex_table and rodata)
Link: http://marc.info/?l=linux-pm&amp;m=146372852823760&amp;w=2
Reported-by: Logan Gunthorpe &lt;logang@deltatee.com&gt;
<span class="tested-by">Tested-by: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="signed-off-by">Signed-off-by: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;</span>
---

v3 -&gt; v4: The new relocate_restore_code() didn&#39;t cover the case when
  the page containing the relocated code was mapped via a huge (1G)
  page and it didn&#39;t clear the NX bit in that case, which led to the
  page fault reported by Logan at
  http://marc.info/?l=linux-kernel&amp;m=146725158621626&amp;w=4.
  Fix that by making relocate_restore_code() handle the huge page
  mapping case too.

I&#39;ve retained the Tested-by: from Kees as this change has nothing to do with
whether or not KASLR works with hibernation after this patch.

Logan, please test this one thoroughly.  I&#39;ll give it at least one week in
linux-next going forward.

Boris, please test it on the machine where we saw memory corruption with
the previous versions if poss.

Thanks,
Rafael

---
 arch/x86/power/hibernate_64.c     |   97 +++++++++++++++++++++++++++++++++-----
 arch/x86/power/hibernate_asm_64.S |   55 +++++++++------------
 2 files changed, 109 insertions(+), 43 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - June 30, 2016, 3:05 p.m.</div>
<pre class="content">
On Thu, Jun 30, 2016 at 03:17:20PM +0200, Rafael J. Wysocki wrote:
<span class="quote">&gt; From: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Logan Gunthorpe reports that hibernation stopped working reliably for</span>
<span class="quote">&gt; him after commit ab76f7b4ab23 (x86/mm: Set NX on gap between __ex_table</span>
<span class="quote">&gt; and rodata).</span>

...
<span class="quote">
&gt; +static int relocate_restore_code(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pgd_t *pgd;</span>
<span class="quote">&gt; +	pud_t *pud;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	relocated_restore_code = get_safe_page(GFP_ATOMIC);</span>
<span class="quote">&gt; +	if (!relocated_restore_code)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	memcpy((void *)relocated_restore_code, &amp;core_restore_code, PAGE_SIZE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Make the page containing the relocated code executable */</span>
<span class="quote">&gt; +	pgd = (pgd_t *)__va(read_cr3()) + pgd_index(relocated_restore_code);</span>
<span class="quote">&gt; +	pud = pud_offset(pgd, relocated_restore_code);</span>
<span class="quote">&gt; +	if (pud_large(*pud)) {</span>
<span class="quote">&gt; +		set_pud(pud, __pud(pud_val(*pud) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		pmd_t *pmd = pmd_offset(pud, relocated_restore_code);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (pmd_large(*pmd)) {</span>
<span class="quote">&gt; +			set_pmd(pmd, __pmd(pmd_val(*pmd) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt; +		} else {</span>
<span class="quote">&gt; +			pte_t *pte = pte_offset_kernel(pmd, relocated_restore_code);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	flush_tlb_all();</span>

I know you want to flush TLBs but this causes the splat below on the
resume kernel.

Most likely because:

resume_target_kernel() does local_irq_disable() and then

swsusp_arch_resume() -&gt; relocate_restore_code() -&gt; flush_tlb_all()

and smp_call_function_many() doesn&#39;t like it when IRQs are disabled.

[    7.613645] Disabling non-boot CPUs ...
[    7.902408] ------------[ cut here ]------------
[    7.907106] WARNING: CPU: 0 PID: 1 at kernel/smp.c:416 smp_call_function_many+0xb6/0x260
[    7.915319] Modules linked in:
[    7.918501] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.7.0-rc5+ #11
[    7.924931] Hardware name: To be filled by O.E.M. To be filled by O.E.M./M5A97 EVO R2.0, BIOS 1503 01/16/2013
[    7.934967]  0000000000000000 ffff88042b957cf8 ffffffff812ac1c3 0000000000000000
[    7.942664]  0000000000000000 ffff88042b957d38 ffffffff8105435d 000001a02b957d28
[    7.950369]  0000000000000000 0000000000000000 ffffffff8104d420 0000000000000000
[    7.958072] Call Trace:
[    7.960598]  [&lt;ffffffff812ac1c3&gt;] dump_stack+0x67/0x94
[    7.965815]  [&lt;ffffffff8105435d&gt;] __warn+0xdd/0x100
[    7.970771]  [&lt;ffffffff8104d420&gt;] ? leave_mm+0xc0/0xc0
[    7.975981]  [&lt;ffffffff8105444d&gt;] warn_slowpath_null+0x1d/0x20
[    7.981891]  [&lt;ffffffff810cb526&gt;] smp_call_function_many+0xb6/0x260
[    7.988236]  [&lt;ffffffff8104d420&gt;] ? leave_mm+0xc0/0xc0
[    7.993452]  [&lt;ffffffff810cb716&gt;] smp_call_function+0x46/0x80
[    7.999277]  [&lt;ffffffff8104d420&gt;] ? leave_mm+0xc0/0xc0
[    8.004494]  [&lt;ffffffff810cb78e&gt;] on_each_cpu+0x3e/0xa0
[    8.009790]  [&lt;ffffffff81098e00&gt;] ? hibernation_restore+0x130/0x130
[    8.016135]  [&lt;ffffffff8104debc&gt;] flush_tlb_all+0x1c/0x20
[    8.021613]  [&lt;ffffffff815bd8d4&gt;] swsusp_arch_resume+0x254/0x2b0
[    8.027696]  [&lt;ffffffff815bd660&gt;] ? restore_processor_state+0x2f0/0x2f0
[    8.034387]  [&lt;ffffffff81098d9d&gt;] hibernation_restore+0xcd/0x130
[    8.040464]  [&lt;ffffffff81112fbd&gt;] software_resume.part.6+0x1f9/0x25b
[    8.046894]  [&lt;ffffffff81098e26&gt;] software_resume+0x26/0x30
[    8.052545]  [&lt;ffffffff81000449&gt;] do_one_initcall+0x59/0x190
[    8.058282]  [&lt;ffffffff81071b3c&gt;] ? parse_args+0x26c/0x3f0
[    8.063867]  [&lt;ffffffff8168b000&gt;] ? _raw_read_unlock_irqrestore+0x30/0x60
[    8.070730]  [&lt;ffffffff81cd5002&gt;] kernel_init_freeable+0x118/0x19e
[    8.076986]  [&lt;ffffffff816851ae&gt;] kernel_init+0xe/0x100
[    8.082290]  [&lt;ffffffff8168b75f&gt;] ret_from_fork+0x1f/0x40
[    8.087768]  [&lt;ffffffff816851a0&gt;] ? rest_init+0x90/0x90
[    8.093073] ---[ end trace 6361ce069253f25c ]---
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=99561">Rafael J. Wysocki</a> - June 30, 2016, 3:17 p.m.</div>
<pre class="content">
On Thu, Jun 30, 2016 at 5:05 PM, Borislav Petkov &lt;bp@alien8.de&gt; wrote:
<span class="quote">&gt; On Thu, Jun 30, 2016 at 03:17:20PM +0200, Rafael J. Wysocki wrote:</span>
<span class="quote">&gt;&gt; From: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Logan Gunthorpe reports that hibernation stopped working reliably for</span>
<span class="quote">&gt;&gt; him after commit ab76f7b4ab23 (x86/mm: Set NX on gap between __ex_table</span>
<span class="quote">&gt;&gt; and rodata).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +static int relocate_restore_code(void)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +     pgd_t *pgd;</span>
<span class="quote">&gt;&gt; +     pud_t *pud;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     relocated_restore_code = get_safe_page(GFP_ATOMIC);</span>
<span class="quote">&gt;&gt; +     if (!relocated_restore_code)</span>
<span class="quote">&gt;&gt; +             return -ENOMEM;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     memcpy((void *)relocated_restore_code, &amp;core_restore_code, PAGE_SIZE);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     /* Make the page containing the relocated code executable */</span>
<span class="quote">&gt;&gt; +     pgd = (pgd_t *)__va(read_cr3()) + pgd_index(relocated_restore_code);</span>
<span class="quote">&gt;&gt; +     pud = pud_offset(pgd, relocated_restore_code);</span>
<span class="quote">&gt;&gt; +     if (pud_large(*pud)) {</span>
<span class="quote">&gt;&gt; +             set_pud(pud, __pud(pud_val(*pud) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt; +     } else {</span>
<span class="quote">&gt;&gt; +             pmd_t *pmd = pmd_offset(pud, relocated_restore_code);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +             if (pmd_large(*pmd)) {</span>
<span class="quote">&gt;&gt; +                     set_pmd(pmd, __pmd(pmd_val(*pmd) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt; +             } else {</span>
<span class="quote">&gt;&gt; +                     pte_t *pte = pte_offset_kernel(pmd, relocated_restore_code);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +                     set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt; +             }</span>
<span class="quote">&gt;&gt; +     }</span>
<span class="quote">&gt;&gt; +     flush_tlb_all();</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I know you want to flush TLBs but this causes the splat below on the</span>
<span class="quote">&gt; resume kernel.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Most likely because:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; resume_target_kernel() does local_irq_disable() and then</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; swsusp_arch_resume() -&gt; relocate_restore_code() -&gt; flush_tlb_all()</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; and smp_call_function_many() doesn&#39;t like it when IRQs are disabled.</span>

Right.

Can I invoke __flush_tlb_all() from here to flush the TLB on the local
CPU?  That should be sufficient IMO.

Thanks,
Rafael
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - June 30, 2016, 3:24 p.m.</div>
<pre class="content">
On Thu, Jun 30, 2016 at 8:17 AM, Rafael J. Wysocki &lt;rafael@kernel.org&gt; wrote:
<span class="quote">&gt; On Thu, Jun 30, 2016 at 5:05 PM, Borislav Petkov &lt;bp@alien8.de&gt; wrote:</span>
<span class="quote">&gt;&gt; On Thu, Jun 30, 2016 at 03:17:20PM +0200, Rafael J. Wysocki wrote:</span>
<span class="quote">&gt;&gt;&gt; From: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Logan Gunthorpe reports that hibernation stopped working reliably for</span>
<span class="quote">&gt;&gt;&gt; him after commit ab76f7b4ab23 (x86/mm: Set NX on gap between __ex_table</span>
<span class="quote">&gt;&gt;&gt; and rodata).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; ...</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +static int relocate_restore_code(void)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +     pgd_t *pgd;</span>
<span class="quote">&gt;&gt;&gt; +     pud_t *pud;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +     relocated_restore_code = get_safe_page(GFP_ATOMIC);</span>
<span class="quote">&gt;&gt;&gt; +     if (!relocated_restore_code)</span>
<span class="quote">&gt;&gt;&gt; +             return -ENOMEM;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +     memcpy((void *)relocated_restore_code, &amp;core_restore_code, PAGE_SIZE);</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +     /* Make the page containing the relocated code executable */</span>
<span class="quote">&gt;&gt;&gt; +     pgd = (pgd_t *)__va(read_cr3()) + pgd_index(relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt; +     pud = pud_offset(pgd, relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt; +     if (pud_large(*pud)) {</span>
<span class="quote">&gt;&gt;&gt; +             set_pud(pud, __pud(pud_val(*pud) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt;&gt; +     } else {</span>
<span class="quote">&gt;&gt;&gt; +             pmd_t *pmd = pmd_offset(pud, relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +             if (pmd_large(*pmd)) {</span>
<span class="quote">&gt;&gt;&gt; +                     set_pmd(pmd, __pmd(pmd_val(*pmd) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt;&gt; +             } else {</span>
<span class="quote">&gt;&gt;&gt; +                     pte_t *pte = pte_offset_kernel(pmd, relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +                     set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt;&gt; +             }</span>
<span class="quote">&gt;&gt;&gt; +     }</span>
<span class="quote">&gt;&gt;&gt; +     flush_tlb_all();</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I know you want to flush TLBs but this causes the splat below on the</span>
<span class="quote">&gt;&gt; resume kernel.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Most likely because:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; resume_target_kernel() does local_irq_disable() and then</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; swsusp_arch_resume() -&gt; relocate_restore_code() -&gt; flush_tlb_all()</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; and smp_call_function_many() doesn&#39;t like it when IRQs are disabled.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Right.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Can I invoke __flush_tlb_all() from here to flush the TLB on the local</span>
<span class="quote">&gt; CPU?  That should be sufficient IMO.</span>

Yes, unless there&#39;s another CPU already up at the time, but that seems unlikely.

FWIW, the CPU can and will cache the NX bit and the CPU will *not*
refresh the TLB before sending a page fault.  You definitely need to
flush.  I wonder if this is also why you&#39;re seeing a certain amount of
random corruption.

--Andy
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=99561">Rafael J. Wysocki</a> - June 30, 2016, 3:29 p.m.</div>
<pre class="content">
On Thu, Jun 30, 2016 at 5:24 PM, Andy Lutomirski &lt;luto@amacapital.net&gt; wrote:
<span class="quote">&gt; On Thu, Jun 30, 2016 at 8:17 AM, Rafael J. Wysocki &lt;rafael@kernel.org&gt; wrote:</span>
<span class="quote">&gt;&gt; On Thu, Jun 30, 2016 at 5:05 PM, Borislav Petkov &lt;bp@alien8.de&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt; On Thu, Jun 30, 2016 at 03:17:20PM +0200, Rafael J. Wysocki wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; From: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Logan Gunthorpe reports that hibernation stopped working reliably for</span>
<span class="quote">&gt;&gt;&gt;&gt; him after commit ab76f7b4ab23 (x86/mm: Set NX on gap between __ex_table</span>
<span class="quote">&gt;&gt;&gt;&gt; and rodata).</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; ...</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; +static int relocate_restore_code(void)</span>
<span class="quote">&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt; +     pgd_t *pgd;</span>
<span class="quote">&gt;&gt;&gt;&gt; +     pud_t *pud;</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +     relocated_restore_code = get_safe_page(GFP_ATOMIC);</span>
<span class="quote">&gt;&gt;&gt;&gt; +     if (!relocated_restore_code)</span>
<span class="quote">&gt;&gt;&gt;&gt; +             return -ENOMEM;</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +     memcpy((void *)relocated_restore_code, &amp;core_restore_code, PAGE_SIZE);</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +     /* Make the page containing the relocated code executable */</span>
<span class="quote">&gt;&gt;&gt;&gt; +     pgd = (pgd_t *)__va(read_cr3()) + pgd_index(relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt;&gt; +     pud = pud_offset(pgd, relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt;&gt; +     if (pud_large(*pud)) {</span>
<span class="quote">&gt;&gt;&gt;&gt; +             set_pud(pud, __pud(pud_val(*pud) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt;&gt;&gt; +     } else {</span>
<span class="quote">&gt;&gt;&gt;&gt; +             pmd_t *pmd = pmd_offset(pud, relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +             if (pmd_large(*pmd)) {</span>
<span class="quote">&gt;&gt;&gt;&gt; +                     set_pmd(pmd, __pmd(pmd_val(*pmd) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt;&gt;&gt; +             } else {</span>
<span class="quote">&gt;&gt;&gt;&gt; +                     pte_t *pte = pte_offset_kernel(pmd, relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +                     set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt;&gt;&gt; +             }</span>
<span class="quote">&gt;&gt;&gt;&gt; +     }</span>
<span class="quote">&gt;&gt;&gt;&gt; +     flush_tlb_all();</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I know you want to flush TLBs but this causes the splat below on the</span>
<span class="quote">&gt;&gt;&gt; resume kernel.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Most likely because:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; resume_target_kernel() does local_irq_disable() and then</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; swsusp_arch_resume() -&gt; relocate_restore_code() -&gt; flush_tlb_all()</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; and smp_call_function_many() doesn&#39;t like it when IRQs are disabled.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Right.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Can I invoke __flush_tlb_all() from here to flush the TLB on the local</span>
<span class="quote">&gt;&gt; CPU?  That should be sufficient IMO.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Yes, unless there&#39;s another CPU already up at the time, but that seems unlikely.</span>

They are all offline at that time.

OK, let me do that then.
<span class="quote">
&gt; FWIW, the CPU can and will cache the NX bit and the CPU will *not*</span>
<span class="quote">&gt; refresh the TLB before sending a page fault.  You definitely need to</span>
<span class="quote">&gt; flush.</span>

OK
<span class="quote">
&gt;  I wonder if this is also why you&#39;re seeing a certain amount of</span>
<span class="quote">&gt; random corruption.</span>

Well, the corruption we saw was not really random.  I can give you all
of the details if you&#39;re interested, maybe you&#39;ll be able to figure
out what might be happening. :-)

Thanks,
Rafael
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - June 30, 2016, 5:23 p.m.</div>
<pre class="content">
On Thu, Jun 30, 2016 at 8:29 AM, Rafael J. Wysocki &lt;rafael@kernel.org&gt; wrote:
<span class="quote">&gt; On Thu, Jun 30, 2016 at 5:24 PM, Andy Lutomirski &lt;luto@amacapital.net&gt; wrote:</span>
<span class="quote">&gt;&gt; On Thu, Jun 30, 2016 at 8:17 AM, Rafael J. Wysocki &lt;rafael@kernel.org&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt; On Thu, Jun 30, 2016 at 5:05 PM, Borislav Petkov &lt;bp@alien8.de&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On Thu, Jun 30, 2016 at 03:17:20PM +0200, Rafael J. Wysocki wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; From: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Logan Gunthorpe reports that hibernation stopped working reliably for</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; him after commit ab76f7b4ab23 (x86/mm: Set NX on gap between __ex_table</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; and rodata).</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; ...</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +static int relocate_restore_code(void)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     pgd_t *pgd;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     pud_t *pud;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     relocated_restore_code = get_safe_page(GFP_ATOMIC);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     if (!relocated_restore_code)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             return -ENOMEM;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     memcpy((void *)relocated_restore_code, &amp;core_restore_code, PAGE_SIZE);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     /* Make the page containing the relocated code executable */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     pgd = (pgd_t *)__va(read_cr3()) + pgd_index(relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     pud = pud_offset(pgd, relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     if (pud_large(*pud)) {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             set_pud(pud, __pud(pud_val(*pud) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     } else {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             pmd_t *pmd = pmd_offset(pud, relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             if (pmd_large(*pmd)) {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +                     set_pmd(pmd, __pmd(pmd_val(*pmd) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             } else {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +                     pte_t *pte = pte_offset_kernel(pmd, relocated_restore_code);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +                     set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_NX));</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             }</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     }</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     flush_tlb_all();</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I know you want to flush TLBs but this causes the splat below on the</span>
<span class="quote">&gt;&gt;&gt;&gt; resume kernel.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Most likely because:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; resume_target_kernel() does local_irq_disable() and then</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; swsusp_arch_resume() -&gt; relocate_restore_code() -&gt; flush_tlb_all()</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; and smp_call_function_many() doesn&#39;t like it when IRQs are disabled.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Right.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Can I invoke __flush_tlb_all() from here to flush the TLB on the local</span>
<span class="quote">&gt;&gt;&gt; CPU?  That should be sufficient IMO.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Yes, unless there&#39;s another CPU already up at the time, but that seems unlikely.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; They are all offline at that time.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; OK, let me do that then.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; FWIW, the CPU can and will cache the NX bit and the CPU will *not*</span>
<span class="quote">&gt;&gt; refresh the TLB before sending a page fault.  You definitely need to</span>
<span class="quote">&gt;&gt; flush.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; OK</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;  I wonder if this is also why you&#39;re seeing a certain amount of</span>
<span class="quote">&gt;&gt; random corruption.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Well, the corruption we saw was not really random.  I can give you all</span>
<span class="quote">&gt; of the details if you&#39;re interested, maybe you&#39;ll be able to figure</span>
<span class="quote">&gt; out what might be happening. :-)</span>

Sure, or at least in abbreviated form.  No guarantee that I&#39;ll have
any clue, though.

--Andy
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">Index: linux-pm/arch/x86/power/hibernate_64.c</span>
===================================================================
<span class="p_header">--- linux-pm.orig/arch/x86/power/hibernate_64.c</span>
<span class="p_header">+++ linux-pm/arch/x86/power/hibernate_64.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/mtrr.h&gt;
 #include &lt;asm/sections.h&gt;
 #include &lt;asm/suspend.h&gt;
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
 
 /* Defined in hibernate_asm_64.S */
 extern asmlinkage __visible int restore_image(void);
<span class="p_chunk">@@ -28,6 +29,7 @@</span> <span class="p_context"> extern asmlinkage __visible int restore_</span>
  * kernel&#39;s text (this value is passed in the image header).
  */
 unsigned long restore_jump_address __visible;
<span class="p_add">+unsigned long jump_address_phys;</span>
 
 /*
  * Value of the cr3 register from before the hibernation (this value is passed
<span class="p_chunk">@@ -37,7 +39,43 @@</span> <span class="p_context"> unsigned long restore_cr3 __visible;</span>
 
 pgd_t *temp_level4_pgt __visible;
 
<span class="p_del">-void *relocated_restore_code __visible;</span>
<span class="p_add">+unsigned long relocated_restore_code __visible;</span>
<span class="p_add">+</span>
<span class="p_add">+static int set_up_temporary_text_mapping(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The new mapping only has to cover the page containing the image</span>
<span class="p_add">+	 * kernel&#39;s entry point (jump_address_phys), because the switch over to</span>
<span class="p_add">+	 * it is carried out by relocated code running from a page allocated</span>
<span class="p_add">+	 * specifically for this purpose and covered by the identity mapping, so</span>
<span class="p_add">+	 * the temporary kernel text mapping is only needed for the final jump.</span>
<span class="p_add">+	 * Moreover, in that mapping the virtual address of the image kernel&#39;s</span>
<span class="p_add">+	 * entry point must be the same as its virtual address in the image</span>
<span class="p_add">+	 * kernel (restore_jump_address), so the image kernel&#39;s</span>
<span class="p_add">+	 * restore_registers() code doesn&#39;t find itself in a different area of</span>
<span class="p_add">+	 * the virtual address space after switching over to the original page</span>
<span class="p_add">+	 * tables used by the image kernel.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pud = (pud_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!pud)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd = (pmd_t *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!pmd)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_pmd(pmd + pmd_index(restore_jump_address),</span>
<span class="p_add">+		__pmd((jump_address_phys &amp; PMD_MASK) | __PAGE_KERNEL_LARGE_EXEC));</span>
<span class="p_add">+	set_pud(pud + pud_index(restore_jump_address),</span>
<span class="p_add">+		__pud(__pa(pmd) | _KERNPG_TABLE));</span>
<span class="p_add">+	set_pgd(temp_level4_pgt + pgd_index(restore_jump_address),</span>
<span class="p_add">+		__pgd(__pa(pud) | _KERNPG_TABLE));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
 static void *alloc_pgt_page(void *context)
 {
<span class="p_chunk">@@ -59,9 +97,10 @@</span> <span class="p_context"> static int set_up_temporary_mappings(voi</span>
 	if (!temp_level4_pgt)
 		return -ENOMEM;
 
<span class="p_del">-	/* It is safe to reuse the original kernel mapping */</span>
<span class="p_del">-	set_pgd(temp_level4_pgt + pgd_index(__START_KERNEL_map),</span>
<span class="p_del">-		init_level4_pgt[pgd_index(__START_KERNEL_map)]);</span>
<span class="p_add">+	/* Prepare a temporary mapping for the kernel text */</span>
<span class="p_add">+	result = set_up_temporary_text_mapping();</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		return result;</span>
 
 	/* Set up the direct mapping from scratch */
 	for (i = 0; i &lt; nr_pfn_mapped; i++) {
<span class="p_chunk">@@ -78,19 +117,50 @@</span> <span class="p_context"> static int set_up_temporary_mappings(voi</span>
 	return 0;
 }
 
<span class="p_add">+static int relocate_restore_code(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+</span>
<span class="p_add">+	relocated_restore_code = get_safe_page(GFP_ATOMIC);</span>
<span class="p_add">+	if (!relocated_restore_code)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy((void *)relocated_restore_code, &amp;core_restore_code, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make the page containing the relocated code executable */</span>
<span class="p_add">+	pgd = (pgd_t *)__va(read_cr3()) + pgd_index(relocated_restore_code);</span>
<span class="p_add">+	pud = pud_offset(pgd, relocated_restore_code);</span>
<span class="p_add">+	if (pud_large(*pud)) {</span>
<span class="p_add">+		set_pud(pud, __pud(pud_val(*pud) &amp; ~_PAGE_NX));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pmd_t *pmd = pmd_offset(pud, relocated_restore_code);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pmd_large(*pmd)) {</span>
<span class="p_add">+			set_pmd(pmd, __pmd(pmd_val(*pmd) &amp; ~_PAGE_NX));</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pte_t *pte = pte_offset_kernel(pmd, relocated_restore_code);</span>
<span class="p_add">+</span>
<span class="p_add">+			set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_NX));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	flush_tlb_all();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int swsusp_arch_resume(void)
 {
 	int error;
 
 	/* We have got enough memory and from now on we cannot recover */
<span class="p_del">-	if ((error = set_up_temporary_mappings()))</span>
<span class="p_add">+	error = set_up_temporary_mappings();</span>
<span class="p_add">+	if (error)</span>
 		return error;
 
<span class="p_del">-	relocated_restore_code = (void *)get_safe_page(GFP_ATOMIC);</span>
<span class="p_del">-	if (!relocated_restore_code)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	memcpy(relocated_restore_code, &amp;core_restore_code,</span>
<span class="p_del">-	       &amp;restore_registers - &amp;core_restore_code);</span>
<span class="p_add">+	error = relocate_restore_code();</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
 
 	restore_image();
 	return 0;
<span class="p_chunk">@@ -109,11 +179,12 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 
 struct restore_data_record {
 	unsigned long jump_address;
<span class="p_add">+	unsigned long jump_address_phys;</span>
 	unsigned long cr3;
 	unsigned long magic;
 };
 
<span class="p_del">-#define RESTORE_MAGIC	0x0123456789ABCDEFUL</span>
<span class="p_add">+#define RESTORE_MAGIC	0x123456789ABCDEF0UL</span>
 
 /**
  *	arch_hibernation_header_save - populate the architecture specific part
<span class="p_chunk">@@ -126,7 +197,8 @@</span> <span class="p_context"> int arch_hibernation_header_save(void *a</span>
 
 	if (max_size &lt; sizeof(struct restore_data_record))
 		return -EOVERFLOW;
<span class="p_del">-	rdr-&gt;jump_address = restore_jump_address;</span>
<span class="p_add">+	rdr-&gt;jump_address = (unsigned long)&amp;restore_registers;</span>
<span class="p_add">+	rdr-&gt;jump_address_phys = __pa_symbol(&amp;restore_registers);</span>
 	rdr-&gt;cr3 = restore_cr3;
 	rdr-&gt;magic = RESTORE_MAGIC;
 	return 0;
<span class="p_chunk">@@ -142,6 +214,7 @@</span> <span class="p_context"> int arch_hibernation_header_restore(void</span>
 	struct restore_data_record *rdr = addr;
 
 	restore_jump_address = rdr-&gt;jump_address;
<span class="p_add">+	jump_address_phys = rdr-&gt;jump_address_phys;</span>
 	restore_cr3 = rdr-&gt;cr3;
 	return (rdr-&gt;magic == RESTORE_MAGIC) ? 0 : -EINVAL;
 }
<span class="p_header">Index: linux-pm/arch/x86/power/hibernate_asm_64.S</span>
===================================================================
<span class="p_header">--- linux-pm.orig/arch/x86/power/hibernate_asm_64.S</span>
<span class="p_header">+++ linux-pm/arch/x86/power/hibernate_asm_64.S</span>
<span class="p_chunk">@@ -44,9 +44,6 @@</span> <span class="p_context"> ENTRY(swsusp_arch_suspend)</span>
 	pushfq
 	popq	pt_regs_flags(%rax)
 
<span class="p_del">-	/* save the address of restore_registers */</span>
<span class="p_del">-	movq	$restore_registers, %rax</span>
<span class="p_del">-	movq	%rax, restore_jump_address(%rip)</span>
 	/* save cr3 */
 	movq	%cr3, %rax
 	movq	%rax, restore_cr3(%rip)
<span class="p_chunk">@@ -57,31 +54,34 @@</span> <span class="p_context"> ENTRY(swsusp_arch_suspend)</span>
 ENDPROC(swsusp_arch_suspend)
 
 ENTRY(restore_image)
<span class="p_del">-	/* switch to temporary page tables */</span>
<span class="p_del">-	movq	$__PAGE_OFFSET, %rdx</span>
<span class="p_del">-	movq	temp_level4_pgt(%rip), %rax</span>
<span class="p_del">-	subq	%rdx, %rax</span>
<span class="p_del">-	movq	%rax, %cr3</span>
<span class="p_del">-	/* Flush TLB */</span>
<span class="p_del">-	movq	mmu_cr4_features(%rip), %rax</span>
<span class="p_del">-	movq	%rax, %rdx</span>
<span class="p_del">-	andq	$~(X86_CR4_PGE), %rdx</span>
<span class="p_del">-	movq	%rdx, %cr4;  # turn off PGE</span>
<span class="p_del">-	movq	%cr3, %rcx;  # flush TLB</span>
<span class="p_del">-	movq	%rcx, %cr3;</span>
<span class="p_del">-	movq	%rax, %cr4;  # turn PGE back on</span>
<span class="p_del">-</span>
 	/* prepare to jump to the image kernel */
<span class="p_del">-	movq	restore_jump_address(%rip), %rax</span>
<span class="p_del">-	movq	restore_cr3(%rip), %rbx</span>
<span class="p_add">+	movq	restore_jump_address(%rip), %r8</span>
<span class="p_add">+	movq	restore_cr3(%rip), %r9</span>
<span class="p_add">+</span>
<span class="p_add">+	/* prepare to switch to temporary page tables */</span>
<span class="p_add">+	movq	temp_level4_pgt(%rip), %rax</span>
<span class="p_add">+	movq	mmu_cr4_features(%rip), %rbx</span>
 
 	/* prepare to copy image data to their original locations */
 	movq	restore_pblist(%rip), %rdx
<span class="p_add">+</span>
<span class="p_add">+	/* jump to relocated restore code */</span>
 	movq	relocated_restore_code(%rip), %rcx
 	jmpq	*%rcx
 
 	/* code below has been relocated to a safe page */
 ENTRY(core_restore_code)
<span class="p_add">+	/* switch to temporary page tables */</span>
<span class="p_add">+	movq	$__PAGE_OFFSET, %rcx</span>
<span class="p_add">+	subq	%rcx, %rax</span>
<span class="p_add">+	movq	%rax, %cr3</span>
<span class="p_add">+	/* flush TLB */</span>
<span class="p_add">+	movq	%rbx, %rcx</span>
<span class="p_add">+	andq	$~(X86_CR4_PGE), %rcx</span>
<span class="p_add">+	movq	%rcx, %cr4;  # turn off PGE</span>
<span class="p_add">+	movq	%cr3, %rcx;  # flush TLB</span>
<span class="p_add">+	movq	%rcx, %cr3;</span>
<span class="p_add">+	movq	%rbx, %cr4;  # turn PGE back on</span>
 .Lloop:
 	testq	%rdx, %rdx
 	jz	.Ldone
<span class="p_chunk">@@ -96,24 +96,17 @@</span> <span class="p_context"> ENTRY(core_restore_code)</span>
 	/* progress to the next pbe */
 	movq	pbe_next(%rdx), %rdx
 	jmp	.Lloop
<span class="p_add">+</span>
 .Ldone:
 	/* jump to the restore_registers address from the image header */
<span class="p_del">-	jmpq	*%rax</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * NOTE: This assumes that the boot kernel&#39;s text mapping covers the</span>
<span class="p_del">-	 * image kernel&#39;s page containing restore_registers and the address of</span>
<span class="p_del">-	 * this page is the same as in the image kernel&#39;s text mapping (it</span>
<span class="p_del">-	 * should always be true, because the text mapping is linear, starting</span>
<span class="p_del">-	 * from 0, and is supposed to cover the entire kernel text for every</span>
<span class="p_del">-	 * kernel).</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * code below belongs to the image kernel</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	jmpq	*%r8</span>
 
<span class="p_add">+	 /* code below belongs to the image kernel */</span>
<span class="p_add">+	.align PAGE_SIZE</span>
 ENTRY(restore_registers)
 	FRAME_BEGIN
 	/* go back to the original page tables */
<span class="p_del">-	movq    %rbx, %cr3</span>
<span class="p_add">+	movq    %r9, %cr3</span>
 
 	/* Flush TLB, including &quot;global&quot; things (vmalloc) */
 	movq	mmu_cr4_features(%rip), %rax

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



