
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] x86/platform changes for v4.9 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] x86/platform changes for v4.9</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 3, 2016, 9:56 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161003095618.GA12263@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9360359/mbox/"
   >mbox</a>
|
   <a href="/patch/9360359/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9360359/">/patch/9360359/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	168EF607D6 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Oct 2016 09:56:40 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 04555288A0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Oct 2016 09:56:40 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id ECEA8288B2; Mon,  3 Oct 2016 09:56:39 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.3 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI, RCVD_IN_SORBS_SPAM,
	T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 52C40288A0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Oct 2016 09:56:37 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752597AbcJCJ4b (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 3 Oct 2016 05:56:31 -0400
Received: from mail-wm0-f66.google.com ([74.125.82.66]:36541 &quot;EHLO
	mail-wm0-f66.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752200AbcJCJ4X (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 3 Oct 2016 05:56:23 -0400
Received: by mail-wm0-f66.google.com with SMTP id b184so13819156wma.3
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 03 Oct 2016 02:56:22 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=w1dAuWxvTY1sENaoFfUZ1XSXvzDYshrokW0hvItWZ/Q=;
	b=DvT9PfWaQudix0W7rmtgHnUiQ5STvLX2K3n2dvB+40WentbEBmf+scqxlaG+5J8UHC
	CXwcm08RCEu+ZgRo135PUXZj4InXM0peM496/hYnce8g9jwqRlrsQ00ymQGG/7/oE92C
	+H4Xr+d0CS7Gvflcnmv/ttV3I4cZOtwzQVkfssjSGJfGr5sYAEJIGK+A39rerZu9x/tX
	8hl4NX2fdqNVvUg5B1ZSxPVQvwsTfWzg1axhtfZGWzi4cAiI55h7TqSfWXh/8YzSZSuJ
	cihzTxANLHXY/Lw0wa0gTqPYp3BFhgLlFVS+tdrTLfNYA7I+3Ku1mNVBu8x24R1JdAVv
	0i6Q==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=w1dAuWxvTY1sENaoFfUZ1XSXvzDYshrokW0hvItWZ/Q=;
	b=E/0bH+nT5kHU17Mu6S/fgsbDeuMhHQnED0pILLLy/Srq7y0kV3UvktcrKbgmsR8oD7
	ENA5DAV80wnV5rqvC8Ewut4A0u+6ofDKq8pxlruXDkHsiDct271owf+gppxyMOGB+LEn
	+B1NkTKTYu+snL4DbVIZu536jQJGWfvKC2C0JfIZE+0GXk4ou5+3/laMflI+S86cfaCO
	YvE7AANMgKKy+61FjZ2ZT7sdC6+C6JuH8Z5su6AuREzLw+STRrWH8QutUUBAqgfVuND0
	nsXq0Vvp+3Ea4PiIkV6ODUUctRsf3c13Gtq8560NcFAqWo9QlzoN0Sy+bOMBupZmXFLe
	dcOg==
X-Gm-Message-State: AA6/9RmVgG2xB8IReo075QAWGLZKk1bU836Wl/ZizUQEMGdO6jrcBCFLLQGv6onpmH4lsA==
X-Received: by 10.194.103.165 with SMTP id fx5mr2409301wjb.188.1475488581822;
	Mon, 03 Oct 2016 02:56:21 -0700 (PDT)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	o196sm17093783wmg.8.2016.10.03.02.56.20
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 03 Oct 2016 02:56:20 -0700 (PDT)
Date: Mon, 3 Oct 2016 11:56:18 +0200
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;, Borislav Petkov &lt;bp@alien8.de&gt;
Subject: [GIT PULL] x86/platform changes for v4.9
Message-ID: &lt;20161003095618.GA12263@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Oct. 3, 2016, 9:56 a.m.</div>
<pre class="content">
Linus,

Please pull the latest x86-platform-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git x86-platform-for-linus

   # HEAD: 65f7422288cd19c4a9202c4ac7a9cca673b9b2ea x86/platform/mellanox: Fix return value check in mlxplat_init()

The main changes in this cycle were:

  - SGI UV updates (Andrew Banman)

  - Intel MID updates (Andy Shevchenko)

  - Initial Mellanox systems platform (Vadim Pasternak)


  out-of-topic modifications in x86-platform-for-linus:
  -------------------------------------------------------
  MAINTAINERS                        # 58cbbee2391c: x86/platform/mellanox: Intro
  drivers/pci/pci-mid.c              # 8e522e1d321b: x86/platform/intel-mid: Add 
                                   # f5fbf848303c: x86/cpu: Rename Merrifield2 
  drivers/powercap/intel_rapl.c      # f5fbf848303c: x86/cpu: Rename Merrifield2 

 Thanks,

	Ingo

------------------&gt;
Andrew Banman (10):
      x86/platform/uv/BAU: Clean up vertical alignment
      x86/platform/uv/BAU: Clean up and update printks
      x86/platform/uv/BAU: Clean up pq_init()
      x86/platform/uv/BAU: Convert uv_physnodeaddr() use to uv_gpa_to_offset()
      x86/platform/uv/BAU: Add generic function pointers
      x86/platform/uv/BAU: Use generic function pointers
      x86/platform/uv/BAU: Populate -&gt;uvhub_version with UV4 version information
      x86/platform/uv/BAU: Disable software timeout on UV4 hardware
      x86/platform/uv/BAU: Fix payload queue setup on UV4 hardware
      x86/platform/uv/BAU: Add UV4-specific functions

Andy Shevchenko (7):
      x86/platform/intel-mid: Run PWRMU command immediately
      x86/platform/intel-mid: Enable WiFi on Intel Edison
      x86/platform/intel-mid: Enable SD card detection on Merrifield
      x86/platform/intel-mid: Implement power off sequence
      x86/cpu: Rename Merrifield2 to Moorefield
      x86/platform/intel-mid: Add Intel Penwell to ID table
      x86/platform/intel-mid: Keep SRAM powered on at boot

Vadim Pasternak (1):
      x86/platform/mellanox: Introduce support for Mellanox systems platform

Wei Yongjun (1):
      x86/platform/mellanox: Fix return value check in mlxplat_init()


 MAINTAINERS                                        |   6 +
 arch/x86/Kconfig                                   |  12 +
 arch/x86/include/asm/intel-family.h                |   4 +-
 arch/x86/include/asm/intel-mid.h                   |   2 +
 arch/x86/include/asm/intel_scu_ipc.h               |   2 +
 arch/x86/include/asm/uv/uv_bau.h                   |  45 +++-
 arch/x86/platform/Makefile                         |   1 +
 arch/x86/platform/atom/punit_atom_debug.c          |   2 +-
 arch/x86/platform/intel-mid/device_libs/Makefile   |   4 +
 .../intel-mid/device_libs/platform_bcm43xx.c       |  95 ++++++++
 .../intel-mid/device_libs/platform_mrfld_sd.c      |  47 ++++
 arch/x86/platform/intel-mid/intel-mid.c            |   5 +
 arch/x86/platform/intel-mid/pwr.c                  |  76 +++++-
 arch/x86/platform/mellanox/Makefile                |   1 +
 arch/x86/platform/mellanox/mlx-platform.c          | 266 +++++++++++++++++++++
 arch/x86/platform/uv/tlb_uv.c                      | 178 ++++++++------
 drivers/pci/pci-mid.c                              |   7 +-
 drivers/powercap/intel_rapl.c                      |   4 +-
 18 files changed, 669 insertions(+), 88 deletions(-)
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_bcm43xx.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mrfld_sd.c
 create mode 100644 arch/x86/platform/mellanox/Makefile
 create mode 100644 arch/x86/platform/mellanox/mlx-platform.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index a0ce40f4c66c..2adc6ef635ce 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -7668,6 +7668,12 @@</span> <span class="p_context"> W:	http://www.mellanox.com</span>
 Q:	http://patchwork.ozlabs.org/project/netdev/list/
 F:	drivers/net/ethernet/mellanox/mlxsw/
 
<span class="p_add">+MELLANOX PLATFORM DRIVER</span>
<span class="p_add">+M:      Vadim Pasternak &lt;vadimp@mellanox.com&gt;</span>
<span class="p_add">+L:      platform-driver-x86@vger.kernel.org</span>
<span class="p_add">+S:      Supported</span>
<span class="p_add">+F:      arch/x86/platform/mellanox/mlx-platform.c</span>
<span class="p_add">+</span>
 SOFT-ROCE DRIVER (rxe)
 M:	Moni Shoua &lt;monis@mellanox.com&gt;
 L:	linux-rdma@vger.kernel.org
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 2a1f0ce7c59a..a72b01b225f2 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -549,6 +549,18 @@</span> <span class="p_context"> config X86_INTEL_QUARK</span>
 	  Say Y here if you have a Quark based system such as the Arduino
 	  compatible Intel Galileo.
 
<span class="p_add">+config MLX_PLATFORM</span>
<span class="p_add">+	tristate &quot;Mellanox Technologies platform support&quot;</span>
<span class="p_add">+	depends on X86_64</span>
<span class="p_add">+	depends on X86_EXTENDED_PLATFORM</span>
<span class="p_add">+	---help---</span>
<span class="p_add">+	  This option enables system support for the Mellanox Technologies</span>
<span class="p_add">+	  platform.</span>
<span class="p_add">+</span>
<span class="p_add">+	  Say Y here if you are building a kernel for Mellanox system.</span>
<span class="p_add">+</span>
<span class="p_add">+	  Otherwise, say N.</span>
<span class="p_add">+</span>
 config X86_INTEL_LPSS
 	bool &quot;Intel Low Power Subsystem Support&quot;
 	depends on X86 &amp;&amp; ACPI
<span class="p_header">diff --git a/arch/x86/include/asm/intel-family.h b/arch/x86/include/asm/intel-family.h</span>
<span class="p_header">index 627719475457..9ae5ab80a497 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/intel-family.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/intel-family.h</span>
<span class="p_chunk">@@ -56,8 +56,8 @@</span> <span class="p_context"></span>
 #define INTEL_FAM6_ATOM_SILVERMONT1	0x37 /* BayTrail/BYT / Valleyview */
 #define INTEL_FAM6_ATOM_SILVERMONT2	0x4D /* Avaton/Rangely */
 #define INTEL_FAM6_ATOM_AIRMONT		0x4C /* CherryTrail / Braswell */
<span class="p_del">-#define INTEL_FAM6_ATOM_MERRIFIELD1	0x4A /* Tangier */</span>
<span class="p_del">-#define INTEL_FAM6_ATOM_MERRIFIELD2	0x5A /* Annidale */</span>
<span class="p_add">+#define INTEL_FAM6_ATOM_MERRIFIELD	0x4A /* Tangier */</span>
<span class="p_add">+#define INTEL_FAM6_ATOM_MOOREFIELD	0x5A /* Annidale */</span>
 #define INTEL_FAM6_ATOM_GOLDMONT	0x5C
 #define INTEL_FAM6_ATOM_DENVERTON	0x5F /* Goldmont Microserver */
 
<span class="p_header">diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h</span>
<span class="p_header">index 9d6b097aa73d..5b6753d1f7f4 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/intel-mid.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/intel-mid.h</span>
<span class="p_chunk">@@ -18,6 +18,8 @@</span> <span class="p_context"></span>
 extern int intel_mid_pci_init(void);
 extern int intel_mid_pci_set_power_state(struct pci_dev *pdev, pci_power_t state);
 
<span class="p_add">+extern void intel_mid_pwr_power_off(void);</span>
<span class="p_add">+</span>
 #define INTEL_MID_PWR_LSS_OFFSET	4
 #define INTEL_MID_PWR_LSS_TYPE		(1 &lt;&lt; 7)
 
<span class="p_header">diff --git a/arch/x86/include/asm/intel_scu_ipc.h b/arch/x86/include/asm/intel_scu_ipc.h</span>
<span class="p_header">index 925b605eb5c6..4fb1d0abef95 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/intel_scu_ipc.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/intel_scu_ipc.h</span>
<span class="p_chunk">@@ -3,6 +3,8 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/notifier.h&gt;
 
<span class="p_add">+#define IPCMSG_COLD_OFF		0x80	/* Only for Tangier */</span>
<span class="p_add">+</span>
 #define IPCMSG_WARM_RESET	0xF0
 #define IPCMSG_COLD_RESET	0xF1
 #define IPCMSG_SOFT_RESET	0xF2
<span class="p_header">diff --git a/arch/x86/include/asm/uv/uv_bau.h b/arch/x86/include/asm/uv/uv_bau.h</span>
<span class="p_header">index cc44d926c17e..57ab86d94d64 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uv/uv_bau.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uv/uv_bau.h</span>
<span class="p_chunk">@@ -49,14 +49,12 @@</span> <span class="p_context"></span>
 #define UV_NET_ENDPOINT_INTD		(is_uv1_hub() ?			\
 			UV1_NET_ENDPOINT_INTD : UV2_NET_ENDPOINT_INTD)
 #define UV_DESC_PSHIFT			49
<span class="p_del">-#define UV_PAYLOADQ_PNODE_SHIFT		49</span>
<span class="p_add">+#define UV_PAYLOADQ_GNODE_SHIFT		49</span>
 #define UV_PTC_BASENAME			&quot;sgi_uv/ptc_statistics&quot;
 #define UV_BAU_BASENAME			&quot;sgi_uv/bau_tunables&quot;
 #define UV_BAU_TUNABLES_DIR		&quot;sgi_uv&quot;
 #define UV_BAU_TUNABLES_FILE		&quot;bau_tunables&quot;
 #define WHITESPACE			&quot; \t\n&quot;
<span class="p_del">-#define uv_mmask			((1UL &lt;&lt; uv_hub_info-&gt;m_val) - 1)</span>
<span class="p_del">-#define uv_physnodeaddr(x)		((__pa((unsigned long)(x)) &amp; uv_mmask))</span>
 #define cpubit_isset(cpu, bau_local_cpumask) \
 	test_bit((cpu), (bau_local_cpumask).bits)
 
<span class="p_chunk">@@ -387,6 +385,17 @@</span> <span class="p_context"> struct uv2_3_bau_msg_header {</span>
 	/* bits 127:120 */
 };
 
<span class="p_add">+/* Abstracted BAU functions */</span>
<span class="p_add">+struct bau_operations {</span>
<span class="p_add">+	unsigned long (*read_l_sw_ack)(void);</span>
<span class="p_add">+	unsigned long (*read_g_sw_ack)(int pnode);</span>
<span class="p_add">+	unsigned long (*bau_gpa_to_offset)(unsigned long vaddr);</span>
<span class="p_add">+	void (*write_l_sw_ack)(unsigned long mmr);</span>
<span class="p_add">+	void (*write_g_sw_ack)(int pnode, unsigned long mmr);</span>
<span class="p_add">+	void (*write_payload_first)(int pnode, unsigned long mmr);</span>
<span class="p_add">+	void (*write_payload_last)(int pnode, unsigned long mmr);</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * The activation descriptor:
  * The format of the message to send, plus all accompanying control
<span class="p_chunk">@@ -655,6 +664,16 @@</span> <span class="p_context"> static inline void write_gmmr_activation(int pnode, unsigned long mmr_image)</span>
 	write_gmmr(pnode, UVH_LB_BAU_SB_ACTIVATION_CONTROL, mmr_image);
 }
 
<span class="p_add">+static inline void write_mmr_proc_payload_first(int pnode, unsigned long mmr_image)</span>
<span class="p_add">+{</span>
<span class="p_add">+	write_gmmr(pnode, UV4H_LB_PROC_INTD_QUEUE_FIRST, mmr_image);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void write_mmr_proc_payload_last(int pnode, unsigned long mmr_image)</span>
<span class="p_add">+{</span>
<span class="p_add">+	write_gmmr(pnode, UV4H_LB_PROC_INTD_QUEUE_LAST, mmr_image);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void write_mmr_payload_first(int pnode, unsigned long mmr_image)
 {
 	write_gmmr(pnode, UVH_LB_BAU_INTD_PAYLOAD_QUEUE_FIRST, mmr_image);
<span class="p_chunk">@@ -700,6 +719,26 @@</span> <span class="p_context"> static inline unsigned long read_gmmr_sw_ack(int pnode)</span>
 	return read_gmmr(pnode, UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE);
 }
 
<span class="p_add">+static inline void write_mmr_proc_sw_ack(unsigned long mr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uv_write_local_mmr(UV4H_LB_PROC_INTD_SOFT_ACK_CLEAR, mr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void write_gmmr_proc_sw_ack(int pnode, unsigned long mr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	write_gmmr(pnode, UV4H_LB_PROC_INTD_SOFT_ACK_CLEAR, mr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long read_mmr_proc_sw_ack(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return read_lmmr(UV4H_LB_PROC_INTD_SOFT_ACK_PENDING);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long read_gmmr_proc_sw_ack(int pnode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return read_gmmr(pnode, UV4H_LB_PROC_INTD_SOFT_ACK_PENDING);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void write_mmr_data_config(int pnode, unsigned long mr)
 {
 	uv_write_global_mmr64(pnode, UVH_BAU_DATA_CONFIG, mr);
<span class="p_header">diff --git a/arch/x86/platform/Makefile b/arch/x86/platform/Makefile</span>
<span class="p_header">index 184842ef332e..3c3c19ea94df 100644</span>
<span class="p_header">--- a/arch/x86/platform/Makefile</span>
<span class="p_header">+++ b/arch/x86/platform/Makefile</span>
<span class="p_chunk">@@ -8,6 +8,7 @@</span> <span class="p_context"> obj-y	+= iris/</span>
 obj-y	+= intel/
 obj-y	+= intel-mid/
 obj-y	+= intel-quark/
<span class="p_add">+obj-y	+= mellanox/</span>
 obj-y	+= olpc/
 obj-y	+= scx200/
 obj-y	+= sfi/
<span class="p_header">diff --git a/arch/x86/platform/atom/punit_atom_debug.c b/arch/x86/platform/atom/punit_atom_debug.c</span>
<span class="p_header">index 8ff7b9355416..d49d3be81953 100644</span>
<span class="p_header">--- a/arch/x86/platform/atom/punit_atom_debug.c</span>
<span class="p_header">+++ b/arch/x86/platform/atom/punit_atom_debug.c</span>
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"> static void punit_dbgfs_unregister(void)</span>
 
 static const struct x86_cpu_id intel_punit_cpu_ids[] = {
 	ICPU(INTEL_FAM6_ATOM_SILVERMONT1, punit_device_byt),
<span class="p_del">-	ICPU(INTEL_FAM6_ATOM_MERRIFIELD1, punit_device_tng),</span>
<span class="p_add">+	ICPU(INTEL_FAM6_ATOM_MERRIFIELD,  punit_device_tng),</span>
 	ICPU(INTEL_FAM6_ATOM_AIRMONT,	  punit_device_cht),
 	{}
 };
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_header">index fc135bf70511..429d08be7848 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_chunk">@@ -1,5 +1,9 @@</span> <span class="p_context"></span>
 # Family-Level Interface Shim (FLIS)
 obj-$(subst m,y,$(CONFIG_PINCTRL_MERRIFIELD)) += platform_mrfld_pinctrl.o
<span class="p_add">+# SDHCI Devices</span>
<span class="p_add">+obj-$(subst m,y,$(CONFIG_MMC_SDHCI_PCI)) += platform_mrfld_sd.o</span>
<span class="p_add">+# WiFi</span>
<span class="p_add">+obj-$(subst m,y,$(CONFIG_BRCMFMAC_SDIO)) += platform_bcm43xx.o</span>
 # IPC Devices
 obj-y += platform_ipc.o
 obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic.o
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_bcm43xx.c b/arch/x86/platform/intel-mid/device_libs/platform_bcm43xx.c</span>
new file mode 100644
<span class="p_header">index 000000000000..4392c15ed9e0</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_bcm43xx.c</span>
<span class="p_chunk">@@ -0,0 +1,95 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * platform_bcm43xx.c: bcm43xx platform data initilization file</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (C) Copyright 2016 Intel Corporation</span>
<span class="p_add">+ * Author: Andy Shevchenko &lt;andriy.shevchenko@linux.intel.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ * modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ * as published by the Free Software Foundation; version 2</span>
<span class="p_add">+ * of the License.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/gpio.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
<span class="p_add">+#include &lt;linux/regulator/fixed.h&gt;</span>
<span class="p_add">+#include &lt;linux/sfi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/intel-mid.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define WLAN_SFI_GPIO_IRQ_NAME		&quot;WLAN-interrupt&quot;</span>
<span class="p_add">+#define WLAN_SFI_GPIO_ENABLE_NAME	&quot;WLAN-enable&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define WLAN_DEV_NAME			&quot;0000:00:01.3&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct regulator_consumer_supply bcm43xx_vmmc_supply = {</span>
<span class="p_add">+	.dev_name		= WLAN_DEV_NAME,</span>
<span class="p_add">+	.supply			= &quot;vmmc&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct regulator_init_data bcm43xx_vmmc_data = {</span>
<span class="p_add">+	.constraints = {</span>
<span class="p_add">+		.valid_ops_mask		= REGULATOR_CHANGE_STATUS,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	.num_consumer_supplies	= 1,</span>
<span class="p_add">+	.consumer_supplies	= &amp;bcm43xx_vmmc_supply,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct fixed_voltage_config bcm43xx_vmmc = {</span>
<span class="p_add">+	.supply_name		= &quot;bcm43xx-vmmc-regulator&quot;,</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Announce 2.0V here to be compatible with SDIO specification. The</span>
<span class="p_add">+	 * real voltage and signaling are still 1.8V.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	.microvolts		= 2000000,		/* 1.8V */</span>
<span class="p_add">+	.gpio			= -EINVAL,</span>
<span class="p_add">+	.startup_delay		= 250 * 1000,		/* 250ms */</span>
<span class="p_add">+	.enable_high		= 1,			/* active high */</span>
<span class="p_add">+	.enabled_at_boot	= 0,			/* disabled at boot */</span>
<span class="p_add">+	.init_data		= &amp;bcm43xx_vmmc_data,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_device bcm43xx_vmmc_regulator = {</span>
<span class="p_add">+	.name		= &quot;reg-fixed-voltage&quot;,</span>
<span class="p_add">+	.id		= PLATFORM_DEVID_AUTO,</span>
<span class="p_add">+	.dev = {</span>
<span class="p_add">+		.platform_data	= &amp;bcm43xx_vmmc,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init bcm43xx_regulator_register(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	bcm43xx_vmmc.gpio = get_gpio_by_name(WLAN_SFI_GPIO_ENABLE_NAME);</span>
<span class="p_add">+	ret = platform_device_register(&amp;bcm43xx_vmmc_regulator);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;%s: vmmc regulator register failed\n&quot;, __func__);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init *bcm43xx_platform_data(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = bcm43xx_regulator_register();</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;Using generic wifi platform data\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* For now it&#39;s empty */</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct devs_id bcm43xx_clk_vmmc_dev_id __initconst = {</span>
<span class="p_add">+	.name			= &quot;bcm43xx_clk_vmmc&quot;,</span>
<span class="p_add">+	.type			= SFI_DEV_TYPE_SD,</span>
<span class="p_add">+	.get_platform_data	= &amp;bcm43xx_platform_data,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+sfi_device(bcm43xx_clk_vmmc_dev_id);</span>
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfld_sd.c b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_sd.c</span>
new file mode 100644
<span class="p_header">index 000000000000..00c4a034ad93</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_sd.c</span>
<span class="p_chunk">@@ -0,0 +1,47 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SDHCI platform data initilisation file</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (C) Copyright 2016 Intel Corporation</span>
<span class="p_add">+ * Author: Andy Shevchenko &lt;andriy.shevchenko@linux.intel.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ * modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ * as published by the Free Software Foundation; version 2</span>
<span class="p_add">+ * of the License.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/pci.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/mmc/sdhci-pci-data.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/intel-mid.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define INTEL_MRFLD_SD			2</span>
<span class="p_add">+#define INTEL_MRFLD_SD_CD_GPIO		77</span>
<span class="p_add">+</span>
<span class="p_add">+static struct sdhci_pci_data mrfld_sdhci_pci_data = {</span>
<span class="p_add">+	.rst_n_gpio	= -EINVAL,</span>
<span class="p_add">+	.cd_gpio	= INTEL_MRFLD_SD_CD_GPIO,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct sdhci_pci_data *</span>
<span class="p_add">+mrfld_sdhci_pci_get_data(struct pci_dev *pdev, int slotno)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int func = PCI_FUNC(pdev-&gt;devfn);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (func == INTEL_MRFLD_SD)</span>
<span class="p_add">+		return &amp;mrfld_sdhci_pci_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mrfld_sd_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_TANGIER)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	sdhci_pci_get_data = mrfld_sdhci_pci_get_data;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+arch_initcall(mrfld_sd_init);</span>
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/intel-mid.c b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">index ce119d2ba0d0..7850128f0026 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_chunk">@@ -70,6 +70,11 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(__intel_mid_cpu_chip);</span>
 
 static void intel_mid_power_off(void)
 {
<span class="p_add">+	/* Shut down South Complex via PWRMU */</span>
<span class="p_add">+	intel_mid_pwr_power_off();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only for Tangier, the rest will ignore this command */</span>
<span class="p_add">+	intel_scu_ipc_simple_command(IPCMSG_COLD_OFF, 1);</span>
 };
 
 static void intel_mid_reboot(void)
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/pwr.c b/arch/x86/platform/intel-mid/pwr.c</span>
<span class="p_header">index c901a3423772..5d3b45ad1c03 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/pwr.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/pwr.c</span>
<span class="p_chunk">@@ -44,7 +44,19 @@</span> <span class="p_context"></span>
 /* Bits in PM_CMD */
 #define PM_CMD_CMD(x)		((x) &lt;&lt; 0)
 #define PM_CMD_IOC		(1 &lt;&lt; 8)
<span class="p_del">-#define PM_CMD_D3cold		(1 &lt;&lt; 21)</span>
<span class="p_add">+#define PM_CMD_CM_NOP		(0 &lt;&lt; 9)</span>
<span class="p_add">+#define PM_CMD_CM_IMMEDIATE	(1 &lt;&lt; 9)</span>
<span class="p_add">+#define PM_CMD_CM_DELAY		(2 &lt;&lt; 9)</span>
<span class="p_add">+#define PM_CMD_CM_TRIGGER	(3 &lt;&lt; 9)</span>
<span class="p_add">+</span>
<span class="p_add">+/* System states */</span>
<span class="p_add">+#define PM_CMD_SYS_STATE_S5	(5 &lt;&lt; 16)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Trigger variants */</span>
<span class="p_add">+#define PM_CMD_CFG_TRIGGER_NC	(3 &lt;&lt; 19)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Message to wait for TRIGGER_NC case */</span>
<span class="p_add">+#define TRIGGER_NC_MSG_2	(2 &lt;&lt; 22)</span>
 
 /* List of commands */
 #define CMD_SET_CFG		0x01
<span class="p_chunk">@@ -137,7 +149,7 @@</span> <span class="p_context"> static int mid_pwr_wait(struct mid_pwr *pwr)</span>
 
 static int mid_pwr_wait_for_cmd(struct mid_pwr *pwr, u8 cmd)
 {
<span class="p_del">-	writel(PM_CMD_CMD(cmd), pwr-&gt;regs + PM_CMD);</span>
<span class="p_add">+	writel(PM_CMD_CMD(cmd) | PM_CMD_CM_IMMEDIATE, pwr-&gt;regs + PM_CMD);</span>
 	return mid_pwr_wait(pwr);
 }
 
<span class="p_chunk">@@ -260,6 +272,20 @@</span> <span class="p_context"> int intel_mid_pci_set_power_state(struct pci_dev *pdev, pci_power_t state)</span>
 }
 EXPORT_SYMBOL_GPL(intel_mid_pci_set_power_state);
 
<span class="p_add">+void intel_mid_pwr_power_off(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mid_pwr *pwr = midpwr;</span>
<span class="p_add">+	u32 cmd = PM_CMD_SYS_STATE_S5 |</span>
<span class="p_add">+		  PM_CMD_CMD(CMD_SET_CFG) |</span>
<span class="p_add">+		  PM_CMD_CM_TRIGGER |</span>
<span class="p_add">+		  PM_CMD_CFG_TRIGGER_NC |</span>
<span class="p_add">+		  TRIGGER_NC_MSG_2;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Send command to SCU */</span>
<span class="p_add">+	writel(cmd, pwr-&gt;regs + PM_CMD);</span>
<span class="p_add">+	mid_pwr_wait(pwr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int intel_mid_pwr_get_lss_id(struct pci_dev *pdev)
 {
 	int vndr;
<span class="p_chunk">@@ -354,7 +380,7 @@</span> <span class="p_context"> static int mid_pwr_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 	return 0;
 }
 
<span class="p_del">-static int mid_set_initial_state(struct mid_pwr *pwr)</span>
<span class="p_add">+static int mid_set_initial_state(struct mid_pwr *pwr, const u32 *states)</span>
 {
 	unsigned int i, j;
 	int ret;
<span class="p_chunk">@@ -379,10 +405,10 @@</span> <span class="p_context"> static int mid_set_initial_state(struct mid_pwr *pwr)</span>
 	 * NOTE: The actual device mapping is provided by a platform at run
 	 * time using vendor capability of PCI configuration space.
 	 */
<span class="p_del">-	mid_pwr_set_state(pwr, 0, 0xffffffff);</span>
<span class="p_del">-	mid_pwr_set_state(pwr, 1, 0xffffffff);</span>
<span class="p_del">-	mid_pwr_set_state(pwr, 2, 0xffffffff);</span>
<span class="p_del">-	mid_pwr_set_state(pwr, 3, 0xffffffff);</span>
<span class="p_add">+	mid_pwr_set_state(pwr, 0, states[0]);</span>
<span class="p_add">+	mid_pwr_set_state(pwr, 1, states[1]);</span>
<span class="p_add">+	mid_pwr_set_state(pwr, 2, states[2]);</span>
<span class="p_add">+	mid_pwr_set_state(pwr, 3, states[3]);</span>
 
 	/* Send command to SCU */
 	ret = mid_pwr_wait_for_cmd(pwr, CMD_SET_CFG);
<span class="p_chunk">@@ -397,13 +423,41 @@</span> <span class="p_context"> static int mid_set_initial_state(struct mid_pwr *pwr)</span>
 	return 0;
 }
 
<span class="p_del">-static const struct mid_pwr_device_info mid_info = {</span>
<span class="p_del">-	.set_initial_state = mid_set_initial_state,</span>
<span class="p_add">+static int pnw_set_initial_state(struct mid_pwr *pwr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* On Penwell SRAM must stay powered on */</span>
<span class="p_add">+	const u32 states[] = {</span>
<span class="p_add">+		0xf00fffff,		/* PM_SSC(0) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(1) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(2) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(3) */</span>
<span class="p_add">+	};</span>
<span class="p_add">+	return mid_set_initial_state(pwr, states);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int tng_set_initial_state(struct mid_pwr *pwr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const u32 states[] = {</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(0) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(1) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(2) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(3) */</span>
<span class="p_add">+	};</span>
<span class="p_add">+	return mid_set_initial_state(pwr, states);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct mid_pwr_device_info pnw_info = {</span>
<span class="p_add">+	.set_initial_state = pnw_set_initial_state,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct mid_pwr_device_info tng_info = {</span>
<span class="p_add">+	.set_initial_state = tng_set_initial_state,</span>
 };
 
<span class="p_add">+/* This table should be in sync with the one in drivers/pci/pci-mid.c */</span>
 static const struct pci_device_id mid_pwr_pci_ids[] = {
<span class="p_del">-	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_PENWELL), (kernel_ulong_t)&amp;mid_info },</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_TANGIER), (kernel_ulong_t)&amp;mid_info },</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_PENWELL), (kernel_ulong_t)&amp;pnw_info },</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_TANGIER), (kernel_ulong_t)&amp;tng_info },</span>
 	{}
 };
 
<span class="p_header">diff --git a/arch/x86/platform/mellanox/Makefile b/arch/x86/platform/mellanox/Makefile</span>
new file mode 100644
<span class="p_header">index 000000000000..f43c93188a1d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/platform/mellanox/Makefile</span>
<span class="p_chunk">@@ -0,0 +1 @@</span> <span class="p_context"></span>
<span class="p_add">+obj-$(CONFIG_MLX_PLATFORM)	+= mlx-platform.o</span>
<span class="p_header">diff --git a/arch/x86/platform/mellanox/mlx-platform.c b/arch/x86/platform/mellanox/mlx-platform.c</span>
new file mode 100644
<span class="p_header">index 000000000000..7dcfcca97399</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/platform/mellanox/mlx-platform.c</span>
<span class="p_chunk">@@ -0,0 +1,266 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * arch/x86/platform/mellanox/mlx-platform.c</span>
<span class="p_add">+ * Copyright (c) 2016 Mellanox Technologies. All rights reserved.</span>
<span class="p_add">+ * Copyright (c) 2016 Vadim Pasternak &lt;vadimp@mellanox.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Redistribution and use in source and binary forms, with or without</span>
<span class="p_add">+ * modification, are permitted provided that the following conditions are met:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * 1. Redistributions of source code must retain the above copyright</span>
<span class="p_add">+ *    notice, this list of conditions and the following disclaimer.</span>
<span class="p_add">+ * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="p_add">+ *    notice, this list of conditions and the following disclaimer in the</span>
<span class="p_add">+ *    documentation and/or other materials provided with the distribution.</span>
<span class="p_add">+ * 3. Neither the names of the copyright holders nor the names of its</span>
<span class="p_add">+ *    contributors may be used to endorse or promote products derived from</span>
<span class="p_add">+ *    this software without specific prior written permission.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Alternatively, this software may be distributed under the terms of the</span>
<span class="p_add">+ * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="p_add">+ * Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="p_add">+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="p_add">+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="p_add">+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="p_add">+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="p_add">+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="p_add">+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="p_add">+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="p_add">+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="p_add">+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="p_add">+ * POSSIBILITY OF SUCH DAMAGE.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/device.h&gt;</span>
<span class="p_add">+#include &lt;linux/dmi.h&gt;</span>
<span class="p_add">+#include &lt;linux/i2c.h&gt;</span>
<span class="p_add">+#include &lt;linux/i2c-mux.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_data/i2c-mux-reg.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define MLX_PLAT_DEVICE_NAME		&quot;mlxplat&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+/* LPC bus IO offsets */</span>
<span class="p_add">+#define MLXPLAT_CPLD_LPC_I2C_BASE_ADRR		0x2000</span>
<span class="p_add">+#define MLXPLAT_CPLD_LPC_REG_BASE_ADRR		0x2500</span>
<span class="p_add">+#define MLXPLAT_CPLD_LPC_IO_RANGE		0x100</span>
<span class="p_add">+#define MLXPLAT_CPLD_LPC_I2C_CH1_OFF		0xdb</span>
<span class="p_add">+#define MLXPLAT_CPLD_LPC_I2C_CH2_OFF		0xda</span>
<span class="p_add">+#define MLXPLAT_CPLD_LPC_PIO_OFFSET		0x10000UL</span>
<span class="p_add">+#define MLXPLAT_CPLD_LPC_REG1	((MLXPLAT_CPLD_LPC_REG_BASE_ADRR + \</span>
<span class="p_add">+				  MLXPLAT_CPLD_LPC_I2C_CH1_OFF) | \</span>
<span class="p_add">+				  MLXPLAT_CPLD_LPC_PIO_OFFSET)</span>
<span class="p_add">+#define MLXPLAT_CPLD_LPC_REG2	((MLXPLAT_CPLD_LPC_REG_BASE_ADRR + \</span>
<span class="p_add">+				  MLXPLAT_CPLD_LPC_I2C_CH2_OFF) | \</span>
<span class="p_add">+				  MLXPLAT_CPLD_LPC_PIO_OFFSET)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Start channel numbers */</span>
<span class="p_add">+#define MLXPLAT_CPLD_CH1			2</span>
<span class="p_add">+#define MLXPLAT_CPLD_CH2			10</span>
<span class="p_add">+</span>
<span class="p_add">+/* Number of LPC attached MUX platform devices */</span>
<span class="p_add">+#define MLXPLAT_CPLD_LPC_MUX_DEVS		2</span>
<span class="p_add">+</span>
<span class="p_add">+/* mlxplat_priv - platform private data</span>
<span class="p_add">+ * @pdev_i2c - i2c controller platform device</span>
<span class="p_add">+ * @pdev_mux - array of mux platform devices</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct mlxplat_priv {</span>
<span class="p_add">+	struct platform_device *pdev_i2c;</span>
<span class="p_add">+	struct platform_device *pdev_mux[MLXPLAT_CPLD_LPC_MUX_DEVS];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Regions for LPC I2C controller and LPC base register space */</span>
<span class="p_add">+static const struct resource mlxplat_lpc_resources[] = {</span>
<span class="p_add">+	[0] = DEFINE_RES_NAMED(MLXPLAT_CPLD_LPC_I2C_BASE_ADRR,</span>
<span class="p_add">+			       MLXPLAT_CPLD_LPC_IO_RANGE,</span>
<span class="p_add">+			       &quot;mlxplat_cpld_lpc_i2c_ctrl&quot;, IORESOURCE_IO),</span>
<span class="p_add">+	[1] = DEFINE_RES_NAMED(MLXPLAT_CPLD_LPC_REG_BASE_ADRR,</span>
<span class="p_add">+			       MLXPLAT_CPLD_LPC_IO_RANGE,</span>
<span class="p_add">+			       &quot;mlxplat_cpld_lpc_regs&quot;,</span>
<span class="p_add">+			       IORESOURCE_IO),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Platform default channels */</span>
<span class="p_add">+static const int mlxplat_default_channels[][8] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		MLXPLAT_CPLD_CH1, MLXPLAT_CPLD_CH1 + 1, MLXPLAT_CPLD_CH1 + 2,</span>
<span class="p_add">+		MLXPLAT_CPLD_CH1 + 3, MLXPLAT_CPLD_CH1 + 4, MLXPLAT_CPLD_CH1 +</span>
<span class="p_add">+		5, MLXPLAT_CPLD_CH1 + 6, MLXPLAT_CPLD_CH1 + 7</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		MLXPLAT_CPLD_CH2, MLXPLAT_CPLD_CH2 + 1, MLXPLAT_CPLD_CH2 + 2,</span>
<span class="p_add">+		MLXPLAT_CPLD_CH2 + 3, MLXPLAT_CPLD_CH2 + 4, MLXPLAT_CPLD_CH2 +</span>
<span class="p_add">+		5, MLXPLAT_CPLD_CH2 + 6, MLXPLAT_CPLD_CH2 + 7</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Platform channels for MSN21xx system family */</span>
<span class="p_add">+static const int mlxplat_msn21xx_channels[] = { 1, 2, 3, 4, 5, 6, 7, 8 };</span>
<span class="p_add">+</span>
<span class="p_add">+/* Platform mux data */</span>
<span class="p_add">+static struct i2c_mux_reg_platform_data mlxplat_mux_data[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.parent = 1,</span>
<span class="p_add">+		.base_nr = MLXPLAT_CPLD_CH1,</span>
<span class="p_add">+		.write_only = 1,</span>
<span class="p_add">+		.reg = (void __iomem *)MLXPLAT_CPLD_LPC_REG1,</span>
<span class="p_add">+		.reg_size = 1,</span>
<span class="p_add">+		.idle_in_use = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.parent = 1,</span>
<span class="p_add">+		.base_nr = MLXPLAT_CPLD_CH2,</span>
<span class="p_add">+		.write_only = 1,</span>
<span class="p_add">+		.reg = (void __iomem *)MLXPLAT_CPLD_LPC_REG2,</span>
<span class="p_add">+		.reg_size = 1,</span>
<span class="p_add">+		.idle_in_use = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_device *mlxplat_dev;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mlxplat_dmi_default_matched(const struct dmi_system_id *dmi)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(mlxplat_mux_data); i++) {</span>
<span class="p_add">+		mlxplat_mux_data[i].values = mlxplat_default_channels[i];</span>
<span class="p_add">+		mlxplat_mux_data[i].n_values =</span>
<span class="p_add">+				ARRAY_SIZE(mlxplat_default_channels[i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mlxplat_dmi_msn21xx_matched(const struct dmi_system_id *dmi)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(mlxplat_mux_data); i++) {</span>
<span class="p_add">+		mlxplat_mux_data[i].values = mlxplat_msn21xx_channels;</span>
<span class="p_add">+		mlxplat_mux_data[i].n_values =</span>
<span class="p_add">+				ARRAY_SIZE(mlxplat_msn21xx_channels);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct dmi_system_id mlxplat_dmi_table[] __initdata = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = mlxplat_dmi_default_matched,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;Mellanox Technologies&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MSN24&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = mlxplat_dmi_default_matched,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;Mellanox Technologies&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MSN27&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = mlxplat_dmi_default_matched,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;Mellanox Technologies&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MSB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = mlxplat_dmi_default_matched,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;Mellanox Technologies&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MSX&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = mlxplat_dmi_msn21xx_matched,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;Mellanox Technologies&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MSN21&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mlxplat_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlxplat_priv *priv;</span>
<span class="p_add">+	int i, err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dmi_check_system(mlxplat_dmi_table))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	mlxplat_dev = platform_device_register_simple(MLX_PLAT_DEVICE_NAME, -1,</span>
<span class="p_add">+					mlxplat_lpc_resources,</span>
<span class="p_add">+					ARRAY_SIZE(mlxplat_lpc_resources));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ERR(mlxplat_dev))</span>
<span class="p_add">+		return PTR_ERR(mlxplat_dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = devm_kzalloc(&amp;mlxplat_dev-&gt;dev, sizeof(struct mlxplat_priv),</span>
<span class="p_add">+			    GFP_KERNEL);</span>
<span class="p_add">+	if (!priv) {</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto fail_alloc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	platform_set_drvdata(mlxplat_dev, priv);</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;pdev_i2c = platform_device_register_simple(&quot;i2c_mlxcpld&quot;, -1,</span>
<span class="p_add">+							 NULL, 0);</span>
<span class="p_add">+	if (IS_ERR(priv-&gt;pdev_i2c)) {</span>
<span class="p_add">+		err = PTR_ERR(priv-&gt;pdev_i2c);</span>
<span class="p_add">+		goto fail_alloc;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(mlxplat_mux_data); i++) {</span>
<span class="p_add">+		priv-&gt;pdev_mux[i] = platform_device_register_resndata(</span>
<span class="p_add">+						&amp;mlxplat_dev-&gt;dev,</span>
<span class="p_add">+						&quot;i2c-mux-reg&quot;, i, NULL,</span>
<span class="p_add">+						0, &amp;mlxplat_mux_data[i],</span>
<span class="p_add">+						sizeof(mlxplat_mux_data[i]));</span>
<span class="p_add">+		if (IS_ERR(priv-&gt;pdev_mux[i])) {</span>
<span class="p_add">+			err = PTR_ERR(priv-&gt;pdev_mux[i]);</span>
<span class="p_add">+			goto fail_platform_mux_register;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+fail_platform_mux_register:</span>
<span class="p_add">+	for (i--; i &gt; 0 ; i--)</span>
<span class="p_add">+		platform_device_unregister(priv-&gt;pdev_mux[i]);</span>
<span class="p_add">+	platform_device_unregister(priv-&gt;pdev_i2c);</span>
<span class="p_add">+fail_alloc:</span>
<span class="p_add">+	platform_device_unregister(mlxplat_dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+module_init(mlxplat_init);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit mlxplat_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlxplat_priv *priv = platform_get_drvdata(mlxplat_dev);</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = ARRAY_SIZE(mlxplat_mux_data) - 1; i &gt;= 0 ; i--)</span>
<span class="p_add">+		platform_device_unregister(priv-&gt;pdev_mux[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+	platform_device_unregister(priv-&gt;pdev_i2c);</span>
<span class="p_add">+	platform_device_unregister(mlxplat_dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+module_exit(mlxplat_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Vadim Pasternak (vadimp@mellanox.com)&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;Mellanox platform driver&quot;);</span>
<span class="p_add">+MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;dmi:*:*Mellanox*:MSN24*:&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;dmi:*:*Mellanox*:MSN27*:&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;dmi:*:*Mellanox*:MSB*:&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;dmi:*:*Mellanox*:MSX*:&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;dmi:*:*Mellanox*:MSN21*:&quot;);</span>
<span class="p_header">diff --git a/arch/x86/platform/uv/tlb_uv.c b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">index fdb4d42b4ce5..56c5a3a3884a 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_chunk">@@ -24,6 +24,29 @@</span> <span class="p_context"></span>
 #include &lt;asm/irq_vectors.h&gt;
 #include &lt;asm/timer.h&gt;
 
<span class="p_add">+static struct bau_operations ops;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct bau_operations uv123_bau_ops = {</span>
<span class="p_add">+	.bau_gpa_to_offset       = uv_gpa_to_offset,</span>
<span class="p_add">+	.read_l_sw_ack           = read_mmr_sw_ack,</span>
<span class="p_add">+	.read_g_sw_ack           = read_gmmr_sw_ack,</span>
<span class="p_add">+	.write_l_sw_ack          = write_mmr_sw_ack,</span>
<span class="p_add">+	.write_g_sw_ack          = write_gmmr_sw_ack,</span>
<span class="p_add">+	.write_payload_first     = write_mmr_payload_first,</span>
<span class="p_add">+	.write_payload_last      = write_mmr_payload_last,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct bau_operations uv4_bau_ops = {</span>
<span class="p_add">+	.bau_gpa_to_offset       = uv_gpa_to_soc_phys_ram,</span>
<span class="p_add">+	.read_l_sw_ack           = read_mmr_proc_sw_ack,</span>
<span class="p_add">+	.read_g_sw_ack           = read_gmmr_proc_sw_ack,</span>
<span class="p_add">+	.write_l_sw_ack          = write_mmr_proc_sw_ack,</span>
<span class="p_add">+	.write_g_sw_ack          = write_gmmr_proc_sw_ack,</span>
<span class="p_add">+	.write_payload_first     = write_mmr_proc_payload_first,</span>
<span class="p_add">+	.write_payload_last      = write_mmr_proc_payload_last,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 /* timeouts in nanoseconds (indexed by UVH_AGING_PRESCALE_SEL urgency7 30:28) */
 static int timeout_base_ns[] = {
 		20,
<span class="p_chunk">@@ -55,16 +78,16 @@</span> <span class="p_context"> static int congested_reps	= CONGESTED_REPS;</span>
 static int disabled_period	= DISABLED_PERIOD;
 
 static struct tunables tunables[] = {
<span class="p_del">-	{&amp;max_concurr, MAX_BAU_CONCURRENT}, /* must be [0] */</span>
<span class="p_del">-	{&amp;plugged_delay, PLUGGED_DELAY},</span>
<span class="p_del">-	{&amp;plugsb4reset, PLUGSB4RESET},</span>
<span class="p_del">-	{&amp;timeoutsb4reset, TIMEOUTSB4RESET},</span>
<span class="p_del">-	{&amp;ipi_reset_limit, IPI_RESET_LIMIT},</span>
<span class="p_del">-	{&amp;complete_threshold, COMPLETE_THRESHOLD},</span>
<span class="p_del">-	{&amp;congested_respns_us, CONGESTED_RESPONSE_US},</span>
<span class="p_del">-	{&amp;congested_reps, CONGESTED_REPS},</span>
<span class="p_del">-	{&amp;disabled_period, DISABLED_PERIOD},</span>
<span class="p_del">-	{&amp;giveup_limit, GIVEUP_LIMIT}</span>
<span class="p_add">+	{&amp;max_concurr,           MAX_BAU_CONCURRENT}, /* must be [0] */</span>
<span class="p_add">+	{&amp;plugged_delay,         PLUGGED_DELAY},</span>
<span class="p_add">+	{&amp;plugsb4reset,          PLUGSB4RESET},</span>
<span class="p_add">+	{&amp;timeoutsb4reset,       TIMEOUTSB4RESET},</span>
<span class="p_add">+	{&amp;ipi_reset_limit,       IPI_RESET_LIMIT},</span>
<span class="p_add">+	{&amp;complete_threshold,    COMPLETE_THRESHOLD},</span>
<span class="p_add">+	{&amp;congested_respns_us,   CONGESTED_RESPONSE_US},</span>
<span class="p_add">+	{&amp;congested_reps,        CONGESTED_REPS},</span>
<span class="p_add">+	{&amp;disabled_period,       DISABLED_PERIOD},</span>
<span class="p_add">+	{&amp;giveup_limit,          GIVEUP_LIMIT}</span>
 };
 
 static struct dentry *tunables_dir;
<span class="p_chunk">@@ -216,7 +239,7 @@</span> <span class="p_context"> static void reply_to_message(struct msg_desc *mdp, struct bau_control *bcp,</span>
 	msg = mdp-&gt;msg;
 	if (!msg-&gt;canceled &amp;&amp; do_acknowledge) {
 		dw = (msg-&gt;swack_vec &lt;&lt; UV_SW_ACK_NPENDING) | msg-&gt;swack_vec;
<span class="p_del">-		write_mmr_sw_ack(dw);</span>
<span class="p_add">+		ops.write_l_sw_ack(dw);</span>
 	}
 	msg-&gt;replied_to = 1;
 	msg-&gt;swack_vec = 0;
<span class="p_chunk">@@ -252,7 +275,7 @@</span> <span class="p_context"> static void bau_process_retry_msg(struct msg_desc *mdp,</span>
 			msg-&gt;swack_vec) == 0) &amp;&amp;
 		    (msg2-&gt;sending_cpu == msg-&gt;sending_cpu) &amp;&amp;
 		    (msg2-&gt;msg_type != MSG_NOOP)) {
<span class="p_del">-			mmr = read_mmr_sw_ack();</span>
<span class="p_add">+			mmr = ops.read_l_sw_ack();</span>
 			msg_res = msg2-&gt;swack_vec;
 			/*
 			 * This is a message retry; clear the resources held
<span class="p_chunk">@@ -270,7 +293,7 @@</span> <span class="p_context"> static void bau_process_retry_msg(struct msg_desc *mdp,</span>
 				stat-&gt;d_canceled++;
 				cancel_count++;
 				mr = (msg_res &lt;&lt; UV_SW_ACK_NPENDING) | msg_res;
<span class="p_del">-				write_mmr_sw_ack(mr);</span>
<span class="p_add">+				ops.write_l_sw_ack(mr);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -403,12 +426,12 @@</span> <span class="p_context"> static void do_reset(void *ptr)</span>
 			/*
 			 * only reset the resource if it is still pending
 			 */
<span class="p_del">-			mmr = read_mmr_sw_ack();</span>
<span class="p_add">+			mmr = ops.read_l_sw_ack();</span>
 			msg_res = msg-&gt;swack_vec;
 			mr = (msg_res &lt;&lt; UV_SW_ACK_NPENDING) | msg_res;
 			if (mmr &amp; msg_res) {
 				stat-&gt;d_rcanceled++;
<span class="p_del">-				write_mmr_sw_ack(mr);</span>
<span class="p_add">+				ops.write_l_sw_ack(mr);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1202,7 +1225,7 @@</span> <span class="p_context"> void process_uv2_message(struct msg_desc *mdp, struct bau_control *bcp)</span>
 	struct bau_pq_entry *msg = mdp-&gt;msg;
 	struct bau_pq_entry *other_msg;
 
<span class="p_del">-	mmr_image = read_mmr_sw_ack();</span>
<span class="p_add">+	mmr_image = ops.read_l_sw_ack();</span>
 	swack_vec = msg-&gt;swack_vec;
 
 	if ((swack_vec &amp; mmr_image) == 0) {
<span class="p_chunk">@@ -1431,7 +1454,7 @@</span> <span class="p_context"> static int ptc_seq_show(struct seq_file *file, void *data)</span>
 		/* destination side statistics */
 		seq_printf(file,
 			&quot;%lx %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld\n&quot;,
<span class="p_del">-			   read_gmmr_sw_ack(uv_cpu_to_pnode(cpu)),</span>
<span class="p_add">+			   ops.read_g_sw_ack(uv_cpu_to_pnode(cpu)),</span>
 			   stat-&gt;d_requestee, cycles_2_us(stat-&gt;d_time),
 			   stat-&gt;d_alltlb, stat-&gt;d_onetlb, stat-&gt;d_multmsg,
 			   stat-&gt;d_nomsg, stat-&gt;d_retries, stat-&gt;d_canceled,
<span class="p_chunk">@@ -1497,16 +1520,16 @@</span> <span class="p_context"> static ssize_t ptc_proc_write(struct file *file, const char __user *user,</span>
 	}
 
 	if (kstrtol(optstr, 10, &amp;input_arg) &lt; 0) {
<span class="p_del">-		printk(KERN_DEBUG &quot;%s is invalid\n&quot;, optstr);</span>
<span class="p_add">+		pr_debug(&quot;%s is invalid\n&quot;, optstr);</span>
 		return -EINVAL;
 	}
 
 	if (input_arg == 0) {
 		elements = ARRAY_SIZE(stat_description);
<span class="p_del">-		printk(KERN_DEBUG &quot;# cpu:      cpu number\n&quot;);</span>
<span class="p_del">-		printk(KERN_DEBUG &quot;Sender statistics:\n&quot;);</span>
<span class="p_add">+		pr_debug(&quot;# cpu:      cpu number\n&quot;);</span>
<span class="p_add">+		pr_debug(&quot;Sender statistics:\n&quot;);</span>
 		for (i = 0; i &lt; elements; i++)
<span class="p_del">-			printk(KERN_DEBUG &quot;%s\n&quot;, stat_description[i]);</span>
<span class="p_add">+			pr_debug(&quot;%s\n&quot;, stat_description[i]);</span>
 	} else if (input_arg == -1) {
 		for_each_present_cpu(cpu) {
 			stat = &amp;per_cpu(ptcstats, cpu);
<span class="p_chunk">@@ -1554,7 +1577,7 @@</span> <span class="p_context"> static int parse_tunables_write(struct bau_control *bcp, char *instr,</span>
 			break;
 	}
 	if (cnt != e) {
<span class="p_del">-		printk(KERN_INFO &quot;bau tunable error: should be %d values\n&quot;, e);</span>
<span class="p_add">+		pr_info(&quot;bau tunable error: should be %d values\n&quot;, e);</span>
 		return -EINVAL;
 	}
 
<span class="p_chunk">@@ -1571,7 +1594,7 @@</span> <span class="p_context"> static int parse_tunables_write(struct bau_control *bcp, char *instr,</span>
 				continue;
 			}
 			if (val &lt; 1 || val &gt; bcp-&gt;cpus_in_uvhub) {
<span class="p_del">-				printk(KERN_DEBUG</span>
<span class="p_add">+				pr_debug(</span>
 				&quot;Error: BAU max concurrent %d is invalid\n&quot;,
 				val);
 				return -EINVAL;
<span class="p_chunk">@@ -1619,17 +1642,17 @@</span> <span class="p_context"> static ssize_t tunables_write(struct file *file, const char __user *user,</span>
 
 	for_each_present_cpu(cpu) {
 		bcp = &amp;per_cpu(bau_control, cpu);
<span class="p_del">-		bcp-&gt;max_concurr =		max_concurr;</span>
<span class="p_del">-		bcp-&gt;max_concurr_const =	max_concurr;</span>
<span class="p_del">-		bcp-&gt;plugged_delay =		plugged_delay;</span>
<span class="p_del">-		bcp-&gt;plugsb4reset =		plugsb4reset;</span>
<span class="p_del">-		bcp-&gt;timeoutsb4reset =		timeoutsb4reset;</span>
<span class="p_del">-		bcp-&gt;ipi_reset_limit =		ipi_reset_limit;</span>
<span class="p_del">-		bcp-&gt;complete_threshold =	complete_threshold;</span>
<span class="p_del">-		bcp-&gt;cong_response_us =		congested_respns_us;</span>
<span class="p_del">-		bcp-&gt;cong_reps =		congested_reps;</span>
<span class="p_del">-		bcp-&gt;disabled_period =		sec_2_cycles(disabled_period);</span>
<span class="p_del">-		bcp-&gt;giveup_limit =		giveup_limit;</span>
<span class="p_add">+		bcp-&gt;max_concurr         = max_concurr;</span>
<span class="p_add">+		bcp-&gt;max_concurr_const   = max_concurr;</span>
<span class="p_add">+		bcp-&gt;plugged_delay       = plugged_delay;</span>
<span class="p_add">+		bcp-&gt;plugsb4reset        = plugsb4reset;</span>
<span class="p_add">+		bcp-&gt;timeoutsb4reset     = timeoutsb4reset;</span>
<span class="p_add">+		bcp-&gt;ipi_reset_limit     = ipi_reset_limit;</span>
<span class="p_add">+		bcp-&gt;complete_threshold  = complete_threshold;</span>
<span class="p_add">+		bcp-&gt;cong_response_us    = congested_respns_us;</span>
<span class="p_add">+		bcp-&gt;cong_reps           = congested_reps;</span>
<span class="p_add">+		bcp-&gt;disabled_period     = sec_2_cycles(disabled_period);</span>
<span class="p_add">+		bcp-&gt;giveup_limit        = giveup_limit;</span>
 	}
 	return count;
 }
<span class="p_chunk">@@ -1676,21 +1699,21 @@</span> <span class="p_context"> static int __init uv_ptc_init(void)</span>
 	proc_uv_ptc = proc_create(UV_PTC_BASENAME, 0444, NULL,
 				  &amp;proc_uv_ptc_operations);
 	if (!proc_uv_ptc) {
<span class="p_del">-		printk(KERN_ERR &quot;unable to create %s proc entry\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;unable to create %s proc entry\n&quot;,</span>
 		       UV_PTC_BASENAME);
 		return -EINVAL;
 	}
 
 	tunables_dir = debugfs_create_dir(UV_BAU_TUNABLES_DIR, NULL);
 	if (!tunables_dir) {
<span class="p_del">-		printk(KERN_ERR &quot;unable to create debugfs directory %s\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;unable to create debugfs directory %s\n&quot;,</span>
 		       UV_BAU_TUNABLES_DIR);
 		return -EINVAL;
 	}
 	tunables_file = debugfs_create_file(UV_BAU_TUNABLES_FILE, 0600,
 					tunables_dir, NULL, &amp;tunables_fops);
 	if (!tunables_file) {
<span class="p_del">-		printk(KERN_ERR &quot;unable to create debugfs file %s\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;unable to create debugfs file %s\n&quot;,</span>
 		       UV_BAU_TUNABLES_FILE);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -1725,7 +1748,7 @@</span> <span class="p_context"> static void activation_descriptor_init(int node, int pnode, int base_pnode)</span>
 
 	gpa = uv_gpa(bau_desc);
 	n = uv_gpa_to_gnode(gpa);
<span class="p_del">-	m = uv_gpa_to_offset(gpa);</span>
<span class="p_add">+	m = ops.bau_gpa_to_offset(gpa);</span>
 	if (is_uv1_hub())
 		uv1 = 1;
 
<span class="p_chunk">@@ -1740,7 +1763,7 @@</span> <span class="p_context"> static void activation_descriptor_init(int node, int pnode, int base_pnode)</span>
 		memset(bd2, 0, sizeof(struct bau_desc));
 		if (uv1) {
 			uv1_hdr = &amp;bd2-&gt;header.uv1_hdr;
<span class="p_del">-			uv1_hdr-&gt;swack_flag =	1;</span>
<span class="p_add">+			uv1_hdr-&gt;swack_flag = 1;</span>
 			/*
 			 * The base_dest_nasid set in the message header
 			 * is the nasid of the first uvhub in the partition.
<span class="p_chunk">@@ -1749,10 +1772,10 @@</span> <span class="p_context"> static void activation_descriptor_init(int node, int pnode, int base_pnode)</span>
 			 * if nasid striding is being used.
 			 */
 			uv1_hdr-&gt;base_dest_nasid =
<span class="p_del">-						UV_PNODE_TO_NASID(base_pnode);</span>
<span class="p_del">-			uv1_hdr-&gt;dest_subnodeid =	UV_LB_SUBNODEID;</span>
<span class="p_del">-			uv1_hdr-&gt;command =		UV_NET_ENDPOINT_INTD;</span>
<span class="p_del">-			uv1_hdr-&gt;int_both =		1;</span>
<span class="p_add">+			                          UV_PNODE_TO_NASID(base_pnode);</span>
<span class="p_add">+			uv1_hdr-&gt;dest_subnodeid  = UV_LB_SUBNODEID;</span>
<span class="p_add">+			uv1_hdr-&gt;command         = UV_NET_ENDPOINT_INTD;</span>
<span class="p_add">+			uv1_hdr-&gt;int_both        = 1;</span>
 			/*
 			 * all others need to be set to zero:
 			 *   fairness chaining multilevel count replied_to
<span class="p_chunk">@@ -1763,11 +1786,11 @@</span> <span class="p_context"> static void activation_descriptor_init(int node, int pnode, int base_pnode)</span>
 			 * uses native mode for selective broadcasts.
 			 */
 			uv2_3_hdr = &amp;bd2-&gt;header.uv2_3_hdr;
<span class="p_del">-			uv2_3_hdr-&gt;swack_flag =	1;</span>
<span class="p_add">+			uv2_3_hdr-&gt;swack_flag      = 1;</span>
 			uv2_3_hdr-&gt;base_dest_nasid =
<span class="p_del">-						UV_PNODE_TO_NASID(base_pnode);</span>
<span class="p_del">-			uv2_3_hdr-&gt;dest_subnodeid =	UV_LB_SUBNODEID;</span>
<span class="p_del">-			uv2_3_hdr-&gt;command =		UV_NET_ENDPOINT_INTD;</span>
<span class="p_add">+			                          UV_PNODE_TO_NASID(base_pnode);</span>
<span class="p_add">+			uv2_3_hdr-&gt;dest_subnodeid  = UV_LB_SUBNODEID;</span>
<span class="p_add">+			uv2_3_hdr-&gt;command         = UV_NET_ENDPOINT_INTD;</span>
 		}
 	}
 	for_each_present_cpu(cpu) {
<span class="p_chunk">@@ -1790,10 +1813,7 @@</span> <span class="p_context"> static void pq_init(int node, int pnode)</span>
 	size_t plsize;
 	char *cp;
 	void *vp;
<span class="p_del">-	unsigned long pn;</span>
<span class="p_del">-	unsigned long first;</span>
<span class="p_del">-	unsigned long pn_first;</span>
<span class="p_del">-	unsigned long last;</span>
<span class="p_add">+	unsigned long gnode, first, last, tail;</span>
 	struct bau_pq_entry *pqp;
 	struct bau_control *bcp;
 
<span class="p_chunk">@@ -1814,17 +1834,25 @@</span> <span class="p_context"> static void pq_init(int node, int pnode)</span>
 		bcp-&gt;bau_msg_head	= pqp;
 		bcp-&gt;queue_last		= pqp + (DEST_Q_SIZE - 1);
 	}
<span class="p_add">+</span>
<span class="p_add">+	first = ops.bau_gpa_to_offset(uv_gpa(pqp));</span>
<span class="p_add">+	last = ops.bau_gpa_to_offset(uv_gpa(pqp + (DEST_Q_SIZE - 1)));</span>
<span class="p_add">+</span>
 	/*
<span class="p_del">-	 * need the gnode of where the memory was really allocated</span>
<span class="p_add">+	 * Pre UV4, the gnode is required to locate the payload queue</span>
<span class="p_add">+	 * and the payload queue tail must be maintained by the kernel.</span>
 	 */
<span class="p_del">-	pn = uv_gpa_to_gnode(uv_gpa(pqp));</span>
<span class="p_del">-	first = uv_physnodeaddr(pqp);</span>
<span class="p_del">-	pn_first = ((unsigned long)pn &lt;&lt; UV_PAYLOADQ_PNODE_SHIFT) | first;</span>
<span class="p_del">-	last = uv_physnodeaddr(pqp + (DEST_Q_SIZE - 1));</span>
<span class="p_del">-	write_mmr_payload_first(pnode, pn_first);</span>
<span class="p_del">-	write_mmr_payload_tail(pnode, first);</span>
<span class="p_del">-	write_mmr_payload_last(pnode, last);</span>
<span class="p_del">-	write_gmmr_sw_ack(pnode, 0xffffUL);</span>
<span class="p_add">+	bcp = &amp;per_cpu(bau_control, smp_processor_id());</span>
<span class="p_add">+	if (bcp-&gt;uvhub_version &lt;= 3) {</span>
<span class="p_add">+		tail = first;</span>
<span class="p_add">+		gnode = uv_gpa_to_gnode(uv_gpa(pqp));</span>
<span class="p_add">+		first = (gnode &lt;&lt; UV_PAYLOADQ_GNODE_SHIFT) | tail;</span>
<span class="p_add">+		write_mmr_payload_tail(pnode, tail);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ops.write_payload_first(pnode, first);</span>
<span class="p_add">+	ops.write_payload_last(pnode, last);</span>
<span class="p_add">+	ops.write_g_sw_ack(pnode, 0xffffUL);</span>
 
 	/* in effect, all msg_type&#39;s are set to MSG_NOOP */
 	memset(pqp, 0, sizeof(struct bau_pq_entry) * DEST_Q_SIZE);
<span class="p_chunk">@@ -1914,8 +1942,8 @@</span> <span class="p_context"> static void __init init_per_cpu_tunables(void)</span>
 		bcp-&gt;complete_threshold		= complete_threshold;
 		bcp-&gt;cong_response_us		= congested_respns_us;
 		bcp-&gt;cong_reps			= congested_reps;
<span class="p_del">-		bcp-&gt;disabled_period =		sec_2_cycles(disabled_period);</span>
<span class="p_del">-		bcp-&gt;giveup_limit =		giveup_limit;</span>
<span class="p_add">+		bcp-&gt;disabled_period		= sec_2_cycles(disabled_period);</span>
<span class="p_add">+		bcp-&gt;giveup_limit		= giveup_limit;</span>
 		spin_lock_init(&amp;bcp-&gt;queue_lock);
 		spin_lock_init(&amp;bcp-&gt;uvhub_lock);
 		spin_lock_init(&amp;bcp-&gt;disable_lock);
<span class="p_chunk">@@ -1944,7 +1972,7 @@</span> <span class="p_context"> static int __init get_cpu_topology(int base_pnode,</span>
 
 		pnode = uv_cpu_hub_info(cpu)-&gt;pnode;
 		if ((pnode - base_pnode) &gt;= UV_DISTRIBUTION_SIZE) {
<span class="p_del">-			printk(KERN_EMERG</span>
<span class="p_add">+			pr_emerg(</span>
 				&quot;cpu %d pnode %d-%d beyond %d; BAU disabled\n&quot;,
 				cpu, pnode, base_pnode, UV_DISTRIBUTION_SIZE);
 			return 1;
<span class="p_chunk">@@ -1969,7 +1997,7 @@</span> <span class="p_context"> static int __init get_cpu_topology(int base_pnode,</span>
 		sdp-&gt;cpu_number[sdp-&gt;num_cpus] = cpu;
 		sdp-&gt;num_cpus++;
 		if (sdp-&gt;num_cpus &gt; MAX_CPUS_PER_SOCKET) {
<span class="p_del">-			printk(KERN_EMERG &quot;%d cpus per socket invalid\n&quot;,</span>
<span class="p_add">+			pr_emerg(&quot;%d cpus per socket invalid\n&quot;,</span>
 				sdp-&gt;num_cpus);
 			return 1;
 		}
<span class="p_chunk">@@ -2035,15 +2063,17 @@</span> <span class="p_context"> static int scan_sock(struct socket_desc *sdp, struct uvhub_desc *bdp,</span>
 			bcp-&gt;uvhub_version = 2;
 		else if (is_uv3_hub())
 			bcp-&gt;uvhub_version = 3;
<span class="p_add">+		else if (is_uv4_hub())</span>
<span class="p_add">+			bcp-&gt;uvhub_version = 4;</span>
 		else {
<span class="p_del">-			printk(KERN_EMERG &quot;uvhub version not 1, 2 or 3\n&quot;);</span>
<span class="p_add">+			pr_emerg(&quot;uvhub version not 1, 2, 3, or 4\n&quot;);</span>
 			return 1;
 		}
 		bcp-&gt;uvhub_master = *hmasterp;
 		bcp-&gt;uvhub_cpu = uv_cpu_blade_processor_id(cpu);
 
 		if (bcp-&gt;uvhub_cpu &gt;= MAX_CPUS_PER_UVHUB) {
<span class="p_del">-			printk(KERN_EMERG &quot;%d cpus per uvhub invalid\n&quot;,</span>
<span class="p_add">+			pr_emerg(&quot;%d cpus per uvhub invalid\n&quot;,</span>
 				bcp-&gt;uvhub_cpu);
 			return 1;
 		}
<span class="p_chunk">@@ -2098,7 +2128,8 @@</span> <span class="p_context"> static int __init init_per_cpu(int nuvhubs, int base_part_pnode)</span>
 	void *vp;
 	struct uvhub_desc *uvhub_descs;
 
<span class="p_del">-	timeout_us = calculate_destination_timeout();</span>
<span class="p_add">+	if (is_uv3_hub() || is_uv2_hub() || is_uv1_hub())</span>
<span class="p_add">+		timeout_us = calculate_destination_timeout();</span>
 
 	vp = kmalloc(nuvhubs * sizeof(struct uvhub_desc), GFP_KERNEL);
 	uvhub_descs = (struct uvhub_desc *)vp;
<span class="p_chunk">@@ -2138,6 +2169,15 @@</span> <span class="p_context"> static int __init uv_bau_init(void)</span>
 	if (!is_uv_system())
 		return 0;
 
<span class="p_add">+	if (is_uv4_hub())</span>
<span class="p_add">+		ops = uv4_bau_ops;</span>
<span class="p_add">+	else if (is_uv3_hub())</span>
<span class="p_add">+		ops = uv123_bau_ops;</span>
<span class="p_add">+	else if (is_uv2_hub())</span>
<span class="p_add">+		ops = uv123_bau_ops;</span>
<span class="p_add">+	else if (is_uv1_hub())</span>
<span class="p_add">+		ops = uv123_bau_ops;</span>
<span class="p_add">+</span>
 	for_each_possible_cpu(cur_cpu) {
 		mask = &amp;per_cpu(uv_flush_tlb_mask, cur_cpu);
 		zalloc_cpumask_var_node(mask, GFP_KERNEL, cpu_to_node(cur_cpu));
<span class="p_chunk">@@ -2153,7 +2193,9 @@</span> <span class="p_context"> static int __init uv_bau_init(void)</span>
 			uv_base_pnode = uv_blade_to_pnode(uvhub);
 	}
 
<span class="p_del">-	enable_timeouts();</span>
<span class="p_add">+	/* software timeouts are not supported on UV4 */</span>
<span class="p_add">+	if (is_uv3_hub() || is_uv2_hub() || is_uv1_hub())</span>
<span class="p_add">+		enable_timeouts();</span>
 
 	if (init_per_cpu(nuvhubs, uv_base_pnode)) {
 		set_bau_off();
<span class="p_header">diff --git a/drivers/pci/pci-mid.c b/drivers/pci/pci-mid.c</span>
<span class="p_header">index c878aa71173b..55f453de562e 100644</span>
<span class="p_header">--- a/drivers/pci/pci-mid.c</span>
<span class="p_header">+++ b/drivers/pci/pci-mid.c</span>
<span class="p_chunk">@@ -60,8 +60,13 @@</span> <span class="p_context"> static struct pci_platform_pm_ops mid_pci_platform_pm = {</span>
 
 #define ICPU(model)	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * This table should be in sync with the one in</span>
<span class="p_add">+ * arch/x86/platform/intel-mid/pwr.c.</span>
<span class="p_add">+ */</span>
 static const struct x86_cpu_id lpss_cpu_ids[] = {
<span class="p_del">-	ICPU(INTEL_FAM6_ATOM_MERRIFIELD1),</span>
<span class="p_add">+	ICPU(INTEL_FAM6_ATOM_PENWELL),</span>
<span class="p_add">+	ICPU(INTEL_FAM6_ATOM_MERRIFIELD),</span>
 	{}
 };
 
<span class="p_header">diff --git a/drivers/powercap/intel_rapl.c b/drivers/powercap/intel_rapl.c</span>
<span class="p_header">index fbab29dfa793..243b233ff31b 100644</span>
<span class="p_header">--- a/drivers/powercap/intel_rapl.c</span>
<span class="p_header">+++ b/drivers/powercap/intel_rapl.c</span>
<span class="p_chunk">@@ -1154,8 +1154,8 @@</span> <span class="p_context"> static const struct x86_cpu_id rapl_ids[] __initconst = {</span>
 
 	RAPL_CPU(INTEL_FAM6_ATOM_SILVERMONT1,	rapl_defaults_byt),
 	RAPL_CPU(INTEL_FAM6_ATOM_AIRMONT,	rapl_defaults_cht),
<span class="p_del">-	RAPL_CPU(INTEL_FAM6_ATOM_MERRIFIELD1,	rapl_defaults_tng),</span>
<span class="p_del">-	RAPL_CPU(INTEL_FAM6_ATOM_MERRIFIELD2,	rapl_defaults_ann),</span>
<span class="p_add">+	RAPL_CPU(INTEL_FAM6_ATOM_MERRIFIELD,	rapl_defaults_tng),</span>
<span class="p_add">+	RAPL_CPU(INTEL_FAM6_ATOM_MOOREFIELD,	rapl_defaults_ann),</span>
 	RAPL_CPU(INTEL_FAM6_ATOM_GOLDMONT,	rapl_defaults_core),
 	RAPL_CPU(INTEL_FAM6_ATOM_DENVERTON,	rapl_defaults_core),
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



