
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v8,6/6] drm/i915/gvt: Adding user interface for dma-buf - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v8,6/6] drm/i915/gvt: Adding user interface for dma-buf</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=170581">Xiaoguang Chen</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 9, 2017, 6:50 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1496991042-2265-7-git-send-email-xiaoguang.chen@intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9777383/mbox/"
   >mbox</a>
|
   <a href="/patch/9777383/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9777383/">/patch/9777383/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	D937E603B4 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Jun 2017 06:52:34 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C9E2826E75
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Jun 2017 06:52:34 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id BE882284B2; Fri,  9 Jun 2017 06:52:34 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D49AE28593
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Jun 2017 06:52:33 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751703AbdFIGwb (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 9 Jun 2017 02:52:31 -0400
Received: from mga11.intel.com ([192.55.52.93]:40794 &quot;EHLO mga11.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751606AbdFIGw3 (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 9 Jun 2017 02:52:29 -0400
Received: from orsmga003.jf.intel.com ([10.7.209.27])
	by fmsmga102.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384;
	08 Jun 2017 23:52:23 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.39,317,1493708400&quot;; d=&quot;scan&#39;208&quot;;a=&quot;978682713&quot;
Received: from chenxg-desktop.bj.intel.com ([10.238.154.180])
	by orsmga003.jf.intel.com with ESMTP; 08 Jun 2017 23:52:21 -0700
From: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;
To: alex.williamson@redhat.com, kraxel@redhat.com,
	chris@chris-wilson.co.uk, intel-gfx@lists.freedesktop.org,
	linux-kernel@vger.kernel.org, zhenyuw@linux.intel.com,
	zhiyuan.lv@intel.com, intel-gvt-dev@lists.freedesktop.org,
	zhi.a.wang@intel.com, kevin.tian@intel.com
Cc: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;
Subject: [PATCH v8 6/6] drm/i915/gvt: Adding user interface for dma-buf
Date: Fri,  9 Jun 2017 14:50:42 +0800
Message-Id: &lt;1496991042-2265-7-git-send-email-xiaoguang.chen@intel.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1496991042-2265-1-git-send-email-xiaoguang.chen@intel.com&gt;
References: &lt;1496991042-2265-1-git-send-email-xiaoguang.chen@intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170581">Xiaoguang Chen</a> - June 9, 2017, 6:50 a.m.</div>
<pre class="content">
User space should create the management fd for the dma-buf operation first.
Then user can query the plane information and create dma-buf if necessary
using the management fd.
<span class="signed-off-by">
Signed-off-by: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="tested-by">Tested-by: Kechen Lu &lt;kechen.lu@intel.com&gt;</span>
---
 drivers/gpu/drm/i915/gvt/dmabuf.c    |  37 ++++++++-
 drivers/gpu/drm/i915/gvt/dmabuf.h    |   5 ++
 drivers/gpu/drm/i915/gvt/gvt.c       |   3 +
 drivers/gpu/drm/i915/gvt/gvt.h       |   5 ++
 drivers/gpu/drm/i915/gvt/hypercall.h |   3 +
 drivers/gpu/drm/i915/gvt/kvmgt.c     | 145 +++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/i915/gvt/mpt.h       |  30 ++++++++
 drivers/gpu/drm/i915/gvt/vgpu.c      |   2 +
 8 files changed, 229 insertions(+), 1 deletion(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7781">Alex Williamson</a> - June 13, 2017, 10:29 p.m.</div>
<pre class="content">
On Fri,  9 Jun 2017 14:50:42 +0800
Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt; wrote:
<span class="quote">
&gt; User space should create the management fd for the dma-buf operation first.</span>
<span class="quote">&gt; Then user can query the plane information and create dma-buf if necessary</span>
<span class="quote">&gt; using the management fd.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt; Tested-by: Kechen Lu &lt;kechen.lu@intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/dmabuf.c    |  37 ++++++++-</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/dmabuf.h    |   5 ++</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/gvt.c       |   3 +</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/gvt.h       |   5 ++</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/hypercall.h |   3 +</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/kvmgt.c     | 145 +++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/mpt.h       |  30 ++++++++</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/vgpu.c      |   2 +</span>
<span class="quote">&gt;  8 files changed, 229 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.c b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; index c38ed8e9fc..1811abd 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; @@ -81,6 +81,28 @@ static void intel_vgpu_gem_put_pages(struct drm_i915_gem_object *obj,</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static void intel_vgpu_gem_release(struct drm_i915_gem_object *obj)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; +	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
<span class="quote">&gt; +	struct intel_vgpu_fb_info *fb_info;</span>
<span class="quote">&gt; +	struct intel_vgpu *vgpu = NULL;</span>

unnecessary initialization
<span class="quote">
&gt; +	struct list_head *pos;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	fb_info = (struct intel_vgpu_fb_info *)obj-&gt;gvt_info;</span>
<span class="quote">&gt; +	if (WARN_ON(!fb_info &amp;&amp; !fb_info-&gt;vgpu)) {</span>

||
<span class="quote">
&gt; +		gvt_vgpu_err(&quot;gvt info is invalid\n&quot;);</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	vgpu = fb_info-&gt;vgpu;</span>
<span class="quote">&gt; +	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="quote">&gt; +		dmabuf_obj = container_of(pos, struct intel_vgpu_dmabuf_obj,</span>
<span class="quote">&gt; +						list);</span>
<span class="quote">&gt; +		if ((dmabuf_obj != NULL) &amp;&amp; (dmabuf_obj-&gt;obj == obj)) {</span>
<span class="quote">&gt; +			kfree(dmabuf_obj);</span>
<span class="quote">&gt; +			break;</span>

Did we intend to remove it from the list?
<span class="quote">
&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	intel_gvt_hypervisor_put_vfio_device(vgpu);</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt;  	kfree(obj-&gt;gvt_info);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -215,6 +237,7 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
<span class="quote">&gt;  	struct vfio_vgpu_create_dmabuf *gvt_dmabuf = args;</span>
<span class="quote">&gt;  	struct intel_vgpu_fb_info *fb_info;</span>
<span class="quote">&gt;  	int ret;</span>
<span class="quote">&gt; +	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	ret = intel_vgpu_get_plane_info(dev, vgpu, &amp;gvt_dmabuf-&gt;plane_info,</span>
<span class="quote">&gt;  					gvt_dmabuf-&gt;plane_id);</span>
<span class="quote">&gt; @@ -237,6 +260,16 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
<span class="quote">&gt;  	fb_info-&gt;vgpu = vgpu;</span>
<span class="quote">&gt;  	obj-&gt;gvt_info = fb_info;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	dmabuf_obj = kmalloc(sizeof(*dmabuf_obj), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!dmabuf_obj) {</span>
<span class="quote">&gt; +		gvt_vgpu_err(&quot;alloc dmabuf_obj failed\n&quot;);</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +		goto out_free_info;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	dmabuf_obj-&gt;obj = obj;</span>
<span class="quote">&gt; +	INIT_LIST_HEAD(&amp;dmabuf_obj-&gt;list);</span>
<span class="quote">&gt; +	list_add_tail(&amp;dmabuf_obj-&gt;list, &amp;vgpu-&gt;dmabuf_obj_list_head);</span>

Does this list need protection?
<span class="quote">
&gt; +</span>
<span class="quote">&gt;  	dmabuf = i915_gem_prime_export(dev, &amp;obj-&gt;base, DRM_CLOEXEC | DRM_RDWR);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (IS_ERR(dmabuf)) {</span>
<span class="quote">&gt; @@ -250,11 +283,13 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
<span class="quote">&gt;  		gvt_vgpu_err(&quot;create dma-buf fd failed ret:%d\n&quot;, ret);</span>
<span class="quote">&gt;  		goto out_free;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; +	intel_gvt_hypervisor_get_vfio_device(vgpu);</span>
<span class="quote">&gt;  	gvt_dmabuf-&gt;fd = ret;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt;  out_free:</span>
<span class="quote">&gt; +	kfree(dmabuf_obj);</span>
<span class="quote">&gt; +out_free_info:</span>
<span class="quote">&gt;  	kfree(fb_info);</span>
<span class="quote">&gt;  out:</span>
<span class="quote">&gt;  	i915_gem_object_put(obj);</span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.h b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; index 8be9979..cafa781 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; @@ -31,6 +31,11 @@ struct intel_vgpu_fb_info {</span>
<span class="quote">&gt;  	uint32_t fb_size;</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +struct intel_vgpu_dmabuf_obj {</span>
<span class="quote">&gt; +	struct drm_i915_gem_object *obj;</span>
<span class="quote">&gt; +	struct list_head list;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  int intel_vgpu_query_plane(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt;  int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; index 2032917..d589830 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; @@ -54,6 +54,9 @@ static const struct intel_gvt_ops intel_gvt_ops = {</span>
<span class="quote">&gt;  	.vgpu_reset = intel_gvt_reset_vgpu,</span>
<span class="quote">&gt;  	.vgpu_activate = intel_gvt_activate_vgpu,</span>
<span class="quote">&gt;  	.vgpu_deactivate = intel_gvt_deactivate_vgpu,</span>
<span class="quote">&gt; +	.vgpu_query_plane = intel_vgpu_query_plane,</span>
<span class="quote">&gt; +	.vgpu_create_dmabuf = intel_vgpu_create_dmabuf,</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /**</span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; index 763a8c5..8f08c42 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; @@ -185,8 +185,11 @@ struct intel_vgpu {</span>
<span class="quote">&gt;  		struct kvm *kvm;</span>
<span class="quote">&gt;  		struct work_struct release_work;</span>
<span class="quote">&gt;  		atomic_t released;</span>
<span class="quote">&gt; +		struct vfio_device *vfio_device;</span>
<span class="quote">&gt;  	} vdev;</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt; +	atomic_t mgr_fd_opened;</span>
<span class="quote">&gt; +	struct list_head dmabuf_obj_list_head;</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  struct intel_gvt_gm {</span>
<span class="quote">&gt; @@ -467,6 +470,8 @@ struct intel_gvt_ops {</span>
<span class="quote">&gt;  	void (*vgpu_reset)(struct intel_vgpu *);</span>
<span class="quote">&gt;  	void (*vgpu_activate)(struct intel_vgpu *);</span>
<span class="quote">&gt;  	void (*vgpu_deactivate)(struct intel_vgpu *);</span>
<span class="quote">&gt; +	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt; +	int (*vgpu_create_dmabuf)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/hypercall.h b/drivers/gpu/drm/i915/gvt/hypercall.h</span>
<span class="quote">&gt; index 32c345c..8f29c23 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/hypercall.h</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/hypercall.h</span>
<span class="quote">&gt; @@ -56,6 +56,9 @@ struct intel_gvt_mpt {</span>
<span class="quote">&gt;  	int (*set_trap_area)(unsigned long handle, u64 start, u64 end,</span>
<span class="quote">&gt;  			     bool map);</span>
<span class="quote">&gt;  	int (*set_opregion)(void *vgpu);</span>
<span class="quote">&gt; +	int (*get_vfio_device)(unsigned long handle);</span>
<span class="quote">&gt; +	void (*put_vfio_device)(unsigned long handle);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  extern struct intel_gvt_mpt xengt_mpt;</span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/kvmgt.c b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; index 6b4652a..e1d3492 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; @@ -41,6 +41,7 @@</span>
<span class="quote">&gt;  #include &lt;linux/kvm_host.h&gt;</span>
<span class="quote">&gt;  #include &lt;linux/vfio.h&gt;</span>
<span class="quote">&gt;  #include &lt;linux/mdev.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/anon_inodes.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &quot;i915_drv.h&quot;</span>
<span class="quote">&gt;  #include &quot;gvt.h&quot;</span>
<span class="quote">&gt; @@ -523,6 +524,117 @@ static int kvmgt_set_opregion(void *p_vgpu)</span>
<span class="quote">&gt;  	return ret;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static int kvmgt_get_vfio_device(unsigned long handle)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct kvmgt_guest_info *info;</span>
<span class="quote">&gt; +	struct intel_vgpu *vgpu;</span>
<span class="quote">&gt; +	struct vfio_device *device;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!handle_valid(handle))</span>
<span class="quote">&gt; +		return -ESRCH;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	info = (struct kvmgt_guest_info *)handle;</span>
<span class="quote">&gt; +	vgpu = info-&gt;vgpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	device = vfio_device_get_from_dev(mdev_dev(vgpu-&gt;vdev.mdev));</span>
<span class="quote">&gt; +	if (device == NULL)</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +	vgpu-&gt;vdev.vfio_device = device;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void kvmgt_put_vfio_device(unsigned long handle)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct kvmgt_guest_info *info;</span>
<span class="quote">&gt; +	struct intel_vgpu *vgpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!handle_valid(handle))</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	info = (struct kvmgt_guest_info *)handle;</span>
<span class="quote">&gt; +	vgpu = info-&gt;vgpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	vfio_device_put(vgpu-&gt;vdev.vfio_device);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int intel_vgpu_dmabuf_mgr_fd_mmap(struct file *file,</span>
<span class="quote">&gt; +		struct vm_area_struct *vma)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return -EPERM;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int intel_vgpu_dmabuf_mgr_fd_release(struct inode *inode,</span>
<span class="quote">&gt; +		struct file *filp)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt; +	struct intel_vgpu_dmabuf_obj *obj;</span>
<span class="quote">&gt; +	struct list_head *pos;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (WARN_ON(!vgpu-&gt;vdev.vfio_device))</span>

Doesn&#39;t seem possible, however any kvmgt_put_vfio_device() call will
set this regardless of whether that calling path retained the reference
or failed and released it, so the way vfio_device is cached here is
rather sketchy in general.
<span class="quote">
&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="quote">&gt; +		obj = container_of(pos, struct intel_vgpu_dmabuf_obj, list);</span>
<span class="quote">&gt; +		if (WARN_ON(!obj))</span>
<span class="quote">&gt; +			return -ENODEV;</span>
<span class="quote">&gt; +		i915_gem_object_put(obj-&gt;obj);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	kvmgt_put_vfio_device(vgpu-&gt;handle);</span>
<span class="quote">&gt; +	atomic_set(&amp;vgpu-&gt;mgr_fd_opened, 0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static long intel_vgpu_dmabuf_mgr_fd_ioctl(struct file *filp,</span>
<span class="quote">&gt; +		unsigned int ioctl, unsigned long arg)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt; +	int minsz;</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (ioctl == VFIO_DEVICE_QUERY_PLANE) {</span>
<span class="quote">&gt; +		struct vfio_vgpu_query_plane plane_info;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		minsz = offsetofend(struct vfio_vgpu_query_plane, padding);</span>
<span class="quote">&gt; +		if (copy_from_user(&amp;plane_info, (void __user *)arg, minsz))</span>
<span class="quote">&gt; +			return -EFAULT;</span>
<span class="quote">&gt; +		if (plane_info.argsz &lt; minsz || plane_info.flags != 0)</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +		ret = intel_gvt_ops-&gt;vgpu_query_plane(vgpu, &amp;plane_info);</span>
<span class="quote">&gt; +		if (ret != 0) {</span>
<span class="quote">&gt; +			gvt_vgpu_err(&quot;query plane failed:%d\n&quot;, ret);</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		return copy_to_user((void __user *)arg, &amp;plane_info, minsz) ?</span>
<span class="quote">&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt; +	} else if (ioctl == VFIO_DEVICE_CREATE_DMABUF) {</span>
<span class="quote">&gt; +		struct vfio_vgpu_create_dmabuf dmabuf;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		minsz = offsetofend(struct vfio_vgpu_create_dmabuf, plane_id);</span>
<span class="quote">&gt; +		if (copy_from_user(&amp;dmabuf, (void __user *)arg, minsz))</span>
<span class="quote">&gt; +			return -EFAULT;</span>
<span class="quote">&gt; +		if (dmabuf.argsz &lt; minsz || dmabuf.flags != 0)</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		ret = intel_gvt_ops-&gt;vgpu_create_dmabuf(vgpu, &amp;dmabuf);</span>
<span class="quote">&gt; +		if (ret != 0)</span>
<span class="quote">&gt; +			return ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		return copy_to_user((void __user *)arg, &amp;dmabuf, minsz) ?</span>
<span class="quote">&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt; +	} else</span>
<span class="quote">&gt; +		gvt_vgpu_err(&quot;unsupported mgr fd operation\n&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return -EINVAL;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct file_operations intel_vgpu_dmabuf_mgr_fd_ops = {</span>
<span class="quote">&gt; +	.release        = intel_vgpu_dmabuf_mgr_fd_release,</span>
<span class="quote">&gt; +	.unlocked_ioctl = intel_vgpu_dmabuf_mgr_fd_ioctl,</span>
<span class="quote">&gt; +	.mmap           = intel_vgpu_dmabuf_mgr_fd_mmap,</span>
<span class="quote">&gt; +	.llseek         = noop_llseek,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt;  static int intel_vgpu_create(struct kobject *kobj, struct mdev_device *mdev)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct intel_vgpu *vgpu = NULL;</span>
<span class="quote">&gt; @@ -1249,6 +1361,36 @@ static long intel_vgpu_ioctl(struct mdev_device *mdev, unsigned int cmd,</span>
<span class="quote">&gt;  	} else if (cmd == VFIO_DEVICE_RESET) {</span>
<span class="quote">&gt;  		intel_gvt_ops-&gt;vgpu_reset(vgpu);</span>
<span class="quote">&gt;  		return 0;</span>
<span class="quote">&gt; +	} else if (cmd == VFIO_DEVICE_GET_FD) {</span>
<span class="quote">&gt; +		int fd;</span>
<span class="quote">&gt; +		u32 type;</span>
<span class="quote">&gt; +		int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (atomic_read(&amp;vgpu-&gt;mgr_fd_opened)) {</span>
<span class="quote">&gt; +			gvt_vgpu_err(&quot;mgr fd already opened\n&quot;);</span>
<span class="quote">&gt; +			return -EPERM;</span>
<span class="quote">&gt; +		}</span>

Should check what&#39;s being asked for first, if other types are created
that are not supported by kvmgt we should consistently return -EINVAL,
not -EINVAL if DMABUF_MGR isn&#39;t already opened and -EPERM if it is.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +		if (copy_from_user(&amp;type, (void __user *)arg, sizeof(type)))</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +		if (type != VFIO_DEVICE_DMABUF_MGR_FD)</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		ret = kvmgt_get_vfio_device(vgpu-&gt;handle);</span>
<span class="quote">&gt; +		if (ret != 0)</span>
<span class="quote">&gt; +			return ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		fd = anon_inode_getfd(&quot;intel-vgpu-dmabuf-mgr-fd&quot;,</span>
<span class="quote">&gt; +			&amp;intel_vgpu_dmabuf_mgr_fd_ops,</span>
<span class="quote">&gt; +			vgpu, O_RDWR | O_CLOEXEC);</span>
<span class="quote">&gt; +		if (fd &lt; 0) {</span>
<span class="quote">&gt; +			kvmgt_put_vfio_device(vgpu-&gt;handle);</span>
<span class="quote">&gt; +			gvt_vgpu_err(&quot;create dmabuf mgr fd failed\n&quot;);</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		atomic_inc(&amp;vgpu-&gt;mgr_fd_opened);</span>

This doesn&#39;t seem like a super effective use of atomics, you could be
sure to have only one open with a cmpxchg.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +		return fd;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt; @@ -1612,6 +1754,9 @@ struct intel_gvt_mpt kvmgt_mpt = {</span>
<span class="quote">&gt;  	.write_gpa = kvmgt_write_gpa,</span>
<span class="quote">&gt;  	.gfn_to_mfn = kvmgt_gfn_to_pfn,</span>
<span class="quote">&gt;  	.set_opregion = kvmgt_set_opregion,</span>
<span class="quote">&gt; +	.get_vfio_device = kvmgt_get_vfio_device,</span>
<span class="quote">&gt; +	.put_vfio_device = kvmgt_put_vfio_device,</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  EXPORT_SYMBOL_GPL(kvmgt_mpt);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h</span>
<span class="quote">&gt; index ab71300..1be961e 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/mpt.h</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/mpt.h</span>
<span class="quote">&gt; @@ -308,4 +308,34 @@ static inline int intel_gvt_hypervisor_set_opregion(struct intel_vgpu *vgpu)</span>
<span class="quote">&gt;  	return intel_gvt_host.mpt-&gt;set_opregion(vgpu);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/**</span>
<span class="quote">&gt; + * intel_gvt_hypervisor_get_vfio_device - increase vfio device ref count</span>
<span class="quote">&gt; + * @vgpu: a vGPU</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Returns:</span>
<span class="quote">&gt; + * Zero on success, negative error code if failed.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +static inline int intel_gvt_hypervisor_get_vfio_device(struct intel_vgpu *vgpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (!intel_gvt_host.mpt-&gt;get_vfio_device)</span>
<span class="quote">&gt; +		return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return intel_gvt_host.mpt-&gt;get_vfio_device(vgpu-&gt;handle);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/**</span>
<span class="quote">&gt; + * intel_gvt_hypervisor_put_vfio_device - decrease vfio device ref count</span>
<span class="quote">&gt; + * @vgpu: a vGPU</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Returns:</span>
<span class="quote">&gt; + * Zero on success, negative error code if failed.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +static inline void intel_gvt_hypervisor_put_vfio_device(struct intel_vgpu *vgpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (!intel_gvt_host.mpt-&gt;put_vfio_device)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	intel_gvt_host.mpt-&gt;put_vfio_device(vgpu-&gt;handle);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  #endif /* _GVT_MPT_H_ */</span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; index 8e1d504..8747613 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; @@ -346,6 +346,8 @@ static struct intel_vgpu *__intel_gvt_create_vgpu(struct intel_gvt *gvt,</span>
<span class="quote">&gt;  	vgpu-&gt;gvt = gvt;</span>
<span class="quote">&gt;  	vgpu-&gt;sched_ctl.weight = param-&gt;weight;</span>
<span class="quote">&gt;  	bitmap_zero(vgpu-&gt;tlb_handle_pending, I915_NUM_ENGINES);</span>
<span class="quote">&gt; +	INIT_LIST_HEAD(&amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt; +	atomic_set(&amp;vgpu-&gt;mgr_fd_opened, 0);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	intel_vgpu_init_cfg_space(vgpu, param-&gt;primary);</span>
<span class="quote">&gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.c b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="p_header">index c38ed8e9fc..1811abd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="p_chunk">@@ -81,6 +81,28 @@</span> <span class="p_context"> static void intel_vgpu_gem_put_pages(struct drm_i915_gem_object *obj,</span>
 
 static void intel_vgpu_gem_release(struct drm_i915_gem_object *obj)
 {
<span class="p_add">+	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
<span class="p_add">+	struct intel_vgpu_fb_info *fb_info;</span>
<span class="p_add">+	struct intel_vgpu *vgpu = NULL;</span>
<span class="p_add">+	struct list_head *pos;</span>
<span class="p_add">+</span>
<span class="p_add">+	fb_info = (struct intel_vgpu_fb_info *)obj-&gt;gvt_info;</span>
<span class="p_add">+	if (WARN_ON(!fb_info &amp;&amp; !fb_info-&gt;vgpu)) {</span>
<span class="p_add">+		gvt_vgpu_err(&quot;gvt info is invalid\n&quot;);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	vgpu = fb_info-&gt;vgpu;</span>
<span class="p_add">+	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="p_add">+		dmabuf_obj = container_of(pos, struct intel_vgpu_dmabuf_obj,</span>
<span class="p_add">+						list);</span>
<span class="p_add">+		if ((dmabuf_obj != NULL) &amp;&amp; (dmabuf_obj-&gt;obj == obj)) {</span>
<span class="p_add">+			kfree(dmabuf_obj);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	intel_gvt_hypervisor_put_vfio_device(vgpu);</span>
<span class="p_add">+out:</span>
 	kfree(obj-&gt;gvt_info);
 }
 
<span class="p_chunk">@@ -215,6 +237,7 @@</span> <span class="p_context"> int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
 	struct vfio_vgpu_create_dmabuf *gvt_dmabuf = args;
 	struct intel_vgpu_fb_info *fb_info;
 	int ret;
<span class="p_add">+	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
 
 	ret = intel_vgpu_get_plane_info(dev, vgpu, &amp;gvt_dmabuf-&gt;plane_info,
 					gvt_dmabuf-&gt;plane_id);
<span class="p_chunk">@@ -237,6 +260,16 @@</span> <span class="p_context"> int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
 	fb_info-&gt;vgpu = vgpu;
 	obj-&gt;gvt_info = fb_info;
 
<span class="p_add">+	dmabuf_obj = kmalloc(sizeof(*dmabuf_obj), GFP_KERNEL);</span>
<span class="p_add">+	if (!dmabuf_obj) {</span>
<span class="p_add">+		gvt_vgpu_err(&quot;alloc dmabuf_obj failed\n&quot;);</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto out_free_info;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dmabuf_obj-&gt;obj = obj;</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;dmabuf_obj-&gt;list);</span>
<span class="p_add">+	list_add_tail(&amp;dmabuf_obj-&gt;list, &amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="p_add">+</span>
 	dmabuf = i915_gem_prime_export(dev, &amp;obj-&gt;base, DRM_CLOEXEC | DRM_RDWR);
 
 	if (IS_ERR(dmabuf)) {
<span class="p_chunk">@@ -250,11 +283,13 @@</span> <span class="p_context"> int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
 		gvt_vgpu_err(&quot;create dma-buf fd failed ret:%d\n&quot;, ret);
 		goto out_free;
 	}
<span class="p_del">-</span>
<span class="p_add">+	intel_gvt_hypervisor_get_vfio_device(vgpu);</span>
 	gvt_dmabuf-&gt;fd = ret;
 
 	return 0;
 out_free:
<span class="p_add">+	kfree(dmabuf_obj);</span>
<span class="p_add">+out_free_info:</span>
 	kfree(fb_info);
 out:
 	i915_gem_object_put(obj);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.h b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="p_header">index 8be9979..cafa781 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="p_chunk">@@ -31,6 +31,11 @@</span> <span class="p_context"> struct intel_vgpu_fb_info {</span>
 	uint32_t fb_size;
 };
 
<span class="p_add">+struct intel_vgpu_dmabuf_obj {</span>
<span class="p_add">+	struct drm_i915_gem_object *obj;</span>
<span class="p_add">+	struct list_head list;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 int intel_vgpu_query_plane(struct intel_vgpu *vgpu, void *args);
 int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args);
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="p_header">index 2032917..d589830 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="p_chunk">@@ -54,6 +54,9 @@</span> <span class="p_context"> static const struct intel_gvt_ops intel_gvt_ops = {</span>
 	.vgpu_reset = intel_gvt_reset_vgpu,
 	.vgpu_activate = intel_gvt_activate_vgpu,
 	.vgpu_deactivate = intel_gvt_deactivate_vgpu,
<span class="p_add">+	.vgpu_query_plane = intel_vgpu_query_plane,</span>
<span class="p_add">+	.vgpu_create_dmabuf = intel_vgpu_create_dmabuf,</span>
<span class="p_add">+</span>
 };
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="p_header">index 763a8c5..8f08c42 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="p_chunk">@@ -185,8 +185,11 @@</span> <span class="p_context"> struct intel_vgpu {</span>
 		struct kvm *kvm;
 		struct work_struct release_work;
 		atomic_t released;
<span class="p_add">+		struct vfio_device *vfio_device;</span>
 	} vdev;
 #endif
<span class="p_add">+	atomic_t mgr_fd_opened;</span>
<span class="p_add">+	struct list_head dmabuf_obj_list_head;</span>
 };
 
 struct intel_gvt_gm {
<span class="p_chunk">@@ -467,6 +470,8 @@</span> <span class="p_context"> struct intel_gvt_ops {</span>
 	void (*vgpu_reset)(struct intel_vgpu *);
 	void (*vgpu_activate)(struct intel_vgpu *);
 	void (*vgpu_deactivate)(struct intel_vgpu *);
<span class="p_add">+	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);</span>
<span class="p_add">+	int (*vgpu_create_dmabuf)(struct intel_vgpu *vgpu, void *);</span>
 };
 
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/hypercall.h b/drivers/gpu/drm/i915/gvt/hypercall.h</span>
<span class="p_header">index 32c345c..8f29c23 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/hypercall.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/hypercall.h</span>
<span class="p_chunk">@@ -56,6 +56,9 @@</span> <span class="p_context"> struct intel_gvt_mpt {</span>
 	int (*set_trap_area)(unsigned long handle, u64 start, u64 end,
 			     bool map);
 	int (*set_opregion)(void *vgpu);
<span class="p_add">+	int (*get_vfio_device)(unsigned long handle);</span>
<span class="p_add">+	void (*put_vfio_device)(unsigned long handle);</span>
<span class="p_add">+</span>
 };
 
 extern struct intel_gvt_mpt xengt_mpt;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/kvmgt.c b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="p_header">index 6b4652a..e1d3492 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kvm_host.h&gt;
 #include &lt;linux/vfio.h&gt;
 #include &lt;linux/mdev.h&gt;
<span class="p_add">+#include &lt;linux/anon_inodes.h&gt;</span>
 
 #include &quot;i915_drv.h&quot;
 #include &quot;gvt.h&quot;
<span class="p_chunk">@@ -523,6 +524,117 @@</span> <span class="p_context"> static int kvmgt_set_opregion(void *p_vgpu)</span>
 	return ret;
 }
 
<span class="p_add">+static int kvmgt_get_vfio_device(unsigned long handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvmgt_guest_info *info;</span>
<span class="p_add">+	struct intel_vgpu *vgpu;</span>
<span class="p_add">+	struct vfio_device *device;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!handle_valid(handle))</span>
<span class="p_add">+		return -ESRCH;</span>
<span class="p_add">+</span>
<span class="p_add">+	info = (struct kvmgt_guest_info *)handle;</span>
<span class="p_add">+	vgpu = info-&gt;vgpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	device = vfio_device_get_from_dev(mdev_dev(vgpu-&gt;vdev.mdev));</span>
<span class="p_add">+	if (device == NULL)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	vgpu-&gt;vdev.vfio_device = device;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void kvmgt_put_vfio_device(unsigned long handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvmgt_guest_info *info;</span>
<span class="p_add">+	struct intel_vgpu *vgpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!handle_valid(handle))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	info = (struct kvmgt_guest_info *)handle;</span>
<span class="p_add">+	vgpu = info-&gt;vgpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	vfio_device_put(vgpu-&gt;vdev.vfio_device);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int intel_vgpu_dmabuf_mgr_fd_mmap(struct file *file,</span>
<span class="p_add">+		struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EPERM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int intel_vgpu_dmabuf_mgr_fd_release(struct inode *inode,</span>
<span class="p_add">+		struct file *filp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="p_add">+	struct intel_vgpu_dmabuf_obj *obj;</span>
<span class="p_add">+	struct list_head *pos;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (WARN_ON(!vgpu-&gt;vdev.vfio_device))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="p_add">+		obj = container_of(pos, struct intel_vgpu_dmabuf_obj, list);</span>
<span class="p_add">+		if (WARN_ON(!obj))</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+		i915_gem_object_put(obj-&gt;obj);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kvmgt_put_vfio_device(vgpu-&gt;handle);</span>
<span class="p_add">+	atomic_set(&amp;vgpu-&gt;mgr_fd_opened, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static long intel_vgpu_dmabuf_mgr_fd_ioctl(struct file *filp,</span>
<span class="p_add">+		unsigned int ioctl, unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="p_add">+	int minsz;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ioctl == VFIO_DEVICE_QUERY_PLANE) {</span>
<span class="p_add">+		struct vfio_vgpu_query_plane plane_info;</span>
<span class="p_add">+</span>
<span class="p_add">+		minsz = offsetofend(struct vfio_vgpu_query_plane, padding);</span>
<span class="p_add">+		if (copy_from_user(&amp;plane_info, (void __user *)arg, minsz))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		if (plane_info.argsz &lt; minsz || plane_info.flags != 0)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		ret = intel_gvt_ops-&gt;vgpu_query_plane(vgpu, &amp;plane_info);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			gvt_vgpu_err(&quot;query plane failed:%d\n&quot;, ret);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		return copy_to_user((void __user *)arg, &amp;plane_info, minsz) ?</span>
<span class="p_add">+								-EFAULT : 0;</span>
<span class="p_add">+	} else if (ioctl == VFIO_DEVICE_CREATE_DMABUF) {</span>
<span class="p_add">+		struct vfio_vgpu_create_dmabuf dmabuf;</span>
<span class="p_add">+</span>
<span class="p_add">+		minsz = offsetofend(struct vfio_vgpu_create_dmabuf, plane_id);</span>
<span class="p_add">+		if (copy_from_user(&amp;dmabuf, (void __user *)arg, minsz))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		if (dmabuf.argsz &lt; minsz || dmabuf.flags != 0)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = intel_gvt_ops-&gt;vgpu_create_dmabuf(vgpu, &amp;dmabuf);</span>
<span class="p_add">+		if (ret != 0)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		return copy_to_user((void __user *)arg, &amp;dmabuf, minsz) ?</span>
<span class="p_add">+								-EFAULT : 0;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		gvt_vgpu_err(&quot;unsupported mgr fd operation\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct file_operations intel_vgpu_dmabuf_mgr_fd_ops = {</span>
<span class="p_add">+	.release        = intel_vgpu_dmabuf_mgr_fd_release,</span>
<span class="p_add">+	.unlocked_ioctl = intel_vgpu_dmabuf_mgr_fd_ioctl,</span>
<span class="p_add">+	.mmap           = intel_vgpu_dmabuf_mgr_fd_mmap,</span>
<span class="p_add">+	.llseek         = noop_llseek,</span>
<span class="p_add">+};</span>
 static int intel_vgpu_create(struct kobject *kobj, struct mdev_device *mdev)
 {
 	struct intel_vgpu *vgpu = NULL;
<span class="p_chunk">@@ -1249,6 +1361,36 @@</span> <span class="p_context"> static long intel_vgpu_ioctl(struct mdev_device *mdev, unsigned int cmd,</span>
 	} else if (cmd == VFIO_DEVICE_RESET) {
 		intel_gvt_ops-&gt;vgpu_reset(vgpu);
 		return 0;
<span class="p_add">+	} else if (cmd == VFIO_DEVICE_GET_FD) {</span>
<span class="p_add">+		int fd;</span>
<span class="p_add">+		u32 type;</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (atomic_read(&amp;vgpu-&gt;mgr_fd_opened)) {</span>
<span class="p_add">+			gvt_vgpu_err(&quot;mgr fd already opened\n&quot;);</span>
<span class="p_add">+			return -EPERM;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (copy_from_user(&amp;type, (void __user *)arg, sizeof(type)))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		if (type != VFIO_DEVICE_DMABUF_MGR_FD)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = kvmgt_get_vfio_device(vgpu-&gt;handle);</span>
<span class="p_add">+		if (ret != 0)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		fd = anon_inode_getfd(&quot;intel-vgpu-dmabuf-mgr-fd&quot;,</span>
<span class="p_add">+			&amp;intel_vgpu_dmabuf_mgr_fd_ops,</span>
<span class="p_add">+			vgpu, O_RDWR | O_CLOEXEC);</span>
<span class="p_add">+		if (fd &lt; 0) {</span>
<span class="p_add">+			kvmgt_put_vfio_device(vgpu-&gt;handle);</span>
<span class="p_add">+			gvt_vgpu_err(&quot;create dmabuf mgr fd failed\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		atomic_inc(&amp;vgpu-&gt;mgr_fd_opened);</span>
<span class="p_add">+</span>
<span class="p_add">+		return fd;</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -1612,6 +1754,9 @@</span> <span class="p_context"> struct intel_gvt_mpt kvmgt_mpt = {</span>
 	.write_gpa = kvmgt_write_gpa,
 	.gfn_to_mfn = kvmgt_gfn_to_pfn,
 	.set_opregion = kvmgt_set_opregion,
<span class="p_add">+	.get_vfio_device = kvmgt_get_vfio_device,</span>
<span class="p_add">+	.put_vfio_device = kvmgt_put_vfio_device,</span>
<span class="p_add">+</span>
 };
 EXPORT_SYMBOL_GPL(kvmgt_mpt);
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/mpt.h b/drivers/gpu/drm/i915/gvt/mpt.h</span>
<span class="p_header">index ab71300..1be961e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/mpt.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/mpt.h</span>
<span class="p_chunk">@@ -308,4 +308,34 @@</span> <span class="p_context"> static inline int intel_gvt_hypervisor_set_opregion(struct intel_vgpu *vgpu)</span>
 	return intel_gvt_host.mpt-&gt;set_opregion(vgpu);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * intel_gvt_hypervisor_get_vfio_device - increase vfio device ref count</span>
<span class="p_add">+ * @vgpu: a vGPU</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns:</span>
<span class="p_add">+ * Zero on success, negative error code if failed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int intel_gvt_hypervisor_get_vfio_device(struct intel_vgpu *vgpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!intel_gvt_host.mpt-&gt;get_vfio_device)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return intel_gvt_host.mpt-&gt;get_vfio_device(vgpu-&gt;handle);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * intel_gvt_hypervisor_put_vfio_device - decrease vfio device ref count</span>
<span class="p_add">+ * @vgpu: a vGPU</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns:</span>
<span class="p_add">+ * Zero on success, negative error code if failed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void intel_gvt_hypervisor_put_vfio_device(struct intel_vgpu *vgpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!intel_gvt_host.mpt-&gt;put_vfio_device)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_gvt_host.mpt-&gt;put_vfio_device(vgpu-&gt;handle);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* _GVT_MPT_H_ */
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="p_header">index 8e1d504..8747613 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="p_chunk">@@ -346,6 +346,8 @@</span> <span class="p_context"> static struct intel_vgpu *__intel_gvt_create_vgpu(struct intel_gvt *gvt,</span>
 	vgpu-&gt;gvt = gvt;
 	vgpu-&gt;sched_ctl.weight = param-&gt;weight;
 	bitmap_zero(vgpu-&gt;tlb_handle_pending, I915_NUM_ENGINES);
<span class="p_add">+	INIT_LIST_HEAD(&amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="p_add">+	atomic_set(&amp;vgpu-&gt;mgr_fd_opened, 0);</span>
 
 	intel_vgpu_init_cfg_space(vgpu, param-&gt;primary);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



