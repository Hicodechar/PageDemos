
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.16.y-ckt,stable] Linux 3.16.7-ckt16 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.16.y-ckt,stable] Linux 3.16.7-ckt16</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 20, 2015, 2:37 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1440081450-4668-2-git-send-email-luis.henriques@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7044921/mbox/"
   >mbox</a>
|
   <a href="/patch/7044921/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7044921/">/patch/7044921/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id EC63D9F358
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 20 Aug 2015 14:40:04 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id B578520595
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 20 Aug 2015 14:39:56 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id E7C46204EC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 20 Aug 2015 14:39:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932116AbbHTOjl (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 20 Aug 2015 10:39:41 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:45769 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752612AbbHTOhg (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 20 Aug 2015 10:37:36 -0400
Received: from [70.103.56.2] (helo=localhost)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;luis.henriques@canonical.com&gt;)
	id 1ZSQyD-00048A-O5; Thu, 20 Aug 2015 14:37:34 +0000
From: Luis Henriques &lt;luis.henriques@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.16.y-ckt stable] Linux 3.16.7-ckt16
Date: Thu, 20 Aug 2015 15:37:30 +0100
Message-Id: &lt;1440081450-4668-2-git-send-email-luis.henriques@canonical.com&gt;
In-Reply-To: &lt;1440081450-4668-1-git-send-email-luis.henriques@canonical.com&gt;
References: &lt;1440081450-4668-1-git-send-email-luis.henriques@canonical.com&gt;
X-Extended-Stable: 3.16
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.5 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a> - Aug. 20, 2015, 2:37 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/spi/spi_pl022.txt b/Documentation/devicetree/bindings/spi/spi_pl022.txt</span>
<span class="p_header">index 22ed6797216d..4d1673ca8cf8 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/spi/spi_pl022.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/spi/spi_pl022.txt</span>
<span class="p_chunk">@@ -4,9 +4,9 @@</span> <span class="p_context"> Required properties:</span>
 - compatible : &quot;arm,pl022&quot;, &quot;arm,primecell&quot;
 - reg : Offset and length of the register set for the device
 - interrupts : Should contain SPI controller interrupt
<span class="p_add">+- num-cs : total number of chipselects</span>
 
 Optional properties:
<span class="p_del">-- num-cs : total number of chipselects</span>
 - cs-gpios : should specify GPIOs used for chipselects.
   The gpios will be referred to as reg = &lt;index&gt; in the SPI child nodes.
   If unspecified, a single SPI device without a chip select can be used.
<span class="p_header">diff --git a/Documentation/kbuild/makefiles.txt b/Documentation/kbuild/makefiles.txt</span>
<span class="p_header">index c600e2f44a62..a2b03386e239 100644</span>
<span class="p_header">--- a/Documentation/kbuild/makefiles.txt</span>
<span class="p_header">+++ b/Documentation/kbuild/makefiles.txt</span>
<span class="p_chunk">@@ -976,6 +976,14 @@</span> <span class="p_context"> When kbuild executes, the following steps are followed (roughly):</span>
 	$(KBUILD_ARFLAGS) set by the top level Makefile to &quot;D&quot; (deterministic
 	mode) if this option is supported by $(AR).
 
<span class="p_add">+    ARCH_CPPFLAGS, ARCH_AFLAGS, ARCH_CFLAGS   Overrides the kbuild defaults</span>
<span class="p_add">+</span>
<span class="p_add">+	These variables are appended to the KBUILD_CPPFLAGS,</span>
<span class="p_add">+	KBUILD_AFLAGS, and KBUILD_CFLAGS, respectively, after the</span>
<span class="p_add">+	top-level Makefile has set any other flags. This provides a</span>
<span class="p_add">+	means for an architecture to override the defaults.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 --- 6.2 Add prerequisites to archheaders:
 
 	The archheaders: rule is used to generate header files that
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 7fb85a24d17c..093419a63d5c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
 SUBLEVEL = 7
<span class="p_del">-EXTRAVERSION =-ckt15</span>
<span class="p_add">+EXTRAVERSION =-ckt16</span>
 NAME = Museum of Fishiegoodies
 
 # *DOCUMENTATION*
<span class="p_chunk">@@ -755,10 +755,11 @@</span> <span class="p_context"> endif</span>
 
 include $(srctree)/scripts/Makefile.extrawarn
 
<span class="p_del">-# Add user supplied CPPFLAGS, AFLAGS and CFLAGS as the last assignments</span>
<span class="p_del">-KBUILD_CPPFLAGS += $(KCPPFLAGS)</span>
<span class="p_del">-KBUILD_AFLAGS += $(KAFLAGS)</span>
<span class="p_del">-KBUILD_CFLAGS += $(KCFLAGS)</span>
<span class="p_add">+# Add any arch overrides and user supplied CPPFLAGS, AFLAGS and CFLAGS as the</span>
<span class="p_add">+# last assignments</span>
<span class="p_add">+KBUILD_CPPFLAGS += $(ARCH_CPPFLAGS) $(KCPPFLAGS)</span>
<span class="p_add">+KBUILD_AFLAGS   += $(ARCH_AFLAGS)   $(KAFLAGS)</span>
<span class="p_add">+KBUILD_CFLAGS   += $(ARCH_CFLAGS)   $(KCFLAGS)</span>
 
 # Use --build-id when available.
 LDFLAGS_BUILD_ID = $(patsubst -Wl$(comma)%,%,\
<span class="p_header">diff --git a/arch/arc/Makefile b/arch/arc/Makefile</span>
<span class="p_header">index 8c0b1aa56f7e..429279bc3028 100644</span>
<span class="p_header">--- a/arch/arc/Makefile</span>
<span class="p_header">+++ b/arch/arc/Makefile</span>
<span class="p_chunk">@@ -44,7 +44,8 @@</span> <span class="p_context"> endif</span>
 
 ifndef CONFIG_CC_OPTIMIZE_FOR_SIZE
 # Generic build system uses -O2, we want -O3
<span class="p_del">-cflags-y  += -O3</span>
<span class="p_add">+# Note: No need to add to cflags-y as that happens anyways</span>
<span class="p_add">+ARCH_CFLAGS += -O3</span>
 endif
 
 # small data is default for elf32 tool-chain. If not usable, disable it
<span class="p_header">diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h</span>
<span class="p_header">index 1bfeec2c0558..2a58af7a2e3a 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> struct callee_regs {</span>
 	long r25, r24, r23, r22, r21, r20, r19, r18, r17, r16, r15, r14, r13;
 };
 
<span class="p_del">-#define instruction_pointer(regs)	((regs)-&gt;ret)</span>
<span class="p_add">+#define instruction_pointer(regs)	(unsigned long)((regs)-&gt;ret)</span>
 #define profile_pc(regs)		instruction_pointer(regs)
 
 /* return 1 if user mode or 0 if kernel mode */
<span class="p_header">diff --git a/arch/arm/boot/dts/imx23.dtsi b/arch/arm/boot/dts/imx23.dtsi</span>
<span class="p_header">index bbcfb5a19c77..0cb8b0b11c3f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx23.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx23.dtsi</span>
<span class="p_chunk">@@ -435,6 +435,7 @@</span> <span class="p_context"></span>
 				interrupts = &lt;36 37 38 39 40 41 42 43 44&gt;;
 				status = &quot;disabled&quot;;
 				clocks = &lt;&amp;clks 26&gt;;
<span class="p_add">+				#io-channel-cells = &lt;1&gt;;</span>
 			};
 
 			spdif@80054000 {
<span class="p_header">diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">index 1f88db06b133..0e09af35f69a 100644</span>
<span class="p_header">--- a/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -2013,7 +2013,7 @@</span> <span class="p_context"> static int extend_iommu_mapping(struct dma_iommu_mapping *mapping)</span>
 {
 	int next_bitmap;
 
<span class="p_del">-	if (mapping-&gt;nr_bitmaps &gt; mapping-&gt;extensions)</span>
<span class="p_add">+	if (mapping-&gt;nr_bitmaps &gt;= mapping-&gt;extensions)</span>
 		return -EINVAL;
 
 	next_bitmap = mapping-&gt;nr_bitmaps;
<span class="p_header">diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c</span>
<span class="p_header">index 51706d6dd5b0..c65062a6ff23 100644</span>
<span class="p_header">--- a/arch/mips/kernel/traps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/traps.c</span>
<span class="p_chunk">@@ -1931,10 +1931,10 @@</span> <span class="p_context"> void per_cpu_trap_init(bool is_boot_cpu)</span>
 	BUG_ON(current-&gt;mm);
 	enter_lazy_tlb(&amp;init_mm, current);
 
<span class="p_del">-		/* Boot CPU&#39;s cache setup in setup_arch(). */</span>
<span class="p_del">-		if (!is_boot_cpu)</span>
<span class="p_del">-			cpu_cache_init();</span>
<span class="p_del">-		tlb_init();</span>
<span class="p_add">+	/* Boot CPU&#39;s cache setup in setup_arch(). */</span>
<span class="p_add">+	if (!is_boot_cpu)</span>
<span class="p_add">+		cpu_cache_init();</span>
<span class="p_add">+	tlb_init();</span>
 	TLBMISS_HANDLER_SETUP();
 }
 
<span class="p_header">diff --git a/arch/s390/kernel/process.c b/arch/s390/kernel/process.c</span>
<span class="p_header">index 93b9ca42e5c0..8a7f7732db1f 100644</span>
<span class="p_header">--- a/arch/s390/kernel/process.c</span>
<span class="p_header">+++ b/arch/s390/kernel/process.c</span>
<span class="p_chunk">@@ -195,7 +195,7 @@</span> <span class="p_context"> asmlinkage void execve_tail(void)</span>
 {
 	current-&gt;thread.fp_regs.fpc = 0;
 	if (MACHINE_HAS_IEEE)
<span class="p_del">-		asm volatile(&quot;sfpc %0,%0&quot; : : &quot;d&quot; (0));</span>
<span class="p_add">+		asm volatile(&quot;sfpc %0&quot; : : &quot;d&quot; (0));</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/s390/kernel/sclp.S b/arch/s390/kernel/sclp.S</span>
<span class="p_header">index a41f2c99dcc8..a0c4e7652647 100644</span>
<span class="p_header">--- a/arch/s390/kernel/sclp.S</span>
<span class="p_header">+++ b/arch/s390/kernel/sclp.S</span>
<span class="p_chunk">@@ -277,6 +277,8 @@</span> <span class="p_context"> ENTRY(_sclp_print_early)</span>
 	jno	.Lesa2
 	ahi	%r15,-80
 	stmh	%r6,%r15,96(%r15)		# store upper register halves
<span class="p_add">+	basr	%r13,0</span>
<span class="p_add">+	lmh	%r0,%r15,.Lzeroes-.(%r13)	# clear upper register halves</span>
 .Lesa2:
 #endif
 	lr	%r10,%r2			# save string pointer
<span class="p_chunk">@@ -300,6 +302,8 @@</span> <span class="p_context"> ENTRY(_sclp_print_early)</span>
 #endif
 	lm	%r6,%r15,120(%r15)		# restore registers
 	br	%r14
<span class="p_add">+.Lzeroes:</span>
<span class="p_add">+	.fill	64,4,0</span>
 
 .LwritedataS4:
 	.long	0x00760005			# SCLP command for write data
<span class="p_header">diff --git a/arch/tile/kernel/setup.c b/arch/tile/kernel/setup.c</span>
<span class="p_header">index 112ababa9e55..d8a9df999da3 100644</span>
<span class="p_header">--- a/arch/tile/kernel/setup.c</span>
<span class="p_header">+++ b/arch/tile/kernel/setup.c</span>
<span class="p_chunk">@@ -1144,7 +1144,7 @@</span> <span class="p_context"> static void __init load_hv_initrd(void)</span>
 
 void __init free_initrd_mem(unsigned long begin, unsigned long end)
 {
<span class="p_del">-	free_bootmem(__pa(begin), end - begin);</span>
<span class="p_add">+	free_bootmem_late(__pa(begin), end - begin);</span>
 }
 
 static int __init setup_initrd(char *str)
<span class="p_header">diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S</span>
<span class="p_header">index 94aa18a9cc11..79565bd80cc2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/entry_64.S</span>
<span class="p_chunk">@@ -1423,19 +1423,7 @@</span> <span class="p_context"> ENTRY(error_exit)</span>
 	CFI_ENDPROC
 END(error_exit)
 
<span class="p_del">-/*</span>
<span class="p_del">- * Test if a given stack is an NMI stack or not.</span>
<span class="p_del">- */</span>
<span class="p_del">-	.macro test_in_nmi reg stack nmi_ret normal_ret</span>
<span class="p_del">-	cmpq %\reg, \stack</span>
<span class="p_del">-	ja \normal_ret</span>
<span class="p_del">-	subq $EXCEPTION_STKSZ, %\reg</span>
<span class="p_del">-	cmpq %\reg, \stack</span>
<span class="p_del">-	jb \normal_ret</span>
<span class="p_del">-	jmp \nmi_ret</span>
<span class="p_del">-	.endm</span>
<span class="p_del">-</span>
<span class="p_del">-	/* runs on exception stack */</span>
<span class="p_add">+/* Runs on exception stack */</span>
 ENTRY(nmi)
 	INTR_FRAME
 	PARAVIRT_ADJUST_EXCEPTION_FRAME
<span class="p_chunk">@@ -1456,11 +1444,12 @@</span> <span class="p_context"> ENTRY(nmi)</span>
 	 *  If the variable is not set and the stack is not the NMI
 	 *  stack then:
 	 *    o Set the special variable on the stack
<span class="p_del">-	 *    o Copy the interrupt frame into a &quot;saved&quot; location on the stack</span>
<span class="p_del">-	 *    o Copy the interrupt frame into a &quot;copy&quot; location on the stack</span>
<span class="p_add">+	 *    o Copy the interrupt frame into an &quot;outermost&quot; location on the</span>
<span class="p_add">+	 *      stack</span>
<span class="p_add">+	 *    o Copy the interrupt frame into an &quot;iret&quot; location on the stack</span>
 	 *    o Continue processing the NMI
 	 *  If the variable is set or the previous stack is the NMI stack:
<span class="p_del">-	 *    o Modify the &quot;copy&quot; location to jump to the repeate_nmi</span>
<span class="p_add">+	 *    o Modify the &quot;iret&quot; location to jump to the repeat_nmi</span>
 	 *    o return back to the first NMI
 	 *
 	 * Now on exit of the first NMI, we first clear the stack variable
<span class="p_chunk">@@ -1469,52 +1458,194 @@</span> <span class="p_context"> ENTRY(nmi)</span>
 	 * a nested NMI that updated the copy interrupt stack frame, a
 	 * jump will be made to the repeat_nmi code that will handle the second
 	 * NMI.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However, espfix prevents us from directly returning to userspace</span>
<span class="p_add">+	 * with a single IRET instruction.  Similarly, IRET to user mode</span>
<span class="p_add">+	 * can fault.  We therefore handle NMIs from user space like</span>
<span class="p_add">+	 * other IST entries.</span>
 	 */
 
 	/* Use %rdx as out temp variable throughout */
 	pushq_cfi %rdx
 	CFI_REL_OFFSET rdx, 0
 
<span class="p_add">+	testb	$3, CS-RIP+8(%rsp)</span>
<span class="p_add">+	jz	.Lnmi_from_kernel</span>
<span class="p_add">+</span>
 	/*
<span class="p_del">-	 * If %cs was not the kernel segment, then the NMI triggered in user</span>
<span class="p_del">-	 * space, which means it is definitely not nested.</span>
<span class="p_add">+	 * NMI from user mode.  We need to run on the thread stack, but we</span>
<span class="p_add">+	 * can&#39;t go through the normal entry paths: NMIs are masked, and</span>
<span class="p_add">+	 * we don&#39;t want to enable interrupts, because then we&#39;ll end</span>
<span class="p_add">+	 * up in an awkward situation in which IRQs are on but NMIs</span>
<span class="p_add">+	 * are off.</span>
 	 */
<span class="p_del">-	cmpl $__KERNEL_CS, 16(%rsp)</span>
<span class="p_del">-	jne first_nmi</span>
<span class="p_add">+</span>
<span class="p_add">+	SWAPGS</span>
<span class="p_add">+	cld</span>
<span class="p_add">+	movq	%rsp, %rdx</span>
<span class="p_add">+	movq	PER_CPU_VAR(kernel_stack), %rsp</span>
<span class="p_add">+	addq	$KERNEL_STACK_OFFSET, %rsp</span>
<span class="p_add">+	pushq	5*8(%rdx)	/* pt_regs-&gt;ss */</span>
<span class="p_add">+	pushq	4*8(%rdx)	/* pt_regs-&gt;rsp */</span>
<span class="p_add">+	pushq	3*8(%rdx)	/* pt_regs-&gt;flags */</span>
<span class="p_add">+	pushq	2*8(%rdx)	/* pt_regs-&gt;cs */</span>
<span class="p_add">+	pushq	1*8(%rdx)	/* pt_regs-&gt;rip */</span>
<span class="p_add">+	pushq   $-1		/* pt_regs-&gt;orig_ax */</span>
<span class="p_add">+	pushq   %rdi		/* pt_regs-&gt;di */</span>
<span class="p_add">+	pushq   %rsi		/* pt_regs-&gt;si */</span>
<span class="p_add">+	pushq   (%rdx)		/* pt_regs-&gt;dx */</span>
<span class="p_add">+	pushq   %rcx		/* pt_regs-&gt;cx */</span>
<span class="p_add">+	pushq   %rax		/* pt_regs-&gt;ax */</span>
<span class="p_add">+	pushq   %r8		/* pt_regs-&gt;r8 */</span>
<span class="p_add">+	pushq   %r9		/* pt_regs-&gt;r9 */</span>
<span class="p_add">+	pushq   %r10		/* pt_regs-&gt;r10 */</span>
<span class="p_add">+	pushq   %r11		/* pt_regs-&gt;r11 */</span>
<span class="p_add">+	pushq	%rbx		/* pt_regs-&gt;rbx */</span>
<span class="p_add">+	pushq	%rbp		/* pt_regs-&gt;rbp */</span>
<span class="p_add">+	pushq	%r12		/* pt_regs-&gt;r12 */</span>
<span class="p_add">+	pushq	%r13		/* pt_regs-&gt;r13 */</span>
<span class="p_add">+	pushq	%r14		/* pt_regs-&gt;r14 */</span>
<span class="p_add">+	pushq	%r15		/* pt_regs-&gt;r15 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * At this point we no longer need to worry about stack damage</span>
<span class="p_add">+	 * due to nesting -- we&#39;re on the normal thread stack and we&#39;re</span>
<span class="p_add">+	 * done with the NMI stack.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	%rsp, %rdi</span>
<span class="p_add">+	movq	$-1, %rsi</span>
<span class="p_add">+	call	do_nmi</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Return back to user mode.  We must *not* do the normal exit</span>
<span class="p_add">+	 * work, because we don&#39;t want to enable interrupts.  Fortunately,</span>
<span class="p_add">+	 * do_nmi doesn&#39;t modify pt_regs.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	SWAPGS</span>
 
 	/*
<span class="p_del">-	 * Check the special variable on the stack to see if NMIs are</span>
<span class="p_del">-	 * executing.</span>
<span class="p_add">+	 * Open-code the entire return process for compatibility with varying</span>
<span class="p_add">+	 * register layouts across different kernel versions.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	addq	$6*8, %rsp	/* skip bx, bp, and r12-r15 */</span>
<span class="p_add">+	popq	%r11		/* pt_regs-&gt;r11 */</span>
<span class="p_add">+	popq	%r10		/* pt_regs-&gt;r10 */</span>
<span class="p_add">+	popq	%r9		/* pt_regs-&gt;r9 */</span>
<span class="p_add">+	popq	%r8		/* pt_regs-&gt;r8 */</span>
<span class="p_add">+	popq	%rax		/* pt_regs-&gt;ax */</span>
<span class="p_add">+	popq	%rcx		/* pt_regs-&gt;cx */</span>
<span class="p_add">+	popq	%rdx		/* pt_regs-&gt;dx */</span>
<span class="p_add">+	popq	%rsi		/* pt_regs-&gt;si */</span>
<span class="p_add">+	popq	%rdi		/* pt_regs-&gt;di */</span>
<span class="p_add">+	addq	$8, %rsp	/* skip orig_ax */</span>
<span class="p_add">+	INTERRUPT_RETURN</span>
<span class="p_add">+</span>
<span class="p_add">+.Lnmi_from_kernel:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Here&#39;s what our stack frame will look like:</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | original SS                                             |</span>
<span class="p_add">+	 * | original Return RSP                                     |</span>
<span class="p_add">+	 * | original RFLAGS                                         |</span>
<span class="p_add">+	 * | original CS                                             |</span>
<span class="p_add">+	 * | original RIP                                            |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | temp storage for rdx                                    |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | &quot;NMI executing&quot; variable                                |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | iret SS          } Copied from &quot;outermost&quot; frame        |</span>
<span class="p_add">+	 * | iret Return RSP  } on each loop iteration; overwritten  |</span>
<span class="p_add">+	 * | iret RFLAGS      } by a nested NMI to force another     |</span>
<span class="p_add">+	 * | iret CS          } iteration if needed.                 |</span>
<span class="p_add">+	 * | iret RIP         }                                      |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | outermost SS          } initialized in first_nmi;       |</span>
<span class="p_add">+	 * | outermost Return RSP  } will not be changed before      |</span>
<span class="p_add">+	 * | outermost RFLAGS      } NMI processing is done.         |</span>
<span class="p_add">+	 * | outermost CS          } Copied to &quot;iret&quot; frame on each  |</span>
<span class="p_add">+	 * | outermost RIP         } iteration.                      |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 * | pt_regs                                                 |</span>
<span class="p_add">+	 * +---------------------------------------------------------+</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The &quot;original&quot; frame is used by hardware.  Before re-enabling</span>
<span class="p_add">+	 * NMIs, we need to be done with it, and we need to leave enough</span>
<span class="p_add">+	 * space for the asm code here.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We return by executing IRET while RSP points to the &quot;iret&quot; frame.</span>
<span class="p_add">+	 * That will either return for real or it will loop back into NMI</span>
<span class="p_add">+	 * processing.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The &quot;outermost&quot; frame is copied to the &quot;iret&quot; frame on each</span>
<span class="p_add">+	 * iteration of the loop, so each iteration starts with the &quot;iret&quot;</span>
<span class="p_add">+	 * frame pointing to the final return target.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Determine whether we&#39;re a nested NMI.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If we interrupted kernel code between repeat_nmi and</span>
<span class="p_add">+	 * end_repeat_nmi, then we are a nested NMI.  We must not</span>
<span class="p_add">+	 * modify the &quot;iret&quot; frame because it&#39;s being written by</span>
<span class="p_add">+	 * the outer NMI.  That&#39;s okay: the outer NMI handler is</span>
<span class="p_add">+	 * about to about to call do_nmi anyway, so we can just</span>
<span class="p_add">+	 * resume the outer NMI.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	$repeat_nmi, %rdx</span>
<span class="p_add">+	cmpq	8(%rsp), %rdx</span>
<span class="p_add">+	ja	1f</span>
<span class="p_add">+	movq	$end_repeat_nmi, %rdx</span>
<span class="p_add">+	cmpq	8(%rsp), %rdx</span>
<span class="p_add">+	ja	nested_nmi_out</span>
<span class="p_add">+1:</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Now check &quot;NMI executing&quot;.  If it&#39;s set, then we&#39;re nested.</span>
<span class="p_add">+	 * This will not detect if we interrupted an outer NMI just</span>
<span class="p_add">+	 * before IRET.</span>
 	 */
 	cmpl $1, -8(%rsp)
 	je nested_nmi
 
 	/*
<span class="p_del">-	 * Now test if the previous stack was an NMI stack.</span>
<span class="p_del">-	 * We need the double check. We check the NMI stack to satisfy the</span>
<span class="p_del">-	 * race when the first NMI clears the variable before returning.</span>
<span class="p_del">-	 * We check the variable because the first NMI could be in a</span>
<span class="p_del">-	 * breakpoint routine using a breakpoint stack.</span>
<span class="p_add">+	 * Now test if the previous stack was an NMI stack.  This covers</span>
<span class="p_add">+	 * the case where we interrupt an outer NMI after it clears</span>
<span class="p_add">+	 * &quot;NMI executing&quot; but before IRET.  We need to be careful, though:</span>
<span class="p_add">+	 * there is one case in which RSP could point to the NMI stack</span>
<span class="p_add">+	 * despite there being no NMI active: naughty userspace controls</span>
<span class="p_add">+	 * RSP at the very beginning of the SYSCALL targets.  We can</span>
<span class="p_add">+	 * pull a fast one on naughty userspace, though: we program</span>
<span class="p_add">+	 * SYSCALL to mask DF, so userspace cannot cause DF to be set</span>
<span class="p_add">+	 * if it controls the kernel&#39;s RSP.  We set DF before we clear</span>
<span class="p_add">+	 * &quot;NMI executing&quot;.</span>
 	 */
<span class="p_del">-	lea 6*8(%rsp), %rdx</span>
<span class="p_del">-	test_in_nmi rdx, 4*8(%rsp), nested_nmi, first_nmi</span>
<span class="p_add">+	lea	6*8(%rsp), %rdx</span>
<span class="p_add">+	/* Compare the NMI stack (rdx) with the stack we came from (4*8(%rsp)) */</span>
<span class="p_add">+	cmpq	%rdx, 4*8(%rsp)</span>
<span class="p_add">+	/* If the stack pointer is above the NMI stack, this is a normal NMI */</span>
<span class="p_add">+	ja	first_nmi</span>
<span class="p_add">+	subq	$EXCEPTION_STKSZ, %rdx</span>
<span class="p_add">+	cmpq	%rdx, 4*8(%rsp)</span>
<span class="p_add">+	/* If it is below the NMI stack, it is a normal NMI */</span>
<span class="p_add">+	jb	first_nmi</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Ah, it is within the NMI stack. */</span>
<span class="p_add">+</span>
<span class="p_add">+	testb	$(X86_EFLAGS_DF &gt;&gt; 8), (3*8 + 1)(%rsp)</span>
<span class="p_add">+	jz	first_nmi	/* RSP was user controlled. */</span>
<span class="p_add">+</span>
 	CFI_REMEMBER_STATE
 
<span class="p_add">+	/* This is a nested NMI. */</span>
<span class="p_add">+</span>
 nested_nmi:
 	/*
<span class="p_del">-	 * Do nothing if we interrupted the fixup in repeat_nmi.</span>
<span class="p_del">-	 * It&#39;s about to repeat the NMI handler, so we are fine</span>
<span class="p_del">-	 * with ignoring this one.</span>
<span class="p_add">+	 * Modify the &quot;iret&quot; frame to point to repeat_nmi, forcing another</span>
<span class="p_add">+	 * iteration of NMI handling.</span>
 	 */
<span class="p_del">-	movq $repeat_nmi, %rdx</span>
<span class="p_del">-	cmpq 8(%rsp), %rdx</span>
<span class="p_del">-	ja 1f</span>
<span class="p_del">-	movq $end_repeat_nmi, %rdx</span>
<span class="p_del">-	cmpq 8(%rsp), %rdx</span>
<span class="p_del">-	ja nested_nmi_out</span>
<span class="p_del">-</span>
<span class="p_del">-1:</span>
<span class="p_del">-	/* Set up the interrupted NMIs stack to jump to repeat_nmi */</span>
 	leaq -1*8(%rsp), %rdx
 	movq %rdx, %rsp
 	CFI_ADJUST_CFA_OFFSET 1*8
<span class="p_chunk">@@ -1533,60 +1664,23 @@</span> <span class="p_context"> nested_nmi_out:</span>
 	popq_cfi %rdx
 	CFI_RESTORE rdx
 
<span class="p_del">-	/* No need to check faults here */</span>
<span class="p_add">+	/* We are returning to kernel mode, so this cannot result in a fault. */</span>
 	INTERRUPT_RETURN
 
 	CFI_RESTORE_STATE
 first_nmi:
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Because nested NMIs will use the pushed location that we</span>
<span class="p_del">-	 * stored in rdx, we must keep that space available.</span>
<span class="p_del">-	 * Here&#39;s what our stack frame will look like:</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | original SS             |</span>
<span class="p_del">-	 * | original Return RSP     |</span>
<span class="p_del">-	 * | original RFLAGS         |</span>
<span class="p_del">-	 * | original CS             |</span>
<span class="p_del">-	 * | original RIP            |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | temp storage for rdx    |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | NMI executing variable  |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | copied SS               |</span>
<span class="p_del">-	 * | copied Return RSP       |</span>
<span class="p_del">-	 * | copied RFLAGS           |</span>
<span class="p_del">-	 * | copied CS               |</span>
<span class="p_del">-	 * | copied RIP              |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | Saved SS                |</span>
<span class="p_del">-	 * | Saved Return RSP        |</span>
<span class="p_del">-	 * | Saved RFLAGS            |</span>
<span class="p_del">-	 * | Saved CS                |</span>
<span class="p_del">-	 * | Saved RIP               |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 * | pt_regs                 |</span>
<span class="p_del">-	 * +-------------------------+</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * The saved stack frame is used to fix up the copied stack frame</span>
<span class="p_del">-	 * that a nested NMI may change to make the interrupted NMI iret jump</span>
<span class="p_del">-	 * to the repeat_nmi. The original stack frame and the temp storage</span>
<span class="p_del">-	 * is also used by nested NMIs and can not be trusted on exit.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	/* Do not pop rdx, nested NMIs will corrupt that part of the stack */</span>
<span class="p_add">+	/* Restore rdx. */</span>
 	movq (%rsp), %rdx
 	CFI_RESTORE rdx
 
<span class="p_del">-	/* Set the NMI executing variable on the stack. */</span>
<span class="p_add">+	/* Set &quot;NMI executing&quot; on the stack. */</span>
 	pushq_cfi $1
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Leave room for the &quot;copied&quot; frame</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* Leave room for the &quot;iret&quot; frame */</span>
 	subq $(5*8), %rsp
 	CFI_ADJUST_CFA_OFFSET 5*8
 
<span class="p_del">-	/* Copy the stack frame to the Saved frame */</span>
<span class="p_add">+	/* Copy the &quot;original&quot; frame to the &quot;outermost&quot; frame */</span>
 	.rept 5
 	pushq_cfi 11*8(%rsp)
 	.endr
<span class="p_chunk">@@ -1594,6 +1688,7 @@</span> <span class="p_context"> first_nmi:</span>
 
 	/* Everything up to here is safe from nested NMIs */
 
<span class="p_add">+repeat_nmi:</span>
 	/*
 	 * If there was a nested NMI, the first NMI&#39;s iret will return
 	 * here. But NMIs are still enabled and we can take another
<span class="p_chunk">@@ -1602,16 +1697,21 @@</span> <span class="p_context"> first_nmi:</span>
 	 * it will just return, as we are about to repeat an NMI anyway.
 	 * This makes it safe to copy to the stack frame that a nested
 	 * NMI will update.
<span class="p_del">-	 */</span>
<span class="p_del">-repeat_nmi:</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Update the stack variable to say we are still in NMI (the update</span>
<span class="p_del">-	 * is benign for the non-repeat case, where 1 was pushed just above</span>
<span class="p_del">-	 * to this very stack slot).</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * RSP is pointing to &quot;outermost RIP&quot;.  gsbase is unknown, but, if</span>
<span class="p_add">+	 * we&#39;re repeating an NMI, gsbase has the same value that it had on</span>
<span class="p_add">+	 * the first iteration.  paranoid_entry will load the kernel</span>
<span class="p_add">+	 * gsbase if needed before we call do_nmi.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Set &quot;NMI executing&quot; in case we came back here via IRET.</span>
 	 */
 	movq $1, 10*8(%rsp)
 
<span class="p_del">-	/* Make another copy, this one may be modified by nested NMIs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Copy the &quot;outermost&quot; frame to the &quot;iret&quot; frame.  NMIs that nest</span>
<span class="p_add">+	 * here must not modify the &quot;iret&quot; frame while we&#39;re writing to</span>
<span class="p_add">+	 * it or it will end up containing garbage.</span>
<span class="p_add">+	 */</span>
 	addq $(10*8), %rsp
 	CFI_ADJUST_CFA_OFFSET -10*8
 	.rept 5
<span class="p_chunk">@@ -1622,9 +1722,9 @@</span> <span class="p_context"> repeat_nmi:</span>
 end_repeat_nmi:
 
 	/*
<span class="p_del">-	 * Everything below this point can be preempted by a nested</span>
<span class="p_del">-	 * NMI if the first NMI took an exception and reset our iret stack</span>
<span class="p_del">-	 * so that we repeat another NMI.</span>
<span class="p_add">+	 * Everything below this point can be preempted by a nested NMI.</span>
<span class="p_add">+	 * If this happens, then the inner NMI will change the &quot;iret&quot;</span>
<span class="p_add">+	 * frame to point back to repeat_nmi.</span>
 	 */
 	pushq_cfi $-1		/* ORIG_RAX: no syscall to restart */
 	subq $ORIG_RAX-R15, %rsp
<span class="p_chunk">@@ -1639,39 +1739,35 @@</span> <span class="p_context"> end_repeat_nmi:</span>
 	call save_paranoid
 	DEFAULT_FRAME 0
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Save off the CR2 register. If we take a page fault in the NMI then</span>
<span class="p_del">-	 * it could corrupt the CR2 value. If the NMI preempts a page fault</span>
<span class="p_del">-	 * handler before it was able to read the CR2 register, and then the</span>
<span class="p_del">-	 * NMI itself takes a page fault, the page fault that was preempted</span>
<span class="p_del">-	 * will read the information from the NMI page fault and not the</span>
<span class="p_del">-	 * origin fault. Save it off and restore it if it changes.</span>
<span class="p_del">-	 * Use the r12 callee-saved register.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	movq %cr2, %r12</span>
<span class="p_del">-</span>
 	/* paranoidentry do_nmi, 0; without TRACE_IRQS_OFF */
 	movq %rsp,%rdi
 	movq $-1,%rsi
 	call do_nmi
 
<span class="p_del">-	/* Did the NMI take a page fault? Restore cr2 if it did */</span>
<span class="p_del">-	movq %cr2, %rcx</span>
<span class="p_del">-	cmpq %rcx, %r12</span>
<span class="p_del">-	je 1f</span>
<span class="p_del">-	movq %r12, %cr2</span>
<span class="p_del">-1:</span>
<span class="p_del">-	</span>
 	testl %ebx,%ebx				/* swapgs needed? */
 	jnz nmi_restore
 nmi_swapgs:
 	SWAPGS_UNSAFE_STACK
 nmi_restore:
<span class="p_del">-	/* Pop the extra iret frame at once */</span>
<span class="p_add">+</span>
 	RESTORE_ALL 6*8
 
<span class="p_del">-	/* Clear the NMI executing stack variable */</span>
<span class="p_del">-	movq $0, 5*8(%rsp)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear &quot;NMI executing&quot;.  Set DF first so that we can easily</span>
<span class="p_add">+	 * distinguish the remaining code between here and IRET from</span>
<span class="p_add">+	 * the SYSCALL entry and exit paths.  On a native kernel, we</span>
<span class="p_add">+	 * could just inspect RIP, but, on paravirt kernels,</span>
<span class="p_add">+	 * INTERRUPT_RETURN can translate into a jump into a</span>
<span class="p_add">+	 * hypercall page.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	std</span>
<span class="p_add">+	movq	$0, 5*8(%rsp)		/* clear &quot;NMI executing&quot; */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * INTERRUPT_RETURN reads the &quot;iret&quot; frame and exits the NMI</span>
<span class="p_add">+	 * stack in a single instruction.  We are returning to kernel</span>
<span class="p_add">+	 * mode, so this cannot result in a fault.</span>
<span class="p_add">+	 */</span>
 	jmp irq_return
 	CFI_ENDPROC
 END(nmi)
<span class="p_header">diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c</span>
<span class="p_header">index c3e985d1751c..d05bd2e2ee91 100644</span>
<span class="p_header">--- a/arch/x86/kernel/nmi.c</span>
<span class="p_header">+++ b/arch/x86/kernel/nmi.c</span>
<span class="p_chunk">@@ -408,15 +408,15 @@</span> <span class="p_context"> static void default_do_nmi(struct pt_regs *regs)</span>
 NOKPROBE_SYMBOL(default_do_nmi);
 
 /*
<span class="p_del">- * NMIs can hit breakpoints which will cause it to lose its</span>
<span class="p_del">- * NMI context with the CPU when the breakpoint does an iret.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-/*</span>
<span class="p_del">- * For i386, NMIs use the same stack as the kernel, and we can</span>
<span class="p_del">- * add a workaround to the iret problem in C (preventing nested</span>
<span class="p_del">- * NMIs if an NMI takes a trap). Simply have 3 states the NMI</span>
<span class="p_del">- * can be in:</span>
<span class="p_add">+ * NMIs can page fault or hit breakpoints which will cause it to lose</span>
<span class="p_add">+ * its NMI context with the CPU when the breakpoint or page fault does an IRET.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * As a result, NMIs can nest if NMIs get unmasked due an IRET during</span>
<span class="p_add">+ * NMI processing.  On x86_64, the asm glue protects us from nested NMIs</span>
<span class="p_add">+ * if the outer NMI came from kernel mode, but we can still nest if the</span>
<span class="p_add">+ * outer NMI came from user mode.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * To handle these nested NMIs, we have three states:</span>
  *
  *  1) not running
  *  2) executing
<span class="p_chunk">@@ -430,15 +430,14 @@</span> <span class="p_context"> NOKPROBE_SYMBOL(default_do_nmi);</span>
  * (Note, the latch is binary, thus multiple NMIs triggering,
  *  when one is running, are ignored. Only one NMI is restarted.)
  *
<span class="p_del">- * If an NMI hits a breakpoint that executes an iret, another</span>
<span class="p_del">- * NMI can preempt it. We do not want to allow this new NMI</span>
<span class="p_del">- * to run, but we want to execute it when the first one finishes.</span>
<span class="p_del">- * We set the state to &quot;latched&quot;, and the exit of the first NMI will</span>
<span class="p_del">- * perform a dec_return, if the result is zero (NOT_RUNNING), then</span>
<span class="p_del">- * it will simply exit the NMI handler. If not, the dec_return</span>
<span class="p_del">- * would have set the state to NMI_EXECUTING (what we want it to</span>
<span class="p_del">- * be when we are running). In this case, we simply jump back</span>
<span class="p_del">- * to rerun the NMI handler again, and restart the &#39;latched&#39; NMI.</span>
<span class="p_add">+ * If an NMI executes an iret, another NMI can preempt it. We do not</span>
<span class="p_add">+ * want to allow this new NMI to run, but we want to execute it when the</span>
<span class="p_add">+ * first one finishes.  We set the state to &quot;latched&quot;, and the exit of</span>
<span class="p_add">+ * the first NMI will perform a dec_return, if the result is zero</span>
<span class="p_add">+ * (NOT_RUNNING), then it will simply exit the NMI handler. If not, the</span>
<span class="p_add">+ * dec_return would have set the state to NMI_EXECUTING (what we want it</span>
<span class="p_add">+ * to be when we are running). In this case, we simply jump back to</span>
<span class="p_add">+ * rerun the NMI handler again, and restart the &#39;latched&#39; NMI.</span>
  *
  * No trap (breakpoint or page fault) should be hit before nmi_restart,
  * thus there is no race between the first check of state for NOT_RUNNING
<span class="p_chunk">@@ -461,49 +460,36 @@</span> <span class="p_context"> enum nmi_states {</span>
 static DEFINE_PER_CPU(enum nmi_states, nmi_state);
 static DEFINE_PER_CPU(unsigned long, nmi_cr2);
 
<span class="p_del">-#define nmi_nesting_preprocess(regs)					\</span>
<span class="p_del">-	do {								\</span>
<span class="p_del">-		if (this_cpu_read(nmi_state) != NMI_NOT_RUNNING) {	\</span>
<span class="p_del">-			this_cpu_write(nmi_state, NMI_LATCHED);		\</span>
<span class="p_del">-			return;						\</span>
<span class="p_del">-		}							\</span>
<span class="p_del">-		this_cpu_write(nmi_state, NMI_EXECUTING);		\</span>
<span class="p_del">-		this_cpu_write(nmi_cr2, read_cr2());			\</span>
<span class="p_del">-	} while (0);							\</span>
<span class="p_del">-	nmi_restart:</span>
<span class="p_del">-</span>
<span class="p_del">-#define nmi_nesting_postprocess()					\</span>
<span class="p_del">-	do {								\</span>
<span class="p_del">-		if (unlikely(this_cpu_read(nmi_cr2) != read_cr2()))	\</span>
<span class="p_del">-			write_cr2(this_cpu_read(nmi_cr2));		\</span>
<span class="p_del">-		if (this_cpu_dec_return(nmi_state))			\</span>
<span class="p_del">-			goto nmi_restart;				\</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-#else /* x86_64 */</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
 /*
<span class="p_del">- * In x86_64 things are a bit more difficult. This has the same problem</span>
<span class="p_del">- * where an NMI hitting a breakpoint that calls iret will remove the</span>
<span class="p_del">- * NMI context, allowing a nested NMI to enter. What makes this more</span>
<span class="p_del">- * difficult is that both NMIs and breakpoints have their own stack.</span>
<span class="p_del">- * When a new NMI or breakpoint is executed, the stack is set to a fixed</span>
<span class="p_del">- * point. If an NMI is nested, it will have its stack set at that same</span>
<span class="p_del">- * fixed address that the first NMI had, and will start corrupting the</span>
<span class="p_del">- * stack. This is handled in entry_64.S, but the same problem exists with</span>
<span class="p_del">- * the breakpoint stack.</span>
<span class="p_add">+ * In x86_64, we need to handle breakpoint -&gt; NMI -&gt; breakpoint.  Without</span>
<span class="p_add">+ * some care, the inner breakpoint will clobber the outer breakpoint&#39;s</span>
<span class="p_add">+ * stack.</span>
  *
<span class="p_del">- * If a breakpoint is being processed, and the debug stack is being used,</span>
<span class="p_del">- * if an NMI comes in and also hits a breakpoint, the stack pointer</span>
<span class="p_del">- * will be set to the same fixed address as the breakpoint that was</span>
<span class="p_del">- * interrupted, causing that stack to be corrupted. To handle this case,</span>
<span class="p_del">- * check if the stack that was interrupted is the debug stack, and if</span>
<span class="p_del">- * so, change the IDT so that new breakpoints will use the current stack</span>
<span class="p_del">- * and not switch to the fixed address. On return of the NMI, switch back</span>
<span class="p_del">- * to the original IDT.</span>
<span class="p_add">+ * If a breakpoint is being processed, and the debug stack is being</span>
<span class="p_add">+ * used, if an NMI comes in and also hits a breakpoint, the stack</span>
<span class="p_add">+ * pointer will be set to the same fixed address as the breakpoint that</span>
<span class="p_add">+ * was interrupted, causing that stack to be corrupted. To handle this</span>
<span class="p_add">+ * case, check if the stack that was interrupted is the debug stack, and</span>
<span class="p_add">+ * if so, change the IDT so that new breakpoints will use the current</span>
<span class="p_add">+ * stack and not switch to the fixed address. On return of the NMI,</span>
<span class="p_add">+ * switch back to the original IDT.</span>
  */
 static DEFINE_PER_CPU(int, update_debug_stack);
<span class="p_add">+#endif</span>
 
<span class="p_del">-static inline void nmi_nesting_preprocess(struct pt_regs *regs)</span>
<span class="p_add">+dotraplinkage notrace void</span>
<span class="p_add">+do_nmi(struct pt_regs *regs, long error_code)</span>
 {
<span class="p_add">+	if (this_cpu_read(nmi_state) != NMI_NOT_RUNNING) {</span>
<span class="p_add">+		this_cpu_write(nmi_state, NMI_LATCHED);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	this_cpu_write(nmi_state, NMI_EXECUTING);</span>
<span class="p_add">+	this_cpu_write(nmi_cr2, read_cr2());</span>
<span class="p_add">+nmi_restart:</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
 	/*
 	 * If we interrupted a breakpoint, it is possible that
 	 * the nmi handler will have breakpoints too. We need to
<span class="p_chunk">@@ -514,22 +500,8 @@</span> <span class="p_context"> static inline void nmi_nesting_preprocess(struct pt_regs *regs)</span>
 		debug_stack_set_zero();
 		this_cpu_write(update_debug_stack, 1);
 	}
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void nmi_nesting_postprocess(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (unlikely(this_cpu_read(update_debug_stack))) {</span>
<span class="p_del">-		debug_stack_reset();</span>
<span class="p_del">-		this_cpu_write(update_debug_stack, 0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
 #endif
 
<span class="p_del">-dotraplinkage notrace void</span>
<span class="p_del">-do_nmi(struct pt_regs *regs, long error_code)</span>
<span class="p_del">-{</span>
<span class="p_del">-	nmi_nesting_preprocess(regs);</span>
<span class="p_del">-</span>
 	nmi_enter();
 
 	inc_irq_stat(__nmi_count);
<span class="p_chunk">@@ -539,8 +511,17 @@</span> <span class="p_context"> do_nmi(struct pt_regs *regs, long error_code)</span>
 
 	nmi_exit();
 
<span class="p_del">-	/* On i386, may loop back to preprocess */</span>
<span class="p_del">-	nmi_nesting_postprocess();</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	if (unlikely(this_cpu_read(update_debug_stack))) {</span>
<span class="p_add">+		debug_stack_reset();</span>
<span class="p_add">+		this_cpu_write(update_debug_stack, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(this_cpu_read(nmi_cr2) != read_cr2()))</span>
<span class="p_add">+		write_cr2(this_cpu_read(nmi_cr2));</span>
<span class="p_add">+	if (this_cpu_dec_return(nmi_state))</span>
<span class="p_add">+		goto nmi_restart;</span>
 }
 NOKPROBE_SYMBOL(do_nmi);
 
<span class="p_header">diff --git a/block/bio-integrity.c b/block/bio-integrity.c</span>
<span class="p_header">index 9e241063a616..f56d85b6c5e3 100644</span>
<span class="p_header">--- a/block/bio-integrity.c</span>
<span class="p_header">+++ b/block/bio-integrity.c</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> struct bio_integrity_payload *bio_integrity_alloc(struct bio *bio,</span>
 	unsigned long idx = BIO_POOL_NONE;
 	unsigned inline_vecs;
 
<span class="p_del">-	if (!bs) {</span>
<span class="p_add">+	if (!bs || !bs-&gt;bio_integrity_pool) {</span>
 		bip = kmalloc(sizeof(struct bio_integrity_payload) +
 			      sizeof(struct bio_vec) * nr_vecs, gfp_mask);
 		inline_vecs = nr_vecs;
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> void bio_integrity_free(struct bio *bio)</span>
 	if (bip-&gt;bip_owns_buf)
 		kfree(bip-&gt;bip_buf);
 
<span class="p_del">-	if (bs) {</span>
<span class="p_add">+	if (bs &amp;&amp; bs-&gt;bio_integrity_pool) {</span>
 		if (bip-&gt;bip_slab != BIO_POOL_NONE)
 			bvec_free(bs-&gt;bvec_integrity_pool, bip-&gt;bip_vec,
 				  bip-&gt;bip_slab);
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index 0ec61c9e536c..6467e6afdcd9 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -1820,8 +1820,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(bio_endio_nodec);</span>
  * Allocates and returns a new bio which represents @sectors from the start of
  * @bio, and updates @bio to represent the remaining sectors.
  *
<span class="p_del">- * The newly allocated bio will point to @bio&#39;s bi_io_vec; it is the caller&#39;s</span>
<span class="p_del">- * responsibility to ensure that @bio is not freed before the split.</span>
<span class="p_add">+ * Unless this is a discard request the newly allocated bio will point</span>
<span class="p_add">+ * to @bio&#39;s bi_io_vec; it is the caller&#39;s responsibility to ensure that</span>
<span class="p_add">+ * @bio is not freed before the split.</span>
  */
 struct bio *bio_split(struct bio *bio, int sectors,
 		      gfp_t gfp, struct bio_set *bs)
<span class="p_chunk">@@ -1831,7 +1832,15 @@</span> <span class="p_context"> struct bio *bio_split(struct bio *bio, int sectors,</span>
 	BUG_ON(sectors &lt;= 0);
 	BUG_ON(sectors &gt;= bio_sectors(bio));
 
<span class="p_del">-	split = bio_clone_fast(bio, gfp, bs);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Discards need a mutable bio_vec to accommodate the payload</span>
<span class="p_add">+	 * required by the DSM TRIM and UNMAP commands.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bio-&gt;bi_rw &amp; REQ_DISCARD)</span>
<span class="p_add">+		split = bio_clone_bioset(bio, gfp, bs);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		split = bio_clone_fast(bio, gfp, bs);</span>
<span class="p_add">+</span>
 	if (!split)
 		return NULL;
 
<span class="p_header">diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c</span>
<span class="p_header">index 28d227c5ca77..efc4fa54372a 100644</span>
<span class="p_header">--- a/block/blk-cgroup.c</span>
<span class="p_header">+++ b/block/blk-cgroup.c</span>
<span class="p_chunk">@@ -716,8 +716,12 @@</span> <span class="p_context"> int blkg_conf_prep(struct blkcg *blkcg, const struct blkcg_policy *pol,</span>
 		return -EINVAL;
 
 	disk = get_gendisk(MKDEV(major, minor), &amp;part);
<span class="p_del">-	if (!disk || part)</span>
<span class="p_add">+	if (!disk)</span>
 		return -EINVAL;
<span class="p_add">+	if (part) {</span>
<span class="p_add">+		put_disk(disk);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
 
 	rcu_read_lock();
 	spin_lock_irq(disk-&gt;queue-&gt;queue_lock);
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index a554b2e17cd4..c9707bcf430c 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4173,9 +4173,10 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;ST3320[68]13AS&quot;,	&quot;SD1[5-9]&quot;,	ATA_HORKAGE_NONCQ |
 						ATA_HORKAGE_FIRMWARE_WARN },
 
<span class="p_del">-	/* Seagate Momentus SpinPoint M8 seem to have FPMDA_AA issues */</span>
<span class="p_add">+	/* drives which fail FPDMA_AA activation (some may freeze afterwards) */</span>
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2AR10001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2BA30001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
<span class="p_add">+	{ &quot;VB0250EAVER&quot;,	&quot;HPG7&quot;,		ATA_HORKAGE_BROKEN_FPDMA_AA },</span>
 
 	/* Blacklist entries taken from Silicon Image 3124/3132
 	   Windows driver .inf file - also several Linux problem reports */
<span class="p_chunk">@@ -4226,11 +4227,14 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	/* devices that don&#39;t properly handle queued TRIM commands */
 	{ &quot;Micron_M500_*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Crucial_CT*M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
<span class="p_del">-	{ &quot;Micron_M5[15]0*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_add">+	{ &quot;Micron_M5[15]0_*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
 	{ &quot;Crucial_CT*M550*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Crucial_CT*MX100*&quot;,		&quot;MU01&quot;, ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Samsung SSD 8*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 
<span class="p_add">+	/* devices that don&#39;t properly handle TRIM commands */</span>
<span class="p_add">+	{ &quot;SuperSSpeed S238*&quot;,		NULL,	ATA_HORKAGE_NOTRIM, },</span>
<span class="p_add">+</span>
 	/*
 	 * Some WD SATA-I drives spin up and down erratically when the link
 	 * is put into the slumber mode.  We don&#39;t have full list of the
<span class="p_chunk">@@ -4535,7 +4539,8 @@</span> <span class="p_context"> static unsigned int ata_dev_set_xfermode(struct ata_device *dev)</span>
 	else /* In the ancient relic department - skip all of this */
 		return 0;
 
<span class="p_del">-	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 0);</span>
<span class="p_add">+	/* On some disks, this command causes spin-up, so we need longer timeout */</span>
<span class="p_add">+	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 15000);</span>
 
 	DPRINTK(&quot;EXIT, err_mask=%x\n&quot;, err_mask);
 	return err_mask;
<span class="p_header">diff --git a/drivers/ata/libata-pmp.c b/drivers/ata/libata-pmp.c</span>
<span class="p_header">index 7ccc084bf1df..85aa76116a30 100644</span>
<span class="p_header">--- a/drivers/ata/libata-pmp.c</span>
<span class="p_header">+++ b/drivers/ata/libata-pmp.c</span>
<span class="p_chunk">@@ -460,6 +460,13 @@</span> <span class="p_context"> static void sata_pmp_quirks(struct ata_port *ap)</span>
 				       ATA_LFLAG_NO_SRST |
 				       ATA_LFLAG_ASSUME_ATA;
 		}
<span class="p_add">+	} else if (vendor == 0x11ab &amp;&amp; devid == 0x4140) {</span>
<span class="p_add">+		/* Marvell 4140 quirks */</span>
<span class="p_add">+		ata_for_each_link(link, ap, EDGE) {</span>
<span class="p_add">+			/* port 4 is for SEMB device and it doesn&#39;t like SRST */</span>
<span class="p_add">+			if (link-&gt;pmp == 4)</span>
<span class="p_add">+				link-&gt;flags |= ATA_LFLAG_DISABLED;</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index 72691fd93948..30af1877fcea 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -2514,7 +2514,8 @@</span> <span class="p_context"> static unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)</span>
 		rbuf[14] = (lowest_aligned &gt;&gt; 8) &amp; 0x3f;
 		rbuf[15] = lowest_aligned;
 
<span class="p_del">-		if (ata_id_has_trim(args-&gt;id)) {</span>
<span class="p_add">+		if (ata_id_has_trim(args-&gt;id) &amp;&amp;</span>
<span class="p_add">+		    !(dev-&gt;horkage &amp; ATA_HORKAGE_NOTRIM)) {</span>
 			rbuf[14] |= 0x80; /* TPE */
 
 			if (ata_id_has_zero_after_trim(args-&gt;id))
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 5b19c4384ec5..af9959e0d3a1 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -107,6 +107,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x0cf3, 0xe003) },
 	{ USB_DEVICE(0x0CF3, 0xE004) },
 	{ USB_DEVICE(0x0CF3, 0xE005) },
<span class="p_add">+	{ USB_DEVICE(0x0CF3, 0xE006) },</span>
 	{ USB_DEVICE(0x13d3, 0x3362) },
 	{ USB_DEVICE(0x13d3, 0x3375) },
 	{ USB_DEVICE(0x13d3, 0x3393) },
<span class="p_chunk">@@ -165,6 +166,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x0CF3, 0x817a), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0xe004), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0xe005), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0cf3, 0xe006), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0cf3, 0xe003), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 41abfa124c34..0ff80ad6464b 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -197,6 +197,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x0cf3, 0xe003), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0xe004), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0xe005), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0cf3, 0xe006), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3393), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/crypto/omap-des.c b/drivers/crypto/omap-des.c</span>
<span class="p_header">index b8bc84be8741..54c7ea58a968 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-des.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-des.c</span>
<span class="p_chunk">@@ -536,9 +536,6 @@</span> <span class="p_context"> static int omap_des_crypt_dma_stop(struct omap_des_dev *dd)</span>
 	dmaengine_terminate_all(dd-&gt;dma_lch_in);
 	dmaengine_terminate_all(dd-&gt;dma_lch_out);
 
<span class="p_del">-	dma_unmap_sg(dd-&gt;dev, dd-&gt;in_sg, dd-&gt;in_sg_len, DMA_TO_DEVICE);</span>
<span class="p_del">-	dma_unmap_sg(dd-&gt;dev, dd-&gt;out_sg, dd-&gt;out_sg_len, DMA_FROM_DEVICE);</span>
<span class="p_del">-</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index fe94cc10cd35..ee96912e0824 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -2382,8 +2382,11 @@</span> <span class="p_context"> int drm_mode_setcrtc(struct drm_device *dev, void *data,</span>
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EINVAL;
 
<span class="p_del">-	/* For some reason crtc x/y offsets are signed internally. */</span>
<span class="p_del">-	if (crtc_req-&gt;x &gt; INT_MAX || crtc_req-&gt;y &gt; INT_MAX)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Universal plane src offsets are only 16.16, prevent havoc for</span>
<span class="p_add">+	 * drivers using universal plane code internally.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (crtc_req-&gt;x &amp; 0xffff0000 || crtc_req-&gt;y &amp; 0xffff0000)</span>
 		return -ERANGE;
 
 	drm_modeset_lock_all(dev);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_uncore.c b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">index 28ac6156ec1d..5334c770714b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_chunk">@@ -863,10 +863,12 @@</span> <span class="p_context"> int i915_reg_read_ioctl(struct drm_device *dev,</span>
 	struct drm_i915_private *dev_priv = dev-&gt;dev_private;
 	struct drm_i915_reg_read *reg = data;
 	struct register_whitelist const *entry = whitelist;
<span class="p_add">+	unsigned size;</span>
<span class="p_add">+	u64 offset;</span>
 	int i, ret = 0;
 
 	for (i = 0; i &lt; ARRAY_SIZE(whitelist); i++, entry++) {
<span class="p_del">-		if (entry-&gt;offset == reg-&gt;offset &amp;&amp;</span>
<span class="p_add">+		if (entry-&gt;offset == (reg-&gt;offset &amp; -entry-&gt;size) &amp;&amp;</span>
 		    (1 &lt;&lt; INTEL_INFO(dev)-&gt;gen &amp; entry-&gt;gen_bitmask))
 			break;
 	}
<span class="p_chunk">@@ -874,23 +876,33 @@</span> <span class="p_context"> int i915_reg_read_ioctl(struct drm_device *dev,</span>
 	if (i == ARRAY_SIZE(whitelist))
 		return -EINVAL;
 
<span class="p_add">+	/* We use the low bits to encode extra flags as the register should</span>
<span class="p_add">+	 * be naturally aligned (and those that are not so aligned merely</span>
<span class="p_add">+	 * limit the available flags for that register).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	offset = entry-&gt;offset;</span>
<span class="p_add">+	size = entry-&gt;size;</span>
<span class="p_add">+	size |= reg-&gt;offset ^ offset;</span>
<span class="p_add">+</span>
 	intel_runtime_pm_get(dev_priv);
 
<span class="p_del">-	switch (entry-&gt;size) {</span>
<span class="p_add">+	switch (size) {</span>
<span class="p_add">+	case 8 | 1:</span>
<span class="p_add">+		reg-&gt;val = I915_READ64_2x32(offset, offset+4);</span>
<span class="p_add">+		break;</span>
 	case 8:
<span class="p_del">-		reg-&gt;val = I915_READ64(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ64(offset);</span>
 		break;
 	case 4:
<span class="p_del">-		reg-&gt;val = I915_READ(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ(offset);</span>
 		break;
 	case 2:
<span class="p_del">-		reg-&gt;val = I915_READ16(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ16(offset);</span>
 		break;
 	case 1:
<span class="p_del">-		reg-&gt;val = I915_READ8(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ8(offset);</span>
 		break;
 	default:
<span class="p_del">-		WARN_ON(1);</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index 6bdaa9500f78..19c9925b17ed 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -7501,23 +7501,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 1: /* D1 vblank/vline */
 			switch (src_data) {
 			case 0: /* D1 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int &amp; LB_D1_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int &amp; LB_D1_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int &amp; LB_D1_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int &amp; LB_D1_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -7527,23 +7531,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 2: /* D2 vblank/vline */
 			switch (src_data) {
 			case 0: /* D2 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D2 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -7553,23 +7561,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 3: /* D3 vblank/vline */
 			switch (src_data) {
 			case 0: /* D3 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D3 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -7579,23 +7591,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 4: /* D4 vblank/vline */
 			switch (src_data) {
 			case 0: /* D4 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D4 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -7605,23 +7621,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 5: /* D5 vblank/vline */
 			switch (src_data) {
 			case 0: /* D5 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D5 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -7631,23 +7651,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 6: /* D6 vblank/vline */
 			switch (src_data) {
 			case 0: /* D6 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D6 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -7666,46 +7690,58 @@</span> <span class="p_context"> restart_ih:</span>
 		case 42: /* HPD hotplug */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int &amp; DC_HPD1_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int &amp; DC_HPD1_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; DC_HPD2_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; DC_HPD2_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 2:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; DC_HPD3_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; DC_HPD3_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 3:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; DC_HPD4_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; DC_HPD4_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; DC_HPD5_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; DC_HPD5_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; DC_HPD6_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; DC_HPD6_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">index 5428b692f9a2..76b12cc441e8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_chunk">@@ -4790,7 +4790,7 @@</span> <span class="p_context"> restart_ih:</span>
 		return IRQ_NONE;
 
 	rptr = rdev-&gt;ih.rptr;
<span class="p_del">-	DRM_DEBUG(&quot;r600_irq_process start: rptr %d, wptr %d\n&quot;, rptr, wptr);</span>
<span class="p_add">+	DRM_DEBUG(&quot;evergreen_irq_process start: rptr %d, wptr %d\n&quot;, rptr, wptr);</span>
 
 	/* Order reading of wptr vs. reading of IH ring data */
 	rmb();
<span class="p_chunk">@@ -4808,23 +4808,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 1: /* D1 vblank/vline */
 			switch (src_data) {
 			case 0: /* D1 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D1 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D1 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4834,23 +4838,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 2: /* D2 vblank/vline */
 			switch (src_data) {
 			case 0: /* D2 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D2 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D2 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D2 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4860,23 +4868,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 3: /* D3 vblank/vline */
 			switch (src_data) {
 			case 0: /* D3 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D3 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D3 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D3 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4886,23 +4898,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 4: /* D4 vblank/vline */
 			switch (src_data) {
 			case 0: /* D4 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D4 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D4 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D4 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4912,23 +4928,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 5: /* D5 vblank/vline */
 			switch (src_data) {
 			case 0: /* D5 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D5 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D5 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D5 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4938,23 +4958,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 6: /* D6 vblank/vline */
 			switch (src_data) {
 			case 0: /* D6 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D6 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D6 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D6 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4973,46 +4997,52 @@</span> <span class="p_context"> restart_ih:</span>
 		case 42: /* HPD hotplug */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
 				break;
 			case 2:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
 				break;
 			case 3:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -5022,46 +5052,52 @@</span> <span class="p_context"> restart_ih:</span>
 		case 44: /* hdmi */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status1 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status1 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI0\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status1 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status1 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI0\n&quot;);</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status2 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status2 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status2 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status2 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI1\n&quot;);</span>
 				break;
 			case 2:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status3 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status3 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status3 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status3 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI2\n&quot;);</span>
 				break;
 			case 3:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status4 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status4 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status4 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status4 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI3\n&quot;);</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status5 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status5 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status5 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status5 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI4\n&quot;);</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status6 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status6 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status6 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status6 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI5\n&quot;);</span>
 				break;
 			default:
 				DRM_ERROR(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">index 5e31413fb454..9eab1f172d33 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_chunk">@@ -3866,23 +3866,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 1: /* D1 vblank/vline */
 			switch (src_data) {
 			case 0: /* D1 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D1_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D1_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D1 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D1_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D1_VLINE_INTERRUPT))</span>
<span class="p_add">+				    DRM_DEBUG(&quot;IH: D1 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -3892,23 +3896,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 5: /* D2 vblank/vline */
 			switch (src_data) {
 			case 0: /* D2 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D2_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D2_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D2 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D2_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D2_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D2 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -3926,46 +3934,53 @@</span> <span class="p_context"> restart_ih:</span>
 		case 19: /* HPD/DAC hotplug */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; DC_HPD1_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; DC_HPD1_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD1 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; DC_HPD2_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; DC_HPD2_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD2 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp; DC_HPD3_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp; DC_HPD3_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD3 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp; DC_HPD4_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp; DC_HPD4_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD4 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
 				break;
 			case 10:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp; DC_HPD5_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp; DC_HPD5_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD5 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
 				break;
 			case 12:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp; DC_HPD6_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp; DC_HPD6_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD6 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -3975,18 +3990,22 @@</span> <span class="p_context"> restart_ih:</span>
 		case 21: /* hdmi */
 			switch (src_data) {
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.hdmi0_status &amp; HDMI0_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.hdmi0_status &amp;= ~HDMI0_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI0\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.hdmi0_status &amp; HDMI0_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HDMI0 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.hdmi0_status &amp;= ~HDMI0_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI0\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.hdmi1_status &amp; HDMI0_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.hdmi1_status &amp;= ~HDMI0_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.hdmi1_status &amp; HDMI0_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HDMI1 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.hdmi1_status &amp;= ~HDMI0_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI1\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_ERROR(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index e5ed5ee9d832..ca470fb17aa4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -1484,11 +1484,21 @@</span> <span class="p_context"> int radeon_suspend_kms(struct drm_device *dev, bool suspend, bool fbcon)</span>
 		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
 	}
 
<span class="p_del">-	/* unpin the front buffers */</span>
<span class="p_add">+	/* unpin the front buffers and cursors */</span>
 	list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
<span class="p_add">+		struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);</span>
 		struct radeon_framebuffer *rfb = to_radeon_framebuffer(crtc-&gt;primary-&gt;fb);
 		struct radeon_bo *robj;
 
<span class="p_add">+		if (radeon_crtc-&gt;cursor_bo) {</span>
<span class="p_add">+			struct radeon_bo *robj = gem_to_radeon_bo(radeon_crtc-&gt;cursor_bo);</span>
<span class="p_add">+			r = radeon_bo_reserve(robj, false);</span>
<span class="p_add">+			if (r == 0) {</span>
<span class="p_add">+				radeon_bo_unpin(robj);</span>
<span class="p_add">+				radeon_bo_unreserve(robj);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (rfb == NULL || rfb-&gt;obj == NULL) {
 			continue;
 		}
<span class="p_chunk">@@ -1554,6 +1564,7 @@</span> <span class="p_context"> int radeon_resume_kms(struct drm_device *dev, bool resume, bool fbcon)</span>
 {
 	struct drm_connector *connector;
 	struct radeon_device *rdev = dev-&gt;dev_private;
<span class="p_add">+	struct drm_crtc *crtc;</span>
 	int r;
 
 	if (dev-&gt;switch_power_state == DRM_SWITCH_POWER_OFF)
<span class="p_chunk">@@ -1593,6 +1604,27 @@</span> <span class="p_context"> int radeon_resume_kms(struct drm_device *dev, bool resume, bool fbcon)</span>
 
 	radeon_restore_bios_scratch_regs(rdev);
 
<span class="p_add">+	/* pin cursors */</span>
<span class="p_add">+	list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {</span>
<span class="p_add">+		struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (radeon_crtc-&gt;cursor_bo) {</span>
<span class="p_add">+			struct radeon_bo *robj = gem_to_radeon_bo(radeon_crtc-&gt;cursor_bo);</span>
<span class="p_add">+			r = radeon_bo_reserve(robj, false);</span>
<span class="p_add">+			if (r == 0) {</span>
<span class="p_add">+				/* Only 27 bit offset for legacy cursor */</span>
<span class="p_add">+				r = radeon_bo_pin_restricted(robj,</span>
<span class="p_add">+							     RADEON_GEM_DOMAIN_VRAM,</span>
<span class="p_add">+							     ASIC_IS_AVIVO(rdev) ?</span>
<span class="p_add">+							     0 : 1 &lt;&lt; 27,</span>
<span class="p_add">+							     &amp;radeon_crtc-&gt;cursor_addr);</span>
<span class="p_add">+				if (r != 0)</span>
<span class="p_add">+					DRM_ERROR(&quot;Failed to pin cursor BO (%d)\n&quot;, r);</span>
<span class="p_add">+				radeon_bo_unreserve(robj);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* init dig PHYs, disp eng pll */
 	if (rdev-&gt;is_atom_bios) {
 		radeon_atom_encoder_init(rdev);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_gart.c b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">index 2e723651069b..4259a1fa323f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_chunk">@@ -249,8 +249,10 @@</span> <span class="p_context"> void radeon_gart_unbind(struct radeon_device *rdev, unsigned offset,</span>
 			}
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -292,8 +294,10 @@</span> <span class="p_context"> int radeon_gart_bind(struct radeon_device *rdev, unsigned offset,</span>
 			}
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">index 5040fac05655..22330f6c7737 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_chunk">@@ -6173,23 +6173,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 1: /* D1 vblank/vline */
 			switch (src_data) {
 			case 0: /* D1 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6199,23 +6203,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 2: /* D2 vblank/vline */
 			switch (src_data) {
 			case 0: /* D2 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D2 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6225,23 +6233,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 3: /* D3 vblank/vline */
 			switch (src_data) {
 			case 0: /* D3 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D3 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6251,23 +6263,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 4: /* D4 vblank/vline */
 			switch (src_data) {
 			case 0: /* D4 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D4 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6277,23 +6293,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 5: /* D5 vblank/vline */
 			switch (src_data) {
 			case 0: /* D5 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D5 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6303,23 +6323,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 6: /* D6 vblank/vline */
 			switch (src_data) {
 			case 0: /* D6 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D6 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6338,46 +6362,58 @@</span> <span class="p_context"> restart_ih:</span>
 		case 42: /* HPD hotplug */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 2:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 3:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 4d47c5819c9c..46c945740b85 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2921,6 +2921,7 @@</span> <span class="p_context"> static struct si_dpm_quirk si_dpm_quirk_list[] = {</span>
 	/* PITCAIRN - https://bugs.freedesktop.org/show_bug.cgi?id=76490 */
 	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1462, 0x3036, 0, 120000 },
 	{ PCI_VENDOR_ID_ATI, 0x6811, 0x174b, 0xe271, 0, 120000 },
<span class="p_add">+	{ PCI_VENDOR_ID_ATI, 0x6810, 0x174b, 0xe271, 85000, 90000 },</span>
 	{ 0, 0, 0, 0 },
 };
 
<span class="p_header">diff --git a/drivers/hid/hid-cp2112.c b/drivers/hid/hid-cp2112.c</span>
<span class="p_header">index 56be85a9a77c..ffe69be882de 100644</span>
<span class="p_header">--- a/drivers/hid/hid-cp2112.c</span>
<span class="p_header">+++ b/drivers/hid/hid-cp2112.c</span>
<span class="p_chunk">@@ -352,6 +352,8 @@</span> <span class="p_context"> static int cp2112_read(struct cp2112_device *dev, u8 *data, size_t size)</span>
 	struct cp2112_force_read_report report;
 	int ret;
 
<span class="p_add">+	if (size &gt; sizeof(dev-&gt;read_data))</span>
<span class="p_add">+		size = sizeof(dev-&gt;read_data);</span>
 	report.report = CP2112_DATA_READ_FORCE_SEND;
 	report.length = cpu_to_be16(size);
 
<span class="p_header">diff --git a/drivers/iio/adc/at91_adc.c b/drivers/iio/adc/at91_adc.c</span>
<span class="p_header">index e7ff26a4aef9..fa5d299d9222 100644</span>
<span class="p_header">--- a/drivers/iio/adc/at91_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/at91_adc.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> struct at91_adc_caps {</span>
 	u8	ts_pen_detect_sensitivity;
 
 	/* startup time calculate function */
<span class="p_del">-	u32 (*calc_startup_ticks)(u8 startup_time, u32 adc_clk_khz);</span>
<span class="p_add">+	u32 (*calc_startup_ticks)(u32 startup_time, u32 adc_clk_khz);</span>
 
 	u8	num_channels;
 	struct at91_adc_reg_desc registers;
<span class="p_chunk">@@ -201,7 +201,7 @@</span> <span class="p_context"> struct at91_adc_state {</span>
 	u8			num_channels;
 	void __iomem		*reg_base;
 	struct at91_adc_reg_desc *registers;
<span class="p_del">-	u8			startup_time;</span>
<span class="p_add">+	u32			startup_time;</span>
 	u8			sample_hold_time;
 	bool			sleep_mode;
 	struct iio_trigger	**trig;
<span class="p_chunk">@@ -779,7 +779,7 @@</span> <span class="p_context"> ret:</span>
 	return ret;
 }
 
<span class="p_del">-static u32 calc_startup_ticks_9260(u8 startup_time, u32 adc_clk_khz)</span>
<span class="p_add">+static u32 calc_startup_ticks_9260(u32 startup_time, u32 adc_clk_khz)</span>
 {
 	/*
 	 * Number of ticks needed to cover the startup time of the ADC
<span class="p_chunk">@@ -790,7 +790,7 @@</span> <span class="p_context"> static u32 calc_startup_ticks_9260(u8 startup_time, u32 adc_clk_khz)</span>
 	return round_up((startup_time * adc_clk_khz / 1000) - 1, 8) / 8;
 }
 
<span class="p_del">-static u32 calc_startup_ticks_9x5(u8 startup_time, u32 adc_clk_khz)</span>
<span class="p_add">+static u32 calc_startup_ticks_9x5(u32 startup_time, u32 adc_clk_khz)</span>
 {
 	/*
 	 * For sama5d3x and at91sam9x5, the formula changes to:
<span class="p_header">diff --git a/drivers/iio/adc/twl4030-madc.c b/drivers/iio/adc/twl4030-madc.c</span>
<span class="p_header">index eb86786e698e..c3afe3a38315 100644</span>
<span class="p_header">--- a/drivers/iio/adc/twl4030-madc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/twl4030-madc.c</span>
<span class="p_chunk">@@ -835,7 +835,8 @@</span> <span class="p_context"> static int twl4030_madc_probe(struct platform_device *pdev)</span>
 	irq = platform_get_irq(pdev, 0);
 	ret = devm_request_threaded_irq(&amp;pdev-&gt;dev, irq, NULL,
 				   twl4030_madc_threaded_irq_handler,
<span class="p_del">-				   IRQF_TRIGGER_RISING, &quot;twl4030_madc&quot;, madc);</span>
<span class="p_add">+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT,</span>
<span class="p_add">+				   &quot;twl4030_madc&quot;, madc);</span>
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;could not request irq\n&quot;);
 		goto err_i2c;
<span class="p_header">diff --git a/drivers/iio/adc/vf610_adc.c b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">index 11048473b89e..0062d0e71d03 100644</span>
<span class="p_header">--- a/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_chunk">@@ -555,7 +555,7 @@</span> <span class="p_context"> static int vf610_adc_reg_access(struct iio_dev *indio_dev,</span>
 	struct vf610_adc *info = iio_priv(indio_dev);
 
 	if ((readval == NULL) ||
<span class="p_del">-		(!(reg % 4) || (reg &gt; VF610_REG_ADC_PCTL)))</span>
<span class="p_add">+		((reg % 4) || (reg &gt; VF610_REG_ADC_PCTL)))</span>
 		return -EINVAL;
 
 	*readval = readl(info-&gt;regs + reg);
<span class="p_header">diff --git a/drivers/iio/dac/ad5624r_spi.c b/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_header">index e8199cce2aea..1e666510c672 100644</span>
<span class="p_header">--- a/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_header">+++ b/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_chunk">@@ -22,7 +22,7 @@</span> <span class="p_context"></span>
 #include &quot;ad5624r.h&quot;
 
 static int ad5624r_spi_write(struct spi_device *spi,
<span class="p_del">-			     u8 cmd, u8 addr, u16 val, u8 len)</span>
<span class="p_add">+			     u8 cmd, u8 addr, u16 val, u8 shift)</span>
 {
 	u32 data;
 	u8 msg[3];
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> static int ad5624r_spi_write(struct spi_device *spi,</span>
 	 * 14-, 12-bit input code followed by 0, 2, or 4 don&#39;t care bits,
 	 * for the AD5664R, AD5644R, and AD5624R, respectively.
 	 */
<span class="p_del">-	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; (16 - len));</span>
<span class="p_add">+	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; shift);</span>
 	msg[0] = data &gt;&gt; 16;
 	msg[1] = data &gt;&gt; 8;
 	msg[2] = data;
<span class="p_header">diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_header">index 0c6517c94a9d..63468e3c3ac8 100644</span>
<span class="p_header">--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_header">+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_chunk">@@ -340,6 +340,23 @@</span> <span class="p_context"> static int inv_mpu6050_write_fsr(struct inv_mpu6050_state *st, int fsr)</span>
 	return 0;
 }
 
<span class="p_add">+static int inv_write_raw_get_fmt(struct iio_dev *indio_dev,</span>
<span class="p_add">+				 struct iio_chan_spec const *chan, long mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (mask) {</span>
<span class="p_add">+	case IIO_CHAN_INFO_SCALE:</span>
<span class="p_add">+		switch (chan-&gt;type) {</span>
<span class="p_add">+		case IIO_ANGL_VEL:</span>
<span class="p_add">+			return IIO_VAL_INT_PLUS_NANO;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			return IIO_VAL_INT_PLUS_MICRO;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return IIO_VAL_INT_PLUS_MICRO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
 static int inv_mpu6050_write_accel_fs(struct inv_mpu6050_state *st, int fs)
 {
 	int result;
<span class="p_chunk">@@ -603,6 +620,7 @@</span> <span class="p_context"> static const struct iio_info mpu_info = {</span>
 	.driver_module = THIS_MODULE,
 	.read_raw = &amp;inv_mpu6050_read_raw,
 	.write_raw = &amp;inv_mpu6050_write_raw,
<span class="p_add">+	.write_raw_get_fmt = &amp;inv_write_raw_get_fmt,</span>
 	.attrs = &amp;inv_attribute_group,
 	.validate_trigger = inv_mpu6050_validate_trigger,
 };
<span class="p_header">diff --git a/drivers/iio/temperature/tmp006.c b/drivers/iio/temperature/tmp006.c</span>
<span class="p_header">index 84a0789c3d96..7a8050996b4e 100644</span>
<span class="p_header">--- a/drivers/iio/temperature/tmp006.c</span>
<span class="p_header">+++ b/drivers/iio/temperature/tmp006.c</span>
<span class="p_chunk">@@ -132,6 +132,9 @@</span> <span class="p_context"> static int tmp006_write_raw(struct iio_dev *indio_dev,</span>
 	struct tmp006_data *data = iio_priv(indio_dev);
 	int i;
 
<span class="p_add">+	if (mask != IIO_CHAN_INFO_SAMP_FREQ)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; ARRAY_SIZE(tmp006_freqs); i++)
 		if ((val == tmp006_freqs[i][0]) &amp;&amp;
 		    (val2 == tmp006_freqs[i][1])) {
<span class="p_header">diff --git a/drivers/input/touchscreen/usbtouchscreen.c b/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_header">index a0966331a89b..c6f7e918b2b1 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_chunk">@@ -625,6 +625,9 @@</span> <span class="p_context"> static int dmc_tsc10_init(struct usbtouch_usb *usbtouch)</span>
 		goto err_out;
 	}
 
<span class="p_add">+	/* TSC-25 data sheet specifies a delay after the RESET command */</span>
<span class="p_add">+	msleep(150);</span>
<span class="p_add">+</span>
 	/* set coordinate output rate */
 	buf[0] = buf[1] = 0xFF;
 	ret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),
<span class="p_header">diff --git a/drivers/isdn/gigaset/ser-gigaset.c b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">index 8c91fd5eb6fd..3ac9c4194814 100644</span>
<span class="p_header">--- a/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">+++ b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_chunk">@@ -524,9 +524,18 @@</span> <span class="p_context"> gigaset_tty_open(struct tty_struct *tty)</span>
 	cs-&gt;hw.ser-&gt;tty = tty;
 	atomic_set(&amp;cs-&gt;hw.ser-&gt;refcnt, 1);
 	init_completion(&amp;cs-&gt;hw.ser-&gt;dead_cmp);
<span class="p_del">-</span>
 	tty-&gt;disc_data = cs;
 
<span class="p_add">+	/* Set the amount of data we&#39;re willing to receive per call</span>
<span class="p_add">+	 * from the hardware driver to half of the input buffer size</span>
<span class="p_add">+	 * to leave some reserve.</span>
<span class="p_add">+	 * Note: We don&#39;t do flow control towards the hardware driver.</span>
<span class="p_add">+	 * If more data is received than will fit into the input buffer,</span>
<span class="p_add">+	 * it will be dropped and an error will be logged. This should</span>
<span class="p_add">+	 * never happen as the device is slow and the buffer size ample.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	tty-&gt;receive_room = RBUFSIZE/2;</span>
<span class="p_add">+</span>
 	/* OK.. Initialization of the datastructures and the HW is done.. Now
 	 * startup system and notify the LL that we are ready to run
 	 */
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index f5b1af403b5c..8276c3b29ab4 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -6225,7 +6225,7 @@</span> <span class="p_context"> static int update_array_info(struct mddev *mddev, mdu_array_info_t *info)</span>
 	    mddev-&gt;ctime         != info-&gt;ctime         ||
 	    mddev-&gt;level         != info-&gt;level         ||
 /*	    mddev-&gt;layout        != info-&gt;layout        || */
<span class="p_del">-	    !mddev-&gt;persistent	 != info-&gt;not_persistent||</span>
<span class="p_add">+	    mddev-&gt;persistent	 != !info-&gt;not_persistent ||</span>
 	    mddev-&gt;chunk_sectors != info-&gt;chunk_size &gt;&gt; 9 ||
 	    /* ignore bottom 8 bits of state, and allow SB_BITMAP_PRESENT to change */
 	    ((state^info-&gt;state) &amp; 0xfffffe00)
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">index b88757cd0d1d..a03178e91a79 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_chunk">@@ -309,8 +309,8 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 
 		if (s &lt; 0 &amp;&amp; nr_center &lt; -s) {
 			/* not enough in central node */
<span class="p_del">-			shift(left, center, nr_center);</span>
<span class="p_del">-			s = nr_center - target;</span>
<span class="p_add">+			shift(left, center, -nr_center);</span>
<span class="p_add">+			s += nr_center;</span>
 			shift(left, right, s);
 			nr_right += s;
 		} else
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 		if (s &gt; 0 &amp;&amp; nr_center &lt; s) {
 			/* not enough in central node */
 			shift(center, right, nr_center);
<span class="p_del">-			s = target - nr_center;</span>
<span class="p_add">+			s -= nr_center;</span>
 			shift(left, right, s);
 			nr_left -= s;
 		} else
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 200ac12a1d40..fdd3793e22f9 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 	int r;
 	struct del_stack *s;
 
<span class="p_del">-	s = kmalloc(sizeof(*s), GFP_KERNEL);</span>
<span class="p_add">+	s = kmalloc(sizeof(*s), GFP_NOIO);</span>
 	if (!s)
 		return -ENOMEM;
 	s-&gt;info = info;
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index b96ee9d78aa3..9be97e0bd149 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -336,7 +336,7 @@</span> <span class="p_context"> static void raid1_end_read_request(struct bio *bio, int error)</span>
 		spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);
 		if (r1_bio-&gt;mddev-&gt;degraded == conf-&gt;raid_disks ||
 		    (r1_bio-&gt;mddev-&gt;degraded == conf-&gt;raid_disks-1 &amp;&amp;
<span class="p_del">-		     !test_bit(Faulty, &amp;conf-&gt;mirrors[mirror].rdev-&gt;flags)))</span>
<span class="p_add">+		     test_bit(In_sync, &amp;conf-&gt;mirrors[mirror].rdev-&gt;flags)))</span>
 			uptodate = 1;
 		spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
 	}
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 7ec3c79852e5..96d2f08a2516 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -205,6 +205,8 @@</span> <span class="p_context"> static ssize_t power_ro_lock_show(struct device *dev,</span>
 
 	ret = snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, locked);
 
<span class="p_add">+	mmc_blk_put(md);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c</span>
<span class="p_header">index 6c70a01b5c15..d4368603e67a 100644</span>
<span class="p_header">--- a/drivers/mmc/host/omap_hsmmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/omap_hsmmc.c</span>
<span class="p_chunk">@@ -1079,6 +1079,10 @@</span> <span class="p_context"> static void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)</span>
 
 		if (status &amp; (CTO_EN | CCRC_EN))
 			end_cmd = 1;
<span class="p_add">+		if (host-&gt;data || host-&gt;response_busy) {</span>
<span class="p_add">+			end_trans = !end_cmd;</span>
<span class="p_add">+			host-&gt;response_busy = 0;</span>
<span class="p_add">+		}</span>
 		if (status &amp; (CTO_EN | DTO_EN))
 			hsmmc_command_incomplete(host, -ETIMEDOUT, end_cmd);
 		else if (status &amp; (CCRC_EN | DCRC_EN))
<span class="p_chunk">@@ -1098,10 +1102,6 @@</span> <span class="p_context"> static void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)</span>
 			}
 			dev_dbg(mmc_dev(host-&gt;mmc), &quot;AC12 err: 0x%x\n&quot;, ac12);
 		}
<span class="p_del">-		if (host-&gt;data || host-&gt;response_busy) {</span>
<span class="p_del">-			end_trans = !end_cmd;</span>
<span class="p_del">-			host-&gt;response_busy = 0;</span>
<span class="p_del">-		}</span>
 	}
 
 	OMAP_HSMMC_WRITE(host-&gt;base, STAT, status);
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h</span>
<span class="p_header">index 3497cfaf683c..a870c42731d7 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-esdhc.h</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-esdhc.h</span>
<span class="p_chunk">@@ -45,6 +45,6 @@</span> <span class="p_context"></span>
 #define ESDHC_DMA_SYSCTL	0x40c
 #define ESDHC_DMA_SNOOP		0x00000040
 
<span class="p_del">-#define ESDHC_HOST_CONTROL_RES	0x05</span>
<span class="p_add">+#define ESDHC_HOST_CONTROL_RES	0x01</span>
 
 #endif /* _DRIVERS_MMC_SDHCI_ESDHC_H */
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c</span>
<span class="p_header">index 8be4dcfb49a0..fdc27327aece 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-of-esdhc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-of-esdhc.c</span>
<span class="p_chunk">@@ -276,6 +276,14 @@</span> <span class="p_context"> static void esdhc_pltfm_set_bus_width(struct sdhci_host *host, int width)</span>
 			ESDHC_CTRL_BUSWIDTH_MASK, ctrl);
 }
 
<span class="p_add">+static void esdhc_reset(struct sdhci_host *host, u8 mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sdhci_reset(host, mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	sdhci_writel(host, host-&gt;ier, SDHCI_INT_ENABLE);</span>
<span class="p_add">+	sdhci_writel(host, host-&gt;ier, SDHCI_SIGNAL_ENABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct sdhci_ops sdhci_esdhc_ops = {
 	.read_l = esdhc_readl,
 	.read_w = esdhc_readw,
<span class="p_chunk">@@ -290,7 +298,7 @@</span> <span class="p_context"> static const struct sdhci_ops sdhci_esdhc_ops = {</span>
 	.platform_init = esdhc_of_platform_init,
 	.adma_workaround = esdhci_of_adma_workaround,
 	.set_bus_width = esdhc_pltfm_set_bus_width,
<span class="p_del">-	.reset = sdhci_reset,</span>
<span class="p_add">+	.reset = esdhc_reset,</span>
 	.set_uhs_signaling = sdhci_set_uhs_signaling,
 };
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-pxav3.c b/drivers/mmc/host/sdhci-pxav3.c</span>
<span class="p_header">index 3ceadd11f641..e630970c4f31 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-pxav3.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-pxav3.c</span>
<span class="p_chunk">@@ -360,6 +360,7 @@</span> <span class="p_context"> static int sdhci_pxav3_probe(struct platform_device *pdev)</span>
 			goto err_of_parse;
 		sdhci_get_of_property(pdev);
 		pdata = pxav3_get_mmc_pdata(dev);
<span class="p_add">+		pdev-&gt;dev.platform_data = pdata;</span>
 	} else if (pdata) {
 		/* on-chip device */
 		if (pdata-&gt;flags &amp; PXA_FLAG_CARD_PERMANENT)
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index 14faf3ec7c7f..e7421fa1d103 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -1642,9 +1642,16 @@</span> <span class="p_context"> err_free:</span>
 
 err_undo_flags:
 	/* Enslave of first slave has failed and we need to fix master&#39;s mac */
<span class="p_del">-	if (!bond_has_slaves(bond) &amp;&amp;</span>
<span class="p_del">-	    ether_addr_equal_64bits(bond_dev-&gt;dev_addr, slave_dev-&gt;dev_addr))</span>
<span class="p_del">-		eth_hw_addr_random(bond_dev);</span>
<span class="p_add">+	if (!bond_has_slaves(bond)) {</span>
<span class="p_add">+		if (ether_addr_equal_64bits(bond_dev-&gt;dev_addr,</span>
<span class="p_add">+					    slave_dev-&gt;dev_addr))</span>
<span class="p_add">+			eth_hw_addr_random(bond_dev);</span>
<span class="p_add">+		if (bond_dev-&gt;type != ARPHRD_ETHER) {</span>
<span class="p_add">+			ether_setup(bond_dev);</span>
<span class="p_add">+			bond_dev-&gt;flags |= IFF_MASTER;</span>
<span class="p_add">+			bond_dev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	return res;
 }
<span class="p_chunk">@@ -1851,6 +1858,7 @@</span> <span class="p_context"> static int  bond_release_and_destroy(struct net_device *bond_dev,</span>
 		bond_dev-&gt;priv_flags |= IFF_DISABLE_NETPOLL;
 		pr_info(&quot;%s: Destroying bond %s\n&quot;,
 			bond_dev-&gt;name, bond_dev-&gt;name);
<span class="p_add">+		bond_remove_proc_entry(bond);</span>
 		unregister_netdevice(bond_dev);
 	}
 	return ret;
<span class="p_header">diff --git a/drivers/net/can/rcar_can.c b/drivers/net/can/rcar_can.c</span>
<span class="p_header">index 5268d216ecfa..6a4f107da6bf 100644</span>
<span class="p_header">--- a/drivers/net/can/rcar_can.c</span>
<span class="p_header">+++ b/drivers/net/can/rcar_can.c</span>
<span class="p_chunk">@@ -517,7 +517,7 @@</span> <span class="p_context"> static int rcar_can_open(struct net_device *ndev)</span>
 	napi_enable(&amp;priv-&gt;napi);
 	err = request_irq(ndev-&gt;irq, rcar_can_interrupt, 0, ndev-&gt;name, ndev);
 	if (err) {
<span class="p_del">-		netdev_err(ndev, &quot;error requesting interrupt %x\n&quot;, ndev-&gt;irq);</span>
<span class="p_add">+		netdev_err(ndev, &quot;error requesting interrupt %d\n&quot;, ndev-&gt;irq);</span>
 		goto out_close;
 	}
 	can_led_event(ndev, CAN_LED_EVENT_OPEN);
<span class="p_chunk">@@ -732,8 +732,9 @@</span> <span class="p_context"> static int rcar_can_probe(struct platform_device *pdev)</span>
 	}
 
 	irq = platform_get_irq(pdev, 0);
<span class="p_del">-	if (!irq) {</span>
<span class="p_add">+	if (irq &lt; 0) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;No IRQ resource\n&quot;);
<span class="p_add">+		err = irq;</span>
 		goto fail;
 	}
 
<span class="p_chunk">@@ -785,7 +786,7 @@</span> <span class="p_context"> static int rcar_can_probe(struct platform_device *pdev)</span>
 
 	devm_can_led_init(ndev);
 
<span class="p_del">-	dev_info(&amp;pdev-&gt;dev, &quot;device registered (reg_base=%p, irq=%u)\n&quot;,</span>
<span class="p_add">+	dev_info(&amp;pdev-&gt;dev, &quot;device registered (regs @ %p, IRQ%d)\n&quot;,</span>
 		 priv-&gt;regs, ndev-&gt;irq);
 
 	return 0;
<span class="p_header">diff --git a/drivers/net/can/spi/mcp251x.c b/drivers/net/can/spi/mcp251x.c</span>
<span class="p_header">index 5df239e68812..cc7ee1b6602b 100644</span>
<span class="p_header">--- a/drivers/net/can/spi/mcp251x.c</span>
<span class="p_header">+++ b/drivers/net/can/spi/mcp251x.c</span>
<span class="p_chunk">@@ -1228,17 +1228,16 @@</span> <span class="p_context"> static int __maybe_unused mcp251x_can_resume(struct device *dev)</span>
 	struct spi_device *spi = to_spi_device(dev);
 	struct mcp251x_priv *priv = spi_get_drvdata(spi);
 
<span class="p_del">-	if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_POWER) {</span>
<span class="p_add">+	if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_POWER)</span>
 		mcp251x_power_enable(priv-&gt;power, 1);
<span class="p_add">+</span>
<span class="p_add">+	if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_UP) {</span>
<span class="p_add">+		mcp251x_power_enable(priv-&gt;transceiver, 1);</span>
 		queue_work(priv-&gt;wq, &amp;priv-&gt;restart_work);
 	} else {
<span class="p_del">-		if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_UP) {</span>
<span class="p_del">-			mcp251x_power_enable(priv-&gt;transceiver, 1);</span>
<span class="p_del">-			queue_work(priv-&gt;wq, &amp;priv-&gt;restart_work);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			priv-&gt;after_suspend = 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		priv-&gt;after_suspend = 0;</span>
 	}
<span class="p_add">+</span>
 	priv-&gt;force_quit = 0;
 	enable_irq(spi-&gt;irq);
 	return 0;
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 807fbdc4b21b..109908574224 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -1433,7 +1433,7 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 		     struct mvneta_rx_queue *rxq)
 {
 	struct net_device *dev = pp-&gt;dev;
<span class="p_del">-	int rx_done, rx_filled;</span>
<span class="p_add">+	int rx_done;</span>
 	u32 rcvd_pkts = 0;
 	u32 rcvd_bytes = 0;
 
<span class="p_chunk">@@ -1444,7 +1444,6 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 		rx_todo = rx_done;
 
 	rx_done = 0;
<span class="p_del">-	rx_filled = 0;</span>
 
 	/* Fairness NAPI loop */
 	while (rx_done &lt; rx_todo) {
<span class="p_chunk">@@ -1455,7 +1454,6 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 		int rx_bytes, err;
 
 		rx_done++;
<span class="p_del">-		rx_filled++;</span>
 		rx_status = rx_desc-&gt;status;
 		rx_bytes = rx_desc-&gt;data_size - (ETH_FCS_LEN + MVNETA_MH_SIZE);
 		data = (unsigned char *)rx_desc-&gt;buf_cookie;
<span class="p_chunk">@@ -1495,6 +1493,14 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 			continue;
 		}
 
<span class="p_add">+		/* Refill processing */</span>
<span class="p_add">+		err = mvneta_rx_refill(pp, rx_desc);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			netdev_err(dev, &quot;Linux processing - Can&#39;t refill\n&quot;);</span>
<span class="p_add">+			rxq-&gt;missed++;</span>
<span class="p_add">+			goto err_drop_frame;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		skb = build_skb(data, pp-&gt;frag_size &gt; PAGE_SIZE ? 0 : pp-&gt;frag_size);
 		if (!skb)
 			goto err_drop_frame;
<span class="p_chunk">@@ -1514,14 +1520,6 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 		mvneta_rx_csum(pp, rx_status, skb);
 
 		napi_gro_receive(&amp;pp-&gt;napi, skb);
<span class="p_del">-</span>
<span class="p_del">-		/* Refill processing */</span>
<span class="p_del">-		err = mvneta_rx_refill(pp, rx_desc);</span>
<span class="p_del">-		if (err) {</span>
<span class="p_del">-			netdev_err(dev, &quot;Linux processing - Can&#39;t refill\n&quot;);</span>
<span class="p_del">-			rxq-&gt;missed++;</span>
<span class="p_del">-			rx_filled--;</span>
<span class="p_del">-		}</span>
 	}
 
 	if (rcvd_pkts) {
<span class="p_chunk">@@ -1534,7 +1532,7 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 	}
 
 	/* Update rxq management counters */
<span class="p_del">-	mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_filled);</span>
<span class="p_add">+	mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_done);</span>
 
 	return rx_done;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c</span>
<span class="p_header">index 099b1eea1f11..3a8341c839d5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ti/cpsw.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ti/cpsw.c</span>
<span class="p_chunk">@@ -507,9 +507,11 @@</span> <span class="p_context"> static const struct cpsw_stats cpsw_gstrings_stats[] = {</span>
 				(func)(slave++, ##arg);			\
 	} while (0)
 #define cpsw_get_slave_ndev(priv, __slave_no__)				\
<span class="p_del">-	(priv-&gt;slaves[__slave_no__].ndev)</span>
<span class="p_add">+	((__slave_no__ &lt; priv-&gt;data.slaves) ?				\</span>
<span class="p_add">+		priv-&gt;slaves[__slave_no__].ndev : NULL)</span>
 #define cpsw_get_slave_priv(priv, __slave_no__)				\
<span class="p_del">-	((priv-&gt;slaves[__slave_no__].ndev) ?				\</span>
<span class="p_add">+	(((__slave_no__ &lt; priv-&gt;data.slaves) &amp;&amp;				\</span>
<span class="p_add">+		(priv-&gt;slaves[__slave_no__].ndev)) ?			\</span>
 		netdev_priv(priv-&gt;slaves[__slave_no__].ndev) : NULL)	\
 
 #define cpsw_dual_emac_src_port_detect(status, priv, ndev, skb)		\
<span class="p_header">diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c</span>
<span class="p_header">index c65b636bcab9..09e4f4ef4eb8 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/netback.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/netback.c</span>
<span class="p_chunk">@@ -1703,13 +1703,13 @@</span> <span class="p_context"> static inline void xenvif_tx_dealloc_action(struct xenvif_queue *queue)</span>
 		smp_rmb();
 
 		while (dc != dp) {
<span class="p_del">-			BUG_ON(gop - queue-&gt;tx_unmap_ops &gt; MAX_PENDING_REQS);</span>
<span class="p_add">+			BUG_ON(gop - queue-&gt;tx_unmap_ops &gt;= MAX_PENDING_REQS);</span>
 			pending_idx =
 				queue-&gt;dealloc_ring[pending_index(dc++)];
 
<span class="p_del">-			pending_idx_release[gop-queue-&gt;tx_unmap_ops] =</span>
<span class="p_add">+			pending_idx_release[gop - queue-&gt;tx_unmap_ops] =</span>
 				pending_idx;
<span class="p_del">-			queue-&gt;pages_to_unmap[gop-queue-&gt;tx_unmap_ops] =</span>
<span class="p_add">+			queue-&gt;pages_to_unmap[gop - queue-&gt;tx_unmap_ops] =</span>
 				queue-&gt;mmap_pages[pending_idx];
 			gnttab_set_unmap_op(gop,
 					    idx_to_kaddr(queue, pending_idx),
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index 791460b798f4..2aa95c89b5bf 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -1693,6 +1693,9 @@</span> <span class="p_context"> static int sg_start_req(Sg_request *srp, unsigned char *cmd)</span>
 			md-&gt;from_user = 0;
 	}
 
<span class="p_add">+	if (unlikely(iov_count &gt; UIO_MAXIOV))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (iov_count) {
 		int len, size = sizeof(struct sg_iovec) * iov_count;
 		struct iovec *iov;
<span class="p_header">diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c</span>
<span class="p_header">index 14eb4b256a03..daa67f509133 100644</span>
<span class="p_header">--- a/drivers/scsi/st.c</span>
<span class="p_header">+++ b/drivers/scsi/st.c</span>
<span class="p_chunk">@@ -1262,9 +1262,9 @@</span> <span class="p_context"> static int st_open(struct inode *inode, struct file *filp)</span>
 	spin_lock(&amp;st_use_lock);
 	STp-&gt;in_use = 0;
 	spin_unlock(&amp;st_use_lock);
<span class="p_del">-	scsi_tape_put(STp);</span>
 	if (resumed)
 		scsi_autopm_put_device(STp-&gt;device);
<span class="p_add">+	scsi_tape_put(STp);</span>
 	return retval;
 
 }
<span class="p_header">diff --git a/drivers/thermal/step_wise.c b/drivers/thermal/step_wise.c</span>
<span class="p_header">index ee52ab7d3730..c501eba601da 100644</span>
<span class="p_header">--- a/drivers/thermal/step_wise.c</span>
<span class="p_header">+++ b/drivers/thermal/step_wise.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static unsigned long get_target_state(struct thermal_instance *instance,</span>
 			next_target = instance-&gt;upper;
 		break;
 	case THERMAL_TREND_DROPPING:
<span class="p_del">-		if (cur_state == instance-&gt;lower) {</span>
<span class="p_add">+		if (cur_state &lt;= instance-&gt;lower) {</span>
 			if (!throttle)
 				next_target = THERMAL_NO_TARGET;
 		} else {
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index fae81924fd4b..a85eadff6bea 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -1690,7 +1690,7 @@</span> <span class="p_context"> static struct async *reap_as(struct usb_dev_state *ps)</span>
 	for (;;) {
 		__set_current_state(TASK_INTERRUPTIBLE);
 		as = async_getcompleted(ps);
<span class="p_del">-		if (as)</span>
<span class="p_add">+		if (as || !connected(ps))</span>
 			break;
 		if (signal_pending(current))
 			break;
<span class="p_chunk">@@ -1713,7 +1713,7 @@</span> <span class="p_context"> static int proc_reapurb(struct usb_dev_state *ps, void __user *arg)</span>
 	}
 	if (signal_pending(current))
 		return -EINTR;
<span class="p_del">-	return -EIO;</span>
<span class="p_add">+	return -ENODEV;</span>
 }
 
 static int proc_reapurbnonblock(struct usb_dev_state *ps, void __user *arg)
<span class="p_chunk">@@ -1722,10 +1722,11 @@</span> <span class="p_context"> static int proc_reapurbnonblock(struct usb_dev_state *ps, void __user *arg)</span>
 	struct async *as;
 
 	as = async_getcompleted(ps);
<span class="p_del">-	retval = -EAGAIN;</span>
 	if (as) {
 		retval = processcompl(as, (void __user * __user *)arg);
 		free_async(as);
<span class="p_add">+	} else {</span>
<span class="p_add">+		retval = (connected(ps) ? -EAGAIN : -ENODEV);</span>
 	}
 	return retval;
 }
<span class="p_chunk">@@ -1855,7 +1856,7 @@</span> <span class="p_context"> static int proc_reapurb_compat(struct usb_dev_state *ps, void __user *arg)</span>
 	}
 	if (signal_pending(current))
 		return -EINTR;
<span class="p_del">-	return -EIO;</span>
<span class="p_add">+	return -ENODEV;</span>
 }
 
 static int proc_reapurbnonblock_compat(struct usb_dev_state *ps, void __user *arg)
<span class="p_chunk">@@ -1863,11 +1864,12 @@</span> <span class="p_context"> static int proc_reapurbnonblock_compat(struct usb_dev_state *ps, void __user *ar</span>
 	int retval;
 	struct async *as;
 
<span class="p_del">-	retval = -EAGAIN;</span>
 	as = async_getcompleted(ps);
 	if (as) {
 		retval = processcompl_compat(as, (void __user * __user *)arg);
 		free_async(as);
<span class="p_add">+	} else {</span>
<span class="p_add">+		retval = (connected(ps) ? -EAGAIN : -ENODEV);</span>
 	}
 	return retval;
 }
<span class="p_chunk">@@ -2039,7 +2041,8 @@</span> <span class="p_context"> static int proc_get_capabilities(struct usb_dev_state *ps, void __user *arg)</span>
 {
 	__u32 caps;
 
<span class="p_del">-	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM;</span>
<span class="p_add">+	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM |</span>
<span class="p_add">+			USBDEVFS_CAP_REAP_AFTER_DISCONNECT;</span>
 	if (!ps-&gt;dev-&gt;bus-&gt;no_stop_on_short)
 		caps |= USBDEVFS_CAP_BULK_CONTINUATION;
 	if (ps-&gt;dev-&gt;bus-&gt;sg_tablesize)
<span class="p_chunk">@@ -2139,6 +2142,32 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 		return -EPERM;
 
 	usb_lock_device(dev);
<span class="p_add">+</span>
<span class="p_add">+	/* Reap operations are allowed even after disconnection */</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case USBDEVFS_REAPURB:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurb(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	case USBDEVFS_REAPURBNDELAY:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurbnonblock(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+	case USBDEVFS_REAPURB32:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB32\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurb_compat(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	case USBDEVFS_REAPURBNDELAY32:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY32\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurbnonblock_compat(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!connected(ps)) {
 		usb_unlock_device(dev);
 		return -ENODEV;
<span class="p_chunk">@@ -2232,16 +2261,6 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 			inode-&gt;i_mtime = CURRENT_TIME;
 		break;
 
<span class="p_del">-	case USBDEVFS_REAPURB32:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB32\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurb_compat(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case USBDEVFS_REAPURBNDELAY32:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY32\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurbnonblock_compat(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
 	case USBDEVFS_IOCTL32:
 		snoop(&amp;dev-&gt;dev, &quot;%s: IOCTL32\n&quot;, __func__);
 		ret = proc_ioctl_compat(ps, ptr_to_compat(p));
<span class="p_chunk">@@ -2253,16 +2272,6 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 		ret = proc_unlinkurb(ps, p);
 		break;
 
<span class="p_del">-	case USBDEVFS_REAPURB:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurb(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case USBDEVFS_REAPURBNDELAY:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurbnonblock(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
 	case USBDEVFS_DISCSIGNAL:
 		snoop(&amp;dev-&gt;dev, &quot;%s: DISCSIGNAL\n&quot;, __func__);
 		ret = proc_disconnectsignal(ps, p);
<span class="p_chunk">@@ -2305,6 +2314,8 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 		ret = proc_free_streams(ps, p);
 		break;
 	}
<span class="p_add">+</span>
<span class="p_add">+ done:</span>
 	usb_unlock_device(dev);
 	if (ret &gt;= 0)
 		inode-&gt;i_atime = CURRENT_TIME;
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 4195906f94d6..c4dc63ad580a 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -1025,9 +1025,12 @@</span> <span class="p_context"> static int register_root_hub(struct usb_hcd *hcd)</span>
 				dev_name(&amp;usb_dev-&gt;dev), retval);
 		return (retval &lt; 0) ? retval : -EMSGSIZE;
 	}
<span class="p_del">-	if (usb_dev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+</span>
<span class="p_add">+	if (le16_to_cpu(usb_dev-&gt;descriptor.bcdUSB) &gt;= 0x0201) {</span>
 		retval = usb_get_bos_descriptor(usb_dev);
<span class="p_del">-		if (retval &lt; 0) {</span>
<span class="p_add">+		if (!retval) {</span>
<span class="p_add">+			usb_dev-&gt;lpm_capable = usb_device_supports_lpm(usb_dev);</span>
<span class="p_add">+		} else if (usb_dev-&gt;speed == USB_SPEED_SUPER) {</span>
 			mutex_unlock(&amp;usb_bus_list_lock);
 			dev_dbg(parent_dev, &quot;can&#39;t read %s bos descriptor %d\n&quot;,
 					dev_name(&amp;usb_dev-&gt;dev), retval);
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index a3ab650a1f72..962fdf5c621b 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)</span>
 	return usb_get_intfdata(hdev-&gt;actconfig-&gt;interface[0]);
 }
 
<span class="p_del">-static int usb_device_supports_lpm(struct usb_device *udev)</span>
<span class="p_add">+int usb_device_supports_lpm(struct usb_device *udev)</span>
 {
 	/* USB 2.1 (and greater) devices indicate LPM support through
 	 * their USB 2.0 Extended Capabilities BOS descriptor.
<span class="p_header">diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h</span>
<span class="p_header">index d9d08720c386..d7ac1603826b 100644</span>
<span class="p_header">--- a/drivers/usb/core/usb.h</span>
<span class="p_header">+++ b/drivers/usb/core/usb.h</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"> extern int  usb_hub_init(void);</span>
 extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);
 extern void usb_major_cleanup(void);
<span class="p_add">+extern int usb_device_supports_lpm(struct usb_device *udev);</span>
 
 #ifdef	CONFIG_PM
 
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index 0985ff715c0c..bcefce032757 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -707,6 +707,10 @@</span> <span class="p_context"> static int dwc3_ep0_std_request(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)</span>
 		dev_vdbg(dwc-&gt;dev, &quot;USB_REQ_SET_ISOCH_DELAY\n&quot;);
 		ret = dwc3_ep0_set_isoch_delay(dwc, ctrl);
 		break;
<span class="p_add">+	case USB_REQ_SET_INTERFACE:</span>
<span class="p_add">+		dev_vdbg(dwc-&gt;dev, &quot;USB_REQ_SET_INTERFACE&quot;);</span>
<span class="p_add">+		dwc-&gt;start_config_issued = false;</span>
<span class="p_add">+		/* Fall through */</span>
 	default:
 		dev_vdbg(dwc-&gt;dev, &quot;Forwarding to gadget driver\n&quot;);
 		ret = dwc3_ep0_delegate_req(dwc, ctrl);
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 18d2ffcc462b..8946e34cef63 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -414,6 +414,8 @@</span> <span class="p_context"> int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,</span>
 		if (!(reg &amp; DWC3_DEPCMD_CMDACT)) {
 			dev_vdbg(dwc-&gt;dev, &quot;Command Complete --&gt; %d\n&quot;,
 					DWC3_DEPCMD_STATUS(reg));
<span class="p_add">+			if (DWC3_DEPCMD_STATUS(reg))</span>
<span class="p_add">+				return -EINVAL;</span>
 			return 0;
 		}
 
<span class="p_header">diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c</span>
<span class="p_header">index b96393908860..53f4d4a868b5 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/f_mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/f_mass_storage.c</span>
<span class="p_chunk">@@ -2819,7 +2819,7 @@</span> <span class="p_context"> int fsg_common_set_nluns(struct fsg_common *common, int nluns)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	curlun = kcalloc(nluns, sizeof(*curlun), GFP_KERNEL);</span>
<span class="p_add">+	curlun = kcalloc(FSG_MAX_LUNS, sizeof(*curlun), GFP_KERNEL);</span>
 	if (unlikely(!curlun))
 		return -ENOMEM;
 
<span class="p_chunk">@@ -2829,8 +2829,6 @@</span> <span class="p_context"> int fsg_common_set_nluns(struct fsg_common *common, int nluns)</span>
 	common-&gt;luns = curlun;
 	common-&gt;nluns = nluns;
 
<span class="p_del">-	pr_info(&quot;Number of LUNs=%d\n&quot;, common-&gt;nluns);</span>
<span class="p_del">-</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(fsg_common_set_nluns);
<span class="p_chunk">@@ -3604,14 +3602,26 @@</span> <span class="p_context"> static struct usb_function *fsg_alloc(struct usb_function_instance *fi)</span>
 	struct fsg_opts *opts = fsg_opts_from_func_inst(fi);
 	struct fsg_common *common = opts-&gt;common;
 	struct fsg_dev *fsg;
<span class="p_add">+	unsigned nluns, i;</span>
 
 	fsg = kzalloc(sizeof(*fsg), GFP_KERNEL);
 	if (unlikely(!fsg))
 		return ERR_PTR(-ENOMEM);
 
 	mutex_lock(&amp;opts-&gt;lock);
<span class="p_add">+	if (!opts-&gt;refcnt) {</span>
<span class="p_add">+		for (nluns = i = 0; i &lt; FSG_MAX_LUNS; ++i)</span>
<span class="p_add">+			if (common-&gt;luns[i])</span>
<span class="p_add">+				nluns = i + 1;</span>
<span class="p_add">+		if (!nluns)</span>
<span class="p_add">+			pr_warn(&quot;No LUNS defined, continuing anyway\n&quot;);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			common-&gt;nluns = nluns;</span>
<span class="p_add">+		pr_info(&quot;Number of LUNs=%u\n&quot;, common-&gt;nluns);</span>
<span class="p_add">+	}</span>
 	opts-&gt;refcnt++;
 	mutex_unlock(&amp;opts-&gt;lock);
<span class="p_add">+</span>
 	fsg-&gt;function.name	= FSG_DRIVER_DESC;
 	fsg-&gt;function.bind	= fsg_bind;
 	fsg-&gt;function.unbind	= fsg_unbind;
<span class="p_header">diff --git a/drivers/usb/gadget/mv_udc_core.c b/drivers/usb/gadget/mv_udc_core.c</span>
<span class="p_header">index fcff3a571b45..571645a749fc 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/mv_udc_core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/mv_udc_core.c</span>
<span class="p_chunk">@@ -2160,7 +2160,7 @@</span> <span class="p_context"> static int mv_udc_probe(struct platform_device *pdev)</span>
 		return -ENODEV;
 	}
 
<span class="p_del">-	udc-&gt;phy_regs = ioremap(r-&gt;start, resource_size(r));</span>
<span class="p_add">+	udc-&gt;phy_regs = devm_ioremap(&amp;pdev-&gt;dev, r-&gt;start, resource_size(r));</span>
 	if (udc-&gt;phy_regs == NULL) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to map phy I/O memory\n&quot;);
 		return -EBUSY;
<span class="p_header">diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c</span>
<span class="p_header">index a8bde5b8cbdd..e9599f64547b 100644</span>
<span class="p_header">--- a/drivers/usb/host/ohci-q.c</span>
<span class="p_header">+++ b/drivers/usb/host/ohci-q.c</span>
<span class="p_chunk">@@ -925,10 +925,6 @@</span> <span class="p_context"> rescan_all:</span>
 		int			completed, modified;
 		__hc32			*prev;
 
<span class="p_del">-		/* Is this ED already invisible to the hardware? */</span>
<span class="p_del">-		if (ed-&gt;state == ED_IDLE)</span>
<span class="p_del">-			goto ed_idle;</span>
<span class="p_del">-</span>
 		/* only take off EDs that the HC isn&#39;t using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
<span class="p_chunk">@@ -959,14 +955,12 @@</span> <span class="p_context"> skip_ed:</span>
 		}
 
 		/* ED&#39;s now officially unlinked, hc doesn&#39;t see */
<span class="p_del">-		ed-&gt;state = ED_IDLE;</span>
 		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
 			ohci-&gt;eds_scheduled--;
 		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
 		ed-&gt;hwNextED = 0;
 		wmb();
 		ed-&gt;hwINFO &amp;= ~cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE);
<span class="p_del">-ed_idle:</span>
 
 		/* reentrancy:  if we drop the schedule lock, someone might
 		 * have modified this list.  normally it&#39;s just prepending
<span class="p_chunk">@@ -1037,6 +1031,7 @@</span> <span class="p_context"> rescan_this:</span>
 		if (list_empty(&amp;ed-&gt;td_list)) {
 			*last = ed-&gt;ed_next;
 			ed-&gt;ed_next = NULL;
<span class="p_add">+			ed-&gt;state = ED_IDLE;</span>
 		} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 			*last = ed-&gt;ed_next;
 			ed-&gt;ed_next = NULL;
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 8c21c3bcd59b..514d5b8f15c1 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -477,10 +477,13 @@</span> <span class="p_context"> static void xhci_hub_report_usb3_link_state(struct xhci_hcd *xhci,</span>
 	u32 pls = status_reg &amp; PORT_PLS_MASK;
 
 	/* resume state is a xHCI internal state.
<span class="p_del">-	 * Do not report it to usb core.</span>
<span class="p_add">+	 * Do not report it to usb core, instead, pretend to be U3,</span>
<span class="p_add">+	 * thus usb core knows it&#39;s not ready for transfer</span>
 	 */
<span class="p_del">-	if (pls == XDEV_RESUME)</span>
<span class="p_add">+	if (pls == XDEV_RESUME) {</span>
<span class="p_add">+		*status |= USB_SS_PORT_LS_U3;</span>
 		return;
<span class="p_add">+	}</span>
 
 	/* When the CAS bit is set then warm reset
 	 * should be performed on port
<span class="p_chunk">@@ -581,7 +584,14 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 		status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 	/* USB3.0 only */
 	if (hcd-&gt;speed == HCD_USB3) {
<span class="p_del">-		if ((raw_port_status &amp; PORT_PLC))</span>
<span class="p_add">+		/* Port link change with port in resume state should not be</span>
<span class="p_add">+		 * reported to usbcore, as this is an internal state to be</span>
<span class="p_add">+		 * handled by xhci driver. Reporting PLC to usbcore may</span>
<span class="p_add">+		 * cause usbcore clearing PLC first and port change event</span>
<span class="p_add">+		 * irq won&#39;t be generated.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((raw_port_status &amp; PORT_PLC) &amp;&amp;</span>
<span class="p_add">+			(raw_port_status &amp; PORT_PLS_MASK) != XDEV_RESUME)</span>
 			status |= USB_PORT_STAT_C_LINK_STATE &lt;&lt; 16;
 		if ((raw_port_status &amp; PORT_WRC))
 			status |= USB_PORT_STAT_C_BH_RESET &lt;&lt; 16;
<span class="p_chunk">@@ -1113,10 +1123,10 @@</span> <span class="p_context"> int xhci_bus_suspend(struct usb_hcd *hcd)</span>
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 
 	if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
<span class="p_del">-		if (bus_state-&gt;resuming_ports) {</span>
<span class="p_add">+		if (bus_state-&gt;resuming_ports ||	/* USB2 */</span>
<span class="p_add">+		    bus_state-&gt;port_remote_wakeup) {	/* USB3 */</span>
 			spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_del">-			xhci_dbg(xhci, &quot;suspend failed because &quot;</span>
<span class="p_del">-						&quot;a port is resuming\n&quot;);</span>
<span class="p_add">+			xhci_dbg(xhci, &quot;suspend failed because a port is resuming\n&quot;);</span>
 			return -EBUSY;
 		}
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 8936211b161d..5c68f227b8bf 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1431,10 +1431,10 @@</span> <span class="p_context"> int xhci_endpoint_init(struct xhci_hcd *xhci,</span>
 		/* Attempt to use the ring cache */
 		if (virt_dev-&gt;num_rings_cached == 0)
 			return -ENOMEM;
<span class="p_add">+		virt_dev-&gt;num_rings_cached--;</span>
 		virt_dev-&gt;eps[ep_index].new_ring =
 			virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached];
 		virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached] = NULL;
<span class="p_del">-		virt_dev-&gt;num_rings_cached--;</span>
 		xhci_reinit_cached_ring(xhci, virt_dev-&gt;eps[ep_index].new_ring,
 					1, type);
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 3303132d875e..3f40772962ec 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1583,6 +1583,9 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 		usb_hcd_resume_root_hub(hcd);
 	}
 
<span class="p_add">+	if (hcd-&gt;speed == HCD_USB3 &amp;&amp; (temp &amp; PORT_PLS_MASK) == XDEV_INACTIVE)</span>
<span class="p_add">+		bus_state-&gt;port_remote_wakeup &amp;= ~(1 &lt;&lt; faked_port_index);</span>
<span class="p_add">+</span>
 	if ((temp &amp; PORT_PLC) &amp;&amp; (temp &amp; PORT_PLS_MASK) == XDEV_RESUME) {
 		xhci_dbg(xhci, &quot;port resume event for port %d\n&quot;, port_id);
 
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index b61913116fe2..7ce24229e863 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -3466,6 +3466,9 @@</span> <span class="p_context"> int xhci_discover_or_reset_device(struct usb_hcd *hcd, struct usb_device *udev)</span>
 			return -EINVAL;
 	}
 
<span class="p_add">+	if (virt_dev-&gt;tt_info)</span>
<span class="p_add">+		old_active_eps = virt_dev-&gt;tt_info-&gt;active_eps;</span>
<span class="p_add">+</span>
 	if (virt_dev-&gt;udev != udev) {
 		/* If the virt_dev and the udev does not match, this virt_dev
 		 * may belong to another udev.
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index a70e45c7c440..92cd5a765602 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -285,6 +285,7 @@</span> <span class="p_context"> struct xhci_op_regs {</span>
 #define XDEV_U0		(0x0 &lt;&lt; 5)
 #define XDEV_U2		(0x2 &lt;&lt; 5)
 #define XDEV_U3		(0x3 &lt;&lt; 5)
<span class="p_add">+#define XDEV_INACTIVE	(0x6 &lt;&lt; 5)</span>
 #define XDEV_RESUME	(0xf &lt;&lt; 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 &lt;&lt; 9)
<span class="p_header">diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">index 0241a3a0d63e..1e9bde4fe785 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_chunk">@@ -273,9 +273,7 @@</span> <span class="p_context"> static int musb_has_gadget(struct musb *musb)</span>
 #ifdef CONFIG_USB_MUSB_HOST
 	return 1;
 #else
<span class="p_del">-	if (musb-&gt;port_mode == MUSB_PORT_MODE_HOST)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	return musb-&gt;g.dev.driver != NULL;</span>
<span class="p_add">+	return musb-&gt;port_mode == MUSB_PORT_MODE_HOST;</span>
 #endif
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 73c7292f48e5..d11335d4395d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -187,6 +187,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1FB9, 0x0602) }, /* Lake Shore Model 648 Magnet Power Supply */
 	{ USB_DEVICE(0x1FB9, 0x0700) }, /* Lake Shore Model 737 VSM Controller */
 	{ USB_DEVICE(0x1FB9, 0x0701) }, /* Lake Shore Model 776 Hall Matrix */
<span class="p_add">+	{ USB_DEVICE(0x2626, 0xEA60) }, /* Aruba Networks 7xxx USB Serial Console */</span>
 	{ USB_DEVICE(0x3195, 0xF190) }, /* Link Instruments MSO-19 */
 	{ USB_DEVICE(0x3195, 0xF280) }, /* Link Instruments MSO-28 */
 	{ USB_DEVICE(0x3195, 0xF281) }, /* Link Instruments MSO-28 */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 0cdbb6c56674..eebe0b72db51 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -1764,6 +1764,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */</span>
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
 	{ } /* Terminating entry */
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">index 19842370a07f..6fbfc8fc2f5d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial.c</span>
<span class="p_chunk">@@ -1290,6 +1290,7 @@</span> <span class="p_context"> static void __exit usb_serial_exit(void)</span>
 	tty_unregister_driver(usb_serial_tty_driver);
 	put_tty_driver(usb_serial_tty_driver);
 	bus_unregister(&amp;usb_serial_bus_type);
<span class="p_add">+	idr_destroy(&amp;serial_minors);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 1b79286e385a..092de140ef1e 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -2046,6 +2046,18 @@</span> <span class="p_context"> UNUSUAL_DEV( 0x1908, 0x3335, 0x0200, 0x0200,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_NO_READ_DISC_INFO ),
 
<span class="p_add">+/* Reported by Oliver Neukum &lt;oneukum@suse.com&gt;</span>
<span class="p_add">+ * This device morphes spontaneously into another device if the access</span>
<span class="p_add">+ * pattern of Windows isn&#39;t followed. Thus writable media would be dirty</span>
<span class="p_add">+ * if the initial instance is used. So the device is limited to its</span>
<span class="p_add">+ * virtual CD.</span>
<span class="p_add">+ * And yes, the concept that BCD goes up to 9 is not heeded */</span>
<span class="p_add">+UNUSUAL_DEV( 0x19d2, 0x1225, 0x0000, 0xffff,</span>
<span class="p_add">+		&quot;ZTE,Incorporated&quot;,</span>
<span class="p_add">+		&quot;ZTE WCDMA Technologies MSM&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_SINGLE_LUN ),</span>
<span class="p_add">+</span>
 /* Reported by Sven Geggus &lt;sven-usbst@geggus.net&gt;
  * This encrypted pen drive returns bogus data for the initial READ(10).
  */
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index 7fa4f7a7653d..509459d71ed0 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -540,8 +540,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">index 1fa85aae24df..d3fb85871921 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_chunk">@@ -149,8 +149,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c</span>
<span class="p_header">index 888fbe19079f..7537c05244c0 100644</span>
<span class="p_header">--- a/fs/btrfs/inode-map.c</span>
<span class="p_header">+++ b/fs/btrfs/inode-map.c</span>
<span class="p_chunk">@@ -246,6 +246,7 @@</span> <span class="p_context"> void btrfs_unpin_free_ino(struct btrfs_root *root)</span>
 {
 	struct btrfs_free_space_ctl *ctl = root-&gt;free_ino_ctl;
 	struct rb_root *rbroot = &amp;root-&gt;free_ino_pinned-&gt;free_space_offset;
<span class="p_add">+	spinlock_t *rbroot_lock = &amp;root-&gt;free_ino_pinned-&gt;tree_lock;</span>
 	struct btrfs_free_space *info;
 	struct rb_node *n;
 	u64 count;
<span class="p_chunk">@@ -254,24 +255,30 @@</span> <span class="p_context"> void btrfs_unpin_free_ino(struct btrfs_root *root)</span>
 		return;
 
 	while (1) {
<span class="p_add">+		bool add_to_ctl = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(rbroot_lock);</span>
 		n = rb_first(rbroot);
<span class="p_del">-		if (!n)</span>
<span class="p_add">+		if (!n) {</span>
<span class="p_add">+			spin_unlock(rbroot_lock);</span>
 			break;
<span class="p_add">+		}</span>
 
 		info = rb_entry(n, struct btrfs_free_space, offset_index);
 		BUG_ON(info-&gt;bitmap); /* Logic error */
 
 		if (info-&gt;offset &gt; root-&gt;cache_progress)
<span class="p_del">-			goto free;</span>
<span class="p_add">+			add_to_ctl = false;</span>
 		else if (info-&gt;offset + info-&gt;bytes &gt; root-&gt;cache_progress)
 			count = root-&gt;cache_progress - info-&gt;offset + 1;
 		else
 			count = info-&gt;bytes;
 
<span class="p_del">-		__btrfs_add_free_space(ctl, info-&gt;offset, count);</span>
<span class="p_del">-free:</span>
 		rb_erase(&amp;info-&gt;offset_index, rbroot);
<span class="p_del">-		kfree(info);</span>
<span class="p_add">+		spin_unlock(rbroot_lock);</span>
<span class="p_add">+		if (add_to_ctl)</span>
<span class="p_add">+			__btrfs_add_free_space(ctl, info-&gt;offset, count);</span>
<span class="p_add">+		kmem_cache_free(btrfs_free_space_cachep, info);</span>
 	}
 }
 
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 7c5f053ee42c..b9d2ce0d4093 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2977,7 +2977,7 @@</span> <span class="p_context"> out_unlock:</span>
 static long btrfs_ioctl_file_extent_same(struct file *file,
 			struct btrfs_ioctl_same_args __user *argp)
 {
<span class="p_del">-	struct btrfs_ioctl_same_args *same;</span>
<span class="p_add">+	struct btrfs_ioctl_same_args *same = NULL;</span>
 	struct btrfs_ioctl_same_extent_info *info;
 	struct inode *src = file_inode(file);
 	u64 off;
<span class="p_chunk">@@ -3007,6 +3007,7 @@</span> <span class="p_context"> static long btrfs_ioctl_file_extent_same(struct file *file,</span>
 
 	if (IS_ERR(same)) {
 		ret = PTR_ERR(same);
<span class="p_add">+		same = NULL;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -3077,6 +3078,7 @@</span> <span class="p_context"> static long btrfs_ioctl_file_extent_same(struct file *file,</span>
 
 out:
 	mnt_drop_write_file(file);
<span class="p_add">+	kfree(same);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -3469,6 +3471,20 @@</span> <span class="p_context"> process_slot:</span>
 				u64 trim = 0;
 				u64 aligned_end = 0;
 
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Don&#39;t copy an inline extent into an offset</span>
<span class="p_add">+				 * greater than zero. Having an inline extent</span>
<span class="p_add">+				 * at such an offset results in chaos as btrfs</span>
<span class="p_add">+				 * isn&#39;t prepared for such cases. Just skip</span>
<span class="p_add">+				 * this case for the same reasons as commented</span>
<span class="p_add">+				 * at btrfs_ioctl_clone().</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (last_dest_end &gt; 0) {</span>
<span class="p_add">+					ret = -EOPNOTSUPP;</span>
<span class="p_add">+					btrfs_end_transaction(trans, root);</span>
<span class="p_add">+					goto out;</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
 				if (off &gt; key.offset) {
 					skip = off - key.offset;
 					new_key.offset += skip;
<span class="p_header">diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c</span>
<span class="p_header">index 6c4a9cdef79b..3807fffb1c33 100644</span>
<span class="p_header">--- a/fs/btrfs/transaction.c</span>
<span class="p_header">+++ b/fs/btrfs/transaction.c</span>
<span class="p_chunk">@@ -723,7 +723,7 @@</span> <span class="p_context"> static int __btrfs_end_transaction(struct btrfs_trans_handle *trans,</span>
 
 	if (!list_empty(&amp;trans-&gt;ordered)) {
 		spin_lock(&amp;info-&gt;trans_lock);
<span class="p_del">-		list_splice(&amp;trans-&gt;ordered, &amp;cur_trans-&gt;pending_ordered);</span>
<span class="p_add">+		list_splice_init(&amp;trans-&gt;ordered, &amp;cur_trans-&gt;pending_ordered);</span>
 		spin_unlock(&amp;info-&gt;trans_lock);
 	}
 
<span class="p_chunk">@@ -1709,7 +1709,7 @@</span> <span class="p_context"> int btrfs_commit_transaction(struct btrfs_trans_handle *trans,</span>
 	}
 
 	spin_lock(&amp;root-&gt;fs_info-&gt;trans_lock);
<span class="p_del">-	list_splice(&amp;trans-&gt;ordered, &amp;cur_trans-&gt;pending_ordered);</span>
<span class="p_add">+	list_splice_init(&amp;trans-&gt;ordered, &amp;cur_trans-&gt;pending_ordered);</span>
 	if (cur_trans-&gt;state &gt;= TRANS_STATE_COMMIT_START) {
 		spin_unlock(&amp;root-&gt;fs_info-&gt;trans_lock);
 		atomic_inc(&amp;cur_trans-&gt;use_count);
<span class="p_header">diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c</span>
<span class="p_header">index 700e6d860e0c..6e3466157090 100644</span>
<span class="p_header">--- a/fs/btrfs/tree-log.c</span>
<span class="p_header">+++ b/fs/btrfs/tree-log.c</span>
<span class="p_chunk">@@ -3911,6 +3911,7 @@</span> <span class="p_context"> static int btrfs_log_inode(struct btrfs_trans_handle *trans,</span>
 	bool fast_search = false;
 	u64 ino = btrfs_ino(inode);
 	u64 logged_isize = 0;
<span class="p_add">+	bool need_log_inode_item = true;</span>
 
 	path = btrfs_alloc_path();
 	if (!path)
<span class="p_chunk">@@ -4000,11 +4001,6 @@</span> <span class="p_context"> static int btrfs_log_inode(struct btrfs_trans_handle *trans,</span>
 		} else {
 			if (inode_only == LOG_INODE_ALL)
 				fast_search = true;
<span class="p_del">-			ret = log_inode_item(trans, log, dst_path, inode);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				err = ret;</span>
<span class="p_del">-				goto out_unlock;</span>
<span class="p_del">-			}</span>
 			goto log_extents;
 		}
 
<span class="p_chunk">@@ -4028,6 +4024,9 @@</span> <span class="p_context"> again:</span>
 		if (min_key.type &gt; max_key.type)
 			break;
 
<span class="p_add">+		if (min_key.type == BTRFS_INODE_ITEM_KEY)</span>
<span class="p_add">+			need_log_inode_item = false;</span>
<span class="p_add">+</span>
 		src = path-&gt;nodes[0];
 		if (ins_nr &amp;&amp; ins_start_slot + ins_nr == path-&gt;slots[0]) {
 			ins_nr++;
<span class="p_chunk">@@ -4097,6 +4096,11 @@</span> <span class="p_context"> next_slot:</span>
 log_extents:
 	btrfs_release_path(path);
 	btrfs_release_path(dst_path);
<span class="p_add">+	if (need_log_inode_item) {</span>
<span class="p_add">+		err = log_inode_item(trans, log, dst_path, inode);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+	}</span>
 	if (fast_search) {
 		ret = btrfs_log_changed_extents(trans, root, inode, dst_path,
 						&amp;logged_list);
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index df0de6b95409..c0214315a1d0 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -600,6 +600,9 @@</span> <span class="p_context"> repeat:</span>
 	if (unlikely(d_unhashed(dentry)))
 		goto kill_it;
 
<span class="p_add">+	if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DISCONNECTED))</span>
<span class="p_add">+		goto kill_it;</span>
<span class="p_add">+</span>
 	if (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_DELETE)) {
 		if (dentry-&gt;d_op-&gt;d_delete(dentry))
 			goto kill_it;
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index fd3c9d5ac932..f7a77141a77c 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1353,7 +1353,7 @@</span> <span class="p_context"> static void ext4_da_page_release_reservation(struct page *page,</span>
 					     unsigned int offset,
 					     unsigned int length)
 {
<span class="p_del">-	int to_release = 0;</span>
<span class="p_add">+	int to_release = 0, contiguous_blks = 0;</span>
 	struct buffer_head *head, *bh;
 	unsigned int curr_off = 0;
 	struct inode *inode = page-&gt;mapping-&gt;host;
<span class="p_chunk">@@ -1374,14 +1374,23 @@</span> <span class="p_context"> static void ext4_da_page_release_reservation(struct page *page,</span>
 
 		if ((offset &lt;= curr_off) &amp;&amp; (buffer_delay(bh))) {
 			to_release++;
<span class="p_add">+			contiguous_blks++;</span>
 			clear_buffer_delay(bh);
<span class="p_add">+		} else if (contiguous_blks) {</span>
<span class="p_add">+			lblk = page-&gt;index &lt;&lt;</span>
<span class="p_add">+			       (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);</span>
<span class="p_add">+			lblk += (curr_off &gt;&gt; inode-&gt;i_blkbits) -</span>
<span class="p_add">+				contiguous_blks;</span>
<span class="p_add">+			ext4_es_remove_extent(inode, lblk, contiguous_blks);</span>
<span class="p_add">+			contiguous_blks = 0;</span>
 		}
 		curr_off = next_off;
 	} while ((bh = bh-&gt;b_this_page) != head);
 
<span class="p_del">-	if (to_release) {</span>
<span class="p_add">+	if (contiguous_blks) {</span>
 		lblk = page-&gt;index &lt;&lt; (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);
<span class="p_del">-		ext4_es_remove_extent(inode, lblk, to_release);</span>
<span class="p_add">+		lblk += (curr_off &gt;&gt; inode-&gt;i_blkbits) - contiguous_blks;</span>
<span class="p_add">+		ext4_es_remove_extent(inode, lblk, contiguous_blks);</span>
 	}
 
 	/* If we have released all the blocks belonging to a cluster, then we
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index c3e7418a6811..47f7af78675a 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -4810,18 +4810,12 @@</span> <span class="p_context"> do_more:</span>
 		/*
 		 * blocks being freed are metadata. these blocks shouldn&#39;t
 		 * be used until this transaction is committed
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed</span>
<span class="p_add">+		 * to fail.</span>
 		 */
<span class="p_del">-	retry:</span>
<span class="p_del">-		new_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);</span>
<span class="p_del">-		if (!new_entry) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We use a retry loop because</span>
<span class="p_del">-			 * ext4_free_blocks() is not allowed to fail.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			cond_resched();</span>
<span class="p_del">-			congestion_wait(BLK_RW_ASYNC, HZ/50);</span>
<span class="p_del">-			goto retry;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		new_entry = kmem_cache_alloc(ext4_free_data_cachep,</span>
<span class="p_add">+				GFP_NOFS|__GFP_NOFAIL);</span>
 		new_entry-&gt;efd_start_cluster = bit;
 		new_entry-&gt;efd_group = block_group;
 		new_entry-&gt;efd_count = count_clusters;
<span class="p_header">diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c</span>
<span class="p_header">index ec092437d3e0..08ef191801cf 100644</span>
<span class="p_header">--- a/fs/ext4/migrate.c</span>
<span class="p_header">+++ b/fs/ext4/migrate.c</span>
<span class="p_chunk">@@ -616,6 +616,7 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 	struct ext4_inode_info		*ei = EXT4_I(inode);
 	struct ext4_extent		*ex;
 	unsigned int			i, len;
<span class="p_add">+	ext4_lblk_t			start, end;</span>
 	ext4_fsblk_t			blk;
 	handle_t			*handle;
 	int				ret;
<span class="p_chunk">@@ -629,6 +630,14 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC))
 		return -EOPNOTSUPP;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In order to get correct extent info, force all delayed allocation</span>
<span class="p_add">+	 * blocks to be allocated, otherwise delayed allocation blocks may not</span>
<span class="p_add">+	 * be reflected and bypass the checks on extent header.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (test_opt(inode-&gt;i_sb, DELALLOC))</span>
<span class="p_add">+		ext4_alloc_da_blocks(inode);</span>
<span class="p_add">+</span>
 	handle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
<span class="p_chunk">@@ -646,11 +655,13 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 		goto errout;
 	}
 	if (eh-&gt;eh_entries == 0)
<span class="p_del">-		blk = len = 0;</span>
<span class="p_add">+		blk = len = start = end = 0;</span>
 	else {
 		len = le16_to_cpu(ex-&gt;ee_len);
 		blk = ext4_ext_pblock(ex);
<span class="p_del">-		if (len &gt; EXT4_NDIR_BLOCKS) {</span>
<span class="p_add">+		start = le32_to_cpu(ex-&gt;ee_block);</span>
<span class="p_add">+		end = start + len - 1;</span>
<span class="p_add">+		if (end &gt;= EXT4_NDIR_BLOCKS) {</span>
 			ret = -EOPNOTSUPP;
 			goto errout;
 		}
<span class="p_chunk">@@ -658,7 +669,7 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 
 	ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);
 	memset(ei-&gt;i_data, 0, sizeof(ei-&gt;i_data));
<span class="p_del">-	for (i=0; i &lt; len; i++)</span>
<span class="p_add">+	for (i = start; i &lt;= end; i++)</span>
 		ei-&gt;i_data[i] = cpu_to_le32(blk++);
 	ext4_mark_inode_dirty(handle, inode);
 errout:
<span class="p_header">diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c</span>
<span class="p_header">index 7cd00d3a7c9b..8685c655737f 100644</span>
<span class="p_header">--- a/fs/hpfs/super.c</span>
<span class="p_header">+++ b/fs/hpfs/super.c</span>
<span class="p_chunk">@@ -52,17 +52,20 @@</span> <span class="p_context"> static void unmark_dirty(struct super_block *s)</span>
 }
 
 /* Filesystem error... */
<span class="p_del">-static char err_buf[1024];</span>
<span class="p_del">-</span>
 void hpfs_error(struct super_block *s, const char *fmt, ...)
 {
<span class="p_add">+	struct va_format vaf;</span>
 	va_list args;
 
 	va_start(args, fmt);
<span class="p_del">-	vsnprintf(err_buf, sizeof(err_buf), fmt, args);</span>
<span class="p_add">+</span>
<span class="p_add">+	vaf.fmt = fmt;</span>
<span class="p_add">+	vaf.va = &amp;args;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_err(&quot;filesystem error: %pV&quot;, &amp;vaf);</span>
<span class="p_add">+</span>
 	va_end(args);
 
<span class="p_del">-	pr_err(&quot;filesystem error: %s&quot;, err_buf);</span>
 	if (!hpfs_sb(s)-&gt;sb_was_error) {
 		if (hpfs_sb(s)-&gt;sb_err == 2) {
 			pr_cont(&quot;; crashing the system because you wanted it\n&quot;);
<span class="p_chunk">@@ -424,11 +427,14 @@</span> <span class="p_context"> static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)</span>
 	int o;
 	struct hpfs_sb_info *sbi = hpfs_sb(s);
 	char *new_opts = kstrdup(data, GFP_KERNEL);
<span class="p_del">-	</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!new_opts)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	sync_filesystem(s);
 
 	*flags |= MS_NOATIME;
<span class="p_del">-	</span>
<span class="p_add">+</span>
 	hpfs_lock(s);
 	uid = sbi-&gt;sb_uid; gid = sbi-&gt;sb_gid;
 	umask = 0777 &amp; ~sbi-&gt;sb_mode;
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 91aac2525c09..714274450c07 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -429,6 +429,8 @@</span> <span class="p_context"> enum {</span>
 	ATA_HORKAGE_NO_NCQ_TRIM	= (1 &lt;&lt; 19),	/* don&#39;t use queued TRIM */
 	ATA_HORKAGE_NOLPM	= (1 &lt;&lt; 20),	/* don&#39;t use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 &lt;&lt; 21),	/* some WDs have broken LPM */
<span class="p_add">+	ATA_HORKAGE_NOTRIM	= (1 &lt;&lt; 24),	/* don&#39;t use TRIM */</span>
<span class="p_add">+</span>
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */
<span class="p_header">diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h</span>
<span class="p_header">index 2f0af2891f0f..c498acebd8bb 100644</span>
<span class="p_header">--- a/include/linux/mtd/nand.h</span>
<span class="p_header">+++ b/include/linux/mtd/nand.h</span>
<span class="p_chunk">@@ -176,17 +176,17 @@</span> <span class="p_context"> typedef enum {</span>
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00040000
 /*
<span class="p_del">- * This option could be defined by controller drivers to protect against</span>
<span class="p_del">- * kmap&#39;ed, vmalloc&#39;ed highmem buffers being passed from upper layers</span>
<span class="p_del">- */</span>
<span class="p_del">-#define NAND_USE_BOUNCE_BUFFER	0x00080000</span>
<span class="p_del">-/*</span>
  * Autodetect nand buswidth with readid/onfi.
  * This suppose the driver will configure the hardware in 8 bits mode
  * when calling nand_scan_ident, and update its configuration
  * before calling nand_scan_tail.
  */
 #define NAND_BUSWIDTH_AUTO      0x00080000
<span class="p_add">+/*</span>
<span class="p_add">+ * This option could be defined by controller drivers to protect against</span>
<span class="p_add">+ * kmap&#39;ed, vmalloc&#39;ed highmem buffers being passed from upper layers</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define NAND_USE_BOUNCE_BUFFER	0x00100000</span>
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
<span class="p_header">diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h</span>
<span class="p_header">index ff57f07c3249..86a07d6ece9c 100644</span>
<span class="p_header">--- a/include/uapi/drm/i915_drm.h</span>
<span class="p_header">+++ b/include/uapi/drm/i915_drm.h</span>
<span class="p_chunk">@@ -1035,6 +1035,14 @@</span> <span class="p_context"> struct drm_i915_reg_read {</span>
 	__u64 offset;
 	__u64 val; /* Return value */
 };
<span class="p_add">+/* Known registers:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Render engine timestamp - 0x2358 + 64bit - gen7+</span>
<span class="p_add">+ * - Note this register returns an invalid value if using the default</span>
<span class="p_add">+ *   single instruction 8byte read, in order to workaround that use</span>
<span class="p_add">+ *   offset (0x2538 | 1) instead.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
 
 struct drm_i915_reset_stats {
 	__u32 ctx_id;
<span class="p_header">diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h</span>
<span class="p_header">index abe5f4bd4d82..019ba1e0799a 100644</span>
<span class="p_header">--- a/include/uapi/linux/usbdevice_fs.h</span>
<span class="p_header">+++ b/include/uapi/linux/usbdevice_fs.h</span>
<span class="p_chunk">@@ -128,11 +128,12 @@</span> <span class="p_context"> struct usbdevfs_hub_portinfo {</span>
 	char port [127];	/* e.g. port 3 connects to device 27 */
 };
 
<span class="p_del">-/* Device capability flags */</span>
<span class="p_add">+/* System and bus capability flags */</span>
 #define USBDEVFS_CAP_ZERO_PACKET		0x01
 #define USBDEVFS_CAP_BULK_CONTINUATION		0x02
 #define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
 #define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
<span class="p_add">+#define USBDEVFS_CAP_REAP_AFTER_DISCONNECT	0x10</span>
 
 /* USBDEVFS_DISCONNECT_CLAIM flags &amp; struct */
 
<span class="p_header">diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c</span>
<span class="p_header">index 9065107f083e..7a5237a1bce5 100644</span>
<span class="p_header">--- a/kernel/irq/resend.c</span>
<span class="p_header">+++ b/kernel/irq/resend.c</span>
<span class="p_chunk">@@ -75,13 +75,21 @@</span> <span class="p_context"> void check_irq_resend(struct irq_desc *desc, unsigned int irq)</span>
 		    !desc-&gt;irq_data.chip-&gt;irq_retrigger(&amp;desc-&gt;irq_data)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 			/*
<span class="p_del">-			 * If the interrupt has a parent irq and runs</span>
<span class="p_del">-			 * in the thread context of the parent irq,</span>
<span class="p_del">-			 * retrigger the parent.</span>
<span class="p_add">+			 * If the interrupt is running in the thread</span>
<span class="p_add">+			 * context of the parent irq we need to be</span>
<span class="p_add">+			 * careful, because we cannot trigger it</span>
<span class="p_add">+			 * directly.</span>
 			 */
<span class="p_del">-			if (desc-&gt;parent_irq &amp;&amp;</span>
<span class="p_del">-			    irq_settings_is_nested_thread(desc))</span>
<span class="p_add">+			if (irq_settings_is_nested_thread(desc)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * If the parent_irq is valid, we</span>
<span class="p_add">+				 * retrigger the parent, otherwise we</span>
<span class="p_add">+				 * do nothing.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (!desc-&gt;parent_irq)</span>
<span class="p_add">+					return;</span>
 				irq = desc-&gt;parent_irq;
<span class="p_add">+			}</span>
 			/* Set it pending and activate the softirq: */
 			set_bit(irq, irqs_resend);
 			tasklet_schedule(&amp;resend_tasklet);
<span class="p_header">diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h</span>
<span class="p_header">index 9258f5a815db..2c204b705e14 100644</span>
<span class="p_header">--- a/kernel/trace/trace.h</span>
<span class="p_header">+++ b/kernel/trace/trace.h</span>
<span class="p_chunk">@@ -440,6 +440,7 @@</span> <span class="p_context"> enum {</span>
 
 	TRACE_CONTROL_BIT,
 
<span class="p_add">+	TRACE_BRANCH_BIT,</span>
 /*
  * Abuse of the trace_recursion.
  * As we need a way to maintain state if we are tracing the function
<span class="p_header">diff --git a/kernel/trace/trace_branch.c b/kernel/trace/trace_branch.c</span>
<span class="p_header">index 697fb9bac8f0..60850b4fcb04 100644</span>
<span class="p_header">--- a/kernel/trace/trace_branch.c</span>
<span class="p_header">+++ b/kernel/trace/trace_branch.c</span>
<span class="p_chunk">@@ -37,9 +37,12 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 	struct trace_branch *entry;
 	struct ring_buffer *buffer;
 	unsigned long flags;
<span class="p_del">-	int cpu, pc;</span>
<span class="p_add">+	int pc;</span>
 	const char *p;
 
<span class="p_add">+	if (current-&gt;trace_recursion &amp; TRACE_BRANCH_BIT)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/*
 	 * I would love to save just the ftrace_likely_data pointer, but
 	 * this code can also be used by modules. Ugly things can happen
<span class="p_chunk">@@ -50,10 +53,10 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 	if (unlikely(!tr))
 		return;
 
<span class="p_del">-	local_irq_save(flags);</span>
<span class="p_del">-	cpu = raw_smp_processor_id();</span>
<span class="p_del">-	data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);</span>
<span class="p_del">-	if (atomic_inc_return(&amp;data-&gt;disabled) != 1)</span>
<span class="p_add">+	raw_local_irq_save(flags);</span>
<span class="p_add">+	current-&gt;trace_recursion |= TRACE_BRANCH_BIT;</span>
<span class="p_add">+	data = this_cpu_ptr(tr-&gt;trace_buffer.data);</span>
<span class="p_add">+	if (atomic_read(&amp;data-&gt;disabled))</span>
 		goto out;
 
 	pc = preempt_count();
<span class="p_chunk">@@ -82,8 +85,8 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 		__buffer_unlock_commit(buffer, event);
 
  out:
<span class="p_del">-	atomic_dec(&amp;data-&gt;disabled);</span>
<span class="p_del">-	local_irq_restore(flags);</span>
<span class="p_add">+	current-&gt;trace_recursion &amp;= ~TRACE_BRANCH_BIT;</span>
<span class="p_add">+	raw_local_irq_restore(flags);</span>
 }
 
 static inline
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index e7ae35a5ffeb..4e03447b1ef2 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -2637,6 +2637,10 @@</span> <span class="p_context"> static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 
 	pte_unmap(page_table);
 
<span class="p_add">+	/* File mapping without -&gt;vm_ops ? */</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_SHARED)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
<span class="p_add">+</span>
 	/* Check if we need to add a guard page to the stack */
 	if (check_stack_guard_page(vma, address) &lt; 0)
 		return VM_FAULT_SIGSEGV;
<span class="p_chunk">@@ -3031,6 +3035,9 @@</span> <span class="p_context"> static int do_linear_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 			- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;
 
 	pte_unmap(page_table);
<span class="p_add">+	/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span>
<span class="p_add">+	if (!vma-&gt;vm_ops-&gt;fault)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
 	if (!(flags &amp; FAULT_FLAG_WRITE))
 		return do_read_fault(mm, vma, address, pmd, pgoff, flags,
 				orig_pte);
<span class="p_chunk">@@ -3191,11 +3198,10 @@</span> <span class="p_context"> static int handle_pte_fault(struct mm_struct *mm,</span>
 	entry = *pte;
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
<span class="p_del">-			if (vma-&gt;vm_ops) {</span>
<span class="p_del">-				if (likely(vma-&gt;vm_ops-&gt;fault))</span>
<span class="p_del">-					return do_linear_fault(mm, vma, address,</span>
<span class="p_add">+			if (vma-&gt;vm_ops)</span>
<span class="p_add">+				return do_linear_fault(mm, vma, address,</span>
 						pte, pmd, flags, entry);
<span class="p_del">-			}</span>
<span class="p_add">+</span>
 			return do_anonymous_page(mm, vma, address,
 						 pte, pmd, flags);
 		}
<span class="p_header">diff --git a/net/bridge/br_mdb.c b/net/bridge/br_mdb.c</span>
<span class="p_header">index d8b1833a363e..f426da78054b 100644</span>
<span class="p_header">--- a/net/bridge/br_mdb.c</span>
<span class="p_header">+++ b/net/bridge/br_mdb.c</span>
<span class="p_chunk">@@ -322,6 +322,7 @@</span> <span class="p_context"> static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,</span>
 	struct net_bridge_port_group *p;
 	struct net_bridge_port_group __rcu **pp;
 	struct net_bridge_mdb_htable *mdb;
<span class="p_add">+	unsigned long now = jiffies;</span>
 	int err;
 
 	mdb = mlock_dereference(br-&gt;mdb, br);
<span class="p_chunk">@@ -346,8 +347,9 @@</span> <span class="p_context"> static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,</span>
 	if (unlikely(!p))
 		return -ENOMEM;
 	rcu_assign_pointer(*pp, p);
<span class="p_add">+	if (state == MDB_TEMPORARY)</span>
<span class="p_add">+		mod_timer(&amp;p-&gt;timer, now + br-&gt;multicast_membership_interval);</span>
 
<span class="p_del">-	br_mdb_notify(br-&gt;dev, port, group, RTM_NEWMDB);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -370,6 +372,7 @@</span> <span class="p_context"> static int __br_mdb_add(struct net *net, struct net_bridge *br,</span>
 	if (!p || p-&gt;br != br || p-&gt;state == BR_STATE_DISABLED)
 		return -EINVAL;
 
<span class="p_add">+	memset(&amp;ip, 0, sizeof(ip));</span>
 	ip.proto = entry-&gt;addr.proto;
 	if (ip.proto == htons(ETH_P_IP))
 		ip.u.ip4 = entry-&gt;addr.u.ip4;
<span class="p_chunk">@@ -416,6 +419,7 @@</span> <span class="p_context"> static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)</span>
 	if (!netif_running(br-&gt;dev) || br-&gt;multicast_disabled)
 		return -EINVAL;
 
<span class="p_add">+	memset(&amp;ip, 0, sizeof(ip));</span>
 	ip.proto = entry-&gt;addr.proto;
 	if (ip.proto == htons(ETH_P_IP)) {
 		if (timer_pending(&amp;br-&gt;ip4_other_query.timer))
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index afa766c453e0..395830206d73 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -3262,6 +3262,8 @@</span> <span class="p_context"> static int enqueue_to_backlog(struct sk_buff *skb, int cpu,</span>
 	local_irq_save(flags);
 
 	rps_lock(sd);
<span class="p_add">+	if (!netif_running(skb-&gt;dev))</span>
<span class="p_add">+		goto drop;</span>
 	qlen = skb_queue_len(&amp;sd-&gt;input_pkt_queue);
 	if (qlen &lt;= netdev_max_backlog &amp;&amp; !skb_flow_limit(skb, qlen)) {
 		if (skb_queue_len(&amp;sd-&gt;input_pkt_queue)) {
<span class="p_chunk">@@ -3283,6 +3285,7 @@</span> <span class="p_context"> enqueue:</span>
 		goto enqueue;
 	}
 
<span class="p_add">+drop:</span>
 	sd-&gt;dropped++;
 	rps_unlock(sd);
 
<span class="p_chunk">@@ -5788,6 +5791,7 @@</span> <span class="p_context"> static void rollback_registered_many(struct list_head *head)</span>
 		unlist_netdevice(dev);
 
 		dev-&gt;reg_state = NETREG_UNREGISTERING;
<span class="p_add">+		on_each_cpu(flush_backlog, dev, 1);</span>
 	}
 
 	synchronize_net();
<span class="p_chunk">@@ -6049,7 +6053,8 @@</span> <span class="p_context"> static int netif_alloc_netdev_queues(struct net_device *dev)</span>
 	struct netdev_queue *tx;
 	size_t sz = count * sizeof(*tx);
 
<span class="p_del">-	BUG_ON(count &lt; 1 || count &gt; 0xffff);</span>
<span class="p_add">+	if (count &lt; 1 || count &gt; 0xffff)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	tx = kzalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);
 	if (!tx) {
<span class="p_chunk">@@ -6407,8 +6412,6 @@</span> <span class="p_context"> void netdev_run_todo(void)</span>
 
 		dev-&gt;reg_state = NETREG_UNREGISTERED;
 
<span class="p_del">-		on_each_cpu(flush_backlog, dev, 1);</span>
<span class="p_del">-</span>
 		netdev_wait_allrefs(dev);
 
 		/* paranoia */
<span class="p_header">diff --git a/net/dsa/dsa.c b/net/dsa/dsa.c</span>
<span class="p_header">index 5db37cef50a9..a3c70870448f 100644</span>
<span class="p_header">--- a/net/dsa/dsa.c</span>
<span class="p_header">+++ b/net/dsa/dsa.c</span>
<span class="p_chunk">@@ -418,7 +418,7 @@</span> <span class="p_context"> static int dsa_of_probe(struct platform_device *pdev)</span>
 			continue;
 
 		cd-&gt;sw_addr = be32_to_cpup(sw_addr);
<span class="p_del">-		if (cd-&gt;sw_addr &gt; PHY_MAX_ADDR)</span>
<span class="p_add">+		if (cd-&gt;sw_addr &gt;= PHY_MAX_ADDR)</span>
 			continue;
 
 		for_each_available_child_of_node(child, port) {
<span class="p_chunk">@@ -427,6 +427,8 @@</span> <span class="p_context"> static int dsa_of_probe(struct platform_device *pdev)</span>
 				continue;
 
 			port_index = be32_to_cpup(port_reg);
<span class="p_add">+			if (port_index &gt;= DSA_MAX_PORTS)</span>
<span class="p_add">+				break;</span>
 
 			port_name = of_get_property(port, &quot;label&quot;, NULL);
 			if (!port_name)
<span class="p_chunk">@@ -449,8 +451,6 @@</span> <span class="p_context"> static int dsa_of_probe(struct platform_device *pdev)</span>
 					goto out_free_chip;
 			}
 
<span class="p_del">-			if (port_index == DSA_MAX_PORTS)</span>
<span class="p_del">-				break;</span>
 		}
 	}
 
<span class="p_header">diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c</span>
<span class="p_header">index 8ff962d15c99..f5dad3f607d9 100644</span>
<span class="p_header">--- a/net/ipv4/ip_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/ip_fragment.c</span>
<span class="p_chunk">@@ -358,7 +358,7 @@</span> <span class="p_context"> static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)</span>
 	ihl = ip_hdrlen(skb);
 
 	/* Determine the position of this fragment. */
<span class="p_del">-	end = offset + skb-&gt;len - ihl;</span>
<span class="p_add">+	end = offset + skb-&gt;len - skb_network_offset(skb) - ihl;</span>
 	err = -EINVAL;
 
 	/* Is this the final fragment? */
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)</span>
 		goto err;
 
 	err = -ENOMEM;
<span class="p_del">-	if (pskb_pull(skb, ihl) == NULL)</span>
<span class="p_add">+	if (!pskb_pull(skb, skb_network_offset(skb) + ihl))</span>
 		goto err;
 
 	err = pskb_trim_rcsum(skb, end - offset);
<span class="p_chunk">@@ -629,6 +629,9 @@</span> <span class="p_context"> static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,</span>
 	iph-&gt;frag_off = qp-&gt;q.max_size ? htons(IP_DF) : 0;
 	iph-&gt;tot_len = htons(len);
 	iph-&gt;tos |= ecn;
<span class="p_add">+</span>
<span class="p_add">+	ip_send_check(iph);</span>
<span class="p_add">+</span>
 	IP_INC_STATS_BH(net, IPSTATS_MIB_REASMOKS);
 	qp-&gt;q.fragments = NULL;
 	qp-&gt;q.fragments_tail = NULL;
<span class="p_header">diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c</span>
<span class="p_header">index 6c2719373bc5..51dd1605f944 100644</span>
<span class="p_header">--- a/net/ipv4/ip_tunnel.c</span>
<span class="p_header">+++ b/net/ipv4/ip_tunnel.c</span>
<span class="p_chunk">@@ -488,7 +488,8 @@</span> <span class="p_context"> drop:</span>
 EXPORT_SYMBOL_GPL(ip_tunnel_rcv);
 
 static int tnl_update_pmtu(struct net_device *dev, struct sk_buff *skb,
<span class="p_del">-			    struct rtable *rt, __be16 df)</span>
<span class="p_add">+			    struct rtable *rt, __be16 df,</span>
<span class="p_add">+			    const struct iphdr *inner_iph)</span>
 {
 	struct ip_tunnel *tunnel = netdev_priv(dev);
 	int pkt_size = skb-&gt;len - tunnel-&gt;hlen - dev-&gt;hard_header_len;
<span class="p_chunk">@@ -505,7 +506,8 @@</span> <span class="p_context"> static int tnl_update_pmtu(struct net_device *dev, struct sk_buff *skb,</span>
 
 	if (skb-&gt;protocol == htons(ETH_P_IP)) {
 		if (!skb_is_gso(skb) &amp;&amp;
<span class="p_del">-		    (df &amp; htons(IP_DF)) &amp;&amp; mtu &lt; pkt_size) {</span>
<span class="p_add">+		    (inner_iph-&gt;frag_off &amp; htons(IP_DF)) &amp;&amp;</span>
<span class="p_add">+		    mtu &lt; pkt_size) {</span>
 			memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
 			icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu));
 			return -E2BIG;
<span class="p_chunk">@@ -636,7 +638,7 @@</span> <span class="p_context"> void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,</span>
 		goto tx_error;
 	}
 
<span class="p_del">-	if (tnl_update_pmtu(dev, skb, rt, tnl_params-&gt;frag_off)) {</span>
<span class="p_add">+	if (tnl_update_pmtu(dev, skb, rt, tnl_params-&gt;frag_off, inner_iph)) {</span>
 		ip_rt_put(rt);
 		goto tx_error;
 	}
<span class="p_header">diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c</span>
<span class="p_header">index 51d54dc376f3..05c94d9c3776 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_input.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_input.c</span>
<span class="p_chunk">@@ -329,10 +329,10 @@</span> <span class="p_context"> int ip6_mc_input(struct sk_buff *skb)</span>
 				if (offset &lt; 0)
 					goto out;
 
<span class="p_del">-				if (!ipv6_is_mld(skb, nexthdr, offset))</span>
<span class="p_del">-					goto out;</span>
<span class="p_add">+				if (ipv6_is_mld(skb, nexthdr, offset))</span>
<span class="p_add">+					deliver = true;</span>
 
<span class="p_del">-				deliver = true;</span>
<span class="p_add">+				goto out;</span>
 			}
 			/* unknown RA - process it normally */
 		}
<span class="p_header">diff --git a/net/mac80211/debugfs_netdev.c b/net/mac80211/debugfs_netdev.c</span>
<span class="p_header">index e205ebabfa50..1ab5e1a51c98 100644</span>
<span class="p_header">--- a/net/mac80211/debugfs_netdev.c</span>
<span class="p_header">+++ b/net/mac80211/debugfs_netdev.c</span>
<span class="p_chunk">@@ -725,6 +725,7 @@</span> <span class="p_context"> void ieee80211_debugfs_remove_netdev(struct ieee80211_sub_if_data *sdata)</span>
 
 	debugfs_remove_recursive(sdata-&gt;vif.debugfs_dir);
 	sdata-&gt;vif.debugfs_dir = NULL;
<span class="p_add">+	sdata-&gt;debugfs.subdir_stations = NULL;</span>
 }
 
 void ieee80211_debugfs_rename_netdev(struct ieee80211_sub_if_data *sdata)
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">index 7f035f0772ee..54330fb5efaf 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> nfnl_cthelper_parse_tuple(struct nf_conntrack_tuple *tuple,</span>
 static int
 nfnl_cthelper_from_nlattr(struct nlattr *attr, struct nf_conn *ct)
 {
<span class="p_del">-	const struct nf_conn_help *help = nfct_help(ct);</span>
<span class="p_add">+	struct nf_conn_help *help = nfct_help(ct);</span>
 
 	if (attr == NULL)
 		return -EINVAL;
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> nfnl_cthelper_from_nlattr(struct nlattr *attr, struct nf_conn *ct)</span>
 	if (help-&gt;helper-&gt;data_len == 0)
 		return -EINVAL;
 
<span class="p_del">-	memcpy(&amp;help-&gt;data, nla_data(attr), help-&gt;helper-&gt;data_len);</span>
<span class="p_add">+	memcpy(help-&gt;data, nla_data(attr), help-&gt;helper-&gt;data_len);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/rds/ib_rdma.c b/net/rds/ib_rdma.c</span>
<span class="p_header">index e8fdb172adbb..a985158d95d5 100644</span>
<span class="p_header">--- a/net/rds/ib_rdma.c</span>
<span class="p_header">+++ b/net/rds/ib_rdma.c</span>
<span class="p_chunk">@@ -759,8 +759,10 @@</span> <span class="p_context"> void *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,</span>
 	}
 
 	ibmr = rds_ib_alloc_fmr(rds_ibdev);
<span class="p_del">-	if (IS_ERR(ibmr))</span>
<span class="p_add">+	if (IS_ERR(ibmr)) {</span>
<span class="p_add">+		rds_ib_dev_put(rds_ibdev);</span>
 		return ibmr;
<span class="p_add">+	}</span>
 
 	ret = rds_ib_map_fmr(rds_ibdev, ibmr, sg, nents);
 	if (ret == 0)
<span class="p_header">diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c</span>
<span class="p_header">index 970772c731ff..41f32259437c 100644</span>
<span class="p_header">--- a/security/integrity/evm/evm_main.c</span>
<span class="p_header">+++ b/security/integrity/evm/evm_main.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/xattr.h&gt;
 #include &lt;linux/integrity.h&gt;
 #include &lt;linux/evm.h&gt;
<span class="p_add">+#include &lt;linux/magic.h&gt;</span>
 #include &lt;crypto/hash.h&gt;
 #include &quot;evm.h&quot;
 
<span class="p_chunk">@@ -290,6 +291,17 @@</span> <span class="p_context"> static int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,</span>
 		iint = integrity_iint_find(dentry-&gt;d_inode);
 		if (iint &amp;&amp; (iint-&gt;flags &amp; IMA_NEW_FILE))
 			return 0;
<span class="p_add">+</span>
<span class="p_add">+		/* exception for pseudo filesystems */</span>
<span class="p_add">+		if (dentry-&gt;d_inode-&gt;i_sb-&gt;s_magic == TMPFS_MAGIC</span>
<span class="p_add">+		    || dentry-&gt;d_inode-&gt;i_sb-&gt;s_magic == SYSFS_MAGIC)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		integrity_audit_msg(AUDIT_INTEGRITY_METADATA,</span>
<span class="p_add">+				    dentry-&gt;d_inode, dentry-&gt;d_name.name,</span>
<span class="p_add">+				    &quot;update_metadata&quot;,</span>
<span class="p_add">+				    integrity_status_msg[evm_status],</span>
<span class="p_add">+				    -EPERM, 0);</span>
 	}
 out:
 	if (evm_status != INTEGRITY_PASS)
<span class="p_header">diff --git a/security/keys/keyring.c b/security/keys/keyring.c</span>
<span class="p_header">index 9cf2575f0d97..860345cb05f1 100644</span>
<span class="p_header">--- a/security/keys/keyring.c</span>
<span class="p_header">+++ b/security/keys/keyring.c</span>
<span class="p_chunk">@@ -1151,9 +1151,11 @@</span> <span class="p_context"> void __key_link_end(struct key *keyring,</span>
 	if (index_key-&gt;type == &amp;key_type_keyring)
 		up_write(&amp;keyring_serialise_link_sem);
 
<span class="p_del">-	if (edit &amp;&amp; !edit-&gt;dead_leaf) {</span>
<span class="p_del">-		key_payload_reserve(keyring,</span>
<span class="p_del">-				    keyring-&gt;datalen - KEYQUOTA_LINK_BYTES);</span>
<span class="p_add">+	if (edit) {</span>
<span class="p_add">+		if (!edit-&gt;dead_leaf) {</span>
<span class="p_add">+			key_payload_reserve(keyring,</span>
<span class="p_add">+				keyring-&gt;datalen - KEYQUOTA_LINK_BYTES);</span>
<span class="p_add">+		}</span>
 		assoc_array_cancel_edit(edit);
 	}
 	up_write(&amp;keyring-&gt;sem);
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index e80c0d60c14b..31a80b10c783 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -3343,6 +3343,7 @@</span> <span class="p_context"> static const struct hda_codec_preset snd_hda_preset_hdmi[] = {</span>
 { .id = 0x10de0070, .name = &quot;GPU 70 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de0071, .name = &quot;GPU 71 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de0072, .name = &quot;GPU 72 HDMI/DP&quot;,	.patch = patch_nvhdmi },
<span class="p_add">+{ .id = 0x10de007d, .name = &quot;GPU 7d HDMI/DP&quot;,	.patch = patch_nvhdmi },</span>
 { .id = 0x10de8001, .name = &quot;MCP73 HDMI&quot;,	.patch = patch_nvhdmi_2ch },
 { .id = 0x11069f80, .name = &quot;VX900 HDMI/DP&quot;,	.patch = patch_via_hdmi },
 { .id = 0x11069f81, .name = &quot;VX900 HDMI/DP&quot;,	.patch = patch_via_hdmi },
<span class="p_chunk">@@ -3403,6 +3404,7 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;snd-hda-codec-id:10de0067&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de0070&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de0071&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de0072&quot;);
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:10de007d&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de8001&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:11069f80&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:11069f81&quot;);
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index 5293b5ac8b9d..7c24088bcaa4 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -2516,6 +2516,74 @@</span> <span class="p_context"> YAMAHA_DEVICE(0x7010, &quot;UB99&quot;),</span>
 	}
 },
 
<span class="p_add">+/* Steinberg devices */</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Steinberg MI2 */</span>
<span class="p_add">+	USB_DEVICE_VENDOR_SPEC(0x0a4e, 0x2040),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp; (const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = &amp; (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 3,</span>
<span class="p_add">+				.type = QUIRK_MIDI_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp;(const struct snd_usb_midi_endpoint_info) {</span>
<span class="p_add">+					.out_cables = 0x0001,</span>
<span class="p_add">+					.in_cables  = 0x0001</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = -1</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Steinberg MI4 */</span>
<span class="p_add">+	USB_DEVICE_VENDOR_SPEC(0x0a4e, 0x4040),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp; (const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = &amp; (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 3,</span>
<span class="p_add">+				.type = QUIRK_MIDI_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp;(const struct snd_usb_midi_endpoint_info) {</span>
<span class="p_add">+					.out_cables = 0x0001,</span>
<span class="p_add">+					.in_cables  = 0x0001</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = -1</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 /* TerraTec devices */
 {
 	USB_DEVICE_VENDOR_SPEC(0x0ccd, 0x0012),
<span class="p_header">diff --git a/tools/perf/ui/browsers/hists.c b/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">index 04a229aa5c0f..868993d355e0 100644</span>
<span class="p_header">--- a/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">+++ b/tools/perf/ui/browsers/hists.c</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> static struct rb_node *hists__filter_entries(struct rb_node *nd,</span>
 
 static bool hist_browser__has_filter(struct hist_browser *hb)
 {
<span class="p_del">-	return hists__has_filter(hb-&gt;hists) || hb-&gt;min_pcnt;</span>
<span class="p_add">+	return hists__has_filter(hb-&gt;hists) || hb-&gt;min_pcnt || symbol_conf.has_filter;</span>
 }
 
 static u32 hist_browser__nr_entries(struct hist_browser *hb)
<span class="p_header">diff --git a/tools/perf/util/symbol.c b/tools/perf/util/symbol.c</span>
<span class="p_header">index 7b9096f29cdb..f8bdba0971cc 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol.c</span>
<span class="p_chunk">@@ -1786,6 +1786,8 @@</span> <span class="p_context"> int setup_list(struct strlist **list, const char *list_str,</span>
 		pr_err(&quot;problems parsing %s list\n&quot;, list_name);
 		return -1;
 	}
<span class="p_add">+</span>
<span class="p_add">+	symbol_conf.has_filter = true;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/tools/perf/util/symbol.h b/tools/perf/util/symbol.h</span>
<span class="p_header">index 615c752dd767..5df02af0280b 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol.h</span>
<span class="p_header">+++ b/tools/perf/util/symbol.h</span>
<span class="p_chunk">@@ -118,7 +118,8 @@</span> <span class="p_context"> struct symbol_conf {</span>
 			annotate_src,
 			event_group,
 			demangle,
<span class="p_del">-			filter_relative;</span>
<span class="p_add">+			filter_relative,</span>
<span class="p_add">+			has_filter;</span>
 	const char	*vmlinux_name,
 			*kallsyms_name,
 			*source_prefix,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



