
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.28 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.28</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 28, 2016, 8:22 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161028082240.GB5773@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9401501/mbox/"
   >mbox</a>
|
   <a href="/patch/9401501/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9401501/">/patch/9401501/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9229D6022E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 28 Oct 2016 08:24:00 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 715892A63D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 28 Oct 2016 08:24:00 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 642352A63E; Fri, 28 Oct 2016 08:24:00 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 243EC2A63F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 28 Oct 2016 08:23:53 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1759552AbcJ1IX3 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 28 Oct 2016 04:23:29 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:49096 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755938AbcJ1IWc (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 28 Oct 2016 04:22:32 -0400
Received: from localhost (timessq103.t.subnet.rcn.com [206.71.234.194])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 12F37480;
	Fri, 28 Oct 2016 08:22:30 +0000 (UTC)
Date: Fri, 28 Oct 2016 04:22:40 -0400
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.28
Message-ID: &lt;20161028082240.GB5773@kroah.com&gt;
References: &lt;20161028082233.GA5773@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161028082233.GA5773@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 28, 2016, 8:22 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index 0e4102ae1a61..c360f80c3473 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -1371,7 +1371,14 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 	i8042.nopnp	[HW] Don&#39;t use ACPIPnP / PnPBIOS to discover KBD/AUX
 			     controllers
 	i8042.notimeout	[HW] Ignore timeout condition signalled by controller
<span class="p_del">-	i8042.reset	[HW] Reset the controller during init and cleanup</span>
<span class="p_add">+	i8042.reset	[HW] Reset the controller during init, cleanup and</span>
<span class="p_add">+			     suspend-to-ram transitions, only during s2r</span>
<span class="p_add">+			     transitions, or never reset</span>
<span class="p_add">+			Format: { 1 | Y | y | 0 | N | n }</span>
<span class="p_add">+			1, Y, y: always reset controller</span>
<span class="p_add">+			0, N, n: don&#39;t ever reset controller</span>
<span class="p_add">+			Default: only on s2r transitions on x86; most other</span>
<span class="p_add">+			architectures force reset to be always executed</span>
 	i8042.unlock	[HW] Unlock (ignore) the keylock
 	i8042.kbdreset  [HW] Reset device connected to KBD port
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index b6ee4ce561f8..391294301aaf 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 27</span>
<span class="p_add">+SUBLEVEL = 28</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arc/kernel/signal.c b/arch/arc/kernel/signal.c</span>
<span class="p_header">index 004b7f0bc76c..257b8699efde 100644</span>
<span class="p_header">--- a/arch/arc/kernel/signal.c</span>
<span class="p_header">+++ b/arch/arc/kernel/signal.c</span>
<span class="p_chunk">@@ -107,13 +107,13 @@</span> <span class="p_context"> static int restore_usr_regs(struct pt_regs *regs, struct rt_sigframe __user *sf)</span>
 	struct user_regs_struct uregs;
 
 	err = __copy_from_user(&amp;set, &amp;sf-&gt;uc.uc_sigmask, sizeof(set));
<span class="p_del">-	if (!err)</span>
<span class="p_del">-		set_current_blocked(&amp;set);</span>
<span class="p_del">-</span>
 	err |= __copy_from_user(&amp;uregs.scratch,
 				&amp;(sf-&gt;uc.uc_mcontext.regs.scratch),
 				sizeof(sf-&gt;uc.uc_mcontext.regs.scratch));
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
<span class="p_add">+	set_current_blocked(&amp;set);</span>
 	regs-&gt;bta	= uregs.scratch.bta;
 	regs-&gt;lp_start	= uregs.scratch.lp_start;
 	regs-&gt;lp_end	= uregs.scratch.lp_end;
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"> static int restore_usr_regs(struct pt_regs *regs, struct rt_sigframe __user *sf)</span>
 	regs-&gt;r0	= uregs.scratch.r0;
 	regs-&gt;sp	= uregs.scratch.sp;
 
<span class="p_del">-	return err;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static inline int is_do_ss_needed(unsigned int magic)
<span class="p_header">diff --git a/arch/arm64/include/asm/percpu.h b/arch/arm64/include/asm/percpu.h</span>
<span class="p_header">index 0a456bef8c79..8a336852eeba 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/percpu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/percpu.h</span>
<span class="p_chunk">@@ -44,48 +44,44 @@</span> <span class="p_context"> static inline unsigned long __percpu_##op(void *ptr,			\</span>
 									\
 	switch (size) {							\
 	case 1:								\
<span class="p_del">-		do {							\</span>
<span class="p_del">-			asm (&quot;//__per_cpu_&quot; #op &quot;_1\n&quot;			\</span>
<span class="p_del">-			&quot;ldxrb	  %w[ret], %[ptr]\n&quot;			\</span>
<span class="p_add">+		asm (&quot;//__per_cpu_&quot; #op &quot;_1\n&quot;				\</span>
<span class="p_add">+		&quot;1:	ldxrb	  %w[ret], %[ptr]\n&quot;			\</span>
 			#asm_op &quot; %w[ret], %w[ret], %w[val]\n&quot;		\
<span class="p_del">-			&quot;stxrb	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),	\</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u8 *)ptr)			\</span>
<span class="p_del">-			: [val] &quot;Ir&quot; (val));				\</span>
<span class="p_del">-		} while (loop);						\</span>
<span class="p_add">+		&quot;	stxrb	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_add">+		&quot;	cbnz	  %w[loop], 1b&quot;				\</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),		\</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u8 *)ptr)				\</span>
<span class="p_add">+		: [val] &quot;Ir&quot; (val));					\</span>
 		break;							\
 	case 2:								\
<span class="p_del">-		do {							\</span>
<span class="p_del">-			asm (&quot;//__per_cpu_&quot; #op &quot;_2\n&quot;			\</span>
<span class="p_del">-			&quot;ldxrh	  %w[ret], %[ptr]\n&quot;			\</span>
<span class="p_add">+		asm (&quot;//__per_cpu_&quot; #op &quot;_2\n&quot;				\</span>
<span class="p_add">+		&quot;1:	ldxrh	  %w[ret], %[ptr]\n&quot;			\</span>
 			#asm_op &quot; %w[ret], %w[ret], %w[val]\n&quot;		\
<span class="p_del">-			&quot;stxrh	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),	\</span>
<span class="p_del">-			  [ptr]  &quot;+Q&quot;(*(u16 *)ptr)			\</span>
<span class="p_del">-			: [val] &quot;Ir&quot; (val));				\</span>
<span class="p_del">-		} while (loop);						\</span>
<span class="p_add">+		&quot;	stxrh	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_add">+		&quot;	cbnz	  %w[loop], 1b&quot;				\</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),		\</span>
<span class="p_add">+		  [ptr]  &quot;+Q&quot;(*(u16 *)ptr)				\</span>
<span class="p_add">+		: [val] &quot;Ir&quot; (val));					\</span>
 		break;							\
 	case 4:								\
<span class="p_del">-		do {							\</span>
<span class="p_del">-			asm (&quot;//__per_cpu_&quot; #op &quot;_4\n&quot;			\</span>
<span class="p_del">-			&quot;ldxr	  %w[ret], %[ptr]\n&quot;			\</span>
<span class="p_add">+		asm (&quot;//__per_cpu_&quot; #op &quot;_4\n&quot;				\</span>
<span class="p_add">+		&quot;1:	ldxr	  %w[ret], %[ptr]\n&quot;			\</span>
 			#asm_op &quot; %w[ret], %w[ret], %w[val]\n&quot;		\
<span class="p_del">-			&quot;stxr	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),	\</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u32 *)ptr)			\</span>
<span class="p_del">-			: [val] &quot;Ir&quot; (val));				\</span>
<span class="p_del">-		} while (loop);						\</span>
<span class="p_add">+		&quot;	stxr	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_add">+		&quot;	cbnz	  %w[loop], 1b&quot;				\</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),		\</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u32 *)ptr)				\</span>
<span class="p_add">+		: [val] &quot;Ir&quot; (val));					\</span>
 		break;							\
 	case 8:								\
<span class="p_del">-		do {							\</span>
<span class="p_del">-			asm (&quot;//__per_cpu_&quot; #op &quot;_8\n&quot;			\</span>
<span class="p_del">-			&quot;ldxr	  %[ret], %[ptr]\n&quot;			\</span>
<span class="p_add">+		asm (&quot;//__per_cpu_&quot; #op &quot;_8\n&quot;				\</span>
<span class="p_add">+		&quot;1:	ldxr	  %[ret], %[ptr]\n&quot;			\</span>
 			#asm_op &quot; %[ret], %[ret], %[val]\n&quot;		\
<span class="p_del">-			&quot;stxr	  %w[loop], %[ret], %[ptr]\n&quot;		\</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),	\</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u64 *)ptr)			\</span>
<span class="p_del">-			: [val] &quot;Ir&quot; (val));				\</span>
<span class="p_del">-		} while (loop);						\</span>
<span class="p_add">+		&quot;	stxr	  %w[loop], %[ret], %[ptr]\n&quot;		\</span>
<span class="p_add">+		&quot;	cbnz	  %w[loop], 1b&quot;				\</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),		\</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u64 *)ptr)				\</span>
<span class="p_add">+		: [val] &quot;Ir&quot; (val));					\</span>
 		break;							\
 	default:							\
 		BUILD_BUG();						\
<span class="p_chunk">@@ -150,44 +146,40 @@</span> <span class="p_context"> static inline unsigned long __percpu_xchg(void *ptr, unsigned long val,</span>
 
 	switch (size) {
 	case 1:
<span class="p_del">-		do {</span>
<span class="p_del">-			asm (&quot;//__percpu_xchg_1\n&quot;</span>
<span class="p_del">-			&quot;ldxrb %w[ret], %[ptr]\n&quot;</span>
<span class="p_del">-			&quot;stxrb %w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u8 *)ptr)</span>
<span class="p_del">-			: [val] &quot;r&quot; (val));</span>
<span class="p_del">-		} while (loop);</span>
<span class="p_add">+		asm (&quot;//__percpu_xchg_1\n&quot;</span>
<span class="p_add">+		&quot;1:	ldxrb	%w[ret], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	stxrb	%w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	cbnz	%w[loop], 1b&quot;</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u8 *)ptr)</span>
<span class="p_add">+		: [val] &quot;r&quot; (val));</span>
 		break;
 	case 2:
<span class="p_del">-		do {</span>
<span class="p_del">-			asm (&quot;//__percpu_xchg_2\n&quot;</span>
<span class="p_del">-			&quot;ldxrh %w[ret], %[ptr]\n&quot;</span>
<span class="p_del">-			&quot;stxrh %w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u16 *)ptr)</span>
<span class="p_del">-			: [val] &quot;r&quot; (val));</span>
<span class="p_del">-		} while (loop);</span>
<span class="p_add">+		asm (&quot;//__percpu_xchg_2\n&quot;</span>
<span class="p_add">+		&quot;1:	ldxrh	%w[ret], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	stxrh	%w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	cbnz	%w[loop], 1b&quot;</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u16 *)ptr)</span>
<span class="p_add">+		: [val] &quot;r&quot; (val));</span>
 		break;
 	case 4:
<span class="p_del">-		do {</span>
<span class="p_del">-			asm (&quot;//__percpu_xchg_4\n&quot;</span>
<span class="p_del">-			&quot;ldxr %w[ret], %[ptr]\n&quot;</span>
<span class="p_del">-			&quot;stxr %w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u32 *)ptr)</span>
<span class="p_del">-			: [val] &quot;r&quot; (val));</span>
<span class="p_del">-		} while (loop);</span>
<span class="p_add">+		asm (&quot;//__percpu_xchg_4\n&quot;</span>
<span class="p_add">+		&quot;1:	ldxr	%w[ret], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	stxr	%w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	cbnz	%w[loop], 1b&quot;</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u32 *)ptr)</span>
<span class="p_add">+		: [val] &quot;r&quot; (val));</span>
 		break;
 	case 8:
<span class="p_del">-		do {</span>
<span class="p_del">-			asm (&quot;//__percpu_xchg_8\n&quot;</span>
<span class="p_del">-			&quot;ldxr %[ret], %[ptr]\n&quot;</span>
<span class="p_del">-			&quot;stxr %w[loop], %[val], %[ptr]\n&quot;</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u64 *)ptr)</span>
<span class="p_del">-			: [val] &quot;r&quot; (val));</span>
<span class="p_del">-		} while (loop);</span>
<span class="p_add">+		asm (&quot;//__percpu_xchg_8\n&quot;</span>
<span class="p_add">+		&quot;1:	ldxr	%[ret], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	stxr	%w[loop], %[val], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	cbnz	%w[loop], 1b&quot;</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u64 *)ptr)</span>
<span class="p_add">+		: [val] &quot;r&quot; (val));</span>
 		break;
 	default:
 		BUILD_BUG();
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index b685257926f0..20ceb5edf7b8 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -518,8 +518,9 @@</span> <span class="p_context"> CPU_LE(	movk	x0, #0x30d0, lsl #16	)	// Clear EE and E0E on LE systems</span>
 	b.lt	4f				// Skip if no PMU present
 	mrs	x0, pmcr_el0			// Disable debug access traps
 	ubfx	x0, x0, #11, #5			// to EL2 and allow access to
<span class="p_del">-	msr	mdcr_el2, x0			// all PMU counters from EL1</span>
 4:
<span class="p_add">+	csel	x0, xzr, x0, lt			// all PMU counters from EL1</span>
<span class="p_add">+	msr	mdcr_el2, x0			// (if they exist)</span>
 
 	/* Stage-2 translation */
 	msr	vttbr_el2, xzr
<span class="p_header">diff --git a/arch/metag/include/asm/atomic.h b/arch/metag/include/asm/atomic.h</span>
<span class="p_header">index 470e365f04ea..8ff0a70865f6 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/atomic.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/atomic.h</span>
<span class="p_chunk">@@ -39,11 +39,10 @@</span> <span class="p_context"></span>
 #define atomic_dec(v) atomic_sub(1, (v))
 
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
<span class="p_add">+#define atomic_dec_if_positive(v)       atomic_sub_if_positive(1, v)</span>
 
 #endif
 
<span class="p_del">-#define atomic_dec_if_positive(v)       atomic_sub_if_positive(1, v)</span>
<span class="p_del">-</span>
 #include &lt;asm-generic/atomic64.h&gt;
 
 #endif /* __ASM_METAG_ATOMIC_H */
<span class="p_header">diff --git a/arch/mips/include/asm/ptrace.h b/arch/mips/include/asm/ptrace.h</span>
<span class="p_header">index f6fc6aac5496..b6578611dddb 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> static inline int is_syscall_success(struct pt_regs *regs)</span>
 
 static inline long regs_return_value(struct pt_regs *regs)
 {
<span class="p_del">-	if (is_syscall_success(regs))</span>
<span class="p_add">+	if (is_syscall_success(regs) || !user_mode(regs))</span>
 		return regs-&gt;regs[2];
 	else
 		return -regs-&gt;regs[2];
<span class="p_header">diff --git a/arch/mips/vdso/Makefile b/arch/mips/vdso/Makefile</span>
<span class="p_header">index 090393aa0f20..6c7d78546eee 100644</span>
<span class="p_header">--- a/arch/mips/vdso/Makefile</span>
<span class="p_header">+++ b/arch/mips/vdso/Makefile</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> obj-vdso := $(obj-vdso-y:%.o=$(obj)/%.o)</span>
 $(obj-vdso): KBUILD_CFLAGS := $(cflags-vdso) $(native-abi)
 $(obj-vdso): KBUILD_AFLAGS := $(aflags-vdso) $(native-abi)
 
<span class="p_del">-$(obj)/vdso.lds: KBUILD_CPPFLAGS := $(native-abi)</span>
<span class="p_add">+$(obj)/vdso.lds: KBUILD_CPPFLAGS := $(ccflags-vdso) $(native-abi)</span>
 
 $(obj)/vdso.so.dbg: $(obj)/vdso.lds $(obj-vdso) FORCE
 	$(call if_changed,vdsold)
<span class="p_header">diff --git a/arch/parisc/include/asm/pgtable.h b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">index 291cee28ccb6..c2c43f714684 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -83,10 +83,10 @@</span> <span class="p_context"> static inline void purge_tlb_entries(struct mm_struct *mm, unsigned long addr)</span>
 	printk(&quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__, (unsigned long)pgd_val(e))
 
 /* This is the size of the initially mapped kernel memory */
<span class="p_del">-#ifdef CONFIG_64BIT</span>
<span class="p_del">-#define KERNEL_INITIAL_ORDER	25	/* 1&lt;&lt;25 = 32MB */</span>
<span class="p_add">+#if defined(CONFIG_64BIT)</span>
<span class="p_add">+#define KERNEL_INITIAL_ORDER	26	/* 1&lt;&lt;26 = 64MB */</span>
 #else
<span class="p_del">-#define KERNEL_INITIAL_ORDER	24	/* 1&lt;&lt;24 = 16MB */</span>
<span class="p_add">+#define KERNEL_INITIAL_ORDER	25	/* 1&lt;&lt;25 = 32MB */</span>
 #endif
 #define KERNEL_INITIAL_SIZE	(1 &lt;&lt; KERNEL_INITIAL_ORDER)
 
<span class="p_header">diff --git a/arch/parisc/kernel/setup.c b/arch/parisc/kernel/setup.c</span>
<span class="p_header">index f7ea626e29c9..81d6f6391944 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/setup.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/setup.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/export.h&gt;
 
 #include &lt;asm/processor.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/pdc.h&gt;
 #include &lt;asm/led.h&gt;
 #include &lt;asm/machdep.h&gt;	/* for pa7300lc_init() proto */
<span class="p_chunk">@@ -140,6 +141,13 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 #endif
 	printk(KERN_CONT &quot;.\n&quot;);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check if initial kernel page mappings are sufficient.</span>
<span class="p_add">+	 * panic early if not, else we may access kernel functions</span>
<span class="p_add">+	 * and variables which can&#39;t be reached.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (__pa((unsigned long) &amp;_end) &gt;= KERNEL_INITIAL_SIZE)</span>
<span class="p_add">+		panic(&quot;KERNEL_INITIAL_ORDER too small!&quot;);</span>
 
 	pdc_console_init();
 
<span class="p_header">diff --git a/arch/parisc/kernel/vmlinux.lds.S b/arch/parisc/kernel/vmlinux.lds.S</span>
<span class="p_header">index 308f29081d46..60771df10fde 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -88,8 +88,9 @@</span> <span class="p_context"> SECTIONS</span>
 	/* Start of data section */
 	_sdata = .;
 
<span class="p_del">-	RO_DATA_SECTION(8)</span>
<span class="p_del">-</span>
<span class="p_add">+	/* Architecturally we need to keep __gp below 0x1000000 and thus</span>
<span class="p_add">+	 * in front of RO_DATA_SECTION() which stores lots of tracepoint</span>
<span class="p_add">+	 * and ftrace symbols. */</span>
 #ifdef CONFIG_64BIT
 	. = ALIGN(16);
 	/* Linkage tables */
<span class="p_chunk">@@ -104,6 +105,8 @@</span> <span class="p_context"> SECTIONS</span>
 	}
 #endif
 
<span class="p_add">+	RO_DATA_SECTION(8)</span>
<span class="p_add">+</span>
 	/* unwind info */
 	.PARISC.unwind : {
 		__start___unwind = .;
<span class="p_header">diff --git a/arch/powerpc/kernel/vdso64/datapage.S b/arch/powerpc/kernel/vdso64/datapage.S</span>
<span class="p_header">index 2f01c4a0d8a0..7612eeb31da1 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vdso64/datapage.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vdso64/datapage.S</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> V_FUNCTION_BEGIN(__kernel_get_syscall_map)</span>
 	bl	V_LOCAL_FUNC(__get_datapage)
 	mtlr	r12
 	addi	r3,r3,CFG_SYSCALL_MAP64
<span class="p_del">-	cmpli	cr0,r4,0</span>
<span class="p_add">+	cmpldi	cr0,r4,0</span>
 	crclr	cr0*4+so
 	beqlr
 	li	r0,__NR_syscalls
<span class="p_header">diff --git a/arch/powerpc/kernel/vdso64/gettimeofday.S b/arch/powerpc/kernel/vdso64/gettimeofday.S</span>
<span class="p_header">index a76b4af37ef2..382021324883 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vdso64/gettimeofday.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vdso64/gettimeofday.S</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> V_FUNCTION_BEGIN(__kernel_clock_getres)</span>
 	bne	cr0,99f
 
 	li	r3,0
<span class="p_del">-	cmpli	cr0,r4,0</span>
<span class="p_add">+	cmpldi	cr0,r4,0</span>
 	crclr	cr0*4+so
 	beqlr
 	lis	r5,CLOCK_REALTIME_RES@h
<span class="p_header">diff --git a/arch/powerpc/lib/copyuser_64.S b/arch/powerpc/lib/copyuser_64.S</span>
<span class="p_header">index f09899e35991..7b22624f332c 100644</span>
<span class="p_header">--- a/arch/powerpc/lib/copyuser_64.S</span>
<span class="p_header">+++ b/arch/powerpc/lib/copyuser_64.S</span>
<span class="p_chunk">@@ -359,6 +359,7 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)</span>
 	addi	r3,r3,8
 171:
 177:
<span class="p_add">+179:</span>
 	addi	r3,r3,8
 370:
 372:
<span class="p_chunk">@@ -373,7 +374,6 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)</span>
 173:
 174:
 175:
<span class="p_del">-179:</span>
 181:
 184:
 186:
<span class="p_header">diff --git a/arch/powerpc/mm/copro_fault.c b/arch/powerpc/mm/copro_fault.c</span>
<span class="p_header">index 6527882ce05e..ddfd2740a1b5 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/copro_fault.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/copro_fault.c</span>
<span class="p_chunk">@@ -106,6 +106,8 @@</span> <span class="p_context"> int copro_calculate_slb(struct mm_struct *mm, u64 ea, struct copro_slb *slb)</span>
 	switch (REGION_ID(ea)) {
 	case USER_REGION_ID:
 		pr_devel(&quot;%s: 0x%llx -- USER_REGION_ID\n&quot;, __func__, ea);
<span class="p_add">+		if (mm == NULL)</span>
<span class="p_add">+			return 1;</span>
 		psize = get_slice_psize(mm, ea);
 		ssize = user_segment_size(ea);
 		vsid = get_vsid(mm-&gt;context.id, ea, ssize);
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/eeh-powernv.c b/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_header">index 2ba602591a20..ba0cae69a396 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_chunk">@@ -1163,7 +1163,7 @@</span> <span class="p_context"> static void pnv_eeh_get_and_dump_hub_diag(struct pci_controller *hose)</span>
 		return;
 	}
 
<span class="p_del">-	switch (data-&gt;type) {</span>
<span class="p_add">+	switch (be16_to_cpu(data-&gt;type)) {</span>
 	case OPAL_P7IOC_DIAG_TYPE_RGC:
 		pr_info(&quot;P7IOC diag-data for RGC\n\n&quot;);
 		pnv_eeh_dump_hub_diag_common(data);
<span class="p_chunk">@@ -1395,7 +1395,7 @@</span> <span class="p_context"> static int pnv_eeh_next_error(struct eeh_pe **pe)</span>
 
 				/* Try best to clear it */
 				opal_pci_eeh_freeze_clear(phb-&gt;opal_id,
<span class="p_del">-					frozen_pe_no,</span>
<span class="p_add">+					be64_to_cpu(frozen_pe_no),</span>
 					OPAL_EEH_ACTION_CLEAR_FREEZE_ALL);
 				ret = EEH_NEXT_ERR_NONE;
 			} else if ((*pe)-&gt;state &amp; EEH_PE_ISOLATED ||
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci.c b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">index ad8c3f4a5e0b..dd5e0f3b1b5d 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_chunk">@@ -197,8 +197,8 @@</span> <span class="p_context"> static void pnv_pci_dump_p7ioc_diag_data(struct pci_controller *hose,</span>
 			be64_to_cpu(data-&gt;dma1ErrorLog1));
 
 	for (i = 0; i &lt; OPAL_P7IOC_NUM_PEST_REGS; i++) {
<span class="p_del">-		if ((data-&gt;pestA[i] &gt;&gt; 63) == 0 &amp;&amp;</span>
<span class="p_del">-		    (data-&gt;pestB[i] &gt;&gt; 63) == 0)</span>
<span class="p_add">+		if ((be64_to_cpu(data-&gt;pestA[i]) &gt;&gt; 63) == 0 &amp;&amp;</span>
<span class="p_add">+		    (be64_to_cpu(data-&gt;pestB[i]) &gt;&gt; 63) == 0)</span>
 			continue;
 
 		pr_info(&quot;PE[%3d] A/B: %016llx %016llx\n&quot;,
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/lpar.c b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">index b7a67e3d2201..3ae43282460e 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_chunk">@@ -406,7 +406,7 @@</span> <span class="p_context"> static void __pSeries_lpar_hugepage_invalidate(unsigned long *slot,</span>
 					     unsigned long *vpn, int count,
 					     int psize, int ssize)
 {
<span class="p_del">-	unsigned long param[8];</span>
<span class="p_add">+	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
 	int i = 0, pix = 0, rc;
 	unsigned long flags = 0;
 	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
<span class="p_chunk">@@ -523,7 +523,7 @@</span> <span class="p_context"> static void pSeries_lpar_flush_hash_range(unsigned long number, int local)</span>
 	unsigned long flags = 0;
 	struct ppc64_tlb_batch *batch = this_cpu_ptr(&amp;ppc64_tlb_batch);
 	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
<span class="p_del">-	unsigned long param[9];</span>
<span class="p_add">+	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
 	unsigned long hash, index, shift, hidx, slot;
 	real_pte_t pte;
 	int psize, ssize;
<span class="p_header">diff --git a/arch/s390/include/asm/tlbflush.h b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">index a2e6ef32e054..0a2031618f7f 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -81,7 +81,8 @@</span> <span class="p_context"> static inline void __tlb_flush_full(struct mm_struct *mm)</span>
 }
 
 /*
<span class="p_del">- * Flush TLB entries for a specific ASCE on all CPUs.</span>
<span class="p_add">+ * Flush TLB entries for a specific ASCE on all CPUs. Should never be used</span>
<span class="p_add">+ * when more than one asce (e.g. gmap) ran on this mm.</span>
  */
 static inline void __tlb_flush_asce(struct mm_struct *mm, unsigned long asce)
 {
<span class="p_header">diff --git a/arch/s390/mm/pgtable.c b/arch/s390/mm/pgtable.c</span>
<span class="p_header">index 471a370a527b..8345ae1f117d 100644</span>
<span class="p_header">--- a/arch/s390/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/s390/mm/pgtable.c</span>
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(gmap_alloc);</span>
 static void gmap_flush_tlb(struct gmap *gmap)
 {
 	if (MACHINE_HAS_IDTE)
<span class="p_del">-		__tlb_flush_asce(gmap-&gt;mm, gmap-&gt;asce);</span>
<span class="p_add">+		__tlb_flush_idte(gmap-&gt;asce);</span>
 	else
 		__tlb_flush_global();
 }
<span class="p_chunk">@@ -205,7 +205,7 @@</span> <span class="p_context"> void gmap_free(struct gmap *gmap)</span>
 
 	/* Flush tlb. */
 	if (MACHINE_HAS_IDTE)
<span class="p_del">-		__tlb_flush_asce(gmap-&gt;mm, gmap-&gt;asce);</span>
<span class="p_add">+		__tlb_flush_idte(gmap-&gt;asce);</span>
 	else
 		__tlb_flush_global();
 
<span class="p_header">diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c</span>
<span class="p_header">index 38b3ead7222d..52a2526c3fbe 100644</span>
<span class="p_header">--- a/arch/x86/kernel/e820.c</span>
<span class="p_header">+++ b/arch/x86/kernel/e820.c</span>
<span class="p_chunk">@@ -347,7 +347,7 @@</span> <span class="p_context"> int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,</span>
 		 * continue building up new bios map based on this
 		 * information
 		 */
<span class="p_del">-		if (current_type != last_type) {</span>
<span class="p_add">+		if (current_type != last_type || current_type == E820_PRAM) {</span>
 			if (last_type != 0)	 {
 				new_bios[new_bios_entry].size =
 					change_point[chgidx]-&gt;addr - last_addr;
<span class="p_header">diff --git a/arch/x86/kvm/ioapic.c b/arch/x86/kvm/ioapic.c</span>
<span class="p_header">index 88d0a92d3f94..3aab53f8cad2 100644</span>
<span class="p_header">--- a/arch/x86/kvm/ioapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/ioapic.c</span>
<span class="p_chunk">@@ -580,7 +580,7 @@</span> <span class="p_context"> static void kvm_ioapic_reset(struct kvm_ioapic *ioapic)</span>
 	ioapic-&gt;irr = 0;
 	ioapic-&gt;irr_delivered = 0;
 	ioapic-&gt;id = 0;
<span class="p_del">-	memset(ioapic-&gt;irq_eoi, 0x00, IOAPIC_NUM_PINS);</span>
<span class="p_add">+	memset(ioapic-&gt;irq_eoi, 0x00, sizeof(ioapic-&gt;irq_eoi));</span>
 	rtc_irq_eoi_tracking_reset(ioapic);
 }
 
<span class="p_header">diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c</span>
<span class="p_header">index 5a37188b559f..9d359e05fad7 100644</span>
<span class="p_header">--- a/block/blk-cgroup.c</span>
<span class="p_header">+++ b/block/blk-cgroup.c</span>
<span class="p_chunk">@@ -1331,10 +1331,8 @@</span> <span class="p_context"> int blkcg_policy_register(struct blkcg_policy *pol)</span>
 			struct blkcg_policy_data *cpd;
 
 			cpd = pol-&gt;cpd_alloc_fn(GFP_KERNEL);
<span class="p_del">-			if (!cpd) {</span>
<span class="p_del">-				mutex_unlock(&amp;blkcg_pol_mutex);</span>
<span class="p_add">+			if (!cpd)</span>
 				goto err_free_cpds;
<span class="p_del">-			}</span>
 
 			blkcg-&gt;cpd[pol-&gt;plid] = cpd;
 			cpd-&gt;blkcg = blkcg;
<span class="p_header">diff --git a/crypto/asymmetric_keys/pkcs7_parser.c b/crypto/asymmetric_keys/pkcs7_parser.c</span>
<span class="p_header">index 758acabf2d81..8f3056cd0399 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/pkcs7_parser.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/pkcs7_parser.c</span>
<span class="p_chunk">@@ -547,9 +547,7 @@</span> <span class="p_context"> int pkcs7_sig_note_set_of_authattrs(void *context, size_t hdrlen,</span>
 	struct pkcs7_signed_info *sinfo = ctx-&gt;sinfo;
 
 	if (!test_bit(sinfo_has_content_type, &amp;sinfo-&gt;aa_set) ||
<span class="p_del">-	    !test_bit(sinfo_has_message_digest, &amp;sinfo-&gt;aa_set) ||</span>
<span class="p_del">-	    (ctx-&gt;msg-&gt;data_type == OID_msIndirectData &amp;&amp;</span>
<span class="p_del">-	     !test_bit(sinfo_has_ms_opus_info, &amp;sinfo-&gt;aa_set))) {</span>
<span class="p_add">+	    !test_bit(sinfo_has_message_digest, &amp;sinfo-&gt;aa_set)) {</span>
 		pr_warn(&quot;Missing required AuthAttr\n&quot;);
 		return -EBADMSG;
 	}
<span class="p_header">diff --git a/drivers/acpi/nfit.c b/drivers/acpi/nfit.c</span>
<span class="p_header">index 5230e8449d30..c097f477c74c 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit.c</span>
<span class="p_header">+++ b/drivers/acpi/nfit.c</span>
<span class="p_chunk">@@ -1806,6 +1806,9 @@</span> <span class="p_context"> static void acpi_nfit_notify(struct acpi_device *adev, u32 event)</span>
 
 	dev_dbg(dev, &quot;%s: event: %d\n&quot;, __func__, event);
 
<span class="p_add">+	if (event != NFIT_NOTIFY_UPDATE)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	device_lock(dev);
 	if (!dev-&gt;driver) {
 		/* dev-&gt;driver may be null if we&#39;re being removed */
<span class="p_header">diff --git a/drivers/acpi/nfit.h b/drivers/acpi/nfit.h</span>
<span class="p_header">index 3d549a383659..13d6ec1ff055 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit.h</span>
<span class="p_header">+++ b/drivers/acpi/nfit.h</span>
<span class="p_chunk">@@ -45,6 +45,10 @@</span> <span class="p_context"> enum {</span>
 	ND_BLK_DCR_LATCH = 2,
 };
 
<span class="p_add">+enum nfit_root_notifiers {</span>
<span class="p_add">+	NFIT_NOTIFY_UPDATE = 0x80,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct nfit_spa {
 	struct acpi_nfit_system_address *spa;
 	struct list_head list;
<span class="p_header">diff --git a/drivers/base/platform.c b/drivers/base/platform.c</span>
<span class="p_header">index 176b59f5bc47..ba66330cea67 100644</span>
<span class="p_header">--- a/drivers/base/platform.c</span>
<span class="p_header">+++ b/drivers/base/platform.c</span>
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> int platform_get_irq(struct platform_device *dev, unsigned int num)</span>
 		int ret;
 
 		ret = of_irq_get(dev-&gt;dev.of_node, num);
<span class="p_del">-		if (ret &gt;= 0 || ret == -EPROBE_DEFER)</span>
<span class="p_add">+		if (ret &gt; 0 || ret == -EPROBE_DEFER)</span>
 			return ret;
 	}
 
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"> int platform_get_irq_byname(struct platform_device *dev, const char *name)</span>
 		int ret;
 
 		ret = of_irq_get_byname(dev-&gt;dev.of_node, name);
<span class="p_del">-		if (ret &gt;= 0 || ret == -EPROBE_DEFER)</span>
<span class="p_add">+		if (ret &gt; 0 || ret == -EPROBE_DEFER)</span>
 			return ret;
 	}
 
<span class="p_header">diff --git a/drivers/clk/imx/clk-imx6q.c b/drivers/clk/imx/clk-imx6q.c</span>
<span class="p_header">index c1935081d34a..aab64205d866 100644</span>
<span class="p_header">--- a/drivers/clk/imx/clk-imx6q.c</span>
<span class="p_header">+++ b/drivers/clk/imx/clk-imx6q.c</span>
<span class="p_chunk">@@ -550,6 +550,24 @@</span> <span class="p_context"> static void __init imx6q_clocks_init(struct device_node *ccm_node)</span>
 	if (IS_ENABLED(CONFIG_PCI_IMX6))
 		clk_set_parent(clk[IMX6QDL_CLK_LVDS1_SEL], clk[IMX6QDL_CLK_SATA_REF_100M]);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Initialize the GPU clock muxes, so that the maximum specified clock</span>
<span class="p_add">+	 * rates for the respective SoC are not exceeded.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (clk_on_imx6dl()) {</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU3D_CORE_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_PLL2_PFD1_594M]);</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU2D_CORE_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_PLL2_PFD1_594M]);</span>
<span class="p_add">+	} else if (clk_on_imx6q()) {</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU3D_CORE_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_MMDC_CH0_AXI]);</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU3D_SHADER_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_PLL2_PFD1_594M]);</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU2D_CORE_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_PLL3_USB_OTG]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	imx_register_uart_clocks(uart_clks);
 }
 CLK_OF_DECLARE(imx6q, &quot;fsl,imx6q-ccm&quot;, imx6q_clocks_init);
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index 6e80e4298274..7ff8b15a3422 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -285,14 +285,14 @@</span> <span class="p_context"> static void intel_pstate_hwp_set(void)</span>
 	int min, hw_min, max, hw_max, cpu, range, adj_range;
 	u64 value, cap;
 
<span class="p_del">-	rdmsrl(MSR_HWP_CAPABILITIES, cap);</span>
<span class="p_del">-	hw_min = HWP_LOWEST_PERF(cap);</span>
<span class="p_del">-	hw_max = HWP_HIGHEST_PERF(cap);</span>
<span class="p_del">-	range = hw_max - hw_min;</span>
<span class="p_del">-</span>
 	get_online_cpus();
 
 	for_each_online_cpu(cpu) {
<span class="p_add">+		rdmsrl_on_cpu(cpu, MSR_HWP_CAPABILITIES, &amp;cap);</span>
<span class="p_add">+		hw_min = HWP_LOWEST_PERF(cap);</span>
<span class="p_add">+		hw_max = HWP_HIGHEST_PERF(cap);</span>
<span class="p_add">+		range = hw_max - hw_min;</span>
<span class="p_add">+</span>
 		rdmsrl_on_cpu(cpu, MSR_HWP_REQUEST, &amp;value);
 		adj_range = limits-&gt;min_perf_pct * range / 100;
 		min = hw_min + adj_range;
<span class="p_header">diff --git a/drivers/gpio/gpio-mpc8xxx.c b/drivers/gpio/gpio-mpc8xxx.c</span>
<span class="p_header">index 48ef368347ab..9e02cb6afb0b 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-mpc8xxx.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-mpc8xxx.c</span>
<span class="p_chunk">@@ -329,7 +329,7 @@</span> <span class="p_context"> static int mpc8xxx_gpio_irq_map(struct irq_domain *h, unsigned int irq,</span>
 				irq_hw_number_t hwirq)
 {
 	irq_set_chip_data(irq, h-&gt;host_data);
<span class="p_del">-	irq_set_chip_and_handler(irq, &amp;mpc8xxx_irq_chip, handle_level_irq);</span>
<span class="p_add">+	irq_set_chip_and_handler(irq, &amp;mpc8xxx_irq_chip, handle_edge_irq);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index be5b399da5d3..43482ae1e049 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -1163,6 +1163,13 @@</span> <span class="p_context"> static const struct dmi_system_id elantech_dmi_has_middle_button[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;CELSIUS H730&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Fujitsu H760 also has a middle button */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;CELSIUS H760&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 #endif
 	{ }
 };
<span class="p_chunk">@@ -1507,10 +1514,10 @@</span> <span class="p_context"> static const struct dmi_system_id elantech_dmi_force_crc_enabled[] = {</span>
 		},
 	},
 	{
<span class="p_del">-		/* Fujitsu LIFEBOOK E554  does not work with crc_enabled == 0 */</span>
<span class="p_add">+		/* Fujitsu H760 does not work with crc_enabled == 0 */</span>
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),
<span class="p_del">-			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E554&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;CELSIUS H760&quot;),</span>
 		},
 	},
 	{
<span class="p_chunk">@@ -1521,6 +1528,20 @@</span> <span class="p_context"> static const struct dmi_system_id elantech_dmi_force_crc_enabled[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		/* Fujitsu LIFEBOOK E554  does not work with crc_enabled == 0 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E554&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Fujitsu LIFEBOOK E556 does not work with crc_enabled == 0 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E556&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* Fujitsu LIFEBOOK U745 does not work with crc_enabled == 0 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),
<span class="p_header">diff --git a/drivers/input/serio/i8042-io.h b/drivers/input/serio/i8042-io.h</span>
<span class="p_header">index a5eed2ade53d..34da81c006b6 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-io.h</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> static inline int i8042_platform_init(void)</span>
 		return -EBUSY;
 #endif
 
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/input/serio/i8042-ip22io.h b/drivers/input/serio/i8042-ip22io.h</span>
<span class="p_header">index ee1ad27d6ed0..08a1c10a1448 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-ip22io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-ip22io.h</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"> static inline int i8042_platform_init(void)</span>
 		return -EBUSY;
 #endif
 
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/serio/i8042-ppcio.h b/drivers/input/serio/i8042-ppcio.h</span>
<span class="p_header">index f708c75d16f1..1aabea43329e 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-ppcio.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-ppcio.h</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static inline void i8042_write_command(int val)</span>
 
 static inline int i8042_platform_init(void)
 {
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/input/serio/i8042-sparcio.h b/drivers/input/serio/i8042-sparcio.h</span>
<span class="p_header">index afcd1c1a05b2..6231d63860ee 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-sparcio.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-sparcio.h</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static int __init i8042_platform_init(void)</span>
 		}
 	}
 
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/serio/i8042-unicore32io.h b/drivers/input/serio/i8042-unicore32io.h</span>
<span class="p_header">index 73f5cc124a36..455747552f85 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-unicore32io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-unicore32io.h</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"> static inline int i8042_platform_init(void)</span>
 	if (!request_mem_region(I8042_REGION_START, I8042_REGION_SIZE, &quot;i8042&quot;))
 		return -EBUSY;
 
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index 68f5f4a0f1e7..f4bfb4b2d50a 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -510,6 +510,90 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_nomux_table[] = {</span>
 	{ }
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * On some Asus laptops, just running self tests cause problems.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static const struct dmi_system_id i8042_dmi_noselftest_table[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;A455LD&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;K401LB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;K501LB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;K501LX&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;R409L&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;V502LX&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X302LA&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X450LCP&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X450LD&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X455LAB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X455LDB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X455LF&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Z450LA&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
 static const struct dmi_system_id __initconst i8042_dmi_reset_table[] = {
 	{
 		/* MSI Wind U-100 */
<span class="p_chunk">@@ -1072,12 +1156,18 @@</span> <span class="p_context"> static int __init i8042_platform_init(void)</span>
 		return retval;
 
 #if defined(__ia64__)
<span class="p_del">-        i8042_reset = true;</span>
<span class="p_add">+        i8042_reset = I8042_RESET_ALWAYS;</span>
 #endif
 
 #ifdef CONFIG_X86
<span class="p_del">-	if (dmi_check_system(i8042_dmi_reset_table))</span>
<span class="p_del">-		i8042_reset = true;</span>
<span class="p_add">+	/* Honor module parameter when value is not default */</span>
<span class="p_add">+	if (i8042_reset == I8042_RESET_DEFAULT) {</span>
<span class="p_add">+		if (dmi_check_system(i8042_dmi_reset_table))</span>
<span class="p_add">+			i8042_reset = I8042_RESET_ALWAYS;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (dmi_check_system(i8042_dmi_noselftest_table))</span>
<span class="p_add">+			i8042_reset = I8042_RESET_NEVER;</span>
<span class="p_add">+	}</span>
 
 	if (dmi_check_system(i8042_dmi_noloop_table))
 		i8042_noloop = true;
<span class="p_header">diff --git a/drivers/input/serio/i8042.c b/drivers/input/serio/i8042.c</span>
<span class="p_header">index 405252a884dd..89abfdb539ac 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042.c</span>
<span class="p_header">+++ b/drivers/input/serio/i8042.c</span>
<span class="p_chunk">@@ -48,9 +48,39 @@</span> <span class="p_context"> static bool i8042_unlock;</span>
 module_param_named(unlock, i8042_unlock, bool, 0);
 MODULE_PARM_DESC(unlock, &quot;Ignore keyboard lock.&quot;);
 
<span class="p_del">-static bool i8042_reset;</span>
<span class="p_del">-module_param_named(reset, i8042_reset, bool, 0);</span>
<span class="p_del">-MODULE_PARM_DESC(reset, &quot;Reset controller during init and cleanup.&quot;);</span>
<span class="p_add">+enum i8042_controller_reset_mode {</span>
<span class="p_add">+	I8042_RESET_NEVER,</span>
<span class="p_add">+	I8042_RESET_ALWAYS,</span>
<span class="p_add">+	I8042_RESET_ON_S2RAM,</span>
<span class="p_add">+#define I8042_RESET_DEFAULT	I8042_RESET_ON_S2RAM</span>
<span class="p_add">+};</span>
<span class="p_add">+static enum i8042_controller_reset_mode i8042_reset = I8042_RESET_DEFAULT;</span>
<span class="p_add">+static int i8042_set_reset(const char *val, const struct kernel_param *kp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	enum i8042_controller_reset_mode *arg = kp-&gt;arg;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+	bool reset;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (val) {</span>
<span class="p_add">+		error = kstrtobool(val, &amp;reset);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		reset = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	*arg = reset ? I8042_RESET_ALWAYS : I8042_RESET_NEVER;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct kernel_param_ops param_ops_reset_param = {</span>
<span class="p_add">+	.flags = KERNEL_PARAM_OPS_FL_NOARG,</span>
<span class="p_add">+	.set = i8042_set_reset,</span>
<span class="p_add">+};</span>
<span class="p_add">+#define param_check_reset_param(name, p)	\</span>
<span class="p_add">+	__param_check(name, p, enum i8042_controller_reset_mode)</span>
<span class="p_add">+module_param_named(reset, i8042_reset, reset_param, 0);</span>
<span class="p_add">+MODULE_PARM_DESC(reset, &quot;Reset controller on resume, cleanup or both&quot;);</span>
 
 static bool i8042_direct;
 module_param_named(direct, i8042_direct, bool, 0);
<span class="p_chunk">@@ -1019,7 +1049,7 @@</span> <span class="p_context"> static int i8042_controller_init(void)</span>
  * Reset the controller and reset CRT to the original value set by BIOS.
  */
 
<span class="p_del">-static void i8042_controller_reset(bool force_reset)</span>
<span class="p_add">+static void i8042_controller_reset(bool s2r_wants_reset)</span>
 {
 	i8042_flush();
 
<span class="p_chunk">@@ -1044,8 +1074,10 @@</span> <span class="p_context"> static void i8042_controller_reset(bool force_reset)</span>
  * Reset the controller if requested.
  */
 
<span class="p_del">-	if (i8042_reset || force_reset)</span>
<span class="p_add">+	if (i8042_reset == I8042_RESET_ALWAYS ||</span>
<span class="p_add">+	    (i8042_reset == I8042_RESET_ON_S2RAM &amp;&amp; s2r_wants_reset)) {</span>
 		i8042_controller_selftest();
<span class="p_add">+	}</span>
 
 /*
  * Restore the original control register setting.
<span class="p_chunk">@@ -1110,7 +1142,7 @@</span> <span class="p_context"> static void i8042_dritek_enable(void)</span>
  * before suspending.
  */
 
<span class="p_del">-static int i8042_controller_resume(bool force_reset)</span>
<span class="p_add">+static int i8042_controller_resume(bool s2r_wants_reset)</span>
 {
 	int error;
 
<span class="p_chunk">@@ -1118,7 +1150,8 @@</span> <span class="p_context"> static int i8042_controller_resume(bool force_reset)</span>
 	if (error)
 		return error;
 
<span class="p_del">-	if (i8042_reset || force_reset) {</span>
<span class="p_add">+	if (i8042_reset == I8042_RESET_ALWAYS ||</span>
<span class="p_add">+	    (i8042_reset == I8042_RESET_ON_S2RAM &amp;&amp; s2r_wants_reset)) {</span>
 		error = i8042_controller_selftest();
 		if (error)
 			return error;
<span class="p_chunk">@@ -1195,7 +1228,7 @@</span> <span class="p_context"> static int i8042_pm_resume_noirq(struct device *dev)</span>
 
 static int i8042_pm_resume(struct device *dev)
 {
<span class="p_del">-	bool force_reset;</span>
<span class="p_add">+	bool want_reset;</span>
 	int i;
 
 	for (i = 0; i &lt; I8042_NUM_PORTS; i++) {
<span class="p_chunk">@@ -1218,9 +1251,9 @@</span> <span class="p_context"> static int i8042_pm_resume(struct device *dev)</span>
 	 * off control to the platform firmware, otherwise we can simply restore
 	 * the mode.
 	 */
<span class="p_del">-	force_reset = pm_resume_via_firmware();</span>
<span class="p_add">+	want_reset = pm_resume_via_firmware();</span>
 
<span class="p_del">-	return i8042_controller_resume(force_reset);</span>
<span class="p_add">+	return i8042_controller_resume(want_reset);</span>
 }
 
 static int i8042_pm_thaw(struct device *dev)
<span class="p_chunk">@@ -1482,7 +1515,7 @@</span> <span class="p_context"> static int __init i8042_probe(struct platform_device *dev)</span>
 
 	i8042_platform_device = dev;
 
<span class="p_del">-	if (i8042_reset) {</span>
<span class="p_add">+	if (i8042_reset == I8042_RESET_ALWAYS) {</span>
 		error = i8042_controller_selftest();
 		if (error)
 			return error;
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">index 44aa57edf207..e33c729b9f48 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"> static void gic_enable_redist(bool enable)</span>
 			return;	/* No PM support in this redistributor */
 	}
 
<span class="p_del">-	while (count--) {</span>
<span class="p_add">+	while (--count) {</span>
 		val = readl_relaxed(rbase + GICR_WAKER);
 		if (enable ^ (val &amp; GICR_WAKER_ChildrenAsleep))
 			break;
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index 51eda7235e32..5cac11d7a876 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -112,8 +112,7 @@</span> <span class="p_context"> struct iv_tcw_private {</span>
  * and encrypts / decrypts at the same time.
  */
 enum flags { DM_CRYPT_SUSPENDED, DM_CRYPT_KEY_VALID,
<span class="p_del">-	     DM_CRYPT_SAME_CPU, DM_CRYPT_NO_OFFLOAD,</span>
<span class="p_del">-	     DM_CRYPT_EXIT_THREAD};</span>
<span class="p_add">+	     DM_CRYPT_SAME_CPU, DM_CRYPT_NO_OFFLOAD };</span>
 
 /*
  * The fields in here must be read only after initialization.
<span class="p_chunk">@@ -1204,18 +1203,20 @@</span> <span class="p_context"> continue_locked:</span>
 		if (!RB_EMPTY_ROOT(&amp;cc-&gt;write_tree))
 			goto pop_from_list;
 
<span class="p_del">-		if (unlikely(test_bit(DM_CRYPT_EXIT_THREAD, &amp;cc-&gt;flags))) {</span>
<span class="p_del">-			spin_unlock_irq(&amp;cc-&gt;write_thread_wait.lock);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		__set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="p_add">+		set_current_state(TASK_INTERRUPTIBLE);</span>
 		__add_wait_queue(&amp;cc-&gt;write_thread_wait, &amp;wait);
 
 		spin_unlock_irq(&amp;cc-&gt;write_thread_wait.lock);
 
<span class="p_add">+		if (unlikely(kthread_should_stop())) {</span>
<span class="p_add">+			set_task_state(current, TASK_RUNNING);</span>
<span class="p_add">+			remove_wait_queue(&amp;cc-&gt;write_thread_wait, &amp;wait);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		schedule();
 
<span class="p_add">+		set_task_state(current, TASK_RUNNING);</span>
 		spin_lock_irq(&amp;cc-&gt;write_thread_wait.lock);
 		__remove_wait_queue(&amp;cc-&gt;write_thread_wait, &amp;wait);
 		goto continue_locked;
<span class="p_chunk">@@ -1530,13 +1531,8 @@</span> <span class="p_context"> static void crypt_dtr(struct dm_target *ti)</span>
 	if (!cc)
 		return;
 
<span class="p_del">-	if (cc-&gt;write_thread) {</span>
<span class="p_del">-		spin_lock_irq(&amp;cc-&gt;write_thread_wait.lock);</span>
<span class="p_del">-		set_bit(DM_CRYPT_EXIT_THREAD, &amp;cc-&gt;flags);</span>
<span class="p_del">-		wake_up_locked(&amp;cc-&gt;write_thread_wait);</span>
<span class="p_del">-		spin_unlock_irq(&amp;cc-&gt;write_thread_wait.lock);</span>
<span class="p_add">+	if (cc-&gt;write_thread)</span>
 		kthread_stop(cc-&gt;write_thread);
<span class="p_del">-	}</span>
 
 	if (cc-&gt;io_queue)
 		destroy_workqueue(cc-&gt;io_queue);
<span class="p_header">diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c</span>
<span class="p_header">index cfa29f574c2a..5b2ef966012b 100644</span>
<span class="p_header">--- a/drivers/md/dm-mpath.c</span>
<span class="p_header">+++ b/drivers/md/dm-mpath.c</span>
<span class="p_chunk">@@ -1220,10 +1220,10 @@</span> <span class="p_context"> static void activate_path(struct work_struct *work)</span>
 {
 	struct pgpath *pgpath =
 		container_of(work, struct pgpath, activate_path.work);
<span class="p_add">+	struct request_queue *q = bdev_get_queue(pgpath-&gt;path.dev-&gt;bdev);</span>
 
<span class="p_del">-	if (pgpath-&gt;is_active)</span>
<span class="p_del">-		scsi_dh_activate(bdev_get_queue(pgpath-&gt;path.dev-&gt;bdev),</span>
<span class="p_del">-				 pg_init_done, pgpath);</span>
<span class="p_add">+	if (pgpath-&gt;is_active &amp;&amp; !blk_queue_dying(q))</span>
<span class="p_add">+		scsi_dh_activate(q, pg_init_done, pgpath);</span>
 	else
 		pg_init_done(pgpath, SCSI_DH_DEV_OFFLINED);
 }
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index a42729ebf272..84aa8b1d0480 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -2869,6 +2869,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(dm_device_name);</span>
 
 static void __dm_destroy(struct mapped_device *md, bool wait)
 {
<span class="p_add">+	struct request_queue *q = dm_get_md_queue(md);</span>
 	struct dm_table *map;
 	int srcu_idx;
 
<span class="p_chunk">@@ -2879,6 +2880,10 @@</span> <span class="p_context"> static void __dm_destroy(struct mapped_device *md, bool wait)</span>
 	set_bit(DMF_FREEING, &amp;md-&gt;flags);
 	spin_unlock(&amp;_minor_lock);
 
<span class="p_add">+	spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+	queue_flag_set(QUEUE_FLAG_DYING, q);</span>
<span class="p_add">+	spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+</span>
 	if (dm_request_based(md) &amp;&amp; md-&gt;kworker_task)
 		flush_kthread_worker(&amp;md-&gt;kworker);
 
<span class="p_chunk">@@ -3245,10 +3250,11 @@</span> <span class="p_context"> static int __dm_resume(struct mapped_device *md, struct dm_table *map)</span>
 
 int dm_resume(struct mapped_device *md)
 {
<span class="p_del">-	int r = -EINVAL;</span>
<span class="p_add">+	int r;</span>
 	struct dm_table *map = NULL;
 
 retry:
<span class="p_add">+	r = -EINVAL;</span>
 	mutex_lock_nested(&amp;md-&gt;suspend_lock, SINGLE_DEPTH_NESTING);
 
 	if (!dm_suspended_md(md))
<span class="p_chunk">@@ -3272,8 +3278,6 @@</span> <span class="p_context"> retry:</span>
 		goto out;
 
 	clear_bit(DMF_SUSPENDED, &amp;md-&gt;flags);
<span class="p_del">-</span>
<span class="p_del">-	r = 0;</span>
 out:
 	mutex_unlock(&amp;md-&gt;suspend_lock);
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/mb86a20s.c b/drivers/media/dvb-frontends/mb86a20s.c</span>
<span class="p_header">index cfc005ee11d8..7fc72de2434c 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/mb86a20s.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/mb86a20s.c</span>
<span class="p_chunk">@@ -71,25 +71,27 @@</span> <span class="p_context"> static struct regdata mb86a20s_init1[] = {</span>
 };
 
 static struct regdata mb86a20s_init2[] = {
<span class="p_del">-	{ 0x28, 0x22 }, { 0x29, 0x00 }, { 0x2a, 0x1f }, { 0x2b, 0xf0 },</span>
<span class="p_add">+	{ 0x50, 0xd1 }, { 0x51, 0x22 },</span>
<span class="p_add">+	{ 0x39, 0x01 },</span>
<span class="p_add">+	{ 0x71, 0x00 },</span>
 	{ 0x3b, 0x21 },
<span class="p_del">-	{ 0x3c, 0x38 },</span>
<span class="p_add">+	{ 0x3c, 0x3a },</span>
 	{ 0x01, 0x0d },
<span class="p_del">-	{ 0x04, 0x08 }, { 0x05, 0x03 },</span>
<span class="p_add">+	{ 0x04, 0x08 }, { 0x05, 0x05 },</span>
 	{ 0x04, 0x0e }, { 0x05, 0x00 },
<span class="p_del">-	{ 0x04, 0x0f }, { 0x05, 0x37 },</span>
<span class="p_del">-	{ 0x04, 0x0b }, { 0x05, 0x78 },</span>
<span class="p_add">+	{ 0x04, 0x0f }, { 0x05, 0x14 },</span>
<span class="p_add">+	{ 0x04, 0x0b }, { 0x05, 0x8c },</span>
 	{ 0x04, 0x00 }, { 0x05, 0x00 },
<span class="p_del">-	{ 0x04, 0x01 }, { 0x05, 0x1e },</span>
<span class="p_del">-	{ 0x04, 0x02 }, { 0x05, 0x07 },</span>
<span class="p_del">-	{ 0x04, 0x03 }, { 0x05, 0xd0 },</span>
<span class="p_add">+	{ 0x04, 0x01 }, { 0x05, 0x07 },</span>
<span class="p_add">+	{ 0x04, 0x02 }, { 0x05, 0x0f },</span>
<span class="p_add">+	{ 0x04, 0x03 }, { 0x05, 0xa0 },</span>
 	{ 0x04, 0x09 }, { 0x05, 0x00 },
 	{ 0x04, 0x0a }, { 0x05, 0xff },
<span class="p_del">-	{ 0x04, 0x27 }, { 0x05, 0x00 },</span>
<span class="p_add">+	{ 0x04, 0x27 }, { 0x05, 0x64 },</span>
 	{ 0x04, 0x28 }, { 0x05, 0x00 },
<span class="p_del">-	{ 0x04, 0x1e }, { 0x05, 0x00 },</span>
<span class="p_del">-	{ 0x04, 0x29 }, { 0x05, 0x64 },</span>
<span class="p_del">-	{ 0x04, 0x32 }, { 0x05, 0x02 },</span>
<span class="p_add">+	{ 0x04, 0x1e }, { 0x05, 0xff },</span>
<span class="p_add">+	{ 0x04, 0x29 }, { 0x05, 0x0a },</span>
<span class="p_add">+	{ 0x04, 0x32 }, { 0x05, 0x0a },</span>
 	{ 0x04, 0x14 }, { 0x05, 0x02 },
 	{ 0x04, 0x04 }, { 0x05, 0x00 },
 	{ 0x04, 0x05 }, { 0x05, 0x22 },
<span class="p_chunk">@@ -97,8 +99,6 @@</span> <span class="p_context"> static struct regdata mb86a20s_init2[] = {</span>
 	{ 0x04, 0x07 }, { 0x05, 0xd8 },
 	{ 0x04, 0x12 }, { 0x05, 0x00 },
 	{ 0x04, 0x13 }, { 0x05, 0xff },
<span class="p_del">-	{ 0x04, 0x15 }, { 0x05, 0x4e },</span>
<span class="p_del">-	{ 0x04, 0x16 }, { 0x05, 0x20 },</span>
 
 	/*
 	 * On this demod, when the bit count reaches the count below,
<span class="p_chunk">@@ -152,42 +152,36 @@</span> <span class="p_context"> static struct regdata mb86a20s_init2[] = {</span>
 	{ 0x50, 0x51 }, { 0x51, 0x04 },		/* MER symbol 4 */
 	{ 0x45, 0x04 },				/* CN symbol 4 */
 	{ 0x48, 0x04 },				/* CN manual mode */
<span class="p_del">-</span>
<span class="p_add">+	{ 0x50, 0xd5 }, { 0x51, 0x01 },</span>
 	{ 0x50, 0xd6 }, { 0x51, 0x1f },
 	{ 0x50, 0xd2 }, { 0x51, 0x03 },
<span class="p_del">-	{ 0x50, 0xd7 }, { 0x51, 0xbf },</span>
<span class="p_del">-	{ 0x28, 0x74 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0xff },</span>
<span class="p_del">-	{ 0x28, 0x46 }, { 0x29, 0x00 }, { 0x2a, 0x1a }, { 0x2b, 0x0c },</span>
<span class="p_del">-</span>
<span class="p_del">-	{ 0x04, 0x40 }, { 0x05, 0x00 },</span>
<span class="p_del">-	{ 0x28, 0x00 }, { 0x2b, 0x08 },</span>
<span class="p_del">-	{ 0x28, 0x05 }, { 0x2b, 0x00 },</span>
<span class="p_add">+	{ 0x50, 0xd7 }, { 0x51, 0x3f },</span>
 	{ 0x1c, 0x01 },
<span class="p_del">-	{ 0x28, 0x06 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x1f },</span>
<span class="p_del">-	{ 0x28, 0x07 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x18 },</span>
<span class="p_del">-	{ 0x28, 0x08 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x12 },</span>
<span class="p_del">-	{ 0x28, 0x09 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x30 },</span>
<span class="p_del">-	{ 0x28, 0x0a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x37 },</span>
<span class="p_del">-	{ 0x28, 0x0b }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x02 },</span>
<span class="p_del">-	{ 0x28, 0x0c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x09 },</span>
<span class="p_del">-	{ 0x28, 0x0d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x06 },</span>
<span class="p_del">-	{ 0x28, 0x0e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x7b },</span>
<span class="p_del">-	{ 0x28, 0x0f }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x76 },</span>
<span class="p_del">-	{ 0x28, 0x10 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x7d },</span>
<span class="p_del">-	{ 0x28, 0x11 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x08 },</span>
<span class="p_del">-	{ 0x28, 0x12 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0b },</span>
<span class="p_del">-	{ 0x28, 0x13 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x00 },</span>
<span class="p_del">-	{ 0x28, 0x14 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xf2 },</span>
<span class="p_del">-	{ 0x28, 0x15 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xf3 },</span>
<span class="p_del">-	{ 0x28, 0x16 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x05 },</span>
<span class="p_del">-	{ 0x28, 0x17 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x16 },</span>
<span class="p_del">-	{ 0x28, 0x18 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0f },</span>
<span class="p_del">-	{ 0x28, 0x19 }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xef },</span>
<span class="p_del">-	{ 0x28, 0x1a }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xd8 },</span>
<span class="p_del">-	{ 0x28, 0x1b }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xf1 },</span>
<span class="p_del">-	{ 0x28, 0x1c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x3d },</span>
<span class="p_del">-	{ 0x28, 0x1d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x94 },</span>
<span class="p_del">-	{ 0x28, 0x1e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0xba },</span>
<span class="p_add">+	{ 0x28, 0x06 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x03 },</span>
<span class="p_add">+	{ 0x28, 0x07 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0d },</span>
<span class="p_add">+	{ 0x28, 0x08 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x02 },</span>
<span class="p_add">+	{ 0x28, 0x09 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x01 },</span>
<span class="p_add">+	{ 0x28, 0x0a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x21 },</span>
<span class="p_add">+	{ 0x28, 0x0b }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x29 },</span>
<span class="p_add">+	{ 0x28, 0x0c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x16 },</span>
<span class="p_add">+	{ 0x28, 0x0d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x31 },</span>
<span class="p_add">+	{ 0x28, 0x0e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0e },</span>
<span class="p_add">+	{ 0x28, 0x0f }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x4e },</span>
<span class="p_add">+	{ 0x28, 0x10 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x46 },</span>
<span class="p_add">+	{ 0x28, 0x11 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0f },</span>
<span class="p_add">+	{ 0x28, 0x12 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x56 },</span>
<span class="p_add">+	{ 0x28, 0x13 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x35 },</span>
<span class="p_add">+	{ 0x28, 0x14 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xbe },</span>
<span class="p_add">+	{ 0x28, 0x15 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0x84 },</span>
<span class="p_add">+	{ 0x28, 0x16 }, { 0x29, 0x00 }, { 0x2a, 0x03 }, { 0x2b, 0xee },</span>
<span class="p_add">+	{ 0x28, 0x17 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x98 },</span>
<span class="p_add">+	{ 0x28, 0x18 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x9f },</span>
<span class="p_add">+	{ 0x28, 0x19 }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xb2 },</span>
<span class="p_add">+	{ 0x28, 0x1a }, { 0x29, 0x00 }, { 0x2a, 0x06 }, { 0x2b, 0xc2 },</span>
<span class="p_add">+	{ 0x28, 0x1b }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0x4a },</span>
<span class="p_add">+	{ 0x28, 0x1c }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xbc },</span>
<span class="p_add">+	{ 0x28, 0x1d }, { 0x29, 0x00 }, { 0x2a, 0x04 }, { 0x2b, 0xba },</span>
<span class="p_add">+	{ 0x28, 0x1e }, { 0x29, 0x00 }, { 0x2a, 0x06 }, { 0x2b, 0x14 },</span>
 	{ 0x50, 0x1e }, { 0x51, 0x5d },
 	{ 0x50, 0x22 }, { 0x51, 0x00 },
 	{ 0x50, 0x23 }, { 0x51, 0xc8 },
<span class="p_chunk">@@ -196,9 +190,7 @@</span> <span class="p_context"> static struct regdata mb86a20s_init2[] = {</span>
 	{ 0x50, 0x26 }, { 0x51, 0x00 },
 	{ 0x50, 0x27 }, { 0x51, 0xc3 },
 	{ 0x50, 0x39 }, { 0x51, 0x02 },
<span class="p_del">-	{ 0xec, 0x0f },</span>
<span class="p_del">-	{ 0xeb, 0x1f },</span>
<span class="p_del">-	{ 0x28, 0x6a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x00 },</span>
<span class="p_add">+	{ 0x50, 0xd5 }, { 0x51, 0x01 },</span>
 	{ 0xd0, 0x00 },
 };
 
<span class="p_chunk">@@ -317,7 +309,11 @@</span> <span class="p_context"> static int mb86a20s_read_status(struct dvb_frontend *fe, enum fe_status *status)</span>
 	if (val &gt;= 7)
 		*status |= FE_HAS_SYNC;
 
<span class="p_del">-	if (val &gt;= 8)				/* Maybe 9? */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Actually, on state S8, it starts receiving TS, but the TS</span>
<span class="p_add">+	 * output is only on normal state after the transition to S9.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (val &gt;= 9)</span>
 		*status |= FE_HAS_LOCK;
 
 	dev_dbg(&amp;state-&gt;i2c-&gt;dev, &quot;%s: Status = 0x%02x (state = %d)\n&quot;,
<span class="p_chunk">@@ -2067,6 +2063,11 @@</span> <span class="p_context"> static void mb86a20s_release(struct dvb_frontend *fe)</span>
 	kfree(state);
 }
 
<span class="p_add">+static int mb86a20s_get_frontend_algo(struct dvb_frontend *fe)</span>
<span class="p_add">+{</span>
<span class="p_add">+        return DVBFE_ALGO_HW;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct dvb_frontend_ops mb86a20s_ops;
 
 struct dvb_frontend *mb86a20s_attach(const struct mb86a20s_config *config,
<span class="p_chunk">@@ -2140,6 +2141,7 @@</span> <span class="p_context"> static struct dvb_frontend_ops mb86a20s_ops = {</span>
 	.read_status = mb86a20s_read_status_and_stats,
 	.read_signal_strength = mb86a20s_read_signal_strength_from_cache,
 	.tune = mb86a20s_tune,
<span class="p_add">+	.get_frontend_algo = mb86a20s_get_frontend_algo,</span>
 };
 
 MODULE_DESCRIPTION(&quot;DVB Frontend module for Fujitsu mb86A20s hardware&quot;);
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-avcore.c b/drivers/media/usb/cx231xx/cx231xx-avcore.c</span>
<span class="p_header">index 491913778bcc..2f52d66b4dae 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-avcore.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-avcore.c</span>
<span class="p_chunk">@@ -1264,7 +1264,10 @@</span> <span class="p_context"> int cx231xx_set_agc_analog_digital_mux_select(struct cx231xx *dev,</span>
 				   dev-&gt;board.agc_analog_digital_select_gpio,
 				   analog_or_digital);
 
<span class="p_del">-	return status;</span>
<span class="p_add">+	if (status &lt; 0)</span>
<span class="p_add">+		return status;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 int cx231xx_enable_i2c_port_3(struct cx231xx *dev, bool is_port_3)
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-cards.c b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">index 4a117a58c39a..8389c162bc89 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_chunk">@@ -486,7 +486,7 @@</span> <span class="p_context"> struct cx231xx_board cx231xx_boards[] = {</span>
 		.output_mode = OUT_MODE_VIP11,
 		.demod_xfer_mode = 0,
 		.ctl_pin_status_mask = 0xFFFFFFC4,
<span class="p_del">-		.agc_analog_digital_select_gpio = 0x00,	/* According with PV cxPolaris.inf file */</span>
<span class="p_add">+		.agc_analog_digital_select_gpio = 0x1c,</span>
 		.tuner_sif_gpio = -1,
 		.tuner_scl_gpio = -1,
 		.tuner_sda_gpio = -1,
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-core.c b/drivers/media/usb/cx231xx/cx231xx-core.c</span>
<span class="p_header">index a2fd49b6be83..19b0293312a0 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-core.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-core.c</span>
<span class="p_chunk">@@ -712,6 +712,7 @@</span> <span class="p_context"> int cx231xx_set_mode(struct cx231xx *dev, enum cx231xx_mode set_mode)</span>
 			break;
 		case CX231XX_BOARD_CNXT_RDE_253S:
 		case CX231XX_BOARD_CNXT_RDU_253S:
<span class="p_add">+		case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:</span>
 			errCode = cx231xx_set_agc_analog_digital_mux_select(dev, 1);
 			break;
 		case CX231XX_BOARD_HAUPPAUGE_EXETER:
<span class="p_chunk">@@ -738,7 +739,7 @@</span> <span class="p_context"> int cx231xx_set_mode(struct cx231xx *dev, enum cx231xx_mode set_mode)</span>
 		case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:
 		case CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:
 		case CX231XX_BOARD_HAUPPAUGE_USB2_FM_NTSC:
<span class="p_del">-		errCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);</span>
<span class="p_add">+			errCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);</span>
 			break;
 		default:
 			break;
<span class="p_header">diff --git a/drivers/memstick/host/rtsx_usb_ms.c b/drivers/memstick/host/rtsx_usb_ms.c</span>
<span class="p_header">index 1105db2355d2..83bfb1659abe 100644</span>
<span class="p_header">--- a/drivers/memstick/host/rtsx_usb_ms.c</span>
<span class="p_header">+++ b/drivers/memstick/host/rtsx_usb_ms.c</span>
<span class="p_chunk">@@ -524,6 +524,7 @@</span> <span class="p_context"> static void rtsx_usb_ms_handle_req(struct work_struct *work)</span>
 	int rc;
 
 	if (!host-&gt;req) {
<span class="p_add">+		pm_runtime_get_sync(ms_dev(host));</span>
 		do {
 			rc = memstick_next_req(msh, &amp;host-&gt;req);
 			dev_dbg(ms_dev(host), &quot;next req %d\n&quot;, rc);
<span class="p_chunk">@@ -544,6 +545,7 @@</span> <span class="p_context"> static void rtsx_usb_ms_handle_req(struct work_struct *work)</span>
 						host-&gt;req-&gt;error);
 			}
 		} while (!rc);
<span class="p_add">+		pm_runtime_put(ms_dev(host));</span>
 	}
 
 }
<span class="p_chunk">@@ -570,6 +572,7 @@</span> <span class="p_context"> static int rtsx_usb_ms_set_param(struct memstick_host *msh,</span>
 	dev_dbg(ms_dev(host), &quot;%s: param = %d, value = %d\n&quot;,
 			__func__, param, value);
 
<span class="p_add">+	pm_runtime_get_sync(ms_dev(host));</span>
 	mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 	err = rtsx_usb_card_exclusive_check(ucr, RTSX_USB_MS_CARD);
<span class="p_chunk">@@ -635,6 +638,7 @@</span> <span class="p_context"> static int rtsx_usb_ms_set_param(struct memstick_host *msh,</span>
 	}
 out:
 	mutex_unlock(&amp;ucr-&gt;dev_mutex);
<span class="p_add">+	pm_runtime_put(ms_dev(host));</span>
 
 	/* power-on delay */
 	if (param == MEMSTICK_POWER &amp;&amp; value == MEMSTICK_POWER_ON)
<span class="p_chunk">@@ -681,6 +685,7 @@</span> <span class="p_context"> static int rtsx_usb_detect_ms_card(void *__host)</span>
 	int err;
 
 	for (;;) {
<span class="p_add">+		pm_runtime_get_sync(ms_dev(host));</span>
 		mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 		/* Check pending MS card changes */
<span class="p_chunk">@@ -703,6 +708,7 @@</span> <span class="p_context"> static int rtsx_usb_detect_ms_card(void *__host)</span>
 		}
 
 poll_again:
<span class="p_add">+		pm_runtime_put(ms_dev(host));</span>
 		if (host-&gt;eject)
 			break;
 
<span class="p_header">diff --git a/drivers/misc/mei/hw-me-regs.h b/drivers/misc/mei/hw-me-regs.h</span>
<span class="p_header">index a8a68acd3267..4e8069866c85 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hw-me-regs.h</span>
<span class="p_header">+++ b/drivers/misc/mei/hw-me-regs.h</span>
<span class="p_chunk">@@ -66,6 +66,9 @@</span> <span class="p_context"></span>
 #ifndef _MEI_HW_MEI_REGS_H_
 #define _MEI_HW_MEI_REGS_H_
 
<span class="p_add">+#define MEI_DEV_ID_KBP        0xA2BA  /* Kaby Point */</span>
<span class="p_add">+#define MEI_DEV_ID_KBP_2      0xA2BB  /* Kaby Point 2 */</span>
<span class="p_add">+</span>
 /*
  * MEI device IDs
  */
<span class="p_header">diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c</span>
<span class="p_header">index 27678d8154e0..0af3d7d30419 100644</span>
<span class="p_header">--- a/drivers/misc/mei/pci-me.c</span>
<span class="p_header">+++ b/drivers/misc/mei/pci-me.c</span>
<span class="p_chunk">@@ -87,6 +87,9 @@</span> <span class="p_context"> static const struct pci_device_id mei_me_pci_tbl[] = {</span>
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H, mei_me_pch8_cfg)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H_2, mei_me_pch8_cfg)},
 
<span class="p_add">+	{MEI_PCI_DEVICE(MEI_DEV_ID_KBP, mei_me_pch8_cfg)},</span>
<span class="p_add">+	{MEI_PCI_DEVICE(MEI_DEV_ID_KBP_2, mei_me_pch8_cfg)},</span>
<span class="p_add">+</span>
 	/* required last entry */
 	{0, }
 };
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 64950035613b..f2b733275a0a 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1755,7 +1755,7 @@</span> <span class="p_context"> static void mmc_blk_packed_hdr_wrq_prep(struct mmc_queue_req *mqrq,</span>
 	struct mmc_blk_data *md = mq-&gt;data;
 	struct mmc_packed *packed = mqrq-&gt;packed;
 	bool do_rel_wr, do_data_tag;
<span class="p_del">-	u32 *packed_cmd_hdr;</span>
<span class="p_add">+	__le32 *packed_cmd_hdr;</span>
 	u8 hdr_blocks;
 	u8 i = 1;
 
<span class="p_chunk">@@ -2279,7 +2279,8 @@</span> <span class="p_context"> static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,</span>
 	set_capacity(md-&gt;disk, size);
 
 	if (mmc_host_cmd23(card-&gt;host)) {
<span class="p_del">-		if (mmc_card_mmc(card) ||</span>
<span class="p_add">+		if ((mmc_card_mmc(card) &amp;&amp;</span>
<span class="p_add">+		     card-&gt;csd.mmca_vsn &gt;= CSD_SPEC_VER_3) ||</span>
 		    (mmc_card_sd(card) &amp;&amp;
 		     card-&gt;scr.cmds &amp; SD_SCR_CMD23_SUPPORT))
 			md-&gt;flags |= MMC_BLK_CMD23;
<span class="p_header">diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h</span>
<span class="p_header">index 36cddab57d77..cf30b3712cb2 100644</span>
<span class="p_header">--- a/drivers/mmc/card/queue.h</span>
<span class="p_header">+++ b/drivers/mmc/card/queue.h</span>
<span class="p_chunk">@@ -25,7 +25,7 @@</span> <span class="p_context"> enum mmc_packed_type {</span>
 
 struct mmc_packed {
 	struct list_head	list;
<span class="p_del">-	u32			cmd_hdr[1024];</span>
<span class="p_add">+	__le32			cmd_hdr[1024];</span>
 	unsigned int		blocks;
 	u8			nr_entries;
 	u8			retries;
<span class="p_header">diff --git a/drivers/mmc/host/rtsx_usb_sdmmc.c b/drivers/mmc/host/rtsx_usb_sdmmc.c</span>
<span class="p_header">index 6c71fc9f76c7..da9f71b8deb0 100644</span>
<span class="p_header">--- a/drivers/mmc/host/rtsx_usb_sdmmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/rtsx_usb_sdmmc.c</span>
<span class="p_chunk">@@ -1138,11 +1138,6 @@</span> <span class="p_context"> static void sdmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 	dev_dbg(sdmmc_dev(host), &quot;%s\n&quot;, __func__);
 	mutex_lock(&amp;ucr-&gt;dev_mutex);
 
<span class="p_del">-	if (rtsx_usb_card_exclusive_check(ucr, RTSX_USB_SD_CARD)) {</span>
<span class="p_del">-		mutex_unlock(&amp;ucr-&gt;dev_mutex);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	sd_set_power_mode(host, ios-&gt;power_mode);
 	sd_set_bus_width(host, ios-&gt;bus_width);
 	sd_set_timing(host, ios-&gt;timing, &amp;host-&gt;ddr_mode);
<span class="p_chunk">@@ -1314,6 +1309,7 @@</span> <span class="p_context"> static void rtsx_usb_update_led(struct work_struct *work)</span>
 		container_of(work, struct rtsx_usb_sdmmc, led_work);
 	struct rtsx_ucr *ucr = host-&gt;ucr;
 
<span class="p_add">+	pm_runtime_get_sync(sdmmc_dev(host));</span>
 	mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 	if (host-&gt;led.brightness == LED_OFF)
<span class="p_chunk">@@ -1322,6 +1318,7 @@</span> <span class="p_context"> static void rtsx_usb_update_led(struct work_struct *work)</span>
 		rtsx_usb_turn_on_led(ucr);
 
 	mutex_unlock(&amp;ucr-&gt;dev_mutex);
<span class="p_add">+	pm_runtime_put(sdmmc_dev(host));</span>
 }
 #endif
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index 552a34dc4f82..64a428984afe 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -675,7 +675,7 @@</span> <span class="p_context"> static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_command *cmd)</span>
 			 * host-&gt;clock is in Hz.  target_timeout is in us.
 			 * Hence, us = 1000000 * cycles / Hz.  Round up.
 			 */
<span class="p_del">-			val = 1000000 * data-&gt;timeout_clks;</span>
<span class="p_add">+			val = 1000000ULL * data-&gt;timeout_clks;</span>
 			if (do_div(val, host-&gt;clock))
 				target_timeout++;
 			target_timeout += val;
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index 56065632a5b8..75286588b823 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -643,7 +643,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int shutdown)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, lnum = -1;</span>
<span class="p_add">+	int erase = 0, keep = 0, vol_id = -1, lnum = -1;</span>
 #ifdef CONFIG_MTD_UBI_FASTMAP
 	int anchor = wrk-&gt;anchor;
 #endif
<span class="p_chunk">@@ -777,6 +777,16 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 			       e1-&gt;pnum);
 			scrubbing = 1;
 			goto out_not_moved;
<span class="p_add">+		} else if (ubi-&gt;fast_attach &amp;&amp; err == UBI_IO_BAD_HDR_EBADMSG) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * While a full scan would detect interrupted erasures</span>
<span class="p_add">+			 * at attach time we can face them here when attached from</span>
<span class="p_add">+			 * Fastmap.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			dbg_wl(&quot;PEB %d has ECC errors, maybe from an interrupted erasure&quot;,</span>
<span class="p_add">+			       e1-&gt;pnum);</span>
<span class="p_add">+			erase = 1;</span>
<span class="p_add">+			goto out_not_moved;</span>
 		}
 
 		ubi_err(ubi, &quot;error %d while reading VID header from PEB %d&quot;,
<span class="p_chunk">@@ -810,6 +820,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 			 * Target PEB had bit-flips or write error - torture it.
 			 */
 			torture = 1;
<span class="p_add">+			keep = 1;</span>
 			goto out_not_moved;
 		}
 
<span class="p_chunk">@@ -895,7 +906,7 @@</span> <span class="p_context"> out_not_moved:</span>
 		ubi-&gt;erroneous_peb_count += 1;
 	} else if (scrubbing)
 		wl_tree_add(e1, &amp;ubi-&gt;scrub);
<span class="p_del">-	else</span>
<span class="p_add">+	else if (keep)</span>
 		wl_tree_add(e1, &amp;ubi-&gt;used);
 	ubi_assert(!ubi-&gt;move_to_put);
 	ubi-&gt;move_from = ubi-&gt;move_to = NULL;
<span class="p_chunk">@@ -907,6 +918,12 @@</span> <span class="p_context"> out_not_moved:</span>
 	if (err)
 		goto out_ro;
 
<span class="p_add">+	if (erase) {</span>
<span class="p_add">+		err = do_sync_erase(ubi, e1, vol_id, lnum, 1);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_ro;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;ubi-&gt;move_mutex);
 	return 0;
 
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">index 2e611dc5f162..1c8123816745 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_chunk">@@ -14819,6 +14819,10 @@</span> <span class="p_context"> static int bnx2x_get_fc_npiv(struct net_device *dev,</span>
 	}
 
 	offset = SHMEM2_RD(bp, fc_npiv_nvram_tbl_addr[BP_PORT(bp)]);
<span class="p_add">+	if (!offset) {</span>
<span class="p_add">+		DP(BNX2X_MSG_MCP, &quot;No FC-NPIV in NVRAM\n&quot;);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 	DP(BNX2X_MSG_MCP, &quot;Offset of FC-NPIV in NVRAM: %08x\n&quot;, offset);
 
 	/* Read the table contents from nvram */
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">index 67e9633ea9c7..232191417b93 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_chunk">@@ -2282,7 +2282,7 @@</span> <span class="p_context"> static int mlx4_en_set_vf_mac(struct net_device *dev, int queue, u8 *mac)</span>
 	struct mlx4_en_dev *mdev = en_priv-&gt;mdev;
 	u64 mac_u64 = mlx4_mac_to_u64(mac);
 
<span class="p_del">-	if (!is_valid_ether_addr(mac))</span>
<span class="p_add">+	if (is_multicast_ether_addr(mac))</span>
 		return -EINVAL;
 
 	return mlx4_set_vf_mac(mdev-&gt;dev, en_priv-&gt;port, queue, mac_u64);
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/regd.c b/drivers/net/wireless/realtek/rtlwifi/regd.c</span>
<span class="p_header">index 5be34118e0af..f67e7e5b13e1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/regd.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/regd.c</span>
<span class="p_chunk">@@ -345,9 +345,9 @@</span> <span class="p_context"> static const struct ieee80211_regdomain *_rtl_regdomain_select(</span>
 		return &amp;rtl_regdom_no_midband;
 	case COUNTRY_CODE_IC:
 		return &amp;rtl_regdom_11;
<span class="p_del">-	case COUNTRY_CODE_ETSI:</span>
 	case COUNTRY_CODE_TELEC_NETGEAR:
 		return &amp;rtl_regdom_60_64;
<span class="p_add">+	case COUNTRY_CODE_ETSI:</span>
 	case COUNTRY_CODE_SPAIN:
 	case COUNTRY_CODE_FRANCE:
 	case COUNTRY_CODE_ISRAEL:
<span class="p_chunk">@@ -406,6 +406,8 @@</span> <span class="p_context"> static u8 channel_plan_to_country_code(u8 channelplan)</span>
 		return COUNTRY_CODE_WORLD_WIDE_13;
 	case 0x22:
 		return COUNTRY_CODE_IC;
<span class="p_add">+	case 0x25:</span>
<span class="p_add">+		return COUNTRY_CODE_ETSI;</span>
 	case 0x32:
 		return COUNTRY_CODE_TELEC_NETGEAR;
 	case 0x41:
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 42774bc39786..254192b5dad1 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -3136,6 +3136,7 @@</span> <span class="p_context"> static void quirk_no_bus_reset(struct pci_dev *dev)</span>
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0030, quirk_no_bus_reset);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0032, quirk_no_bus_reset);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x003c, quirk_no_bus_reset);
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0033, quirk_no_bus_reset);</span>
 
 static void quirk_no_pm_reset(struct pci_dev *dev)
 {
<span class="p_header">diff --git a/drivers/regulator/tps65910-regulator.c b/drivers/regulator/tps65910-regulator.c</span>
<span class="p_header">index fb991ec76423..696116ebdf50 100644</span>
<span class="p_header">--- a/drivers/regulator/tps65910-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/tps65910-regulator.c</span>
<span class="p_chunk">@@ -1111,6 +1111,12 @@</span> <span class="p_context"> static int tps65910_probe(struct platform_device *pdev)</span>
 		pmic-&gt;num_regulators = ARRAY_SIZE(tps65910_regs);
 		pmic-&gt;ext_sleep_control = tps65910_ext_sleep_control;
 		info = tps65910_regs;
<span class="p_add">+		/* Work around silicon erratum SWCZ010: output programmed</span>
<span class="p_add">+		 * voltage level can go higher than expected or crash</span>
<span class="p_add">+		 * Workaround: use no synchronization of DCDC clocks</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tps65910_reg_clear_bits(pmic-&gt;mfd, TPS65910_DCDCCTRL,</span>
<span class="p_add">+					DCDCCTRL_DCDCCKSYNC_MASK);</span>
 		break;
 	case TPS65911:
 		pmic-&gt;get_ctrl_reg = &amp;tps65911_get_ctrl_register;
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.c b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">index 5d7fbe4e907e..581001989937 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Debug traces for zfcp.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2013</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2016</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> void zfcp_dbf_pl_write(struct zfcp_dbf *dbf, void *data, u16 length, char *area,</span>
  * @tag: tag indicating which kind of unsolicited status has been received
  * @req: request for which a response was received
  */
<span class="p_del">-void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)</span>
<span class="p_add">+void zfcp_dbf_hba_fsf_res(char *tag, int level, struct zfcp_fsf_req *req)</span>
 {
 	struct zfcp_dbf *dbf = req-&gt;adapter-&gt;dbf;
 	struct fsf_qtcb_prefix *q_pref = &amp;req-&gt;qtcb-&gt;prefix;
<span class="p_chunk">@@ -85,6 +85,8 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)</span>
 	rec-&gt;u.res.req_issued = req-&gt;issued;
 	rec-&gt;u.res.prot_status = q_pref-&gt;prot_status;
 	rec-&gt;u.res.fsf_status = q_head-&gt;fsf_status;
<span class="p_add">+	rec-&gt;u.res.port_handle = q_head-&gt;port_handle;</span>
<span class="p_add">+	rec-&gt;u.res.lun_handle = q_head-&gt;lun_handle;</span>
 
 	memcpy(rec-&gt;u.res.prot_status_qual, &amp;q_pref-&gt;prot_status_qual,
 	       FSF_PROT_STATUS_QUAL_SIZE);
<span class="p_chunk">@@ -97,7 +99,7 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)</span>
 				  rec-&gt;pl_len, &quot;fsf_res&quot;, req-&gt;req_id);
 	}
 
<span class="p_del">-	debug_event(dbf-&gt;hba, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	debug_event(dbf-&gt;hba, level, rec, sizeof(*rec));</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;hba_lock, flags);
 }
 
<span class="p_chunk">@@ -241,7 +243,8 @@</span> <span class="p_context"> static void zfcp_dbf_set_common(struct zfcp_dbf_rec *rec,</span>
 	if (sdev) {
 		rec-&gt;lun_status = atomic_read(&amp;sdev_to_zfcp(sdev)-&gt;status);
 		rec-&gt;lun = zfcp_scsi_dev_lun(sdev);
<span class="p_del">-	}</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		rec-&gt;lun = ZFCP_DBF_INVALID_LUN;</span>
 }
 
 /**
<span class="p_chunk">@@ -320,13 +323,48 @@</span> <span class="p_context"> void zfcp_dbf_rec_run(char *tag, struct zfcp_erp_action *erp)</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;rec_lock, flags);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * zfcp_dbf_rec_run_wka - trace wka port event with info like running recovery</span>
<span class="p_add">+ * @tag: identifier for event</span>
<span class="p_add">+ * @wka_port: well known address port</span>
<span class="p_add">+ * @req_id: request ID to correlate with potential HBA trace record</span>
<span class="p_add">+ */</span>
<span class="p_add">+void zfcp_dbf_rec_run_wka(char *tag, struct zfcp_fc_wka_port *wka_port,</span>
<span class="p_add">+			  u64 req_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zfcp_dbf *dbf = wka_port-&gt;adapter-&gt;dbf;</span>
<span class="p_add">+	struct zfcp_dbf_rec *rec = &amp;dbf-&gt;rec_buf;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dbf-&gt;rec_lock, flags);</span>
<span class="p_add">+	memset(rec, 0, sizeof(*rec));</span>
<span class="p_add">+</span>
<span class="p_add">+	rec-&gt;id = ZFCP_DBF_REC_RUN;</span>
<span class="p_add">+	memcpy(rec-&gt;tag, tag, ZFCP_DBF_TAG_LEN);</span>
<span class="p_add">+	rec-&gt;port_status = wka_port-&gt;status;</span>
<span class="p_add">+	rec-&gt;d_id = wka_port-&gt;d_id;</span>
<span class="p_add">+	rec-&gt;lun = ZFCP_DBF_INVALID_LUN;</span>
<span class="p_add">+</span>
<span class="p_add">+	rec-&gt;u.run.fsf_req_id = req_id;</span>
<span class="p_add">+	rec-&gt;u.run.rec_status = ~0;</span>
<span class="p_add">+	rec-&gt;u.run.rec_step = ~0;</span>
<span class="p_add">+	rec-&gt;u.run.rec_action = ~0;</span>
<span class="p_add">+	rec-&gt;u.run.rec_count = ~0;</span>
<span class="p_add">+</span>
<span class="p_add">+	debug_event(dbf-&gt;rec, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dbf-&gt;rec_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline
<span class="p_del">-void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf, void *data, u8 id, u16 len,</span>
<span class="p_del">-		  u64 req_id, u32 d_id)</span>
<span class="p_add">+void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf,</span>
<span class="p_add">+		  char *paytag, struct scatterlist *sg, u8 id, u16 len,</span>
<span class="p_add">+		  u64 req_id, u32 d_id, u16 cap_len)</span>
 {
 	struct zfcp_dbf_san *rec = &amp;dbf-&gt;san_buf;
 	u16 rec_len;
 	unsigned long flags;
<span class="p_add">+	struct zfcp_dbf_pay *payload = &amp;dbf-&gt;pay_buf;</span>
<span class="p_add">+	u16 pay_sum = 0;</span>
 
 	spin_lock_irqsave(&amp;dbf-&gt;san_lock, flags);
 	memset(rec, 0, sizeof(*rec));
<span class="p_chunk">@@ -334,10 +372,41 @@</span> <span class="p_context"> void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf, void *data, u8 id, u16 len,</span>
 	rec-&gt;id = id;
 	rec-&gt;fsf_req_id = req_id;
 	rec-&gt;d_id = d_id;
<span class="p_del">-	rec_len = min(len, (u16)ZFCP_DBF_SAN_MAX_PAYLOAD);</span>
<span class="p_del">-	memcpy(rec-&gt;payload, data, rec_len);</span>
 	memcpy(rec-&gt;tag, tag, ZFCP_DBF_TAG_LEN);
<span class="p_add">+	rec-&gt;pl_len = len; /* full length even if we cap pay below */</span>
<span class="p_add">+	if (!sg)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	rec_len = min_t(unsigned int, sg-&gt;length, ZFCP_DBF_SAN_MAX_PAYLOAD);</span>
<span class="p_add">+	memcpy(rec-&gt;payload, sg_virt(sg), rec_len); /* part of 1st sg entry */</span>
<span class="p_add">+	if (len &lt;= rec_len)</span>
<span class="p_add">+		goto out; /* skip pay record if full content in rec-&gt;payload */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if (len &gt; rec_len):</span>
<span class="p_add">+	 * dump data up to cap_len ignoring small duplicate in rec-&gt;payload</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock(&amp;dbf-&gt;pay_lock);</span>
<span class="p_add">+	memset(payload, 0, sizeof(*payload));</span>
<span class="p_add">+	memcpy(payload-&gt;area, paytag, ZFCP_DBF_TAG_LEN);</span>
<span class="p_add">+	payload-&gt;fsf_req_id = req_id;</span>
<span class="p_add">+	payload-&gt;counter = 0;</span>
<span class="p_add">+	for (; sg &amp;&amp; pay_sum &lt; cap_len; sg = sg_next(sg)) {</span>
<span class="p_add">+		u16 pay_len, offset = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		while (offset &lt; sg-&gt;length &amp;&amp; pay_sum &lt; cap_len) {</span>
<span class="p_add">+			pay_len = min((u16)ZFCP_DBF_PAY_MAX_REC,</span>
<span class="p_add">+				      (u16)(sg-&gt;length - offset));</span>
<span class="p_add">+			/* cap_len &lt;= pay_sum &lt; cap_len+ZFCP_DBF_PAY_MAX_REC */</span>
<span class="p_add">+			memcpy(payload-&gt;data, sg_virt(sg) + offset, pay_len);</span>
<span class="p_add">+			debug_event(dbf-&gt;pay, 1, payload,</span>
<span class="p_add">+				    zfcp_dbf_plen(pay_len));</span>
<span class="p_add">+			payload-&gt;counter++;</span>
<span class="p_add">+			offset += pay_len;</span>
<span class="p_add">+			pay_sum += pay_len;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock(&amp;dbf-&gt;pay_lock);</span>
 
<span class="p_add">+out:</span>
 	debug_event(dbf-&gt;san, 1, rec, sizeof(*rec));
 	spin_unlock_irqrestore(&amp;dbf-&gt;san_lock, flags);
 }
<span class="p_chunk">@@ -354,9 +423,62 @@</span> <span class="p_context"> void zfcp_dbf_san_req(char *tag, struct zfcp_fsf_req *fsf, u32 d_id)</span>
 	struct zfcp_fsf_ct_els *ct_els = fsf-&gt;data;
 	u16 length;
 
<span class="p_del">-	length = (u16)(ct_els-&gt;req-&gt;length + FC_CT_HDR_LEN);</span>
<span class="p_del">-	zfcp_dbf_san(tag, dbf, sg_virt(ct_els-&gt;req), ZFCP_DBF_SAN_REQ, length,</span>
<span class="p_del">-		     fsf-&gt;req_id, d_id);</span>
<span class="p_add">+	length = (u16)zfcp_qdio_real_bytes(ct_els-&gt;req);</span>
<span class="p_add">+	zfcp_dbf_san(tag, dbf, &quot;san_req&quot;, ct_els-&gt;req, ZFCP_DBF_SAN_REQ,</span>
<span class="p_add">+		     length, fsf-&gt;req_id, d_id, length);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,</span>
<span class="p_add">+					      struct zfcp_fsf_req *fsf,</span>
<span class="p_add">+					      u16 len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zfcp_fsf_ct_els *ct_els = fsf-&gt;data;</span>
<span class="p_add">+	struct fc_ct_hdr *reqh = sg_virt(ct_els-&gt;req);</span>
<span class="p_add">+	struct fc_ns_gid_ft *reqn = (struct fc_ns_gid_ft *)(reqh + 1);</span>
<span class="p_add">+	struct scatterlist *resp_entry = ct_els-&gt;resp;</span>
<span class="p_add">+	struct fc_gpn_ft_resp *acc;</span>
<span class="p_add">+	int max_entries, x, last = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(memcmp(tag, &quot;fsscth2&quot;, 7) == 0</span>
<span class="p_add">+	      &amp;&amp; ct_els-&gt;d_id == FC_FID_DIR_SERV</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_rev == FC_CT_REV</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_in_id[0] == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_in_id[1] == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_in_id[2] == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_fs_type == FC_FST_DIR</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_fs_subtype == FC_NS_SUBTYPE</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_options == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;_ct_resvd1 == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_cmd == FC_NS_GPN_FT</span>
<span class="p_add">+	      /* reqh-&gt;ct_mr_size can vary so do not match but read below */</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;_ct_resvd2 == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_reason == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_explan == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_vendor == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_resvd == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_domain_id_scope == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_area_id_scope == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_fc4_type == FC_TYPE_FCP))</span>
<span class="p_add">+		return len; /* not GPN_FT response so do not cap */</span>
<span class="p_add">+</span>
<span class="p_add">+	acc = sg_virt(resp_entry);</span>
<span class="p_add">+	max_entries = (reqh-&gt;ct_mr_size * 4 / sizeof(struct fc_gpn_ft_resp))</span>
<span class="p_add">+		+ 1 /* zfcp_fc_scan_ports: bytes correct, entries off-by-one</span>
<span class="p_add">+		     * to account for header as 1st pseudo &quot;entry&quot; */;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* the basic CT_IU preamble is the same size as one entry in the GPN_FT</span>
<span class="p_add">+	 * response, allowing us to skip special handling for it - just skip it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (x = 1; x &lt; max_entries &amp;&amp; !last; x++) {</span>
<span class="p_add">+		if (x % (ZFCP_FC_GPN_FT_ENT_PAGE + 1))</span>
<span class="p_add">+			acc++;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			acc = sg_virt(++resp_entry);</span>
<span class="p_add">+</span>
<span class="p_add">+		last = acc-&gt;fp_flags &amp; FC_NS_FID_LAST;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	len = min(len, (u16)(x * sizeof(struct fc_gpn_ft_resp)));</span>
<span class="p_add">+	return len; /* cap after last entry */</span>
 }
 
 /**
<span class="p_chunk">@@ -370,9 +492,10 @@</span> <span class="p_context"> void zfcp_dbf_san_res(char *tag, struct zfcp_fsf_req *fsf)</span>
 	struct zfcp_fsf_ct_els *ct_els = fsf-&gt;data;
 	u16 length;
 
<span class="p_del">-	length = (u16)(ct_els-&gt;resp-&gt;length + FC_CT_HDR_LEN);</span>
<span class="p_del">-	zfcp_dbf_san(tag, dbf, sg_virt(ct_els-&gt;resp), ZFCP_DBF_SAN_RES, length,</span>
<span class="p_del">-		     fsf-&gt;req_id, 0);</span>
<span class="p_add">+	length = (u16)zfcp_qdio_real_bytes(ct_els-&gt;resp);</span>
<span class="p_add">+	zfcp_dbf_san(tag, dbf, &quot;san_res&quot;, ct_els-&gt;resp, ZFCP_DBF_SAN_RES,</span>
<span class="p_add">+		     length, fsf-&gt;req_id, ct_els-&gt;d_id,</span>
<span class="p_add">+		     zfcp_dbf_san_res_cap_len_if_gpn_ft(tag, fsf, length));</span>
 }
 
 /**
<span class="p_chunk">@@ -386,11 +509,13 @@</span> <span class="p_context"> void zfcp_dbf_san_in_els(char *tag, struct zfcp_fsf_req *fsf)</span>
 	struct fsf_status_read_buffer *srb =
 		(struct fsf_status_read_buffer *) fsf-&gt;data;
 	u16 length;
<span class="p_add">+	struct scatterlist sg;</span>
 
 	length = (u16)(srb-&gt;length -
 			offsetof(struct fsf_status_read_buffer, payload));
<span class="p_del">-	zfcp_dbf_san(tag, dbf, srb-&gt;payload.data, ZFCP_DBF_SAN_ELS, length,</span>
<span class="p_del">-		     fsf-&gt;req_id, ntoh24(srb-&gt;d_id));</span>
<span class="p_add">+	sg_init_one(&amp;sg, srb-&gt;payload.data, length);</span>
<span class="p_add">+	zfcp_dbf_san(tag, dbf, &quot;san_els&quot;, &amp;sg, ZFCP_DBF_SAN_ELS, length,</span>
<span class="p_add">+		     fsf-&gt;req_id, ntoh24(srb-&gt;d_id), length);</span>
 }
 
 /**
<span class="p_chunk">@@ -399,7 +524,8 @@</span> <span class="p_context"> void zfcp_dbf_san_in_els(char *tag, struct zfcp_fsf_req *fsf)</span>
  * @sc: pointer to struct scsi_cmnd
  * @fsf: pointer to struct zfcp_fsf_req
  */
<span class="p_del">-void zfcp_dbf_scsi(char *tag, struct scsi_cmnd *sc, struct zfcp_fsf_req *fsf)</span>
<span class="p_add">+void zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *sc,</span>
<span class="p_add">+		   struct zfcp_fsf_req *fsf)</span>
 {
 	struct zfcp_adapter *adapter =
 		(struct zfcp_adapter *) sc-&gt;device-&gt;host-&gt;hostdata[0];
<span class="p_chunk">@@ -442,7 +568,7 @@</span> <span class="p_context"> void zfcp_dbf_scsi(char *tag, struct scsi_cmnd *sc, struct zfcp_fsf_req *fsf)</span>
 		}
 	}
 
<span class="p_del">-	debug_event(dbf-&gt;scsi, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	debug_event(dbf-&gt;scsi, level, rec, sizeof(*rec));</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;scsi_lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">index 0be3d48681ae..36d07584271d 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
  * zfcp device driver
  * debug feature declarations
  *
<span class="p_del">- * Copyright IBM Corp. 2008, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2008, 2015</span>
  */
 
 #ifndef ZFCP_DBF_H
<span class="p_chunk">@@ -17,6 +17,11 @@</span> <span class="p_context"></span>
 
 #define ZFCP_DBF_INVALID_LUN	0xFFFFFFFFFFFFFFFFull
 
<span class="p_add">+enum zfcp_dbf_pseudo_erp_act_type {</span>
<span class="p_add">+	ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD = 0xff,</span>
<span class="p_add">+	ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL = 0xfe,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /**
  * struct zfcp_dbf_rec_trigger - trace record for triggered recovery action
  * @ready: number of ready recovery actions
<span class="p_chunk">@@ -110,6 +115,7 @@</span> <span class="p_context"> struct zfcp_dbf_san {</span>
 	u32 d_id;
 #define ZFCP_DBF_SAN_MAX_PAYLOAD (FC_CT_HDR_LEN + 32)
 	char payload[ZFCP_DBF_SAN_MAX_PAYLOAD];
<span class="p_add">+	u16 pl_len;</span>
 } __packed;
 
 /**
<span class="p_chunk">@@ -126,6 +132,8 @@</span> <span class="p_context"> struct zfcp_dbf_hba_res {</span>
 	u8  prot_status_qual[FSF_PROT_STATUS_QUAL_SIZE];
 	u32 fsf_status;
 	u8  fsf_status_qual[FSF_STATUS_QUALIFIER_SIZE];
<span class="p_add">+	u32 port_handle;</span>
<span class="p_add">+	u32 lun_handle;</span>
 } __packed;
 
 /**
<span class="p_chunk">@@ -279,7 +287,7 @@</span> <span class="p_context"> static inline</span>
 void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 {
 	if (debug_level_enabled(req-&gt;adapter-&gt;dbf-&gt;hba, level))
<span class="p_del">-		zfcp_dbf_hba_fsf_res(tag, req);</span>
<span class="p_add">+		zfcp_dbf_hba_fsf_res(tag, level, req);</span>
 }
 
 /**
<span class="p_chunk">@@ -318,7 +326,7 @@</span> <span class="p_context"> void _zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *scmd,</span>
 					scmd-&gt;device-&gt;host-&gt;hostdata[0];
 
 	if (debug_level_enabled(adapter-&gt;dbf-&gt;scsi, level))
<span class="p_del">-		zfcp_dbf_scsi(tag, scmd, req);</span>
<span class="p_add">+		zfcp_dbf_scsi(tag, level, scmd, req);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_erp.c b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">index 3fb410977014..a59d678125bd 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Error Recovery Procedures (ERP).
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -1217,8 +1217,14 @@</span> <span class="p_context"> static void zfcp_erp_action_cleanup(struct zfcp_erp_action *act, int result)</span>
 		break;
 
 	case ZFCP_ERP_ACTION_REOPEN_PORT:
<span class="p_del">-		if (result == ZFCP_ERP_SUCCEEDED)</span>
<span class="p_del">-			zfcp_scsi_schedule_rport_register(port);</span>
<span class="p_add">+		/* This switch case might also happen after a forced reopen</span>
<span class="p_add">+		 * was successfully done and thus overwritten with a new</span>
<span class="p_add">+		 * non-forced reopen at `ersfs_2&#39;. In this case, we must not</span>
<span class="p_add">+		 * do the clean-up of the non-forced version.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (act-&gt;step != ZFCP_ERP_STEP_UNINITIALIZED)</span>
<span class="p_add">+			if (result == ZFCP_ERP_SUCCEEDED)</span>
<span class="p_add">+				zfcp_scsi_schedule_rport_register(port);</span>
 		/* fall through */
 	case ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:
 		put_device(&amp;port-&gt;dev);
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_ext.h b/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_header">index 5b500652572b..c8fed9fa1cca 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * External function declarations.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #ifndef ZFCP_EXT_H
<span class="p_chunk">@@ -35,8 +35,9 @@</span> <span class="p_context"> extern void zfcp_dbf_adapter_unregister(struct zfcp_adapter *);</span>
 extern void zfcp_dbf_rec_trig(char *, struct zfcp_adapter *,
 			      struct zfcp_port *, struct scsi_device *, u8, u8);
 extern void zfcp_dbf_rec_run(char *, struct zfcp_erp_action *);
<span class="p_add">+extern void zfcp_dbf_rec_run_wka(char *, struct zfcp_fc_wka_port *, u64);</span>
 extern void zfcp_dbf_hba_fsf_uss(char *, struct zfcp_fsf_req *);
<span class="p_del">-extern void zfcp_dbf_hba_fsf_res(char *, struct zfcp_fsf_req *);</span>
<span class="p_add">+extern void zfcp_dbf_hba_fsf_res(char *, int, struct zfcp_fsf_req *);</span>
 extern void zfcp_dbf_hba_bit_err(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_berr(struct zfcp_dbf *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_def_err(struct zfcp_adapter *, u64, u16, void **);
<span class="p_chunk">@@ -44,7 +45,8 @@</span> <span class="p_context"> extern void zfcp_dbf_hba_basic(char *, struct zfcp_adapter *);</span>
 extern void zfcp_dbf_san_req(char *, struct zfcp_fsf_req *, u32);
 extern void zfcp_dbf_san_res(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_san_in_els(char *, struct zfcp_fsf_req *);
<span class="p_del">-extern void zfcp_dbf_scsi(char *, struct scsi_cmnd *, struct zfcp_fsf_req *);</span>
<span class="p_add">+extern void zfcp_dbf_scsi(char *, int, struct scsi_cmnd *,</span>
<span class="p_add">+			  struct zfcp_fsf_req *);</span>
 
 /* zfcp_erp.c */
 extern void zfcp_erp_set_adapter_status(struct zfcp_adapter *, u32);
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.c b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">index 522a633c866a..75f820ca17b7 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Implementation of FSF commands.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2013</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -508,7 +508,10 @@</span> <span class="p_context"> static int zfcp_fsf_exchange_config_evaluate(struct zfcp_fsf_req *req)</span>
 		fc_host_port_type(shost) = FC_PORTTYPE_PTP;
 		break;
 	case FSF_TOPO_FABRIC:
<span class="p_del">-		fc_host_port_type(shost) = FC_PORTTYPE_NPORT;</span>
<span class="p_add">+		if (bottom-&gt;connection_features &amp; FSF_FEATURE_NPIV_MODE)</span>
<span class="p_add">+			fc_host_port_type(shost) = FC_PORTTYPE_NPIV;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			fc_host_port_type(shost) = FC_PORTTYPE_NPORT;</span>
 		break;
 	case FSF_TOPO_AL:
 		fc_host_port_type(shost) = FC_PORTTYPE_NLPORT;
<span class="p_chunk">@@ -613,7 +616,6 @@</span> <span class="p_context"> static void zfcp_fsf_exchange_port_evaluate(struct zfcp_fsf_req *req)</span>
 
 	if (adapter-&gt;connection_features &amp; FSF_FEATURE_NPIV_MODE) {
 		fc_host_permanent_port_name(shost) = bottom-&gt;wwpn;
<span class="p_del">-		fc_host_port_type(shost) = FC_PORTTYPE_NPIV;</span>
 	} else
 		fc_host_permanent_port_name(shost) = fc_host_port_name(shost);
 	fc_host_maxframe_size(shost) = bottom-&gt;maximum_frame_size;
<span class="p_chunk">@@ -982,8 +984,12 @@</span> <span class="p_context"> static int zfcp_fsf_setup_ct_els_sbals(struct zfcp_fsf_req *req,</span>
 	if (zfcp_adapter_multi_buffer_active(adapter)) {
 		if (zfcp_qdio_sbals_from_sg(qdio, &amp;req-&gt;qdio_req, sg_req))
 			return -EIO;
<span class="p_add">+		qtcb-&gt;bottom.support.req_buf_length =</span>
<span class="p_add">+			zfcp_qdio_real_bytes(sg_req);</span>
 		if (zfcp_qdio_sbals_from_sg(qdio, &amp;req-&gt;qdio_req, sg_resp))
 			return -EIO;
<span class="p_add">+		qtcb-&gt;bottom.support.resp_buf_length =</span>
<span class="p_add">+			zfcp_qdio_real_bytes(sg_resp);</span>
 
 		zfcp_qdio_set_data_div(qdio, &amp;req-&gt;qdio_req,
 					zfcp_qdio_sbale_count(sg_req));
<span class="p_chunk">@@ -1073,6 +1079,7 @@</span> <span class="p_context"> int zfcp_fsf_send_ct(struct zfcp_fc_wka_port *wka_port,</span>
 
 	req-&gt;handler = zfcp_fsf_send_ct_handler;
 	req-&gt;qtcb-&gt;header.port_handle = wka_port-&gt;handle;
<span class="p_add">+	ct-&gt;d_id = wka_port-&gt;d_id;</span>
 	req-&gt;data = ct;
 
 	zfcp_dbf_san_req(&quot;fssct_1&quot;, req, wka_port-&gt;d_id);
<span class="p_chunk">@@ -1169,6 +1176,7 @@</span> <span class="p_context"> int zfcp_fsf_send_els(struct zfcp_adapter *adapter, u32 d_id,</span>
 
 	hton24(req-&gt;qtcb-&gt;bottom.support.d_id, d_id);
 	req-&gt;handler = zfcp_fsf_send_els_handler;
<span class="p_add">+	els-&gt;d_id = d_id;</span>
 	req-&gt;data = els;
 
 	zfcp_dbf_san_req(&quot;fssels1&quot;, req, d_id);
<span class="p_chunk">@@ -1575,7 +1583,7 @@</span> <span class="p_context"> out:</span>
 int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port-&gt;adapter-&gt;qdio;
<span class="p_del">-	struct zfcp_fsf_req *req;</span>
<span class="p_add">+	struct zfcp_fsf_req *req = NULL;</span>
 	int retval = -EIO;
 
 	spin_lock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_chunk">@@ -1604,6 +1612,8 @@</span> <span class="p_context"> int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)</span>
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_add">+	if (req &amp;&amp; !IS_ERR(req))</span>
<span class="p_add">+		zfcp_dbf_rec_run_wka(&quot;fsowp_1&quot;, wka_port, req-&gt;req_id);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -1628,7 +1638,7 @@</span> <span class="p_context"> static void zfcp_fsf_close_wka_port_handler(struct zfcp_fsf_req *req)</span>
 int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port-&gt;adapter-&gt;qdio;
<span class="p_del">-	struct zfcp_fsf_req *req;</span>
<span class="p_add">+	struct zfcp_fsf_req *req = NULL;</span>
 	int retval = -EIO;
 
 	spin_lock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_chunk">@@ -1657,6 +1667,8 @@</span> <span class="p_context"> int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)</span>
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_add">+	if (req &amp;&amp; !IS_ERR(req))</span>
<span class="p_add">+		zfcp_dbf_rec_run_wka(&quot;fscwp_1&quot;, wka_port, req-&gt;req_id);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.h b/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_header">index 57ae3ae1046d..be1c04b334c5 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to the FSF support functions.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #ifndef FSF_H
<span class="p_chunk">@@ -436,6 +436,7 @@</span> <span class="p_context"> struct zfcp_blk_drv_data {</span>
  * @handler_data: data passed to handler function
  * @port: Optional pointer to port for zfcp internal ELS (only test link ADISC)
  * @status: used to pass error status to calling function
<span class="p_add">+ * @d_id: Destination ID of either open WKA port for CT or of D_ID for ELS</span>
  */
 struct zfcp_fsf_ct_els {
 	struct scatterlist *req;
<span class="p_chunk">@@ -444,6 +445,7 @@</span> <span class="p_context"> struct zfcp_fsf_ct_els {</span>
 	void *handler_data;
 	struct zfcp_port *port;
 	int status;
<span class="p_add">+	u32 d_id;</span>
 };
 
 #endif				/* FSF_H */
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">index b3c6ff49103b..9069f98a1817 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to Linux SCSI midlayer.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2013</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -556,6 +556,9 @@</span> <span class="p_context"> static void zfcp_scsi_rport_register(struct zfcp_port *port)</span>
 	ids.port_id = port-&gt;d_id;
 	ids.roles = FC_RPORT_ROLE_FCP_TARGET;
 
<span class="p_add">+	zfcp_dbf_rec_trig(&quot;scpaddy&quot;, port-&gt;adapter, port, NULL,</span>
<span class="p_add">+			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD,</span>
<span class="p_add">+			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD);</span>
 	rport = fc_remote_port_add(port-&gt;adapter-&gt;scsi_host, 0, &amp;ids);
 	if (!rport) {
 		dev_err(&amp;port-&gt;adapter-&gt;ccw_device-&gt;dev,
<span class="p_chunk">@@ -577,6 +580,9 @@</span> <span class="p_context"> static void zfcp_scsi_rport_block(struct zfcp_port *port)</span>
 	struct fc_rport *rport = port-&gt;rport;
 
 	if (rport) {
<span class="p_add">+		zfcp_dbf_rec_trig(&quot;scpdely&quot;, port-&gt;adapter, port, NULL,</span>
<span class="p_add">+				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL,</span>
<span class="p_add">+				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL);</span>
 		fc_remote_port_delete(rport);
 		port-&gt;rport = NULL;
 	}
<span class="p_header">diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c</span>
<span class="p_header">index a3860367b568..e9ce74afd13f 100644</span>
<span class="p_header">--- a/drivers/scsi/hpsa.c</span>
<span class="p_header">+++ b/drivers/scsi/hpsa.c</span>
<span class="p_chunk">@@ -3930,6 +3930,70 @@</span> <span class="p_context"> static int hpsa_set_local_logical_count(struct ctlr_info *h,</span>
 	return rc;
 }
 
<span class="p_add">+static bool hpsa_is_disk_spare(struct ctlr_info *h, u8 *lunaddrbytes)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct bmic_identify_physical_device *id_phys;</span>
<span class="p_add">+	bool is_spare = false;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	id_phys = kzalloc(sizeof(*id_phys), GFP_KERNEL);</span>
<span class="p_add">+	if (!id_phys)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = hpsa_bmic_id_physical_device(h,</span>
<span class="p_add">+					lunaddrbytes,</span>
<span class="p_add">+					GET_BMIC_DRIVE_NUMBER(lunaddrbytes),</span>
<span class="p_add">+					id_phys, sizeof(*id_phys));</span>
<span class="p_add">+	if (rc == 0)</span>
<span class="p_add">+		is_spare = (id_phys-&gt;more_flags &gt;&gt; 6) &amp; 0x01;</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(id_phys);</span>
<span class="p_add">+	return is_spare;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define RPL_DEV_FLAG_NON_DISK                           0x1</span>
<span class="p_add">+#define RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED  0x2</span>
<span class="p_add">+#define RPL_DEV_FLAG_UNCONFIG_DISK                      0x4</span>
<span class="p_add">+</span>
<span class="p_add">+#define BMIC_DEVICE_TYPE_ENCLOSURE  6</span>
<span class="p_add">+</span>
<span class="p_add">+static bool hpsa_skip_device(struct ctlr_info *h, u8 *lunaddrbytes,</span>
<span class="p_add">+				struct ext_report_lun_entry *rle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 device_flags;</span>
<span class="p_add">+	u8 device_type;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!MASKED_DEVICE(lunaddrbytes))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	device_flags = rle-&gt;device_flags;</span>
<span class="p_add">+	device_type = rle-&gt;device_type;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (device_flags &amp; RPL_DEV_FLAG_NON_DISK) {</span>
<span class="p_add">+		if (device_type == BMIC_DEVICE_TYPE_ENCLOSURE)</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(device_flags &amp; RPL_DEV_FLAG_UNCONFIG_DISK_REPORTING_SUPPORTED))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (device_flags &amp; RPL_DEV_FLAG_UNCONFIG_DISK)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Spares may be spun down, we do not want to</span>
<span class="p_add">+	 * do an Inquiry to a RAID set spare drive as</span>
<span class="p_add">+	 * that would have them spun up, that is a</span>
<span class="p_add">+	 * performance hit because I/O to the RAID device</span>
<span class="p_add">+	 * stops while the spin up occurs which can take</span>
<span class="p_add">+	 * over 50 seconds.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (hpsa_is_disk_spare(h, lunaddrbytes))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
 
 static void hpsa_update_scsi_devices(struct ctlr_info *h)
 {
<span class="p_chunk">@@ -4023,6 +4087,7 @@</span> <span class="p_context"> static void hpsa_update_scsi_devices(struct ctlr_info *h)</span>
 		u8 *lunaddrbytes, is_OBDR = 0;
 		int rc = 0;
 		int phys_dev_index = i - (raid_ctlr_position == 0);
<span class="p_add">+		bool skip_device = false;</span>
 
 		physical_device = i &lt; nphysicals + (raid_ctlr_position == 0);
 
<span class="p_chunk">@@ -4030,10 +4095,15 @@</span> <span class="p_context"> static void hpsa_update_scsi_devices(struct ctlr_info *h)</span>
 		lunaddrbytes = figure_lunaddrbytes(h, raid_ctlr_position,
 			i, nphysicals, nlogicals, physdev_list, logdev_list);
 
<span class="p_del">-		/* skip masked non-disk devices */</span>
<span class="p_del">-		if (MASKED_DEVICE(lunaddrbytes) &amp;&amp; physical_device &amp;&amp;</span>
<span class="p_del">-			(physdev_list-&gt;LUN[phys_dev_index].device_flags &amp; 0x01))</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Skip over some devices such as a spare.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!tmpdevice-&gt;external &amp;&amp; physical_device) {</span>
<span class="p_add">+			skip_device = hpsa_skip_device(h, lunaddrbytes,</span>
<span class="p_add">+					&amp;physdev_list-&gt;LUN[phys_dev_index]);</span>
<span class="p_add">+			if (skip_device)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+		}</span>
 
 		/* Get device type, vendor, model, device id */
 		rc = hpsa_update_device_info(h, lunaddrbytes, tmpdevice,
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index f0cfaacbfabd..692445bcca6f 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -1459,12 +1459,12 @@</span> <span class="p_context"> retry:</span>
  out_err:
 	kfree(lun_data);
  out:
<span class="p_del">-	scsi_device_put(sdev);</span>
 	if (scsi_device_created(sdev))
 		/*
 		 * the sdev we used didn&#39;t appear in the report luns scan
 		 */
 		__scsi_remove_device(sdev);
<span class="p_add">+	scsi_device_put(sdev);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 0d7c6e86f149..6ee50742f6a5 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -2879,10 +2879,10 @@</span> <span class="p_context"> static int sd_revalidate_disk(struct gendisk *disk)</span>
 	if (sdkp-&gt;opt_xfer_blocks &amp;&amp;
 	    sdkp-&gt;opt_xfer_blocks &lt;= dev_max &amp;&amp;
 	    sdkp-&gt;opt_xfer_blocks &lt;= SD_DEF_XFER_BLOCKS &amp;&amp;
<span class="p_del">-	    sdkp-&gt;opt_xfer_blocks * sdp-&gt;sector_size &gt;= PAGE_CACHE_SIZE)</span>
<span class="p_del">-		rw_max = q-&gt;limits.io_opt =</span>
<span class="p_del">-			sdkp-&gt;opt_xfer_blocks * sdp-&gt;sector_size;</span>
<span class="p_del">-	else</span>
<span class="p_add">+	    logical_to_bytes(sdp, sdkp-&gt;opt_xfer_blocks) &gt;= PAGE_CACHE_SIZE) {</span>
<span class="p_add">+		q-&gt;limits.io_opt = logical_to_bytes(sdp, sdkp-&gt;opt_xfer_blocks);</span>
<span class="p_add">+		rw_max = logical_to_sectors(sdp, sdkp-&gt;opt_xfer_blocks);</span>
<span class="p_add">+	} else</span>
 		rw_max = BLK_DEF_MAX_SECTORS;
 
 	/* Combine with controller limits */
<span class="p_header">diff --git a/drivers/scsi/sd.h b/drivers/scsi/sd.h</span>
<span class="p_header">index 654630bb7d0e..765a6f1ac1b7 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.h</span>
<span class="p_header">+++ b/drivers/scsi/sd.h</span>
<span class="p_chunk">@@ -151,6 +151,11 @@</span> <span class="p_context"> static inline sector_t logical_to_sectors(struct scsi_device *sdev, sector_t blo</span>
 	return blocks &lt;&lt; (ilog2(sdev-&gt;sector_size) - 9);
 }
 
<span class="p_add">+static inline unsigned int logical_to_bytes(struct scsi_device *sdev, sector_t blocks)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return blocks * sdev-&gt;sector_size;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * A DIF-capable target device can be formatted with different
  * protection schemes.  Currently 0 through 3 are defined:
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 7bc3778a1ac9..2a67af4e2e13 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1680,6 +1680,7 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	case TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED:
 	case TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED:
 	case TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED:
<span class="p_add">+	case TCM_COPY_TARGET_DEVICE_NOT_REACHABLE:</span>
 		break;
 	case TCM_OUT_OF_RESOURCES:
 		sense_reason = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
<span class="p_chunk">@@ -2509,8 +2510,10 @@</span> <span class="p_context"> int target_get_sess_cmd(struct se_cmd *se_cmd, bool ack_kref)</span>
 	 * fabric acknowledgement that requires two target_put_sess_cmd()
 	 * invocations before se_cmd descriptor release.
 	 */
<span class="p_del">-	if (ack_kref)</span>
<span class="p_add">+	if (ack_kref) {</span>
 		kref_get(&amp;se_cmd-&gt;cmd_kref);
<span class="p_add">+		se_cmd-&gt;se_cmd_flags |= SCF_ACK_KREF;</span>
<span class="p_add">+	}</span>
 
 	spin_lock_irqsave(&amp;se_sess-&gt;sess_cmd_lock, flags);
 	if (se_sess-&gt;sess_tearing_down) {
<span class="p_chunk">@@ -2833,6 +2836,12 @@</span> <span class="p_context"> static const struct sense_info sense_info_table[] = {</span>
 		.ascq = 0x03, /* LOGICAL BLOCK REFERENCE TAG CHECK FAILED */
 		.add_sector_info = true,
 	},
<span class="p_add">+	[TCM_COPY_TARGET_DEVICE_NOT_REACHABLE] = {</span>
<span class="p_add">+		.key = COPY_ABORTED,</span>
<span class="p_add">+		.asc = 0x0d,</span>
<span class="p_add">+		.ascq = 0x02, /* COPY TARGET DEVICE NOT REACHABLE */</span>
<span class="p_add">+</span>
<span class="p_add">+	},</span>
 	[TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE] = {
 		/*
 		 * Returning ILLEGAL REQUEST would cause immediate IO errors on
<span class="p_header">diff --git a/drivers/target/target_core_xcopy.c b/drivers/target/target_core_xcopy.c</span>
<span class="p_header">index 47fe94ee10b8..153a6f255b6d 100644</span>
<span class="p_header">--- a/drivers/target/target_core_xcopy.c</span>
<span class="p_header">+++ b/drivers/target/target_core_xcopy.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> static int target_xcopy_locate_se_dev_e4(struct se_cmd *se_cmd, struct xcopy_op</span>
 	}
 	mutex_unlock(&amp;g_device_mutex);
 
<span class="p_del">-	pr_err(&quot;Unable to locate 0xe4 descriptor for EXTENDED_COPY\n&quot;);</span>
<span class="p_add">+	pr_debug_ratelimited(&quot;Unable to locate 0xe4 descriptor for EXTENDED_COPY\n&quot;);</span>
 	return -EINVAL;
 }
 
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"> static int target_xcopy_parse_tiddesc_e4(struct se_cmd *se_cmd, struct xcopy_op</span>
 
 static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,
 				struct xcopy_op *xop, unsigned char *p,
<span class="p_del">-				unsigned short tdll)</span>
<span class="p_add">+				unsigned short tdll, sense_reason_t *sense_ret)</span>
 {
 	struct se_device *local_dev = se_cmd-&gt;se_dev;
 	unsigned char *desc = p;
<span class="p_chunk">@@ -193,6 +193,8 @@</span> <span class="p_context"> static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,</span>
 	unsigned short start = 0;
 	bool src = true;
 
<span class="p_add">+	*sense_ret = TCM_INVALID_PARAMETER_LIST;</span>
<span class="p_add">+</span>
 	if (offset != 0) {
 		pr_err(&quot;XCOPY target descriptor list length is not&quot;
 			&quot; multiple of %d\n&quot;, XCOPY_TARGET_DESC_LEN);
<span class="p_chunk">@@ -243,9 +245,16 @@</span> <span class="p_context"> static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,</span>
 		rc = target_xcopy_locate_se_dev_e4(se_cmd, xop, true);
 	else
 		rc = target_xcopy_locate_se_dev_e4(se_cmd, xop, false);
<span class="p_del">-</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If a matching IEEE NAA 0x83 descriptor for the requested device</span>
<span class="p_add">+	 * is not located on this node, return COPY_ABORTED with ASQ/ASQC</span>
<span class="p_add">+	 * 0x0d/0x02 - COPY_TARGET_DEVICE_NOT_REACHABLE to request the</span>
<span class="p_add">+	 * initiator to fall back to normal copy method.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
<span class="p_add">+		*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	pr_debug(&quot;XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\n&quot;,
 		 xop-&gt;src_dev, &amp;xop-&gt;src_tid_wwn[0]);
<span class="p_chunk">@@ -653,6 +662,7 @@</span> <span class="p_context"> static int target_xcopy_read_source(</span>
 	rc = target_xcopy_setup_pt_cmd(xpt_cmd, xop, src_dev, &amp;cdb[0],
 				remote_port, true);
 	if (rc &lt; 0) {
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		transport_generic_free_cmd(se_cmd, 0);
 		return rc;
 	}
<span class="p_chunk">@@ -664,6 +674,7 @@</span> <span class="p_context"> static int target_xcopy_read_source(</span>
 
 	rc = target_xcopy_issue_pt_cmd(xpt_cmd);
 	if (rc &lt; 0) {
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		transport_generic_free_cmd(se_cmd, 0);
 		return rc;
 	}
<span class="p_chunk">@@ -714,6 +725,7 @@</span> <span class="p_context"> static int target_xcopy_write_destination(</span>
 				remote_port, false);
 	if (rc &lt; 0) {
 		struct se_cmd *src_cmd = &amp;xop-&gt;src_pt_cmd-&gt;se_cmd;
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		/*
 		 * If the failure happened before the t_mem_list hand-off in
 		 * target_xcopy_setup_pt_cmd(), Reset memory + clear flag so that
<span class="p_chunk">@@ -729,6 +741,7 @@</span> <span class="p_context"> static int target_xcopy_write_destination(</span>
 
 	rc = target_xcopy_issue_pt_cmd(xpt_cmd);
 	if (rc &lt; 0) {
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		se_cmd-&gt;se_cmd_flags &amp;= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;
 		transport_generic_free_cmd(se_cmd, 0);
 		return rc;
<span class="p_chunk">@@ -815,9 +828,14 @@</span> <span class="p_context"> static void target_xcopy_do_work(struct work_struct *work)</span>
 out:
 	xcopy_pt_undepend_remotedev(xop);
 	kfree(xop);
<span class="p_del">-</span>
<span class="p_del">-	pr_warn(&quot;target_xcopy_do_work: Setting X-COPY CHECK_CONDITION -&gt; sending response\n&quot;);</span>
<span class="p_del">-	ec_cmd-&gt;scsi_status = SAM_STAT_CHECK_CONDITION;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t override an error scsi status if it has already been set</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ec_cmd-&gt;scsi_status == SAM_STAT_GOOD) {</span>
<span class="p_add">+		pr_warn_ratelimited(&quot;target_xcopy_do_work: rc: %d, Setting X-COPY&quot;</span>
<span class="p_add">+			&quot; CHECK_CONDITION -&gt; sending response\n&quot;, rc);</span>
<span class="p_add">+		ec_cmd-&gt;scsi_status = SAM_STAT_CHECK_CONDITION;</span>
<span class="p_add">+	}</span>
 	target_complete_cmd(ec_cmd, SAM_STAT_CHECK_CONDITION);
 }
 
<span class="p_chunk">@@ -875,7 +893,7 @@</span> <span class="p_context"> sense_reason_t target_do_xcopy(struct se_cmd *se_cmd)</span>
 		&quot; tdll: %hu sdll: %u inline_dl: %u\n&quot;, list_id, list_id_usage,
 		tdll, sdll, inline_dl);
 
<span class="p_del">-	rc = target_xcopy_parse_target_descriptors(se_cmd, xop, &amp;p[16], tdll);</span>
<span class="p_add">+	rc = target_xcopy_parse_target_descriptors(se_cmd, xop, &amp;p[16], tdll, &amp;ret);</span>
 	if (rc &lt;= 0)
 		goto out;
 
<span class="p_header">diff --git a/drivers/video/fbdev/efifb.c b/drivers/video/fbdev/efifb.c</span>
<span class="p_header">index 95d293b7445a..dc2fcda54d53 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/efifb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/efifb.c</span>
<span class="p_chunk">@@ -52,9 +52,9 @@</span> <span class="p_context"> static int efifb_setcolreg(unsigned regno, unsigned red, unsigned green,</span>
 		return 1;
 
 	if (regno &lt; 16) {
<span class="p_del">-		red   &gt;&gt;= 8;</span>
<span class="p_del">-		green &gt;&gt;= 8;</span>
<span class="p_del">-		blue  &gt;&gt;= 8;</span>
<span class="p_add">+		red   &gt;&gt;= 16 - info-&gt;var.red.length;</span>
<span class="p_add">+		green &gt;&gt;= 16 - info-&gt;var.green.length;</span>
<span class="p_add">+		blue  &gt;&gt;= 16 - info-&gt;var.blue.length;</span>
 		((u32 *)(info-&gt;pseudo_palette))[regno] =
 			(red   &lt;&lt; info-&gt;var.red.offset)   |
 			(green &lt;&lt; info-&gt;var.green.offset) |
<span class="p_header">diff --git a/fs/ceph/file.c b/fs/ceph/file.c</span>
<span class="p_header">index 3c68e6aee2f0..c8222bfe1e56 100644</span>
<span class="p_header">--- a/fs/ceph/file.c</span>
<span class="p_header">+++ b/fs/ceph/file.c</span>
<span class="p_chunk">@@ -929,7 +929,8 @@</span> <span class="p_context"> again:</span>
 		statret = __ceph_do_getattr(inode, page,
 					    CEPH_STAT_CAP_INLINE_DATA, !!page);
 		if (statret &lt; 0) {
<span class="p_del">-			 __free_page(page);</span>
<span class="p_add">+			if (page)</span>
<span class="p_add">+				__free_page(page);</span>
 			if (statret == -ENODATA) {
 				BUG_ON(retry_op != READ_INLINE);
 				goto again;
<span class="p_header">diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c</span>
<span class="p_header">index 50b268483302..0a3544fb50f9 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_debug.c</span>
<span class="p_header">+++ b/fs/cifs/cifs_debug.c</span>
<span class="p_chunk">@@ -152,6 +152,7 @@</span> <span class="p_context"> static int cifs_debug_data_proc_show(struct seq_file *m, void *v)</span>
 	list_for_each(tmp1, &amp;cifs_tcp_ses_list) {
 		server = list_entry(tmp1, struct TCP_Server_Info,
 				    tcp_ses_list);
<span class="p_add">+		seq_printf(m, &quot;\nNumber of credits: %d&quot;, server-&gt;credits);</span>
 		i++;
 		list_for_each(tmp2, &amp;server-&gt;smb_ses_list) {
 			ses = list_entry(tmp2, struct cifs_ses,
<span class="p_chunk">@@ -255,7 +256,6 @@</span> <span class="p_context"> static const struct file_operations cifs_debug_data_proc_fops = {</span>
 static ssize_t cifs_stats_proc_write(struct file *file,
 		const char __user *buffer, size_t count, loff_t *ppos)
 {
<span class="p_del">-	char c;</span>
 	bool bv;
 	int rc;
 	struct list_head *tmp1, *tmp2, *tmp3;
<span class="p_chunk">@@ -263,11 +263,8 @@</span> <span class="p_context"> static ssize_t cifs_stats_proc_write(struct file *file,</span>
 	struct cifs_ses *ses;
 	struct cifs_tcon *tcon;
 
<span class="p_del">-	rc = get_user(c, buffer);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (strtobool(&amp;c, &amp;bv) == 0) {</span>
<span class="p_add">+	rc = kstrtobool_from_user(buffer, count, &amp;bv);</span>
<span class="p_add">+	if (rc == 0) {</span>
 #ifdef CONFIG_CIFS_STATS2
 		atomic_set(&amp;totBufAllocCount, 0);
 		atomic_set(&amp;totSmBufAllocCount, 0);
<span class="p_chunk">@@ -290,6 +287,8 @@</span> <span class="p_context"> static ssize_t cifs_stats_proc_write(struct file *file,</span>
 			}
 		}
 		spin_unlock(&amp;cifs_tcp_ses_lock);
<span class="p_add">+	} else {</span>
<span class="p_add">+		return rc;</span>
 	}
 
 	return count;
<span class="p_chunk">@@ -433,17 +432,17 @@</span> <span class="p_context"> static int cifsFYI_proc_open(struct inode *inode, struct file *file)</span>
 static ssize_t cifsFYI_proc_write(struct file *file, const char __user *buffer,
 		size_t count, loff_t *ppos)
 {
<span class="p_del">-	char c;</span>
<span class="p_add">+	char c[2] = { &#39;\0&#39; };</span>
 	bool bv;
 	int rc;
 
<span class="p_del">-	rc = get_user(c, buffer);</span>
<span class="p_add">+	rc = get_user(c[0], buffer);</span>
 	if (rc)
 		return rc;
<span class="p_del">-	if (strtobool(&amp;c, &amp;bv) == 0)</span>
<span class="p_add">+	if (strtobool(c, &amp;bv) == 0)</span>
 		cifsFYI = bv;
<span class="p_del">-	else if ((c &gt; &#39;1&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))</span>
<span class="p_del">-		cifsFYI = (int) (c - &#39;0&#39;); /* see cifs_debug.h for meanings */</span>
<span class="p_add">+	else if ((c[0] &gt; &#39;1&#39;) &amp;&amp; (c[0] &lt;= &#39;9&#39;))</span>
<span class="p_add">+		cifsFYI = (int) (c[0] - &#39;0&#39;); /* see cifs_debug.h for meanings */</span>
 
 	return count;
 }
<span class="p_chunk">@@ -471,20 +470,12 @@</span> <span class="p_context"> static int cifs_linux_ext_proc_open(struct inode *inode, struct file *file)</span>
 static ssize_t cifs_linux_ext_proc_write(struct file *file,
 		const char __user *buffer, size_t count, loff_t *ppos)
 {
<span class="p_del">-	char c;</span>
<span class="p_del">-	bool bv;</span>
 	int rc;
 
<span class="p_del">-	rc = get_user(c, buffer);</span>
<span class="p_add">+	rc = kstrtobool_from_user(buffer, count, &amp;linuxExtEnabled);</span>
 	if (rc)
 		return rc;
 
<span class="p_del">-	rc = strtobool(&amp;c, &amp;bv);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	linuxExtEnabled = bv;</span>
<span class="p_del">-</span>
 	return count;
 }
 
<span class="p_chunk">@@ -511,20 +502,12 @@</span> <span class="p_context"> static int cifs_lookup_cache_proc_open(struct inode *inode, struct file *file)</span>
 static ssize_t cifs_lookup_cache_proc_write(struct file *file,
 		const char __user *buffer, size_t count, loff_t *ppos)
 {
<span class="p_del">-	char c;</span>
<span class="p_del">-	bool bv;</span>
 	int rc;
 
<span class="p_del">-	rc = get_user(c, buffer);</span>
<span class="p_add">+	rc = kstrtobool_from_user(buffer, count, &amp;lookupCacheEnabled);</span>
 	if (rc)
 		return rc;
 
<span class="p_del">-	rc = strtobool(&amp;c, &amp;bv);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	lookupCacheEnabled = bv;</span>
<span class="p_del">-</span>
 	return count;
 }
 
<span class="p_chunk">@@ -551,20 +534,12 @@</span> <span class="p_context"> static int traceSMB_proc_open(struct inode *inode, struct file *file)</span>
 static ssize_t traceSMB_proc_write(struct file *file, const char __user *buffer,
 		size_t count, loff_t *ppos)
 {
<span class="p_del">-	char c;</span>
<span class="p_del">-	bool bv;</span>
 	int rc;
 
<span class="p_del">-	rc = get_user(c, buffer);</span>
<span class="p_add">+	rc = kstrtobool_from_user(buffer, count, &amp;traceSMB);</span>
 	if (rc)
 		return rc;
 
<span class="p_del">-	rc = strtobool(&amp;c, &amp;bv);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	traceSMB = bv;</span>
<span class="p_del">-</span>
 	return count;
 }
 
<span class="p_chunk">@@ -622,7 +597,6 @@</span> <span class="p_context"> static ssize_t cifs_security_flags_proc_write(struct file *file,</span>
 	int rc;
 	unsigned int flags;
 	char flags_string[12];
<span class="p_del">-	char c;</span>
 	bool bv;
 
 	if ((count &lt; 1) || (count &gt; 11))
<span class="p_chunk">@@ -635,11 +609,10 @@</span> <span class="p_context"> static ssize_t cifs_security_flags_proc_write(struct file *file,</span>
 
 	if (count &lt; 3) {
 		/* single char or single char followed by null */
<span class="p_del">-		c = flags_string[0];</span>
<span class="p_del">-		if (strtobool(&amp;c, &amp;bv) == 0) {</span>
<span class="p_add">+		if (strtobool(flags_string, &amp;bv) == 0) {</span>
 			global_secflags = bv ? CIFSSEC_MAX : CIFSSEC_DEF;
 			return count;
<span class="p_del">-		} else if (!isdigit(c)) {</span>
<span class="p_add">+		} else if (!isdigit(flags_string[0])) {</span>
 			cifs_dbg(VFS, &quot;Invalid SecurityFlags: %s\n&quot;,
 					flags_string);
 			return -EINVAL;
<span class="p_header">diff --git a/fs/cifs/cifs_debug.h b/fs/cifs/cifs_debug.h</span>
<span class="p_header">index 66cf0f9fff89..c611ca2339d7 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_debug.h</span>
<span class="p_header">+++ b/fs/cifs/cifs_debug.h</span>
<span class="p_chunk">@@ -25,7 +25,7 @@</span> <span class="p_context"></span>
 void cifs_dump_mem(char *label, void *data, int length);
 void cifs_dump_detail(void *);
 void cifs_dump_mids(struct TCP_Server_Info *);
<span class="p_del">-extern int traceSMB;		/* flag which enables the function below */</span>
<span class="p_add">+extern bool traceSMB;		/* flag which enables the function below */</span>
 void dump_smb(void *, int);
 #define CIFS_INFO	0x01
 #define CIFS_RC		0x02
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index 450578097fb7..4f4fc9ff3636 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -54,10 +54,10 @@</span> <span class="p_context"></span>
 #endif
 
 int cifsFYI = 0;
<span class="p_del">-int traceSMB = 0;</span>
<span class="p_add">+bool traceSMB;</span>
 bool enable_oplocks = true;
<span class="p_del">-unsigned int linuxExtEnabled = 1;</span>
<span class="p_del">-unsigned int lookupCacheEnabled = 1;</span>
<span class="p_add">+bool linuxExtEnabled = true;</span>
<span class="p_add">+bool lookupCacheEnabled = true;</span>
 unsigned int global_secflags = CIFSSEC_DEF;
 /* unsigned int ntlmv2_support = 0; */
 unsigned int sign_CIFS_PDUs = 1;
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"> cifs_alloc_inode(struct super_block *sb)</span>
 	cifs_inode-&gt;createtime = 0;
 	cifs_inode-&gt;epoch = 0;
 #ifdef CONFIG_CIFS_SMB2
<span class="p_del">-	get_random_bytes(cifs_inode-&gt;lease_key, SMB2_LEASE_KEY_SIZE);</span>
<span class="p_add">+	generate_random_uuid(cifs_inode-&gt;lease_key);</span>
 #endif
 	/*
 	 * Can not set i_flags here - they get immediately overwritten to zero
<span class="p_chunk">@@ -1210,7 +1210,6 @@</span> <span class="p_context"> init_cifs(void)</span>
 	GlobalTotalActiveXid = 0;
 	GlobalMaxActiveXid = 0;
 	spin_lock_init(&amp;cifs_tcp_ses_lock);
<span class="p_del">-	spin_lock_init(&amp;cifs_file_list_lock);</span>
 	spin_lock_init(&amp;GlobalMid_Lock);
 
 	if (cifs_max_pending &lt; 2) {
<span class="p_header">diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h</span>
<span class="p_header">index 2b510c537a0d..c669a1471395 100644</span>
<span class="p_header">--- a/fs/cifs/cifsglob.h</span>
<span class="p_header">+++ b/fs/cifs/cifsglob.h</span>
<span class="p_chunk">@@ -827,6 +827,7 @@</span> <span class="p_context"> struct cifs_tcon {</span>
 	struct list_head tcon_list;
 	int tc_count;
 	struct list_head openFileList;
<span class="p_add">+	spinlock_t open_file_lock; /* protects list above */</span>
 	struct cifs_ses *ses;	/* pointer to session associated with */
 	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */
 	char *nativeFileSystem;
<span class="p_chunk">@@ -883,7 +884,7 @@</span> <span class="p_context"> struct cifs_tcon {</span>
 #endif /* CONFIG_CIFS_STATS2 */
 	__u64    bytes_read;
 	__u64    bytes_written;
<span class="p_del">-	spinlock_t stat_lock;</span>
<span class="p_add">+	spinlock_t stat_lock;  /* protects the two fields above */</span>
 #endif /* CONFIG_CIFS_STATS */
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */
<span class="p_chunk">@@ -1034,8 +1035,10 @@</span> <span class="p_context"> struct cifs_fid_locks {</span>
 };
 
 struct cifsFileInfo {
<span class="p_add">+	/* following two lists are protected by tcon-&gt;open_file_lock */</span>
 	struct list_head tlist;	/* pointer to next fid owned by tcon */
 	struct list_head flist;	/* next fid (file instance) for this inode */
<span class="p_add">+	/* lock list below protected by cifsi-&gt;lock_sem */</span>
 	struct cifs_fid_locks *llist;	/* brlocks held by this fid */
 	kuid_t uid;		/* allows finding which FileInfo structure */
 	__u32 pid;		/* process id who opened file */
<span class="p_chunk">@@ -1043,11 +1046,12 @@</span> <span class="p_context"> struct cifsFileInfo {</span>
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
 	struct dentry *dentry;
<span class="p_del">-	unsigned int f_flags;</span>
 	struct tcon_link *tlink;
<span class="p_add">+	unsigned int f_flags;</span>
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool oplock_break_cancelled:1;
<span class="p_del">-	int count;		/* refcount protected by cifs_file_list_lock */</span>
<span class="p_add">+	int count;</span>
<span class="p_add">+	spinlock_t file_info_lock; /* protects four flag/count fields above */</span>
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 	struct work_struct oplock_break; /* work for oplock breaks */
<span class="p_chunk">@@ -1114,7 +1118,7 @@</span> <span class="p_context"> struct cifs_writedata {</span>
 
 /*
  * Take a reference on the file private data. Must be called with
<span class="p_del">- * cifs_file_list_lock held.</span>
<span class="p_add">+ * cfile-&gt;file_info_lock held.</span>
  */
 static inline void
 cifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)
<span class="p_chunk">@@ -1508,8 +1512,10 @@</span> <span class="p_context"> require use of the stronger protocol */</span>
  *  GlobalMid_Lock protects:
  *	list operations on pending_mid_q and oplockQ
  *      updates to XID counters, multiplex id  and SMB sequence numbers
<span class="p_del">- *  cifs_file_list_lock protects:</span>
<span class="p_del">- *	list operations on tcp and SMB session lists and tCon lists</span>
<span class="p_add">+ *  tcp_ses_lock protects:</span>
<span class="p_add">+ *	list operations on tcp and SMB session lists</span>
<span class="p_add">+ *  tcon-&gt;open_file_lock protects the list of open files hanging off the tcon</span>
<span class="p_add">+ *  cfile-&gt;file_info_lock protects counters and fields in cifs file struct</span>
  *  f_owner.lock protects certain per file struct operations
  *  mapping-&gt;page_lock protects certain per page operations
  *
<span class="p_chunk">@@ -1541,18 +1547,12 @@</span> <span class="p_context"> GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;</span>
  * tcp session, and the list of tcon&#39;s per smb session. It also protects
  * the reference counters for the server, smb session, and tcon. Finally,
  * changes to the tcon-&gt;tidStatus should be done while holding this lock.
<span class="p_add">+ * generally the locks should be taken in order tcp_ses_lock before</span>
<span class="p_add">+ * tcon-&gt;open_file_lock and that before file-&gt;file_info_lock since the</span>
<span class="p_add">+ * structure order is cifs_socket--&gt;cifs_ses--&gt;cifs_tcon--&gt;cifs_file</span>
  */
 GLOBAL_EXTERN spinlock_t		cifs_tcp_ses_lock;
 
<span class="p_del">-/*</span>
<span class="p_del">- * This lock protects the cifs_file-&gt;llist and cifs_file-&gt;flist</span>
<span class="p_del">- * list operations, and updates to some flags (cifs_file-&gt;invalidHandle)</span>
<span class="p_del">- * It will be moved to either use the tcon-&gt;stat_lock or equivalent later.</span>
<span class="p_del">- * If cifs_tcp_ses_lock and the lock below are both needed to be held, then</span>
<span class="p_del">- * the cifs_tcp_ses_lock must be grabbed first and released last.</span>
<span class="p_del">- */</span>
<span class="p_del">-GLOBAL_EXTERN spinlock_t	cifs_file_list_lock;</span>
<span class="p_del">-</span>
 #ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* unused temporarily */
 /* Outstanding dir notify requests */
 GLOBAL_EXTERN struct list_head GlobalDnotifyReqList;
<span class="p_chunk">@@ -1588,11 +1588,11 @@</span> <span class="p_context"> GLOBAL_EXTERN atomic_t midCount;</span>
 
 /* Misc globals */
 GLOBAL_EXTERN bool enable_oplocks; /* enable or disable oplocks */
<span class="p_del">-GLOBAL_EXTERN unsigned int lookupCacheEnabled;</span>
<span class="p_add">+GLOBAL_EXTERN bool lookupCacheEnabled;</span>
 GLOBAL_EXTERN unsigned int global_secflags;	/* if on, session setup sent
 				with more secure ntlmssp2 challenge/resp */
 GLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */
<span class="p_del">-GLOBAL_EXTERN unsigned int linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/</span>
<span class="p_add">+GLOBAL_EXTERN bool linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/</span>
 GLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */
 GLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */
 GLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */
<span class="p_header">diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c</span>
<span class="p_header">index 76fcb50295a3..b1104ed8f54c 100644</span>
<span class="p_header">--- a/fs/cifs/cifssmb.c</span>
<span class="p_header">+++ b/fs/cifs/cifssmb.c</span>
<span class="p_chunk">@@ -98,13 +98,13 @@</span> <span class="p_context"> cifs_mark_open_files_invalid(struct cifs_tcon *tcon)</span>
 	struct list_head *tmp1;
 
 	/* list all files open on tree connection and mark them invalid */
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	list_for_each_safe(tmp, tmp1, &amp;tcon-&gt;openFileList) {
 		open_file = list_entry(tmp, struct cifsFileInfo, tlist);
 		open_file-&gt;invalidHandle = true;
 		open_file-&gt;oplock_break_cancelled = true;
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 	/*
 	 * BB Add call to invalidate_inodes(sb) for all superblocks mounted
 	 * to this tcon.
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 61c3a5ab8637..812a8cb07c63 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -2200,7 +2200,7 @@</span> <span class="p_context"> cifs_get_tcp_session(struct smb_vol *volume_info)</span>
 	memcpy(&amp;tcp_ses-&gt;dstaddr, &amp;volume_info-&gt;dstaddr,
 		sizeof(tcp_ses-&gt;dstaddr));
 #ifdef CONFIG_CIFS_SMB2
<span class="p_del">-	get_random_bytes(tcp_ses-&gt;client_guid, SMB2_CLIENT_GUID_SIZE);</span>
<span class="p_add">+	generate_random_uuid(tcp_ses-&gt;client_guid);</span>
 #endif
 	/*
 	 * at this point we are the only ones with the pointer
<span class="p_chunk">@@ -3693,14 +3693,16 @@</span> <span class="p_context"> remote_path_check:</span>
 			goto mount_fail_check;
 		}
 
<span class="p_del">-		rc = cifs_are_all_path_components_accessible(server,</span>
<span class="p_add">+		if (rc != -EREMOTE) {</span>
<span class="p_add">+			rc = cifs_are_all_path_components_accessible(server,</span>
 							     xid, tcon, cifs_sb,
 							     full_path);
<span class="p_del">-		if (rc != 0) {</span>
<span class="p_del">-			cifs_dbg(VFS, &quot;cannot query dirs between root and final path, &quot;</span>
<span class="p_del">-				 &quot;enabling CIFS_MOUNT_USE_PREFIX_PATH\n&quot;);</span>
<span class="p_del">-			cifs_sb-&gt;mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;</span>
<span class="p_del">-			rc = 0;</span>
<span class="p_add">+			if (rc != 0) {</span>
<span class="p_add">+				cifs_dbg(VFS, &quot;cannot query dirs between root and final path, &quot;</span>
<span class="p_add">+					 &quot;enabling CIFS_MOUNT_USE_PREFIX_PATH\n&quot;);</span>
<span class="p_add">+				cifs_sb-&gt;mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;</span>
<span class="p_add">+				rc = 0;</span>
<span class="p_add">+			}</span>
 		}
 		kfree(full_path);
 	}
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index 0068e82217c3..72f270d4bd17 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -305,6 +305,7 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 	cfile-&gt;tlink = cifs_get_tlink(tlink);
 	INIT_WORK(&amp;cfile-&gt;oplock_break, cifs_oplock_break);
 	mutex_init(&amp;cfile-&gt;fh_mutex);
<span class="p_add">+	spin_lock_init(&amp;cfile-&gt;file_info_lock);</span>
 
 	cifs_sb_active(inode-&gt;i_sb);
 
<span class="p_chunk">@@ -317,7 +318,7 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 		oplock = 0;
 	}
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	if (fid-&gt;pending_open-&gt;oplock != CIFS_OPLOCK_NO_CHANGE &amp;&amp; oplock)
 		oplock = fid-&gt;pending_open-&gt;oplock;
 	list_del(&amp;fid-&gt;pending_open-&gt;olist);
<span class="p_chunk">@@ -326,12 +327,13 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 	server-&gt;ops-&gt;set_fid(cfile, fid, oplock);
 
 	list_add(&amp;cfile-&gt;tlist, &amp;tcon-&gt;openFileList);
<span class="p_add">+</span>
 	/* if readable file instance put first in list*/
 	if (file-&gt;f_mode &amp; FMODE_READ)
 		list_add(&amp;cfile-&gt;flist, &amp;cinode-&gt;openFileList);
 	else
 		list_add_tail(&amp;cfile-&gt;flist, &amp;cinode-&gt;openFileList);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 
 	if (fid-&gt;purge_cache)
 		cifs_zap_mapping(inode);
<span class="p_chunk">@@ -343,16 +345,16 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 struct cifsFileInfo *
 cifsFileInfo_get(struct cifsFileInfo *cifs_file)
 {
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;cifs_file-&gt;file_info_lock);</span>
 	cifsFileInfo_get_locked(cifs_file);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;cifs_file-&gt;file_info_lock);</span>
 	return cifs_file;
 }
 
 /*
  * Release a reference on the file private data. This may involve closing
  * the filehandle out on the server. Must be called without holding
<span class="p_del">- * cifs_file_list_lock.</span>
<span class="p_add">+ * tcon-&gt;open_file_lock and cifs_file-&gt;file_info_lock.</span>
  */
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
 {
<span class="p_chunk">@@ -367,11 +369,15 @@</span> <span class="p_context"> void cifsFileInfo_put(struct cifsFileInfo *cifs_file)</span>
 	struct cifs_pending_open open;
 	bool oplock_break_cancelled;
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;cifs_file-&gt;file_info_lock);</span>
 	if (--cifs_file-&gt;count &gt; 0) {
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;cifs_file-&gt;file_info_lock);</span>
<span class="p_add">+		spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 		return;
 	}
<span class="p_add">+	spin_unlock(&amp;cifs_file-&gt;file_info_lock);</span>
 
 	if (server-&gt;ops-&gt;get_lease_key)
 		server-&gt;ops-&gt;get_lease_key(inode, &amp;fid);
<span class="p_chunk">@@ -395,7 +401,8 @@</span> <span class="p_context"> void cifsFileInfo_put(struct cifsFileInfo *cifs_file)</span>
 			set_bit(CIFS_INO_INVALID_MAPPING, &amp;cifsi-&gt;flags);
 		cifs_set_oplock_level(cifsi, 0);
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 
 	oplock_break_cancelled = cancel_work_sync(&amp;cifs_file-&gt;oplock_break);
 
<span class="p_chunk">@@ -772,10 +779,10 @@</span> <span class="p_context"> int cifs_closedir(struct inode *inode, struct file *file)</span>
 	server = tcon-&gt;ses-&gt;server;
 
 	cifs_dbg(FYI, &quot;Freeing private data in close dir\n&quot;);
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;cfile-&gt;file_info_lock);</span>
 	if (server-&gt;ops-&gt;dir_needs_close(cfile)) {
 		cfile-&gt;invalidHandle = true;
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 		if (server-&gt;ops-&gt;close_dir)
 			rc = server-&gt;ops-&gt;close_dir(xid, tcon, &amp;cfile-&gt;fid);
 		else
<span class="p_chunk">@@ -784,7 +791,7 @@</span> <span class="p_context"> int cifs_closedir(struct inode *inode, struct file *file)</span>
 		/* not much we can do if it fails anyway, ignore rc */
 		rc = 0;
 	} else
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 
 	buf = cfile-&gt;srch_inf.ntwrk_buf_start;
 	if (buf) {
<span class="p_chunk">@@ -1720,12 +1727,13 @@</span> <span class="p_context"> struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,</span>
 {
 	struct cifsFileInfo *open_file = NULL;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode-&gt;vfs_inode.i_sb);
<span class="p_add">+	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);</span>
 
 	/* only filter by fsuid on multiuser mounts */
 	if (!(cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_MULTIUSER))
 		fsuid_only = false;
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	/* we could simply get the first_list_entry since write-only entries
 	   are always at the end of the list but since the first entry might
 	   have a close pending, we go through the whole list */
<span class="p_chunk">@@ -1736,8 +1744,8 @@</span> <span class="p_context"> struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,</span>
 			if (!open_file-&gt;invalidHandle) {
 				/* found a good file */
 				/* lock it so it will not be closed on us */
<span class="p_del">-				cifsFileInfo_get_locked(open_file);</span>
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				cifsFileInfo_get(open_file);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				return open_file;
 			} /* else might as well continue, and look for
 			     another, or simply have the caller reopen it
<span class="p_chunk">@@ -1745,7 +1753,7 @@</span> <span class="p_context"> struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,</span>
 		} else /* write only file */
 			break; /* write only files are last so must be done */
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 	return NULL;
 }
 
<span class="p_chunk">@@ -1754,6 +1762,7 @@</span> <span class="p_context"> struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,</span>
 {
 	struct cifsFileInfo *open_file, *inv_file = NULL;
 	struct cifs_sb_info *cifs_sb;
<span class="p_add">+	struct cifs_tcon *tcon;</span>
 	bool any_available = false;
 	int rc;
 	unsigned int refind = 0;
<span class="p_chunk">@@ -1769,15 +1778,16 @@</span> <span class="p_context"> struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,</span>
 	}
 
 	cifs_sb = CIFS_SB(cifs_inode-&gt;vfs_inode.i_sb);
<span class="p_add">+	tcon = cifs_sb_master_tcon(cifs_sb);</span>
 
 	/* only filter by fsuid on multiuser mounts */
 	if (!(cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_MULTIUSER))
 		fsuid_only = false;
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 refind_writable:
 	if (refind &gt; MAX_REOPEN_ATT) {
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 		return NULL;
 	}
 	list_for_each_entry(open_file, &amp;cifs_inode-&gt;openFileList, flist) {
<span class="p_chunk">@@ -1788,8 +1798,8 @@</span> <span class="p_context"> refind_writable:</span>
 		if (OPEN_FMODE(open_file-&gt;f_flags) &amp; FMODE_WRITE) {
 			if (!open_file-&gt;invalidHandle) {
 				/* found a good writable file */
<span class="p_del">-				cifsFileInfo_get_locked(open_file);</span>
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				cifsFileInfo_get(open_file);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				return open_file;
 			} else {
 				if (!inv_file)
<span class="p_chunk">@@ -1805,24 +1815,24 @@</span> <span class="p_context"> refind_writable:</span>
 
 	if (inv_file) {
 		any_available = false;
<span class="p_del">-		cifsFileInfo_get_locked(inv_file);</span>
<span class="p_add">+		cifsFileInfo_get(inv_file);</span>
 	}
 
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 
 	if (inv_file) {
 		rc = cifs_reopen_file(inv_file, false);
 		if (!rc)
 			return inv_file;
 		else {
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			list_move_tail(&amp;inv_file-&gt;flist,
 					&amp;cifs_inode-&gt;openFileList);
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			cifsFileInfo_put(inv_file);
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
 			++refind;
 			inv_file = NULL;
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			goto refind_writable;
 		}
 	}
<span class="p_chunk">@@ -3632,15 +3642,17 @@</span> <span class="p_context"> static int cifs_readpage(struct file *file, struct page *page)</span>
 static int is_inode_writable(struct cifsInodeInfo *cifs_inode)
 {
 	struct cifsFileInfo *open_file;
<span class="p_add">+	struct cifs_tcon *tcon =</span>
<span class="p_add">+		cifs_sb_master_tcon(CIFS_SB(cifs_inode-&gt;vfs_inode.i_sb));</span>
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	list_for_each_entry(open_file, &amp;cifs_inode-&gt;openFileList, flist) {
 		if (OPEN_FMODE(open_file-&gt;f_flags) &amp; FMODE_WRITE) {
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			return 1;
 		}
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c</span>
<span class="p_header">index 8442b8b8e0be..2396ab099849 100644</span>
<span class="p_header">--- a/fs/cifs/misc.c</span>
<span class="p_header">+++ b/fs/cifs/misc.c</span>
<span class="p_chunk">@@ -120,6 +120,7 @@</span> <span class="p_context"> tconInfoAlloc(void)</span>
 		++ret_buf-&gt;tc_count;
 		INIT_LIST_HEAD(&amp;ret_buf-&gt;openFileList);
 		INIT_LIST_HEAD(&amp;ret_buf-&gt;tcon_list);
<span class="p_add">+		spin_lock_init(&amp;ret_buf-&gt;open_file_lock);</span>
 #ifdef CONFIG_CIFS_STATS
 		spin_lock_init(&amp;ret_buf-&gt;stat_lock);
 #endif
<span class="p_chunk">@@ -465,7 +466,7 @@</span> <span class="p_context"> is_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)</span>
 				continue;
 
 			cifs_stats_inc(&amp;tcon-&gt;stats.cifs_stats.num_oplock_brks);
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			list_for_each(tmp2, &amp;tcon-&gt;openFileList) {
 				netfile = list_entry(tmp2, struct cifsFileInfo,
 						     tlist);
<span class="p_chunk">@@ -495,11 +496,11 @@</span> <span class="p_context"> is_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)</span>
 					   &amp;netfile-&gt;oplock_break);
 				netfile-&gt;oplock_break_cancelled = false;
 
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				spin_unlock(&amp;cifs_tcp_ses_lock);
 				return true;
 			}
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			spin_unlock(&amp;cifs_tcp_ses_lock);
 			cifs_dbg(FYI, &quot;No matching file for oplock break\n&quot;);
 			return true;
<span class="p_chunk">@@ -613,9 +614,9 @@</span> <span class="p_context"> backup_cred(struct cifs_sb_info *cifs_sb)</span>
 void
 cifs_del_pending_open(struct cifs_pending_open *open)
 {
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tlink_tcon(open-&gt;tlink)-&gt;open_file_lock);</span>
 	list_del(&amp;open-&gt;olist);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tlink_tcon(open-&gt;tlink)-&gt;open_file_lock);</span>
 }
 
 void
<span class="p_chunk">@@ -635,7 +636,7 @@</span> <span class="p_context"> void</span>
 cifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,
 		      struct cifs_pending_open *open)
 {
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tlink_tcon(tlink)-&gt;open_file_lock);</span>
 	cifs_add_pending_open_locked(fid, tlink, open);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tlink_tcon(open-&gt;tlink)-&gt;open_file_lock);</span>
 }
<span class="p_header">diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c</span>
<span class="p_header">index b30a4a6d98a0..833e5844a2db 100644</span>
<span class="p_header">--- a/fs/cifs/readdir.c</span>
<span class="p_header">+++ b/fs/cifs/readdir.c</span>
<span class="p_chunk">@@ -594,14 +594,14 @@</span> <span class="p_context"> find_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,</span>
 	     is_dir_changed(file)) || (index_to_find &lt; first_entry_in_buffer)) {
 		/* close and restart search */
 		cifs_dbg(FYI, &quot;search backing up - close and restart search\n&quot;);
<span class="p_del">-		spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_lock(&amp;cfile-&gt;file_info_lock);</span>
 		if (server-&gt;ops-&gt;dir_needs_close(cfile)) {
 			cfile-&gt;invalidHandle = true;
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 			if (server-&gt;ops-&gt;close_dir)
 				server-&gt;ops-&gt;close_dir(xid, tcon, &amp;cfile-&gt;fid);
 		} else
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 		if (cfile-&gt;srch_inf.ntwrk_buf_start) {
 			cifs_dbg(FYI, &quot;freeing SMB ff cache buf on search rewind\n&quot;);
 			if (cfile-&gt;srch_inf.smallBuf)
<span class="p_header">diff --git a/fs/cifs/smb2glob.h b/fs/cifs/smb2glob.h</span>
<span class="p_header">index 0ffa18094335..238759c146ba 100644</span>
<span class="p_header">--- a/fs/cifs/smb2glob.h</span>
<span class="p_header">+++ b/fs/cifs/smb2glob.h</span>
<span class="p_chunk">@@ -61,4 +61,14 @@</span> <span class="p_context"></span>
 /* Maximum buffer size value we can send with 1 credit */
 #define SMB2_MAX_BUFFER_SIZE 65536
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Maximum number of credits to keep available.</span>
<span class="p_add">+ * This value is chosen somewhat arbitrarily. The Windows client</span>
<span class="p_add">+ * defaults to 128 credits, the Windows server allows clients up to</span>
<span class="p_add">+ * 512 credits, and the NetApp server does not limit clients at all.</span>
<span class="p_add">+ * Choose a high enough value such that the client shouldn&#39;t limit</span>
<span class="p_add">+ * performance.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define SMB2_MAX_CREDITS_AVAILABLE 32000</span>
<span class="p_add">+</span>
 #endif	/* _SMB2_GLOB_H */
<span class="p_header">diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c</span>
<span class="p_header">index 4f0231e685a9..1238cd3552f9 100644</span>
<span class="p_header">--- a/fs/cifs/smb2inode.c</span>
<span class="p_header">+++ b/fs/cifs/smb2inode.c</span>
<span class="p_chunk">@@ -266,9 +266,15 @@</span> <span class="p_context"> smb2_set_file_info(struct inode *inode, const char *full_path,</span>
 	struct tcon_link *tlink;
 	int rc;
 
<span class="p_add">+	if ((buf-&gt;CreationTime == 0) &amp;&amp; (buf-&gt;LastAccessTime == 0) &amp;&amp;</span>
<span class="p_add">+	    (buf-&gt;LastWriteTime == 0) &amp;&amp; (buf-&gt;ChangeTime) &amp;&amp;</span>
<span class="p_add">+	    (buf-&gt;Attributes == 0))</span>
<span class="p_add">+		return 0; /* would be a no op, no sense sending this */</span>
<span class="p_add">+</span>
 	tlink = cifs_sb_tlink(cifs_sb);
 	if (IS_ERR(tlink))
 		return PTR_ERR(tlink);
<span class="p_add">+</span>
 	rc = smb2_open_op_close(xid, tlink_tcon(tlink), cifs_sb, full_path,
 				FILE_WRITE_ATTRIBUTES, FILE_OPEN, 0, buf,
 				SMB2_OP_SET_INFO);
<span class="p_header">diff --git a/fs/cifs/smb2misc.c b/fs/cifs/smb2misc.c</span>
<span class="p_header">index 1c5907019045..e5bc85e49be7 100644</span>
<span class="p_header">--- a/fs/cifs/smb2misc.c</span>
<span class="p_header">+++ b/fs/cifs/smb2misc.c</span>
<span class="p_chunk">@@ -525,19 +525,19 @@</span> <span class="p_context"> smb2_is_valid_lease_break(char *buffer)</span>
 		list_for_each(tmp1, &amp;server-&gt;smb_ses_list) {
 			ses = list_entry(tmp1, struct cifs_ses, smb_ses_list);
 
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
 			list_for_each(tmp2, &amp;ses-&gt;tcon_list) {
 				tcon = list_entry(tmp2, struct cifs_tcon,
 						  tcon_list);
<span class="p_add">+				spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 				cifs_stats_inc(
 				    &amp;tcon-&gt;stats.cifs_stats.num_oplock_brks);
 				if (smb2_tcon_has_lease(tcon, rsp, lw)) {
<span class="p_del">-					spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+					spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 					spin_unlock(&amp;cifs_tcp_ses_lock);
 					return true;
 				}
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			}
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
 		}
 	}
 	spin_unlock(&amp;cifs_tcp_ses_lock);
<span class="p_chunk">@@ -579,7 +579,7 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 			tcon = list_entry(tmp1, struct cifs_tcon, tcon_list);
 
 			cifs_stats_inc(&amp;tcon-&gt;stats.cifs_stats.num_oplock_brks);
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			list_for_each(tmp2, &amp;tcon-&gt;openFileList) {
 				cfile = list_entry(tmp2, struct cifsFileInfo,
 						     tlist);
<span class="p_chunk">@@ -591,7 +591,7 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 
 				cifs_dbg(FYI, &quot;file id match, oplock break\n&quot;);
 				cinode = CIFS_I(d_inode(cfile-&gt;dentry));
<span class="p_del">-</span>
<span class="p_add">+				spin_lock(&amp;cfile-&gt;file_info_lock);</span>
 				if (!CIFS_CACHE_WRITE(cinode) &amp;&amp;
 				    rsp-&gt;OplockLevel == SMB2_OPLOCK_LEVEL_NONE)
 					cfile-&gt;oplock_break_cancelled = true;
<span class="p_chunk">@@ -613,14 +613,14 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 					clear_bit(
 					   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,
 					   &amp;cinode-&gt;flags);
<span class="p_del">-</span>
<span class="p_add">+				spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 				queue_work(cifsiod_wq, &amp;cfile-&gt;oplock_break);
 
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				spin_unlock(&amp;cifs_tcp_ses_lock);
 				return true;
 			}
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			spin_unlock(&amp;cifs_tcp_ses_lock);
 			cifs_dbg(FYI, &quot;No matching file for oplock break\n&quot;);
 			return true;
<span class="p_header">diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c</span>
<span class="p_header">index dd8543caa56e..be34b4860675 100644</span>
<span class="p_header">--- a/fs/cifs/smb2ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb2ops.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> SMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon)</span>
 		cifs_dbg(FYI, &quot;Link Speed %lld\n&quot;,
 			le64_to_cpu(out_buf-&gt;LinkSpeed));
 	}
<span class="p_del">-</span>
<span class="p_add">+	kfree(out_buf);</span>
 	return rc;
 }
 #endif /* STATS2 */
<span class="p_chunk">@@ -536,6 +536,7 @@</span> <span class="p_context"> smb2_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)</span>
 	server-&gt;ops-&gt;set_oplock_level(cinode, oplock, fid-&gt;epoch,
 				      &amp;fid-&gt;purge_cache);
 	cinode-&gt;can_cache_brlcks = CIFS_CACHE_WRITE(cinode);
<span class="p_add">+	memcpy(cfile-&gt;fid.create_guid, fid-&gt;create_guid, 16);</span>
 }
 
 static void
<span class="p_chunk">@@ -694,6 +695,7 @@</span> <span class="p_context"> smb2_clone_range(const unsigned int xid,</span>
 
 cchunk_out:
 	kfree(pcchunk);
<span class="p_add">+	kfree(retbuf);</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -818,7 +820,6 @@</span> <span class="p_context"> smb2_duplicate_extents(const unsigned int xid,</span>
 {
 	int rc;
 	unsigned int ret_data_len;
<span class="p_del">-	char *retbuf = NULL;</span>
 	struct duplicate_extents_to_file dup_ext_buf;
 	struct cifs_tcon *tcon = tlink_tcon(trgtfile-&gt;tlink);
 
<span class="p_chunk">@@ -844,7 +845,7 @@</span> <span class="p_context"> smb2_duplicate_extents(const unsigned int xid,</span>
 			FSCTL_DUPLICATE_EXTENTS_TO_FILE,
 			true /* is_fsctl */, (char *)&amp;dup_ext_buf,
 			sizeof(struct duplicate_extents_to_file),
<span class="p_del">-			(char **)&amp;retbuf,</span>
<span class="p_add">+			NULL,</span>
 			&amp;ret_data_len);
 
 	if (ret_data_len &gt; 0)
<span class="p_chunk">@@ -867,7 +868,6 @@</span> <span class="p_context"> smb3_set_integrity(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		   struct cifsFileInfo *cfile)
 {
 	struct fsctl_set_integrity_information_req integr_info;
<span class="p_del">-	char *retbuf = NULL;</span>
 	unsigned int ret_data_len;
 
 	integr_info.ChecksumAlgorithm = cpu_to_le16(CHECKSUM_TYPE_UNCHANGED);
<span class="p_chunk">@@ -879,7 +879,7 @@</span> <span class="p_context"> smb3_set_integrity(const unsigned int xid, struct cifs_tcon *tcon,</span>
 			FSCTL_SET_INTEGRITY_INFORMATION,
 			true /* is_fsctl */, (char *)&amp;integr_info,
 			sizeof(struct fsctl_set_integrity_information_req),
<span class="p_del">-			(char **)&amp;retbuf,</span>
<span class="p_add">+			NULL,</span>
 			&amp;ret_data_len);
 
 }
<span class="p_chunk">@@ -1036,7 +1036,7 @@</span> <span class="p_context"> smb2_set_lease_key(struct inode *inode, struct cifs_fid *fid)</span>
 static void
 smb2_new_lease_key(struct cifs_fid *fid)
 {
<span class="p_del">-	get_random_bytes(fid-&gt;lease_key, SMB2_LEASE_KEY_SIZE);</span>
<span class="p_add">+	generate_random_uuid(fid-&gt;lease_key);</span>
 }
 
 #define SMB2_SYMLINK_STRUCT_SIZE \
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 0b6dc1942bdc..0dbbdf5e4aee 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -103,7 +103,21 @@</span> <span class="p_context"> smb2_hdr_assemble(struct smb2_hdr *hdr, __le16 smb2_cmd /* command */ ,</span>
 	hdr-&gt;ProtocolId[3] = &#39;B&#39;;
 	hdr-&gt;StructureSize = cpu_to_le16(64);
 	hdr-&gt;Command = smb2_cmd;
<span class="p_del">-	hdr-&gt;CreditRequest = cpu_to_le16(2); /* BB make this dynamic */</span>
<span class="p_add">+	if (tcon &amp;&amp; tcon-&gt;ses &amp;&amp; tcon-&gt;ses-&gt;server) {</span>
<span class="p_add">+		struct TCP_Server_Info *server = tcon-&gt;ses-&gt;server;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;server-&gt;req_lock);</span>
<span class="p_add">+		/* Request up to 2 credits but don&#39;t go over the limit. */</span>
<span class="p_add">+		if (server-&gt;credits &gt;= SMB2_MAX_CREDITS_AVAILABLE)</span>
<span class="p_add">+			hdr-&gt;CreditRequest = cpu_to_le16(0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			hdr-&gt;CreditRequest = cpu_to_le16(</span>
<span class="p_add">+				min_t(int, SMB2_MAX_CREDITS_AVAILABLE -</span>
<span class="p_add">+						server-&gt;credits, 2));</span>
<span class="p_add">+		spin_unlock(&amp;server-&gt;req_lock);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hdr-&gt;CreditRequest = cpu_to_le16(2);</span>
<span class="p_add">+	}</span>
 	hdr-&gt;ProcessId = cpu_to_le32((__u16)current-&gt;tgid);
 
 	if (!tcon)
<span class="p_chunk">@@ -593,6 +607,7 @@</span> <span class="p_context"> SMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,</span>
 	char *security_blob = NULL;
 	unsigned char *ntlmssp_blob = NULL;
 	bool use_spnego = false; /* else use raw ntlmssp */
<span class="p_add">+	u64 previous_session = ses-&gt;Suid;</span>
 
 	cifs_dbg(FYI, &quot;Session Setup\n&quot;);
 
<span class="p_chunk">@@ -630,6 +645,10 @@</span> <span class="p_context"> ssetup_ntlmssp_authenticate:</span>
 		return rc;
 
 	req-&gt;hdr.SessionId = 0; /* First session, not a reauthenticate */
<span class="p_add">+</span>
<span class="p_add">+	/* if reconnect, we need to send previous sess id, otherwise it is 0 */</span>
<span class="p_add">+	req-&gt;PreviousSessionId = previous_session;</span>
<span class="p_add">+</span>
 	req-&gt;Flags = 0; /* MBZ */
 	/* to enable echos and oplocks */
 	req-&gt;hdr.CreditRequest = cpu_to_le16(3);
<span class="p_chunk">@@ -1167,7 +1186,7 @@</span> <span class="p_context"> create_durable_v2_buf(struct cifs_fid *pfid)</span>
 
 	buf-&gt;dcontext.Timeout = 0; /* Should this be configurable by workload */
 	buf-&gt;dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);
<span class="p_del">-	get_random_bytes(buf-&gt;dcontext.CreateGuid, 16);</span>
<span class="p_add">+	generate_random_uuid(buf-&gt;dcontext.CreateGuid);</span>
 	memcpy(pfid-&gt;create_guid, buf-&gt;dcontext.CreateGuid, 16);
 
 	/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is &quot;DH2Q&quot; */
<span class="p_chunk">@@ -2059,6 +2078,7 @@</span> <span class="p_context"> smb2_async_readv(struct cifs_readdata *rdata)</span>
 	if (rdata-&gt;credits) {
 		buf-&gt;CreditCharge = cpu_to_le16(DIV_ROUND_UP(rdata-&gt;bytes,
 						SMB2_MAX_BUFFER_SIZE));
<span class="p_add">+		buf-&gt;CreditRequest = buf-&gt;CreditCharge;</span>
 		spin_lock(&amp;server-&gt;req_lock);
 		server-&gt;credits += rdata-&gt;credits -
 						le16_to_cpu(buf-&gt;CreditCharge);
<span class="p_chunk">@@ -2245,6 +2265,7 @@</span> <span class="p_context"> smb2_async_writev(struct cifs_writedata *wdata,</span>
 	if (wdata-&gt;credits) {
 		req-&gt;hdr.CreditCharge = cpu_to_le16(DIV_ROUND_UP(wdata-&gt;bytes,
 						    SMB2_MAX_BUFFER_SIZE));
<span class="p_add">+		req-&gt;hdr.CreditRequest = req-&gt;hdr.CreditCharge;</span>
 		spin_lock(&amp;server-&gt;req_lock);
 		server-&gt;credits += wdata-&gt;credits -
 					le16_to_cpu(req-&gt;hdr.CreditCharge);
<span class="p_header">diff --git a/fs/cifs/smb2pdu.h b/fs/cifs/smb2pdu.h</span>
<span class="p_header">index 4af52780ec35..b8f553b32dda 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.h</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.h</span>
<span class="p_chunk">@@ -276,7 +276,7 @@</span> <span class="p_context"> struct smb2_sess_setup_req {</span>
 	__le32 Channel;
 	__le16 SecurityBufferOffset;
 	__le16 SecurityBufferLength;
<span class="p_del">-	__le64 PreviousSessionId;</span>
<span class="p_add">+	__u64 PreviousSessionId;</span>
 	__u8   Buffer[1];	/* variable length GSS security buffer */
 } __packed;
 
<span class="p_header">diff --git a/fs/ext4/sysfs.c b/fs/ext4/sysfs.c</span>
<span class="p_header">index 1420a3c614af..5d09ea585840 100644</span>
<span class="p_header">--- a/fs/ext4/sysfs.c</span>
<span class="p_header">+++ b/fs/ext4/sysfs.c</span>
<span class="p_chunk">@@ -223,14 +223,18 @@</span> <span class="p_context"> static struct attribute *ext4_attrs[] = {</span>
 EXT4_ATTR_FEATURE(lazy_itable_init);
 EXT4_ATTR_FEATURE(batched_discard);
 EXT4_ATTR_FEATURE(meta_bg_resize);
<span class="p_add">+#ifdef CONFIG_EXT4_FS_ENCRYPTION</span>
 EXT4_ATTR_FEATURE(encryption);
<span class="p_add">+#endif</span>
 EXT4_ATTR_FEATURE(metadata_csum_seed);
 
 static struct attribute *ext4_feat_attrs[] = {
 	ATTR_LIST(lazy_itable_init),
 	ATTR_LIST(batched_discard),
 	ATTR_LIST(meta_bg_resize),
<span class="p_add">+#ifdef CONFIG_EXT4_FS_ENCRYPTION</span>
 	ATTR_LIST(encryption),
<span class="p_add">+#endif</span>
 	ATTR_LIST(metadata_csum_seed),
 	NULL,
 };
<span class="p_header">diff --git a/fs/isofs/inode.c b/fs/isofs/inode.c</span>
<span class="p_header">index d67a16f2a45d..350f67fb5b9c 100644</span>
<span class="p_header">--- a/fs/isofs/inode.c</span>
<span class="p_header">+++ b/fs/isofs/inode.c</span>
<span class="p_chunk">@@ -690,6 +690,11 @@</span> <span class="p_context"> static int isofs_fill_super(struct super_block *s, void *data, int silent)</span>
 	pri_bh = NULL;
 
 root_found:
<span class="p_add">+	/* We don&#39;t support read-write mounts */</span>
<span class="p_add">+	if (!(s-&gt;s_flags &amp; MS_RDONLY)) {</span>
<span class="p_add">+		error = -EACCES;</span>
<span class="p_add">+		goto out_freebh;</span>
<span class="p_add">+	}</span>
 
 	if (joliet_level &amp;&amp; (pri == NULL || !opt.rock)) {
 		/* This is the case of Joliet with the norock mount flag.
<span class="p_chunk">@@ -1503,9 +1508,6 @@</span> <span class="p_context"> struct inode *__isofs_iget(struct super_block *sb,</span>
 static struct dentry *isofs_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
<span class="p_del">-	/* We don&#39;t support read-write mounts */</span>
<span class="p_del">-	if (!(flags &amp; MS_RDONLY))</span>
<span class="p_del">-		return ERR_PTR(-EACCES);</span>
 	return mount_bdev(fs_type, flags, dev_name, data, isofs_fill_super);
 }
 
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index ca181e81c765..fa1b8e0dcacf 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -1156,6 +1156,7 @@</span> <span class="p_context"> int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)</span>
 		JBUFFER_TRACE(jh, &quot;file as BJ_Reserved&quot;);
 		spin_lock(&amp;journal-&gt;j_list_lock);
 		__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);
<span class="p_add">+		spin_unlock(&amp;journal-&gt;j_list_lock);</span>
 	} else if (jh-&gt;b_transaction == journal-&gt;j_committing_transaction) {
 		/* first access by this transaction */
 		jh-&gt;b_modified = 0;
<span class="p_chunk">@@ -1163,8 +1164,8 @@</span> <span class="p_context"> int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)</span>
 		JBUFFER_TRACE(jh, &quot;set next transaction&quot;);
 		spin_lock(&amp;journal-&gt;j_list_lock);
 		jh-&gt;b_next_transaction = transaction;
<span class="p_add">+		spin_unlock(&amp;journal-&gt;j_list_lock);</span>
 	}
<span class="p_del">-	spin_unlock(&amp;journal-&gt;j_list_lock);</span>
 	jbd_unlock_bh_state(bh);
 
 	/*
<span class="p_header">diff --git a/fs/nfs/delegation.c b/fs/nfs/delegation.c</span>
<span class="p_header">index 5166adcfc0fb..7af5eeabc80e 100644</span>
<span class="p_header">--- a/fs/nfs/delegation.c</span>
<span class="p_header">+++ b/fs/nfs/delegation.c</span>
<span class="p_chunk">@@ -41,6 +41,17 @@</span> <span class="p_context"> void nfs_mark_delegation_referenced(struct nfs_delegation *delegation)</span>
 	set_bit(NFS_DELEGATION_REFERENCED, &amp;delegation-&gt;flags);
 }
 
<span class="p_add">+static bool</span>
<span class="p_add">+nfs4_is_valid_delegation(const struct nfs_delegation *delegation,</span>
<span class="p_add">+		fmode_t flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (delegation != NULL &amp;&amp; (delegation-&gt;type &amp; flags) == flags &amp;&amp;</span>
<span class="p_add">+	    !test_bit(NFS_DELEGATION_REVOKED, &amp;delegation-&gt;flags) &amp;&amp;</span>
<span class="p_add">+	    !test_bit(NFS_DELEGATION_RETURNING, &amp;delegation-&gt;flags))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 nfs4_do_check_delegation(struct inode *inode, fmode_t flags, bool mark)
 {
<span class="p_chunk">@@ -50,8 +61,7 @@</span> <span class="p_context"> nfs4_do_check_delegation(struct inode *inode, fmode_t flags, bool mark)</span>
 	flags &amp;= FMODE_READ|FMODE_WRITE;
 	rcu_read_lock();
 	delegation = rcu_dereference(NFS_I(inode)-&gt;delegation);
<span class="p_del">-	if (delegation != NULL &amp;&amp; (delegation-&gt;type &amp; flags) == flags &amp;&amp;</span>
<span class="p_del">-	    !test_bit(NFS_DELEGATION_RETURNING, &amp;delegation-&gt;flags)) {</span>
<span class="p_add">+	if (nfs4_is_valid_delegation(delegation, flags)) {</span>
 		if (mark)
 			nfs_mark_delegation_referenced(delegation);
 		ret = 1;
<span class="p_chunk">@@ -892,7 +902,7 @@</span> <span class="p_context"> bool nfs4_copy_delegation_stateid(nfs4_stateid *dst, struct inode *inode,</span>
 	flags &amp;= FMODE_READ|FMODE_WRITE;
 	rcu_read_lock();
 	delegation = rcu_dereference(nfsi-&gt;delegation);
<span class="p_del">-	ret = (delegation != NULL &amp;&amp; (delegation-&gt;type &amp; flags) == flags);</span>
<span class="p_add">+	ret = nfs4_is_valid_delegation(delegation, flags);</span>
 	if (ret) {
 		nfs4_stateid_copy(dst, &amp;delegation-&gt;stateid);
 		nfs_mark_delegation_referenced(delegation);
<span class="p_header">diff --git a/fs/nfs/nfs42proc.c b/fs/nfs/nfs42proc.c</span>
<span class="p_header">index 6b1ce9825430..7f1a0fb8c493 100644</span>
<span class="p_header">--- a/fs/nfs/nfs42proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs42proc.c</span>
<span class="p_chunk">@@ -269,6 +269,7 @@</span> <span class="p_context"> int nfs42_proc_layoutstats_generic(struct nfs_server *server,</span>
 	task = rpc_run_task(&amp;task_setup);
 	if (IS_ERR(task))
 		return PTR_ERR(task);
<span class="p_add">+	rpc_put_task(task);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index d854693a15b0..82dc3035ea45 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1493,6 +1493,9 @@</span> <span class="p_context"> restart:</span>
 					__func__, status);
 			case -ENOENT:
 			case -ENOMEM:
<span class="p_add">+			case -EACCES:</span>
<span class="p_add">+			case -EROFS:</span>
<span class="p_add">+			case -EIO:</span>
 			case -ESTALE:
 				/* Open state on this file cannot be recovered */
 				nfs4_state_mark_recovery_failed(state, status);
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index 9e52609cd683..ea0dd9ee138d 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"> int ovl_copy_xattr(struct dentry *old, struct dentry *new)</span>
 	ssize_t list_size, size, value_size = 0;
 	char *buf, *name, *value = NULL;
 	int uninitialized_var(error);
<span class="p_add">+	size_t slen;</span>
 
 	if (!old-&gt;d_inode-&gt;i_op-&gt;getxattr ||
 	    !new-&gt;d_inode-&gt;i_op-&gt;getxattr)
<span class="p_chunk">@@ -47,7 +48,16 @@</span> <span class="p_context"> int ovl_copy_xattr(struct dentry *old, struct dentry *new)</span>
 		goto out;
 	}
 
<span class="p_del">-	for (name = buf; name &lt; (buf + list_size); name += strlen(name) + 1) {</span>
<span class="p_add">+	for (name = buf; list_size; name += slen) {</span>
<span class="p_add">+		slen = strnlen(name, list_size) + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* underlying fs providing us with an broken xattr list? */</span>
<span class="p_add">+		if (WARN_ON(slen &gt; list_size)) {</span>
<span class="p_add">+			error = -EIO;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		list_size -= slen;</span>
<span class="p_add">+</span>
 		if (ovl_is_private_xattr(name))
 			continue;
 retry:
<span class="p_header">diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c</span>
<span class="p_header">index ba5ef733951f..327177df03a5 100644</span>
<span class="p_header">--- a/fs/overlayfs/dir.c</span>
<span class="p_header">+++ b/fs/overlayfs/dir.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/xattr.h&gt;
 #include &lt;linux/security.h&gt;
 #include &lt;linux/cred.h&gt;
<span class="p_add">+#include &lt;linux/atomic.h&gt;</span>
 #include &quot;overlayfs.h&quot;
 
 void ovl_cleanup(struct inode *wdir, struct dentry *wdentry)
<span class="p_chunk">@@ -35,8 +36,10 @@</span> <span class="p_context"> struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)</span>
 {
 	struct dentry *temp;
 	char name[20];
<span class="p_add">+	static atomic_t temp_id = ATOMIC_INIT(0);</span>
 
<span class="p_del">-	snprintf(name, sizeof(name), &quot;#%lx&quot;, (unsigned long) dentry);</span>
<span class="p_add">+	/* counter is allowed to wrap, since temp dentries are ephemeral */</span>
<span class="p_add">+	snprintf(name, sizeof(name), &quot;#%x&quot;, atomic_inc_return(&amp;temp_id));</span>
 
 	temp = lookup_one_len(name, workdir, strlen(name));
 	if (!IS_ERR(temp) &amp;&amp; temp-&gt;d_inode) {
<span class="p_header">diff --git a/fs/pstore/ram.c b/fs/pstore/ram.c</span>
<span class="p_header">index 319c3a60cfa5..905caba36529 100644</span>
<span class="p_header">--- a/fs/pstore/ram.c</span>
<span class="p_header">+++ b/fs/pstore/ram.c</span>
<span class="p_chunk">@@ -375,13 +375,14 @@</span> <span class="p_context"> static void ramoops_free_przs(struct ramoops_context *cxt)</span>
 {
 	int i;
 
<span class="p_del">-	cxt-&gt;max_dump_cnt = 0;</span>
 	if (!cxt-&gt;przs)
 		return;
 
<span class="p_del">-	for (i = 0; !IS_ERR_OR_NULL(cxt-&gt;przs[i]); i++)</span>
<span class="p_add">+	for (i = 0; i &lt; cxt-&gt;max_dump_cnt; i++)</span>
 		persistent_ram_free(cxt-&gt;przs[i]);
<span class="p_add">+</span>
 	kfree(cxt-&gt;przs);
<span class="p_add">+	cxt-&gt;max_dump_cnt = 0;</span>
 }
 
 static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,
<span class="p_chunk">@@ -406,7 +407,7 @@</span> <span class="p_context"> static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,</span>
 			     GFP_KERNEL);
 	if (!cxt-&gt;przs) {
 		dev_err(dev, &quot;failed to initialize a prz array for dumps\n&quot;);
<span class="p_del">-		goto fail_prz;</span>
<span class="p_add">+		goto fail_mem;</span>
 	}
 
 	for (i = 0; i &lt; cxt-&gt;max_dump_cnt; i++) {
<span class="p_chunk">@@ -417,6 +418,11 @@</span> <span class="p_context"> static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,</span>
 			err = PTR_ERR(cxt-&gt;przs[i]);
 			dev_err(dev, &quot;failed to request mem region (0x%zx@0x%llx): %d\n&quot;,
 				cxt-&gt;record_size, (unsigned long long)*paddr, err);
<span class="p_add">+</span>
<span class="p_add">+			while (i &gt; 0) {</span>
<span class="p_add">+				i--;</span>
<span class="p_add">+				persistent_ram_free(cxt-&gt;przs[i]);</span>
<span class="p_add">+			}</span>
 			goto fail_prz;
 		}
 		*paddr += cxt-&gt;record_size;
<span class="p_chunk">@@ -424,7 +430,9 @@</span> <span class="p_context"> static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,</span>
 
 	return 0;
 fail_prz:
<span class="p_del">-	ramoops_free_przs(cxt);</span>
<span class="p_add">+	kfree(cxt-&gt;przs);</span>
<span class="p_add">+fail_mem:</span>
<span class="p_add">+	cxt-&gt;max_dump_cnt = 0;</span>
 	return err;
 }
 
<span class="p_chunk">@@ -583,7 +591,6 @@</span> <span class="p_context"> static int ramoops_remove(struct platform_device *pdev)</span>
 	struct ramoops_context *cxt = &amp;oops_cxt;
 
 	pstore_unregister(&amp;cxt-&gt;pstore);
<span class="p_del">-	cxt-&gt;max_dump_cnt = 0;</span>
 
 	kfree(cxt-&gt;pstore.buf);
 	cxt-&gt;pstore.bufsize = 0;
<span class="p_header">diff --git a/fs/pstore/ram_core.c b/fs/pstore/ram_core.c</span>
<span class="p_header">index 76c3f80efdfa..364d2dffe5a6 100644</span>
<span class="p_header">--- a/fs/pstore/ram_core.c</span>
<span class="p_header">+++ b/fs/pstore/ram_core.c</span>
<span class="p_chunk">@@ -47,43 +47,10 @@</span> <span class="p_context"> static inline size_t buffer_start(struct persistent_ram_zone *prz)</span>
 	return atomic_read(&amp;prz-&gt;buffer-&gt;start);
 }
 
<span class="p_del">-/* increase and wrap the start pointer, returning the old value */</span>
<span class="p_del">-static size_t buffer_start_add_atomic(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int old;</span>
<span class="p_del">-	int new;</span>
<span class="p_del">-</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		old = atomic_read(&amp;prz-&gt;buffer-&gt;start);</span>
<span class="p_del">-		new = old + a;</span>
<span class="p_del">-		while (unlikely(new &gt;= prz-&gt;buffer_size))</span>
<span class="p_del">-			new -= prz-&gt;buffer_size;</span>
<span class="p_del">-	} while (atomic_cmpxchg(&amp;prz-&gt;buffer-&gt;start, old, new) != old);</span>
<span class="p_del">-</span>
<span class="p_del">-	return old;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* increase the size counter until it hits the max size */</span>
<span class="p_del">-static void buffer_size_add_atomic(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_del">-{</span>
<span class="p_del">-	size_t old;</span>
<span class="p_del">-	size_t new;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (atomic_read(&amp;prz-&gt;buffer-&gt;size) == prz-&gt;buffer_size)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		old = atomic_read(&amp;prz-&gt;buffer-&gt;size);</span>
<span class="p_del">-		new = old + a;</span>
<span class="p_del">-		if (new &gt; prz-&gt;buffer_size)</span>
<span class="p_del">-			new = prz-&gt;buffer_size;</span>
<span class="p_del">-	} while (atomic_cmpxchg(&amp;prz-&gt;buffer-&gt;size, old, new) != old);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static DEFINE_RAW_SPINLOCK(buffer_lock);
 
 /* increase and wrap the start pointer, returning the old value */
<span class="p_del">-static size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_add">+static size_t buffer_start_add(struct persistent_ram_zone *prz, size_t a)</span>
 {
 	int old;
 	int new;
<span class="p_chunk">@@ -103,7 +70,7 @@</span> <span class="p_context"> static size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)</span>
 }
 
 /* increase the size counter until it hits the max size */
<span class="p_del">-static void buffer_size_add_locked(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_add">+static void buffer_size_add(struct persistent_ram_zone *prz, size_t a)</span>
 {
 	size_t old;
 	size_t new;
<span class="p_chunk">@@ -124,9 +91,6 @@</span> <span class="p_context"> exit:</span>
 	raw_spin_unlock_irqrestore(&amp;buffer_lock, flags);
 }
 
<span class="p_del">-static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;</span>
<span class="p_del">-static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;</span>
<span class="p_del">-</span>
 static void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,
 	uint8_t *data, size_t len, uint8_t *ecc)
 {
<span class="p_chunk">@@ -299,7 +263,7 @@</span> <span class="p_context"> static void notrace persistent_ram_update(struct persistent_ram_zone *prz,</span>
 	const void *s, unsigned int start, unsigned int count)
 {
 	struct persistent_ram_buffer *buffer = prz-&gt;buffer;
<span class="p_del">-	memcpy(buffer-&gt;data + start, s, count);</span>
<span class="p_add">+	memcpy_toio(buffer-&gt;data + start, s, count);</span>
 	persistent_ram_update_ecc(prz, start, count);
 }
 
<span class="p_chunk">@@ -322,8 +286,8 @@</span> <span class="p_context"> void persistent_ram_save_old(struct persistent_ram_zone *prz)</span>
 	}
 
 	prz-&gt;old_log_size = size;
<span class="p_del">-	memcpy(prz-&gt;old_log, &amp;buffer-&gt;data[start], size - start);</span>
<span class="p_del">-	memcpy(prz-&gt;old_log + size - start, &amp;buffer-&gt;data[0], start);</span>
<span class="p_add">+	memcpy_fromio(prz-&gt;old_log, &amp;buffer-&gt;data[start], size - start);</span>
<span class="p_add">+	memcpy_fromio(prz-&gt;old_log + size - start, &amp;buffer-&gt;data[0], start);</span>
 }
 
 int notrace persistent_ram_write(struct persistent_ram_zone *prz,
<span class="p_chunk">@@ -426,9 +390,6 @@</span> <span class="p_context"> static void *persistent_ram_iomap(phys_addr_t start, size_t size,</span>
 		return NULL;
 	}
 
<span class="p_del">-	buffer_start_add = buffer_start_add_locked;</span>
<span class="p_del">-	buffer_size_add = buffer_size_add_locked;</span>
<span class="p_del">-</span>
 	if (memtype)
 		va = ioremap(start, size);
 	else
<span class="p_header">diff --git a/fs/super.c b/fs/super.c</span>
<span class="p_header">index f5f4b328f860..d4d2591b77c8 100644</span>
<span class="p_header">--- a/fs/super.c</span>
<span class="p_header">+++ b/fs/super.c</span>
<span class="p_chunk">@@ -1326,8 +1326,8 @@</span> <span class="p_context"> int freeze_super(struct super_block *sb)</span>
 		}
 	}
 	/*
<span class="p_del">-	 * This is just for debugging purposes so that fs can warn if it</span>
<span class="p_del">-	 * sees write activity when frozen is set to SB_FREEZE_COMPLETE.</span>
<span class="p_add">+	 * For debugging purposes so that fs can warn if it sees write activity</span>
<span class="p_add">+	 * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().</span>
 	 */
 	sb-&gt;s_writers.frozen = SB_FREEZE_COMPLETE;
 	up_write(&amp;sb-&gt;s_umount);
<span class="p_chunk">@@ -1346,7 +1346,7 @@</span> <span class="p_context"> int thaw_super(struct super_block *sb)</span>
 	int error;
 
 	down_write(&amp;sb-&gt;s_umount);
<span class="p_del">-	if (sb-&gt;s_writers.frozen == SB_UNFROZEN) {</span>
<span class="p_add">+	if (sb-&gt;s_writers.frozen != SB_FREEZE_COMPLETE) {</span>
 		up_write(&amp;sb-&gt;s_umount);
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/fs/ubifs/xattr.c b/fs/ubifs/xattr.c</span>
<span class="p_header">index e8b01b721e99..b5bf23b34241 100644</span>
<span class="p_header">--- a/fs/ubifs/xattr.c</span>
<span class="p_header">+++ b/fs/ubifs/xattr.c</span>
<span class="p_chunk">@@ -173,6 +173,7 @@</span> <span class="p_context"> out_cancel:</span>
 	host_ui-&gt;xattr_cnt -= 1;
 	host_ui-&gt;xattr_size -= CALC_DENT_SIZE(nm-&gt;len);
 	host_ui-&gt;xattr_size -= CALC_XATTR_BYTES(size);
<span class="p_add">+	host_ui-&gt;xattr_names -= nm-&gt;len;</span>
 	mutex_unlock(&amp;host_ui-&gt;ui_mutex);
 out_free:
 	make_bad_inode(inode);
<span class="p_chunk">@@ -533,6 +534,7 @@</span> <span class="p_context"> out_cancel:</span>
 	host_ui-&gt;xattr_cnt += 1;
 	host_ui-&gt;xattr_size += CALC_DENT_SIZE(nm-&gt;len);
 	host_ui-&gt;xattr_size += CALC_XATTR_BYTES(ui-&gt;data_len);
<span class="p_add">+	host_ui-&gt;xattr_names += nm-&gt;len;</span>
 	mutex_unlock(&amp;host_ui-&gt;ui_mutex);
 	ubifs_release_budget(c, &amp;req);
 	make_bad_inode(inode);
<span class="p_header">diff --git a/include/linux/devfreq-event.h b/include/linux/devfreq-event.h</span>
<span class="p_header">index 0a83a1e648b0..4db00b02ca3f 100644</span>
<span class="p_header">--- a/include/linux/devfreq-event.h</span>
<span class="p_header">+++ b/include/linux/devfreq-event.h</span>
<span class="p_chunk">@@ -148,11 +148,6 @@</span> <span class="p_context"> static inline int devfreq_event_reset_event(struct devfreq_event_dev *edev)</span>
 	return -EINVAL;
 }
 
<span class="p_del">-static inline void *devfreq_event_get_drvdata(struct devfreq_event_dev *edev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return ERR_PTR(-EINVAL);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline struct devfreq_event_dev *devfreq_event_get_edev_by_phandle(
 					struct device *dev, int index)
 {
<span class="p_header">diff --git a/include/linux/irqchip/arm-gic-v3.h b/include/linux/irqchip/arm-gic-v3.h</span>
<span class="p_header">index e98425058f20..54048f336a1f 100644</span>
<span class="p_header">--- a/include/linux/irqchip/arm-gic-v3.h</span>
<span class="p_header">+++ b/include/linux/irqchip/arm-gic-v3.h</span>
<span class="p_chunk">@@ -218,7 +218,7 @@</span> <span class="p_context"></span>
 #define GITS_BASER_TYPE_SHIFT		(56)
 #define GITS_BASER_TYPE(r)		(((r) &gt;&gt; GITS_BASER_TYPE_SHIFT) &amp; 7)
 #define GITS_BASER_ENTRY_SIZE_SHIFT	(48)
<span class="p_del">-#define GITS_BASER_ENTRY_SIZE(r)	((((r) &gt;&gt; GITS_BASER_ENTRY_SIZE_SHIFT) &amp; 0xff) + 1)</span>
<span class="p_add">+#define GITS_BASER_ENTRY_SIZE(r)	((((r) &gt;&gt; GITS_BASER_ENTRY_SIZE_SHIFT) &amp; 0x1f) + 1)</span>
 #define GITS_BASER_NonShareable		(0UL &lt;&lt; 10)
 #define GITS_BASER_InnerShareable	(1UL &lt;&lt; 10)
 #define GITS_BASER_OuterShareable	(2UL &lt;&lt; 10)
<span class="p_header">diff --git a/include/linux/kernel.h b/include/linux/kernel.h</span>
<span class="p_header">index e571e592e53a..50220cab738c 100644</span>
<span class="p_header">--- a/include/linux/kernel.h</span>
<span class="p_header">+++ b/include/linux/kernel.h</span>
<span class="p_chunk">@@ -356,6 +356,7 @@</span> <span class="p_context"> int __must_check kstrtou16(const char *s, unsigned int base, u16 *res);</span>
 int __must_check kstrtos16(const char *s, unsigned int base, s16 *res);
 int __must_check kstrtou8(const char *s, unsigned int base, u8 *res);
 int __must_check kstrtos8(const char *s, unsigned int base, s8 *res);
<span class="p_add">+int __must_check kstrtobool(const char *s, bool *res);</span>
 
 int __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);
 int __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);
<span class="p_chunk">@@ -367,6 +368,7 @@</span> <span class="p_context"> int __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigne</span>
 int __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);
 int __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);
 int __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);
<span class="p_add">+int __must_check kstrtobool_from_user(const char __user *s, size_t count, bool *res);</span>
 
 static inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)
 {
<span class="p_header">diff --git a/include/linux/lightnvm.h b/include/linux/lightnvm.h</span>
<span class="p_header">index f09648d14694..782d4e814e21 100644</span>
<span class="p_header">--- a/include/linux/lightnvm.h</span>
<span class="p_header">+++ b/include/linux/lightnvm.h</span>
<span class="p_chunk">@@ -1,6 +1,8 @@</span> <span class="p_context"></span>
 #ifndef NVM_H
 #define NVM_H
 
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
 enum {
 	NVM_IO_OK = 0,
 	NVM_IO_REQUEUE = 1,
<span class="p_chunk">@@ -11,10 +13,71 @@</span> <span class="p_context"> enum {</span>
 	NVM_IOTYPE_GC = 1,
 };
 
<span class="p_add">+#define NVM_BLK_BITS (16)</span>
<span class="p_add">+#define NVM_PG_BITS  (16)</span>
<span class="p_add">+#define NVM_SEC_BITS (8)</span>
<span class="p_add">+#define NVM_PL_BITS  (8)</span>
<span class="p_add">+#define NVM_LUN_BITS (8)</span>
<span class="p_add">+#define NVM_CH_BITS  (8)</span>
<span class="p_add">+</span>
<span class="p_add">+struct ppa_addr {</span>
<span class="p_add">+	/* Generic structure for all addresses */</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			u64 blk		: NVM_BLK_BITS;</span>
<span class="p_add">+			u64 pg		: NVM_PG_BITS;</span>
<span class="p_add">+			u64 sec		: NVM_SEC_BITS;</span>
<span class="p_add">+			u64 pl		: NVM_PL_BITS;</span>
<span class="p_add">+			u64 lun		: NVM_LUN_BITS;</span>
<span class="p_add">+			u64 ch		: NVM_CH_BITS;</span>
<span class="p_add">+		} g;</span>
<span class="p_add">+</span>
<span class="p_add">+		u64 ppa;</span>
<span class="p_add">+	};</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct nvm_rq;</span>
<span class="p_add">+struct nvm_id;</span>
<span class="p_add">+struct nvm_dev;</span>
<span class="p_add">+</span>
<span class="p_add">+typedef int (nvm_l2p_update_fn)(u64, u32, __le64 *, void *);</span>
<span class="p_add">+typedef int (nvm_bb_update_fn)(struct ppa_addr, int, u8 *, void *);</span>
<span class="p_add">+typedef int (nvm_id_fn)(struct nvm_dev *, struct nvm_id *);</span>
<span class="p_add">+typedef int (nvm_get_l2p_tbl_fn)(struct nvm_dev *, u64, u32,</span>
<span class="p_add">+				nvm_l2p_update_fn *, void *);</span>
<span class="p_add">+typedef int (nvm_op_bb_tbl_fn)(struct nvm_dev *, struct ppa_addr, int,</span>
<span class="p_add">+				nvm_bb_update_fn *, void *);</span>
<span class="p_add">+typedef int (nvm_op_set_bb_fn)(struct nvm_dev *, struct nvm_rq *, int);</span>
<span class="p_add">+typedef int (nvm_submit_io_fn)(struct nvm_dev *, struct nvm_rq *);</span>
<span class="p_add">+typedef int (nvm_erase_blk_fn)(struct nvm_dev *, struct nvm_rq *);</span>
<span class="p_add">+typedef void *(nvm_create_dma_pool_fn)(struct nvm_dev *, char *);</span>
<span class="p_add">+typedef void (nvm_destroy_dma_pool_fn)(void *);</span>
<span class="p_add">+typedef void *(nvm_dev_dma_alloc_fn)(struct nvm_dev *, void *, gfp_t,</span>
<span class="p_add">+								dma_addr_t *);</span>
<span class="p_add">+typedef void (nvm_dev_dma_free_fn)(void *, void*, dma_addr_t);</span>
<span class="p_add">+</span>
<span class="p_add">+struct nvm_dev_ops {</span>
<span class="p_add">+	nvm_id_fn		*identity;</span>
<span class="p_add">+	nvm_get_l2p_tbl_fn	*get_l2p_tbl;</span>
<span class="p_add">+	nvm_op_bb_tbl_fn	*get_bb_tbl;</span>
<span class="p_add">+	nvm_op_set_bb_fn	*set_bb_tbl;</span>
<span class="p_add">+</span>
<span class="p_add">+	nvm_submit_io_fn	*submit_io;</span>
<span class="p_add">+	nvm_erase_blk_fn	*erase_block;</span>
<span class="p_add">+</span>
<span class="p_add">+	nvm_create_dma_pool_fn	*create_dma_pool;</span>
<span class="p_add">+	nvm_destroy_dma_pool_fn	*destroy_dma_pool;</span>
<span class="p_add">+	nvm_dev_dma_alloc_fn	*dev_dma_alloc;</span>
<span class="p_add">+	nvm_dev_dma_free_fn	*dev_dma_free;</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned int		max_phys_sect;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 #ifdef CONFIG_NVM
 
 #include &lt;linux/blkdev.h&gt;
<span class="p_del">-#include &lt;linux/types.h&gt;</span>
 #include &lt;linux/file.h&gt;
 #include &lt;linux/dmapool.h&gt;
 
<span class="p_chunk">@@ -126,29 +189,6 @@</span> <span class="p_context"> struct nvm_tgt_instance {</span>
 #define NVM_VERSION_MINOR 0
 #define NVM_VERSION_PATCH 0
 
<span class="p_del">-#define NVM_BLK_BITS (16)</span>
<span class="p_del">-#define NVM_PG_BITS  (16)</span>
<span class="p_del">-#define NVM_SEC_BITS (8)</span>
<span class="p_del">-#define NVM_PL_BITS  (8)</span>
<span class="p_del">-#define NVM_LUN_BITS (8)</span>
<span class="p_del">-#define NVM_CH_BITS  (8)</span>
<span class="p_del">-</span>
<span class="p_del">-struct ppa_addr {</span>
<span class="p_del">-	/* Generic structure for all addresses */</span>
<span class="p_del">-	union {</span>
<span class="p_del">-		struct {</span>
<span class="p_del">-			u64 blk		: NVM_BLK_BITS;</span>
<span class="p_del">-			u64 pg		: NVM_PG_BITS;</span>
<span class="p_del">-			u64 sec		: NVM_SEC_BITS;</span>
<span class="p_del">-			u64 pl		: NVM_PL_BITS;</span>
<span class="p_del">-			u64 lun		: NVM_LUN_BITS;</span>
<span class="p_del">-			u64 ch		: NVM_CH_BITS;</span>
<span class="p_del">-		} g;</span>
<span class="p_del">-</span>
<span class="p_del">-		u64 ppa;</span>
<span class="p_del">-	};</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 struct nvm_rq {
 	struct nvm_tgt_instance *ins;
 	struct nvm_dev *dev;
<span class="p_chunk">@@ -182,39 +222,6 @@</span> <span class="p_context"> static inline void *nvm_rq_to_pdu(struct nvm_rq *rqdata)</span>
 
 struct nvm_block;
 
<span class="p_del">-typedef int (nvm_l2p_update_fn)(u64, u32, __le64 *, void *);</span>
<span class="p_del">-typedef int (nvm_bb_update_fn)(struct ppa_addr, int, u8 *, void *);</span>
<span class="p_del">-typedef int (nvm_id_fn)(struct nvm_dev *, struct nvm_id *);</span>
<span class="p_del">-typedef int (nvm_get_l2p_tbl_fn)(struct nvm_dev *, u64, u32,</span>
<span class="p_del">-				nvm_l2p_update_fn *, void *);</span>
<span class="p_del">-typedef int (nvm_op_bb_tbl_fn)(struct nvm_dev *, struct ppa_addr, int,</span>
<span class="p_del">-				nvm_bb_update_fn *, void *);</span>
<span class="p_del">-typedef int (nvm_op_set_bb_fn)(struct nvm_dev *, struct nvm_rq *, int);</span>
<span class="p_del">-typedef int (nvm_submit_io_fn)(struct nvm_dev *, struct nvm_rq *);</span>
<span class="p_del">-typedef int (nvm_erase_blk_fn)(struct nvm_dev *, struct nvm_rq *);</span>
<span class="p_del">-typedef void *(nvm_create_dma_pool_fn)(struct nvm_dev *, char *);</span>
<span class="p_del">-typedef void (nvm_destroy_dma_pool_fn)(void *);</span>
<span class="p_del">-typedef void *(nvm_dev_dma_alloc_fn)(struct nvm_dev *, void *, gfp_t,</span>
<span class="p_del">-								dma_addr_t *);</span>
<span class="p_del">-typedef void (nvm_dev_dma_free_fn)(void *, void*, dma_addr_t);</span>
<span class="p_del">-</span>
<span class="p_del">-struct nvm_dev_ops {</span>
<span class="p_del">-	nvm_id_fn		*identity;</span>
<span class="p_del">-	nvm_get_l2p_tbl_fn	*get_l2p_tbl;</span>
<span class="p_del">-	nvm_op_bb_tbl_fn	*get_bb_tbl;</span>
<span class="p_del">-	nvm_op_set_bb_fn	*set_bb_tbl;</span>
<span class="p_del">-</span>
<span class="p_del">-	nvm_submit_io_fn	*submit_io;</span>
<span class="p_del">-	nvm_erase_blk_fn	*erase_block;</span>
<span class="p_del">-</span>
<span class="p_del">-	nvm_create_dma_pool_fn	*create_dma_pool;</span>
<span class="p_del">-	nvm_destroy_dma_pool_fn	*destroy_dma_pool;</span>
<span class="p_del">-	nvm_dev_dma_alloc_fn	*dev_dma_alloc;</span>
<span class="p_del">-	nvm_dev_dma_free_fn	*dev_dma_free;</span>
<span class="p_del">-</span>
<span class="p_del">-	unsigned int		max_phys_sect;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 struct nvm_lun {
 	int id;
 
<span class="p_header">diff --git a/include/linux/sem.h b/include/linux/sem.h</span>
<span class="p_header">index 976ce3a19f1b..d0efd6e6c20a 100644</span>
<span class="p_header">--- a/include/linux/sem.h</span>
<span class="p_header">+++ b/include/linux/sem.h</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> struct sem_array {</span>
 	struct list_head	list_id;	/* undo requests on this array */
 	int			sem_nsems;	/* no. of semaphores in array */
 	int			complex_count;	/* pending complex operations */
<span class="p_add">+	bool			complex_mode;	/* no parallel simple ops */</span>
 };
 
 #ifdef CONFIG_SYSVIPC
<span class="p_header">diff --git a/include/linux/string.h b/include/linux/string.h</span>
<span class="p_header">index 9ef7795e65e4..aa30789b0f65 100644</span>
<span class="p_header">--- a/include/linux/string.h</span>
<span class="p_header">+++ b/include/linux/string.h</span>
<span class="p_chunk">@@ -127,7 +127,11 @@</span> <span class="p_context"> extern char **argv_split(gfp_t gfp, const char *str, int *argcp);</span>
 extern void argv_free(char **argv);
 
 extern bool sysfs_streq(const char *s1, const char *s2);
<span class="p_del">-extern int strtobool(const char *s, bool *res);</span>
<span class="p_add">+extern int kstrtobool(const char *s, bool *res);</span>
<span class="p_add">+static inline int strtobool(const char *s, bool *res)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kstrtobool(s, res);</span>
<span class="p_add">+}</span>
 
 #ifdef CONFIG_BINARY_PRINTF
 int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args);
<span class="p_header">diff --git a/include/linux/swap.h b/include/linux/swap.h</span>
<span class="p_header">index 7ba7dccaf0e7..d8ca2eaa3a8b 100644</span>
<span class="p_header">--- a/include/linux/swap.h</span>
<span class="p_header">+++ b/include/linux/swap.h</span>
<span class="p_chunk">@@ -266,6 +266,7 @@</span> <span class="p_context"> static inline void workingset_node_pages_inc(struct radix_tree_node *node)</span>
 
 static inline void workingset_node_pages_dec(struct radix_tree_node *node)
 {
<span class="p_add">+	VM_WARN_ON_ONCE(!workingset_node_pages(node));</span>
 	node-&gt;count--;
 }
 
<span class="p_chunk">@@ -281,6 +282,7 @@</span> <span class="p_context"> static inline void workingset_node_shadows_inc(struct radix_tree_node *node)</span>
 
 static inline void workingset_node_shadows_dec(struct radix_tree_node *node)
 {
<span class="p_add">+	VM_WARN_ON_ONCE(!workingset_node_shadows(node));</span>
 	node-&gt;count -= 1U &lt;&lt; RADIX_TREE_COUNT_SHIFT;
 }
 
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 59081c73b296..6afc6f388edf 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -180,6 +180,7 @@</span> <span class="p_context"> enum tcm_sense_reason_table {</span>
 	TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED	= R(0x15),
 	TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED	= R(0x16),
 	TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED	= R(0x17),
<span class="p_add">+	TCM_COPY_TARGET_DEVICE_NOT_REACHABLE	= R(0x18),</span>
 #undef R
 };
 
<span class="p_header">diff --git a/ipc/sem.c b/ipc/sem.c</span>
<span class="p_header">index 20d07008ad5e..9862c3d1c26d 100644</span>
<span class="p_header">--- a/ipc/sem.c</span>
<span class="p_header">+++ b/ipc/sem.c</span>
<span class="p_chunk">@@ -155,14 +155,21 @@</span> <span class="p_context"> static int sysvipc_sem_proc_show(struct seq_file *s, void *it);</span>
 
 /*
  * Locking:
<span class="p_add">+ * a) global sem_lock() for read/write</span>
  *	sem_undo.id_next,
  *	sem_array.complex_count,
<span class="p_del">- *	sem_array.pending{_alter,_cont},</span>
<span class="p_del">- *	sem_array.sem_undo: global sem_lock() for read/write</span>
<span class="p_del">- *	sem_undo.proc_next: only &quot;current&quot; is allowed to read/write that field.</span>
<span class="p_add">+ *	sem_array.complex_mode</span>
<span class="p_add">+ *	sem_array.pending{_alter,_const},</span>
<span class="p_add">+ *	sem_array.sem_undo</span>
  *
<span class="p_add">+ * b) global or semaphore sem_lock() for read/write:</span>
  *	sem_array.sem_base[i].pending_{const,alter}:
<span class="p_del">- *		global or semaphore sem_lock() for read/write</span>
<span class="p_add">+ *	sem_array.complex_mode (for read)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * c) special:</span>
<span class="p_add">+ *	sem_undo_list.list_proc:</span>
<span class="p_add">+ *	* undo_list-&gt;lock for write</span>
<span class="p_add">+ *	* rcu for read</span>
  */
 
 #define sc_semmsl	sem_ctls[0]
<span class="p_chunk">@@ -263,24 +270,25 @@</span> <span class="p_context"> static void sem_rcu_free(struct rcu_head *head)</span>
 #define ipc_smp_acquire__after_spin_is_unlocked()	smp_rmb()
 
 /*
<span class="p_del">- * Wait until all currently ongoing simple ops have completed.</span>
<span class="p_add">+ * Enter the mode suitable for non-simple operations:</span>
  * Caller must own sem_perm.lock.
<span class="p_del">- * New simple ops cannot start, because simple ops first check</span>
<span class="p_del">- * that sem_perm.lock is free.</span>
<span class="p_del">- * that a) sem_perm.lock is free and b) complex_count is 0.</span>
  */
<span class="p_del">-static void sem_wait_array(struct sem_array *sma)</span>
<span class="p_add">+static void complexmode_enter(struct sem_array *sma)</span>
 {
 	int i;
 	struct sem *sem;
 
<span class="p_del">-	if (sma-&gt;complex_count)  {</span>
<span class="p_del">-		/* The thread that increased sma-&gt;complex_count waited on</span>
<span class="p_del">-		 * all sem-&gt;lock locks. Thus we don&#39;t need to wait again.</span>
<span class="p_del">-		 */</span>
<span class="p_add">+	if (sma-&gt;complex_mode)  {</span>
<span class="p_add">+		/* We are already in complex_mode. Nothing to do */</span>
 		return;
 	}
 
<span class="p_add">+	/* We need a full barrier after seting complex_mode:</span>
<span class="p_add">+	 * The write to complex_mode must be visible</span>
<span class="p_add">+	 * before we read the first sem-&gt;lock spinlock state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_mb(sma-&gt;complex_mode, true);</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; sma-&gt;sem_nsems; i++) {
 		sem = sma-&gt;sem_base + i;
 		spin_unlock_wait(&amp;sem-&gt;lock);
<span class="p_chunk">@@ -289,6 +297,28 @@</span> <span class="p_context"> static void sem_wait_array(struct sem_array *sma)</span>
 }
 
 /*
<span class="p_add">+ * Try to leave the mode that disallows simple operations:</span>
<span class="p_add">+ * Caller must own sem_perm.lock.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void complexmode_tryleave(struct sem_array *sma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (sma-&gt;complex_count)  {</span>
<span class="p_add">+		/* Complex ops are sleeping.</span>
<span class="p_add">+		 * We must stay in complex mode</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Immediately after setting complex_mode to false,</span>
<span class="p_add">+	 * a simple op can start. Thus: all memory writes</span>
<span class="p_add">+	 * performed by the current operation must be visible</span>
<span class="p_add">+	 * before we set complex_mode to false.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_release(&amp;sma-&gt;complex_mode, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define SEM_GLOBAL_LOCK	(-1)</span>
<span class="p_add">+/*</span>
  * If the request contains only one semaphore operation, and there are
  * no complex transactions pending, lock only the semaphore involved.
  * Otherwise, lock the entire semaphore array, since we either have
<span class="p_chunk">@@ -304,56 +334,42 @@</span> <span class="p_context"> static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,</span>
 		/* Complex operation - acquire a full lock */
 		ipc_lock_object(&amp;sma-&gt;sem_perm);
 
<span class="p_del">-		/* And wait until all simple ops that are processed</span>
<span class="p_del">-		 * right now have dropped their locks.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		sem_wait_array(sma);</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+		/* Prevent parallel simple ops */</span>
<span class="p_add">+		complexmode_enter(sma);</span>
<span class="p_add">+		return SEM_GLOBAL_LOCK;</span>
 	}
 
 	/*
 	 * Only one semaphore affected - try to optimize locking.
<span class="p_del">-	 * The rules are:</span>
<span class="p_del">-	 * - optimized locking is possible if no complex operation</span>
<span class="p_del">-	 *   is either enqueued or processed right now.</span>
<span class="p_del">-	 * - The test for enqueued complex ops is simple:</span>
<span class="p_del">-	 *      sma-&gt;complex_count != 0</span>
<span class="p_del">-	 * - Testing for complex ops that are processed right now is</span>
<span class="p_del">-	 *   a bit more difficult. Complex ops acquire the full lock</span>
<span class="p_del">-	 *   and first wait that the running simple ops have completed.</span>
<span class="p_del">-	 *   (see above)</span>
<span class="p_del">-	 *   Thus: If we own a simple lock and the global lock is free</span>
<span class="p_del">-	 *	and complex_count is now 0, then it will stay 0 and</span>
<span class="p_del">-	 *	thus just locking sem-&gt;lock is sufficient.</span>
<span class="p_add">+	 * Optimized locking is possible if no complex operation</span>
<span class="p_add">+	 * is either enqueued or processed right now.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Both facts are tracked by complex_mode.</span>
 	 */
 	sem = sma-&gt;sem_base + sops-&gt;sem_num;
 
<span class="p_del">-	if (sma-&gt;complex_count == 0) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Initial check for complex_mode. Just an optimization,</span>
<span class="p_add">+	 * no locking, no memory barrier.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!sma-&gt;complex_mode) {</span>
 		/*
 		 * It appears that no complex operation is around.
 		 * Acquire the per-semaphore lock.
 		 */
 		spin_lock(&amp;sem-&gt;lock);
 
<span class="p_del">-		/* Then check that the global lock is free */</span>
<span class="p_del">-		if (!spin_is_locked(&amp;sma-&gt;sem_perm.lock)) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We need a memory barrier with acquire semantics,</span>
<span class="p_del">-			 * otherwise we can race with another thread that does:</span>
<span class="p_del">-			 *	complex_count++;</span>
<span class="p_del">-			 *	spin_unlock(sem_perm.lock);</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			ipc_smp_acquire__after_spin_is_unlocked();</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * See 51d7d5205d33</span>
<span class="p_add">+		 * (&quot;powerpc: Add smp_mb() to arch_spin_is_locked()&quot;):</span>
<span class="p_add">+		 * A full barrier is required: the write of sem-&gt;lock</span>
<span class="p_add">+		 * must be visible before the read is executed</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_mb();</span>
 
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Now repeat the test of complex_count:</span>
<span class="p_del">-			 * It can&#39;t change anymore until we drop sem-&gt;lock.</span>
<span class="p_del">-			 * Thus: if is now 0, then it will stay 0.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (sma-&gt;complex_count == 0) {</span>
<span class="p_del">-				/* fast path successful! */</span>
<span class="p_del">-				return sops-&gt;sem_num;</span>
<span class="p_del">-			}</span>
<span class="p_add">+		if (!smp_load_acquire(&amp;sma-&gt;complex_mode)) {</span>
<span class="p_add">+			/* fast path successful! */</span>
<span class="p_add">+			return sops-&gt;sem_num;</span>
 		}
 		spin_unlock(&amp;sem-&gt;lock);
 	}
<span class="p_chunk">@@ -373,15 +389,16 @@</span> <span class="p_context"> static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,</span>
 		/* Not a false alarm, thus complete the sequence for a
 		 * full lock.
 		 */
<span class="p_del">-		sem_wait_array(sma);</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+		complexmode_enter(sma);</span>
<span class="p_add">+		return SEM_GLOBAL_LOCK;</span>
 	}
 }
 
 static inline void sem_unlock(struct sem_array *sma, int locknum)
 {
<span class="p_del">-	if (locknum == -1) {</span>
<span class="p_add">+	if (locknum == SEM_GLOBAL_LOCK) {</span>
 		unmerge_queues(sma);
<span class="p_add">+		complexmode_tryleave(sma);</span>
 		ipc_unlock_object(&amp;sma-&gt;sem_perm);
 	} else {
 		struct sem *sem = sma-&gt;sem_base + locknum;
<span class="p_chunk">@@ -533,6 +550,7 @@</span> <span class="p_context"> static int newary(struct ipc_namespace *ns, struct ipc_params *params)</span>
 	}
 
 	sma-&gt;complex_count = 0;
<span class="p_add">+	sma-&gt;complex_mode = true; /* dropped by sem_unlock below */</span>
 	INIT_LIST_HEAD(&amp;sma-&gt;pending_alter);
 	INIT_LIST_HEAD(&amp;sma-&gt;pending_const);
 	INIT_LIST_HEAD(&amp;sma-&gt;list_id);
<span class="p_chunk">@@ -2186,10 +2204,10 @@</span> <span class="p_context"> static int sysvipc_sem_proc_show(struct seq_file *s, void *it)</span>
 	/*
 	 * The proc interface isn&#39;t aware of sem_lock(), it calls
 	 * ipc_lock_object() directly (in sysvipc_find_ipc).
<span class="p_del">-	 * In order to stay compatible with sem_lock(), we must wait until</span>
<span class="p_del">-	 * all simple semop() calls have left their critical regions.</span>
<span class="p_add">+	 * In order to stay compatible with sem_lock(), we must</span>
<span class="p_add">+	 * enter / leave complex_mode.</span>
 	 */
<span class="p_del">-	sem_wait_array(sma);</span>
<span class="p_add">+	complexmode_enter(sma);</span>
 
 	sem_otime = get_semotime(sma);
 
<span class="p_chunk">@@ -2206,6 +2224,8 @@</span> <span class="p_context"> static int sysvipc_sem_proc_show(struct seq_file *s, void *it)</span>
 		   sem_otime,
 		   sma-&gt;sem_ctime);
 
<span class="p_add">+	complexmode_tryleave(sma);</span>
<span class="p_add">+</span>
 	return 0;
 }
 #endif
<span class="p_header">diff --git a/lib/kstrtox.c b/lib/kstrtox.c</span>
<span class="p_header">index 94be244e8441..d8a5cf66c316 100644</span>
<span class="p_header">--- a/lib/kstrtox.c</span>
<span class="p_header">+++ b/lib/kstrtox.c</span>
<span class="p_chunk">@@ -321,6 +321,70 @@</span> <span class="p_context"> int kstrtos8(const char *s, unsigned int base, s8 *res)</span>
 }
 EXPORT_SYMBOL(kstrtos8);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * kstrtobool - convert common user inputs into boolean values</span>
<span class="p_add">+ * @s: input string</span>
<span class="p_add">+ * @res: result</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This routine returns 0 iff the first character is one of &#39;Yy1Nn0&#39;, or</span>
<span class="p_add">+ * [oO][NnFf] for &quot;on&quot; and &quot;off&quot;. Otherwise it will return -EINVAL.  Value</span>
<span class="p_add">+ * pointed to by res is updated upon finding a match.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int kstrtobool(const char *s, bool *res)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!s)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (s[0]) {</span>
<span class="p_add">+	case &#39;y&#39;:</span>
<span class="p_add">+	case &#39;Y&#39;:</span>
<span class="p_add">+	case &#39;1&#39;:</span>
<span class="p_add">+		*res = true;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	case &#39;n&#39;:</span>
<span class="p_add">+	case &#39;N&#39;:</span>
<span class="p_add">+	case &#39;0&#39;:</span>
<span class="p_add">+		*res = false;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	case &#39;o&#39;:</span>
<span class="p_add">+	case &#39;O&#39;:</span>
<span class="p_add">+		switch (s[1]) {</span>
<span class="p_add">+		case &#39;n&#39;:</span>
<span class="p_add">+		case &#39;N&#39;:</span>
<span class="p_add">+			*res = true;</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		case &#39;f&#39;:</span>
<span class="p_add">+		case &#39;F&#39;:</span>
<span class="p_add">+			*res = false;</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(kstrtobool);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Since &quot;base&quot; would be a nonsense argument, this open-codes the</span>
<span class="p_add">+ * _from_user helper instead of using the helper macro below.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int kstrtobool_from_user(const char __user *s, size_t count, bool *res)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Longest string needed to differentiate, newline, terminator */</span>
<span class="p_add">+	char buf[4];</span>
<span class="p_add">+</span>
<span class="p_add">+	count = min(count, sizeof(buf) - 1);</span>
<span class="p_add">+	if (copy_from_user(buf, s, count))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	buf[count] = &#39;\0&#39;;</span>
<span class="p_add">+	return kstrtobool(buf, res);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(kstrtobool_from_user);</span>
<span class="p_add">+</span>
 #define kstrto_from_user(f, g, type)					\
 int f(const char __user *s, size_t count, unsigned int base, type *res)	\
 {									\
<span class="p_header">diff --git a/lib/string.c b/lib/string.c</span>
<span class="p_header">index 0323c0d5629a..1a90db9bc6e1 100644</span>
<span class="p_header">--- a/lib/string.c</span>
<span class="p_header">+++ b/lib/string.c</span>
<span class="p_chunk">@@ -630,35 +630,6 @@</span> <span class="p_context"> bool sysfs_streq(const char *s1, const char *s2)</span>
 }
 EXPORT_SYMBOL(sysfs_streq);
 
<span class="p_del">-/**</span>
<span class="p_del">- * strtobool - convert common user inputs into boolean values</span>
<span class="p_del">- * @s: input string</span>
<span class="p_del">- * @res: result</span>
<span class="p_del">- *</span>
<span class="p_del">- * This routine returns 0 iff the first character is one of &#39;Yy1Nn0&#39;.</span>
<span class="p_del">- * Otherwise it will return -EINVAL.  Value pointed to by res is</span>
<span class="p_del">- * updated upon finding a match.</span>
<span class="p_del">- */</span>
<span class="p_del">-int strtobool(const char *s, bool *res)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (s[0]) {</span>
<span class="p_del">-	case &#39;y&#39;:</span>
<span class="p_del">-	case &#39;Y&#39;:</span>
<span class="p_del">-	case &#39;1&#39;:</span>
<span class="p_del">-		*res = true;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case &#39;n&#39;:</span>
<span class="p_del">-	case &#39;N&#39;:</span>
<span class="p_del">-	case &#39;0&#39;:</span>
<span class="p_del">-		*res = false;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(strtobool);</span>
<span class="p_del">-</span>
 #ifndef __HAVE_ARCH_MEMSET
 /**
  * memset - Fill a region of memory with the given value
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index 1bb007624b53..c588d1222b2a 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -109,6 +109,48 @@</span> <span class="p_context"></span>
  *   -&gt;tasklist_lock            (memory_failure, collect_procs_ao)
  */
 
<span class="p_add">+static int page_cache_tree_insert(struct address_space *mapping,</span>
<span class="p_add">+				  struct page *page, void **shadowp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct radix_tree_node *node;</span>
<span class="p_add">+	void **slot;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = __radix_tree_create(&amp;mapping-&gt;page_tree, page-&gt;index,</span>
<span class="p_add">+				    &amp;node, &amp;slot);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	if (*slot) {</span>
<span class="p_add">+		void *p;</span>
<span class="p_add">+</span>
<span class="p_add">+		p = radix_tree_deref_slot_protected(slot, &amp;mapping-&gt;tree_lock);</span>
<span class="p_add">+		if (!radix_tree_exceptional_entry(p))</span>
<span class="p_add">+			return -EEXIST;</span>
<span class="p_add">+		if (shadowp)</span>
<span class="p_add">+			*shadowp = p;</span>
<span class="p_add">+		mapping-&gt;nrshadows--;</span>
<span class="p_add">+		if (node)</span>
<span class="p_add">+			workingset_node_shadows_dec(node);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	radix_tree_replace_slot(slot, page);</span>
<span class="p_add">+	mapping-&gt;nrpages++;</span>
<span class="p_add">+	if (node) {</span>
<span class="p_add">+		workingset_node_pages_inc(node);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Don&#39;t track node that contains actual pages.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Avoid acquiring the list_lru lock if already</span>
<span class="p_add">+		 * untracked.  The list_empty() test is safe as</span>
<span class="p_add">+		 * node-&gt;private_list is protected by</span>
<span class="p_add">+		 * mapping-&gt;tree_lock.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!list_empty(&amp;node-&gt;private_list))</span>
<span class="p_add">+			list_lru_del(&amp;workingset_shadow_nodes,</span>
<span class="p_add">+				     &amp;node-&gt;private_list);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void page_cache_tree_delete(struct address_space *mapping,
 				   struct page *page, void *shadow)
 {
<span class="p_chunk">@@ -122,6 +164,14 @@</span> <span class="p_context"> static void page_cache_tree_delete(struct address_space *mapping,</span>
 
 	__radix_tree_lookup(&amp;mapping-&gt;page_tree, page-&gt;index, &amp;node, &amp;slot);
 
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We need a node to properly account shadow</span>
<span class="p_add">+		 * entries. Don&#39;t plant any without. XXX</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		shadow = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (shadow) {
 		mapping-&gt;nrshadows++;
 		/*
<span class="p_chunk">@@ -538,9 +588,8 @@</span> <span class="p_context"> int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask)</span>
 		memcg = mem_cgroup_begin_page_stat(old);
 		spin_lock_irqsave(&amp;mapping-&gt;tree_lock, flags);
 		__delete_from_page_cache(old, NULL, memcg);
<span class="p_del">-		error = radix_tree_insert(&amp;mapping-&gt;page_tree, offset, new);</span>
<span class="p_add">+		error = page_cache_tree_insert(mapping, new, NULL);</span>
 		BUG_ON(error);
<span class="p_del">-		mapping-&gt;nrpages++;</span>
 
 		/*
 		 * hugetlb pages do not participate in page cache accounting.
<span class="p_chunk">@@ -562,48 +611,6 @@</span> <span class="p_context"> int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask)</span>
 }
 EXPORT_SYMBOL_GPL(replace_page_cache_page);
 
<span class="p_del">-static int page_cache_tree_insert(struct address_space *mapping,</span>
<span class="p_del">-				  struct page *page, void **shadowp)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct radix_tree_node *node;</span>
<span class="p_del">-	void **slot;</span>
<span class="p_del">-	int error;</span>
<span class="p_del">-</span>
<span class="p_del">-	error = __radix_tree_create(&amp;mapping-&gt;page_tree, page-&gt;index,</span>
<span class="p_del">-				    &amp;node, &amp;slot);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-	if (*slot) {</span>
<span class="p_del">-		void *p;</span>
<span class="p_del">-</span>
<span class="p_del">-		p = radix_tree_deref_slot_protected(slot, &amp;mapping-&gt;tree_lock);</span>
<span class="p_del">-		if (!radix_tree_exceptional_entry(p))</span>
<span class="p_del">-			return -EEXIST;</span>
<span class="p_del">-		if (shadowp)</span>
<span class="p_del">-			*shadowp = p;</span>
<span class="p_del">-		mapping-&gt;nrshadows--;</span>
<span class="p_del">-		if (node)</span>
<span class="p_del">-			workingset_node_shadows_dec(node);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	radix_tree_replace_slot(slot, page);</span>
<span class="p_del">-	mapping-&gt;nrpages++;</span>
<span class="p_del">-	if (node) {</span>
<span class="p_del">-		workingset_node_pages_inc(node);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Don&#39;t track node that contains actual pages.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Avoid acquiring the list_lru lock if already</span>
<span class="p_del">-		 * untracked.  The list_empty() test is safe as</span>
<span class="p_del">-		 * node-&gt;private_list is protected by</span>
<span class="p_del">-		 * mapping-&gt;tree_lock.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!list_empty(&amp;node-&gt;private_list))</span>
<span class="p_del">-			list_lru_del(&amp;workingset_shadow_nodes,</span>
<span class="p_del">-				     &amp;node-&gt;private_list);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int __add_to_page_cache_locked(struct page *page,
 				      struct address_space *mapping,
 				      pgoff_t offset, gfp_t gfp_mask,
<span class="p_header">diff --git a/mm/workingset.c b/mm/workingset.c</span>
<span class="p_header">index aa017133744b..df66f426fdcf 100644</span>
<span class="p_header">--- a/mm/workingset.c</span>
<span class="p_header">+++ b/mm/workingset.c</span>
<span class="p_chunk">@@ -341,21 +341,19 @@</span> <span class="p_context"> static enum lru_status shadow_lru_isolate(struct list_head *item,</span>
 	 * no pages, so we expect to be able to remove them all and
 	 * delete and free the empty node afterwards.
 	 */
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(!node-&gt;count);</span>
<span class="p_del">-	BUG_ON(node-&gt;count &amp; RADIX_TREE_COUNT_MASK);</span>
<span class="p_add">+	BUG_ON(!workingset_node_shadows(node));</span>
<span class="p_add">+	BUG_ON(workingset_node_pages(node));</span>
 
 	for (i = 0; i &lt; RADIX_TREE_MAP_SIZE; i++) {
 		if (node-&gt;slots[i]) {
 			BUG_ON(!radix_tree_exceptional_entry(node-&gt;slots[i]));
 			node-&gt;slots[i] = NULL;
<span class="p_del">-			BUG_ON(node-&gt;count &lt; (1U &lt;&lt; RADIX_TREE_COUNT_SHIFT));</span>
<span class="p_del">-			node-&gt;count -= 1U &lt;&lt; RADIX_TREE_COUNT_SHIFT;</span>
<span class="p_add">+			workingset_node_shadows_dec(node);</span>
 			BUG_ON(!mapping-&gt;nrshadows);
 			mapping-&gt;nrshadows--;
 		}
 	}
<span class="p_del">-	BUG_ON(node-&gt;count);</span>
<span class="p_add">+	BUG_ON(workingset_node_shadows(node));</span>
 	inc_zone_state(page_zone(virt_to_page(node)), WORKINGSET_NODERECLAIM);
 	if (!__radix_tree_delete_node(&amp;mapping-&gt;page_tree, node))
 		BUG();
<span class="p_header">diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c</span>
<span class="p_header">index 1ba417207465..27b6f55fa43a 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtsock.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtsock.c</span>
<span class="p_chunk">@@ -474,7 +474,16 @@</span> <span class="p_context"> static int xs_nospace(struct rpc_task *task)</span>
 	spin_unlock_bh(&amp;xprt-&gt;transport_lock);
 
 	/* Race breaker in case memory is freed before above code is called */
<span class="p_del">-	sk-&gt;sk_write_space(sk);</span>
<span class="p_add">+	if (ret == -EAGAIN) {</span>
<span class="p_add">+		struct socket_wq *wq;</span>
<span class="p_add">+</span>
<span class="p_add">+		rcu_read_lock();</span>
<span class="p_add">+		wq = rcu_dereference(sk-&gt;sk_wq);</span>
<span class="p_add">+		set_bit(SOCKWQ_ASYNC_NOSPACE, &amp;wq-&gt;flags);</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+		sk-&gt;sk_write_space(sk);</span>
<span class="p_add">+	}</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/sound/pci/hda/dell_wmi_helper.c b/sound/pci/hda/dell_wmi_helper.c</span>
<span class="p_header">index 9c22f95838ef..19d41da79f93 100644</span>
<span class="p_header">--- a/sound/pci/hda/dell_wmi_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/dell_wmi_helper.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> static void alc_fixup_dell_wmi(struct hda_codec *codec,</span>
 		removefunc = true;
 		if (dell_led_set_func(DELL_LED_MICMUTE, false) &gt;= 0) {
 			dell_led_value = 0;
<span class="p_del">-			if (spec-&gt;gen.num_adc_nids &gt; 1)</span>
<span class="p_add">+			if (spec-&gt;gen.num_adc_nids &gt; 1 &amp;&amp; !spec-&gt;gen.dyn_adc_switch)</span>
 				codec_dbg(codec, &quot;Skipping micmute LED control due to several ADCs&quot;);
 			else {
 				dell_old_cap_hook = spec-&gt;gen.cap_sync_hook;
<span class="p_header">diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">index 0a4ad5feb82e..12826ac0381f 100644</span>
<span class="p_header">--- a/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,</span>
 			removefunc = false;
 		}
 		if (led_set_func(TPACPI_LED_MICMUTE, false) &gt;= 0) {
<span class="p_del">-			if (spec-&gt;num_adc_nids &gt; 1)</span>
<span class="p_add">+			if (spec-&gt;num_adc_nids &gt; 1 &amp;&amp; !spec-&gt;dyn_adc_switch)</span>
 				codec_dbg(codec,
 					  &quot;Skipping micmute LED control due to several ADCs&quot;);
 			else {
<span class="p_header">diff --git a/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c b/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c</span>
<span class="p_header">index 9409d014b46c..71df7acf8643 100644</span>
<span class="p_header">--- a/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c</span>
<span class="p_header">+++ b/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c</span>
<span class="p_chunk">@@ -89,6 +89,7 @@</span> <span class="p_context"> struct intel_pt_decoder {</span>
 	bool pge;
 	bool have_tma;
 	bool have_cyc;
<span class="p_add">+	bool fixup_last_mtc;</span>
 	uint64_t pos;
 	uint64_t last_ip;
 	uint64_t ip;
<span class="p_chunk">@@ -584,10 +585,31 @@</span> <span class="p_context"> struct intel_pt_calc_cyc_to_tsc_info {</span>
 	uint64_t        tsc_timestamp;
 	uint64_t        timestamp;
 	bool            have_tma;
<span class="p_add">+	bool            fixup_last_mtc;</span>
 	bool            from_mtc;
 	double          cbr_cyc_to_tsc;
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * MTC provides a 8-bit slice of CTC but the TMA packet only provides the lower</span>
<span class="p_add">+ * 16 bits of CTC. If mtc_shift &gt; 8 then some of the MTC bits are not in the CTC</span>
<span class="p_add">+ * provided by the TMA packet. Fix-up the last_mtc calculated from the TMA</span>
<span class="p_add">+ * packet by copying the missing bits from the current MTC assuming the least</span>
<span class="p_add">+ * difference between the two, and that the current MTC comes after last_mtc.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void intel_pt_fixup_last_mtc(uint32_t mtc, int mtc_shift,</span>
<span class="p_add">+				    uint32_t *last_mtc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t first_missing_bit = 1U &lt;&lt; (16 - mtc_shift);</span>
<span class="p_add">+	uint32_t mask = ~(first_missing_bit - 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	*last_mtc |= mtc &amp; mask;</span>
<span class="p_add">+	if (*last_mtc &gt;= mtc) {</span>
<span class="p_add">+		*last_mtc -= first_missing_bit;</span>
<span class="p_add">+		*last_mtc &amp;= 0xff;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int intel_pt_calc_cyc_cb(struct intel_pt_pkt_info *pkt_info)
 {
 	struct intel_pt_decoder *decoder = pkt_info-&gt;decoder;
<span class="p_chunk">@@ -617,6 +639,11 @@</span> <span class="p_context"> static int intel_pt_calc_cyc_cb(struct intel_pt_pkt_info *pkt_info)</span>
 			return 0;
 
 		mtc = pkt_info-&gt;packet.payload;
<span class="p_add">+		if (decoder-&gt;mtc_shift &gt; 8 &amp;&amp; data-&gt;fixup_last_mtc) {</span>
<span class="p_add">+			data-&gt;fixup_last_mtc = false;</span>
<span class="p_add">+			intel_pt_fixup_last_mtc(mtc, decoder-&gt;mtc_shift,</span>
<span class="p_add">+						&amp;data-&gt;last_mtc);</span>
<span class="p_add">+		}</span>
 		if (mtc &gt; data-&gt;last_mtc)
 			mtc_delta = mtc - data-&gt;last_mtc;
 		else
<span class="p_chunk">@@ -685,6 +712,7 @@</span> <span class="p_context"> static int intel_pt_calc_cyc_cb(struct intel_pt_pkt_info *pkt_info)</span>
 
 		data-&gt;ctc_delta = 0;
 		data-&gt;have_tma = true;
<span class="p_add">+		data-&gt;fixup_last_mtc = true;</span>
 
 		return 0;
 
<span class="p_chunk">@@ -751,6 +779,7 @@</span> <span class="p_context"> static void intel_pt_calc_cyc_to_tsc(struct intel_pt_decoder *decoder,</span>
 		.tsc_timestamp  = decoder-&gt;tsc_timestamp,
 		.timestamp      = decoder-&gt;timestamp,
 		.have_tma       = decoder-&gt;have_tma,
<span class="p_add">+		.fixup_last_mtc = decoder-&gt;fixup_last_mtc,</span>
 		.from_mtc       = from_mtc,
 		.cbr_cyc_to_tsc = 0,
 	};
<span class="p_chunk">@@ -1241,6 +1270,7 @@</span> <span class="p_context"> static void intel_pt_calc_tma(struct intel_pt_decoder *decoder)</span>
 	}
 	decoder-&gt;ctc_delta = 0;
 	decoder-&gt;have_tma = true;
<span class="p_add">+	decoder-&gt;fixup_last_mtc = true;</span>
 	intel_pt_log(&quot;CTC timestamp &quot; x64_fmt &quot; last MTC %#x  CTC rem %#x\n&quot;,
 		     decoder-&gt;ctc_timestamp, decoder-&gt;last_mtc, ctc_rem);
 }
<span class="p_chunk">@@ -1255,6 +1285,12 @@</span> <span class="p_context"> static void intel_pt_calc_mtc_timestamp(struct intel_pt_decoder *decoder)</span>
 
 	mtc = decoder-&gt;packet.payload;
 
<span class="p_add">+	if (decoder-&gt;mtc_shift &gt; 8 &amp;&amp; decoder-&gt;fixup_last_mtc) {</span>
<span class="p_add">+		decoder-&gt;fixup_last_mtc = false;</span>
<span class="p_add">+		intel_pt_fixup_last_mtc(mtc, decoder-&gt;mtc_shift,</span>
<span class="p_add">+					&amp;decoder-&gt;last_mtc);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (mtc &gt; decoder-&gt;last_mtc)
 		mtc_delta = mtc - decoder-&gt;last_mtc;
 	else
<span class="p_chunk">@@ -1323,6 +1359,8 @@</span> <span class="p_context"> static void intel_pt_calc_cyc_timestamp(struct intel_pt_decoder *decoder)</span>
 			     timestamp, decoder-&gt;timestamp);
 	else
 		decoder-&gt;timestamp = timestamp;
<span class="p_add">+</span>
<span class="p_add">+	decoder-&gt;timestamp_insn_cnt = 0;</span>
 }
 
 /* Walk PSB+ packets when already in sync. */
<span class="p_header">diff --git a/tools/perf/util/intel-pt.c b/tools/perf/util/intel-pt.c</span>
<span class="p_header">index 9227c2f076c3..89927b5beebf 100644</span>
<span class="p_header">--- a/tools/perf/util/intel-pt.c</span>
<span class="p_header">+++ b/tools/perf/util/intel-pt.c</span>
<span class="p_chunk">@@ -238,7 +238,7 @@</span> <span class="p_context"> static int intel_pt_get_trace(struct intel_pt_buffer *b, void *data)</span>
 	}
 
 	queue = &amp;ptq-&gt;pt-&gt;queues.queue_array[ptq-&gt;queue_nr];
<span class="p_del">-</span>
<span class="p_add">+next:</span>
 	buffer = auxtrace_buffer__next(queue, buffer);
 	if (!buffer) {
 		if (old_buffer)
<span class="p_chunk">@@ -261,9 +261,6 @@</span> <span class="p_context"> static int intel_pt_get_trace(struct intel_pt_buffer *b, void *data)</span>
 	    intel_pt_do_fix_overlap(ptq-&gt;pt, old_buffer, buffer))
 		return -ENOMEM;
 
<span class="p_del">-	if (old_buffer)</span>
<span class="p_del">-		auxtrace_buffer__drop_data(old_buffer);</span>
<span class="p_del">-</span>
 	if (buffer-&gt;use_data) {
 		b-&gt;len = buffer-&gt;use_size;
 		b-&gt;buf = buffer-&gt;use_data;
<span class="p_chunk">@@ -273,6 +270,16 @@</span> <span class="p_context"> static int intel_pt_get_trace(struct intel_pt_buffer *b, void *data)</span>
 	}
 	b-&gt;ref_timestamp = buffer-&gt;reference;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If in snapshot mode and the buffer has no usable data, get next</span>
<span class="p_add">+	 * buffer and again check overlap against old_buffer.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ptq-&gt;pt-&gt;snapshot_mode &amp;&amp; !b-&gt;len)</span>
<span class="p_add">+		goto next;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (old_buffer)</span>
<span class="p_add">+		auxtrace_buffer__drop_data(old_buffer);</span>
<span class="p_add">+</span>
 	if (!old_buffer || ptq-&gt;pt-&gt;sampling_mode || (ptq-&gt;pt-&gt;snapshot_mode &amp;&amp;
 						      !buffer-&gt;consecutive)) {
 		b-&gt;consecutive = false;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



