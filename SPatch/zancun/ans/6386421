
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.16.y-ckt,stable] Linux 3.16.7-ckt11 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.16.y-ckt,stable] Linux 3.16.7-ckt11</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 12, 2015, 8:38 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1431419911-4023-2-git-send-email-luis.henriques@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6386421/mbox/"
   >mbox</a>
|
   <a href="/patch/6386421/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6386421/">/patch/6386421/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 1680ABEEE1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 12 May 2015 08:40:08 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 5DC482024C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 12 May 2015 08:39:56 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id D0331203F3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 12 May 2015 08:39:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932637AbbELIja (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 12 May 2015 04:39:30 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:50239 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932602AbbELIig (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 12 May 2015 04:38:36 -0400
Received: from av-217-129-142-138.netvisao.pt ([217.129.142.138]
	helo=localhost) by youngberry.canonical.com with esmtpsa
	(TLS1.0:RSA_AES_128_CBC_SHA1:16) (Exim 4.71)
	(envelope-from &lt;luis.henriques@canonical.com&gt;)
	id 1Ys5hx-0007eq-NS; Tue, 12 May 2015 08:38:34 +0000
From: Luis Henriques &lt;luis.henriques@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.16.y-ckt stable] Linux 3.16.7-ckt11
Date: Tue, 12 May 2015 09:38:31 +0100
Message-Id: &lt;1431419911-4023-2-git-send-email-luis.henriques@canonical.com&gt;
X-Mailer: git-send-email 2.1.4
In-Reply-To: &lt;1431419911-4023-1-git-send-email-luis.henriques@canonical.com&gt;
References: &lt;1431419911-4023-1-git-send-email-luis.henriques@canonical.com&gt;
X-Extended-Stable: 3.16
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a> - May 12, 2015, 8:38 a.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index a89a3f0b8f9c..d5de7dccbe7a 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
 SUBLEVEL = 7
<span class="p_del">-EXTRAVERSION =-ckt10</span>
<span class="p_add">+EXTRAVERSION =-ckt11</span>
 NAME = Museum of Fishiegoodies
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arm/boot/dts/dove.dtsi b/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_header">index 3b891dd20993..c00078d237fa 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"></span>
 
 			uart2: serial@12200 {
 				compatible = &quot;ns16550a&quot;;
<span class="p_del">-				reg = &lt;0x12000 0x100&gt;;</span>
<span class="p_add">+				reg = &lt;0x12200 0x100&gt;;</span>
 				reg-shift = &lt;2&gt;;
 				interrupts = &lt;9&gt;;
 				clocks = &lt;&amp;core_clk 0&gt;;
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"></span>
 
 			uart3: serial@12300 {
 				compatible = &quot;ns16550a&quot;;
<span class="p_del">-				reg = &lt;0x12100 0x100&gt;;</span>
<span class="p_add">+				reg = &lt;0x12300 0x100&gt;;</span>
 				reg-shift = &lt;2&gt;;
 				interrupts = &lt;10&gt;;
 				clocks = &lt;&amp;core_clk 0&gt;;
<span class="p_header">diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h</span>
<span class="p_header">index f4b46d39b9cf..051b7269e639 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/elf.h</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs);</span>
    the loader.  We need to make sure that it is out of the way of the program
    that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */
 
<span class="p_del">-#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)</span>
<span class="p_add">+#define ELF_ET_DYN_BASE	(TASK_SIZE / 3 * 2)</span>
 
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
<span class="p_header">diff --git a/arch/arm/kernel/hibernate.c b/arch/arm/kernel/hibernate.c</span>
<span class="p_header">index bb8b79648643..cfb354ff2a60 100644</span>
<span class="p_header">--- a/arch/arm/kernel/hibernate.c</span>
<span class="p_header">+++ b/arch/arm/kernel/hibernate.c</span>
<span class="p_chunk">@@ -21,8 +21,8 @@</span> <span class="p_context"></span>
 #include &lt;asm/idmap.h&gt;
 #include &lt;asm/suspend.h&gt;
 #include &lt;asm/memory.h&gt;
<span class="p_del">-</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &quot;reboot.h&quot;</span>
 
 int pfn_is_nosave(unsigned long pfn)
 {
<span class="p_chunk">@@ -62,7 +62,7 @@</span> <span class="p_context"> static int notrace arch_save_image(unsigned long unused)</span>
 
 	ret = swsusp_save();
 	if (ret == 0)
<span class="p_del">-		soft_restart(virt_to_phys(cpu_resume));</span>
<span class="p_add">+		_soft_restart(virt_to_phys(cpu_resume), false);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> static void notrace arch_restore_image(void *unused)</span>
 	for (pbe = restore_pblist; pbe; pbe = pbe-&gt;next)
 		copy_page(pbe-&gt;orig_address, pbe-&gt;address);
 
<span class="p_del">-	soft_restart(virt_to_phys(cpu_resume));</span>
<span class="p_add">+	_soft_restart(virt_to_phys(cpu_resume), false);</span>
 }
 
 static u64 resume_stack[PAGE_SIZE/2/sizeof(u64)] __nosavedata;
<span class="p_header">diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c</span>
<span class="p_header">index a35f6ebbd2c2..3f688b73dda2 100644</span>
<span class="p_header">--- a/arch/arm/kernel/process.c</span>
<span class="p_header">+++ b/arch/arm/kernel/process.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/system_misc.h&gt;
 #include &lt;asm/mach/time.h&gt;
 #include &lt;asm/tls.h&gt;
<span class="p_add">+#include &quot;reboot.h&quot;</span>
 
 #ifdef CONFIG_CC_STACKPROTECTOR
 #include &lt;linux/stackprotector.h&gt;
<span class="p_chunk">@@ -95,7 +96,7 @@</span> <span class="p_context"> static void __soft_restart(void *addr)</span>
 	BUG();
 }
 
<span class="p_del">-void soft_restart(unsigned long addr)</span>
<span class="p_add">+void _soft_restart(unsigned long addr, bool disable_l2)</span>
 {
 	u64 *stack = soft_restart_stack + ARRAY_SIZE(soft_restart_stack);
 
<span class="p_chunk">@@ -104,7 +105,7 @@</span> <span class="p_context"> void soft_restart(unsigned long addr)</span>
 	local_fiq_disable();
 
 	/* Disable the L2 if we&#39;re the last man standing. */
<span class="p_del">-	if (num_online_cpus() == 1)</span>
<span class="p_add">+	if (disable_l2)</span>
 		outer_disable();
 
 	/* Change to the new stack and continue with the reset. */
<span class="p_chunk">@@ -118,6 +119,11 @@</span> <span class="p_context"> static void null_restart(enum reboot_mode reboot_mode, const char *cmd)</span>
 {
 }
 
<span class="p_add">+void soft_restart(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	_soft_restart(addr, num_online_cpus() == 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Function pointers to optional machine specific functions
  */
<span class="p_header">diff --git a/arch/arm/kernel/reboot.h b/arch/arm/kernel/reboot.h</span>
new file mode 100644
<span class="p_header">index 000000000000..c87f05816d6b</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/kernel/reboot.h</span>
<span class="p_chunk">@@ -0,0 +1,6 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef REBOOT_H</span>
<span class="p_add">+#define REBOOT_H</span>
<span class="p_add">+</span>
<span class="p_add">+extern void _soft_restart(unsigned long addr, bool disable_l2);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/crag6410.h b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">index 7bc66682687e..dcbe17f5e5f8 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;mach/gpio-samsung.h&gt;
 
 #define GLENFARCLAS_PMIC_IRQ_BASE	IRQ_BOARD_START
<span class="p_add">+#define BANFF_PMIC_IRQ_BASE		(IRQ_BOARD_START + 64)</span>
 
 #define PCA935X_GPIO_BASE		GPIO_BOARD_START
 #define CODEC_GPIO_BASE			(GPIO_BOARD_START + 8)
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/mach-crag6410.c b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">index 4b0199fff9f5..e57dd645309b 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_chunk">@@ -555,6 +555,7 @@</span> <span class="p_context"> static struct wm831x_touch_pdata touch_pdata = {</span>
 
 static struct wm831x_pdata crag_pmic_pdata = {
 	.wm831x_num = 1,
<span class="p_add">+	.irq_base = BANFF_PMIC_IRQ_BASE,</span>
 	.gpio_base = BANFF_PMIC_GPIO_BASE,
 	.soft_shutdown = true,
 
<span class="p_header">diff --git a/arch/arm/mach-shmobile/pm-r8a7790.c b/arch/arm/mach-shmobile/pm-r8a7790.c</span>
<span class="p_header">index fc82839e2c2a..886b0b3b8ff5 100644</span>
<span class="p_header">--- a/arch/arm/mach-shmobile/pm-r8a7790.c</span>
<span class="p_header">+++ b/arch/arm/mach-shmobile/pm-r8a7790.c</span>
<span class="p_chunk">@@ -26,7 +26,7 @@</span> <span class="p_context"> static void __init r8a7790_sysc_init(void)</span>
 	void __iomem *base = rcar_sysc_init(0xe6180000);
 
 	/* enable all interrupt sources, but do not use interrupt handler */
<span class="p_del">-	iowrite32(0x0131000e, base + SYSCIER);</span>
<span class="p_add">+	iowrite32(0x013111ef, base + SYSCIER);</span>
 	iowrite32(0, base + SYSCIMR);
 }
 
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index a2c1195abb7f..1cd11e73058f 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -599,6 +599,7 @@</span> <span class="p_context"> __create_page_tables:</span>
 	 */
 	mov	x0, x25
 	add	x1, x26, #SWAPPER_DIR_SIZE
<span class="p_add">+	dmb	sy</span>
 	bl	__inval_cache_range
 
 	mov	lr, x27
<span class="p_header">diff --git a/arch/arm64/kernel/vdso/Makefile b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">index 6d20b7d162d8..a268a9af0c2d 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> $(obj)/vdso-offsets.h: $(obj)/vdso.so.dbg FORCE</span>
 	$(call if_changed,vdsosym)
 
 # Assembly rules for the .S files
<span class="p_del">-$(obj-vdso): %.o: %.S</span>
<span class="p_add">+$(obj-vdso): %.o: %.S FORCE</span>
 	$(call if_changed_dep,vdsoas)
 
 # Actual build commands
<span class="p_header">diff --git a/arch/c6x/kernel/time.c b/arch/c6x/kernel/time.c</span>
<span class="p_header">index 356ee84cad95..04845aaf5985 100644</span>
<span class="p_header">--- a/arch/c6x/kernel/time.c</span>
<span class="p_header">+++ b/arch/c6x/kernel/time.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> u64 sched_clock(void)</span>
 	return (tsc * sched_clock_multiplier) &gt;&gt; SCHED_CLOCK_SHIFT;
 }
 
<span class="p_del">-void time_init(void)</span>
<span class="p_add">+void __init time_init(void)</span>
 {
 	u64 tmp = (u64)NSEC_PER_SEC &lt;&lt; SCHED_CLOCK_SHIFT;
 
<span class="p_header">diff --git a/arch/mips/include/asm/asm-eva.h b/arch/mips/include/asm/asm-eva.h</span>
<span class="p_header">index e41c56e375b1..1e38f0e1ea3e 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/asm-eva.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/asm-eva.h</span>
<span class="p_chunk">@@ -11,6 +11,36 @@</span> <span class="p_context"></span>
 #define __ASM_ASM_EVA_H
 
 #ifndef __ASSEMBLY__
<span class="p_add">+</span>
<span class="p_add">+/* Kernel variants */</span>
<span class="p_add">+</span>
<span class="p_add">+#define kernel_cache(op, base)		&quot;cache &quot; op &quot;, &quot; base &quot;\n&quot;</span>
<span class="p_add">+#define kernel_ll(reg, addr)		&quot;ll &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_sc(reg, addr)		&quot;sc &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lw(reg, addr)		&quot;lw &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lwl(reg, addr)		&quot;lwl &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lwr(reg, addr)		&quot;lwr &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lh(reg, addr)		&quot;lh &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lb(reg, addr)		&quot;lb &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lbu(reg, addr)		&quot;lbu &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_sw(reg, addr)		&quot;sw &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_swl(reg, addr)		&quot;swl &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_swr(reg, addr)		&quot;swr &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_sh(reg, addr)		&quot;sh &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_sb(reg, addr)		&quot;sb &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_32BIT</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * No &#39;sd&#39; or &#39;ld&#39; instructions in 32-bit but the code will</span>
<span class="p_add">+ * do the correct thing</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define kernel_sd(reg, addr)		user_sw(reg, addr)</span>
<span class="p_add">+#define kernel_ld(reg, addr)		user_lw(reg, addr)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define kernel_sd(reg, addr)		&quot;sd &quot; reg&quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_ld(reg, addr)		&quot;ld &quot; reg&quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#endif /* CONFIG_32BIT */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_EVA
 
 #define __BUILD_EVA_INSN(insn, reg, addr)				\
<span class="p_chunk">@@ -41,37 +71,60 @@</span> <span class="p_context"></span>
 
 #else
 
<span class="p_del">-#define user_cache(op, base)		&quot;cache &quot; op &quot;, &quot; base &quot;\n&quot;</span>
<span class="p_del">-#define user_ll(reg, addr)		&quot;ll &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_sc(reg, addr)		&quot;sc &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lw(reg, addr)		&quot;lw &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lwl(reg, addr)		&quot;lwl &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lwr(reg, addr)		&quot;lwr &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lh(reg, addr)		&quot;lh &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lb(reg, addr)		&quot;lb &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lbu(reg, addr)		&quot;lbu &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_sw(reg, addr)		&quot;sw &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_swl(reg, addr)		&quot;swl &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_swr(reg, addr)		&quot;swr &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_sh(reg, addr)		&quot;sh &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_sb(reg, addr)		&quot;sb &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define user_cache(op, base)		kernel_cache(op, base)</span>
<span class="p_add">+#define user_ll(reg, addr)		kernel_ll(reg, addr)</span>
<span class="p_add">+#define user_sc(reg, addr)		kernel_sc(reg, addr)</span>
<span class="p_add">+#define user_lw(reg, addr)		kernel_lw(reg, addr)</span>
<span class="p_add">+#define user_lwl(reg, addr)		kernel_lwl(reg, addr)</span>
<span class="p_add">+#define user_lwr(reg, addr)		kernel_lwr(reg, addr)</span>
<span class="p_add">+#define user_lh(reg, addr)		kernel_lh(reg, addr)</span>
<span class="p_add">+#define user_lb(reg, addr)		kernel_lb(reg, addr)</span>
<span class="p_add">+#define user_lbu(reg, addr)		kernel_lbu(reg, addr)</span>
<span class="p_add">+#define user_sw(reg, addr)		kernel_sw(reg, addr)</span>
<span class="p_add">+#define user_swl(reg, addr)		kernel_swl(reg, addr)</span>
<span class="p_add">+#define user_swr(reg, addr)		kernel_swr(reg, addr)</span>
<span class="p_add">+#define user_sh(reg, addr)		kernel_sh(reg, addr)</span>
<span class="p_add">+#define user_sb(reg, addr)		kernel_sb(reg, addr)</span>
 
 #ifdef CONFIG_32BIT
<span class="p_del">-/*</span>
<span class="p_del">- * No &#39;sd&#39; or &#39;ld&#39; instructions in 32-bit but the code will</span>
<span class="p_del">- * do the correct thing</span>
<span class="p_del">- */</span>
<span class="p_del">-#define user_sd(reg, addr)		user_sw(reg, addr)</span>
<span class="p_del">-#define user_ld(reg, addr)		user_lw(reg, addr)</span>
<span class="p_add">+#define user_sd(reg, addr)		kernel_sw(reg, addr)</span>
<span class="p_add">+#define user_ld(reg, addr)		kernel_lw(reg, addr)</span>
 #else
<span class="p_del">-#define user_sd(reg, addr)		&quot;sd &quot; reg&quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_ld(reg, addr)		&quot;ld &quot; reg&quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define user_sd(reg, addr)		kernel_sd(reg, addr)</span>
<span class="p_add">+#define user_ld(reg, addr)		kernel_ld(reg, addr)</span>
 #endif /* CONFIG_32BIT */
 
 #endif /* CONFIG_EVA */
 
 #else /* __ASSEMBLY__ */
 
<span class="p_add">+#define kernel_cache(op, base)		cache op, base</span>
<span class="p_add">+#define kernel_ll(reg, addr)		ll reg, addr</span>
<span class="p_add">+#define kernel_sc(reg, addr)		sc reg, addr</span>
<span class="p_add">+#define kernel_lw(reg, addr)		lw reg, addr</span>
<span class="p_add">+#define kernel_lwl(reg, addr)		lwl reg, addr</span>
<span class="p_add">+#define kernel_lwr(reg, addr)		lwr reg, addr</span>
<span class="p_add">+#define kernel_lh(reg, addr)		lh reg, addr</span>
<span class="p_add">+#define kernel_lb(reg, addr)		lb reg, addr</span>
<span class="p_add">+#define kernel_lbu(reg, addr)		lbu reg, addr</span>
<span class="p_add">+#define kernel_sw(reg, addr)		sw reg, addr</span>
<span class="p_add">+#define kernel_swl(reg, addr)		swl reg, addr</span>
<span class="p_add">+#define kernel_swr(reg, addr)		swr reg, addr</span>
<span class="p_add">+#define kernel_sh(reg, addr)		sh reg, addr</span>
<span class="p_add">+#define kernel_sb(reg, addr)		sb reg, addr</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_32BIT</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * No &#39;sd&#39; or &#39;ld&#39; instructions in 32-bit but the code will</span>
<span class="p_add">+ * do the correct thing</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define kernel_sd(reg, addr)		user_sw(reg, addr)</span>
<span class="p_add">+#define kernel_ld(reg, addr)		user_lw(reg, addr)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define kernel_sd(reg, addr)		sd reg, addr</span>
<span class="p_add">+#define kernel_ld(reg, addr)		ld reg, addr</span>
<span class="p_add">+#endif /* CONFIG_32BIT */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_EVA
 
 #define __BUILD_EVA_INSN(insn, reg, addr)			\
<span class="p_chunk">@@ -101,31 +154,27 @@</span> <span class="p_context"></span>
 #define user_sd(reg, addr)		user_sw(reg, addr)
 #else
 
<span class="p_del">-#define user_cache(op, base)		cache op, base</span>
<span class="p_del">-#define user_ll(reg, addr)		ll reg, addr</span>
<span class="p_del">-#define user_sc(reg, addr)		sc reg, addr</span>
<span class="p_del">-#define user_lw(reg, addr)		lw reg, addr</span>
<span class="p_del">-#define user_lwl(reg, addr)		lwl reg, addr</span>
<span class="p_del">-#define user_lwr(reg, addr)		lwr reg, addr</span>
<span class="p_del">-#define user_lh(reg, addr)		lh reg, addr</span>
<span class="p_del">-#define user_lb(reg, addr)		lb reg, addr</span>
<span class="p_del">-#define user_lbu(reg, addr)		lbu reg, addr</span>
<span class="p_del">-#define user_sw(reg, addr)		sw reg, addr</span>
<span class="p_del">-#define user_swl(reg, addr)		swl reg, addr</span>
<span class="p_del">-#define user_swr(reg, addr)		swr reg, addr</span>
<span class="p_del">-#define user_sh(reg, addr)		sh reg, addr</span>
<span class="p_del">-#define user_sb(reg, addr)		sb reg, addr</span>
<span class="p_add">+#define user_cache(op, base)		kernel_cache(op, base)</span>
<span class="p_add">+#define user_ll(reg, addr)		kernel_ll(reg, addr)</span>
<span class="p_add">+#define user_sc(reg, addr)		kernel_sc(reg, addr)</span>
<span class="p_add">+#define user_lw(reg, addr)		kernel_lw(reg, addr)</span>
<span class="p_add">+#define user_lwl(reg, addr)		kernel_lwl(reg, addr)</span>
<span class="p_add">+#define user_lwr(reg, addr)		kernel_lwr(reg, addr)</span>
<span class="p_add">+#define user_lh(reg, addr)		kernel_lh(reg, addr)</span>
<span class="p_add">+#define user_lb(reg, addr)		kernel_lb(reg, addr)</span>
<span class="p_add">+#define user_lbu(reg, addr)		kernel_lbu(reg, addr)</span>
<span class="p_add">+#define user_sw(reg, addr)		kernel_sw(reg, addr)</span>
<span class="p_add">+#define user_swl(reg, addr)		kernel_swl(reg, addr)</span>
<span class="p_add">+#define user_swr(reg, addr)		kernel_swr(reg, addr)</span>
<span class="p_add">+#define user_sh(reg, addr)		kernel_sh(reg, addr)</span>
<span class="p_add">+#define user_sb(reg, addr)		kernel_sb(reg, addr)</span>
 
 #ifdef CONFIG_32BIT
<span class="p_del">-/*</span>
<span class="p_del">- * No &#39;sd&#39; or &#39;ld&#39; instructions in 32-bit but the code will</span>
<span class="p_del">- * do the correct thing</span>
<span class="p_del">- */</span>
<span class="p_del">-#define user_sd(reg, addr)		user_sw(reg, addr)</span>
<span class="p_del">-#define user_ld(reg, addr)		user_lw(reg, addr)</span>
<span class="p_add">+#define user_sd(reg, addr)		kernel_sw(reg, addr)</span>
<span class="p_add">+#define user_ld(reg, addr)		kernel_lw(reg, addr)</span>
 #else
<span class="p_del">-#define user_sd(reg, addr)		sd reg, addr</span>
<span class="p_del">-#define user_ld(reg, addr)		ld reg, addr</span>
<span class="p_add">+#define user_sd(reg, addr)		kernel_sd(reg, addr)</span>
<span class="p_add">+#define user_ld(reg, addr)		kernel_sd(reg, addr)</span>
 #endif /* CONFIG_32BIT */
 
 #endif /* CONFIG_EVA */
<span class="p_header">diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">index b0aa95565752..5a8defbad431 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -326,6 +326,7 @@</span> <span class="p_context"> enum mips_mmu_types {</span>
 #define T_TRAP			13	/* Trap instruction */
 #define T_VCEI			14	/* Virtual coherency exception */
 #define T_FPE			15	/* Floating point exception */
<span class="p_add">+#define T_MSADIS		21	/* MSA disabled exception */</span>
 #define T_WATCH			23	/* Watch address reference */
 #define T_VCED			31	/* Virtual coherency data */
 
<span class="p_chunk">@@ -578,6 +579,7 @@</span> <span class="p_context"> struct kvm_mips_callbacks {</span>
 	int (*handle_syscall)(struct kvm_vcpu *vcpu);
 	int (*handle_res_inst)(struct kvm_vcpu *vcpu);
 	int (*handle_break)(struct kvm_vcpu *vcpu);
<span class="p_add">+	int (*handle_msa_disabled)(struct kvm_vcpu *vcpu);</span>
 	int (*vm_init)(struct kvm *kvm);
 	int (*vcpu_init)(struct kvm_vcpu *vcpu);
 	int (*vcpu_setup)(struct kvm_vcpu *vcpu);
<span class="p_header">diff --git a/arch/mips/include/asm/suspend.h b/arch/mips/include/asm/suspend.h</span>
deleted file mode 100644
<span class="p_header">index 3adac3b53d19..000000000000</span>
<span class="p_header">--- a/arch/mips/include/asm/suspend.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,7 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef __ASM_SUSPEND_H</span>
<span class="p_del">-#define __ASM_SUSPEND_H</span>
<span class="p_del">-</span>
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* __ASM_SUSPEND_H */</span>
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">index d84f96e51349..59298b97ac39 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_chunk">@@ -1156,6 +1156,10 @@</span> <span class="p_context"> int kvm_mips_handle_exit(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 		ret = kvm_mips_callbacks-&gt;handle_break(vcpu);
 		break;
 
<span class="p_add">+	case T_MSADIS:</span>
<span class="p_add">+		ret = kvm_mips_callbacks-&gt;handle_msa_disabled(vcpu);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	default:
 		kvm_err
 		    (&quot;Exception Code: %d, not yet handled, @ PC: %p, inst: 0x%08x  BadVaddr: %#lx Status: %#lx\n&quot;,
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">index 8d4840090082..2071472bc3c4 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_chunk">@@ -2204,6 +2204,7 @@</span> <span class="p_context"> kvm_mips_check_privilege(unsigned long cause, uint32_t *opc,</span>
 		case T_SYSCALL:
 		case T_BREAK:
 		case T_RES_INST:
<span class="p_add">+		case T_MSADIS:</span>
 			break;
 
 		case T_COP_UNUSABLE:
<span class="p_header">diff --git a/arch/mips/kvm/kvm_trap_emul.c b/arch/mips/kvm/kvm_trap_emul.c</span>
<span class="p_header">index 693f952b2fbb..0c521c356553 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_trap_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_trap_emul.c</span>
<span class="p_chunk">@@ -333,6 +333,33 @@</span> <span class="p_context"> static int kvm_trap_emul_handle_break(struct kvm_vcpu *vcpu)</span>
 	return ret;
 }
 
<span class="p_add">+static int kvm_trap_emul_handle_msa_disabled(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_run *run = vcpu-&gt;run;</span>
<span class="p_add">+	uint32_t __user *opc = (uint32_t __user *) vcpu-&gt;arch.pc;</span>
<span class="p_add">+	unsigned long cause = vcpu-&gt;arch.host_cp0_cause;</span>
<span class="p_add">+	enum emulation_result er = EMULATE_DONE;</span>
<span class="p_add">+	int ret = RESUME_GUEST;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* No MSA supported in guest, guest reserved instruction exception */</span>
<span class="p_add">+	er = kvm_mips_emulate_ri_exc(cause, opc, run, vcpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (er) {</span>
<span class="p_add">+	case EMULATE_DONE:</span>
<span class="p_add">+		ret = RESUME_GUEST;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case EMULATE_FAIL:</span>
<span class="p_add">+		run-&gt;exit_reason = KVM_EXIT_INTERNAL_ERROR;</span>
<span class="p_add">+		ret = RESUME_HOST;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int kvm_trap_emul_vm_init(struct kvm *kvm)
 {
 	return 0;
<span class="p_chunk">@@ -472,6 +499,7 @@</span> <span class="p_context"> static struct kvm_mips_callbacks kvm_trap_emul_callbacks = {</span>
 	.handle_syscall = kvm_trap_emul_handle_syscall,
 	.handle_res_inst = kvm_trap_emul_handle_res_inst,
 	.handle_break = kvm_trap_emul_handle_break,
<span class="p_add">+	.handle_msa_disabled = kvm_trap_emul_handle_msa_disabled,</span>
 
 	.vm_init = kvm_trap_emul_vm_init,
 	.vcpu_init = kvm_trap_emul_vcpu_init,
<span class="p_header">diff --git a/arch/mips/loongson/loongson-3/irq.c b/arch/mips/loongson/loongson-3/irq.c</span>
<span class="p_header">index f240828181ff..f2077f201a2a 100644</span>
<span class="p_header">--- a/arch/mips/loongson/loongson-3/irq.c</span>
<span class="p_header">+++ b/arch/mips/loongson/loongson-3/irq.c</span>
<span class="p_chunk">@@ -42,6 +42,7 @@</span> <span class="p_context"> void mach_irq_dispatch(unsigned int pending)</span>
 
 static struct irqaction cascade_irqaction = {
 	.handler = no_action,
<span class="p_add">+	.flags = IRQF_NO_SUSPEND,</span>
 	.name = &quot;cascade&quot;,
 };
 
<span class="p_header">diff --git a/arch/mips/mti-malta/malta-memory.c b/arch/mips/mti-malta/malta-memory.c</span>
<span class="p_header">index fdffc806664f..9b3a07d962ce 100644</span>
<span class="p_header">--- a/arch/mips/mti-malta/malta-memory.c</span>
<span class="p_header">+++ b/arch/mips/mti-malta/malta-memory.c</span>
<span class="p_chunk">@@ -52,6 +52,12 @@</span> <span class="p_context"> fw_memblock_t * __init fw_getmdesc(int eva)</span>
 		pr_warn(&quot;memsize not set in YAMON, set to default (32Mb)\n&quot;);
 		physical_memsize = 0x02000000;
 	} else {
<span class="p_add">+		if (memsize &gt; (256 &lt;&lt; 20)) { /* memsize should be capped to 256M */</span>
<span class="p_add">+			pr_warn(&quot;Unsupported memsize value (0x%lx) detected! &quot;</span>
<span class="p_add">+				&quot;Using 0x10000000 (256M) instead\n&quot;,</span>
<span class="p_add">+				memsize);</span>
<span class="p_add">+			memsize = 256 &lt;&lt; 20;</span>
<span class="p_add">+		}</span>
 		/* If ememsize is set, then set physical_memsize to that */
 		physical_memsize = ememsize ? : memsize;
 	}
<span class="p_header">diff --git a/arch/mips/power/cpu.c b/arch/mips/power/cpu.c</span>
<span class="p_header">index 521e5963df05..2129e67723ff 100644</span>
<span class="p_header">--- a/arch/mips/power/cpu.c</span>
<span class="p_header">+++ b/arch/mips/power/cpu.c</span>
<span class="p_chunk">@@ -7,7 +7,7 @@</span> <span class="p_context"></span>
  * Author: Hu Hongbing &lt;huhb@lemote.com&gt;
  *	   Wu Zhangjin &lt;wuzhangjin@gmail.com&gt;
  */
<span class="p_del">-#include &lt;asm/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/fpu.h&gt;
 #include &lt;asm/dsp.h&gt;
 
<span class="p_header">diff --git a/arch/mips/power/hibernate.S b/arch/mips/power/hibernate.S</span>
<span class="p_header">index 32a7c828f073..e7567c8a9e79 100644</span>
<span class="p_header">--- a/arch/mips/power/hibernate.S</span>
<span class="p_header">+++ b/arch/mips/power/hibernate.S</span>
<span class="p_chunk">@@ -30,6 +30,8 @@</span> <span class="p_context"> LEAF(swsusp_arch_suspend)</span>
 END(swsusp_arch_suspend)
 
 LEAF(swsusp_arch_resume)
<span class="p_add">+	/* Avoid TLB mismatch during and after kernel resume */</span>
<span class="p_add">+	jal local_flush_tlb_all</span>
 	PTR_L t0, restore_pblist
 0:
 	PTR_L t1, PBE_ADDRESS(t0)   /* source */
<span class="p_chunk">@@ -43,7 +45,6 @@</span> <span class="p_context"> LEAF(swsusp_arch_resume)</span>
 	bne t1, t3, 1b
 	PTR_L t0, PBE_NEXT(t0)
 	bnez t0, 0b
<span class="p_del">-	jal local_flush_tlb_all /* Avoid TLB mismatch after kernel resume */</span>
 	PTR_LA t0, saved_regs
 	PTR_L ra, PT_R31(t0)
 	PTR_L sp, PT_R29(t0)
<span class="p_header">diff --git a/arch/powerpc/kernel/cacheinfo.c b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">index 40198d50b4c2..8005b79ecbcf 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -61,12 +61,22 @@</span> <span class="p_context"> struct cache_type_info {</span>
 };
 
 /* These are used to index the cache_type_info array. */
<span class="p_del">-#define CACHE_TYPE_UNIFIED     0</span>
<span class="p_del">-#define CACHE_TYPE_INSTRUCTION 1</span>
<span class="p_del">-#define CACHE_TYPE_DATA        2</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED     0 /* cache-size, cache-block-size, etc. */</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED_D   1 /* d-cache-size, d-cache-block-size, etc */</span>
<span class="p_add">+#define CACHE_TYPE_INSTRUCTION 2</span>
<span class="p_add">+#define CACHE_TYPE_DATA        3</span>
 
 static const struct cache_type_info cache_type_info[] = {
 	{
<span class="p_add">+		/* Embedded systems that use cache-size, cache-block-size,</span>
<span class="p_add">+		 * etc. for the Unified (typically L2) cache. */</span>
<span class="p_add">+		.name            = &quot;Unified&quot;,</span>
<span class="p_add">+		.size_prop       = &quot;cache-size&quot;,</span>
<span class="p_add">+		.line_size_props = { &quot;cache-line-size&quot;,</span>
<span class="p_add">+				     &quot;cache-block-size&quot;, },</span>
<span class="p_add">+		.nr_sets_prop    = &quot;cache-sets&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* PowerPC Processor binding says the [di]-cache-*
 		 * must be equal on unified caches, so just use
 		 * d-cache properties. */
<span class="p_chunk">@@ -293,7 +303,8 @@</span> <span class="p_context"> static struct cache *cache_find_first_sibling(struct cache *cache)</span>
 {
 	struct cache *iter;
 
<span class="p_del">-	if (cache-&gt;type == CACHE_TYPE_UNIFIED)</span>
<span class="p_add">+	if (cache-&gt;type == CACHE_TYPE_UNIFIED ||</span>
<span class="p_add">+	    cache-&gt;type == CACHE_TYPE_UNIFIED_D)</span>
 		return cache;
 
 	list_for_each_entry(iter, &amp;cache_list, list)
<span class="p_chunk">@@ -324,16 +335,29 @@</span> <span class="p_context"> static bool cache_node_is_unified(const struct device_node *np)</span>
 	return of_get_property(np, &quot;cache-unified&quot;, NULL);
 }
 
<span class="p_del">-static struct cache *cache_do_one_devnode_unified(struct device_node *node,</span>
<span class="p_del">-						  int level)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Unified caches can have two different sets of tags.  Most embedded</span>
<span class="p_add">+ * use cache-size, etc. for the unified cache size, but open firmware systems</span>
<span class="p_add">+ * use d-cache-size, etc.   Check on initialization for which type we have, and</span>
<span class="p_add">+ * return the appropriate structure type.  Assume it&#39;s embedded if it isn&#39;t</span>
<span class="p_add">+ * open firmware.  If it&#39;s yet a 3rd type, then there will be missing entries</span>
<span class="p_add">+ * in /sys/devices/system/cpu/cpu0/cache/index2/, and this code will need</span>
<span class="p_add">+ * to be extended further.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int cache_is_unified_d(const struct device_node *np)</span>
 {
<span class="p_del">-	struct cache *cache;</span>
<span class="p_add">+	return of_get_property(np,</span>
<span class="p_add">+		cache_type_info[CACHE_TYPE_UNIFIED_D].size_prop, NULL) ?</span>
<span class="p_add">+		CACHE_TYPE_UNIFIED_D : CACHE_TYPE_UNIFIED;</span>
<span class="p_add">+}</span>
 
<span class="p_add">+/*</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct cache *cache_do_one_devnode_unified(struct device_node *node, int level)</span>
<span class="p_add">+{</span>
 	pr_debug(&quot;creating L%d ucache for %s\n&quot;, level, node-&gt;full_name);
 
<span class="p_del">-	cache = new_cache(CACHE_TYPE_UNIFIED, level, node);</span>
<span class="p_del">-</span>
<span class="p_del">-	return cache;</span>
<span class="p_add">+	return new_cache(cache_is_unified_d(node), level, node);</span>
 }
 
 static struct cache *cache_do_one_devnode_split(struct device_node *node,
<span class="p_header">diff --git a/arch/powerpc/kernel/suspend.c b/arch/powerpc/kernel/suspend.c</span>
<span class="p_header">index 0167d53da30c..a531154cc0f3 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/suspend.c</span>
<span class="p_chunk">@@ -9,9 +9,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/mm.h&gt;
 #include &lt;asm/page.h&gt;
<span class="p_del">-</span>
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 
 /*
  *	pfn_is_nosave - check if given pfn is in the &#39;nosave&#39; section
<span class="p_header">diff --git a/arch/powerpc/perf/callchain.c b/arch/powerpc/perf/callchain.c</span>
<span class="p_header">index 2396dda282cd..ead55351b254 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/callchain.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/callchain.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static void perf_callchain_user_64(struct perf_callchain_entry *entry,</span>
 	sp = regs-&gt;gpr[1];
 	perf_callchain_store(entry, next_ip);
 
<span class="p_del">-	for (;;) {</span>
<span class="p_add">+	while (entry-&gt;nr &lt; PERF_MAX_STACK_DEPTH) {</span>
 		fp = (unsigned long __user *) sp;
 		if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &amp;next_sp))
 			return;
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/iommu.c b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">index 2b90ff8a93be..59ef76c5f4f4 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_chunk">@@ -197,7 +197,7 @@</span> <span class="p_context"> static int tce_build_cell(struct iommu_table *tbl, long index, long npages,</span>
 
 	io_pte = (unsigned long *)tbl-&gt;it_base + (index - tbl-&gt;it_offset);
 
<span class="p_del">-	for (i = 0; i &lt; npages; i++, uaddr += tbl-&gt;it_page_shift)</span>
<span class="p_add">+	for (i = 0; i &lt; npages; i++, uaddr += (1 &lt;&lt; tbl-&gt;it_page_shift))</span>
 		io_pte[i] = base_pte | (__pa(uaddr) &amp; CBE_IOPTE_RPN_Mask);
 
 	mb();
<span class="p_header">diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c</span>
<span class="p_header">index a7a7537ce1e7..d3236c9e226b 100644</span>
<span class="p_header">--- a/arch/s390/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/s390/kernel/suspend.c</span>
<span class="p_chunk">@@ -13,14 +13,10 @@</span> <span class="p_context"></span>
 #include &lt;asm/ipl.h&gt;
 #include &lt;asm/cio.h&gt;
 #include &lt;asm/pci.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &quot;entry.h&quot;
 
 /*
<span class="p_del">- * References to section boundaries</span>
<span class="p_del">- */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * The restore of the saved pages in an hibernation image will set
  * the change and referenced bits in the storage key for each page.
  * Overindication of the referenced bits after an hibernation cycle
<span class="p_chunk">@@ -142,6 +138,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 {
 	unsigned long nosave_begin_pfn = PFN_DOWN(__pa(&amp;__nosave_begin));
 	unsigned long nosave_end_pfn = PFN_DOWN(__pa(&amp;__nosave_end));
<span class="p_add">+	unsigned long eshared_pfn = PFN_DOWN(__pa(&amp;_eshared)) - 1;</span>
<span class="p_add">+	unsigned long stext_pfn = PFN_DOWN(__pa(&amp;_stext));</span>
 
 	/* Always save lowcore pages (LC protection might be enabled). */
 	if (pfn &lt;= LC_PAGES)
<span class="p_chunk">@@ -149,6 +147,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 	if (pfn &gt;= nosave_begin_pfn &amp;&amp; pfn &lt; nosave_end_pfn)
 		return 1;
 	/* Skip memory holes and read-only pages (NSS, DCSS, ...). */
<span class="p_add">+	if (pfn &gt;= stext_pfn &amp;&amp; pfn &lt;= eshared_pfn)</span>
<span class="p_add">+		return ipl_info.type == IPL_TYPE_NSS ? 1 : 0;</span>
 	if (tprot(PFN_PHYS(pfn)))
 		return 1;
 	return 0;
<span class="p_header">diff --git a/arch/s390/kvm/interrupt.c b/arch/s390/kvm/interrupt.c</span>
<span class="p_header">index f19702fc89ec..be5fb350d255 100644</span>
<span class="p_header">--- a/arch/s390/kvm/interrupt.c</span>
<span class="p_header">+++ b/arch/s390/kvm/interrupt.c</span>
<span class="p_chunk">@@ -1007,10 +1007,10 @@</span> <span class="p_context"> int kvm_s390_inject_vm(struct kvm *kvm,</span>
 	return rc;
 }
 
<span class="p_del">-void kvm_s390_reinject_io_int(struct kvm *kvm,</span>
<span class="p_add">+int kvm_s390_reinject_io_int(struct kvm *kvm,</span>
 			      struct kvm_s390_interrupt_info *inti)
 {
<span class="p_del">-	__inject_vm(kvm, inti);</span>
<span class="p_add">+	return __inject_vm(kvm, inti);</span>
 }
 
 int kvm_s390_inject_vcpu(struct kvm_vcpu *vcpu,
<span class="p_header">diff --git a/arch/s390/kvm/kvm-s390.h b/arch/s390/kvm/kvm-s390.h</span>
<span class="p_header">index a8655ed31616..3d08a076729f 100644</span>
<span class="p_header">--- a/arch/s390/kvm/kvm-s390.h</span>
<span class="p_header">+++ b/arch/s390/kvm/kvm-s390.h</span>
<span class="p_chunk">@@ -143,8 +143,8 @@</span> <span class="p_context"> int __must_check kvm_s390_inject_vcpu(struct kvm_vcpu *vcpu,</span>
 int __must_check kvm_s390_inject_program_int(struct kvm_vcpu *vcpu, u16 code);
 struct kvm_s390_interrupt_info *kvm_s390_get_io_int(struct kvm *kvm,
 						    u64 cr6, u64 schid);
<span class="p_del">-void kvm_s390_reinject_io_int(struct kvm *kvm,</span>
<span class="p_del">-			      struct kvm_s390_interrupt_info *inti);</span>
<span class="p_add">+int kvm_s390_reinject_io_int(struct kvm *kvm,</span>
<span class="p_add">+			     struct kvm_s390_interrupt_info *inti);</span>
 int kvm_s390_mask_adapter(struct kvm *kvm, unsigned int id, bool masked);
 
 /* implemented in priv.c */
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index 9f41229df1aa..8a5156d85c70 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -228,18 +228,19 @@</span> <span class="p_context"> static int handle_tpi(struct kvm_vcpu *vcpu)</span>
 	struct kvm_s390_interrupt_info *inti;
 	unsigned long len;
 	u32 tpi_data[3];
<span class="p_del">-	int cc, rc;</span>
<span class="p_add">+	int rc;</span>
 	u64 addr;
 
<span class="p_del">-	rc = 0;</span>
 	addr = kvm_s390_get_base_disp_s(vcpu);
 	if (addr &amp; 3)
 		return kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);
<span class="p_del">-	cc = 0;</span>
<span class="p_add">+</span>
 	inti = kvm_s390_get_io_int(vcpu-&gt;kvm, vcpu-&gt;arch.sie_block-&gt;gcr[6], 0);
<span class="p_del">-	if (!inti)</span>
<span class="p_del">-		goto no_interrupt;</span>
<span class="p_del">-	cc = 1;</span>
<span class="p_add">+	if (!inti) {</span>
<span class="p_add">+		kvm_s390_set_psw_cc(vcpu, 0);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	tpi_data[0] = inti-&gt;io.subchannel_id &lt;&lt; 16 | inti-&gt;io.subchannel_nr;
 	tpi_data[1] = inti-&gt;io.io_int_parm;
 	tpi_data[2] = inti-&gt;io.io_int_word;
<span class="p_chunk">@@ -250,30 +251,38 @@</span> <span class="p_context"> static int handle_tpi(struct kvm_vcpu *vcpu)</span>
 		 */
 		len = sizeof(tpi_data) - 4;
 		rc = write_guest(vcpu, addr, &amp;tpi_data, len);
<span class="p_del">-		if (rc)</span>
<span class="p_del">-			return kvm_s390_inject_prog_cond(vcpu, rc);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			rc = kvm_s390_inject_prog_cond(vcpu, rc);</span>
<span class="p_add">+			goto reinject_interrupt;</span>
<span class="p_add">+		}</span>
 	} else {
 		/*
 		 * Store the three-word I/O interruption code into
 		 * the appropriate lowcore area.
 		 */
 		len = sizeof(tpi_data);
<span class="p_del">-		if (write_guest_lc(vcpu, __LC_SUBCHANNEL_ID, &amp;tpi_data, len))</span>
<span class="p_add">+		if (write_guest_lc(vcpu, __LC_SUBCHANNEL_ID, &amp;tpi_data, len)) {</span>
<span class="p_add">+			/* failed writes to the low core are not recoverable */</span>
 			rc = -EFAULT;
<span class="p_add">+			goto reinject_interrupt;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* irq was successfully handed to the guest */</span>
<span class="p_add">+	kfree(inti);</span>
<span class="p_add">+	kvm_s390_set_psw_cc(vcpu, 1);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+reinject_interrupt:</span>
 	/*
 	 * If we encounter a problem storing the interruption code, the
 	 * instruction is suppressed from the guest&#39;s view: reinject the
 	 * interrupt.
 	 */
<span class="p_del">-	if (!rc)</span>
<span class="p_add">+	if (kvm_s390_reinject_io_int(vcpu-&gt;kvm, inti)) {</span>
 		kfree(inti);
<span class="p_del">-	else</span>
<span class="p_del">-		kvm_s390_reinject_io_int(vcpu-&gt;kvm, inti);</span>
<span class="p_del">-no_interrupt:</span>
<span class="p_del">-	/* Set condition code and we&#39;re done. */</span>
<span class="p_del">-	if (!rc)</span>
<span class="p_del">-		kvm_s390_set_psw_cc(vcpu, cc);</span>
<span class="p_add">+		rc = -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* don&#39;t set the cc, a pgm irq was injected or we drop to user space */</span>
 	return rc ? -EFAULT : 0;
 }
 
<span class="p_chunk">@@ -470,6 +479,7 @@</span> <span class="p_context"> static void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)</span>
 	for (n = mem-&gt;count - 1; n &gt; 0 ; n--)
 		memcpy(&amp;mem-&gt;vm[n], &amp;mem-&gt;vm[n - 1], sizeof(mem-&gt;vm[0]));
 
<span class="p_add">+	memset(&amp;mem-&gt;vm[0], 0, sizeof(mem-&gt;vm[0]));</span>
 	mem-&gt;vm[0].cpus_total = cpus;
 	mem-&gt;vm[0].cpus_configured = cpus;
 	mem-&gt;vm[0].cpus_standby = 0;
<span class="p_header">diff --git a/arch/sh/include/asm/sections.h b/arch/sh/include/asm/sections.h</span>
<span class="p_header">index 1b6199740e98..7a99e6af6372 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/sections.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/sections.h</span>
<span class="p_chunk">@@ -3,7 +3,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm-generic/sections.h&gt;
 
<span class="p_del">-extern long __nosave_begin, __nosave_end;</span>
 extern long __machvec_start, __machvec_end;
 extern char __uncached_start, __uncached_end;
 extern char __start_eh_frame[], __stop_eh_frame[];
<span class="p_header">diff --git a/arch/sparc/power/hibernate.c b/arch/sparc/power/hibernate.c</span>
<span class="p_header">index 42b0b8ce699a..17bd2e167e07 100644</span>
<span class="p_header">--- a/arch/sparc/power/hibernate.c</span>
<span class="p_header">+++ b/arch/sparc/power/hibernate.c</span>
<span class="p_chunk">@@ -9,11 +9,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/hibernate.h&gt;
 #include &lt;asm/visasm.h&gt;
 #include &lt;asm/page.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/tlb.h&gt;
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 struct saved_context saved_context;
 
 /*
<span class="p_header">diff --git a/arch/unicore32/include/mach/pm.h b/arch/unicore32/include/mach/pm.h</span>
<span class="p_header">index 4dcd34ae194c..77b522694e74 100644</span>
<span class="p_header">--- a/arch/unicore32/include/mach/pm.h</span>
<span class="p_header">+++ b/arch/unicore32/include/mach/pm.h</span>
<span class="p_chunk">@@ -36,8 +36,5 @@</span> <span class="p_context"> extern int puv3_pm_enter(suspend_state_t state);</span>
 /* Defined in hibernate_asm.S */
 extern int restore_image(pgd_t *resume_pg_dir, struct pbe *restore_pblist);
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 extern struct pbe *restore_pblist;
 #endif
<span class="p_header">diff --git a/arch/unicore32/kernel/hibernate.c b/arch/unicore32/kernel/hibernate.c</span>
<span class="p_header">index d75ef8b6cb56..9969ec374abb 100644</span>
<span class="p_header">--- a/arch/unicore32/kernel/hibernate.c</span>
<span class="p_header">+++ b/arch/unicore32/kernel/hibernate.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/pgalloc.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/suspend.h&gt;
 
 #include &quot;mach/pm.h&quot;
<span class="p_header">diff --git a/arch/x86/include/asm/mwait.h b/arch/x86/include/asm/mwait.h</span>
<span class="p_header">index 1da25a5f96f9..3ba047cbcf5b 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mwait.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mwait.h</span>
<span class="p_chunk">@@ -30,6 +30,14 @@</span> <span class="p_context"> static inline void __mwait(unsigned long eax, unsigned long ecx)</span>
 		     :: &quot;a&quot; (eax), &quot;c&quot; (ecx));
 }
 
<span class="p_add">+static inline void __sti_mwait(unsigned long eax, unsigned long ecx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_hardirqs_on();</span>
<span class="p_add">+	/* &quot;mwait %eax, %ecx;&quot; */</span>
<span class="p_add">+	asm volatile(&quot;sti; .byte 0x0f, 0x01, 0xc9;&quot;</span>
<span class="p_add">+		     :: &quot;a&quot; (eax), &quot;c&quot; (ecx));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * This uses new MONITOR/MWAIT instructions on P4 processors with PNI,
  * which can obviate IPI to trigger checking of need_resched.
<span class="p_header">diff --git a/arch/x86/include/asm/pvclock.h b/arch/x86/include/asm/pvclock.h</span>
<span class="p_header">index d6b078e9fa28..25b1cc07d496 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pvclock.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pvclock.h</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> unsigned __pvclock_read_cycles(const struct pvclock_vcpu_time_info *src,</span>
 
 struct pvclock_vsyscall_time_info {
 	struct pvclock_vcpu_time_info pvti;
<span class="p_add">+	u32 migrate_count;</span>
 } __attribute__((__aligned__(SMP_CACHE_BYTES)));
 
 #define PVTI_SIZE sizeof(struct pvclock_vsyscall_time_info)
<span class="p_header">diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c</span>
<span class="p_header">index 4505e2a950d8..c98cff71760d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process.c</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/syscalls.h&gt;
 #include &lt;asm/idle.h&gt;
 #include &lt;asm/uaccess.h&gt;
<span class="p_add">+#include &lt;asm/mwait.h&gt;</span>
 #include &lt;asm/i387.h&gt;
 #include &lt;asm/fpu-internal.h&gt;
 #include &lt;asm/debugreg.h&gt;
<span class="p_chunk">@@ -395,6 +396,52 @@</span> <span class="p_context"> static void amd_e400_idle(void)</span>
 		default_idle();
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Intel Core2 and older machines prefer MWAIT over HALT for C1.</span>
<span class="p_add">+ * We can&#39;t rely on cpuidle installing MWAIT, because it will not load</span>
<span class="p_add">+ * on systems that support only C1 -- so the boot default must be MWAIT.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some AMD machines are the opposite, they depend on using HALT.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * So for default C1, which is used during boot until cpuidle loads,</span>
<span class="p_add">+ * use MWAIT-C1 on Intel HW that has it, else use HALT.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int prefer_mwait_c1_over_halt(const struct cpuinfo_x86 *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (c-&gt;x86_vendor != X86_VENDOR_INTEL)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpu_has(c, X86_FEATURE_MWAIT))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MONITOR/MWAIT with no hints, used for default default C1 state.</span>
<span class="p_add">+ * This invokes MWAIT with interrutps enabled and no flags,</span>
<span class="p_add">+ * which is backwards compatible with the original MWAIT implementation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static void mwait_idle(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!current_set_polling_and_test()) {</span>
<span class="p_add">+		if (static_cpu_has(X86_FEATURE_CLFLUSH_MONITOR)) {</span>
<span class="p_add">+			mb();</span>
<span class="p_add">+			clflush((void *)&amp;current_thread_info()-&gt;flags);</span>
<span class="p_add">+			mb();</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		__monitor((void *)&amp;current_thread_info()-&gt;flags, 0, 0);</span>
<span class="p_add">+		if (!need_resched())</span>
<span class="p_add">+			__sti_mwait(0, 0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			local_irq_enable();</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		local_irq_enable();</span>
<span class="p_add">+	current_clr_polling();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void select_idle_routine(const struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_SMP
<span class="p_chunk">@@ -408,6 +455,9 @@</span> <span class="p_context"> void select_idle_routine(const struct cpuinfo_x86 *c)</span>
 		/* E400: APIC timer interrupt does not wake up CPU from C1e */
 		pr_info(&quot;using AMD E400 aware idle routine\n&quot;);
 		x86_idle = amd_e400_idle;
<span class="p_add">+	} else if (prefer_mwait_c1_over_halt(c)) {</span>
<span class="p_add">+		pr_info(&quot;using mwait in idle threads\n&quot;);</span>
<span class="p_add">+		x86_idle = mwait_idle;</span>
 	} else
 		x86_idle = default_idle;
 }
<span class="p_header">diff --git a/arch/x86/kernel/pvclock.c b/arch/x86/kernel/pvclock.c</span>
<span class="p_header">index 2f355d229a58..e5ecd20e72dd 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pvclock.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pvclock.c</span>
<span class="p_chunk">@@ -141,7 +141,46 @@</span> <span class="p_context"> void pvclock_read_wallclock(struct pvclock_wall_clock *wall_clock,</span>
 	set_normalized_timespec(ts, now.tv_sec, now.tv_nsec);
 }
 
<span class="p_add">+static struct pvclock_vsyscall_time_info *pvclock_vdso_info;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct pvclock_vsyscall_time_info *</span>
<span class="p_add">+pvclock_get_vsyscall_user_time_info(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!pvclock_vdso_info) {</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;pvclock_vdso_info[cpu];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct pvclock_vcpu_time_info *pvclock_get_vsyscall_time_info(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;pvclock_get_vsyscall_user_time_info(cpu)-&gt;pvti;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_64
<span class="p_add">+static int pvclock_task_migrate(struct notifier_block *nb, unsigned long l,</span>
<span class="p_add">+			        void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_migration_notifier *mn = v;</span>
<span class="p_add">+	struct pvclock_vsyscall_time_info *pvti;</span>
<span class="p_add">+</span>
<span class="p_add">+	pvti = pvclock_get_vsyscall_user_time_info(mn-&gt;from_cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* this is NULL when pvclock vsyscall is not initialized */</span>
<span class="p_add">+	if (unlikely(pvti == NULL))</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
<span class="p_add">+</span>
<span class="p_add">+	pvti-&gt;migrate_count++;</span>
<span class="p_add">+</span>
<span class="p_add">+	return NOTIFY_DONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block pvclock_migrate = {</span>
<span class="p_add">+	.notifier_call = pvclock_task_migrate,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Initialize the generic pvclock vsyscall state.  This will allocate
  * a/some page(s) for the per-vcpu pvclock information, set up a
<span class="p_chunk">@@ -155,12 +194,17 @@</span> <span class="p_context"> int __init pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i,</span>
 
 	WARN_ON (size != PVCLOCK_VSYSCALL_NR_PAGES*PAGE_SIZE);
 
<span class="p_add">+	pvclock_vdso_info = i;</span>
<span class="p_add">+</span>
 	for (idx = 0; idx &lt;= (PVCLOCK_FIXMAP_END-PVCLOCK_FIXMAP_BEGIN); idx++) {
 		__set_fixmap(PVCLOCK_FIXMAP_BEGIN + idx,
 			     __pa(i) + (idx*PAGE_SIZE),
 			     PAGE_KERNEL_VVAR);
 	}
 
<span class="p_add">+</span>
<span class="p_add">+	register_task_migration_notifier(&amp;pvclock_migrate);</span>
<span class="p_add">+</span>
 	return 0;
 }
 #endif
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 453e5fbbb7ae..f96b8a4d3fed 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -323,8 +323,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(kvm_apic_update_irr);</span>
 
 static inline void apic_set_irr(int vec, struct kvm_lapic *apic)
 {
<span class="p_del">-	apic-&gt;irr_pending = true;</span>
 	apic_set_vector(vec, apic-&gt;regs + APIC_IRR);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * irr_pending must be true if any interrupt is pending; set it after</span>
<span class="p_add">+	 * APIC_IRR to avoid race with apic_clear_irr</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	apic-&gt;irr_pending = true;</span>
 }
 
 static inline int apic_search_irr(struct kvm_lapic *apic)
<span class="p_chunk">@@ -356,13 +360,15 @@</span> <span class="p_context"> static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)</span>
 
 	vcpu = apic-&gt;vcpu;
 
<span class="p_del">-	apic_clear_vector(vec, apic-&gt;regs + APIC_IRR);</span>
<span class="p_del">-	if (unlikely(kvm_apic_vid_enabled(vcpu-&gt;kvm)))</span>
<span class="p_add">+	if (unlikely(kvm_apic_vid_enabled(vcpu-&gt;kvm))) {</span>
 		/* try to update RVI */
<span class="p_add">+		apic_clear_vector(vec, apic-&gt;regs + APIC_IRR);</span>
 		kvm_make_request(KVM_REQ_EVENT, vcpu);
<span class="p_del">-	else {</span>
<span class="p_del">-		vec = apic_search_irr(apic);</span>
<span class="p_del">-		apic-&gt;irr_pending = (vec != -1);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		apic-&gt;irr_pending = false;</span>
<span class="p_add">+		apic_clear_vector(vec, apic-&gt;regs + APIC_IRR);</span>
<span class="p_add">+		if (apic_search_irr(apic) != -1)</span>
<span class="p_add">+			apic-&gt;irr_pending = true;</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index a711a0d1ebc3..6018e319d7fb 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -5634,7 +5634,6 @@</span> <span class="p_context"> int kvm_arch_init(void *opaque)</span>
 	kvm_set_mmio_spte_mask();
 
 	kvm_x86_ops = ops;
<span class="p_del">-	kvm_init_msr_list();</span>
 
 	kvm_mmu_set_mask_ptes(PT_USER_MASK, PT_ACCESSED_MASK,
 			PT_DIRTY_MASK, PT64_NX_MASK, 0);
<span class="p_chunk">@@ -7015,7 +7014,14 @@</span> <span class="p_context"> void kvm_arch_hardware_disable(void *garbage)</span>
 
 int kvm_arch_hardware_setup(void)
 {
<span class="p_del">-	return kvm_x86_ops-&gt;hardware_setup();</span>
<span class="p_add">+	int r;</span>
<span class="p_add">+</span>
<span class="p_add">+	r = kvm_x86_ops-&gt;hardware_setup();</span>
<span class="p_add">+	if (r != 0)</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_init_msr_list();</span>
<span class="p_add">+	return 0;</span>
 }
 
 void kvm_arch_hardware_unsetup(void)
<span class="p_header">diff --git a/arch/x86/power/hibernate_32.c b/arch/x86/power/hibernate_32.c</span>
<span class="p_header">index 7d28c885d238..291226b952a9 100644</span>
<span class="p_header">--- a/arch/x86/power/hibernate_32.c</span>
<span class="p_header">+++ b/arch/x86/power/hibernate_32.c</span>
<span class="p_chunk">@@ -13,13 +13,11 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/mmzone.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 
 /* Defined in hibernate_asm_32.S */
 extern int restore_image(void);
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 /* Pointer to the temporary resume page tables */
 pgd_t *resume_pg_dir;
 
<span class="p_header">diff --git a/arch/x86/power/hibernate_64.c b/arch/x86/power/hibernate_64.c</span>
<span class="p_header">index 35e2bb6c0f37..009947d419a6 100644</span>
<span class="p_header">--- a/arch/x86/power/hibernate_64.c</span>
<span class="p_header">+++ b/arch/x86/power/hibernate_64.c</span>
<span class="p_chunk">@@ -17,11 +17,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/mtrr.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/suspend.h&gt;
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern __visible const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 /* Defined in hibernate_asm_64.S */
 extern asmlinkage __visible int restore_image(void);
 
<span class="p_header">diff --git a/arch/x86/vdso/vclock_gettime.c b/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_header">index 9793322751e0..40d2473836c9 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_header">+++ b/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_chunk">@@ -82,18 +82,15 @@</span> <span class="p_context"> static notrace cycle_t vread_pvclock(int *mode)</span>
 	cycle_t ret;
 	u64 last;
 	u32 version;
<span class="p_add">+	u32 migrate_count;</span>
 	u8 flags;
 	unsigned cpu, cpu1;
 
 
 	/*
<span class="p_del">-	 * Note: hypervisor must guarantee that:</span>
<span class="p_del">-	 * 1. cpu ID number maps 1:1 to per-CPU pvclock time info.</span>
<span class="p_del">-	 * 2. that per-CPU pvclock time info is updated if the</span>
<span class="p_del">-	 *    underlying CPU changes.</span>
<span class="p_del">-	 * 3. that version is increased whenever underlying CPU</span>
<span class="p_del">-	 *    changes.</span>
<span class="p_del">-	 *</span>
<span class="p_add">+	 * When looping to get a consistent (time-info, tsc) pair, we</span>
<span class="p_add">+	 * also need to deal with the possibility we can switch vcpus,</span>
<span class="p_add">+	 * so make sure we always re-fetch time-info for the current vcpu.</span>
 	 */
 	do {
 		cpu = __getcpu() &amp; VGETCPU_CPU_MASK;
<span class="p_chunk">@@ -102,20 +99,27 @@</span> <span class="p_context"> static notrace cycle_t vread_pvclock(int *mode)</span>
 		 * __getcpu() calls (Gleb).
 		 */
 
<span class="p_del">-		pvti = get_pvti(cpu);</span>
<span class="p_add">+		/* Make sure migrate_count will change if we leave the VCPU. */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			pvti = get_pvti(cpu);</span>
<span class="p_add">+			migrate_count = pvti-&gt;migrate_count;</span>
<span class="p_add">+</span>
<span class="p_add">+			cpu1 = cpu;</span>
<span class="p_add">+			cpu = __getcpu() &amp; VGETCPU_CPU_MASK;</span>
<span class="p_add">+		} while (unlikely(cpu != cpu1));</span>
 
 		version = __pvclock_read_cycles(&amp;pvti-&gt;pvti, &amp;ret, &amp;flags);
 
 		/*
 		 * Test we&#39;re still on the cpu as well as the version.
<span class="p_del">-		 * We could have been migrated just after the first</span>
<span class="p_del">-		 * vgetcpu but before fetching the version, so we</span>
<span class="p_del">-		 * wouldn&#39;t notice a version change.</span>
<span class="p_add">+		 * - We must read TSC of pvti&#39;s VCPU.</span>
<span class="p_add">+		 * - KVM doesn&#39;t follow the versioning protocol, so data could</span>
<span class="p_add">+		 *   change before version if we left the VCPU.</span>
 		 */
<span class="p_del">-		cpu1 = __getcpu() &amp; VGETCPU_CPU_MASK;</span>
<span class="p_del">-	} while (unlikely(cpu != cpu1 ||</span>
<span class="p_del">-			  (pvti-&gt;pvti.version &amp; 1) ||</span>
<span class="p_del">-			  pvti-&gt;pvti.version != version));</span>
<span class="p_add">+		smp_rmb();</span>
<span class="p_add">+	} while (unlikely((pvti-&gt;pvti.version &amp; 1) ||</span>
<span class="p_add">+			  pvti-&gt;pvti.version != version ||</span>
<span class="p_add">+			  pvti-&gt;migrate_count != migrate_count));</span>
 
 	if (unlikely(!(flags &amp; PVCLOCK_TSC_STABLE_BIT)))
 		*mode = VCLOCK_NONE;
<span class="p_header">diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig</span>
<span class="p_header">index 3a617af60d46..6f30b98d8280 100644</span>
<span class="p_header">--- a/arch/xtensa/Kconfig</span>
<span class="p_header">+++ b/arch/xtensa/Kconfig</span>
<span class="p_chunk">@@ -348,6 +348,36 @@</span> <span class="p_context"> source &quot;drivers/pcmcia/Kconfig&quot;</span>
 
 source &quot;drivers/pci/hotplug/Kconfig&quot;
 
<span class="p_add">+config XTFPGA_LCD</span>
<span class="p_add">+	bool &quot;Enable XTFPGA LCD driver&quot;</span>
<span class="p_add">+	depends on XTENSA_PLATFORM_XTFPGA</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  There&#39;s a 2x16 LCD on most of XTFPGA boards, kernel may output</span>
<span class="p_add">+	  progress messages there during bootup/shutdown. It may be useful</span>
<span class="p_add">+	  during board bringup.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_BASE_ADDR</span>
<span class="p_add">+	hex &quot;XTFPGA LCD base address&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default &quot;0x0d0c0000&quot;</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Base address of the LCD controller inside KIO region.</span>
<span class="p_add">+	  Different boards from XTFPGA family have LCD controller at different</span>
<span class="p_add">+	  addresses. Please consult prototyping user guide for your board for</span>
<span class="p_add">+	  the correct address. Wrong address here may lead to hardware lockup.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	bool &quot;Use 8-bit access to XTFPGA LCD&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  LCD may be connected with 4- or 8-bit interface, 8-bit access may</span>
<span class="p_add">+	  only be used with 8-bit interface. Please consult prototyping user</span>
<span class="p_add">+	  guide for your board for the correct interface width.</span>
<span class="p_add">+</span>
 endmenu
 
 menu &quot;Executable file formats&quot;
<span class="p_header">diff --git a/arch/xtensa/include/uapi/asm/unistd.h b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">index 50084f7c01c8..b54fa1bd7f7e 100644</span>
<span class="p_header">--- a/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">+++ b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_chunk">@@ -715,7 +715,7 @@</span> <span class="p_context"> __SYSCALL(323, sys_process_vm_writev, 6)</span>
 __SYSCALL(324, sys_name_to_handle_at, 5)
 #define __NR_open_by_handle_at			325
 __SYSCALL(325, sys_open_by_handle_at, 3)
<span class="p_del">-#define __NR_sync_file_range			326</span>
<span class="p_add">+#define __NR_sync_file_range2			326</span>
 __SYSCALL(326, sys_sync_file_range2, 6)
 #define __NR_perf_event_open			327
 __SYSCALL(327, sys_perf_event_open, 5)
<span class="p_header">diff --git a/arch/xtensa/platforms/iss/network.c b/arch/xtensa/platforms/iss/network.c</span>
<span class="p_header">index d05f8feeb8d7..17b1ef3232e4 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/iss/network.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/iss/network.c</span>
<span class="p_chunk">@@ -349,8 +349,8 @@</span> <span class="p_context"> static void iss_net_timer(unsigned long priv)</span>
 {
 	struct iss_net_private *lp = (struct iss_net_private *)priv;
 
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
 	iss_net_poll();
<span class="p_add">+	spin_lock(&amp;lp-&gt;lock);</span>
 	mod_timer(&amp;lp-&gt;timer, jiffies + lp-&gt;timer_val);
 	spin_unlock(&amp;lp-&gt;lock);
 }
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	struct iss_net_private *lp = netdev_priv(dev);
 	int err;
 
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	err = lp-&gt;tp.open(lp);
 	if (err &lt; 0)
<span class="p_chunk">@@ -376,9 +376,11 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	while ((err = iss_net_rx(dev)) &gt; 0)
 		;
 
<span class="p_del">-	spin_lock(&amp;opened_lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;opened_lock);</span>
 	list_add(&amp;lp-&gt;opened_list, &amp;opened);
<span class="p_del">-	spin_unlock(&amp;opened_lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;opened_lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	init_timer(&amp;lp-&gt;timer);
 	lp-&gt;timer_val = ISS_NET_TIMER_VALUE;
<span class="p_chunk">@@ -387,7 +389,7 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	mod_timer(&amp;lp-&gt;timer, jiffies + lp-&gt;timer_val);
 
 out:
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -395,7 +397,7 @@</span> <span class="p_context"> static int iss_net_close(struct net_device *dev)</span>
 {
 	struct iss_net_private *lp = netdev_priv(dev);
 	netif_stop_queue(dev);
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	spin_lock(&amp;opened_lock);
 	list_del(&amp;opened);
<span class="p_chunk">@@ -405,18 +407,17 @@</span> <span class="p_context"> static int iss_net_close(struct net_device *dev)</span>
 
 	lp-&gt;tp.close(lp);
 
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return 0;
 }
 
 static int iss_net_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct iss_net_private *lp = netdev_priv(dev);
<span class="p_del">-	unsigned long flags;</span>
 	int len;
 
 	netif_stop_queue(dev);
<span class="p_del">-	spin_lock_irqsave(&amp;lp-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	len = lp-&gt;tp.write(lp, &amp;skb);
 
<span class="p_chunk">@@ -438,7 +439,7 @@</span> <span class="p_context"> static int iss_net_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		pr_err(&quot;%s: %s failed(%d)\n&quot;, dev-&gt;name, __func__, len);
 	}
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;lp-&gt;lock, flags);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 
 	dev_kfree_skb(skb);
 	return NETDEV_TX_OK;
<span class="p_chunk">@@ -466,9 +467,9 @@</span> <span class="p_context"> static int iss_net_set_mac(struct net_device *dev, void *addr)</span>
 
 	if (!is_valid_ether_addr(hwaddr-&gt;sa_data))
 		return -EADDRNOTAVAIL;
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 	memcpy(dev-&gt;dev_addr, hwaddr-&gt;sa_data, ETH_ALEN);
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -520,11 +521,11 @@</span> <span class="p_context"> static int iss_net_configure(int index, char *init)</span>
 	*lp = (struct iss_net_private) {
 		.device_list		= LIST_HEAD_INIT(lp-&gt;device_list),
 		.opened_list		= LIST_HEAD_INIT(lp-&gt;opened_list),
<span class="p_del">-		.lock			= __SPIN_LOCK_UNLOCKED(lp.lock),</span>
 		.dev			= dev,
 		.index			= index,
<span class="p_del">-		};</span>
<span class="p_add">+	};</span>
 
<span class="p_add">+	spin_lock_init(&amp;lp-&gt;lock);</span>
 	/*
 	 * If this name ends up conflicting with an existing registered
 	 * netdevice, that is OK, register_netdev{,ice}() will notice this
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/Makefile b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">index b9ae206340cd..7839d38b2337 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_chunk">@@ -6,4 +6,5 @@</span> <span class="p_context"></span>
 #
 # Note 2! The CFLAGS definitions are in the main makefile...
 
<span class="p_del">-obj-y			= setup.o lcd.o</span>
<span class="p_add">+obj-y			+= setup.o</span>
<span class="p_add">+obj-$(CONFIG_XTFPGA_LCD) += lcd.o</span>
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">index aeb316b7ff88..e8cc86fbba09 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_chunk">@@ -40,9 +40,6 @@</span> <span class="p_context"></span>
 
 /* UART */
 #define DUART16552_PADDR	(XCHAL_KIO_PADDR + 0x0D050020)
<span class="p_del">-/* LCD instruction and data addresses. */</span>
<span class="p_del">-#define LCD_INSTR_ADDR		((char *)IOADDR(0x0D040000))</span>
<span class="p_del">-#define LCD_DATA_ADDR		((char *)IOADDR(0x0D040004))</span>
 
 /* Misc. */
 #define XTFPGA_FPGAREGS_VADDR	IOADDR(0x0D020000)
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">index 0e435645af5a..4c8541ed1139 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_chunk">@@ -11,10 +11,25 @@</span> <span class="p_context"></span>
 #ifndef __XTENSA_XTAVNET_LCD_H
 #define __XTENSA_XTAVNET_LCD_H
 
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD</span>
 /* Display string STR at position POS on the LCD. */
 void lcd_disp_at_pos(char *str, unsigned char pos);
 
 /* Shift the contents of the LCD display left or right. */
 void lcd_shiftleft(void);
 void lcd_shiftright(void);
<span class="p_add">+#else</span>
<span class="p_add">+static inline void lcd_disp_at_pos(char *str, unsigned char pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftleft(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftright(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/lcd.c b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">index 2872301598df..4dc0c1b43f4b 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_chunk">@@ -1,50 +1,63 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Driver for the LCD display on the Tensilica LX60 Board.</span>
<span class="p_add">+ * Driver for the LCD display on the Tensilica XTFPGA board family.</span>
<span class="p_add">+ * http://www.mytechcorp.com/cfdata/productFile/File1/MOC-16216B-B-A0A04.pdf</span>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file &quot;COPYING&quot; in the main directory of this archive
  * for more details.
  *
  * Copyright (C) 2001, 2006 Tensilica Inc.
<span class="p_add">+ * Copyright (C) 2015 Cadence Design Systems Inc.</span>
  */
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * FIXME: this code is from the examples from the LX60 user guide.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The lcd_pause function does busy waiting, which is probably not</span>
<span class="p_del">- * great. Maybe the code could be changed to use kernel timers, or</span>
<span class="p_del">- * change the hardware to not need to wait.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/io.h&gt;
 
 #include &lt;platform/hardware.h&gt;
 #include &lt;platform/lcd.h&gt;
<span class="p_del">-#include &lt;linux/delay.h&gt;</span>
 
<span class="p_del">-#define LCD_PAUSE_ITERATIONS	4000</span>
<span class="p_add">+/* LCD instruction and data addresses. */</span>
<span class="p_add">+#define LCD_INSTR_ADDR		((char *)IOADDR(CONFIG_XTFPGA_LCD_BASE_ADDR))</span>
<span class="p_add">+#define LCD_DATA_ADDR		(LCD_INSTR_ADDR + 4)</span>
<span class="p_add">+</span>
 #define LCD_CLEAR		0x1
 #define LCD_DISPLAY_ON		0xc
 
 /* 8bit and 2 lines display */
 #define LCD_DISPLAY_MODE8BIT	0x38
<span class="p_add">+#define LCD_DISPLAY_MODE4BIT	0x28</span>
 #define LCD_DISPLAY_POS		0x80
 #define LCD_SHIFT_LEFT		0x18
 #define LCD_SHIFT_RIGHT		0x1c
 
<span class="p_add">+static void lcd_put_byte(u8 *addr, u8 data)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data &amp; 0xf0;</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = (data &lt;&lt; 4) &amp; 0xf0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init lcd_init(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	mdelay(5);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	udelay(200);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+#ifndef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE4BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_MODE4BIT);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_ON;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_ON);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_CLEAR;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_CLEAR);</span>
 	mdelay(10);
 	lcd_disp_at_pos(&quot;XTENSA LINUX&quot;, 0);
 	return 0;
<span class="p_chunk">@@ -52,10 +65,10 @@</span> <span class="p_context"> static int __init lcd_init(void)</span>
 
 void lcd_disp_at_pos(char *str, unsigned char pos)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_POS | pos;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_POS | pos);</span>
 	udelay(100);
 	while (*str != 0) {
<span class="p_del">-		*LCD_DATA_ADDR = *str;</span>
<span class="p_add">+		lcd_put_byte(LCD_DATA_ADDR, *str);</span>
 		udelay(200);
 		str++;
 	}
<span class="p_chunk">@@ -63,13 +76,13 @@</span> <span class="p_context"> void lcd_disp_at_pos(char *str, unsigned char pos)</span>
 
 void lcd_shiftleft(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_LEFT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_LEFT);</span>
 	udelay(50);
 }
 
 void lcd_shiftright(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_RIGHT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_RIGHT);</span>
 	udelay(50);
 }
 
<span class="p_header">diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">index 755b90c40ddf..c0b39f304ea3 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_chunk">@@ -346,7 +346,6 @@</span> <span class="p_context"> acpi_tb_install_standard_table(acpi_physical_address address,</span>
 				 */
 				acpi_tb_uninstall_table(&amp;new_table_desc);
 				*table_index = i;
<span class="p_del">-				(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);</span>
 				return_ACPI_STATUS(AE_OK);
 			}
 		}
<span class="p_header">diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c</span>
<span class="p_header">index 17f9ec501972..fd8496a92b45 100644</span>
<span class="p_header">--- a/drivers/acpi/processor_idle.c</span>
<span class="p_header">+++ b/drivers/acpi/processor_idle.c</span>
<span class="p_chunk">@@ -962,7 +962,7 @@</span> <span class="p_context"> static int acpi_processor_setup_cpuidle_states(struct acpi_processor *pr)</span>
 		return -EINVAL;
 
 	drv-&gt;safe_state_index = -1;
<span class="p_del">-	for (i = 0; i &lt; CPUIDLE_STATE_MAX; i++) {</span>
<span class="p_add">+	for (i = CPUIDLE_DRIVER_STATE_START; i &lt; CPUIDLE_STATE_MAX; i++) {</span>
 		drv-&gt;states[i].name[0] = &#39;\0&#39;;
 		drv-&gt;states[i].desc[0] = &#39;\0&#39;;
 	}
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index f002835894c1..3d0924ed0b46 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -214,7 +214,11 @@</span> <span class="p_context"> bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)</span>
 	struct acpi_device_physical_node *pn;
 	bool offline = true;
 
<span class="p_del">-	mutex_lock(&amp;adev-&gt;physical_node_lock);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * acpi_container_offline() calls this for all of the container&#39;s</span>
<span class="p_add">+	 * children under the container&#39;s physical_node_lock lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock_nested(&amp;adev-&gt;physical_node_lock, SINGLE_DEPTH_NESTING);</span>
 
 	list_for_each_entry(pn, &amp;adev-&gt;physical_node_list, node)
 		if (device_supports_offline(pn-&gt;dev) &amp;&amp; !pn-&gt;dev-&gt;offline) {
<span class="p_header">diff --git a/drivers/base/bus.c b/drivers/base/bus.c</span>
<span class="p_header">index 876bae5ade33..79bc203f51ef 100644</span>
<span class="p_header">--- a/drivers/base/bus.c</span>
<span class="p_header">+++ b/drivers/base/bus.c</span>
<span class="p_chunk">@@ -515,11 +515,11 @@</span> <span class="p_context"> int bus_add_device(struct device *dev)</span>
 			goto out_put;
 		error = device_add_groups(dev, bus-&gt;dev_groups);
 		if (error)
<span class="p_del">-			goto out_groups;</span>
<span class="p_add">+			goto out_id;</span>
 		error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,
 						&amp;dev-&gt;kobj, dev_name(dev));
 		if (error)
<span class="p_del">-			goto out_id;</span>
<span class="p_add">+			goto out_groups;</span>
 		error = sysfs_create_link(&amp;dev-&gt;kobj,
 				&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, &quot;subsystem&quot;);
 		if (error)
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 6f08271c1d99..b526e7c7b109 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	/* Atheros AR3011 with sflash firmware*/
 	{ USB_DEVICE(0x0489, 0xE027) },
 	{ USB_DEVICE(0x0489, 0xE03D) },
<span class="p_add">+	{ USB_DEVICE(0x04F2, 0xAFF1) },</span>
 	{ USB_DEVICE(0x0930, 0x0215) },
 	{ USB_DEVICE(0x0CF3, 0x3002) },
 	{ USB_DEVICE(0x0CF3, 0xE019) },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 35b8e75eb6fb..ae854bab7dfa 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -155,6 +155,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	/* Atheros 3011 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0489, 0xe03d), .driver_info = BTUSB_IGNORE },
<span class="p_add">+	{ USB_DEVICE(0x04f2, 0xaff1), .driver_info = BTUSB_IGNORE },</span>
 	{ USB_DEVICE(0x0930, 0x0215), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0x3002), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0xe019), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/clk/at91/clk-usb.c b/drivers/clk/at91/clk-usb.c</span>
<span class="p_header">index 7d1d26a4bd04..03fda404bb96 100644</span>
<span class="p_header">--- a/drivers/clk/at91/clk-usb.c</span>
<span class="p_header">+++ b/drivers/clk/at91/clk-usb.c</span>
<span class="p_chunk">@@ -52,29 +52,26 @@</span> <span class="p_context"> static unsigned long at91sam9x5_clk_usb_recalc_rate(struct clk_hw *hw,</span>
 
 	tmp = pmc_read(pmc, AT91_PMC_USB);
 	usbdiv = (tmp &amp; AT91_PMC_OHCIUSBDIV) &gt;&gt; SAM9X5_USB_DIV_SHIFT;
<span class="p_del">-	return parent_rate / (usbdiv + 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(parent_rate, (usbdiv + 1));</span>
 }
 
 static long at91sam9x5_clk_usb_round_rate(struct clk_hw *hw, unsigned long rate,
 					  unsigned long *parent_rate)
 {
 	unsigned long div;
<span class="p_del">-	unsigned long bestrate;</span>
<span class="p_del">-	unsigned long tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rate)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (rate &gt;= *parent_rate)
 		return *parent_rate;
 
<span class="p_del">-	div = *parent_rate / rate;</span>
<span class="p_del">-	if (div &gt;= SAM9X5_USB_MAX_DIV)</span>
<span class="p_del">-		return *parent_rate / (SAM9X5_USB_MAX_DIV + 1);</span>
<span class="p_add">+	div = DIV_ROUND_CLOSEST(*parent_rate, rate);</span>
<span class="p_add">+	if (div &gt; SAM9X5_USB_MAX_DIV + 1)</span>
<span class="p_add">+		div = SAM9X5_USB_MAX_DIV + 1;</span>
 
<span class="p_del">-	bestrate = *parent_rate / div;</span>
<span class="p_del">-	tmp = *parent_rate / (div + 1);</span>
<span class="p_del">-	if (bestrate - rate &gt; rate - tmp)</span>
<span class="p_del">-		bestrate = tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	return bestrate;</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(*parent_rate, div);</span>
 }
 
 static int at91sam9x5_clk_usb_set_parent(struct clk_hw *hw, u8 index)
<span class="p_chunk">@@ -106,9 +103,13 @@</span> <span class="p_context"> static int at91sam9x5_clk_usb_set_rate(struct clk_hw *hw, unsigned long rate,</span>
 	u32 tmp;
 	struct at91sam9x5_clk_usb *usb = to_at91sam9x5_clk_usb(hw);
 	struct at91_pmc *pmc = usb-&gt;pmc;
<span class="p_del">-	unsigned long div = parent_rate / rate;</span>
<span class="p_add">+	unsigned long div;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rate)</span>
<span class="p_add">+		return -EINVAL;</span>
 
<span class="p_del">-	if (parent_rate % rate || div &lt; 1 || div &gt;= SAM9X5_USB_MAX_DIV)</span>
<span class="p_add">+	div = DIV_ROUND_CLOSEST(parent_rate, rate);</span>
<span class="p_add">+	if (div &gt; SAM9X5_USB_MAX_DIV + 1 || !div)</span>
 		return -EINVAL;
 
 	tmp = pmc_read(pmc, AT91_PMC_USB) &amp; ~AT91_PMC_OHCIUSBDIV;
<span class="p_header">diff --git a/drivers/clk/qcom/clk-rcg2.c b/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_header">index cd185d5cc67a..9f5e0dfc3699 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_chunk">@@ -253,7 +253,7 @@</span> <span class="p_context"> static int clk_rcg2_configure(struct clk_rcg2 *rcg, const struct freq_tbl *f)</span>
 	mask |= CFG_SRC_SEL_MASK | CFG_MODE_MASK;
 	cfg = f-&gt;pre_div &lt;&lt; CFG_SRC_DIV_SHIFT;
 	cfg |= rcg-&gt;parent_map[f-&gt;src] &lt;&lt; CFG_SRC_SEL_SHIFT;
<span class="p_del">-	if (rcg-&gt;mnd_width &amp;&amp; f-&gt;n)</span>
<span class="p_add">+	if (rcg-&gt;mnd_width &amp;&amp; f-&gt;n &amp;&amp; (f-&gt;m != f-&gt;n))</span>
 		cfg |= CFG_MODE_DUAL_EDGE;
 	ret = regmap_update_bits(rcg-&gt;clkr.regmap,
 			rcg-&gt;cmd_rcgr + CFG_REG, mask, cfg);
<span class="p_header">diff --git a/drivers/clk/tegra/clk.c b/drivers/clk/tegra/clk.c</span>
<span class="p_header">index c0a7d7723510..a90af1780cf2 100644</span>
<span class="p_header">--- a/drivers/clk/tegra/clk.c</span>
<span class="p_header">+++ b/drivers/clk/tegra/clk.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> void __init tegra_add_of_provider(struct device_node *np)</span>
 	of_clk_add_provider(np, of_clk_src_onecell_get, &amp;clk_data);
 
 	rst_ctlr.of_node = np;
<span class="p_del">-	rst_ctlr.nr_resets = clk_num * 32;</span>
<span class="p_add">+	rst_ctlr.nr_resets = periph_banks * 32;</span>
 	reset_controller_register(&amp;rst_ctlr);
 }
 
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c</span>
<span class="p_header">index f1c5e49ece97..1e1b3a894a81 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq.c</span>
<span class="p_chunk">@@ -1725,15 +1725,18 @@</span> <span class="p_context"> void cpufreq_resume(void)</span>
 		    || __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS))
 			pr_err(&quot;%s: Failed to start governor for policy: %p\n&quot;,
 				__func__, policy);
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * schedule call cpufreq_update_policy() for boot CPU, i.e. last</span>
<span class="p_del">-		 * policy in list. It will verify that the current freq is in</span>
<span class="p_del">-		 * sync with what we believe it to be.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (list_is_last(&amp;policy-&gt;policy_list, &amp;cpufreq_policy_list))</span>
<span class="p_del">-			schedule_work(&amp;policy-&gt;update);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * schedule call cpufreq_update_policy() for first-online CPU, as that</span>
<span class="p_add">+	 * wouldn&#39;t be hotplugged-out on suspend. It will verify that the</span>
<span class="p_add">+	 * current freq is in sync with what we believe it to be.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	policy = cpufreq_cpu_get_raw(cpumask_first(cpu_online_mask));</span>
<span class="p_add">+	if (WARN_ON(!policy))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	schedule_work(&amp;policy-&gt;update);</span>
 }
 
 /**
<span class="p_chunk">@@ -2014,6 +2017,12 @@</span> <span class="p_context"> static int __cpufreq_governor(struct cpufreq_policy *policy,</span>
 	/* Don&#39;t start any governor operations if we are entering suspend */
 	if (cpufreq_suspended)
 		return 0;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Governor might not be initiated here if ACPI _PPC changed</span>
<span class="p_add">+	 * notification happened, so check it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!policy-&gt;governor)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (policy-&gt;governor-&gt;max_transition_latency &amp;&amp;
 	    policy-&gt;cpuinfo.transition_latency &gt;
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">index cb7019977c50..d3185606473a 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle.c</span>
<span class="p_chunk">@@ -289,9 +289,6 @@</span> <span class="p_context"> int cpuidle_enable_device(struct cpuidle_device *dev)</span>
 	if (!dev-&gt;registered)
 		return -EINVAL;
 
<span class="p_del">-	if (!dev-&gt;state_count)</span>
<span class="p_del">-		dev-&gt;state_count = drv-&gt;state_count;</span>
<span class="p_del">-</span>
 	ret = cpuidle_add_device_sysfs(dev);
 	if (ret)
 		return ret;
<span class="p_header">diff --git a/drivers/cpuidle/sysfs.c b/drivers/cpuidle/sysfs.c</span>
<span class="p_header">index efe2f175168f..3368c50ef0ea 100644</span>
<span class="p_header">--- a/drivers/cpuidle/sysfs.c</span>
<span class="p_header">+++ b/drivers/cpuidle/sysfs.c</span>
<span class="p_chunk">@@ -401,7 +401,7 @@</span> <span class="p_context"> static int cpuidle_add_state_sysfs(struct cpuidle_device *device)</span>
 	struct cpuidle_driver *drv = cpuidle_get_cpu_driver(device);
 
 	/* state statistics */
<span class="p_del">-	for (i = 0; i &lt; device-&gt;state_count; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; drv-&gt;state_count; i++) {</span>
 		kobj = kzalloc(sizeof(struct cpuidle_state_kobj), GFP_KERNEL);
 		if (!kobj)
 			goto error_state;
<span class="p_chunk">@@ -433,9 +433,10 @@</span> <span class="p_context"> error_state:</span>
  */
 static void cpuidle_remove_state_sysfs(struct cpuidle_device *device)
 {
<span class="p_add">+	struct cpuidle_driver *drv = cpuidle_get_cpu_driver(device);</span>
 	int i;
 
<span class="p_del">-	for (i = 0; i &lt; device-&gt;state_count; i++)</span>
<span class="p_add">+	for (i = 0; i &lt; drv-&gt;state_count; i++)</span>
 		cpuidle_free_state_kobj(device, i);
 }
 
<span class="p_header">diff --git a/drivers/crypto/omap-aes.c b/drivers/crypto/omap-aes.c</span>
<span class="p_header">index cb98fa54573d..f7826ee3754b 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-aes.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-aes.c</span>
<span class="p_chunk">@@ -554,15 +554,23 @@</span> <span class="p_context"> static int omap_aes_crypt_dma_stop(struct omap_aes_dev *dd)</span>
 	return err;
 }
 
<span class="p_del">-static int omap_aes_check_aligned(struct scatterlist *sg)</span>
<span class="p_add">+static int omap_aes_check_aligned(struct scatterlist *sg, int total)</span>
 {
<span class="p_add">+	int len = 0;</span>
<span class="p_add">+</span>
 	while (sg) {
 		if (!IS_ALIGNED(sg-&gt;offset, 4))
 			return -1;
 		if (!IS_ALIGNED(sg-&gt;length, AES_BLOCK_SIZE))
 			return -1;
<span class="p_add">+</span>
<span class="p_add">+		len += sg-&gt;length;</span>
 		sg = sg_next(sg);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (len != total)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -633,8 +641,8 @@</span> <span class="p_context"> static int omap_aes_handle_queue(struct omap_aes_dev *dd,</span>
 	dd-&gt;in_sg = req-&gt;src;
 	dd-&gt;out_sg = req-&gt;dst;
 
<span class="p_del">-	if (omap_aes_check_aligned(dd-&gt;in_sg) ||</span>
<span class="p_del">-	    omap_aes_check_aligned(dd-&gt;out_sg)) {</span>
<span class="p_add">+	if (omap_aes_check_aligned(dd-&gt;in_sg, dd-&gt;total) ||</span>
<span class="p_add">+	    omap_aes_check_aligned(dd-&gt;out_sg, dd-&gt;total)) {</span>
 		if (omap_aes_copy_sgs(dd))
 			pr_err(&quot;Failed to copy SGs for unaligned cases\n&quot;);
 		dd-&gt;sgs_copied = 1;
<span class="p_header">diff --git a/drivers/gpio/gpio-mvebu.c b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">index 418e38650363..a93ddbc1948e 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_chunk">@@ -305,11 +305,13 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_mask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache &amp;= ~mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_edge_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv &amp;= ~mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -317,11 +319,13 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_unmask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache |= mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_edge_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv |= mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -329,11 +333,13 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_mask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache &amp;= ~mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_level_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv &amp;= ~mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -341,11 +347,13 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_unmask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache |= mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_level_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv |= mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">index e35e32f33e31..17d375344f46 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_chunk">@@ -1018,7 +1018,7 @@</span> <span class="p_context"> static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)</span>
 		s-&gt;lra_limits[i] = I915_READ(GEN7_LRA_LIMITS_BASE + i * 4);
 
 	s-&gt;media_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);
<span class="p_del">-	s-&gt;gfx_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);</span>
<span class="p_add">+	s-&gt;gfx_max_req_count	= I915_READ(GEN7_GFX_MAX_REQ_COUNT);</span>
 
 	s-&gt;render_hwsp		= I915_READ(RENDER_HWS_PGA_GEN7);
 	s-&gt;ecochk		= I915_READ(GAM_ECOCHK);
<span class="p_chunk">@@ -1071,6 +1071,7 @@</span> <span class="p_context"> static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)</span>
 	/* Gunit-Display CZ domain, 0x182028-0x1821CF */
 	s-&gt;gu_ctl0		= I915_READ(VLV_GU_CTL0);
 	s-&gt;gu_ctl1		= I915_READ(VLV_GU_CTL1);
<span class="p_add">+	s-&gt;pcbr			= I915_READ(VLV_PCBR);</span>
 	s-&gt;clock_gate_dis2	= I915_READ(VLV_GUNIT_CLOCK_GATE2);
 
 	/*
<span class="p_chunk">@@ -1099,7 +1100,7 @@</span> <span class="p_context"> static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)</span>
 		I915_WRITE(GEN7_LRA_LIMITS_BASE + i * 4, s-&gt;lra_limits[i]);
 
 	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s-&gt;media_max_req_count);
<span class="p_del">-	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s-&gt;gfx_max_req_count);</span>
<span class="p_add">+	I915_WRITE(GEN7_GFX_MAX_REQ_COUNT, s-&gt;gfx_max_req_count);</span>
 
 	I915_WRITE(RENDER_HWS_PGA_GEN7,	s-&gt;render_hwsp);
 	I915_WRITE(GAM_ECOCHK,		s-&gt;ecochk);
<span class="p_chunk">@@ -1165,6 +1166,7 @@</span> <span class="p_context"> static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)</span>
 	/* Gunit-Display CZ domain, 0x182028-0x1821CF */
 	I915_WRITE(VLV_GU_CTL0,			s-&gt;gu_ctl0);
 	I915_WRITE(VLV_GU_CTL1,			s-&gt;gu_ctl1);
<span class="p_add">+	I915_WRITE(VLV_PCBR,			s-&gt;pcbr);</span>
 	I915_WRITE(VLV_GUNIT_CLOCK_GATE2,	s-&gt;clock_gate_dis2);
 }
 
<span class="p_chunk">@@ -1173,19 +1175,7 @@</span> <span class="p_context"> int vlv_force_gfx_clock(struct drm_i915_private *dev_priv, bool force_on)</span>
 	u32 val;
 	int err;
 
<span class="p_del">-	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);</span>
<span class="p_del">-	WARN_ON(!!(val &amp; VLV_GFX_CLK_FORCE_ON_BIT) == force_on);</span>
<span class="p_del">-</span>
 #define COND (I915_READ(VLV_GTLC_SURVIVABILITY_REG) &amp; VLV_GFX_CLK_STATUS_BIT)
<span class="p_del">-	/* Wait for a previous force-off to settle */</span>
<span class="p_del">-	if (force_on) {</span>
<span class="p_del">-		err = wait_for(!COND, 20);</span>
<span class="p_del">-		if (err) {</span>
<span class="p_del">-			DRM_ERROR(&quot;timeout waiting for GFX clock force-off (%08x)\n&quot;,</span>
<span class="p_del">-				  I915_READ(VLV_GTLC_SURVIVABILITY_REG));</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
 
 	val = I915_READ(VLV_GTLC_SURVIVABILITY_REG);
 	val &amp;= ~VLV_GFX_CLK_FORCE_ON_BIT;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index 09501070d7cd..28c7afdfffbc 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -878,6 +878,7 @@</span> <span class="p_context"> struct vlv_s0ix_state {</span>
 	/* Display 2 CZ domain */
 	u32 gu_ctl0;
 	u32 gu_ctl1;
<span class="p_add">+	u32 pcbr;</span>
 	u32 clock_gate_dis2;
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">index 085cb5645e66..a736b4af46f1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_chunk">@@ -3687,14 +3687,12 @@</span> <span class="p_context"> static int i8xx_irq_postinstall(struct drm_device *dev)</span>
 		~(I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
 		  I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
<span class="p_del">-		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |</span>
<span class="p_del">-		  I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);</span>
<span class="p_add">+		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT);</span>
 	I915_WRITE16(IMR, dev_priv-&gt;irq_mask);
 
 	I915_WRITE16(IER,
 		     I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		     I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
<span class="p_del">-		     I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT |</span>
 		     I915_USER_INTERRUPT);
 	POSTING_READ16(IER);
 
<span class="p_chunk">@@ -3856,14 +3854,12 @@</span> <span class="p_context"> static int i915_irq_postinstall(struct drm_device *dev)</span>
 		  I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
 		  I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
<span class="p_del">-		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |</span>
<span class="p_del">-		  I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);</span>
<span class="p_add">+		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT);</span>
 
 	enable_mask =
 		I915_ASLE_INTERRUPT |
 		I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
<span class="p_del">-		I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT |</span>
 		I915_USER_INTERRUPT;
 
 	if (I915_HAS_HOTPLUG(dev)) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index 37dacd14c208..dda970cb01c1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -1551,6 +1551,7 @@</span> <span class="p_context"> enum punit_power_well {</span>
 #define   GMBUS_CYCLE_INDEX	(2&lt;&lt;25)
 #define   GMBUS_CYCLE_STOP	(4&lt;&lt;25)
 #define   GMBUS_BYTE_COUNT_SHIFT 16
<span class="p_add">+#define   GMBUS_BYTE_COUNT_MAX   256U</span>
 #define   GMBUS_SLAVE_INDEX_SHIFT 8
 #define   GMBUS_SLAVE_ADDR_SHIFT 1
 #define   GMBUS_SLAVE_READ	(1&lt;&lt;0)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">index d33b61d0dd33..1d02970ed395 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_chunk">@@ -324,18 +324,17 @@</span> <span class="p_context"> gmbus_wait_idle(struct drm_i915_private *dev_priv)</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_del">-		u32 gmbus1_index)</span>
<span class="p_add">+gmbus_xfer_read_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		      unsigned short addr, u8 *buf, unsigned int len,</span>
<span class="p_add">+		      u32 gmbus1_index)</span>
 {
 	int reg_offset = dev_priv-&gt;gpio_mmio_base;
<span class="p_del">-	u16 len = msg-&gt;len;</span>
<span class="p_del">-	u8 *buf = msg-&gt;buf;</span>
 
 	I915_WRITE(GMBUS1 + reg_offset,
 		   gmbus1_index |
 		   GMBUS_CYCLE_WAIT |
 		   (len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_READ | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -357,11 +356,35 @@</span> <span class="p_context"> gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_add">+		u32 gmbus1_index)</span>
 {
<span class="p_del">-	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_del">-	u16 len = msg-&gt;len;</span>
 	u8 *buf = msg-&gt;buf;
<span class="p_add">+	unsigned int rx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(rx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_read_chunk(dev_priv, msg-&gt;addr,</span>
<span class="p_add">+					    buf, len, gmbus1_index);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		rx_size -= len;</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+	} while (rx_size != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		       unsigned short addr, u8 *buf, unsigned int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_add">+	unsigned int chunk_size = len;</span>
 	u32 val, loop;
 
 	val = loop = 0;
<span class="p_chunk">@@ -373,8 +396,8 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 	I915_WRITE(GMBUS3 + reg_offset, val);
 	I915_WRITE(GMBUS1 + reg_offset,
 		   GMBUS_CYCLE_WAIT |
<span class="p_del">-		   (msg-&gt;len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (chunk_size &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_WRITE | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -391,6 +414,29 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 		if (ret)
 			return ret;
 	}
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *buf = msg-&gt;buf;</span>
<span class="p_add">+	unsigned int tx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(tx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_write_chunk(dev_priv, msg-&gt;addr, buf, len);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+		tx_size -= len;</span>
<span class="p_add">+	} while (tx_size != 0);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 9f0e62529c46..ce8cab52285b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -330,8 +330,10 @@</span> <span class="p_context"> atombios_set_crtc_dtd_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_chunk">@@ -374,8 +376,10 @@</span> <span class="p_context"> static void atombios_crtc_set_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index 51a4d9bbbc9d..e9aad0c8f2f7 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -454,6 +454,10 @@</span> <span class="p_context"></span>
 #define USB_DEVICE_ID_UGCI_FLYING	0x0020
 #define USB_DEVICE_ID_UGCI_FIGHTING	0x0030
 
<span class="p_add">+#define USB_VENDOR_ID_HP		0x03f0</span>
<span class="p_add">+#define USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE	0x0a4a</span>
<span class="p_add">+#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE		0x134a</span>
<span class="p_add">+</span>
 #define USB_VENDOR_ID_HUION		0x256c
 #define USB_DEVICE_ID_HUION_580		0x006e
 
<span class="p_chunk">@@ -575,6 +579,7 @@</span> <span class="p_context"></span>
 
 #define USB_VENDOR_ID_LOGITECH		0x046d
 #define USB_DEVICE_ID_LOGITECH_AUDIOHUB 0x0a0e
<span class="p_add">+#define USB_DEVICE_ID_LOGITECH_C077	0xc007</span>
 #define USB_DEVICE_ID_LOGITECH_RECEIVER	0xc101
 #define USB_DEVICE_ID_LOGITECH_HARMONY_FIRST  0xc110
 #define USB_DEVICE_ID_LOGITECH_HARMONY_LAST 0xc14f
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">index 913c9e0d2963..ba05afc22eb5 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_chunk">@@ -78,6 +78,9 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 	{ USB_VENDOR_ID_ELO, USB_DEVICE_ID_ELO_TS2700, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_FORMOSA, USB_DEVICE_ID_FORMOSA_IR_RECEIVER, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_FREESCALE, USB_DEVICE_ID_FREESCALE_MX28, HID_QUIRK_NOGET },
<span class="p_add">+	{ USB_VENDOR_ID_HP, USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE, HID_QUIRK_ALWAYS_POLL },</span>
<span class="p_add">+	{ USB_VENDOR_ID_HP, USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE, HID_QUIRK_ALWAYS_POLL },</span>
<span class="p_add">+	{ USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_C077, HID_QUIRK_ALWAYS_POLL },</span>
 	{ USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3_JP, HID_QUIRK_NO_INIT_REPORTS },
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index bec55ed2917a..1e951c507c0d 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 			   GFP_KERNEL);
 	if (!open_info) {
 		err = -ENOMEM;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	init_completion(&amp;open_info-&gt;waitevent);
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 
 	if (userdatalen &gt; MAX_USER_DEFINED_BYTES) {
 		err = -EINVAL;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	if (userdatalen)
<span class="p_chunk">@@ -195,6 +195,9 @@</span> <span class="p_context"> error1:</span>
 	list_del(&amp;open_info-&gt;msglistentry);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
<span class="p_add">+error_gpadl:</span>
<span class="p_add">+	vmbus_teardown_gpadl(newchannel, newchannel-&gt;ringbuffer_gpadlhandle);</span>
<span class="p_add">+</span>
 error0:
 	free_pages((unsigned long)out,
 		get_order(send_ringbuffer_size + recv_ringbuffer_size));
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index 75330b3e388e..10953ece3307 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -758,7 +758,7 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 {
 	struct vmbus_channel_message_header *msg;
 	struct vmbus_channel_msginfo *msginfo;
<span class="p_del">-	int ret, t;</span>
<span class="p_add">+	int ret;</span>
 
 	msginfo = kmalloc(sizeof(*msginfo) +
 			  sizeof(struct vmbus_channel_message_header),
<span class="p_chunk">@@ -766,8 +766,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 	if (!msginfo)
 		return -ENOMEM;
 
<span class="p_del">-	init_completion(&amp;msginfo-&gt;waitevent);</span>
<span class="p_del">-</span>
 	msg = (struct vmbus_channel_message_header *)msginfo-&gt;msg;
 
 	msg-&gt;msgtype = CHANNELMSG_REQUESTOFFERS;
<span class="p_chunk">@@ -781,14 +779,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 		goto cleanup;
 	}
 
<span class="p_del">-	t = wait_for_completion_timeout(&amp;msginfo-&gt;waitevent, 5*HZ);</span>
<span class="p_del">-	if (t == 0) {</span>
<span class="p_del">-		ret = -ETIMEDOUT;</span>
<span class="p_del">-		goto cleanup;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 cleanup:
 	kfree(msginfo);
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-rk3x.c b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">index b38b0529946a..f8e9a8b06d88 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_chunk">@@ -588,7 +588,7 @@</span> <span class="p_context"> static int rk3x_i2c_xfer(struct i2c_adapter *adap,</span>
 	clk_disable(i2c-&gt;clk);
 	spin_unlock_irqrestore(&amp;i2c-&gt;lock, flags);
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return ret &lt; 0 ? ret : num;</span>
 }
 
 static u32 rk3x_i2c_func(struct i2c_adapter *adap)
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index 7c7f4b856bad..4d835fbeba44 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -232,6 +232,7 @@</span> <span class="p_context"> int i2c_generic_scl_recovery(struct i2c_adapter *adap)</span>
 	adap-&gt;bus_recovery_info-&gt;set_scl(adap, 1);
 	return i2c_generic_recovery(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_scl_recovery);</span>
 
 int i2c_generic_gpio_recovery(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -246,6 +247,7 @@</span> <span class="p_context"> int i2c_generic_gpio_recovery(struct i2c_adapter *adap)</span>
 
 	return ret;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_gpio_recovery);</span>
 
 int i2c_recover_bus(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -255,6 +257,7 @@</span> <span class="p_context"> int i2c_recover_bus(struct i2c_adapter *adap)</span>
 	dev_dbg(&amp;adap-&gt;dev, &quot;Trying i2c bus recovery\n&quot;);
 	return adap-&gt;bus_recovery_info-&gt;recover_bus(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_recover_bus);</span>
 
 static int i2c_device_probe(struct device *dev)
 {
<span class="p_chunk">@@ -1249,6 +1252,8 @@</span> <span class="p_context"> static int i2c_register_adapter(struct i2c_adapter *adap)</span>
 
 	dev_dbg(&amp;adap-&gt;dev, &quot;adapter [%s] registered\n&quot;, adap-&gt;name);
 
<span class="p_add">+	pm_runtime_no_callbacks(&amp;adap-&gt;dev);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_I2C_COMPAT
 	res = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,
 				       adap-&gt;dev.parent);
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index 0b2584dbeba0..c9fed8f2e070 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -94,12 +94,15 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &amp;attrs);
 
<span class="p_add">+	if (!size)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	/*
 	 * If the combination of the addr and size requested for this memory
 	 * region causes an integer overflow, return error.
 	 */
<span class="p_del">-	if ((PAGE_ALIGN(addr + size) &lt;= size) ||</span>
<span class="p_del">-	    (PAGE_ALIGN(addr + size) &lt;= addr))</span>
<span class="p_add">+	if (((addr + size) &lt; addr) ||</span>
<span class="p_add">+	    PAGE_ALIGN(addr + size) &lt; (addr + size))</span>
 		return ERR_PTR(-EINVAL);
 
 	if (!can_do_mlock())
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 67780452f0cf..6914462e4b5b 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -2535,8 +2535,7 @@</span> <span class="p_context"> static int build_lso_seg(struct mlx4_wqe_lso_seg *wqe, struct ib_send_wr *wr,</span>
 
 	memcpy(wqe-&gt;header, wr-&gt;wr.ud.header, wr-&gt;wr.ud.hlen);
 
<span class="p_del">-	*lso_hdr_sz  = cpu_to_be32((wr-&gt;wr.ud.mss - wr-&gt;wr.ud.hlen) &lt;&lt; 16 |</span>
<span class="p_del">-				   wr-&gt;wr.ud.hlen);</span>
<span class="p_add">+	*lso_hdr_sz  = cpu_to_be32(wr-&gt;wr.ud.mss &lt;&lt; 16 | wr-&gt;wr.ud.hlen);</span>
 	*lso_seg_len = halign;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c</span>
<span class="p_header">index 73c4ca8d2458..5a406f979be4 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iser_initiator.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iser_initiator.c</span>
<span class="p_chunk">@@ -402,8 +402,8 @@</span> <span class="p_context"> int iser_send_command(struct iscsi_conn *conn,</span>
 	if (scsi_prot_sg_count(sc)) {
 		prot_buf-&gt;buf  = scsi_prot_sglist(sc);
 		prot_buf-&gt;size = scsi_prot_sg_count(sc);
<span class="p_del">-		prot_buf-&gt;data_len = data_buf-&gt;data_len &gt;&gt;</span>
<span class="p_del">-				     ilog2(sc-&gt;device-&gt;sector_size) * 8;</span>
<span class="p_add">+		prot_buf-&gt;data_len = (data_buf-&gt;data_len &gt;&gt;</span>
<span class="p_add">+				     ilog2(sc-&gt;device-&gt;sector_size)) * 8;</span>
 	}
 
 	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ) {
<span class="p_header">diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">index 3a36b8bbca33..31939ba1d238 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_chunk">@@ -218,7 +218,7 @@</span> <span class="p_context"> fail:</span>
 static void
 isert_free_rx_descriptors(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
<span class="p_add">+	struct ib_device *ib_dev = isert_conn-&gt;conn_device-&gt;ib_device;</span>
 	struct iser_rx_desc *rx_desc;
 	int i;
 
<span class="p_chunk">@@ -737,8 +737,8 @@</span> <span class="p_context"> out:</span>
 static void
 isert_connect_release(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
 	struct isert_device *device = isert_conn-&gt;conn_device;
<span class="p_add">+	struct ib_device *ib_dev = device-&gt;ib_device;</span>
 	int cq_index;
 
 	pr_debug(&quot;Entering isert_connect_release(): &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;);
<span class="p_chunk">@@ -747,7 +747,8 @@</span> <span class="p_context"> isert_connect_release(struct isert_conn *isert_conn)</span>
 		isert_conn_free_fastreg_pool(isert_conn);
 
 	isert_free_rx_descriptors(isert_conn);
<span class="p_del">-	rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
<span class="p_add">+	if (isert_conn-&gt;conn_cm_id)</span>
<span class="p_add">+		rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
 
 	if (isert_conn-&gt;conn_qp) {
 		cq_index = ((struct isert_cq_desc *)
<span class="p_chunk">@@ -905,12 +906,15 @@</span> <span class="p_context"> isert_disconnected_handler(struct rdma_cm_id *cma_id,</span>
 	return 0;
 }
 
<span class="p_del">-static void</span>
<span class="p_add">+static int</span>
 isert_connect_error(struct rdma_cm_id *cma_id)
 {
 	struct isert_conn *isert_conn = cma_id-&gt;qp-&gt;qp_context;
 
<span class="p_add">+	isert_conn-&gt;conn_cm_id = NULL;</span>
 	isert_put_conn(isert_conn);
<span class="p_add">+</span>
<span class="p_add">+	return -1;</span>
 }
 
 static int
<span class="p_chunk">@@ -940,7 +944,7 @@</span> <span class="p_context"> isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)</span>
 	case RDMA_CM_EVENT_REJECTED:       /* FALLTHRU */
 	case RDMA_CM_EVENT_UNREACHABLE:    /* FALLTHRU */
 	case RDMA_CM_EVENT_CONNECT_ERROR:
<span class="p_del">-		isert_connect_error(cma_id);</span>
<span class="p_add">+		ret = isert_connect_error(cma_id);</span>
 		break;
 	default:
 		pr_err(&quot;Unhandled RDMA CMA event: %d\n&quot;, event-&gt;event);
<span class="p_chunk">@@ -1898,11 +1902,13 @@</span> <span class="p_context"> isert_completion_rdma_read(struct iser_tx_desc *tx_desc,</span>
 	cmd-&gt;i_state = ISTATE_RECEIVED_LAST_DATAOUT;
 	spin_unlock_bh(&amp;cmd-&gt;istate_lock);
 
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		target_put_sess_cmd(se_cmd-&gt;se_sess, se_cmd);</span>
 		transport_send_check_condition_and_sense(se_cmd,
 							 se_cmd-&gt;pi_err, 0);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		target_execute_cmd(se_cmd);
<span class="p_add">+	}</span>
 }
 
 static void
<span class="p_header">diff --git a/drivers/input/misc/twl4030-pwrbutton.c b/drivers/input/misc/twl4030-pwrbutton.c</span>
<span class="p_header">index fb3b63b2f85c..8400a1a34d87 100644</span>
<span class="p_header">--- a/drivers/input/misc/twl4030-pwrbutton.c</span>
<span class="p_header">+++ b/drivers/input/misc/twl4030-pwrbutton.c</span>
<span class="p_chunk">@@ -85,6 +85,7 @@</span> <span class="p_context"> static int twl4030_pwrbutton_probe(struct platform_device *pdev)</span>
 	}
 
 	platform_set_drvdata(pdev, pwr);
<span class="p_add">+	device_init_wakeup(&amp;pdev-&gt;dev, true);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index e66780e35962..b865f55e4b62 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -814,6 +814,21 @@</span> <span class="p_context"> static psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)</span>
 }
 
 /*
<span class="p_add">+ * This writes the reg_07 value again to the hardware at the end of every</span>
<span class="p_add">+ * set_rate call because the register loses its value. reg_07 allows setting</span>
<span class="p_add">+ * absolute mode on v4 hardware</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,</span>
<span class="p_add">+		unsigned int rate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct elantech_data *etd = psmouse-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	etd-&gt;original_set_rate(psmouse, rate);</span>
<span class="p_add">+	if (elantech_write_reg(psmouse, 0x07, etd-&gt;reg_07))</span>
<span class="p_add">+		psmouse_err(psmouse, &quot;restoring reg_07 failed\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Put the touchpad into absolute mode
  */
 static int elantech_set_absolute_mode(struct psmouse *psmouse)
<span class="p_chunk">@@ -1015,9 +1030,13 @@</span> <span class="p_context"> static int elantech_get_resolution_v4(struct psmouse *psmouse,</span>
  * Asus K53SV              0x450f01        78, 15, 0c      2 hw buttons
  * Asus G46VW              0x460f02        00, 18, 0c      2 hw buttons
  * Asus G750JX             0x360f00        00, 16, 0c      2 hw buttons
<span class="p_add">+ * Asus TP500LN            0x381f17        10, 14, 0e      clickpad</span>
<span class="p_add">+ * Asus X750JN             0x381f17        10, 14, 0e      clickpad</span>
  * Asus UX31               0x361f00        20, 15, 0e      clickpad
  * Asus UX32VD             0x361f02        00, 15, 0e      clickpad
  * Avatar AVIU-145A2       0x361f00        ?               clickpad
<span class="p_add">+ * Fujitsu LIFEBOOK E544   0x470f00        d0, 12, 09      2 hw buttons</span>
<span class="p_add">+ * Fujitsu LIFEBOOK E554   0x570f01        40, 14, 0c      2 hw buttons</span>
  * Gigabyte U2442          0x450f01        58, 17, 0c      2 hw buttons
  * Lenovo L430             0x350f02        b9, 15, 0c      2 hw buttons (*)
  * Samsung NF210           0x150b00        78, 14, 0a      2 hw buttons
<span class="p_chunk">@@ -1357,6 +1376,36 @@</span> <span class="p_context"> static int elantech_reconnect(struct psmouse *psmouse)</span>
 }
 
 /*
<span class="p_add">+ * Some hw_version 4 models do not work with crc_disabled</span>
<span class="p_add">+ */</span>
<span class="p_add">+static const struct dmi_system_id elantech_dmi_force_crc_enabled[] = {</span>
<span class="p_add">+#if defined(CONFIG_DMI) &amp;&amp; defined(CONFIG_X86)</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Fujitsu H730 does not work with crc_enabled == 0 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;CELSIUS H730&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Fujitsu LIFEBOOK E554  does not work with crc_enabled == 0 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E554&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Fujitsu LIFEBOOK E544  does not work with crc_enabled == 0 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E544&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Some hw_version 3 models go into error state when we try to set
  * bit 3 and/or bit 1 of r10.
  */
<span class="p_chunk">@@ -1433,7 +1482,8 @@</span> <span class="p_context"> static int elantech_set_properties(struct elantech_data *etd)</span>
 	 * The signatures of v3 and v4 packets change depending on the
 	 * value of this hardware flag.
 	 */
<span class="p_del">-	etd-&gt;crc_enabled = ((etd-&gt;fw_version &amp; 0x4000) == 0x4000);</span>
<span class="p_add">+	etd-&gt;crc_enabled = (etd-&gt;fw_version &amp; 0x4000) == 0x4000 ||</span>
<span class="p_add">+			   dmi_check_system(elantech_dmi_force_crc_enabled);</span>
 
 	/* Enable real hardware resolution on hw_version 3 ? */
 	etd-&gt;set_hw_resolution = !dmi_check_system(no_hw_res_dmi_table);
<span class="p_chunk">@@ -1493,6 +1543,11 @@</span> <span class="p_context"> int elantech_init(struct psmouse *psmouse)</span>
 		goto init_fail;
 	}
 
<span class="p_add">+	if (etd-&gt;fw_version == 0x381f17) {</span>
<span class="p_add">+		etd-&gt;original_set_rate = psmouse-&gt;set_rate;</span>
<span class="p_add">+		psmouse-&gt;set_rate = elantech_set_rate_restore_reg_07;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (elantech_set_input_params(psmouse)) {
 		psmouse_err(psmouse, &quot;failed to query touchpad range.\n&quot;);
 		goto init_fail;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.h b/drivers/input/mouse/elantech.h</span>
<span class="p_header">index 9e0e2a1f340d..59263a3a8667 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.h</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.h</span>
<span class="p_chunk">@@ -139,6 +139,7 @@</span> <span class="p_context"> struct elantech_data {</span>
 	struct finger_pos mt[ETP_MAX_FINGERS];
 	unsigned char parity[256];
 	int (*send_cmd)(struct psmouse *psmouse, unsigned char c, unsigned char *param);
<span class="p_add">+	void (*original_set_rate)(struct psmouse *psmouse, unsigned int rate);</span>
 };
 
 #ifdef CONFIG_MOUSE_PS2_ELANTECH
<span class="p_header">diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c</span>
<span class="p_header">index 407a99e46f69..683e685ed697 100644</span>
<span class="p_header">--- a/drivers/md/raid0.c</span>
<span class="p_header">+++ b/drivers/md/raid0.c</span>
<span class="p_chunk">@@ -320,7 +320,7 @@</span> <span class="p_context"> static struct strip_zone *find_zone(struct r0conf *conf,</span>
 
 /*
  * remaps the bio to the target device. we separate two flows.
<span class="p_del">- * power 2 flow and a general flow for the sake of perfromance</span>
<span class="p_add">+ * power 2 flow and a general flow for the sake of performance</span>
 */
 static struct md_rdev *map_sector(struct mddev *mddev, struct strip_zone *zone,
 				sector_t sector, sector_t *sector_offset)
<span class="p_chunk">@@ -538,6 +538,7 @@</span> <span class="p_context"> static void raid0_make_request(struct mddev *mddev, struct bio *bio)</span>
 			split = bio;
 		}
 
<span class="p_add">+		sector = bio-&gt;bi_iter.bi_sector;</span>
 		zone = find_zone(mddev-&gt;private, &amp;sector);
 		tmp_dev = map_sector(mddev, zone, sector, &amp;sector);
 		split-&gt;bi_bdev = tmp_dev-&gt;bdev;
<span class="p_header">diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc_common.h b/drivers/media/platform/s5p-mfc/s5p_mfc_common.h</span>
<span class="p_header">index b04360cd34f0..d45779798d65 100644</span>
<span class="p_header">--- a/drivers/media/platform/s5p-mfc/s5p_mfc_common.h</span>
<span class="p_header">+++ b/drivers/media/platform/s5p-mfc/s5p_mfc_common.h</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
 
 /* Offset base used to differentiate between CAPTURE and OUTPUT
 *  while mmaping */
<span class="p_del">-#define DST_QUEUE_OFF_BASE      (TASK_SIZE / 2)</span>
<span class="p_add">+#define DST_QUEUE_OFF_BASE	(1 &lt;&lt; 30)</span>
 
 #define MFC_BANK1_ALLOC_CTX	0
 #define MFC_BANK2_ALLOC_CTX	1
<span class="p_header">diff --git a/drivers/media/platform/sh_veu.c b/drivers/media/platform/sh_veu.c</span>
<span class="p_header">index 744e43b480bc..f698e322a1cd 100644</span>
<span class="p_header">--- a/drivers/media/platform/sh_veu.c</span>
<span class="p_header">+++ b/drivers/media/platform/sh_veu.c</span>
<span class="p_chunk">@@ -1183,6 +1183,7 @@</span> <span class="p_context"> static int sh_veu_probe(struct platform_device *pdev)</span>
 	}
 
 	*vdev = sh_veu_videodev;
<span class="p_add">+	vdev-&gt;v4l2_dev = &amp;veu-&gt;v4l2_dev;</span>
 	spin_lock_init(&amp;veu-&gt;lock);
 	mutex_init(&amp;veu-&gt;fop_lock);
 	vdev-&gt;lock = &amp;veu-&gt;fop_lock;
<span class="p_header">diff --git a/drivers/media/rc/img-ir/img-ir-core.c b/drivers/media/rc/img-ir/img-ir-core.c</span>
<span class="p_header">index 6b7834834fb8..fbcbf803ba38 100644</span>
<span class="p_header">--- a/drivers/media/rc/img-ir/img-ir-core.c</span>
<span class="p_header">+++ b/drivers/media/rc/img-ir/img-ir-core.c</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> static int img_ir_remove(struct platform_device *pdev)</span>
 {
 	struct img_ir_priv *priv = platform_get_drvdata(pdev);
 
<span class="p_del">-	free_irq(priv-&gt;irq, img_ir_isr);</span>
<span class="p_add">+	free_irq(priv-&gt;irq, priv);</span>
 	img_ir_remove_hw(priv);
 	img_ir_remove_raw(priv);
 
<span class="p_header">diff --git a/drivers/media/usb/stk1160/stk1160-v4l.c b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">index 5461341a31cb..45cf8c265612 100644</span>
<span class="p_header">--- a/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">+++ b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_chunk">@@ -244,6 +244,11 @@</span> <span class="p_context"> static int stk1160_stop_streaming(struct stk1160 *dev)</span>
 	if (mutex_lock_interruptible(&amp;dev-&gt;v4l_lock))
 		return -ERESTARTSYS;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Once URBs are cancelled, the URB complete handler</span>
<span class="p_add">+	 * won&#39;t be running. This is required to safely release the</span>
<span class="p_add">+	 * current buffer (dev-&gt;isoc_ctl.buf).</span>
<span class="p_add">+	 */</span>
 	stk1160_cancel_isoc(dev);
 
 	/*
<span class="p_chunk">@@ -624,8 +629,16 @@</span> <span class="p_context"> void stk1160_clear_queue(struct stk1160 *dev)</span>
 		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,
 				buf, buf-&gt;vb.v4l2_buf.index);
 	}
<span class="p_del">-	/* It&#39;s important to clear current buffer */</span>
<span class="p_del">-	dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It&#39;s important to release the current buffer */</span>
<span class="p_add">+	if (dev-&gt;isoc_ctl.buf) {</span>
<span class="p_add">+		buf = dev-&gt;isoc_ctl.buf;</span>
<span class="p_add">+		dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		vb2_buffer_done(&amp;buf-&gt;vb, VB2_BUF_STATE_ERROR);</span>
<span class="p_add">+		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,</span>
<span class="p_add">+				buf, buf-&gt;vb.v4l2_buf.index);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;dev-&gt;buf_lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/memstick/core/mspro_block.c b/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">index fc145d202c46..922a750640e8 100644</span>
<span class="p_header">--- a/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">+++ b/drivers/memstick/core/mspro_block.c</span>
<span class="p_chunk">@@ -758,7 +758,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 
 		if (error || (card-&gt;current_mrq.tpc == MSPRO_CMD_STOP)) {
 			if (msb-&gt;data_dir == READ) {
<span class="p_del">-				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++)</span>
<span class="p_add">+				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++) {</span>
 					t_len += msb-&gt;req_sg[cnt].length
 						 / msb-&gt;page_size;
 
<span class="p_chunk">@@ -766,6 +766,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 						t_len += msb-&gt;current_page - 1;
 
 					t_len *= msb-&gt;page_size;
<span class="p_add">+				}</span>
 			}
 		} else
 			t_len = blk_rq_bytes(msb-&gt;block_req);
<span class="p_header">diff --git a/drivers/mmc/host/sunxi-mmc.c b/drivers/mmc/host/sunxi-mmc.c</span>
<span class="p_header">index 024f67c98cdc..97823c68600a 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sunxi-mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sunxi-mmc.c</span>
<span class="p_chunk">@@ -909,7 +909,9 @@</span> <span class="p_context"> static int sunxi_mmc_resource_request(struct sunxi_mmc_host *host,</span>
 		return PTR_ERR(host-&gt;clk_mmc);
 	}
 
<span class="p_del">-	host-&gt;reset = devm_reset_control_get(&amp;pdev-&gt;dev, &quot;ahb&quot;);</span>
<span class="p_add">+	host-&gt;reset = devm_reset_control_get_optional(&amp;pdev-&gt;dev, &quot;ahb&quot;);</span>
<span class="p_add">+	if (PTR_ERR(host-&gt;reset) == -EPROBE_DEFER)</span>
<span class="p_add">+		return PTR_ERR(host-&gt;reset);</span>
 
 	ret = clk_prepare_enable(host-&gt;clk_ahb);
 	if (ret) {
<span class="p_header">diff --git a/drivers/mtd/ubi/attach.c b/drivers/mtd/ubi/attach.c</span>
<span class="p_header">index 6f27d9a1be3b..21841fe25ad3 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/attach.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/attach.c</span>
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> int ubi_compare_lebs(struct ubi_device *ubi, const struct ubi_ainf_peb *aeb,</span>
 		second_is_newer = !second_is_newer;
 	} else {
 		dbg_bld(&quot;PEB %d CRC is OK&quot;, pnum);
<span class="p_del">-		bitflips = !!err;</span>
<span class="p_add">+		bitflips |= !!err;</span>
 	}
 	mutex_unlock(&amp;ubi-&gt;buf_mutex);
 
<span class="p_header">diff --git a/drivers/mtd/ubi/cdev.c b/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">index 7646220ca6e2..0a2a16111429 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/cdev.c</span>
<span class="p_chunk">@@ -451,7 +451,7 @@</span> <span class="p_context"> static long vol_cdev_ioctl(struct file *file, unsigned int cmd,</span>
 		/* Validate the request */
 		err = -EINVAL;
 		if (req.lnum &lt; 0 || req.lnum &gt;= vol-&gt;reserved_pebs ||
<span class="p_del">-		    req.bytes &lt; 0 || req.lnum &gt;= vol-&gt;usable_leb_size)</span>
<span class="p_add">+		    req.bytes &lt; 0 || req.bytes &gt; vol-&gt;usable_leb_size)</span>
 			break;
 
 		err = get_exclusive(desc);
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index 0e11671dadc4..930cf2c77abb 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -1362,7 +1362,8 @@</span> <span class="p_context"> int ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 				 * during re-size.
 				 */
 				ubi_move_aeb_to_list(av, aeb, &amp;ai-&gt;erase);
<span class="p_del">-			vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index 89d51f94db11..31afc91a326f 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -1000,7 +1000,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int cancel)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, uninitialized_var(lnum);</span>
<span class="p_add">+	int vol_id = -1, lnum = -1;</span>
 #ifdef CONFIG_MTD_UBI_FASTMAP
 	int anchor = wrk-&gt;anchor;
 #endif
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index 6c795cfd6bbc..14faf3ec7c7f 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -3763,7 +3763,8 @@</span> <span class="p_context"> static inline int bond_slave_override(struct bonding *bond,</span>
 	/* Find out if any slaves have the same mapping as this skb. */
 	bond_for_each_slave_rcu(bond, slave, iter) {
 		if (slave-&gt;queue_id == skb-&gt;queue_mapping) {
<span class="p_del">-			if (bond_slave_can_tx(slave)) {</span>
<span class="p_add">+			if (bond_slave_is_up(slave) &amp;&amp;</span>
<span class="p_add">+			    slave-&gt;link == BOND_LINK_UP) {</span>
 				bond_dev_queue_xmit(bond, skb, slave-&gt;dev);
 				return 0;
 			}
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">index 660971f304b2..2a26dd187a49 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_chunk">@@ -144,6 +144,11 @@</span> <span class="p_context"> static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,</span>
 static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
 				     struct e1000_rx_ring *rx_ring,
 				     int *work_done, int work_to_do);
<span class="p_add">+static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,</span>
<span class="p_add">+					 struct e1000_rx_ring *rx_ring,</span>
<span class="p_add">+					 int cleaned_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
 				   struct e1000_rx_ring *rx_ring,
 				   int cleaned_count);
<span class="p_chunk">@@ -3525,8 +3530,11 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		msleep(1);
 	/* e1000_down has a dependency on max_frame_size */
 	hw-&gt;max_frame_size = max_frame;
<span class="p_del">-	if (netif_running(netdev))</span>
<span class="p_add">+	if (netif_running(netdev)) {</span>
<span class="p_add">+		/* prevent buffers from being reallocated */</span>
<span class="p_add">+		adapter-&gt;alloc_rx_buf = e1000_alloc_dummy_rx_buffers;</span>
 		e1000_down(adapter);
<span class="p_add">+	}</span>
 
 	/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN
 	 * means we reserve 2 more, this pushes us to allocate from the next
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c b/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c</span>
<span class="p_header">index c2a953ef0e67..7bd9582303e8 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c</span>
<span class="p_chunk">@@ -211,26 +211,28 @@</span> <span class="p_context"> static int alloc_4k(struct mlx5_core_dev *dev, u64 *addr)</span>
 	return 0;
 }
 
<span class="p_add">+#define MLX5_U64_4K_PAGE_MASK ((~(u64)0U) &lt;&lt; PAGE_SHIFT)</span>
<span class="p_add">+</span>
 static void free_4k(struct mlx5_core_dev *dev, u64 addr)
 {
 	struct fw_page *fwp;
 	int n;
 
<span class="p_del">-	fwp = find_fw_page(dev, addr &amp; PAGE_MASK);</span>
<span class="p_add">+	fwp = find_fw_page(dev, addr &amp; MLX5_U64_4K_PAGE_MASK);</span>
 	if (!fwp) {
 		mlx5_core_warn(dev, &quot;page not found\n&quot;);
 		return;
 	}
 
<span class="p_del">-	n = (addr &amp; ~PAGE_MASK) &gt;&gt; MLX5_ADAPTER_PAGE_SHIFT;</span>
<span class="p_add">+	n = (addr &amp; ~MLX5_U64_4K_PAGE_MASK) &gt;&gt; MLX5_ADAPTER_PAGE_SHIFT;</span>
 	fwp-&gt;free_count++;
 	set_bit(n, &amp;fwp-&gt;bitmask);
 	if (fwp-&gt;free_count == MLX5_NUM_4K_IN_PAGE) {
 		rb_erase(&amp;fwp-&gt;rb_node, &amp;dev-&gt;priv.page_root);
 		if (fwp-&gt;free_count != 1)
 			list_del(&amp;fwp-&gt;list);
<span class="p_del">-		dma_unmap_page(&amp;dev-&gt;pdev-&gt;dev, addr &amp; PAGE_MASK, PAGE_SIZE,</span>
<span class="p_del">-			       DMA_BIDIRECTIONAL);</span>
<span class="p_add">+		dma_unmap_page(&amp;dev-&gt;pdev-&gt;dev, addr &amp; MLX5_U64_4K_PAGE_MASK,</span>
<span class="p_add">+			       PAGE_SIZE, DMA_BIDIRECTIONAL);</span>
 		__free_page(fwp-&gt;page);
 		kfree(fwp);
 	} else if (fwp-&gt;free_count == 1) {
<span class="p_header">diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">index a75a411b1c27..dbf56debb7e3 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_chunk">@@ -1710,6 +1710,7 @@</span> <span class="p_context"> ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)</span>
 {
 	/* note: a 0-length skb is used as an error indication */
 	if (skb-&gt;len &gt; 0) {
<span class="p_add">+		skb_checksum_complete_unset(skb);</span>
 #ifdef CONFIG_PPP_MULTILINK
 		/* XXX do channel-level decompression here */
 		if (PPP_PROTO(skb) == PPP_MP)
<span class="p_header">diff --git a/drivers/net/usb/asix_common.c b/drivers/net/usb/asix_common.c</span>
<span class="p_header">index 5c55f11572ba..75d6f26729a3 100644</span>
<span class="p_header">--- a/drivers/net/usb/asix_common.c</span>
<span class="p_header">+++ b/drivers/net/usb/asix_common.c</span>
<span class="p_chunk">@@ -188,6 +188,8 @@</span> <span class="p_context"> struct sk_buff *asix_tx_fixup(struct usbnet *dev, struct sk_buff *skb,</span>
 		memcpy(skb_tail_pointer(skb), &amp;padbytes, sizeof(padbytes));
 		skb_put(skb, sizeof(padbytes));
 	}
<span class="p_add">+</span>
<span class="p_add">+	usbnet_set_skb_tx_stats(skb, 1, 0);</span>
 	return skb;
 }
 
<span class="p_header">diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">index 80a844e0ae03..c3e4da9e79ca 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_chunk">@@ -1172,17 +1172,17 @@</span> <span class="p_context"> cdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign)</span>
 
 	/* return skb */
 	ctx-&gt;tx_curr_skb = NULL;
<span class="p_del">-	dev-&gt;net-&gt;stats.tx_packets += ctx-&gt;tx_curr_frame_num;</span>
 
 	/* keep private stats: framing overhead and number of NTBs */
 	ctx-&gt;tx_overhead += skb_out-&gt;len - ctx-&gt;tx_curr_frame_payload;
 	ctx-&gt;tx_ntbs++;
 
<span class="p_del">-	/* usbnet has already counted all the framing overhead.</span>
<span class="p_add">+	/* usbnet will count all the framing overhead by default.</span>
 	 * Adjust the stats so that the tx_bytes counter show real
 	 * payload data instead.
 	 */
<span class="p_del">-	dev-&gt;net-&gt;stats.tx_bytes -= skb_out-&gt;len - ctx-&gt;tx_curr_frame_payload;</span>
<span class="p_add">+	usbnet_set_skb_tx_stats(skb_out, n,</span>
<span class="p_add">+				ctx-&gt;tx_curr_frame_payload - skb_out-&gt;len);</span>
 
 	return skb_out;
 
<span class="p_header">diff --git a/drivers/net/usb/sr9800.c b/drivers/net/usb/sr9800.c</span>
<span class="p_header">index b94a0fbb8b3b..953de13267df 100644</span>
<span class="p_header">--- a/drivers/net/usb/sr9800.c</span>
<span class="p_header">+++ b/drivers/net/usb/sr9800.c</span>
<span class="p_chunk">@@ -144,6 +144,7 @@</span> <span class="p_context"> static struct sk_buff *sr_tx_fixup(struct usbnet *dev, struct sk_buff *skb,</span>
 		skb_put(skb, sizeof(padbytes));
 	}
 
<span class="p_add">+	usbnet_set_skb_tx_stats(skb, 1, 0);</span>
 	return skb;
 }
 
<span class="p_header">diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c</span>
<span class="p_header">index f9e96c427558..c5a2ad29d53c 100644</span>
<span class="p_header">--- a/drivers/net/usb/usbnet.c</span>
<span class="p_header">+++ b/drivers/net/usb/usbnet.c</span>
<span class="p_chunk">@@ -1169,8 +1169,7 @@</span> <span class="p_context"> static void tx_complete (struct urb *urb)</span>
 	struct usbnet		*dev = entry-&gt;dev;
 
 	if (urb-&gt;status == 0) {
<span class="p_del">-		if (!(dev-&gt;driver_info-&gt;flags &amp; FLAG_MULTI_PACKET))</span>
<span class="p_del">-			dev-&gt;net-&gt;stats.tx_packets++;</span>
<span class="p_add">+		dev-&gt;net-&gt;stats.tx_packets += entry-&gt;packets;</span>
 		dev-&gt;net-&gt;stats.tx_bytes += entry-&gt;length;
 	} else {
 		dev-&gt;net-&gt;stats.tx_errors++;
<span class="p_chunk">@@ -1323,7 +1322,19 @@</span> <span class="p_context"> netdev_tx_t usbnet_start_xmit (struct sk_buff *skb,</span>
 		} else
 			urb-&gt;transfer_flags |= URB_ZERO_PACKET;
 	}
<span class="p_del">-	entry-&gt;length = urb-&gt;transfer_buffer_length = length;</span>
<span class="p_add">+	urb-&gt;transfer_buffer_length = length;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (info-&gt;flags &amp; FLAG_MULTI_PACKET) {</span>
<span class="p_add">+		/* Driver has set number of packets and a length delta.</span>
<span class="p_add">+		 * Calculate the complete length and ensure that it&#39;s</span>
<span class="p_add">+		 * positive.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		entry-&gt;length += length;</span>
<span class="p_add">+		if (WARN_ON_ONCE(entry-&gt;length &lt;= 0))</span>
<span class="p_add">+			entry-&gt;length = length;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		usbnet_set_skb_tx_stats(skb, 1, length);</span>
<span class="p_add">+	}</span>
 
 	spin_lock_irqsave(&amp;dev-&gt;txq.lock, flags);
 	retval = usb_autopm_get_interface_async(dev-&gt;intf);
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index 1ac6383e7947..7ada8cb0f0da 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -314,6 +314,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x07b8, 0x8188, rtl92cu_hal_cfg)}, /*Abocom - Abocom*/
 	{RTL_USB_DEVICE(0x07b8, 0x8189, rtl92cu_hal_cfg)}, /*Funai - Abocom*/
 	{RTL_USB_DEVICE(0x0846, 0x9041, rtl92cu_hal_cfg)}, /*NetGear WNA1000M*/
<span class="p_add">+	{RTL_USB_DEVICE(0x0b05, 0x17ba, rtl92cu_hal_cfg)}, /*ASUS-Edimax*/</span>
 	{RTL_USB_DEVICE(0x0bda, 0x5088, rtl92cu_hal_cfg)}, /*Thinkware-CC&amp;C*/
 	{RTL_USB_DEVICE(0x0df6, 0x0052, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
 	{RTL_USB_DEVICE(0x0df6, 0x005c, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
<span class="p_chunk">@@ -370,6 +371,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x2001, 0x3307, rtl92cu_hal_cfg)}, /*D-Link-Cameo*/
 	{RTL_USB_DEVICE(0x2001, 0x3309, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
 	{RTL_USB_DEVICE(0x2001, 0x330a, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
<span class="p_add">+	{RTL_USB_DEVICE(0x2001, 0x330d, rtl92cu_hal_cfg)}, /*D-Link DWA-131 */</span>
 	{RTL_USB_DEVICE(0x2019, 0xab2b, rtl92cu_hal_cfg)}, /*Planex -Abocom*/
 	{RTL_USB_DEVICE(0x20f4, 0x624d, rtl92cu_hal_cfg)}, /*TRENDNet*/
 	{RTL_USB_DEVICE(0x2357, 0x0100, rtl92cu_hal_cfg)}, /*TP-Link WN8200ND*/
<span class="p_header">diff --git a/drivers/net/wireless/ti/wl18xx/debugfs.c b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">index 7f1669cdea09..779dc2b2ca75 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, protection_filter, &quot;%u&quot;);</span>
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, accum_arp_pend_requests, &quot;%u&quot;);
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, max_arp_queue_dep, &quot;%u&quot;);
 
<span class="p_del">-WL18XX_DEBUGFS_FWSTATS_FILE(rx_rate, rx_frames_per_rates, &quot;%u&quot;);</span>
<span class="p_add">+WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(rx_rate, rx_frames_per_rates, 50);</span>
 
 WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(aggr_size, tx_agg_vs_rate,
 				  AGGR_STATS_TX_AGG*AGGR_STATS_TX_RATE);
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/debugfs.h b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">index 0f2cfb0d2a9e..bf14676e6515 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_chunk">@@ -26,8 +26,8 @@</span> <span class="p_context"></span>
 
 #include &quot;wlcore.h&quot;
 
<span class="p_del">-int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_del">-			 loff_t *ppos, char *fmt, ...);</span>
<span class="p_add">+__printf(4, 5) int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_add">+					loff_t *ppos, char *fmt, ...);</span>
 
 int wl1271_debugfs_init(struct wl1271 *wl);
 void wl1271_debugfs_exit(struct wl1271 *wl);
<span class="p_header">diff --git a/drivers/of/address.c b/drivers/of/address.c</span>
<span class="p_header">index 22ce1572af38..bab28871b992 100644</span>
<span class="p_header">--- a/drivers/of/address.c</span>
<span class="p_header">+++ b/drivers/of/address.c</span>
<span class="p_chunk">@@ -403,12 +403,17 @@</span> <span class="p_context"> static struct of_bus *of_match_bus(struct device_node *np)</span>
 	return NULL;
 }
 
<span class="p_del">-static int of_empty_ranges_quirk(void)</span>
<span class="p_add">+static int of_empty_ranges_quirk(struct device_node *np)</span>
 {
 	if (IS_ENABLED(CONFIG_PPC)) {
<span class="p_del">-		/* To save cycles, we cache the result */</span>
<span class="p_add">+		/* To save cycles, we cache the result for global &quot;Mac&quot; setting */</span>
 		static int quirk_state = -1;
 
<span class="p_add">+		/* PA-SEMI sdc DT bug */</span>
<span class="p_add">+		if (of_device_is_compatible(np, &quot;1682m-sdc&quot;))</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Make quirk cached */</span>
 		if (quirk_state &lt; 0)
 			quirk_state =
 				of_machine_is_compatible(&quot;Power Macintosh&quot;) ||
<span class="p_chunk">@@ -443,7 +448,7 @@</span> <span class="p_context"> static int of_translate_one(struct device_node *parent, struct of_bus *bus,</span>
 	 * This code is only enabled on powerpc. --gcl
 	 */
 	ranges = of_get_property(parent, rprop, &amp;rlen);
<span class="p_del">-	if (ranges == NULL &amp;&amp; !of_empty_ranges_quirk()) {</span>
<span class="p_add">+	if (ranges == NULL &amp;&amp; !of_empty_ranges_quirk(parent)) {</span>
 		pr_err(&quot;OF: no ranges; cannot translate\n&quot;);
 		return 1;
 	}
<span class="p_header">diff --git a/drivers/pci/hotplug/cpci_hotplug_pci.c b/drivers/pci/hotplug/cpci_hotplug_pci.c</span>
<span class="p_header">index 7d48ecae6695..788db48dbbad 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/cpci_hotplug_pci.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/cpci_hotplug_pci.c</span>
<span class="p_chunk">@@ -286,11 +286,12 @@</span> <span class="p_context"> int cpci_configure_slot(struct slot *slot)</span>
 	}
 	parent = slot-&gt;dev-&gt;bus;
 
<span class="p_del">-	list_for_each_entry(dev, &amp;parent-&gt;devices, bus_list)</span>
<span class="p_add">+	list_for_each_entry(dev, &amp;parent-&gt;devices, bus_list) {</span>
 		if (PCI_SLOT(dev-&gt;devfn) != PCI_SLOT(slot-&gt;devfn))
 			continue;
 		if (pci_is_bridge(dev))
 			pci_hp_add_bridge(dev);
<span class="p_add">+	}</span>
 
 
 	pci_assign_unassigned_bridge_resources(parent-&gt;self);
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv_errprint.c b/drivers/pci/pcie/aer/aerdrv_errprint.c</span>
<span class="p_header">index 36ed31b52198..3f893dd8fa89 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv_errprint.c</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv_errprint.c</span>
<span class="p_chunk">@@ -127,16 +127,8 @@</span> <span class="p_context"> static const char *aer_agent_string[] = {</span>
 static void __print_tlp_header(struct pci_dev *dev,
 			       struct aer_header_log_regs *t)
 {
<span class="p_del">-	unsigned char *tlp = (unsigned char *)&amp;t;</span>
<span class="p_del">-</span>
<span class="p_del">-	dev_err(&amp;dev-&gt;dev, &quot;  TLP Header:&quot;</span>
<span class="p_del">-		&quot; %02x%02x%02x%02x %02x%02x%02x%02x&quot;</span>
<span class="p_del">-		&quot; %02x%02x%02x%02x %02x%02x%02x%02x\n&quot;,</span>
<span class="p_del">-		*(tlp + 3), *(tlp + 2), *(tlp + 1), *tlp,</span>
<span class="p_del">-		*(tlp + 7), *(tlp + 6), *(tlp + 5), *(tlp + 4),</span>
<span class="p_del">-		*(tlp + 11), *(tlp + 10), *(tlp + 9),</span>
<span class="p_del">-		*(tlp + 8), *(tlp + 15), *(tlp + 14),</span>
<span class="p_del">-		*(tlp + 13), *(tlp + 12));</span>
<span class="p_add">+	dev_err(&amp;dev-&gt;dev, &quot;  TLP Header: %08x %08x %08x %08x\n&quot;,</span>
<span class="p_add">+		t-&gt;dw0, t-&gt;dw1, t-&gt;dw2, t-&gt;dw3);</span>
 }
 
 static void __aer_print_error(struct pci_dev *dev,
<span class="p_header">diff --git a/drivers/platform/x86/apple-gmux.c b/drivers/platform/x86/apple-gmux.c</span>
<span class="p_header">index b9429fbf1cd8..e743b03f50da 100644</span>
<span class="p_header">--- a/drivers/platform/x86/apple-gmux.c</span>
<span class="p_header">+++ b/drivers/platform/x86/apple-gmux.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/pci.h&gt;
 #include &lt;linux/vga_switcheroo.h&gt;
<span class="p_add">+#include &lt;linux/vgaarb.h&gt;</span>
 #include &lt;acpi/video.h&gt;
 #include &lt;asm/io.h&gt;
 
<span class="p_chunk">@@ -31,6 +32,7 @@</span> <span class="p_context"> struct apple_gmux_data {</span>
 	bool indexed;
 	struct mutex index_lock;
 
<span class="p_add">+	struct pci_dev *pdev;</span>
 	struct backlight_device *bdev;
 
 	/* switcheroo data */
<span class="p_chunk">@@ -415,6 +417,23 @@</span> <span class="p_context"> static int gmux_resume(struct device *dev)</span>
 	return 0;
 }
 
<span class="p_add">+static struct pci_dev *gmux_get_io_pdev(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pdev = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA &lt;&lt; 8, pdev))) {</span>
<span class="p_add">+		u16 cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_read_config_word(pdev, PCI_COMMAND, &amp;cmd);</span>
<span class="p_add">+		if (!(cmd &amp; PCI_COMMAND_IO))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		return pdev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int gmux_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)
 {
 	struct apple_gmux_data *gmux_data;
<span class="p_chunk">@@ -425,6 +444,7 @@</span> <span class="p_context"> static int gmux_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)</span>
 	int ret = -ENXIO;
 	acpi_status status;
 	unsigned long long gpe;
<span class="p_add">+	struct pci_dev *pdev = NULL;</span>
 
 	if (apple_gmux_data)
 		return -EBUSY;
<span class="p_chunk">@@ -475,7 +495,7 @@</span> <span class="p_context"> static int gmux_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)</span>
 			ver_minor = (version &gt;&gt; 16) &amp; 0xff;
 			ver_release = (version &gt;&gt; 8) &amp; 0xff;
 		} else {
<span class="p_del">-			pr_info(&quot;gmux device not present\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;gmux device not present or IO disabled\n&quot;);</span>
 			ret = -ENODEV;
 			goto err_release;
 		}
<span class="p_chunk">@@ -483,6 +503,23 @@</span> <span class="p_context"> static int gmux_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)</span>
 	pr_info(&quot;Found gmux version %d.%d.%d [%s]\n&quot;, ver_major, ver_minor,
 		ver_release, (gmux_data-&gt;indexed ? &quot;indexed&quot; : &quot;classic&quot;));
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Apple systems with gmux are EFI based and normally don&#39;t use</span>
<span class="p_add">+	 * VGA. In addition changing IO+MEM ownership between IGP and dGPU</span>
<span class="p_add">+	 * disables IO/MEM used for backlight control on some systems.</span>
<span class="p_add">+	 * Lock IO+MEM to GPU with active IO to prevent switch.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pdev = gmux_get_io_pdev();</span>
<span class="p_add">+	if (pdev &amp;&amp; vga_tryget(pdev,</span>
<span class="p_add">+			       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM)) {</span>
<span class="p_add">+		pr_err(&quot;IO+MEM vgaarb-locking for PCI:%s failed\n&quot;,</span>
<span class="p_add">+			pci_name(pdev));</span>
<span class="p_add">+		ret = -EBUSY;</span>
<span class="p_add">+		goto err_release;</span>
<span class="p_add">+	} else if (pdev)</span>
<span class="p_add">+		pr_info(&quot;locked IO for PCI:%s\n&quot;, pci_name(pdev));</span>
<span class="p_add">+	gmux_data-&gt;pdev = pdev;</span>
<span class="p_add">+</span>
 	memset(&amp;props, 0, sizeof(props));
 	props.type = BACKLIGHT_PLATFORM;
 	props.max_brightness = gmux_read32(gmux_data, GMUX_PORT_MAX_BRIGHTNESS);
<span class="p_chunk">@@ -574,6 +611,10 @@</span> <span class="p_context"> err_enable_gpe:</span>
 err_notify:
 	backlight_device_unregister(bdev);
 err_release:
<span class="p_add">+	if (gmux_data-&gt;pdev)</span>
<span class="p_add">+		vga_put(gmux_data-&gt;pdev,</span>
<span class="p_add">+			VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM);</span>
<span class="p_add">+	pci_dev_put(pdev);</span>
 	release_region(gmux_data-&gt;iostart, gmux_data-&gt;iolen);
 err_free:
 	kfree(gmux_data);
<span class="p_chunk">@@ -593,6 +634,11 @@</span> <span class="p_context"> static void gmux_remove(struct pnp_dev *pnp)</span>
 					   &amp;gmux_notify_handler);
 	}
 
<span class="p_add">+	if (gmux_data-&gt;pdev) {</span>
<span class="p_add">+		vga_put(gmux_data-&gt;pdev,</span>
<span class="p_add">+			VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM);</span>
<span class="p_add">+		pci_dev_put(gmux_data-&gt;pdev);</span>
<span class="p_add">+	}</span>
 	backlight_device_unregister(gmux_data-&gt;bdev);
 
 	release_region(gmux_data-&gt;iostart, gmux_data-&gt;iolen);
<span class="p_header">diff --git a/drivers/platform/x86/compal-laptop.c b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">index 7297df2ebf50..034aa844a1b5 100644</span>
<span class="p_header">--- a/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_chunk">@@ -1027,9 +1027,9 @@</span> <span class="p_context"> static int compal_probe(struct platform_device *pdev)</span>
 	if (err)
 		return err;
 
<span class="p_del">-	hwmon_dev = hwmon_device_register_with_groups(&amp;pdev-&gt;dev,</span>
<span class="p_del">-						      DRIVER_NAME, data,</span>
<span class="p_del">-						      compal_hwmon_groups);</span>
<span class="p_add">+	hwmon_dev = devm_hwmon_device_register_with_groups(&amp;pdev-&gt;dev,</span>
<span class="p_add">+							   &quot;compal&quot;, data,</span>
<span class="p_add">+							   compal_hwmon_groups);</span>
 	if (IS_ERR(hwmon_dev)) {
 		err = PTR_ERR(hwmon_dev);
 		goto remove;
<span class="p_chunk">@@ -1037,7 +1037,9 @@</span> <span class="p_context"> static int compal_probe(struct platform_device *pdev)</span>
 
 	/* Power supply */
 	initialize_power_supply_data(data);
<span class="p_del">-	power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	err = power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto remove;</span>
 
 	platform_set_drvdata(pdev, data);
 
<span class="p_header">diff --git a/drivers/power/lp8788-charger.c b/drivers/power/lp8788-charger.c</span>
<span class="p_header">index ed49b50b220b..72da2a6c22db 100644</span>
<span class="p_header">--- a/drivers/power/lp8788-charger.c</span>
<span class="p_header">+++ b/drivers/power/lp8788-charger.c</span>
<span class="p_chunk">@@ -417,8 +417,10 @@</span> <span class="p_context"> static int lp8788_psy_register(struct platform_device *pdev,</span>
 	pchg-&gt;battery.num_properties = ARRAY_SIZE(lp8788_battery_prop);
 	pchg-&gt;battery.get_property = lp8788_battery_get_property;
 
<span class="p_del">-	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery))</span>
<span class="p_add">+	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery)) {</span>
<span class="p_add">+		power_supply_unregister(&amp;pchg-&gt;charger);</span>
 		return -EPERM;
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/power/twl4030_madc_battery.c b/drivers/power/twl4030_madc_battery.c</span>
<span class="p_header">index 7ef445a6cfa6..cf907609ec49 100644</span>
<span class="p_header">--- a/drivers/power/twl4030_madc_battery.c</span>
<span class="p_header">+++ b/drivers/power/twl4030_madc_battery.c</span>
<span class="p_chunk">@@ -192,6 +192,7 @@</span> <span class="p_context"> static int twl4030_madc_battery_probe(struct platform_device *pdev)</span>
 {
 	struct twl4030_madc_battery *twl4030_madc_bat;
 	struct twl4030_madc_bat_platform_data *pdata = pdev-&gt;dev.platform_data;
<span class="p_add">+	int ret = 0;</span>
 
 	twl4030_madc_bat = kzalloc(sizeof(*twl4030_madc_bat), GFP_KERNEL);
 	if (!twl4030_madc_bat)
<span class="p_chunk">@@ -216,9 +217,11 @@</span> <span class="p_context"> static int twl4030_madc_battery_probe(struct platform_device *pdev)</span>
 
 	twl4030_madc_bat-&gt;pdata = pdata;
 	platform_set_drvdata(pdev, twl4030_madc_bat);
<span class="p_del">-	power_supply_register(&amp;pdev-&gt;dev, &amp;twl4030_madc_bat-&gt;psy);</span>
<span class="p_add">+	ret = power_supply_register(&amp;pdev-&gt;dev, &amp;twl4030_madc_bat-&gt;psy);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		kfree(twl4030_madc_bat);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int twl4030_madc_battery_remove(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">index f7e9c531cc26..5d13d109d9a2 100644</span>
<span class="p_header">--- a/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">+++ b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_chunk">@@ -5707,9 +5707,9 @@</span> <span class="p_context"> free_port:</span>
 hba_free:
 	if (phba-&gt;msix_enabled)
 		pci_disable_msix(phba-&gt;pcidev);
<span class="p_del">-	iscsi_host_remove(phba-&gt;shost);</span>
 	pci_dev_put(phba-&gt;pcidev);
 	iscsi_host_free(phba-&gt;shost);
<span class="p_add">+	pci_set_drvdata(pcidev, NULL);</span>
 disable_pci:
 	pci_disable_device(pcidev);
 	return ret;
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_sas.c b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">index 6c1f223a8e1d..4c0b8b4e1d40 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_chunk">@@ -441,14 +441,11 @@</span> <span class="p_context"> static u32 mvs_get_ncq_tag(struct sas_task *task, u32 *tag)</span>
 static int mvs_task_prep_ata(struct mvs_info *mvi,
 			     struct mvs_task_exec_info *tei)
 {
<span class="p_del">-	struct sas_ha_struct *sha = mvi-&gt;sas;</span>
 	struct sas_task *task = tei-&gt;task;
 	struct domain_device *dev = task-&gt;dev;
 	struct mvs_device *mvi_dev = dev-&gt;lldd_dev;
 	struct mvs_cmd_hdr *hdr = tei-&gt;hdr;
 	struct asd_sas_port *sas_port = dev-&gt;port;
<span class="p_del">-	struct sas_phy *sphy = dev-&gt;phy;</span>
<span class="p_del">-	struct asd_sas_phy *sas_phy = sha-&gt;sas_phy[sphy-&gt;number];</span>
 	struct mvs_slot_info *slot;
 	void *buf_prd;
 	u32 tag = tei-&gt;tag, hdr_tag;
<span class="p_chunk">@@ -468,7 +465,7 @@</span> <span class="p_context"> static int mvs_task_prep_ata(struct mvs_info *mvi,</span>
 	slot-&gt;tx = mvi-&gt;tx_prod;
 	del_q = TXQ_MODE_I | tag |
 		(TXQ_CMD_STP &lt;&lt; TXQ_CMD_SHIFT) |
<span class="p_del">-		(MVS_PHY_ID &lt;&lt; TXQ_PHY_SHIFT) |</span>
<span class="p_add">+		((sas_port-&gt;phy_mask &amp; TXQ_PHY_MASK) &lt;&lt; TXQ_PHY_SHIFT) |</span>
 		(mvi_dev-&gt;taskfileset &lt;&lt; TXQ_SRS_SHIFT);
 	mvi-&gt;tx[mvi-&gt;tx_prod] = cpu_to_le32(del_q);
 
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index 3f50dfcb3227..d7062a06f72e 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -1172,9 +1172,11 @@</span> <span class="p_context"> scsi_prep_state_check(struct scsi_device *sdev, struct request *req)</span>
 				    &quot;rejecting I/O to dead device\n&quot;);
 			ret = BLKPREP_KILL;
 			break;
<span class="p_del">-		case SDEV_QUIESCE:</span>
 		case SDEV_BLOCK:
 		case SDEV_CREATED_BLOCK:
<span class="p_add">+			ret = BLKPREP_DEFER;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case SDEV_QUIESCE:</span>
 			/*
 			 * If the devices is blocked we defer normal commands.
 			 */
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 86b05151fdab..97892f258043 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -739,21 +739,22 @@</span> <span class="p_context"> static unsigned int copy_to_bounce_buffer(struct scatterlist *orig_sgl,</span>
 			if (bounce_sgl[j].length == PAGE_SIZE) {
 				/* full..move to next entry */
 				sg_kunmap_atomic(bounce_addr);
<span class="p_add">+				bounce_addr = 0;</span>
 				j++;
<span class="p_add">+			}</span>
 
<span class="p_del">-				/* if we need to use another bounce buffer */</span>
<span class="p_del">-				if (srclen || i != orig_sgl_count - 1)</span>
<span class="p_del">-					bounce_addr = sg_kmap_atomic(bounce_sgl,j);</span>
<span class="p_add">+			/* if we need to use another bounce buffer */</span>
<span class="p_add">+			if (srclen &amp;&amp; bounce_addr == 0)</span>
<span class="p_add">+				bounce_addr = sg_kmap_atomic(bounce_sgl, j);</span>
 
<span class="p_del">-			} else if (srclen == 0 &amp;&amp; i == orig_sgl_count - 1) {</span>
<span class="p_del">-				/* unmap the last bounce that is &lt; PAGE_SIZE */</span>
<span class="p_del">-				sg_kunmap_atomic(bounce_addr);</span>
<span class="p_del">-			}</span>
 		}
 
 		sg_kunmap_atomic(src_addr - orig_sgl[i].offset);
 	}
 
<span class="p_add">+	if (bounce_addr)</span>
<span class="p_add">+		sg_kunmap_atomic(bounce_addr);</span>
<span class="p_add">+</span>
 	local_irq_restore(flags);
 
 	return total_copied;
<span class="p_header">diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c</span>
<span class="p_header">index e3bc23bb5883..621df17214a5 100644</span>
<span class="p_header">--- a/drivers/spi/spidev.c</span>
<span class="p_header">+++ b/drivers/spi/spidev.c</span>
<span class="p_chunk">@@ -244,7 +244,10 @@</span> <span class="p_context"> static int spidev_message(struct spidev_data *spidev,</span>
 		k_tmp-&gt;len = u_tmp-&gt;len;
 
 		total += k_tmp-&gt;len;
<span class="p_del">-		if (total &gt; bufsiz) {</span>
<span class="p_add">+		/* Check total length of transfers.  Also check each</span>
<span class="p_add">+		 * transfer length to avoid arithmetic overflow.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (total &gt; bufsiz || k_tmp-&gt;len &gt; bufsiz) {</span>
 			status = -EMSGSIZE;
 			goto done;
 		}
<span class="p_header">diff --git a/drivers/staging/panel/panel.c b/drivers/staging/panel/panel.c</span>
<span class="p_header">index 4e9229363c36..7e2063fa924d 100644</span>
<span class="p_header">--- a/drivers/staging/panel/panel.c</span>
<span class="p_header">+++ b/drivers/staging/panel/panel.c</span>
<span class="p_chunk">@@ -275,11 +275,11 @@</span> <span class="p_context"> static unsigned char lcd_bits[LCD_PORTS][LCD_BITS][BIT_STATES];</span>
  * LCD types
  */
 #define LCD_TYPE_NONE		0
<span class="p_del">-#define LCD_TYPE_OLD		1</span>
<span class="p_del">-#define LCD_TYPE_KS0074		2</span>
<span class="p_del">-#define LCD_TYPE_HANTRONIX	3</span>
<span class="p_del">-#define LCD_TYPE_NEXCOM		4</span>
<span class="p_del">-#define LCD_TYPE_CUSTOM		5</span>
<span class="p_add">+#define LCD_TYPE_CUSTOM		1</span>
<span class="p_add">+#define LCD_TYPE_OLD		2</span>
<span class="p_add">+#define LCD_TYPE_KS0074		3</span>
<span class="p_add">+#define LCD_TYPE_HANTRONIX	4</span>
<span class="p_add">+#define LCD_TYPE_NEXCOM		5</span>
 
 /*
  * keypad types
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(keypad_enabled, &quot;Deprecated option, use keypad_type instead&quot;);</span>
 static int lcd_type = -1;
 module_param(lcd_type, int, 0000);
 MODULE_PARM_DESC(lcd_type,
<span class="p_del">-		 &quot;LCD type: 0=none, 1=old //, 2=serial ks0074, 3=hantronix //, 4=nexcom //, 5=compiled-in&quot;);</span>
<span class="p_add">+		 &quot;LCD type: 0=none, 1=compiled-in, 2=old, 3=serial ks0074, 4=hantronix, 5=nexcom&quot;);</span>
 
 static int lcd_proto = -1;
 module_param(lcd_proto, int, 0000);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 209eb58b5d3a..8932cb2e9165 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -537,7 +537,7 @@</span> <span class="p_context"> static struct iscsit_transport iscsi_target_transport = {</span>
 
 static int __init iscsi_target_init_module(void)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = 0, size;</span>
 
 	pr_debug(&quot;iSCSI-Target &quot;ISCSIT_VERSION&quot;\n&quot;);
 
<span class="p_chunk">@@ -546,6 +546,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 		pr_err(&quot;Unable to allocate memory for iscsit_global\n&quot;);
 		return -1;
 	}
<span class="p_add">+	spin_lock_init(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 	mutex_init(&amp;auth_id_lock);
 	spin_lock_init(&amp;sess_idr_lock);
 	idr_init(&amp;tiqn_idr);
<span class="p_chunk">@@ -555,15 +556,11 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (ret &lt; 0)
 		goto out;
 
<span class="p_del">-	ret = iscsi_thread_set_init();</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	size = BITS_TO_LONGS(ISCSIT_BITMAP_BITS) * sizeof(long);</span>
<span class="p_add">+	iscsit_global-&gt;ts_bitmap = vzalloc(size);</span>
<span class="p_add">+	if (!iscsit_global-&gt;ts_bitmap) {</span>
<span class="p_add">+		pr_err(&quot;Unable to allocate iscsit_global-&gt;ts_bitmap\n&quot;);</span>
 		goto configfs_out;
<span class="p_del">-</span>
<span class="p_del">-	if (iscsi_allocate_thread_sets(TARGET_THREAD_SET_COUNT) !=</span>
<span class="p_del">-			TARGET_THREAD_SET_COUNT) {</span>
<span class="p_del">-		pr_err(&quot;iscsi_allocate_thread_sets() returned&quot;</span>
<span class="p_del">-			&quot; unexpected value!\n&quot;);</span>
<span class="p_del">-		goto ts_out1;</span>
 	}
 
 	lio_qr_cache = kmem_cache_create(&quot;lio_qr_cache&quot;,
<span class="p_chunk">@@ -572,7 +569,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (!lio_qr_cache) {
 		pr_err(&quot;nable to kmem_cache_create() for&quot;
 				&quot; lio_qr_cache\n&quot;);
<span class="p_del">-		goto ts_out2;</span>
<span class="p_add">+		goto bitmap_out;</span>
 	}
 
 	lio_dr_cache = kmem_cache_create(&quot;lio_dr_cache&quot;,
<span class="p_chunk">@@ -616,10 +613,8 @@</span> <span class="p_context"> dr_out:</span>
 	kmem_cache_destroy(lio_dr_cache);
 qr_out:
 	kmem_cache_destroy(lio_qr_cache);
<span class="p_del">-ts_out2:</span>
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-ts_out1:</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
<span class="p_add">+bitmap_out:</span>
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 configfs_out:
 	iscsi_target_deregister_configfs();
 out:
<span class="p_chunk">@@ -629,8 +624,6 @@</span> <span class="p_context"> out:</span>
 
 static void __exit iscsi_target_cleanup_module(void)
 {
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
 	iscsit_release_discovery_tpg();
 	iscsit_unregister_transport(&amp;iscsi_target_transport);
 	kmem_cache_destroy(lio_qr_cache);
<span class="p_chunk">@@ -640,6 +633,7 @@</span> <span class="p_context"> static void __exit iscsi_target_cleanup_module(void)</span>
 
 	iscsi_target_deregister_configfs();
 
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 	kfree(iscsit_global);
 }
 
<span class="p_chunk">@@ -1184,7 +1178,7 @@</span> <span class="p_context"> iscsit_handle_scsi_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,</span>
 	 * traditional iSCSI block I/O.
 	 */
 	if (iscsit_allocate_iovecs(cmd) &lt; 0) {
<span class="p_del">-		return iscsit_add_reject_cmd(cmd,</span>
<span class="p_add">+		return iscsit_reject_cmd(cmd,</span>
 				ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
 	}
 	immed_data = cmd-&gt;immediate_data;
<span class="p_chunk">@@ -3680,17 +3674,16 @@</span> <span class="p_context"> static int iscsit_send_reject(</span>
 
 void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
 {
<span class="p_del">-	struct iscsi_thread_set *ts = conn-&gt;thread_set;</span>
 	int ord, cpu;
 	/*
<span class="p_del">-	 * thread_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_del">-	 * within iscsi_thread_set.c:iscsi_allocate_thread_sets()</span>
<span class="p_add">+	 * bitmap_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_add">+	 * within iscsit_start_kthreads()</span>
 	 *
<span class="p_del">-	 * Here we use thread_id to determine which CPU that this</span>
<span class="p_del">-	 * iSCSI connection&#39;s iscsi_thread_set will be scheduled to</span>
<span class="p_add">+	 * Here we use bitmap_id to determine which CPU that this</span>
<span class="p_add">+	 * iSCSI connection&#39;s RX/TX threads will be scheduled to</span>
 	 * execute upon.
 	 */
<span class="p_del">-	ord = ts-&gt;thread_id % cpumask_weight(cpu_online_mask);</span>
<span class="p_add">+	ord = conn-&gt;bitmap_id % cpumask_weight(cpu_online_mask);</span>
 	for_each_online_cpu(cpu) {
 		if (ord-- == 0) {
 			cpumask_set_cpu(cpu, conn-&gt;conn_cpumask);
<span class="p_chunk">@@ -3882,7 +3875,7 @@</span> <span class="p_context"> check_rsp_state:</span>
 	switch (state) {
 	case ISTATE_SEND_LOGOUTRSP:
 		if (!iscsit_logout_post_handler(cmd, conn))
<span class="p_del">-			goto restart;</span>
<span class="p_add">+			return -ECONNRESET;</span>
 		/* fall through */
 	case ISTATE_SEND_STATUS:
 	case ISTATE_SEND_ASYNCMSG:
<span class="p_chunk">@@ -3910,8 +3903,6 @@</span> <span class="p_context"> check_rsp_state:</span>
 
 err:
 	return -1;
<span class="p_del">-restart:</span>
<span class="p_del">-	return -EAGAIN;</span>
 }
 
 static int iscsit_handle_response_queue(struct iscsi_conn *conn)
<span class="p_chunk">@@ -3938,21 +3929,13 @@</span> <span class="p_context"> static int iscsit_handle_response_queue(struct iscsi_conn *conn)</span>
 int iscsi_target_tx_thread(void *arg)
 {
 	int ret = 0;
<span class="p_del">-	struct iscsi_conn *conn;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
 
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_tx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-</span>
 	while (!kthread_should_stop()) {
 		/*
 		 * Ensure that both TX and RX per connection kthreads
<span class="p_chunk">@@ -3961,11 +3944,9 @@</span> <span class="p_context"> restart:</span>
 		iscsit_thread_check_cpumask(conn, current, 1);
 
 		wait_event_interruptible(conn-&gt;queues_wq,
<span class="p_del">-					 !iscsit_conn_all_queues_empty(conn) ||</span>
<span class="p_del">-					 ts-&gt;status == ISCSI_THREAD_SET_RESET);</span>
<span class="p_add">+					 !iscsit_conn_all_queues_empty(conn));</span>
 
<span class="p_del">-		if ((ts-&gt;status == ISCSI_THREAD_SET_RESET) ||</span>
<span class="p_del">-		     signal_pending(current))</span>
<span class="p_add">+		if (signal_pending(current))</span>
 			goto transport_err;
 
 get_immediate:
<span class="p_chunk">@@ -3976,15 +3957,14 @@</span> <span class="p_context"> get_immediate:</span>
 		ret = iscsit_handle_response_queue(conn);
 		if (ret == 1)
 			goto get_immediate;
<span class="p_del">-		else if (ret == -EAGAIN)</span>
<span class="p_del">-			goto restart;</span>
<span class="p_add">+		else if (ret == -ECONNRESET)</span>
<span class="p_add">+			goto out;</span>
 		else if (ret &lt; 0)
 			goto transport_err;
 	}
 
 transport_err:
 	iscsit_take_action_for_connection_exit(conn);
<span class="p_del">-	goto restart;</span>
 out:
 	return 0;
 }
<span class="p_chunk">@@ -4073,8 +4053,7 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	int ret;
 	u8 buffer[ISCSI_HDR_LEN], opcode;
 	u32 checksum = 0, digest = 0;
<span class="p_del">-	struct iscsi_conn *conn = NULL;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	struct kvec iov;
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
<span class="p_chunk">@@ -4082,11 +4061,6 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	 */
 	allow_signal(SIGINT);
 
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_rx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
 		int rc;
<span class="p_chunk">@@ -4096,7 +4070,7 @@</span> <span class="p_context"> restart:</span>
 		if (rc &lt; 0)
 			goto transport_err;
 
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto transport_err;</span>
 	}
 
 	while (!kthread_should_stop()) {
<span class="p_chunk">@@ -4172,8 +4146,6 @@</span> <span class="p_context"> transport_err:</span>
 	if (!signal_pending(current))
 		atomic_set(&amp;conn-&gt;transport_failed, 1);
 	iscsit_take_action_for_connection_exit(conn);
<span class="p_del">-	goto restart;</span>
<span class="p_del">-out:</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4235,7 +4207,24 @@</span> <span class="p_context"> int iscsit_close_connection(</span>
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)
 		complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsi_release_thread_set(conn);</span>
<span class="p_add">+	if (!strcmp(current-&gt;comm, ISCSI_RX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;tx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;tx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (!strcmp(current-&gt;comm, ISCSI_TX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;rx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;rx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;rx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 
 	iscsit_stop_timers_for_cmds(conn);
 	iscsit_stop_nopin_response_timer(conn);
<span class="p_chunk">@@ -4514,15 +4503,13 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 	struct iscsi_conn *conn)
 {
 	struct iscsi_session *sess = conn-&gt;sess;
<span class="p_del">-</span>
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
 	iscsit_dec_conn_usage_count(conn);
<span class="p_del">-	iscsit_stop_session(sess, 1, 1);</span>
<span class="p_add">+	iscsit_stop_session(sess, sleep, sleep);</span>
 	iscsit_dec_session_usage_count(sess);
 	target_put_session(sess-&gt;se_sess);
 }
<span class="p_chunk">@@ -4530,13 +4517,12 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 static void iscsit_logout_post_handler_samecid(
 	struct iscsi_conn *conn)
 {
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsit_cause_connection_reinstatement(conn, 1);</span>
<span class="p_add">+	iscsit_cause_connection_reinstatement(conn, sleep);</span>
 	iscsit_dec_conn_usage_count(conn);
 }
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index 302eb3b78715..2423f27e4670 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -602,6 +602,11 @@</span> <span class="p_context"> struct iscsi_conn {</span>
 	struct iscsi_session	*sess;
 	/* Pointer to thread_set in use for this conn&#39;s threads */
 	struct iscsi_thread_set	*thread_set;
<span class="p_add">+	int			bitmap_id;</span>
<span class="p_add">+	int			rx_thread_active;</span>
<span class="p_add">+	struct task_struct	*rx_thread;</span>
<span class="p_add">+	int			tx_thread_active;</span>
<span class="p_add">+	struct task_struct	*tx_thread;</span>
 	/* list_head for session connection list */
 	struct list_head	conn_list;
 } ____cacheline_aligned;
<span class="p_chunk">@@ -872,10 +877,12 @@</span> <span class="p_context"> struct iscsit_global {</span>
 	/* Unique identifier used for the authentication daemon */
 	u32			auth_id;
 	u32			inactive_ts;
<span class="p_add">+#define ISCSIT_BITMAP_BITS	262144</span>
 	/* Thread Set bitmap count */
 	int			ts_bitmap_count;
 	/* Thread Set bitmap pointer */
 	unsigned long		*ts_bitmap;
<span class="p_add">+	spinlock_t		ts_bitmap_lock;</span>
 	/* Used for iSCSI discovery session authentication */
 	struct iscsi_node_acl	discovery_acl;
 	struct iscsi_portal_group	*discovery_tpg;
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_erl0.c b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">index 0d1e6ee3e992..7396d90d96b2 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_chunk">@@ -864,7 +864,10 @@</span> <span class="p_context"> void iscsit_connection_reinstatement_rcfr(struct iscsi_conn *conn)</span>
 	}
 	spin_unlock_bh(&amp;conn-&gt;state_lock);
 
<span class="p_del">-	iscsi_thread_set_force_reinstatement(conn);</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 sleep:
 	wait_for_completion(&amp;conn-&gt;conn_wait_rcfr_comp);
<span class="p_chunk">@@ -889,10 +892,10 @@</span> <span class="p_context"> void iscsit_cause_connection_reinstatement(struct iscsi_conn *conn, int sleep)</span>
 		return;
 	}
 
<span class="p_del">-	if (iscsi_thread_set_force_reinstatement(conn) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_bh(&amp;conn-&gt;state_lock);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 	atomic_set(&amp;conn-&gt;connection_reinstatement, 1);
 	if (!sleep) {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index dabc7e770b00..cb45313182b7 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -699,6 +699,51 @@</span> <span class="p_context"> static void iscsi_post_login_start_timers(struct iscsi_conn *conn)</span>
 		iscsit_start_nopin_timer(conn);
 }
 
<span class="p_add">+int iscsit_start_kthreads(struct iscsi_conn *conn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	conn-&gt;bitmap_id = bitmap_find_free_region(iscsit_global-&gt;ts_bitmap,</span>
<span class="p_add">+					ISCSIT_BITMAP_BITS, get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;bitmap_id &lt; 0) {</span>
<span class="p_add">+		pr_err(&quot;bitmap_find_free_region() failed for&quot;</span>
<span class="p_add">+		       &quot; iscsit_start_kthreads()\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;tx_thread = kthread_run(iscsi_target_tx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_TX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;tx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_tx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;tx_thread);</span>
<span class="p_add">+		goto out_bitmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;tx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;rx_thread = kthread_run(iscsi_target_rx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_RX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;rx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_rx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;rx_thread);</span>
<span class="p_add">+		goto out_tx;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;rx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+out_tx:</span>
<span class="p_add">+	kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+	conn-&gt;tx_thread_active = false;</span>
<span class="p_add">+out_bitmap:</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int iscsi_post_login_handler(
 	struct iscsi_np *np,
 	struct iscsi_conn *conn,
<span class="p_chunk">@@ -709,7 +754,7 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	struct se_session *se_sess = sess-&gt;se_sess;
 	struct iscsi_portal_group *tpg = sess-&gt;tpg;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
<span class="p_del">-	struct iscsi_thread_set *ts;</span>
<span class="p_add">+	int rc;</span>
 
 	iscsit_inc_conn_usage_count(conn);
 
<span class="p_chunk">@@ -724,7 +769,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	/*
 	 * SCSI Initiator -&gt; SCSI Target Port Mapping
 	 */
<span class="p_del">-	ts = iscsi_get_thread_set();</span>
 	if (!zero_tsih) {
 		iscsi_set_session_parameters(sess-&gt;sess_ops,
 				conn-&gt;param_list, 0);
<span class="p_chunk">@@ -751,9 +795,11 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 			sess-&gt;sess_ops-&gt;InitiatorName);
 		spin_unlock_bh(&amp;sess-&gt;conn_lock);
 
<span class="p_del">-		iscsi_post_login_start_timers(conn);</span>
<span class="p_add">+		rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+		if (rc)</span>
<span class="p_add">+			return rc;</span>
 
<span class="p_del">-		iscsi_activate_thread_set(conn, ts);</span>
<span class="p_add">+		iscsi_post_login_start_timers(conn);</span>
 		/*
 		 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 		 * are scheduled on the same CPU.
<span class="p_chunk">@@ -810,8 +856,11 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 		&quot; iSCSI Target Portal Group: %hu\n&quot;, tpg-&gt;nsessions, tpg-&gt;tpgt);
 	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 
<span class="p_add">+	rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
 	iscsi_post_login_start_timers(conn);
<span class="p_del">-	iscsi_activate_thread_set(conn, ts);</span>
 	/*
 	 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 	 * are scheduled on the same CPU.
<span class="p_header">diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c</span>
<span class="p_header">index 6f9f0c499813..4568dc549a63 100644</span>
<span class="p_header">--- a/drivers/target/target_core_file.c</span>
<span class="p_header">+++ b/drivers/target/target_core_file.c</span>
<span class="p_chunk">@@ -263,40 +263,32 @@</span> <span class="p_context"> static int fd_do_prot_rw(struct se_cmd *cmd, struct fd_prot *fd_prot,</span>
 	struct se_device *se_dev = cmd-&gt;se_dev;
 	struct fd_dev *dev = FD_DEV(se_dev);
 	struct file *prot_fd = dev-&gt;fd_prot_file;
<span class="p_del">-	struct scatterlist *sg;</span>
 	loff_t pos = (cmd-&gt;t_task_lba * se_dev-&gt;prot_length);
 	unsigned char *buf;
<span class="p_del">-	u32 prot_size, len, size;</span>
<span class="p_del">-	int rc, ret = 1, i;</span>
<span class="p_add">+	u32 prot_size;</span>
<span class="p_add">+	int rc, ret = 1;</span>
 
 	prot_size = (cmd-&gt;data_length / se_dev-&gt;dev_attrib.block_size) *
 		     se_dev-&gt;prot_length;
 
 	if (!is_write) {
<span class="p_del">-		fd_prot-&gt;prot_buf = vzalloc(prot_size);</span>
<span class="p_add">+		fd_prot-&gt;prot_buf = kzalloc(prot_size, GFP_KERNEL);</span>
 		if (!fd_prot-&gt;prot_buf) {
 			pr_err(&quot;Unable to allocate fd_prot-&gt;prot_buf\n&quot;);
 			return -ENOMEM;
 		}
 		buf = fd_prot-&gt;prot_buf;
 
<span class="p_del">-		fd_prot-&gt;prot_sg_nents = cmd-&gt;t_prot_nents;</span>
<span class="p_del">-		fd_prot-&gt;prot_sg = kzalloc(sizeof(struct scatterlist) *</span>
<span class="p_del">-					   fd_prot-&gt;prot_sg_nents, GFP_KERNEL);</span>
<span class="p_add">+		fd_prot-&gt;prot_sg_nents = 1;</span>
<span class="p_add">+		fd_prot-&gt;prot_sg = kzalloc(sizeof(struct scatterlist),</span>
<span class="p_add">+					   GFP_KERNEL);</span>
 		if (!fd_prot-&gt;prot_sg) {
 			pr_err(&quot;Unable to allocate fd_prot-&gt;prot_sg\n&quot;);
<span class="p_del">-			vfree(fd_prot-&gt;prot_buf);</span>
<span class="p_add">+			kfree(fd_prot-&gt;prot_buf);</span>
 			return -ENOMEM;
 		}
<span class="p_del">-		size = prot_size;</span>
<span class="p_del">-</span>
<span class="p_del">-		for_each_sg(fd_prot-&gt;prot_sg, sg, fd_prot-&gt;prot_sg_nents, i) {</span>
<span class="p_del">-</span>
<span class="p_del">-			len = min_t(u32, PAGE_SIZE, size);</span>
<span class="p_del">-			sg_set_buf(sg, buf, len);</span>
<span class="p_del">-			size -= len;</span>
<span class="p_del">-			buf += len;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		sg_init_table(fd_prot-&gt;prot_sg, fd_prot-&gt;prot_sg_nents);</span>
<span class="p_add">+		sg_set_buf(fd_prot-&gt;prot_sg, buf, prot_size);</span>
 	}
 
 	if (is_write) {
<span class="p_chunk">@@ -317,7 +309,7 @@</span> <span class="p_context"> static int fd_do_prot_rw(struct se_cmd *cmd, struct fd_prot *fd_prot,</span>
 
 	if (is_write || ret &lt; 0) {
 		kfree(fd_prot-&gt;prot_sg);
<span class="p_del">-		vfree(fd_prot-&gt;prot_buf);</span>
<span class="p_add">+		kfree(fd_prot-&gt;prot_buf);</span>
 	}
 
 	return ret;
<span class="p_chunk">@@ -543,6 +535,56 @@</span> <span class="p_context"> fd_execute_write_same(struct se_cmd *cmd)</span>
 	return 0;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+fd_do_prot_fill(struct se_device *se_dev, sector_t lba, sector_t nolb,</span>
<span class="p_add">+		void *buf, size_t bufsize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fd_dev *fd_dev = FD_DEV(se_dev);</span>
<span class="p_add">+	struct file *prot_fd = fd_dev-&gt;fd_prot_file;</span>
<span class="p_add">+	sector_t prot_length, prot;</span>
<span class="p_add">+	loff_t pos = lba * se_dev-&gt;prot_length;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!prot_fd) {</span>
<span class="p_add">+		pr_err(&quot;Unable to locate fd_dev-&gt;fd_prot_file\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	prot_length = nolb * se_dev-&gt;prot_length;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (prot = 0; prot &lt; prot_length;) {</span>
<span class="p_add">+		sector_t len = min_t(sector_t, bufsize, prot_length - prot);</span>
<span class="p_add">+		ssize_t ret = kernel_write(prot_fd, buf, len, pos + prot);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret != len) {</span>
<span class="p_add">+			pr_err(&quot;vfs_write to prot file failed: %zd\n&quot;, ret);</span>
<span class="p_add">+			return ret &lt; 0 ? ret : -ENODEV;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		prot += ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+fd_do_prot_unmap(struct se_cmd *cmd, sector_t lba, sector_t nolb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *buf;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = (void *)__get_free_page(GFP_KERNEL);</span>
<span class="p_add">+	if (!buf) {</span>
<span class="p_add">+		pr_err(&quot;Unable to allocate FILEIO prot buf\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memset(buf, 0xff, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = fd_do_prot_fill(cmd-&gt;se_dev, lba, nolb, buf, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	free_page((unsigned long)buf);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static sense_reason_t
 fd_do_unmap(struct se_cmd *cmd, void *priv, sector_t lba, sector_t nolb)
 {
<span class="p_chunk">@@ -550,6 +592,12 @@</span> <span class="p_context"> fd_do_unmap(struct se_cmd *cmd, void *priv, sector_t lba, sector_t nolb)</span>
 	struct inode *inode = file-&gt;f_mapping-&gt;host;
 	int ret;
 
<span class="p_add">+	if (cmd-&gt;se_dev-&gt;dev_attrib.pi_prot_type) {</span>
<span class="p_add">+		ret = fd_do_prot_unmap(cmd, lba, nolb);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (S_ISBLK(inode-&gt;i_mode)) {
 		/* The backend is block device, use discard */
 		struct block_device *bdev = inode-&gt;i_bdev;
<span class="p_chunk">@@ -652,11 +700,11 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 						 0, fd_prot.prot_sg, 0);
 			if (rc) {
 				kfree(fd_prot.prot_sg);
<span class="p_del">-				vfree(fd_prot.prot_buf);</span>
<span class="p_add">+				kfree(fd_prot.prot_buf);</span>
 				return rc;
 			}
 			kfree(fd_prot.prot_sg);
<span class="p_del">-			vfree(fd_prot.prot_buf);</span>
<span class="p_add">+			kfree(fd_prot.prot_buf);</span>
 		}
 	} else {
 		memset(&amp;fd_prot, 0, sizeof(struct fd_prot));
<span class="p_chunk">@@ -672,7 +720,7 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 						  0, fd_prot.prot_sg, 0);
 			if (rc) {
 				kfree(fd_prot.prot_sg);
<span class="p_del">-				vfree(fd_prot.prot_buf);</span>
<span class="p_add">+				kfree(fd_prot.prot_buf);</span>
 				return rc;
 			}
 		}
<span class="p_chunk">@@ -703,7 +751,7 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 
 	if (ret &lt; 0) {
 		kfree(fd_prot.prot_sg);
<span class="p_del">-		vfree(fd_prot.prot_buf);</span>
<span class="p_add">+		kfree(fd_prot.prot_buf);</span>
 		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 	}
 
<span class="p_chunk">@@ -865,48 +913,28 @@</span> <span class="p_context"> static int fd_init_prot(struct se_device *dev)</span>
 
 static int fd_format_prot(struct se_device *dev)
 {
<span class="p_del">-	struct fd_dev *fd_dev = FD_DEV(dev);</span>
<span class="p_del">-	struct file *prot_fd = fd_dev-&gt;fd_prot_file;</span>
<span class="p_del">-	sector_t prot_length, prot;</span>
 	unsigned char *buf;
<span class="p_del">-	loff_t pos = 0;</span>
 	int unit_size = FDBD_FORMAT_UNIT_SIZE * dev-&gt;dev_attrib.block_size;
<span class="p_del">-	int rc, ret = 0, size, len;</span>
<span class="p_add">+	int ret;</span>
 
 	if (!dev-&gt;dev_attrib.pi_prot_type) {
 		pr_err(&quot;Unable to format_prot while pi_prot_type == 0\n&quot;);
 		return -ENODEV;
 	}
<span class="p_del">-	if (!prot_fd) {</span>
<span class="p_del">-		pr_err(&quot;Unable to locate fd_dev-&gt;fd_prot_file\n&quot;);</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-	}</span>
 
 	buf = vzalloc(unit_size);
 	if (!buf) {
 		pr_err(&quot;Unable to allocate FILEIO prot buf\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_del">-	prot_length = (dev-&gt;transport-&gt;get_blocks(dev) + 1) * dev-&gt;prot_length;</span>
<span class="p_del">-	size = prot_length;</span>
 
 	pr_debug(&quot;Using FILEIO prot_length: %llu\n&quot;,
<span class="p_del">-		 (unsigned long long)prot_length);</span>
<span class="p_add">+		 (unsigned long long)(dev-&gt;transport-&gt;get_blocks(dev) + 1) *</span>
<span class="p_add">+					dev-&gt;prot_length);</span>
 
 	memset(buf, 0xff, unit_size);
<span class="p_del">-	for (prot = 0; prot &lt; prot_length; prot += unit_size) {</span>
<span class="p_del">-		len = min(unit_size, size);</span>
<span class="p_del">-		rc = kernel_write(prot_fd, buf, len, pos);</span>
<span class="p_del">-		if (rc != len) {</span>
<span class="p_del">-			pr_err(&quot;vfs_write to prot file failed: %d\n&quot;, rc);</span>
<span class="p_del">-			ret = -ENODEV;</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		pos += len;</span>
<span class="p_del">-		size -= len;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_add">+	ret = fd_do_prot_fill(dev, 0, dev-&gt;transport-&gt;get_blocks(dev) + 1,</span>
<span class="p_add">+			      buf, unit_size);</span>
 	vfree(buf);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index ccddbd1d97ed..be2a1000e3dd 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -299,7 +299,7 @@</span> <span class="p_context"> sbc_setup_write_same(struct se_cmd *cmd, unsigned char *flags, struct sbc_ops *o</span>
 	return 0;
 }
 
<span class="p_del">-static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success)</span>
 {
 	unsigned char *buf, *addr;
 	struct scatterlist *sg;
<span class="p_chunk">@@ -363,7 +363,7 @@</span> <span class="p_context"> sbc_execute_rw(struct se_cmd *cmd)</span>
 			       cmd-&gt;data_direction);
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_post(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 
<span class="p_chunk">@@ -386,7 +386,7 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd)</span>
 	return TCM_NO_SENSE;
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_callback(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 	struct scatterlist *write_sg = NULL, *sg;
<span class="p_chunk">@@ -401,11 +401,16 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_callback(struct se_cmd *cmd)</span>
 
 	/*
 	 * Handle early failure in transport_generic_request_failure(),
<span class="p_del">-	 * which will not have taken -&gt;caw_mutex yet..</span>
<span class="p_add">+	 * which will not have taken -&gt;caw_sem yet..</span>
 	 */
<span class="p_del">-	if (!cmd-&gt;t_data_sg || !cmd-&gt;t_bidi_data_sg)</span>
<span class="p_add">+	if (!success &amp;&amp; (!cmd-&gt;t_data_sg || !cmd-&gt;t_bidi_data_sg))</span>
 		return TCM_NO_SENSE;
 	/*
<span class="p_add">+	 * Handle special case for zero-length COMPARE_AND_WRITE</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!cmd-&gt;data_length)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	/*</span>
 	 * Immediately exit + release dev-&gt;caw_sem if command has already
 	 * been failed with a non-zero SCSI status.
 	 */
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 83b0d08c9d5b..b32cbb8ab5b8 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1613,11 +1613,11 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	transport_complete_task_attr(cmd);
 	/*
 	 * Handle special case for COMPARE_AND_WRITE failure, where the
<span class="p_del">-	 * callback is expected to drop the per device -&gt;caw_mutex.</span>
<span class="p_add">+	 * callback is expected to drop the per device -&gt;caw_sem.</span>
 	 */
 	if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;
 	     cmd-&gt;transport_complete_callback)
<span class="p_del">-		cmd-&gt;transport_complete_callback(cmd);</span>
<span class="p_add">+		cmd-&gt;transport_complete_callback(cmd, false);</span>
 
 	switch (sense_reason) {
 	case TCM_NON_EXISTENT_LUN:
<span class="p_chunk">@@ -1978,8 +1978,12 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 	if (cmd-&gt;transport_complete_callback) {
 		sense_reason_t rc;
 
<span class="p_del">-		rc = cmd-&gt;transport_complete_callback(cmd);</span>
<span class="p_add">+		rc = cmd-&gt;transport_complete_callback(cmd, true);</span>
 		if (!rc &amp;&amp; !(cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE_POST)) {
<span class="p_add">+			if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_add">+			    !cmd-&gt;data_length)</span>
<span class="p_add">+				goto queue_rsp;</span>
<span class="p_add">+</span>
 			return;
 		} else if (rc) {
 			ret = transport_send_check_condition_and_sense(cmd,
<span class="p_chunk">@@ -1993,6 +1997,7 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 		}
 	}
 
<span class="p_add">+queue_rsp:</span>
 	switch (cmd-&gt;data_direction) {
 	case DMA_FROM_DEVICE:
 		spin_lock(&amp;cmd-&gt;se_lun-&gt;lun_sep_lock);
<span class="p_chunk">@@ -2097,6 +2102,16 @@</span> <span class="p_context"> static inline void transport_reset_sgl_orig(struct se_cmd *cmd)</span>
 static inline void transport_free_pages(struct se_cmd *cmd)
 {
 	if (cmd-&gt;se_cmd_flags &amp; SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Release special case READ buffer payload required for</span>
<span class="p_add">+		 * SG_TO_MEM_NOALLOC to function with COMPARE_AND_WRITE</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) {</span>
<span class="p_add">+			transport_free_sgl(cmd-&gt;t_bidi_data_sg,</span>
<span class="p_add">+					   cmd-&gt;t_bidi_data_nents);</span>
<span class="p_add">+			cmd-&gt;t_bidi_data_sg = NULL;</span>
<span class="p_add">+			cmd-&gt;t_bidi_data_nents = 0;</span>
<span class="p_add">+		}</span>
 		transport_reset_sgl_orig(cmd);
 		return;
 	}
<span class="p_chunk">@@ -2249,6 +2264,7 @@</span> <span class="p_context"> sense_reason_t</span>
 transport_generic_new_cmd(struct se_cmd *cmd)
 {
 	int ret = 0;
<span class="p_add">+	bool zero_flag = !(cmd-&gt;se_cmd_flags &amp; SCF_SCSI_DATA_CDB);</span>
 
 	/*
 	 * Determine is the TCM fabric module has already allocated physical
<span class="p_chunk">@@ -2257,7 +2273,6 @@</span> <span class="p_context"> transport_generic_new_cmd(struct se_cmd *cmd)</span>
 	 */
 	if (!(cmd-&gt;se_cmd_flags &amp; SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) &amp;&amp;
 	    cmd-&gt;data_length) {
<span class="p_del">-		bool zero_flag = !(cmd-&gt;se_cmd_flags &amp; SCF_SCSI_DATA_CDB);</span>
 
 		if ((cmd-&gt;se_cmd_flags &amp; SCF_BIDI) ||
 		    (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE)) {
<span class="p_chunk">@@ -2288,6 +2303,20 @@</span> <span class="p_context"> transport_generic_new_cmd(struct se_cmd *cmd)</span>
 				       cmd-&gt;data_length, zero_flag);
 		if (ret &lt; 0)
 			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
<span class="p_add">+	} else if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_add">+		    cmd-&gt;data_length) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Special case for COMPARE_AND_WRITE with fabrics</span>
<span class="p_add">+		 * using SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u32 caw_length = cmd-&gt;t_task_nolb *</span>
<span class="p_add">+				 cmd-&gt;se_dev-&gt;dev_attrib.block_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = target_alloc_sgl(&amp;cmd-&gt;t_bidi_data_sg,</span>
<span class="p_add">+				       &amp;cmd-&gt;t_bidi_data_nents,</span>
<span class="p_add">+				       caw_length, zero_flag);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;</span>
 	}
 	/*
 	 * If this command is not a write we can execute it right here,
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index 662cbb3af586..35de4adc3f1d 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -247,8 +247,6 @@</span> <span class="p_context"> static void n_tty_write_wakeup(struct tty_struct *tty)</span>
 
 static void n_tty_check_throttle(struct tty_struct *tty)
 {
<span class="p_del">-	if (tty-&gt;driver-&gt;type == TTY_DRIVER_TYPE_PTY)</span>
<span class="p_del">-		return;</span>
 	/*
 	 * Check the remaining room for the input canonicalization
 	 * mode.  We don&#39;t want to throttle the driver if we&#39;re in
<span class="p_chunk">@@ -1512,23 +1510,6 @@</span> <span class="p_context"> n_tty_receive_char_lnext(struct tty_struct *tty, unsigned char c, char flag)</span>
 		n_tty_receive_char_flagged(tty, c, flag);
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- *	n_tty_receive_buf	-	data receive</span>
<span class="p_del">- *	@tty: terminal device</span>
<span class="p_del">- *	@cp: buffer</span>
<span class="p_del">- *	@fp: flag buffer</span>
<span class="p_del">- *	@count: characters</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Called by the terminal driver when a block of characters has</span>
<span class="p_del">- *	been received. This function must be called from soft contexts</span>
<span class="p_del">- *	not from interrupt context. The driver is responsible for making</span>
<span class="p_del">- *	calls one at a time and in order (or using flush_to_ldisc)</span>
<span class="p_del">- *</span>
<span class="p_del">- *	n_tty_receive_buf()/producer path:</span>
<span class="p_del">- *		claims non-exclusive termios_rwsem</span>
<span class="p_del">- *		publishes read_head and canon_head</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
 static void
 n_tty_receive_buf_real_raw(struct tty_struct *tty, const unsigned char *cp,
 			   char *fp, int count)
<span class="p_chunk">@@ -1684,24 +1665,85 @@</span> <span class="p_context"> static void __receive_buf(struct tty_struct *tty, const unsigned char *cp,</span>
 	}
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ *	n_tty_receive_buf_common	-	process input</span>
<span class="p_add">+ *	@tty: device to receive input</span>
<span class="p_add">+ *	@cp: input chars</span>
<span class="p_add">+ *	@fp: flags for each char (if NULL, all chars are TTY_NORMAL)</span>
<span class="p_add">+ *	@count: number of input chars in @cp</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Called by the terminal driver when a block of characters has</span>
<span class="p_add">+ *	been received. This function must be called from soft contexts</span>
<span class="p_add">+ *	not from interrupt context. The driver is responsible for making</span>
<span class="p_add">+ *	calls one at a time and in order (or using flush_to_ldisc)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Returns the # of input chars from @cp which were processed.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	In canonical mode, the maximum line length is 4096 chars (including</span>
<span class="p_add">+ *	the line termination char); lines longer than 4096 chars are</span>
<span class="p_add">+ *	truncated. After 4095 chars, input data is still processed but</span>
<span class="p_add">+ *	not stored. Overflow processing ensures the tty can always</span>
<span class="p_add">+ *	receive more input until at least one line can be read.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	In non-canonical mode, the read buffer will only accept 4095 chars;</span>
<span class="p_add">+ *	this provides the necessary space for a newline char if the input</span>
<span class="p_add">+ *	mode is switched to canonical.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Note it is possible for the read buffer to _contain_ 4096 chars</span>
<span class="p_add">+ *	in non-canonical mode: the read buffer could already contain the</span>
<span class="p_add">+ *	maximum canon line of 4096 chars when the mode is switched to</span>
<span class="p_add">+ *	non-canonical.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	n_tty_receive_buf()/producer path:</span>
<span class="p_add">+ *		claims non-exclusive termios_rwsem</span>
<span class="p_add">+ *		publishes commit_head or canon_head</span>
<span class="p_add">+ */</span>
 static int
 n_tty_receive_buf_common(struct tty_struct *tty, const unsigned char *cp,
 			 char *fp, int count, int flow)
 {
 	struct n_tty_data *ldata = tty-&gt;disc_data;
<span class="p_del">-	int room, n, rcvd = 0;</span>
<span class="p_add">+	int room, n, rcvd = 0, overflow;</span>
 
 	down_read(&amp;tty-&gt;termios_rwsem);
 
 	while (1) {
<span class="p_del">-		room = receive_room(tty);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * When PARMRK is set, each input char may take up to 3 chars</span>
<span class="p_add">+		 * in the read buf; reduce the buffer space avail by 3x</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * If we are doing input canonicalization, and there are no</span>
<span class="p_add">+		 * pending newlines, let characters through without limit, so</span>
<span class="p_add">+		 * that erase characters will be handled.  Other excess</span>
<span class="p_add">+		 * characters will be beeped.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * paired with store in *_copy_from_read_buf() -- guarantees</span>
<span class="p_add">+		 * the consumer has loaded the data in read_buf up to the new</span>
<span class="p_add">+		 * read_tail (so this producer will not overwrite unread data)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		size_t tail = ldata-&gt;read_tail;</span>
<span class="p_add">+</span>
<span class="p_add">+		room = N_TTY_BUF_SIZE - (ldata-&gt;read_head - tail);</span>
<span class="p_add">+		if (I_PARMRK(tty))</span>
<span class="p_add">+			room = (room + 2) / 3;</span>
<span class="p_add">+		room--;</span>
<span class="p_add">+		if (room &lt;= 0) {</span>
<span class="p_add">+			overflow = ldata-&gt;icanon &amp;&amp; ldata-&gt;canon_head == tail;</span>
<span class="p_add">+			if (overflow &amp;&amp; room &lt; 0)</span>
<span class="p_add">+				ldata-&gt;read_head--;</span>
<span class="p_add">+			room = overflow;</span>
<span class="p_add">+			ldata-&gt;no_room = flow &amp;&amp; !room;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			overflow = 0;</span>
<span class="p_add">+</span>
 		n = min(count, room);
<span class="p_del">-		if (!n) {</span>
<span class="p_del">-			if (flow &amp;&amp; !room)</span>
<span class="p_del">-				ldata-&gt;no_room = 1;</span>
<span class="p_add">+		if (!n)</span>
 			break;
<span class="p_del">-		}</span>
<span class="p_del">-		__receive_buf(tty, cp, fp, n);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* ignore parity errors if handling overflow */</span>
<span class="p_add">+		if (!overflow || !fp || *fp != TTY_PARITY)</span>
<span class="p_add">+			__receive_buf(tty, cp, fp, n);</span>
<span class="p_add">+</span>
 		cp += n;
 		if (fp)
 			fp += n;
<span class="p_chunk">@@ -1710,7 +1752,17 @@</span> <span class="p_context"> n_tty_receive_buf_common(struct tty_struct *tty, const unsigned char *cp,</span>
 	}
 
 	tty-&gt;receive_room = room;
<span class="p_del">-	n_tty_check_throttle(tty);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Unthrottle if handling overflow on pty */</span>
<span class="p_add">+	if (tty-&gt;driver-&gt;type == TTY_DRIVER_TYPE_PTY) {</span>
<span class="p_add">+		if (overflow) {</span>
<span class="p_add">+			tty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);</span>
<span class="p_add">+			tty_unthrottle_safe(tty);</span>
<span class="p_add">+			__tty_set_flow_change(tty, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		n_tty_check_throttle(tty);</span>
<span class="p_add">+</span>
 	up_read(&amp;tty-&gt;termios_rwsem);
 
 	return rcvd;
<span class="p_header">diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">index a051a7a2b1bd..a81f9dd7ee97 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 	case USB_CDC_NOTIFY_RESPONSE_AVAILABLE:
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev,
 			&quot;NOTIFY_RESPONSE_AVAILABLE received: index %d len %d&quot;,
<span class="p_del">-			dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex), le16_to_cpu(dr-&gt;wLength));</span>
 		break;
 
 	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
<span class="p_chunk">@@ -262,7 +262,9 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 		clear_bit(WDM_POLL_RUNNING, &amp;desc-&gt;flags);
 		dev_err(&amp;desc-&gt;intf-&gt;dev,
 			&quot;unknown notification %d received: index %d len %d\n&quot;,
<span class="p_del">-			dr-&gt;bNotificationType, dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			dr-&gt;bNotificationType,</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex),</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wLength));</span>
 		goto exit;
 	}
 
<span class="p_chunk">@@ -408,7 +410,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 			     USB_RECIP_INTERFACE);
 	req-&gt;bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;
 	req-&gt;wValue = 0;
<span class="p_del">-	req-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	req-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	req-&gt;wLength = cpu_to_le16(count);
 	set_bit(WDM_IN_USE, &amp;desc-&gt;flags);
 	desc-&gt;outbuf = buf;
<span class="p_chunk">@@ -422,7 +424,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 		rv = usb_translate_errors(rv);
 	} else {
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev, &quot;Tx URB has been submitted index=%d&quot;,
<span class="p_del">-			req-&gt;wIndex);</span>
<span class="p_add">+			le16_to_cpu(req-&gt;wIndex));</span>
 	}
 out:
 	usb_autopm_put_interface(desc-&gt;intf);
<span class="p_chunk">@@ -820,7 +822,7 @@</span> <span class="p_context"> static int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor</span>
 	desc-&gt;irq-&gt;bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
 	desc-&gt;irq-&gt;bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
 	desc-&gt;irq-&gt;wValue = 0;
<span class="p_del">-	desc-&gt;irq-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	desc-&gt;irq-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	desc-&gt;irq-&gt;wLength = cpu_to_le16(desc-&gt;wMaxCommand);
 
 	usb_fill_control_urb(
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 0e0e0354c523..4209fc7d91c6 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -3375,10 +3375,10 @@</span> <span class="p_context"> int usb_port_resume(struct usb_device *udev, pm_message_t msg)</span>
 	if (status) {
 		dev_dbg(&amp;port_dev-&gt;dev, &quot;can&#39;t resume, status %d\n&quot;, status);
 	} else {
<span class="p_del">-		/* drive resume for at least 20 msec */</span>
<span class="p_add">+		/* drive resume for USB_RESUME_TIMEOUT msec */</span>
 		dev_dbg(&amp;udev-&gt;dev, &quot;usb %sresume\n&quot;,
 				(PMSG_IS_AUTO(msg) ? &quot;auto-&quot; : &quot;&quot;));
<span class="p_del">-		msleep(25);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
<span class="p_header">diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c</span>
<span class="p_header">index 4d918ed8d343..0f9980088c08 100644</span>
<span class="p_header">--- a/drivers/usb/dwc2/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/dwc2/hcd.c</span>
<span class="p_chunk">@@ -1501,7 +1501,7 @@</span> <span class="p_context"> static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,</span>
 			dev_dbg(hsotg-&gt;dev,
 				&quot;ClearPortFeature USB_PORT_FEAT_SUSPEND\n&quot;);
 			writel(0, hsotg-&gt;regs + PCGCTL);
<span class="p_del">-			usleep_range(20000, 40000);</span>
<span class="p_add">+			msleep(USB_RESUME_TIMEOUT);</span>
 
 			hprt0 = dwc2_read_hprt0(hsotg);
 			hprt0 |= HPRT0_RES;
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index f80151932053..9536b6abf65b 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -560,7 +560,7 @@</span> <span class="p_context"> static int bos_desc(struct usb_composite_dev *cdev)</span>
 	usb_ext-&gt;bLength = USB_DT_USB_EXT_CAP_SIZE;
 	usb_ext-&gt;bDescriptorType = USB_DT_DEVICE_CAPABILITY;
 	usb_ext-&gt;bDevCapabilityType = USB_CAP_TYPE_EXT;
<span class="p_del">-	usb_ext-&gt;bmAttributes = cpu_to_le32(USB_LPM_SUPPORT);</span>
<span class="p_add">+	usb_ext-&gt;bmAttributes = cpu_to_le32(USB_LPM_SUPPORT | USB_BESL_SUPPORT);</span>
 
 	/*
 	 * The Superspeed USB Capability descriptor shall be implemented by all
<span class="p_header">diff --git a/drivers/usb/gadget/printer.c b/drivers/usb/gadget/printer.c</span>
<span class="p_header">index 6474081dcbaf..c9c6dae75c13 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/printer.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/printer.c</span>
<span class="p_chunk">@@ -980,6 +980,15 @@</span> <span class="p_context"> unknown:</span>
 		break;
 	}
 	/* host either stalls (value &lt; 0) or reports success */
<span class="p_add">+	if (value &gt;= 0) {</span>
<span class="p_add">+		req-&gt;length = value;</span>
<span class="p_add">+		req-&gt;zero = value &lt; wLength;</span>
<span class="p_add">+		value = usb_ep_queue(cdev-&gt;gadget-&gt;ep0, req, GFP_ATOMIC);</span>
<span class="p_add">+		if (value &lt; 0) {</span>
<span class="p_add">+			ERROR(dev, &quot;%s:%d Error!\n&quot;, __func__, __LINE__);</span>
<span class="p_add">+			req-&gt;status = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	return value;
 }
 
<span class="p_header">diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">index 488a30836c36..03d334172ed9 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_chunk">@@ -787,12 +787,12 @@</span> <span class="p_context"> static irqreturn_t ehci_irq (struct usb_hcd *hcd)</span>
 					ehci-&gt;reset_done[i] == 0))
 				continue;
 
<span class="p_del">-			/* start 20 msec resume signaling from this port,</span>
<span class="p_del">-			 * and make khubd collect PORT_STAT_C_SUSPEND to</span>
<span class="p_del">-			 * stop that signaling.  Use 5 ms extra for safety,</span>
<span class="p_del">-			 * like usb_port_resume() does.</span>
<span class="p_add">+			/* start USB_RESUME_TIMEOUT msec resume signaling from</span>
<span class="p_add">+			 * this port, and make khubd collect</span>
<span class="p_add">+			 * PORT_STAT_C_SUSPEND to stop that signaling.</span>
 			 */
<span class="p_del">-			ehci-&gt;reset_done[i] = jiffies + msecs_to_jiffies(25);</span>
<span class="p_add">+			ehci-&gt;reset_done[i] = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(i, &amp;ehci-&gt;resuming_ports);
 			ehci_dbg (ehci, &quot;port %d remote wakeup\n&quot;, i + 1);
 			usb_hcd_start_port_resume(&amp;hcd-&gt;self, i);
<span class="p_header">diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c</span>
<span class="p_header">index 6130b7574908..837a1edd33e2 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-hub.c</span>
<span class="p_chunk">@@ -473,10 +473,13 @@</span> <span class="p_context"> static int ehci_bus_resume (struct usb_hcd *hcd)</span>
 		ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
 	}
 
<span class="p_del">-	/* msleep for 20ms only if code is trying to resume port */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * msleep for USB_RESUME_TIMEOUT ms only if code is trying to resume</span>
<span class="p_add">+	 * port</span>
<span class="p_add">+	 */</span>
 	if (resume_needed) {
 		spin_unlock_irq(&amp;ehci-&gt;lock);
<span class="p_del">-		msleep(20);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 		spin_lock_irq(&amp;ehci-&gt;lock);
 		if (ehci-&gt;shutdown)
 			goto shutdown;
<span class="p_chunk">@@ -944,7 +947,7 @@</span> <span class="p_context"> int ehci_hub_control(</span>
 			temp &amp;= ~PORT_WAKE_BITS;
 			ehci_writel(ehci, temp | PORT_RESUME, status_reg);
 			ehci-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 			usb_hcd_start_port_resume(&amp;hcd-&gt;self, wIndex);
 			break;
<span class="p_header">diff --git a/drivers/usb/host/fotg210-hcd.c b/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_header">index 98a89d16cc3e..8aa4ba0a0c69 100644</span>
<span class="p_header">--- a/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_chunk">@@ -1595,7 +1595,7 @@</span> <span class="p_context"> static int fotg210_hub_control(</span>
 			/* resume signaling for 20 msec */
 			fotg210_writel(fotg210, temp | PORT_RESUME, status_reg);
 			fotg210-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;fotg210-&gt;port_c_suspend);
<span class="p_header">diff --git a/drivers/usb/host/fusbh200-hcd.c b/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_header">index ba9499060f63..3e3926aa584e 100644</span>
<span class="p_header">--- a/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_chunk">@@ -1550,10 +1550,9 @@</span> <span class="p_context"> static int fusbh200_hub_control (</span>
 			if ((temp &amp; PORT_PE) == 0)
 				goto error;
 
<span class="p_del">-			/* resume signaling for 20 msec */</span>
 			fusbh200_writel(fusbh200, temp | PORT_RESUME, status_reg);
 			fusbh200-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;fusbh200-&gt;port_c_suspend);
<span class="p_header">diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">index 240e792c81a7..b62298fe0be8 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_chunk">@@ -1487,7 +1487,7 @@</span> <span class="p_context"> static int isp116x_bus_resume(struct usb_hcd *hcd)</span>
 	spin_unlock_irq(&amp;isp116x-&gt;lock);
 
 	hcd-&gt;state = HC_STATE_RESUMING;
<span class="p_del">-	msleep(20);</span>
<span class="p_add">+	msleep(USB_RESUME_TIMEOUT);</span>
 
 	/* Go operational */
 	spin_lock_irq(&amp;isp116x-&gt;lock);
<span class="p_header">diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">index 5ea7c6bdfd28..6295b353bb65 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_chunk">@@ -1895,7 +1895,7 @@</span> <span class="p_context"> static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,</span>
 				reg_write32(hcd-&gt;regs, HC_PORTSC1,
 							temp | PORT_RESUME);
 				priv-&gt;reset_done = jiffies +
<span class="p_del">-					msecs_to_jiffies(20);</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			}
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
<span class="p_header">diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c</span>
<span class="p_header">index e07248b6ab67..8a0158667166 100644</span>
<span class="p_header">--- a/drivers/usb/host/oxu210hp-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/oxu210hp-hcd.c</span>
<span class="p_chunk">@@ -2500,11 +2500,12 @@</span> <span class="p_context"> static irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)</span>
 					|| oxu-&gt;reset_done[i] != 0)
 				continue;
 
<span class="p_del">-			/* start 20 msec resume signaling from this port,</span>
<span class="p_del">-			 * and make khubd collect PORT_STAT_C_SUSPEND to</span>
<span class="p_add">+			/* start USB_RESUME_TIMEOUT resume signaling from this</span>
<span class="p_add">+			 * port, and make khubd collect PORT_STAT_C_SUSPEND to</span>
 			 * stop that signaling.
 			 */
<span class="p_del">-			oxu-&gt;reset_done[i] = jiffies + msecs_to_jiffies(20);</span>
<span class="p_add">+			oxu-&gt;reset_done[i] = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			oxu_dbg(oxu, &quot;port %d remote wakeup\n&quot;, i + 1);
 			mod_timer(&amp;hcd-&gt;rh_timer, oxu-&gt;reset_done[i]);
 		}
<span class="p_header">diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">index 110b4b9ebeaa..f130bb2f7bbe 100644</span>
<span class="p_header">--- a/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_chunk">@@ -2300,7 +2300,7 @@</span> <span class="p_context"> static int r8a66597_bus_resume(struct usb_hcd *hcd)</span>
 		rh-&gt;port &amp;= ~USB_PORT_STAT_SUSPEND;
 		rh-&gt;port |= USB_PORT_STAT_C_SUSPEND &lt;&lt; 16;
 		r8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);
<span class="p_del">-		msleep(50);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 		r8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);
 	}
 
<span class="p_header">diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">index a517151867af..0f53cc8c8ecf 100644</span>
<span class="p_header">--- a/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_chunk">@@ -1259,7 +1259,7 @@</span> <span class="p_context"> sl811h_hub_control(</span>
 			sl811_write(sl811, SL11H_CTLREG1, sl811-&gt;ctrl1);
 
 			mod_timer(&amp;sl811-&gt;timer, jiffies
<span class="p_del">-					+ msecs_to_jiffies(20));</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT));</span>
 			break;
 		case USB_PORT_FEAT_POWER:
 			port_power(sl811, 0);
<span class="p_header">diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c</span>
<span class="p_header">index 93e17b12fb33..98c66d88ebde 100644</span>
<span class="p_header">--- a/drivers/usb/host/uhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/uhci-hub.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static void uhci_check_ports(struct uhci_hcd *uhci)</span>
 				/* Port received a wakeup request */
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
<span class="p_del">-						msecs_to_jiffies(25);</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 				usb_hcd_start_port_resume(
 						&amp;uhci_to_hcd(uhci)-&gt;self, port);
 
<span class="p_chunk">@@ -337,7 +337,8 @@</span> <span class="p_context"> static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 			uhci_finish_suspend(uhci, port, port_addr);
 
 			/* USB v2.0 7.1.7.5 */
<span class="p_del">-			uhci-&gt;ports_timeout = jiffies + msecs_to_jiffies(50);</span>
<span class="p_add">+			uhci-&gt;ports_timeout = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_POWER:
 			/* UHCI has no power switching */
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 5e4e1d1d7de7..f176280e2fcf 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1611,7 +1611,7 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 		} else {
 			xhci_dbg(xhci, &quot;resume HS port %d\n&quot;, port_id);
 			bus_state-&gt;resume_done[faked_port_index] = jiffies +
<span class="p_del">-				msecs_to_jiffies(20);</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(faked_port_index, &amp;bus_state-&gt;resuming_ports);
 			mod_timer(&amp;hcd-&gt;rh_timer,
 				  bus_state-&gt;resume_done[faked_port_index]);
<span class="p_header">diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c</span>
<span class="p_header">index a9ac102ee7a0..e2c34c83f409 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_core.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_core.c</span>
<span class="p_chunk">@@ -99,6 +99,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/io.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
<span class="p_add">+#include &lt;linux/usb.h&gt;</span>
 
 #include &quot;musb_core.h&quot;
 
<span class="p_chunk">@@ -477,10 +478,10 @@</span> <span class="p_context"> static irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,</span>
 						(USB_PORT_STAT_C_SUSPEND &lt;&lt; 16)
 						| MUSB_PORT_STAT_RESUME;
 				musb-&gt;rh_timer = jiffies
<span class="p_del">-						 + msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 				schedule_delayed_work(
 					&amp;musb-&gt;finish_resume_work,
<span class="p_del">-					msecs_to_jiffies(20));</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT));</span>
 
 				musb-&gt;xceiv-&gt;state = OTG_STATE_A_HOST;
 				musb-&gt;is_active = 1;
<span class="p_chunk">@@ -1520,16 +1521,30 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 		(devctl &amp; MUSB_DEVCTL_HM) ? &quot;host&quot; : &quot;peripheral&quot;,
 		musb-&gt;int_usb, musb-&gt;int_tx, musb-&gt;int_rx);
 
<span class="p_del">-	/* the core can interrupt us for multiple reasons; docs have</span>
<span class="p_del">-	 * a generic interrupt flowchart to follow</span>
<span class="p_add">+	/**</span>
<span class="p_add">+	 * According to Mentor Graphics&#39; documentation, flowchart on page 98,</span>
<span class="p_add">+	 * IRQ should be handled as follows:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * . Resume IRQ</span>
<span class="p_add">+	 * . Session Request IRQ</span>
<span class="p_add">+	 * . VBUS Error IRQ</span>
<span class="p_add">+	 * . Suspend IRQ</span>
<span class="p_add">+	 * . Connect IRQ</span>
<span class="p_add">+	 * . Disconnect IRQ</span>
<span class="p_add">+	 * . Reset/Babble IRQ</span>
<span class="p_add">+	 * . SOF IRQ (we&#39;re not using this one)</span>
<span class="p_add">+	 * . Endpoint 0 IRQ</span>
<span class="p_add">+	 * . TX Endpoints</span>
<span class="p_add">+	 * . RX Endpoints</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We will be following that flowchart in order to avoid any problems</span>
<span class="p_add">+	 * that might arise with internal Finite State Machine.</span>
 	 */
<span class="p_add">+</span>
 	if (musb-&gt;int_usb)
 		retval |= musb_stage0_irq(musb, musb-&gt;int_usb,
 				devctl);
 
<span class="p_del">-	/* &quot;stage 1&quot; is handling endpoint irqs */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* handle endpoint 0 first */</span>
 	if (musb-&gt;int_tx &amp; 1) {
 		if (devctl &amp; MUSB_DEVCTL_HM)
 			retval |= musb_h_ep0_irq(musb);
<span class="p_chunk">@@ -1537,37 +1552,31 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 			retval |= musb_g_ep0_irq(musb);
 	}
 
<span class="p_del">-	/* RX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval = ep-&gt;rx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (devctl &amp; MUSB_DEVCTL_HM)
<span class="p_del">-				musb_host_rx(musb, ep_num);</span>
<span class="p_add">+				musb_host_tx(musb, ep_num);</span>
 			else
<span class="p_del">-				musb_g_rx(musb, ep_num);</span>
<span class="p_add">+				musb_g_tx(musb, ep_num);</span>
 		}
<span class="p_del">-</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
 
<span class="p_del">-	/* TX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval |= ep-&gt;tx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (devctl &amp; MUSB_DEVCTL_HM)
<span class="p_del">-				musb_host_tx(musb, ep_num);</span>
<span class="p_add">+				musb_host_rx(musb, ep_num);</span>
 			else
<span class="p_del">-				musb_g_tx(musb, ep_num);</span>
<span class="p_add">+				musb_g_rx(musb, ep_num);</span>
 		}
<span class="p_add">+</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
<span class="p_header">diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">index e2d2d8c9891b..0241a3a0d63e 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> void musb_port_suspend(struct musb *musb, bool do_suspend)</span>
 		/* later, GetPortStatus will stop RESUME signaling */
 		musb-&gt;port1_status |= MUSB_PORT_STAT_RESUME;
 		schedule_delayed_work(&amp;musb-&gt;finish_resume_work,
<span class="p_del">-				      msecs_to_jiffies(20));</span>
<span class="p_add">+				      msecs_to_jiffies(USB_RESUME_TIMEOUT));</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/usb/phy/phy.c b/drivers/usb/phy/phy.c</span>
<span class="p_header">index fd0d7f122ace..1abe16acc828 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy.c</span>
<span class="p_chunk">@@ -78,7 +78,9 @@</span> <span class="p_context"> static void devm_usb_phy_release(struct device *dev, void *res)</span>
 
 static int devm_usb_phy_match(struct device *dev, void *res, void *match_data)
 {
<span class="p_del">-	return res == match_data;</span>
<span class="p_add">+	struct usb_phy **phy = res;</span>
<span class="p_add">+</span>
<span class="p_add">+	return *phy == match_data;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/usb/serial/generic.c b/drivers/usb/serial/generic.c</span>
<span class="p_header">index 904ab353ecf2..c44b911937e8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/generic.c</span>
<span class="p_header">+++ b/drivers/usb/serial/generic.c</span>
<span class="p_chunk">@@ -374,7 +374,7 @@</span> <span class="p_context"> void usb_serial_generic_read_bulk_callback(struct urb *urb)</span>
 							__func__, urb-&gt;status);
 		return;
 	default:
<span class="p_del">-		dev_err(&amp;port-&gt;dev, &quot;%s - nonzero urb status: %d\n&quot;,</span>
<span class="p_add">+		dev_dbg(&amp;port-&gt;dev, &quot;%s - nonzero urb status: %d\n&quot;,</span>
 							__func__, urb-&gt;status);
 		goto resubmit;
 	}
<span class="p_header">diff --git a/drivers/usb/storage/uas-detect.h b/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">index 8a6f371ed6e7..9893d696fc97 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">+++ b/drivers/usb/storage/uas-detect.h</span>
<span class="p_chunk">@@ -69,16 +69,39 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 		return 0;
 
 	/*
<span class="p_del">-	 * ASM1051 and older ASM1053 devices have the same usb-id, and UAS is</span>
<span class="p_del">-	 * broken on the ASM1051, use the number of streams to differentiate.</span>
<span class="p_del">-	 * New ASM1053-s also support 32 streams, but have a different prod-id.</span>
<span class="p_add">+	 * ASMedia has a number of usb3 to sata bridge chips, at the time of</span>
<span class="p_add">+	 * this writing the following versions exist:</span>
<span class="p_add">+	 * ASM1051 - no uas support version</span>
<span class="p_add">+	 * ASM1051 - with broken (*) uas support</span>
<span class="p_add">+	 * ASM1053 - with working uas support</span>
<span class="p_add">+	 * ASM1153 - with working uas support</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Devices with these chips re-use a number of device-ids over the</span>
<span class="p_add">+	 * entire line, so the device-id is useless to determine if we&#39;re</span>
<span class="p_add">+	 * dealing with an ASM1051 (which we want to avoid).</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The ASM1153 can be identified by config.MaxPower == 0,</span>
<span class="p_add">+	 * where as the ASM105x models have config.MaxPower == 36.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Differentiating between the ASM1053 and ASM1051 is trickier, when</span>
<span class="p_add">+	 * connected over USB-3 we can look at the number of streams supported,</span>
<span class="p_add">+	 * ASM1051 supports 32 streams, where as early ASM1053 versions support</span>
<span class="p_add">+	 * 16 streams, newer ASM1053-s also support 32 streams, but have a</span>
<span class="p_add">+	 * different prod-id.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * (*) ASM1051 chips do work with UAS with some disks (with the</span>
<span class="p_add">+	 *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks</span>
 	 */
 	if (le16_to_cpu(udev-&gt;descriptor.idVendor) == 0x174c &amp;&amp;
<span class="p_del">-			le16_to_cpu(udev-&gt;descriptor.idProduct) == 0x55aa) {</span>
<span class="p_del">-		if (udev-&gt;speed &lt; USB_SPEED_SUPER) {</span>
<span class="p_add">+			(le16_to_cpu(udev-&gt;descriptor.idProduct) == 0x5106 ||</span>
<span class="p_add">+			 le16_to_cpu(udev-&gt;descriptor.idProduct) == 0x55aa)) {</span>
<span class="p_add">+		if (udev-&gt;actconfig-&gt;desc.bMaxPower == 0) {</span>
<span class="p_add">+			/* ASM1153, do nothing */</span>
<span class="p_add">+		} else if (udev-&gt;speed &lt; USB_SPEED_SUPER) {</span>
 			/* No streams info, assume ASM1051 */
 			flags |= US_FL_IGNORE_UAS;
 		} else if (usb_ss_max_streams(&amp;eps[1]-&gt;ss_ep_comp) == 32) {
<span class="p_add">+			/* Possibly an ASM1051, disable uas */</span>
 			flags |= US_FL_IGNORE_UAS;
 		}
 	}
<span class="p_header">diff --git a/drivers/usb/storage/unusual_uas.h b/drivers/usb/storage/unusual_uas.h</span>
<span class="p_header">index cd4ba61330c8..30ec9be3b198 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_uas.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_uas.h</span>
<span class="p_chunk">@@ -124,14 +124,6 @@</span> <span class="p_context"> UNUSUAL_DEV(0x152d, 0x0567, 0x0000, 0x9999,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_NO_REPORT_OPCODES),
 
<span class="p_del">-/* Most ASM1051 based devices have issues with uas, blacklist them all */</span>
<span class="p_del">-/* Reported-by: Hans de Goede &lt;hdegoede@redhat.com&gt; */</span>
<span class="p_del">-UNUSUAL_DEV(0x174c, 0x5106, 0x0000, 0x9999,</span>
<span class="p_del">-		&quot;ASMedia&quot;,</span>
<span class="p_del">-		&quot;ASM1051&quot;,</span>
<span class="p_del">-		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_del">-		US_FL_IGNORE_UAS),</span>
<span class="p_del">-</span>
 /* Reported-by: Hans de Goede &lt;hdegoede@redhat.com&gt; */
 UNUSUAL_DEV(0x2109, 0x0711, 0x0000, 0x9999,
 		&quot;VIA&quot;,
<span class="p_header">diff --git a/firmware/ihex2fw.c b/firmware/ihex2fw.c</span>
<span class="p_header">index cf38e159131a..08d90e25abf0 100644</span>
<span class="p_header">--- a/firmware/ihex2fw.c</span>
<span class="p_header">+++ b/firmware/ihex2fw.c</span>
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> int main(int argc, char **argv)</span>
 		case &#39;j&#39;:
 			include_jump = 1;
 			break;
<span class="p_add">+		default:</span>
 			return usage();
 		}
 	}
<span class="p_header">diff --git a/fs/aio.c b/fs/aio.c</span>
<span class="p_header">index b645387b6d57..a6f86dae34be 100644</span>
<span class="p_header">--- a/fs/aio.c</span>
<span class="p_header">+++ b/fs/aio.c</span>
<span class="p_chunk">@@ -719,6 +719,9 @@</span> <span class="p_context"> static struct kioctx *ioctx_alloc(unsigned nr_events)</span>
 err_cleanup:
 	aio_nr_sub(ctx-&gt;max_reqs);
 err_ctx:
<span class="p_add">+	atomic_set(&amp;ctx-&gt;dead, 1);</span>
<span class="p_add">+	if (ctx-&gt;mmap_size)</span>
<span class="p_add">+		vm_munmap(ctx-&gt;mmap_base, ctx-&gt;mmap_size);</span>
 	aio_free_ring(ctx);
 err:
 	mutex_unlock(&amp;ctx-&gt;ring_lock);
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index c10fc70e4912..44bdf7b200c3 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -752,6 +752,7 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 	    i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) {
 		int elf_prot = 0, elf_flags;
 		unsigned long k, vaddr;
<span class="p_add">+		unsigned long total_size = 0;</span>
 
 		if (elf_ppnt-&gt;p_type != PT_LOAD)
 			continue;
<span class="p_chunk">@@ -816,10 +817,16 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 #else
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
 #endif
<span class="p_add">+			total_size = total_mapping_size(elf_phdata,</span>
<span class="p_add">+							loc-&gt;elf_ex.e_phnum);</span>
<span class="p_add">+			if (!total_size) {</span>
<span class="p_add">+				error = -EINVAL;</span>
<span class="p_add">+				goto out_free_dentry;</span>
<span class="p_add">+			}</span>
 		}
 
 		error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,
<span class="p_del">-				elf_prot, elf_flags, 0);</span>
<span class="p_add">+				elf_prot, elf_flags, total_size);</span>
 		if (BAD_ADDR(error)) {
 			send_sig(SIGKILL, current, 0);
 			retval = IS_ERR((void *)error) ?
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 58f014a2bba1..b6f19735d6a8 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -6971,12 +6971,11 @@</span> <span class="p_context"> static int __btrfs_free_reserved_extent(struct btrfs_root *root,</span>
 		return -ENOSPC;
 	}
 
<span class="p_del">-	if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_del">-		ret = btrfs_discard_extent(root, start, len, NULL);</span>
<span class="p_del">-</span>
 	if (pin)
 		pin_down_extent(root, cache, start, len, 1);
 	else {
<span class="p_add">+		if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_add">+			ret = btrfs_discard_extent(root, start, len, NULL);</span>
 		btrfs_add_free_space(cache, start, len);
 		btrfs_update_reserved_bytes(cache, len, RESERVE_FREE, delalloc);
 	}
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 4e395f3f251d..5576abb92a23 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2941,6 +2941,9 @@</span> <span class="p_context"> static int btrfs_extent_same(struct inode *src, u64 loff, u64 len,</span>
 	if (src == dst)
 		return -EINVAL;
 
<span class="p_add">+	if (len == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	btrfs_double_lock(src, loff, dst, dst_loff, len);
 
 	ret = extent_same_check_offsets(src, loff, len);
<span class="p_chunk">@@ -3669,6 +3672,11 @@</span> <span class="p_context"> static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,</span>
 	if (off + len == src-&gt;i_size)
 		len = ALIGN(src-&gt;i_size, bs) - off;
 
<span class="p_add">+	if (len == 0) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* verify the end result is block aligned */
 	if (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||
 	    !IS_ALIGNED(destoff, bs))
<span class="p_header">diff --git a/fs/btrfs/xattr.c b/fs/btrfs/xattr.c</span>
<span class="p_header">index 7b29ee23b4ad..618e86ceede7 100644</span>
<span class="p_header">--- a/fs/btrfs/xattr.c</span>
<span class="p_header">+++ b/fs/btrfs/xattr.c</span>
<span class="p_chunk">@@ -360,22 +360,42 @@</span> <span class="p_context"> const struct xattr_handler *btrfs_xattr_handlers[] = {</span>
 /*
  * Check if the attribute is in a supported namespace.
  *
<span class="p_del">- * This applied after the check for the synthetic attributes in the system</span>
<span class="p_add">+ * This is applied after the check for the synthetic attributes in the system</span>
  * namespace.
  */
<span class="p_del">-static bool btrfs_is_valid_xattr(const char *name)</span>
<span class="p_add">+static int btrfs_is_valid_xattr(const char *name)</span>
 {
<span class="p_del">-	return !strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_del">-			XATTR_SECURITY_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||</span>
<span class="p_del">-		!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);</span>
<span class="p_add">+	int len = strlen(name);</span>
<span class="p_add">+	int prefixlen = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_add">+			XATTR_SECURITY_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SECURITY_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SYSTEM_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_TRUSTED_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_USER_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_BTRFS_PREFIX_LEN;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The name cannot consist of just prefix</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (len &lt;= prefixlen)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,
 		       void *buffer, size_t size)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	/*
 	 * If this is a request for a synthetic attribute in the system.*
 	 * namespace use the generic infrastructure to resolve a handler
<span class="p_chunk">@@ -384,8 +404,9 @@</span> <span class="p_context"> ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_getxattr(dentry, name, buffer, size);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	return __btrfs_getxattr(dentry-&gt;d_inode, name, buffer, size);
 }
 
<span class="p_chunk">@@ -393,6 +414,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 		   size_t size, int flags)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -409,8 +431,9 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_setxattr(dentry, name, value, size, flags);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))
 		return btrfs_set_prop(dentry-&gt;d_inode, name,
<span class="p_chunk">@@ -426,6 +449,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 int btrfs_removexattr(struct dentry *dentry, const char *name)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -442,8 +466,9 @@</span> <span class="p_context"> int btrfs_removexattr(struct dentry *dentry, const char *name)</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_removexattr(dentry, name);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))
 		return btrfs_set_prop(dentry-&gt;d_inode, name,
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index a3d33fe592d6..68a0843250c9 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -1254,6 +1254,53 @@</span> <span class="p_context"> static void check_unsafe_exec(struct linux_binprm *bprm)</span>
 	spin_unlock(&amp;p-&gt;fs-&gt;lock);
 }
 
<span class="p_add">+static void bprm_fill_uid(struct linux_binprm *bprm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode;</span>
<span class="p_add">+	unsigned int mode;</span>
<span class="p_add">+	kuid_t uid;</span>
<span class="p_add">+	kgid_t gid;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear any previous set[ug]id data from a previous binary */</span>
<span class="p_add">+	bprm-&gt;cred-&gt;euid = current_euid();</span>
<span class="p_add">+	bprm-&gt;cred-&gt;egid = current_egid();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;no_new_privs)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	inode = file_inode(bprm-&gt;file);</span>
<span class="p_add">+	mode = ACCESS_ONCE(inode-&gt;i_mode);</span>
<span class="p_add">+	if (!(mode &amp; (S_ISUID|S_ISGID)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Be careful if suid/sgid is set */</span>
<span class="p_add">+	mutex_lock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* reload atomically mode/uid/gid now that lock held */</span>
<span class="p_add">+	mode = inode-&gt;i_mode;</span>
<span class="p_add">+	uid = inode-&gt;i_uid;</span>
<span class="p_add">+	gid = inode-&gt;i_gid;</span>
<span class="p_add">+	mutex_unlock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We ignore suid/sgid if there are no mappings for them in the ns */</span>
<span class="p_add">+	if (!kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, uid) ||</span>
<span class="p_add">+		 !kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, gid))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mode &amp; S_ISUID) {</span>
<span class="p_add">+		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_add">+		bprm-&gt;cred-&gt;euid = uid;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
<span class="p_add">+		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_add">+		bprm-&gt;cred-&gt;egid = gid;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Fill the binprm structure from the inode.
  * Check permissions, then read the first 128 (BINPRM_BUF_SIZE) bytes
<span class="p_chunk">@@ -1262,36 +1309,9 @@</span> <span class="p_context"> static void check_unsafe_exec(struct linux_binprm *bprm)</span>
  */
 int prepare_binprm(struct linux_binprm *bprm)
 {
<span class="p_del">-	struct inode *inode = file_inode(bprm-&gt;file);</span>
<span class="p_del">-	umode_t mode = inode-&gt;i_mode;</span>
 	int retval;
 
<span class="p_del">-</span>
<span class="p_del">-	/* clear any previous set[ug]id data from a previous binary */</span>
<span class="p_del">-	bprm-&gt;cred-&gt;euid = current_euid();</span>
<span class="p_del">-	bprm-&gt;cred-&gt;egid = current_egid();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID) &amp;&amp;</span>
<span class="p_del">-	    !current-&gt;no_new_privs &amp;&amp;</span>
<span class="p_del">-	    kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, inode-&gt;i_uid) &amp;&amp;</span>
<span class="p_del">-	    kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, inode-&gt;i_gid)) {</span>
<span class="p_del">-		/* Set-uid? */</span>
<span class="p_del">-		if (mode &amp; S_ISUID) {</span>
<span class="p_del">-			bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_del">-			bprm-&gt;cred-&gt;euid = inode-&gt;i_uid;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Set-gid? */</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If setgid is set but no group execute bit then this</span>
<span class="p_del">-		 * is a candidate for mandatory locking, not a setgid</span>
<span class="p_del">-		 * executable.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
<span class="p_del">-			bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_del">-			bprm-&gt;cred-&gt;egid = inode-&gt;i_gid;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	bprm_fill_uid(bprm);</span>
 
 	/* fill in binprm security blob */
 	retval = security_bprm_set_creds(bprm);
<span class="p_header">diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h</span>
<span class="p_header">index 20889da7f8a0..e00dc9772402 100644</span>
<span class="p_header">--- a/fs/ext4/ext4.h</span>
<span class="p_header">+++ b/fs/ext4/ext4.h</span>
<span class="p_chunk">@@ -569,6 +569,7 @@</span> <span class="p_context"> enum {</span>
 #define EXT4_GET_BLOCKS_NO_PUT_HOLE		0x0200
 	/* Convert written extents to unwritten */
 #define EXT4_GET_BLOCKS_CONVERT_UNWRITTEN	0x0400
<span class="p_add">+/* DO NOT ASSIGN ADDITIONAL FLAG VALUES WITHOUT ADJUSTING THE FLAGS BELOW */</span>
 
 /*
  * The bit position of these flags must not overlap with any of the
<span class="p_chunk">@@ -579,8 +580,8 @@</span> <span class="p_context"> enum {</span>
  * caching the extents when reading from the extent tree while a
  * truncate or punch hole operation is in progress.
  */
<span class="p_del">-#define EXT4_EX_NOCACHE				0x0400</span>
<span class="p_del">-#define EXT4_EX_FORCE_CACHE			0x0800</span>
<span class="p_add">+#define EXT4_EX_NOCACHE				0x0800</span>
<span class="p_add">+#define EXT4_EX_FORCE_CACHE			0x1000</span>
 
 /*
  * Flags used by ext4_free_blocks
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index 467661264ad0..cdfe574ba3d9 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -4795,11 +4795,6 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 	else
 		max_blocks -= lblk;
 
<span class="p_del">-	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |</span>
<span class="p_del">-		EXT4_GET_BLOCKS_CONVERT_UNWRITTEN;</span>
<span class="p_del">-	if (mode &amp; FALLOC_FL_KEEP_SIZE)</span>
<span class="p_del">-		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;inode-&gt;i_mutex);
 
 	/*
<span class="p_chunk">@@ -4816,15 +4811,28 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
 			goto out_mutex;
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If we have a partial block after EOF we have to allocate</span>
<span class="p_del">-		 * the entire block.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (partial_end)</span>
<span class="p_del">-			max_blocks += 1;</span>
 	}
 
<span class="p_add">+	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;</span>
<span class="p_add">+	if (mode &amp; FALLOC_FL_KEEP_SIZE)</span>
<span class="p_add">+		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Preallocate the range including the unaligned edges */</span>
<span class="p_add">+	if (partial_begin || partial_end) {</span>
<span class="p_add">+		ret = ext4_alloc_file_blocks(file,</span>
<span class="p_add">+				round_down(offset, 1 &lt;&lt; blkbits) &gt;&gt; blkbits,</span>
<span class="p_add">+				(round_up((offset + len), 1 &lt;&lt; blkbits) -</span>
<span class="p_add">+				 round_down(offset, 1 &lt;&lt; blkbits)) &gt;&gt; blkbits,</span>
<span class="p_add">+				new_size, flags, mode);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_mutex;</span>
<span class="p_add">+</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Zero range excluding the unaligned edges */</span>
 	if (max_blocks &gt; 0) {
<span class="p_add">+		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |</span>
<span class="p_add">+			  EXT4_EX_NOCACHE);</span>
 
 		/* Now release the pages and zero block aligned part of pages*/
 		truncate_pagecache_range(inode, start, end - 1);
<span class="p_chunk">@@ -4834,15 +4842,21 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 		ext4_inode_block_unlocked_dio(inode);
 		inode_dio_wait(inode);
 
<span class="p_add">+		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,</span>
<span class="p_add">+					     flags, mode);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_dio;</span>
 		/*
 		 * Remove entire range from the extent status tree.
<span class="p_add">+		 *</span>
<span class="p_add">+		 * ext4_es_remove_extent(inode, lblk, max_blocks) is</span>
<span class="p_add">+		 * NOT sufficient.  I&#39;m not sure why this is the case,</span>
<span class="p_add">+		 * but let&#39;s be conservative and remove the extent</span>
<span class="p_add">+		 * status tree for the entire inode.  There should be</span>
<span class="p_add">+		 * no outstanding delalloc extents thanks to the</span>
<span class="p_add">+		 * filemap_write_and_wait_range() call above.</span>
 		 */
<span class="p_del">-		ret = ext4_es_remove_extent(inode, lblk, max_blocks);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			goto out_dio;</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,</span>
<span class="p_del">-					     flags, mode);</span>
<span class="p_add">+		ret = ext4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);</span>
 		if (ret)
 			goto out_dio;
 	}
<span class="p_header">diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c</span>
<span class="p_header">index e75f840000a0..944c49dd83e3 100644</span>
<span class="p_header">--- a/fs/ext4/indirect.c</span>
<span class="p_header">+++ b/fs/ext4/indirect.c</span>
<span class="p_chunk">@@ -1395,10 +1395,7 @@</span> <span class="p_context"> end_range:</span>
 				 * to free. Everything was covered by the start
 				 * of the range.
 				 */
<span class="p_del">-				return 0;</span>
<span class="p_del">-			} else {</span>
<span class="p_del">-				/* Shared branch grows from an indirect block */</span>
<span class="p_del">-				partial2--;</span>
<span class="p_add">+				goto do_indirects;</span>
 			}
 		} else {
 			/*
<span class="p_chunk">@@ -1429,56 +1426,96 @@</span> <span class="p_context"> end_range:</span>
 	/* Punch happened within the same level (n == n2) */
 	partial = ext4_find_shared(inode, n, offsets, chain, &amp;nr);
 	partial2 = ext4_find_shared(inode, n2, offsets2, chain2, &amp;nr2);
<span class="p_del">-	/*</span>
<span class="p_del">-	 * ext4_find_shared returns Indirect structure which</span>
<span class="p_del">-	 * points to the last element which should not be</span>
<span class="p_del">-	 * removed by truncate. But this is end of the range</span>
<span class="p_del">-	 * in punch_hole so we need to point to the next element</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	partial2-&gt;p++;</span>
<span class="p_del">-	while ((partial &gt; chain) || (partial2 &gt; chain2)) {</span>
<span class="p_del">-		/* We&#39;re at the same block, so we&#39;re almost finished */</span>
<span class="p_del">-		if ((partial-&gt;bh &amp;&amp; partial2-&gt;bh) &amp;&amp;</span>
<span class="p_del">-		    (partial-&gt;bh-&gt;b_blocknr == partial2-&gt;bh-&gt;b_blocknr)) {</span>
<span class="p_del">-			if ((partial &gt; chain) &amp;&amp; (partial2 &gt; chain2)) {</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Free top, but only if partial2 isn&#39;t its subtree. */</span>
<span class="p_add">+	if (nr) {</span>
<span class="p_add">+		int level = min(partial - chain, partial2 - chain2);</span>
<span class="p_add">+		int i;</span>
<span class="p_add">+		int subtree = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt;= level; i++) {</span>
<span class="p_add">+			if (offsets[i] != offsets2[i]) {</span>
<span class="p_add">+				subtree = 0;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!subtree) {</span>
<span class="p_add">+			if (partial == chain) {</span>
<span class="p_add">+				/* Shared branch grows from the inode */</span>
<span class="p_add">+				ext4_free_branches(handle, inode, NULL,</span>
<span class="p_add">+						   &amp;nr, &amp;nr+1,</span>
<span class="p_add">+						   (chain+n-1) - partial);</span>
<span class="p_add">+				*partial-&gt;p = 0;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/* Shared branch grows from an indirect block */</span>
<span class="p_add">+				BUFFER_TRACE(partial-&gt;bh, &quot;get_write_access&quot;);</span>
 				ext4_free_branches(handle, inode, partial-&gt;bh,
<span class="p_del">-						   partial-&gt;p + 1,</span>
<span class="p_del">-						   partial2-&gt;p,</span>
<span class="p_add">+						   partial-&gt;p,</span>
<span class="p_add">+						   partial-&gt;p+1,</span>
 						   (chain+n-1) - partial);
<span class="p_del">-				BUFFER_TRACE(partial-&gt;bh, &quot;call brelse&quot;);</span>
<span class="p_del">-				brelse(partial-&gt;bh);</span>
<span class="p_del">-				BUFFER_TRACE(partial2-&gt;bh, &quot;call brelse&quot;);</span>
<span class="p_del">-				brelse(partial2-&gt;bh);</span>
 			}
<span class="p_del">-			return 0;</span>
 		}
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!nr2) {</span>
 		/*
<span class="p_del">-		 * Clear the ends of indirect blocks on the shared branch</span>
<span class="p_del">-		 * at the start of the range</span>
<span class="p_add">+		 * ext4_find_shared returns Indirect structure which</span>
<span class="p_add">+		 * points to the last element which should not be</span>
<span class="p_add">+		 * removed by truncate. But this is end of the range</span>
<span class="p_add">+		 * in punch_hole so we need to point to the next element</span>
 		 */
<span class="p_del">-		if (partial &gt; chain) {</span>
<span class="p_add">+		partial2-&gt;p++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	while (partial &gt; chain || partial2 &gt; chain2) {</span>
<span class="p_add">+		int depth = (chain+n-1) - partial;</span>
<span class="p_add">+		int depth2 = (chain2+n2-1) - partial2;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (partial &gt; chain &amp;&amp; partial2 &gt; chain2 &amp;&amp;</span>
<span class="p_add">+		    partial-&gt;bh-&gt;b_blocknr == partial2-&gt;bh-&gt;b_blocknr) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We&#39;ve converged on the same block. Clear the range,</span>
<span class="p_add">+			 * then we&#39;re done.</span>
<span class="p_add">+			 */</span>
 			ext4_free_branches(handle, inode, partial-&gt;bh,
<span class="p_del">-				   partial-&gt;p + 1,</span>
<span class="p_del">-				   (__le32 *)partial-&gt;bh-&gt;b_data+addr_per_block,</span>
<span class="p_del">-				   (chain+n-1) - partial);</span>
<span class="p_add">+					   partial-&gt;p + 1,</span>
<span class="p_add">+					   partial2-&gt;p,</span>
<span class="p_add">+					   (chain+n-1) - partial);</span>
 			BUFFER_TRACE(partial-&gt;bh, &quot;call brelse&quot;);
 			brelse(partial-&gt;bh);
<span class="p_del">-			partial--;</span>
<span class="p_add">+			BUFFER_TRACE(partial2-&gt;bh, &quot;call brelse&quot;);</span>
<span class="p_add">+			brelse(partial2-&gt;bh);</span>
<span class="p_add">+			return 0;</span>
 		}
<span class="p_add">+</span>
 		/*
<span class="p_del">-		 * Clear the ends of indirect blocks on the shared branch</span>
<span class="p_del">-		 * at the end of the range</span>
<span class="p_add">+		 * The start and end partial branches may not be at the same</span>
<span class="p_add">+		 * level even though the punch happened within one level. So, we</span>
<span class="p_add">+		 * give them a chance to arrive at the same level, then walk</span>
<span class="p_add">+		 * them in step with each other until we converge on the same</span>
<span class="p_add">+		 * block.</span>
 		 */
<span class="p_del">-		if (partial2 &gt; chain2) {</span>
<span class="p_add">+		if (partial &gt; chain &amp;&amp; depth &lt;= depth2) {</span>
<span class="p_add">+			ext4_free_branches(handle, inode, partial-&gt;bh,</span>
<span class="p_add">+					   partial-&gt;p + 1,</span>
<span class="p_add">+					   (__le32 *)partial-&gt;bh-&gt;b_data+addr_per_block,</span>
<span class="p_add">+					   (chain+n-1) - partial);</span>
<span class="p_add">+			BUFFER_TRACE(partial-&gt;bh, &quot;call brelse&quot;);</span>
<span class="p_add">+			brelse(partial-&gt;bh);</span>
<span class="p_add">+			partial--;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (partial2 &gt; chain2 &amp;&amp; depth2 &lt;= depth) {</span>
 			ext4_free_branches(handle, inode, partial2-&gt;bh,
 					   (__le32 *)partial2-&gt;bh-&gt;b_data,
 					   partial2-&gt;p,
<span class="p_del">-					   (chain2+n-1) - partial2);</span>
<span class="p_add">+					   (chain2+n2-1) - partial2);</span>
 			BUFFER_TRACE(partial2-&gt;bh, &quot;call brelse&quot;);
 			brelse(partial2-&gt;bh);
 			partial2--;
 		}
 	}
<span class="p_add">+	return 0;</span>
 
 do_indirects:
 	/* Kill the remaining (whole) subtrees */
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index 5c0b71c734ea..5dbec667d75b 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1889,7 +1889,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			  struct inode *inode)
 {
 	struct inode *dir = dentry-&gt;d_parent-&gt;d_inode;
<span class="p_del">-	struct buffer_head *bh;</span>
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 	struct ext4_dir_entry_2 *de;
 	struct ext4_dir_entry_tail *t;
 	struct super_block *sb;
<span class="p_chunk">@@ -1913,14 +1913,14 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return retval;
 		if (retval == 1) {
 			retval = 0;
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		}
 	}
 
 	if (is_dx(dir)) {
 		retval = ext4_dx_add_entry(handle, dentry, inode);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
 		dx_fallback++;
 		ext4_mark_inode_dirty(handle, dir);
<span class="p_chunk">@@ -1932,14 +1932,15 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return PTR_ERR(bh);
 
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
<span class="p_del">-		if (retval != -ENOSPC) {</span>
<span class="p_del">-			brelse(bh);</span>
<span class="p_del">-			return retval;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (retval != -ENOSPC)</span>
<span class="p_add">+			goto out;</span>
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
<span class="p_del">-		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))</span>
<span class="p_del">-			return make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {</span>
<span class="p_add">+			retval = make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+			bh = NULL; /* make_indexed_dir releases bh */</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &amp;block);
<span class="p_chunk">@@ -1955,6 +1956,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 	}
 
 	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
<span class="p_add">+out:</span>
 	brelse(bh);
 	if (retval == 0)
 		ext4_set_inode_state(inode, EXT4_STATE_NEWENTRY);
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 0b79fe47502a..19ac9c89dbab 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1554,7 +1554,8 @@</span> <span class="p_context"> static inline int walk_component(struct nameidata *nd, struct path *path,</span>
 
 	if (should_follow_link(path-&gt;dentry, follow)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				err = -ECHILD;
 				goto out_err;
 			}
<span class="p_chunk">@@ -3015,7 +3016,8 @@</span> <span class="p_context"> finish_lookup:</span>
 
 	if (should_follow_link(path-&gt;dentry, !symlink_ok)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				error = -ECHILD;
 				goto out;
 			}
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index b1a14ad2ca01..d74c67678bb1 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -1258,14 +1258,15 @@</span> <span class="p_context"> static inline void namespace_lock(void)</span>
 	down_write(&amp;namespace_sem);
 }
 
<span class="p_add">+enum umount_tree_flags {</span>
<span class="p_add">+	UMOUNT_SYNC = 1,</span>
<span class="p_add">+	UMOUNT_PROPAGATE = 2,</span>
<span class="p_add">+};</span>
 /*
  * mount_lock must be held
  * namespace_sem must be held for write
<span class="p_del">- * how = 0 =&gt; just this tree, don&#39;t propagate</span>
<span class="p_del">- * how = 1 =&gt; propagate; we know that nobody else has reference to any victims</span>
<span class="p_del">- * how = 2 =&gt; lazy umount</span>
  */
<span class="p_del">-void umount_tree(struct mount *mnt, int how)</span>
<span class="p_add">+static void umount_tree(struct mount *mnt, enum umount_tree_flags how)</span>
 {
 	HLIST_HEAD(tmp_list);
 	struct mount *p;
<span class="p_chunk">@@ -1279,7 +1280,7 @@</span> <span class="p_context"> void umount_tree(struct mount *mnt, int how)</span>
 	hlist_for_each_entry(p, &amp;tmp_list, mnt_hash)
 		list_del_init(&amp;p-&gt;mnt_child);
 
<span class="p_del">-	if (how)</span>
<span class="p_add">+	if (how &amp; UMOUNT_PROPAGATE)</span>
 		propagate_umount(&amp;tmp_list);
 
 	hlist_for_each_entry(p, &amp;tmp_list, mnt_hash) {
<span class="p_chunk">@@ -1287,7 +1288,7 @@</span> <span class="p_context"> void umount_tree(struct mount *mnt, int how)</span>
 		list_del_init(&amp;p-&gt;mnt_list);
 		__touch_mnt_namespace(p-&gt;mnt_ns);
 		p-&gt;mnt_ns = NULL;
<span class="p_del">-		if (how &lt; 2)</span>
<span class="p_add">+		if (how &amp; UMOUNT_SYNC)</span>
 			p-&gt;mnt.mnt_flags |= MNT_SYNC_UMOUNT;
 		if (mnt_has_parent(p)) {
 			put_mountpoint(p-&gt;mnt_mp);
<span class="p_chunk">@@ -1391,14 +1392,14 @@</span> <span class="p_context"> static int do_umount(struct mount *mnt, int flags)</span>
 
 	if (flags &amp; MNT_DETACH) {
 		if (!list_empty(&amp;mnt-&gt;mnt_list))
<span class="p_del">-			umount_tree(mnt, 2);</span>
<span class="p_add">+			umount_tree(mnt, UMOUNT_PROPAGATE);</span>
 		retval = 0;
 	} else {
 		shrink_submounts(mnt);
 		retval = -EBUSY;
 		if (!propagate_mount_busy(mnt, 2)) {
 			if (!list_empty(&amp;mnt-&gt;mnt_list))
<span class="p_del">-				umount_tree(mnt, 1);</span>
<span class="p_add">+				umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span>
 			retval = 0;
 		}
 	}
<span class="p_chunk">@@ -1566,7 +1567,7 @@</span> <span class="p_context"> struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,</span>
 out:
 	if (res) {
 		lock_mount_hash();
<span class="p_del">-		umount_tree(res, 0);</span>
<span class="p_add">+		umount_tree(res, UMOUNT_SYNC);</span>
 		unlock_mount_hash();
 	}
 	return q;
<span class="p_chunk">@@ -1590,7 +1591,7 @@</span> <span class="p_context"> void drop_collected_mounts(struct vfsmount *mnt)</span>
 {
 	namespace_lock();
 	lock_mount_hash();
<span class="p_del">-	umount_tree(real_mount(mnt), 0);</span>
<span class="p_add">+	umount_tree(real_mount(mnt), UMOUNT_SYNC);</span>
 	unlock_mount_hash();
 	namespace_unlock();
 }
<span class="p_chunk">@@ -1746,7 +1747,7 @@</span> <span class="p_context"> static int attach_recursive_mnt(struct mount *source_mnt,</span>
  out_cleanup_ids:
 	while (!hlist_empty(&amp;tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
<span class="p_del">-		umount_tree(child, 0);</span>
<span class="p_add">+		umount_tree(child, UMOUNT_SYNC);</span>
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
<span class="p_chunk">@@ -1921,7 +1922,7 @@</span> <span class="p_context"> static int do_loopback(struct path *path, const char *old_name,</span>
 	err = graft_tree(mnt, parent, mp);
 	if (err) {
 		lock_mount_hash();
<span class="p_del">-		umount_tree(mnt, 0);</span>
<span class="p_add">+		umount_tree(mnt, UMOUNT_SYNC);</span>
 		unlock_mount_hash();
 	}
 out2:
<span class="p_chunk">@@ -2292,7 +2293,7 @@</span> <span class="p_context"> void mark_mounts_for_expiry(struct list_head *mounts)</span>
 	while (!list_empty(&amp;graveyard)) {
 		mnt = list_first_entry(&amp;graveyard, struct mount, mnt_expire);
 		touch_mnt_namespace(mnt-&gt;mnt_ns);
<span class="p_del">-		umount_tree(mnt, 1);</span>
<span class="p_add">+		umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span>
 	}
 	unlock_mount_hash();
 	namespace_unlock();
<span class="p_chunk">@@ -2363,7 +2364,7 @@</span> <span class="p_context"> static void shrink_submounts(struct mount *mnt)</span>
 			m = list_first_entry(&amp;graveyard, struct mount,
 						mnt_expire);
 			touch_mnt_namespace(m-&gt;mnt_ns);
<span class="p_del">-			umount_tree(m, 1);</span>
<span class="p_add">+			umount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span>
 		}
 	}
 }
<span class="p_header">diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c</span>
<span class="p_header">index 0a2016bd6e58..8c849947d34f 100644</span>
<span class="p_header">--- a/fs/nfs/callback.c</span>
<span class="p_header">+++ b/fs/nfs/callback.c</span>
<span class="p_chunk">@@ -128,7 +128,7 @@</span> <span class="p_context"> nfs41_callback_svc(void *vrqstp)</span>
 		if (try_to_freeze())
 			continue;
 
<span class="p_del">-		prepare_to_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq, TASK_UNINTERRUPTIBLE);</span>
<span class="p_add">+		prepare_to_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq, TASK_INTERRUPTIBLE);</span>
 		spin_lock_bh(&amp;serv-&gt;sv_cb_lock);
 		if (!list_empty(&amp;serv-&gt;sv_cb_list)) {
 			req = list_first_entry(&amp;serv-&gt;sv_cb_list,
<span class="p_chunk">@@ -142,10 +142,10 @@</span> <span class="p_context"> nfs41_callback_svc(void *vrqstp)</span>
 				error);
 		} else {
 			spin_unlock_bh(&amp;serv-&gt;sv_cb_lock);
<span class="p_del">-			/* schedule_timeout to game the hung task watchdog */</span>
<span class="p_del">-			schedule_timeout(60 * HZ);</span>
<span class="p_add">+			schedule();</span>
 			finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);
 		}
<span class="p_add">+		flush_signals(current);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c</span>
<span class="p_header">index 51844048937f..1f451f90f857 100644</span>
<span class="p_header">--- a/fs/nfsd/nfsctl.c</span>
<span class="p_header">+++ b/fs/nfsd/nfsctl.c</span>
<span class="p_chunk">@@ -1170,15 +1170,15 @@</span> <span class="p_context"> static int __init init_nfsd(void)</span>
 	int retval;
 	printk(KERN_INFO &quot;Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\n&quot;);
 
<span class="p_del">-	retval = register_cld_notifier();</span>
<span class="p_del">-	if (retval)</span>
<span class="p_del">-		return retval;</span>
 	retval = register_pernet_subsys(&amp;nfsd_net_ops);
 	if (retval &lt; 0)
<span class="p_del">-		goto out_unregister_notifier;</span>
<span class="p_del">-	retval = nfsd4_init_slabs();</span>
<span class="p_add">+		return retval;</span>
<span class="p_add">+	retval = register_cld_notifier();</span>
 	if (retval)
 		goto out_unregister_pernet;
<span class="p_add">+	retval = nfsd4_init_slabs();</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		goto out_unregister_notifier;</span>
 	retval = nfsd_fault_inject_init(); /* nfsd fault injection controls */
 	if (retval)
 		goto out_free_slabs;
<span class="p_chunk">@@ -1205,10 +1205,10 @@</span> <span class="p_context"> out_free_stat:</span>
 	nfsd_fault_inject_cleanup();
 out_free_slabs:
 	nfsd4_free_slabs();
<span class="p_del">-out_unregister_pernet:</span>
<span class="p_del">-	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 out_unregister_notifier:
 	unregister_cld_notifier();
<span class="p_add">+out_unregister_pernet:</span>
<span class="p_add">+	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -1222,8 +1222,8 @@</span> <span class="p_context"> static void __exit exit_nfsd(void)</span>
 	nfsd4_free_slabs();
 	nfsd_fault_inject_cleanup();
 	unregister_filesystem(&amp;nfsd_fs_type);
<span class="p_del">-	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 	unregister_cld_notifier();
<span class="p_add">+	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 }
 
 MODULE_AUTHOR(&quot;Olaf Kirch &lt;okir@monad.swb.de&gt;&quot;);
<span class="p_header">diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c</span>
<span class="p_header">index 2930e231f3f9..fd106d136983 100644</span>
<span class="p_header">--- a/fs/ocfs2/file.c</span>
<span class="p_header">+++ b/fs/ocfs2/file.c</span>
<span class="p_chunk">@@ -2375,10 +2375,14 @@</span> <span class="p_context"> out_dio:</span>
 	/* buffered aio wouldn&#39;t have proper lock coverage today */
 	BUG_ON(ret == -EIOCBQUEUED &amp;&amp; !(file-&gt;f_flags &amp; O_DIRECT));
 
<span class="p_add">+	if (unlikely(written &lt;= 0))</span>
<span class="p_add">+		goto no_sync;</span>
<span class="p_add">+</span>
 	if (((file-&gt;f_flags &amp; O_DSYNC) &amp;&amp; !direct_io) || IS_SYNC(inode) ||
 	    ((file-&gt;f_flags &amp; O_DIRECT) &amp;&amp; !direct_io)) {
<span class="p_del">-		ret = filemap_fdatawrite_range(file-&gt;f_mapping, *ppos,</span>
<span class="p_del">-					       *ppos + count - 1);</span>
<span class="p_add">+		ret = filemap_fdatawrite_range(file-&gt;f_mapping,</span>
<span class="p_add">+					       iocb-&gt;ki_pos - written,</span>
<span class="p_add">+					       iocb-&gt;ki_pos - 1);</span>
 		if (ret &lt; 0)
 			written = ret;
 
<span class="p_chunk">@@ -2391,10 +2395,12 @@</span> <span class="p_context"> out_dio:</span>
 		}
 
 		if (!ret)
<span class="p_del">-			ret = filemap_fdatawait_range(file-&gt;f_mapping, *ppos,</span>
<span class="p_del">-						      *ppos + count - 1);</span>
<span class="p_add">+			ret = filemap_fdatawait_range(file-&gt;f_mapping,</span>
<span class="p_add">+						      iocb-&gt;ki_pos - written,</span>
<span class="p_add">+						      iocb-&gt;ki_pos - 1);</span>
 	}
 
<span class="p_add">+no_sync:</span>
 	/*
 	 * deep in g_f_a_w_n()-&gt;ocfs2_direct_IO we pass in a ocfs2_dio_end_io
 	 * function pointer which is called when o_direct io completes so that
<span class="p_header">diff --git a/fs/pnode.h b/fs/pnode.h</span>
<span class="p_header">index 4a246358b031..16afc3d6d2f2 100644</span>
<span class="p_header">--- a/fs/pnode.h</span>
<span class="p_header">+++ b/fs/pnode.h</span>
<span class="p_chunk">@@ -47,7 +47,6 @@</span> <span class="p_context"> int get_dominating_id(struct mount *mnt, const struct path *root);</span>
 unsigned int mnt_get_count(struct mount *mnt);
 void mnt_set_mountpoint(struct mount *, struct mountpoint *,
 			struct mount *);
<span class="p_del">-void umount_tree(struct mount *, int);</span>
 struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);
<span class="p_header">diff --git a/include/asm-generic/sections.h b/include/asm-generic/sections.h</span>
<span class="p_header">index f1a24b5c3b90..b58fd667f87b 100644</span>
<span class="p_header">--- a/include/asm-generic/sections.h</span>
<span class="p_header">+++ b/include/asm-generic/sections.h</span>
<span class="p_chunk">@@ -3,6 +3,8 @@</span> <span class="p_context"></span>
 
 /* References to section boundaries */
 
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+</span>
 /*
  * Usage guidelines:
  * _text, _data: architecture specific, don&#39;t use them in arch-independent code
<span class="p_chunk">@@ -37,6 +39,8 @@</span> <span class="p_context"> extern char __start_rodata[], __end_rodata[];</span>
 /* Start and end of .ctors section - used for constructor calls. */
 extern char __ctors_start[], __ctors_end[];
 
<span class="p_add">+extern __visible const void __nosave_begin, __nosave_end;</span>
<span class="p_add">+</span>
 /* function descriptor handling (if any).  Override
  * in asm/sections.h */
 #ifndef dereference_function_descriptor
<span class="p_header">diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h</span>
<span class="p_header">index 66c2167f04a9..37ac4b1ed28f 100644</span>
<span class="p_header">--- a/include/linux/blk_types.h</span>
<span class="p_header">+++ b/include/linux/blk_types.h</span>
<span class="p_chunk">@@ -180,7 +180,9 @@</span> <span class="p_context"> enum rq_flag_bits {</span>
 	__REQ_ELVPRIV,		/* elevator private data attached */
 	__REQ_FAILED,		/* set if the request failed */
 	__REQ_QUIET,		/* don&#39;t worry about errors */
<span class="p_del">-	__REQ_PREEMPT,		/* set for &quot;ide_preempt&quot; requests */</span>
<span class="p_add">+	__REQ_PREEMPT,		/* set for &quot;ide_preempt&quot; requests and also</span>
<span class="p_add">+				   for requests for which the SCSI &quot;quiesce&quot;</span>
<span class="p_add">+				   state must be ignored. */</span>
 	__REQ_ALLOCED,		/* request came from our alloc pool */
 	__REQ_COPY_USER,	/* contains copies of user pages */
 	__REQ_FLUSH_SEQ,	/* request for flush sequence */
<span class="p_header">diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h</span>
<span class="p_header">index 25e0df6155a4..575b7166cb08 100644</span>
<span class="p_header">--- a/include/linux/cpuidle.h</span>
<span class="p_header">+++ b/include/linux/cpuidle.h</span>
<span class="p_chunk">@@ -69,7 +69,6 @@</span> <span class="p_context"> struct cpuidle_device {</span>
 	unsigned int		cpu;
 
 	int			last_residency;
<span class="p_del">-	int			state_count;</span>
 	struct cpuidle_state_usage	states_usage[CPUIDLE_STATE_MAX];
 	struct cpuidle_state_kobj *kobjs[CPUIDLE_STATE_MAX];
 	struct cpuidle_driver_kobj *kobj_driver;
<span class="p_header">diff --git a/include/linux/jhash.h b/include/linux/jhash.h</span>
<span class="p_header">index 47cb09edec1a..348c6f47e4cc 100644</span>
<span class="p_header">--- a/include/linux/jhash.h</span>
<span class="p_header">+++ b/include/linux/jhash.h</span>
<span class="p_chunk">@@ -145,11 +145,11 @@</span> <span class="p_context"> static inline u32 jhash2(const u32 *k, u32 length, u32 initval)</span>
 }
 
 
<span class="p_del">-/* jhash_3words - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_del">-static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+/* __jhash_nwords - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_add">+static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)</span>
 {
<span class="p_del">-	a += JHASH_INITVAL;</span>
<span class="p_del">-	b += JHASH_INITVAL;</span>
<span class="p_add">+	a += initval;</span>
<span class="p_add">+	b += initval;</span>
 	c += initval;
 
 	__jhash_final(a, b, c);
<span class="p_chunk">@@ -157,14 +157,19 @@</span> <span class="p_context"> static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
 	return c;
 }
 
<span class="p_add">+static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __jhash_nwords(a, b, c, initval + JHASH_INITVAL + (3 &lt;&lt; 2));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u32 jhash_2words(u32 a, u32 b, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, b, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 &lt;&lt; 2));</span>
 }
 
 static inline u32 jhash_1word(u32 a, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, 0, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, 0, 0, initval + JHASH_INITVAL + (1 &lt;&lt; 2));</span>
 }
 
 #endif /* _LINUX_JHASH_H */
<span class="p_header">diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h</span>
<span class="p_header">index 66f9a04ec270..ab4ce78c5bb8 100644</span>
<span class="p_header">--- a/include/linux/netdevice.h</span>
<span class="p_header">+++ b/include/linux/netdevice.h</span>
<span class="p_chunk">@@ -1977,6 +1977,12 @@</span> <span class="p_context"> void netdev_freemem(struct net_device *dev);</span>
 void synchronize_net(void);
 int init_dummy_netdev(struct net_device *dev);
 
<span class="p_add">+DECLARE_PER_CPU(int, xmit_recursion);</span>
<span class="p_add">+static inline int dev_recursion_level(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return this_cpu_read(xmit_recursion);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct net_device *dev_get_by_index(struct net *net, int ifindex);
 struct net_device *__dev_get_by_index(struct net *net, int ifindex);
 struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex);
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index c5cc872b351d..4bab946551e9 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -174,6 +174,14 @@</span> <span class="p_context"> extern unsigned long this_cpu_load(void);</span>
 extern void calc_global_load(unsigned long ticks);
 extern void update_cpu_load_nohz(void);
 
<span class="p_add">+/* Notifier for when a task gets migrated to a new CPU */</span>
<span class="p_add">+struct task_migration_notifier {</span>
<span class="p_add">+	struct task_struct *task;</span>
<span class="p_add">+	int from_cpu;</span>
<span class="p_add">+	int to_cpu;</span>
<span class="p_add">+};</span>
<span class="p_add">+extern void register_task_migration_notifier(struct notifier_block *n);</span>
<span class="p_add">+</span>
 extern unsigned long get_parent_ip(unsigned long addr);
 
 extern void dump_cpu_task(int cpu);
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index 6bb6bd86b0dc..89524732dd5e 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -724,6 +724,7 @@</span> <span class="p_context"> bool skb_try_coalesce(struct sk_buff *to, struct sk_buff *from,</span>
 
 struct sk_buff *__alloc_skb(unsigned int size, gfp_t priority, int flags,
 			    int node);
<span class="p_add">+struct sk_buff *__build_skb(void *data, unsigned int frag_size);</span>
 struct sk_buff *build_skb(void *data, unsigned int frag_size);
 static inline struct sk_buff *alloc_skb(unsigned int size,
 					gfp_t priority)
<span class="p_chunk">@@ -2798,6 +2799,18 @@</span> <span class="p_context"> static inline bool __skb_checksum_validate_needed(struct sk_buff *skb,</span>
  */
 #define CHECKSUM_BREAK 76
 
<span class="p_add">+/* Unset checksum-complete</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Unset checksum complete can be done when packet is being modified</span>
<span class="p_add">+ * (uncompressed for instance) and checksum-complete value is</span>
<span class="p_add">+ * invalidated.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void skb_checksum_complete_unset(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)</span>
<span class="p_add">+		skb-&gt;ip_summed = CHECKSUM_NONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Validate (init) checksum based on checksum complete.
  *
  * Return values:
<span class="p_header">diff --git a/include/linux/usb.h b/include/linux/usb.h</span>
<span class="p_header">index d2465bc0e73c..2e47496ace0d 100644</span>
<span class="p_header">--- a/include/linux/usb.h</span>
<span class="p_header">+++ b/include/linux/usb.h</span>
<span class="p_chunk">@@ -210,6 +210,32 @@</span> <span class="p_context"> void usb_put_intf(struct usb_interface *intf);</span>
 #define USB_MAXINTERFACES	32
 #define USB_MAXIADS		(USB_MAXINTERFACES/2)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * USB Resume Timer: Every Host controller driver should drive the resume</span>
<span class="p_add">+ * signalling on the bus for the amount of time defined by this macro.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * That way we will have a &#39;stable&#39; behavior among all HCDs supported by Linux.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that the USB Specification states we should drive resume for *at least*</span>
<span class="p_add">+ * 20 ms, but it doesn&#39;t give an upper bound. This creates two possible</span>
<span class="p_add">+ * situations which we want to avoid:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes</span>
<span class="p_add">+ * us to fail USB Electrical Tests, thus failing Certification</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (b) Some (many) devices actually need more than 20 ms of resume signalling,</span>
<span class="p_add">+ * and while we can argue that&#39;s against the USB Specification, we don&#39;t have</span>
<span class="p_add">+ * control over which devices a certification laboratory will be using for</span>
<span class="p_add">+ * certification. If CertLab uses a device which was tested against Windows and</span>
<span class="p_add">+ * that happens to have relaxed resume signalling rules, we might fall into</span>
<span class="p_add">+ * situations where we fail interoperability and electrical tests.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to avoid both conditions, we&#39;re using a 40 ms resume timeout, which</span>
<span class="p_add">+ * should cope with both LPJ calibration errors and devices not following every</span>
<span class="p_add">+ * detail of the USB Specification.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define USB_RESUME_TIMEOUT	40 /* ms */</span>
<span class="p_add">+</span>
 /**
  * struct usb_interface_cache - long-term representation of a device interface
  * @num_altsetting: number of altsettings defined.
<span class="p_header">diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h</span>
<span class="p_header">index 0662e98fef72..36afcd9ca57d 100644</span>
<span class="p_header">--- a/include/linux/usb/usbnet.h</span>
<span class="p_header">+++ b/include/linux/usb/usbnet.h</span>
<span class="p_chunk">@@ -220,9 +220,23 @@</span> <span class="p_context"> struct skb_data {	/* skb-&gt;cb is one of these */</span>
 	struct urb		*urb;
 	struct usbnet		*dev;
 	enum skb_state		state;
<span class="p_del">-	size_t			length;</span>
<span class="p_add">+	long			length;</span>
<span class="p_add">+	unsigned long		packets;</span>
 };
 
<span class="p_add">+/* Drivers that set FLAG_MULTI_PACKET must call this in their</span>
<span class="p_add">+ * tx_fixup method before returning an skb.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+usbnet_set_skb_tx_stats(struct sk_buff *skb,</span>
<span class="p_add">+			unsigned long packets, long bytes_delta)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct skb_data *entry = (struct skb_data *) skb-&gt;cb;</span>
<span class="p_add">+</span>
<span class="p_add">+	entry-&gt;packets = packets;</span>
<span class="p_add">+	entry-&gt;length = bytes_delta;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern int usbnet_open(struct net_device *net);
 extern int usbnet_stop(struct net_device *net);
 extern netdev_tx_t usbnet_start_xmit(struct sk_buff *skb,
<span class="p_header">diff --git a/include/net/ip.h b/include/net/ip.h</span>
<span class="p_header">index fdef22d88203..f2254fe1a39c 100644</span>
<span class="p_header">--- a/include/net/ip.h</span>
<span class="p_header">+++ b/include/net/ip.h</span>
<span class="p_chunk">@@ -425,22 +425,6 @@</span> <span class="p_context"> static __inline__ void inet_reset_saddr(struct sock *sk)</span>
 
 #endif
 
<span class="p_del">-static inline int sk_mc_loop(struct sock *sk)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!sk)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	switch (sk-&gt;sk_family) {</span>
<span class="p_del">-	case AF_INET:</span>
<span class="p_del">-		return inet_sk(sk)-&gt;mc_loop;</span>
<span class="p_del">-#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="p_del">-	case AF_INET6:</span>
<span class="p_del">-		return inet6_sk(sk)-&gt;mc_loop;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_del">-	WARN_ON(1);</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 bool ip_call_ra_chain(struct sk_buff *skb);
 
 /*
<span class="p_header">diff --git a/include/net/ip6_route.h b/include/net/ip6_route.h</span>
<span class="p_header">index 1d09b46c1e48..eda131d179d9 100644</span>
<span class="p_header">--- a/include/net/ip6_route.h</span>
<span class="p_header">+++ b/include/net/ip6_route.h</span>
<span class="p_chunk">@@ -174,7 +174,8 @@</span> <span class="p_context"> int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));</span>
 
 static inline int ip6_skb_dst_mtu(struct sk_buff *skb)
 {
<span class="p_del">-	struct ipv6_pinfo *np = skb-&gt;sk ? inet6_sk(skb-&gt;sk) : NULL;</span>
<span class="p_add">+	struct ipv6_pinfo *np = skb-&gt;sk &amp;&amp; !dev_recursion_level() ?</span>
<span class="p_add">+				inet6_sk(skb-&gt;sk) : NULL;</span>
 
 	return (np &amp;&amp; np-&gt;pmtudisc &gt;= IPV6_PMTUDISC_PROBE) ?
 	       skb_dst(skb)-&gt;dev-&gt;mtu : dst_mtu(skb_dst(skb));
<span class="p_header">diff --git a/include/net/sock.h b/include/net/sock.h</span>
<span class="p_header">index 6cc7944d65bf..927cfc56b76a 100644</span>
<span class="p_header">--- a/include/net/sock.h</span>
<span class="p_header">+++ b/include/net/sock.h</span>
<span class="p_chunk">@@ -1790,6 +1790,8 @@</span> <span class="p_context"> struct dst_entry *__sk_dst_check(struct sock *sk, u32 cookie);</span>
 
 struct dst_entry *sk_dst_check(struct sock *sk, u32 cookie);
 
<span class="p_add">+bool sk_mc_loop(struct sock *sk);</span>
<span class="p_add">+</span>
 static inline bool sk_can_gso(const struct sock *sk)
 {
 	return net_gso_ok(sk-&gt;sk_route_caps, sk-&gt;sk_gso_type);
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 9cbe50191dd6..edfd69a25884 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -518,7 +518,7 @@</span> <span class="p_context"> struct se_cmd {</span>
 	sense_reason_t		(*execute_cmd)(struct se_cmd *);
 	sense_reason_t		(*execute_rw)(struct se_cmd *, struct scatterlist *,
 					      u32, enum dma_data_direction);
<span class="p_del">-	sense_reason_t (*transport_complete_callback)(struct se_cmd *);</span>
<span class="p_add">+	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool);</span>
 
 	unsigned char		*t_task_cdb;
 	unsigned char		__t_task_cdb[TCM_MAX_COMMAND_SIZE];
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index adf98622cb32..808e5dbcbd9f 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -720,6 +720,8 @@</span> <span class="p_context"> static int ptrace_peek_siginfo(struct task_struct *child,</span>
 static int ptrace_resume(struct task_struct *child, long request,
 			 unsigned long data)
 {
<span class="p_add">+	bool need_siglock;</span>
<span class="p_add">+</span>
 	if (!valid_signal(data))
 		return -EIO;
 
<span class="p_chunk">@@ -747,8 +749,26 @@</span> <span class="p_context"> static int ptrace_resume(struct task_struct *child, long request,</span>
 		user_disable_single_step(child);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Change -&gt;exit_code and -&gt;state under siglock to avoid the race</span>
<span class="p_add">+	 * with wait_task_stopped() in between; a non-zero -&gt;exit_code will</span>
<span class="p_add">+	 * wrongly look like another report from tracee.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we need siglock even if -&gt;exit_code == data and/or this</span>
<span class="p_add">+	 * status was not reported yet, the new status must not be cleared by</span>
<span class="p_add">+	 * wait_task_stopped() after resume.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If data == 0 we do not care if wait_task_stopped() reports the old</span>
<span class="p_add">+	 * status and clears the code too; this can&#39;t race with the tracee, it</span>
<span class="p_add">+	 * takes siglock after resume.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	need_siglock = data &amp;&amp; !thread_group_empty(current);</span>
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_lock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 	child-&gt;exit_code = data;
 	wake_up_state(child, __TASK_TRACED);
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_unlock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 2eb2e7992970..847922e4ba67 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -1036,6 +1036,13 @@</span> <span class="p_context"> void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)</span>
 		rq-&gt;skip_clock_update = 1;
 }
 
<span class="p_add">+static ATOMIC_NOTIFIER_HEAD(task_migration_notifier);</span>
<span class="p_add">+</span>
<span class="p_add">+void register_task_migration_notifier(struct notifier_block *n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_notifier_chain_register(&amp;task_migration_notifier, n);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_SMP
 void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
 {
<span class="p_chunk">@@ -1066,10 +1073,18 @@</span> <span class="p_context"> void set_task_cpu(struct task_struct *p, unsigned int new_cpu)</span>
 	trace_sched_migrate_task(p, new_cpu);
 
 	if (task_cpu(p) != new_cpu) {
<span class="p_add">+		struct task_migration_notifier tmn;</span>
<span class="p_add">+</span>
 		if (p-&gt;sched_class-&gt;migrate_task_rq)
 			p-&gt;sched_class-&gt;migrate_task_rq(p, new_cpu);
 		p-&gt;se.nr_migrations++;
 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);
<span class="p_add">+</span>
<span class="p_add">+		tmn.task = p;</span>
<span class="p_add">+		tmn.from_cpu = task_cpu(p);</span>
<span class="p_add">+		tmn.to_cpu = new_cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+		atomic_notifier_call_chain(&amp;task_migration_notifier, 0, &amp;tmn);</span>
 	}
 
 	__set_task_cpu(p, new_cpu);
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index a16472e40117..c2aad7276111 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -2700,7 +2700,7 @@</span> <span class="p_context"> static DEFINE_PER_CPU(unsigned int, current_context);</span>
 
 static __always_inline int trace_recursive_lock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 	int bit;
 
 	if (in_interrupt()) {
<span class="p_chunk">@@ -2717,18 +2717,17 @@</span> <span class="p_context"> static __always_inline int trace_recursive_lock(void)</span>
 		return 1;
 
 	val |= (1 &lt;&lt; bit);
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 
 	return 0;
 }
 
 static __always_inline void trace_recursive_unlock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 
<span class="p_del">-	val--;</span>
<span class="p_del">-	val &amp;= this_cpu_read(current_context);</span>
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	val &amp;= val &amp; (val - 1);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 }
 
 #else
<span class="p_header">diff --git a/lib/string.c b/lib/string.c</span>
<span class="p_header">index 3a3120452a1d..30a2f627bc14 100644</span>
<span class="p_header">--- a/lib/string.c</span>
<span class="p_header">+++ b/lib/string.c</span>
<span class="p_chunk">@@ -616,7 +616,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(memset);</span>
 void memzero_explicit(void *s, size_t count)
 {
 	memset(s, 0, count);
<span class="p_del">-	OPTIMIZER_HIDE_VAR(s);</span>
<span class="p_add">+	barrier();</span>
 }
 EXPORT_SYMBOL(memzero_explicit);
 
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 5f217e906ff9..1e080a06e6ba 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -3723,8 +3723,7 @@</span> <span class="p_context"> retry:</span>
 	if (!pmd_huge(*pmd))
 		goto out;
 	if (pmd_present(*pmd)) {
<span class="p_del">-		page = pte_page(*(pte_t *)pmd) +</span>
<span class="p_del">-			((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+		page = pmd_page(*pmd) + ((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</span>
 		if (flags &amp; FOLL_GET)
 			get_page(page);
 	} else {
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 58bf1016a521..9742052fb55e 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2821,7 +2821,9 @@</span> <span class="p_context"> static void skb_update_prio(struct sk_buff *skb)</span>
 #define skb_update_prio(skb)
 #endif
 
<span class="p_del">-static DEFINE_PER_CPU(int, xmit_recursion);</span>
<span class="p_add">+DEFINE_PER_CPU(int, xmit_recursion);</span>
<span class="p_add">+EXPORT_SYMBOL(xmit_recursion);</span>
<span class="p_add">+</span>
 #define RECURSION_LIMIT 10
 
 /**
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index fe07faaed256..dc27721ece4d 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -278,13 +278,14 @@</span> <span class="p_context"> nodata:</span>
 EXPORT_SYMBOL(__alloc_skb);
 
 /**
<span class="p_del">- * build_skb - build a network buffer</span>
<span class="p_add">+ * __build_skb - build a network buffer</span>
  * @data: data buffer provided by caller
<span class="p_del">- * @frag_size: size of fragment, or 0 if head was kmalloced</span>
<span class="p_add">+ * @frag_size: size of data, or 0 if head was kmalloced</span>
  *
  * Allocate a new &amp;sk_buff. Caller provides space holding head and
  * skb_shared_info. @data must have been allocated by kmalloc() only if
<span class="p_del">- * @frag_size is 0, otherwise data should come from the page allocator.</span>
<span class="p_add">+ * @frag_size is 0, otherwise data should come from the page allocator</span>
<span class="p_add">+ *  or vmalloc()</span>
  * The return is the new skb buffer.
  * On a failure the return is %NULL, and @data is not freed.
  * Notes :
<span class="p_chunk">@@ -295,7 +296,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(__alloc_skb);</span>
  *  before giving packet to stack.
  *  RX rings only contains data buffers, not full skbs.
  */
<span class="p_del">-struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
<span class="p_add">+struct sk_buff *__build_skb(void *data, unsigned int frag_size)</span>
 {
 	struct skb_shared_info *shinfo;
 	struct sk_buff *skb;
<span class="p_chunk">@@ -309,7 +310,6 @@</span> <span class="p_context"> struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
 
 	memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb-&gt;truesize = SKB_TRUESIZE(size);
<span class="p_del">-	skb-&gt;head_frag = frag_size != 0;</span>
 	atomic_set(&amp;skb-&gt;users, 1);
 	skb-&gt;head = data;
 	skb-&gt;data = data;
<span class="p_chunk">@@ -326,6 +326,23 @@</span> <span class="p_context"> struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
 
 	return skb;
 }
<span class="p_add">+</span>
<span class="p_add">+/* build_skb() is wrapper over __build_skb(), that specifically</span>
<span class="p_add">+ * takes care of skb-&gt;head and skb-&gt;pfmemalloc</span>
<span class="p_add">+ * This means that if @frag_size is not zero, then @data must be backed</span>
<span class="p_add">+ * by a page fragment, not kmalloc() or vmalloc()</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *skb = __build_skb(data, frag_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (skb &amp;&amp; frag_size) {</span>
<span class="p_add">+		skb-&gt;head_frag = 1;</span>
<span class="p_add">+		if (virt_to_head_page(data)-&gt;pfmemalloc)</span>
<span class="p_add">+			skb-&gt;pfmemalloc = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return skb;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(build_skb);
 
 struct netdev_alloc_cache {
<span class="p_chunk">@@ -352,7 +369,8 @@</span> <span class="p_context"> refill:</span>
 			gfp_t gfp = gfp_mask;
 
 			if (order)
<span class="p_del">-				gfp |= __GFP_COMP | __GFP_NOWARN;</span>
<span class="p_add">+				gfp |= __GFP_COMP | __GFP_NOWARN |</span>
<span class="p_add">+				       __GFP_NOMEMALLOC;</span>
 			nc-&gt;frag.page = alloc_pages(gfp, order);
 			if (likely(nc-&gt;frag.page))
 				break;
<span class="p_chunk">@@ -3925,18 +3943,21 @@</span> <span class="p_context"> EXPORT_SYMBOL(skb_try_coalesce);</span>
  */
 void skb_scrub_packet(struct sk_buff *skb, bool xnet)
 {
<span class="p_del">-	if (xnet)</span>
<span class="p_del">-		skb_orphan(skb);</span>
 	skb-&gt;tstamp.tv64 = 0;
 	skb-&gt;pkt_type = PACKET_HOST;
 	skb-&gt;skb_iif = 0;
 	skb-&gt;ignore_df = 0;
 	skb_dst_drop(skb);
<span class="p_del">-	skb-&gt;mark = 0;</span>
 	skb_init_secmark(skb);
 	secpath_reset(skb);
 	nf_reset(skb);
 	nf_reset_trace(skb);
<span class="p_add">+</span>
<span class="p_add">+	if (!xnet)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb_orphan(skb);</span>
<span class="p_add">+	skb-&gt;mark = 0;</span>
 }
 EXPORT_SYMBOL_GPL(skb_scrub_packet);
 
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index 026e01f70274..a6ddd4ada315 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -659,6 +659,25 @@</span> <span class="p_context"> static inline void sock_valbool_flag(struct sock *sk, int bit, int valbool)</span>
 		sock_reset_flag(sk, bit);
 }
 
<span class="p_add">+bool sk_mc_loop(struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (dev_recursion_level())</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (!sk)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	switch (sk-&gt;sk_family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		return inet_sk(sk)-&gt;mc_loop;</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="p_add">+	case AF_INET6:</span>
<span class="p_add">+		return inet6_sk(sk)-&gt;mc_loop;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+	WARN_ON(1);</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(sk_mc_loop);</span>
<span class="p_add">+</span>
 /*
  *	This is meant for all protocols to use and covers goings on
  *	at the socket level. Everything here is generic.
<span class="p_header">diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c</span>
<span class="p_header">index 787b3c294ce6..d5410b57da19 100644</span>
<span class="p_header">--- a/net/ipv4/ip_forward.c</span>
<span class="p_header">+++ b/net/ipv4/ip_forward.c</span>
<span class="p_chunk">@@ -81,6 +81,9 @@</span> <span class="p_context"> int ip_forward(struct sk_buff *skb)</span>
 	if (skb-&gt;pkt_type != PACKET_HOST)
 		goto drop;
 
<span class="p_add">+	if (unlikely(skb-&gt;sk))</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+</span>
 	if (skb_warn_if_lro(skb))
 		goto drop;
 
<span class="p_header">diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c</span>
<span class="p_header">index 45d5bc0ad86c..30d0a64be413 100644</span>
<span class="p_header">--- a/net/ipv4/ping.c</span>
<span class="p_header">+++ b/net/ipv4/ping.c</span>
<span class="p_chunk">@@ -158,6 +158,7 @@</span> <span class="p_context"> void ping_unhash(struct sock *sk)</span>
 	if (sk_hashed(sk)) {
 		write_lock_bh(&amp;ping_table.lock);
 		hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);
<span class="p_add">+		sk_nulls_node_init(&amp;sk-&gt;sk_nulls_node);</span>
 		sock_put(sk);
 		isk-&gt;inet_num = 0;
 		isk-&gt;inet_sport = 0;
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index ac7752f4f777..b68fd0d65411 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -1637,7 +1637,7 @@</span> <span class="p_context"> void tcp_v4_early_demux(struct sk_buff *skb)</span>
 		skb-&gt;sk = sk;
 		skb-&gt;destructor = sock_edemux;
 		if (sk-&gt;sk_state != TCP_TIME_WAIT) {
<span class="p_del">-			struct dst_entry *dst = sk-&gt;sk_rx_dst;</span>
<span class="p_add">+			struct dst_entry *dst = ACCESS_ONCE(sk-&gt;sk_rx_dst);</span>
 
 			if (dst)
 				dst = dst_check(dst, 0);
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 1ea0a07ab0b5..9d26f4569a2e 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -2675,39 +2675,65 @@</span> <span class="p_context"> begin_fwd:</span>
 	}
 }
 
<span class="p_del">-/* Send a fin.  The caller locks the socket for us.  This cannot be</span>
<span class="p_del">- * allowed to fail queueing a FIN frame under any circumstances.</span>
<span class="p_add">+/* We allow to exceed memory limits for FIN packets to expedite</span>
<span class="p_add">+ * connection tear down and (memory) recovery.</span>
<span class="p_add">+ * Otherwise tcp_send_fin() could be tempted to either delay FIN</span>
<span class="p_add">+ * or even be forced to close flow without any FIN.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void sk_forced_wmem_schedule(struct sock *sk, int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int amt, status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &lt;= sk-&gt;sk_forward_alloc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	amt = sk_mem_pages(size);</span>
<span class="p_add">+	sk-&gt;sk_forward_alloc += amt * SK_MEM_QUANTUM;</span>
<span class="p_add">+	sk_memory_allocated_add(sk, amt, &amp;status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Send a FIN. The caller locks the socket for us.</span>
<span class="p_add">+ * We should try to send a FIN packet really hard, but eventually give up.</span>
  */
 void tcp_send_fin(struct sock *sk)
 {
<span class="p_add">+	struct sk_buff *skb, *tskb = tcp_write_queue_tail(sk);</span>
 	struct tcp_sock *tp = tcp_sk(sk);
<span class="p_del">-	struct sk_buff *skb = tcp_write_queue_tail(sk);</span>
<span class="p_del">-	int mss_now;</span>
 
<span class="p_del">-	/* Optimization, tack on the FIN if we have a queue of</span>
<span class="p_del">-	 * unsent frames.  But be careful about outgoing SACKS</span>
<span class="p_del">-	 * and IP options.</span>
<span class="p_add">+	/* Optimization, tack on the FIN if we have one skb in write queue and</span>
<span class="p_add">+	 * this skb was not yet sent, or we are under memory pressure.</span>
<span class="p_add">+	 * Note: in the latter case, FIN packet will be sent after a timeout,</span>
<span class="p_add">+	 * as TCP stack thinks it has already been transmitted.</span>
 	 */
<span class="p_del">-	mss_now = tcp_current_mss(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tcp_send_head(sk) != NULL) {</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;end_seq++;</span>
<span class="p_add">+	if (tskb &amp;&amp; (tcp_send_head(sk) || sk_under_memory_pressure(sk))) {</span>
<span class="p_add">+coalesce:</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;end_seq++;</span>
 		tp-&gt;write_seq++;
<span class="p_add">+		if (!tcp_send_head(sk)) {</span>
<span class="p_add">+			/* This means tskb was already sent.</span>
<span class="p_add">+			 * Pretend we included the FIN on previous transmit.</span>
<span class="p_add">+			 * We need to set tp-&gt;snd_nxt to the value it would have</span>
<span class="p_add">+			 * if FIN had been sent. This is because retransmit path</span>
<span class="p_add">+			 * does not change tp-&gt;snd_nxt.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tp-&gt;snd_nxt++;</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
 	} else {
<span class="p_del">-		/* Socket is locked, keep trying until memory is available. */</span>
<span class="p_del">-		for (;;) {</span>
<span class="p_del">-			skb = sk_stream_alloc_skb(sk, 0, sk-&gt;sk_allocation);</span>
<span class="p_del">-			if (skb)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			yield();</span>
<span class="p_add">+		skb = alloc_skb_fclone(MAX_TCP_HEADER, sk-&gt;sk_allocation);</span>
<span class="p_add">+		if (unlikely(!skb)) {</span>
<span class="p_add">+			if (tskb)</span>
<span class="p_add">+				goto coalesce;</span>
<span class="p_add">+			return;</span>
 		}
<span class="p_add">+		skb_reserve(skb, MAX_TCP_HEADER);</span>
<span class="p_add">+		sk_forced_wmem_schedule(sk, skb-&gt;truesize);</span>
 		/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */
 		tcp_init_nondata_skb(skb, tp-&gt;write_seq,
 				     TCPHDR_ACK | TCPHDR_FIN);
 		tcp_queue_skb(sk, skb);
 	}
<span class="p_del">-	__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_OFF);</span>
<span class="p_add">+	__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);</span>
 }
 
 /* We get here when a process closes a file descriptor (either due to
<span class="p_chunk">@@ -2855,6 +2881,8 @@</span> <span class="p_context"> struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,</span>
 	}
 #endif
 
<span class="p_add">+	/* Do not fool tcpdump (if any), clean our debris */</span>
<span class="p_add">+	skb-&gt;tstamp.tv64 = 0;</span>
 	return skb;
 }
 EXPORT_SYMBOL(tcp_make_synack);
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index f709462b1a77..264bcf784926 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -555,7 +555,8 @@</span> <span class="p_context"> int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *))</span>
 {
 	struct sk_buff *frag;
 	struct rt6_info *rt = (struct rt6_info*)skb_dst(skb);
<span class="p_del">-	struct ipv6_pinfo *np = skb-&gt;sk ? inet6_sk(skb-&gt;sk) : NULL;</span>
<span class="p_add">+	struct ipv6_pinfo *np = skb-&gt;sk &amp;&amp; !dev_recursion_level() ?</span>
<span class="p_add">+				inet6_sk(skb-&gt;sk) : NULL;</span>
 	struct ipv6hdr *tmp_hdr;
 	struct frag_hdr *fh;
 	unsigned int mtu, hlen, left, len;
<span class="p_header">diff --git a/net/ipv6/ip6_vti.c b/net/ipv6/ip6_vti.c</span>
<span class="p_header">index 7c6e6bfb1b0f..4e083dab7445 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_vti.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_vti.c</span>
<span class="p_chunk">@@ -267,8 +267,7 @@</span> <span class="p_context"> static struct ip6_tnl *vti6_locate(struct net *net, struct __ip6_tnl_parm *p,</span>
 static void vti6_dev_uninit(struct net_device *dev)
 {
 	struct ip6_tnl *t = netdev_priv(dev);
<span class="p_del">-	struct net *net = dev_net(dev);</span>
<span class="p_del">-	struct vti6_net *ip6n = net_generic(net, vti6_net_id);</span>
<span class="p_add">+	struct vti6_net *ip6n = net_generic(t-&gt;net, vti6_net_id);</span>
 
 	if (dev == ip6n-&gt;fb_tnl_dev)
 		RCU_INIT_POINTER(ip6n-&gt;tnls_wc[0], NULL);
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index cb5125c5328d..d15a5484076f 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -1646,7 +1646,7 @@</span> <span class="p_context"> static void tcp_v6_early_demux(struct sk_buff *skb)</span>
 		skb-&gt;sk = sk;
 		skb-&gt;destructor = sock_edemux;
 		if (sk-&gt;sk_state != TCP_TIME_WAIT) {
<span class="p_del">-			struct dst_entry *dst = sk-&gt;sk_rx_dst;</span>
<span class="p_add">+			struct dst_entry *dst = ACCESS_ONCE(sk-&gt;sk_rx_dst);</span>
 
 			if (dst)
 				dst = dst_check(dst, inet6_sk(sk)-&gt;rx_dst_cookie);
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 256ce8b84456..5dcb2baaf2c2 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -1650,13 +1650,11 @@</span> <span class="p_context"> static struct sk_buff *netlink_alloc_large_skb(unsigned int size,</span>
 	if (data == NULL)
 		return NULL;
 
<span class="p_del">-	skb = build_skb(data, size);</span>
<span class="p_add">+	skb = __build_skb(data, size);</span>
 	if (skb == NULL)
 		vfree(data);
<span class="p_del">-	else {</span>
<span class="p_del">-		skb-&gt;head_frag = 0;</span>
<span class="p_add">+	else</span>
 		skb-&gt;destructor = netlink_skb_destructor;
<span class="p_del">-	}</span>
 
 	return skb;
 }
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/verbs.c b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">index 13dbd1c389ff..9ec12f834c43 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_chunk">@@ -541,9 +541,10 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 
 	if (memreg == RPCRDMA_FRMR) {
 		/* Requires both frmr reg and local dma lkey */
<span class="p_del">-		if ((devattr.device_cap_flags &amp;</span>
<span class="p_add">+		if (((devattr.device_cap_flags &amp;</span>
 		     (IB_DEVICE_MEM_MGT_EXTENSIONS|IB_DEVICE_LOCAL_DMA_LKEY)) !=
<span class="p_del">-		    (IB_DEVICE_MEM_MGT_EXTENSIONS|IB_DEVICE_LOCAL_DMA_LKEY)) {</span>
<span class="p_add">+		    (IB_DEVICE_MEM_MGT_EXTENSIONS|IB_DEVICE_LOCAL_DMA_LKEY)) ||</span>
<span class="p_add">+		      (devattr.max_fast_reg_page_list_len == 0)) {</span>
 			dprintk(&quot;RPC:       %s: FRMR registration &quot;
 				&quot;not supported by HCA\n&quot;, __func__);
 			memreg = RPCRDMA_MTHCAFMR;
<span class="p_header">diff --git a/sound/firewire/bebob/bebob_maudio.c b/sound/firewire/bebob/bebob_maudio.c</span>
<span class="p_header">index 70faa3a32526..0215a9194d88 100644</span>
<span class="p_header">--- a/sound/firewire/bebob/bebob_maudio.c</span>
<span class="p_header">+++ b/sound/firewire/bebob/bebob_maudio.c</span>
<span class="p_chunk">@@ -96,10 +96,10 @@</span> <span class="p_context"> int snd_bebob_maudio_load_firmware(struct fw_unit *unit)</span>
 	struct fw_device *device = fw_parent_device(unit);
 	int err, rcode;
 	u64 date;
<span class="p_del">-	__be32 cues[3] = {</span>
<span class="p_del">-		MAUDIO_BOOTLOADER_CUE1,</span>
<span class="p_del">-		MAUDIO_BOOTLOADER_CUE2,</span>
<span class="p_del">-		MAUDIO_BOOTLOADER_CUE3</span>
<span class="p_add">+	__le32 cues[3] = {</span>
<span class="p_add">+		cpu_to_le32(MAUDIO_BOOTLOADER_CUE1),</span>
<span class="p_add">+		cpu_to_le32(MAUDIO_BOOTLOADER_CUE2),</span>
<span class="p_add">+		cpu_to_le32(MAUDIO_BOOTLOADER_CUE3)</span>
 	};
 
 	/* check date of software used to build */
<span class="p_header">diff --git a/sound/pci/emu10k1/emuproc.c b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">index 2ca9f2e93139..53745f4c2bf5 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_chunk">@@ -241,31 +241,22 @@</span> <span class="p_context"> static void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry,</span>
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
 	u32 value2;
<span class="p_del">-	unsigned long flags;</span>
 	u32 rate;
 
 	if (emu-&gt;card_capabilities-&gt;emu_model) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x38, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x1) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x2a, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x2b, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;ADAT Locked : %u\n&quot;, rate);
 		} else {
 			snd_iprintf(buffer, &quot;ADAT Unlocked\n&quot;);
 		}
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x20, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x4) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x28, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x29, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;SPDIF Locked : %d\n&quot;, rate);
 		} else {
<span class="p_chunk">@@ -410,14 +401,11 @@</span> <span class="p_context"> static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,</span>
 {
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
<span class="p_del">-	unsigned long flags;</span>
 	int i;
 	snd_iprintf(buffer, &quot;EMU1010 Registers:\n\n&quot;);
 
 	for(i = 0; i &lt; 0x40; i+=1) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, i, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_iprintf(buffer, &quot;%02X: %08X, %02X\n&quot;, i, value, (value &gt;&gt; 8) &amp; 0x7f);
 	}
 }
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 4a6d7a0ee242..7b16c8ca5faf 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -3057,6 +3057,8 @@</span> <span class="p_context"> static void alc283_init(struct hda_codec *codec)</span>
 
 	if (!hp_pin)
 		return;
<span class="p_add">+</span>
<span class="p_add">+	msleep(30);</span>
 	hp_pin_sense = snd_hda_jack_detect(codec, hp_pin);
 
 	/* Index 0x43 Direct Drive HP AMP LPM Control 1 */
<span class="p_chunk">@@ -4265,6 +4267,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_QUANTA_MUTE,
 	ALC269_FIXUP_LIFEBOOK,
 	ALC269_FIXUP_LIFEBOOK_EXTMIC,
<span class="p_add">+	ALC269_FIXUP_LIFEBOOK_HP_PIN,</span>
 	ALC269_FIXUP_AMIC,
 	ALC269_FIXUP_DMIC,
 	ALC269VB_FIXUP_AMIC,
<span class="p_chunk">@@ -4409,6 +4412,13 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{ }
 		},
 	},
<span class="p_add">+	[ALC269_FIXUP_LIFEBOOK_HP_PIN] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x21, 0x0221102f }, /* HP out */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	[ALC269_FIXUP_AMIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -4868,6 +4878,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x104d, 0x9099, &quot;Sony VAIO S13&quot;, ALC275_FIXUP_SONY_DISABLE_AAMIX),
 	SND_PCI_QUIRK_VENDOR(0x104d, &quot;Sony VAIO&quot;, ALC269_FIXUP_SONY_VAIO),
 	SND_PCI_QUIRK(0x10cf, 0x1475, &quot;Lifebook&quot;, ALC269_FIXUP_LIFEBOOK),
<span class="p_add">+	SND_PCI_QUIRK(0x10cf, 0x15dc, &quot;Lifebook T731&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),</span>
 	SND_PCI_QUIRK(0x10cf, 0x1845, &quot;Lifebook U904&quot;, ALC269_FIXUP_LIFEBOOK_EXTMIC),
 	SND_PCI_QUIRK(0x17aa, 0x20f2, &quot;Thinkpad SL410/510&quot;, ALC269_FIXUP_SKU_IGNORE),
 	SND_PCI_QUIRK(0x17aa, 0x215e, &quot;Thinkpad L512&quot;, ALC269_FIXUP_SKU_IGNORE),
<span class="p_chunk">@@ -4886,11 +4897,13 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x2212, &quot;Thinkpad T440&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2214, &quot;Thinkpad X240&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2215, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2226, &quot;ThinkPad X250&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;IdeaPad S210&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;IdeaPad Y410P&quot;, ALC269_FIXUP_NO_SHUTUP),
 	SND_PCI_QUIRK(0x17aa, 0x5013, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x501a, &quot;Thinkpad&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x5026, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x5034, &quot;Thinkpad T450&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x5036, &quot;Thinkpad T450s&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5109, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x3bf8, &quot;Quanta FL1&quot;, ALC269_FIXUP_PCM_44K),
<span class="p_header">diff --git a/sound/soc/codecs/cs4271.c b/sound/soc/codecs/cs4271.c</span>
<span class="p_header">index 6ec074fec068..38c2adc99770 100644</span>
<span class="p_header">--- a/sound/soc/codecs/cs4271.c</span>
<span class="p_header">+++ b/sound/soc/codecs/cs4271.c</span>
<span class="p_chunk">@@ -561,10 +561,10 @@</span> <span class="p_context"> static int cs4271_probe(struct snd_soc_codec *codec)</span>
 	if (gpio_is_valid(cs4271-&gt;gpio_nreset)) {
 		/* Reset codec */
 		gpio_direction_output(cs4271-&gt;gpio_nreset, 0);
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 		gpio_set_value(cs4271-&gt;gpio_nreset, 1);
 		/* Give the codec time to wake up */
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 	}
 
 	ret = regmap_update_bits(cs4271-&gt;regmap, CS4271_MODE2,
<span class="p_header">diff --git a/sound/soc/codecs/pcm512x.c b/sound/soc/codecs/pcm512x.c</span>
<span class="p_header">index f36414be3d22..3f8bcf73e567 100644</span>
<span class="p_header">--- a/sound/soc/codecs/pcm512x.c</span>
<span class="p_header">+++ b/sound/soc/codecs/pcm512x.c</span>
<span class="p_chunk">@@ -261,9 +261,9 @@</span> <span class="p_context"> static const struct soc_enum pcm512x_veds =</span>
 static const struct snd_kcontrol_new pcm512x_controls[] = {
 SOC_DOUBLE_R_TLV(&quot;Playback Digital Volume&quot;, PCM512x_DIGITAL_VOLUME_2,
 		 PCM512x_DIGITAL_VOLUME_3, 0, 255, 1, digital_tlv),
<span class="p_del">-SOC_DOUBLE_TLV(&quot;Playback Volume&quot;, PCM512x_ANALOG_GAIN_CTRL,</span>
<span class="p_add">+SOC_DOUBLE_TLV(&quot;Analogue Playback Volume&quot;, PCM512x_ANALOG_GAIN_CTRL,</span>
 	       PCM512x_LAGN_SHIFT, PCM512x_RAGN_SHIFT, 1, 1, analog_tlv),
<span class="p_del">-SOC_DOUBLE_TLV(&quot;Playback Boost Volume&quot;, PCM512x_ANALOG_GAIN_BOOST,</span>
<span class="p_add">+SOC_DOUBLE_TLV(&quot;Analogue Playback Boost Volume&quot;, PCM512x_ANALOG_GAIN_BOOST,</span>
 	       PCM512x_AGBL_SHIFT, PCM512x_AGBR_SHIFT, 1, 0, boost_tlv),
 SOC_DOUBLE(&quot;Playback Digital Switch&quot;, PCM512x_MUTE, PCM512x_RQML_SHIFT,
 	   PCM512x_RQMR_SHIFT, 1, 1),
<span class="p_header">diff --git a/sound/soc/codecs/wm8741.c b/sound/soc/codecs/wm8741.c</span>
<span class="p_header">index b33542a04607..e90520b9973e 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8741.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8741.c</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static const unsigned int rates_11289[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static const struct snd_pcm_hw_constraint_list constraints_11289 = {
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static const struct snd_pcm_hw_constraint_list constraints_16384 = {</span>
 };
 
 static const unsigned int rates_16934[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static const struct snd_pcm_hw_constraint_list constraints_16934 = {
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> static const struct snd_pcm_hw_constraint_list constraints_18432 = {</span>
 };
 
 static const unsigned int rates_22579[] = {
<span class="p_del">-	44100, 88235, 1764000</span>
<span class="p_add">+	44100, 88200, 176400</span>
 };
 
 static const struct snd_pcm_hw_constraint_list constraints_22579 = {
<span class="p_chunk">@@ -186,7 +186,7 @@</span> <span class="p_context"> static const struct snd_pcm_hw_constraint_list constraints_24576 = {</span>
 };
 
 static const unsigned int rates_36864[] = {
<span class="p_del">-	48000, 96000, 19200</span>
<span class="p_add">+	48000, 96000, 192000</span>
 };
 
 static const struct snd_pcm_hw_constraint_list constraints_36864 = {
<span class="p_header">diff --git a/sound/soc/davinci/davinci-evm.c b/sound/soc/davinci/davinci-evm.c</span>
<span class="p_header">index a50010e2891f..82837e5e96ab 100644</span>
<span class="p_header">--- a/sound/soc/davinci/davinci-evm.c</span>
<span class="p_header">+++ b/sound/soc/davinci/davinci-evm.c</span>
<span class="p_chunk">@@ -431,18 +431,8 @@</span> <span class="p_context"> static int davinci_evm_probe(struct platform_device *pdev)</span>
 	return ret;
 }
 
<span class="p_del">-static int davinci_evm_remove(struct platform_device *pdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct snd_soc_card *card = platform_get_drvdata(pdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	snd_soc_unregister_card(card);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct platform_driver davinci_evm_driver = {
 	.probe		= davinci_evm_probe,
<span class="p_del">-	.remove		= davinci_evm_remove,</span>
 	.driver		= {
 		.name	= &quot;davinci_evm&quot;,
 		.owner	= THIS_MODULE,
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index 7c83bab69dee..9484d02d5f2c 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -178,6 +178,7 @@</span> <span class="p_context"> static const struct rc_config {</span>
 	{ USB_ID(0x041e, 0x3040), 2, 2, 6, 6,  2,  0x6e91 }, /* Live! 24-bit */
 	{ USB_ID(0x041e, 0x3042), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 */
 	{ USB_ID(0x041e, 0x30df), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 Pro */
<span class="p_add">+	{ USB_ID(0x041e, 0x3237), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 Pro */</span>
 	{ USB_ID(0x041e, 0x3048), 2, 2, 6, 6,  2,  0x6e91 }, /* Toshiba SB0500 */
 };
 
<span class="p_header">diff --git a/tools/lib/traceevent/kbuffer-parse.c b/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_header">index dcc665228c71..deb3569ab004 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_header">+++ b/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_chunk">@@ -372,7 +372,6 @@</span> <span class="p_context"> translate_data(struct kbuffer *kbuf, void *data, void **rptr,</span>
 	switch (type_len) {
 	case KBUFFER_TYPE_PADDING:
 		*length = read_4(kbuf, data);
<span class="p_del">-		data += *length;</span>
 		break;
 
 	case KBUFFER_TYPE_TIME_EXTEND:
<span class="p_header">diff --git a/tools/power/x86/turbostat/Makefile b/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">index d1b3a361e526..4039854560d0 100644</span>
<span class="p_header">--- a/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">+++ b/tools/power/x86/turbostat/Makefile</span>
<span class="p_chunk">@@ -1,8 +1,12 @@</span> <span class="p_context"></span>
 CC		= $(CROSS_COMPILE)gcc
<span class="p_del">-BUILD_OUTPUT	:= $(PWD)</span>
<span class="p_add">+BUILD_OUTPUT	:= $(CURDIR)</span>
 PREFIX		:= /usr
 DESTDIR		:=
 
<span class="p_add">+ifeq (&quot;$(origin O)&quot;, &quot;command line&quot;)</span>
<span class="p_add">+	BUILD_OUTPUT := $(O)</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 turbostat : turbostat.c
 CFLAGS +=	-Wall
 CFLAGS +=	-DMSRHEADER=&#39;&quot;../../../../arch/x86/include/uapi/asm/msr-index.h&quot;&#39;
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 27e140d5f073..032150ca597d 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -1550,8 +1550,8 @@</span> <span class="p_context"> int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,</span>
 	ghc-&gt;generation = slots-&gt;generation;
 	ghc-&gt;len = len;
 	ghc-&gt;memslot = gfn_to_memslot(kvm, start_gfn);
<span class="p_del">-	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, &amp;nr_pages_avail);</span>
<span class="p_del">-	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_avail &gt;= nr_pages_needed) {</span>
<span class="p_add">+	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, NULL);</span>
<span class="p_add">+	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_needed &lt;= 1) {</span>
 		ghc-&gt;hva += offset;
 	} else {
 		/*

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



