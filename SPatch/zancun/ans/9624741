
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.15 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.15</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 15, 2017, 3:04 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170315030439.GB24000@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9624741/mbox/"
   >mbox</a>
|
   <a href="/patch/9624741/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9624741/">/patch/9624741/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	1486D604CC for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 15 Mar 2017 03:05:20 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id F313C28568
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 15 Mar 2017 03:05:19 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E65BB285EC; Wed, 15 Mar 2017 03:05:19 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 56D6D28568
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 15 Mar 2017 03:05:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751609AbdCODFJ (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 14 Mar 2017 23:05:09 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:39000 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750768AbdCODFE (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 14 Mar 2017 23:05:04 -0400
Received: from localhost (unknown [104.132.150.97])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 8D8FE95E;
	Wed, 15 Mar 2017 03:04:52 +0000 (UTC)
Date: Wed, 15 Mar 2017 11:04:39 +0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.15
Message-ID: &lt;20170315030439.GB24000@kroah.com&gt;
References: &lt;20170315030434.GA24000@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170315030434.GA24000@kroah.com&gt;
User-Agent: Mutt/1.8.0 (2017-02-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - March 15, 2017, 3:04 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 5e7706e94622..03df4fcacdf2 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 14</span>
<span class="p_add">+SUBLEVEL = 15</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/s390/include/asm/processor.h b/arch/s390/include/asm/processor.h</span>
<span class="p_header">index 602af692efdc..6bcbbece082b 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/processor.h</span>
<span class="p_chunk">@@ -89,7 +89,8 @@</span> <span class="p_context"> extern void execve_tail(void);</span>
  * User space process size: 2GB for 31 bit, 4TB or 8PT for 64 bit.
  */
 
<span class="p_del">-#define TASK_SIZE_OF(tsk)	((tsk)-&gt;mm-&gt;context.asce_limit)</span>
<span class="p_add">+#define TASK_SIZE_OF(tsk)	((tsk)-&gt;mm ? \</span>
<span class="p_add">+				 (tsk)-&gt;mm-&gt;context.asce_limit : TASK_MAX_SIZE)</span>
 #define TASK_UNMAPPED_BASE	(test_thread_flag(TIF_31BIT) ? \
 					(1UL &lt;&lt; 30) : (1UL &lt;&lt; 41))
 #define TASK_SIZE		TASK_SIZE_OF(current)
<span class="p_header">diff --git a/arch/s390/kernel/crash_dump.c b/arch/s390/kernel/crash_dump.c</span>
<span class="p_header">index f9293bfefb7f..408b4f4fda0f 100644</span>
<span class="p_header">--- a/arch/s390/kernel/crash_dump.c</span>
<span class="p_header">+++ b/arch/s390/kernel/crash_dump.c</span>
<span class="p_chunk">@@ -329,7 +329,11 @@</span> <span class="p_context"> static void *nt_init_name(void *buf, Elf64_Word type, void *desc, int d_len,</span>
 
 static inline void *nt_init(void *buf, Elf64_Word type, void *desc, int d_len)
 {
<span class="p_del">-	return nt_init_name(buf, type, desc, d_len, KEXEC_CORE_NOTE_NAME);</span>
<span class="p_add">+	const char *note_name = &quot;LINUX&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type == NT_PRPSINFO || type == NT_PRSTATUS || type == NT_PRFPREG)</span>
<span class="p_add">+		note_name = KEXEC_CORE_NOTE_NAME;</span>
<span class="p_add">+	return nt_init_name(buf, type, desc, d_len, note_name);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/s390/kernel/setup.c b/arch/s390/kernel/setup.c</span>
<span class="p_header">index d027f2eb3559..e974e53ab597 100644</span>
<span class="p_header">--- a/arch/s390/kernel/setup.c</span>
<span class="p_header">+++ b/arch/s390/kernel/setup.c</span>
<span class="p_chunk">@@ -819,10 +819,10 @@</span> <span class="p_context"> static void __init setup_randomness(void)</span>
 {
 	struct sysinfo_3_2_2 *vmms;
 
<span class="p_del">-	vmms = (struct sysinfo_3_2_2 *) alloc_page(GFP_KERNEL);</span>
<span class="p_del">-	if (vmms &amp;&amp; stsi(vmms, 3, 2, 2) == 0 &amp;&amp; vmms-&gt;count)</span>
<span class="p_del">-		add_device_randomness(&amp;vmms, vmms-&gt;count);</span>
<span class="p_del">-	free_page((unsigned long) vmms);</span>
<span class="p_add">+	vmms = (struct sysinfo_3_2_2 *) memblock_alloc(PAGE_SIZE, PAGE_SIZE);</span>
<span class="p_add">+	if (stsi(vmms, 3, 2, 2) == 0 &amp;&amp; vmms-&gt;count)</span>
<span class="p_add">+		add_device_randomness(&amp;vmms-&gt;vm, sizeof(vmms-&gt;vm[0]) * vmms-&gt;count);</span>
<span class="p_add">+	memblock_free((unsigned long) vmms, PAGE_SIZE);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">index 47a1de77b18d..5ba494ed18c1 100644</span>
<span class="p_header">--- a/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">+++ b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_chunk">@@ -442,6 +442,9 @@</span> <span class="p_context"> int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm,</span>
 	struct kvm_memory_slot *memslot;
 	int is_dirty = 0;
 
<span class="p_add">+	if (kvm_is_ucontrol(kvm))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;kvm-&gt;slots_lock);
 
 	r = -EINVAL;
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 6fa85944af83..fc5abff9b7fd 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -188,7 +188,7 @@</span> <span class="p_context"> static inline void __native_flush_tlb_single(unsigned long addr)</span>
 
 static inline void __flush_tlb_all(void)
 {
<span class="p_del">-	if (static_cpu_has(X86_FEATURE_PGE))</span>
<span class="p_add">+	if (boot_cpu_has(X86_FEATURE_PGE))</span>
 		__flush_tlb_global();
 	else
 		__flush_tlb();
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 64774f419c72..69b8f8a5ecb0 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -3693,7 +3693,7 @@</span> <span class="p_context"> static void fix_rmode_seg(int seg, struct kvm_segment *save)</span>
 	}
 
 	vmcs_write16(sf-&gt;selector, var.selector);
<span class="p_del">-	vmcs_write32(sf-&gt;base, var.base);</span>
<span class="p_add">+	vmcs_writel(sf-&gt;base, var.base);</span>
 	vmcs_write32(sf-&gt;limit, var.limit);
 	vmcs_write32(sf-&gt;ar_bytes, vmx_segment_access_rights(&amp;var));
 }
<span class="p_chunk">@@ -8202,7 +8202,7 @@</span> <span class="p_context"> static void kvm_flush_pml_buffers(struct kvm *kvm)</span>
 static void vmx_dump_sel(char *name, uint32_t sel)
 {
 	pr_err(&quot;%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\n&quot;,
<span class="p_del">-	       name, vmcs_read32(sel),</span>
<span class="p_add">+	       name, vmcs_read16(sel),</span>
 	       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),
 	       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),
 	       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));
<span class="p_header">diff --git a/arch/x86/mm/gup.c b/arch/x86/mm/gup.c</span>
<span class="p_header">index 0d4fb3ebbbac..1680768d392c 100644</span>
<span class="p_header">--- a/arch/x86/mm/gup.c</span>
<span class="p_header">+++ b/arch/x86/mm/gup.c</span>
<span class="p_chunk">@@ -120,6 +120,11 @@</span> <span class="p_context"> static noinline int gup_pte_range(pmd_t pmd, unsigned long addr,</span>
 			return 0;
 		}
 
<span class="p_add">+		if (!pte_allows_gup(pte_val(pte), write)) {</span>
<span class="p_add">+			pte_unmap(ptep);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (pte_devmap(pte)) {
 			pgmap = get_dev_pagemap(pte_pfn(pte), pgmap);
 			if (unlikely(!pgmap)) {
<span class="p_chunk">@@ -127,8 +132,7 @@</span> <span class="p_context"> static noinline int gup_pte_range(pmd_t pmd, unsigned long addr,</span>
 				pte_unmap(ptep);
 				return 0;
 			}
<span class="p_del">-		} else if (!pte_allows_gup(pte_val(pte), write) ||</span>
<span class="p_del">-			   pte_special(pte)) {</span>
<span class="p_add">+		} else if (pte_special(pte)) {</span>
 			pte_unmap(ptep);
 			return 0;
 		}
<span class="p_header">diff --git a/arch/xtensa/kernel/setup.c b/arch/xtensa/kernel/setup.c</span>
<span class="p_header">index 32cdc2c52e98..a45d32abea26 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/setup.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/setup.c</span>
<span class="p_chunk">@@ -133,6 +133,8 @@</span> <span class="p_context"> static int __init parse_tag_initrd(const bp_tag_t* tag)</span>
 
 __tagtable(BP_TAG_INITRD, parse_tag_initrd);
 
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_OF
 
 static int __init parse_tag_fdt(const bp_tag_t *tag)
<span class="p_chunk">@@ -145,8 +147,6 @@</span> <span class="p_context"> __tagtable(BP_TAG_FDT, parse_tag_fdt);</span>
 
 #endif /* CONFIG_OF */
 
<span class="p_del">-#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_del">-</span>
 static int __init parse_tag_cmdline(const bp_tag_t* tag)
 {
 	strlcpy(command_line, (char *)(tag-&gt;data), COMMAND_LINE_SIZE);
<span class="p_header">diff --git a/drivers/acpi/nfit/core.c b/drivers/acpi/nfit/core.c</span>
<span class="p_header">index 6eb6733a7a5c..d1664df001f8 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit/core.c</span>
<span class="p_header">+++ b/drivers/acpi/nfit/core.c</span>
<span class="p_chunk">@@ -1603,7 +1603,7 @@</span> <span class="p_context"> static size_t sizeof_nfit_set_info(int num_mappings)</span>
 		+ num_mappings * sizeof(struct nfit_set_info_map);
 }
 
<span class="p_del">-static int cmp_map(const void *m0, const void *m1)</span>
<span class="p_add">+static int cmp_map_compat(const void *m0, const void *m1)</span>
 {
 	const struct nfit_set_info_map *map0 = m0;
 	const struct nfit_set_info_map *map1 = m1;
<span class="p_chunk">@@ -1612,6 +1612,14 @@</span> <span class="p_context"> static int cmp_map(const void *m0, const void *m1)</span>
 			sizeof(u64));
 }
 
<span class="p_add">+static int cmp_map(const void *m0, const void *m1)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct nfit_set_info_map *map0 = m0;</span>
<span class="p_add">+	const struct nfit_set_info_map *map1 = m1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return map0-&gt;region_offset - map1-&gt;region_offset;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Retrieve the nth entry referencing this spa */
 static struct acpi_nfit_memory_map *memdev_from_spa(
 		struct acpi_nfit_desc *acpi_desc, u16 range_index, int n)
<span class="p_chunk">@@ -1667,6 +1675,12 @@</span> <span class="p_context"> static int acpi_nfit_init_interleave_set(struct acpi_nfit_desc *acpi_desc,</span>
 	sort(&amp;info-&gt;mapping[0], nr, sizeof(struct nfit_set_info_map),
 			cmp_map, NULL);
 	nd_set-&gt;cookie = nd_fletcher64(info, sizeof_nfit_set_info(nr), 0);
<span class="p_add">+</span>
<span class="p_add">+	/* support namespaces created with the wrong sort order */</span>
<span class="p_add">+	sort(&amp;info-&gt;mapping[0], nr, sizeof(struct nfit_set_info_map),</span>
<span class="p_add">+			cmp_map_compat, NULL);</span>
<span class="p_add">+	nd_set-&gt;altcookie = nd_fletcher64(info, sizeof_nfit_set_info(nr), 0);</span>
<span class="p_add">+</span>
 	ndr_desc-&gt;nd_set = nd_set;
 	devm_kfree(dev, info);
 
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index fadba88745dc..b793853ff05f 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -94,6 +94,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x04CA, 0x300f) },
 	{ USB_DEVICE(0x04CA, 0x3010) },
 	{ USB_DEVICE(0x04CA, 0x3014) },
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x3018) },</span>
 	{ USB_DEVICE(0x0930, 0x0219) },
 	{ USB_DEVICE(0x0930, 0x021c) },
 	{ USB_DEVICE(0x0930, 0x0220) },
<span class="p_chunk">@@ -162,6 +163,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3014), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x3018), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x021c), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 2f633df9f4e6..dd220fad366c 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -209,6 +209,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3014), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x3018), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x021c), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/dma/imx-sdma.c b/drivers/dma/imx-sdma.c</span>
<span class="p_header">index b9629b2bfc05..d1651a50c349 100644</span>
<span class="p_header">--- a/drivers/dma/imx-sdma.c</span>
<span class="p_header">+++ b/drivers/dma/imx-sdma.c</span>
<span class="p_chunk">@@ -298,6 +298,7 @@</span> <span class="p_context"> struct sdma_engine;</span>
  * @event_id1		for channels that use 2 events
  * @word_size		peripheral access size
  * @buf_tail		ID of the buffer that was processed
<span class="p_add">+ * @buf_ptail		ID of the previous buffer that was processed</span>
  * @num_bd		max NUM_BD. number of descriptors currently handling
  */
 struct sdma_channel {
<span class="p_chunk">@@ -309,6 +310,7 @@</span> <span class="p_context"> struct sdma_channel {</span>
 	unsigned int			event_id1;
 	enum dma_slave_buswidth		word_size;
 	unsigned int			buf_tail;
<span class="p_add">+	unsigned int			buf_ptail;</span>
 	unsigned int			num_bd;
 	unsigned int			period_len;
 	struct sdma_buffer_descriptor	*bd;
<span class="p_chunk">@@ -700,6 +702,8 @@</span> <span class="p_context"> static void sdma_update_channel_loop(struct sdma_channel *sdmac)</span>
 		sdmac-&gt;chn_real_count = bd-&gt;mode.count;
 		bd-&gt;mode.status |= BD_DONE;
 		bd-&gt;mode.count = sdmac-&gt;period_len;
<span class="p_add">+		sdmac-&gt;buf_ptail = sdmac-&gt;buf_tail;</span>
<span class="p_add">+		sdmac-&gt;buf_tail = (sdmac-&gt;buf_tail + 1) % sdmac-&gt;num_bd;</span>
 
 		/*
 		 * The callback is called from the interrupt context in order
<span class="p_chunk">@@ -710,9 +714,6 @@</span> <span class="p_context"> static void sdma_update_channel_loop(struct sdma_channel *sdmac)</span>
 
 		dmaengine_desc_get_callback_invoke(&amp;sdmac-&gt;desc, NULL);
 
<span class="p_del">-		sdmac-&gt;buf_tail++;</span>
<span class="p_del">-		sdmac-&gt;buf_tail %= sdmac-&gt;num_bd;</span>
<span class="p_del">-</span>
 		if (error)
 			sdmac-&gt;status = old_status;
 	}
<span class="p_chunk">@@ -1186,6 +1187,8 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *sdma_prep_slave_sg(</span>
 	sdmac-&gt;flags = 0;
 
 	sdmac-&gt;buf_tail = 0;
<span class="p_add">+	sdmac-&gt;buf_ptail = 0;</span>
<span class="p_add">+	sdmac-&gt;chn_real_count = 0;</span>
 
 	dev_dbg(sdma-&gt;dev, &quot;setting up %d entries for channel %d.\n&quot;,
 			sg_len, channel);
<span class="p_chunk">@@ -1288,6 +1291,8 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *sdma_prep_dma_cyclic(</span>
 	sdmac-&gt;status = DMA_IN_PROGRESS;
 
 	sdmac-&gt;buf_tail = 0;
<span class="p_add">+	sdmac-&gt;buf_ptail = 0;</span>
<span class="p_add">+	sdmac-&gt;chn_real_count = 0;</span>
 	sdmac-&gt;period_len = period_len;
 
 	sdmac-&gt;flags |= IMX_DMA_SG_LOOP;
<span class="p_chunk">@@ -1385,7 +1390,7 @@</span> <span class="p_context"> static enum dma_status sdma_tx_status(struct dma_chan *chan,</span>
 	u32 residue;
 
 	if (sdmac-&gt;flags &amp; IMX_DMA_SG_LOOP)
<span class="p_del">-		residue = (sdmac-&gt;num_bd - sdmac-&gt;buf_tail) *</span>
<span class="p_add">+		residue = (sdmac-&gt;num_bd - sdmac-&gt;buf_ptail) *</span>
 			   sdmac-&gt;period_len - sdmac-&gt;chn_real_count;
 	else
 		residue = sdmac-&gt;chn_count - sdmac-&gt;chn_real_count;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">index 7ddc32127d88..64a1df62cc65 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_chunk">@@ -3814,9 +3814,15 @@</span> <span class="p_context"> static void dce_v11_0_encoder_add(struct amdgpu_device *adev,</span>
 	default:
 		encoder-&gt;possible_crtcs = 0x3;
 		break;
<span class="p_add">+	case 3:</span>
<span class="p_add">+		encoder-&gt;possible_crtcs = 0x7;</span>
<span class="p_add">+		break;</span>
 	case 4:
 		encoder-&gt;possible_crtcs = 0xf;
 		break;
<span class="p_add">+	case 5:</span>
<span class="p_add">+		encoder-&gt;possible_crtcs = 0x1f;</span>
<span class="p_add">+		break;</span>
 	case 6:
 		encoder-&gt;possible_crtcs = 0x3f;
 		break;
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_post.c b/drivers/gpu/drm/ast/ast_post.c</span>
<span class="p_header">index 810c51d92b99..30672a3df8a9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_post.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_post.c</span>
<span class="p_chunk">@@ -58,13 +58,9 @@</span> <span class="p_context"> bool ast_is_vga_enabled(struct drm_device *dev)</span>
 		/* TODO 1180 */
 	} else {
 		ch = ast_io_read8(ast, AST_IO_VGA_ENABLE_PORT);
<span class="p_del">-		if (ch) {</span>
<span class="p_del">-			ast_open_key(ast);</span>
<span class="p_del">-			ch = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb6, 0xff);</span>
<span class="p_del">-			return ch &amp; 0x04;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		return !!(ch &amp; 0x01);</span>
 	}
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return false;</span>
 }
 
 static const u8 extreginfo[] = { 0x0f, 0x04, 0x1c, 0xff };
<span class="p_chunk">@@ -375,8 +371,8 @@</span> <span class="p_context"> void ast_post_gpu(struct drm_device *dev)</span>
 	pci_write_config_dword(ast-&gt;dev-&gt;pdev, 0x04, reg);
 
 	ast_enable_vga(dev);
<span class="p_del">-	ast_enable_mmio(dev);</span>
 	ast_open_key(ast);
<span class="p_add">+	ast_enable_mmio(dev);</span>
 	ast_set_def_ext_reg(dev);
 
 	if (ast-&gt;chip == AST2300 || ast-&gt;chip == AST2400)
<span class="p_chunk">@@ -1630,12 +1626,44 @@</span> <span class="p_context"> static void ast_init_dram_2300(struct drm_device *dev)</span>
 		temp |= 0x73;
 		ast_write32(ast, 0x12008, temp);
 
<span class="p_add">+		param.dram_freq = 396;</span>
 		param.dram_type = AST_DDR3;
<span class="p_add">+		temp = ast_mindwm(ast, 0x1e6e2070);</span>
 		if (temp &amp; 0x01000000)
 			param.dram_type = AST_DDR2;
<span class="p_del">-		param.dram_chipid = ast-&gt;dram_type;</span>
<span class="p_del">-		param.dram_freq = ast-&gt;mclk;</span>
<span class="p_del">-		param.vram_size = ast-&gt;vram_size;</span>
<span class="p_add">+                switch (temp &amp; 0x18000000) {</span>
<span class="p_add">+		case 0:</span>
<span class="p_add">+			param.dram_chipid = AST_DRAM_512Mx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+		case 0x08000000:</span>
<span class="p_add">+			param.dram_chipid = AST_DRAM_1Gx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x10000000:</span>
<span class="p_add">+			param.dram_chipid = AST_DRAM_2Gx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x18000000:</span>
<span class="p_add">+			param.dram_chipid = AST_DRAM_4Gx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+                switch (temp &amp; 0x0c) {</span>
<span class="p_add">+                default:</span>
<span class="p_add">+		case 0x00:</span>
<span class="p_add">+			param.vram_size = AST_VIDMEM_SIZE_8M;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		case 0x04:</span>
<span class="p_add">+			param.vram_size = AST_VIDMEM_SIZE_16M;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		case 0x08:</span>
<span class="p_add">+			param.vram_size = AST_VIDMEM_SIZE_32M;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		case 0x0c:</span>
<span class="p_add">+			param.vram_size = AST_VIDMEM_SIZE_64M;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
 		if (param.dram_type == AST_DDR3) {
 			get_ddr3_info(ast, &amp;param);
<span class="p_header">diff --git a/drivers/gpu/drm/drm_atomic_helper.c b/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_header">index a05bb3891119..2e42a0584a84 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_chunk">@@ -362,7 +362,7 @@</span> <span class="p_context"> mode_fixup(struct drm_atomic_state *state)</span>
 	struct drm_connector *connector;
 	struct drm_connector_state *conn_state;
 	int i;
<span class="p_del">-	bool ret;</span>
<span class="p_add">+	int ret;</span>
 
 	for_each_crtc_in_state(state, crtc, crtc_state, i) {
 		if (!crtc_state-&gt;mode_changed &amp;&amp;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">index ec77bd3e1f08..7491180698d1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_chunk">@@ -145,6 +145,9 @@</span> <span class="p_context"> static struct edid_quirk {</span>
 
 	/* Panel in Samsung NP700G7A-S01PL notebook reports 6bpc */
 	{ &quot;SEC&quot;, 0xd033, EDID_QUIRK_FORCE_8BPC },
<span class="p_add">+</span>
<span class="p_add">+	/* Rotel RSX-1058 forwards sink&#39;s EDID but only does HDMI 1.1*/</span>
<span class="p_add">+	{ &quot;ETR&quot;, 13896, EDID_QUIRK_FORCE_8BPC },</span>
 };
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">index 6c75e62c0b22..6a48d6637e5c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_chunk">@@ -848,6 +848,9 @@</span> <span class="p_context"> void drm_fb_helper_fini(struct drm_fb_helper *fb_helper)</span>
 	if (!drm_fbdev_emulation)
 		return;
 
<span class="p_add">+	cancel_work_sync(&amp;fb_helper-&gt;resume_work);</span>
<span class="p_add">+	cancel_work_sync(&amp;fb_helper-&gt;dirty_work);</span>
<span class="p_add">+</span>
 	if (!list_empty(&amp;fb_helper-&gt;kernel_fb_list)) {
 		list_del(&amp;fb_helper-&gt;kernel_fb_list);
 		if (list_empty(&amp;kernel_fb_helper_list)) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_stolen.c b/drivers/gpu/drm/i915/i915_gem_stolen.c</span>
<span class="p_header">index 9a71ed546b90..f46aac1e85fb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_stolen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_stolen.c</span>
<span class="p_chunk">@@ -415,6 +415,11 @@</span> <span class="p_context"> int i915_gem_init_stolen(struct drm_device *dev)</span>
 
 	mutex_init(&amp;dev_priv-&gt;mm.stolen_lock);
 
<span class="p_add">+	if (intel_vgpu_active(dev_priv)) {</span>
<span class="p_add">+		DRM_INFO(&quot;iGVT-g active, disabling use of stolen memory\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_INTEL_IOMMU
 	if (intel_iommu_gfx_mapped &amp;&amp; INTEL_INFO(dev)-&gt;gen &lt; 8) {
 		DRM_INFO(&quot;DMAR active, disabling use of stolen memory\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index 055525013d2f..7b06280b23aa 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -2832,6 +2832,9 @@</span> <span class="p_context"> static void vlv_detach_power_sequencer(struct intel_dp *intel_dp)</span>
 	enum pipe pipe = intel_dp-&gt;pps_pipe;
 	i915_reg_t pp_on_reg = PP_ON_DELAYS(pipe);
 
<span class="p_add">+	if (WARN_ON(pipe != PIPE_A &amp;&amp; pipe != PIPE_B))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	edp_panel_vdd_off_sync(intel_dp);
 
 	/*
<span class="p_chunk">@@ -2859,9 +2862,6 @@</span> <span class="p_context"> static void vlv_steal_power_sequencer(struct drm_device *dev,</span>
 
 	lockdep_assert_held(&amp;dev_priv-&gt;pps_mutex);
 
<span class="p_del">-	if (WARN_ON(pipe != PIPE_A &amp;&amp; pipe != PIPE_B))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	for_each_intel_encoder(dev, encoder) {
 		struct intel_dp *intel_dp;
 		enum port port;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_opregion.c b/drivers/gpu/drm/i915/intel_opregion.c</span>
<span class="p_header">index 7acbbbf97833..4534e4cadccf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_opregion.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_opregion.c</span>
<span class="p_chunk">@@ -1031,7 +1031,18 @@</span> <span class="p_context"> int intel_opregion_setup(struct drm_i915_private *dev_priv)</span>
 			opregion-&gt;vbt_size = vbt_size;
 		} else {
 			vbt = base + OPREGION_VBT_OFFSET;
<span class="p_del">-			vbt_size = OPREGION_ASLE_EXT_OFFSET - OPREGION_VBT_OFFSET;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The VBT specification says that if the ASLE ext</span>
<span class="p_add">+			 * mailbox is not used its area is reserved, but</span>
<span class="p_add">+			 * on some CHT boards the VBT extends into the</span>
<span class="p_add">+			 * ASLE ext area. Allow this even though it is</span>
<span class="p_add">+			 * against the spec, so we do not end up rejecting</span>
<span class="p_add">+			 * the VBT on those boards (and end up not finding the</span>
<span class="p_add">+			 * LCD panel because of this).</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			vbt_size = (mboxes &amp; MBOX_ASLE_EXT) ?</span>
<span class="p_add">+				OPREGION_ASLE_EXT_OFFSET : OPREGION_SIZE;</span>
<span class="p_add">+			vbt_size -= OPREGION_VBT_OFFSET;</span>
 			if (intel_bios_is_valid_vbt(vbt, vbt_size)) {
 				DRM_DEBUG_KMS(&quot;Found valid VBT in ACPI OpRegion (Mailbox #4)\n&quot;);
 				opregion-&gt;vbt = vbt;
<span class="p_header">diff --git a/drivers/gpu/drm/imx/imx-tve.c b/drivers/gpu/drm/imx/imx-tve.c</span>
<span class="p_header">index 8fc088843e55..89cf0090feac 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/imx/imx-tve.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/imx/imx-tve.c</span>
<span class="p_chunk">@@ -98,6 +98,8 @@</span> <span class="p_context"></span>
 /* TVE_TST_MODE_REG */
 #define TVE_TVDAC_TEST_MODE_MASK	(0x7 &lt;&lt; 0)
 
<span class="p_add">+#define IMX_TVE_DAC_VOLTAGE	2750000</span>
<span class="p_add">+</span>
 enum {
 	TVE_MODE_TVOUT,
 	TVE_MODE_VGA,
<span class="p_chunk">@@ -628,9 +630,8 @@</span> <span class="p_context"> static int imx_tve_bind(struct device *dev, struct device *master, void *data)</span>
 
 	tve-&gt;dac_reg = devm_regulator_get(dev, &quot;dac&quot;);
 	if (!IS_ERR(tve-&gt;dac_reg)) {
<span class="p_del">-		ret = regulator_set_voltage(tve-&gt;dac_reg, 2750000, 2750000);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_add">+		if (regulator_get_voltage(tve-&gt;dac_reg) != IMX_TVE_DAC_VOLTAGE)</span>
<span class="p_add">+			dev_warn(dev, &quot;dac voltage is not %d uV\n&quot;, IMX_TVE_DAC_VOLTAGE);</span>
 		ret = regulator_enable(tve-&gt;dac_reg);
 		if (ret)
 			return ret;
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_bo.c b/drivers/gpu/drm/ttm/ttm_bo.c</span>
<span class="p_header">index fc6217dfe401..35cc16f9fec9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_bo.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_bo.c</span>
<span class="p_chunk">@@ -1654,7 +1654,6 @@</span> <span class="p_context"> static int ttm_bo_swapout(struct ttm_mem_shrink *shrink)</span>
 	struct ttm_buffer_object *bo;
 	int ret = -EBUSY;
 	int put_count;
<span class="p_del">-	uint32_t swap_placement = (TTM_PL_FLAG_CACHED | TTM_PL_FLAG_SYSTEM);</span>
 
 	spin_lock(&amp;glob-&gt;lru_lock);
 	list_for_each_entry(bo, &amp;glob-&gt;swap_lru, swap) {
<span class="p_chunk">@@ -1685,7 +1684,8 @@</span> <span class="p_context"> static int ttm_bo_swapout(struct ttm_mem_shrink *shrink)</span>
 	 * Move to system cached
 	 */
 
<span class="p_del">-	if ((bo-&gt;mem.placement &amp; swap_placement) != swap_placement) {</span>
<span class="p_add">+	if (bo-&gt;mem.mem_type != TTM_PL_SYSTEM ||</span>
<span class="p_add">+	    bo-&gt;ttm-&gt;caching_state != tt_cached) {</span>
 		struct ttm_mem_reg evict_mem;
 
 		evict_mem = bo-&gt;mem;
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">index 18061a4bc2f2..36005bdf3749 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_chunk">@@ -199,9 +199,14 @@</span> <span class="p_context"> static const struct drm_ioctl_desc vmw_ioctls[] = {</span>
 	VMW_IOCTL_DEF(VMW_PRESENT_READBACK,
 		      vmw_present_readback_ioctl,
 		      DRM_MASTER | DRM_AUTH),
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The permissions of the below ioctl are overridden in</span>
<span class="p_add">+	 * vmw_generic_ioctl(). We require either</span>
<span class="p_add">+	 * DRM_MASTER or capable(CAP_SYS_ADMIN).</span>
<span class="p_add">+	 */</span>
 	VMW_IOCTL_DEF(VMW_UPDATE_LAYOUT,
 		      vmw_kms_update_layout_ioctl,
<span class="p_del">-		      DRM_MASTER | DRM_CONTROL_ALLOW),</span>
<span class="p_add">+		      DRM_RENDER_ALLOW),</span>
 	VMW_IOCTL_DEF(VMW_CREATE_SHADER,
 		      vmw_shader_define_ioctl,
 		      DRM_AUTH | DRM_RENDER_ALLOW),
<span class="p_chunk">@@ -1125,6 +1130,10 @@</span> <span class="p_context"> static long vmw_generic_ioctl(struct file *filp, unsigned int cmd,</span>
 
 			return (long) vmw_execbuf_ioctl(dev, arg, file_priv,
 							_IOC_SIZE(cmd));
<span class="p_add">+		} else if (nr == DRM_COMMAND_BASE + DRM_VMW_UPDATE_LAYOUT) {</span>
<span class="p_add">+			if (!drm_is_current_master(file_priv) &amp;&amp;</span>
<span class="p_add">+			    !capable(CAP_SYS_ADMIN))</span>
<span class="p_add">+				return -EACCES;</span>
 		}
 
 		if (unlikely(ioctl-&gt;cmd != cmd))
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h</span>
<span class="p_header">index 1e59a486bba8..59ff4197173a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h</span>
<span class="p_chunk">@@ -41,9 +41,9 @@</span> <span class="p_context"></span>
 #include &lt;drm/ttm/ttm_module.h&gt;
 #include &quot;vmwgfx_fence.h&quot;
 
<span class="p_del">-#define VMWGFX_DRIVER_DATE &quot;20160210&quot;</span>
<span class="p_add">+#define VMWGFX_DRIVER_DATE &quot;20170221&quot;</span>
 #define VMWGFX_DRIVER_MAJOR 2
<span class="p_del">-#define VMWGFX_DRIVER_MINOR 11</span>
<span class="p_add">+#define VMWGFX_DRIVER_MINOR 12</span>
 #define VMWGFX_DRIVER_PATCHLEVEL 0
 #define VMWGFX_FILE_PAGE_OFFSET 0x00100000
 #define VMWGFX_FIFO_STATIC_SIZE (1024*1024)
<span class="p_header">diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c</span>
<span class="p_header">index 6e49a4dd99c0..e0a8216ecf2b 100644</span>
<span class="p_header">--- a/drivers/hv/hv.c</span>
<span class="p_header">+++ b/drivers/hv/hv.c</span>
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> int hv_init(void)</span>
 	/* See if the hypercall page is already set */
 	rdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 
<span class="p_del">-	virtaddr = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL_EXEC);</span>
<span class="p_add">+	virtaddr = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL_RX);</span>
 
 	if (!virtaddr)
 		goto cleanup;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/srq.c b/drivers/infiniband/hw/mlx5/srq.c</span>
<span class="p_header">index 729b0696626e..d61fd2c727c0 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/srq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/srq.c</span>
<span class="p_chunk">@@ -165,8 +165,6 @@</span> <span class="p_context"> static int create_srq_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_srq *srq,</span>
 	int err;
 	int i;
 	struct mlx5_wqe_srq_next_seg *next;
<span class="p_del">-	int page_shift;</span>
<span class="p_del">-	int npages;</span>
 
 	err = mlx5_db_alloc(dev-&gt;mdev, &amp;srq-&gt;db);
 	if (err) {
<span class="p_chunk">@@ -179,7 +177,6 @@</span> <span class="p_context"> static int create_srq_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_srq *srq,</span>
 		err = -ENOMEM;
 		goto err_db;
 	}
<span class="p_del">-	page_shift = srq-&gt;buf.page_shift;</span>
 
 	srq-&gt;head    = 0;
 	srq-&gt;tail    = srq-&gt;msrq.max - 1;
<span class="p_chunk">@@ -191,10 +188,8 @@</span> <span class="p_context"> static int create_srq_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_srq *srq,</span>
 			cpu_to_be16((i + 1) &amp; (srq-&gt;msrq.max - 1));
 	}
 
<span class="p_del">-	npages = DIV_ROUND_UP(srq-&gt;buf.npages, 1 &lt;&lt; (page_shift - PAGE_SHIFT));</span>
<span class="p_del">-	mlx5_ib_dbg(dev, &quot;buf_size %d, page_shift %d, npages %d, calc npages %d\n&quot;,</span>
<span class="p_del">-		    buf_size, page_shift, srq-&gt;buf.npages, npages);</span>
<span class="p_del">-	in-&gt;pas = mlx5_vzalloc(sizeof(*in-&gt;pas) * npages);</span>
<span class="p_add">+	mlx5_ib_dbg(dev, &quot;srq-&gt;buf.page_shift = %d\n&quot;, srq-&gt;buf.page_shift);</span>
<span class="p_add">+	in-&gt;pas = mlx5_vzalloc(sizeof(*in-&gt;pas) * srq-&gt;buf.npages);</span>
 	if (!in-&gt;pas) {
 		err = -ENOMEM;
 		goto err_buf;
<span class="p_chunk">@@ -210,7 +205,7 @@</span> <span class="p_context"> static int create_srq_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_srq *srq,</span>
 	}
 	srq-&gt;wq_sig = !!srq_signature;
 
<span class="p_del">-	in-&gt;log_page_size = page_shift - MLX5_ADAPTER_PAGE_SHIFT;</span>
<span class="p_add">+	in-&gt;log_page_size = srq-&gt;buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT;</span>
 	if (MLX5_CAP_GEN(dev-&gt;mdev, cqe_version) == MLX5_CQE_VERSION_V1 &amp;&amp;
 	    in-&gt;type == IB_SRQT_XRC)
 		in-&gt;user_index = MLX5_IB_DEFAULT_UIDX;
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 81a8080c18b3..0616a65f0d78 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -1511,12 +1511,14 @@</span> <span class="p_context"> static ssize_t set_mode(struct device *d, struct device_attribute *attr,</span>
 
 	ret = ipoib_set_mode(dev, buf);
 
<span class="p_del">-	rtnl_unlock();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ret)</span>
<span class="p_del">-		return count;</span>
<span class="p_add">+	/* The assumption is that the function ipoib_set_mode returned</span>
<span class="p_add">+	 * with the rtnl held by it, if not the value -EBUSY returned,</span>
<span class="p_add">+	 * then no need to rtnl_unlock</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ret != -EBUSY)</span>
<span class="p_add">+		rtnl_unlock();</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return (!ret || ret == -EBUSY) ? count : ret;</span>
 }
 
 static DEVICE_ATTR(mode, S_IWUSR | S_IRUGO, show_mode, set_mode);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index b58d9dca5c93..3ef7b8f049c4 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -468,8 +468,7 @@</span> <span class="p_context"> int ipoib_set_mode(struct net_device *dev, const char *buf)</span>
 		priv-&gt;tx_wr.wr.send_flags &amp;= ~IB_SEND_IP_CSUM;
 
 		ipoib_flush_paths(dev);
<span class="p_del">-		rtnl_lock();</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return (!rtnl_trylock()) ? -EBUSY : 0;</span>
 	}
 
 	if (!strcmp(buf, &quot;datagram\n&quot;)) {
<span class="p_chunk">@@ -478,8 +477,7 @@</span> <span class="p_context"> int ipoib_set_mode(struct net_device *dev, const char *buf)</span>
 		dev_set_mtu(dev, min(priv-&gt;mcast_mtu, dev-&gt;mtu));
 		rtnl_unlock();
 		ipoib_flush_paths(dev);
<span class="p_del">-		rtnl_lock();</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return (!rtnl_trylock()) ? -EBUSY : 0;</span>
 	}
 
 	return -EINVAL;
<span class="p_chunk">@@ -703,6 +701,14 @@</span> <span class="p_context"> int ipoib_check_sm_sendonly_fullmember_support(struct ipoib_dev_priv *priv)</span>
 	return ret;
 }
 
<span class="p_add">+static void push_pseudo_header(struct sk_buff *skb, const char *daddr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ipoib_pseudo_header *phdr;</span>
<span class="p_add">+</span>
<span class="p_add">+	phdr = (struct ipoib_pseudo_header *)skb_push(skb, sizeof(*phdr));</span>
<span class="p_add">+	memcpy(phdr-&gt;hwaddr, daddr, INFINIBAND_ALEN);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void ipoib_flush_paths(struct net_device *dev)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
<span class="p_chunk">@@ -927,8 +933,7 @@</span> <span class="p_context"> static void neigh_add_path(struct sk_buff *skb, u8 *daddr,</span>
 			}
 			if (skb_queue_len(&amp;neigh-&gt;queue) &lt;
 			    IPOIB_MAX_PATH_REC_QUEUE) {
<span class="p_del">-				/* put pseudoheader back on for next time */</span>
<span class="p_del">-				skb_push(skb, IPOIB_PSEUDO_LEN);</span>
<span class="p_add">+				push_pseudo_header(skb, neigh-&gt;daddr);</span>
 				__skb_queue_tail(&amp;neigh-&gt;queue, skb);
 			} else {
 				ipoib_warn(priv, &quot;queue length limit %d. Packet drop.\n&quot;,
<span class="p_chunk">@@ -946,10 +951,12 @@</span> <span class="p_context"> static void neigh_add_path(struct sk_buff *skb, u8 *daddr,</span>
 
 		if (!path-&gt;query &amp;&amp; path_rec_start(dev, path))
 			goto err_path;
<span class="p_del">-		if (skb_queue_len(&amp;neigh-&gt;queue) &lt; IPOIB_MAX_PATH_REC_QUEUE)</span>
<span class="p_add">+		if (skb_queue_len(&amp;neigh-&gt;queue) &lt; IPOIB_MAX_PATH_REC_QUEUE) {</span>
<span class="p_add">+			push_pseudo_header(skb, neigh-&gt;daddr);</span>
 			__skb_queue_tail(&amp;neigh-&gt;queue, skb);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			goto err_drop;
<span class="p_add">+		}</span>
 	}
 
 	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
<span class="p_chunk">@@ -985,8 +992,7 @@</span> <span class="p_context"> static void unicast_arp_send(struct sk_buff *skb, struct net_device *dev,</span>
 		}
 		if (path) {
 			if (skb_queue_len(&amp;path-&gt;queue) &lt; IPOIB_MAX_PATH_REC_QUEUE) {
<span class="p_del">-				/* put pseudoheader back on for next time */</span>
<span class="p_del">-				skb_push(skb, IPOIB_PSEUDO_LEN);</span>
<span class="p_add">+				push_pseudo_header(skb, phdr-&gt;hwaddr);</span>
 				__skb_queue_tail(&amp;path-&gt;queue, skb);
 			} else {
 				++dev-&gt;stats.tx_dropped;
<span class="p_chunk">@@ -1018,8 +1024,7 @@</span> <span class="p_context"> static void unicast_arp_send(struct sk_buff *skb, struct net_device *dev,</span>
 		return;
 	} else if ((path-&gt;query || !path_rec_start(dev, path)) &amp;&amp;
 		   skb_queue_len(&amp;path-&gt;queue) &lt; IPOIB_MAX_PATH_REC_QUEUE) {
<span class="p_del">-		/* put pseudoheader back on for next time */</span>
<span class="p_del">-		skb_push(skb, IPOIB_PSEUDO_LEN);</span>
<span class="p_add">+		push_pseudo_header(skb, phdr-&gt;hwaddr);</span>
 		__skb_queue_tail(&amp;path-&gt;queue, skb);
 	} else {
 		++dev-&gt;stats.tx_dropped;
<span class="p_chunk">@@ -1100,8 +1105,7 @@</span> <span class="p_context"> static int ipoib_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	}
 
 	if (skb_queue_len(&amp;neigh-&gt;queue) &lt; IPOIB_MAX_PATH_REC_QUEUE) {
<span class="p_del">-		/* put pseudoheader back on for next time */</span>
<span class="p_del">-		skb_push(skb, sizeof(*phdr));</span>
<span class="p_add">+		push_pseudo_header(skb, phdr-&gt;hwaddr);</span>
 		spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 		__skb_queue_tail(&amp;neigh-&gt;queue, skb);
 		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
<span class="p_chunk">@@ -1133,7 +1137,6 @@</span> <span class="p_context"> static int ipoib_hard_header(struct sk_buff *skb,</span>
 			     unsigned short type,
 			     const void *daddr, const void *saddr, unsigned len)
 {
<span class="p_del">-	struct ipoib_pseudo_header *phdr;</span>
 	struct ipoib_header *header;
 
 	header = (struct ipoib_header *) skb_push(skb, sizeof *header);
<span class="p_chunk">@@ -1146,8 +1149,7 @@</span> <span class="p_context"> static int ipoib_hard_header(struct sk_buff *skb,</span>
 	 * destination address into skb hard header so we can figure out where
 	 * to send the packet later.
 	 */
<span class="p_del">-	phdr = (struct ipoib_pseudo_header *) skb_push(skb, sizeof(*phdr));</span>
<span class="p_del">-	memcpy(phdr-&gt;hwaddr, daddr, INFINIBAND_ALEN);</span>
<span class="p_add">+	push_pseudo_header(skb, daddr);</span>
 
 	return IPOIB_HARD_LEN;
 }
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index e7dcf14a76e2..1eee8f7e75ca 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -366,7 +366,6 @@</span> <span class="p_context"> static struct srp_fr_pool *srp_create_fr_pool(struct ib_device *device,</span>
 	struct srp_fr_desc *d;
 	struct ib_mr *mr;
 	int i, ret = -EINVAL;
<span class="p_del">-	enum ib_mr_type mr_type;</span>
 
 	if (pool_size &lt;= 0)
 		goto err;
<span class="p_chunk">@@ -380,13 +379,9 @@</span> <span class="p_context"> static struct srp_fr_pool *srp_create_fr_pool(struct ib_device *device,</span>
 	spin_lock_init(&amp;pool-&gt;lock);
 	INIT_LIST_HEAD(&amp;pool-&gt;free_list);
 
<span class="p_del">-	if (device-&gt;attrs.device_cap_flags &amp; IB_DEVICE_SG_GAPS_REG)</span>
<span class="p_del">-		mr_type = IB_MR_TYPE_SG_GAPS;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		mr_type = IB_MR_TYPE_MEM_REG;</span>
<span class="p_del">-</span>
 	for (i = 0, d = &amp;pool-&gt;desc[0]; i &lt; pool-&gt;size; i++, d++) {
<span class="p_del">-		mr = ib_alloc_mr(pd, mr_type, max_page_list_len);</span>
<span class="p_add">+		mr = ib_alloc_mr(pd, IB_MR_TYPE_MEM_REG,</span>
<span class="p_add">+				 max_page_list_len);</span>
 		if (IS_ERR(mr)) {
 			ret = PTR_ERR(mr);
 			goto destroy_pool;
<span class="p_chunk">@@ -1877,17 +1872,24 @@</span> <span class="p_context"> static void srp_process_rsp(struct srp_rdma_ch *ch, struct srp_rsp *rsp)</span>
 	if (unlikely(rsp-&gt;tag &amp; SRP_TAG_TSK_MGMT)) {
 		spin_lock_irqsave(&amp;ch-&gt;lock, flags);
 		ch-&gt;req_lim += be32_to_cpu(rsp-&gt;req_lim_delta);
<span class="p_add">+		if (rsp-&gt;tag == ch-&gt;tsk_mgmt_tag) {</span>
<span class="p_add">+			ch-&gt;tsk_mgmt_status = -1;</span>
<span class="p_add">+			if (be32_to_cpu(rsp-&gt;resp_data_len) &gt;= 4)</span>
<span class="p_add">+				ch-&gt;tsk_mgmt_status = rsp-&gt;data[3];</span>
<span class="p_add">+			complete(&amp;ch-&gt;tsk_mgmt_done);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			shost_printk(KERN_ERR, target-&gt;scsi_host,</span>
<span class="p_add">+				     &quot;Received tsk mgmt response too late for tag %#llx\n&quot;,</span>
<span class="p_add">+				     rsp-&gt;tag);</span>
<span class="p_add">+		}</span>
 		spin_unlock_irqrestore(&amp;ch-&gt;lock, flags);
<span class="p_del">-</span>
<span class="p_del">-		ch-&gt;tsk_mgmt_status = -1;</span>
<span class="p_del">-		if (be32_to_cpu(rsp-&gt;resp_data_len) &gt;= 4)</span>
<span class="p_del">-			ch-&gt;tsk_mgmt_status = rsp-&gt;data[3];</span>
<span class="p_del">-		complete(&amp;ch-&gt;tsk_mgmt_done);</span>
 	} else {
 		scmnd = scsi_host_find_tag(target-&gt;scsi_host, rsp-&gt;tag);
<span class="p_del">-		if (scmnd) {</span>
<span class="p_add">+		if (scmnd &amp;&amp; scmnd-&gt;host_scribble) {</span>
 			req = (void *)scmnd-&gt;host_scribble;
 			scmnd = srp_claim_req(ch, req, NULL, scmnd);
<span class="p_add">+		} else {</span>
<span class="p_add">+			scmnd = NULL;</span>
 		}
 		if (!scmnd) {
 			shost_printk(KERN_ERR, target-&gt;scsi_host,
<span class="p_chunk">@@ -2519,19 +2521,18 @@</span> <span class="p_context"> srp_change_queue_depth(struct scsi_device *sdev, int qdepth)</span>
 }
 
 static int srp_send_tsk_mgmt(struct srp_rdma_ch *ch, u64 req_tag, u64 lun,
<span class="p_del">-			     u8 func)</span>
<span class="p_add">+			     u8 func, u8 *status)</span>
 {
 	struct srp_target_port *target = ch-&gt;target;
 	struct srp_rport *rport = target-&gt;rport;
 	struct ib_device *dev = target-&gt;srp_host-&gt;srp_dev-&gt;dev;
 	struct srp_iu *iu;
 	struct srp_tsk_mgmt *tsk_mgmt;
<span class="p_add">+	int res;</span>
 
 	if (!ch-&gt;connected || target-&gt;qp_in_error)
 		return -1;
 
<span class="p_del">-	init_completion(&amp;ch-&gt;tsk_mgmt_done);</span>
<span class="p_del">-</span>
 	/*
 	 * Lock the rport mutex to avoid that srp_create_ch_ib() is
 	 * invoked while a task management function is being sent.
<span class="p_chunk">@@ -2554,10 +2555,16 @@</span> <span class="p_context"> static int srp_send_tsk_mgmt(struct srp_rdma_ch *ch, u64 req_tag, u64 lun,</span>
 
 	tsk_mgmt-&gt;opcode 	= SRP_TSK_MGMT;
 	int_to_scsilun(lun, &amp;tsk_mgmt-&gt;lun);
<span class="p_del">-	tsk_mgmt-&gt;tag		= req_tag | SRP_TAG_TSK_MGMT;</span>
 	tsk_mgmt-&gt;tsk_mgmt_func = func;
 	tsk_mgmt-&gt;task_tag	= req_tag;
 
<span class="p_add">+	spin_lock_irq(&amp;ch-&gt;lock);</span>
<span class="p_add">+	ch-&gt;tsk_mgmt_tag = (ch-&gt;tsk_mgmt_tag + 1) | SRP_TAG_TSK_MGMT;</span>
<span class="p_add">+	tsk_mgmt-&gt;tag = ch-&gt;tsk_mgmt_tag;</span>
<span class="p_add">+	spin_unlock_irq(&amp;ch-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	init_completion(&amp;ch-&gt;tsk_mgmt_done);</span>
<span class="p_add">+</span>
 	ib_dma_sync_single_for_device(dev, iu-&gt;dma, sizeof *tsk_mgmt,
 				      DMA_TO_DEVICE);
 	if (srp_post_send(ch, iu, sizeof(*tsk_mgmt))) {
<span class="p_chunk">@@ -2566,13 +2573,15 @@</span> <span class="p_context"> static int srp_send_tsk_mgmt(struct srp_rdma_ch *ch, u64 req_tag, u64 lun,</span>
 
 		return -1;
 	}
<span class="p_add">+	res = wait_for_completion_timeout(&amp;ch-&gt;tsk_mgmt_done,</span>
<span class="p_add">+					msecs_to_jiffies(SRP_ABORT_TIMEOUT_MS));</span>
<span class="p_add">+	if (res &gt; 0 &amp;&amp; status)</span>
<span class="p_add">+		*status = ch-&gt;tsk_mgmt_status;</span>
 	mutex_unlock(&amp;rport-&gt;mutex);
 
<span class="p_del">-	if (!wait_for_completion_timeout(&amp;ch-&gt;tsk_mgmt_done,</span>
<span class="p_del">-					 msecs_to_jiffies(SRP_ABORT_TIMEOUT_MS)))</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+	WARN_ON_ONCE(res &lt; 0);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return res &gt; 0 ? 0 : -1;</span>
 }
 
 static int srp_abort(struct scsi_cmnd *scmnd)
<span class="p_chunk">@@ -2598,7 +2607,7 @@</span> <span class="p_context"> static int srp_abort(struct scsi_cmnd *scmnd)</span>
 	shost_printk(KERN_ERR, target-&gt;scsi_host,
 		     &quot;Sending SRP abort for tag %#x\n&quot;, tag);
 	if (srp_send_tsk_mgmt(ch, tag, scmnd-&gt;device-&gt;lun,
<span class="p_del">-			      SRP_TSK_ABORT_TASK) == 0)</span>
<span class="p_add">+			      SRP_TSK_ABORT_TASK, NULL) == 0)</span>
 		ret = SUCCESS;
 	else if (target-&gt;rport-&gt;state == SRP_RPORT_LOST)
 		ret = FAST_IO_FAIL;
<span class="p_chunk">@@ -2616,14 +2625,15 @@</span> <span class="p_context"> static int srp_reset_device(struct scsi_cmnd *scmnd)</span>
 	struct srp_target_port *target = host_to_target(scmnd-&gt;device-&gt;host);
 	struct srp_rdma_ch *ch;
 	int i;
<span class="p_add">+	u8 status;</span>
 
 	shost_printk(KERN_ERR, target-&gt;scsi_host, &quot;SRP reset_device called\n&quot;);
 
 	ch = &amp;target-&gt;ch[0];
 	if (srp_send_tsk_mgmt(ch, SRP_TAG_NO_REQ, scmnd-&gt;device-&gt;lun,
<span class="p_del">-			      SRP_TSK_LUN_RESET))</span>
<span class="p_add">+			      SRP_TSK_LUN_RESET, &amp;status))</span>
 		return FAILED;
<span class="p_del">-	if (ch-&gt;tsk_mgmt_status)</span>
<span class="p_add">+	if (status)</span>
 		return FAILED;
 
 	for (i = 0; i &lt; target-&gt;ch_count; i++) {
<span class="p_chunk">@@ -2652,9 +2662,8 @@</span> <span class="p_context"> static int srp_slave_alloc(struct scsi_device *sdev)</span>
 	struct Scsi_Host *shost = sdev-&gt;host;
 	struct srp_target_port *target = host_to_target(shost);
 	struct srp_device *srp_dev = target-&gt;srp_host-&gt;srp_dev;
<span class="p_del">-	struct ib_device *ibdev = srp_dev-&gt;dev;</span>
 
<span class="p_del">-	if (!(ibdev-&gt;attrs.device_cap_flags &amp; IB_DEVICE_SG_GAPS_REG))</span>
<span class="p_add">+	if (true)</span>
 		blk_queue_virt_boundary(sdev-&gt;request_queue,
 					~srp_dev-&gt;mr_page_mask);
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h</span>
<span class="p_header">index 21c69695f9d4..32ed40db3ca2 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.h</span>
<span class="p_chunk">@@ -163,6 +163,7 @@</span> <span class="p_context"> struct srp_rdma_ch {</span>
 	int			max_ti_iu_len;
 	int			comp_vector;
 
<span class="p_add">+	u64			tsk_mgmt_tag;</span>
 	struct completion	tsk_mgmt_done;
 	u8			tsk_mgmt_status;
 	bool			connected;
<span class="p_header">diff --git a/drivers/memory/atmel-ebi.c b/drivers/memory/atmel-ebi.c</span>
<span class="p_header">index b5ed3bd082b5..e9ebc4f31d16 100644</span>
<span class="p_header">--- a/drivers/memory/atmel-ebi.c</span>
<span class="p_header">+++ b/drivers/memory/atmel-ebi.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> static void at91sam9_ebi_get_config(struct at91_ebi_dev *ebid,</span>
 				    struct at91_ebi_dev_config *conf)
 {
 	struct at91sam9_smc_generic_fields *fields = &amp;ebid-&gt;ebi-&gt;sam9;
<span class="p_del">-	unsigned int clk_rate = clk_get_rate(ebid-&gt;ebi-&gt;clk);</span>
<span class="p_add">+	unsigned int clk_period = NSEC_PER_SEC / clk_get_rate(ebid-&gt;ebi-&gt;clk);</span>
 	struct at91sam9_ebi_dev_config *config = &amp;conf-&gt;sam9;
 	struct at91sam9_smc_timings *timings = &amp;config-&gt;timings;
 	unsigned int val;
<span class="p_chunk">@@ -102,43 +102,43 @@</span> <span class="p_context"> static void at91sam9_ebi_get_config(struct at91_ebi_dev *ebid,</span>
 	config-&gt;mode = val &amp; ~AT91_SMC_TDF;
 
 	val = (val &amp; AT91_SMC_TDF) &gt;&gt; 16;
<span class="p_del">-	timings-&gt;tdf_ns = clk_rate * val;</span>
<span class="p_add">+	timings-&gt;tdf_ns = clk_period * val;</span>
 
 	regmap_fields_read(fields-&gt;setup, conf-&gt;cs, &amp;val);
 	timings-&gt;ncs_rd_setup_ns = (val &gt;&gt; 24) &amp; 0x1f;
 	timings-&gt;ncs_rd_setup_ns += ((val &gt;&gt; 29) &amp; 0x1) * 128;
<span class="p_del">-	timings-&gt;ncs_rd_setup_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;ncs_rd_setup_ns *= clk_period;</span>
 	timings-&gt;nrd_setup_ns = (val &gt;&gt; 16) &amp; 0x1f;
 	timings-&gt;nrd_setup_ns += ((val &gt;&gt; 21) &amp; 0x1) * 128;
<span class="p_del">-	timings-&gt;nrd_setup_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;nrd_setup_ns *= clk_period;</span>
 	timings-&gt;ncs_wr_setup_ns = (val &gt;&gt; 8) &amp; 0x1f;
 	timings-&gt;ncs_wr_setup_ns += ((val &gt;&gt; 13) &amp; 0x1) * 128;
<span class="p_del">-	timings-&gt;ncs_wr_setup_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;ncs_wr_setup_ns *= clk_period;</span>
 	timings-&gt;nwe_setup_ns = val &amp; 0x1f;
 	timings-&gt;nwe_setup_ns += ((val &gt;&gt; 5) &amp; 0x1) * 128;
<span class="p_del">-	timings-&gt;nwe_setup_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;nwe_setup_ns *= clk_period;</span>
 
 	regmap_fields_read(fields-&gt;pulse, conf-&gt;cs, &amp;val);
 	timings-&gt;ncs_rd_pulse_ns = (val &gt;&gt; 24) &amp; 0x3f;
 	timings-&gt;ncs_rd_pulse_ns += ((val &gt;&gt; 30) &amp; 0x1) * 256;
<span class="p_del">-	timings-&gt;ncs_rd_pulse_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;ncs_rd_pulse_ns *= clk_period;</span>
 	timings-&gt;nrd_pulse_ns = (val &gt;&gt; 16) &amp; 0x3f;
 	timings-&gt;nrd_pulse_ns += ((val &gt;&gt; 22) &amp; 0x1) * 256;
<span class="p_del">-	timings-&gt;nrd_pulse_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;nrd_pulse_ns *= clk_period;</span>
 	timings-&gt;ncs_wr_pulse_ns = (val &gt;&gt; 8) &amp; 0x3f;
 	timings-&gt;ncs_wr_pulse_ns += ((val &gt;&gt; 14) &amp; 0x1) * 256;
<span class="p_del">-	timings-&gt;ncs_wr_pulse_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;ncs_wr_pulse_ns *= clk_period;</span>
 	timings-&gt;nwe_pulse_ns = val &amp; 0x3f;
 	timings-&gt;nwe_pulse_ns += ((val &gt;&gt; 6) &amp; 0x1) * 256;
<span class="p_del">-	timings-&gt;nwe_pulse_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;nwe_pulse_ns *= clk_period;</span>
 
 	regmap_fields_read(fields-&gt;cycle, conf-&gt;cs, &amp;val);
 	timings-&gt;nrd_cycle_ns = (val &gt;&gt; 16) &amp; 0x7f;
 	timings-&gt;nrd_cycle_ns += ((val &gt;&gt; 23) &amp; 0x3) * 256;
<span class="p_del">-	timings-&gt;nrd_cycle_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;nrd_cycle_ns *= clk_period;</span>
 	timings-&gt;nwe_cycle_ns = val &amp; 0x7f;
 	timings-&gt;nwe_cycle_ns += ((val &gt;&gt; 7) &amp; 0x3) * 256;
<span class="p_del">-	timings-&gt;nwe_cycle_ns *= clk_rate;</span>
<span class="p_add">+	timings-&gt;nwe_cycle_ns *= clk_period;</span>
 }
 
 static int at91_xlate_timing(struct device_node *np, const char *prop,
<span class="p_chunk">@@ -334,6 +334,7 @@</span> <span class="p_context"> static int at91sam9_ebi_apply_config(struct at91_ebi_dev *ebid,</span>
 				     struct at91_ebi_dev_config *conf)
 {
 	unsigned int clk_rate = clk_get_rate(ebid-&gt;ebi-&gt;clk);
<span class="p_add">+	unsigned int clk_period = NSEC_PER_SEC / clk_rate;</span>
 	struct at91sam9_ebi_dev_config *config = &amp;conf-&gt;sam9;
 	struct at91sam9_smc_timings *timings = &amp;config-&gt;timings;
 	struct at91sam9_smc_generic_fields *fields = &amp;ebid-&gt;ebi-&gt;sam9;
<span class="p_chunk">@@ -376,7 +377,7 @@</span> <span class="p_context"> static int at91sam9_ebi_apply_config(struct at91_ebi_dev *ebid,</span>
 	val |= AT91SAM9_SMC_NWECYCLE(coded_val);
 	regmap_fields_write(fields-&gt;cycle, conf-&gt;cs, val);
 
<span class="p_del">-	val = DIV_ROUND_UP(timings-&gt;tdf_ns, clk_rate);</span>
<span class="p_add">+	val = DIV_ROUND_UP(timings-&gt;tdf_ns, clk_period);</span>
 	if (val &gt; AT91_SMC_TDF_MAX)
 		val = AT91_SMC_TDF_MAX;
 	regmap_fields_write(fields-&gt;mode, conf-&gt;cs,
<span class="p_header">diff --git a/drivers/misc/cxl/cxl.h b/drivers/misc/cxl/cxl.h</span>
<span class="p_header">index a144073593fa..52ee3da85366 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/cxl.h</span>
<span class="p_header">+++ b/drivers/misc/cxl/cxl.h</span>
<span class="p_chunk">@@ -419,6 +419,9 @@</span> <span class="p_context"> struct cxl_afu {</span>
 	struct mutex contexts_lock;
 	spinlock_t afu_cntl_lock;
 
<span class="p_add">+	/* -1: AFU deconfigured/locked, &gt;= 0: number of readers */</span>
<span class="p_add">+	atomic_t configured_state;</span>
<span class="p_add">+</span>
 	/* AFU error buffer fields and bin attribute for sysfs */
 	u64 eb_len, eb_offset;
 	struct bin_attribute attr_eb;
<span class="p_header">diff --git a/drivers/misc/cxl/main.c b/drivers/misc/cxl/main.c</span>
<span class="p_header">index 62e0dfb5f15b..cc1706a92ace 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/main.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/main.c</span>
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"> struct cxl_afu *cxl_alloc_afu(struct cxl *adapter, int slice)</span>
 	idr_init(&amp;afu-&gt;contexts_idr);
 	mutex_init(&amp;afu-&gt;contexts_lock);
 	spin_lock_init(&amp;afu-&gt;afu_cntl_lock);
<span class="p_del">-</span>
<span class="p_add">+	atomic_set(&amp;afu-&gt;configured_state, -1);</span>
 	afu-&gt;prefault_mode = CXL_PREFAULT_NONE;
 	afu-&gt;irqs_max = afu-&gt;adapter-&gt;user_irqs;
 
<span class="p_header">diff --git a/drivers/misc/cxl/pci.c b/drivers/misc/cxl/pci.c</span>
<span class="p_header">index e96be9ca4e60..dd99b06e121a 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/pci.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/pci.c</span>
<span class="p_chunk">@@ -1129,6 +1129,7 @@</span> <span class="p_context"> static int pci_configure_afu(struct cxl_afu *afu, struct cxl *adapter, struct pc</span>
 	if ((rc = cxl_native_register_psl_irq(afu)))
 		goto err2;
 
<span class="p_add">+	atomic_set(&amp;afu-&gt;configured_state, 0);</span>
 	return 0;
 
 err2:
<span class="p_chunk">@@ -1141,6 +1142,14 @@</span> <span class="p_context"> static int pci_configure_afu(struct cxl_afu *afu, struct cxl *adapter, struct pc</span>
 
 static void pci_deconfigure_afu(struct cxl_afu *afu)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * It&#39;s okay to deconfigure when AFU is already locked, otherwise wait</span>
<span class="p_add">+	 * until there are no readers</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (atomic_read(&amp;afu-&gt;configured_state) != -1) {</span>
<span class="p_add">+		while (atomic_cmpxchg(&amp;afu-&gt;configured_state, 0, -1) != -1)</span>
<span class="p_add">+			schedule();</span>
<span class="p_add">+	}</span>
 	cxl_native_release_psl_irq(afu);
 	if (afu-&gt;adapter-&gt;native-&gt;sl_ops-&gt;release_serr_irq)
 		afu-&gt;adapter-&gt;native-&gt;sl_ops-&gt;release_serr_irq(afu);
<span class="p_header">diff --git a/drivers/misc/cxl/vphb.c b/drivers/misc/cxl/vphb.c</span>
<span class="p_header">index 3519acebfdab..512a4897dbf6 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/vphb.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/vphb.c</span>
<span class="p_chunk">@@ -76,23 +76,32 @@</span> <span class="p_context"> static int cxl_pcie_cfg_record(u8 bus, u8 devfn)</span>
 	return (bus &lt;&lt; 8) + devfn;
 }
 
<span class="p_del">-static int cxl_pcie_config_info(struct pci_bus *bus, unsigned int devfn,</span>
<span class="p_del">-				struct cxl_afu **_afu, int *_record)</span>
<span class="p_add">+static inline struct cxl_afu *pci_bus_to_afu(struct pci_bus *bus)</span>
 {
<span class="p_del">-	struct pci_controller *phb;</span>
<span class="p_del">-	struct cxl_afu *afu;</span>
<span class="p_del">-	int record;</span>
<span class="p_add">+	struct pci_controller *phb = bus ? pci_bus_to_host(bus) : NULL;</span>
 
<span class="p_del">-	phb = pci_bus_to_host(bus);</span>
<span class="p_del">-	if (phb == NULL)</span>
<span class="p_del">-		return PCIBIOS_DEVICE_NOT_FOUND;</span>
<span class="p_add">+	return phb ? phb-&gt;private_data : NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void cxl_afu_configured_put(struct cxl_afu *afu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_dec_if_positive(&amp;afu-&gt;configured_state);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool cxl_afu_configured_get(struct cxl_afu *afu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return atomic_inc_unless_negative(&amp;afu-&gt;configured_state);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int cxl_pcie_config_info(struct pci_bus *bus, unsigned int devfn,</span>
<span class="p_add">+				       struct cxl_afu *afu, int *_record)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int record;</span>
 
<span class="p_del">-	afu = (struct cxl_afu *)phb-&gt;private_data;</span>
 	record = cxl_pcie_cfg_record(bus-&gt;number, devfn);
 	if (record &gt; afu-&gt;crs_num)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
<span class="p_del">-	*_afu = afu;</span>
 	*_record = record;
 	return 0;
 }
<span class="p_chunk">@@ -106,9 +115,14 @@</span> <span class="p_context"> static int cxl_pcie_read_config(struct pci_bus *bus, unsigned int devfn,</span>
 	u16 val16;
 	u32 val32;
 
<span class="p_del">-	rc = cxl_pcie_config_info(bus, devfn, &amp;afu, &amp;record);</span>
<span class="p_add">+	afu = pci_bus_to_afu(bus);</span>
<span class="p_add">+	/* Grab a reader lock on afu. */</span>
<span class="p_add">+	if (afu == NULL || !cxl_afu_configured_get(afu))</span>
<span class="p_add">+		return PCIBIOS_DEVICE_NOT_FOUND;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = cxl_pcie_config_info(bus, devfn, afu, &amp;record);</span>
 	if (rc)
<span class="p_del">-		return rc;</span>
<span class="p_add">+		goto out;</span>
 
 	switch (len) {
 	case 1:
<span class="p_chunk">@@ -127,10 +141,9 @@</span> <span class="p_context"> static int cxl_pcie_read_config(struct pci_bus *bus, unsigned int devfn,</span>
 		WARN_ON(1);
 	}
 
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return PCIBIOS_DEVICE_NOT_FOUND;</span>
<span class="p_del">-</span>
<span class="p_del">-	return PCIBIOS_SUCCESSFUL;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	cxl_afu_configured_put(afu);</span>
<span class="p_add">+	return rc ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;</span>
 }
 
 static int cxl_pcie_write_config(struct pci_bus *bus, unsigned int devfn,
<span class="p_chunk">@@ -139,9 +152,14 @@</span> <span class="p_context"> static int cxl_pcie_write_config(struct pci_bus *bus, unsigned int devfn,</span>
 	int rc, record;
 	struct cxl_afu *afu;
 
<span class="p_del">-	rc = cxl_pcie_config_info(bus, devfn, &amp;afu, &amp;record);</span>
<span class="p_add">+	afu = pci_bus_to_afu(bus);</span>
<span class="p_add">+	/* Grab a reader lock on afu. */</span>
<span class="p_add">+	if (afu == NULL || !cxl_afu_configured_get(afu))</span>
<span class="p_add">+		return PCIBIOS_DEVICE_NOT_FOUND;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = cxl_pcie_config_info(bus, devfn, afu, &amp;record);</span>
 	if (rc)
<span class="p_del">-		return rc;</span>
<span class="p_add">+		goto out;</span>
 
 	switch (len) {
 	case 1:
<span class="p_chunk">@@ -157,10 +175,9 @@</span> <span class="p_context"> static int cxl_pcie_write_config(struct pci_bus *bus, unsigned int devfn,</span>
 		WARN_ON(1);
 	}
 
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return PCIBIOS_SET_FAILED;</span>
<span class="p_del">-</span>
<span class="p_del">-	return PCIBIOS_SUCCESSFUL;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	cxl_afu_configured_put(afu);</span>
<span class="p_add">+	return rc ? PCIBIOS_SET_FAILED : PCIBIOS_SUCCESSFUL;</span>
 }
 
 static struct pci_ops cxl_pcie_pci_ops =
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvpp2.c b/drivers/net/ethernet/marvell/mvpp2.c</span>
<span class="p_header">index 930c8165f2a8..0a4e81a253fb 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvpp2.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvpp2.c</span>
<span class="p_chunk">@@ -991,7 +991,7 @@</span> <span class="p_context"> static void mvpp2_txq_inc_put(struct mvpp2_txq_pcpu *txq_pcpu,</span>
 		txq_pcpu-&gt;buffs + txq_pcpu-&gt;txq_put_index;
 	tx_buf-&gt;skb = skb;
 	tx_buf-&gt;size = tx_desc-&gt;data_size;
<span class="p_del">-	tx_buf-&gt;phys = tx_desc-&gt;buf_phys_addr;</span>
<span class="p_add">+	tx_buf-&gt;phys = tx_desc-&gt;buf_phys_addr + tx_desc-&gt;packet_offset;</span>
 	txq_pcpu-&gt;txq_put_index++;
 	if (txq_pcpu-&gt;txq_put_index == txq_pcpu-&gt;size)
 		txq_pcpu-&gt;txq_put_index = 0;
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">index b892dac70f4b..2458e6e05276 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_chunk">@@ -1660,7 +1660,7 @@</span> <span class="p_context"> static u8 brcmf_sdio_rxglom(struct brcmf_sdio *bus, u8 rxseq)</span>
 					   pfirst-&gt;len, pfirst-&gt;next,
 					   pfirst-&gt;prev);
 			skb_unlink(pfirst, &amp;bus-&gt;glom);
<span class="p_del">-			if (brcmf_sdio_fromevntchan(pfirst-&gt;data))</span>
<span class="p_add">+			if (brcmf_sdio_fromevntchan(&amp;dptr[SDPCM_HWHDR_LEN]))</span>
 				brcmf_rx_event(bus-&gt;sdiodev-&gt;dev, pfirst);
 			else
 				brcmf_rx_frame(bus-&gt;sdiodev-&gt;dev, pfirst,
<span class="p_header">diff --git a/drivers/nvdimm/namespace_devs.c b/drivers/nvdimm/namespace_devs.c</span>
<span class="p_header">index aefca644219b..a38ae34b74e4 100644</span>
<span class="p_header">--- a/drivers/nvdimm/namespace_devs.c</span>
<span class="p_header">+++ b/drivers/nvdimm/namespace_devs.c</span>
<span class="p_chunk">@@ -1700,6 +1700,7 @@</span> <span class="p_context"> static int select_pmem_id(struct nd_region *nd_region, u8 *pmem_id)</span>
 struct device *create_namespace_pmem(struct nd_region *nd_region,
 		struct nd_namespace_label *nd_label)
 {
<span class="p_add">+	u64 altcookie = nd_region_interleave_set_altcookie(nd_region);</span>
 	u64 cookie = nd_region_interleave_set_cookie(nd_region);
 	struct nd_label_ent *label_ent;
 	struct nd_namespace_pmem *nspm;
<span class="p_chunk">@@ -1718,7 +1719,11 @@</span> <span class="p_context"> struct device *create_namespace_pmem(struct nd_region *nd_region,</span>
 	if (__le64_to_cpu(nd_label-&gt;isetcookie) != cookie) {
 		dev_dbg(&amp;nd_region-&gt;dev, &quot;invalid cookie in label: %pUb\n&quot;,
 				nd_label-&gt;uuid);
<span class="p_del">-		return ERR_PTR(-EAGAIN);</span>
<span class="p_add">+		if (__le64_to_cpu(nd_label-&gt;isetcookie) != altcookie)</span>
<span class="p_add">+			return ERR_PTR(-EAGAIN);</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_dbg(&amp;nd_region-&gt;dev, &quot;valid altcookie in label: %pUb\n&quot;,</span>
<span class="p_add">+				nd_label-&gt;uuid);</span>
 	}
 
 	nspm = kzalloc(sizeof(*nspm), GFP_KERNEL);
<span class="p_chunk">@@ -1733,9 +1738,14 @@</span> <span class="p_context"> struct device *create_namespace_pmem(struct nd_region *nd_region,</span>
 	res-&gt;name = dev_name(&amp;nd_region-&gt;dev);
 	res-&gt;flags = IORESOURCE_MEM;
 
<span class="p_del">-	for (i = 0; i &lt; nd_region-&gt;ndr_mappings; i++)</span>
<span class="p_del">-		if (!has_uuid_at_pos(nd_region, nd_label-&gt;uuid, cookie, i))</span>
<span class="p_del">-			break;</span>
<span class="p_add">+	for (i = 0; i &lt; nd_region-&gt;ndr_mappings; i++) {</span>
<span class="p_add">+		if (has_uuid_at_pos(nd_region, nd_label-&gt;uuid, cookie, i))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (has_uuid_at_pos(nd_region, nd_label-&gt;uuid, altcookie, i))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (i &lt; nd_region-&gt;ndr_mappings) {
 		struct nvdimm_drvdata *ndd = to_ndd(&amp;nd_region-&gt;mapping[i]);
 
<span class="p_header">diff --git a/drivers/nvdimm/nd.h b/drivers/nvdimm/nd.h</span>
<span class="p_header">index d3b2fca8deec..d869236b474f 100644</span>
<span class="p_header">--- a/drivers/nvdimm/nd.h</span>
<span class="p_header">+++ b/drivers/nvdimm/nd.h</span>
<span class="p_chunk">@@ -327,6 +327,7 @@</span> <span class="p_context"> struct nd_region *to_nd_region(struct device *dev);</span>
 int nd_region_to_nstype(struct nd_region *nd_region);
 int nd_region_register_namespaces(struct nd_region *nd_region, int *err);
 u64 nd_region_interleave_set_cookie(struct nd_region *nd_region);
<span class="p_add">+u64 nd_region_interleave_set_altcookie(struct nd_region *nd_region);</span>
 void nvdimm_bus_lock(struct device *dev);
 void nvdimm_bus_unlock(struct device *dev);
 bool is_nvdimm_bus_locked(struct device *dev);
<span class="p_header">diff --git a/drivers/nvdimm/region_devs.c b/drivers/nvdimm/region_devs.c</span>
<span class="p_header">index 6af5e629140c..9cf6f1a88fce 100644</span>
<span class="p_header">--- a/drivers/nvdimm/region_devs.c</span>
<span class="p_header">+++ b/drivers/nvdimm/region_devs.c</span>
<span class="p_chunk">@@ -505,6 +505,15 @@</span> <span class="p_context"> u64 nd_region_interleave_set_cookie(struct nd_region *nd_region)</span>
 	return 0;
 }
 
<span class="p_add">+u64 nd_region_interleave_set_altcookie(struct nd_region *nd_region)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nd_interleave_set *nd_set = nd_region-&gt;nd_set;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (nd_set)</span>
<span class="p_add">+		return nd_set-&gt;altcookie;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void nd_mapping_free_labels(struct nd_mapping *nd_mapping)
 {
 	struct nd_label_ent *label_ent, *e;
<span class="p_header">diff --git a/drivers/pci/hotplug/pnv_php.c b/drivers/pci/hotplug/pnv_php.c</span>
<span class="p_header">index acb2be0c8c2c..e96973b95e7a 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/pnv_php.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/pnv_php.c</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> static void pnv_php_free_slot(struct kref *kref)</span>
 static inline void pnv_php_put_slot(struct pnv_php_slot *php_slot)
 {
 
<span class="p_del">-	if (WARN_ON(!php_slot))</span>
<span class="p_add">+	if (!php_slot)</span>
 		return;
 
 	kref_put(&amp;php_slot-&gt;kref, pnv_php_free_slot);
<span class="p_chunk">@@ -436,9 +436,21 @@</span> <span class="p_context"> static int pnv_php_enable(struct pnv_php_slot *php_slot, bool rescan)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	/* Proceed if there have nothing behind the slot */</span>
<span class="p_del">-	if (presence == OPAL_PCI_SLOT_EMPTY)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Proceed if there have nothing behind the slot. However,</span>
<span class="p_add">+	 * we should leave the slot in registered state at the</span>
<span class="p_add">+	 * beginning. Otherwise, the PCI devices inserted afterwards</span>
<span class="p_add">+	 * won&#39;t be probed and populated.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (presence == OPAL_PCI_SLOT_EMPTY) {</span>
<span class="p_add">+		if (!php_slot-&gt;power_state_check) {</span>
<span class="p_add">+			php_slot-&gt;power_state_check = true;</span>
<span class="p_add">+</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		goto scan;
<span class="p_add">+	}</span>
 
 	/*
 	 * If the power supply to the slot is off, we can&#39;t detect
<span class="p_chunk">@@ -713,8 +725,12 @@</span> <span class="p_context"> static irqreturn_t pnv_php_interrupt(int irq, void *data)</span>
 		added = !!(lsts &amp; PCI_EXP_LNKSTA_DLLLA);
 	} else if (sts &amp; PCI_EXP_SLTSTA_PDC) {
 		ret = pnv_pci_get_presence_state(php_slot-&gt;id, &amp;presence);
<span class="p_del">-		if (!ret)</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_warn(&amp;pdev-&gt;dev, &quot;PCI slot [%s] error %d getting presence (0x%04x), to retry the operation.\n&quot;,</span>
<span class="p_add">+				 php_slot-&gt;name, ret, sts);</span>
 			return IRQ_HANDLED;
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		added = !!(presence == OPAL_PCI_SLOT_PRESENT);
 	} else {
 		return IRQ_NONE;
<span class="p_chunk">@@ -799,6 +815,14 @@</span> <span class="p_context"> static void pnv_php_enable_irq(struct pnv_php_slot *php_slot)</span>
 	struct pci_dev *pdev = php_slot-&gt;pdev;
 	int irq, ret;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The MSI/MSIx interrupt might have been occupied by other</span>
<span class="p_add">+	 * drivers. Don&#39;t populate the surprise hotplug capability</span>
<span class="p_add">+	 * in that case.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pci_dev_msi_enabled(pdev))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	ret = pci_enable_device(pdev);
 	if (ret) {
 		dev_warn(&amp;pdev-&gt;dev, &quot;Error %d enabling device\n&quot;, ret);
<span class="p_header">diff --git a/drivers/pwm/pwm-pca9685.c b/drivers/pwm/pwm-pca9685.c</span>
<span class="p_header">index 117fccf7934a..01a6a83f625d 100644</span>
<span class="p_header">--- a/drivers/pwm/pwm-pca9685.c</span>
<span class="p_header">+++ b/drivers/pwm/pwm-pca9685.c</span>
<span class="p_chunk">@@ -65,7 +65,6 @@</span> <span class="p_context"></span>
 #define PCA9685_MAXCHAN		0x10
 
 #define LED_FULL		(1 &lt;&lt; 4)
<span class="p_del">-#define MODE1_RESTART		(1 &lt;&lt; 7)</span>
 #define MODE1_SLEEP		(1 &lt;&lt; 4)
 #define MODE2_INVRT		(1 &lt;&lt; 4)
 #define MODE2_OUTDRV		(1 &lt;&lt; 2)
<span class="p_chunk">@@ -117,16 +116,6 @@</span> <span class="p_context"> static int pca9685_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,</span>
 			udelay(500);
 
 			pca-&gt;period_ns = period_ns;
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * If the duty cycle did not change, restart PWM with</span>
<span class="p_del">-			 * the same duty cycle to period ratio and return.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (duty_ns == pca-&gt;duty_ns) {</span>
<span class="p_del">-				regmap_update_bits(pca-&gt;regmap, PCA9685_MODE1,</span>
<span class="p_del">-						   MODE1_RESTART, 0x1);</span>
<span class="p_del">-				return 0;</span>
<span class="p_del">-			}</span>
 		} else {
 			dev_err(chip-&gt;dev,
 				&quot;prescaler not set: period out of bounds!\n&quot;);
<span class="p_header">diff --git a/drivers/s390/block/dcssblk.c b/drivers/s390/block/dcssblk.c</span>
<span class="p_header">index 9d66b4fb174b..415d10a67b7a 100644</span>
<span class="p_header">--- a/drivers/s390/block/dcssblk.c</span>
<span class="p_header">+++ b/drivers/s390/block/dcssblk.c</span>
<span class="p_chunk">@@ -892,7 +892,7 @@</span> <span class="p_context"> dcssblk_direct_access (struct block_device *bdev, sector_t secnum,</span>
 	dev_info = bdev-&gt;bd_disk-&gt;private_data;
 	if (!dev_info)
 		return -ENODEV;
<span class="p_del">-	dev_sz = dev_info-&gt;end - dev_info-&gt;start;</span>
<span class="p_add">+	dev_sz = dev_info-&gt;end - dev_info-&gt;start + 1;</span>
 	offset = secnum * 512;
 	*kaddr = (void *) dev_info-&gt;start + offset;
 	*pfn = __pfn_to_pfn_t(PFN_DOWN(dev_info-&gt;start + offset), PFN_DEV);
<span class="p_header">diff --git a/drivers/s390/cio/ioasm.c b/drivers/s390/cio/ioasm.c</span>
<span class="p_header">index 8225da619014..4182f60124da 100644</span>
<span class="p_header">--- a/drivers/s390/cio/ioasm.c</span>
<span class="p_header">+++ b/drivers/s390/cio/ioasm.c</span>
<span class="p_chunk">@@ -165,13 +165,15 @@</span> <span class="p_context"> int tpi(struct tpi_info *addr)</span>
 int chsc(void *chsc_area)
 {
 	typedef struct { char _[4096]; } addr_type;
<span class="p_del">-	int cc;</span>
<span class="p_add">+	int cc = -EIO;</span>
 
 	asm volatile(
 		&quot;	.insn	rre,0xb25f0000,%2,0\n&quot;
<span class="p_del">-		&quot;	ipm	%0\n&quot;</span>
<span class="p_add">+		&quot;0:	ipm	%0\n&quot;</span>
 		&quot;	srl	%0,28\n&quot;
<span class="p_del">-		: &quot;=d&quot; (cc), &quot;=m&quot; (*(addr_type *) chsc_area)</span>
<span class="p_add">+		&quot;1:\n&quot;</span>
<span class="p_add">+		EX_TABLE(0b, 1b)</span>
<span class="p_add">+		: &quot;+d&quot; (cc), &quot;=m&quot; (*(addr_type *) chsc_area)</span>
 		: &quot;d&quot; (chsc_area), &quot;m&quot; (*(addr_type *) chsc_area)
 		: &quot;cc&quot;);
 	trace_s390_cio_chsc(chsc_area, cc);
<span class="p_header">diff --git a/drivers/s390/cio/qdio_thinint.c b/drivers/s390/cio/qdio_thinint.c</span>
<span class="p_header">index 5d06253c2a7a..30e9fbbff051 100644</span>
<span class="p_header">--- a/drivers/s390/cio/qdio_thinint.c</span>
<span class="p_header">+++ b/drivers/s390/cio/qdio_thinint.c</span>
<span class="p_chunk">@@ -147,11 +147,11 @@</span> <span class="p_context"> static inline void tiqdio_call_inq_handlers(struct qdio_irq *irq)</span>
 	struct qdio_q *q;
 	int i;
 
<span class="p_del">-	for_each_input_queue(irq, q, i) {</span>
<span class="p_del">-		if (!references_shared_dsci(irq) &amp;&amp;</span>
<span class="p_del">-		    has_multiple_inq_on_dsci(irq))</span>
<span class="p_del">-			xchg(q-&gt;irq_ptr-&gt;dsci, 0);</span>
<span class="p_add">+	if (!references_shared_dsci(irq) &amp;&amp;</span>
<span class="p_add">+	    has_multiple_inq_on_dsci(irq))</span>
<span class="p_add">+		xchg(irq-&gt;dsci, 0);</span>
 
<span class="p_add">+	for_each_input_queue(irq, q, i) {</span>
 		if (q-&gt;u.in.queue_start_poll) {
 			/* skip if polling is enabled or already in work */
 			if (test_and_set_bit(QDIO_QUEUE_IRQS_DISABLED,
<span class="p_header">diff --git a/drivers/target/target_core_device.c b/drivers/target/target_core_device.c</span>
<span class="p_header">index ea9617c7b403..cc38a3509f78 100644</span>
<span class="p_header">--- a/drivers/target/target_core_device.c</span>
<span class="p_header">+++ b/drivers/target/target_core_device.c</span>
<span class="p_chunk">@@ -77,12 +77,16 @@</span> <span class="p_context"> transport_lookup_cmd_lun(struct se_cmd *se_cmd, u64 unpacked_lun)</span>
 					&amp;deve-&gt;read_bytes);
 
 		se_lun = rcu_dereference(deve-&gt;se_lun);
<span class="p_add">+</span>
<span class="p_add">+		if (!percpu_ref_tryget_live(&amp;se_lun-&gt;lun_ref)) {</span>
<span class="p_add">+			se_lun = NULL;</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		se_cmd-&gt;se_lun = rcu_dereference(deve-&gt;se_lun);
 		se_cmd-&gt;pr_res_key = deve-&gt;pr_res_key;
 		se_cmd-&gt;orig_fe_lun = unpacked_lun;
 		se_cmd-&gt;se_cmd_flags |= SCF_SE_LUN_CMD;
<span class="p_del">-</span>
<span class="p_del">-		percpu_ref_get(&amp;se_lun-&gt;lun_ref);</span>
 		se_cmd-&gt;lun_ref_active = true;
 
 		if ((se_cmd-&gt;data_direction == DMA_TO_DEVICE) &amp;&amp;
<span class="p_chunk">@@ -96,6 +100,7 @@</span> <span class="p_context"> transport_lookup_cmd_lun(struct se_cmd *se_cmd, u64 unpacked_lun)</span>
 			goto ref_dev;
 		}
 	}
<span class="p_add">+out_unlock:</span>
 	rcu_read_unlock();
 
 	if (!se_lun) {
<span class="p_chunk">@@ -815,6 +820,7 @@</span> <span class="p_context"> struct se_device *target_alloc_device(struct se_hba *hba, const char *name)</span>
 	xcopy_lun = &amp;dev-&gt;xcopy_lun;
 	rcu_assign_pointer(xcopy_lun-&gt;lun_se_dev, dev);
 	init_completion(&amp;xcopy_lun-&gt;lun_ref_comp);
<span class="p_add">+	init_completion(&amp;xcopy_lun-&gt;lun_shutdown_comp);</span>
 	INIT_LIST_HEAD(&amp;xcopy_lun-&gt;lun_deve_list);
 	INIT_LIST_HEAD(&amp;xcopy_lun-&gt;lun_dev_link);
 	mutex_init(&amp;xcopy_lun-&gt;lun_tg_pt_md_mutex);
<span class="p_header">diff --git a/drivers/target/target_core_tpg.c b/drivers/target/target_core_tpg.c</span>
<span class="p_header">index d99752c6cd60..2744251178ad 100644</span>
<span class="p_header">--- a/drivers/target/target_core_tpg.c</span>
<span class="p_header">+++ b/drivers/target/target_core_tpg.c</span>
<span class="p_chunk">@@ -445,7 +445,7 @@</span> <span class="p_context"> static void core_tpg_lun_ref_release(struct percpu_ref *ref)</span>
 {
 	struct se_lun *lun = container_of(ref, struct se_lun, lun_ref);
 
<span class="p_del">-	complete(&amp;lun-&gt;lun_ref_comp);</span>
<span class="p_add">+	complete(&amp;lun-&gt;lun_shutdown_comp);</span>
 }
 
 int core_tpg_register(
<span class="p_chunk">@@ -571,6 +571,7 @@</span> <span class="p_context"> struct se_lun *core_tpg_alloc_lun(</span>
 	lun-&gt;lun_link_magic = SE_LUN_LINK_MAGIC;
 	atomic_set(&amp;lun-&gt;lun_acl_count, 0);
 	init_completion(&amp;lun-&gt;lun_ref_comp);
<span class="p_add">+	init_completion(&amp;lun-&gt;lun_shutdown_comp);</span>
 	INIT_LIST_HEAD(&amp;lun-&gt;lun_deve_list);
 	INIT_LIST_HEAD(&amp;lun-&gt;lun_dev_link);
 	atomic_set(&amp;lun-&gt;lun_tg_pt_secondary_offline, 0);
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 767d1eb6e035..cae4dea6464e 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -2702,10 +2702,39 @@</span> <span class="p_context"> void target_wait_for_sess_cmds(struct se_session *se_sess)</span>
 }
 EXPORT_SYMBOL(target_wait_for_sess_cmds);
 
<span class="p_add">+static void target_lun_confirm(struct percpu_ref *ref)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct se_lun *lun = container_of(ref, struct se_lun, lun_ref);</span>
<span class="p_add">+</span>
<span class="p_add">+	complete(&amp;lun-&gt;lun_ref_comp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void transport_clear_lun_ref(struct se_lun *lun)
 {
<span class="p_del">-	percpu_ref_kill(&amp;lun-&gt;lun_ref);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Mark the percpu-ref as DEAD, switch to atomic_t mode, drop</span>
<span class="p_add">+	 * the initial reference and schedule confirm kill to be</span>
<span class="p_add">+	 * executed after one full RCU grace period has completed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	percpu_ref_kill_and_confirm(&amp;lun-&gt;lun_ref, target_lun_confirm);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The first completion waits for percpu_ref_switch_to_atomic_rcu()</span>
<span class="p_add">+	 * to call target_lun_confirm after lun-&gt;lun_ref has been marked</span>
<span class="p_add">+	 * as __PERCPU_REF_DEAD on all CPUs, and switches to atomic_t</span>
<span class="p_add">+	 * mode so that percpu_ref_tryget_live() lookup of lun-&gt;lun_ref</span>
<span class="p_add">+	 * fails for all new incoming I/O.</span>
<span class="p_add">+	 */</span>
 	wait_for_completion(&amp;lun-&gt;lun_ref_comp);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The second completion waits for percpu_ref_put_many() to</span>
<span class="p_add">+	 * invoke -&gt;release() after lun-&gt;lun_ref has switched to</span>
<span class="p_add">+	 * atomic_t mode, and lun-&gt;lun_ref.count has reached zero.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * At this point all target-core lun-&gt;lun_ref references have</span>
<span class="p_add">+	 * been dropped via transport_lun_remove_cmd(), and it&#39;s safe</span>
<span class="p_add">+	 * to proceed with the remaining LUN shutdown.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	wait_for_completion(&amp;lun-&gt;lun_shutdown_comp);</span>
 }
 
 static bool
<span class="p_header">diff --git a/drivers/tty/n_hdlc.c b/drivers/tty/n_hdlc.c</span>
<span class="p_header">index a7fa016f31eb..6d1e2f746ab4 100644</span>
<span class="p_header">--- a/drivers/tty/n_hdlc.c</span>
<span class="p_header">+++ b/drivers/tty/n_hdlc.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"></span>
 #define DEFAULT_TX_BUF_COUNT 3
 
 struct n_hdlc_buf {
<span class="p_del">-	struct n_hdlc_buf *link;</span>
<span class="p_add">+	struct list_head  list_item;</span>
 	int		  count;
 	char		  buf[1];
 };
<span class="p_chunk">@@ -122,8 +122,7 @@</span> <span class="p_context"> struct n_hdlc_buf {</span>
 #define	N_HDLC_BUF_SIZE	(sizeof(struct n_hdlc_buf) + maxframe)
 
 struct n_hdlc_buf_list {
<span class="p_del">-	struct n_hdlc_buf *head;</span>
<span class="p_del">-	struct n_hdlc_buf *tail;</span>
<span class="p_add">+	struct list_head  list;</span>
 	int		  count;
 	spinlock_t	  spinlock;
 };
<span class="p_chunk">@@ -136,7 +135,6 @@</span> <span class="p_context"> struct n_hdlc_buf_list {</span>
  * @backup_tty - TTY to use if tty gets closed
  * @tbusy - reentrancy flag for tx wakeup code
  * @woke_up - FIXME: describe this field
<span class="p_del">- * @tbuf - currently transmitting tx buffer</span>
  * @tx_buf_list - list of pending transmit frame buffers
  * @rx_buf_list - list of received frame buffers
  * @tx_free_buf_list - list unused transmit frame buffers
<span class="p_chunk">@@ -149,7 +147,6 @@</span> <span class="p_context"> struct n_hdlc {</span>
 	struct tty_struct	*backup_tty;
 	int			tbusy;
 	int			woke_up;
<span class="p_del">-	struct n_hdlc_buf	*tbuf;</span>
 	struct n_hdlc_buf_list	tx_buf_list;
 	struct n_hdlc_buf_list	rx_buf_list;
 	struct n_hdlc_buf_list	tx_free_buf_list;
<span class="p_chunk">@@ -159,6 +156,8 @@</span> <span class="p_context"> struct n_hdlc {</span>
 /*
  * HDLC buffer list manipulation functions
  */
<span class="p_add">+static void n_hdlc_buf_return(struct n_hdlc_buf_list *buf_list,</span>
<span class="p_add">+						struct n_hdlc_buf *buf);</span>
 static void n_hdlc_buf_put(struct n_hdlc_buf_list *list,
 			   struct n_hdlc_buf *buf);
 static struct n_hdlc_buf *n_hdlc_buf_get(struct n_hdlc_buf_list *list);
<span class="p_chunk">@@ -208,16 +207,9 @@</span> <span class="p_context"> static void flush_tx_queue(struct tty_struct *tty)</span>
 {
 	struct n_hdlc *n_hdlc = tty2n_hdlc(tty);
 	struct n_hdlc_buf *buf;
<span class="p_del">-	unsigned long flags;</span>
 
 	while ((buf = n_hdlc_buf_get(&amp;n_hdlc-&gt;tx_buf_list)))
 		n_hdlc_buf_put(&amp;n_hdlc-&gt;tx_free_buf_list, buf);
<span class="p_del">- 	spin_lock_irqsave(&amp;n_hdlc-&gt;tx_buf_list.spinlock, flags);</span>
<span class="p_del">-	if (n_hdlc-&gt;tbuf) {</span>
<span class="p_del">-		n_hdlc_buf_put(&amp;n_hdlc-&gt;tx_free_buf_list, n_hdlc-&gt;tbuf);</span>
<span class="p_del">-		n_hdlc-&gt;tbuf = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;n_hdlc-&gt;tx_buf_list.spinlock, flags);</span>
 }
 
 static struct tty_ldisc_ops n_hdlc_ldisc = {
<span class="p_chunk">@@ -283,7 +275,6 @@</span> <span class="p_context"> static void n_hdlc_release(struct n_hdlc *n_hdlc)</span>
 		} else
 			break;
 	}
<span class="p_del">-	kfree(n_hdlc-&gt;tbuf);</span>
 	kfree(n_hdlc);
 	
 }	/* end of n_hdlc_release() */
<span class="p_chunk">@@ -402,13 +393,7 @@</span> <span class="p_context"> static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)</span>
 	n_hdlc-&gt;woke_up = 0;
 	spin_unlock_irqrestore(&amp;n_hdlc-&gt;tx_buf_list.spinlock, flags);
 
<span class="p_del">-	/* get current transmit buffer or get new transmit */</span>
<span class="p_del">-	/* buffer from list of pending transmit buffers */</span>
<span class="p_del">-		</span>
<span class="p_del">-	tbuf = n_hdlc-&gt;tbuf;</span>
<span class="p_del">-	if (!tbuf)</span>
<span class="p_del">-		tbuf = n_hdlc_buf_get(&amp;n_hdlc-&gt;tx_buf_list);</span>
<span class="p_del">-		</span>
<span class="p_add">+	tbuf = n_hdlc_buf_get(&amp;n_hdlc-&gt;tx_buf_list);</span>
 	while (tbuf) {
 		if (debuglevel &gt;= DEBUG_LEVEL_INFO)	
 			printk(&quot;%s(%d)sending frame %p, count=%d\n&quot;,
<span class="p_chunk">@@ -420,7 +405,7 @@</span> <span class="p_context"> static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)</span>
 
 		/* rollback was possible and has been done */
 		if (actual == -ERESTARTSYS) {
<span class="p_del">-			n_hdlc-&gt;tbuf = tbuf;</span>
<span class="p_add">+			n_hdlc_buf_return(&amp;n_hdlc-&gt;tx_buf_list, tbuf);</span>
 			break;
 		}
 		/* if transmit error, throw frame away by */
<span class="p_chunk">@@ -435,10 +420,7 @@</span> <span class="p_context"> static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)</span>
 					
 			/* free current transmit buffer */
 			n_hdlc_buf_put(&amp;n_hdlc-&gt;tx_free_buf_list, tbuf);
<span class="p_del">-			</span>
<span class="p_del">-			/* this tx buffer is done */</span>
<span class="p_del">-			n_hdlc-&gt;tbuf = NULL;</span>
<span class="p_del">-			</span>
<span class="p_add">+</span>
 			/* wait up sleeping writers */
 			wake_up_interruptible(&amp;tty-&gt;write_wait);
 	
<span class="p_chunk">@@ -448,10 +430,12 @@</span> <span class="p_context"> static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)</span>
 			if (debuglevel &gt;= DEBUG_LEVEL_INFO)	
 				printk(&quot;%s(%d)frame %p pending\n&quot;,
 					__FILE__,__LINE__,tbuf);
<span class="p_del">-					</span>
<span class="p_del">-			/* buffer not accepted by driver */</span>
<span class="p_del">-			/* set this buffer as pending buffer */</span>
<span class="p_del">-			n_hdlc-&gt;tbuf = tbuf;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * the buffer was not accepted by driver,</span>
<span class="p_add">+			 * return it back into tx queue</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			n_hdlc_buf_return(&amp;n_hdlc-&gt;tx_buf_list, tbuf);</span>
 			break;
 		}
 	}
<span class="p_chunk">@@ -749,7 +733,8 @@</span> <span class="p_context"> static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,</span>
 	int error = 0;
 	int count;
 	unsigned long flags;
<span class="p_del">-	</span>
<span class="p_add">+	struct n_hdlc_buf *buf = NULL;</span>
<span class="p_add">+</span>
 	if (debuglevel &gt;= DEBUG_LEVEL_INFO)	
 		printk(&quot;%s(%d)n_hdlc_tty_ioctl() called %d\n&quot;,
 			__FILE__,__LINE__,cmd);
<span class="p_chunk">@@ -763,8 +748,10 @@</span> <span class="p_context"> static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,</span>
 		/* report count of read data available */
 		/* in next available frame (if any) */
 		spin_lock_irqsave(&amp;n_hdlc-&gt;rx_buf_list.spinlock,flags);
<span class="p_del">-		if (n_hdlc-&gt;rx_buf_list.head)</span>
<span class="p_del">-			count = n_hdlc-&gt;rx_buf_list.head-&gt;count;</span>
<span class="p_add">+		buf = list_first_entry_or_null(&amp;n_hdlc-&gt;rx_buf_list.list,</span>
<span class="p_add">+						struct n_hdlc_buf, list_item);</span>
<span class="p_add">+		if (buf)</span>
<span class="p_add">+			count = buf-&gt;count;</span>
 		else
 			count = 0;
 		spin_unlock_irqrestore(&amp;n_hdlc-&gt;rx_buf_list.spinlock,flags);
<span class="p_chunk">@@ -776,8 +763,10 @@</span> <span class="p_context"> static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,</span>
 		count = tty_chars_in_buffer(tty);
 		/* add size of next output frame in queue */
 		spin_lock_irqsave(&amp;n_hdlc-&gt;tx_buf_list.spinlock,flags);
<span class="p_del">-		if (n_hdlc-&gt;tx_buf_list.head)</span>
<span class="p_del">-			count += n_hdlc-&gt;tx_buf_list.head-&gt;count;</span>
<span class="p_add">+		buf = list_first_entry_or_null(&amp;n_hdlc-&gt;tx_buf_list.list,</span>
<span class="p_add">+						struct n_hdlc_buf, list_item);</span>
<span class="p_add">+		if (buf)</span>
<span class="p_add">+			count += buf-&gt;count;</span>
 		spin_unlock_irqrestore(&amp;n_hdlc-&gt;tx_buf_list.spinlock,flags);
 		error = put_user(count, (int __user *)arg);
 		break;
<span class="p_chunk">@@ -825,14 +814,14 @@</span> <span class="p_context"> static unsigned int n_hdlc_tty_poll(struct tty_struct *tty, struct file *filp,</span>
 		poll_wait(filp, &amp;tty-&gt;write_wait, wait);
 
 		/* set bits for operations that won&#39;t block */
<span class="p_del">-		if (n_hdlc-&gt;rx_buf_list.head)</span>
<span class="p_add">+		if (!list_empty(&amp;n_hdlc-&gt;rx_buf_list.list))</span>
 			mask |= POLLIN | POLLRDNORM;	/* readable */
 		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))
 			mask |= POLLHUP;
 		if (tty_hung_up_p(filp))
 			mask |= POLLHUP;
 		if (!tty_is_writelocked(tty) &amp;&amp;
<span class="p_del">-				n_hdlc-&gt;tx_free_buf_list.head)</span>
<span class="p_add">+				!list_empty(&amp;n_hdlc-&gt;tx_free_buf_list.list))</span>
 			mask |= POLLOUT | POLLWRNORM;	/* writable */
 	}
 	return mask;
<span class="p_chunk">@@ -856,7 +845,12 @@</span> <span class="p_context"> static struct n_hdlc *n_hdlc_alloc(void)</span>
 	spin_lock_init(&amp;n_hdlc-&gt;tx_free_buf_list.spinlock);
 	spin_lock_init(&amp;n_hdlc-&gt;rx_buf_list.spinlock);
 	spin_lock_init(&amp;n_hdlc-&gt;tx_buf_list.spinlock);
<span class="p_del">-	</span>
<span class="p_add">+</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;n_hdlc-&gt;rx_free_buf_list.list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;n_hdlc-&gt;tx_free_buf_list.list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;n_hdlc-&gt;rx_buf_list.list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;n_hdlc-&gt;tx_buf_list.list);</span>
<span class="p_add">+</span>
 	/* allocate free rx buffer list */
 	for(i=0;i&lt;DEFAULT_RX_BUF_COUNT;i++) {
 		buf = kmalloc(N_HDLC_BUF_SIZE, GFP_KERNEL);
<span class="p_chunk">@@ -884,53 +878,65 @@</span> <span class="p_context"> static struct n_hdlc *n_hdlc_alloc(void)</span>
 }	/* end of n_hdlc_alloc() */
 
 /**
<span class="p_add">+ * n_hdlc_buf_return - put the HDLC buffer after the head of the specified list</span>
<span class="p_add">+ * @buf_list - pointer to the buffer list</span>
<span class="p_add">+ * @buf - pointer to the buffer</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void n_hdlc_buf_return(struct n_hdlc_buf_list *buf_list,</span>
<span class="p_add">+						struct n_hdlc_buf *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;buf_list-&gt;spinlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_add(&amp;buf-&gt;list_item, &amp;buf_list-&gt;list);</span>
<span class="p_add">+	buf_list-&gt;count++;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;buf_list-&gt;spinlock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * n_hdlc_buf_put - add specified HDLC buffer to tail of specified list
<span class="p_del">- * @list - pointer to buffer list</span>
<span class="p_add">+ * @buf_list - pointer to buffer list</span>
  * @buf	- pointer to buffer
  */
<span class="p_del">-static void n_hdlc_buf_put(struct n_hdlc_buf_list *list,</span>
<span class="p_add">+static void n_hdlc_buf_put(struct n_hdlc_buf_list *buf_list,</span>
 			   struct n_hdlc_buf *buf)
 {
 	unsigned long flags;
<span class="p_del">-	spin_lock_irqsave(&amp;list-&gt;spinlock,flags);</span>
<span class="p_del">-	</span>
<span class="p_del">-	buf-&gt;link=NULL;</span>
<span class="p_del">-	if (list-&gt;tail)</span>
<span class="p_del">-		list-&gt;tail-&gt;link = buf;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		list-&gt;head = buf;</span>
<span class="p_del">-	list-&gt;tail = buf;</span>
<span class="p_del">-	(list-&gt;count)++;</span>
<span class="p_del">-	</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;list-&gt;spinlock,flags);</span>
<span class="p_del">-	</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;buf_list-&gt;spinlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_add_tail(&amp;buf-&gt;list_item, &amp;buf_list-&gt;list);</span>
<span class="p_add">+	buf_list-&gt;count++;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;buf_list-&gt;spinlock, flags);</span>
 }	/* end of n_hdlc_buf_put() */
 
 /**
  * n_hdlc_buf_get - remove and return an HDLC buffer from list
<span class="p_del">- * @list - pointer to HDLC buffer list</span>
<span class="p_add">+ * @buf_list - pointer to HDLC buffer list</span>
  * 
  * Remove and return an HDLC buffer from the head of the specified HDLC buffer
  * list.
  * Returns a pointer to HDLC buffer if available, otherwise %NULL.
  */
<span class="p_del">-static struct n_hdlc_buf* n_hdlc_buf_get(struct n_hdlc_buf_list *list)</span>
<span class="p_add">+static struct n_hdlc_buf *n_hdlc_buf_get(struct n_hdlc_buf_list *buf_list)</span>
 {
 	unsigned long flags;
 	struct n_hdlc_buf *buf;
<span class="p_del">-	spin_lock_irqsave(&amp;list-&gt;spinlock,flags);</span>
<span class="p_del">-	</span>
<span class="p_del">-	buf = list-&gt;head;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;buf_list-&gt;spinlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = list_first_entry_or_null(&amp;buf_list-&gt;list,</span>
<span class="p_add">+						struct n_hdlc_buf, list_item);</span>
 	if (buf) {
<span class="p_del">-		list-&gt;head = buf-&gt;link;</span>
<span class="p_del">-		(list-&gt;count)--;</span>
<span class="p_add">+		list_del(&amp;buf-&gt;list_item);</span>
<span class="p_add">+		buf_list-&gt;count--;</span>
 	}
<span class="p_del">-	if (!list-&gt;head)</span>
<span class="p_del">-		list-&gt;tail = NULL;</span>
<span class="p_del">-	</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;list-&gt;spinlock,flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;buf_list-&gt;spinlock, flags);</span>
 	return buf;
<span class="p_del">-	</span>
 }	/* end of n_hdlc_buf_get() */
 
 static char hdlc_banner[] __initdata =
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index b98c1578f45a..4d09bd495a88 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -2688,6 +2688,8 @@</span> <span class="p_context"> enum pci_board_num_t {</span>
 	pbn_b0_4_1152000_200,
 	pbn_b0_8_1152000_200,
 
<span class="p_add">+	pbn_b0_4_1250000,</span>
<span class="p_add">+</span>
 	pbn_b0_2_1843200,
 	pbn_b0_4_1843200,
 
<span class="p_chunk">@@ -2919,6 +2921,13 @@</span> <span class="p_context"> static struct pciserial_board pci_boards[] = {</span>
 		.uart_offset	= 0x200,
 	},
 
<span class="p_add">+	[pbn_b0_4_1250000] = {</span>
<span class="p_add">+		.flags		= FL_BASE0,</span>
<span class="p_add">+		.num_ports	= 4,</span>
<span class="p_add">+		.base_baud	= 1250000,</span>
<span class="p_add">+		.uart_offset	= 8,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	[pbn_b0_2_1843200] = {
 		.flags		= FL_BASE0,
 		.num_ports	= 2,
<span class="p_chunk">@@ -5549,6 +5558,10 @@</span> <span class="p_context"> static struct pci_device_id serial_pci_tbl[] = {</span>
 	{ PCI_DEVICE(0x1c29, 0x1108), .driver_data = pbn_fintek_8 },
 	{ PCI_DEVICE(0x1c29, 0x1112), .driver_data = pbn_fintek_12 },
 
<span class="p_add">+	/* MKS Tenta SCOM-080x serial cards */</span>
<span class="p_add">+	{ PCI_DEVICE(0x1601, 0x0800), .driver_data = pbn_b0_4_1250000 },</span>
<span class="p_add">+	{ PCI_DEVICE(0x1601, 0xa801), .driver_data = pbn_b0_4_1250000 },</span>
<span class="p_add">+</span>
 	/*
 	 * These entries match devices with class COMMUNICATION_SERIAL,
 	 * COMMUNICATION_MODEM or COMMUNICATION_MULTISERIAL
<span class="p_header">diff --git a/fs/afs/mntpt.c b/fs/afs/mntpt.c</span>
<span class="p_header">index 81dd075356b9..d4fb0afc0097 100644</span>
<span class="p_header">--- a/fs/afs/mntpt.c</span>
<span class="p_header">+++ b/fs/afs/mntpt.c</span>
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> static struct vfsmount *afs_mntpt_do_automount(struct dentry *mntpt)</span>
 
 	/* try and do the mount */
 	_debug(&quot;--- attempting mount %s -o %s ---&quot;, devname, options);
<span class="p_del">-	mnt = vfs_kern_mount(&amp;afs_fs_type, 0, devname, options);</span>
<span class="p_add">+	mnt = vfs_submount(mntpt, &amp;afs_fs_type, devname, options);</span>
 	_debug(&quot;--- mount result %p ---&quot;, mnt);
 
 	free_page((unsigned long) devname);
<span class="p_header">diff --git a/fs/autofs4/waitq.c b/fs/autofs4/waitq.c</span>
<span class="p_header">index e44271dfceb6..5db6c8d745ea 100644</span>
<span class="p_header">--- a/fs/autofs4/waitq.c</span>
<span class="p_header">+++ b/fs/autofs4/waitq.c</span>
<span class="p_chunk">@@ -431,8 +431,8 @@</span> <span class="p_context"> int autofs4_wait(struct autofs_sb_info *sbi,</span>
 		memcpy(&amp;wq-&gt;name, &amp;qstr, sizeof(struct qstr));
 		wq-&gt;dev = autofs4_get_dev(sbi);
 		wq-&gt;ino = autofs4_get_ino(sbi);
<span class="p_del">-		wq-&gt;uid = current_real_cred()-&gt;uid;</span>
<span class="p_del">-		wq-&gt;gid = current_real_cred()-&gt;gid;</span>
<span class="p_add">+		wq-&gt;uid = current_cred()-&gt;uid;</span>
<span class="p_add">+		wq-&gt;gid = current_cred()-&gt;gid;</span>
 		wq-&gt;pid = pid;
 		wq-&gt;tgid = tgid;
 		wq-&gt;status = -EINTR; /* Status return if interrupted */
<span class="p_header">diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c</span>
<span class="p_header">index 6a26c7bd1286..e3e1a80b351e 100644</span>
<span class="p_header">--- a/fs/ceph/mds_client.c</span>
<span class="p_header">+++ b/fs/ceph/mds_client.c</span>
<span class="p_chunk">@@ -628,6 +628,9 @@</span> <span class="p_context"> static void __unregister_request(struct ceph_mds_client *mdsc,</span>
 {
 	dout(&quot;__unregister_request %p tid %lld\n&quot;, req, req-&gt;r_tid);
 
<span class="p_add">+	/* Never leave an unregistered request on an unsafe list! */</span>
<span class="p_add">+	list_del_init(&amp;req-&gt;r_unsafe_item);</span>
<span class="p_add">+</span>
 	if (req-&gt;r_tid == mdsc-&gt;oldest_tid) {
 		struct rb_node *p = rb_next(&amp;req-&gt;r_node);
 		mdsc-&gt;oldest_tid = 0;
<span class="p_chunk">@@ -1036,7 +1039,6 @@</span> <span class="p_context"> static void cleanup_session_requests(struct ceph_mds_client *mdsc,</span>
 	while (!list_empty(&amp;session-&gt;s_unsafe)) {
 		req = list_first_entry(&amp;session-&gt;s_unsafe,
 				       struct ceph_mds_request, r_unsafe_item);
<span class="p_del">-		list_del_init(&amp;req-&gt;r_unsafe_item);</span>
 		pr_warn_ratelimited(&quot; dropping unsafe request %llu\n&quot;,
 				    req-&gt;r_tid);
 		__unregister_request(mdsc, req);
<span class="p_chunk">@@ -2423,7 +2425,6 @@</span> <span class="p_context"> static void handle_reply(struct ceph_mds_session *session, struct ceph_msg *msg)</span>
 			 * useful we could do with a revised return value.
 			 */
 			dout(&quot;got safe reply %llu, mds%d\n&quot;, tid, mds);
<span class="p_del">-			list_del_init(&amp;req-&gt;r_unsafe_item);</span>
 
 			/* last unsafe request during umount? */
 			if (mdsc-&gt;stopping &amp;&amp; !__get_oldest_req(mdsc))
<span class="p_header">diff --git a/fs/cifs/cifs_dfs_ref.c b/fs/cifs/cifs_dfs_ref.c</span>
<span class="p_header">index ec9dbbcca3b9..9156be545b0f 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_dfs_ref.c</span>
<span class="p_header">+++ b/fs/cifs/cifs_dfs_ref.c</span>
<span class="p_chunk">@@ -245,7 +245,8 @@</span> <span class="p_context"> char *cifs_compose_mount_options(const char *sb_mountdata,</span>
  * @fullpath:		full path in UNC format
  * @ref:		server&#39;s referral
  */
<span class="p_del">-static struct vfsmount *cifs_dfs_do_refmount(struct cifs_sb_info *cifs_sb,</span>
<span class="p_add">+static struct vfsmount *cifs_dfs_do_refmount(struct dentry *mntpt,</span>
<span class="p_add">+		struct cifs_sb_info *cifs_sb,</span>
 		const char *fullpath, const struct dfs_info3_param *ref)
 {
 	struct vfsmount *mnt;
<span class="p_chunk">@@ -259,7 +260,7 @@</span> <span class="p_context"> static struct vfsmount *cifs_dfs_do_refmount(struct cifs_sb_info *cifs_sb,</span>
 	if (IS_ERR(mountdata))
 		return (struct vfsmount *)mountdata;
 
<span class="p_del">-	mnt = vfs_kern_mount(&amp;cifs_fs_type, 0, devname, mountdata);</span>
<span class="p_add">+	mnt = vfs_submount(mntpt, &amp;cifs_fs_type, devname, mountdata);</span>
 	kfree(mountdata);
 	kfree(devname);
 	return mnt;
<span class="p_chunk">@@ -334,7 +335,7 @@</span> <span class="p_context"> static struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)</span>
 			mnt = ERR_PTR(-EINVAL);
 			break;
 		}
<span class="p_del">-		mnt = cifs_dfs_do_refmount(cifs_sb,</span>
<span class="p_add">+		mnt = cifs_dfs_do_refmount(mntpt, cifs_sb,</span>
 				full_path, referrals + i);
 		cifs_dbg(FYI, &quot;%s: cifs_dfs_do_refmount:%s , mnt:%p\n&quot;,
 			 __func__, referrals[i].node_name, mnt);
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index f17fcf89e18e..1e30f74a9527 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -187,9 +187,9 @@</span> <span class="p_context"> static const struct super_operations debugfs_super_operations = {</span>
 
 static struct vfsmount *debugfs_automount(struct path *path)
 {
<span class="p_del">-	struct vfsmount *(*f)(void *);</span>
<span class="p_del">-	f = (struct vfsmount *(*)(void *))path-&gt;dentry-&gt;d_fsdata;</span>
<span class="p_del">-	return f(d_inode(path-&gt;dentry)-&gt;i_private);</span>
<span class="p_add">+	debugfs_automount_t f;</span>
<span class="p_add">+	f = (debugfs_automount_t)path-&gt;dentry-&gt;d_fsdata;</span>
<span class="p_add">+	return f(path-&gt;dentry, d_inode(path-&gt;dentry)-&gt;i_private);</span>
 }
 
 static const struct dentry_operations debugfs_dops = {
<span class="p_chunk">@@ -504,7 +504,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(debugfs_create_dir);</span>
  */
 struct dentry *debugfs_create_automount(const char *name,
 					struct dentry *parent,
<span class="p_del">-					struct vfsmount *(*f)(void *),</span>
<span class="p_add">+					debugfs_automount_t f,</span>
 					void *data)
 {
 	struct dentry *dentry = start_creating(name, parent);
<span class="p_header">diff --git a/fs/fat/inode.c b/fs/fat/inode.c</span>
<span class="p_header">index 338d2f73eb29..a2c05f2ada6d 100644</span>
<span class="p_header">--- a/fs/fat/inode.c</span>
<span class="p_header">+++ b/fs/fat/inode.c</span>
<span class="p_chunk">@@ -1359,6 +1359,16 @@</span> <span class="p_context"> static int parse_options(struct super_block *sb, char *options, int is_vfat,</span>
 	return 0;
 }
 
<span class="p_add">+static void fat_dummy_inode_init(struct inode *inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Initialize this dummy inode to work as no-op. */</span>
<span class="p_add">+	MSDOS_I(inode)-&gt;mmu_private = 0;</span>
<span class="p_add">+	MSDOS_I(inode)-&gt;i_start = 0;</span>
<span class="p_add">+	MSDOS_I(inode)-&gt;i_logstart = 0;</span>
<span class="p_add">+	MSDOS_I(inode)-&gt;i_attrs = 0;</span>
<span class="p_add">+	MSDOS_I(inode)-&gt;i_pos = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int fat_read_root(struct inode *inode)
 {
 	struct msdos_sb_info *sbi = MSDOS_SB(inode-&gt;i_sb);
<span class="p_chunk">@@ -1803,12 +1813,13 @@</span> <span class="p_context"> int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,</span>
 	fat_inode = new_inode(sb);
 	if (!fat_inode)
 		goto out_fail;
<span class="p_del">-	MSDOS_I(fat_inode)-&gt;i_pos = 0;</span>
<span class="p_add">+	fat_dummy_inode_init(fat_inode);</span>
 	sbi-&gt;fat_inode = fat_inode;
 
 	fsinfo_inode = new_inode(sb);
 	if (!fsinfo_inode)
 		goto out_fail;
<span class="p_add">+	fat_dummy_inode_init(fsinfo_inode);</span>
 	fsinfo_inode-&gt;i_ino = MSDOS_FSINFO_INO;
 	sbi-&gt;fsinfo_inode = fsinfo_inode;
 	insert_inode_hash(fsinfo_inode);
<span class="p_header">diff --git a/fs/mount.h b/fs/mount.h</span>
<span class="p_header">index d2e25d7b64b3..d8295f273a2f 100644</span>
<span class="p_header">--- a/fs/mount.h</span>
<span class="p_header">+++ b/fs/mount.h</span>
<span class="p_chunk">@@ -89,7 +89,6 @@</span> <span class="p_context"> static inline int is_mounted(struct vfsmount *mnt)</span>
 }
 
 extern struct mount *__lookup_mnt(struct vfsmount *, struct dentry *);
<span class="p_del">-extern struct mount *__lookup_mnt_last(struct vfsmount *, struct dentry *);</span>
 
 extern int __legitimize_mnt(struct vfsmount *, unsigned);
 extern bool legitimize_mnt(struct vfsmount *, unsigned);
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 5b4eed221530..d5e5140c1045 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1100,7 +1100,6 @@</span> <span class="p_context"> static int follow_automount(struct path *path, struct nameidata *nd,</span>
 			    bool *need_mntput)
 {
 	struct vfsmount *mnt;
<span class="p_del">-	const struct cred *old_cred;</span>
 	int err;
 
 	if (!path-&gt;dentry-&gt;d_op || !path-&gt;dentry-&gt;d_op-&gt;d_automount)
<span class="p_chunk">@@ -1129,9 +1128,7 @@</span> <span class="p_context"> static int follow_automount(struct path *path, struct nameidata *nd,</span>
 	if (nd-&gt;total_link_count &gt;= 40)
 		return -ELOOP;
 
<span class="p_del">-	old_cred = override_creds(&amp;init_cred);</span>
 	mnt = path-&gt;dentry-&gt;d_op-&gt;d_automount(path);
<span class="p_del">-	revert_creds(old_cred);</span>
 	if (IS_ERR(mnt)) {
 		/*
 		 * The filesystem is allowed to return -EISDIR here to indicate
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 7cea503ae06d..5e35057f07ac 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -641,28 +641,6 @@</span> <span class="p_context"> struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)</span>
 }
 
 /*
<span class="p_del">- * find the last mount at @dentry on vfsmount @mnt.</span>
<span class="p_del">- * mount_lock must be held.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mount *p, *res = NULL;</span>
<span class="p_del">-	p = __lookup_mnt(mnt, dentry);</span>
<span class="p_del">-	if (!p)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	if (!(p-&gt;mnt.mnt_flags &amp; MNT_UMOUNT))</span>
<span class="p_del">-		res = p;</span>
<span class="p_del">-	hlist_for_each_entry_continue(p, mnt_hash) {</span>
<span class="p_del">-		if (&amp;p-&gt;mnt_parent-&gt;mnt != mnt || p-&gt;mnt_mountpoint != dentry)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		if (!(p-&gt;mnt.mnt_flags &amp; MNT_UMOUNT))</span>
<span class="p_del">-			res = p;</span>
<span class="p_del">-	}</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return res;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * lookup_mnt - Return the first child mount mounted at path
  *
  * &quot;First&quot; means first mounted chronologically.  If you create the
<span class="p_chunk">@@ -882,6 +860,13 @@</span> <span class="p_context"> void mnt_set_mountpoint(struct mount *mnt,</span>
 	hlist_add_head(&amp;child_mnt-&gt;mnt_mp_list, &amp;mp-&gt;m_list);
 }
 
<span class="p_add">+static void __attach_mnt(struct mount *mnt, struct mount *parent)</span>
<span class="p_add">+{</span>
<span class="p_add">+	hlist_add_head_rcu(&amp;mnt-&gt;mnt_hash,</span>
<span class="p_add">+			   m_hash(&amp;parent-&gt;mnt, mnt-&gt;mnt_mountpoint));</span>
<span class="p_add">+	list_add_tail(&amp;mnt-&gt;mnt_child, &amp;parent-&gt;mnt_mounts);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * vfsmount lock must be held for write
  */
<span class="p_chunk">@@ -890,28 +875,45 @@</span> <span class="p_context"> static void attach_mnt(struct mount *mnt,</span>
 			struct mountpoint *mp)
 {
 	mnt_set_mountpoint(parent, mp, mnt);
<span class="p_del">-	hlist_add_head_rcu(&amp;mnt-&gt;mnt_hash, m_hash(&amp;parent-&gt;mnt, mp-&gt;m_dentry));</span>
<span class="p_del">-	list_add_tail(&amp;mnt-&gt;mnt_child, &amp;parent-&gt;mnt_mounts);</span>
<span class="p_add">+	__attach_mnt(mnt, parent);</span>
 }
 
<span class="p_del">-static void attach_shadowed(struct mount *mnt,</span>
<span class="p_del">-			struct mount *parent,</span>
<span class="p_del">-			struct mount *shadows)</span>
<span class="p_add">+void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp, struct mount *mnt)</span>
 {
<span class="p_del">-	if (shadows) {</span>
<span class="p_del">-		hlist_add_behind_rcu(&amp;mnt-&gt;mnt_hash, &amp;shadows-&gt;mnt_hash);</span>
<span class="p_del">-		list_add(&amp;mnt-&gt;mnt_child, &amp;shadows-&gt;mnt_child);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		hlist_add_head_rcu(&amp;mnt-&gt;mnt_hash,</span>
<span class="p_del">-				m_hash(&amp;parent-&gt;mnt, mnt-&gt;mnt_mountpoint));</span>
<span class="p_del">-		list_add_tail(&amp;mnt-&gt;mnt_child, &amp;parent-&gt;mnt_mounts);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	struct mountpoint *old_mp = mnt-&gt;mnt_mp;</span>
<span class="p_add">+	struct dentry *old_mountpoint = mnt-&gt;mnt_mountpoint;</span>
<span class="p_add">+	struct mount *old_parent = mnt-&gt;mnt_parent;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_del_init(&amp;mnt-&gt;mnt_child);</span>
<span class="p_add">+	hlist_del_init(&amp;mnt-&gt;mnt_mp_list);</span>
<span class="p_add">+	hlist_del_init_rcu(&amp;mnt-&gt;mnt_hash);</span>
<span class="p_add">+</span>
<span class="p_add">+	attach_mnt(mnt, parent, mp);</span>
<span class="p_add">+</span>
<span class="p_add">+	put_mountpoint(old_mp);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Safely avoid even the suggestion this code might sleep or</span>
<span class="p_add">+	 * lock the mount hash by taking advantage of the knowledge that</span>
<span class="p_add">+	 * mnt_change_mountpoint will not release the final reference</span>
<span class="p_add">+	 * to a mountpoint.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * During mounting, the mount passed in as the parent mount will</span>
<span class="p_add">+	 * continue to use the old mountpoint and during unmounting, the</span>
<span class="p_add">+	 * old mountpoint will continue to exist until namespace_unlock,</span>
<span class="p_add">+	 * which happens well after mnt_change_mountpoint.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock(&amp;old_mountpoint-&gt;d_lock);</span>
<span class="p_add">+	old_mountpoint-&gt;d_lockref.count--;</span>
<span class="p_add">+	spin_unlock(&amp;old_mountpoint-&gt;d_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	mnt_add_count(old_parent, -1);</span>
 }
 
 /*
  * vfsmount lock must be held for write
  */
<span class="p_del">-static void commit_tree(struct mount *mnt, struct mount *shadows)</span>
<span class="p_add">+static void commit_tree(struct mount *mnt)</span>
 {
 	struct mount *parent = mnt-&gt;mnt_parent;
 	struct mount *m;
<span class="p_chunk">@@ -929,7 +931,7 @@</span> <span class="p_context"> static void commit_tree(struct mount *mnt, struct mount *shadows)</span>
 	n-&gt;mounts += n-&gt;pending_mounts;
 	n-&gt;pending_mounts = 0;
 
<span class="p_del">-	attach_shadowed(mnt, parent, shadows);</span>
<span class="p_add">+	__attach_mnt(mnt, parent);</span>
 	touch_mnt_namespace(n);
 }
 
<span class="p_chunk">@@ -993,6 +995,21 @@</span> <span class="p_context"> vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void</span>
 }
 EXPORT_SYMBOL_GPL(vfs_kern_mount);
 
<span class="p_add">+struct vfsmount *</span>
<span class="p_add">+vfs_submount(const struct dentry *mountpoint, struct file_system_type *type,</span>
<span class="p_add">+	     const char *name, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Until it is worked out how to pass the user namespace</span>
<span class="p_add">+	 * through from the parent mount to the submount don&#39;t support</span>
<span class="p_add">+	 * unprivileged mounts with submounts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mountpoint-&gt;d_sb-&gt;s_user_ns != &amp;init_user_ns)</span>
<span class="p_add">+		return ERR_PTR(-EPERM);</span>
<span class="p_add">+</span>
<span class="p_add">+	return vfs_kern_mount(type, MS_SUBMOUNT, name, data);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(vfs_submount);</span>
<span class="p_add">+</span>
 static struct mount *clone_mnt(struct mount *old, struct dentry *root,
 					int flag)
 {
<span class="p_chunk">@@ -1737,7 +1754,6 @@</span> <span class="p_context"> struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,</span>
 			continue;
 
 		for (s = r; s; s = next_mnt(s, r)) {
<span class="p_del">-			struct mount *t = NULL;</span>
 			if (!(flag &amp; CL_COPY_UNBINDABLE) &amp;&amp;
 			    IS_MNT_UNBINDABLE(s)) {
 				s = skip_mnt_tree(s);
<span class="p_chunk">@@ -1759,14 +1775,7 @@</span> <span class="p_context"> struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,</span>
 				goto out;
 			lock_mount_hash();
 			list_add_tail(&amp;q-&gt;mnt_list, &amp;res-&gt;mnt_list);
<span class="p_del">-			mnt_set_mountpoint(parent, p-&gt;mnt_mp, q);</span>
<span class="p_del">-			if (!list_empty(&amp;parent-&gt;mnt_mounts)) {</span>
<span class="p_del">-				t = list_last_entry(&amp;parent-&gt;mnt_mounts,</span>
<span class="p_del">-					struct mount, mnt_child);</span>
<span class="p_del">-				if (t-&gt;mnt_mp != p-&gt;mnt_mp)</span>
<span class="p_del">-					t = NULL;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			attach_shadowed(q, parent, t);</span>
<span class="p_add">+			attach_mnt(q, parent, p-&gt;mnt_mp);</span>
 			unlock_mount_hash();
 		}
 	}
<span class="p_chunk">@@ -1967,10 +1976,18 @@</span> <span class="p_context"> static int attach_recursive_mnt(struct mount *source_mnt,</span>
 {
 	HLIST_HEAD(tree_list);
 	struct mnt_namespace *ns = dest_mnt-&gt;mnt_ns;
<span class="p_add">+	struct mountpoint *smp;</span>
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
<span class="p_add">+	/* Preallocate a mountpoint in case the new mounts need</span>
<span class="p_add">+	 * to be tucked under other mounts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp = get_mountpoint(source_mnt-&gt;mnt.mnt_root);</span>
<span class="p_add">+	if (IS_ERR(smp))</span>
<span class="p_add">+		return PTR_ERR(smp);</span>
<span class="p_add">+</span>
 	/* Is there space to add these mounts to the mount namespace? */
 	if (!parent_path) {
 		err = count_mounts(ns, source_mnt);
<span class="p_chunk">@@ -1997,16 +2014,19 @@</span> <span class="p_context"> static int attach_recursive_mnt(struct mount *source_mnt,</span>
 		touch_mnt_namespace(source_mnt-&gt;mnt_ns);
 	} else {
 		mnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);
<span class="p_del">-		commit_tree(source_mnt, NULL);</span>
<span class="p_add">+		commit_tree(source_mnt);</span>
 	}
 
 	hlist_for_each_entry_safe(child, n, &amp;tree_list, mnt_hash) {
 		struct mount *q;
 		hlist_del_init(&amp;child-&gt;mnt_hash);
<span class="p_del">-		q = __lookup_mnt_last(&amp;child-&gt;mnt_parent-&gt;mnt,</span>
<span class="p_del">-				      child-&gt;mnt_mountpoint);</span>
<span class="p_del">-		commit_tree(child, q);</span>
<span class="p_add">+		q = __lookup_mnt(&amp;child-&gt;mnt_parent-&gt;mnt,</span>
<span class="p_add">+				 child-&gt;mnt_mountpoint);</span>
<span class="p_add">+		if (q)</span>
<span class="p_add">+			mnt_change_mountpoint(child, smp, q);</span>
<span class="p_add">+		commit_tree(child);</span>
 	}
<span class="p_add">+	put_mountpoint(smp);</span>
 	unlock_mount_hash();
 
 	return 0;
<span class="p_chunk">@@ -2021,6 +2041,11 @@</span> <span class="p_context"> static int attach_recursive_mnt(struct mount *source_mnt,</span>
 	cleanup_group_ids(source_mnt, NULL);
  out:
 	ns-&gt;pending_mounts = 0;
<span class="p_add">+</span>
<span class="p_add">+	read_seqlock_excl(&amp;mount_lock);</span>
<span class="p_add">+	put_mountpoint(smp);</span>
<span class="p_add">+	read_sequnlock_excl(&amp;mount_lock);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_chunk">@@ -2769,7 +2794,7 @@</span> <span class="p_context"> long do_mount(const char *dev_name, const char __user *dir_name,</span>
 
 	flags &amp;= ~(MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_ACTIVE | MS_BORN |
 		   MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT |
<span class="p_del">-		   MS_STRICTATIME | MS_NOREMOTELOCK);</span>
<span class="p_add">+		   MS_STRICTATIME | MS_NOREMOTELOCK | MS_SUBMOUNT);</span>
 
 	if (flags &amp; MS_REMOUNT)
 		retval = do_remount(&amp;path, flags &amp; ~MS_REMOUNT, mnt_flags,
<span class="p_header">diff --git a/fs/nfs/namespace.c b/fs/nfs/namespace.c</span>
<span class="p_header">index 5551e8ef67fd..e49d831c4e85 100644</span>
<span class="p_header">--- a/fs/nfs/namespace.c</span>
<span class="p_header">+++ b/fs/nfs/namespace.c</span>
<span class="p_chunk">@@ -226,7 +226,7 @@</span> <span class="p_context"> static struct vfsmount *nfs_do_clone_mount(struct nfs_server *server,</span>
 					   const char *devname,
 					   struct nfs_clone_mount *mountdata)
 {
<span class="p_del">-	return vfs_kern_mount(&amp;nfs_xdev_fs_type, 0, devname, mountdata);</span>
<span class="p_add">+	return vfs_submount(mountdata-&gt;dentry, &amp;nfs_xdev_fs_type, devname, mountdata);</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/nfs/nfs4namespace.c b/fs/nfs/nfs4namespace.c</span>
<span class="p_header">index d21104912676..d8b040bd9814 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4namespace.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4namespace.c</span>
<span class="p_chunk">@@ -279,7 +279,7 @@</span> <span class="p_context"> static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,</span>
 				mountdata-&gt;hostname,
 				mountdata-&gt;mnt_path);
 
<span class="p_del">-		mnt = vfs_kern_mount(&amp;nfs4_referral_fs_type, 0, page, mountdata);</span>
<span class="p_add">+		mnt = vfs_submount(mountdata-&gt;dentry, &amp;nfs4_referral_fs_type, page, mountdata);</span>
 		if (!IS_ERR(mnt))
 			break;
 	}
<span class="p_header">diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c</span>
<span class="p_header">index c48859f16e7b..67c24351a67f 100644</span>
<span class="p_header">--- a/fs/orangefs/super.c</span>
<span class="p_header">+++ b/fs/orangefs/super.c</span>
<span class="p_chunk">@@ -115,6 +115,13 @@</span> <span class="p_context"> static struct inode *orangefs_alloc_inode(struct super_block *sb)</span>
 	return &amp;orangefs_inode-&gt;vfs_inode;
 }
 
<span class="p_add">+static void orangefs_i_callback(struct rcu_head *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = container_of(head, struct inode, i_rcu);</span>
<span class="p_add">+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);</span>
<span class="p_add">+	kmem_cache_free(orangefs_inode_cache, orangefs_inode);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void orangefs_destroy_inode(struct inode *inode)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
<span class="p_chunk">@@ -123,7 +130,7 @@</span> <span class="p_context"> static void orangefs_destroy_inode(struct inode *inode)</span>
 			&quot;%s: deallocated %p destroying inode %pU\n&quot;,
 			__func__, orangefs_inode, get_khandle_from_ino(inode));
 
<span class="p_del">-	kmem_cache_free(orangefs_inode_cache, orangefs_inode);</span>
<span class="p_add">+	call_rcu(&amp;inode-&gt;i_rcu, orangefs_i_callback);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/pnode.c b/fs/pnode.c</span>
<span class="p_header">index 234a9ac49958..b394ca5307ec 100644</span>
<span class="p_header">--- a/fs/pnode.c</span>
<span class="p_header">+++ b/fs/pnode.c</span>
<span class="p_chunk">@@ -324,6 +324,21 @@</span> <span class="p_context"> int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,</span>
 	return ret;
 }
 
<span class="p_add">+static struct mount *find_topper(struct mount *mnt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* If there is exactly one mount covering mnt completely return it. */</span>
<span class="p_add">+	struct mount *child;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!list_is_singular(&amp;mnt-&gt;mnt_mounts))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	child = list_first_entry(&amp;mnt-&gt;mnt_mounts, struct mount, mnt_child);</span>
<span class="p_add">+	if (child-&gt;mnt_mountpoint != mnt-&gt;mnt.mnt_root)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return child;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * return true if the refcount is greater than count
  */
<span class="p_chunk">@@ -344,9 +359,8 @@</span> <span class="p_context"> static inline int do_refcount_check(struct mount *mnt, int count)</span>
  */
 int propagate_mount_busy(struct mount *mnt, int refcnt)
 {
<span class="p_del">-	struct mount *m, *child;</span>
<span class="p_add">+	struct mount *m, *child, *topper;</span>
 	struct mount *parent = mnt-&gt;mnt_parent;
<span class="p_del">-	int ret = 0;</span>
 
 	if (mnt == parent)
 		return do_refcount_check(mnt, refcnt);
<span class="p_chunk">@@ -361,12 +375,24 @@</span> <span class="p_context"> int propagate_mount_busy(struct mount *mnt, int refcnt)</span>
 
 	for (m = propagation_next(parent, parent); m;
 	     		m = propagation_next(m, parent)) {
<span class="p_del">-		child = __lookup_mnt_last(&amp;m-&gt;mnt, mnt-&gt;mnt_mountpoint);</span>
<span class="p_del">-		if (child &amp;&amp; list_empty(&amp;child-&gt;mnt_mounts) &amp;&amp;</span>
<span class="p_del">-		    (ret = do_refcount_check(child, 1)))</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		int count = 1;</span>
<span class="p_add">+		child = __lookup_mnt(&amp;m-&gt;mnt, mnt-&gt;mnt_mountpoint);</span>
<span class="p_add">+		if (!child)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Is there exactly one mount on the child that covers</span>
<span class="p_add">+		 * it completely whose reference should be ignored?</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		topper = find_topper(child);</span>
<span class="p_add">+		if (topper)</span>
<span class="p_add">+			count += 1;</span>
<span class="p_add">+		else if (!list_empty(&amp;child-&gt;mnt_mounts))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (do_refcount_check(child, count))</span>
<span class="p_add">+			return 1;</span>
 	}
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -383,7 +409,7 @@</span> <span class="p_context"> void propagate_mount_unlock(struct mount *mnt)</span>
 
 	for (m = propagation_next(parent, parent); m;
 			m = propagation_next(m, parent)) {
<span class="p_del">-		child = __lookup_mnt_last(&amp;m-&gt;mnt, mnt-&gt;mnt_mountpoint);</span>
<span class="p_add">+		child = __lookup_mnt(&amp;m-&gt;mnt, mnt-&gt;mnt_mountpoint);</span>
 		if (child)
 			child-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED;
 	}
<span class="p_chunk">@@ -401,9 +427,11 @@</span> <span class="p_context"> static void mark_umount_candidates(struct mount *mnt)</span>
 
 	for (m = propagation_next(parent, parent); m;
 			m = propagation_next(m, parent)) {
<span class="p_del">-		struct mount *child = __lookup_mnt_last(&amp;m-&gt;mnt,</span>
<span class="p_add">+		struct mount *child = __lookup_mnt(&amp;m-&gt;mnt,</span>
 						mnt-&gt;mnt_mountpoint);
<span class="p_del">-		if (child &amp;&amp; (!IS_MNT_LOCKED(child) || IS_MNT_MARKED(m))) {</span>
<span class="p_add">+		if (!child || (child-&gt;mnt.mnt_flags &amp; MNT_UMOUNT))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (!IS_MNT_LOCKED(child) || IS_MNT_MARKED(m)) {</span>
 			SET_MNT_MARK(child);
 		}
 	}
<span class="p_chunk">@@ -422,8 +450,8 @@</span> <span class="p_context"> static void __propagate_umount(struct mount *mnt)</span>
 
 	for (m = propagation_next(parent, parent); m;
 			m = propagation_next(m, parent)) {
<span class="p_del">-</span>
<span class="p_del">-		struct mount *child = __lookup_mnt_last(&amp;m-&gt;mnt,</span>
<span class="p_add">+		struct mount *topper;</span>
<span class="p_add">+		struct mount *child = __lookup_mnt(&amp;m-&gt;mnt,</span>
 						mnt-&gt;mnt_mountpoint);
 		/*
 		 * umount the child only if the child has no children
<span class="p_chunk">@@ -432,6 +460,15 @@</span> <span class="p_context"> static void __propagate_umount(struct mount *mnt)</span>
 		if (!child || !IS_MNT_MARKED(child))
 			continue;
 		CLEAR_MNT_MARK(child);
<span class="p_add">+</span>
<span class="p_add">+		/* If there is exactly one mount covering all of child</span>
<span class="p_add">+		 * replace child with that mount.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		topper = find_topper(child);</span>
<span class="p_add">+		if (topper)</span>
<span class="p_add">+			mnt_change_mountpoint(child-&gt;mnt_parent, child-&gt;mnt_mp,</span>
<span class="p_add">+					      topper);</span>
<span class="p_add">+</span>
 		if (list_empty(&amp;child-&gt;mnt_mounts)) {
 			list_del_init(&amp;child-&gt;mnt_child);
 			child-&gt;mnt.mnt_flags |= MNT_UMOUNT;
<span class="p_header">diff --git a/fs/pnode.h b/fs/pnode.h</span>
<span class="p_header">index 550f5a8b4fcf..dc87e65becd2 100644</span>
<span class="p_header">--- a/fs/pnode.h</span>
<span class="p_header">+++ b/fs/pnode.h</span>
<span class="p_chunk">@@ -49,6 +49,8 @@</span> <span class="p_context"> int get_dominating_id(struct mount *mnt, const struct path *root);</span>
 unsigned int mnt_get_count(struct mount *mnt);
 void mnt_set_mountpoint(struct mount *, struct mountpoint *,
 			struct mount *);
<span class="p_add">+void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp,</span>
<span class="p_add">+			   struct mount *mnt);</span>
 struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);
<span class="p_header">diff --git a/fs/super.c b/fs/super.c</span>
<span class="p_header">index c183835566c1..1058bf3e8724 100644</span>
<span class="p_header">--- a/fs/super.c</span>
<span class="p_header">+++ b/fs/super.c</span>
<span class="p_chunk">@@ -470,7 +470,7 @@</span> <span class="p_context"> struct super_block *sget_userns(struct file_system_type *type,</span>
 	struct super_block *old;
 	int err;
 
<span class="p_del">-	if (!(flags &amp; MS_KERNMOUNT) &amp;&amp;</span>
<span class="p_add">+	if (!(flags &amp; (MS_KERNMOUNT|MS_SUBMOUNT)) &amp;&amp;</span>
 	    !(type-&gt;fs_flags &amp; FS_USERNS_MOUNT) &amp;&amp;
 	    !capable(CAP_SYS_ADMIN))
 		return ERR_PTR(-EPERM);
<span class="p_chunk">@@ -500,7 +500,7 @@</span> <span class="p_context"> struct super_block *sget_userns(struct file_system_type *type,</span>
 	}
 	if (!s) {
 		spin_unlock(&amp;sb_lock);
<span class="p_del">-		s = alloc_super(type, flags, user_ns);</span>
<span class="p_add">+		s = alloc_super(type, (flags &amp; ~MS_SUBMOUNT), user_ns);</span>
 		if (!s)
 			return ERR_PTR(-ENOMEM);
 		goto retry;
<span class="p_chunk">@@ -541,8 +541,15 @@</span> <span class="p_context"> struct super_block *sget(struct file_system_type *type,</span>
 {
 	struct user_namespace *user_ns = current_user_ns();
 
<span class="p_add">+	/* We don&#39;t yet pass the user namespace of the parent</span>
<span class="p_add">+	 * mount through to here so always use &amp;init_user_ns</span>
<span class="p_add">+	 * until that changes.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (flags &amp; MS_SUBMOUNT)</span>
<span class="p_add">+		user_ns = &amp;init_user_ns;</span>
<span class="p_add">+</span>
 	/* Ensure the requestor has permissions over the target filesystem */
<span class="p_del">-	if (!(flags &amp; MS_KERNMOUNT) &amp;&amp; !ns_capable(user_ns, CAP_SYS_ADMIN))</span>
<span class="p_add">+	if (!(flags &amp; (MS_KERNMOUNT|MS_SUBMOUNT)) &amp;&amp; !ns_capable(user_ns, CAP_SYS_ADMIN))</span>
 		return ERR_PTR(-EPERM);
 
 	return sget_userns(type, test, set, flags, user_ns, data);
<span class="p_header">diff --git a/include/linux/ceph/osdmap.h b/include/linux/ceph/osdmap.h</span>
<span class="p_header">index 9a9041784dcf..412906609954 100644</span>
<span class="p_header">--- a/include/linux/ceph/osdmap.h</span>
<span class="p_header">+++ b/include/linux/ceph/osdmap.h</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> static inline bool ceph_can_shift_osds(struct ceph_pg_pool_info *pool)</span>
 	case CEPH_POOL_TYPE_EC:
 		return false;
 	default:
<span class="p_del">-		BUG_ON(1);</span>
<span class="p_add">+		BUG();</span>
 	}
 }
 
<span class="p_header">diff --git a/include/linux/debugfs.h b/include/linux/debugfs.h</span>
<span class="p_header">index 1b413a9aab81..b20a0945b550 100644</span>
<span class="p_header">--- a/include/linux/debugfs.h</span>
<span class="p_header">+++ b/include/linux/debugfs.h</span>
<span class="p_chunk">@@ -96,9 +96,10 @@</span> <span class="p_context"> struct dentry *debugfs_create_dir(const char *name, struct dentry *parent);</span>
 struct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,
 				      const char *dest);
 
<span class="p_add">+typedef struct vfsmount *(*debugfs_automount_t)(struct dentry *, void *);</span>
 struct dentry *debugfs_create_automount(const char *name,
 					struct dentry *parent,
<span class="p_del">-					struct vfsmount *(*f)(void *),</span>
<span class="p_add">+					debugfs_automount_t f,</span>
 					void *data);
 
 void debugfs_remove(struct dentry *dentry);
<span class="p_header">diff --git a/include/linux/libnvdimm.h b/include/linux/libnvdimm.h</span>
<span class="p_header">index 8458c5351e56..77e7af32543f 100644</span>
<span class="p_header">--- a/include/linux/libnvdimm.h</span>
<span class="p_header">+++ b/include/linux/libnvdimm.h</span>
<span class="p_chunk">@@ -70,6 +70,8 @@</span> <span class="p_context"> struct nd_cmd_desc {</span>
 
 struct nd_interleave_set {
 	u64 cookie;
<span class="p_add">+	/* compatibility with initial buggy Linux implementation */</span>
<span class="p_add">+	u64 altcookie;</span>
 };
 
 struct nd_mapping_desc {
<span class="p_header">diff --git a/include/linux/lockd/lockd.h b/include/linux/lockd/lockd.h</span>
<span class="p_header">index c15373894a42..b37dee3acaba 100644</span>
<span class="p_header">--- a/include/linux/lockd/lockd.h</span>
<span class="p_header">+++ b/include/linux/lockd/lockd.h</span>
<span class="p_chunk">@@ -355,7 +355,8 @@</span> <span class="p_context"> static inline int nlm_privileged_requester(const struct svc_rqst *rqstp)</span>
 static inline int nlm_compare_locks(const struct file_lock *fl1,
 				    const struct file_lock *fl2)
 {
<span class="p_del">-	return	fl1-&gt;fl_pid   == fl2-&gt;fl_pid</span>
<span class="p_add">+	return file_inode(fl1-&gt;fl_file) == file_inode(fl2-&gt;fl_file)</span>
<span class="p_add">+	     &amp;&amp; fl1-&gt;fl_pid   == fl2-&gt;fl_pid</span>
 	     &amp;&amp; fl1-&gt;fl_owner == fl2-&gt;fl_owner
 	     &amp;&amp; fl1-&gt;fl_start == fl2-&gt;fl_start
 	     &amp;&amp; fl1-&gt;fl_end   == fl2-&gt;fl_end
<span class="p_header">diff --git a/include/linux/mount.h b/include/linux/mount.h</span>
<span class="p_header">index 1172cce949a4..e0f3a82eee6d 100644</span>
<span class="p_header">--- a/include/linux/mount.h</span>
<span class="p_header">+++ b/include/linux/mount.h</span>
<span class="p_chunk">@@ -90,6 +90,9 @@</span> <span class="p_context"> struct file_system_type;</span>
 extern struct vfsmount *vfs_kern_mount(struct file_system_type *type,
 				      int flags, const char *name,
 				      void *data);
<span class="p_add">+extern struct vfsmount *vfs_submount(const struct dentry *mountpoint,</span>
<span class="p_add">+				     struct file_system_type *type,</span>
<span class="p_add">+				     const char *name, void *data);</span>
 
 extern void mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list);
 extern void mark_mounts_for_expiry(struct list_head *mounts);
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 48bc1ac1da43..6233e8fd95b5 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -732,6 +732,7 @@</span> <span class="p_context"> struct se_lun {</span>
 	struct config_group	lun_group;
 	struct se_port_stat_grps port_stat_grps;
 	struct completion	lun_ref_comp;
<span class="p_add">+	struct completion	lun_shutdown_comp;</span>
 	struct percpu_ref	lun_ref;
 	struct list_head	lun_dev_link;
 	struct hlist_node	link;
<span class="p_header">diff --git a/include/uapi/linux/fs.h b/include/uapi/linux/fs.h</span>
<span class="p_header">index acb2b6152ba0..474995568f35 100644</span>
<span class="p_header">--- a/include/uapi/linux/fs.h</span>
<span class="p_header">+++ b/include/uapi/linux/fs.h</span>
<span class="p_chunk">@@ -132,6 +132,7 @@</span> <span class="p_context"> struct inodes_stat_t {</span>
 #define MS_LAZYTIME	(1&lt;&lt;25) /* Update the on-disk [acm]times lazily */
 
 /* These sb flags are internal to the kernel */
<span class="p_add">+#define MS_SUBMOUNT     (1&lt;&lt;26)</span>
 #define MS_NOREMOTELOCK	(1&lt;&lt;27)
 #define MS_NOSEC	(1&lt;&lt;28)
 #define MS_BORN		(1&lt;&lt;29)
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 8696ce6bf2f6..90b66ed6f0e2 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -7241,7 +7241,7 @@</span> <span class="p_context"> init_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer)</span>
 	ftrace_init_tracefs(tr, d_tracer);
 }
 
<span class="p_del">-static struct vfsmount *trace_automount(void *ingore)</span>
<span class="p_add">+static struct vfsmount *trace_automount(struct dentry *mntpt, void *ingore)</span>
 {
 	struct vfsmount *mnt;
 	struct file_system_type *type;
<span class="p_chunk">@@ -7254,7 +7254,7 @@</span> <span class="p_context"> static struct vfsmount *trace_automount(void *ingore)</span>
 	type = get_fs_type(&quot;tracefs&quot;);
 	if (!type)
 		return NULL;
<span class="p_del">-	mnt = vfs_kern_mount(type, 0, &quot;tracefs&quot;, NULL);</span>
<span class="p_add">+	mnt = vfs_submount(mntpt, type, &quot;tracefs&quot;, NULL);</span>
 	put_filesystem(type);
 	if (IS_ERR(mnt))
 		return NULL;
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 4c6ade54d833..0de26691f0f5 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -4139,17 +4139,22 @@</span> <span class="p_context"> static void free_mem_cgroup_per_node_info(struct mem_cgroup *memcg, int node)</span>
 	kfree(memcg-&gt;nodeinfo[node]);
 }
 
<span class="p_del">-static void mem_cgroup_free(struct mem_cgroup *memcg)</span>
<span class="p_add">+static void __mem_cgroup_free(struct mem_cgroup *memcg)</span>
 {
 	int node;
 
<span class="p_del">-	memcg_wb_domain_exit(memcg);</span>
 	for_each_node(node)
 		free_mem_cgroup_per_node_info(memcg, node);
 	free_percpu(memcg-&gt;stat);
 	kfree(memcg);
 }
 
<span class="p_add">+static void mem_cgroup_free(struct mem_cgroup *memcg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memcg_wb_domain_exit(memcg);</span>
<span class="p_add">+	__mem_cgroup_free(memcg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct mem_cgroup *mem_cgroup_alloc(void)
 {
 	struct mem_cgroup *memcg;
<span class="p_chunk">@@ -4200,7 +4205,7 @@</span> <span class="p_context"> static struct mem_cgroup *mem_cgroup_alloc(void)</span>
 fail:
 	if (memcg-&gt;id.id &gt; 0)
 		idr_remove(&amp;mem_cgroup_idr, memcg-&gt;id.id);
<span class="p_del">-	mem_cgroup_free(memcg);</span>
<span class="p_add">+	__mem_cgroup_free(memcg);</span>
 	return NULL;
 }
 
<span class="p_header">diff --git a/mm/mlock.c b/mm/mlock.c</span>
<span class="p_header">index cdbed8aaa426..665ab75b5533 100644</span>
<span class="p_header">--- a/mm/mlock.c</span>
<span class="p_header">+++ b/mm/mlock.c</span>
<span class="p_chunk">@@ -441,7 +441,7 @@</span> <span class="p_context"> void munlock_vma_pages_range(struct vm_area_struct *vma,</span>
 
 	while (start &lt; end) {
 		struct page *page;
<span class="p_del">-		unsigned int page_mask;</span>
<span class="p_add">+		unsigned int page_mask = 0;</span>
 		unsigned long page_increm;
 		struct pagevec pvec;
 		struct zone *zone;
<span class="p_chunk">@@ -455,8 +455,7 @@</span> <span class="p_context"> void munlock_vma_pages_range(struct vm_area_struct *vma,</span>
 		 * suits munlock very well (and if somehow an abnormal page
 		 * has sneaked into the range, we won&#39;t oops here: great).
 		 */
<span class="p_del">-		page = follow_page_mask(vma, start, FOLL_GET | FOLL_DUMP,</span>
<span class="p_del">-				&amp;page_mask);</span>
<span class="p_add">+		page = follow_page(vma, start, FOLL_GET | FOLL_DUMP);</span>
 
 		if (page &amp;&amp; !IS_ERR(page)) {
 			if (PageTransTail(page)) {
<span class="p_chunk">@@ -467,8 +466,8 @@</span> <span class="p_context"> void munlock_vma_pages_range(struct vm_area_struct *vma,</span>
 				/*
 				 * Any THP page found by follow_page_mask() may
 				 * have gotten split before reaching
<span class="p_del">-				 * munlock_vma_page(), so we need to recompute</span>
<span class="p_del">-				 * the page_mask here.</span>
<span class="p_add">+				 * munlock_vma_page(), so we need to compute</span>
<span class="p_add">+				 * the page_mask here instead.</span>
 				 */
 				page_mask = munlock_vma_page(page);
 				unlock_page(page);
<span class="p_header">diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c</span>
<span class="p_header">index 3b5fd4188f2a..58ad23a44109 100644</span>
<span class="p_header">--- a/net/mac80211/agg-rx.c</span>
<span class="p_header">+++ b/net/mac80211/agg-rx.c</span>
<span class="p_chunk">@@ -398,6 +398,7 @@</span> <span class="p_context"> void __ieee80211_start_rx_ba_session(struct sta_info *sta,</span>
 	tid_agg_rx-&gt;timeout = timeout;
 	tid_agg_rx-&gt;stored_mpdu_num = 0;
 	tid_agg_rx-&gt;auto_seq = auto_seq;
<span class="p_add">+	tid_agg_rx-&gt;started = false;</span>
 	tid_agg_rx-&gt;reorder_buf_filtered = 0;
 	status = WLAN_STATUS_SUCCESS;
 
<span class="p_header">diff --git a/net/mac80211/pm.c b/net/mac80211/pm.c</span>
<span class="p_header">index 28a3a0957c9e..76a8bcd8ef11 100644</span>
<span class="p_header">--- a/net/mac80211/pm.c</span>
<span class="p_header">+++ b/net/mac80211/pm.c</span>
<span class="p_chunk">@@ -168,6 +168,7 @@</span> <span class="p_context"> int __ieee80211_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)</span>
 			break;
 		}
 
<span class="p_add">+		flush_delayed_work(&amp;sdata-&gt;dec_tailroom_needed_wk);</span>
 		drv_remove_interface(local, sdata);
 	}
 
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index 2384b4aae064..a697ddf56334 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -4,7 +4,7 @@</span> <span class="p_context"></span>
  * Copyright 2006-2007	Jiri Benc &lt;jbenc@suse.cz&gt;
  * Copyright 2007-2010	Johannes Berg &lt;johannes@sipsolutions.net&gt;
  * Copyright 2013-2014  Intel Mobile Communications GmbH
<span class="p_del">- * Copyright(c) 2015 - 2016 Intel Deutschland GmbH</span>
<span class="p_add">+ * Copyright(c) 2015 - 2017 Intel Deutschland GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
<span class="p_chunk">@@ -1034,6 +1034,18 @@</span> <span class="p_context"> static bool ieee80211_sta_manage_reorder_buf(struct ieee80211_sub_if_data *sdata</span>
 	buf_size = tid_agg_rx-&gt;buf_size;
 	head_seq_num = tid_agg_rx-&gt;head_seq_num;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the current MPDU&#39;s SN is smaller than the SSN, it shouldn&#39;t</span>
<span class="p_add">+	 * be reordered.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(!tid_agg_rx-&gt;started)) {</span>
<span class="p_add">+		if (ieee80211_sn_less(mpdu_seq_num, head_seq_num)) {</span>
<span class="p_add">+			ret = false;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		tid_agg_rx-&gt;started = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* frame with out of date sequence number */
 	if (ieee80211_sn_less(mpdu_seq_num, head_seq_num)) {
 		dev_kfree_skb(skb);
<span class="p_chunk">@@ -4080,15 +4092,17 @@</span> <span class="p_context"> static void __ieee80211_rx_handle_packet(struct ieee80211_hw *hw,</span>
 		     ieee80211_is_beacon(hdr-&gt;frame_control)))
 		ieee80211_scan_rx(local, skb);
 
<span class="p_del">-	if (pubsta) {</span>
<span class="p_del">-		rx.sta = container_of(pubsta, struct sta_info, sta);</span>
<span class="p_del">-		rx.sdata = rx.sta-&gt;sdata;</span>
<span class="p_del">-		if (ieee80211_prepare_and_rx_handle(&amp;rx, skb, true))</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	} else if (ieee80211_is_data(fc)) {</span>
<span class="p_add">+	if (ieee80211_is_data(fc)) {</span>
 		struct sta_info *sta, *prev_sta;
 
<span class="p_add">+		if (pubsta) {</span>
<span class="p_add">+			rx.sta = container_of(pubsta, struct sta_info, sta);</span>
<span class="p_add">+			rx.sdata = rx.sta-&gt;sdata;</span>
<span class="p_add">+			if (ieee80211_prepare_and_rx_handle(&amp;rx, skb, true))</span>
<span class="p_add">+				return;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		prev_sta = NULL;
 
 		for_each_sta_info(local, hdr-&gt;addr2, sta, tmp) {
<span class="p_header">diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h</span>
<span class="p_header">index dd06ef0b8861..15599c70a38f 100644</span>
<span class="p_header">--- a/net/mac80211/sta_info.h</span>
<span class="p_header">+++ b/net/mac80211/sta_info.h</span>
<span class="p_chunk">@@ -189,6 +189,7 @@</span> <span class="p_context"> struct tid_ampdu_tx {</span>
  * @auto_seq: used for offloaded BA sessions to automatically pick head_seq_and
  *	and ssn.
  * @removed: this session is removed (but might have been found due to RCU)
<span class="p_add">+ * @started: this session has started (head ssn or higher was received)</span>
  *
  * This structure&#39;s lifetime is managed by RCU, assignments to
  * the array holding it must hold the aggregation mutex.
<span class="p_chunk">@@ -212,8 +213,9 @@</span> <span class="p_context"> struct tid_ampdu_rx {</span>
 	u16 ssn;
 	u16 buf_size;
 	u16 timeout;
<span class="p_del">-	bool auto_seq;</span>
<span class="p_del">-	bool removed;</span>
<span class="p_add">+	u8 auto_seq:1,</span>
<span class="p_add">+	   removed:1,</span>
<span class="p_add">+	   started:1;</span>
 };
 
 /**
<span class="p_header">diff --git a/net/mac80211/status.c b/net/mac80211/status.c</span>
<span class="p_header">index ddf71c648cab..ad37b4e58c2f 100644</span>
<span class="p_header">--- a/net/mac80211/status.c</span>
<span class="p_header">+++ b/net/mac80211/status.c</span>
<span class="p_chunk">@@ -51,7 +51,8 @@</span> <span class="p_context"> static void ieee80211_handle_filtered_frame(struct ieee80211_local *local,</span>
 	struct ieee80211_hdr *hdr = (void *)skb-&gt;data;
 	int ac;
 
<span class="p_del">-	if (info-&gt;flags &amp; IEEE80211_TX_CTL_NO_PS_BUFFER) {</span>
<span class="p_add">+	if (info-&gt;flags &amp; (IEEE80211_TX_CTL_NO_PS_BUFFER |</span>
<span class="p_add">+			   IEEE80211_TX_CTL_AMPDU)) {</span>
 		ieee80211_free_txskb(&amp;local-&gt;hw, skb);
 		return;
 	}
<span class="p_header">diff --git a/tools/testing/ktest/ktest.pl b/tools/testing/ktest/ktest.pl</span>
<span class="p_header">index d08e214ec6e7..223d88e25e05 100755</span>
<span class="p_header">--- a/tools/testing/ktest/ktest.pl</span>
<span class="p_header">+++ b/tools/testing/ktest/ktest.pl</span>
<span class="p_chunk">@@ -2629,7 +2629,7 @@</span> <span class="p_context"> sub do_run_test {</span>
     }
 
     waitpid $child_pid, 0;
<span class="p_del">-    $child_exit = $?;</span>
<span class="p_add">+    $child_exit = $? &gt;&gt; 8;</span>
 
     my $end_time = time;
     $test_time = $end_time - $start_time;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



