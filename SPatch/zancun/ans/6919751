
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v8,2/2] ARM: imx: support suspend states on imx7D - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v8,2/2] ARM: imx: support suspend states on imx7D</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 31, 2015, 9:33 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1438378439-11569-3-git-send-email-shenwei.wang@freescale.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6919751/mbox/"
   >mbox</a>
|
   <a href="/patch/6919751/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6919751/">/patch/6919751/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 890889F38B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 31 Jul 2015 21:35:32 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 1B1B120685
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 31 Jul 2015 21:35:29 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 15D2C2045E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 31 Jul 2015 21:35:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1947767AbbGaVex (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 31 Jul 2015 17:34:53 -0400
Received: from mail-bl2on0118.outbound.protection.outlook.com
	([65.55.169.118]:58144
	&quot;EHLO na01-bl2-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1752218AbbGaVef (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 31 Jul 2015 17:34:35 -0400
Received: from DM2PR03CA0022.namprd03.prod.outlook.com (10.141.96.21) by
	CY1PR03MB1374.namprd03.prod.outlook.com (10.163.16.28) with Microsoft
	SMTP Server (TLS) id 15.1.225.19; Fri, 31 Jul 2015 21:34:32 +0000
Received: from BN1AFFO11FD018.protection.gbl (2a01:111:f400:7c10::188) by
	DM2PR03CA0022.outlook.office365.com (2a01:111:e400:2428::21) with
	Microsoft SMTP Server (TLS) id 15.1.225.19 via Frontend Transport;
	Fri, 31 Jul 2015 21:34:32 +0000
Authentication-Results: spf=fail (sender IP is 192.88.158.2)
	smtp.mailfrom=freescale.com; freescale.mail.onmicrosoft.com; dkim=none
	(message not signed) header.d=none;
Received-SPF: Fail (protection.outlook.com: domain of freescale.com does not
	designate 192.88.158.2 as permitted sender)
	receiver=protection.outlook.com; 
	client-ip=192.88.158.2; helo=az84smr01.freescale.net;
Received: from az84smr01.freescale.net (192.88.158.2) by
	BN1AFFO11FD018.mail.protection.outlook.com (10.58.52.78) with
	Microsoft SMTP Server (TLS) id 15.1.231.11 via Frontend Transport;
	Fri, 31 Jul 2015 21:34:32 +0000
Received: from [az84smr01.freescale.net (B38339-11.am.freescale.net
	[10.81.93.199])
	by az84smr01.freescale.net (8.14.3/8.14.0) with ESMTP id
	t6VLY9hA028985; Fri, 31 Jul 2015 14:34:30 -0700
From: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;
To: &lt;shawn.guo@linaro.org&gt;, &lt;tglx@linutronix.de&gt;,
	&lt;jason@lakedaemon.net&gt;
CC: &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;b20788@freescale.com&gt;
Subject: [PATCH v8 2/2] ARM: imx: support suspend states on imx7D
Date: Fri, 31 Jul 2015 16:33:59 -0500
Message-ID: &lt;1438378439-11569-3-git-send-email-shenwei.wang@freescale.com&gt;
X-Mailer: git-send-email 2.5.0.rc2
In-Reply-To: &lt;1438378439-11569-1-git-send-email-shenwei.wang@freescale.com&gt;
References: &lt;1438378439-11569-1-git-send-email-shenwei.wang@freescale.com&gt;
X-EOPAttributedMessage: 0
X-Microsoft-Exchange-Diagnostics: 1; BN1AFFO11FD018;
	1:EZBbld7nMDHJqx697bb78tyJ+r6zOxuALusCINRQLJ/Ssgxb43EA1GqoudeLC+HkT+qARQBvHa0OgA8RHlOFby0/0zVjz3PLMBs3LRCaS4ybyRruNmRIaGdYMLHnawkZzXVGgFABVbMjH1FwnRC/uUpYpDyBHvQrLxqkNeWzVELIBEoC7fqdCQJ+9vXBv8mZYEUsIzTn8Jve6PXMsIS2U6UMxZcCKVk0HlgGmJ+sECbtJ+PYDcISQIq/MTw7KIJ+sO81wrk7D4YsHtbvQGP6jW8jpwzQB+qBRi3lCw0Ll8Bc+hainouQMJisk7B/tB8lV5thUlJmfUAxC0kmzoHQ2w==
X-Forefront-Antispam-Report: CIP:192.88.158.2; CTRY:US; IPV:NLI; EFV:NLI;
	SFV:NSPM;
	SFS:(10019020)(6009001)(2980300002)(339900001)(199003)(189002)(76176999)(50226001)(229853001)(189998001)(33646002)(50466002)(107886002)(575784001)(19580395003)(6806004)(77096005)(106466001)(105606002)(104016003)(2950100001)(86362001)(50986999)(87936001)(19580405001)(77156002)(36756003)(2420400006)(2201001)(15975445007)(48376002)(5001770100001)(85426001)(92566002)(47776003)(46102003)(5001960100002)(62966003)(4001430100001)(579004);
	DIR:OUT; SFP:1102; SCL:1; SRVR:CY1PR03MB1374;
	H:az84smr01.freescale.net; FPR:; SPF:Fail; MLV:sfv; A:1; MX:1;
	LANG:en; 
MIME-Version: 1.0
Content-Type: text/plain
X-Microsoft-Exchange-Diagnostics: 1; CY1PR03MB1374;
	2:UnFeZ9Q+hEhhMWr4nwp2b1VRC0LdBB/ZPRFoEFwwPZC8dyWeKzRma3vNmyYsMDMrsmnifc61ofxLbgprjZ5YyiSgKxjO5tYBMMnCz0Gw3w238yWIdJ39gnz9qgmxMDm4iu8H0uzFjV6yM4Ftqs9YkAe0leggopp3KMFFR3C91PY=;
	3:BQHQABz+54n10xcgeaGqUKHMs0T6WvJdTzxlpi974akm9e5k4+X9t9uXZAo44k0Du2fkmVfN2qBWRq5w7CRgfKj5Oaxj1H+BU8icBSLSwDSrIycrhfjKYCSxzAuZDVjBEb7In3vJs/u7xnmq9ANBLZNXiqJzr3mB0FqE4QovVvfaaary44cZhleY8/3dPB37at7dXQfvdTLVMcI4qI4g+xYt4YnbBfs7cX1t8J0achY=;
	25:XfSQI4VEYxoSCqJiJP/zApoLLlk6QjtLInftIZwo7P0apM0YHu1H0W4GWlkJjTL7JxyMKKJhtuOXMug8mhlAuFetdOL4UDEKeqGk6i9+DL/x7GWTphk/av+jco5N0WZbk8cMwPh2/JhX2i/cta9ZPYpUJYHM16yu6aW4Ye/yjVqFkQfueldLzTsDjEO38S5KWtyngkt8Yqm7bbyBSxowjhWskJxpjXt7Qmi+8AZPSE7jghGLIGsh9POxBTjlrohfChfO1ls7nxq7G1xG8UbeGA==
X-Microsoft-Antispam: UriScan:;BCL:0;PCL:0;RULEID:;SRVR:CY1PR03MB1374;
X-Microsoft-Exchange-Diagnostics: 1; CY1PR03MB1374;
	20:2whyG59YjVYV/6w2silSZvUIscVCGr0aP76LhmV0gt6ncKk0lHjDcmamqi3G3iso2ceIcapF99bdsvLo+lYyFSztMFlXT/E13msIp5DhT0dcdxdN5wFxSVbo7q3VY3wNnetvE3zZ2erJWV6+UQUGwPAQLy1edkFiOBWrpV+fYkh26e5Q/ZjAWno8ll5blNCypZjrwzh184k3Q1kN9I1uGnPl3f9grpsaMQX3sg8nKUopmgmO/1+l5LZQfFyFrz9Ohjyp6f11+PwPoDl7PjP0aNk3ndWNg0OxmWrDdun+Mtq5Kw1YvbX0c+F+j/Pso8gHtyT8UmPy1u6jUPW1pF+9Fj1DNFGVfSewDVT2JwcuSaM=;
	4:/lGoCMUngicLnOWogLkpEhDMaViNSXmLz8wrYavZK7slF7L1sud2/YvkKUVur+xeFL4nuNlhMYBAW2egyIZ6r+f1E4sa7CKx5j4o8Upqpv7MNW/8S+m19sh9itMuvE3jOpUnbcJ/xxUioH+ul7zux6SxOktS4/5P2wZtTxaD/uZ+aNKsS4VJxUcZCsQQauLFyoNomDhdkxnVxZuyRyeRmCk613ThHew2FbEKUkxFVhBAQyKqKfXdGRFoWKQEs6XCefzDeYr/weh34Zl5ZKWSO7tPDlPOIR/sPmfDUxQ7biY=
CY1PR03MB1374: X-MS-Exchange-Organization-RulesExecuted
X-Microsoft-Antispam-PRVS: &lt;CY1PR03MB1374C6D3C90F8C05FF235147838A0@CY1PR03MB1374.namprd03.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:;
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(601004)(5005006)(3002001); SRVR:CY1PR03MB1374; BCL:0;
	PCL:0; RULEID:; SRVR:CY1PR03MB1374; 
X-Forefront-PRVS: 0654257CF5
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; CY1PR03MB1374;
	23:7SpTR7BTwFtDOJhcGq8DWK0G/wXrHPG3V34upZ9ut?=
	=?us-ascii?Q?cQVLS/z038vW28DweQM2BPHKu1H8sjPUWxhpoKghlUOg+4kSBA0n0+nCEZyZ?=
	=?us-ascii?Q?fo+rv5IYeQXVRRTHFgpYCOnhi6PXuOwYlo5YaZBJfmU3proZU4qHs7n51RdB?=
	=?us-ascii?Q?FJFyTc/DIIVXAVTnpafNuibz2O+xLvWG0U4dHHUZz8qvghC0SNbuPtNAHGpE?=
	=?us-ascii?Q?ash1MLrXYX8rhtGI4xcTEHbsRhz8xMcgFryzJH8nnMfIhXgoBhyERZxF6vBH?=
	=?us-ascii?Q?kGbGKqaM/22txL8cneUe1GuBVcmjurpKIW2IkmGPDteJHZ0tkg5sr/lHygrn?=
	=?us-ascii?Q?+GoUR7HUr9Nt78YZHf0ZtlKJ1jkdUKPSbkWKT8CBOMIbEd9/0uv6rmr3DRI4?=
	=?us-ascii?Q?uh6HGzcqRVMpAyFNbawP0ddZT005gm9trxufUvPVv0F8OdrYeiVz9KsR7Fwv?=
	=?us-ascii?Q?OcAM5D8XEvFgxynrn1X8lUNdhgFxM/lS2pGKiv3LfmmsoYQnCOyZc35nbDZQ?=
	=?us-ascii?Q?dq65q2om/fJxG0ucAzs3sc77QWknQSTNeXl7Huip+5UUIKitsLWhgVTifRlq?=
	=?us-ascii?Q?yo+VbGTk2Vg+dsONs/uCwUrEUOE7n5LGtr3nRPWM4Sdbduy6uV9ruTB57lS7?=
	=?us-ascii?Q?rZsZbda7FeKSH5PIrbqvzeRbwuzOf3J4gZFklgmF1unDR020zgrtUNHTupyH?=
	=?us-ascii?Q?52uftvCu27pI7L7nmmvb9Eg7Xb1x2nTkoKBXsfvL2YBrZn2fURTFLk0uqrwq?=
	=?us-ascii?Q?3U+oeNiWq0HGJNOnALx7JWxe9AVOmrWpAbJP3n/rrxYDvJzpLm+ipB7Vtxle?=
	=?us-ascii?Q?1NOXOOxn2G4cH3A/Dm8z1GNTlAqgQobZENgLR5LwVln+aXi1CbyGtCYrU7nF?=
	=?us-ascii?Q?q+MsZgZrlgGZo27HEeq/e/CqVuAGcYky3h25ZT7TNQDOj9co3XXYFusza+f4?=
	=?us-ascii?Q?TPwhPzf+mW42nNXckyfbzxhOk9iw7uFsh77BAoHqufYTjU7cuADEYDudKs4M?=
	=?us-ascii?Q?r3SgSpojK9NEsNhAnB+WywbmPgFHxZvvmcs+uKcsz5zDA=3D=3D?=
X-Microsoft-Exchange-Diagnostics: 1; CY1PR03MB1374;
	5:ViFu1skb9vpyBCbbEVyYe8riHMKWNxT/H8NQawgl4Mlx1O9eioLaigoF+hPbvXh7tA9EvqnYklTCA7d9fqQOT+UzOYs+FTSUFYtJpRnFndVetG7MO1PNvsh8ez1KJkbkkea6JZKhe3mWkm4Bm2JMhg==;
	24:Q2nFYlqnlO9UvO4cxS0PyfcQDFo3akO66HNtR1/i5KRDk4JfQq8XwYo98MryR87Ss2VMFuzRP9HFNPk3imrlV/evPLRHatcWhTKhkELn4FE=;
	20:659YmL/K6CEkLxNp2bxjAxI3BcJQcTsFokyVObZkRclhk4orGoH8DViqDU0a7CqxGODwfDg3G548Z0E3AqyEQw==
X-OriginatorOrg: freescale.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 31 Jul 2015 21:34:32.2183
	(UTC)
X-MS-Exchange-CrossTenant-Id: 710a03f5-10f6-4d38-9ff4-a80b81da590d
X-MS-Exchange-CrossTenant-OriginalAttributedTenantConnectingIp: TenantId=710a03f5-10f6-4d38-9ff4-a80b81da590d;
	Ip=[192.88.158.2]; Helo=[az84smr01.freescale.net]
X-MS-Exchange-CrossTenant-FromEntityHeader: HybridOnPrem
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY1PR03MB1374
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a> - July 31, 2015, 9:33 p.m.</div>
<pre class="content">
IMX7D contains a new version of GPC IP block (GPCv2). It has two
major functions: power management and wakeup source management.

GPCv2 provides low power mode control for Cortex-A7 and Cortex-M4
domains. And it can support WAIT, STOP, and DSM(Deep Sleep Mode) modes.
After configuring the GPCv2 module, the platform can enter into a
selected mode either automatically triggered by ARM WFI instruction or
manually by software. The system will exit the low power states
by the predefined wakeup sources which are managed by the gpcv2
irqchip driver.

This patch adds a new suspend driver to manage the power states on IMX7D.
It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.
<span class="signed-off-by">
Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Anson Huang &lt;b20788@freescale.com&gt;</span>
---
 arch/arm/mach-imx/Kconfig        |   1 +
 arch/arm/mach-imx/Makefile       |   2 +
 arch/arm/mach-imx/common.h       |   4 +
 arch/arm/mach-imx/pm-imx7.c      | 917 +++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-imx/suspend-imx7.S | 529 ++++++++++++++++++++++
 5 files changed, 1453 insertions(+)
 create mode 100644 arch/arm/mach-imx/pm-imx7.c
 create mode 100644 arch/arm/mach-imx/suspend-imx7.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a> - Sept. 3, 2015, 8:41 p.m.</div>
<pre class="content">
2nd ping.

Shenwei
<span class="quote">
&gt; -----Original Message-----</span>
<span class="quote">&gt; From: linux-kernel-owner@vger.kernel.org</span>
<span class="quote">&gt; [mailto:linux-kernel-owner@vger.kernel.org] On Behalf Of Shenwei Wang</span>
<span class="quote">&gt; Sent: 2015?7?31? 16:34</span>
<span class="quote">&gt; To: shawn.guo@linaro.org; tglx@linutronix.de; jason@lakedaemon.net</span>
<span class="quote">&gt; Cc: linux-arm-kernel@lists.infradead.org; linux-kernel@vger.kernel.org; Huang</span>
<span class="quote">&gt; Yongcai-B20788</span>
<span class="quote">&gt; Subject: [PATCH v8 2/2] ARM: imx: support suspend states on imx7D</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; IMX7D contains a new version of GPC IP block (GPCv2). It has two major functions:</span>
<span class="quote">&gt; power management and wakeup source management.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; GPCv2 provides low power mode control for Cortex-A7 and Cortex-M4 domains.</span>
<span class="quote">&gt; And it can support WAIT, STOP, and DSM(Deep Sleep Mode) modes.</span>
<span class="quote">&gt; After configuring the GPCv2 module, the platform can enter into a selected mode</span>
<span class="quote">&gt; either automatically triggered by ARM WFI instruction or manually by software.</span>
<span class="quote">&gt; The system will exit the low power states by the predefined wakeup sources</span>
<span class="quote">&gt; which are managed by the gpcv2 irqchip driver.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This patch adds a new suspend driver to manage the power states on IMX7D.</span>
<span class="quote">&gt; It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Anson Huang &lt;b20788@freescale.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/arm/mach-imx/Kconfig        |   1 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/Makefile       |   2 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/common.h       |   4 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/pm-imx7.c      | 917</span>
<span class="quote">&gt; +++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/arm/mach-imx/suspend-imx7.S | 529 ++++++++++++++++++++++</span>
<span class="quote">&gt;  5 files changed, 1453 insertions(+)</span>
<span class="quote">&gt;  create mode 100644 arch/arm/mach-imx/pm-imx7.c  create mode 100644</span>
<span class="quote">&gt; arch/arm/mach-imx/suspend-imx7.S</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig index</span>
<span class="quote">&gt; 8ceda28..54f8553 100644</span>
<span class="quote">&gt; --- a/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; @@ -562,6 +562,7 @@ config SOC_IMX7D</span>
<span class="quote">&gt;  	select ARM_GIC</span>
<span class="quote">&gt;  	select HAVE_IMX_ANATOP</span>
<span class="quote">&gt;  	select HAVE_IMX_MMDC</span>
<span class="quote">&gt; +	select IMX_GPCV2</span>
<span class="quote">&gt;  	help</span>
<span class="quote">&gt;  		This enables support for Freescale i.MX7 Dual processor.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile index</span>
<span class="quote">&gt; fb689d8..60f13fd 100644</span>
<span class="quote">&gt; --- a/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; @@ -88,6 +88,8 @@ obj-$(CONFIG_SOC_IMX7D) += mach-imx7d.o</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  ifeq ($(CONFIG_SUSPEND),y)</span>
<span class="quote">&gt;  AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; +AFLAGS_suspend-imx7.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; +obj-$(CONFIG_SOC_IMX7D)	+= suspend-imx7.o pm-imx7.o</span>
<span class="quote">&gt;  obj-$(CONFIG_SOC_IMX6) += suspend-imx6.o</span>
<span class="quote">&gt;  obj-$(CONFIG_SOC_IMX53) += suspend-imx53.o  endif diff --git</span>
<span class="quote">&gt; a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h index</span>
<span class="quote">&gt; 21e4e86..c5767f4 100644</span>
<span class="quote">&gt; --- a/arch/arm/mach-imx/common.h</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/common.h</span>
<span class="quote">&gt; @@ -126,6 +126,10 @@ static const u32 imx53_suspend_sz;  static inline void</span>
<span class="quote">&gt; imx6_suspend(void __iomem *ocram_vbase) {}  #endif</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; +void ca7_cpu_resume(void);</span>
<span class="quote">&gt; +void imx7_suspend(void __iomem *ocram_vbase);</span>
<span class="quote">&gt; +u32 imx_gpcv2_get_wakeup_source(u32 **sources);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  void imx6_pm_ccm_init(const char *ccm_compat);  void imx6q_pm_init(void);</span>
<span class="quote">&gt; void imx6dl_pm_init(void); diff --git a/arch/arm/mach-imx/pm-imx7.c</span>
<span class="quote">&gt; b/arch/arm/mach-imx/pm-imx7.c new file mode 100644 index 0000000..052c2cb</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="quote">&gt; @@ -0,0 +1,917 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/mfd/syscon.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/regmap.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/suspend.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/suspend.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/fncpy.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &quot;common.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GPC_LPCR_A7_BSC		0x0</span>
<span class="quote">&gt; +#define GPC_LPCR_A7_AD		0x4</span>
<span class="quote">&gt; +#define GPC_LPCR_M4		0x8</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GPC_SLPCR		0x14</span>
<span class="quote">&gt; +#define GPC_PGC_ACK_SEL_A7	0x24</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GPC_SLOTx_CFG(x) 	(0xb0 + 4 * (x))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GPC_PGC_CPU_MAPPING	0xec</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GPC_PGC_C0		0x800</span>
<span class="quote">&gt; +#define GPC_PGC_C1		0x840</span>
<span class="quote">&gt; +#define GPC_PGC_SCU		0x880</span>
<span class="quote">&gt; +#define GPC_PGC_SCU_TIMING	0x890</span>
<span class="quote">&gt; +#define GPC_PGC_FM		0xa00</span>
<span class="quote">&gt; +#define GPC_PGC_MIPI_PHY	0xc00</span>
<span class="quote">&gt; +#define GPC_PGC_PCIE_PHY	0xc40</span>
<span class="quote">&gt; +#define GPC_PGC_USB_OTG1_PHY	0xc80</span>
<span class="quote">&gt; +#define GPC_PGC_USB_OTG2_PHY	0xcc0</span>
<span class="quote">&gt; +#define GPC_PGC_USB_HSIC_PHY	0xd00</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ANADIG_ARM_PLL		0x60</span>
<span class="quote">&gt; +#define ANADIG_DDR_PLL		0x70</span>
<span class="quote">&gt; +#define ANADIG_SYS_PLL		0xb0</span>
<span class="quote">&gt; +#define ANADIG_ENET_PLL		0xe0</span>
<span class="quote">&gt; +#define ANADIG_AUDIO_PLL	0xf0</span>
<span class="quote">&gt; +#define ANADIG_VIDEO_PLL	0x130</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_L2PGE			(0x1 &lt;&lt; 16)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C1_PUP			(0x1 &lt;&lt; 11)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C1_IRQ_PUP		(0x1 &lt;&lt; 10)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C0_PUP			(0x1 &lt;&lt; 9)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C0_IRQ_PUP		(0x1 &lt;&lt; 8)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_PLAT_PDN		(0x1 &lt;&lt; 4)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C1_PDN			(0x1 &lt;&lt; 3)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C1_WFI_PDN		(0x1 &lt;&lt; 2)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C0_PDN			(0x1 &lt;&lt; 1)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C0_WFI_PDN		(0x1)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP	(0x7 &lt;&lt; 28)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_BSC_CPU_CLK_ON_LPM		(0x1 &lt;&lt; 14)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_BSC_LPM1			(0x3 &lt;&lt; 2)</span>
<span class="quote">&gt; +#define BM_LPCR_A7_BSC_LPM0			(0x3)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_LPCR_M4_MASK_DSM_TRIGGER		(0x1 &lt;&lt; 31)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_SLPCR_EN_DSM				(0x1 &lt;&lt; 31)</span>
<span class="quote">&gt; +#define BM_SLPCR_RBC_EN				(0x1 &lt;&lt; 30)</span>
<span class="quote">&gt; +#define BM_SLPCR_VSTBY				(0x1 &lt;&lt; 2)</span>
<span class="quote">&gt; +#define BM_SLPCR_SBYOS				(0x1 &lt;&lt; 1)</span>
<span class="quote">&gt; +#define BM_SLPCR_BYPASS_PMIC_READY		(0x1)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP		(0x1 &lt;&lt; 31)</span>
<span class="quote">&gt; +#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN		(0x1 &lt;&lt; 15)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_ANADIG_ARM_PLL_OVERRIDE		(0x1 &lt;&lt; 20)</span>
<span class="quote">&gt; +#define BM_ANADIG_DDR_PLL_OVERRIDE		(0x1 &lt;&lt; 19)</span>
<span class="quote">&gt; +#define BM_ANADIG_SYS_PLL_PFDx_OVERRIDE		(0x1FF &lt;&lt; 17)</span>
<span class="quote">&gt; +#define BM_ANADIG_ENET_PLL_OVERRIDE		(0x1 &lt;&lt; 13)</span>
<span class="quote">&gt; +#define BM_ANADIG_AUDIO_PLL_OVERRIDE		(0x1 &lt;&lt; 24)</span>
<span class="quote">&gt; +#define BM_ANADIG_VIDEO_PLL_OVERRIDE		(0x1 &lt;&lt; 24)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define A7_LPM_WAIT		0x5</span>
<span class="quote">&gt; +#define A7_LPM_STOP		0xa</span>
<span class="quote">&gt; +#define GPC_MAX_SLOT_NUMBER	10</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_SET			0x4</span>
<span class="quote">&gt; +#define REG_CLR			0x8</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define MX7_MAX_DDRC_NUM		32</span>
<span class="quote">&gt; +#define MX7_MAX_DDRC_PHY_NUM		16</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define READ_DATA_FROM_HARDWARE		0</span>
<span class="quote">&gt; +#define MX7_SUSPEND_OCRAM_SIZE		0x1000</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +enum gpcv2_mode {</span>
<span class="quote">&gt; +	GPC_WAIT_CLOCKED,</span>
<span class="quote">&gt; +	GPC_WAIT_UNCLOCKED,</span>
<span class="quote">&gt; +	GPC_STOP_POWER_ON,</span>
<span class="quote">&gt; +	GPC_STOP_POWER_OFF,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * GPCv2 has the following power domains, and each domain can be</span>
<span class="quote">&gt; +power-up</span>
<span class="quote">&gt; + * and power-down via GPC settings.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * 	Core 0 of A7 power domain</span>
<span class="quote">&gt; + * 	Core1 of A7 power domain</span>
<span class="quote">&gt; + * 	SCU/L2 cache RAM of A7 power domain</span>
<span class="quote">&gt; + * 	Fastmix and megamix power domain</span>
<span class="quote">&gt; + * 	USB OTG1 PHY power domain</span>
<span class="quote">&gt; + * 	USB OTG2 PHY power domain</span>
<span class="quote">&gt; + * 	PCIE PHY power domain</span>
<span class="quote">&gt; + * 	USB HSIC PHY power domain</span>
<span class="quote">&gt; + *	Core 0 of M4 power domain</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +enum gpcv2_slot {</span>
<span class="quote">&gt; +	CORE0_A7,</span>
<span class="quote">&gt; +	CORE1_A7,</span>
<span class="quote">&gt; +	SCU_A7,</span>
<span class="quote">&gt; +	FAST_MEGA_MIX,</span>
<span class="quote">&gt; +	MIPI_PHY,</span>
<span class="quote">&gt; +	PCIE_PHY,</span>
<span class="quote">&gt; +	USB_OTG1_PHY,</span>
<span class="quote">&gt; +	USB_OTG2_PHY,</span>
<span class="quote">&gt; +	USB_HSIC_PHY,</span>
<span class="quote">&gt; +	CORE0_M4,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx_gpcv2;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx_gpcv2_suspend {</span>
<span class="quote">&gt; +	void (*set_mode)(struct imx_gpcv2 *, enum gpcv2_mode mode);</span>
<span class="quote">&gt; +	void (*lpm_cpu_power_gate)(struct imx_gpcv2 *, u32, bool);</span>
<span class="quote">&gt; +	void (*lpm_plat_power_gate)(struct imx_gpcv2 *, bool);</span>
<span class="quote">&gt; +	void (*lpm_env_setup)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +	void (*lpm_env_clean)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	void (*set_slot)(struct imx_gpcv2 *cd, u32 index,</span>
<span class="quote">&gt; +			enum gpcv2_slot slot, bool mode);</span>
<span class="quote">&gt; +	void (*set_act)(struct imx_gpcv2 *cd,</span>
<span class="quote">&gt; +			enum gpcv2_slot slot, bool mode);</span>
<span class="quote">&gt; +	void (*clear_slots)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +	void (*lpm_enable_core)(struct imx_gpcv2 *,</span>
<span class="quote">&gt; +			bool enable, u32 offset);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	void (*standby)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +	void (*suspend)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	void (*suspend_fn_in_ocram)(void __iomem *ocram_vbase);</span>
<span class="quote">&gt; +	void __iomem *ocram_vbase;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx_gpcv2 {</span>
<span class="quote">&gt; +	u32 *wakeupmix_mask;</span>
<span class="quote">&gt; +	u32 *lpsrmix_mask;</span>
<span class="quote">&gt; +	u32 *mfmix_mask;</span>
<span class="quote">&gt; +	spinlock_t lock;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm;</span>
<span class="quote">&gt; +	struct regmap *anatop;</span>
<span class="quote">&gt; +	struct regmap *gpcv2;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	u32 (*get_wakeup_source)(u32 **);</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx7_pm_base {</span>
<span class="quote">&gt; +	phys_addr_t pbase;</span>
<span class="quote">&gt; +	void __iomem *vbase;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx7_pm_socdata {</span>
<span class="quote">&gt; +	u32 ddr_type;</span>
<span class="quote">&gt; +	const char *ddrc_compat;</span>
<span class="quote">&gt; +	const char *ddrc_phy_compat;</span>
<span class="quote">&gt; +	const char *src_compat;</span>
<span class="quote">&gt; +	const char *iomuxc_gpr_compat;</span>
<span class="quote">&gt; +	const char *ccm_compat;</span>
<span class="quote">&gt; +	const char *gpc_compat;</span>
<span class="quote">&gt; +	const char *anatop_compat;</span>
<span class="quote">&gt; +	const u32 ddrc_num;</span>
<span class="quote">&gt; +	const u32 (*ddrc_offset)[2];</span>
<span class="quote">&gt; +	const u32 ddrc_phy_num;</span>
<span class="quote">&gt; +	const u32 (*ddrc_phy_offset)[2];</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * This structure is for passing necessary data for low level ocram</span>
<span class="quote">&gt; + * suspend code(arch/arm/mach-imx/suspend-imx7.S), if this struct</span>
<span class="quote">&gt; + * definition is changed, the offset definition in</span>
<span class="quote">&gt; + * arch/arm/mach-imx/suspend-imx7.S must be also changed accordingly,</span>
<span class="quote">&gt; + * otherwise, the suspend to ocram function will be broken!</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx7_cpu_pm_info {</span>
<span class="quote">&gt; +	u32 m4_reserve0;</span>
<span class="quote">&gt; +	u32 m4_reserve1;</span>
<span class="quote">&gt; +	u32 m4_reserve2;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* The physical address of pm_info. */</span>
<span class="quote">&gt; +	phys_addr_t pbase;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* The physical resume address for asm code */</span>
<span class="quote">&gt; +	phys_addr_t resume_addr;</span>
<span class="quote">&gt; +	u32 ddr_type;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	u32 pm_info_size;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	struct imx7_pm_base ddrc_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base ddrc_phy_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base src_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base iomuxc_gpr_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base ccm_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base gpc_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base l2_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base anatop_base;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	u32 ttbr1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Number of DDRC which need saved/restored. */</span>
<span class="quote">&gt; +	u32 ddrc_num;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* To save offset and value */</span>
<span class="quote">&gt; +	u32 ddrc_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Number of DDRC which need saved/restored. */</span>
<span class="quote">&gt; +	u32 ddrc_phy_num;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* To save offset and value */</span>
<span class="quote">&gt; +	u32 ddrc_phy_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="quote">&gt; +} __aligned(8);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const u32 imx7d_ddrc_ddr3_setting[][2] __initconst = {</span>
<span class="quote">&gt; +	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x1a0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x1a4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x1a8, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x64, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x490, 0x00000001 },</span>
<span class="quote">&gt; +	{ 0xd0, 0xc0020001 },</span>
<span class="quote">&gt; +	{ 0xd4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0xdc, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0xe0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0xe4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0xf4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x100, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x104, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x108, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x10c, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x110, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x114, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x120, 0x03030803 },</span>
<span class="quote">&gt; +	{ 0x180, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x190, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x194, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x200, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x204, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x214, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x218, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x240, 0x06000601 },</span>
<span class="quote">&gt; +	{ 0x244, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const u32 imx7d_ddrc_phy_ddr3_setting[][2] __initconst = {</span>
<span class="quote">&gt; +	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x10, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x9c, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x20, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x30, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x50, 0x01000010 },</span>
<span class="quote">&gt; +	{ 0x50, 0x00000010 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e407304 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e447304 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e447306 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e447304 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e407306 },</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct imx7_pm_socdata imx7d_pm_data_ddr3 __initconst = {</span>
<span class="quote">&gt; +	.iomuxc_gpr_compat = &quot;fsl,imx7d-iomuxc&quot;,</span>
<span class="quote">&gt; +	.ddrc_phy_compat = &quot;fsl,imx7d-ddrc-phy&quot;,</span>
<span class="quote">&gt; +	.anatop_compat = &quot;fsl,imx7d-anatop&quot;,</span>
<span class="quote">&gt; +	.ddrc_compat = &quot;fsl,imx7d-ddrc&quot;,</span>
<span class="quote">&gt; +	.ccm_compat = &quot;fsl,imx7d-ccm&quot;,</span>
<span class="quote">&gt; +	.src_compat = &quot;fsl,imx7d-src&quot;,</span>
<span class="quote">&gt; +	.gpc_compat = &quot;fsl,imx7d-gpc&quot;,</span>
<span class="quote">&gt; +	.ddrc_phy_num = ARRAY_SIZE(imx7d_ddrc_phy_ddr3_setting),</span>
<span class="quote">&gt; +	.ddrc_phy_offset = imx7d_ddrc_phy_ddr3_setting,</span>
<span class="quote">&gt; +	.ddrc_num = ARRAY_SIZE(imx7d_ddrc_ddr3_setting),</span>
<span class="quote">&gt; +	.ddrc_offset = imx7d_ddrc_ddr3_setting, };</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct imx_gpcv2 *gpcv2_instance;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_clear_slots(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; +	int i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for (i = 0; i &lt; GPC_MAX_SLOT_NUMBER; i++)</span>
<span class="quote">&gt; +		regmap_write(gpc-&gt;gpcv2, GPC_SLOTx_CFG(i), 0x0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_PGC_ACK_SEL_A7,</span>
<span class="quote">&gt; +			BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP |</span>
<span class="quote">&gt; +			BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_enable_core(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; +			bool enable, u32 offset)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, offset, enable); }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_slot_setup(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; +		u32 index, enum gpcv2_slot slot, bool powerup) {</span>
<span class="quote">&gt; +	u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (index &gt;= GPC_MAX_SLOT_NUMBER) {</span>
<span class="quote">&gt; +		pr_err(&quot;Invalid slot index!\n&quot;);</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	val = (powerup ? 0x2 : 0x1) &lt;&lt; (slot * 2);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_SLOTx_CFG(index), val); }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_set_ack(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; +		enum gpcv2_slot slot, bool powerup)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regmap_read(gpc-&gt;gpcv2, GPC_PGC_ACK_SEL_A7, &amp;val);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* clear dummy ack */</span>
<span class="quote">&gt; +	val &amp;= ~(powerup ? BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP :</span>
<span class="quote">&gt; +				BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	val |= 1 &lt;&lt; (slot + (powerup ? 16 : 0));</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_PGC_ACK_SEL_A7, val); }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_env_setup(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; +	/* PLL and PFDs overwrite set */</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_ARM_PLL + REG_SET,</span>
<span class="quote">&gt; +			BM_ANADIG_ARM_PLL_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_DDR_PLL + REG_SET,</span>
<span class="quote">&gt; +			BM_ANADIG_DDR_PLL_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_SYS_PLL + REG_SET,</span>
<span class="quote">&gt; +			BM_ANADIG_SYS_PLL_PFDx_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_ENET_PLL + REG_SET,</span>
<span class="quote">&gt; +			BM_ANADIG_ENET_PLL_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_AUDIO_PLL + REG_SET,</span>
<span class="quote">&gt; +			BM_ANADIG_AUDIO_PLL_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_VIDEO_PLL + REG_SET,</span>
<span class="quote">&gt; +			BM_ANADIG_VIDEO_PLL_OVERRIDE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_env_clean(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; +	/* PLL and PFDs overwrite clear */</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_ARM_PLL + REG_CLR,</span>
<span class="quote">&gt; +			BM_ANADIG_ARM_PLL_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_DDR_PLL + REG_CLR,</span>
<span class="quote">&gt; +			BM_ANADIG_DDR_PLL_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_SYS_PLL + REG_CLR,</span>
<span class="quote">&gt; +			BM_ANADIG_SYS_PLL_PFDx_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_ENET_PLL + REG_CLR,</span>
<span class="quote">&gt; +			BM_ANADIG_ENET_PLL_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_AUDIO_PLL + REG_CLR,</span>
<span class="quote">&gt; +			BM_ANADIG_AUDIO_PLL_OVERRIDE);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;anatop, ANADIG_VIDEO_PLL + REG_CLR,</span>
<span class="quote">&gt; +			BM_ANADIG_VIDEO_PLL_OVERRIDE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_set_mode(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; +		enum gpcv2_mode mode)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	u32 lpcr, slpcr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_A7_BSC, &amp;lpcr);</span>
<span class="quote">&gt; +	regmap_read(gpc-&gt;gpcv2, GPC_SLPCR, &amp;slpcr);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* all cores&#39; LPM settings must be same */</span>
<span class="quote">&gt; +	lpcr &amp;= ~(BM_LPCR_A7_BSC_LPM0 | BM_LPCR_A7_BSC_LPM1);</span>
<span class="quote">&gt; +	lpcr |= BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	slpcr &amp;= ~(BM_SLPCR_EN_DSM | BM_SLPCR_VSTBY | BM_SLPCR_RBC_EN</span>
<span class="quote">&gt; |</span>
<span class="quote">&gt; +		BM_SLPCR_SBYOS | BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	switch (mode) {</span>
<span class="quote">&gt; +	case GPC_WAIT_CLOCKED:</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case GPC_WAIT_UNCLOCKED:</span>
<span class="quote">&gt; +		lpcr |= A7_LPM_WAIT;</span>
<span class="quote">&gt; +		lpcr &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case GPC_STOP_POWER_ON:</span>
<span class="quote">&gt; +		lpcr |= A7_LPM_STOP;</span>
<span class="quote">&gt; +		lpcr &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; +		slpcr |= (BM_SLPCR_EN_DSM | BM_SLPCR_RBC_EN |</span>
<span class="quote">&gt; +			BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case GPC_STOP_POWER_OFF:</span>
<span class="quote">&gt; +		lpcr |= A7_LPM_STOP;</span>
<span class="quote">&gt; +		lpcr &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; +		slpcr |= (BM_SLPCR_EN_DSM | BM_SLPCR_RBC_EN |</span>
<span class="quote">&gt; +			BM_SLPCR_SBYOS | BM_SLPCR_VSTBY  |</span>
<span class="quote">&gt; +			BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	default:</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_A7_BSC, lpcr);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_SLPCR, slpcr); }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_cpu_power_gate(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; +				u32 cpu, bool engate)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	const u32 val_pdn[2] = {</span>
<span class="quote">&gt; +		BM_LPCR_A7_AD_EN_C0_PDN | BM_LPCR_A7_AD_EN_C0_PUP,</span>
<span class="quote">&gt; +		BM_LPCR_A7_AD_EN_C1_PDN | BM_LPCR_A7_AD_EN_C1_PUP,</span>
<span class="quote">&gt; +	};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_A7_AD, &amp;val);</span>
<span class="quote">&gt; +	if (engate)</span>
<span class="quote">&gt; +		val |= val_pdn[cpu];</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		val &amp;= ~val_pdn[cpu];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_A7_AD, val); }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_lpm_plat_power_gate(struct imx_gpcv2 *gpc, bool engate)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_A7_AD, &amp;val);</span>
<span class="quote">&gt; +	val &amp;= ~(BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE);</span>
<span class="quote">&gt; +	if (engate)</span>
<span class="quote">&gt; +		val |= BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_A7_AD, val); }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_standby(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_setup(gpc);</span>
<span class="quote">&gt; +	/* pm-&gt;set_mode(gpc, GPC_STOP_POWER_OFF); */</span>
<span class="quote">&gt; +	pm-&gt;set_mode(gpc, GPC_WAIT_UNCLOCKED);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Zzz ... */</span>
<span class="quote">&gt; +	cpu_do_idle();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;set_mode(gpc, GPC_WAIT_CLOCKED);</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_clean(gpc);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int gpcv2_suspend_finish(unsigned long val) {</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm = (struct imx_gpcv2_suspend *)val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!pm-&gt;suspend_fn_in_ocram) {</span>
<span class="quote">&gt; +		cpu_do_idle();</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * call low level suspend function in ocram,</span>
<span class="quote">&gt; +		 * as we need to float DDR IO.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		local_flush_tlb_all();</span>
<span class="quote">&gt; +		pm-&gt;suspend_fn_in_ocram(pm-&gt;ocram_vbase);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_suspend(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; +	u32 *sources;</span>
<span class="quote">&gt; +	int i, num;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_setup(gpc);</span>
<span class="quote">&gt; +	pm-&gt;set_mode(gpc, GPC_STOP_POWER_OFF);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enable core0 power down/up with low power mode */</span>
<span class="quote">&gt; +	pm-&gt;lpm_cpu_power_gate(gpc, 0, true);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enable plat power down with low power mode */</span>
<span class="quote">&gt; +	pm-&gt;lpm_plat_power_gate(gpc, true);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * To avoid confuse, we use slot 0~4 for power down,</span>
<span class="quote">&gt; +	 * slot 5~9 for power up.</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * Power down slot sequence:</span>
<span class="quote">&gt; +	 * Slot0 -&gt; CORE0</span>
<span class="quote">&gt; +	 * Slot1 -&gt; Mega/Fast MIX</span>
<span class="quote">&gt; +	 * Slot2 -&gt; SCU</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * Power up slot sequence:</span>
<span class="quote">&gt; +	 * Slot5 -&gt; Mega/Fast MIX</span>
<span class="quote">&gt; +	 * Slot6 -&gt; SCU</span>
<span class="quote">&gt; +	 * Slot7 -&gt; CORE0</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	pm-&gt;set_slot(gpc, 0, CORE0_A7, false);</span>
<span class="quote">&gt; +	pm-&gt;set_slot(gpc, 2, SCU_A7, false);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (gpc-&gt;get_wakeup_source) {</span>
<span class="quote">&gt; +		pm-&gt;set_slot(gpc, 1, FAST_MEGA_MIX, false);</span>
<span class="quote">&gt; +		pm-&gt;set_slot(gpc, 5, FAST_MEGA_MIX, true);</span>
<span class="quote">&gt; +		pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_FM);</span>
<span class="quote">&gt; +		num = gpc-&gt;get_wakeup_source(&amp;sources);</span>
<span class="quote">&gt; +		for (i = 0; i &lt; num; i++) {</span>
<span class="quote">&gt; +			if ((~sources[i] &amp; gpc-&gt;mfmix_mask[i]) == 0)</span>
<span class="quote">&gt; +				continue;</span>
<span class="quote">&gt; +			pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_FM);</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;set_slot(gpc, 6, SCU_A7, true);</span>
<span class="quote">&gt; +	pm-&gt;set_slot(gpc, 7, CORE0_A7, true);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set Power down act */</span>
<span class="quote">&gt; +	pm-&gt;set_act(gpc, SCU_A7, false);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set Power up act */</span>
<span class="quote">&gt; +	pm-&gt;set_act(gpc, CORE0_A7, true);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enable core0, scu */</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_C0);</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_SCU);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cpu_suspend((unsigned long)pm, gpcv2_suspend_finish);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_clean(gpc);</span>
<span class="quote">&gt; +	pm-&gt;set_mode(gpc, GPC_WAIT_CLOCKED);</span>
<span class="quote">&gt; +	pm-&gt;lpm_cpu_power_gate(gpc, 0, false);</span>
<span class="quote">&gt; +	pm-&gt;lpm_plat_power_gate(gpc, false);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_C0);</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_SCU);</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_FM);</span>
<span class="quote">&gt; +	pm-&gt;clear_slots(gpc);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int imx_gpcv2_pm_enter(suspend_state_t state) {</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	BUG_ON(!gpcv2_instance);</span>
<span class="quote">&gt; +	pm = gpcv2_instance-&gt;pm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	switch (state) {</span>
<span class="quote">&gt; +	case PM_SUSPEND_STANDBY:</span>
<span class="quote">&gt; +		pm-&gt;standby(gpcv2_instance);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	case PM_SUSPEND_MEM:</span>
<span class="quote">&gt; +		pm-&gt;suspend(gpcv2_instance);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	default:</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int imx_gpcv2_pm_valid(suspend_state_t state) {</span>
<span class="quote">&gt; +	return state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY; }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_get_base_from_node(struct device_node *node,</span>
<span class="quote">&gt; +			struct imx7_pm_base *base)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct resource res;</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		goto put_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	base-&gt;pbase = res.start;</span>
<span class="quote">&gt; +	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="quote">&gt; +	if (!base-&gt;vbase) {</span>
<span class="quote">&gt; +		iounmap(base-&gt;vbase);</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +put_node:</span>
<span class="quote">&gt; +	of_node_put(node);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_get_base_from_dt(struct imx7_pm_base *base,</span>
<span class="quote">&gt; +				const char *compat)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct device_node *node;</span>
<span class="quote">&gt; +	struct resource res;</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="quote">&gt; +	if (!node) {</span>
<span class="quote">&gt; +		ret = -ENODEV;</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		goto put_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	base-&gt;pbase = res.start;</span>
<span class="quote">&gt; +	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="quote">&gt; +	if (!base-&gt;vbase)</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +put_node:</span>
<span class="quote">&gt; +	of_node_put(node);</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_get_exec_base_from_dt(struct imx7_pm_base *base,</span>
<span class="quote">&gt; +				const char *compat)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct device_node *node;</span>
<span class="quote">&gt; +	struct resource res;</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="quote">&gt; +	if (!node) {</span>
<span class="quote">&gt; +		ret = -ENODEV;</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		goto put_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	base-&gt;pbase = res.start;</span>
<span class="quote">&gt; +	base-&gt;vbase = __arm_ioremap_exec(res.start, resource_size(&amp;res),</span>
<span class="quote">&gt; +false);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!base-&gt;vbase)</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +put_node:</span>
<span class="quote">&gt; +	of_node_put(node);</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_gpcv2_suspend_init(struct imx_gpcv2_suspend *pm,</span>
<span class="quote">&gt; +			const struct imx7_pm_socdata *socdata) {</span>
<span class="quote">&gt; +	struct imx7_pm_base aips_base[3] = { {0, 0}, {0, 0}, {0, 0} };</span>
<span class="quote">&gt; +	struct imx7_pm_base sram_base = {0, 0};</span>
<span class="quote">&gt; +	struct imx7_cpu_pm_info *pm_info;</span>
<span class="quote">&gt; +	struct device_node *node = NULL;</span>
<span class="quote">&gt; +	int i, ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	const u32 (*ddrc_phy_offset_array)[2];</span>
<span class="quote">&gt; +	const u32 (*ddrc_offset_array)[2];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!socdata || !pm) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: invalid argument!\n&quot;, __func__);</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for (i = 0; i &lt; 3; i++) {</span>
<span class="quote">&gt; +		node = of_find_compatible_node(node, NULL, &quot;fsl,aips-bus&quot;);</span>
<span class="quote">&gt; +		if (!node) {</span>
<span class="quote">&gt; +			pr_warn(&quot;%s: failed to find aips %d node!\n&quot;,</span>
<span class="quote">&gt; +					__func__, i);</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		ret = imx_get_base_from_node(node, &amp;aips_base[i]);</span>
<span class="quote">&gt; +		if (ret) {</span>
<span class="quote">&gt; +			pr_warn(&quot;%s: failed to get aips[%d] base %d!\n&quot;,</span>
<span class="quote">&gt; +					__func__, i, ret);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_exec_base_from_dt(&amp;sram_base, &quot;fsl,lpm-sram&quot;);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get lpm-sram base %d!\n&quot;,</span>
<span class="quote">&gt; +				__func__, ret);</span>
<span class="quote">&gt; +		goto lpm_sram_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm_info = sram_base.vbase;</span>
<span class="quote">&gt; +	pm_info-&gt;pbase = sram_base.pbase;</span>
<span class="quote">&gt; +	pm_info-&gt;resume_addr = virt_to_phys(ca7_cpu_resume);</span>
<span class="quote">&gt; +	pm_info-&gt;pm_info_size = sizeof(*pm_info);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ccm_base,</span>
<span class="quote">&gt; socdata-&gt;ccm_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get ccm base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto ccm_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_base,</span>
<span class="quote">&gt; socdata-&gt;ddrc_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get ddrc base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto ddrc_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_phy_base,</span>
<span class="quote">&gt; +				socdata-&gt;ddrc_phy_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get ddrc_phy base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto ddrc_phy_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;src_base, socdata-&gt;src_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get src base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto src_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;iomuxc_gpr_base,</span>
<span class="quote">&gt; +				socdata-&gt;iomuxc_gpr_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get iomuxc_gpr base %d!\n&quot;,</span>
<span class="quote">&gt; +					__func__, ret);</span>
<span class="quote">&gt; +		goto iomuxc_gpr_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;gpc_base, socdata-&gt;gpc_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get gpc base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto gpc_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;anatop_base,</span>
<span class="quote">&gt; +				socdata-&gt;anatop_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get anatop base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto anatop_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm_info-&gt;ddrc_num = socdata-&gt;ddrc_num;</span>
<span class="quote">&gt; +	ddrc_offset_array = socdata-&gt;ddrc_offset;</span>
<span class="quote">&gt; +	pm_info-&gt;ddrc_phy_num = socdata-&gt;ddrc_phy_num;</span>
<span class="quote">&gt; +	ddrc_phy_offset_array = socdata-&gt;ddrc_phy_offset;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* initialize DDRC settings */</span>
<span class="quote">&gt; +	for (i = 0; i &lt; pm_info-&gt;ddrc_num; i++) {</span>
<span class="quote">&gt; +		pm_info-&gt;ddrc_val[i][0] = ddrc_offset_array[i][0];</span>
<span class="quote">&gt; +		if (ddrc_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="quote">&gt; +			pm_info-&gt;ddrc_val[i][1] =</span>
<span class="quote">&gt; +				readl_relaxed(pm_info-&gt;ddrc_base.vbase +</span>
<span class="quote">&gt; +				ddrc_offset_array[i][0]);</span>
<span class="quote">&gt; +		else</span>
<span class="quote">&gt; +			pm_info-&gt;ddrc_val[i][1] = ddrc_offset_array[i][1];</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* initialize DDRC PHY settings */</span>
<span class="quote">&gt; +	for (i = 0; i &lt; pm_info-&gt;ddrc_phy_num; i++) {</span>
<span class="quote">&gt; +		pm_info-&gt;ddrc_phy_val[i][0] =</span>
<span class="quote">&gt; +			ddrc_phy_offset_array[i][0];</span>
<span class="quote">&gt; +		if (ddrc_phy_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="quote">&gt; +			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="quote">&gt; +				readl_relaxed(pm_info-&gt;ddrc_phy_base.vbase +</span>
<span class="quote">&gt; +				ddrc_phy_offset_array[i][0]);</span>
<span class="quote">&gt; +		else</span>
<span class="quote">&gt; +			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="quote">&gt; +				ddrc_phy_offset_array[i][1];</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;suspend_fn_in_ocram = fncpy(</span>
<span class="quote">&gt; +		sram_base.vbase + sizeof(*pm_info),</span>
<span class="quote">&gt; +		&amp;imx7_suspend,</span>
<span class="quote">&gt; +		MX7_SUSPEND_OCRAM_SIZE - sizeof(*pm_info));</span>
<span class="quote">&gt; +	pm-&gt;ocram_vbase = sram_base.vbase;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	goto put_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +anatop_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;anatop_base.vbase);</span>
<span class="quote">&gt; +gpc_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;gpc_base.vbase);</span>
<span class="quote">&gt; +iomuxc_gpr_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;iomuxc_gpr_base.vbase);</span>
<span class="quote">&gt; +src_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;src_base.vbase);</span>
<span class="quote">&gt; +ddrc_phy_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;ddrc_phy_base.vbase);</span>
<span class="quote">&gt; +ddrc_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;ddrc_base.vbase);</span>
<span class="quote">&gt; +ccm_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;ccm_base.vbase);</span>
<span class="quote">&gt; +lpm_sram_map_failed:</span>
<span class="quote">&gt; +	iounmap(sram_base.vbase);</span>
<span class="quote">&gt; +put_node:</span>
<span class="quote">&gt; +	of_node_put(node);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct platform_suspend_ops imx_gpcv2_pm_ops = {</span>
<span class="quote">&gt; +	.enter = imx_gpcv2_pm_enter,</span>
<span class="quote">&gt; +	.valid = imx_gpcv2_pm_valid,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_gpcv2_pm_init(void) {</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm;</span>
<span class="quote">&gt; +	struct imx_gpcv2 *gpc;</span>
<span class="quote">&gt; +	int val, num;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm = kzalloc(sizeof(struct imx_gpcv2_suspend), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!pm) {</span>
<span class="quote">&gt; +		pr_warn(&quot;[GPCv2] %s init failed\r\n&quot;, __func__);</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	gpc = kzalloc(sizeof(struct imx_gpcv2), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!gpc) {</span>
<span class="quote">&gt; +		pr_warn(&quot;[GPCv2] %s init failed\r\n&quot;, __func__);</span>
<span class="quote">&gt; +		kfree(pm);</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	imx_gpcv2_suspend_init(pm, &amp;imx7d_pm_data_ddr3);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_setup = imx_gpcv2_lpm_env_setup;</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_clean = imx_gpcv2_lpm_env_clean;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_cpu_power_gate = imx_gpcv2_lpm_cpu_power_gate;</span>
<span class="quote">&gt; +	pm-&gt;lpm_plat_power_gate = imx_lpm_plat_power_gate;</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core = imx_gpcv2_lpm_enable_core;</span>
<span class="quote">&gt; +	pm-&gt;set_mode = imx_gpcv2_lpm_set_mode;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;clear_slots = imx_gpcv2_lpm_clear_slots;</span>
<span class="quote">&gt; +	pm-&gt;set_slot = imx_gpcv2_lpm_slot_setup;</span>
<span class="quote">&gt; +	pm-&gt;set_act = imx_gpcv2_lpm_set_ack;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;standby = imx_gpcv2_lpm_standby;</span>
<span class="quote">&gt; +	pm-&gt;suspend = imx_gpcv2_lpm_suspend;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	gpc-&gt;anatop = syscon_regmap_lookup_by_compatible(&quot;fsl,imx6q-anatop&quot;);</span>
<span class="quote">&gt; +	if (IS_ERR(gpc-&gt;anatop))</span>
<span class="quote">&gt; +		goto error_exit;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	gpc-&gt;gpcv2 = syscon_regmap_lookup_by_compatible(&quot;fsl,imx7d-gpc&quot;);</span>
<span class="quote">&gt; +	if (IS_ERR(gpc-&gt;gpcv2))</span>
<span class="quote">&gt; +		goto error_exit;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* only external IRQs to wake up LPM and core 0/1 */</span>
<span class="quote">&gt; +	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_A7_BSC, &amp;val);</span>
<span class="quote">&gt; +	val |= BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP;</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_A7_BSC, val);</span>
<span class="quote">&gt; +	/* mask m4 dsm trigger */</span>
<span class="quote">&gt; +	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_M4, &amp;val);</span>
<span class="quote">&gt; +	val |= BM_LPCR_M4_MASK_DSM_TRIGGER;</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_M4, val);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* set mega/fast mix in A7 domain */</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_PGC_CPU_MAPPING, 0x1);</span>
<span class="quote">&gt; +	/* set SCU timing */</span>
<span class="quote">&gt; +	val = (0x59 &lt;&lt; 10) | 0x5B | (0x51 &lt;&lt; 20);</span>
<span class="quote">&gt; +	regmap_write(gpc-&gt;gpcv2, GPC_PGC_SCU_TIMING, val);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	gpc-&gt;pm = pm;</span>
<span class="quote">&gt; +	gpc-&gt;get_wakeup_source = imx_gpcv2_get_wakeup_source;</span>
<span class="quote">&gt; +	gpcv2_instance = gpc;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	num = imx_gpcv2_get_wakeup_source(0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * The IP blocks which may be the wakeup sources are allocated into</span>
<span class="quote">&gt; +	 * several power domains. MFMIX, LPSRMX, and WAKEUPMIX are three of</span>
<span class="quote">&gt; +	 * those power domains. If a bit is &#39;1&#39; in the mask, it means the IP</span>
<span class="quote">&gt; +	 * block is inside the power domain. The mask will be used to decide</span>
<span class="quote">&gt; +	 * if a power domain should be shutdown or not when system goes into</span>
<span class="quote">&gt; +	 * suspend states.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (num)</span>
<span class="quote">&gt; +		gpc-&gt;wakeupmix_mask = kzalloc(sizeof(u32)*num*3, GFP_KERNEL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!gpc-&gt;wakeupmix_mask)</span>
<span class="quote">&gt; +		goto error_exit;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Shutdown LPSRMIX and WAKEUP power domain has not been</span>
<span class="quote">&gt; +	 * implemented in this patch yet.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	gpc-&gt;lpsrmix_mask = gpc-&gt;wakeupmix_mask + num;</span>
<span class="quote">&gt; +	gpc-&gt;mfmix_mask = gpc-&gt;wakeupmix_mask + num*2;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Mask the wakeup sources in M/F power domain */</span>
<span class="quote">&gt; +	gpc-&gt;mfmix_mask[0] = 0x54010000;</span>
<span class="quote">&gt; +	gpc-&gt;mfmix_mask[1] = 0xC00;</span>
<span class="quote">&gt; +	gpc-&gt;mfmix_mask[2] = 0x0;</span>
<span class="quote">&gt; +	gpc-&gt;mfmix_mask[3] = 0x400010;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	suspend_set_ops(&amp;imx_gpcv2_pm_ops);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +error_exit:</span>
<span class="quote">&gt; +	kfree(pm);</span>
<span class="quote">&gt; +	kfree(gpc);</span>
<span class="quote">&gt; +	return -ENODEV;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +device_initcall(imx_gpcv2_pm_init);</span>
<span class="quote">&gt; diff --git a/arch/arm/mach-imx/suspend-imx7.S</span>
<span class="quote">&gt; b/arch/arm/mach-imx/suspend-imx7.S</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..8c3f516</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/suspend-imx7.S</span>
<span class="quote">&gt; @@ -0,0 +1,529 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * The code contained herein is licensed under the GNU General Public</span>
<span class="quote">&gt; + * License. You may obtain a copy of the GNU General Public License</span>
<span class="quote">&gt; + * Version 2 or later at the following locations:</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * http://www.opensource.org/licenses/gpl-license.html</span>
<span class="quote">&gt; + * http://www.gnu.org/copyleft/gpl.html</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/linkage.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/asm-offsets.h&gt;</span>
<span class="quote">&gt; +#include &quot;hardware.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * ==================== low level suspend ====================</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Better to follow below rules to use ARM registers:</span>
<span class="quote">&gt; + * r0: pm_info structure address;</span>
<span class="quote">&gt; + * r1 ~ r4: for saving pm_info members;</span>
<span class="quote">&gt; + * r5 ~ r10: free registers;</span>
<span class="quote">&gt; + * r11: io base address.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * suspend ocram space layout:</span>
<span class="quote">&gt; + * ======================== high address ======================</span>
<span class="quote">&gt; + *                              .</span>
<span class="quote">&gt; + *                              .</span>
<span class="quote">&gt; + *                              .</span>
<span class="quote">&gt; + *                              ^</span>
<span class="quote">&gt; + *                              ^</span>
<span class="quote">&gt; + *                              ^</span>
<span class="quote">&gt; + *                      imx7_suspend code</span>
<span class="quote">&gt; + *              PM_INFO structure(imx7_cpu_pm_info)</span>
<span class="quote">&gt; + * ======================== low address =======================  */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Below offsets are based on struct imx7_cpu_pm_info</span>
<span class="quote">&gt; + * which defined in arch/arm/mach-imx/pm-imx7.c, this</span>
<span class="quote">&gt; + * structure contains necessary pm info for low level</span>
<span class="quote">&gt; + * suspend related code.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#define PM_INFO_M4_RESERVE0_OFFSET		0x0</span>
<span class="quote">&gt; +#define PM_INFO_M4_RESERVE1_OFFSET		0x4</span>
<span class="quote">&gt; +#define PM_INFO_M4_RESERVE2_OFFSET		0x8</span>
<span class="quote">&gt; +#define PM_INFO_PBASE_OFFSET			0xc</span>
<span class="quote">&gt; +#define PM_INFO_RESUME_ADDR_OFFSET		0x10</span>
<span class="quote">&gt; +#define PM_INFO_DDR_TYPE_OFFSET			0x14</span>
<span class="quote">&gt; +#define PM_INFO_PM_INFO_SIZE_OFFSET		0x18</span>
<span class="quote">&gt; +#define PM_INFO_MX7_DDRC_P_OFFSET		0x1c</span>
<span class="quote">&gt; +#define PM_INFO_MX7_DDRC_V_OFFSET		0x20</span>
<span class="quote">&gt; +#define PM_INFO_MX7_DDRC_PHY_P_OFFSET		0x24</span>
<span class="quote">&gt; +#define PM_INFO_MX7_DDRC_PHY_V_OFFSET		0x28</span>
<span class="quote">&gt; +#define PM_INFO_MX7_SRC_P_OFFSET		0x2c</span>
<span class="quote">&gt; +#define PM_INFO_MX7_SRC_V_OFFSET		0x30</span>
<span class="quote">&gt; +#define PM_INFO_MX7_IOMUXC_GPR_P_OFFSET		0x34</span>
<span class="quote">&gt; +#define PM_INFO_MX7_IOMUXC_GPR_V_OFFSET		0x38</span>
<span class="quote">&gt; +#define PM_INFO_MX7_CCM_P_OFFSET		0x3c</span>
<span class="quote">&gt; +#define PM_INFO_MX7_CCM_V_OFFSET		0x40</span>
<span class="quote">&gt; +#define PM_INFO_MX7_GPC_P_OFFSET		0x44</span>
<span class="quote">&gt; +#define PM_INFO_MX7_GPC_V_OFFSET		0x48</span>
<span class="quote">&gt; +#define PM_INFO_MX7_L2_P_OFFSET			0x4c</span>
<span class="quote">&gt; +#define PM_INFO_MX7_L2_V_OFFSET			0x50</span>
<span class="quote">&gt; +#define PM_INFO_MX7_ANATOP_P_OFFSET		0x54</span>
<span class="quote">&gt; +#define PM_INFO_MX7_ANATOP_V_OFFSET		0x58</span>
<span class="quote">&gt; +#define PM_INFO_MX7_TTBR1_V_OFFSET		0x5c</span>
<span class="quote">&gt; +#define PM_INFO_DDRC_REG_NUM_OFFSET		0x60</span>
<span class="quote">&gt; +#define PM_INFO_DDRC_REG_OFFSET			0x64</span>
<span class="quote">&gt; +#define PM_INFO_DDRC_VALUE_OFFSET		0x68</span>
<span class="quote">&gt; +#define PM_INFO_DDRC_PHY_REG_NUM_OFFSET		0x164</span>
<span class="quote">&gt; +#define PM_INFO_DDRC_PHY_REG_OFFSET		0x168</span>
<span class="quote">&gt; +#define PM_INFO_DDRC_PHY_VALUE_OFFSET		0x16c</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define MX7_SRC_GPR1	0x74</span>
<span class="quote">&gt; +#define MX7_SRC_GPR2	0x78</span>
<span class="quote">&gt; +#define GPC_PGC_FM	0xa00</span>
<span class="quote">&gt; +#define ANADIG_SNVS_MISC_CTRL	0x380</span>
<span class="quote">&gt; +#define DDRC_STAT	0x4</span>
<span class="quote">&gt; +#define DDRC_PWRCTL	0x30</span>
<span class="quote">&gt; +#define DDRC_PSTAT	0x3fc</span>
<span class="quote">&gt; +#define DDRC_PCTRL_0	0x490</span>
<span class="quote">&gt; +#define DDRC_DFIMISC	0x1b0</span>
<span class="quote">&gt; +#define DDRC_SWCTL	0x320</span>
<span class="quote">&gt; +#define DDRC_SWSTAT	0x324</span>
<span class="quote">&gt; +#define DDRPHY_LP_CON0	0x18</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.align 3</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.macro	disable_l1_dcache</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Flush all data from the L1 data cache before disabling</span>
<span class="quote">&gt; +	 * SCTLR.C bit.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	push	{r0 - r10, lr}</span>
<span class="quote">&gt; +	ldr	r7, =v7_flush_dcache_all</span>
<span class="quote">&gt; +	mov	lr, pc</span>
<span class="quote">&gt; +	mov	pc, r7</span>
<span class="quote">&gt; +	pop	{r0 - r10, lr}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* disable d-cache */</span>
<span class="quote">&gt; +	mrc	p15, 0, r7, c1, c0, 0</span>
<span class="quote">&gt; +	bic	r7, r7, #(1 &lt;&lt; 2)</span>
<span class="quote">&gt; +	mcr	p15, 0, r7, c1, c0, 0</span>
<span class="quote">&gt; +	dsb</span>
<span class="quote">&gt; +	isb</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	push	{r0 - r10, lr}</span>
<span class="quote">&gt; +	ldr	r7, =v7_flush_dcache_all</span>
<span class="quote">&gt; +	mov	lr, pc</span>
<span class="quote">&gt; +	mov	pc, r7</span>
<span class="quote">&gt; +	pop	{r0 - r10, lr}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.endm</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.macro enable_l1_dcache</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Enable L1 data cache. */</span>
<span class="quote">&gt; +	mrc	p15, 0, r6, c1, c0, 0</span>
<span class="quote">&gt; +	orr	r6, r6, #0x4</span>
<span class="quote">&gt; +	mcr	p15, 0, r6, c1, c0, 0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dsb</span>
<span class="quote">&gt; +	isb</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.endm</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.macro ddrc_enter_self_refresh</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* let DDR out of self-refresh */</span>
<span class="quote">&gt; +	ldr	r7, =0x0</span>
<span class="quote">&gt; +	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* wait rw port_busy clear */</span>
<span class="quote">&gt; +	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="quote">&gt; +	orr	r6, r6, #0x1</span>
<span class="quote">&gt; +1:</span>
<span class="quote">&gt; +	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="quote">&gt; +	ands	r7, r7, r6</span>
<span class="quote">&gt; +	bne	1b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enter self-refresh bit 5 */</span>
<span class="quote">&gt; +	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="quote">&gt; +	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* wait until self-refresh mode entered */</span>
<span class="quote">&gt; +2:</span>
<span class="quote">&gt; +	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="quote">&gt; +	and	r7, r7, #0x3</span>
<span class="quote">&gt; +	cmp	r7, #0x3</span>
<span class="quote">&gt; +	bne	2b</span>
<span class="quote">&gt; +3:</span>
<span class="quote">&gt; +	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="quote">&gt; +	ands	r7, r7, #0x20</span>
<span class="quote">&gt; +	beq	3b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* disable dram clk */</span>
<span class="quote">&gt; +	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="quote">&gt; +	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.endm</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.macro ddrc_exit_self_refresh</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cmp	r5, #0x0</span>
<span class="quote">&gt; +	ldreq	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="quote">&gt; +	ldrne	r11, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* let DDR out of self-refresh */</span>
<span class="quote">&gt; +	ldr	r7, =0x0</span>
<span class="quote">&gt; +	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* wait until self-refresh mode entered */</span>
<span class="quote">&gt; +4:</span>
<span class="quote">&gt; +	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="quote">&gt; +	and	r7, r7, #0x3</span>
<span class="quote">&gt; +	cmp	r7, #0x3</span>
<span class="quote">&gt; +	beq	4b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enable auto self-refresh */</span>
<span class="quote">&gt; +	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +	orr	r7, r7, #(1 &lt;&lt; 0)</span>
<span class="quote">&gt; +	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.endm</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.macro wait_delay</span>
<span class="quote">&gt; +5:</span>
<span class="quote">&gt; +	subs	r6, r6, #0x1</span>
<span class="quote">&gt; +	bne	5b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.endm</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.macro ddr_enter_retention</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* let DDR out of self-refresh */</span>
<span class="quote">&gt; +	ldr	r7, =0x0</span>
<span class="quote">&gt; +	str	r7, [r11, #DDRC_PCTRL_0]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* wait rw port_busy clear */</span>
<span class="quote">&gt; +	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="quote">&gt; +	orr	r6, r6, #0x1</span>
<span class="quote">&gt; +6:</span>
<span class="quote">&gt; +	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="quote">&gt; +	ands	r7, r7, r6</span>
<span class="quote">&gt; +	bne	6b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="quote">&gt; +	/* enter self-refresh bit 5 */</span>
<span class="quote">&gt; +	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="quote">&gt; +	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* wait until self-refresh mode entered */</span>
<span class="quote">&gt; +7:</span>
<span class="quote">&gt; +	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="quote">&gt; +	and	r7, r7, #0x3</span>
<span class="quote">&gt; +	cmp	r7, #0x3</span>
<span class="quote">&gt; +	bne	7b</span>
<span class="quote">&gt; +8:</span>
<span class="quote">&gt; +	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="quote">&gt; +	ands	r7, r7, #0x20</span>
<span class="quote">&gt; +	beq	8b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* disable dram clk */</span>
<span class="quote">&gt; +	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="quote">&gt; +	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="quote">&gt; +	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* reset ddr_phy  */</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, =0x0</span>
<span class="quote">&gt; +	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* delay 7 us */</span>
<span class="quote">&gt; +	ldr	r6, =6000</span>
<span class="quote">&gt; +	wait_delay</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r6, =0x1000</span>
<span class="quote">&gt; +	ldr	r7, [r11, r6]</span>
<span class="quote">&gt; +	orr	r7, r7, #0x1</span>
<span class="quote">&gt; +	str	r7, [r11, r6]</span>
<span class="quote">&gt; +	/* turn off ddr power */</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="quote">&gt; +	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.endm</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.macro ddr_exit_retention</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cmp	r5, #0x0</span>
<span class="quote">&gt; +	ldreq	r1, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="quote">&gt; +	ldrne	r1, [r0, #PM_INFO_MX7_ANATOP_P_OFFSET]</span>
<span class="quote">&gt; +	ldreq	r2, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="quote">&gt; +	ldrne	r2, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="quote">&gt; +	ldreq	r3, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="quote">&gt; +	ldrne	r3, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="quote">&gt; +	ldreq	r4, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="quote">&gt; +	ldrne	r4, [r0, #PM_INFO_MX7_DDRC_PHY_P_OFFSET]</span>
<span class="quote">&gt; +	ldreq	r10, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="quote">&gt; +	ldrne	r10, [r0, #PM_INFO_MX7_CCM_P_OFFSET]</span>
<span class="quote">&gt; +	ldreq	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="quote">&gt; +	ldrne	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_P_OFFSET]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* turn on ddr power */</span>
<span class="quote">&gt; +	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="quote">&gt; +	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r6, =50</span>
<span class="quote">&gt; +	wait_delay</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r7, =0x0</span>
<span class="quote">&gt; +	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* clear ddr_phy reset */</span>
<span class="quote">&gt; +	ldr	r6, =0x1000</span>
<span class="quote">&gt; +	ldr	r7, [r2, r6]</span>
<span class="quote">&gt; +	orr	r7, r7, #0x3</span>
<span class="quote">&gt; +	str	r7, [r2, r6]</span>
<span class="quote">&gt; +	ldr	r7, [r2, r6]</span>
<span class="quote">&gt; +	bic	r7, r7, #0x1</span>
<span class="quote">&gt; +	str	r7, [r2, r6]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r6, [r0, #PM_INFO_DDRC_REG_NUM_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, =PM_INFO_DDRC_REG_OFFSET</span>
<span class="quote">&gt; +	add	r7, r7, r0</span>
<span class="quote">&gt; +9:</span>
<span class="quote">&gt; +	ldr	r8, [r7], #0x4</span>
<span class="quote">&gt; +	ldr	r9, [r7], #0x4</span>
<span class="quote">&gt; +	str	r9, [r3, r8]</span>
<span class="quote">&gt; +	subs	r6, r6, #0x1</span>
<span class="quote">&gt; +	bne	9b</span>
<span class="quote">&gt; +	ldr	r7, =0x20</span>
<span class="quote">&gt; +	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +	ldr	r7, =0x0</span>
<span class="quote">&gt; +	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* do PHY, clear ddr_phy reset */</span>
<span class="quote">&gt; +	ldr	r6, =0x1000</span>
<span class="quote">&gt; +	ldr	r7, [r2, r6]</span>
<span class="quote">&gt; +	bic	r7, r7, #0x2</span>
<span class="quote">&gt; +	str	r7, [r2, r6]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r7, =(0x1 &lt;&lt; 30)</span>
<span class="quote">&gt; +	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* need to delay ~5mS */</span>
<span class="quote">&gt; +	ldr	r6, =0x100000</span>
<span class="quote">&gt; +	wait_delay</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r6, [r0, #PM_INFO_DDRC_PHY_REG_NUM_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, =PM_INFO_DDRC_PHY_REG_OFFSET</span>
<span class="quote">&gt; +	add	r7, r7, r0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +10:</span>
<span class="quote">&gt; +	ldr	r8, [r7], #0x4</span>
<span class="quote">&gt; +	ldr	r9, [r7], #0x4</span>
<span class="quote">&gt; +	str	r9, [r4, r8]</span>
<span class="quote">&gt; +	subs	r6, r6, #0x1</span>
<span class="quote">&gt; +	bne	10b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r7, =0x0</span>
<span class="quote">&gt; +	add	r9, r10, #0x4000</span>
<span class="quote">&gt; +	str	r7, [r9, #0x130]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cmp	r5, #0x0</span>
<span class="quote">&gt; +	beq	101f</span>
<span class="quote">&gt; +	ldr	r7, =0x170</span>
<span class="quote">&gt; +	orr	r7, r7, #0x8</span>
<span class="quote">&gt; +	str	r7, [r11, #0x20]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +101:</span>
<span class="quote">&gt; +	ldr	r7, =0x2</span>
<span class="quote">&gt; +	add	r9, r10, #0x4000</span>
<span class="quote">&gt; +	str	r7, [r9, #0x130]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r7, =0xf</span>
<span class="quote">&gt; +	str	r7, [r4, #DDRPHY_LP_CON0]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* wait until self-refresh mode entered */</span>
<span class="quote">&gt; +11:</span>
<span class="quote">&gt; +	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="quote">&gt; +	and	r7, r7, #0x3</span>
<span class="quote">&gt; +	cmp	r7, #0x3</span>
<span class="quote">&gt; +	bne	11b</span>
<span class="quote">&gt; +	ldr	r7, =0x0</span>
<span class="quote">&gt; +	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="quote">&gt; +	ldr	r7, =0x1</span>
<span class="quote">&gt; +	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="quote">&gt; +	ldr	r7, =0x1</span>
<span class="quote">&gt; +	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="quote">&gt; +12:</span>
<span class="quote">&gt; +	ldr	r7, [r3, #DDRC_SWSTAT]</span>
<span class="quote">&gt; +	and	r7, r7, #0x1</span>
<span class="quote">&gt; +	cmp	r7, #0x1</span>
<span class="quote">&gt; +	bne	12b</span>
<span class="quote">&gt; +13:</span>
<span class="quote">&gt; +	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="quote">&gt; +	and	r7, r7, #0x20</span>
<span class="quote">&gt; +	cmp	r7, #0x20</span>
<span class="quote">&gt; +	bne	13b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* let DDR out of self-refresh */</span>
<span class="quote">&gt; +	ldr	r7, =0x0</span>
<span class="quote">&gt; +	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="quote">&gt; +14:</span>
<span class="quote">&gt; +	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="quote">&gt; +	and	r7, r7, #0x30</span>
<span class="quote">&gt; +	cmp	r7, #0x0</span>
<span class="quote">&gt; +	bne	14b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +15:</span>
<span class="quote">&gt; +	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="quote">&gt; +	and	r7, r7, #0x3</span>
<span class="quote">&gt; +	cmp	r7, #0x1</span>
<span class="quote">&gt; +	bne	15b</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enable port */</span>
<span class="quote">&gt; +	ldr	r7, =0x1</span>
<span class="quote">&gt; +	str	r7, [r3, #DDRC_PCTRL_0]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.endm</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +ENTRY(imx7_suspend)</span>
<span class="quote">&gt; +	push	{r4-r12}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * The value of r0 is mapped the same in origin table and IRAM table,</span>
<span class="quote">&gt; +	 * thus no need to care r0 here.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	ldr	r1, [r0, #PM_INFO_PBASE_OFFSET]</span>
<span class="quote">&gt; +	ldr	r2, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="quote">&gt; +	ldr	r3, [r0, #PM_INFO_DDR_TYPE_OFFSET]</span>
<span class="quote">&gt; +	ldr	r4, [r0, #PM_INFO_PM_INFO_SIZE_OFFSET]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * counting the resume address in iram</span>
<span class="quote">&gt; +	 * to set it in SRC register.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	ldr	r6, =imx7_suspend</span>
<span class="quote">&gt; +	ldr	r7, =resume</span>
<span class="quote">&gt; +	sub	r7, r7, r6</span>
<span class="quote">&gt; +	add	r8, r1, r4</span>
<span class="quote">&gt; +	add	r9, r8, r7</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="quote">&gt; +	/* store physical resume addr and pm_info address. */</span>
<span class="quote">&gt; +	str	r9, [r11, #MX7_SRC_GPR1]</span>
<span class="quote">&gt; +	str	r1, [r11, #MX7_SRC_GPR2]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	disable_l1_dcache</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * make sure TLB contain the addr we want,</span>
<span class="quote">&gt; +	 * as we will access them after DDR is in</span>
<span class="quote">&gt; +	 * self-refresh mode.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	ldr	r6, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, [r0, #0x0]</span>
<span class="quote">&gt; +	ldr	r6, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="quote">&gt; +	add	r6, #0x4000</span>
<span class="quote">&gt; +	ldr	r7, [r6]</span>
<span class="quote">&gt; +	ldr	r6, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, [r6, #0x0]</span>
<span class="quote">&gt; +	ldr	r6, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, [r6, #0x0]</span>
<span class="quote">&gt; +	add	r6, #0x1000</span>
<span class="quote">&gt; +	ldr	r7, [r6]</span>
<span class="quote">&gt; +	ldr	r6, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, [r6, #0x0]</span>
<span class="quote">&gt; +	ldr	r7, [r6, #0x490]</span>
<span class="quote">&gt; +	ldr	r6, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, [r6, #0x0]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="quote">&gt; +	cmp	r7, #0</span>
<span class="quote">&gt; +	beq	ddr_only_self_refresh</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ddr_enter_retention</span>
<span class="quote">&gt; +	b	ddr_retention_enter_out</span>
<span class="quote">&gt; +ddr_only_self_refresh:</span>
<span class="quote">&gt; +	ddrc_enter_self_refresh</span>
<span class="quote">&gt; +ddr_retention_enter_out:</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Zzz, enter stop mode */</span>
<span class="quote">&gt; +	wfi</span>
<span class="quote">&gt; +	nop</span>
<span class="quote">&gt; +	nop</span>
<span class="quote">&gt; +	nop</span>
<span class="quote">&gt; +	nop</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mov	r5, #0x0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="quote">&gt; +	cmp	r7, #0</span>
<span class="quote">&gt; +	beq	wfi_ddr_self_refresh_out</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ddr_exit_retention</span>
<span class="quote">&gt; +	b	wfi_ddr_retention_out</span>
<span class="quote">&gt; +wfi_ddr_self_refresh_out:</span>
<span class="quote">&gt; +	ddrc_exit_self_refresh</span>
<span class="quote">&gt; +wfi_ddr_retention_out:</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, =0x170</span>
<span class="quote">&gt; +	orr	r7, r7, #0x8</span>
<span class="quote">&gt; +	str	r7, [r11, #0x20]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* clear core0&#39;s entry and parameter */</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="quote">&gt; +	mov	r7, #0x0</span>
<span class="quote">&gt; +	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="quote">&gt; +	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	enable_l1_dcache</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pop	{r4-r12}</span>
<span class="quote">&gt; +	/* return to suspend finish */</span>
<span class="quote">&gt; +	mov	pc, lr</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +resume:</span>
<span class="quote">&gt; +	/* invalidate L1 I-cache first */</span>
<span class="quote">&gt; +	mov     r6, #0x0</span>
<span class="quote">&gt; +	mcr     p15, 0, r6, c7, c5, 0</span>
<span class="quote">&gt; +	mcr     p15, 0, r6, c7, c5, 6</span>
<span class="quote">&gt; +	/* enable the Icache and branch prediction */</span>
<span class="quote">&gt; +	mov     r6, #0x1800</span>
<span class="quote">&gt; +	mcr     p15, 0, r6, c1, c0, 0</span>
<span class="quote">&gt; +	isb</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* get physical resume address from pm_info. */</span>
<span class="quote">&gt; +	ldr	lr, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="quote">&gt; +	/* clear core0&#39;s entry and parameter */</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="quote">&gt; +	mov	r7, #0x0</span>
<span class="quote">&gt; +	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="quote">&gt; +	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mov	r5, #0x1</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ldr	r11, [r0, #PM_INFO_MX7_GPC_P_OFFSET]</span>
<span class="quote">&gt; +	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="quote">&gt; +	cmp	r7, #0</span>
<span class="quote">&gt; +	beq	dsm_ddr_self_refresh_out</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ddr_exit_retention</span>
<span class="quote">&gt; +	b	dsm_ddr_retention_out</span>
<span class="quote">&gt; +dsm_ddr_self_refresh_out:</span>
<span class="quote">&gt; +	ddrc_exit_self_refresh</span>
<span class="quote">&gt; +dsm_ddr_retention_out:</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mov	pc, lr</span>
<span class="quote">&gt; +ENDPROC(imx7_suspend)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +ENTRY(ca7_cpu_resume)</span>
<span class="quote">&gt; +	bl	v7_invalidate_l1</span>
<span class="quote">&gt; +	b	cpu_resume</span>
<span class="quote">&gt; +ENDPROC(ca7_cpu_resume)</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; 2.5.0.rc2</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in</span>
<span class="quote">&gt; the body of a message to majordomo@vger.kernel.org</span>
<span class="quote">&gt; More majordomo info at  http://vger.kernel.org/majordomo-info.html</span>
<span class="quote">&gt; Please read the FAQ at  http://www.tux.org/lkml/</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131511">Shawn Guo</a> - Sept. 7, 2015, 3:11 p.m.</div>
<pre class="content">
On Fri, Jul 31, 2015 at 04:33:59PM -0500, Shenwei Wang wrote:
<span class="quote">&gt; IMX7D contains a new version of GPC IP block (GPCv2). It has two</span>
<span class="quote">&gt; major functions: power management and wakeup source management.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; GPCv2 provides low power mode control for Cortex-A7 and Cortex-M4</span>
<span class="quote">&gt; domains. And it can support WAIT, STOP, and DSM(Deep Sleep Mode) modes.</span>
<span class="quote">&gt; After configuring the GPCv2 module, the platform can enter into a</span>
<span class="quote">&gt; selected mode either automatically triggered by ARM WFI instruction or</span>
<span class="quote">&gt; manually by software. The system will exit the low power states</span>
<span class="quote">&gt; by the predefined wakeup sources which are managed by the gpcv2</span>
<span class="quote">&gt; irqchip driver.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This patch adds a new suspend driver to manage the power states on IMX7D.</span>
<span class="quote">&gt; It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Anson Huang &lt;b20788@freescale.com&gt;</span>

Please stop sending patches to my Linaro mailbox, and use
shawnguo@kernel.org instead.  You should already get that if you ever
run ./scripts/get_maintainer.pl on the patch.  Also please always copy
kernel@pengutronix.de for i.MX platform patches like this.
<span class="quote">
&gt; ---</span>
<span class="quote">&gt;  arch/arm/mach-imx/Kconfig        |   1 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/Makefile       |   2 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/common.h       |   4 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/pm-imx7.c      | 917 +++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/arm/mach-imx/suspend-imx7.S | 529 ++++++++++++++++++++++</span>
<span class="quote">&gt;  5 files changed, 1453 insertions(+)</span>

1453 lines addition to kernel only for i.MX7D suspend support.  Yes,
this is the way we support suspend on i.MX6, but that&#39;s enough, and
we have to stop this somewhere.  I would ask you to take Sudeep&#39;s
comment and adopt PSCI for i.MX7D power management.

Shawn

[1] https://lkml.org/lkml/2015/8/26/554
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a> - Sept. 8, 2015, 3:01 p.m.</div>
<pre class="content">
<span class="quote">&gt; -----Original Message-----</span>
<span class="quote">&gt; From: Shawn Guo [mailto:shawnguo@kernel.org]</span>
<span class="quote">&gt; &gt; This patch adds a new suspend driver to manage the power states on IMX7D.</span>
<span class="quote">&gt; &gt; It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Anson Huang &lt;b20788@freescale.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Please stop sending patches to my Linaro mailbox, and use</span>
<span class="quote">&gt; shawnguo@kernel.org instead.  You should already get that if you ever</span>
<span class="quote">&gt; run ./scripts/get_maintainer.pl on the patch.  Also please always copy</span>
<span class="quote">&gt; kernel@pengutronix.de for i.MX platform patches like this.</span>

Noted.
<span class="quote">
&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  arch/arm/mach-imx/Kconfig        |   1 +</span>
<span class="quote">&gt; &gt;  arch/arm/mach-imx/Makefile       |   2 +</span>
<span class="quote">&gt; &gt;  arch/arm/mach-imx/common.h       |   4 +</span>
<span class="quote">&gt; &gt;  arch/arm/mach-imx/pm-imx7.c      | 917</span>
<span class="quote">&gt; +++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;  arch/arm/mach-imx/suspend-imx7.S | 529 ++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;  5 files changed, 1453 insertions(+)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 1453 lines addition to kernel only for i.MX7D suspend support.  Yes, this is the</span>
<span class="quote">&gt; way we support suspend on i.MX6, but that&#39;s enough, and we have to stop this</span>
<span class="quote">&gt; somewhere.  I would ask you to take Sudeep&#39;s comment and adopt PSCI for</span>
<span class="quote">&gt; i.MX7D power management.</span>

According to PSCI spec, a supervisory software must be implemented under either
HVC(EL2) or SMC(EL3) privilege level. I agree that, with this idea, we could finally move 
these 1453 lines of codes from kernel into a platform specific firmware. The problem
is we don&#39;t have the firmware so far, and we haven&#39;t even had a plan to enable the
hypervisor or secure software on this platform. Because low power consumption is
the key feature of this i.MX7D platform, please continue to consider the current 
implementation and get this feature supported first. 

Thanks,
Shenwei
<span class="quote">
 
&gt; Shawn</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [1] https://lkml.org/lkml/2015/8/26/554</span>
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131511">Shawn Guo</a> - Sept. 18, 2015, 2:15 p.m.</div>
<pre class="content">
On Tue, Sep 08, 2015 at 03:01:07PM +0000, Shenwei Wang wrote:
<span class="quote">&gt; &gt; &gt;  arch/arm/mach-imx/Kconfig        |   1 +</span>
<span class="quote">&gt; &gt; &gt;  arch/arm/mach-imx/Makefile       |   2 +</span>
<span class="quote">&gt; &gt; &gt;  arch/arm/mach-imx/common.h       |   4 +</span>
<span class="quote">&gt; &gt; &gt;  arch/arm/mach-imx/pm-imx7.c      | 917</span>
<span class="quote">&gt; &gt; +++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt; &gt;  arch/arm/mach-imx/suspend-imx7.S | 529 ++++++++++++++++++++++</span>
<span class="quote">&gt; &gt; &gt;  5 files changed, 1453 insertions(+)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 1453 lines addition to kernel only for i.MX7D suspend support.  Yes, this is the</span>
<span class="quote">&gt; &gt; way we support suspend on i.MX6, but that&#39;s enough, and we have to stop this</span>
<span class="quote">&gt; &gt; somewhere.  I would ask you to take Sudeep&#39;s comment and adopt PSCI for</span>
<span class="quote">&gt; &gt; i.MX7D power management.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; According to PSCI spec, a supervisory software must be implemented under either</span>
<span class="quote">&gt; HVC(EL2) or SMC(EL3) privilege level. I agree that, with this idea, we could finally move </span>
<span class="quote">&gt; these 1453 lines of codes from kernel into a platform specific firmware. The problem</span>
<span class="quote">&gt; is we don&#39;t have the firmware so far, and we haven&#39;t even had a plan to enable the</span>
<span class="quote">&gt; hypervisor or secure software on this platform. Because low power consumption is</span>
<span class="quote">&gt; the key feature of this i.MX7D platform, please continue to consider the current </span>
<span class="quote">&gt; implementation and get this feature supported first. </span>

Can&#39;t U-Boot be considered as a firmware to implement PSCI?  I have seen
an initial ARMv7 PSCI core support for U-Boot added by Marc Zyngier.

Shawn

[1] http://lists.denx.de/pipermail/u-boot/2013-December/168655.html
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131511">Shawn Guo</a> - Sept. 19, 2015, 1:12 a.m.</div>
<pre class="content">
On Fri, Sep 18, 2015 at 02:38:39PM +0000, Shenwei Wang wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; -----Original Message-----</span>
<span class="quote">&gt; &gt; From: Shawn Guo [mailto:shawnguo@kernel.org]</span>
<span class="quote">&gt; &gt; Sent: 2015?9?18? 9:15</span>
<span class="quote">&gt; &gt; To: Wang Shenwei-B38339</span>
<span class="quote">&gt; &gt; Cc: jason@lakedaemon.net; Huang Yongcai-B20788;</span>
<span class="quote">&gt; &gt; linux-kernel@vger.kernel.org; kernel@pengutronix.de; Sudeep Holla;</span>
<span class="quote">&gt; &gt; tglx@linutronix.de; shawn.guo@linaro.org; linux-arm-kernel@lists.infradead.org</span>
<span class="quote">&gt; &gt; Subject: Re: [PATCH v8 2/2] ARM: imx: support suspend states on imx7D</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; On Tue, Sep 08, 2015 at 03:01:07PM +0000, Shenwei Wang wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/Kconfig        |   1 +</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/Makefile       |   2 +</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/common.h       |   4 +</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/pm-imx7.c      | 917</span>
<span class="quote">&gt; &gt; &gt; &gt; +++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/suspend-imx7.S | 529 ++++++++++++++++++++++</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  5 files changed, 1453 insertions(+)</span>
<span class="quote">&gt; &gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; &gt; 1453 lines addition to kernel only for i.MX7D suspend support.  Yes,</span>
<span class="quote">&gt; &gt; &gt; &gt; this is the way we support suspend on i.MX6, but that&#39;s enough, and</span>
<span class="quote">&gt; &gt; &gt; &gt; we have to stop this somewhere.  I would ask you to take Sudeep&#39;s</span>
<span class="quote">&gt; &gt; &gt; &gt; comment and adopt PSCI for i.MX7D power management.</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; According to PSCI spec, a supervisory software must be implemented</span>
<span class="quote">&gt; &gt; &gt; under either</span>
<span class="quote">&gt; &gt; &gt; HVC(EL2) or SMC(EL3) privilege level. I agree that, with this idea, we</span>
<span class="quote">&gt; &gt; &gt; could finally move these 1453 lines of codes from kernel into a</span>
<span class="quote">&gt; &gt; &gt; platform specific firmware. The problem is we don&#39;t have the firmware</span>
<span class="quote">&gt; &gt; &gt; so far, and we haven&#39;t even had a plan to enable the hypervisor or</span>
<span class="quote">&gt; &gt; &gt; secure software on this platform. Because low power consumption is the</span>
<span class="quote">&gt; &gt; &gt; key feature of this i.MX7D platform, please continue to consider the current</span>
<span class="quote">&gt; &gt; implementation and get this feature supported first.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Can&#39;t U-Boot be considered as a firmware to implement PSCI?  I have seen an</span>
<span class="quote">&gt; &gt; initial ARMv7 PSCI core support for U-Boot added by Marc Zyngier.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The current PSCI support in uboot is not complete. It can now support cpuidle, shutdown, </span>
<span class="quote">&gt; and reset. But to support system suspend, there would be a lot more tasks. For example,</span>
<span class="quote">&gt; even the current wakeup source management codes will have to move into the firmware </span>
<span class="quote">&gt; too. It is not a short time task. Please continue to consider this platform dependent implementation</span>
<span class="quote">&gt; first, meanwhile, we will start to migrate the solution to PSCI. However it will take some time.</span>

I have zero interest to maintain this pile of code in the mainline
kernel.  Take it as a motivation to move to PSCI soon, or you maintain
it on your own as a out-of-tree patch for whatever long time you like.

Shawn
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=52451">Frank Li</a> - Oct. 1, 2015, 4:31 p.m.</div>
<pre class="content">
On Fri, Sep 18, 2015 at 8:12 PM, Shawn Guo &lt;shawnguo@kernel.org&gt; wrote:
<span class="quote">&gt; On Fri, Sep 18, 2015 at 02:38:39PM +0000, Shenwei Wang wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt; -----Original Message-----</span>
<span class="quote">&gt;&gt; &gt; From: Shawn Guo [mailto:shawnguo@kernel.org]</span>
<span class="quote">&gt;&gt; &gt; Sent: 2015?9?18? 9:15</span>
<span class="quote">&gt;&gt; &gt; To: Wang Shenwei-B38339</span>
<span class="quote">&gt;&gt; &gt; Cc: jason@lakedaemon.net; Huang Yongcai-B20788;</span>
<span class="quote">&gt;&gt; &gt; linux-kernel@vger.kernel.org; kernel@pengutronix.de; Sudeep Holla;</span>
<span class="quote">&gt;&gt; &gt; tglx@linutronix.de; shawn.guo@linaro.org; linux-arm-kernel@lists.infradead.org</span>
<span class="quote">&gt;&gt; &gt; Subject: Re: [PATCH v8 2/2] ARM: imx: support suspend states on imx7D</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; On Tue, Sep 08, 2015 at 03:01:07PM +0000, Shenwei Wang wrote:</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/Kconfig        |   1 +</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/Makefile       |   2 +</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/common.h       |   4 +</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/pm-imx7.c      | 917</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; +++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; &gt;  arch/arm/mach-imx/suspend-imx7.S | 529 ++++++++++++++++++++++</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; &gt;  5 files changed, 1453 insertions(+)</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; 1453 lines addition to kernel only for i.MX7D suspend support.  Yes,</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; this is the way we support suspend on i.MX6, but that&#39;s enough, and</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; we have to stop this somewhere.  I would ask you to take Sudeep&#39;s</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; comment and adopt PSCI for i.MX7D power management.</span>
<span class="quote">&gt;&gt; &gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; &gt; According to PSCI spec, a supervisory software must be implemented</span>
<span class="quote">&gt;&gt; &gt; &gt; under either</span>
<span class="quote">&gt;&gt; &gt; &gt; HVC(EL2) or SMC(EL3) privilege level. I agree that, with this idea, we</span>
<span class="quote">&gt;&gt; &gt; &gt; could finally move these 1453 lines of codes from kernel into a</span>
<span class="quote">&gt;&gt; &gt; &gt; platform specific firmware. The problem is we don&#39;t have the firmware</span>
<span class="quote">&gt;&gt; &gt; &gt; so far, and we haven&#39;t even had a plan to enable the hypervisor or</span>
<span class="quote">&gt;&gt; &gt; &gt; secure software on this platform. Because low power consumption is the</span>
<span class="quote">&gt;&gt; &gt; &gt; key feature of this i.MX7D platform, please continue to consider the current</span>
<span class="quote">&gt;&gt; &gt; implementation and get this feature supported first.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; Can&#39;t U-Boot be considered as a firmware to implement PSCI?  I have seen an</span>
<span class="quote">&gt;&gt; &gt; initial ARMv7 PSCI core support for U-Boot added by Marc Zyngier.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The current PSCI support in uboot is not complete. It can now support cpuidle, shutdown,</span>
<span class="quote">&gt;&gt; and reset. But to support system suspend, there would be a lot more tasks. For example,</span>
<span class="quote">&gt;&gt; even the current wakeup source management codes will have to move into the firmware</span>
<span class="quote">&gt;&gt; too. It is not a short time task. Please continue to consider this platform dependent implementation</span>
<span class="quote">&gt;&gt; first, meanwhile, we will start to migrate the solution to PSCI. However it will take some time.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I have zero interest to maintain this pile of code in the mainline</span>
<span class="quote">&gt; kernel.  Take it as a motivation to move to PSCI soon, or you maintain</span>
<span class="quote">&gt; it on your own as a out-of-tree patch for whatever long time you like.</span>
<span class="quote">&gt;</span>

Does it means that SMP support also need go through PSCI?

best regards
Frank Li
<span class="quote">
&gt; Shawn</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; _______________________________________________</span>
<span class="quote">&gt; linux-arm-kernel mailing list</span>
<span class="quote">&gt; linux-arm-kernel@lists.infradead.org</span>
<span class="quote">&gt; http://lists.infradead.org/mailman/listinfo/linux-arm-kernel</span>
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131511">Shawn Guo</a> - Oct. 8, 2015, 6:37 a.m.</div>
<pre class="content">
On Thu, Oct 01, 2015 at 11:31:11AM -0500, Zhi Li wrote:
<span class="quote">&gt; On Fri, Sep 18, 2015 at 8:12 PM, Shawn Guo &lt;shawnguo@kernel.org&gt; wrote:</span>
<span class="quote">&gt; &gt; I have zero interest to maintain this pile of code in the mainline</span>
<span class="quote">&gt; &gt; kernel.  Take it as a motivation to move to PSCI soon, or you maintain</span>
<span class="quote">&gt; &gt; it on your own as a out-of-tree patch for whatever long time you like.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Does it means that SMP support also need go through PSCI?</span>

Yes, please.

Shawn
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">index 8ceda28..54f8553 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Kconfig</span>
<span class="p_chunk">@@ -562,6 +562,7 @@</span> <span class="p_context"> config SOC_IMX7D</span>
 	select ARM_GIC
 	select HAVE_IMX_ANATOP
 	select HAVE_IMX_MMDC
<span class="p_add">+	select IMX_GPCV2</span>
 	help
 		This enables support for Freescale i.MX7 Dual processor.
 
<span class="p_header">diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile</span>
<span class="p_header">index fb689d8..60f13fd 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Makefile</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Makefile</span>
<span class="p_chunk">@@ -88,6 +88,8 @@</span> <span class="p_context"> obj-$(CONFIG_SOC_IMX7D) += mach-imx7d.o</span>
 
 ifeq ($(CONFIG_SUSPEND),y)
 AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a
<span class="p_add">+AFLAGS_suspend-imx7.o :=-Wa,-march=armv7-a</span>
<span class="p_add">+obj-$(CONFIG_SOC_IMX7D)	+= suspend-imx7.o pm-imx7.o</span>
 obj-$(CONFIG_SOC_IMX6) += suspend-imx6.o
 obj-$(CONFIG_SOC_IMX53) += suspend-imx53.o
 endif
<span class="p_header">diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h</span>
<span class="p_header">index 21e4e86..c5767f4 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/common.h</span>
<span class="p_header">+++ b/arch/arm/mach-imx/common.h</span>
<span class="p_chunk">@@ -126,6 +126,10 @@</span> <span class="p_context"> static const u32 imx53_suspend_sz;</span>
 static inline void imx6_suspend(void __iomem *ocram_vbase) {}
 #endif
 
<span class="p_add">+void ca7_cpu_resume(void);</span>
<span class="p_add">+void imx7_suspend(void __iomem *ocram_vbase);</span>
<span class="p_add">+u32 imx_gpcv2_get_wakeup_source(u32 **sources);</span>
<span class="p_add">+</span>
 void imx6_pm_ccm_init(const char *ccm_compat);
 void imx6q_pm_init(void);
 void imx6dl_pm_init(void);
<span class="p_header">diff --git a/arch/arm/mach-imx/pm-imx7.c b/arch/arm/mach-imx/pm-imx7.c</span>
new file mode 100644
<span class="p_header">index 0000000..052c2cb</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="p_chunk">@@ -0,0 +1,917 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/mfd/syscon.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/regmap.h&gt;</span>
<span class="p_add">+#include &lt;linux/suspend.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;asm/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/fncpy.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;common.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_LPCR_A7_BSC		0x0</span>
<span class="p_add">+#define GPC_LPCR_A7_AD		0x4</span>
<span class="p_add">+#define GPC_LPCR_M4		0x8</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_SLPCR		0x14</span>
<span class="p_add">+#define GPC_PGC_ACK_SEL_A7	0x24</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_SLOTx_CFG(x) 	(0xb0 + 4 * (x))</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_PGC_CPU_MAPPING	0xec</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_PGC_C0		0x800</span>
<span class="p_add">+#define GPC_PGC_C1		0x840</span>
<span class="p_add">+#define GPC_PGC_SCU		0x880</span>
<span class="p_add">+#define GPC_PGC_SCU_TIMING	0x890</span>
<span class="p_add">+#define GPC_PGC_FM		0xa00</span>
<span class="p_add">+#define GPC_PGC_MIPI_PHY	0xc00</span>
<span class="p_add">+#define GPC_PGC_PCIE_PHY	0xc40</span>
<span class="p_add">+#define GPC_PGC_USB_OTG1_PHY	0xc80</span>
<span class="p_add">+#define GPC_PGC_USB_OTG2_PHY	0xcc0</span>
<span class="p_add">+#define GPC_PGC_USB_HSIC_PHY	0xd00</span>
<span class="p_add">+</span>
<span class="p_add">+#define ANADIG_ARM_PLL		0x60</span>
<span class="p_add">+#define ANADIG_DDR_PLL		0x70</span>
<span class="p_add">+#define ANADIG_SYS_PLL		0xb0</span>
<span class="p_add">+#define ANADIG_ENET_PLL		0xe0</span>
<span class="p_add">+#define ANADIG_AUDIO_PLL	0xf0</span>
<span class="p_add">+#define ANADIG_VIDEO_PLL	0x130</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_LPCR_A7_AD_L2PGE			(0x1 &lt;&lt; 16)</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C1_PUP			(0x1 &lt;&lt; 11)</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C1_IRQ_PUP		(0x1 &lt;&lt; 10)</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C0_PUP			(0x1 &lt;&lt; 9)</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C0_IRQ_PUP		(0x1 &lt;&lt; 8)</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_PLAT_PDN		(0x1 &lt;&lt; 4)</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C1_PDN			(0x1 &lt;&lt; 3)</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C1_WFI_PDN		(0x1 &lt;&lt; 2)</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C0_PDN			(0x1 &lt;&lt; 1)</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C0_WFI_PDN		(0x1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP	(0x7 &lt;&lt; 28)</span>
<span class="p_add">+#define BM_LPCR_A7_BSC_CPU_CLK_ON_LPM		(0x1 &lt;&lt; 14)</span>
<span class="p_add">+#define BM_LPCR_A7_BSC_LPM1			(0x3 &lt;&lt; 2)</span>
<span class="p_add">+#define BM_LPCR_A7_BSC_LPM0			(0x3)</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_LPCR_M4_MASK_DSM_TRIGGER		(0x1 &lt;&lt; 31)</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_SLPCR_EN_DSM				(0x1 &lt;&lt; 31)</span>
<span class="p_add">+#define BM_SLPCR_RBC_EN				(0x1 &lt;&lt; 30)</span>
<span class="p_add">+#define BM_SLPCR_VSTBY				(0x1 &lt;&lt; 2)</span>
<span class="p_add">+#define BM_SLPCR_SBYOS				(0x1 &lt;&lt; 1)</span>
<span class="p_add">+#define BM_SLPCR_BYPASS_PMIC_READY		(0x1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP		(0x1 &lt;&lt; 31)</span>
<span class="p_add">+#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN		(0x1 &lt;&lt; 15)</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_ANADIG_ARM_PLL_OVERRIDE		(0x1 &lt;&lt; 20)</span>
<span class="p_add">+#define BM_ANADIG_DDR_PLL_OVERRIDE		(0x1 &lt;&lt; 19)</span>
<span class="p_add">+#define BM_ANADIG_SYS_PLL_PFDx_OVERRIDE		(0x1FF &lt;&lt; 17)</span>
<span class="p_add">+#define BM_ANADIG_ENET_PLL_OVERRIDE		(0x1 &lt;&lt; 13)</span>
<span class="p_add">+#define BM_ANADIG_AUDIO_PLL_OVERRIDE		(0x1 &lt;&lt; 24)</span>
<span class="p_add">+#define BM_ANADIG_VIDEO_PLL_OVERRIDE		(0x1 &lt;&lt; 24)</span>
<span class="p_add">+</span>
<span class="p_add">+#define A7_LPM_WAIT		0x5</span>
<span class="p_add">+#define A7_LPM_STOP		0xa</span>
<span class="p_add">+#define GPC_MAX_SLOT_NUMBER	10</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_SET			0x4</span>
<span class="p_add">+#define REG_CLR			0x8</span>
<span class="p_add">+</span>
<span class="p_add">+#define MX7_MAX_DDRC_NUM		32</span>
<span class="p_add">+#define MX7_MAX_DDRC_PHY_NUM		16</span>
<span class="p_add">+</span>
<span class="p_add">+#define READ_DATA_FROM_HARDWARE		0</span>
<span class="p_add">+#define MX7_SUSPEND_OCRAM_SIZE		0x1000</span>
<span class="p_add">+</span>
<span class="p_add">+enum gpcv2_mode {</span>
<span class="p_add">+	GPC_WAIT_CLOCKED,</span>
<span class="p_add">+	GPC_WAIT_UNCLOCKED,</span>
<span class="p_add">+	GPC_STOP_POWER_ON,</span>
<span class="p_add">+	GPC_STOP_POWER_OFF,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * GPCv2 has the following power domains, and each domain can be power-up</span>
<span class="p_add">+ * and power-down via GPC settings.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * 	Core 0 of A7 power domain</span>
<span class="p_add">+ * 	Core1 of A7 power domain</span>
<span class="p_add">+ * 	SCU/L2 cache RAM of A7 power domain</span>
<span class="p_add">+ * 	Fastmix and megamix power domain</span>
<span class="p_add">+ * 	USB OTG1 PHY power domain</span>
<span class="p_add">+ * 	USB OTG2 PHY power domain</span>
<span class="p_add">+ * 	PCIE PHY power domain</span>
<span class="p_add">+ * 	USB HSIC PHY power domain</span>
<span class="p_add">+ *	Core 0 of M4 power domain</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+enum gpcv2_slot {</span>
<span class="p_add">+	CORE0_A7,</span>
<span class="p_add">+	CORE1_A7,</span>
<span class="p_add">+	SCU_A7,</span>
<span class="p_add">+	FAST_MEGA_MIX,</span>
<span class="p_add">+	MIPI_PHY,</span>
<span class="p_add">+	PCIE_PHY,</span>
<span class="p_add">+	USB_OTG1_PHY,</span>
<span class="p_add">+	USB_OTG2_PHY,</span>
<span class="p_add">+	USB_HSIC_PHY,</span>
<span class="p_add">+	CORE0_M4,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx_gpcv2;</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx_gpcv2_suspend {</span>
<span class="p_add">+	void (*set_mode)(struct imx_gpcv2 *, enum gpcv2_mode mode);</span>
<span class="p_add">+	void (*lpm_cpu_power_gate)(struct imx_gpcv2 *, u32, bool);</span>
<span class="p_add">+	void (*lpm_plat_power_gate)(struct imx_gpcv2 *, bool);</span>
<span class="p_add">+	void (*lpm_env_setup)(struct imx_gpcv2 *);</span>
<span class="p_add">+	void (*lpm_env_clean)(struct imx_gpcv2 *);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*set_slot)(struct imx_gpcv2 *cd, u32 index,</span>
<span class="p_add">+			enum gpcv2_slot slot, bool mode);</span>
<span class="p_add">+	void (*set_act)(struct imx_gpcv2 *cd,</span>
<span class="p_add">+			enum gpcv2_slot slot, bool mode);</span>
<span class="p_add">+	void (*clear_slots)(struct imx_gpcv2 *);</span>
<span class="p_add">+	void (*lpm_enable_core)(struct imx_gpcv2 *,</span>
<span class="p_add">+			bool enable, u32 offset);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*standby)(struct imx_gpcv2 *);</span>
<span class="p_add">+	void (*suspend)(struct imx_gpcv2 *);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*suspend_fn_in_ocram)(void __iomem *ocram_vbase);</span>
<span class="p_add">+	void __iomem *ocram_vbase;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx_gpcv2 {</span>
<span class="p_add">+	u32 *wakeupmix_mask;</span>
<span class="p_add">+	u32 *lpsrmix_mask;</span>
<span class="p_add">+	u32 *mfmix_mask;</span>
<span class="p_add">+	spinlock_t lock;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm;</span>
<span class="p_add">+	struct regmap *anatop;</span>
<span class="p_add">+	struct regmap *gpcv2;</span>
<span class="p_add">+</span>
<span class="p_add">+	u32 (*get_wakeup_source)(u32 **);</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx7_pm_base {</span>
<span class="p_add">+	phys_addr_t pbase;</span>
<span class="p_add">+	void __iomem *vbase;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx7_pm_socdata {</span>
<span class="p_add">+	u32 ddr_type;</span>
<span class="p_add">+	const char *ddrc_compat;</span>
<span class="p_add">+	const char *ddrc_phy_compat;</span>
<span class="p_add">+	const char *src_compat;</span>
<span class="p_add">+	const char *iomuxc_gpr_compat;</span>
<span class="p_add">+	const char *ccm_compat;</span>
<span class="p_add">+	const char *gpc_compat;</span>
<span class="p_add">+	const char *anatop_compat;</span>
<span class="p_add">+	const u32 ddrc_num;</span>
<span class="p_add">+	const u32 (*ddrc_offset)[2];</span>
<span class="p_add">+	const u32 ddrc_phy_num;</span>
<span class="p_add">+	const u32 (*ddrc_phy_offset)[2];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This structure is for passing necessary data for low level ocram</span>
<span class="p_add">+ * suspend code(arch/arm/mach-imx/suspend-imx7.S), if this struct</span>
<span class="p_add">+ * definition is changed, the offset definition in</span>
<span class="p_add">+ * arch/arm/mach-imx/suspend-imx7.S must be also changed accordingly,</span>
<span class="p_add">+ * otherwise, the suspend to ocram function will be broken!</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx7_cpu_pm_info {</span>
<span class="p_add">+	u32 m4_reserve0;</span>
<span class="p_add">+	u32 m4_reserve1;</span>
<span class="p_add">+	u32 m4_reserve2;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The physical address of pm_info. */</span>
<span class="p_add">+	phys_addr_t pbase;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The physical resume address for asm code */</span>
<span class="p_add">+	phys_addr_t resume_addr;</span>
<span class="p_add">+	u32 ddr_type;</span>
<span class="p_add">+</span>
<span class="p_add">+	u32 pm_info_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct imx7_pm_base ddrc_base;</span>
<span class="p_add">+	struct imx7_pm_base ddrc_phy_base;</span>
<span class="p_add">+	struct imx7_pm_base src_base;</span>
<span class="p_add">+	struct imx7_pm_base iomuxc_gpr_base;</span>
<span class="p_add">+	struct imx7_pm_base ccm_base;</span>
<span class="p_add">+	struct imx7_pm_base gpc_base;</span>
<span class="p_add">+	struct imx7_pm_base l2_base;</span>
<span class="p_add">+	struct imx7_pm_base anatop_base;</span>
<span class="p_add">+</span>
<span class="p_add">+	u32 ttbr1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Number of DDRC which need saved/restored. */</span>
<span class="p_add">+	u32 ddrc_num;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* To save offset and value */</span>
<span class="p_add">+	u32 ddrc_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Number of DDRC which need saved/restored. */</span>
<span class="p_add">+	u32 ddrc_phy_num;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* To save offset and value */</span>
<span class="p_add">+	u32 ddrc_phy_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="p_add">+} __aligned(8);</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 imx7d_ddrc_ddr3_setting[][2] __initconst = {</span>
<span class="p_add">+	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a8, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x64, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x490, 0x00000001 },</span>
<span class="p_add">+	{ 0xd0, 0xc0020001 },</span>
<span class="p_add">+	{ 0xd4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xdc, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xe0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xe4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xf4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x100, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x104, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x108, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x10c, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x110, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x114, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x120, 0x03030803 },</span>
<span class="p_add">+	{ 0x180, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x190, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x194, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x200, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x204, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x214, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x218, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x240, 0x06000601 },</span>
<span class="p_add">+	{ 0x244, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 imx7d_ddrc_phy_ddr3_setting[][2] __initconst = {</span>
<span class="p_add">+	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x10, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x9c, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x20, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x30, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x50, 0x01000010 },</span>
<span class="p_add">+	{ 0x50, 0x00000010 },</span>
<span class="p_add">+	{ 0xc0, 0x0e407304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447306 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e407306 },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct imx7_pm_socdata imx7d_pm_data_ddr3 __initconst = {</span>
<span class="p_add">+	.iomuxc_gpr_compat = &quot;fsl,imx7d-iomuxc&quot;,</span>
<span class="p_add">+	.ddrc_phy_compat = &quot;fsl,imx7d-ddrc-phy&quot;,</span>
<span class="p_add">+	.anatop_compat = &quot;fsl,imx7d-anatop&quot;,</span>
<span class="p_add">+	.ddrc_compat = &quot;fsl,imx7d-ddrc&quot;,</span>
<span class="p_add">+	.ccm_compat = &quot;fsl,imx7d-ccm&quot;,</span>
<span class="p_add">+	.src_compat = &quot;fsl,imx7d-src&quot;,</span>
<span class="p_add">+	.gpc_compat = &quot;fsl,imx7d-gpc&quot;,</span>
<span class="p_add">+	.ddrc_phy_num = ARRAY_SIZE(imx7d_ddrc_phy_ddr3_setting),</span>
<span class="p_add">+	.ddrc_phy_offset = imx7d_ddrc_phy_ddr3_setting,</span>
<span class="p_add">+	.ddrc_num = ARRAY_SIZE(imx7d_ddrc_ddr3_setting),</span>
<span class="p_add">+	.ddrc_offset = imx7d_ddrc_ddr3_setting,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct imx_gpcv2 *gpcv2_instance;</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_clear_slots(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; GPC_MAX_SLOT_NUMBER; i++)</span>
<span class="p_add">+		regmap_write(gpc-&gt;gpcv2, GPC_SLOTx_CFG(i), 0x0);</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_PGC_ACK_SEL_A7,</span>
<span class="p_add">+			BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP |</span>
<span class="p_add">+			BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_enable_core(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+			bool enable, u32 offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, offset, enable);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_slot_setup(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+		u32 index, enum gpcv2_slot slot, bool powerup)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (index &gt;= GPC_MAX_SLOT_NUMBER) {</span>
<span class="p_add">+		pr_err(&quot;Invalid slot index!\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (powerup ? 0x2 : 0x1) &lt;&lt; (slot * 2);</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_SLOTx_CFG(index), val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_set_ack(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+		enum gpcv2_slot slot, bool powerup)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_read(gpc-&gt;gpcv2, GPC_PGC_ACK_SEL_A7, &amp;val);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear dummy ack */</span>
<span class="p_add">+	val &amp;= ~(powerup ? BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP :</span>
<span class="p_add">+				BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN);</span>
<span class="p_add">+</span>
<span class="p_add">+	val |= 1 &lt;&lt; (slot + (powerup ? 16 : 0));</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_PGC_ACK_SEL_A7, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_env_setup(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* PLL and PFDs overwrite set */</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_ARM_PLL + REG_SET,</span>
<span class="p_add">+			BM_ANADIG_ARM_PLL_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_DDR_PLL + REG_SET,</span>
<span class="p_add">+			BM_ANADIG_DDR_PLL_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_SYS_PLL + REG_SET,</span>
<span class="p_add">+			BM_ANADIG_SYS_PLL_PFDx_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_ENET_PLL + REG_SET,</span>
<span class="p_add">+			BM_ANADIG_ENET_PLL_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_AUDIO_PLL + REG_SET,</span>
<span class="p_add">+			BM_ANADIG_AUDIO_PLL_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_VIDEO_PLL + REG_SET,</span>
<span class="p_add">+			BM_ANADIG_VIDEO_PLL_OVERRIDE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_env_clean(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* PLL and PFDs overwrite clear */</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_ARM_PLL + REG_CLR,</span>
<span class="p_add">+			BM_ANADIG_ARM_PLL_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_DDR_PLL + REG_CLR,</span>
<span class="p_add">+			BM_ANADIG_DDR_PLL_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_SYS_PLL + REG_CLR,</span>
<span class="p_add">+			BM_ANADIG_SYS_PLL_PFDx_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_ENET_PLL + REG_CLR,</span>
<span class="p_add">+			BM_ANADIG_ENET_PLL_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_AUDIO_PLL + REG_CLR,</span>
<span class="p_add">+			BM_ANADIG_AUDIO_PLL_OVERRIDE);</span>
<span class="p_add">+	regmap_write(gpc-&gt;anatop, ANADIG_VIDEO_PLL + REG_CLR,</span>
<span class="p_add">+			BM_ANADIG_VIDEO_PLL_OVERRIDE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_set_mode(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+		enum gpcv2_mode mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 lpcr, slpcr;</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_A7_BSC, &amp;lpcr);</span>
<span class="p_add">+	regmap_read(gpc-&gt;gpcv2, GPC_SLPCR, &amp;slpcr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all cores&#39; LPM settings must be same */</span>
<span class="p_add">+	lpcr &amp;= ~(BM_LPCR_A7_BSC_LPM0 | BM_LPCR_A7_BSC_LPM1);</span>
<span class="p_add">+	lpcr |= BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+</span>
<span class="p_add">+	slpcr &amp;= ~(BM_SLPCR_EN_DSM | BM_SLPCR_VSTBY | BM_SLPCR_RBC_EN |</span>
<span class="p_add">+		BM_SLPCR_SBYOS | BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (mode) {</span>
<span class="p_add">+	case GPC_WAIT_CLOCKED:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case GPC_WAIT_UNCLOCKED:</span>
<span class="p_add">+		lpcr |= A7_LPM_WAIT;</span>
<span class="p_add">+		lpcr &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case GPC_STOP_POWER_ON:</span>
<span class="p_add">+		lpcr |= A7_LPM_STOP;</span>
<span class="p_add">+		lpcr &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		slpcr |= (BM_SLPCR_EN_DSM | BM_SLPCR_RBC_EN |</span>
<span class="p_add">+			BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case GPC_STOP_POWER_OFF:</span>
<span class="p_add">+		lpcr |= A7_LPM_STOP;</span>
<span class="p_add">+		lpcr &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		slpcr |= (BM_SLPCR_EN_DSM | BM_SLPCR_RBC_EN |</span>
<span class="p_add">+			BM_SLPCR_SBYOS | BM_SLPCR_VSTBY  |</span>
<span class="p_add">+			BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_A7_BSC, lpcr);</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_SLPCR, slpcr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_cpu_power_gate(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+				u32 cpu, bool engate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	const u32 val_pdn[2] = {</span>
<span class="p_add">+		BM_LPCR_A7_AD_EN_C0_PDN | BM_LPCR_A7_AD_EN_C0_PUP,</span>
<span class="p_add">+		BM_LPCR_A7_AD_EN_C1_PDN | BM_LPCR_A7_AD_EN_C1_PUP,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_A7_AD, &amp;val);</span>
<span class="p_add">+	if (engate)</span>
<span class="p_add">+		val |= val_pdn[cpu];</span>
<span class="p_add">+	else</span>
<span class="p_add">+		val &amp;= ~val_pdn[cpu];</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_A7_AD, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_lpm_plat_power_gate(struct imx_gpcv2 *gpc, bool engate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_A7_AD, &amp;val);</span>
<span class="p_add">+	val &amp;= ~(BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE);</span>
<span class="p_add">+	if (engate)</span>
<span class="p_add">+		val |= BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE;</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_A7_AD, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_standby(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_setup(gpc);</span>
<span class="p_add">+	/* pm-&gt;set_mode(gpc, GPC_STOP_POWER_OFF); */</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, GPC_WAIT_UNCLOCKED);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Zzz ... */</span>
<span class="p_add">+	cpu_do_idle();</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, GPC_WAIT_CLOCKED);</span>
<span class="p_add">+	pm-&gt;lpm_env_clean(gpc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int gpcv2_suspend_finish(unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = (struct imx_gpcv2_suspend *)val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pm-&gt;suspend_fn_in_ocram) {</span>
<span class="p_add">+		cpu_do_idle();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * call low level suspend function in ocram,</span>
<span class="p_add">+		 * as we need to float DDR IO.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		local_flush_tlb_all();</span>
<span class="p_add">+		pm-&gt;suspend_fn_in_ocram(pm-&gt;ocram_vbase);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_suspend(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+	u32 *sources;</span>
<span class="p_add">+	int i, num;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_setup(gpc);</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, GPC_STOP_POWER_OFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable core0 power down/up with low power mode */</span>
<span class="p_add">+	pm-&gt;lpm_cpu_power_gate(gpc, 0, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable plat power down with low power mode */</span>
<span class="p_add">+	pm-&gt;lpm_plat_power_gate(gpc, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * To avoid confuse, we use slot 0~4 for power down,</span>
<span class="p_add">+	 * slot 5~9 for power up.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Power down slot sequence:</span>
<span class="p_add">+	 * Slot0 -&gt; CORE0</span>
<span class="p_add">+	 * Slot1 -&gt; Mega/Fast MIX</span>
<span class="p_add">+	 * Slot2 -&gt; SCU</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Power up slot sequence:</span>
<span class="p_add">+	 * Slot5 -&gt; Mega/Fast MIX</span>
<span class="p_add">+	 * Slot6 -&gt; SCU</span>
<span class="p_add">+	 * Slot7 -&gt; CORE0</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 0, CORE0_A7, false);</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 2, SCU_A7, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (gpc-&gt;get_wakeup_source) {</span>
<span class="p_add">+		pm-&gt;set_slot(gpc, 1, FAST_MEGA_MIX, false);</span>
<span class="p_add">+		pm-&gt;set_slot(gpc, 5, FAST_MEGA_MIX, true);</span>
<span class="p_add">+		pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_FM);</span>
<span class="p_add">+		num = gpc-&gt;get_wakeup_source(&amp;sources);</span>
<span class="p_add">+		for (i = 0; i &lt; num; i++) {</span>
<span class="p_add">+			if ((~sources[i] &amp; gpc-&gt;mfmix_mask[i]) == 0)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_FM);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 6, SCU_A7, true);</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 7, CORE0_A7, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set Power down act */</span>
<span class="p_add">+	pm-&gt;set_act(gpc, SCU_A7, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set Power up act */</span>
<span class="p_add">+	pm-&gt;set_act(gpc, CORE0_A7, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable core0, scu */</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_C0);</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_SCU);</span>
<span class="p_add">+</span>
<span class="p_add">+	cpu_suspend((unsigned long)pm, gpcv2_suspend_finish);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_clean(gpc);</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, GPC_WAIT_CLOCKED);</span>
<span class="p_add">+	pm-&gt;lpm_cpu_power_gate(gpc, 0, false);</span>
<span class="p_add">+	pm-&gt;lpm_plat_power_gate(gpc, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_C0);</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_SCU);</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_FM);</span>
<span class="p_add">+	pm-&gt;clear_slots(gpc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int imx_gpcv2_pm_enter(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!gpcv2_instance);</span>
<span class="p_add">+	pm = gpcv2_instance-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (state) {</span>
<span class="p_add">+	case PM_SUSPEND_STANDBY:</span>
<span class="p_add">+		pm-&gt;standby(gpcv2_instance);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case PM_SUSPEND_MEM:</span>
<span class="p_add">+		pm-&gt;suspend(gpcv2_instance);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int imx_gpcv2_pm_valid(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_base_from_node(struct device_node *node,</span>
<span class="p_add">+			struct imx7_pm_base *base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="p_add">+	if (!base-&gt;vbase) {</span>
<span class="p_add">+		iounmap(base-&gt;vbase);</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_base_from_dt(struct imx7_pm_base *base,</span>
<span class="p_add">+				const char *compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="p_add">+	if (!base-&gt;vbase)</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_exec_base_from_dt(struct imx7_pm_base *base,</span>
<span class="p_add">+				const char *compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = __arm_ioremap_exec(res.start, resource_size(&amp;res), false);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!base-&gt;vbase)</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_gpcv2_suspend_init(struct imx_gpcv2_suspend *pm,</span>
<span class="p_add">+			const struct imx7_pm_socdata *socdata)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx7_pm_base aips_base[3] = { {0, 0}, {0, 0}, {0, 0} };</span>
<span class="p_add">+	struct imx7_pm_base sram_base = {0, 0};</span>
<span class="p_add">+	struct imx7_cpu_pm_info *pm_info;</span>
<span class="p_add">+	struct device_node *node = NULL;</span>
<span class="p_add">+	int i, ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	const u32 (*ddrc_phy_offset_array)[2];</span>
<span class="p_add">+	const u32 (*ddrc_offset_array)[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!socdata || !pm) {</span>
<span class="p_add">+		pr_warn(&quot;%s: invalid argument!\n&quot;, __func__);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; 3; i++) {</span>
<span class="p_add">+		node = of_find_compatible_node(node, NULL, &quot;fsl,aips-bus&quot;);</span>
<span class="p_add">+		if (!node) {</span>
<span class="p_add">+			pr_warn(&quot;%s: failed to find aips %d node!\n&quot;,</span>
<span class="p_add">+					__func__, i);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ret = imx_get_base_from_node(node, &amp;aips_base[i]);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			pr_warn(&quot;%s: failed to get aips[%d] base %d!\n&quot;,</span>
<span class="p_add">+					__func__, i, ret);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_exec_base_from_dt(&amp;sram_base, &quot;fsl,lpm-sram&quot;);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get lpm-sram base %d!\n&quot;,</span>
<span class="p_add">+				__func__, ret);</span>
<span class="p_add">+		goto lpm_sram_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info = sram_base.vbase;</span>
<span class="p_add">+	pm_info-&gt;pbase = sram_base.pbase;</span>
<span class="p_add">+	pm_info-&gt;resume_addr = virt_to_phys(ca7_cpu_resume);</span>
<span class="p_add">+	pm_info-&gt;pm_info_size = sizeof(*pm_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ccm_base, socdata-&gt;ccm_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ccm base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ccm_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_base, socdata-&gt;ddrc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ddrc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ddrc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_phy_base,</span>
<span class="p_add">+				socdata-&gt;ddrc_phy_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ddrc_phy base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ddrc_phy_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;src_base, socdata-&gt;src_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get src base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto src_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;iomuxc_gpr_base,</span>
<span class="p_add">+				socdata-&gt;iomuxc_gpr_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get iomuxc_gpr base %d!\n&quot;,</span>
<span class="p_add">+					__func__, ret);</span>
<span class="p_add">+		goto iomuxc_gpr_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;gpc_base, socdata-&gt;gpc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get gpc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto gpc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;anatop_base,</span>
<span class="p_add">+				socdata-&gt;anatop_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get anatop base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto anatop_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info-&gt;ddrc_num = socdata-&gt;ddrc_num;</span>
<span class="p_add">+	ddrc_offset_array = socdata-&gt;ddrc_offset;</span>
<span class="p_add">+	pm_info-&gt;ddrc_phy_num = socdata-&gt;ddrc_phy_num;</span>
<span class="p_add">+	ddrc_phy_offset_array = socdata-&gt;ddrc_phy_offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* initialize DDRC settings */</span>
<span class="p_add">+	for (i = 0; i &lt; pm_info-&gt;ddrc_num; i++) {</span>
<span class="p_add">+		pm_info-&gt;ddrc_val[i][0] = ddrc_offset_array[i][0];</span>
<span class="p_add">+		if (ddrc_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="p_add">+			pm_info-&gt;ddrc_val[i][1] =</span>
<span class="p_add">+				readl_relaxed(pm_info-&gt;ddrc_base.vbase +</span>
<span class="p_add">+				ddrc_offset_array[i][0]);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pm_info-&gt;ddrc_val[i][1] = ddrc_offset_array[i][1];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* initialize DDRC PHY settings */</span>
<span class="p_add">+	for (i = 0; i &lt; pm_info-&gt;ddrc_phy_num; i++) {</span>
<span class="p_add">+		pm_info-&gt;ddrc_phy_val[i][0] =</span>
<span class="p_add">+			ddrc_phy_offset_array[i][0];</span>
<span class="p_add">+		if (ddrc_phy_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="p_add">+			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="p_add">+				readl_relaxed(pm_info-&gt;ddrc_phy_base.vbase +</span>
<span class="p_add">+				ddrc_phy_offset_array[i][0]);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="p_add">+				ddrc_phy_offset_array[i][1];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;suspend_fn_in_ocram = fncpy(</span>
<span class="p_add">+		sram_base.vbase + sizeof(*pm_info),</span>
<span class="p_add">+		&amp;imx7_suspend,</span>
<span class="p_add">+		MX7_SUSPEND_OCRAM_SIZE - sizeof(*pm_info));</span>
<span class="p_add">+	pm-&gt;ocram_vbase = sram_base.vbase;</span>
<span class="p_add">+</span>
<span class="p_add">+	goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+anatop_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;anatop_base.vbase);</span>
<span class="p_add">+gpc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;gpc_base.vbase);</span>
<span class="p_add">+iomuxc_gpr_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;iomuxc_gpr_base.vbase);</span>
<span class="p_add">+src_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;src_base.vbase);</span>
<span class="p_add">+ddrc_phy_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ddrc_phy_base.vbase);</span>
<span class="p_add">+ddrc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ddrc_base.vbase);</span>
<span class="p_add">+ccm_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ccm_base.vbase);</span>
<span class="p_add">+lpm_sram_map_failed:</span>
<span class="p_add">+	iounmap(sram_base.vbase);</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct platform_suspend_ops imx_gpcv2_pm_ops = {</span>
<span class="p_add">+	.enter = imx_gpcv2_pm_enter,</span>
<span class="p_add">+	.valid = imx_gpcv2_pm_valid,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_gpcv2_pm_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm;</span>
<span class="p_add">+	struct imx_gpcv2 *gpc;</span>
<span class="p_add">+	int val, num;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm = kzalloc(sizeof(struct imx_gpcv2_suspend), GFP_KERNEL);</span>
<span class="p_add">+	if (!pm) {</span>
<span class="p_add">+		pr_warn(&quot;[GPCv2] %s init failed\r\n&quot;, __func__);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	gpc = kzalloc(sizeof(struct imx_gpcv2), GFP_KERNEL);</span>
<span class="p_add">+	if (!gpc) {</span>
<span class="p_add">+		pr_warn(&quot;[GPCv2] %s init failed\r\n&quot;, __func__);</span>
<span class="p_add">+		kfree(pm);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	imx_gpcv2_suspend_init(pm, &amp;imx7d_pm_data_ddr3);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_setup = imx_gpcv2_lpm_env_setup;</span>
<span class="p_add">+	pm-&gt;lpm_env_clean = imx_gpcv2_lpm_env_clean;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_cpu_power_gate = imx_gpcv2_lpm_cpu_power_gate;</span>
<span class="p_add">+	pm-&gt;lpm_plat_power_gate = imx_lpm_plat_power_gate;</span>
<span class="p_add">+	pm-&gt;lpm_enable_core = imx_gpcv2_lpm_enable_core;</span>
<span class="p_add">+	pm-&gt;set_mode = imx_gpcv2_lpm_set_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;clear_slots = imx_gpcv2_lpm_clear_slots;</span>
<span class="p_add">+	pm-&gt;set_slot = imx_gpcv2_lpm_slot_setup;</span>
<span class="p_add">+	pm-&gt;set_act = imx_gpcv2_lpm_set_ack;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;standby = imx_gpcv2_lpm_standby;</span>
<span class="p_add">+	pm-&gt;suspend = imx_gpcv2_lpm_suspend;</span>
<span class="p_add">+</span>
<span class="p_add">+	gpc-&gt;anatop = syscon_regmap_lookup_by_compatible(&quot;fsl,imx6q-anatop&quot;);</span>
<span class="p_add">+	if (IS_ERR(gpc-&gt;anatop))</span>
<span class="p_add">+		goto error_exit;</span>
<span class="p_add">+</span>
<span class="p_add">+	gpc-&gt;gpcv2 = syscon_regmap_lookup_by_compatible(&quot;fsl,imx7d-gpc&quot;);</span>
<span class="p_add">+	if (IS_ERR(gpc-&gt;gpcv2))</span>
<span class="p_add">+		goto error_exit;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* only external IRQs to wake up LPM and core 0/1 */</span>
<span class="p_add">+	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_A7_BSC, &amp;val);</span>
<span class="p_add">+	val |= BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP;</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_A7_BSC, val);</span>
<span class="p_add">+	/* mask m4 dsm trigger */</span>
<span class="p_add">+	regmap_read(gpc-&gt;gpcv2, GPC_LPCR_M4, &amp;val);</span>
<span class="p_add">+	val |= BM_LPCR_M4_MASK_DSM_TRIGGER;</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_LPCR_M4, val);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* set mega/fast mix in A7 domain */</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_PGC_CPU_MAPPING, 0x1);</span>
<span class="p_add">+	/* set SCU timing */</span>
<span class="p_add">+	val = (0x59 &lt;&lt; 10) | 0x5B | (0x51 &lt;&lt; 20);</span>
<span class="p_add">+	regmap_write(gpc-&gt;gpcv2, GPC_PGC_SCU_TIMING, val);</span>
<span class="p_add">+</span>
<span class="p_add">+	gpc-&gt;pm = pm;</span>
<span class="p_add">+	gpc-&gt;get_wakeup_source = imx_gpcv2_get_wakeup_source;</span>
<span class="p_add">+	gpcv2_instance = gpc;</span>
<span class="p_add">+</span>
<span class="p_add">+	num = imx_gpcv2_get_wakeup_source(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The IP blocks which may be the wakeup sources are allocated into</span>
<span class="p_add">+	 * several power domains. MFMIX, LPSRMX, and WAKEUPMIX are three of</span>
<span class="p_add">+	 * those power domains. If a bit is &#39;1&#39; in the mask, it means the IP</span>
<span class="p_add">+	 * block is inside the power domain. The mask will be used to decide</span>
<span class="p_add">+	 * if a power domain should be shutdown or not when system goes into</span>
<span class="p_add">+	 * suspend states.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	if (num)</span>
<span class="p_add">+		gpc-&gt;wakeupmix_mask = kzalloc(sizeof(u32)*num*3, GFP_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!gpc-&gt;wakeupmix_mask)</span>
<span class="p_add">+		goto error_exit;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Shutdown LPSRMIX and WAKEUP power domain has not been</span>
<span class="p_add">+	 * implemented in this patch yet.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	gpc-&gt;lpsrmix_mask = gpc-&gt;wakeupmix_mask + num;</span>
<span class="p_add">+	gpc-&gt;mfmix_mask = gpc-&gt;wakeupmix_mask + num*2;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Mask the wakeup sources in M/F power domain */</span>
<span class="p_add">+	gpc-&gt;mfmix_mask[0] = 0x54010000;</span>
<span class="p_add">+	gpc-&gt;mfmix_mask[1] = 0xC00;</span>
<span class="p_add">+	gpc-&gt;mfmix_mask[2] = 0x0;</span>
<span class="p_add">+	gpc-&gt;mfmix_mask[3] = 0x400010;</span>
<span class="p_add">+</span>
<span class="p_add">+	suspend_set_ops(&amp;imx_gpcv2_pm_ops);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+error_exit:</span>
<span class="p_add">+	kfree(pm);</span>
<span class="p_add">+	kfree(gpc);</span>
<span class="p_add">+	return -ENODEV;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+device_initcall(imx_gpcv2_pm_init);</span>
<span class="p_header">diff --git a/arch/arm/mach-imx/suspend-imx7.S b/arch/arm/mach-imx/suspend-imx7.S</span>
new file mode 100644
<span class="p_header">index 0000000..8c3f516</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/suspend-imx7.S</span>
<span class="p_chunk">@@ -0,0 +1,529 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The code contained herein is licensed under the GNU General Public</span>
<span class="p_add">+ * License. You may obtain a copy of the GNU General Public License</span>
<span class="p_add">+ * Version 2 or later at the following locations:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * http://www.opensource.org/licenses/gpl-license.html</span>
<span class="p_add">+ * http://www.gnu.org/copyleft/gpl.html</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &quot;hardware.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ==================== low level suspend ====================</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Better to follow below rules to use ARM registers:</span>
<span class="p_add">+ * r0: pm_info structure address;</span>
<span class="p_add">+ * r1 ~ r4: for saving pm_info members;</span>
<span class="p_add">+ * r5 ~ r10: free registers;</span>
<span class="p_add">+ * r11: io base address.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * suspend ocram space layout:</span>
<span class="p_add">+ * ======================== high address ======================</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                      imx7_suspend code</span>
<span class="p_add">+ *              PM_INFO structure(imx7_cpu_pm_info)</span>
<span class="p_add">+ * ======================== low address =======================</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Below offsets are based on struct imx7_cpu_pm_info</span>
<span class="p_add">+ * which defined in arch/arm/mach-imx/pm-imx7.c, this</span>
<span class="p_add">+ * structure contains necessary pm info for low level</span>
<span class="p_add">+ * suspend related code.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE0_OFFSET		0x0</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE1_OFFSET		0x4</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE2_OFFSET		0x8</span>
<span class="p_add">+#define PM_INFO_PBASE_OFFSET			0xc</span>
<span class="p_add">+#define PM_INFO_RESUME_ADDR_OFFSET		0x10</span>
<span class="p_add">+#define PM_INFO_DDR_TYPE_OFFSET			0x14</span>
<span class="p_add">+#define PM_INFO_PM_INFO_SIZE_OFFSET		0x18</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_P_OFFSET		0x1c</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_V_OFFSET		0x20</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_PHY_P_OFFSET		0x24</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_PHY_V_OFFSET		0x28</span>
<span class="p_add">+#define PM_INFO_MX7_SRC_P_OFFSET		0x2c</span>
<span class="p_add">+#define PM_INFO_MX7_SRC_V_OFFSET		0x30</span>
<span class="p_add">+#define PM_INFO_MX7_IOMUXC_GPR_P_OFFSET		0x34</span>
<span class="p_add">+#define PM_INFO_MX7_IOMUXC_GPR_V_OFFSET		0x38</span>
<span class="p_add">+#define PM_INFO_MX7_CCM_P_OFFSET		0x3c</span>
<span class="p_add">+#define PM_INFO_MX7_CCM_V_OFFSET		0x40</span>
<span class="p_add">+#define PM_INFO_MX7_GPC_P_OFFSET		0x44</span>
<span class="p_add">+#define PM_INFO_MX7_GPC_V_OFFSET		0x48</span>
<span class="p_add">+#define PM_INFO_MX7_L2_P_OFFSET			0x4c</span>
<span class="p_add">+#define PM_INFO_MX7_L2_V_OFFSET			0x50</span>
<span class="p_add">+#define PM_INFO_MX7_ANATOP_P_OFFSET		0x54</span>
<span class="p_add">+#define PM_INFO_MX7_ANATOP_V_OFFSET		0x58</span>
<span class="p_add">+#define PM_INFO_MX7_TTBR1_V_OFFSET		0x5c</span>
<span class="p_add">+#define PM_INFO_DDRC_REG_NUM_OFFSET		0x60</span>
<span class="p_add">+#define PM_INFO_DDRC_REG_OFFSET			0x64</span>
<span class="p_add">+#define PM_INFO_DDRC_VALUE_OFFSET		0x68</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_REG_NUM_OFFSET		0x164</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_REG_OFFSET		0x168</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_VALUE_OFFSET		0x16c</span>
<span class="p_add">+</span>
<span class="p_add">+#define MX7_SRC_GPR1	0x74</span>
<span class="p_add">+#define MX7_SRC_GPR2	0x78</span>
<span class="p_add">+#define GPC_PGC_FM	0xa00</span>
<span class="p_add">+#define ANADIG_SNVS_MISC_CTRL	0x380</span>
<span class="p_add">+#define DDRC_STAT	0x4</span>
<span class="p_add">+#define DDRC_PWRCTL	0x30</span>
<span class="p_add">+#define DDRC_PSTAT	0x3fc</span>
<span class="p_add">+#define DDRC_PCTRL_0	0x490</span>
<span class="p_add">+#define DDRC_DFIMISC	0x1b0</span>
<span class="p_add">+#define DDRC_SWCTL	0x320</span>
<span class="p_add">+#define DDRC_SWSTAT	0x324</span>
<span class="p_add">+#define DDRPHY_LP_CON0	0x18</span>
<span class="p_add">+</span>
<span class="p_add">+	.align 3</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	disable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Flush all data from the L1 data cache before disabling</span>
<span class="p_add">+	 * SCTLR.C bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	push	{r0 - r10, lr}</span>
<span class="p_add">+	ldr	r7, =v7_flush_dcache_all</span>
<span class="p_add">+	mov	lr, pc</span>
<span class="p_add">+	mov	pc, r7</span>
<span class="p_add">+	pop	{r0 - r10, lr}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable d-cache */</span>
<span class="p_add">+	mrc	p15, 0, r7, c1, c0, 0</span>
<span class="p_add">+	bic	r7, r7, #(1 &lt;&lt; 2)</span>
<span class="p_add">+	mcr	p15, 0, r7, c1, c0, 0</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	push	{r0 - r10, lr}</span>
<span class="p_add">+	ldr	r7, =v7_flush_dcache_all</span>
<span class="p_add">+	mov	lr, pc</span>
<span class="p_add">+	mov	pc, r7</span>
<span class="p_add">+	pop	{r0 - r10, lr}</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro enable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable L1 data cache. */</span>
<span class="p_add">+	mrc	p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+	orr	r6, r6, #0x4</span>
<span class="p_add">+	mcr	p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddrc_enter_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait rw port_busy clear */</span>
<span class="p_add">+	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="p_add">+	orr	r6, r6, #0x1</span>
<span class="p_add">+1:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="p_add">+	ands	r7, r7, r6</span>
<span class="p_add">+	bne	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enter self-refresh bit 5 */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+2:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	2b</span>
<span class="p_add">+3:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	ands	r7, r7, #0x20</span>
<span class="p_add">+	beq	3b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable dram clk */</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddrc_exit_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	ldreq	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r11, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+4:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	beq	4b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable auto self-refresh */</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 0)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro wait_delay</span>
<span class="p_add">+5:</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	5b</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddr_enter_retention</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PCTRL_0]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait rw port_busy clear */</span>
<span class="p_add">+	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="p_add">+	orr	r6, r6, #0x1</span>
<span class="p_add">+6:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="p_add">+	ands	r7, r7, r6</span>
<span class="p_add">+	bne	6b</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	/* enter self-refresh bit 5 */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+7:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	7b</span>
<span class="p_add">+8:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	ands	r7, r7, #0x20</span>
<span class="p_add">+	beq	8b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable dram clk */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* reset ddr_phy  */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* delay 7 us */</span>
<span class="p_add">+	ldr	r6, =6000</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r11, r6]</span>
<span class="p_add">+	orr	r7, r7, #0x1</span>
<span class="p_add">+	str	r7, [r11, r6]</span>
<span class="p_add">+	/* turn off ddr power */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="p_add">+	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddr_exit_retention</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	ldreq	r1, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldrne	r1, [r0, #PM_INFO_MX7_ANATOP_P_OFFSET]</span>
<span class="p_add">+	ldreq	r2, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r2, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="p_add">+	ldreq	r3, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r3, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="p_add">+	ldreq	r4, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="p_add">+	ldrne	r4, [r0, #PM_INFO_MX7_DDRC_PHY_P_OFFSET]</span>
<span class="p_add">+	ldreq	r10, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="p_add">+	ldrne	r10, [r0, #PM_INFO_MX7_CCM_P_OFFSET]</span>
<span class="p_add">+	ldreq	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldrne	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* turn on ddr power */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, =50</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear ddr_phy reset */</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	orr	r7, r7, #0x3</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	bic	r7, r7, #0x1</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_DDRC_REG_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_DDRC_REG_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+9:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r3, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	9b</span>
<span class="p_add">+	ldr	r7, =0x20</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* do PHY, clear ddr_phy reset */</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	bic	r7, r7, #0x2</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 30)</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* need to delay ~5mS */</span>
<span class="p_add">+	ldr	r6, =0x100000</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_DDRC_PHY_REG_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_DDRC_PHY_REG_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+</span>
<span class="p_add">+10:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r4, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	10b</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	add	r9, r10, #0x4000</span>
<span class="p_add">+	str	r7, [r9, #0x130]</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	beq	101f</span>
<span class="p_add">+	ldr	r7, =0x170</span>
<span class="p_add">+	orr	r7, r7, #0x8</span>
<span class="p_add">+	str	r7, [r11, #0x20]</span>
<span class="p_add">+</span>
<span class="p_add">+101:</span>
<span class="p_add">+	ldr	r7, =0x2</span>
<span class="p_add">+	add	r9, r10, #0x4000</span>
<span class="p_add">+	str	r7, [r9, #0x130]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0xf</span>
<span class="p_add">+	str	r7, [r4, #DDRPHY_LP_CON0]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+11:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	11b</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="p_add">+12:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_SWSTAT]</span>
<span class="p_add">+	and	r7, r7, #0x1</span>
<span class="p_add">+	cmp	r7, #0x1</span>
<span class="p_add">+	bne	12b</span>
<span class="p_add">+13:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x20</span>
<span class="p_add">+	cmp	r7, #0x20</span>
<span class="p_add">+	bne	13b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="p_add">+14:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x30</span>
<span class="p_add">+	cmp	r7, #0x0</span>
<span class="p_add">+	bne	14b</span>
<span class="p_add">+</span>
<span class="p_add">+15:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x1</span>
<span class="p_add">+	bne	15b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable port */</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PCTRL_0]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(imx7_suspend)</span>
<span class="p_add">+	push	{r4-r12}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The value of r0 is mapped the same in origin table and IRAM table,</span>
<span class="p_add">+	 * thus no need to care r0 here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r1, [r0, #PM_INFO_PBASE_OFFSET]</span>
<span class="p_add">+	ldr	r2, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+	ldr	r3, [r0, #PM_INFO_DDR_TYPE_OFFSET]</span>
<span class="p_add">+	ldr	r4, [r0, #PM_INFO_PM_INFO_SIZE_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * counting the resume address in iram</span>
<span class="p_add">+	 * to set it in SRC register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r6, =imx7_suspend</span>
<span class="p_add">+	ldr	r7, =resume</span>
<span class="p_add">+	sub	r7, r7, r6</span>
<span class="p_add">+	add	r8, r1, r4</span>
<span class="p_add">+	add	r9, r8, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	/* store physical resume addr and pm_info address. */</span>
<span class="p_add">+	str	r9, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r1, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	disable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * make sure TLB contain the addr we want,</span>
<span class="p_add">+	 * as we will access them after DDR is in</span>
<span class="p_add">+	 * self-refresh mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r0, #0x0]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="p_add">+	add	r6, #0x4000</span>
<span class="p_add">+	ldr	r7, [r6]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	add	r6, #0x1000</span>
<span class="p_add">+	ldr	r7, [r6]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	ldr	r7, [r6, #0x490]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	ddr_only_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_enter_retention</span>
<span class="p_add">+	b	ddr_retention_enter_out</span>
<span class="p_add">+ddr_only_self_refresh:</span>
<span class="p_add">+	ddrc_enter_self_refresh</span>
<span class="p_add">+ddr_retention_enter_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Zzz, enter stop mode */</span>
<span class="p_add">+	wfi</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	r5, #0x0</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	wfi_ddr_self_refresh_out</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_exit_retention</span>
<span class="p_add">+	b	wfi_ddr_retention_out</span>
<span class="p_add">+wfi_ddr_self_refresh_out:</span>
<span class="p_add">+	ddrc_exit_self_refresh</span>
<span class="p_add">+wfi_ddr_retention_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =0x170</span>
<span class="p_add">+	orr	r7, r7, #0x8</span>
<span class="p_add">+	str	r7, [r11, #0x20]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear core0&#39;s entry and parameter */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	mov	r7, #0x0</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	enable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	pop	{r4-r12}</span>
<span class="p_add">+	/* return to suspend finish */</span>
<span class="p_add">+	mov	pc, lr</span>
<span class="p_add">+</span>
<span class="p_add">+resume:</span>
<span class="p_add">+	/* invalidate L1 I-cache first */</span>
<span class="p_add">+	mov     r6, #0x0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 6</span>
<span class="p_add">+	/* enable the Icache and branch prediction */</span>
<span class="p_add">+	mov     r6, #0x1800</span>
<span class="p_add">+	mcr     p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get physical resume address from pm_info. */</span>
<span class="p_add">+	ldr	lr, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+	/* clear core0&#39;s entry and parameter */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="p_add">+	mov	r7, #0x0</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	r5, #0x1</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_P_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	dsm_ddr_self_refresh_out</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_exit_retention</span>
<span class="p_add">+	b	dsm_ddr_retention_out</span>
<span class="p_add">+dsm_ddr_self_refresh_out:</span>
<span class="p_add">+	ddrc_exit_self_refresh</span>
<span class="p_add">+dsm_ddr_retention_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	pc, lr</span>
<span class="p_add">+ENDPROC(imx7_suspend)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ca7_cpu_resume)</span>
<span class="p_add">+	bl	v7_invalidate_l1</span>
<span class="p_add">+	b	cpu_resume</span>
<span class="p_add">+ENDPROC(ca7_cpu_resume)</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



