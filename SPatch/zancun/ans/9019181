
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.5.3 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.5.3</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 4, 2016, 10:21 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160504222158.GB15279@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9019181/mbox/"
   >mbox</a>
|
   <a href="/patch/9019181/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9019181/">/patch/9019181/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 8EEF4BF29F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  4 May 2016 22:22:50 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 423722041A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  4 May 2016 22:22:38 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 78E8C20412
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  4 May 2016 22:22:25 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754947AbcEDWWM (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 4 May 2016 18:22:12 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:38109 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1754658AbcEDWWB (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 4 May 2016 18:22:01 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 439A3411;
	Wed,  4 May 2016 22:21:59 +0000 (UTC)
Date: Wed, 4 May 2016 15:21:58 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.5.3
Message-ID: &lt;20160504222158.GB15279@kroah.com&gt;
References: &lt;20160504222151.GA15279@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160504222151.GA15279@kroah.com&gt;
User-Agent: Mutt/1.6.1 (2016-04-27)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-9.0 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - May 4, 2016, 10:21 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 1ecaaeb7791d..9b56a6c5e36f 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 5
<span class="p_del">-SUBLEVEL = 2</span>
<span class="p_add">+SUBLEVEL = 3</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/am33xx.dtsi b/arch/arm/boot/dts/am33xx.dtsi</span>
<span class="p_header">index 1fafaad516ba..97471d62d5e4 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am33xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am33xx.dtsi</span>
<span class="p_chunk">@@ -860,7 +860,7 @@</span> <span class="p_context"></span>
 			ti,no-idle-on-init;
 			reg = &lt;0x50000000 0x2000&gt;;
 			interrupts = &lt;100&gt;;
<span class="p_del">-			dmas = &lt;&amp;edma 52&gt;;</span>
<span class="p_add">+			dmas = &lt;&amp;edma 52 0&gt;;</span>
 			dma-names = &quot;rxtx&quot;;
 			gpmc,num-cs = &lt;7&gt;;
 			gpmc,num-waitpins = &lt;2&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/am4372.dtsi b/arch/arm/boot/dts/am4372.dtsi</span>
<span class="p_header">index 92068fbf8b57..6bd38a28e26c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am4372.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am4372.dtsi</span>
<span class="p_chunk">@@ -207,7 +207,7 @@</span> <span class="p_context"></span>
 			ti,tptcs = &lt;&amp;edma_tptc0 7&gt;, &lt;&amp;edma_tptc1 5&gt;,
 				   &lt;&amp;edma_tptc2 0&gt;;
 
<span class="p_del">-			ti,edma-memcpy-channels = &lt;32 33&gt;;</span>
<span class="p_add">+			ti,edma-memcpy-channels = &lt;58 59&gt;;</span>
 		};
 
 		edma_tptc0: tptc@49800000 {
<span class="p_chunk">@@ -884,7 +884,7 @@</span> <span class="p_context"></span>
 		gpmc: gpmc@50000000 {
 			compatible = &quot;ti,am3352-gpmc&quot;;
 			ti,hwmods = &quot;gpmc&quot;;
<span class="p_del">-			dmas = &lt;&amp;edma 52&gt;;</span>
<span class="p_add">+			dmas = &lt;&amp;edma 52 0&gt;;</span>
 			dma-names = &quot;rxtx&quot;;
 			clocks = &lt;&amp;l3s_gclk&gt;;
 			clock-names = &quot;fck&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/am43x-epos-evm.dts b/arch/arm/boot/dts/am43x-epos-evm.dts</span>
<span class="p_header">index d580e2b70f9a..637dc5dbc8ac 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am43x-epos-evm.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am43x-epos-evm.dts</span>
<span class="p_chunk">@@ -792,3 +792,8 @@</span> <span class="p_context"></span>
 	tx-num-evt = &lt;32&gt;;
 	rx-num-evt = &lt;32&gt;;
 };
<span class="p_add">+</span>
<span class="p_add">+&amp;synctimer_32kclk {</span>
<span class="p_add">+	assigned-clocks = &lt;&amp;mux_synctimer32k_ck&gt;;</span>
<span class="p_add">+	assigned-clock-parents = &lt;&amp;clkdiv32k_ick&gt;;</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-375.dtsi b/arch/arm/boot/dts/armada-375.dtsi</span>
<span class="p_header">index 7ccce7529b0c..cc952cf8ec30 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-375.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-375.dtsi</span>
<span class="p_chunk">@@ -529,7 +529,7 @@</span> <span class="p_context"></span>
 			};
 
 			sata@a0000 {
<span class="p_del">-				compatible = &quot;marvell,orion-sata&quot;;</span>
<span class="p_add">+				compatible = &quot;marvell,armada-370-sata&quot;;</span>
 				reg = &lt;0xa0000 0x5000&gt;;
 				interrupts = &lt;GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH&gt;;
 				clocks = &lt;&amp;gateclk 14&gt;, &lt;&amp;gateclk 20&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-385-linksys.dtsi b/arch/arm/boot/dts/armada-385-linksys.dtsi</span>
<span class="p_header">index 3710755c6d76..85d2c377c332 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-385-linksys.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-385-linksys.dtsi</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"></span>
 			};
 
 			/* USB part of the eSATA/USB 2.0 port */
<span class="p_del">-			usb@50000 {</span>
<span class="p_add">+			usb@58000 {</span>
 				status = &quot;okay&quot;;
 			};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/pxa3xx.dtsi b/arch/arm/boot/dts/pxa3xx.dtsi</span>
<span class="p_header">index cf6998a0804d..564341af7e97 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/pxa3xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/pxa3xx.dtsi</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"></span>
 			reg = &lt;0x43100000 90&gt;;
 			interrupts = &lt;45&gt;;
 			clocks = &lt;&amp;clks CLK_NAND&gt;;
<span class="p_del">-			dmas = &lt;&amp;pdma 97&gt;;</span>
<span class="p_add">+			dmas = &lt;&amp;pdma 97 3&gt;;</span>
 			dma-names = &quot;data&quot;;
 			#address-cells = &lt;1&gt;;
 			#size-cells = &lt;1&gt;;	
<span class="p_header">diff --git a/arch/arm/mach-exynos/Kconfig b/arch/arm/mach-exynos/Kconfig</span>
<span class="p_header">index 652a0bb11578..5189bcecad12 100644</span>
<span class="p_header">--- a/arch/arm/mach-exynos/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-exynos/Kconfig</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"> menuconfig ARCH_EXYNOS</span>
 	select S5P_DEV_MFC
 	select SRAM
 	select THERMAL
<span class="p_add">+	select THERMAL_OF</span>
 	select MFD_SYSCON
 	select CLKSRC_EXYNOS_MCT
 	select POWER_RESET
<span class="p_header">diff --git a/arch/arm/mach-omap2/cpuidle34xx.c b/arch/arm/mach-omap2/cpuidle34xx.c</span>
<span class="p_header">index aa7b379e2661..2a3db0bd9e15 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/cpuidle34xx.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/cpuidle34xx.c</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"></span>
 #include &quot;pm.h&quot;
 #include &quot;control.h&quot;
 #include &quot;common.h&quot;
<span class="p_add">+#include &quot;soc.h&quot;</span>
 
 /* Mach specific information to be recorded in the C-state driver_data */
 struct omap3_idle_statedata {
<span class="p_chunk">@@ -315,6 +316,69 @@</span> <span class="p_context"> static struct cpuidle_driver omap3_idle_driver = {</span>
 	.safe_state_index = 0,
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Numbers based on measurements made in October 2009 for PM optimized kernel</span>
<span class="p_add">+ * with CPU freq enabled on device Nokia N900. Assumes OPP2 (main idle OPP,</span>
<span class="p_add">+ * and worst case latencies).</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct cpuidle_driver omap3430_idle_driver = {</span>
<span class="p_add">+	.name             = &quot;omap3430_idle&quot;,</span>
<span class="p_add">+	.owner            = THIS_MODULE,</span>
<span class="p_add">+	.states = {</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 110 + 162,</span>
<span class="p_add">+			.target_residency = 5,</span>
<span class="p_add">+			.name		  = &quot;C1&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU ON + CORE ON&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 106 + 180,</span>
<span class="p_add">+			.target_residency = 309,</span>
<span class="p_add">+			.name		  = &quot;C2&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU ON + CORE ON&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 107 + 410,</span>
<span class="p_add">+			.target_residency = 46057,</span>
<span class="p_add">+			.name		  = &quot;C3&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU RET + CORE ON&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 121 + 3374,</span>
<span class="p_add">+			.target_residency = 46057,</span>
<span class="p_add">+			.name		  = &quot;C4&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU OFF + CORE ON&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 855 + 1146,</span>
<span class="p_add">+			.target_residency = 46057,</span>
<span class="p_add">+			.name		  = &quot;C5&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU RET + CORE RET&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 7580 + 4134,</span>
<span class="p_add">+			.target_residency = 484329,</span>
<span class="p_add">+			.name		  = &quot;C6&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU OFF + CORE RET&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 7505 + 15274,</span>
<span class="p_add">+			.target_residency = 484329,</span>
<span class="p_add">+			.name		  = &quot;C7&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU OFF + CORE OFF&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	.state_count = ARRAY_SIZE(omap3_idle_data),</span>
<span class="p_add">+	.safe_state_index = 0,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /* Public functions */
 
 /**
<span class="p_chunk">@@ -333,5 +397,8 @@</span> <span class="p_context"> int __init omap3_idle_init(void)</span>
 	if (!mpu_pd || !core_pd || !per_pd || !cam_pd)
 		return -ENODEV;
 
<span class="p_del">-	return cpuidle_register(&amp;omap3_idle_driver, NULL);</span>
<span class="p_add">+	if (cpu_is_omap3430())</span>
<span class="p_add">+		return cpuidle_register(&amp;omap3430_idle_driver, NULL);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return cpuidle_register(&amp;omap3_idle_driver, NULL);</span>
 }
<span class="p_header">diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c</span>
<span class="p_header">index 3c87e40650cf..9821be6dfd5e 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/io.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/io.c</span>
<span class="p_chunk">@@ -368,6 +368,7 @@</span> <span class="p_context"> void __init omap5_map_io(void)</span>
 void __init dra7xx_map_io(void)
 {
 	iotable_init(dra7xx_io_desc, ARRAY_SIZE(dra7xx_io_desc));
<span class="p_add">+	omap_barriers_init();</span>
 }
 #endif
 /*
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">index b6d62e4cdfdd..2af6ff63e3b4 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_chunk">@@ -1416,9 +1416,7 @@</span> <span class="p_context"> static void _enable_sysc(struct omap_hwmod *oh)</span>
 	    (sf &amp; SYSC_HAS_CLOCKACTIVITY))
 		_set_clockactivity(oh, oh-&gt;class-&gt;sysc-&gt;clockact, &amp;v);
 
<span class="p_del">-	/* If the cached value is the same as the new value, skip the write */</span>
<span class="p_del">-	if (oh-&gt;_sysc_cache != v)</span>
<span class="p_del">-		_write_sysconfig(v, oh);</span>
<span class="p_add">+	_write_sysconfig(v, oh);</span>
 
 	/*
 	 * Set the autoidle bit only after setting the smartidle bit
<span class="p_chunk">@@ -1481,7 +1479,9 @@</span> <span class="p_context"> static void _idle_sysc(struct omap_hwmod *oh)</span>
 		_set_master_standbymode(oh, idlemode, &amp;v);
 	}
 
<span class="p_del">-	_write_sysconfig(v, oh);</span>
<span class="p_add">+	/* If the cached value is the same as the new value, skip the write */</span>
<span class="p_add">+	if (oh-&gt;_sysc_cache != v)</span>
<span class="p_add">+		_write_sysconfig(v, oh);</span>
 }
 
 /**
<span class="p_header">diff --git a/arch/arm/mach-prima2/Kconfig b/arch/arm/mach-prima2/Kconfig</span>
<span class="p_header">index f998eb1c698e..0cf4426183cf 100644</span>
<span class="p_header">--- a/arch/arm/mach-prima2/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-prima2/Kconfig</span>
<span class="p_chunk">@@ -2,6 +2,7 @@</span> <span class="p_context"> menuconfig ARCH_SIRF</span>
 	bool &quot;CSR SiRF&quot;
 	depends on ARCH_MULTI_V7
 	select ARCH_HAS_RESET_CONTROLLER
<span class="p_add">+	select RESET_CONTROLLER</span>
 	select ARCH_REQUIRE_GPIOLIB
 	select GENERIC_IRQ_CHIP
 	select NO_IOPORT_MAP
<span class="p_header">diff --git a/arch/powerpc/include/uapi/asm/cputable.h b/arch/powerpc/include/uapi/asm/cputable.h</span>
<span class="p_header">index 8dde19962a5b..f63c96cd3608 100644</span>
<span class="p_header">--- a/arch/powerpc/include/uapi/asm/cputable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/uapi/asm/cputable.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 #define PPC_FEATURE_PSERIES_PERFMON_COMPAT \
 					0x00000040
 
<span class="p_add">+/* Reserved - do not use		0x00000004 */</span>
 #define PPC_FEATURE_TRUE_LE		0x00000002
 #define PPC_FEATURE_PPC_LE		0x00000001
 
<span class="p_header">diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c</span>
<span class="p_header">index 7030b035905d..a15fe1d4e84a 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/prom.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/prom.c</span>
<span class="p_chunk">@@ -148,23 +148,25 @@</span> <span class="p_context"> static struct ibm_pa_feature {</span>
 	unsigned long	cpu_features;	/* CPU_FTR_xxx bit */
 	unsigned long	mmu_features;	/* MMU_FTR_xxx bit */
 	unsigned int	cpu_user_ftrs;	/* PPC_FEATURE_xxx bit */
<span class="p_add">+	unsigned int	cpu_user_ftrs2;	/* PPC_FEATURE2_xxx bit */</span>
 	unsigned char	pabyte;		/* byte number in ibm,pa-features */
 	unsigned char	pabit;		/* bit number (big-endian) */
 	unsigned char	invert;		/* if 1, pa bit set =&gt; clear feature */
 } ibm_pa_features[] __initdata = {
<span class="p_del">-	{0, 0, PPC_FEATURE_HAS_MMU,	0, 0, 0},</span>
<span class="p_del">-	{0, 0, PPC_FEATURE_HAS_FPU,	0, 1, 0},</span>
<span class="p_del">-	{CPU_FTR_CTRL, 0, 0,		0, 3, 0},</span>
<span class="p_del">-	{CPU_FTR_NOEXECUTE, 0, 0,	0, 6, 0},</span>
<span class="p_del">-	{CPU_FTR_NODSISRALIGN, 0, 0,	1, 1, 1},</span>
<span class="p_del">-	{0, MMU_FTR_CI_LARGE_PAGE, 0,	1, 2, 0},</span>
<span class="p_del">-	{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},</span>
<span class="p_add">+	{0, 0, PPC_FEATURE_HAS_MMU, 0,		0, 0, 0},</span>
<span class="p_add">+	{0, 0, PPC_FEATURE_HAS_FPU, 0,		0, 1, 0},</span>
<span class="p_add">+	{CPU_FTR_CTRL, 0, 0, 0,			0, 3, 0},</span>
<span class="p_add">+	{CPU_FTR_NOEXECUTE, 0, 0, 0,		0, 6, 0},</span>
<span class="p_add">+	{CPU_FTR_NODSISRALIGN, 0, 0, 0,		1, 1, 1},</span>
<span class="p_add">+	{0, MMU_FTR_CI_LARGE_PAGE, 0, 0,		1, 2, 0},</span>
<span class="p_add">+	{CPU_FTR_REAL_LE, 0, PPC_FEATURE_TRUE_LE, 0, 5, 0, 0},</span>
 	/*
<span class="p_del">-	 * If the kernel doesn&#39;t support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),</span>
<span class="p_del">-	 * we don&#39;t want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP</span>
<span class="p_del">-	 * which is 0 if the kernel doesn&#39;t support TM.</span>
<span class="p_add">+	 * If the kernel doesn&#39;t support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),</span>
<span class="p_add">+	 * we don&#39;t want to turn on TM here, so we use the *_COMP versions</span>
<span class="p_add">+	 * which are 0 if the kernel doesn&#39;t support TM.</span>
 	 */
<span class="p_del">-	{CPU_FTR_TM_COMP, 0, 0,		22, 0, 0},</span>
<span class="p_add">+	{CPU_FTR_TM_COMP, 0, 0,</span>
<span class="p_add">+	 PPC_FEATURE2_HTM_COMP|PPC_FEATURE2_HTM_NOSC_COMP, 22, 0, 0},</span>
 };
 
 static void __init scan_features(unsigned long node, const unsigned char *ftrs,
<span class="p_chunk">@@ -195,10 +197,12 @@</span> <span class="p_context"> static void __init scan_features(unsigned long node, const unsigned char *ftrs,</span>
 		if (bit ^ fp-&gt;invert) {
 			cur_cpu_spec-&gt;cpu_features |= fp-&gt;cpu_features;
 			cur_cpu_spec-&gt;cpu_user_features |= fp-&gt;cpu_user_ftrs;
<span class="p_add">+			cur_cpu_spec-&gt;cpu_user_features2 |= fp-&gt;cpu_user_ftrs2;</span>
 			cur_cpu_spec-&gt;mmu_features |= fp-&gt;mmu_features;
 		} else {
 			cur_cpu_spec-&gt;cpu_features &amp;= ~fp-&gt;cpu_features;
 			cur_cpu_spec-&gt;cpu_user_features &amp;= ~fp-&gt;cpu_user_ftrs;
<span class="p_add">+			cur_cpu_spec-&gt;cpu_user_features2 &amp;= ~fp-&gt;cpu_user_ftrs2;</span>
 			cur_cpu_spec-&gt;mmu_features &amp;= ~fp-&gt;mmu_features;
 		}
 	}
<span class="p_header">diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.h</span>
<span class="p_header">index 2b2ced9dc00a..6dafabb6ae1a 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pci.h</span>
<span class="p_chunk">@@ -45,7 +45,8 @@</span> <span class="p_context"> struct zpci_fmb {</span>
 	u64 rpcit_ops;
 	u64 dma_rbytes;
 	u64 dma_wbytes;
<span class="p_del">-} __packed __aligned(64);</span>
<span class="p_add">+	u64 pad[2];</span>
<span class="p_add">+} __packed __aligned(128);</span>
 
 enum zpci_state {
 	ZPCI_FN_STATE_RESERVED,
<span class="p_header">diff --git a/arch/x86/crypto/sha-mb/sha1_mb.c b/arch/x86/crypto/sha-mb/sha1_mb.c</span>
<span class="p_header">index a841e9765bd6..8381c09d2870 100644</span>
<span class="p_header">--- a/arch/x86/crypto/sha-mb/sha1_mb.c</span>
<span class="p_header">+++ b/arch/x86/crypto/sha-mb/sha1_mb.c</span>
<span class="p_chunk">@@ -453,10 +453,10 @@</span> <span class="p_context"> static int sha_complete_job(struct mcryptd_hash_request_ctx *rctx,</span>
 
 			req = cast_mcryptd_ctx_to_req(req_ctx);
 			if (irqs_disabled())
<span class="p_del">-				rctx-&gt;complete(&amp;req-&gt;base, ret);</span>
<span class="p_add">+				req_ctx-&gt;complete(&amp;req-&gt;base, ret);</span>
 			else {
 				local_bh_disable();
<span class="p_del">-				rctx-&gt;complete(&amp;req-&gt;base, ret);</span>
<span class="p_add">+				req_ctx-&gt;complete(&amp;req-&gt;base, ret);</span>
 				local_bh_enable();
 			}
 		}
<span class="p_header">diff --git a/arch/x86/include/asm/hugetlb.h b/arch/x86/include/asm/hugetlb.h</span>
<span class="p_header">index f8a29d2c97b0..e6a8613fbfb0 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -4,6 +4,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm-generic/hugetlb.h&gt;
 
<span class="p_add">+#define hugepages_supported() cpu_has_pse</span>
 
 static inline int is_hugepage_only_range(struct mm_struct *mm,
 					 unsigned long addr,
<span class="p_header">diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">index ad59d70bcb1a..ef495511f019 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/vector.c</span>
<span class="p_chunk">@@ -256,7 +256,8 @@</span> <span class="p_context"> static void clear_irq_vector(int irq, struct apic_chip_data *data)</span>
 	struct irq_desc *desc;
 	int cpu, vector;
 
<span class="p_del">-	BUG_ON(!data-&gt;cfg.vector);</span>
<span class="p_add">+	if (!data-&gt;cfg.vector)</span>
<span class="p_add">+		return;</span>
 
 	vector = data-&gt;cfg.vector;
 	for_each_cpu_and(cpu, data-&gt;domain, cpu_online_mask)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce-genpool.c b/arch/x86/kernel/cpu/mcheck/mce-genpool.c</span>
<span class="p_header">index 0a850100c594..2658e2af74ec 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce-genpool.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce-genpool.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"> static char gen_pool_buf[MCE_POOLSZ];</span>
 void mce_gen_pool_process(void)
 {
 	struct llist_node *head;
<span class="p_del">-	struct mce_evt_llist *node;</span>
<span class="p_add">+	struct mce_evt_llist *node, *tmp;</span>
 	struct mce *mce;
 
 	head = llist_del_all(&amp;mce_event_llist);
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"> void mce_gen_pool_process(void)</span>
 		return;
 
 	head = llist_reverse_order(head);
<span class="p_del">-	llist_for_each_entry(node, head, llnode) {</span>
<span class="p_add">+	llist_for_each_entry_safe(node, tmp, head, llnode) {</span>
 		mce = &amp;node-&gt;mce;
 		atomic_notifier_call_chain(&amp;x86_mce_decoder_chain, 0, mce);
 		gen_pool_free(mce_evt_pool, (unsigned long)node, sizeof(*node));
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index eca5bd9f0e47..ac4963c38aa3 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -697,7 +697,6 @@</span> <span class="p_context"> static int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)</span>
 		if ((xcr0 &amp; XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)
 			return 1;
 	}
<span class="p_del">-	kvm_put_guest_xcr0(vcpu);</span>
 	vcpu-&gt;arch.xcr0 = xcr0;
 
 	if ((xcr0 ^ old_xcr0) &amp; XFEATURE_MASK_EXTEND)
<span class="p_chunk">@@ -6569,8 +6568,6 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 	kvm_x86_ops-&gt;prepare_guest_switch(vcpu);
 	if (vcpu-&gt;fpu_active)
 		kvm_load_guest_fpu(vcpu);
<span class="p_del">-	kvm_load_guest_xcr0(vcpu);</span>
<span class="p_del">-</span>
 	vcpu-&gt;mode = IN_GUEST_MODE;
 
 	srcu_read_unlock(&amp;vcpu-&gt;kvm-&gt;srcu, vcpu-&gt;srcu_idx);
<span class="p_chunk">@@ -6593,6 +6590,8 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 		goto cancel_injection;
 	}
 
<span class="p_add">+	kvm_load_guest_xcr0(vcpu);</span>
<span class="p_add">+</span>
 	if (req_immediate_exit)
 		smp_send_reschedule(vcpu-&gt;cpu);
 
<span class="p_chunk">@@ -6642,6 +6641,8 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 	vcpu-&gt;mode = OUTSIDE_GUEST_MODE;
 	smp_wmb();
 
<span class="p_add">+	kvm_put_guest_xcr0(vcpu);</span>
<span class="p_add">+</span>
 	/* Interrupt is enabled by handle_external_intr() */
 	kvm_x86_ops-&gt;handle_external_intr(vcpu);
 
<span class="p_chunk">@@ -7289,7 +7290,6 @@</span> <span class="p_context"> void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)</span>
 	 * and assume host would use all available bits.
 	 * Guest xcr0 would be loaded later.
 	 */
<span class="p_del">-	kvm_put_guest_xcr0(vcpu);</span>
 	vcpu-&gt;guest_fpu_loaded = 1;
 	__kernel_fpu_begin();
 	__copy_kernel_to_fpregs(&amp;vcpu-&gt;arch.guest_fpu.state);
<span class="p_chunk">@@ -7298,8 +7298,6 @@</span> <span class="p_context"> void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)</span>
 
 void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	kvm_put_guest_xcr0(vcpu);</span>
<span class="p_del">-</span>
 	if (!vcpu-&gt;guest_fpu_loaded) {
 		vcpu-&gt;fpu_counter = 0;
 		return;
<span class="p_header">diff --git a/arch/x86/mm/kmmio.c b/arch/x86/mm/kmmio.c</span>
<span class="p_header">index 637ab34ed632..ddb2244b06a1 100644</span>
<span class="p_header">--- a/arch/x86/mm/kmmio.c</span>
<span class="p_header">+++ b/arch/x86/mm/kmmio.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"></span>
 struct kmmio_fault_page {
 	struct list_head list;
 	struct kmmio_fault_page *release_next;
<span class="p_del">-	unsigned long page; /* location of the fault page */</span>
<span class="p_add">+	unsigned long addr; /* the requested address */</span>
 	pteval_t old_presence; /* page presence prior to arming */
 	bool armed;
 
<span class="p_chunk">@@ -70,9 +70,16 @@</span> <span class="p_context"> unsigned int kmmio_count;</span>
 static struct list_head kmmio_page_table[KMMIO_PAGE_TABLE_SIZE];
 static LIST_HEAD(kmmio_probes);
 
<span class="p_del">-static struct list_head *kmmio_page_list(unsigned long page)</span>
<span class="p_add">+static struct list_head *kmmio_page_list(unsigned long addr)</span>
 {
<span class="p_del">-	return &amp;kmmio_page_table[hash_long(page, KMMIO_PAGE_HASH_BITS)];</span>
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte = lookup_address(addr, &amp;l);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pte)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	addr &amp;= page_level_mask(l);</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;kmmio_page_table[hash_long(addr, KMMIO_PAGE_HASH_BITS)];</span>
 }
 
 /* Accessed per-cpu */
<span class="p_chunk">@@ -98,15 +105,19 @@</span> <span class="p_context"> static struct kmmio_probe *get_kmmio_probe(unsigned long addr)</span>
 }
 
 /* You must be holding RCU read lock. */
<span class="p_del">-static struct kmmio_fault_page *get_kmmio_fault_page(unsigned long page)</span>
<span class="p_add">+static struct kmmio_fault_page *get_kmmio_fault_page(unsigned long addr)</span>
 {
 	struct list_head *head;
 	struct kmmio_fault_page *f;
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte = lookup_address(addr, &amp;l);</span>
 
<span class="p_del">-	page &amp;= PAGE_MASK;</span>
<span class="p_del">-	head = kmmio_page_list(page);</span>
<span class="p_add">+	if (!pte)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	addr &amp;= page_level_mask(l);</span>
<span class="p_add">+	head = kmmio_page_list(addr);</span>
 	list_for_each_entry_rcu(f, head, list) {
<span class="p_del">-		if (f-&gt;page == page)</span>
<span class="p_add">+		if (f-&gt;addr == addr)</span>
 			return f;
 	}
 	return NULL;
<span class="p_chunk">@@ -137,10 +148,10 @@</span> <span class="p_context"> static void clear_pte_presence(pte_t *pte, bool clear, pteval_t *old)</span>
 static int clear_page_presence(struct kmmio_fault_page *f, bool clear)
 {
 	unsigned int level;
<span class="p_del">-	pte_t *pte = lookup_address(f-&gt;page, &amp;level);</span>
<span class="p_add">+	pte_t *pte = lookup_address(f-&gt;addr, &amp;level);</span>
 
 	if (!pte) {
<span class="p_del">-		pr_err(&quot;no pte for page 0x%08lx\n&quot;, f-&gt;page);</span>
<span class="p_add">+		pr_err(&quot;no pte for addr 0x%08lx\n&quot;, f-&gt;addr);</span>
 		return -1;
 	}
 
<span class="p_chunk">@@ -156,7 +167,7 @@</span> <span class="p_context"> static int clear_page_presence(struct kmmio_fault_page *f, bool clear)</span>
 		return -1;
 	}
 
<span class="p_del">-	__flush_tlb_one(f-&gt;page);</span>
<span class="p_add">+	__flush_tlb_one(f-&gt;addr);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -176,12 +187,12 @@</span> <span class="p_context"> static int arm_kmmio_fault_page(struct kmmio_fault_page *f)</span>
 	int ret;
 	WARN_ONCE(f-&gt;armed, KERN_ERR pr_fmt(&quot;kmmio page already armed.\n&quot;));
 	if (f-&gt;armed) {
<span class="p_del">-		pr_warning(&quot;double-arm: page 0x%08lx, ref %d, old %d\n&quot;,</span>
<span class="p_del">-			   f-&gt;page, f-&gt;count, !!f-&gt;old_presence);</span>
<span class="p_add">+		pr_warning(&quot;double-arm: addr 0x%08lx, ref %d, old %d\n&quot;,</span>
<span class="p_add">+			   f-&gt;addr, f-&gt;count, !!f-&gt;old_presence);</span>
 	}
 	ret = clear_page_presence(f, true);
<span class="p_del">-	WARN_ONCE(ret &lt; 0, KERN_ERR pr_fmt(&quot;arming 0x%08lx failed.\n&quot;),</span>
<span class="p_del">-		  f-&gt;page);</span>
<span class="p_add">+	WARN_ONCE(ret &lt; 0, KERN_ERR pr_fmt(&quot;arming at 0x%08lx failed.\n&quot;),</span>
<span class="p_add">+		  f-&gt;addr);</span>
 	f-&gt;armed = true;
 	return ret;
 }
<span class="p_chunk">@@ -191,7 +202,7 @@</span> <span class="p_context"> static void disarm_kmmio_fault_page(struct kmmio_fault_page *f)</span>
 {
 	int ret = clear_page_presence(f, false);
 	WARN_ONCE(ret &lt; 0,
<span class="p_del">-			KERN_ERR &quot;kmmio disarming 0x%08lx failed.\n&quot;, f-&gt;page);</span>
<span class="p_add">+			KERN_ERR &quot;kmmio disarming at 0x%08lx failed.\n&quot;, f-&gt;addr);</span>
 	f-&gt;armed = false;
 }
 
<span class="p_chunk">@@ -215,6 +226,12 @@</span> <span class="p_context"> int kmmio_handler(struct pt_regs *regs, unsigned long addr)</span>
 	struct kmmio_context *ctx;
 	struct kmmio_fault_page *faultpage;
 	int ret = 0; /* default to fault not handled */
<span class="p_add">+	unsigned long page_base = addr;</span>
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte = lookup_address(addr, &amp;l);</span>
<span class="p_add">+	if (!pte)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	page_base &amp;= page_level_mask(l);</span>
 
 	/*
 	 * Preemption is now disabled to prevent process switch during
<span class="p_chunk">@@ -227,7 +244,7 @@</span> <span class="p_context"> int kmmio_handler(struct pt_regs *regs, unsigned long addr)</span>
 	preempt_disable();
 	rcu_read_lock();
 
<span class="p_del">-	faultpage = get_kmmio_fault_page(addr);</span>
<span class="p_add">+	faultpage = get_kmmio_fault_page(page_base);</span>
 	if (!faultpage) {
 		/*
 		 * Either this page fault is not caused by kmmio, or
<span class="p_chunk">@@ -239,7 +256,7 @@</span> <span class="p_context"> int kmmio_handler(struct pt_regs *regs, unsigned long addr)</span>
 
 	ctx = &amp;get_cpu_var(kmmio_ctx);
 	if (ctx-&gt;active) {
<span class="p_del">-		if (addr == ctx-&gt;addr) {</span>
<span class="p_add">+		if (page_base == ctx-&gt;addr) {</span>
 			/*
 			 * A second fault on the same page means some other
 			 * condition needs handling by do_page_fault(), the
<span class="p_chunk">@@ -267,9 +284,9 @@</span> <span class="p_context"> int kmmio_handler(struct pt_regs *regs, unsigned long addr)</span>
 	ctx-&gt;active++;
 
 	ctx-&gt;fpage = faultpage;
<span class="p_del">-	ctx-&gt;probe = get_kmmio_probe(addr);</span>
<span class="p_add">+	ctx-&gt;probe = get_kmmio_probe(page_base);</span>
 	ctx-&gt;saved_flags = (regs-&gt;flags &amp; (X86_EFLAGS_TF | X86_EFLAGS_IF));
<span class="p_del">-	ctx-&gt;addr = addr;</span>
<span class="p_add">+	ctx-&gt;addr = page_base;</span>
 
 	if (ctx-&gt;probe &amp;&amp; ctx-&gt;probe-&gt;pre_handler)
 		ctx-&gt;probe-&gt;pre_handler(ctx-&gt;probe, regs, addr);
<span class="p_chunk">@@ -354,12 +371,11 @@</span> <span class="p_context"> out:</span>
 }
 
 /* You must be holding kmmio_lock. */
<span class="p_del">-static int add_kmmio_fault_page(unsigned long page)</span>
<span class="p_add">+static int add_kmmio_fault_page(unsigned long addr)</span>
 {
 	struct kmmio_fault_page *f;
 
<span class="p_del">-	page &amp;= PAGE_MASK;</span>
<span class="p_del">-	f = get_kmmio_fault_page(page);</span>
<span class="p_add">+	f = get_kmmio_fault_page(addr);</span>
 	if (f) {
 		if (!f-&gt;count)
 			arm_kmmio_fault_page(f);
<span class="p_chunk">@@ -372,26 +388,25 @@</span> <span class="p_context"> static int add_kmmio_fault_page(unsigned long page)</span>
 		return -1;
 
 	f-&gt;count = 1;
<span class="p_del">-	f-&gt;page = page;</span>
<span class="p_add">+	f-&gt;addr = addr;</span>
 
 	if (arm_kmmio_fault_page(f)) {
 		kfree(f);
 		return -1;
 	}
 
<span class="p_del">-	list_add_rcu(&amp;f-&gt;list, kmmio_page_list(f-&gt;page));</span>
<span class="p_add">+	list_add_rcu(&amp;f-&gt;list, kmmio_page_list(f-&gt;addr));</span>
 
 	return 0;
 }
 
 /* You must be holding kmmio_lock. */
<span class="p_del">-static void release_kmmio_fault_page(unsigned long page,</span>
<span class="p_add">+static void release_kmmio_fault_page(unsigned long addr,</span>
 				struct kmmio_fault_page **release_list)
 {
 	struct kmmio_fault_page *f;
 
<span class="p_del">-	page &amp;= PAGE_MASK;</span>
<span class="p_del">-	f = get_kmmio_fault_page(page);</span>
<span class="p_add">+	f = get_kmmio_fault_page(addr);</span>
 	if (!f)
 		return;
 
<span class="p_chunk">@@ -420,18 +435,27 @@</span> <span class="p_context"> int register_kmmio_probe(struct kmmio_probe *p)</span>
 	int ret = 0;
 	unsigned long size = 0;
 	const unsigned long size_lim = p-&gt;len + (p-&gt;addr &amp; ~PAGE_MASK);
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte;</span>
 
 	spin_lock_irqsave(&amp;kmmio_lock, flags);
 	if (get_kmmio_probe(p-&gt;addr)) {
 		ret = -EEXIST;
 		goto out;
 	}
<span class="p_add">+</span>
<span class="p_add">+	pte = lookup_address(p-&gt;addr, &amp;l);</span>
<span class="p_add">+	if (!pte) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kmmio_count++;
 	list_add_rcu(&amp;p-&gt;list, &amp;kmmio_probes);
 	while (size &lt; size_lim) {
 		if (add_kmmio_fault_page(p-&gt;addr + size))
 			pr_err(&quot;Unable to set page fault.\n&quot;);
<span class="p_del">-		size += PAGE_SIZE;</span>
<span class="p_add">+		size += page_level_size(l);</span>
 	}
 out:
 	spin_unlock_irqrestore(&amp;kmmio_lock, flags);
<span class="p_chunk">@@ -506,11 +530,17 @@</span> <span class="p_context"> void unregister_kmmio_probe(struct kmmio_probe *p)</span>
 	const unsigned long size_lim = p-&gt;len + (p-&gt;addr &amp; ~PAGE_MASK);
 	struct kmmio_fault_page *release_list = NULL;
 	struct kmmio_delayed_release *drelease;
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = lookup_address(p-&gt;addr, &amp;l);</span>
<span class="p_add">+	if (!pte)</span>
<span class="p_add">+		return;</span>
 
 	spin_lock_irqsave(&amp;kmmio_lock, flags);
 	while (size &lt; size_lim) {
 		release_kmmio_fault_page(p-&gt;addr + size, &amp;release_list);
<span class="p_del">-		size += PAGE_SIZE;</span>
<span class="p_add">+		size += page_level_size(l);</span>
 	}
 	list_del_rcu(&amp;p-&gt;list);
 	kmmio_count--;
<span class="p_header">diff --git a/block/partition-generic.c b/block/partition-generic.c</span>
<span class="p_header">index fefd01b496a0..cfcfe1b0ecbc 100644</span>
<span class="p_header">--- a/block/partition-generic.c</span>
<span class="p_header">+++ b/block/partition-generic.c</span>
<span class="p_chunk">@@ -350,15 +350,20 @@</span> <span class="p_context"> struct hd_struct *add_partition(struct gendisk *disk, int partno,</span>
 			goto out_del;
 	}
 
<span class="p_add">+	err = hd_ref_init(p);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		if (flags &amp; ADDPART_FLAG_WHOLEDISK)</span>
<span class="p_add">+			goto out_remove_file;</span>
<span class="p_add">+		goto out_del;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* everything is up and running, commence */
 	rcu_assign_pointer(ptbl-&gt;part[partno], p);
 
 	/* suppress uevent if the disk suppresses it */
 	if (!dev_get_uevent_suppress(ddev))
 		kobject_uevent(&amp;pdev-&gt;kobj, KOBJ_ADD);
<span class="p_del">-</span>
<span class="p_del">-	if (!hd_ref_init(p))</span>
<span class="p_del">-		return p;</span>
<span class="p_add">+	return p;</span>
 
 out_free_info:
 	free_part_info(p);
<span class="p_chunk">@@ -367,6 +372,8 @@</span> <span class="p_context"> out_free_stats:</span>
 out_free:
 	kfree(p);
 	return ERR_PTR(err);
<span class="p_add">+out_remove_file:</span>
<span class="p_add">+	device_remove_file(pdev, &amp;dev_attr_whole_disk);</span>
 out_del:
 	kobject_put(p-&gt;holder_dir);
 	device_del(pdev);
<span class="p_header">diff --git a/crypto/rsa-pkcs1pad.c b/crypto/rsa-pkcs1pad.c</span>
<span class="p_header">index 50f5c97e1087..0cbc5a5025c2 100644</span>
<span class="p_header">--- a/crypto/rsa-pkcs1pad.c</span>
<span class="p_header">+++ b/crypto/rsa-pkcs1pad.c</span>
<span class="p_chunk">@@ -310,16 +310,16 @@</span> <span class="p_context"> static int pkcs1pad_decrypt(struct akcipher_request *req)</span>
 	req_ctx-&gt;child_req.src = req-&gt;src;
 	req_ctx-&gt;child_req.src_len = req-&gt;src_len;
 	req_ctx-&gt;child_req.dst = req_ctx-&gt;out_sg;
<span class="p_del">-	req_ctx-&gt;child_req.dst_len = ctx-&gt;key_size - 1;</span>
<span class="p_add">+	req_ctx-&gt;child_req.dst_len = ctx-&gt;key_size ;</span>
 
<span class="p_del">-	req_ctx-&gt;out_buf = kmalloc(ctx-&gt;key_size - 1,</span>
<span class="p_add">+	req_ctx-&gt;out_buf = kmalloc(ctx-&gt;key_size,</span>
 			(req-&gt;base.flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP) ?
 			GFP_KERNEL : GFP_ATOMIC);
 	if (!req_ctx-&gt;out_buf)
 		return -ENOMEM;
 
 	pkcs1pad_sg_set_buf(req_ctx-&gt;out_sg, req_ctx-&gt;out_buf,
<span class="p_del">-			ctx-&gt;key_size - 1, NULL);</span>
<span class="p_add">+			    ctx-&gt;key_size, NULL);</span>
 
 	akcipher_request_set_tfm(&amp;req_ctx-&gt;child_req, ctx-&gt;child);
 	akcipher_request_set_callback(&amp;req_ctx-&gt;child_req, req-&gt;base.flags,
<span class="p_chunk">@@ -491,16 +491,16 @@</span> <span class="p_context"> static int pkcs1pad_verify(struct akcipher_request *req)</span>
 	req_ctx-&gt;child_req.src = req-&gt;src;
 	req_ctx-&gt;child_req.src_len = req-&gt;src_len;
 	req_ctx-&gt;child_req.dst = req_ctx-&gt;out_sg;
<span class="p_del">-	req_ctx-&gt;child_req.dst_len = ctx-&gt;key_size - 1;</span>
<span class="p_add">+	req_ctx-&gt;child_req.dst_len = ctx-&gt;key_size;</span>
 
<span class="p_del">-	req_ctx-&gt;out_buf = kmalloc(ctx-&gt;key_size - 1,</span>
<span class="p_add">+	req_ctx-&gt;out_buf = kmalloc(ctx-&gt;key_size,</span>
 			(req-&gt;base.flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP) ?
 			GFP_KERNEL : GFP_ATOMIC);
 	if (!req_ctx-&gt;out_buf)
 		return -ENOMEM;
 
 	pkcs1pad_sg_set_buf(req_ctx-&gt;out_sg, req_ctx-&gt;out_buf,
<span class="p_del">-			ctx-&gt;key_size - 1, NULL);</span>
<span class="p_add">+			    ctx-&gt;key_size, NULL);</span>
 
 	akcipher_request_set_tfm(&amp;req_ctx-&gt;child_req, ctx-&gt;child);
 	akcipher_request_set_callback(&amp;req_ctx-&gt;child_req, req-&gt;base.flags,
<span class="p_header">diff --git a/drivers/acpi/acpica/nsinit.c b/drivers/acpi/acpica/nsinit.c</span>
<span class="p_header">index bd75d46234a4..ddb436f86415 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/nsinit.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/nsinit.c</span>
<span class="p_chunk">@@ -83,6 +83,8 @@</span> <span class="p_context"> acpi_status acpi_ns_initialize_objects(void)</span>
 
 	ACPI_FUNCTION_TRACE(ns_initialize_objects);
 
<span class="p_add">+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,</span>
<span class="p_add">+			  &quot;[Init] Completing Initialization of ACPI Objects\n&quot;));</span>
 	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
 			  &quot;**** Starting initialization of namespace objects ****\n&quot;));
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
<span class="p_header">diff --git a/drivers/acpi/acpica/tbxfload.c b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">index 278666e39563..c37d47982fbe 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_chunk">@@ -83,6 +83,20 @@</span> <span class="p_context"> acpi_status __init acpi_load_tables(void)</span>
 				&quot;While loading namespace from ACPI tables&quot;));
 	}
 
<span class="p_add">+	if (!acpi_gbl_group_module_level_code) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Initialize the objects that remain uninitialized. This</span>
<span class="p_add">+		 * runs the executable AML that may be part of the</span>
<span class="p_add">+		 * declaration of these objects:</span>
<span class="p_add">+		 * operation_regions, buffer_fields, Buffers, and Packages.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		status = acpi_ns_initialize_objects();</span>
<span class="p_add">+		if (ACPI_FAILURE(status)) {</span>
<span class="p_add">+			return_ACPI_STATUS(status);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	acpi_gbl_reg_methods_enabled = TRUE;</span>
 	return_ACPI_STATUS(status);
 }
 
<span class="p_header">diff --git a/drivers/acpi/acpica/utxfinit.c b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">index 721b87cce908..638fbd4ad72b 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_chunk">@@ -267,7 +267,6 @@</span> <span class="p_context"> acpi_status __init acpi_initialize_objects(u32 flags)</span>
 	 * initialized, even if they contain executable AML (see the call to
 	 * acpi_ns_initialize_objects below).
 	 */
<span class="p_del">-	acpi_gbl_reg_methods_enabled = TRUE;</span>
 	if (!(flags &amp; ACPI_NO_ADDRESS_SPACE_INIT)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 				  &quot;[Init] Executing _REG OpRegion methods\n&quot;));
<span class="p_chunk">@@ -299,20 +298,18 @@</span> <span class="p_context"> acpi_status __init acpi_initialize_objects(u32 flags)</span>
 	 */
 	if (acpi_gbl_group_module_level_code) {
 		acpi_ns_exec_module_code_list();
<span class="p_del">-	}</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Initialize the objects that remain uninitialized. This runs the</span>
<span class="p_del">-	 * executable AML that may be part of the declaration of these objects:</span>
<span class="p_del">-	 * operation_regions, buffer_fields, Buffers, and Packages.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!(flags &amp; ACPI_NO_OBJECT_INIT)) {</span>
<span class="p_del">-		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,</span>
<span class="p_del">-				  &quot;[Init] Completing Initialization of ACPI Objects\n&quot;));</span>
<span class="p_del">-</span>
<span class="p_del">-		status = acpi_ns_initialize_objects();</span>
<span class="p_del">-		if (ACPI_FAILURE(status)) {</span>
<span class="p_del">-			return_ACPI_STATUS(status);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Initialize the objects that remain uninitialized. This</span>
<span class="p_add">+		 * runs the executable AML that may be part of the</span>
<span class="p_add">+		 * declaration of these objects:</span>
<span class="p_add">+		 * operation_regions, buffer_fields, Buffers, and Packages.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!(flags &amp; ACPI_NO_OBJECT_INIT)) {</span>
<span class="p_add">+			status = acpi_ns_initialize_objects();</span>
<span class="p_add">+			if (ACPI_FAILURE(status)) {</span>
<span class="p_add">+				return_ACPI_STATUS(status);</span>
<span class="p_add">+			}</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/base/power/domain.c b/drivers/base/power/domain.c</span>
<span class="p_header">index 301b785f9f56..0caf92ae25f3 100644</span>
<span class="p_header">--- a/drivers/base/power/domain.c</span>
<span class="p_header">+++ b/drivers/base/power/domain.c</span>
<span class="p_chunk">@@ -1378,7 +1378,7 @@</span> <span class="p_context"> int pm_genpd_remove_subdomain(struct generic_pm_domain *genpd,</span>
 	mutex_lock(&amp;subdomain-&gt;lock);
 	mutex_lock_nested(&amp;genpd-&gt;lock, SINGLE_DEPTH_NESTING);
 
<span class="p_del">-	if (!list_empty(&amp;subdomain-&gt;slave_links) || subdomain-&gt;device_count) {</span>
<span class="p_add">+	if (!list_empty(&amp;subdomain-&gt;master_links) || subdomain-&gt;device_count) {</span>
 		pr_warn(&quot;%s: unable to remove subdomain %s\n&quot;, genpd-&gt;name,
 			subdomain-&gt;name);
 		ret = -EBUSY;
<span class="p_header">diff --git a/drivers/base/power/opp/core.c b/drivers/base/power/opp/core.c</span>
<span class="p_header">index cf351d3dab1c..0708f301ad97 100644</span>
<span class="p_header">--- a/drivers/base/power/opp/core.c</span>
<span class="p_header">+++ b/drivers/base/power/opp/core.c</span>
<span class="p_chunk">@@ -844,8 +844,14 @@</span> <span class="p_context"> static int opp_parse_supplies(struct dev_pm_opp *opp, struct device *dev,</span>
 	}
 
 	opp-&gt;u_volt = microvolt[0];
<span class="p_del">-	opp-&gt;u_volt_min = microvolt[1];</span>
<span class="p_del">-	opp-&gt;u_volt_max = microvolt[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (count == 1) {</span>
<span class="p_add">+		opp-&gt;u_volt_min = opp-&gt;u_volt;</span>
<span class="p_add">+		opp-&gt;u_volt_max = opp-&gt;u_volt;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		opp-&gt;u_volt_min = microvolt[1];</span>
<span class="p_add">+		opp-&gt;u_volt_max = microvolt[2];</span>
<span class="p_add">+	}</span>
 
 	/* Search for &quot;opp-microamp-&lt;name&gt;&quot; */
 	prop = NULL;
<span class="p_header">diff --git a/drivers/block/loop.c b/drivers/block/loop.c</span>
<span class="p_header">index 423f4ca7d712..80cf8add46ff 100644</span>
<span class="p_header">--- a/drivers/block/loop.c</span>
<span class="p_header">+++ b/drivers/block/loop.c</span>
<span class="p_chunk">@@ -488,6 +488,12 @@</span> <span class="p_context"> static int lo_rw_aio(struct loop_device *lo, struct loop_cmd *cmd,</span>
 	bvec = __bvec_iter_bvec(bio-&gt;bi_io_vec, bio-&gt;bi_iter);
 	iov_iter_bvec(&amp;iter, ITER_BVEC | rw, bvec,
 		      bio_segments(bio), blk_rq_bytes(cmd-&gt;rq));
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This bio may be started from the middle of the &#39;bvec&#39;</span>
<span class="p_add">+	 * because of bio splitting, so offset from the bvec must</span>
<span class="p_add">+	 * be passed to iov iterator</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	iter.iov_offset = bio-&gt;bi_iter.bi_bvec_done;</span>
 
 	cmd-&gt;iocb.ki_pos = pos;
 	cmd-&gt;iocb.ki_filp = file;
<span class="p_header">diff --git a/drivers/block/paride/pd.c b/drivers/block/paride/pd.c</span>
<span class="p_header">index 562b5a4ca7b7..78a39f736c64 100644</span>
<span class="p_header">--- a/drivers/block/paride/pd.c</span>
<span class="p_header">+++ b/drivers/block/paride/pd.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"></span>
 */
 #include &lt;linux/types.h&gt;
 
<span class="p_del">-static bool verbose = 0;</span>
<span class="p_add">+static int verbose = 0;</span>
 static int major = PD_MAJOR;
 static char *name = PD_NAME;
 static int cluster = 64;
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> enum {D_PRT, D_PRO, D_UNI, D_MOD, D_GEO, D_SBY, D_DLY, D_SLV};</span>
 static DEFINE_MUTEX(pd_mutex);
 static DEFINE_SPINLOCK(pd_lock);
 
<span class="p_del">-module_param(verbose, bool, 0);</span>
<span class="p_add">+module_param(verbose, int, 0);</span>
 module_param(major, int, 0);
 module_param(name, charp, 0);
 module_param(cluster, int, 0);
<span class="p_header">diff --git a/drivers/block/paride/pt.c b/drivers/block/paride/pt.c</span>
<span class="p_header">index 1740d75e8a32..216a94fed5b4 100644</span>
<span class="p_header">--- a/drivers/block/paride/pt.c</span>
<span class="p_header">+++ b/drivers/block/paride/pt.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"></span>
 
 */
 
<span class="p_del">-static bool verbose = 0;</span>
<span class="p_add">+static int verbose = 0;</span>
 static int major = PT_MAJOR;
 static char *name = PT_NAME;
 static int disable = 0;
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> static int (*drives[4])[6] = {&amp;drive0, &amp;drive1, &amp;drive2, &amp;drive3};</span>
 
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_del">-module_param(verbose, bool, 0);</span>
<span class="p_add">+module_param(verbose, int, 0);</span>
 module_param(major, int, 0);
 module_param(name, charp, 0);
 module_param_array(drive0, int, NULL, 0);
<span class="p_header">diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c</span>
<span class="p_header">index e98d15eaa799..1827fc4d15c1 100644</span>
<span class="p_header">--- a/drivers/bus/imx-weim.c</span>
<span class="p_header">+++ b/drivers/bus/imx-weim.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static int __init weim_parse_dt(struct platform_device *pdev,</span>
 			return ret;
 	}
 
<span class="p_del">-	for_each_child_of_node(pdev-&gt;dev.of_node, child) {</span>
<span class="p_add">+	for_each_available_child_of_node(pdev-&gt;dev.of_node, child) {</span>
 		if (!child-&gt;name)
 			continue;
 
<span class="p_header">diff --git a/drivers/bus/uniphier-system-bus.c b/drivers/bus/uniphier-system-bus.c</span>
<span class="p_header">index 834a2aeaf27a..350b7309c26d 100644</span>
<span class="p_header">--- a/drivers/bus/uniphier-system-bus.c</span>
<span class="p_header">+++ b/drivers/bus/uniphier-system-bus.c</span>
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> static int uniphier_system_bus_check_overlap(</span>
 
 	for (i = 0; i &lt; ARRAY_SIZE(priv-&gt;bank); i++) {
 		for (j = i + 1; j &lt; ARRAY_SIZE(priv-&gt;bank); j++) {
<span class="p_del">-			if (priv-&gt;bank[i].end &gt; priv-&gt;bank[j].base ||</span>
<span class="p_add">+			if (priv-&gt;bank[i].end &gt; priv-&gt;bank[j].base &amp;&amp;</span>
 			    priv-&gt;bank[i].base &lt; priv-&gt;bank[j].end) {
 				dev_err(priv-&gt;dev,
 					&quot;region overlap between bank%d and bank%d\n&quot;,
<span class="p_header">diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">index 45a634016f95..b28e4da3d2cf 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_chunk">@@ -20,7 +20,11 @@</span> <span class="p_context"></span>
 #include &lt;keys/trusted-type.h&gt;
 
 enum tpm2_object_attributes {
<span class="p_del">-	TPM2_ATTR_USER_WITH_AUTH	= BIT(6),</span>
<span class="p_add">+	TPM2_OA_USER_WITH_AUTH		= BIT(6),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+enum tpm2_session_attributes {</span>
<span class="p_add">+	TPM2_SA_CONTINUE_SESSION	= BIT(0),</span>
 };
 
 struct tpm2_startup_in {
<span class="p_chunk">@@ -478,22 +482,18 @@</span> <span class="p_context"> int tpm2_seal_trusted(struct tpm_chip *chip,</span>
 	tpm_buf_append_u8(&amp;buf, payload-&gt;migratable);
 
 	/* public */
<span class="p_del">-	if (options-&gt;policydigest)</span>
<span class="p_del">-		tpm_buf_append_u16(&amp;buf, 14 + options-&gt;digest_len);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		tpm_buf_append_u16(&amp;buf, 14);</span>
<span class="p_del">-</span>
<span class="p_add">+	tpm_buf_append_u16(&amp;buf, 14 + options-&gt;policydigest_len);</span>
 	tpm_buf_append_u16(&amp;buf, TPM2_ALG_KEYEDHASH);
 	tpm_buf_append_u16(&amp;buf, hash);
 
 	/* policy */
<span class="p_del">-	if (options-&gt;policydigest) {</span>
<span class="p_add">+	if (options-&gt;policydigest_len) {</span>
 		tpm_buf_append_u32(&amp;buf, 0);
<span class="p_del">-		tpm_buf_append_u16(&amp;buf, options-&gt;digest_len);</span>
<span class="p_add">+		tpm_buf_append_u16(&amp;buf, options-&gt;policydigest_len);</span>
 		tpm_buf_append(&amp;buf, options-&gt;policydigest,
<span class="p_del">-			       options-&gt;digest_len);</span>
<span class="p_add">+			       options-&gt;policydigest_len);</span>
 	} else {
<span class="p_del">-		tpm_buf_append_u32(&amp;buf, TPM2_ATTR_USER_WITH_AUTH);</span>
<span class="p_add">+		tpm_buf_append_u32(&amp;buf, TPM2_OA_USER_WITH_AUTH);</span>
 		tpm_buf_append_u16(&amp;buf, 0);
 	}
 
<span class="p_chunk">@@ -631,7 +631,7 @@</span> <span class="p_context"> static int tpm2_unseal(struct tpm_chip *chip,</span>
 			     options-&gt;policyhandle ?
 			     options-&gt;policyhandle : TPM2_RS_PW,
 			     NULL /* nonce */, 0,
<span class="p_del">-			     0 /* session_attributes */,</span>
<span class="p_add">+			     TPM2_SA_CONTINUE_SESSION,</span>
 			     options-&gt;blobauth /* hmac */,
 			     TPM_DIGEST_SIZE);
 
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index cd83d477e32d..e89512383c3c 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -673,6 +673,11 @@</span> <span class="p_context"> static int core_get_max_pstate(void)</span>
 			if (err)
 				goto skip_tar;
 
<span class="p_add">+			/* For level 1 and 2, bits[23:16] contain the ratio */</span>
<span class="p_add">+			if (tdp_ctrl)</span>
<span class="p_add">+				tdp_ratio &gt;&gt;= 16;</span>
<span class="p_add">+</span>
<span class="p_add">+			tdp_ratio &amp;= 0xff; /* ratios are only 8 bits long */</span>
 			if (tdp_ratio - 1 == tar) {
 				max_pstate = tar;
 				pr_debug(&quot;max_pstate=TAC %x\n&quot;, max_pstate);
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto-aes-cmac.c b/drivers/crypto/ccp/ccp-crypto-aes-cmac.c</span>
<span class="p_header">index 3d9acc53d247..60fc0fa26fd3 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto-aes-cmac.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto-aes-cmac.c</span>
<span class="p_chunk">@@ -225,6 +225,9 @@</span> <span class="p_context"> static int ccp_aes_cmac_export(struct ahash_request *req, void *out)</span>
 	struct ccp_aes_cmac_req_ctx *rctx = ahash_request_ctx(req);
 	struct ccp_aes_cmac_exp_ctx state;
 
<span class="p_add">+	/* Don&#39;t let anything leak to &#39;out&#39; */</span>
<span class="p_add">+	memset(&amp;state, 0, sizeof(state));</span>
<span class="p_add">+</span>
 	state.null_msg = rctx-&gt;null_msg;
 	memcpy(state.iv, rctx-&gt;iv, sizeof(state.iv));
 	state.buf_count = rctx-&gt;buf_count;
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto-sha.c b/drivers/crypto/ccp/ccp-crypto-sha.c</span>
<span class="p_header">index 8ef06fad8b14..ab9945f2cb7a 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto-sha.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto-sha.c</span>
<span class="p_chunk">@@ -212,6 +212,9 @@</span> <span class="p_context"> static int ccp_sha_export(struct ahash_request *req, void *out)</span>
 	struct ccp_sha_req_ctx *rctx = ahash_request_ctx(req);
 	struct ccp_sha_exp_ctx state;
 
<span class="p_add">+	/* Don&#39;t let anything leak to &#39;out&#39; */</span>
<span class="p_add">+	memset(&amp;state, 0, sizeof(state));</span>
<span class="p_add">+</span>
 	state.type = rctx-&gt;type;
 	state.msg_bits = rctx-&gt;msg_bits;
 	state.first = rctx-&gt;first;
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index a0d4a08313ae..aae05547b924 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -63,6 +63,14 @@</span> <span class="p_context"> static void to_talitos_ptr(struct talitos_ptr *ptr, dma_addr_t dma_addr,</span>
 		ptr-&gt;eptr = upper_32_bits(dma_addr);
 }
 
<span class="p_add">+static void copy_talitos_ptr(struct talitos_ptr *dst_ptr,</span>
<span class="p_add">+			     struct talitos_ptr *src_ptr, bool is_sec1)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dst_ptr-&gt;ptr = src_ptr-&gt;ptr;</span>
<span class="p_add">+	if (!is_sec1)</span>
<span class="p_add">+		dst_ptr-&gt;eptr = src_ptr-&gt;eptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void to_talitos_ptr_len(struct talitos_ptr *ptr, unsigned int len,
 			       bool is_sec1)
 {
<span class="p_chunk">@@ -1083,21 +1091,20 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 	sg_count = dma_map_sg(dev, areq-&gt;src, edesc-&gt;src_nents ?: 1,
 			      (areq-&gt;src == areq-&gt;dst) ? DMA_BIDIRECTIONAL
 							   : DMA_TO_DEVICE);
<span class="p_del">-</span>
 	/* hmac data */
 	desc-&gt;ptr[1].len = cpu_to_be16(areq-&gt;assoclen);
 	if (sg_count &gt; 1 &amp;&amp;
 	    (ret = sg_to_link_tbl_offset(areq-&gt;src, sg_count, 0,
 					 areq-&gt;assoclen,
 					 &amp;edesc-&gt;link_tbl[tbl_off])) &gt; 1) {
<span class="p_del">-		tbl_off += ret;</span>
<span class="p_del">-</span>
 		to_talitos_ptr(&amp;desc-&gt;ptr[1], edesc-&gt;dma_link_tbl + tbl_off *
 			       sizeof(struct talitos_ptr), 0);
 		desc-&gt;ptr[1].j_extent = DESC_PTR_LNKTBL_JUMP;
 
 		dma_sync_single_for_device(dev, edesc-&gt;dma_link_tbl,
 					   edesc-&gt;dma_len, DMA_BIDIRECTIONAL);
<span class="p_add">+</span>
<span class="p_add">+		tbl_off += ret;</span>
 	} else {
 		to_talitos_ptr(&amp;desc-&gt;ptr[1], sg_dma_address(areq-&gt;src), 0);
 		desc-&gt;ptr[1].j_extent = 0;
<span class="p_chunk">@@ -1126,11 +1133,13 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 	if (edesc-&gt;desc.hdr &amp; DESC_HDR_MODE1_MDEU_CICV)
 		sg_link_tbl_len += authsize;
 
<span class="p_del">-	if (sg_count &gt; 1 &amp;&amp;</span>
<span class="p_del">-	    (ret = sg_to_link_tbl_offset(areq-&gt;src, sg_count, areq-&gt;assoclen,</span>
<span class="p_del">-					 sg_link_tbl_len,</span>
<span class="p_del">-					 &amp;edesc-&gt;link_tbl[tbl_off])) &gt; 1) {</span>
<span class="p_del">-		tbl_off += ret;</span>
<span class="p_add">+	if (sg_count == 1) {</span>
<span class="p_add">+		to_talitos_ptr(&amp;desc-&gt;ptr[4], sg_dma_address(areq-&gt;src) +</span>
<span class="p_add">+			       areq-&gt;assoclen, 0);</span>
<span class="p_add">+	} else if ((ret = sg_to_link_tbl_offset(areq-&gt;src, sg_count,</span>
<span class="p_add">+						areq-&gt;assoclen, sg_link_tbl_len,</span>
<span class="p_add">+						&amp;edesc-&gt;link_tbl[tbl_off])) &gt;</span>
<span class="p_add">+		   1) {</span>
 		desc-&gt;ptr[4].j_extent |= DESC_PTR_LNKTBL_JUMP;
 		to_talitos_ptr(&amp;desc-&gt;ptr[4], edesc-&gt;dma_link_tbl +
 					      tbl_off *
<span class="p_chunk">@@ -1138,8 +1147,10 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 		dma_sync_single_for_device(dev, edesc-&gt;dma_link_tbl,
 					   edesc-&gt;dma_len,
 					   DMA_BIDIRECTIONAL);
<span class="p_del">-	} else</span>
<span class="p_del">-		to_talitos_ptr(&amp;desc-&gt;ptr[4], sg_dma_address(areq-&gt;src), 0);</span>
<span class="p_add">+		tbl_off += ret;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		copy_talitos_ptr(&amp;desc-&gt;ptr[4], &amp;edesc-&gt;link_tbl[tbl_off], 0);</span>
<span class="p_add">+	}</span>
 
 	/* cipher out */
 	desc-&gt;ptr[5].len = cpu_to_be16(cryptlen);
<span class="p_chunk">@@ -1151,11 +1162,13 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 
 	edesc-&gt;icv_ool = false;
 
<span class="p_del">-	if (sg_count &gt; 1 &amp;&amp;</span>
<span class="p_del">-	    (sg_count = sg_to_link_tbl_offset(areq-&gt;dst, sg_count,</span>
<span class="p_add">+	if (sg_count == 1) {</span>
<span class="p_add">+		to_talitos_ptr(&amp;desc-&gt;ptr[5], sg_dma_address(areq-&gt;dst) +</span>
<span class="p_add">+			       areq-&gt;assoclen, 0);</span>
<span class="p_add">+	} else if ((sg_count =</span>
<span class="p_add">+			sg_to_link_tbl_offset(areq-&gt;dst, sg_count,</span>
 					      areq-&gt;assoclen, cryptlen,
<span class="p_del">-					      &amp;edesc-&gt;link_tbl[tbl_off])) &gt;</span>
<span class="p_del">-	    1) {</span>
<span class="p_add">+					      &amp;edesc-&gt;link_tbl[tbl_off])) &gt; 1) {</span>
 		struct talitos_ptr *tbl_ptr = &amp;edesc-&gt;link_tbl[tbl_off];
 
 		to_talitos_ptr(&amp;desc-&gt;ptr[5], edesc-&gt;dma_link_tbl +
<span class="p_chunk">@@ -1178,8 +1191,9 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 					   edesc-&gt;dma_len, DMA_BIDIRECTIONAL);
 
 		edesc-&gt;icv_ool = true;
<span class="p_del">-	} else</span>
<span class="p_del">-		to_talitos_ptr(&amp;desc-&gt;ptr[5], sg_dma_address(areq-&gt;dst), 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		copy_talitos_ptr(&amp;desc-&gt;ptr[5], &amp;edesc-&gt;link_tbl[tbl_off], 0);</span>
<span class="p_add">+	}</span>
 
 	/* iv out */
 	map_single_talitos_ptr(dev, &amp;desc-&gt;ptr[6], ivsize, ctx-&gt;iv,
<span class="p_chunk">@@ -2629,21 +2643,11 @@</span> <span class="p_context"> struct talitos_crypto_alg {</span>
 	struct talitos_alg_template algt;
 };
 
<span class="p_del">-static int talitos_cra_init(struct crypto_tfm *tfm)</span>
<span class="p_add">+static int talitos_init_common(struct talitos_ctx *ctx,</span>
<span class="p_add">+			       struct talitos_crypto_alg *talitos_alg)</span>
 {
<span class="p_del">-	struct crypto_alg *alg = tfm-&gt;__crt_alg;</span>
<span class="p_del">-	struct talitos_crypto_alg *talitos_alg;</span>
<span class="p_del">-	struct talitos_ctx *ctx = crypto_tfm_ctx(tfm);</span>
 	struct talitos_private *priv;
 
<span class="p_del">-	if ((alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK) == CRYPTO_ALG_TYPE_AHASH)</span>
<span class="p_del">-		talitos_alg = container_of(__crypto_ahash_alg(alg),</span>
<span class="p_del">-					   struct talitos_crypto_alg,</span>
<span class="p_del">-					   algt.alg.hash);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		talitos_alg = container_of(alg, struct talitos_crypto_alg,</span>
<span class="p_del">-					   algt.alg.crypto);</span>
<span class="p_del">-</span>
 	/* update context with ptr to dev */
 	ctx-&gt;dev = talitos_alg-&gt;dev;
 
<span class="p_chunk">@@ -2661,10 +2665,33 @@</span> <span class="p_context"> static int talitos_cra_init(struct crypto_tfm *tfm)</span>
 	return 0;
 }
 
<span class="p_add">+static int talitos_cra_init(struct crypto_tfm *tfm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct crypto_alg *alg = tfm-&gt;__crt_alg;</span>
<span class="p_add">+	struct talitos_crypto_alg *talitos_alg;</span>
<span class="p_add">+	struct talitos_ctx *ctx = crypto_tfm_ctx(tfm);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK) == CRYPTO_ALG_TYPE_AHASH)</span>
<span class="p_add">+		talitos_alg = container_of(__crypto_ahash_alg(alg),</span>
<span class="p_add">+					   struct talitos_crypto_alg,</span>
<span class="p_add">+					   algt.alg.hash);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		talitos_alg = container_of(alg, struct talitos_crypto_alg,</span>
<span class="p_add">+					   algt.alg.crypto);</span>
<span class="p_add">+</span>
<span class="p_add">+	return talitos_init_common(ctx, talitos_alg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int talitos_cra_init_aead(struct crypto_aead *tfm)
 {
<span class="p_del">-	talitos_cra_init(crypto_aead_tfm(tfm));</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	struct aead_alg *alg = crypto_aead_alg(tfm);</span>
<span class="p_add">+	struct talitos_crypto_alg *talitos_alg;</span>
<span class="p_add">+	struct talitos_ctx *ctx = crypto_aead_ctx(tfm);</span>
<span class="p_add">+</span>
<span class="p_add">+	talitos_alg = container_of(alg, struct talitos_crypto_alg,</span>
<span class="p_add">+				   algt.alg.aead);</span>
<span class="p_add">+</span>
<span class="p_add">+	return talitos_init_common(ctx, talitos_alg);</span>
 }
 
 static int talitos_cra_init_ahash(struct crypto_tfm *tfm)
<span class="p_header">diff --git a/drivers/dma/dw/core.c b/drivers/dma/dw/core.c</span>
<span class="p_header">index 5ad0ec1f0e29..97199b3c25a2 100644</span>
<span class="p_header">--- a/drivers/dma/dw/core.c</span>
<span class="p_header">+++ b/drivers/dma/dw/core.c</span>
<span class="p_chunk">@@ -130,26 +130,14 @@</span> <span class="p_context"> static void dwc_desc_put(struct dw_dma_chan *dwc, struct dw_desc *desc)</span>
 static void dwc_initialize(struct dw_dma_chan *dwc)
 {
 	struct dw_dma *dw = to_dw_dma(dwc-&gt;chan.device);
<span class="p_del">-	struct dw_dma_slave *dws = dwc-&gt;chan.private;</span>
 	u32 cfghi = DWC_CFGH_FIFO_MODE;
 	u32 cfglo = DWC_CFGL_CH_PRIOR(dwc-&gt;priority);
 
 	if (dwc-&gt;initialized == true)
 		return;
 
<span class="p_del">-	if (dws) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We need controller-specific data to set up slave</span>
<span class="p_del">-		 * transfers.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		BUG_ON(!dws-&gt;dma_dev || dws-&gt;dma_dev != dw-&gt;dma.dev);</span>
<span class="p_del">-</span>
<span class="p_del">-		cfghi |= DWC_CFGH_DST_PER(dws-&gt;dst_id);</span>
<span class="p_del">-		cfghi |= DWC_CFGH_SRC_PER(dws-&gt;src_id);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		cfghi |= DWC_CFGH_DST_PER(dwc-&gt;dst_id);</span>
<span class="p_del">-		cfghi |= DWC_CFGH_SRC_PER(dwc-&gt;src_id);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	cfghi |= DWC_CFGH_DST_PER(dwc-&gt;dst_id);</span>
<span class="p_add">+	cfghi |= DWC_CFGH_SRC_PER(dwc-&gt;src_id);</span>
 
 	channel_writel(dwc, CFG_LO, cfglo);
 	channel_writel(dwc, CFG_HI, cfghi);
<span class="p_chunk">@@ -941,7 +929,7 @@</span> <span class="p_context"> bool dw_dma_filter(struct dma_chan *chan, void *param)</span>
 	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
 	struct dw_dma_slave *dws = param;
 
<span class="p_del">-	if (!dws || dws-&gt;dma_dev != chan-&gt;device-&gt;dev)</span>
<span class="p_add">+	if (dws-&gt;dma_dev != chan-&gt;device-&gt;dev)</span>
 		return false;
 
 	/* We have to copy data since dws can be temporary storage */
<span class="p_chunk">@@ -1165,6 +1153,14 @@</span> <span class="p_context"> static int dwc_alloc_chan_resources(struct dma_chan *chan)</span>
 	 * doesn&#39;t mean what you think it means), and status writeback.
 	 */
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need controller-specific data to set up slave transfers.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (chan-&gt;private &amp;&amp; !dw_dma_filter(chan, chan-&gt;private)) {</span>
<span class="p_add">+		dev_warn(chan2dev(chan), &quot;Wrong controller-specific data\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Enable controller here if needed */
 	if (!dw-&gt;in_use)
 		dw_dma_on(dw);
<span class="p_chunk">@@ -1226,6 +1222,14 @@</span> <span class="p_context"> static void dwc_free_chan_resources(struct dma_chan *chan)</span>
 	spin_lock_irqsave(&amp;dwc-&gt;lock, flags);
 	list_splice_init(&amp;dwc-&gt;free_list, &amp;list);
 	dwc-&gt;descs_allocated = 0;
<span class="p_add">+</span>
<span class="p_add">+	/* Clear custom channel configuration */</span>
<span class="p_add">+	dwc-&gt;src_id = 0;</span>
<span class="p_add">+	dwc-&gt;dst_id = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	dwc-&gt;src_master = 0;</span>
<span class="p_add">+	dwc-&gt;dst_master = 0;</span>
<span class="p_add">+</span>
 	dwc-&gt;initialized = false;
 
 	/* Disable interrupts */
<span class="p_header">diff --git a/drivers/dma/edma.c b/drivers/dma/edma.c</span>
<span class="p_header">index e3d7fcb69b4c..2dac314a2d7a 100644</span>
<span class="p_header">--- a/drivers/dma/edma.c</span>
<span class="p_header">+++ b/drivers/dma/edma.c</span>
<span class="p_chunk">@@ -1563,32 +1563,6 @@</span> <span class="p_context"> static irqreturn_t dma_ccerr_handler(int irq, void *data)</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_del">-static void edma_tc_set_pm_state(struct edma_tc *tc, bool enable)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct platform_device *tc_pdev;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!IS_ENABLED(CONFIG_OF) || !tc)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	tc_pdev = of_find_device_by_node(tc-&gt;node);</span>
<span class="p_del">-	if (!tc_pdev) {</span>
<span class="p_del">-		pr_err(&quot;%s: TPTC device is not found\n&quot;, __func__);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (!pm_runtime_enabled(&amp;tc_pdev-&gt;dev))</span>
<span class="p_del">-		pm_runtime_enable(&amp;tc_pdev-&gt;dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (enable)</span>
<span class="p_del">-		ret = pm_runtime_get_sync(&amp;tc_pdev-&gt;dev);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		ret = pm_runtime_put_sync(&amp;tc_pdev-&gt;dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		pr_err(&quot;%s: pm_runtime_%s_sync() failed for %s\n&quot;, __func__,</span>
<span class="p_del">-		       enable ? &quot;get&quot; : &quot;put&quot;, dev_name(&amp;tc_pdev-&gt;dev));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Alloc channel resources */
 static int edma_alloc_chan_resources(struct dma_chan *chan)
 {
<span class="p_chunk">@@ -1625,8 +1599,6 @@</span> <span class="p_context"> static int edma_alloc_chan_resources(struct dma_chan *chan)</span>
 		EDMA_CHAN_SLOT(echan-&gt;ch_num), chan-&gt;chan_id,
 		echan-&gt;hw_triggered ? &quot;HW&quot; : &quot;SW&quot;);
 
<span class="p_del">-	edma_tc_set_pm_state(echan-&gt;tc, true);</span>
<span class="p_del">-</span>
 	return 0;
 
 err_slot:
<span class="p_chunk">@@ -1663,7 +1635,6 @@</span> <span class="p_context"> static void edma_free_chan_resources(struct dma_chan *chan)</span>
 		echan-&gt;alloced = false;
 	}
 
<span class="p_del">-	edma_tc_set_pm_state(echan-&gt;tc, false);</span>
 	echan-&gt;tc = NULL;
 	echan-&gt;hw_triggered = false;
 
<span class="p_chunk">@@ -2408,10 +2379,8 @@</span> <span class="p_context"> static int edma_pm_suspend(struct device *dev)</span>
 	int i;
 
 	for (i = 0; i &lt; ecc-&gt;num_channels; i++) {
<span class="p_del">-		if (echan[i].alloced) {</span>
<span class="p_add">+		if (echan[i].alloced)</span>
 			edma_setup_interrupt(&amp;echan[i], false);
<span class="p_del">-			edma_tc_set_pm_state(echan[i].tc, false);</span>
<span class="p_del">-		}</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -2441,8 +2410,6 @@</span> <span class="p_context"> static int edma_pm_resume(struct device *dev)</span>
 
 			/* Set up channel -&gt; slot mapping for the entry slot */
 			edma_set_chmap(&amp;echan[i], echan[i].slot[0]);
<span class="p_del">-</span>
<span class="p_del">-			edma_tc_set_pm_state(echan[i].tc, true);</span>
 		}
 	}
 
<span class="p_chunk">@@ -2466,7 +2433,8 @@</span> <span class="p_context"> static struct platform_driver edma_driver = {</span>
 
 static int edma_tptc_probe(struct platform_device *pdev)
 {
<span class="p_del">-	return 0;</span>
<span class="p_add">+	pm_runtime_enable(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	return pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
 }
 
 static struct platform_driver edma_tptc_driver = {
<span class="p_header">diff --git a/drivers/dma/hsu/hsu.c b/drivers/dma/hsu/hsu.c</span>
<span class="p_header">index eef145edb936..025d375fc3d7 100644</span>
<span class="p_header">--- a/drivers/dma/hsu/hsu.c</span>
<span class="p_header">+++ b/drivers/dma/hsu/hsu.c</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> static u32 hsu_dma_chan_get_sr(struct hsu_dma_chan *hsuc)</span>
 	sr = hsu_chan_readl(hsuc, HSU_CH_SR);
 	spin_unlock_irqrestore(&amp;hsuc-&gt;vchan.lock, flags);
 
<span class="p_del">-	return sr;</span>
<span class="p_add">+	return sr &amp; ~(HSU_CH_SR_DESCE_ANY | HSU_CH_SR_CDESC_ANY);</span>
 }
 
 irqreturn_t hsu_dma_irq(struct hsu_dma_chip *chip, unsigned short nr)
<span class="p_chunk">@@ -254,10 +254,13 @@</span> <span class="p_context"> static void hsu_dma_issue_pending(struct dma_chan *chan)</span>
 static size_t hsu_dma_active_desc_size(struct hsu_dma_chan *hsuc)
 {
 	struct hsu_dma_desc *desc = hsuc-&gt;desc;
<span class="p_del">-	size_t bytes = desc-&gt;length;</span>
<span class="p_add">+	size_t bytes = 0;</span>
 	int i;
 
<span class="p_del">-	i = desc-&gt;active % HSU_DMA_CHAN_NR_DESC;</span>
<span class="p_add">+	for (i = desc-&gt;active; i &lt; desc-&gt;nents; i++)</span>
<span class="p_add">+		bytes += desc-&gt;sg[i].len;</span>
<span class="p_add">+</span>
<span class="p_add">+	i = HSU_DMA_CHAN_NR_DESC - 1;</span>
 	do {
 		bytes += hsu_chan_readl(hsuc, HSU_CH_DxTSR(i));
 	} while (--i &gt;= 0);
<span class="p_header">diff --git a/drivers/dma/hsu/hsu.h b/drivers/dma/hsu/hsu.h</span>
<span class="p_header">index 578a8ee8cd05..6b070c22b1df 100644</span>
<span class="p_header">--- a/drivers/dma/hsu/hsu.h</span>
<span class="p_header">+++ b/drivers/dma/hsu/hsu.h</span>
<span class="p_chunk">@@ -41,6 +41,9 @@</span> <span class="p_context"></span>
 #define HSU_CH_SR_DESCTO(x)	BIT(8 + (x))
 #define HSU_CH_SR_DESCTO_ANY	(BIT(11) | BIT(10) | BIT(9) | BIT(8))
 #define HSU_CH_SR_CHE		BIT(15)
<span class="p_add">+#define HSU_CH_SR_DESCE(x)	BIT(16 + (x))</span>
<span class="p_add">+#define HSU_CH_SR_DESCE_ANY	(BIT(19) | BIT(18) | BIT(17) | BIT(16))</span>
<span class="p_add">+#define HSU_CH_SR_CDESC_ANY	(BIT(31) | BIT(30))</span>
 
 /* Bits in HSU_CH_CR */
 #define HSU_CH_CR_CHA		BIT(0)
<span class="p_header">diff --git a/drivers/dma/omap-dma.c b/drivers/dma/omap-dma.c</span>
<span class="p_header">index 9794b073d7d7..a5ed9407c51b 100644</span>
<span class="p_header">--- a/drivers/dma/omap-dma.c</span>
<span class="p_header">+++ b/drivers/dma/omap-dma.c</span>
<span class="p_chunk">@@ -48,6 +48,7 @@</span> <span class="p_context"> struct omap_chan {</span>
 	unsigned dma_sig;
 	bool cyclic;
 	bool paused;
<span class="p_add">+	bool running;</span>
 
 	int dma_ch;
 	struct omap_desc *desc;
<span class="p_chunk">@@ -294,6 +295,8 @@</span> <span class="p_context"> static void omap_dma_start(struct omap_chan *c, struct omap_desc *d)</span>
 
 	/* Enable channel */
 	omap_dma_chan_write(c, CCR, d-&gt;ccr | CCR_ENABLE);
<span class="p_add">+</span>
<span class="p_add">+	c-&gt;running = true;</span>
 }
 
 static void omap_dma_stop(struct omap_chan *c)
<span class="p_chunk">@@ -355,6 +358,8 @@</span> <span class="p_context"> static void omap_dma_stop(struct omap_chan *c)</span>
 
 		omap_dma_chan_write(c, CLNK_CTRL, val);
 	}
<span class="p_add">+</span>
<span class="p_add">+	c-&gt;running = false;</span>
 }
 
 static void omap_dma_start_sg(struct omap_chan *c, struct omap_desc *d,
<span class="p_chunk">@@ -673,15 +678,20 @@</span> <span class="p_context"> static enum dma_status omap_dma_tx_status(struct dma_chan *chan,</span>
 	struct omap_chan *c = to_omap_dma_chan(chan);
 	struct virt_dma_desc *vd;
 	enum dma_status ret;
<span class="p_del">-	uint32_t ccr;</span>
 	unsigned long flags;
 
<span class="p_del">-	ccr = omap_dma_chan_read(c, CCR);</span>
<span class="p_del">-	/* The channel is no longer active, handle the completion right away */</span>
<span class="p_del">-	if (!(ccr &amp; CCR_ENABLE))</span>
<span class="p_del">-		omap_dma_callback(c-&gt;dma_ch, 0, c);</span>
<span class="p_del">-</span>
 	ret = dma_cookie_status(chan, cookie, txstate);
<span class="p_add">+</span>
<span class="p_add">+	if (!c-&gt;paused &amp;&amp; c-&gt;running) {</span>
<span class="p_add">+		uint32_t ccr = omap_dma_chan_read(c, CCR);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The channel is no longer active, set the return value</span>
<span class="p_add">+		 * accordingly</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!(ccr &amp; CCR_ENABLE))</span>
<span class="p_add">+			ret = DMA_COMPLETE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (ret == DMA_COMPLETE || !txstate)
 		return ret;
 
<span class="p_header">diff --git a/drivers/dma/pxa_dma.c b/drivers/dma/pxa_dma.c</span>
<span class="p_header">index debca824bed6..77c1c44009d8 100644</span>
<span class="p_header">--- a/drivers/dma/pxa_dma.c</span>
<span class="p_header">+++ b/drivers/dma/pxa_dma.c</span>
<span class="p_chunk">@@ -122,6 +122,7 @@</span> <span class="p_context"> struct pxad_chan {</span>
 struct pxad_device {
 	struct dma_device		slave;
 	int				nr_chans;
<span class="p_add">+	int				nr_requestors;</span>
 	void __iomem			*base;
 	struct pxad_phy			*phys;
 	spinlock_t			phy_lock;	/* Phy association */
<span class="p_chunk">@@ -473,7 +474,7 @@</span> <span class="p_context"> static void pxad_free_phy(struct pxad_chan *chan)</span>
 		return;
 
 	/* clear the channel mapping in DRCMR */
<span class="p_del">-	if (chan-&gt;drcmr &lt;= DRCMR_CHLNUM) {</span>
<span class="p_add">+	if (chan-&gt;drcmr &lt;= pdev-&gt;nr_requestors) {</span>
 		reg = pxad_drcmr(chan-&gt;drcmr);
 		writel_relaxed(0, chan-&gt;phy-&gt;base + reg);
 	}
<span class="p_chunk">@@ -509,6 +510,7 @@</span> <span class="p_context"> static bool is_running_chan_misaligned(struct pxad_chan *chan)</span>
 
 static void phy_enable(struct pxad_phy *phy, bool misaligned)
 {
<span class="p_add">+	struct pxad_device *pdev;</span>
 	u32 reg, dalgn;
 
 	if (!phy-&gt;vchan)
<span class="p_chunk">@@ -518,7 +520,8 @@</span> <span class="p_context"> static void phy_enable(struct pxad_phy *phy, bool misaligned)</span>
 		&quot;%s(); phy=%p(%d) misaligned=%d\n&quot;, __func__,
 		phy, phy-&gt;idx, misaligned);
 
<span class="p_del">-	if (phy-&gt;vchan-&gt;drcmr &lt;= DRCMR_CHLNUM) {</span>
<span class="p_add">+	pdev = to_pxad_dev(phy-&gt;vchan-&gt;vc.chan.device);</span>
<span class="p_add">+	if (phy-&gt;vchan-&gt;drcmr &lt;= pdev-&gt;nr_requestors) {</span>
 		reg = pxad_drcmr(phy-&gt;vchan-&gt;drcmr);
 		writel_relaxed(DRCMR_MAPVLD | phy-&gt;idx, phy-&gt;base + reg);
 	}
<span class="p_chunk">@@ -914,6 +917,7 @@</span> <span class="p_context"> static void pxad_get_config(struct pxad_chan *chan,</span>
 {
 	u32 maxburst = 0, dev_addr = 0;
 	enum dma_slave_buswidth width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
<span class="p_add">+	struct pxad_device *pdev = to_pxad_dev(chan-&gt;vc.chan.device);</span>
 
 	*dcmd = 0;
 	if (dir == DMA_DEV_TO_MEM) {
<span class="p_chunk">@@ -922,7 +926,7 @@</span> <span class="p_context"> static void pxad_get_config(struct pxad_chan *chan,</span>
 		dev_addr = chan-&gt;cfg.src_addr;
 		*dev_src = dev_addr;
 		*dcmd |= PXA_DCMD_INCTRGADDR;
<span class="p_del">-		if (chan-&gt;drcmr &lt;= DRCMR_CHLNUM)</span>
<span class="p_add">+		if (chan-&gt;drcmr &lt;= pdev-&gt;nr_requestors)</span>
 			*dcmd |= PXA_DCMD_FLOWSRC;
 	}
 	if (dir == DMA_MEM_TO_DEV) {
<span class="p_chunk">@@ -931,7 +935,7 @@</span> <span class="p_context"> static void pxad_get_config(struct pxad_chan *chan,</span>
 		dev_addr = chan-&gt;cfg.dst_addr;
 		*dev_dst = dev_addr;
 		*dcmd |= PXA_DCMD_INCSRCADDR;
<span class="p_del">-		if (chan-&gt;drcmr &lt;= DRCMR_CHLNUM)</span>
<span class="p_add">+		if (chan-&gt;drcmr &lt;= pdev-&gt;nr_requestors)</span>
 			*dcmd |= PXA_DCMD_FLOWTRG;
 	}
 	if (dir == DMA_MEM_TO_MEM)
<span class="p_chunk">@@ -1341,13 +1345,15 @@</span> <span class="p_context"> static struct dma_chan *pxad_dma_xlate(struct of_phandle_args *dma_spec,</span>
 
 static int pxad_init_dmadev(struct platform_device *op,
 			    struct pxad_device *pdev,
<span class="p_del">-			    unsigned int nr_phy_chans)</span>
<span class="p_add">+			    unsigned int nr_phy_chans,</span>
<span class="p_add">+			    unsigned int nr_requestors)</span>
 {
 	int ret;
 	unsigned int i;
 	struct pxad_chan *c;
 
 	pdev-&gt;nr_chans = nr_phy_chans;
<span class="p_add">+	pdev-&gt;nr_requestors = nr_requestors;</span>
 	INIT_LIST_HEAD(&amp;pdev-&gt;slave.channels);
 	pdev-&gt;slave.device_alloc_chan_resources = pxad_alloc_chan_resources;
 	pdev-&gt;slave.device_free_chan_resources = pxad_free_chan_resources;
<span class="p_chunk">@@ -1382,7 +1388,7 @@</span> <span class="p_context"> static int pxad_probe(struct platform_device *op)</span>
 	const struct of_device_id *of_id;
 	struct mmp_dma_platdata *pdata = dev_get_platdata(&amp;op-&gt;dev);
 	struct resource *iores;
<span class="p_del">-	int ret, dma_channels = 0;</span>
<span class="p_add">+	int ret, dma_channels = 0, nb_requestors = 0;</span>
 	const enum dma_slave_buswidth widths =
 		DMA_SLAVE_BUSWIDTH_1_BYTE   | DMA_SLAVE_BUSWIDTH_2_BYTES |
 		DMA_SLAVE_BUSWIDTH_4_BYTES;
<span class="p_chunk">@@ -1399,13 +1405,23 @@</span> <span class="p_context"> static int pxad_probe(struct platform_device *op)</span>
 		return PTR_ERR(pdev-&gt;base);
 
 	of_id = of_match_device(pxad_dt_ids, &amp;op-&gt;dev);
<span class="p_del">-	if (of_id)</span>
<span class="p_add">+	if (of_id) {</span>
 		of_property_read_u32(op-&gt;dev.of_node, &quot;#dma-channels&quot;,
 				     &amp;dma_channels);
<span class="p_del">-	else if (pdata &amp;&amp; pdata-&gt;dma_channels)</span>
<span class="p_add">+		ret = of_property_read_u32(op-&gt;dev.of_node, &quot;#dma-requests&quot;,</span>
<span class="p_add">+					   &amp;nb_requestors);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_warn(pdev-&gt;slave.dev,</span>
<span class="p_add">+				 &quot;#dma-requests set to default 32 as missing in OF: %d&quot;,</span>
<span class="p_add">+				 ret);</span>
<span class="p_add">+			nb_requestors = 32;</span>
<span class="p_add">+		};</span>
<span class="p_add">+	} else if (pdata &amp;&amp; pdata-&gt;dma_channels) {</span>
 		dma_channels = pdata-&gt;dma_channels;
<span class="p_del">-	else</span>
<span class="p_add">+		nb_requestors = pdata-&gt;nb_requestors;</span>
<span class="p_add">+	} else {</span>
 		dma_channels = 32;	/* default 32 channel */
<span class="p_add">+	}</span>
 
 	dma_cap_set(DMA_SLAVE, pdev-&gt;slave.cap_mask);
 	dma_cap_set(DMA_MEMCPY, pdev-&gt;slave.cap_mask);
<span class="p_chunk">@@ -1423,7 +1439,7 @@</span> <span class="p_context"> static int pxad_probe(struct platform_device *op)</span>
 	pdev-&gt;slave.descriptor_reuse = true;
 
 	pdev-&gt;slave.dev = &amp;op-&gt;dev;
<span class="p_del">-	ret = pxad_init_dmadev(op, pdev, dma_channels);</span>
<span class="p_add">+	ret = pxad_init_dmadev(op, pdev, dma_channels, nb_requestors);</span>
 	if (ret) {
 		dev_err(pdev-&gt;slave.dev, &quot;unable to register\n&quot;);
 		return ret;
<span class="p_chunk">@@ -1442,7 +1458,8 @@</span> <span class="p_context"> static int pxad_probe(struct platform_device *op)</span>
 
 	platform_set_drvdata(op, pdev);
 	pxad_init_debugfs(pdev);
<span class="p_del">-	dev_info(pdev-&gt;slave.dev, &quot;initialized %d channels\n&quot;, dma_channels);</span>
<span class="p_add">+	dev_info(pdev-&gt;slave.dev, &quot;initialized %d channels on %d requestors\n&quot;,</span>
<span class="p_add">+		 dma_channels, nb_requestors);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c</span>
<span class="p_header">index 01087a38da22..792bdae2b91d 100644</span>
<span class="p_header">--- a/drivers/edac/i7core_edac.c</span>
<span class="p_header">+++ b/drivers/edac/i7core_edac.c</span>
<span class="p_chunk">@@ -1866,7 +1866,7 @@</span> <span class="p_context"> static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,</span>
 
 	i7_dev = get_i7core_dev(mce-&gt;socketid);
 	if (!i7_dev)
<span class="p_del">-		return NOTIFY_BAD;</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
 
 	mci = i7_dev-&gt;mci;
 	pvt = mci-&gt;pvt_info;
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index 93f0d4120289..8bf745d2da7e 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -362,6 +362,7 @@</span> <span class="p_context"> struct sbridge_pvt {</span>
 
 	/* Memory type detection */
 	bool			is_mirrored, is_lockstep, is_close_pg;
<span class="p_add">+	bool			is_chan_hash;</span>
 
 	/* Fifo double buffers */
 	struct mce		mce_entry[MCE_LOG_LEN];
<span class="p_chunk">@@ -1060,6 +1061,20 @@</span> <span class="p_context"> static inline u8 sad_pkg_ha(u8 pkg)</span>
 	return (pkg &gt;&gt; 2) &amp; 0x1;
 }
 
<span class="p_add">+static int haswell_chan_hash(int idx, u64 addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * XOR even bits from 12:26 to bit0 of idx,</span>
<span class="p_add">+	 *     odd bits from 13:27 to bit1</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 12; i &lt; 28; i += 2)</span>
<span class="p_add">+		idx ^= (addr &gt;&gt; i) &amp; 3;</span>
<span class="p_add">+</span>
<span class="p_add">+	return idx;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
<span class="p_chunk">@@ -1616,6 +1631,10 @@</span> <span class="p_context"> static int get_dimm_config(struct mem_ctl_info *mci)</span>
 		KNL_MAX_CHANNELS : NUM_CHANNELS;
 	u64 knl_mc_sizes[KNL_MAX_CHANNELS];
 
<span class="p_add">+	if (pvt-&gt;info.type == HASWELL || pvt-&gt;info.type == BROADWELL) {</span>
<span class="p_add">+		pci_read_config_dword(pvt-&gt;pci_ha0, HASWELL_HASYSDEFEATURE2, &amp;reg);</span>
<span class="p_add">+		pvt-&gt;is_chan_hash = GET_BITFIELD(reg, 21, 21);</span>
<span class="p_add">+	}</span>
 	if (pvt-&gt;info.type == HASWELL || pvt-&gt;info.type == BROADWELL ||
 			pvt-&gt;info.type == KNIGHTS_LANDING)
 		pci_read_config_dword(pvt-&gt;pci_sad1, SAD_TARGET, &amp;reg);
<span class="p_chunk">@@ -2118,12 +2137,15 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 	}
 
 	ch_way = TAD_CH(reg) + 1;
<span class="p_del">-	sck_way = 1 &lt;&lt; TAD_SOCK(reg);</span>
<span class="p_add">+	sck_way = TAD_SOCK(reg);</span>
 
 	if (ch_way == 3)
 		idx = addr &gt;&gt; 6;
<span class="p_del">-	else</span>
<span class="p_add">+	else {</span>
 		idx = (addr &gt;&gt; (6 + sck_way + shiftup)) &amp; 0x3;
<span class="p_add">+		if (pvt-&gt;is_chan_hash)</span>
<span class="p_add">+			idx = haswell_chan_hash(idx, addr);</span>
<span class="p_add">+	}</span>
 	idx = idx % ch_way;
 
 	/*
<span class="p_chunk">@@ -2157,7 +2179,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 		switch(ch_way) {
 		case 2:
 		case 4:
<span class="p_del">-			sck_xch = 1 &lt;&lt; sck_way * (ch_way &gt;&gt; 1);</span>
<span class="p_add">+			sck_xch = (1 &lt;&lt; sck_way) * (ch_way &gt;&gt; 1);</span>
 			break;
 		default:
 			sprintf(msg, &quot;Invalid mirror set. Can&#39;t decode addr&quot;);
<span class="p_chunk">@@ -2193,7 +2215,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 
 	ch_addr = addr - offset;
 	ch_addr &gt;&gt;= (6 + shiftup);
<span class="p_del">-	ch_addr /= ch_way * sck_way;</span>
<span class="p_add">+	ch_addr /= sck_xch;</span>
 	ch_addr &lt;&lt;= (6 + shiftup);
 	ch_addr |= addr &amp; ((1 &lt;&lt; (6 + shiftup)) - 1);
 
<span class="p_chunk">@@ -3146,7 +3168,7 @@</span> <span class="p_context"> static int sbridge_mce_check_error(struct notifier_block *nb, unsigned long val,</span>
 
 	mci = get_mci_for_node_id(mce-&gt;socketid);
 	if (!mci)
<span class="p_del">-		return NOTIFY_BAD;</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
 	pvt = mci-&gt;pvt_info;
 
 	/*
<span class="p_header">diff --git a/drivers/extcon/extcon-max77843.c b/drivers/extcon/extcon-max77843.c</span>
<span class="p_header">index 74dfb7f4f277..d8cac4661cfe 100644</span>
<span class="p_header">--- a/drivers/extcon/extcon-max77843.c</span>
<span class="p_header">+++ b/drivers/extcon/extcon-max77843.c</span>
<span class="p_chunk">@@ -803,7 +803,7 @@</span> <span class="p_context"> static int max77843_muic_probe(struct platform_device *pdev)</span>
 	/* Clear IRQ bits before request IRQs */
 	ret = regmap_bulk_read(max77843-&gt;regmap_muic,
 			MAX77843_MUIC_REG_INT1, info-&gt;status,
<span class="p_del">-			MAX77843_MUIC_IRQ_NUM);</span>
<span class="p_add">+			MAX77843_MUIC_STATUS_NUM);</span>
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to Clear IRQ bits\n&quot;);
 		goto err_muic_irq;
<span class="p_header">diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c</span>
<span class="p_header">index 9e15d571b53c..a76c35fc0b92 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/arm-init.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/arm-init.c</span>
<span class="p_chunk">@@ -203,7 +203,19 @@</span> <span class="p_context"> void __init efi_init(void)</span>
 
 	reserve_regions();
 	early_memunmap(memmap.map, params.mmap_size);
<span class="p_del">-	memblock_mark_nomap(params.mmap &amp; PAGE_MASK,</span>
<span class="p_del">-			    PAGE_ALIGN(params.mmap_size +</span>
<span class="p_del">-				       (params.mmap &amp; ~PAGE_MASK)));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_ARM)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * ARM currently does not allow ioremap_cache() to be called on</span>
<span class="p_add">+		 * memory regions that are covered by struct page. So remove the</span>
<span class="p_add">+		 * UEFI memory map from the linear mapping.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		memblock_mark_nomap(params.mmap &amp; PAGE_MASK,</span>
<span class="p_add">+				    PAGE_ALIGN(params.mmap_size +</span>
<span class="p_add">+					       (params.mmap &amp; ~PAGE_MASK)));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		memblock_reserve(params.mmap &amp; PAGE_MASK,</span>
<span class="p_add">+				 PAGE_ALIGN(params.mmap_size +</span>
<span class="p_add">+					    (params.mmap &amp; ~PAGE_MASK)));</span>
<span class="p_add">+	}</span>
 }
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index 2cd37dad67a6..c51f3b2fe3c0 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -182,6 +182,7 @@</span> <span class="p_context"> static int generic_ops_register(void)</span>
 {
 	generic_ops.get_variable = efi.get_variable;
 	generic_ops.set_variable = efi.set_variable;
<span class="p_add">+	generic_ops.set_variable_nonblocking = efi.set_variable_nonblocking;</span>
 	generic_ops.get_next_variable = efi.get_next_variable;
 	generic_ops.query_variable_store = efi_query_variable_store;
 
<span class="p_header">diff --git a/drivers/firmware/efi/vars.c b/drivers/firmware/efi/vars.c</span>
<span class="p_header">index 7f2ea21c730d..6f182fd91a6d 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/vars.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/vars.c</span>
<span class="p_chunk">@@ -202,29 +202,44 @@</span> <span class="p_context"> static const struct variable_validate variable_validate[] = {</span>
 	{ NULL_GUID, &quot;&quot;, NULL },
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Check if @var_name matches the pattern given in @match_name.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @var_name: an array of @len non-NUL characters.</span>
<span class="p_add">+ * @match_name: a NUL-terminated pattern string, optionally ending in &quot;*&quot;. A</span>
<span class="p_add">+ *              final &quot;*&quot; character matches any trailing characters @var_name,</span>
<span class="p_add">+ *              including the case when there are none left in @var_name.</span>
<span class="p_add">+ * @match: on output, the number of non-wildcard characters in @match_name</span>
<span class="p_add">+ *         that @var_name matches, regardless of the return value.</span>
<span class="p_add">+ * @return: whether @var_name fully matches @match_name.</span>
<span class="p_add">+ */</span>
 static bool
 variable_matches(const char *var_name, size_t len, const char *match_name,
 		 int *match)
 {
 	for (*match = 0; ; (*match)++) {
 		char c = match_name[*match];
<span class="p_del">-		char u = var_name[*match];</span>
 
<span class="p_del">-		/* Wildcard in the matching name means we&#39;ve matched */</span>
<span class="p_del">-		if (c == &#39;*&#39;)</span>
<span class="p_add">+		switch (c) {</span>
<span class="p_add">+		case &#39;*&#39;:</span>
<span class="p_add">+			/* Wildcard in @match_name means we&#39;ve matched. */</span>
 			return true;
 
<span class="p_del">-		/* Case sensitive match */</span>
<span class="p_del">-		if (!c &amp;&amp; *match == len)</span>
<span class="p_del">-			return true;</span>
<span class="p_add">+		case &#39;\0&#39;:</span>
<span class="p_add">+			/* @match_name has ended. Has @var_name too? */</span>
<span class="p_add">+			return (*match == len);</span>
 
<span class="p_del">-		if (c != u)</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We&#39;ve reached a non-wildcard char in @match_name.</span>
<span class="p_add">+			 * Continue only if there&#39;s an identical character in</span>
<span class="p_add">+			 * @var_name.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (*match &lt; len &amp;&amp; c == var_name[*match])</span>
<span class="p_add">+				continue;</span>
 			return false;
<span class="p_del">-</span>
<span class="p_del">-		if (!c)</span>
<span class="p_del">-			return true;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-	return true;</span>
 }
 
 bool
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">index 5e7770f9a415..ff299752d5e6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_chunk">@@ -1619,6 +1619,7 @@</span> <span class="p_context"> struct amdgpu_uvd {</span>
 	struct amdgpu_bo	*vcpu_bo;
 	void			*cpu_addr;
 	uint64_t		gpu_addr;
<span class="p_add">+	unsigned		fw_version;</span>
 	atomic_t		handles[AMDGPU_MAX_UVD_HANDLES];
 	struct drm_file		*filp[AMDGPU_MAX_UVD_HANDLES];
 	struct delayed_work	idle_work;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">index 81dc6b65436f..3c895863fcf5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_chunk">@@ -63,10 +63,6 @@</span> <span class="p_context"> bool amdgpu_has_atpx(void) {</span>
 	return amdgpu_atpx_priv.atpx_detected;
 }
 
<span class="p_del">-bool amdgpu_has_atpx_dgpu_power_cntl(void) {</span>
<span class="p_del">-	return amdgpu_atpx_priv.atpx.functions.power_cntl;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * amdgpu_atpx_call - call an ATPX method
  *
<span class="p_chunk">@@ -146,6 +142,10 @@</span> <span class="p_context"> static void amdgpu_atpx_parse_functions(struct amdgpu_atpx_functions *f, u32 mas</span>
  */
 static int amdgpu_atpx_validate(struct amdgpu_atpx *atpx)
 {
<span class="p_add">+	/* make sure required functions are enabled */</span>
<span class="p_add">+	/* dGPU power control is required */</span>
<span class="p_add">+	atpx-&gt;functions.power_cntl = true;</span>
<span class="p_add">+</span>
 	if (atpx-&gt;functions.px_params) {
 		union acpi_object *info;
 		struct atpx_px_params output;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">index d6c68d00cbb0..51bfc114584e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_chunk">@@ -62,12 +62,6 @@</span> <span class="p_context"> static const char *amdgpu_asic_name[] = {</span>
 	&quot;LAST&quot;,
 };
 
<span class="p_del">-#if defined(CONFIG_VGA_SWITCHEROO)</span>
<span class="p_del">-bool amdgpu_has_atpx_dgpu_power_cntl(void);</span>
<span class="p_del">-#else</span>
<span class="p_del">-static inline bool amdgpu_has_atpx_dgpu_power_cntl(void) { return false; }</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 bool amdgpu_device_is_px(struct drm_device *dev)
 {
 	struct amdgpu_device *adev = dev-&gt;dev_private;
<span class="p_chunk">@@ -1517,7 +1511,7 @@</span> <span class="p_context"> int amdgpu_device_init(struct amdgpu_device *adev,</span>
 
 	if (amdgpu_runtime_pm == 1)
 		runtime = true;
<span class="p_del">-	if (amdgpu_device_is_px(ddev) &amp;&amp; amdgpu_has_atpx_dgpu_power_cntl())</span>
<span class="p_add">+	if (amdgpu_device_is_px(ddev))</span>
 		runtime = true;
 	vga_switcheroo_register_client(adev-&gt;pdev, &amp;amdgpu_switcheroo_ops, runtime);
 	if (runtime)
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_header">index e23843f4d877..4488e82f87b0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_chunk">@@ -303,7 +303,7 @@</span> <span class="p_context"> static int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file</span>
 			fw_info.feature = adev-&gt;vce.fb_version;
 			break;
 		case AMDGPU_INFO_FW_UVD:
<span class="p_del">-			fw_info.ver = 0;</span>
<span class="p_add">+			fw_info.ver = adev-&gt;uvd.fw_version;</span>
 			fw_info.feature = 0;
 			break;
 		case AMDGPU_INFO_FW_GMC:
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h</span>
<span class="p_header">index fdc1be8550da..3b2d75d96ea0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> struct amdgpu_hpd;</span>
 
 #define AMDGPU_MAX_HPD_PINS 6
 #define AMDGPU_MAX_CRTCS 6
<span class="p_del">-#define AMDGPU_MAX_AFMT_BLOCKS 7</span>
<span class="p_add">+#define AMDGPU_MAX_AFMT_BLOCKS 9</span>
 
 enum amdgpu_rmx_type {
 	RMX_OFF,
<span class="p_chunk">@@ -309,8 +309,8 @@</span> <span class="p_context"> struct amdgpu_mode_info {</span>
 	struct atom_context *atom_context;
 	struct card_info *atom_card_info;
 	bool mode_config_initialized;
<span class="p_del">-	struct amdgpu_crtc *crtcs[6];</span>
<span class="p_del">-	struct amdgpu_afmt *afmt[7];</span>
<span class="p_add">+	struct amdgpu_crtc *crtcs[AMDGPU_MAX_CRTCS];</span>
<span class="p_add">+	struct amdgpu_afmt *afmt[AMDGPU_MAX_AFMT_BLOCKS];</span>
 	/* DVI-I properties */
 	struct drm_property *coherent_mode_property;
 	/* DAC enable load detect */
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c</span>
<span class="p_header">index 53f987aeeacf..3b35ad83867c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c</span>
<span class="p_chunk">@@ -156,6 +156,9 @@</span> <span class="p_context"> int amdgpu_uvd_sw_init(struct amdgpu_device *adev)</span>
 	DRM_INFO(&quot;Found UVD firmware Version: %hu.%hu Family ID: %hu\n&quot;,
 		version_major, version_minor, family_id);
 
<span class="p_add">+	adev-&gt;uvd.fw_version = ((version_major &lt;&lt; 24) | (version_minor &lt;&lt; 16) |</span>
<span class="p_add">+				(family_id &lt;&lt; 8));</span>
<span class="p_add">+</span>
 	bo_size = AMDGPU_GPU_PAGE_ALIGN(le32_to_cpu(hdr-&gt;ucode_size_bytes) + 8)
 		 +  AMDGPU_UVD_STACK_SIZE + AMDGPU_UVD_HEAP_SIZE;
 	r = amdgpu_bo_create(adev, bo_size, PAGE_SIZE, true,
<span class="p_chunk">@@ -273,6 +276,8 @@</span> <span class="p_context"> int amdgpu_uvd_resume(struct amdgpu_device *adev)</span>
 	memcpy(adev-&gt;uvd.cpu_addr, (adev-&gt;uvd.fw-&gt;data) + offset,
 		(adev-&gt;uvd.fw-&gt;size) - offset);
 
<span class="p_add">+	cancel_delayed_work_sync(&amp;adev-&gt;uvd.idle_work);</span>
<span class="p_add">+</span>
 	size = amdgpu_bo_size(adev-&gt;uvd.vcpu_bo);
 	size -= le32_to_cpu(hdr-&gt;ucode_size_bytes);
 	ptr = adev-&gt;uvd.cpu_addr;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_header">index a745eeeb5d82..bb0da76051a1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_chunk">@@ -220,6 +220,7 @@</span> <span class="p_context"> int amdgpu_vce_suspend(struct amdgpu_device *adev)</span>
 	if (i == AMDGPU_MAX_VCE_HANDLES)
 		return 0;
 
<span class="p_add">+	cancel_delayed_work_sync(&amp;adev-&gt;vce.idle_work);</span>
 	/* TODO: suspending running encoding sessions isn&#39;t supported */
 	return -EINVAL;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c</span>
<span class="p_header">index 06602df707f8..9b1c43005c80 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c</span>
<span class="p_chunk">@@ -3628,7 +3628,7 @@</span> <span class="p_context"> static void gfx_v7_0_ring_emit_vm_flush(struct amdgpu_ring *ring,</span>
 					unsigned vm_id, uint64_t pd_addr)
 {
 	int usepfp = (ring-&gt;type == AMDGPU_RING_TYPE_GFX);
<span class="p_del">-	uint32_t seq = ring-&gt;fence_drv.sync_seq;</span>
<span class="p_add">+	uint32_t seq = ring-&gt;fence_drv.sync_seq[ring-&gt;idx];</span>
 	uint64_t addr = ring-&gt;fence_drv.gpu_addr;
 
 	amdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_dbgdev.c b/drivers/gpu/drm/amd/amdkfd/kfd_dbgdev.c</span>
<span class="p_header">index c34c393e9aea..d5e19b5fbbfb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdkfd/kfd_dbgdev.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdkfd/kfd_dbgdev.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static int dbgdev_wave_control_set_registers(</span>
 				union SQ_CMD_BITS *in_reg_sq_cmd,
 				union GRBM_GFX_INDEX_BITS *in_reg_gfx_index)
 {
<span class="p_del">-	int status;</span>
<span class="p_add">+	int status = 0;</span>
 	union SQ_CMD_BITS reg_sq_cmd;
 	union GRBM_GFX_INDEX_BITS reg_gfx_index;
 	struct HsaDbgWaveMsgAMDGen2 *pMsg;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">index 27fbd79d0daf..71ea0521ea96 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_chunk">@@ -1672,13 +1672,19 @@</span> <span class="p_context"> static int drm_dp_payload_send_msg(struct drm_dp_mst_topology_mgr *mgr,</span>
 	u8 sinks[DRM_DP_MAX_SDP_STREAMS];
 	int i;
 
<span class="p_add">+	port = drm_dp_get_validated_port_ref(mgr, port);</span>
<span class="p_add">+	if (!port)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	port_num = port-&gt;port_num;
 	mstb = drm_dp_get_validated_mstb_ref(mgr, port-&gt;parent);
 	if (!mstb) {
 		mstb = drm_dp_get_last_connected_port_and_mstb(mgr, port-&gt;parent, &amp;port_num);
 
<span class="p_del">-		if (!mstb)</span>
<span class="p_add">+		if (!mstb) {</span>
<span class="p_add">+			drm_dp_put_port(port);</span>
 			return -EINVAL;
<span class="p_add">+		}</span>
 	}
 
 	txmsg = kzalloc(sizeof(*txmsg), GFP_KERNEL);
<span class="p_chunk">@@ -1707,6 +1713,7 @@</span> <span class="p_context"> static int drm_dp_payload_send_msg(struct drm_dp_mst_topology_mgr *mgr,</span>
 	kfree(txmsg);
 fail_put:
 	drm_dp_put_mst_branch_device(mstb);
<span class="p_add">+	drm_dp_put_port(port);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1789,6 +1796,11 @@</span> <span class="p_context"> int drm_dp_update_payload_part1(struct drm_dp_mst_topology_mgr *mgr)</span>
 		req_payload.start_slot = cur_slots;
 		if (mgr-&gt;proposed_vcpis[i]) {
 			port = container_of(mgr-&gt;proposed_vcpis[i], struct drm_dp_mst_port, vcpi);
<span class="p_add">+			port = drm_dp_get_validated_port_ref(mgr, port);</span>
<span class="p_add">+			if (!port) {</span>
<span class="p_add">+				mutex_unlock(&amp;mgr-&gt;payload_lock);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
 			req_payload.num_slots = mgr-&gt;proposed_vcpis[i]-&gt;num_slots;
 			req_payload.vcpi = mgr-&gt;proposed_vcpis[i]-&gt;vcpi;
 		} else {
<span class="p_chunk">@@ -1816,6 +1828,9 @@</span> <span class="p_context"> int drm_dp_update_payload_part1(struct drm_dp_mst_topology_mgr *mgr)</span>
 			mgr-&gt;payloads[i].payload_state = req_payload.payload_state;
 		}
 		cur_slots += req_payload.num_slots;
<span class="p_add">+</span>
<span class="p_add">+		if (port)</span>
<span class="p_add">+			drm_dp_put_port(port);</span>
 	}
 
 	for (i = 0; i &lt; mgr-&gt;max_payloads; i++) {
<span class="p_chunk">@@ -2121,6 +2136,8 @@</span> <span class="p_context"> int drm_dp_mst_topology_mgr_resume(struct drm_dp_mst_topology_mgr *mgr)</span>
 
 	if (mgr-&gt;mst_primary) {
 		int sret;
<span class="p_add">+		u8 guid[16];</span>
<span class="p_add">+</span>
 		sret = drm_dp_dpcd_read(mgr-&gt;aux, DP_DPCD_REV, mgr-&gt;dpcd, DP_RECEIVER_CAP_SIZE);
 		if (sret != DP_RECEIVER_CAP_SIZE) {
 			DRM_DEBUG_KMS(&quot;dpcd read failed - undocked during suspend?\n&quot;);
<span class="p_chunk">@@ -2135,6 +2152,16 @@</span> <span class="p_context"> int drm_dp_mst_topology_mgr_resume(struct drm_dp_mst_topology_mgr *mgr)</span>
 			ret = -1;
 			goto out_unlock;
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* Some hubs forget their guids after they resume */</span>
<span class="p_add">+		sret = drm_dp_dpcd_read(mgr-&gt;aux, DP_GUID, guid, 16);</span>
<span class="p_add">+		if (sret != 16) {</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;dpcd read failed - undocked during suspend?\n&quot;);</span>
<span class="p_add">+			ret = -1;</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		drm_dp_check_mstb_guid(mgr-&gt;mst_primary, guid);</span>
<span class="p_add">+</span>
 		ret = 0;
 	} else
 		ret = -1;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_csr.c b/drivers/gpu/drm/i915/intel_csr.c</span>
<span class="p_header">index 647d85e77c2f..597cfb5ca847 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_csr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_csr.c</span>
<span class="p_chunk">@@ -177,7 +177,8 @@</span> <span class="p_context"> static const struct stepping_info kbl_stepping_info[] = {</span>
 static const struct stepping_info skl_stepping_info[] = {
 	{&#39;A&#39;, &#39;0&#39;}, {&#39;B&#39;, &#39;0&#39;}, {&#39;C&#39;, &#39;0&#39;},
 	{&#39;D&#39;, &#39;0&#39;}, {&#39;E&#39;, &#39;0&#39;}, {&#39;F&#39;, &#39;0&#39;},
<span class="p_del">-	{&#39;G&#39;, &#39;0&#39;}, {&#39;H&#39;, &#39;0&#39;}, {&#39;I&#39;, &#39;0&#39;}</span>
<span class="p_add">+	{&#39;G&#39;, &#39;0&#39;}, {&#39;H&#39;, &#39;0&#39;}, {&#39;I&#39;, &#39;0&#39;},</span>
<span class="p_add">+	{&#39;J&#39;, &#39;0&#39;}, {&#39;K&#39;, &#39;0&#39;}</span>
 };
 
 static const struct stepping_info bxt_stepping_info[] = {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 46947fffd599..a9c35134f2e2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -4455,7 +4455,7 @@</span> <span class="p_context"> int skl_update_scaler_crtc(struct intel_crtc_state *state)</span>
 		      intel_crtc-&gt;base.base.id, intel_crtc-&gt;pipe, SKL_CRTC_INDEX);
 
 	return skl_update_scaler(state, !state-&gt;base.active, SKL_CRTC_INDEX,
<span class="p_del">-		&amp;state-&gt;scaler_state.scaler_id, DRM_ROTATE_0,</span>
<span class="p_add">+		&amp;state-&gt;scaler_state.scaler_id, BIT(DRM_ROTATE_0),</span>
 		state-&gt;pipe_src_w, state-&gt;pipe_src_h,
 		adjusted_mode-&gt;crtc_hdisplay, adjusted_mode-&gt;crtc_vdisplay);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp_mst.c b/drivers/gpu/drm/i915/intel_dp_mst.c</span>
<span class="p_header">index fa0dabf578dc..db6361b5a6ab 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp_mst.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp_mst.c</span>
<span class="p_chunk">@@ -184,7 +184,7 @@</span> <span class="p_context"> static void intel_mst_pre_enable_dp(struct intel_encoder *encoder)</span>
 	intel_mst-&gt;port = found-&gt;port;
 
 	if (intel_dp-&gt;active_mst_links == 0) {
<span class="p_del">-		intel_ddi_clk_select(encoder, intel_crtc-&gt;config);</span>
<span class="p_add">+		intel_ddi_clk_select(&amp;intel_dig_port-&gt;base, intel_crtc-&gt;config);</span>
 
 		intel_dp_set_link_params(intel_dp, intel_crtc-&gt;config);
 
<span class="p_chunk">@@ -499,6 +499,8 @@</span> <span class="p_context"> static void intel_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,</span>
 	struct intel_connector *intel_connector = to_intel_connector(connector);
 	struct drm_device *dev = connector-&gt;dev;
 
<span class="p_add">+	intel_connector-&gt;unregister(intel_connector);</span>
<span class="p_add">+</span>
 	/* need to nuke the connector */
 	drm_modeset_lock_all(dev);
 	if (connector-&gt;state-&gt;crtc) {
<span class="p_chunk">@@ -512,11 +514,7 @@</span> <span class="p_context"> static void intel_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,</span>
 
 		WARN(ret, &quot;Disabling mst crtc failed with %i\n&quot;, ret);
 	}
<span class="p_del">-	drm_modeset_unlock_all(dev);</span>
 
<span class="p_del">-	intel_connector-&gt;unregister(intel_connector);</span>
<span class="p_del">-</span>
<span class="p_del">-	drm_modeset_lock_all(dev);</span>
 	intel_connector_remove_from_fbdev(intel_connector);
 	drm_connector_cleanup(connector);
 	drm_modeset_unlock_all(dev);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">index f1fa756c5d5d..cfd5f9fff2f4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_chunk">@@ -781,11 +781,11 @@</span> <span class="p_context"> static int logical_ring_prepare(struct drm_i915_gem_request *req, int bytes)</span>
 		if (unlikely(total_bytes &gt; remain_usable)) {
 			/*
 			 * The base request will fit but the reserved space
<span class="p_del">-			 * falls off the end. So only need to to wait for the</span>
<span class="p_del">-			 * reserved size after flushing out the remainder.</span>
<span class="p_add">+			 * falls off the end. So don&#39;t need an immediate wrap</span>
<span class="p_add">+			 * and only need to effectively wait for the reserved</span>
<span class="p_add">+			 * size space from the start of ringbuffer.</span>
 			 */
 			wait_bytes = remain_actual + ringbuf-&gt;reserved_size;
<span class="p_del">-			need_wrap = true;</span>
 		} else if (total_bytes &gt; ringbuf-&gt;space) {
 			/* No wrapping required, just waiting. */
 			wait_bytes = total_bytes;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index b28c29f20e75..7e4a9842b9ea 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -2281,6 +2281,7 @@</span> <span class="p_context"> static int ilk_compute_pipe_wm(struct intel_crtc *intel_crtc,</span>
 		return PTR_ERR(cstate);
 
 	pipe_wm = &amp;cstate-&gt;wm.optimal.ilk;
<span class="p_add">+	memset(pipe_wm, 0, sizeof(*pipe_wm));</span>
 
 	for_each_intel_plane_on_crtc(dev, intel_crtc, intel_plane) {
 		ps = drm_atomic_get_plane_state(state,
<span class="p_chunk">@@ -3606,23 +3607,43 @@</span> <span class="p_context"> static void skl_update_wm(struct drm_crtc *crtc)</span>
 	dev_priv-&gt;wm.skl_hw = *results;
 }
 
<span class="p_add">+static void ilk_compute_wm_config(struct drm_device *dev,</span>
<span class="p_add">+				  struct intel_wm_config *config)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct intel_crtc *crtc;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Compute the currently _active_ config */</span>
<span class="p_add">+	for_each_intel_crtc(dev, crtc) {</span>
<span class="p_add">+		const struct intel_pipe_wm *wm = &amp;crtc-&gt;wm.active.ilk;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!wm-&gt;pipe_enabled)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		config-&gt;sprites_enabled |= wm-&gt;sprites_enabled;</span>
<span class="p_add">+		config-&gt;sprites_scaled |= wm-&gt;sprites_scaled;</span>
<span class="p_add">+		config-&gt;num_pipes_active++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void ilk_program_watermarks(struct drm_i915_private *dev_priv)
 {
 	struct drm_device *dev = dev_priv-&gt;dev;
 	struct intel_pipe_wm lp_wm_1_2 = {}, lp_wm_5_6 = {}, *best_lp_wm;
 	struct ilk_wm_maximums max;
<span class="p_del">-	struct intel_wm_config *config = &amp;dev_priv-&gt;wm.config;</span>
<span class="p_add">+	struct intel_wm_config config = {};</span>
 	struct ilk_wm_values results = {};
 	enum intel_ddb_partitioning partitioning;
 
<span class="p_del">-	ilk_compute_wm_maximums(dev, 1, config, INTEL_DDB_PART_1_2, &amp;max);</span>
<span class="p_del">-	ilk_wm_merge(dev, config, &amp;max, &amp;lp_wm_1_2);</span>
<span class="p_add">+	ilk_compute_wm_config(dev, &amp;config);</span>
<span class="p_add">+</span>
<span class="p_add">+	ilk_compute_wm_maximums(dev, 1, &amp;config, INTEL_DDB_PART_1_2, &amp;max);</span>
<span class="p_add">+	ilk_wm_merge(dev, &amp;config, &amp;max, &amp;lp_wm_1_2);</span>
 
 	/* 5/6 split only in single pipe config on IVB+ */
 	if (INTEL_INFO(dev)-&gt;gen &gt;= 7 &amp;&amp;
<span class="p_del">-	    config-&gt;num_pipes_active == 1 &amp;&amp; config-&gt;sprites_enabled) {</span>
<span class="p_del">-		ilk_compute_wm_maximums(dev, 1, config, INTEL_DDB_PART_5_6, &amp;max);</span>
<span class="p_del">-		ilk_wm_merge(dev, config, &amp;max, &amp;lp_wm_5_6);</span>
<span class="p_add">+	    config.num_pipes_active == 1 &amp;&amp; config.sprites_enabled) {</span>
<span class="p_add">+		ilk_compute_wm_maximums(dev, 1, &amp;config, INTEL_DDB_PART_5_6, &amp;max);</span>
<span class="p_add">+		ilk_wm_merge(dev, &amp;config, &amp;max, &amp;lp_wm_5_6);</span>
 
 		best_lp_wm = ilk_find_best_result(dev, &amp;lp_wm_1_2, &amp;lp_wm_5_6);
 	} else {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.c b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">index 40c6aff57256..549afa7bc75f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_chunk">@@ -951,7 +951,7 @@</span> <span class="p_context"> static int gen9_init_workarounds(struct intel_engine_cs *ring)</span>
 
 	/* WaForceContextSaveRestoreNonCoherent:skl,bxt */
 	tmp = HDC_FORCE_CONTEXT_SAVE_RESTORE_NON_COHERENT;
<span class="p_del">-	if (IS_SKL_REVID(dev, SKL_REVID_F0, SKL_REVID_F0) ||</span>
<span class="p_add">+	if (IS_SKL_REVID(dev, SKL_REVID_F0, REVID_FOREVER) ||</span>
 	    IS_BXT_REVID(dev, BXT_REVID_B0, REVID_FOREVER))
 		tmp |= HDC_FORCE_CSR_NON_COHERENT_OVR_DISABLE;
 	WA_SET_BIT_MASKED(HDC_CHICKEN0, tmp);
<span class="p_chunk">@@ -1044,7 +1044,8 @@</span> <span class="p_context"> static int skl_init_workarounds(struct intel_engine_cs *ring)</span>
 		WA_SET_BIT_MASKED(HIZ_CHICKEN,
 				  BDW_HIZ_POWER_COMPILER_CLOCK_GATING_DISABLE);
 
<span class="p_del">-	if (IS_SKL_REVID(dev, 0, SKL_REVID_F0)) {</span>
<span class="p_add">+	/* This is tied to WaForceContextSaveRestoreNonCoherent */</span>
<span class="p_add">+	if (IS_SKL_REVID(dev, 0, REVID_FOREVER)) {</span>
 		/*
 		 *Use Force Non-Coherent whenever executing a 3D context. This
 		 * is a workaround for a possible hang in the unlikely event
<span class="p_chunk">@@ -1901,6 +1902,17 @@</span> <span class="p_context"> i915_dispatch_execbuffer(struct drm_i915_gem_request *req,</span>
 	return 0;
 }
 
<span class="p_add">+static void cleanup_phys_status_page(struct intel_engine_cs *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(ring-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev_priv-&gt;status_page_dmah)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	drm_pci_free(ring-&gt;dev, dev_priv-&gt;status_page_dmah);</span>
<span class="p_add">+	ring-&gt;status_page.page_addr = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cleanup_status_page(struct intel_engine_cs *ring)
 {
 	struct drm_i915_gem_object *obj;
<span class="p_chunk">@@ -1917,9 +1929,9 @@</span> <span class="p_context"> static void cleanup_status_page(struct intel_engine_cs *ring)</span>
 
 static int init_status_page(struct intel_engine_cs *ring)
 {
<span class="p_del">-	struct drm_i915_gem_object *obj;</span>
<span class="p_add">+	struct drm_i915_gem_object *obj = ring-&gt;status_page.obj;</span>
 
<span class="p_del">-	if ((obj = ring-&gt;status_page.obj) == NULL) {</span>
<span class="p_add">+	if (obj == NULL) {</span>
 		unsigned flags;
 		int ret;
 
<span class="p_chunk">@@ -2019,10 +2031,12 @@</span> <span class="p_context"> int intel_pin_and_map_ringbuffer_obj(struct drm_device *dev,</span>
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct drm_i915_gem_object *obj = ringbuf-&gt;obj;
<span class="p_add">+	/* Ring wraparound at offset 0 sometimes hangs. No idea why. */</span>
<span class="p_add">+	unsigned flags = PIN_OFFSET_BIAS | 4096;</span>
 	int ret;
 
 	if (HAS_LLC(dev_priv) &amp;&amp; !obj-&gt;stolen) {
<span class="p_del">-		ret = i915_gem_obj_ggtt_pin(obj, PAGE_SIZE, 0);</span>
<span class="p_add">+		ret = i915_gem_obj_ggtt_pin(obj, PAGE_SIZE, flags);</span>
 		if (ret)
 			return ret;
 
<span class="p_chunk">@@ -2038,7 +2052,8 @@</span> <span class="p_context"> int intel_pin_and_map_ringbuffer_obj(struct drm_device *dev,</span>
 			return -ENOMEM;
 		}
 	} else {
<span class="p_del">-		ret = i915_gem_obj_ggtt_pin(obj, PAGE_SIZE, PIN_MAPPABLE);</span>
<span class="p_add">+		ret = i915_gem_obj_ggtt_pin(obj, PAGE_SIZE,</span>
<span class="p_add">+					    flags | PIN_MAPPABLE);</span>
 		if (ret)
 			return ret;
 
<span class="p_chunk">@@ -2164,7 +2179,7 @@</span> <span class="p_context"> static int intel_init_ring_buffer(struct drm_device *dev,</span>
 		if (ret)
 			goto error;
 	} else {
<span class="p_del">-		BUG_ON(ring-&gt;id != RCS);</span>
<span class="p_add">+		WARN_ON(ring-&gt;id != RCS);</span>
 		ret = init_phys_status_page(ring);
 		if (ret)
 			goto error;
<span class="p_chunk">@@ -2210,7 +2225,12 @@</span> <span class="p_context"> void intel_cleanup_ring_buffer(struct intel_engine_cs *ring)</span>
 	if (ring-&gt;cleanup)
 		ring-&gt;cleanup(ring);
 
<span class="p_del">-	cleanup_status_page(ring);</span>
<span class="p_add">+	if (I915_NEED_GFX_HWS(ring-&gt;dev)) {</span>
<span class="p_add">+		cleanup_status_page(ring);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		WARN_ON(ring-&gt;id != RCS);</span>
<span class="p_add">+		cleanup_phys_status_page(ring);</span>
<span class="p_add">+	}</span>
 
 	i915_cmd_parser_fini_ring(ring);
 	i915_gem_batch_pool_fini(&amp;ring-&gt;batch_pool);
<span class="p_chunk">@@ -2373,11 +2393,11 @@</span> <span class="p_context"> static int __intel_ring_prepare(struct intel_engine_cs *ring, int bytes)</span>
 		if (unlikely(total_bytes &gt; remain_usable)) {
 			/*
 			 * The base request will fit but the reserved space
<span class="p_del">-			 * falls off the end. So only need to to wait for the</span>
<span class="p_del">-			 * reserved size after flushing out the remainder.</span>
<span class="p_add">+			 * falls off the end. So don&#39;t need an immediate wrap</span>
<span class="p_add">+			 * and only need to effectively wait for the reserved</span>
<span class="p_add">+			 * size space from the start of ringbuffer.</span>
 			 */
 			wait_bytes = remain_actual + ringbuf-&gt;reserved_size;
<span class="p_del">-			need_wrap = true;</span>
 		} else if (total_bytes &gt; ringbuf-&gt;space) {
 			/* No wrapping required, just waiting. */
 			wait_bytes = total_bytes;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_uncore.c b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">index 277e60ae0e47..08961f7d151c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_chunk">@@ -1155,7 +1155,11 @@</span> <span class="p_context"> static void intel_uncore_fw_domains_init(struct drm_device *dev)</span>
 	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
 		dev_priv-&gt;uncore.funcs.force_wake_get =
 			fw_domains_get_with_thread_status;
<span class="p_del">-		dev_priv-&gt;uncore.funcs.force_wake_put = fw_domains_put;</span>
<span class="p_add">+		if (IS_HASWELL(dev))</span>
<span class="p_add">+			dev_priv-&gt;uncore.funcs.force_wake_put =</span>
<span class="p_add">+				fw_domains_put_with_fifo;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			dev_priv-&gt;uncore.funcs.force_wake_put = fw_domains_put;</span>
 		fw_domain_init(dev_priv, FW_DOMAIN_ID_RENDER,
 			       FORCEWAKE_MT, FORCEWAKE_ACK_HSW);
 	} else if (IS_IVYBRIDGE(dev)) {
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c</span>
<span class="p_header">index 3216e157a8a0..89da47234016 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c</span>
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> nvkm_ramht_del(struct nvkm_ramht **pramht)</span>
 	struct nvkm_ramht *ramht = *pramht;
 	if (ramht) {
 		nvkm_gpuobj_del(&amp;ramht-&gt;gpuobj);
<span class="p_del">-		kfree(*pramht);</span>
<span class="p_add">+		vfree(*pramht);</span>
 		*pramht = NULL;
 	}
 }
<span class="p_chunk">@@ -143,8 +143,8 @@</span> <span class="p_context"> nvkm_ramht_new(struct nvkm_device *device, u32 size, u32 align,</span>
 	struct nvkm_ramht *ramht;
 	int ret, i;
 
<span class="p_del">-	if (!(ramht = *pramht = kzalloc(sizeof(*ramht) + (size &gt;&gt; 3) *</span>
<span class="p_del">-					sizeof(*ramht-&gt;data), GFP_KERNEL)))</span>
<span class="p_add">+	if (!(ramht = *pramht = vzalloc(sizeof(*ramht) +</span>
<span class="p_add">+					(size &gt;&gt; 3) * sizeof(*ramht-&gt;data))))</span>
 		return -ENOMEM;
 
 	ramht-&gt;device = device;
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c</span>
<span class="p_header">index 1f81069edc58..332b5fe687fe 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c</span>
<span class="p_chunk">@@ -1807,6 +1807,8 @@</span> <span class="p_context"> gf100_gr_init(struct gf100_gr *gr)</span>
 
 	gf100_gr_mmio(gr, gr-&gt;func-&gt;mmio);
 
<span class="p_add">+	nvkm_mask(device, TPC_UNIT(0, 0, 0x05c), 0x00000001, 0x00000001);</span>
<span class="p_add">+</span>
 	memcpy(tpcnr, gr-&gt;tpc_nr, sizeof(gr-&gt;tpc_nr));
 	for (i = 0, gpc = -1; i &lt; gr-&gt;tpc_total; i++) {
 		do {
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_display.c b/drivers/gpu/drm/qxl/qxl_display.c</span>
<span class="p_header">index 86276519b2ef..47e52647c9e5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_display.c</span>
<span class="p_chunk">@@ -375,10 +375,15 @@</span> <span class="p_context"> static int qxl_crtc_cursor_set2(struct drm_crtc *crtc,</span>
 
 	qxl_bo_kunmap(user_bo);
 
<span class="p_add">+	qcrtc-&gt;cur_x += qcrtc-&gt;hot_spot_x - hot_x;</span>
<span class="p_add">+	qcrtc-&gt;cur_y += qcrtc-&gt;hot_spot_y - hot_y;</span>
<span class="p_add">+	qcrtc-&gt;hot_spot_x = hot_x;</span>
<span class="p_add">+	qcrtc-&gt;hot_spot_y = hot_y;</span>
<span class="p_add">+</span>
 	cmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_CURSOR_SET;
<span class="p_del">-	cmd-&gt;u.set.position.x = qcrtc-&gt;cur_x;</span>
<span class="p_del">-	cmd-&gt;u.set.position.y = qcrtc-&gt;cur_y;</span>
<span class="p_add">+	cmd-&gt;u.set.position.x = qcrtc-&gt;cur_x + qcrtc-&gt;hot_spot_x;</span>
<span class="p_add">+	cmd-&gt;u.set.position.y = qcrtc-&gt;cur_y + qcrtc-&gt;hot_spot_y;</span>
 
 	cmd-&gt;u.set.shape = qxl_bo_physical_address(qdev, cursor_bo, 0);
 
<span class="p_chunk">@@ -441,8 +446,8 @@</span> <span class="p_context"> static int qxl_crtc_cursor_move(struct drm_crtc *crtc,</span>
 
 	cmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_CURSOR_MOVE;
<span class="p_del">-	cmd-&gt;u.position.x = qcrtc-&gt;cur_x;</span>
<span class="p_del">-	cmd-&gt;u.position.y = qcrtc-&gt;cur_y;</span>
<span class="p_add">+	cmd-&gt;u.position.x = qcrtc-&gt;cur_x + qcrtc-&gt;hot_spot_x;</span>
<span class="p_add">+	cmd-&gt;u.position.y = qcrtc-&gt;cur_y + qcrtc-&gt;hot_spot_y;</span>
 	qxl_release_unmap(qdev, release, &amp;cmd-&gt;release_info);
 
 	qxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h</span>
<span class="p_header">index 6e6b9b1519b8..3f3897eb458c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_drv.h</span>
<span class="p_chunk">@@ -135,6 +135,8 @@</span> <span class="p_context"> struct qxl_crtc {</span>
 	int index;
 	int cur_x;
 	int cur_y;
<span class="p_add">+	int hot_spot_x;</span>
<span class="p_add">+	int hot_spot_y;</span>
 };
 
 struct qxl_output {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">index 2ad462896896..32491355a1d4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_chunk">@@ -2608,10 +2608,152 @@</span> <span class="p_context"> static void evergreen_agp_enable(struct radeon_device *rdev)</span>
 	WREG32(VM_CONTEXT1_CNTL, 0);
 }
 
<span class="p_add">+static const unsigned ni_dig_offsets[] =</span>
<span class="p_add">+{</span>
<span class="p_add">+	NI_DIG0_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG1_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG2_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG3_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG4_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG5_REGISTER_OFFSET</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const unsigned ni_tx_offsets[] =</span>
<span class="p_add">+{</span>
<span class="p_add">+	NI_DCIO_UNIPHY0_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY1_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY2_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY3_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY4_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY5_UNIPHY_TX_CONTROL1</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const unsigned evergreen_dp_offsets[] =</span>
<span class="p_add">+{</span>
<span class="p_add">+	EVERGREEN_DP0_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP1_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP2_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP3_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP4_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP5_REGISTER_OFFSET</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Assumption is that EVERGREEN_CRTC_MASTER_EN enable for requested crtc</span>
<span class="p_add">+ * We go from crtc to connector and it is not relible  since it</span>
<span class="p_add">+ * should be an opposite direction .If crtc is enable then</span>
<span class="p_add">+ * find the dig_fe which selects this crtc and insure that it enable.</span>
<span class="p_add">+ * if such dig_fe is found then find dig_be which selects found dig_be and</span>
<span class="p_add">+ * insure that it enable and in DP_SST mode.</span>
<span class="p_add">+ * if UNIPHY_PLL_CONTROL1.enable then we should disconnect timing</span>
<span class="p_add">+ * from dp symbols clocks .</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool evergreen_is_dp_sst_stream_enabled(struct radeon_device *rdev,</span>
<span class="p_add">+					       unsigned crtc_id, unsigned *ret_dig_fe)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned i;</span>
<span class="p_add">+	unsigned dig_fe;</span>
<span class="p_add">+	unsigned dig_be;</span>
<span class="p_add">+	unsigned dig_en_be;</span>
<span class="p_add">+	unsigned uniphy_pll;</span>
<span class="p_add">+	unsigned digs_fe_selected;</span>
<span class="p_add">+	unsigned dig_be_mode;</span>
<span class="p_add">+	unsigned dig_fe_mask;</span>
<span class="p_add">+	bool is_enabled = false;</span>
<span class="p_add">+	bool found_crtc = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* loop through all running dig_fe to find selected crtc */</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(ni_dig_offsets); i++) {</span>
<span class="p_add">+		dig_fe = RREG32(NI_DIG_FE_CNTL + ni_dig_offsets[i]);</span>
<span class="p_add">+		if (dig_fe &amp; NI_DIG_FE_CNTL_SYMCLK_FE_ON &amp;&amp;</span>
<span class="p_add">+		    crtc_id == NI_DIG_FE_CNTL_SOURCE_SELECT(dig_fe)) {</span>
<span class="p_add">+			/* found running pipe */</span>
<span class="p_add">+			found_crtc = true;</span>
<span class="p_add">+			dig_fe_mask = 1 &lt;&lt; i;</span>
<span class="p_add">+			dig_fe = i;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (found_crtc) {</span>
<span class="p_add">+		/* loop through all running dig_be to find selected dig_fe */</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(ni_dig_offsets); i++) {</span>
<span class="p_add">+			dig_be = RREG32(NI_DIG_BE_CNTL + ni_dig_offsets[i]);</span>
<span class="p_add">+			/* if dig_fe_selected by dig_be? */</span>
<span class="p_add">+			digs_fe_selected = NI_DIG_BE_CNTL_FE_SOURCE_SELECT(dig_be);</span>
<span class="p_add">+			dig_be_mode = NI_DIG_FE_CNTL_MODE(dig_be);</span>
<span class="p_add">+			if (dig_fe_mask &amp;  digs_fe_selected &amp;&amp;</span>
<span class="p_add">+			    /* if dig_be in sst mode? */</span>
<span class="p_add">+			    dig_be_mode == NI_DIG_BE_DPSST) {</span>
<span class="p_add">+				dig_en_be = RREG32(NI_DIG_BE_EN_CNTL +</span>
<span class="p_add">+						   ni_dig_offsets[i]);</span>
<span class="p_add">+				uniphy_pll = RREG32(NI_DCIO_UNIPHY0_PLL_CONTROL1 +</span>
<span class="p_add">+						    ni_tx_offsets[i]);</span>
<span class="p_add">+				/* dig_be enable and tx is running */</span>
<span class="p_add">+				if (dig_en_be &amp; NI_DIG_BE_EN_CNTL_ENABLE &amp;&amp;</span>
<span class="p_add">+				    dig_en_be &amp; NI_DIG_BE_EN_CNTL_SYMBCLK_ON &amp;&amp;</span>
<span class="p_add">+				    uniphy_pll &amp; NI_DCIO_UNIPHY0_PLL_CONTROL1_ENABLE) {</span>
<span class="p_add">+					is_enabled = true;</span>
<span class="p_add">+					*ret_dig_fe = dig_fe;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return is_enabled;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Blank dig when in dp sst mode</span>
<span class="p_add">+ * Dig ignores crtc timing</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void evergreen_blank_dp_output(struct radeon_device *rdev,</span>
<span class="p_add">+				      unsigned dig_fe)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned stream_ctrl;</span>
<span class="p_add">+	unsigned fifo_ctrl;</span>
<span class="p_add">+	unsigned counter = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dig_fe &gt;= ARRAY_SIZE(evergreen_dp_offsets)) {</span>
<span class="p_add">+		DRM_ERROR(&quot;invalid dig_fe %d\n&quot;, dig_fe);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	stream_ctrl = RREG32(EVERGREEN_DP_VID_STREAM_CNTL +</span>
<span class="p_add">+			     evergreen_dp_offsets[dig_fe]);</span>
<span class="p_add">+	if (!(stream_ctrl &amp; EVERGREEN_DP_VID_STREAM_CNTL_ENABLE)) {</span>
<span class="p_add">+		DRM_ERROR(&quot;dig %d , should be enable\n&quot;, dig_fe);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	stream_ctrl &amp;=~EVERGREEN_DP_VID_STREAM_CNTL_ENABLE;</span>
<span class="p_add">+	WREG32(EVERGREEN_DP_VID_STREAM_CNTL +</span>
<span class="p_add">+	       evergreen_dp_offsets[dig_fe], stream_ctrl);</span>
<span class="p_add">+</span>
<span class="p_add">+	stream_ctrl = RREG32(EVERGREEN_DP_VID_STREAM_CNTL +</span>
<span class="p_add">+			     evergreen_dp_offsets[dig_fe]);</span>
<span class="p_add">+	while (counter &lt; 32 &amp;&amp; stream_ctrl &amp; EVERGREEN_DP_VID_STREAM_STATUS) {</span>
<span class="p_add">+		msleep(1);</span>
<span class="p_add">+		counter++;</span>
<span class="p_add">+		stream_ctrl = RREG32(EVERGREEN_DP_VID_STREAM_CNTL +</span>
<span class="p_add">+				     evergreen_dp_offsets[dig_fe]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (counter &gt;= 32 )</span>
<span class="p_add">+		DRM_ERROR(&quot;counter exceeds %d\n&quot;, counter);</span>
<span class="p_add">+</span>
<span class="p_add">+	fifo_ctrl = RREG32(EVERGREEN_DP_STEER_FIFO + evergreen_dp_offsets[dig_fe]);</span>
<span class="p_add">+	fifo_ctrl |= EVERGREEN_DP_STEER_FIFO_RESET;</span>
<span class="p_add">+	WREG32(EVERGREEN_DP_STEER_FIFO + evergreen_dp_offsets[dig_fe], fifo_ctrl);</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void evergreen_mc_stop(struct radeon_device *rdev, struct evergreen_mc_save *save)
 {
 	u32 crtc_enabled, tmp, frame_count, blackout;
 	int i, j;
<span class="p_add">+	unsigned dig_fe;</span>
 
 	if (!ASIC_IS_NODCE(rdev)) {
 		save-&gt;vga_render_control = RREG32(VGA_RENDER_CONTROL);
<span class="p_chunk">@@ -2651,7 +2793,17 @@</span> <span class="p_context"> void evergreen_mc_stop(struct radeon_device *rdev, struct evergreen_mc_save *sav</span>
 					break;
 				udelay(1);
 			}
<span class="p_del">-</span>
<span class="p_add">+			/*we should disable dig if it drives dp sst*/</span>
<span class="p_add">+			/*but we are in radeon_device_init and the topology is unknown*/</span>
<span class="p_add">+			/*and it is available after radeon_modeset_init*/</span>
<span class="p_add">+			/*the following method radeon_atom_encoder_dpms_dig*/</span>
<span class="p_add">+			/*does the job if we initialize it properly*/</span>
<span class="p_add">+			/*for now we do it this manually*/</span>
<span class="p_add">+			/**/</span>
<span class="p_add">+			if (ASIC_IS_DCE5(rdev) &amp;&amp;</span>
<span class="p_add">+			    evergreen_is_dp_sst_stream_enabled(rdev, i ,&amp;dig_fe))</span>
<span class="p_add">+				evergreen_blank_dp_output(rdev, dig_fe);</span>
<span class="p_add">+			/*we could remove 6 lines below*/</span>
 			/* XXX this is a hack to avoid strange behavior with EFI on certain systems */
 			WREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 1);
 			tmp = RREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i]);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen_reg.h b/drivers/gpu/drm/radeon/evergreen_reg.h</span>
<span class="p_header">index aa939dfed3a3..b436badf9efa 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen_reg.h</span>
<span class="p_chunk">@@ -250,8 +250,43 @@</span> <span class="p_context"></span>
 
 /* HDMI blocks at 0x7030, 0x7c30, 0x10830, 0x11430, 0x12030, 0x12c30 */
 #define EVERGREEN_HDMI_BASE				0x7030
<span class="p_add">+/*DIG block*/</span>
<span class="p_add">+#define NI_DIG0_REGISTER_OFFSET                 (0x7000  - 0x7000)</span>
<span class="p_add">+#define NI_DIG1_REGISTER_OFFSET                 (0x7C00  - 0x7000)</span>
<span class="p_add">+#define NI_DIG2_REGISTER_OFFSET                 (0x10800 - 0x7000)</span>
<span class="p_add">+#define NI_DIG3_REGISTER_OFFSET                 (0x11400 - 0x7000)</span>
<span class="p_add">+#define NI_DIG4_REGISTER_OFFSET                 (0x12000 - 0x7000)</span>
<span class="p_add">+#define NI_DIG5_REGISTER_OFFSET                 (0x12C00 - 0x7000)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define NI_DIG_FE_CNTL                               0x7000</span>
<span class="p_add">+#       define NI_DIG_FE_CNTL_SOURCE_SELECT(x)        ((x) &amp; 0x3)</span>
<span class="p_add">+#       define NI_DIG_FE_CNTL_SYMCLK_FE_ON            (1&lt;&lt;24)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define NI_DIG_BE_CNTL                    0x7140</span>
<span class="p_add">+#       define NI_DIG_BE_CNTL_FE_SOURCE_SELECT(x)     (((x) &gt;&gt; 8 ) &amp; 0x3F)</span>
<span class="p_add">+#       define NI_DIG_FE_CNTL_MODE(x)                 (((x) &gt;&gt; 16) &amp; 0x7 )</span>
<span class="p_add">+</span>
<span class="p_add">+#define NI_DIG_BE_EN_CNTL                              0x7144</span>
<span class="p_add">+#       define NI_DIG_BE_EN_CNTL_ENABLE               (1 &lt;&lt; 0)</span>
<span class="p_add">+#       define NI_DIG_BE_EN_CNTL_SYMBCLK_ON           (1 &lt;&lt; 8)</span>
<span class="p_add">+#       define NI_DIG_BE_DPSST 0</span>
 
 /* Display Port block */
<span class="p_add">+#define EVERGREEN_DP0_REGISTER_OFFSET                 (0x730C  - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP1_REGISTER_OFFSET                 (0x7F0C  - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP2_REGISTER_OFFSET                 (0x10B0C - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP3_REGISTER_OFFSET                 (0x1170C - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP4_REGISTER_OFFSET                 (0x1230C - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP5_REGISTER_OFFSET                 (0x12F0C - 0x730C)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define EVERGREEN_DP_VID_STREAM_CNTL                    0x730C</span>
<span class="p_add">+#       define EVERGREEN_DP_VID_STREAM_CNTL_ENABLE     (1 &lt;&lt; 0)</span>
<span class="p_add">+#       define EVERGREEN_DP_VID_STREAM_STATUS          (1 &lt;&lt;16)</span>
<span class="p_add">+#define EVERGREEN_DP_STEER_FIFO                         0x7310</span>
<span class="p_add">+#       define EVERGREEN_DP_STEER_FIFO_RESET           (1 &lt;&lt; 0)</span>
 #define EVERGREEN_DP_SEC_CNTL                           0x7280
 #       define EVERGREEN_DP_SEC_STREAM_ENABLE           (1 &lt;&lt; 0)
 #       define EVERGREEN_DP_SEC_ASP_ENABLE              (1 &lt;&lt; 4)
<span class="p_chunk">@@ -266,4 +301,15 @@</span> <span class="p_context"></span>
 #       define EVERGREEN_DP_SEC_N_BASE_MULTIPLE(x)      (((x) &amp; 0xf) &lt;&lt; 24)
 #       define EVERGREEN_DP_SEC_SS_EN                   (1 &lt;&lt; 28)
 
<span class="p_add">+/*DCIO_UNIPHY block*/</span>
<span class="p_add">+#define NI_DCIO_UNIPHY0_UNIPHY_TX_CONTROL1            (0x6600  -0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY1_UNIPHY_TX_CONTROL1            (0x6640  -0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY2_UNIPHY_TX_CONTROL1            (0x6680 - 0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY3_UNIPHY_TX_CONTROL1            (0x66C0 - 0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY4_UNIPHY_TX_CONTROL1            (0x6700 - 0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY5_UNIPHY_TX_CONTROL1            (0x6740 - 0x6600)</span>
<span class="p_add">+</span>
<span class="p_add">+#define NI_DCIO_UNIPHY0_PLL_CONTROL1                   0x6618</span>
<span class="p_add">+#       define NI_DCIO_UNIPHY0_PLL_CONTROL1_ENABLE     (1 &lt;&lt; 0)</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">index 9bc408c9f9f6..c4b4f298a283 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_chunk">@@ -62,10 +62,6 @@</span> <span class="p_context"> bool radeon_has_atpx(void) {</span>
 	return radeon_atpx_priv.atpx_detected;
 }
 
<span class="p_del">-bool radeon_has_atpx_dgpu_power_cntl(void) {</span>
<span class="p_del">-	return radeon_atpx_priv.atpx.functions.power_cntl;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * radeon_atpx_call - call an ATPX method
  *
<span class="p_chunk">@@ -145,6 +141,10 @@</span> <span class="p_context"> static void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mas</span>
  */
 static int radeon_atpx_validate(struct radeon_atpx *atpx)
 {
<span class="p_add">+	/* make sure required functions are enabled */</span>
<span class="p_add">+	/* dGPU power control is required */</span>
<span class="p_add">+	atpx-&gt;functions.power_cntl = true;</span>
<span class="p_add">+</span>
 	if (atpx-&gt;functions.px_params) {
 		union acpi_object *info;
 		struct atpx_px_params output;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 340f3f549f29..9cfc1c3e1965 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -1996,10 +1996,12 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 						   rdev-&gt;mode_info.dither_property,
 						   RADEON_FMT_DITHER_DISABLE);
 
<span class="p_del">-			if (radeon_audio != 0)</span>
<span class="p_add">+			if (radeon_audio != 0) {</span>
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.audio_property,
 							   RADEON_AUDIO_AUTO);
<span class="p_add">+				radeon_connector-&gt;audio = RADEON_AUDIO_AUTO;</span>
<span class="p_add">+			}</span>
 			if (ASIC_IS_DCE5(rdev))
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.output_csc_property,
<span class="p_chunk">@@ -2124,6 +2126,7 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.audio_property,
 							   RADEON_AUDIO_AUTO);
<span class="p_add">+				radeon_connector-&gt;audio = RADEON_AUDIO_AUTO;</span>
 			}
 			if (connector_type == DRM_MODE_CONNECTOR_DVII) {
 				radeon_connector-&gt;dac_load_detect = true;
<span class="p_chunk">@@ -2179,6 +2182,7 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.audio_property,
 							   RADEON_AUDIO_AUTO);
<span class="p_add">+				radeon_connector-&gt;audio = RADEON_AUDIO_AUTO;</span>
 			}
 			if (ASIC_IS_DCE5(rdev))
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
<span class="p_chunk">@@ -2231,6 +2235,7 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.audio_property,
 							   RADEON_AUDIO_AUTO);
<span class="p_add">+				radeon_connector-&gt;audio = RADEON_AUDIO_AUTO;</span>
 			}
 			if (ASIC_IS_DCE5(rdev))
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index e2396336f9e8..4197ca1bb1e4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -103,12 +103,6 @@</span> <span class="p_context"> static const char radeon_family_name[][16] = {</span>
 	&quot;LAST&quot;,
 };
 
<span class="p_del">-#if defined(CONFIG_VGA_SWITCHEROO)</span>
<span class="p_del">-bool radeon_has_atpx_dgpu_power_cntl(void);</span>
<span class="p_del">-#else</span>
<span class="p_del">-static inline bool radeon_has_atpx_dgpu_power_cntl(void) { return false; }</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 #define RADEON_PX_QUIRK_DISABLE_PX  (1 &lt;&lt; 0)
 #define RADEON_PX_QUIRK_LONG_WAKEUP (1 &lt;&lt; 1)
 
<span class="p_chunk">@@ -1439,7 +1433,7 @@</span> <span class="p_context"> int radeon_device_init(struct radeon_device *rdev,</span>
 	 * ignore it */
 	vga_client_register(rdev-&gt;pdev, rdev, NULL, radeon_vga_set_decode);
 
<span class="p_del">-	if ((rdev-&gt;flags &amp; RADEON_IS_PX) &amp;&amp; radeon_has_atpx_dgpu_power_cntl())</span>
<span class="p_add">+	if (rdev-&gt;flags &amp; RADEON_IS_PX)</span>
 		runtime = true;
 	vga_switcheroo_register_client(rdev-&gt;pdev, &amp;radeon_switcheroo_ops, runtime);
 	if (runtime)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">index e06ac546a90f..f342aad79cc6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_chunk">@@ -235,6 +235,8 @@</span> <span class="p_context"> static int radeon_verify_access(struct ttm_buffer_object *bo, struct file *filp)</span>
 {
 	struct radeon_bo *rbo = container_of(bo, struct radeon_bo, tbo);
 
<span class="p_add">+	if (radeon_ttm_tt_has_userptr(bo-&gt;ttm))</span>
<span class="p_add">+		return -EPERM;</span>
 	return drm_vma_node_verify_access(&amp;rbo-&gt;gem_base.vma_node, filp);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 7285adb27099..caa73de584a5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2931,6 +2931,7 @@</span> <span class="p_context"> static struct si_dpm_quirk si_dpm_quirk_list[] = {</span>
 	{ PCI_VENDOR_ID_ATI, 0x6811, 0x1462, 0x2015, 0, 120000 },
 	{ PCI_VENDOR_ID_ATI, 0x6811, 0x1043, 0x2015, 0, 120000 },
 	{ PCI_VENDOR_ID_ATI, 0x6811, 0x148c, 0x2015, 0, 120000 },
<span class="p_add">+	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1682, 0x9275, 0, 120000 },</span>
 	{ 0, 0, 0, 0 },
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_bo.c b/drivers/gpu/drm/ttm/ttm_bo.c</span>
<span class="p_header">index 4cbf26555093..e3daafa1be13 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_bo.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_bo.c</span>
<span class="p_chunk">@@ -230,22 +230,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(ttm_bo_del_sub_from_lru);</span>
 
 void ttm_bo_move_to_lru_tail(struct ttm_buffer_object *bo)
 {
<span class="p_del">-	struct ttm_bo_device *bdev = bo-&gt;bdev;</span>
<span class="p_del">-	struct ttm_mem_type_manager *man;</span>
<span class="p_add">+	int put_count = 0;</span>
 
 	lockdep_assert_held(&amp;bo-&gt;resv-&gt;lock.base);
 
<span class="p_del">-	if (bo-&gt;mem.placement &amp; TTM_PL_FLAG_NO_EVICT) {</span>
<span class="p_del">-		list_del_init(&amp;bo-&gt;swap);</span>
<span class="p_del">-		list_del_init(&amp;bo-&gt;lru);</span>
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (bo-&gt;ttm &amp;&amp; !(bo-&gt;ttm-&gt;page_flags &amp; TTM_PAGE_FLAG_SG))</span>
<span class="p_del">-			list_move_tail(&amp;bo-&gt;swap, &amp;bo-&gt;glob-&gt;swap_lru);</span>
<span class="p_del">-</span>
<span class="p_del">-		man = &amp;bdev-&gt;man[bo-&gt;mem.mem_type];</span>
<span class="p_del">-		list_move_tail(&amp;bo-&gt;lru, &amp;man-&gt;lru);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	put_count = ttm_bo_del_from_lru(bo);</span>
<span class="p_add">+	ttm_bo_list_ref_sub(bo, put_count, true);</span>
<span class="p_add">+	ttm_bo_add_to_lru(bo);</span>
 }
 EXPORT_SYMBOL(ttm_bo_move_to_lru_tail);
 
<span class="p_header">diff --git a/drivers/hwtracing/stm/Kconfig b/drivers/hwtracing/stm/Kconfig</span>
<span class="p_header">index 83e9f591a54b..e7a348807f0c 100644</span>
<span class="p_header">--- a/drivers/hwtracing/stm/Kconfig</span>
<span class="p_header">+++ b/drivers/hwtracing/stm/Kconfig</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 config STM
 	tristate &quot;System Trace Module devices&quot;
 	select CONFIGFS_FS
<span class="p_add">+	select SRCU</span>
 	help
 	  A System Trace Module (STM) is a device exporting data in System
 	  Trace Protocol (STP) format as defined by MIPI STP standards.
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-cpm.c b/drivers/i2c/busses/i2c-cpm.c</span>
<span class="p_header">index 714bdc837769..b167ab25310a 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-cpm.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-cpm.c</span>
<span class="p_chunk">@@ -116,8 +116,8 @@</span> <span class="p_context"> struct cpm_i2c {</span>
 	cbd_t __iomem *rbase;
 	u_char *txbuf[CPM_MAXBD];
 	u_char *rxbuf[CPM_MAXBD];
<span class="p_del">-	u32 txdma[CPM_MAXBD];</span>
<span class="p_del">-	u32 rxdma[CPM_MAXBD];</span>
<span class="p_add">+	dma_addr_t txdma[CPM_MAXBD];</span>
<span class="p_add">+	dma_addr_t rxdma[CPM_MAXBD];</span>
 };
 
 static irqreturn_t cpm_i2c_interrupt(int irq, void *dev_id)
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-exynos5.c b/drivers/i2c/busses/i2c-exynos5.c</span>
<span class="p_header">index b29c7500461a..f54ece8fce78 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-exynos5.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-exynos5.c</span>
<span class="p_chunk">@@ -671,7 +671,9 @@</span> <span class="p_context"> static int exynos5_i2c_xfer(struct i2c_adapter *adap,</span>
 		return -EIO;
 	}
 
<span class="p_del">-	clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	ret = clk_enable(i2c-&gt;clk);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	for (i = 0; i &lt; num; i++, msgs++) {
 		stop = (i == num - 1);
<span class="p_chunk">@@ -695,7 +697,7 @@</span> <span class="p_context"> static int exynos5_i2c_xfer(struct i2c_adapter *adap,</span>
 	}
 
  out:
<span class="p_del">-	clk_disable_unprepare(i2c-&gt;clk);</span>
<span class="p_add">+	clk_disable(i2c-&gt;clk);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -747,7 +749,9 @@</span> <span class="p_context"> static int exynos5_i2c_probe(struct platform_device *pdev)</span>
 		return -ENOENT;
 	}
 
<span class="p_del">-	clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	ret = clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	i2c-&gt;regs = devm_ioremap_resource(&amp;pdev-&gt;dev, mem);
<span class="p_chunk">@@ -799,6 +803,10 @@</span> <span class="p_context"> static int exynos5_i2c_probe(struct platform_device *pdev)</span>
 
 	platform_set_drvdata(pdev, i2c);
 
<span class="p_add">+	clk_disable(i2c-&gt;clk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
  err_clk:
 	clk_disable_unprepare(i2c-&gt;clk);
 	return ret;
<span class="p_chunk">@@ -810,6 +818,8 @@</span> <span class="p_context"> static int exynos5_i2c_remove(struct platform_device *pdev)</span>
 
 	i2c_del_adapter(&amp;i2c-&gt;adap);
 
<span class="p_add">+	clk_unprepare(i2c-&gt;clk);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -821,6 +831,8 @@</span> <span class="p_context"> static int exynos5_i2c_suspend_noirq(struct device *dev)</span>
 
 	i2c-&gt;suspended = 1;
 
<span class="p_add">+	clk_unprepare(i2c-&gt;clk);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -830,7 +842,9 @@</span> <span class="p_context"> static int exynos5_i2c_resume_noirq(struct device *dev)</span>
 	struct exynos5_i2c *i2c = platform_get_drvdata(pdev);
 	int ret = 0;
 
<span class="p_del">-	clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	ret = clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	ret = exynos5_hsi2c_clock_setup(i2c);
 	if (ret) {
<span class="p_chunk">@@ -839,7 +853,7 @@</span> <span class="p_context"> static int exynos5_i2c_resume_noirq(struct device *dev)</span>
 	}
 
 	exynos5_i2c_init(i2c);
<span class="p_del">-	clk_disable_unprepare(i2c-&gt;clk);</span>
<span class="p_add">+	clk_disable(i2c-&gt;clk);</span>
 	i2c-&gt;suspended = 0;
 
 	return 0;
<span class="p_header">diff --git a/drivers/infiniband/core/cache.c b/drivers/infiniband/core/cache.c</span>
<span class="p_header">index 53343ffbff7a..1b109b2a235e 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cache.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cache.c</span>
<span class="p_chunk">@@ -691,7 +691,8 @@</span> <span class="p_context"> void ib_cache_gid_set_default_gid(struct ib_device *ib_dev, u8 port,</span>
 			      NULL);
 
 		/* Coudn&#39;t find default GID location */
<span class="p_del">-		WARN_ON(ix &lt; 0);</span>
<span class="p_add">+		if (WARN_ON(ix &lt; 0))</span>
<span class="p_add">+			goto release;</span>
 
 		zattr_type.gid_type = gid_type;
 
<span class="p_header">diff --git a/drivers/infiniband/core/ucm.c b/drivers/infiniband/core/ucm.c</span>
<span class="p_header">index 6b4e8a008bc0..564adf3116e8 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/ucm.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/ucm.c</span>
<span class="p_chunk">@@ -48,6 +48,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
 #include &lt;rdma/ib_cm.h&gt;
 #include &lt;rdma/ib_user_cm.h&gt;
 #include &lt;rdma/ib_marshall.h&gt;
<span class="p_chunk">@@ -1103,6 +1104,9 @@</span> <span class="p_context"> static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,</span>
 	struct ib_ucm_cmd_hdr hdr;
 	ssize_t result;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (len &lt; sizeof(hdr))
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/infiniband/core/ucma.c b/drivers/infiniband/core/ucma.c</span>
<span class="p_header">index 8b5a934e1133..886f61ea6cc7 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/ucma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/ucma.c</span>
<span class="p_chunk">@@ -1574,6 +1574,9 @@</span> <span class="p_context"> static ssize_t ucma_write(struct file *filp, const char __user *buf,</span>
 	struct rdma_ucm_cmd_hdr hdr;
 	ssize_t ret;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (len &lt; sizeof(hdr))
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index 39680aed99dd..d3fb8aa46c59 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -48,6 +48,8 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;uverbs.h&quot;
 
 MODULE_AUTHOR(&quot;Roland Dreier&quot;);
<span class="p_chunk">@@ -693,6 +695,9 @@</span> <span class="p_context"> static ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,</span>
 	int srcu_key;
 	ssize_t ret;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (count &lt; sizeof hdr)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index 03c418ccbc98..ed9cefa1f6f1 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -517,7 +517,7 @@</span> <span class="p_context"> static int mlx5_ib_query_device(struct ib_device *ibdev,</span>
 		     sizeof(struct mlx5_wqe_ctrl_seg)) /
 		     sizeof(struct mlx5_wqe_data_seg);
 	props-&gt;max_sge = min(max_rq_sg, max_sq_sg);
<span class="p_del">-	props-&gt;max_sge_rd = props-&gt;max_sge;</span>
<span class="p_add">+	props-&gt;max_sge_rd	   = MLX5_MAX_SGE_RD;</span>
 	props-&gt;max_cq		   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_cq);
 	props-&gt;max_cqe = (1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_cq_sz)) - 1;
 	props-&gt;max_mr		   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_mkey);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_file_ops.c b/drivers/infiniband/hw/qib/qib_file_ops.c</span>
<span class="p_header">index e449e394963f..24f4a782e0f4 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_file_ops.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_file_ops.c</span>
<span class="p_chunk">@@ -45,6 +45,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/export.h&gt;
 #include &lt;linux/uio.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;qib.h&quot;
 #include &quot;qib_common.h&quot;
 #include &quot;qib_user_sdma.h&quot;
<span class="p_chunk">@@ -2067,6 +2069,9 @@</span> <span class="p_context"> static ssize_t qib_write(struct file *fp, const char __user *data,</span>
 	ssize_t ret = 0;
 	void *dest;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (count &lt; sizeof(cmd.type)) {
 		ret = -EINVAL;
 		goto bail;
<span class="p_header">diff --git a/drivers/input/misc/pmic8xxx-pwrkey.c b/drivers/input/misc/pmic8xxx-pwrkey.c</span>
<span class="p_header">index 3f02e0e03d12..67aab86048ad 100644</span>
<span class="p_header">--- a/drivers/input/misc/pmic8xxx-pwrkey.c</span>
<span class="p_header">+++ b/drivers/input/misc/pmic8xxx-pwrkey.c</span>
<span class="p_chunk">@@ -353,7 +353,8 @@</span> <span class="p_context"> static int pmic8xxx_pwrkey_probe(struct platform_device *pdev)</span>
 	if (of_property_read_u32(pdev-&gt;dev.of_node, &quot;debounce&quot;, &amp;kpd_delay))
 		kpd_delay = 15625;
 
<span class="p_del">-	if (kpd_delay &gt; 62500 || kpd_delay == 0) {</span>
<span class="p_add">+	/* Valid range of pwr key trigger delay is 1/64 sec to 2 seconds. */</span>
<span class="p_add">+	if (kpd_delay &gt; USEC_PER_SEC * 2 || kpd_delay &lt; USEC_PER_SEC / 64) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;invalid power key trigger delay\n&quot;);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -385,8 +386,8 @@</span> <span class="p_context"> static int pmic8xxx_pwrkey_probe(struct platform_device *pdev)</span>
 	pwr-&gt;name = &quot;pmic8xxx_pwrkey&quot;;
 	pwr-&gt;phys = &quot;pmic8xxx_pwrkey/input0&quot;;
 
<span class="p_del">-	delay = (kpd_delay &lt;&lt; 10) / USEC_PER_SEC;</span>
<span class="p_del">-	delay = 1 + ilog2(delay);</span>
<span class="p_add">+	delay = (kpd_delay &lt;&lt; 6) / USEC_PER_SEC;</span>
<span class="p_add">+	delay = ilog2(delay);</span>
 
 	err = regmap_read(regmap, PON_CNTL_1, &amp;pon_cntl);
 	if (err &lt; 0) {
<span class="p_header">diff --git a/drivers/input/tablet/gtco.c b/drivers/input/tablet/gtco.c</span>
<span class="p_header">index 3a7f3a4a4396..7c18249d6c8e 100644</span>
<span class="p_header">--- a/drivers/input/tablet/gtco.c</span>
<span class="p_header">+++ b/drivers/input/tablet/gtco.c</span>
<span class="p_chunk">@@ -858,6 +858,14 @@</span> <span class="p_context"> static int gtco_probe(struct usb_interface *usbinterface,</span>
 		goto err_free_buf;
 	}
 
<span class="p_add">+	/* Sanity check that a device has an endpoint */</span>
<span class="p_add">+	if (usbinterface-&gt;altsetting[0].desc.bNumEndpoints &lt; 1) {</span>
<span class="p_add">+		dev_err(&amp;usbinterface-&gt;dev,</span>
<span class="p_add">+			&quot;Invalid number of endpoints\n&quot;);</span>
<span class="p_add">+		error = -EINVAL;</span>
<span class="p_add">+		goto err_free_urb;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * The endpoint is always altsetting 0, we know this since we know
 	 * this device only has one interrupt endpoint
<span class="p_chunk">@@ -879,7 +887,7 @@</span> <span class="p_context"> static int gtco_probe(struct usb_interface *usbinterface,</span>
 	 * HID report descriptor
 	 */
 	if (usb_get_extra_descriptor(usbinterface-&gt;cur_altsetting,
<span class="p_del">-				     HID_DEVICE_TYPE, &amp;hid_desc) != 0){</span>
<span class="p_add">+				     HID_DEVICE_TYPE, &amp;hid_desc) != 0) {</span>
 		dev_err(&amp;usbinterface-&gt;dev,
 			&quot;Can&#39;t retrieve exta USB descriptor to get hid report descriptor length\n&quot;);
 		error = -EIO;
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 374c129219ef..5efadad4615b 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -92,6 +92,7 @@</span> <span class="p_context"> struct iommu_dev_data {</span>
 	struct list_head dev_data_list;	  /* For global dev_data_list */
 	struct protection_domain *domain; /* Domain the device is bound to */
 	u16 devid;			  /* PCI Device ID */
<span class="p_add">+	u16 alias;			  /* Alias Device ID */</span>
 	bool iommu_v2;			  /* Device can make use of IOMMUv2 */
 	bool passthrough;		  /* Device is identity mapped */
 	struct {
<span class="p_chunk">@@ -166,6 +167,13 @@</span> <span class="p_context"> static struct protection_domain *to_pdomain(struct iommu_domain *dom)</span>
 	return container_of(dom, struct protection_domain, domain);
 }
 
<span class="p_add">+static inline u16 get_device_id(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pdev = to_pci_dev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return PCI_DEVID(pdev-&gt;bus-&gt;number, pdev-&gt;devfn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct iommu_dev_data *alloc_dev_data(u16 devid)
 {
 	struct iommu_dev_data *dev_data;
<span class="p_chunk">@@ -203,6 +211,68 @@</span> <span class="p_context"> out_unlock:</span>
 	return dev_data;
 }
 
<span class="p_add">+static int __last_alias(struct pci_dev *pdev, u16 alias, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*(u16 *)data = alias;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u16 get_alias(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pdev = to_pci_dev(dev);</span>
<span class="p_add">+	u16 devid, ivrs_alias, pci_alias;</span>
<span class="p_add">+</span>
<span class="p_add">+	devid = get_device_id(dev);</span>
<span class="p_add">+	ivrs_alias = amd_iommu_alias_table[devid];</span>
<span class="p_add">+	pci_for_each_dma_alias(pdev, __last_alias, &amp;pci_alias);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ivrs_alias == pci_alias)</span>
<span class="p_add">+		return ivrs_alias;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * DMA alias showdown</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The IVRS is fairly reliable in telling us about aliases, but it</span>
<span class="p_add">+	 * can&#39;t know about every screwy device.  If we don&#39;t have an IVRS</span>
<span class="p_add">+	 * reported alias, use the PCI reported alias.  In that case we may</span>
<span class="p_add">+	 * still need to initialize the rlookup and dev_table entries if the</span>
<span class="p_add">+	 * alias is to a non-existent device.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ivrs_alias == devid) {</span>
<span class="p_add">+		if (!amd_iommu_rlookup_table[pci_alias]) {</span>
<span class="p_add">+			amd_iommu_rlookup_table[pci_alias] =</span>
<span class="p_add">+				amd_iommu_rlookup_table[devid];</span>
<span class="p_add">+			memcpy(amd_iommu_dev_table[pci_alias].data,</span>
<span class="p_add">+			       amd_iommu_dev_table[devid].data,</span>
<span class="p_add">+			       sizeof(amd_iommu_dev_table[pci_alias].data));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		return pci_alias;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;AMD-Vi: Using IVRS reported alias %02x:%02x.%d &quot;</span>
<span class="p_add">+		&quot;for device %s[%04x:%04x], kernel reported alias &quot;</span>
<span class="p_add">+		&quot;%02x:%02x.%d\n&quot;, PCI_BUS_NUM(ivrs_alias), PCI_SLOT(ivrs_alias),</span>
<span class="p_add">+		PCI_FUNC(ivrs_alias), dev_name(dev), pdev-&gt;vendor, pdev-&gt;device,</span>
<span class="p_add">+		PCI_BUS_NUM(pci_alias), PCI_SLOT(pci_alias),</span>
<span class="p_add">+		PCI_FUNC(pci_alias));</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we don&#39;t have a PCI DMA alias and the IVRS alias is on the same</span>
<span class="p_add">+	 * bus, then the IVRS table may know about a quirk that we don&#39;t.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pci_alias == devid &amp;&amp;</span>
<span class="p_add">+	    PCI_BUS_NUM(ivrs_alias) == pdev-&gt;bus-&gt;number) {</span>
<span class="p_add">+		pdev-&gt;dev_flags |= PCI_DEV_FLAGS_DMA_ALIAS_DEVFN;</span>
<span class="p_add">+		pdev-&gt;dma_alias_devfn = ivrs_alias &amp; 0xff;</span>
<span class="p_add">+		pr_info(&quot;AMD-Vi: Added PCI DMA alias %02x.%d for %s\n&quot;,</span>
<span class="p_add">+			PCI_SLOT(ivrs_alias), PCI_FUNC(ivrs_alias),</span>
<span class="p_add">+			dev_name(dev));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ivrs_alias;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct iommu_dev_data *find_dev_data(u16 devid)
 {
 	struct iommu_dev_data *dev_data;
<span class="p_chunk">@@ -215,13 +285,6 @@</span> <span class="p_context"> static struct iommu_dev_data *find_dev_data(u16 devid)</span>
 	return dev_data;
 }
 
<span class="p_del">-static inline u16 get_device_id(struct device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pci_dev *pdev = to_pci_dev(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	return PCI_DEVID(pdev-&gt;bus-&gt;number, pdev-&gt;devfn);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct iommu_dev_data *get_dev_data(struct device *dev)
 {
 	return dev-&gt;archdata.iommu;
<span class="p_chunk">@@ -349,6 +412,8 @@</span> <span class="p_context"> static int iommu_init_device(struct device *dev)</span>
 	if (!dev_data)
 		return -ENOMEM;
 
<span class="p_add">+	dev_data-&gt;alias = get_alias(dev);</span>
<span class="p_add">+</span>
 	if (pci_iommuv2_capable(pdev)) {
 		struct amd_iommu *iommu;
 
<span class="p_chunk">@@ -369,7 +434,7 @@</span> <span class="p_context"> static void iommu_ignore_device(struct device *dev)</span>
 	u16 devid, alias;
 
 	devid = get_device_id(dev);
<span class="p_del">-	alias = amd_iommu_alias_table[devid];</span>
<span class="p_add">+	alias = get_alias(dev);</span>
 
 	memset(&amp;amd_iommu_dev_table[devid], 0, sizeof(struct dev_table_entry));
 	memset(&amp;amd_iommu_dev_table[alias], 0, sizeof(struct dev_table_entry));
<span class="p_chunk">@@ -1061,7 +1126,7 @@</span> <span class="p_context"> static int device_flush_dte(struct iommu_dev_data *dev_data)</span>
 	int ret;
 
 	iommu = amd_iommu_rlookup_table[dev_data-&gt;devid];
<span class="p_del">-	alias = amd_iommu_alias_table[dev_data-&gt;devid];</span>
<span class="p_add">+	alias = dev_data-&gt;alias;</span>
 
 	ret = iommu_flush_dte(iommu, dev_data-&gt;devid);
 	if (!ret &amp;&amp; alias != dev_data-&gt;devid)
<span class="p_chunk">@@ -2039,7 +2104,7 @@</span> <span class="p_context"> static void do_attach(struct iommu_dev_data *dev_data,</span>
 	bool ats;
 
 	iommu = amd_iommu_rlookup_table[dev_data-&gt;devid];
<span class="p_del">-	alias = amd_iommu_alias_table[dev_data-&gt;devid];</span>
<span class="p_add">+	alias = dev_data-&gt;alias;</span>
 	ats   = dev_data-&gt;ats.enabled;
 
 	/* Update data structures */
<span class="p_chunk">@@ -2073,7 +2138,7 @@</span> <span class="p_context"> static void do_detach(struct iommu_dev_data *dev_data)</span>
 		return;
 
 	iommu = amd_iommu_rlookup_table[dev_data-&gt;devid];
<span class="p_del">-	alias = amd_iommu_alias_table[dev_data-&gt;devid];</span>
<span class="p_add">+	alias = dev_data-&gt;alias;</span>
 
 	/* decrease reference counters */
 	dev_data-&gt;domain-&gt;dev_iommu[iommu-&gt;index] -= 1;
<span class="p_header">diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c</span>
<span class="p_header">index 72d6182666cb..58f2fe687a24 100644</span>
<span class="p_header">--- a/drivers/iommu/dma-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/dma-iommu.c</span>
<span class="p_chunk">@@ -403,7 +403,7 @@</span> <span class="p_context"> static int __finalise_sg(struct device *dev, struct scatterlist *sg, int nents,</span>
 		unsigned int s_length = sg_dma_len(s);
 		unsigned int s_dma_len = s-&gt;length;
 
<span class="p_del">-		s-&gt;offset = s_offset;</span>
<span class="p_add">+		s-&gt;offset += s_offset;</span>
 		s-&gt;length = s_length;
 		sg_dma_address(s) = dma_addr + s_offset;
 		dma_addr += s_dma_len;
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> static void __invalidate_sg(struct scatterlist *sg, int nents)</span>
 
 	for_each_sg(sg, s, nents, i) {
 		if (sg_dma_address(s) != DMA_ERROR_CODE)
<span class="p_del">-			s-&gt;offset = sg_dma_address(s);</span>
<span class="p_add">+			s-&gt;offset += sg_dma_address(s);</span>
 		if (sg_dma_len(s))
 			s-&gt;length = sg_dma_len(s);
 		sg_dma_address(s) = DMA_ERROR_CODE;
<span class="p_header">diff --git a/drivers/irqchip/irq-mxs.c b/drivers/irqchip/irq-mxs.c</span>
<span class="p_header">index efe50845939d..17304705f2cf 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-mxs.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-mxs.c</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static void __iomem * __init icoll_init_iobase(struct device_node *np)</span>
 	void __iomem *icoll_base;
 
 	icoll_base = of_io_request_and_map(np, 0, np-&gt;name);
<span class="p_del">-	if (!icoll_base)</span>
<span class="p_add">+	if (IS_ERR(icoll_base))</span>
 		panic(&quot;%s: unable to map resource&quot;, np-&gt;full_name);
 	return icoll_base;
 }
<span class="p_header">diff --git a/drivers/irqchip/irq-sunxi-nmi.c b/drivers/irqchip/irq-sunxi-nmi.c</span>
<span class="p_header">index 0820f67cc9a7..668730c5cb66 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-sunxi-nmi.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-sunxi-nmi.c</span>
<span class="p_chunk">@@ -160,9 +160,9 @@</span> <span class="p_context"> static int __init sunxi_sc_nmi_irq_init(struct device_node *node,</span>
 
 	gc = irq_get_domain_generic_chip(domain, 0);
 	gc-&gt;reg_base = of_io_request_and_map(node, 0, of_node_full_name(node));
<span class="p_del">-	if (!gc-&gt;reg_base) {</span>
<span class="p_add">+	if (IS_ERR(gc-&gt;reg_base)) {</span>
 		pr_err(&quot;unable to map resource\n&quot;);
<span class="p_del">-		ret = -ENOMEM;</span>
<span class="p_add">+		ret = PTR_ERR(gc-&gt;reg_base);</span>
 		goto fail_irqd_remove;
 	}
 
<span class="p_header">diff --git a/drivers/md/dm-cache-metadata.c b/drivers/md/dm-cache-metadata.c</span>
<span class="p_header">index 27f2ef300f8b..3970cda10080 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-metadata.c</span>
<span class="p_chunk">@@ -867,39 +867,55 @@</span> <span class="p_context"> static int blocks_are_unmapped_or_clean(struct dm_cache_metadata *cmd,</span>
 	return 0;
 }
 
<span class="p_del">-#define WRITE_LOCK(cmd)	\</span>
<span class="p_del">-	down_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_del">-		up_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-		return -EINVAL; \</span>
<span class="p_add">+static bool cmd_write_lock(struct dm_cache_metadata *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	down_write(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) {</span>
<span class="p_add">+		up_write(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+		return false;</span>
 	}
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#define WRITE_LOCK_VOID(cmd) \</span>
<span class="p_del">-	down_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_del">-		up_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-		return; \</span>
<span class="p_del">-	}</span>
<span class="p_add">+#define WRITE_LOCK(cmd)				\</span>
<span class="p_add">+	do {					\</span>
<span class="p_add">+		if (!cmd_write_lock((cmd)))	\</span>
<span class="p_add">+			return -EINVAL;		\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define WRITE_LOCK_VOID(cmd)			\</span>
<span class="p_add">+	do {					\</span>
<span class="p_add">+		if (!cmd_write_lock((cmd)))	\</span>
<span class="p_add">+			return;			\</span>
<span class="p_add">+	} while(0)</span>
 
 #define WRITE_UNLOCK(cmd) \
<span class="p_del">-	up_write(&amp;cmd-&gt;root_lock)</span>
<span class="p_add">+	up_write(&amp;(cmd)-&gt;root_lock)</span>
 
<span class="p_del">-#define READ_LOCK(cmd) \</span>
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_del">-		up_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-		return -EINVAL; \</span>
<span class="p_add">+static bool cmd_read_lock(struct dm_cache_metadata *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	if (cmd-&gt;fail_io) {</span>
<span class="p_add">+		up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+		return false;</span>
 	}
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#define READ_LOCK_VOID(cmd)	\</span>
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_del">-		up_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-		return; \</span>
<span class="p_del">-	}</span>
<span class="p_add">+#define READ_LOCK(cmd)				\</span>
<span class="p_add">+	do {					\</span>
<span class="p_add">+		if (!cmd_read_lock((cmd)))	\</span>
<span class="p_add">+			return -EINVAL;		\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define READ_LOCK_VOID(cmd)			\</span>
<span class="p_add">+	do {					\</span>
<span class="p_add">+		if (!cmd_read_lock((cmd)))	\</span>
<span class="p_add">+			return;			\</span>
<span class="p_add">+	} while(0)</span>
 
 #define READ_UNLOCK(cmd) \
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock)</span>
<span class="p_add">+	up_read(&amp;(cmd)-&gt;root_lock)</span>
 
 int dm_cache_resize(struct dm_cache_metadata *cmd, dm_cblock_t new_cache_size)
 {
<span class="p_header">diff --git a/drivers/media/usb/usbvision/usbvision-video.c b/drivers/media/usb/usbvision/usbvision-video.c</span>
<span class="p_header">index de9ff3bb8edd..6996ab8db108 100644</span>
<span class="p_header">--- a/drivers/media/usb/usbvision/usbvision-video.c</span>
<span class="p_header">+++ b/drivers/media/usb/usbvision/usbvision-video.c</span>
<span class="p_chunk">@@ -1461,13 +1461,6 @@</span> <span class="p_context"> static int usbvision_probe(struct usb_interface *intf,</span>
 	printk(KERN_INFO &quot;%s: %s found\n&quot;, __func__,
 				usbvision_device_data[model].model_string);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * this is a security check.</span>
<span class="p_del">-	 * an exploit using an incorrect bInterfaceNumber is known</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (ifnum &gt;= USB_MAXINTERFACES || !dev-&gt;actconfig-&gt;interface[ifnum])</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
 	if (usbvision_device_data[model].interface &gt;= 0)
 		interface = &amp;dev-&gt;actconfig-&gt;interface[usbvision_device_data[model].interface]-&gt;altsetting[0];
 	else if (ifnum &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces)
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index ff8953ae52d1..d7d7c52a3060 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -1643,7 +1643,7 @@</span> <span class="p_context"> static int __vb2_wait_for_done_vb(struct vb2_queue *q, int nonblocking)</span>
  * Will sleep if required for nonblocking == false.
  */
 static int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,
<span class="p_del">-				int nonblocking)</span>
<span class="p_add">+			     void *pb, int nonblocking)</span>
 {
 	unsigned long flags;
 	int ret;
<span class="p_chunk">@@ -1664,10 +1664,10 @@</span> <span class="p_context"> static int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,</span>
 	/*
 	 * Only remove the buffer from done_list if v4l2_buffer can handle all
 	 * the planes.
<span class="p_del">-	 * Verifying planes is NOT necessary since it already has been checked</span>
<span class="p_del">-	 * before the buffer is queued/prepared. So it can never fail.</span>
 	 */
<span class="p_del">-	list_del(&amp;(*vb)-&gt;done_entry);</span>
<span class="p_add">+	ret = call_bufop(q, verify_planes_array, *vb, pb);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		list_del(&amp;(*vb)-&gt;done_entry);</span>
 	spin_unlock_irqrestore(&amp;q-&gt;done_lock, flags);
 
 	return ret;
<span class="p_chunk">@@ -1746,7 +1746,7 @@</span> <span class="p_context"> int vb2_core_dqbuf(struct vb2_queue *q, unsigned int *pindex, void *pb,</span>
 	struct vb2_buffer *vb = NULL;
 	int ret;
 
<span class="p_del">-	ret = __vb2_get_done_vb(q, &amp;vb, nonblocking);</span>
<span class="p_add">+	ret = __vb2_get_done_vb(q, &amp;vb, pb, nonblocking);</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_chunk">@@ -2293,6 +2293,16 @@</span> <span class="p_context"> unsigned int vb2_core_poll(struct vb2_queue *q, struct file *file,</span>
 		return POLLERR;
 
 	/*
<span class="p_add">+	 * If this quirk is set and QBUF hasn&#39;t been called yet then</span>
<span class="p_add">+	 * return POLLERR as well. This only affects capture queues, output</span>
<span class="p_add">+	 * queues will always initialize waiting_for_buffers to false.</span>
<span class="p_add">+	 * This quirk is set by V4L2 for backwards compatibility reasons.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (q-&gt;quirk_poll_must_check_waiting_for_buffers &amp;&amp;</span>
<span class="p_add">+	    q-&gt;waiting_for_buffers &amp;&amp; (req_events &amp; (POLLIN | POLLRDNORM)))</span>
<span class="p_add">+		return POLLERR;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * For output streams you can call write() as long as there are fewer
 	 * buffers queued than there are buffers available.
 	 */
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-memops.c b/drivers/media/v4l2-core/videobuf2-memops.c</span>
<span class="p_header">index dbec5923fcf0..3c3b517f1d1c 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-memops.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-memops.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> struct frame_vector *vb2_create_framevec(unsigned long start,</span>
 	vec = frame_vector_create(nr);
 	if (!vec)
 		return ERR_PTR(-ENOMEM);
<span class="p_del">-	ret = get_vaddr_frames(start, nr, write, 1, vec);</span>
<span class="p_add">+	ret = get_vaddr_frames(start &amp; PAGE_MASK, nr, write, true, vec);</span>
 	if (ret &lt; 0)
 		goto out_destroy;
 	/* We accept only complete set of PFNs */
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-v4l2.c b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">index 91f552124050..7f366f1b0377 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_chunk">@@ -74,6 +74,11 @@</span> <span class="p_context"> static int __verify_planes_array(struct vb2_buffer *vb, const struct v4l2_buffer</span>
 	return 0;
 }
 
<span class="p_add">+static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __verify_planes_array(vb, pb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * __verify_length() - Verify that the bytesused value for each plane fits in
  * the plane length and that the data offset doesn&#39;t exceed the bytesused value.
<span class="p_chunk">@@ -437,6 +442,7 @@</span> <span class="p_context"> static int __fill_vb2_buffer(struct vb2_buffer *vb,</span>
 }
 
 static const struct vb2_buf_ops v4l2_buf_ops = {
<span class="p_add">+	.verify_planes_array	= __verify_planes_array_core,</span>
 	.fill_user_buffer	= __fill_v4l2_buffer,
 	.fill_vb2_buffer	= __fill_vb2_buffer,
 	.copy_timestamp		= __copy_timestamp,
<span class="p_chunk">@@ -765,6 +771,12 @@</span> <span class="p_context"> int vb2_queue_init(struct vb2_queue *q)</span>
 	q-&gt;is_output = V4L2_TYPE_IS_OUTPUT(q-&gt;type);
 	q-&gt;copy_timestamp = (q-&gt;timestamp_flags &amp; V4L2_BUF_FLAG_TIMESTAMP_MASK)
 			== V4L2_BUF_FLAG_TIMESTAMP_COPY;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For compatibility with vb1: if QBUF hasn&#39;t been called yet, then</span>
<span class="p_add">+	 * return POLLERR as well. This only affects capture queues, output</span>
<span class="p_add">+	 * queues will always initialize waiting_for_buffers to false.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	q-&gt;quirk_poll_must_check_waiting_for_buffers = true;</span>
 
 	return vb2_core_queue_init(q);
 }
<span class="p_chunk">@@ -818,14 +830,6 @@</span> <span class="p_context"> unsigned int vb2_poll(struct vb2_queue *q, struct file *file, poll_table *wait)</span>
 			poll_wait(file, &amp;fh-&gt;wait, wait);
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * For compatibility with vb1: if QBUF hasn&#39;t been called yet, then</span>
<span class="p_del">-	 * return POLLERR as well. This only affects capture queues, output</span>
<span class="p_del">-	 * queues will always initialize waiting_for_buffers to false.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (q-&gt;waiting_for_buffers &amp;&amp; (req_events &amp; (POLLIN | POLLRDNORM)))</span>
<span class="p_del">-		return POLLERR;</span>
<span class="p_del">-</span>
 	return res | vb2_core_poll(q, file, wait);
 }
 EXPORT_SYMBOL_GPL(vb2_poll);
<span class="p_header">diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig</span>
<span class="p_header">index 054fc10cb3b6..b22c03264270 100644</span>
<span class="p_header">--- a/drivers/misc/Kconfig</span>
<span class="p_header">+++ b/drivers/misc/Kconfig</span>
<span class="p_chunk">@@ -440,7 +440,7 @@</span> <span class="p_context"> config ARM_CHARLCD</span>
 	  still useful.
 
 config BMP085
<span class="p_del">-	bool</span>
<span class="p_add">+	tristate</span>
 	depends on SYSFS
 
 config BMP085_I2C
<span class="p_header">diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c</span>
<span class="p_header">index 15e88078ba1e..f1a0b99f5a9a 100644</span>
<span class="p_header">--- a/drivers/misc/ad525x_dpot.c</span>
<span class="p_header">+++ b/drivers/misc/ad525x_dpot.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)</span>
 			 */
 			value = swab16(value);
 
<span class="p_del">-			if (dpot-&gt;uid == DPOT_UID(AD5271_ID))</span>
<span class="p_add">+			if (dpot-&gt;uid == DPOT_UID(AD5274_ID))</span>
 				value = value &gt;&gt; 2;
 		return value;
 	default:
<span class="p_header">diff --git a/drivers/misc/cxl/irq.c b/drivers/misc/cxl/irq.c</span>
<span class="p_header">index 09a406058c46..efbb6945eb18 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/irq.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/irq.c</span>
<span class="p_chunk">@@ -288,7 +288,6 @@</span> <span class="p_context"> unsigned int cxl_map_irq(struct cxl *adapter, irq_hw_number_t hwirq,</span>
 void cxl_unmap_irq(unsigned int virq, void *cookie)
 {
 	free_irq(virq, cookie);
<span class="p_del">-	irq_dispose_mapping(virq);</span>
 }
 
 static int cxl_register_one_irq(struct cxl *adapter,
<span class="p_header">diff --git a/drivers/misc/mic/scif/scif_rma.c b/drivers/misc/mic/scif/scif_rma.c</span>
<span class="p_header">index 8310b4dbff06..6a451bd65bf3 100644</span>
<span class="p_header">--- a/drivers/misc/mic/scif/scif_rma.c</span>
<span class="p_header">+++ b/drivers/misc/mic/scif/scif_rma.c</span>
<span class="p_chunk">@@ -1511,7 +1511,7 @@</span> <span class="p_context"> off_t scif_register_pinned_pages(scif_epd_t epd,</span>
 	if ((map_flags &amp; SCIF_MAP_FIXED) &amp;&amp;
 	    ((ALIGN(offset, PAGE_SIZE) != offset) ||
 	    (offset &lt; 0) ||
<span class="p_del">-	    (offset + (off_t)len &lt; offset)))</span>
<span class="p_add">+	    (len &gt; LONG_MAX - offset)))</span>
 		return -EINVAL;
 
 	might_sleep();
<span class="p_chunk">@@ -1614,7 +1614,7 @@</span> <span class="p_context"> off_t scif_register(scif_epd_t epd, void *addr, size_t len, off_t offset,</span>
 	if ((map_flags &amp; SCIF_MAP_FIXED) &amp;&amp;
 	    ((ALIGN(offset, PAGE_SIZE) != offset) ||
 	    (offset &lt; 0) ||
<span class="p_del">-	    (offset + (off_t)len &lt; offset)))</span>
<span class="p_add">+	    (len &gt; LONG_MAX - offset)))</span>
 		return -EINVAL;
 
 	/* Unsupported protection requested */
<span class="p_chunk">@@ -1732,7 +1732,8 @@</span> <span class="p_context"> scif_unregister(scif_epd_t epd, off_t offset, size_t len)</span>
 
 	/* Offset is not page aligned or offset+len wraps around */
 	if ((ALIGN(offset, PAGE_SIZE) != offset) ||
<span class="p_del">-	    (offset + (off_t)len &lt; offset))</span>
<span class="p_add">+	    (offset &lt; 0) ||</span>
<span class="p_add">+	    (len &gt; LONG_MAX - offset))</span>
 		return -EINVAL;
 
 	err = scif_verify_epd(ep);
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 5fbffdb6b854..c6f36f3ca5d2 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -86,7 +86,6 @@</span> <span class="p_context"> static int max_devices;</span>
 
 /* TODO: Replace these with struct ida */
 static DECLARE_BITMAP(dev_use, MAX_DEVICES);
<span class="p_del">-static DECLARE_BITMAP(name_use, MAX_DEVICES);</span>
 
 /*
  * There is one mmc_blk_data per slot.
<span class="p_chunk">@@ -105,7 +104,6 @@</span> <span class="p_context"> struct mmc_blk_data {</span>
 	unsigned int	usage;
 	unsigned int	read_only;
 	unsigned int	part_type;
<span class="p_del">-	unsigned int	name_idx;</span>
 	unsigned int	reset_done;
 #define MMC_BLK_READ		BIT(0)
 #define MMC_BLK_WRITE		BIT(1)
<span class="p_chunk">@@ -2202,19 +2200,6 @@</span> <span class="p_context"> static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,</span>
 		goto out;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * !subname implies we are creating main mmc_blk_data that will be</span>
<span class="p_del">-	 * associated with mmc_card with dev_set_drvdata. Due to device</span>
<span class="p_del">-	 * partitions, devidx will not coincide with a per-physical card</span>
<span class="p_del">-	 * index anymore so we keep track of a name index.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!subname) {</span>
<span class="p_del">-		md-&gt;name_idx = find_first_zero_bit(name_use, max_devices);</span>
<span class="p_del">-		__set_bit(md-&gt;name_idx, name_use);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		md-&gt;name_idx = ((struct mmc_blk_data *)</span>
<span class="p_del">-				dev_to_disk(parent)-&gt;private_data)-&gt;name_idx;</span>
<span class="p_del">-</span>
 	md-&gt;area_type = area_type;
 
 	/*
<span class="p_chunk">@@ -2264,7 +2249,7 @@</span> <span class="p_context"> static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,</span>
 	 */
 
 	snprintf(md-&gt;disk-&gt;disk_name, sizeof(md-&gt;disk-&gt;disk_name),
<span class="p_del">-		 &quot;mmcblk%u%s&quot;, md-&gt;name_idx, subname ? subname : &quot;&quot;);</span>
<span class="p_add">+		 &quot;mmcblk%u%s&quot;, card-&gt;host-&gt;index, subname ? subname : &quot;&quot;);</span>
 
 	if (mmc_card_mmc(card))
 		blk_queue_logical_block_size(md-&gt;queue.queue,
<span class="p_chunk">@@ -2418,7 +2403,6 @@</span> <span class="p_context"> static void mmc_blk_remove_parts(struct mmc_card *card,</span>
 	struct list_head *pos, *q;
 	struct mmc_blk_data *part_md;
 
<span class="p_del">-	__clear_bit(md-&gt;name_idx, name_use);</span>
 	list_for_each_safe(pos, q, &amp;md-&gt;part) {
 		part_md = list_entry(pos, struct mmc_blk_data, part);
 		list_del(pos);
<span class="p_header">diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig</span>
<span class="p_header">index 1526b8a10b09..3b944fc70eec 100644</span>
<span class="p_header">--- a/drivers/mmc/host/Kconfig</span>
<span class="p_header">+++ b/drivers/mmc/host/Kconfig</span>
<span class="p_chunk">@@ -97,6 +97,7 @@</span> <span class="p_context"> config MMC_RICOH_MMC</span>
 config MMC_SDHCI_ACPI
 	tristate &quot;SDHCI support for ACPI enumerated SDHCI controllers&quot;
 	depends on MMC_SDHCI &amp;&amp; ACPI
<span class="p_add">+	select IOSF_MBI if X86</span>
 	help
 	  This selects support for ACPI enumerated SDHCI controllers,
 	  identified by ACPI Compatibility ID PNP0D40 or specific
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">index a5cda926d38e..975139f97498 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_chunk">@@ -41,6 +41,11 @@</span> <span class="p_context"></span>
 #include &lt;linux/mmc/pm.h&gt;
 #include &lt;linux/mmc/slot-gpio.h&gt;
 
<span class="p_add">+#ifdef CONFIG_X86</span>
<span class="p_add">+#include &lt;asm/cpu_device_id.h&gt;</span>
<span class="p_add">+#include &lt;asm/iosf_mbi.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #include &quot;sdhci.h&quot;
 
 enum {
<span class="p_chunk">@@ -146,6 +151,75 @@</span> <span class="p_context"> static const struct sdhci_acpi_chip sdhci_acpi_chip_int = {</span>
 	.ops = &amp;sdhci_acpi_ops_int,
 };
 
<span class="p_add">+#ifdef CONFIG_X86</span>
<span class="p_add">+</span>
<span class="p_add">+static bool sdhci_acpi_byt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static const struct x86_cpu_id byt[] = {</span>
<span class="p_add">+		{ X86_VENDOR_INTEL, 6, 0x37 },</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	return x86_match_cpu(byt);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define BYT_IOSF_SCCEP			0x63</span>
<span class="p_add">+#define BYT_IOSF_OCP_NETCTRL0		0x1078</span>
<span class="p_add">+#define BYT_IOSF_OCP_TIMEOUT_BASE	GENMASK(10, 8)</span>
<span class="p_add">+</span>
<span class="p_add">+static void sdhci_acpi_byt_setting(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!sdhci_acpi_byt())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (iosf_mbi_read(BYT_IOSF_SCCEP, MBI_CR_READ, BYT_IOSF_OCP_NETCTRL0,</span>
<span class="p_add">+			  &amp;val)) {</span>
<span class="p_add">+		dev_err(dev, &quot;%s read error\n&quot;, __func__);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(val &amp; BYT_IOSF_OCP_TIMEOUT_BASE))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	val &amp;= ~BYT_IOSF_OCP_TIMEOUT_BASE;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (iosf_mbi_write(BYT_IOSF_SCCEP, MBI_CR_WRITE, BYT_IOSF_OCP_NETCTRL0,</span>
<span class="p_add">+			   val)) {</span>
<span class="p_add">+		dev_err(dev, &quot;%s write error\n&quot;, __func__);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_dbg(dev, &quot;%s completed\n&quot;, __func__);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool sdhci_acpi_byt_defer(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!sdhci_acpi_byt())</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!iosf_mbi_available())</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	sdhci_acpi_byt_setting(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#else</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void sdhci_acpi_byt_setting(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool sdhci_acpi_byt_defer(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static int bxt_get_cd(struct mmc_host *mmc)
 {
 	int gpio_cd = mmc_gpio_get_cd(mmc);
<span class="p_chunk">@@ -337,6 +411,9 @@</span> <span class="p_context"> static int sdhci_acpi_probe(struct platform_device *pdev)</span>
 	if (acpi_bus_get_status(device) || !device-&gt;status.present)
 		return -ENODEV;
 
<span class="p_add">+	if (sdhci_acpi_byt_defer(dev))</span>
<span class="p_add">+		return -EPROBE_DEFER;</span>
<span class="p_add">+</span>
 	hid = acpi_device_hid(device);
 	uid = device-&gt;pnp.unique_id;
 
<span class="p_chunk">@@ -460,6 +537,8 @@</span> <span class="p_context"> static int sdhci_acpi_resume(struct device *dev)</span>
 {
 	struct sdhci_acpi_host *c = dev_get_drvdata(dev);
 
<span class="p_add">+	sdhci_acpi_byt_setting(&amp;c-&gt;pdev-&gt;dev);</span>
<span class="p_add">+</span>
 	return sdhci_resume_host(c-&gt;host);
 }
 
<span class="p_chunk">@@ -483,6 +562,8 @@</span> <span class="p_context"> static int sdhci_acpi_runtime_resume(struct device *dev)</span>
 {
 	struct sdhci_acpi_host *c = dev_get_drvdata(dev);
 
<span class="p_add">+	sdhci_acpi_byt_setting(&amp;c-&gt;pdev-&gt;dev);</span>
<span class="p_add">+</span>
 	return sdhci_runtime_resume_host(c-&gt;host);
 }
 
<span class="p_header">diff --git a/drivers/mtd/nand/brcmnand/brcmnand.c b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">index 844fc07d22cd..f7009c1cb90c 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_chunk">@@ -311,6 +311,36 @@</span> <span class="p_context"> static const u16 brcmnand_regs_v60[] = {</span>
 	[BRCMNAND_FC_BASE]		= 0x400,
 };
 
<span class="p_add">+/* BRCMNAND v7.1 */</span>
<span class="p_add">+static const u16 brcmnand_regs_v71[] = {</span>
<span class="p_add">+	[BRCMNAND_CMD_START]		=  0x04,</span>
<span class="p_add">+	[BRCMNAND_CMD_EXT_ADDRESS]	=  0x08,</span>
<span class="p_add">+	[BRCMNAND_CMD_ADDRESS]		=  0x0c,</span>
<span class="p_add">+	[BRCMNAND_INTFC_STATUS]		=  0x14,</span>
<span class="p_add">+	[BRCMNAND_CS_SELECT]		=  0x18,</span>
<span class="p_add">+	[BRCMNAND_CS_XOR]		=  0x1c,</span>
<span class="p_add">+	[BRCMNAND_LL_OP]		=  0x20,</span>
<span class="p_add">+	[BRCMNAND_CS0_BASE]		=  0x50,</span>
<span class="p_add">+	[BRCMNAND_CS1_BASE]		=     0,</span>
<span class="p_add">+	[BRCMNAND_CORR_THRESHOLD]	=  0xdc,</span>
<span class="p_add">+	[BRCMNAND_CORR_THRESHOLD_EXT]	=  0xe0,</span>
<span class="p_add">+	[BRCMNAND_UNCORR_COUNT]		=  0xfc,</span>
<span class="p_add">+	[BRCMNAND_CORR_COUNT]		= 0x100,</span>
<span class="p_add">+	[BRCMNAND_CORR_EXT_ADDR]	= 0x10c,</span>
<span class="p_add">+	[BRCMNAND_CORR_ADDR]		= 0x110,</span>
<span class="p_add">+	[BRCMNAND_UNCORR_EXT_ADDR]	= 0x114,</span>
<span class="p_add">+	[BRCMNAND_UNCORR_ADDR]		= 0x118,</span>
<span class="p_add">+	[BRCMNAND_SEMAPHORE]		= 0x150,</span>
<span class="p_add">+	[BRCMNAND_ID]			= 0x194,</span>
<span class="p_add">+	[BRCMNAND_ID_EXT]		= 0x198,</span>
<span class="p_add">+	[BRCMNAND_LL_RDATA]		= 0x19c,</span>
<span class="p_add">+	[BRCMNAND_OOB_READ_BASE]	= 0x200,</span>
<span class="p_add">+	[BRCMNAND_OOB_READ_10_BASE]	=     0,</span>
<span class="p_add">+	[BRCMNAND_OOB_WRITE_BASE]	= 0x280,</span>
<span class="p_add">+	[BRCMNAND_OOB_WRITE_10_BASE]	=     0,</span>
<span class="p_add">+	[BRCMNAND_FC_BASE]		= 0x400,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 enum brcmnand_cs_reg {
 	BRCMNAND_CS_CFG_EXT = 0,
 	BRCMNAND_CS_CFG,
<span class="p_chunk">@@ -406,7 +436,9 @@</span> <span class="p_context"> static int brcmnand_revision_init(struct brcmnand_controller *ctrl)</span>
 	}
 
 	/* Register offsets */
<span class="p_del">-	if (ctrl-&gt;nand_version &gt;= 0x0600)</span>
<span class="p_add">+	if (ctrl-&gt;nand_version &gt;= 0x0701)</span>
<span class="p_add">+		ctrl-&gt;reg_offsets = brcmnand_regs_v71;</span>
<span class="p_add">+	else if (ctrl-&gt;nand_version &gt;= 0x0600)</span>
 		ctrl-&gt;reg_offsets = brcmnand_regs_v60;
 	else if (ctrl-&gt;nand_version &gt;= 0x0500)
 		ctrl-&gt;reg_offsets = brcmnand_regs_v50;
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index f2c8ff398d6c..171d146645ba 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -4021,7 +4021,6 @@</span> <span class="p_context"> static int nand_dt_init(struct nand_chip *chip)</span>
  * This is the first phase of the normal nand_scan() function. It reads the
  * flash ID and sets up MTD fields accordingly.
  *
<span class="p_del">- * The mtd-&gt;owner field must be set to the module of the caller.</span>
  */
 int nand_scan_ident(struct mtd_info *mtd, int maxchips,
 		    struct nand_flash_dev *table)
<span class="p_chunk">@@ -4443,19 +4442,12 @@</span> <span class="p_context"> EXPORT_SYMBOL(nand_scan_tail);</span>
  *
  * This fills out all the uninitialized function pointers with the defaults.
  * The flash ID is read and the mtd/chip structures are filled with the
<span class="p_del">- * appropriate values. The mtd-&gt;owner field must be set to the module of the</span>
<span class="p_del">- * caller.</span>
<span class="p_add">+ * appropriate values.</span>
  */
 int nand_scan(struct mtd_info *mtd, int maxchips)
 {
 	int ret;
 
<span class="p_del">-	/* Many callers got this wrong, so check for it for a while... */</span>
<span class="p_del">-	if (!mtd-&gt;owner &amp;&amp; caller_is_module()) {</span>
<span class="p_del">-		pr_crit(&quot;%s called with NULL mtd-&gt;owner!\n&quot;, __func__);</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = nand_scan_ident(mtd, maxchips, NULL);
 	if (!ret)
 		ret = nand_scan_tail(mtd);
<span class="p_header">diff --git a/drivers/mtd/nand/pxa3xx_nand.c b/drivers/mtd/nand/pxa3xx_nand.c</span>
<span class="p_header">index 86fc245dc71a..fd78644469fa 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/pxa3xx_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/pxa3xx_nand.c</span>
<span class="p_chunk">@@ -1738,7 +1738,7 @@</span> <span class="p_context"> static int alloc_nand_resource(struct platform_device *pdev)</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	if (use_dma) {</span>
<span class="p_add">+	if (!np &amp;&amp; use_dma) {</span>
 		r = platform_get_resource(pdev, IORESOURCE_DMA, 0);
 		if (r == NULL) {
 			dev_err(&amp;pdev-&gt;dev,
<span class="p_header">diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c</span>
<span class="p_header">index ed0c19c558b5..3028c06547c1 100644</span>
<span class="p_header">--- a/drivers/mtd/spi-nor/spi-nor.c</span>
<span class="p_header">+++ b/drivers/mtd/spi-nor/spi-nor.c</span>
<span class="p_chunk">@@ -1100,45 +1100,6 @@</span> <span class="p_context"> static int spansion_quad_enable(struct spi_nor *nor)</span>
 	return 0;
 }
 
<span class="p_del">-static int micron_quad_enable(struct spi_nor *nor)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	u8 val;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = nor-&gt;read_reg(nor, SPINOR_OP_RD_EVCR, &amp;val, 1);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(nor-&gt;dev, &quot;error %d reading EVCR\n&quot;, ret);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	write_enable(nor);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* set EVCR, enable quad I/O */</span>
<span class="p_del">-	nor-&gt;cmd_buf[0] = val &amp; ~EVCR_QUAD_EN_MICRON;</span>
<span class="p_del">-	ret = nor-&gt;write_reg(nor, SPINOR_OP_WD_EVCR, nor-&gt;cmd_buf, 1);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(nor-&gt;dev, &quot;error while writing EVCR register\n&quot;);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = spi_nor_wait_till_ready(nor);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* read EVCR and check it */</span>
<span class="p_del">-	ret = nor-&gt;read_reg(nor, SPINOR_OP_RD_EVCR, &amp;val, 1);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(nor-&gt;dev, &quot;error %d reading EVCR\n&quot;, ret);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (val &amp; EVCR_QUAD_EN_MICRON) {</span>
<span class="p_del">-		dev_err(nor-&gt;dev, &quot;Micron EVCR Quad bit not clear\n&quot;);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int set_quad_mode(struct spi_nor *nor, const struct flash_info *info)
 {
 	int status;
<span class="p_chunk">@@ -1152,12 +1113,7 @@</span> <span class="p_context"> static int set_quad_mode(struct spi_nor *nor, const struct flash_info *info)</span>
 		}
 		return status;
 	case SNOR_MFR_MICRON:
<span class="p_del">-		status = micron_quad_enable(nor);</span>
<span class="p_del">-		if (status) {</span>
<span class="p_del">-			dev_err(nor-&gt;dev, &quot;Micron quad-read not enabled\n&quot;);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		return status;</span>
<span class="p_add">+		return 0;</span>
 	default:
 		status = spansion_quad_enable(nor);
 		if (status) {
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index d70a1716f3e0..1486f33a743e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -1143,6 +1143,8 @@</span> <span class="p_context"> void __iwl_mvm_mac_stop(struct iwl_mvm *mvm)</span>
 	/* the fw is stopped, the aux sta is dead: clean up driver state */
 	iwl_mvm_del_aux_sta(mvm);
 
<span class="p_add">+	iwl_free_fw_paging(mvm);</span>
<span class="p_add">+</span>
 	/*
 	 * Clear IN_HW_RESTART flag when stopping the hw (as restart_complete()
 	 * won&#39;t be called in this case).
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/ops.c b/drivers/net/wireless/intel/iwlwifi/mvm/ops.c</span>
<span class="p_header">index e80be9a59520..89ea70deeb84 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/ops.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/ops.c</span>
<span class="p_chunk">@@ -684,8 +684,6 @@</span> <span class="p_context"> static void iwl_op_mode_mvm_stop(struct iwl_op_mode *op_mode)</span>
 	for (i = 0; i &lt; NVM_MAX_NUM_SECTIONS; i++)
 		kfree(mvm-&gt;nvm_sections[i].data);
 
<span class="p_del">-	iwl_free_fw_paging(mvm);</span>
<span class="p_del">-</span>
 	iwl_mvm_tof_clean(mvm);
 
 	ieee80211_free_hw(mvm-&gt;hw);
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c</span>
<span class="p_header">index 5a854c609477..1198caac35c8 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c</span>
<span class="p_chunk">@@ -731,8 +731,8 @@</span> <span class="p_context"> static int iwl_pcie_rsa_race_bug_wa(struct iwl_trans *trans)</span>
 	 */
 	val = iwl_read_prph(trans, PREG_AUX_BUS_WPROT_0);
 	if (val &amp; (BIT(1) | BIT(17))) {
<span class="p_del">-		IWL_INFO(trans,</span>
<span class="p_del">-			 &quot;can&#39;t access the RSA semaphore it is write protected\n&quot;);</span>
<span class="p_add">+		IWL_DEBUG_INFO(trans,</span>
<span class="p_add">+			       &quot;can&#39;t access the RSA semaphore it is write protected\n&quot;);</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/sta_event.c b/drivers/net/wireless/marvell/mwifiex/sta_event.c</span>
<span class="p_header">index ff3ee9dfbbd5..23bae87d4d3d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/sta_event.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/sta_event.c</span>
<span class="p_chunk">@@ -607,11 +607,13 @@</span> <span class="p_context"> int mwifiex_process_sta_event(struct mwifiex_private *priv)</span>
 
 	case EVENT_PS_AWAKE:
 		mwifiex_dbg(adapter, EVENT, &quot;info: EVENT: AWAKE\n&quot;);
<span class="p_del">-		if (!adapter-&gt;pps_uapsd_mode &amp;&amp; priv-&gt;port_open &amp;&amp;</span>
<span class="p_add">+		if (!adapter-&gt;pps_uapsd_mode &amp;&amp;</span>
<span class="p_add">+		    (priv-&gt;port_open ||</span>
<span class="p_add">+		     (priv-&gt;bss_mode == NL80211_IFTYPE_ADHOC)) &amp;&amp;</span>
 		    priv-&gt;media_connected &amp;&amp; adapter-&gt;sleep_period.period) {
<span class="p_del">-				adapter-&gt;pps_uapsd_mode = true;</span>
<span class="p_del">-				mwifiex_dbg(adapter, EVENT,</span>
<span class="p_del">-					    &quot;event: PPS/UAPSD mode activated\n&quot;);</span>
<span class="p_add">+			adapter-&gt;pps_uapsd_mode = true;</span>
<span class="p_add">+			mwifiex_dbg(adapter, EVENT,</span>
<span class="p_add">+				    &quot;event: PPS/UAPSD mode activated\n&quot;);</span>
 		}
 		adapter-&gt;tx_lock_flag = false;
 		if (adapter-&gt;pps_uapsd_mode &amp;&amp; adapter-&gt;gen_null_pkt) {
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/wmm.c b/drivers/net/wireless/marvell/mwifiex/wmm.c</span>
<span class="p_header">index acccd6734e3b..499e5a741c62 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/wmm.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/wmm.c</span>
<span class="p_chunk">@@ -475,7 +475,8 @@</span> <span class="p_context"> mwifiex_wmm_lists_empty(struct mwifiex_adapter *adapter)</span>
 		priv = adapter-&gt;priv[i];
 		if (!priv)
 			continue;
<span class="p_del">-		if (!priv-&gt;port_open)</span>
<span class="p_add">+		if (!priv-&gt;port_open &amp;&amp;</span>
<span class="p_add">+		    (priv-&gt;bss_mode != NL80211_IFTYPE_ADHOC))</span>
 			continue;
 		if (adapter-&gt;if_ops.is_port_ready &amp;&amp;
 		    !adapter-&gt;if_ops.is_port_ready(priv))
<span class="p_chunk">@@ -1099,7 +1100,8 @@</span> <span class="p_context"> mwifiex_wmm_get_highest_priolist_ptr(struct mwifiex_adapter *adapter,</span>
 
 			priv_tmp = adapter-&gt;bss_prio_tbl[j].bss_prio_cur-&gt;priv;
 
<span class="p_del">-			if (!priv_tmp-&gt;port_open ||</span>
<span class="p_add">+			if (((priv_tmp-&gt;bss_mode != NL80211_IFTYPE_ADHOC) &amp;&amp;</span>
<span class="p_add">+			     !priv_tmp-&gt;port_open) ||</span>
 			    (atomic_read(&amp;priv_tmp-&gt;wmm.tx_pkts_queued) == 0))
 				continue;
 
<span class="p_header">diff --git a/drivers/ntb/hw/amd/ntb_hw_amd.c b/drivers/ntb/hw/amd/ntb_hw_amd.c</span>
<span class="p_header">index 588803ad6847..6ccba0d862df 100644</span>
<span class="p_header">--- a/drivers/ntb/hw/amd/ntb_hw_amd.c</span>
<span class="p_header">+++ b/drivers/ntb/hw/amd/ntb_hw_amd.c</span>
<span class="p_chunk">@@ -357,20 +357,6 @@</span> <span class="p_context"> static int amd_ntb_db_clear_mask(struct ntb_dev *ntb, u64 db_bits)</span>
 	return 0;
 }
 
<span class="p_del">-static int amd_ntb_peer_db_addr(struct ntb_dev *ntb,</span>
<span class="p_del">-				phys_addr_t *db_addr,</span>
<span class="p_del">-				resource_size_t *db_size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct amd_ntb_dev *ndev = ntb_ndev(ntb);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (db_addr)</span>
<span class="p_del">-		*db_addr = (phys_addr_t)(ndev-&gt;peer_mmio + AMD_DBREQ_OFFSET);</span>
<span class="p_del">-	if (db_size)</span>
<span class="p_del">-		*db_size = sizeof(u32);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int amd_ntb_peer_db_set(struct ntb_dev *ntb, u64 db_bits)
 {
 	struct amd_ntb_dev *ndev = ntb_ndev(ntb);
<span class="p_chunk">@@ -415,20 +401,6 @@</span> <span class="p_context"> static int amd_ntb_spad_write(struct ntb_dev *ntb,</span>
 	return 0;
 }
 
<span class="p_del">-static int amd_ntb_peer_spad_addr(struct ntb_dev *ntb, int idx,</span>
<span class="p_del">-				  phys_addr_t *spad_addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct amd_ntb_dev *ndev = ntb_ndev(ntb);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (idx &lt; 0 || idx &gt;= ndev-&gt;spad_count)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (spad_addr)</span>
<span class="p_del">-		*spad_addr = (phys_addr_t)(ndev-&gt;self_mmio + AMD_SPAD_OFFSET +</span>
<span class="p_del">-					   ndev-&gt;peer_spad + (idx &lt;&lt; 2));</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static u32 amd_ntb_peer_spad_read(struct ntb_dev *ntb, int idx)
 {
 	struct amd_ntb_dev *ndev = ntb_ndev(ntb);
<span class="p_chunk">@@ -472,12 +444,10 @@</span> <span class="p_context"> static const struct ntb_dev_ops amd_ntb_ops = {</span>
 	.db_clear		= amd_ntb_db_clear,
 	.db_set_mask		= amd_ntb_db_set_mask,
 	.db_clear_mask		= amd_ntb_db_clear_mask,
<span class="p_del">-	.peer_db_addr		= amd_ntb_peer_db_addr,</span>
 	.peer_db_set		= amd_ntb_peer_db_set,
 	.spad_count		= amd_ntb_spad_count,
 	.spad_read		= amd_ntb_spad_read,
 	.spad_write		= amd_ntb_spad_write,
<span class="p_del">-	.peer_spad_addr		= amd_ntb_peer_spad_addr,</span>
 	.peer_spad_read		= amd_ntb_peer_spad_read,
 	.peer_spad_write	= amd_ntb_peer_spad_write,
 };
<span class="p_header">diff --git a/drivers/ntb/test/ntb_perf.c b/drivers/ntb/test/ntb_perf.c</span>
<span class="p_header">index c8a37ba4b4f9..6bdc1e7b7503 100644</span>
<span class="p_header">--- a/drivers/ntb/test/ntb_perf.c</span>
<span class="p_header">+++ b/drivers/ntb/test/ntb_perf.c</span>
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"> static void perf_copy_callback(void *data)</span>
 	atomic_dec(&amp;pctx-&gt;dma_sync);
 }
 
<span class="p_del">-static ssize_t perf_copy(struct pthr_ctx *pctx, char *dst,</span>
<span class="p_add">+static ssize_t perf_copy(struct pthr_ctx *pctx, char __iomem *dst,</span>
 			 char *src, size_t size)
 {
 	struct perf_ctx *perf = pctx-&gt;perf;
<span class="p_chunk">@@ -189,7 +189,8 @@</span> <span class="p_context"> static ssize_t perf_copy(struct pthr_ctx *pctx, char *dst,</span>
 	dma_cookie_t cookie;
 	size_t src_off, dst_off;
 	struct perf_mw *mw = &amp;perf-&gt;mw;
<span class="p_del">-	u64 vbase, dst_vaddr;</span>
<span class="p_add">+	void __iomem *vbase;</span>
<span class="p_add">+	void __iomem *dst_vaddr;</span>
 	dma_addr_t dst_phys;
 	int retries = 0;
 
<span class="p_chunk">@@ -204,14 +205,14 @@</span> <span class="p_context"> static ssize_t perf_copy(struct pthr_ctx *pctx, char *dst,</span>
 	}
 
 	device = chan-&gt;device;
<span class="p_del">-	src_off = (size_t)src &amp; ~PAGE_MASK;</span>
<span class="p_del">-	dst_off = (size_t)dst &amp; ~PAGE_MASK;</span>
<span class="p_add">+	src_off = (uintptr_t)src &amp; ~PAGE_MASK;</span>
<span class="p_add">+	dst_off = (uintptr_t __force)dst &amp; ~PAGE_MASK;</span>
 
 	if (!is_dma_copy_aligned(device, src_off, dst_off, size))
 		return -ENODEV;
 
<span class="p_del">-	vbase = (u64)(u64 *)mw-&gt;vbase;</span>
<span class="p_del">-	dst_vaddr = (u64)(u64 *)dst;</span>
<span class="p_add">+	vbase = mw-&gt;vbase;</span>
<span class="p_add">+	dst_vaddr = dst;</span>
 	dst_phys = mw-&gt;phys_addr + (dst_vaddr - vbase);
 
 	unmap = dmaengine_get_unmap_data(device-&gt;dev, 1, GFP_NOWAIT);
<span class="p_chunk">@@ -261,13 +262,13 @@</span> <span class="p_context"> err_get_unmap:</span>
 	return 0;
 }
 
<span class="p_del">-static int perf_move_data(struct pthr_ctx *pctx, char *dst, char *src,</span>
<span class="p_add">+static int perf_move_data(struct pthr_ctx *pctx, char __iomem *dst, char *src,</span>
 			  u64 buf_size, u64 win_size, u64 total)
 {
 	int chunks, total_chunks, i;
 	int copied_chunks = 0;
 	u64 copied = 0, result;
<span class="p_del">-	char *tmp = dst;</span>
<span class="p_add">+	char __iomem *tmp = dst;</span>
 	u64 perf, diff_us;
 	ktime_t kstart, kstop, kdiff;
 
<span class="p_chunk">@@ -324,7 +325,7 @@</span> <span class="p_context"> static int ntb_perf_thread(void *data)</span>
 	struct perf_ctx *perf = pctx-&gt;perf;
 	struct pci_dev *pdev = perf-&gt;ntb-&gt;pdev;
 	struct perf_mw *mw = &amp;perf-&gt;mw;
<span class="p_del">-	char *dst;</span>
<span class="p_add">+	char __iomem *dst;</span>
 	u64 win_size, buf_size, total;
 	void *src;
 	int rc, node, i;
<span class="p_chunk">@@ -364,7 +365,7 @@</span> <span class="p_context"> static int ntb_perf_thread(void *data)</span>
 	if (buf_size &gt; MAX_TEST_SIZE)
 		buf_size = MAX_TEST_SIZE;
 
<span class="p_del">-	dst = (char *)mw-&gt;vbase;</span>
<span class="p_add">+	dst = (char __iomem *)mw-&gt;vbase;</span>
 
 	atomic_inc(&amp;perf-&gt;tsync);
 	while (atomic_read(&amp;perf-&gt;tsync) != perf-&gt;perf_threads)
<span class="p_header">diff --git a/drivers/pci/host/pci-imx6.c b/drivers/pci/host/pci-imx6.c</span>
<span class="p_header">index fe600964fa50..88ccfeaa49c7 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-imx6.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-imx6.c</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"></span>
 #define to_imx6_pcie(x)	container_of(x, struct imx6_pcie, pp)
 
 struct imx6_pcie {
<span class="p_del">-	struct gpio_desc	*reset_gpio;</span>
<span class="p_add">+	int			reset_gpio;</span>
 	struct clk		*pcie_bus;
 	struct clk		*pcie_phy;
 	struct clk		*pcie;
<span class="p_chunk">@@ -287,10 +287,10 @@</span> <span class="p_context"> static int imx6_pcie_deassert_core_reset(struct pcie_port *pp)</span>
 	usleep_range(200, 500);
 
 	/* Some boards don&#39;t have PCIe reset GPIO. */
<span class="p_del">-	if (imx6_pcie-&gt;reset_gpio) {</span>
<span class="p_del">-		gpiod_set_value_cansleep(imx6_pcie-&gt;reset_gpio, 0);</span>
<span class="p_add">+	if (gpio_is_valid(imx6_pcie-&gt;reset_gpio)) {</span>
<span class="p_add">+		gpio_set_value_cansleep(imx6_pcie-&gt;reset_gpio, 0);</span>
 		msleep(100);
<span class="p_del">-		gpiod_set_value_cansleep(imx6_pcie-&gt;reset_gpio, 1);</span>
<span class="p_add">+		gpio_set_value_cansleep(imx6_pcie-&gt;reset_gpio, 1);</span>
 	}
 	return 0;
 
<span class="p_chunk">@@ -561,6 +561,7 @@</span> <span class="p_context"> static int __init imx6_pcie_probe(struct platform_device *pdev)</span>
 {
 	struct imx6_pcie *imx6_pcie;
 	struct pcie_port *pp;
<span class="p_add">+	struct device_node *np = pdev-&gt;dev.of_node;</span>
 	struct resource *dbi_base;
 	int ret;
 
<span class="p_chunk">@@ -581,8 +582,15 @@</span> <span class="p_context"> static int __init imx6_pcie_probe(struct platform_device *pdev)</span>
 		return PTR_ERR(pp-&gt;dbi_base);
 
 	/* Fetch GPIOs */
<span class="p_del">-	imx6_pcie-&gt;reset_gpio = devm_gpiod_get_optional(&amp;pdev-&gt;dev, &quot;reset&quot;,</span>
<span class="p_del">-							GPIOD_OUT_LOW);</span>
<span class="p_add">+	imx6_pcie-&gt;reset_gpio = of_get_named_gpio(np, &quot;reset-gpio&quot;, 0);</span>
<span class="p_add">+	if (gpio_is_valid(imx6_pcie-&gt;reset_gpio)) {</span>
<span class="p_add">+		ret = devm_gpio_request_one(&amp;pdev-&gt;dev, imx6_pcie-&gt;reset_gpio,</span>
<span class="p_add">+					    GPIOF_OUT_INIT_LOW, &quot;PCIe reset&quot;);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev, &quot;unable to get reset gpio\n&quot;);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	/* Fetch clocks */
 	imx6_pcie-&gt;pcie_phy = devm_clk_get(&amp;pdev-&gt;dev, &quot;pcie_phy&quot;);
<span class="p_header">diff --git a/drivers/pinctrl/mediatek/pinctrl-mtk-common.c b/drivers/pinctrl/mediatek/pinctrl-mtk-common.c</span>
<span class="p_header">index e96e86d2e745..3878d23ca7a8 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mediatek/pinctrl-mtk-common.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mediatek/pinctrl-mtk-common.c</span>
<span class="p_chunk">@@ -949,7 +949,8 @@</span> <span class="p_context"> static int mtk_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,</span>
 	struct mtk_pinctrl *pctl = dev_get_drvdata(chip-&gt;parent);
 	int eint_num, virq, eint_offset;
 	unsigned int set_offset, bit, clr_bit, clr_offset, rst, i, unmask, dbnc;
<span class="p_del">-	static const unsigned int dbnc_arr[] = {0 , 1, 16, 32, 64, 128, 256};</span>
<span class="p_add">+	static const unsigned int debounce_time[] = {500, 1000, 16000, 32000, 64000,</span>
<span class="p_add">+						128000, 256000};</span>
 	const struct mtk_desc_pin *pin;
 	struct irq_data *d;
 
<span class="p_chunk">@@ -967,9 +968,9 @@</span> <span class="p_context"> static int mtk_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,</span>
 	if (!mtk_eint_can_en_debounce(pctl, eint_num))
 		return -ENOSYS;
 
<span class="p_del">-	dbnc = ARRAY_SIZE(dbnc_arr);</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(dbnc_arr); i++) {</span>
<span class="p_del">-		if (debounce &lt;= dbnc_arr[i]) {</span>
<span class="p_add">+	dbnc = ARRAY_SIZE(debounce_time);</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(debounce_time); i++) {</span>
<span class="p_add">+		if (debounce &lt;= debounce_time[i]) {</span>
 			dbnc = i;
 			break;
 		}
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-single.c b/drivers/pinctrl/pinctrl-single.c</span>
<span class="p_header">index d24e5f1d1525..bd2e657163b8 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-single.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-single.c</span>
<span class="p_chunk">@@ -1273,9 +1273,9 @@</span> <span class="p_context"> static int pcs_parse_bits_in_pinctrl_entry(struct pcs_device *pcs,</span>
 
 		/* Parse pins in each row from LSB */
 		while (mask) {
<span class="p_del">-			bit_pos = ffs(mask);</span>
<span class="p_add">+			bit_pos = __ffs(mask);</span>
 			pin_num_from_lsb = bit_pos / pcs-&gt;bits_per_pin;
<span class="p_del">-			mask_pos = ((pcs-&gt;fmask) &lt;&lt; (bit_pos - 1));</span>
<span class="p_add">+			mask_pos = ((pcs-&gt;fmask) &lt;&lt; bit_pos);</span>
 			val_pos = val &amp; mask_pos;
 			submask = mask &amp; mask_pos;
 
<span class="p_chunk">@@ -1844,7 +1844,7 @@</span> <span class="p_context"> static int pcs_probe(struct platform_device *pdev)</span>
 	ret = of_property_read_u32(np, &quot;pinctrl-single,function-mask&quot;,
 				   &amp;pcs-&gt;fmask);
 	if (!ret) {
<span class="p_del">-		pcs-&gt;fshift = ffs(pcs-&gt;fmask) - 1;</span>
<span class="p_add">+		pcs-&gt;fshift = __ffs(pcs-&gt;fmask);</span>
 		pcs-&gt;fmax = pcs-&gt;fmask &gt;&gt; pcs-&gt;fshift;
 	} else {
 		/* If mask property doesn&#39;t exist, function mux is invalid. */
<span class="p_header">diff --git a/drivers/platform/x86/toshiba_acpi.c b/drivers/platform/x86/toshiba_acpi.c</span>
<span class="p_header">index 73833079bac8..d6baea6a7544 100644</span>
<span class="p_header">--- a/drivers/platform/x86/toshiba_acpi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/toshiba_acpi.c</span>
<span class="p_chunk">@@ -133,7 +133,7 @@</span> <span class="p_context"> MODULE_LICENSE(&quot;GPL&quot;);</span>
 /* Field definitions */
 #define HCI_ACCEL_MASK			0x7fff
 #define HCI_HOTKEY_DISABLE		0x0b
<span class="p_del">-#define HCI_HOTKEY_ENABLE		0x01</span>
<span class="p_add">+#define HCI_HOTKEY_ENABLE		0x09</span>
 #define HCI_HOTKEY_SPECIAL_FUNCTIONS	0x10
 #define HCI_LCD_BRIGHTNESS_BITS		3
 #define HCI_LCD_BRIGHTNESS_SHIFT	(16-HCI_LCD_BRIGHTNESS_BITS)
<span class="p_header">diff --git a/drivers/pwm/pwm-brcmstb.c b/drivers/pwm/pwm-brcmstb.c</span>
<span class="p_header">index 423ce087cd9c..5d5adee16886 100644</span>
<span class="p_header">--- a/drivers/pwm/pwm-brcmstb.c</span>
<span class="p_header">+++ b/drivers/pwm/pwm-brcmstb.c</span>
<span class="p_chunk">@@ -274,8 +274,8 @@</span> <span class="p_context"> static int brcmstb_pwm_probe(struct platform_device *pdev)</span>
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	p-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);
<span class="p_del">-	if (!p-&gt;base) {</span>
<span class="p_del">-		ret = -ENOMEM;</span>
<span class="p_add">+	if (IS_ERR(p-&gt;base)) {</span>
<span class="p_add">+		ret = PTR_ERR(p-&gt;base);</span>
 		goto out_clk;
 	}
 
<span class="p_header">diff --git a/drivers/regulator/s5m8767.c b/drivers/regulator/s5m8767.c</span>
<span class="p_header">index 58f5d3b8e981..27343e1c43ef 100644</span>
<span class="p_header">--- a/drivers/regulator/s5m8767.c</span>
<span class="p_header">+++ b/drivers/regulator/s5m8767.c</span>
<span class="p_chunk">@@ -202,9 +202,10 @@</span> <span class="p_context"> static int s5m8767_get_register(struct s5m8767_info *s5m8767, int reg_id,</span>
 		}
 	}
 
<span class="p_del">-	if (i &lt; s5m8767-&gt;num_regulators)</span>
<span class="p_del">-		*enable_ctrl =</span>
<span class="p_del">-		s5m8767_opmode_reg[reg_id][mode] &lt;&lt; S5M8767_ENCTRL_SHIFT;</span>
<span class="p_add">+	if (i &gt;= s5m8767-&gt;num_regulators)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	*enable_ctrl = s5m8767_opmode_reg[reg_id][mode] &lt;&lt; S5M8767_ENCTRL_SHIFT;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -937,8 +938,12 @@</span> <span class="p_context"> static int s5m8767_pmic_probe(struct platform_device *pdev)</span>
 			else
 				regulators[id].vsel_mask = 0xff;
 
<span class="p_del">-			s5m8767_get_register(s5m8767, id, &amp;enable_reg,</span>
<span class="p_add">+			ret = s5m8767_get_register(s5m8767, id, &amp;enable_reg,</span>
 					     &amp;enable_val);
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				dev_err(s5m8767-&gt;dev, &quot;error reading registers\n&quot;);</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+			}</span>
 			regulators[id].enable_reg = enable_reg;
 			regulators[id].enable_mask = S5M8767_ENCTRL_MASK;
 			regulators[id].enable_val = enable_val;
<span class="p_header">diff --git a/drivers/rtc/rtc-ds1685.c b/drivers/rtc/rtc-ds1685.c</span>
<span class="p_header">index 535050fc5e9f..08e0ff8c786a 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-ds1685.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-ds1685.c</span>
<span class="p_chunk">@@ -187,9 +187,9 @@</span> <span class="p_context"> ds1685_rtc_end_data_access(struct ds1685_priv *rtc)</span>
  * Only use this where you are certain another lock will not be held.
  */
 static inline void
<span class="p_del">-ds1685_rtc_begin_ctrl_access(struct ds1685_priv *rtc, unsigned long flags)</span>
<span class="p_add">+ds1685_rtc_begin_ctrl_access(struct ds1685_priv *rtc, unsigned long *flags)</span>
 {
<span class="p_del">-	spin_lock_irqsave(&amp;rtc-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;rtc-&gt;lock, *flags);</span>
 	ds1685_rtc_switch_to_bank1(rtc);
 }
 
<span class="p_chunk">@@ -1300,7 +1300,7 @@</span> <span class="p_context"> ds1685_rtc_sysfs_ctrl_regs_store(struct device *dev,</span>
 {
 	struct ds1685_priv *rtc = dev_get_drvdata(dev);
 	u8 reg = 0, bit = 0, tmp;
<span class="p_del">-	unsigned long flags = 0;</span>
<span class="p_add">+	unsigned long flags;</span>
 	long int val = 0;
 	const struct ds1685_rtc_ctrl_regs *reg_info =
 		ds1685_rtc_sysfs_ctrl_regs_lookup(attr-&gt;attr.name);
<span class="p_chunk">@@ -1321,7 +1321,7 @@</span> <span class="p_context"> ds1685_rtc_sysfs_ctrl_regs_store(struct device *dev,</span>
 	bit = reg_info-&gt;bit;
 
 	/* Safe to spinlock during a write. */
<span class="p_del">-	ds1685_rtc_begin_ctrl_access(rtc, flags);</span>
<span class="p_add">+	ds1685_rtc_begin_ctrl_access(rtc, &amp;flags);</span>
 	tmp = rtc-&gt;read(rtc, reg);
 	rtc-&gt;write(rtc, reg, (val ? (tmp | bit) : (tmp &amp; ~(bit))));
 	ds1685_rtc_end_ctrl_access(rtc, flags);
<span class="p_header">diff --git a/drivers/rtc/rtc-hym8563.c b/drivers/rtc/rtc-hym8563.c</span>
<span class="p_header">index 097325d96db5..b1b4746a0eab 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-hym8563.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-hym8563.c</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static int hym8563_rtc_set_time(struct device *dev, struct rtc_time *tm)</span>
 	 * it does not seem to carry it over a subsequent write/read.
 	 * So we&#39;ll limit ourself to 100 years, starting at 2000 for now.
 	 */
<span class="p_del">-	buf[6] = tm-&gt;tm_year - 100;</span>
<span class="p_add">+	buf[6] = bin2bcd(tm-&gt;tm_year - 100);</span>
 
 	/*
 	 * CTL1 only contains TEST-mode bits apart from stop,
<span class="p_header">diff --git a/drivers/rtc/rtc-max77686.c b/drivers/rtc/rtc-max77686.c</span>
<span class="p_header">index 7184a0eda793..725dccae24e7 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-max77686.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-max77686.c</span>
<span class="p_chunk">@@ -465,7 +465,7 @@</span> <span class="p_context"> static int max77686_rtc_probe(struct platform_device *pdev)</span>
 
 	info-&gt;virq = regmap_irq_get_virq(max77686-&gt;rtc_irq_data,
 					 MAX77686_RTCIRQ_RTCA1);
<span class="p_del">-	if (!info-&gt;virq) {</span>
<span class="p_add">+	if (info-&gt;virq &lt;= 0) {</span>
 		ret = -ENXIO;
 		goto err_rtc;
 	}
<span class="p_header">diff --git a/drivers/rtc/rtc-rx8025.c b/drivers/rtc/rtc-rx8025.c</span>
<span class="p_header">index bd911bafb809..17341feadad1 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-rx8025.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-rx8025.c</span>
<span class="p_chunk">@@ -65,7 +65,6 @@</span> <span class="p_context"></span>
 
 static const struct i2c_device_id rx8025_id[] = {
 	{ &quot;rx8025&quot;, 0 },
<span class="p_del">-	{ &quot;rv8803&quot;, 1 },</span>
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, rx8025_id);
<span class="p_header">diff --git a/drivers/rtc/rtc-vr41xx.c b/drivers/rtc/rtc-vr41xx.c</span>
<span class="p_header">index f64c282275b3..e1b86bb01062 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-vr41xx.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-vr41xx.c</span>
<span class="p_chunk">@@ -272,12 +272,13 @@</span> <span class="p_context"> static irqreturn_t rtclong1_interrupt(int irq, void *dev_id)</span>
 }
 
 static const struct rtc_class_ops vr41xx_rtc_ops = {
<span class="p_del">-	.release	= vr41xx_rtc_release,</span>
<span class="p_del">-	.ioctl		= vr41xx_rtc_ioctl,</span>
<span class="p_del">-	.read_time	= vr41xx_rtc_read_time,</span>
<span class="p_del">-	.set_time	= vr41xx_rtc_set_time,</span>
<span class="p_del">-	.read_alarm	= vr41xx_rtc_read_alarm,</span>
<span class="p_del">-	.set_alarm	= vr41xx_rtc_set_alarm,</span>
<span class="p_add">+	.release		= vr41xx_rtc_release,</span>
<span class="p_add">+	.ioctl			= vr41xx_rtc_ioctl,</span>
<span class="p_add">+	.read_time		= vr41xx_rtc_read_time,</span>
<span class="p_add">+	.set_time		= vr41xx_rtc_set_time,</span>
<span class="p_add">+	.read_alarm		= vr41xx_rtc_read_alarm,</span>
<span class="p_add">+	.set_alarm		= vr41xx_rtc_set_alarm,</span>
<span class="p_add">+	.alarm_irq_enable	= vr41xx_rtc_alarm_irq_enable,</span>
 };
 
 static int rtc_probe(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/scsi/device_handler/Kconfig b/drivers/scsi/device_handler/Kconfig</span>
<span class="p_header">index e5647d59224f..0b331c9c0a8f 100644</span>
<span class="p_header">--- a/drivers/scsi/device_handler/Kconfig</span>
<span class="p_header">+++ b/drivers/scsi/device_handler/Kconfig</span>
<span class="p_chunk">@@ -13,13 +13,13 @@</span> <span class="p_context"> menuconfig SCSI_DH</span>
 
 config SCSI_DH_RDAC
 	tristate &quot;LSI RDAC Device Handler&quot;
<span class="p_del">-	depends on SCSI_DH</span>
<span class="p_add">+	depends on SCSI_DH &amp;&amp; SCSI</span>
 	help
 	If you have a LSI RDAC select y. Otherwise, say N.
 
 config SCSI_DH_HP_SW
 	tristate &quot;HP/COMPAQ MSA Device Handler&quot;
<span class="p_del">-	depends on SCSI_DH</span>
<span class="p_add">+	depends on SCSI_DH &amp;&amp; SCSI</span>
 	help
 	If you have a HP/COMPAQ MSA device that requires START_STOP to
 	be sent to start it and cannot upgrade the firmware then select y.
<span class="p_chunk">@@ -27,13 +27,13 @@</span> <span class="p_context"> config SCSI_DH_HP_SW</span>
 
 config SCSI_DH_EMC
 	tristate &quot;EMC CLARiiON Device Handler&quot;
<span class="p_del">-	depends on SCSI_DH</span>
<span class="p_add">+	depends on SCSI_DH &amp;&amp; SCSI</span>
 	help
 	If you have a EMC CLARiiON select y. Otherwise, say N.
 
 config SCSI_DH_ALUA
 	tristate &quot;SPC-3 ALUA Device Handler&quot;
<span class="p_del">-	depends on SCSI_DH</span>
<span class="p_add">+	depends on SCSI_DH &amp;&amp; SCSI</span>
 	help
 	  SCSI Device handler for generic SPC-3 Asymmetric Logical Unit
 	  Access (ALUA).
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 97a1c1c33b05..00ce3e269a43 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -6282,12 +6282,13 @@</span> <span class="p_context"> out:</span>
 	}
 
 	for (i = 0; i &lt; ioc-&gt;sge_count; i++) {
<span class="p_del">-		if (kbuff_arr[i])</span>
<span class="p_add">+		if (kbuff_arr[i]) {</span>
 			dma_free_coherent(&amp;instance-&gt;pdev-&gt;dev,
 					  le32_to_cpu(kern_sge32[i].length),
 					  kbuff_arr[i],
 					  le32_to_cpu(kern_sge32[i].phys_addr));
 			kbuff_arr[i] = NULL;
<span class="p_add">+		}</span>
 	}
 
 	megasas_return_cmd(instance, cmd);
<span class="p_header">diff --git a/drivers/spi/spi-rockchip.c b/drivers/spi/spi-rockchip.c</span>
<span class="p_header">index 7cb1b2d710c1..475fb44c1883 100644</span>
<span class="p_header">--- a/drivers/spi/spi-rockchip.c</span>
<span class="p_header">+++ b/drivers/spi/spi-rockchip.c</span>
<span class="p_chunk">@@ -265,7 +265,10 @@</span> <span class="p_context"> static inline u32 rx_max(struct rockchip_spi *rs)</span>
 static void rockchip_spi_set_cs(struct spi_device *spi, bool enable)
 {
 	u32 ser;
<span class="p_del">-	struct rockchip_spi *rs = spi_master_get_devdata(spi-&gt;master);</span>
<span class="p_add">+	struct spi_master *master = spi-&gt;master;</span>
<span class="p_add">+	struct rockchip_spi *rs = spi_master_get_devdata(master);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_runtime_get_sync(rs-&gt;dev);</span>
 
 	ser = readl_relaxed(rs-&gt;regs + ROCKCHIP_SPI_SER) &amp; SER_MASK;
 
<span class="p_chunk">@@ -290,6 +293,8 @@</span> <span class="p_context"> static void rockchip_spi_set_cs(struct spi_device *spi, bool enable)</span>
 		ser &amp;= ~(1 &lt;&lt; spi-&gt;chip_select);
 
 	writel_relaxed(ser, rs-&gt;regs + ROCKCHIP_SPI_SER);
<span class="p_add">+</span>
<span class="p_add">+	pm_runtime_put_sync(rs-&gt;dev);</span>
 }
 
 static int rockchip_spi_prepare_message(struct spi_master *master,
<span class="p_header">diff --git a/drivers/staging/rdma/hfi1/TODO b/drivers/staging/rdma/hfi1/TODO</span>
<span class="p_header">index 05de0dad8762..4c6f1d7d2eaf 100644</span>
<span class="p_header">--- a/drivers/staging/rdma/hfi1/TODO</span>
<span class="p_header">+++ b/drivers/staging/rdma/hfi1/TODO</span>
<span class="p_chunk">@@ -3,4 +3,4 @@</span> <span class="p_context"> July, 2015</span>
 - Remove unneeded file entries in sysfs
 - Remove software processing of IB protocol and place in library for use
   by qib, ipath (if still present), hfi1, and eventually soft-roce
<span class="p_del">-</span>
<span class="p_add">+- Replace incorrect uAPI</span>
<span class="p_header">diff --git a/drivers/staging/rdma/hfi1/file_ops.c b/drivers/staging/rdma/hfi1/file_ops.c</span>
<span class="p_header">index d57d549052c8..29ae777556d2 100644</span>
<span class="p_header">--- a/drivers/staging/rdma/hfi1/file_ops.c</span>
<span class="p_header">+++ b/drivers/staging/rdma/hfi1/file_ops.c</span>
<span class="p_chunk">@@ -52,6 +52,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/io.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;hfi.h&quot;
 #include &quot;pio.h&quot;
 #include &quot;device.h&quot;
<span class="p_chunk">@@ -194,6 +196,10 @@</span> <span class="p_context"> static ssize_t hfi1_file_write(struct file *fp, const char __user *data,</span>
 	int uctxt_required = 1;
 	int must_be_root = 0;
 
<span class="p_add">+	/* FIXME: This interface cannot continue out of staging */</span>
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (count &lt; sizeof(cmd)) {
 		ret = -EINVAL;
 		goto bail;
<span class="p_header">diff --git a/drivers/thermal/rockchip_thermal.c b/drivers/thermal/rockchip_thermal.c</span>
<span class="p_header">index b58e3fb9b311..433085a97626 100644</span>
<span class="p_header">--- a/drivers/thermal/rockchip_thermal.c</span>
<span class="p_header">+++ b/drivers/thermal/rockchip_thermal.c</span>
<span class="p_chunk">@@ -693,15 +693,14 @@</span> <span class="p_context"> static int rockchip_configure_from_dt(struct device *dev,</span>
 			 thermal-&gt;chip-&gt;tshut_temp);
 		thermal-&gt;tshut_temp = thermal-&gt;chip-&gt;tshut_temp;
 	} else {
<span class="p_add">+		if (shut_temp &gt; INT_MAX) {</span>
<span class="p_add">+			dev_err(dev, &quot;Invalid tshut temperature specified: %d\n&quot;,</span>
<span class="p_add">+				shut_temp);</span>
<span class="p_add">+			return -ERANGE;</span>
<span class="p_add">+		}</span>
 		thermal-&gt;tshut_temp = shut_temp;
 	}
 
<span class="p_del">-	if (thermal-&gt;tshut_temp &gt; INT_MAX) {</span>
<span class="p_del">-		dev_err(dev, &quot;Invalid tshut temperature specified: %d\n&quot;,</span>
<span class="p_del">-			thermal-&gt;tshut_temp);</span>
<span class="p_del">-		return -ERANGE;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (of_property_read_u32(np, &quot;rockchip,hw-tshut-mode&quot;, &amp;tshut_mode)) {
 		dev_warn(dev,
 			 &quot;Missing tshut mode property, using default (%s)\n&quot;,
<span class="p_header">diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">index 9eb1cff28bd4..b8b580e5ae6e 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd-pci.c</span>
<span class="p_chunk">@@ -74,6 +74,15 @@</span> <span class="p_context"> static void for_each_companion(struct pci_dev *pdev, struct usb_hcd *hcd,</span>
 		if (companion-&gt;bus != pdev-&gt;bus ||
 				PCI_SLOT(companion-&gt;devfn) != slot)
 			continue;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Companion device should be either UHCI,OHCI or EHCI host</span>
<span class="p_add">+		 * controller, otherwise skip.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (companion-&gt;class != CL_UHCI &amp;&amp; companion-&gt;class != CL_OHCI &amp;&amp;</span>
<span class="p_add">+				companion-&gt;class != CL_EHCI)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		companion_hcd = pci_get_drvdata(companion);
 		if (!companion_hcd || !companion_hcd-&gt;self.root_hub)
 			continue;
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index cf43e9e18368..79d895c2dd71 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -646,6 +646,7 @@</span> <span class="p_context"> static void ffs_user_copy_worker(struct work_struct *work)</span>
 						   work);
 	int ret = io_data-&gt;req-&gt;status ? io_data-&gt;req-&gt;status :
 					 io_data-&gt;req-&gt;actual;
<span class="p_add">+	bool kiocb_has_eventfd = io_data-&gt;kiocb-&gt;ki_flags &amp; IOCB_EVENTFD;</span>
 
 	if (io_data-&gt;read &amp;&amp; ret &gt; 0) {
 		use_mm(io_data-&gt;mm);
<span class="p_chunk">@@ -657,13 +658,11 @@</span> <span class="p_context"> static void ffs_user_copy_worker(struct work_struct *work)</span>
 
 	io_data-&gt;kiocb-&gt;ki_complete(io_data-&gt;kiocb, ret, ret);
 
<span class="p_del">-	if (io_data-&gt;ffs-&gt;ffs_eventfd &amp;&amp;</span>
<span class="p_del">-	    !(io_data-&gt;kiocb-&gt;ki_flags &amp; IOCB_EVENTFD))</span>
<span class="p_add">+	if (io_data-&gt;ffs-&gt;ffs_eventfd &amp;&amp; !kiocb_has_eventfd)</span>
 		eventfd_signal(io_data-&gt;ffs-&gt;ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data-&gt;ep, io_data-&gt;req);
 
<span class="p_del">-	io_data-&gt;kiocb-&gt;private = NULL;</span>
 	if (io_data-&gt;read)
 		kfree(io_data-&gt;to_free);
 	kfree(io_data-&gt;buf);
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 5cd080e0a685..743d9a20e248 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1873,6 +1873,12 @@</span> <span class="p_context"> no_bw:</span>
 	kfree(xhci-&gt;rh_bw);
 	kfree(xhci-&gt;ext_caps);
 
<span class="p_add">+	xhci-&gt;usb2_ports = NULL;</span>
<span class="p_add">+	xhci-&gt;usb3_ports = NULL;</span>
<span class="p_add">+	xhci-&gt;port_array = NULL;</span>
<span class="p_add">+	xhci-&gt;rh_bw = NULL;</span>
<span class="p_add">+	xhci-&gt;ext_caps = NULL;</span>
<span class="p_add">+</span>
 	xhci-&gt;page_size = 0;
 	xhci-&gt;page_shift = 0;
 	xhci-&gt;bus_state[0].bus_suspended = 0;
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index f0640b7a1c42..48672fac7ff3 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -48,6 +48,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
 #define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI		0x1aa8</span>
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
<span class="p_chunk">@@ -155,7 +156,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
<span class="p_del">-		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI)) {</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI)) {</span>
 		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
<span class="p_chunk">@@ -302,6 +304,7 @@</span> <span class="p_context"> static void xhci_pci_remove(struct pci_dev *dev)</span>
 	struct xhci_hcd *xhci;
 
 	xhci = hcd_to_xhci(pci_get_drvdata(dev));
<span class="p_add">+	xhci-&gt;xhc_state |= XHCI_STATE_REMOVING;</span>
 	if (xhci-&gt;shared_hcd) {
 		usb_remove_hcd(xhci-&gt;shared_hcd);
 		usb_put_hcd(xhci-&gt;shared_hcd);
<span class="p_header">diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">index d39d6bf1d090..d4962208be30 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-plat.c</span>
<span class="p_chunk">@@ -39,12 +39,25 @@</span> <span class="p_context"> static const struct xhci_driver_overrides xhci_plat_overrides __initconst = {</span>
 
 static void xhci_plat_quirks(struct device *dev, struct xhci_hcd *xhci)
 {
<span class="p_add">+	struct usb_hcd *hcd = xhci_to_hcd(xhci);</span>
<span class="p_add">+</span>
 	/*
 	 * As of now platform drivers don&#39;t provide MSI support so we ensure
 	 * here that the generic code does not try to make a pci_dev from our
 	 * dev struct in order to setup MSI
 	 */
 	xhci-&gt;quirks |= XHCI_PLAT;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On R-Car Gen2 and Gen3, the AC64 bit (bit 0) of HCCPARAMS1 is set</span>
<span class="p_add">+	 * to 1. However, these SoCs don&#39;t support 64-bit address memory</span>
<span class="p_add">+	 * pointers. So, this driver clears the AC64 bit of xhci-&gt;hcc_params</span>
<span class="p_add">+	 * to call dma_set_coherent_mask(dev, DMA_BIT_MASK(32)) in</span>
<span class="p_add">+	 * xhci_gen_setup().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (xhci_plat_type_is(hcd, XHCI_PLAT_TYPE_RENESAS_RCAR_GEN2) ||</span>
<span class="p_add">+	    xhci_plat_type_is(hcd, XHCI_PLAT_TYPE_RENESAS_RCAR_GEN3))</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_NO_64BIT_SUPPORT;</span>
 }
 
 /* called during probe() after chip reset completes */
<span class="p_header">diff --git a/drivers/usb/host/xhci-plat.h b/drivers/usb/host/xhci-plat.h</span>
<span class="p_header">index 5a2e2e3936c4..529c3c40f901 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-plat.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-plat.h</span>
<span class="p_chunk">@@ -14,7 +14,7 @@</span> <span class="p_context"></span>
 #include &quot;xhci.h&quot;	/* for hcd_to_xhci() */
 
 enum xhci_plat_type {
<span class="p_del">-	XHCI_PLAT_TYPE_MARVELL_ARMADA,</span>
<span class="p_add">+	XHCI_PLAT_TYPE_MARVELL_ARMADA = 1,</span>
 	XHCI_PLAT_TYPE_RENESAS_RCAR_GEN2,
 	XHCI_PLAT_TYPE_RENESAS_RCAR_GEN3,
 };
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 3915657e6078..a85a1c993d61 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -4014,7 +4014,8 @@</span> <span class="p_context"> static int queue_command(struct xhci_hcd *xhci, struct xhci_command *cmd,</span>
 	int reserved_trbs = xhci-&gt;cmd_ring_reserved_trbs;
 	int ret;
 
<span class="p_del">-	if (xhci-&gt;xhc_state) {</span>
<span class="p_add">+	if ((xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) ||</span>
<span class="p_add">+		(xhci-&gt;xhc_state &amp; XHCI_STATE_HALTED)) {</span>
 		xhci_dbg(xhci, &quot;xHCI dying or halted, can&#39;t queue_command\n&quot;);
 		return -ESHUTDOWN;
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 0c8087d3c313..8e713cca58ed 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -147,7 +147,8 @@</span> <span class="p_context"> static int xhci_start(struct xhci_hcd *xhci)</span>
 				&quot;waited %u microseconds.\n&quot;,
 				XHCI_MAX_HALT_USEC);
 	if (!ret)
<span class="p_del">-		xhci-&gt;xhc_state &amp;= ~(XHCI_STATE_HALTED | XHCI_STATE_DYING);</span>
<span class="p_add">+		/* clear state flags. Including dying, halted or removing */</span>
<span class="p_add">+		xhci-&gt;xhc_state = 0;</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1108,8 +1109,8 @@</span> <span class="p_context"> int xhci_resume(struct xhci_hcd *xhci, bool hibernated)</span>
 		/* Resume root hubs only when have pending events. */
 		status = readl(&amp;xhci-&gt;op_regs-&gt;status);
 		if (status &amp; STS_EINT) {
<span class="p_del">-			usb_hcd_resume_root_hub(hcd);</span>
 			usb_hcd_resume_root_hub(xhci-&gt;shared_hcd);
<span class="p_add">+			usb_hcd_resume_root_hub(hcd);</span>
 		}
 	}
 
<span class="p_chunk">@@ -1124,10 +1125,10 @@</span> <span class="p_context"> int xhci_resume(struct xhci_hcd *xhci, bool hibernated)</span>
 
 	/* Re-enable port polling. */
 	xhci_dbg(xhci, &quot;%s: starting port polling.\n&quot;, __func__);
<span class="p_del">-	set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);</span>
<span class="p_del">-	usb_hcd_poll_rh_status(hcd);</span>
 	set_bit(HCD_FLAG_POLL_RH, &amp;xhci-&gt;shared_hcd-&gt;flags);
 	usb_hcd_poll_rh_status(xhci-&gt;shared_hcd);
<span class="p_add">+	set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);</span>
<span class="p_add">+	usb_hcd_poll_rh_status(hcd);</span>
 
 	return retval;
 }
<span class="p_chunk">@@ -2770,7 +2771,8 @@</span> <span class="p_context"> int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev)</span>
 	if (ret &lt;= 0)
 		return ret;
 	xhci = hcd_to_xhci(hcd);
<span class="p_del">-	if (xhci-&gt;xhc_state &amp; XHCI_STATE_DYING)</span>
<span class="p_add">+	if ((xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) ||</span>
<span class="p_add">+		(xhci-&gt;xhc_state &amp; XHCI_STATE_REMOVING))</span>
 		return -ENODEV;
 
 	xhci_dbg(xhci, &quot;%s called for udev %p\n&quot;, __func__, udev);
<span class="p_chunk">@@ -3817,7 +3819,7 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 
 	mutex_lock(&amp;xhci-&gt;mutex);
 
<span class="p_del">-	if (xhci-&gt;xhc_state)	/* dying or halted */</span>
<span class="p_add">+	if (xhci-&gt;xhc_state)	/* dying, removing or halted */</span>
 		goto out;
 
 	if (!udev-&gt;slot_id) {
<span class="p_chunk">@@ -4944,6 +4946,16 @@</span> <span class="p_context"> int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)</span>
 		return retval;
 	xhci_dbg(xhci, &quot;Reset complete\n&quot;);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On some xHCI controllers (e.g. R-Car SoCs), the AC64 bit (bit 0)</span>
<span class="p_add">+	 * of HCCPARAMS1 is set to 1. However, the xHCs don&#39;t support 64-bit</span>
<span class="p_add">+	 * address memory pointers actually. So, this driver clears the AC64</span>
<span class="p_add">+	 * bit of xhci-&gt;hcc_params to call dma_set_coherent_mask(dev,</span>
<span class="p_add">+	 * DMA_BIT_MASK(32)) in this xhci_gen_setup().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_NO_64BIT_SUPPORT)</span>
<span class="p_add">+		xhci-&gt;hcc_params &amp;= ~BIT(0);</span>
<span class="p_add">+</span>
 	/* Set dma_mask and coherent_dma_mask to 64-bits,
 	 * if xHC supports 64-bit addressing */
 	if (HCC_64BIT_ADDR(xhci-&gt;hcc_params) &amp;&amp;
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index cc651383ce5a..1cdea4a8c895 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1596,6 +1596,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
  */
 #define XHCI_STATE_DYING	(1 &lt;&lt; 0)
 #define XHCI_STATE_HALTED	(1 &lt;&lt; 1)
<span class="p_add">+#define XHCI_STATE_REMOVING	(1 &lt;&lt; 2)</span>
 	/* Statistics */
 	int			error_bitmask;
 	unsigned int		quirks;
<span class="p_chunk">@@ -1632,6 +1633,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 #define XHCI_PME_STUCK_QUIRK	(1 &lt;&lt; 20)
 #define XHCI_MTK_HOST		(1 &lt;&lt; 21)
 #define XHCI_SSIC_PORT_UNUSED	(1 &lt;&lt; 22)
<span class="p_add">+#define XHCI_NO_64BIT_SUPPORT	(1 &lt;&lt; 23)</span>
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
<span class="p_header">diff --git a/drivers/usb/usbip/usbip_common.c b/drivers/usb/usbip/usbip_common.c</span>
<span class="p_header">index facaaf003f19..e40da7759a0e 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/usbip_common.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/usbip_common.c</span>
<span class="p_chunk">@@ -741,6 +741,17 @@</span> <span class="p_context"> int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)</span>
 	if (!(size &gt; 0))
 		return 0;
 
<span class="p_add">+	if (size &gt; urb-&gt;transfer_buffer_length) {</span>
<span class="p_add">+		/* should not happen, probably malicious packet */</span>
<span class="p_add">+		if (ud-&gt;side == USBIP_STUB) {</span>
<span class="p_add">+			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);</span>
<span class="p_add">+			return -EPIPE;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = usbip_recv(ud-&gt;tcp_socket, urb-&gt;transfer_buffer, size);
 	if (ret != size) {
 		dev_err(&amp;urb-&gt;dev-&gt;dev, &quot;recv xbuf, %d\n&quot;, ret);
<span class="p_header">diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig</span>
<span class="p_header">index 8ea45a5cd806..d889ef2048df 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/Kconfig</span>
<span class="p_header">+++ b/drivers/video/fbdev/Kconfig</span>
<span class="p_chunk">@@ -2246,7 +2246,6 @@</span> <span class="p_context"> config XEN_FBDEV_FRONTEND</span>
 	select FB_SYS_IMAGEBLIT
 	select FB_SYS_FOPS
 	select FB_DEFERRED_IO
<span class="p_del">-	select INPUT_XEN_KBDDEV_FRONTEND if INPUT_MISC</span>
 	select XEN_XENBUS_FRONTEND
 	default y
 	help
<span class="p_header">diff --git a/drivers/video/fbdev/amba-clcd.c b/drivers/video/fbdev/amba-clcd.c</span>
<span class="p_header">index 9362424c2340..f9ef06d0cd48 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/amba-clcd.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/amba-clcd.c</span>
<span class="p_chunk">@@ -440,13 +440,14 @@</span> <span class="p_context"> static int clcdfb_register(struct clcd_fb *fb)</span>
 		fb-&gt;off_ienb = CLCD_PL111_IENB;
 		fb-&gt;off_cntl = CLCD_PL111_CNTL;
 	} else {
<span class="p_del">-#ifdef CONFIG_ARCH_VERSATILE</span>
<span class="p_del">-		fb-&gt;off_ienb = CLCD_PL111_IENB;</span>
<span class="p_del">-		fb-&gt;off_cntl = CLCD_PL111_CNTL;</span>
<span class="p_del">-#else</span>
<span class="p_del">-		fb-&gt;off_ienb = CLCD_PL110_IENB;</span>
<span class="p_del">-		fb-&gt;off_cntl = CLCD_PL110_CNTL;</span>
<span class="p_del">-#endif</span>
<span class="p_add">+		if (of_machine_is_compatible(&quot;arm,versatile-ab&quot;) ||</span>
<span class="p_add">+		    of_machine_is_compatible(&quot;arm,versatile-pb&quot;)) {</span>
<span class="p_add">+			fb-&gt;off_ienb = CLCD_PL111_IENB;</span>
<span class="p_add">+			fb-&gt;off_cntl = CLCD_PL111_CNTL;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			fb-&gt;off_ienb = CLCD_PL110_IENB;</span>
<span class="p_add">+			fb-&gt;off_cntl = CLCD_PL110_CNTL;</span>
<span class="p_add">+		}</span>
 	}
 
 	fb-&gt;clk = clk_get(&amp;fb-&gt;dev-&gt;dev, NULL);
<span class="p_header">diff --git a/drivers/video/fbdev/da8xx-fb.c b/drivers/video/fbdev/da8xx-fb.c</span>
<span class="p_header">index 6b2a06d09f2b..d8d583d32a37 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/da8xx-fb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/da8xx-fb.c</span>
<span class="p_chunk">@@ -209,8 +209,7 @@</span> <span class="p_context"> static struct fb_videomode known_lcd_panels[] = {</span>
 		.lower_margin   = 2,
 		.hsync_len      = 0,
 		.vsync_len      = 0,
<span class="p_del">-		.sync           = FB_SYNC_CLK_INVERT |</span>
<span class="p_del">-			FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,</span>
<span class="p_add">+		.sync           = FB_SYNC_CLK_INVERT,</span>
 	},
 	/* Sharp LK043T1DG01 */
 	[1] = {
<span class="p_chunk">@@ -224,7 +223,7 @@</span> <span class="p_context"> static struct fb_videomode known_lcd_panels[] = {</span>
 		.lower_margin   = 2,
 		.hsync_len      = 41,
 		.vsync_len      = 10,
<span class="p_del">-		.sync           = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,</span>
<span class="p_add">+		.sync           = 0,</span>
 		.flag           = 0,
 	},
 	[2] = {
<span class="p_chunk">@@ -239,7 +238,7 @@</span> <span class="p_context"> static struct fb_videomode known_lcd_panels[] = {</span>
 		.lower_margin   = 10,
 		.hsync_len      = 10,
 		.vsync_len      = 10,
<span class="p_del">-		.sync           = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,</span>
<span class="p_add">+		.sync           = 0,</span>
 		.flag           = 0,
 	},
 	[3] = {
<span class="p_header">diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c</span>
<span class="p_header">index 4545e2e2ad45..d8d68af5aef0 100644</span>
<span class="p_header">--- a/fs/btrfs/disk-io.c</span>
<span class="p_header">+++ b/fs/btrfs/disk-io.c</span>
<span class="p_chunk">@@ -1830,7 +1830,7 @@</span> <span class="p_context"> static int cleaner_kthread(void *arg)</span>
 		 */
 		btrfs_delete_unused_bgs(root-&gt;fs_info);
 sleep:
<span class="p_del">-		if (!try_to_freeze() &amp;&amp; !again) {</span>
<span class="p_add">+		if (!again) {</span>
 			set_current_state(TASK_INTERRUPTIBLE);
 			if (!kthread_should_stop())
 				schedule();
<span class="p_header">diff --git a/fs/btrfs/tests/btrfs-tests.c b/fs/btrfs/tests/btrfs-tests.c</span>
<span class="p_header">index 0e1e61a7ec23..d39f714dabeb 100644</span>
<span class="p_header">--- a/fs/btrfs/tests/btrfs-tests.c</span>
<span class="p_header">+++ b/fs/btrfs/tests/btrfs-tests.c</span>
<span class="p_chunk">@@ -189,12 +189,6 @@</span> <span class="p_context"> btrfs_alloc_dummy_block_group(unsigned long length)</span>
 		kfree(cache);
 		return NULL;
 	}
<span class="p_del">-	cache-&gt;fs_info = btrfs_alloc_dummy_fs_info();</span>
<span class="p_del">-	if (!cache-&gt;fs_info) {</span>
<span class="p_del">-		kfree(cache-&gt;free_space_ctl);</span>
<span class="p_del">-		kfree(cache);</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	}</span>
 
 	cache-&gt;key.objectid = 0;
 	cache-&gt;key.offset = length;
<span class="p_header">diff --git a/fs/btrfs/tests/free-space-tree-tests.c b/fs/btrfs/tests/free-space-tree-tests.c</span>
<span class="p_header">index d05fe1ab4808..7cea4462acd5 100644</span>
<span class="p_header">--- a/fs/btrfs/tests/free-space-tree-tests.c</span>
<span class="p_header">+++ b/fs/btrfs/tests/free-space-tree-tests.c</span>
<span class="p_chunk">@@ -485,6 +485,7 @@</span> <span class="p_context"> static int run_test(test_func_t test_func, int bitmaps)</span>
 	cache-&gt;bitmap_low_thresh = 0;
 	cache-&gt;bitmap_high_thresh = (u32)-1;
 	cache-&gt;needs_free_space = 1;
<span class="p_add">+	cache-&gt;fs_info = root-&gt;fs_info;</span>
 
 	btrfs_init_dummy_trans(&amp;trans);
 
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index bece948b363d..8580831ed237 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"> struct dentry *debugfs_create_automount(const char *name,</span>
 	if (unlikely(!inode))
 		return failed_creating(dentry);
 
<span class="p_del">-	inode-&gt;i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;</span>
<span class="p_add">+	make_empty_dir_inode(inode);</span>
 	inode-&gt;i_flags |= S_AUTOMOUNT;
 	inode-&gt;i_private = data;
 	dentry-&gt;d_fsdata = (void *)f;
<span class="p_header">diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c</span>
<span class="p_header">index ecb54394492a..25634c353191 100644</span>
<span class="p_header">--- a/fs/ext4/crypto.c</span>
<span class="p_header">+++ b/fs/ext4/crypto.c</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/random.h&gt;
 #include &lt;linux/scatterlist.h&gt;
 #include &lt;linux/spinlock_types.h&gt;
<span class="p_add">+#include &lt;linux/namei.h&gt;</span>
 
 #include &quot;ext4_extents.h&quot;
 #include &quot;xattr.h&quot;
<span class="p_chunk">@@ -479,6 +480,9 @@</span> <span class="p_context"> static int ext4_d_revalidate(struct dentry *dentry, unsigned int flags)</span>
 	struct ext4_crypt_info *ci;
 	int dir_has_key, cached_with_key;
 
<span class="p_add">+	if (flags &amp; LOOKUP_RCU)</span>
<span class="p_add">+		return -ECHILD;</span>
<span class="p_add">+</span>
 	dir = dget_parent(dentry);
 	if (!ext4_encrypted_inode(d_inode(dir))) {
 		dput(dir);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index aee960b1af34..e6218cbc8332 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -5261,6 +5261,8 @@</span> <span class="p_context"> int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)</span>
 	might_sleep();
 	trace_ext4_mark_inode_dirty(inode, _RET_IP_);
 	err = ext4_reserve_inode_write(handle, inode, &amp;iloc);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 	if (ext4_handle_valid(handle) &amp;&amp;
 	    EXT4_I(inode)-&gt;i_extra_isize &lt; sbi-&gt;s_want_extra_isize &amp;&amp;
 	    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {
<span class="p_chunk">@@ -5291,9 +5293,7 @@</span> <span class="p_context"> int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)</span>
 			}
 		}
 	}
<span class="p_del">-	if (!err)</span>
<span class="p_del">-		err = ext4_mark_iloc_dirty(handle, inode, &amp;iloc);</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	return ext4_mark_iloc_dirty(handle, inode, &amp;iloc);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/f2fs/crypto_policy.c b/fs/f2fs/crypto_policy.c</span>
<span class="p_header">index d4a96af513c2..596f02490f27 100644</span>
<span class="p_header">--- a/fs/f2fs/crypto_policy.c</span>
<span class="p_header">+++ b/fs/f2fs/crypto_policy.c</span>
<span class="p_chunk">@@ -192,7 +192,8 @@</span> <span class="p_context"> int f2fs_inherit_context(struct inode *parent, struct inode *child,</span>
 		return res;
 
 	ci = F2FS_I(parent)-&gt;i_crypt_info;
<span class="p_del">-	BUG_ON(ci == NULL);</span>
<span class="p_add">+	if (ci == NULL)</span>
<span class="p_add">+		return -ENOKEY;</span>
 
 	ctx.format = F2FS_ENCRYPTION_CONTEXT_FORMAT_V1;
 
<span class="p_header">diff --git a/fs/f2fs/data.c b/fs/f2fs/data.c</span>
<span class="p_header">index 5c06db17e41f..44802599fa67 100644</span>
<span class="p_header">--- a/fs/f2fs/data.c</span>
<span class="p_header">+++ b/fs/f2fs/data.c</span>
<span class="p_chunk">@@ -67,7 +67,6 @@</span> <span class="p_context"> static void f2fs_write_end_io(struct bio *bio)</span>
 		f2fs_restore_and_release_control_page(&amp;page);
 
 		if (unlikely(bio-&gt;bi_error)) {
<span class="p_del">-			set_page_dirty(page);</span>
 			set_bit(AS_EIO, &amp;page-&gt;mapping-&gt;flags);
 			f2fs_stop_checkpoint(sbi);
 		}
<span class="p_chunk">@@ -504,7 +503,7 @@</span> <span class="p_context"> static int __allocate_data_blocks(struct inode *inode, loff_t offset,</span>
 	struct dnode_of_data dn;
 	u64 start = F2FS_BYTES_TO_BLK(offset);
 	u64 len = F2FS_BYTES_TO_BLK(count);
<span class="p_del">-	bool allocated;</span>
<span class="p_add">+	bool allocated = false;</span>
 	u64 end_offset;
 	int err = 0;
 
<span class="p_chunk">@@ -546,7 +545,7 @@</span> <span class="p_context"> static int __allocate_data_blocks(struct inode *inode, loff_t offset,</span>
 		f2fs_put_dnode(&amp;dn);
 		f2fs_unlock_op(sbi);
 
<span class="p_del">-		f2fs_balance_fs(sbi, dn.node_changed);</span>
<span class="p_add">+		f2fs_balance_fs(sbi, allocated);</span>
 	}
 	return err;
 
<span class="p_chunk">@@ -556,7 +555,7 @@</span> <span class="p_context"> sync_out:</span>
 	f2fs_put_dnode(&amp;dn);
 out:
 	f2fs_unlock_op(sbi);
<span class="p_del">-	f2fs_balance_fs(sbi, dn.node_changed);</span>
<span class="p_add">+	f2fs_balance_fs(sbi, allocated);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -650,14 +649,14 @@</span> <span class="p_context"> get_next:</span>
 	if (dn.ofs_in_node &gt;= end_offset) {
 		if (allocated)
 			sync_inode_page(&amp;dn);
<span class="p_del">-		allocated = false;</span>
 		f2fs_put_dnode(&amp;dn);
 
 		if (create) {
 			f2fs_unlock_op(sbi);
<span class="p_del">-			f2fs_balance_fs(sbi, dn.node_changed);</span>
<span class="p_add">+			f2fs_balance_fs(sbi, allocated);</span>
 			f2fs_lock_op(sbi);
 		}
<span class="p_add">+		allocated = false;</span>
 
 		set_new_dnode(&amp;dn, inode, NULL, NULL, 0);
 		err = get_dnode_of_data(&amp;dn, pgofs, mode);
<span class="p_chunk">@@ -715,7 +714,7 @@</span> <span class="p_context"> put_out:</span>
 unlock_out:
 	if (create) {
 		f2fs_unlock_op(sbi);
<span class="p_del">-		f2fs_balance_fs(sbi, dn.node_changed);</span>
<span class="p_add">+		f2fs_balance_fs(sbi, allocated);</span>
 	}
 out:
 	trace_f2fs_map_blocks(inode, map, err);
<span class="p_header">diff --git a/fs/f2fs/dir.c b/fs/f2fs/dir.c</span>
<span class="p_header">index faa7495e2d7e..30e6b6563494 100644</span>
<span class="p_header">--- a/fs/f2fs/dir.c</span>
<span class="p_header">+++ b/fs/f2fs/dir.c</span>
<span class="p_chunk">@@ -892,11 +892,19 @@</span> <span class="p_context"> out:</span>
 	return err;
 }
 
<span class="p_add">+static int f2fs_dir_open(struct inode *inode, struct file *filp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (f2fs_encrypted_inode(inode))</span>
<span class="p_add">+		return f2fs_get_encryption_info(inode) ? -EACCES : 0;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 const struct file_operations f2fs_dir_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= generic_read_dir,
 	.iterate	= f2fs_readdir,
 	.fsync		= f2fs_sync_file,
<span class="p_add">+	.open		= f2fs_dir_open,</span>
 	.unlocked_ioctl	= f2fs_ioctl,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl   = f2fs_compat_ioctl,
<span class="p_header">diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="p_header">index ea272be62677..5a322bc00ac4 100644</span>
<span class="p_header">--- a/fs/f2fs/file.c</span>
<span class="p_header">+++ b/fs/f2fs/file.c</span>
<span class="p_chunk">@@ -425,6 +425,8 @@</span> <span class="p_context"> static int f2fs_file_mmap(struct file *file, struct vm_area_struct *vma)</span>
 		err = f2fs_get_encryption_info(inode);
 		if (err)
 			return 0;
<span class="p_add">+		if (!f2fs_encrypted_inode(inode))</span>
<span class="p_add">+			return -ENOKEY;</span>
 	}
 
 	/* we don&#39;t need to use inline_data strictly */
<span class="p_chunk">@@ -444,7 +446,9 @@</span> <span class="p_context"> static int f2fs_file_open(struct inode *inode, struct file *filp)</span>
 	if (!ret &amp;&amp; f2fs_encrypted_inode(inode)) {
 		ret = f2fs_get_encryption_info(inode);
 		if (ret)
<span class="p_del">-			ret = -EACCES;</span>
<span class="p_add">+			return -EACCES;</span>
<span class="p_add">+		if (!f2fs_encrypted_inode(inode))</span>
<span class="p_add">+			return -ENOKEY;</span>
 	}
 	return ret;
 }
<span class="p_header">diff --git a/fs/f2fs/namei.c b/fs/f2fs/namei.c</span>
<span class="p_header">index 6f944e5eb76e..7e9e38769660 100644</span>
<span class="p_header">--- a/fs/f2fs/namei.c</span>
<span class="p_header">+++ b/fs/f2fs/namei.c</span>
<span class="p_chunk">@@ -980,12 +980,6 @@</span> <span class="p_context"> static const char *f2fs_encrypted_get_link(struct dentry *dentry,</span>
 	}
 	memcpy(cstr.name, sd-&gt;encrypted_path, cstr.len);
 
<span class="p_del">-	/* this is broken symlink case */</span>
<span class="p_del">-	if (unlikely(cstr.name[0] == 0)) {</span>
<span class="p_del">-		res = -ENOENT;</span>
<span class="p_del">-		goto errout;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if ((cstr.len + sizeof(struct f2fs_encrypted_symlink_data) - 1) &gt;
 								max_size) {
 		/* Symlink data on the disk is corrupted */
<span class="p_chunk">@@ -1002,6 +996,12 @@</span> <span class="p_context"> static const char *f2fs_encrypted_get_link(struct dentry *dentry,</span>
 
 	kfree(cstr.name);
 
<span class="p_add">+	/* this is broken symlink case */</span>
<span class="p_add">+	if (unlikely(pstr.name[0] == 0)) {</span>
<span class="p_add">+		res = -ENOENT;</span>
<span class="p_add">+		goto errout;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	paddr = pstr.name;
 
 	/* Null-terminate the name */
<span class="p_header">diff --git a/fs/f2fs/super.c b/fs/f2fs/super.c</span>
<span class="p_header">index 6134832baaaf..013a62b2f8ca 100644</span>
<span class="p_header">--- a/fs/f2fs/super.c</span>
<span class="p_header">+++ b/fs/f2fs/super.c</span>
<span class="p_chunk">@@ -926,9 +926,25 @@</span> <span class="p_context"> static loff_t max_file_blocks(void)</span>
 	return result;
 }
 
<span class="p_add">+static int __f2fs_commit_super(struct buffer_head *bh,</span>
<span class="p_add">+			struct f2fs_super_block *super)</span>
<span class="p_add">+{</span>
<span class="p_add">+	lock_buffer(bh);</span>
<span class="p_add">+	if (super)</span>
<span class="p_add">+		memcpy(bh-&gt;b_data + F2FS_SUPER_OFFSET, super, sizeof(*super));</span>
<span class="p_add">+	set_buffer_uptodate(bh);</span>
<span class="p_add">+	set_buffer_dirty(bh);</span>
<span class="p_add">+	unlock_buffer(bh);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* it&#39;s rare case, we can do fua all the time */</span>
<span class="p_add">+	return __sync_dirty_buffer(bh, WRITE_FLUSH_FUA);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline bool sanity_check_area_boundary(struct super_block *sb,
<span class="p_del">-					struct f2fs_super_block *raw_super)</span>
<span class="p_add">+					struct buffer_head *bh)</span>
 {
<span class="p_add">+	struct f2fs_super_block *raw_super = (struct f2fs_super_block *)</span>
<span class="p_add">+					(bh-&gt;b_data + F2FS_SUPER_OFFSET);</span>
 	u32 segment0_blkaddr = le32_to_cpu(raw_super-&gt;segment0_blkaddr);
 	u32 cp_blkaddr = le32_to_cpu(raw_super-&gt;cp_blkaddr);
 	u32 sit_blkaddr = le32_to_cpu(raw_super-&gt;sit_blkaddr);
<span class="p_chunk">@@ -942,6 +958,10 @@</span> <span class="p_context"> static inline bool sanity_check_area_boundary(struct super_block *sb,</span>
 	u32 segment_count_main = le32_to_cpu(raw_super-&gt;segment_count_main);
 	u32 segment_count = le32_to_cpu(raw_super-&gt;segment_count);
 	u32 log_blocks_per_seg = le32_to_cpu(raw_super-&gt;log_blocks_per_seg);
<span class="p_add">+	u64 main_end_blkaddr = main_blkaddr +</span>
<span class="p_add">+				(segment_count_main &lt;&lt; log_blocks_per_seg);</span>
<span class="p_add">+	u64 seg_end_blkaddr = segment0_blkaddr +</span>
<span class="p_add">+				(segment_count &lt;&lt; log_blocks_per_seg);</span>
 
 	if (segment0_blkaddr != cp_blkaddr) {
 		f2fs_msg(sb, KERN_INFO,
<span class="p_chunk">@@ -986,22 +1006,45 @@</span> <span class="p_context"> static inline bool sanity_check_area_boundary(struct super_block *sb,</span>
 		return true;
 	}
 
<span class="p_del">-	if (main_blkaddr + (segment_count_main &lt;&lt; log_blocks_per_seg) !=</span>
<span class="p_del">-		segment0_blkaddr + (segment_count &lt;&lt; log_blocks_per_seg)) {</span>
<span class="p_add">+	if (main_end_blkaddr &gt; seg_end_blkaddr) {</span>
 		f2fs_msg(sb, KERN_INFO,
<span class="p_del">-			&quot;Wrong MAIN_AREA boundary, start(%u) end(%u) blocks(%u)&quot;,</span>
<span class="p_add">+			&quot;Wrong MAIN_AREA boundary, start(%u) end(%u) block(%u)&quot;,</span>
 			main_blkaddr,
<span class="p_del">-			segment0_blkaddr + (segment_count &lt;&lt; log_blocks_per_seg),</span>
<span class="p_add">+			segment0_blkaddr +</span>
<span class="p_add">+				(segment_count &lt;&lt; log_blocks_per_seg),</span>
 			segment_count_main &lt;&lt; log_blocks_per_seg);
 		return true;
<span class="p_add">+	} else if (main_end_blkaddr &lt; seg_end_blkaddr) {</span>
<span class="p_add">+		int err = 0;</span>
<span class="p_add">+		char *res;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* fix in-memory information all the time */</span>
<span class="p_add">+		raw_super-&gt;segment_count = cpu_to_le32((main_end_blkaddr -</span>
<span class="p_add">+				segment0_blkaddr) &gt;&gt; log_blocks_per_seg);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (f2fs_readonly(sb) || bdev_read_only(sb-&gt;s_bdev)) {</span>
<span class="p_add">+			res = &quot;internally&quot;;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			err = __f2fs_commit_super(bh, NULL);</span>
<span class="p_add">+			res = err ? &quot;failed&quot; : &quot;done&quot;;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		f2fs_msg(sb, KERN_INFO,</span>
<span class="p_add">+			&quot;Fix alignment : %s, start(%u) end(%u) block(%u)&quot;,</span>
<span class="p_add">+			res, main_blkaddr,</span>
<span class="p_add">+			segment0_blkaddr +</span>
<span class="p_add">+				(segment_count &lt;&lt; log_blocks_per_seg),</span>
<span class="p_add">+			segment_count_main &lt;&lt; log_blocks_per_seg);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return true;</span>
 	}
<span class="p_del">-</span>
 	return false;
 }
 
 static int sanity_check_raw_super(struct super_block *sb,
<span class="p_del">-			struct f2fs_super_block *raw_super)</span>
<span class="p_add">+				struct buffer_head *bh)</span>
 {
<span class="p_add">+	struct f2fs_super_block *raw_super = (struct f2fs_super_block *)</span>
<span class="p_add">+					(bh-&gt;b_data + F2FS_SUPER_OFFSET);</span>
 	unsigned int blocksize;
 
 	if (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super-&gt;magic)) {
<span class="p_chunk">@@ -1068,7 +1111,7 @@</span> <span class="p_context"> static int sanity_check_raw_super(struct super_block *sb,</span>
 	}
 
 	/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */
<span class="p_del">-	if (sanity_check_area_boundary(sb, raw_super))</span>
<span class="p_add">+	if (sanity_check_area_boundary(sb, bh))</span>
 		return 1;
 
 	return 0;
<span class="p_chunk">@@ -1134,103 +1177,87 @@</span> <span class="p_context"> static void init_sb_info(struct f2fs_sb_info *sbi)</span>
 
 /*
  * Read f2fs raw super block.
<span class="p_del">- * Because we have two copies of super block, so read the first one at first,</span>
<span class="p_del">- * if the first one is invalid, move to read the second one.</span>
<span class="p_add">+ * Because we have two copies of super block, so read both of them</span>
<span class="p_add">+ * to get the first valid one. If any one of them is broken, we pass</span>
<span class="p_add">+ * them recovery flag back to the caller.</span>
  */
 static int read_raw_super_block(struct super_block *sb,
 			struct f2fs_super_block **raw_super,
 			int *valid_super_block, int *recovery)
 {
<span class="p_del">-	int block = 0;</span>
<span class="p_add">+	int block;</span>
 	struct buffer_head *bh;
<span class="p_del">-	struct f2fs_super_block *super, *buf;</span>
<span class="p_add">+	struct f2fs_super_block *super;</span>
 	int err = 0;
 
 	super = kzalloc(sizeof(struct f2fs_super_block), GFP_KERNEL);
 	if (!super)
 		return -ENOMEM;
<span class="p_del">-retry:</span>
<span class="p_del">-	bh = sb_bread(sb, block);</span>
<span class="p_del">-	if (!bh) {</span>
<span class="p_del">-		*recovery = 1;</span>
<span class="p_del">-		f2fs_msg(sb, KERN_ERR, &quot;Unable to read %dth superblock&quot;,</span>
<span class="p_add">+</span>
<span class="p_add">+	for (block = 0; block &lt; 2; block++) {</span>
<span class="p_add">+		bh = sb_bread(sb, block);</span>
<span class="p_add">+		if (!bh) {</span>
<span class="p_add">+			f2fs_msg(sb, KERN_ERR, &quot;Unable to read %dth superblock&quot;,</span>
 				block + 1);
<span class="p_del">-		err = -EIO;</span>
<span class="p_del">-		goto next;</span>
<span class="p_del">-	}</span>
<span class="p_add">+			err = -EIO;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	buf = (struct f2fs_super_block *)(bh-&gt;b_data + F2FS_SUPER_OFFSET);</span>
<span class="p_add">+		/* sanity checking of raw super */</span>
<span class="p_add">+		if (sanity_check_raw_super(sb, bh)) {</span>
<span class="p_add">+			f2fs_msg(sb, KERN_ERR,</span>
<span class="p_add">+				&quot;Can&#39;t find valid F2FS filesystem in %dth superblock&quot;,</span>
<span class="p_add">+				block + 1);</span>
<span class="p_add">+			err = -EINVAL;</span>
<span class="p_add">+			brelse(bh);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	/* sanity checking of raw super */</span>
<span class="p_del">-	if (sanity_check_raw_super(sb, buf)) {</span>
<span class="p_add">+		if (!*raw_super) {</span>
<span class="p_add">+			memcpy(super, bh-&gt;b_data + F2FS_SUPER_OFFSET,</span>
<span class="p_add">+							sizeof(*super));</span>
<span class="p_add">+			*valid_super_block = block;</span>
<span class="p_add">+			*raw_super = super;</span>
<span class="p_add">+		}</span>
 		brelse(bh);
<span class="p_del">-		*recovery = 1;</span>
<span class="p_del">-		f2fs_msg(sb, KERN_ERR,</span>
<span class="p_del">-			&quot;Can&#39;t find valid F2FS filesystem in %dth superblock&quot;,</span>
<span class="p_del">-								block + 1);</span>
<span class="p_del">-		err = -EINVAL;</span>
<span class="p_del">-		goto next;</span>
 	}
 
<span class="p_del">-	if (!*raw_super) {</span>
<span class="p_del">-		memcpy(super, buf, sizeof(*super));</span>
<span class="p_del">-		*valid_super_block = block;</span>
<span class="p_del">-		*raw_super = super;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	brelse(bh);</span>
<span class="p_del">-</span>
<span class="p_del">-next:</span>
<span class="p_del">-	/* check the validity of the second superblock */</span>
<span class="p_del">-	if (block == 0) {</span>
<span class="p_del">-		block++;</span>
<span class="p_del">-		goto retry;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Fail to read any one of the superblocks*/</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		*recovery = 1;</span>
 
 	/* No valid superblock */
<span class="p_del">-	if (!*raw_super) {</span>
<span class="p_add">+	if (!*raw_super)</span>
 		kfree(super);
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	else</span>
<span class="p_add">+		err = 0;</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
<span class="p_del">-static int __f2fs_commit_super(struct f2fs_sb_info *sbi, int block)</span>
<span class="p_add">+int f2fs_commit_super(struct f2fs_sb_info *sbi, bool recover)</span>
 {
<span class="p_del">-	struct f2fs_super_block *super = F2FS_RAW_SUPER(sbi);</span>
 	struct buffer_head *bh;
 	int err;
 
<span class="p_del">-	bh = sb_getblk(sbi-&gt;sb, block);</span>
<span class="p_add">+	/* write back-up superblock first */</span>
<span class="p_add">+	bh = sb_getblk(sbi-&gt;sb, sbi-&gt;valid_super_block ? 0: 1);</span>
 	if (!bh)
 		return -EIO;
<span class="p_del">-</span>
<span class="p_del">-	lock_buffer(bh);</span>
<span class="p_del">-	memcpy(bh-&gt;b_data + F2FS_SUPER_OFFSET, super, sizeof(*super));</span>
<span class="p_del">-	set_buffer_uptodate(bh);</span>
<span class="p_del">-	set_buffer_dirty(bh);</span>
<span class="p_del">-	unlock_buffer(bh);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* it&#39;s rare case, we can do fua all the time */</span>
<span class="p_del">-	err = __sync_dirty_buffer(bh, WRITE_FLUSH_FUA);</span>
<span class="p_add">+	err = __f2fs_commit_super(bh, F2FS_RAW_SUPER(sbi));</span>
 	brelse(bh);
 
<span class="p_del">-	return err;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int f2fs_commit_super(struct f2fs_sb_info *sbi, bool recover)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* write back-up superblock first */</span>
<span class="p_del">-	err = __f2fs_commit_super(sbi, sbi-&gt;valid_super_block ? 0 : 1);</span>
<span class="p_del">-</span>
 	/* if we are in recovery path, skip writing valid superblock */
 	if (recover || err)
 		return err;
 
 	/* write current valid superblock */
<span class="p_del">-	return __f2fs_commit_super(sbi, sbi-&gt;valid_super_block);</span>
<span class="p_add">+	bh = sb_getblk(sbi-&gt;sb, sbi-&gt;valid_super_block);</span>
<span class="p_add">+	if (!bh)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	err = __f2fs_commit_super(bh, F2FS_RAW_SUPER(sbi));</span>
<span class="p_add">+	brelse(bh);</span>
<span class="p_add">+	return err;</span>
 }
 
 static int f2fs_fill_super(struct super_block *sb, void *data, int silent)
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index fa95ab2d3674..9d2f3e0a6360 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -1504,6 +1504,32 @@</span> <span class="p_context"> static struct page *can_gather_numa_stats(pte_t pte, struct vm_area_struct *vma,</span>
 	return page;
 }
 
<span class="p_add">+#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="p_add">+static struct page *can_gather_numa_stats_pmd(pmd_t pmd,</span>
<span class="p_add">+					      struct vm_area_struct *vma,</span>
<span class="p_add">+					      unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct page *page;</span>
<span class="p_add">+	int nid;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pmd_present(pmd))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	page = vm_normal_page_pmd(vma, addr, pmd);</span>
<span class="p_add">+	if (!page)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PageReserved(page))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	nid = page_to_nid(page);</span>
<span class="p_add">+	if (!node_isset(nid, node_states[N_MEMORY]))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return page;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static int gather_pte_stats(pmd_t *pmd, unsigned long addr,
 		unsigned long end, struct mm_walk *walk)
 {
<span class="p_chunk">@@ -1513,14 +1539,14 @@</span> <span class="p_context"> static int gather_pte_stats(pmd_t *pmd, unsigned long addr,</span>
 	pte_t *orig_pte;
 	pte_t *pte;
 
<span class="p_add">+#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
 	ptl = pmd_trans_huge_lock(pmd, vma);
 	if (ptl) {
<span class="p_del">-		pte_t huge_pte = *(pte_t *)pmd;</span>
 		struct page *page;
 
<span class="p_del">-		page = can_gather_numa_stats(huge_pte, vma, addr);</span>
<span class="p_add">+		page = can_gather_numa_stats_pmd(*pmd, vma, addr);</span>
 		if (page)
<span class="p_del">-			gather_stats(page, md, pte_dirty(huge_pte),</span>
<span class="p_add">+			gather_stats(page, md, pmd_dirty(*pmd),</span>
 				     HPAGE_PMD_SIZE/PAGE_SIZE);
 		spin_unlock(ptl);
 		return 0;
<span class="p_chunk">@@ -1528,6 +1554,7 @@</span> <span class="p_context"> static int gather_pte_stats(pmd_t *pmd, unsigned long addr,</span>
 
 	if (pmd_trans_unstable(pmd))
 		return 0;
<span class="p_add">+#endif</span>
 	orig_pte = pte = pte_offset_map_lock(walk-&gt;mm, pmd, addr, &amp;ptl);
 	do {
 		struct page *page = can_gather_numa_stats(*pte, vma, addr);
<span class="p_header">diff --git a/include/asm-generic/futex.h b/include/asm-generic/futex.h</span>
<span class="p_header">index e56272c919b5..bf2d34c9d804 100644</span>
<span class="p_header">--- a/include/asm-generic/futex.h</span>
<span class="p_header">+++ b/include/asm-generic/futex.h</span>
<span class="p_chunk">@@ -108,11 +108,15 @@</span> <span class="p_context"> futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,</span>
 	u32 val;
 
 	preempt_disable();
<span class="p_del">-	if (unlikely(get_user(val, uaddr) != 0))</span>
<span class="p_add">+	if (unlikely(get_user(val, uaddr) != 0)) {</span>
<span class="p_add">+		preempt_enable();</span>
 		return -EFAULT;
<span class="p_add">+	}</span>
 
<span class="p_del">-	if (val == oldval &amp;&amp; unlikely(put_user(newval, uaddr) != 0))</span>
<span class="p_add">+	if (val == oldval &amp;&amp; unlikely(put_user(newval, uaddr) != 0)) {</span>
<span class="p_add">+		preempt_enable();</span>
 		return -EFAULT;
<span class="p_add">+	}</span>
 
 	*uval = val;
 	preempt_enable();
<span class="p_header">diff --git a/include/drm/drm_cache.h b/include/drm/drm_cache.h</span>
<span class="p_header">index 461a0558bca4..cebecff536a3 100644</span>
<span class="p_header">--- a/include/drm/drm_cache.h</span>
<span class="p_header">+++ b/include/drm/drm_cache.h</span>
<span class="p_chunk">@@ -39,6 +39,8 @@</span> <span class="p_context"> static inline bool drm_arch_can_wc_memory(void)</span>
 {
 #if defined(CONFIG_PPC) &amp;&amp; !defined(CONFIG_NOT_COHERENT_CACHE)
 	return false;
<span class="p_add">+#elif defined(CONFIG_MIPS) &amp;&amp; defined(CONFIG_CPU_LOONGSON3)</span>
<span class="p_add">+	return false;</span>
 #else
 	return true;
 #endif
<span class="p_header">diff --git a/include/keys/trusted-type.h b/include/keys/trusted-type.h</span>
<span class="p_header">index 42cf2d991bf4..4ea7e55f20b0 100644</span>
<span class="p_header">--- a/include/keys/trusted-type.h</span>
<span class="p_header">+++ b/include/keys/trusted-type.h</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> struct trusted_key_options {</span>
 	unsigned char pcrinfo[MAX_PCRINFO_SIZE];
 	int pcrlock;
 	uint32_t hash;
<span class="p_del">-	uint32_t digest_len;</span>
<span class="p_add">+	uint32_t policydigest_len;</span>
 	unsigned char policydigest[MAX_DIGEST_SIZE];
 	uint32_t policyhandle;
 };
<span class="p_header">diff --git a/include/linux/cgroup-defs.h b/include/linux/cgroup-defs.h</span>
<span class="p_header">index 89d944b25d87..7fc7cb7872e3 100644</span>
<span class="p_header">--- a/include/linux/cgroup-defs.h</span>
<span class="p_header">+++ b/include/linux/cgroup-defs.h</span>
<span class="p_chunk">@@ -442,6 +442,7 @@</span> <span class="p_context"> struct cgroup_subsys {</span>
 	int (*can_attach)(struct cgroup_taskset *tset);
 	void (*cancel_attach)(struct cgroup_taskset *tset);
 	void (*attach)(struct cgroup_taskset *tset);
<span class="p_add">+	void (*post_attach)(void);</span>
 	int (*can_fork)(struct task_struct *task);
 	void (*cancel_fork)(struct task_struct *task);
 	void (*fork)(struct task_struct *task);
<span class="p_header">diff --git a/include/linux/cpuset.h b/include/linux/cpuset.h</span>
<span class="p_header">index fea160ee5803..85a868ccb493 100644</span>
<span class="p_header">--- a/include/linux/cpuset.h</span>
<span class="p_header">+++ b/include/linux/cpuset.h</span>
<span class="p_chunk">@@ -137,8 +137,6 @@</span> <span class="p_context"> static inline void set_mems_allowed(nodemask_t nodemask)</span>
 	task_unlock(current);
 }
 
<span class="p_del">-extern void cpuset_post_attach_flush(void);</span>
<span class="p_del">-</span>
 #else /* !CONFIG_CPUSETS */
 
 static inline bool cpusets_enabled(void) { return false; }
<span class="p_chunk">@@ -245,10 +243,6 @@</span> <span class="p_context"> static inline bool read_mems_allowed_retry(unsigned int seq)</span>
 	return false;
 }
 
<span class="p_del">-static inline void cpuset_post_attach_flush(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #endif /* !CONFIG_CPUSETS */
 
 #endif /* _LINUX_CPUSET_H */
<span class="p_header">diff --git a/include/linux/mlx5/device.h b/include/linux/mlx5/device.h</span>
<span class="p_header">index 987764afa65c..f8b83792939b 100644</span>
<span class="p_header">--- a/include/linux/mlx5/device.h</span>
<span class="p_header">+++ b/include/linux/mlx5/device.h</span>
<span class="p_chunk">@@ -363,6 +363,17 @@</span> <span class="p_context"> enum {</span>
 	MLX5_CAP_OFF_CMDIF_CSUM		= 46,
 };
 
<span class="p_add">+enum {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Max wqe size for rdma read is 512 bytes, so this</span>
<span class="p_add">+	 * limits our max_sge_rd as the wqe needs to fit:</span>
<span class="p_add">+	 * - ctrl segment (16 bytes)</span>
<span class="p_add">+	 * - rdma segment (16 bytes)</span>
<span class="p_add">+	 * - scatter elements (16 bytes each)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	MLX5_MAX_SGE_RD	= (512 - 16 - 16) / 16</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct mlx5_inbox_hdr {
 	__be16		opcode;
 	u8		rsvd[4];
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 516e14944339..a6c240e885c0 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1010,6 +1010,8 @@</span> <span class="p_context"> static inline bool page_mapped(struct page *page)</span>
 	page = compound_head(page);
 	if (atomic_read(compound_mapcount_ptr(page)) &gt;= 0)
 		return true;
<span class="p_add">+	if (PageHuge(page))</span>
<span class="p_add">+		return false;</span>
 	for (i = 0; i &lt; hpage_nr_pages(page); i++) {
 		if (atomic_read(&amp;page[i]._mapcount) &gt;= 0)
 			return true;
<span class="p_chunk">@@ -1117,6 +1119,8 @@</span> <span class="p_context"> struct zap_details {</span>
 
 struct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,
 		pte_t pte);
<span class="p_add">+struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,</span>
<span class="p_add">+				pmd_t pmd);</span>
 
 int zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,
 		unsigned long size);
<span class="p_header">diff --git a/include/linux/platform_data/mmp_dma.h b/include/linux/platform_data/mmp_dma.h</span>
<span class="p_header">index 2a330ec9e2af..d1397c8ed94e 100644</span>
<span class="p_header">--- a/include/linux/platform_data/mmp_dma.h</span>
<span class="p_header">+++ b/include/linux/platform_data/mmp_dma.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 
 struct mmp_dma_platdata {
 	int dma_channels;
<span class="p_add">+	int nb_requestors;</span>
 };
 
 #endif /* MMP_DMA_H */
<span class="p_header">diff --git a/include/media/videobuf2-core.h b/include/media/videobuf2-core.h</span>
<span class="p_header">index 8a0f55b6c2ba..88e3ab496e8f 100644</span>
<span class="p_header">--- a/include/media/videobuf2-core.h</span>
<span class="p_header">+++ b/include/media/videobuf2-core.h</span>
<span class="p_chunk">@@ -375,6 +375,9 @@</span> <span class="p_context"> struct vb2_ops {</span>
 /**
  * struct vb2_ops - driver-specific callbacks
  *
<span class="p_add">+ * @verify_planes_array: Verify that a given user space structure contains</span>
<span class="p_add">+ *			enough planes for the buffer. This is called</span>
<span class="p_add">+ *			for each dequeued buffer.</span>
  * @fill_user_buffer:	given a vb2_buffer fill in the userspace structure.
  *			For V4L2 this is a struct v4l2_buffer.
  * @fill_vb2_buffer:	given a userspace structure, fill in the vb2_buffer.
<span class="p_chunk">@@ -384,6 +387,7 @@</span> <span class="p_context"> struct vb2_ops {</span>
  *			the vb2_buffer struct.
  */
 struct vb2_buf_ops {
<span class="p_add">+	int (*verify_planes_array)(struct vb2_buffer *vb, const void *pb);</span>
 	void (*fill_user_buffer)(struct vb2_buffer *vb, void *pb);
 	int (*fill_vb2_buffer)(struct vb2_buffer *vb, const void *pb,
 				struct vb2_plane *planes);
<span class="p_chunk">@@ -400,6 +404,9 @@</span> <span class="p_context"> struct vb2_buf_ops {</span>
  * @fileio_read_once:		report EOF after reading the first buffer
  * @fileio_write_immediately:	queue buffer after each write() call
  * @allow_zero_bytesused:	allow bytesused == 0 to be passed to the driver
<span class="p_add">+ * @quirk_poll_must_check_waiting_for_buffers: Return POLLERR at poll when QBUF</span>
<span class="p_add">+ *              has not been called. This is a vb1 idiom that has been adopted</span>
<span class="p_add">+ *              also by vb2.</span>
  * @lock:	pointer to a mutex that protects the vb2_queue struct. The
  *		driver can set this to a mutex to let the v4l2 core serialize
  *		the queuing ioctls. If the driver wants to handle locking
<span class="p_chunk">@@ -463,6 +470,7 @@</span> <span class="p_context"> struct vb2_queue {</span>
 	unsigned			fileio_read_once:1;
 	unsigned			fileio_write_immediately:1;
 	unsigned			allow_zero_bytesused:1;
<span class="p_add">+	unsigned		   quirk_poll_must_check_waiting_for_buffers:1;</span>
 
 	struct mutex			*lock;
 	void				*owner;
<span class="p_header">diff --git a/include/rdma/ib.h b/include/rdma/ib.h</span>
<span class="p_header">index cf8f9e700e48..a6b93706b0fc 100644</span>
<span class="p_header">--- a/include/rdma/ib.h</span>
<span class="p_header">+++ b/include/rdma/ib.h</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"></span>
 #define _RDMA_IB_H
 
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
 
 struct ib_addr {
 	union {
<span class="p_chunk">@@ -86,4 +87,19 @@</span> <span class="p_context"> struct sockaddr_ib {</span>
 	__u64			sib_scope_id;
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The IB interfaces that use write() as bi-directional ioctl() are</span>
<span class="p_add">+ * fundamentally unsafe, since there are lots of ways to trigger &quot;write()&quot;</span>
<span class="p_add">+ * calls from various contexts with elevated privileges. That includes the</span>
<span class="p_add">+ * traditional suid executable error message writes, but also various kernel</span>
<span class="p_add">+ * interfaces that can write to file descriptors.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function provides protection for the legacy API by restricting the</span>
<span class="p_add">+ * calling context.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool ib_safe_file_access(struct file *filp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return filp-&gt;f_cred == current_cred() &amp;&amp; segment_eq(get_fs(), USER_DS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* _RDMA_IB_H */
<span class="p_header">diff --git a/include/sound/hda_i915.h b/include/sound/hda_i915.h</span>
<span class="p_header">index fa341fcb5829..f5842bcd9c94 100644</span>
<span class="p_header">--- a/include/sound/hda_i915.h</span>
<span class="p_header">+++ b/include/sound/hda_i915.h</span>
<span class="p_chunk">@@ -9,7 +9,7 @@</span> <span class="p_context"></span>
 #ifdef CONFIG_SND_HDA_I915
 int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable);
 int snd_hdac_display_power(struct hdac_bus *bus, bool enable);
<span class="p_del">-int snd_hdac_get_display_clk(struct hdac_bus *bus);</span>
<span class="p_add">+void snd_hdac_i915_set_bclk(struct hdac_bus *bus);</span>
 int snd_hdac_sync_audio_rate(struct hdac_bus *bus, hda_nid_t nid, int rate);
 int snd_hdac_acomp_get_eld(struct hdac_bus *bus, hda_nid_t nid,
 			   bool *audio_enabled, char *buffer, int max_bytes);
<span class="p_chunk">@@ -25,9 +25,8 @@</span> <span class="p_context"> static inline int snd_hdac_display_power(struct hdac_bus *bus, bool enable)</span>
 {
 	return 0;
 }
<span class="p_del">-static inline int snd_hdac_get_display_clk(struct hdac_bus *bus)</span>
<span class="p_add">+static inline void snd_hdac_i915_set_bclk(struct hdac_bus *bus)</span>
 {
<span class="p_del">-	return 0;</span>
 }
 static inline int snd_hdac_sync_audio_rate(struct hdac_bus *bus, hda_nid_t nid,
 					   int rate)
<span class="p_header">diff --git a/include/uapi/linux/v4l2-dv-timings.h b/include/uapi/linux/v4l2-dv-timings.h</span>
<span class="p_header">index c039f1d68a09..086168e18ca8 100644</span>
<span class="p_header">--- a/include/uapi/linux/v4l2-dv-timings.h</span>
<span class="p_header">+++ b/include/uapi/linux/v4l2-dv-timings.h</span>
<span class="p_chunk">@@ -183,7 +183,8 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_3840X2160P24 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 1276, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -191,14 +192,16 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_3840X2160P25 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 1056, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_IS_CE_VIDEO) \
 }
 
 #define V4L2_DV_BT_CEA_3840X2160P30 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 176, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -206,14 +209,16 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_3840X2160P50 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 1056, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_IS_CE_VIDEO) \
 }
 
 #define V4L2_DV_BT_CEA_3840X2160P60 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 176, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -221,7 +226,8 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_4096X2160P24 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 1020, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -229,14 +235,16 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_4096X2160P25 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 968, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_IS_CE_VIDEO) \
 }
 
 #define V4L2_DV_BT_CEA_4096X2160P30 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 88, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -244,14 +252,16 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_4096X2160P50 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 968, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_IS_CE_VIDEO) \
 }
 
 #define V4L2_DV_BT_CEA_4096X2160P60 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 88, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index 6a498daf2eec..355cd5f2b416 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -2697,9 +2697,10 @@</span> <span class="p_context"> static ssize_t __cgroup_procs_write(struct kernfs_open_file *of, char *buf,</span>
 				    size_t nbytes, loff_t off, bool threadgroup)
 {
 	struct task_struct *tsk;
<span class="p_add">+	struct cgroup_subsys *ss;</span>
 	struct cgroup *cgrp;
 	pid_t pid;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ssid, ret;</span>
 
 	if (kstrtoint(strstrip(buf), 0, &amp;pid) || pid &lt; 0)
 		return -EINVAL;
<span class="p_chunk">@@ -2747,8 +2748,10 @@</span> <span class="p_context"> out_unlock_rcu:</span>
 	rcu_read_unlock();
 out_unlock_threadgroup:
 	percpu_up_write(&amp;cgroup_threadgroup_rwsem);
<span class="p_add">+	for_each_subsys(ss, ssid)</span>
<span class="p_add">+		if (ss-&gt;post_attach)</span>
<span class="p_add">+			ss-&gt;post_attach();</span>
 	cgroup_kn_unlock(of-&gt;kn);
<span class="p_del">-	cpuset_post_attach_flush();</span>
 	return ret ?: nbytes;
 }
 
<span class="p_header">diff --git a/kernel/cpuset.c b/kernel/cpuset.c</span>
<span class="p_header">index 41989ab4db57..df16d0c9349f 100644</span>
<span class="p_header">--- a/kernel/cpuset.c</span>
<span class="p_header">+++ b/kernel/cpuset.c</span>
<span class="p_chunk">@@ -58,7 +58,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/uaccess.h&gt;
 #include &lt;linux/atomic.h&gt;
 #include &lt;linux/mutex.h&gt;
<span class="p_del">-#include &lt;linux/workqueue.h&gt;</span>
 #include &lt;linux/cgroup.h&gt;
 #include &lt;linux/wait.h&gt;
 
<span class="p_chunk">@@ -1016,7 +1015,7 @@</span> <span class="p_context"> static void cpuset_migrate_mm(struct mm_struct *mm, const nodemask_t *from,</span>
 	}
 }
 
<span class="p_del">-void cpuset_post_attach_flush(void)</span>
<span class="p_add">+static void cpuset_post_attach(void)</span>
 {
 	flush_workqueue(cpuset_migrate_mm_wq);
 }
<span class="p_chunk">@@ -2087,6 +2086,7 @@</span> <span class="p_context"> struct cgroup_subsys cpuset_cgrp_subsys = {</span>
 	.can_attach	= cpuset_can_attach,
 	.cancel_attach	= cpuset_cancel_attach,
 	.attach		= cpuset_attach,
<span class="p_add">+	.post_attach	= cpuset_post_attach,</span>
 	.bind		= cpuset_bind,
 	.legacy_cftypes	= files,
 	.early_init	= 1,
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index f0b4b328d8f5..a0ef98b258d7 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -2402,14 +2402,24 @@</span> <span class="p_context"> static void ctx_sched_out(struct perf_event_context *ctx,</span>
 			cpuctx-&gt;task_ctx = NULL;
 	}
 
<span class="p_del">-	is_active ^= ctx-&gt;is_active; /* changed bits */</span>
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Always update time if it was set; not only when it changes.</span>
<span class="p_add">+	 * Otherwise we can &#39;forget&#39; to update time for any but the last</span>
<span class="p_add">+	 * context we sched out. For example:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   ctx_sched_out(.event_type = EVENT_FLEXIBLE)</span>
<span class="p_add">+	 *   ctx_sched_out(.event_type = EVENT_PINNED)</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * would only update time for the pinned events.</span>
<span class="p_add">+	 */</span>
 	if (is_active &amp; EVENT_TIME) {
 		/* update (and stop) ctx time */
 		update_context_time(ctx);
 		update_cgrp_time_from_cpuctx(cpuctx);
 	}
 
<span class="p_add">+	is_active ^= ctx-&gt;is_active; /* changed bits */</span>
<span class="p_add">+</span>
 	if (!ctx-&gt;nr_active || !(is_active &amp; EVENT_ALL))
 		return;
 
<span class="p_chunk">@@ -8479,6 +8489,7 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 					f_flags);
 	if (IS_ERR(event_file)) {
 		err = PTR_ERR(event_file);
<span class="p_add">+		event_file = NULL;</span>
 		goto err_context;
 	}
 
<span class="p_header">diff --git a/kernel/futex.c b/kernel/futex.c</span>
<span class="p_header">index 5d6ce6413ef1..11b502159f3a 100644</span>
<span class="p_header">--- a/kernel/futex.c</span>
<span class="p_header">+++ b/kernel/futex.c</span>
<span class="p_chunk">@@ -1212,10 +1212,20 @@</span> <span class="p_context"> static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this,</span>
 	if (unlikely(should_fail_futex(true)))
 		ret = -EFAULT;
 
<span class="p_del">-	if (cmpxchg_futex_value_locked(&amp;curval, uaddr, uval, newval))</span>
<span class="p_add">+	if (cmpxchg_futex_value_locked(&amp;curval, uaddr, uval, newval)) {</span>
 		ret = -EFAULT;
<span class="p_del">-	else if (curval != uval)</span>
<span class="p_del">-		ret = -EINVAL;</span>
<span class="p_add">+	} else if (curval != uval) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If a unconditional UNLOCK_PI operation (user space did not</span>
<span class="p_add">+		 * try the TID-&gt;0 transition) raced with a waiter setting the</span>
<span class="p_add">+		 * FUTEX_WAITERS flag between get_user() and locking the hash</span>
<span class="p_add">+		 * bucket lock, retry the operation.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((FUTEX_TID_MASK &amp; curval) == uval)</span>
<span class="p_add">+			ret = -EAGAIN;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+	}</span>
 	if (ret) {
 		raw_spin_unlock_irq(&amp;pi_state-&gt;pi_mutex.wait_lock);
 		return ret;
<span class="p_chunk">@@ -1442,8 +1452,8 @@</span> <span class="p_context"> void requeue_futex(struct futex_q *q, struct futex_hash_bucket *hb1,</span>
 	if (likely(&amp;hb1-&gt;chain != &amp;hb2-&gt;chain)) {
 		plist_del(&amp;q-&gt;list, &amp;hb1-&gt;chain);
 		hb_waiters_dec(hb1);
<span class="p_del">-		plist_add(&amp;q-&gt;list, &amp;hb2-&gt;chain);</span>
 		hb_waiters_inc(hb2);
<span class="p_add">+		plist_add(&amp;q-&gt;list, &amp;hb2-&gt;chain);</span>
 		q-&gt;lock_ptr = &amp;hb2-&gt;lock;
 	}
 	get_futex_key_refs(key2);
<span class="p_chunk">@@ -2536,6 +2546,15 @@</span> <span class="p_context"> retry:</span>
 		if (ret == -EFAULT)
 			goto pi_faulted;
 		/*
<span class="p_add">+		 * A unconditional UNLOCK_PI op raced against a waiter</span>
<span class="p_add">+		 * setting the FUTEX_WAITERS bit. Try again.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (ret == -EAGAIN) {</span>
<span class="p_add">+			spin_unlock(&amp;hb-&gt;lock);</span>
<span class="p_add">+			put_futex_key(&amp;key);</span>
<span class="p_add">+			goto retry;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/*</span>
 		 * wake_futex_pi has detected invalid state. Tell user
 		 * space.
 		 */
<span class="p_header">diff --git a/kernel/locking/mcs_spinlock.h b/kernel/locking/mcs_spinlock.h</span>
<span class="p_header">index 5b9102a47ea5..c835270f0c2f 100644</span>
<span class="p_header">--- a/kernel/locking/mcs_spinlock.h</span>
<span class="p_header">+++ b/kernel/locking/mcs_spinlock.h</span>
<span class="p_chunk">@@ -67,7 +67,13 @@</span> <span class="p_context"> void mcs_spin_lock(struct mcs_spinlock **lock, struct mcs_spinlock *node)</span>
 	node-&gt;locked = 0;
 	node-&gt;next   = NULL;
 
<span class="p_del">-	prev = xchg_acquire(lock, node);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We rely on the full barrier with global transitivity implied by the</span>
<span class="p_add">+	 * below xchg() to order the initialization stores above against any</span>
<span class="p_add">+	 * observation of @node. And to provide the ACQUIRE ordering associated</span>
<span class="p_add">+	 * with a LOCK primitive.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	prev = xchg(lock, node);</span>
 	if (likely(prev == NULL)) {
 		/*
 		 * Lock acquired, don&#39;t need to set node-&gt;locked to 1. Threads
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index a74073f8c08c..1c1d2a00ad95 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -7802,7 +7802,7 @@</span> <span class="p_context"> void set_curr_task(int cpu, struct task_struct *p)</span>
 /* task_group_lock serializes the addition/removal of task groups */
 static DEFINE_SPINLOCK(task_group_lock);
 
<span class="p_del">-static void free_sched_group(struct task_group *tg)</span>
<span class="p_add">+static void sched_free_group(struct task_group *tg)</span>
 {
 	free_fair_sched_group(tg);
 	free_rt_sched_group(tg);
<span class="p_chunk">@@ -7828,7 +7828,7 @@</span> <span class="p_context"> struct task_group *sched_create_group(struct task_group *parent)</span>
 	return tg;
 
 err:
<span class="p_del">-	free_sched_group(tg);</span>
<span class="p_add">+	sched_free_group(tg);</span>
 	return ERR_PTR(-ENOMEM);
 }
 
<span class="p_chunk">@@ -7848,17 +7848,16 @@</span> <span class="p_context"> void sched_online_group(struct task_group *tg, struct task_group *parent)</span>
 }
 
 /* rcu callback to free various structures associated with a task group */
<span class="p_del">-static void free_sched_group_rcu(struct rcu_head *rhp)</span>
<span class="p_add">+static void sched_free_group_rcu(struct rcu_head *rhp)</span>
 {
 	/* now it should be safe to free those cfs_rqs */
<span class="p_del">-	free_sched_group(container_of(rhp, struct task_group, rcu));</span>
<span class="p_add">+	sched_free_group(container_of(rhp, struct task_group, rcu));</span>
 }
 
<span class="p_del">-/* Destroy runqueue etc associated with a task group */</span>
 void sched_destroy_group(struct task_group *tg)
 {
 	/* wait for possible concurrent references to cfs_rqs complete */
<span class="p_del">-	call_rcu(&amp;tg-&gt;rcu, free_sched_group_rcu);</span>
<span class="p_add">+	call_rcu(&amp;tg-&gt;rcu, sched_free_group_rcu);</span>
 }
 
 void sched_offline_group(struct task_group *tg)
<span class="p_chunk">@@ -8319,31 +8318,26 @@</span> <span class="p_context"> cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)</span>
 	if (IS_ERR(tg))
 		return ERR_PTR(-ENOMEM);
 
<span class="p_add">+	sched_online_group(tg, parent);</span>
<span class="p_add">+</span>
 	return &amp;tg-&gt;css;
 }
 
<span class="p_del">-static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)</span>
<span class="p_add">+static void cpu_cgroup_css_released(struct cgroup_subsys_state *css)</span>
 {
 	struct task_group *tg = css_tg(css);
<span class="p_del">-	struct task_group *parent = css_tg(css-&gt;parent);</span>
 
<span class="p_del">-	if (parent)</span>
<span class="p_del">-		sched_online_group(tg, parent);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	sched_offline_group(tg);</span>
 }
 
 static void cpu_cgroup_css_free(struct cgroup_subsys_state *css)
 {
 	struct task_group *tg = css_tg(css);
 
<span class="p_del">-	sched_destroy_group(tg);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct task_group *tg = css_tg(css);</span>
<span class="p_del">-</span>
<span class="p_del">-	sched_offline_group(tg);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Relies on the RCU grace period between css_released() and this.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sched_free_group(tg);</span>
 }
 
 static void cpu_cgroup_fork(struct task_struct *task)
<span class="p_chunk">@@ -8703,9 +8697,8 @@</span> <span class="p_context"> static struct cftype cpu_files[] = {</span>
 
 struct cgroup_subsys cpu_cgrp_subsys = {
 	.css_alloc	= cpu_cgroup_css_alloc,
<span class="p_add">+	.css_released	= cpu_cgroup_css_released,</span>
 	.css_free	= cpu_cgroup_css_free,
<span class="p_del">-	.css_online	= cpu_cgroup_css_online,</span>
<span class="p_del">-	.css_offline	= cpu_cgroup_css_offline,</span>
 	.fork		= cpu_cgroup_fork,
 	.can_attach	= cpu_cgroup_can_attach,
 	.attach		= cpu_cgroup_attach,
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index 7ff5dc7d2ac5..9e82d0450fad 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -667,6 +667,35 @@</span> <span class="p_context"> static void set_work_pool_and_clear_pending(struct work_struct *work,</span>
 	 */
 	smp_wmb();
 	set_work_data(work, (unsigned long)pool_id &lt;&lt; WORK_OFFQ_POOL_SHIFT, 0);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The following mb guarantees that previous clear of a PENDING bit</span>
<span class="p_add">+	 * will not be reordered with any speculative LOADS or STORES from</span>
<span class="p_add">+	 * work-&gt;current_func, which is executed afterwards.  This possible</span>
<span class="p_add">+	 * reordering can lead to a missed execution on attempt to qeueue</span>
<span class="p_add">+	 * the same @work.  E.g. consider this case:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   CPU#0                         CPU#1</span>
<span class="p_add">+	 *   ----------------------------  --------------------------------</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * 1  STORE event_indicated</span>
<span class="p_add">+	 * 2  queue_work_on() {</span>
<span class="p_add">+	 * 3    test_and_set_bit(PENDING)</span>
<span class="p_add">+	 * 4 }                             set_..._and_clear_pending() {</span>
<span class="p_add">+	 * 5                                 set_work_data() # clear bit</span>
<span class="p_add">+	 * 6                                 smp_mb()</span>
<span class="p_add">+	 * 7                               work-&gt;current_func() {</span>
<span class="p_add">+	 * 8				      LOAD event_indicated</span>
<span class="p_add">+	 *				   }</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Without an explicit full barrier speculative LOAD on line 8 can</span>
<span class="p_add">+	 * be executed before CPU#0 does STORE on line 1.  If that happens,</span>
<span class="p_add">+	 * CPU#0 observes the PENDING bit is still set and new execution of</span>
<span class="p_add">+	 * a @work is not queued in a hope, that CPU#1 will eventually</span>
<span class="p_add">+	 * finish the queued @work.  Meanwhile CPU#1 does not see</span>
<span class="p_add">+	 * event_indicated is set, because speculative LOAD was executed</span>
<span class="p_add">+	 * before actual STORE.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
 }
 
 static void clear_work_data(struct work_struct *work)
<span class="p_header">diff --git a/lib/assoc_array.c b/lib/assoc_array.c</span>
<span class="p_header">index 03dd576e6773..59fd7c0b119c 100644</span>
<span class="p_header">--- a/lib/assoc_array.c</span>
<span class="p_header">+++ b/lib/assoc_array.c</span>
<span class="p_chunk">@@ -524,7 +524,9 @@</span> <span class="p_context"> static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,</span>
 			free_slot = i;
 			continue;
 		}
<span class="p_del">-		if (ops-&gt;compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) {</span>
<span class="p_add">+		if (assoc_array_ptr_is_leaf(ptr) &amp;&amp;</span>
<span class="p_add">+		    ops-&gt;compare_object(assoc_array_ptr_to_leaf(ptr),</span>
<span class="p_add">+					index_key)) {</span>
 			pr_devel(&quot;replace in slot %d\n&quot;, i);
 			edit-&gt;leaf_p = &amp;node-&gt;slots[i];
 			edit-&gt;dead_leaf = node-&gt;slots[i];
<span class="p_header">diff --git a/lib/lz4/lz4defs.h b/lib/lz4/lz4defs.h</span>
<span class="p_header">index abcecdc2d0f2..0710a62ad2f6 100644</span>
<span class="p_header">--- a/lib/lz4/lz4defs.h</span>
<span class="p_header">+++ b/lib/lz4/lz4defs.h</span>
<span class="p_chunk">@@ -11,8 +11,7 @@</span> <span class="p_context"></span>
 /*
  * Detects 64 bits mode
  */
<span class="p_del">-#if (defined(__x86_64__) || defined(__x86_64) || defined(__amd64__) \</span>
<span class="p_del">-	|| defined(__ppc64__) || defined(__LP64__))</span>
<span class="p_add">+#if defined(CONFIG_64BIT)</span>
 #define LZ4_ARCH64 1
 #else
 #define LZ4_ARCH64 0
<span class="p_chunk">@@ -35,6 +34,10 @@</span> <span class="p_context"> typedef struct _U64_S { u64 v; } U64_S;</span>
 
 #define PUT4(s, d) (A32(d) = A32(s))
 #define PUT8(s, d) (A64(d) = A64(s))
<span class="p_add">+</span>
<span class="p_add">+#define LZ4_READ_LITTLEENDIAN_16(d, s, p)	\</span>
<span class="p_add">+	(d = s - A16(p))</span>
<span class="p_add">+</span>
 #define LZ4_WRITE_LITTLEENDIAN_16(p, v)	\
 	do {	\
 		A16(p) = v; \
<span class="p_chunk">@@ -51,10 +54,13 @@</span> <span class="p_context"> typedef struct _U64_S { u64 v; } U64_S;</span>
 #define PUT8(s, d) \
 	put_unaligned(get_unaligned((const u64 *) s), (u64 *) d)
 
<span class="p_del">-#define LZ4_WRITE_LITTLEENDIAN_16(p, v)	\</span>
<span class="p_del">-	do {	\</span>
<span class="p_del">-		put_unaligned(v, (u16 *)(p)); \</span>
<span class="p_del">-		p += 2; \</span>
<span class="p_add">+#define LZ4_READ_LITTLEENDIAN_16(d, s, p)	\</span>
<span class="p_add">+	(d = s - get_unaligned_le16(p))</span>
<span class="p_add">+</span>
<span class="p_add">+#define LZ4_WRITE_LITTLEENDIAN_16(p, v)			\</span>
<span class="p_add">+	do {						\</span>
<span class="p_add">+		put_unaligned_le16(v, (u16 *)(p));	\</span>
<span class="p_add">+		p += 2;					\</span>
 	} while (0)
 #endif
 
<span class="p_chunk">@@ -140,9 +146,6 @@</span> <span class="p_context"> typedef struct _U64_S { u64 v; } U64_S;</span>
 
 #endif
 
<span class="p_del">-#define LZ4_READ_LITTLEENDIAN_16(d, s, p) \</span>
<span class="p_del">-	(d = s - get_unaligned_le16(p))</span>
<span class="p_del">-</span>
 #define LZ4_WILDCOPY(s, d, e)		\
 	do {				\
 		LZ4_COPYPACKET(s, d);	\
<span class="p_header">diff --git a/lib/mpi/mpicoder.c b/lib/mpi/mpicoder.c</span>
<span class="p_header">index ec533a6c77b5..eb15e7dc7b65 100644</span>
<span class="p_header">--- a/lib/mpi/mpicoder.c</span>
<span class="p_header">+++ b/lib/mpi/mpicoder.c</span>
<span class="p_chunk">@@ -128,6 +128,23 @@</span> <span class="p_context"> leave:</span>
 }
 EXPORT_SYMBOL_GPL(mpi_read_from_buffer);
 
<span class="p_add">+static int count_lzeros(MPI a)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mpi_limb_t alimb;</span>
<span class="p_add">+	int i, lzeros = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = a-&gt;nlimbs - 1; i &gt;= 0; i--) {</span>
<span class="p_add">+		alimb = a-&gt;d[i];</span>
<span class="p_add">+		if (alimb == 0) {</span>
<span class="p_add">+			lzeros += sizeof(mpi_limb_t);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			lzeros += count_leading_zeros(alimb) / 8;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return lzeros;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * mpi_read_buffer() - read MPI to a bufer provided by user (msb first)
  *
<span class="p_chunk">@@ -148,7 +165,7 @@</span> <span class="p_context"> int mpi_read_buffer(MPI a, uint8_t *buf, unsigned buf_len, unsigned *nbytes,</span>
 	uint8_t *p;
 	mpi_limb_t alimb;
 	unsigned int n = mpi_get_size(a);
<span class="p_del">-	int i, lzeros = 0;</span>
<span class="p_add">+	int i, lzeros;</span>
 
 	if (!buf || !nbytes)
 		return -EINVAL;
<span class="p_chunk">@@ -156,14 +173,7 @@</span> <span class="p_context"> int mpi_read_buffer(MPI a, uint8_t *buf, unsigned buf_len, unsigned *nbytes,</span>
 	if (sign)
 		*sign = a-&gt;sign;
 
<span class="p_del">-	p = (void *)&amp;a-&gt;d[a-&gt;nlimbs] - 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = a-&gt;nlimbs * sizeof(alimb) - 1; i &gt;= 0; i--, p--) {</span>
<span class="p_del">-		if (!*p)</span>
<span class="p_del">-			lzeros++;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	lzeros = count_lzeros(a);</span>
 
 	if (buf_len &lt; n - lzeros) {
 		*nbytes = n - lzeros;
<span class="p_chunk">@@ -351,7 +361,7 @@</span> <span class="p_context"> int mpi_write_to_sgl(MPI a, struct scatterlist *sgl, unsigned *nbytes,</span>
 	u8 *p, *p2;
 	mpi_limb_t alimb, alimb2;
 	unsigned int n = mpi_get_size(a);
<span class="p_del">-	int i, x, y = 0, lzeros = 0, buf_len;</span>
<span class="p_add">+	int i, x, y = 0, lzeros, buf_len;</span>
 
 	if (!nbytes)
 		return -EINVAL;
<span class="p_chunk">@@ -359,14 +369,7 @@</span> <span class="p_context"> int mpi_write_to_sgl(MPI a, struct scatterlist *sgl, unsigned *nbytes,</span>
 	if (sign)
 		*sign = a-&gt;sign;
 
<span class="p_del">-	p = (void *)&amp;a-&gt;d[a-&gt;nlimbs] - 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = a-&gt;nlimbs * sizeof(alimb) - 1; i &gt;= 0; i--, p--) {</span>
<span class="p_del">-		if (!*p)</span>
<span class="p_del">-			lzeros++;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	lzeros = count_lzeros(a);</span>
 
 	if (*nbytes &lt; n - lzeros) {
 		*nbytes = n - lzeros;
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index e10a4fee88d2..a7db0a2db1ab 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1919,10 +1919,9 @@</span> <span class="p_context"> int khugepaged_enter_vma_merge(struct vm_area_struct *vma,</span>
 		 * page fault if needed.
 		 */
 		return 0;
<span class="p_del">-	if (vma-&gt;vm_ops)</span>
<span class="p_add">+	if (vma-&gt;vm_ops || (vm_flags &amp; VM_NO_THP))</span>
 		/* khugepaged not yet working on file or special mappings */
 		return 0;
<span class="p_del">-	VM_BUG_ON_VMA(vm_flags &amp; VM_NO_THP, vma);</span>
 	hstart = (vma-&gt;vm_start + ~HPAGE_PMD_MASK) &amp; HPAGE_PMD_MASK;
 	hend = vma-&gt;vm_end &amp; HPAGE_PMD_MASK;
 	if (hstart &lt; hend)
<span class="p_chunk">@@ -2310,8 +2309,7 @@</span> <span class="p_context"> static bool hugepage_vma_check(struct vm_area_struct *vma)</span>
 		return false;
 	if (is_vma_temporary_stack(vma))
 		return false;
<span class="p_del">-	VM_BUG_ON_VMA(vma-&gt;vm_flags &amp; VM_NO_THP, vma);</span>
<span class="p_del">-	return true;</span>
<span class="p_add">+	return !(vma-&gt;vm_flags &amp; VM_NO_THP);</span>
 }
 
 static void collapse_huge_page(struct mm_struct *mm,
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index caf3bf73b533..a65ad1d59232 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -207,6 +207,7 @@</span> <span class="p_context"> static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);</span>
 /* &quot;mc&quot; and its members are protected by cgroup_mutex */
 static struct move_charge_struct {
 	spinlock_t	  lock; /* for from, to */
<span class="p_add">+	struct mm_struct  *mm;</span>
 	struct mem_cgroup *from;
 	struct mem_cgroup *to;
 	unsigned long flags;
<span class="p_chunk">@@ -4730,6 +4731,8 @@</span> <span class="p_context"> static void __mem_cgroup_clear_mc(void)</span>
 
 static void mem_cgroup_clear_mc(void)
 {
<span class="p_add">+	struct mm_struct *mm = mc.mm;</span>
<span class="p_add">+</span>
 	/*
 	 * we must clear moving_task before waking up waiters at the end of
 	 * task migration.
<span class="p_chunk">@@ -4739,7 +4742,10 @@</span> <span class="p_context"> static void mem_cgroup_clear_mc(void)</span>
 	spin_lock(&amp;mc.lock);
 	mc.from = NULL;
 	mc.to = NULL;
<span class="p_add">+	mc.mm = NULL;</span>
 	spin_unlock(&amp;mc.lock);
<span class="p_add">+</span>
<span class="p_add">+	mmput(mm);</span>
 }
 
 static int mem_cgroup_can_attach(struct cgroup_taskset *tset)
<span class="p_chunk">@@ -4796,6 +4802,7 @@</span> <span class="p_context"> static int mem_cgroup_can_attach(struct cgroup_taskset *tset)</span>
 		VM_BUG_ON(mc.moved_swap);
 
 		spin_lock(&amp;mc.lock);
<span class="p_add">+		mc.mm = mm;</span>
 		mc.from = from;
 		mc.to = memcg;
 		mc.flags = move_flags;
<span class="p_chunk">@@ -4805,8 +4812,9 @@</span> <span class="p_context"> static int mem_cgroup_can_attach(struct cgroup_taskset *tset)</span>
 		ret = mem_cgroup_precharge_mc(mm);
 		if (ret)
 			mem_cgroup_clear_mc();
<span class="p_add">+	} else {</span>
<span class="p_add">+		mmput(mm);</span>
 	}
<span class="p_del">-	mmput(mm);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -4915,11 +4923,11 @@</span> <span class="p_context"> put:			/* get_mctgt_type() gets the page */</span>
 	return ret;
 }
 
<span class="p_del">-static void mem_cgroup_move_charge(struct mm_struct *mm)</span>
<span class="p_add">+static void mem_cgroup_move_charge(void)</span>
 {
 	struct mm_walk mem_cgroup_move_charge_walk = {
 		.pmd_entry = mem_cgroup_move_charge_pte_range,
<span class="p_del">-		.mm = mm,</span>
<span class="p_add">+		.mm = mc.mm,</span>
 	};
 
 	lru_add_drain_all();
<span class="p_chunk">@@ -4931,7 +4939,7 @@</span> <span class="p_context"> static void mem_cgroup_move_charge(struct mm_struct *mm)</span>
 	atomic_inc(&amp;mc.from-&gt;moving_account);
 	synchronize_rcu();
 retry:
<span class="p_del">-	if (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) {</span>
<span class="p_add">+	if (unlikely(!down_read_trylock(&amp;mc.mm-&gt;mmap_sem))) {</span>
 		/*
 		 * Someone who are holding the mmap_sem might be waiting in
 		 * waitq. So we cancel all extra charges, wake up all waiters,
<span class="p_chunk">@@ -4948,23 +4956,16 @@</span> <span class="p_context"> retry:</span>
 	 * additional charge, the page walk just aborts.
 	 */
 	walk_page_range(0, ~0UL, &amp;mem_cgroup_move_charge_walk);
<span class="p_del">-	up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	up_read(&amp;mc.mm-&gt;mmap_sem);</span>
 	atomic_dec(&amp;mc.from-&gt;moving_account);
 }
 
<span class="p_del">-static void mem_cgroup_move_task(struct cgroup_taskset *tset)</span>
<span class="p_add">+static void mem_cgroup_move_task(void)</span>
 {
<span class="p_del">-	struct cgroup_subsys_state *css;</span>
<span class="p_del">-	struct task_struct *p = cgroup_taskset_first(tset, &amp;css);</span>
<span class="p_del">-	struct mm_struct *mm = get_task_mm(p);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mm) {</span>
<span class="p_del">-		if (mc.to)</span>
<span class="p_del">-			mem_cgroup_move_charge(mm);</span>
<span class="p_del">-		mmput(mm);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (mc.to)</span>
<span class="p_add">+	if (mc.to) {</span>
<span class="p_add">+		mem_cgroup_move_charge();</span>
 		mem_cgroup_clear_mc();
<span class="p_add">+	}</span>
 }
 #else	/* !CONFIG_MMU */
 static int mem_cgroup_can_attach(struct cgroup_taskset *tset)
<span class="p_chunk">@@ -4974,7 +4975,7 @@</span> <span class="p_context"> static int mem_cgroup_can_attach(struct cgroup_taskset *tset)</span>
 static void mem_cgroup_cancel_attach(struct cgroup_taskset *tset)
 {
 }
<span class="p_del">-static void mem_cgroup_move_task(struct cgroup_taskset *tset)</span>
<span class="p_add">+static void mem_cgroup_move_task(void)</span>
 {
 }
 #endif
<span class="p_chunk">@@ -5246,7 +5247,7 @@</span> <span class="p_context"> struct cgroup_subsys memory_cgrp_subsys = {</span>
 	.css_reset = mem_cgroup_css_reset,
 	.can_attach = mem_cgroup_can_attach,
 	.cancel_attach = mem_cgroup_cancel_attach,
<span class="p_del">-	.attach = mem_cgroup_move_task,</span>
<span class="p_add">+	.post_attach = mem_cgroup_move_task,</span>
 	.bind = mem_cgroup_bind,
 	.dfl_cftypes = memory_files,
 	.legacy_cftypes = mem_cgroup_legacy_files,
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 8132787ae4d5..3345dcf862cf 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -792,6 +792,46 @@</span> <span class="p_context"> out:</span>
 	return pfn_to_page(pfn);
 }
 
<span class="p_add">+#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="p_add">+struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,</span>
<span class="p_add">+				pmd_t pmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pfn = pmd_pfn(pmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * There is no pmd_special() but there may be special pmds, e.g.</span>
<span class="p_add">+	 * in a direct-access (dax) mapping, so let&#39;s just replicate the</span>
<span class="p_add">+	 * !HAVE_PTE_SPECIAL case from vm_normal_page() here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(vma-&gt;vm_flags &amp; (VM_PFNMAP|VM_MIXEDMAP))) {</span>
<span class="p_add">+		if (vma-&gt;vm_flags &amp; VM_MIXEDMAP) {</span>
<span class="p_add">+			if (!pfn_valid(pfn))</span>
<span class="p_add">+				return NULL;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			unsigned long off;</span>
<span class="p_add">+			off = (addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+			if (pfn == vma-&gt;vm_pgoff + off)</span>
<span class="p_add">+				return NULL;</span>
<span class="p_add">+			if (!is_cow_mapping(vma-&gt;vm_flags))</span>
<span class="p_add">+				return NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_zero_pfn(pfn))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	if (unlikely(pfn &gt; highest_memmap_pfn))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * NOTE! We still have PageReserved() pages in the page tables.</span>
<span class="p_add">+	 * eg. VDSO mappings can cause them to exist.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return pfn_to_page(pfn);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * copy one vm_area from one task to the other. Assumes the page tables
  * already present in the new task to be cleared in the whole range
<span class="p_header">diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="p_header">index 3ad0fea5c438..625741faa068 100644</span>
<span class="p_header">--- a/mm/migrate.c</span>
<span class="p_header">+++ b/mm/migrate.c</span>
<span class="p_chunk">@@ -967,7 +967,13 @@</span> <span class="p_context"> out:</span>
 		dec_zone_page_state(page, NR_ISOLATED_ANON +
 				page_is_file_cache(page));
 		/* Soft-offlined page shouldn&#39;t go through lru cache list */
<span class="p_del">-		if (reason == MR_MEMORY_FAILURE) {</span>
<span class="p_add">+		if (reason == MR_MEMORY_FAILURE &amp;&amp; rc == MIGRATEPAGE_SUCCESS) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * With this release, we free successfully migrated</span>
<span class="p_add">+			 * page and set PG_HWPoison on just freed page</span>
<span class="p_add">+			 * intentionally. Although it&#39;s rather weird, it&#39;s how</span>
<span class="p_add">+			 * HWPoison flag works at the moment.</span>
<span class="p_add">+			 */</span>
 			put_page(page);
 			if (!test_set_page_hwpoison(page))
 				num_poisoned_pages_inc();
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index d8fbd4a6ed59..2a722e141958 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -2815,6 +2815,7 @@</span> <span class="p_context"> struct detached_freelist {</span>
 	void *tail;
 	void *freelist;
 	int cnt;
<span class="p_add">+	struct kmem_cache *s;</span>
 };
 
 /*
<span class="p_chunk">@@ -2829,8 +2830,9 @@</span> <span class="p_context"> struct detached_freelist {</span>
  * synchronization primitive.  Look ahead in the array is limited due
  * to performance reasons.
  */
<span class="p_del">-static int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
<span class="p_del">-				   void **p, struct detached_freelist *df)</span>
<span class="p_add">+static inline</span>
<span class="p_add">+int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
<span class="p_add">+			    void **p, struct detached_freelist *df)</span>
 {
 	size_t first_skipped_index = 0;
 	int lookahead = 3;
<span class="p_chunk">@@ -2846,8 +2848,11 @@</span> <span class="p_context"> static int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
 	if (!object)
 		return 0;
 
<span class="p_add">+	/* Support for memcg, compiler can optimize this out */</span>
<span class="p_add">+	df-&gt;s = cache_from_obj(s, object);</span>
<span class="p_add">+</span>
 	/* Start new detached freelist */
<span class="p_del">-	set_freepointer(s, object, NULL);</span>
<span class="p_add">+	set_freepointer(df-&gt;s, object, NULL);</span>
 	df-&gt;page = virt_to_head_page(object);
 	df-&gt;tail = object;
 	df-&gt;freelist = object;
<span class="p_chunk">@@ -2862,7 +2867,7 @@</span> <span class="p_context"> static int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
 		/* df-&gt;page is always set at this point */
 		if (df-&gt;page == virt_to_head_page(object)) {
 			/* Opportunity build freelist */
<span class="p_del">-			set_freepointer(s, object, df-&gt;freelist);</span>
<span class="p_add">+			set_freepointer(df-&gt;s, object, df-&gt;freelist);</span>
 			df-&gt;freelist = object;
 			df-&gt;cnt++;
 			p[size] = NULL; /* mark object processed */
<span class="p_chunk">@@ -2881,25 +2886,20 @@</span> <span class="p_context"> static int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
 	return first_skipped_index;
 }
 
<span class="p_del">-</span>
 /* Note that interrupts must be enabled when calling this function. */
<span class="p_del">-void kmem_cache_free_bulk(struct kmem_cache *orig_s, size_t size, void **p)</span>
<span class="p_add">+void kmem_cache_free_bulk(struct kmem_cache *s, size_t size, void **p)</span>
 {
 	if (WARN_ON(!size))
 		return;
 
 	do {
 		struct detached_freelist df;
<span class="p_del">-		struct kmem_cache *s;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Support for memcg */</span>
<span class="p_del">-		s = cache_from_obj(orig_s, p[size - 1]);</span>
 
 		size = build_detached_freelist(s, size, p, &amp;df);
 		if (unlikely(!df.page))
 			continue;
 
<span class="p_del">-		slab_free(s, df.page, df.freelist, df.tail, df.cnt, _RET_IP_);</span>
<span class="p_add">+		slab_free(df.s, df.page, df.freelist, df.tail, df.cnt,_RET_IP_);</span>
 	} while (likely(size));
 }
 EXPORT_SYMBOL(kmem_cache_free_bulk);
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index 71b1c29948db..c712b016e0ab 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -2561,7 +2561,7 @@</span> <span class="p_context"> static bool shrink_zones(struct zonelist *zonelist, struct scan_control *sc)</span>
 		sc-&gt;gfp_mask |= __GFP_HIGHMEM;
 
 	for_each_zone_zonelist_nodemask(zone, z, zonelist,
<span class="p_del">-					requested_highidx, sc-&gt;nodemask) {</span>
<span class="p_add">+					gfp_zone(sc-&gt;gfp_mask), sc-&gt;nodemask) {</span>
 		enum zone_type classzone_idx;
 
 		if (!populated_zone(zone))
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index f1ffb34e253f..d2bc03f0b4d7 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -1305,7 +1305,7 @@</span> <span class="p_context"> static int netlink_release(struct socket *sock)</span>
 
 	skb_queue_purge(&amp;sk-&gt;sk_write_queue);
 
<span class="p_del">-	if (nlk-&gt;portid) {</span>
<span class="p_add">+	if (nlk-&gt;portid &amp;&amp; nlk-&gt;bound) {</span>
 		struct netlink_notify n = {
 						.net = sock_net(sk),
 						.protocol = sk-&gt;sk_protocol,
<span class="p_header">diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c</span>
<span class="p_header">index 273bc3a35425..008c25d1b9f9 100644</span>
<span class="p_header">--- a/net/sunrpc/cache.c</span>
<span class="p_header">+++ b/net/sunrpc/cache.c</span>
<span class="p_chunk">@@ -1182,14 +1182,14 @@</span> <span class="p_context"> int sunrpc_cache_pipe_upcall(struct cache_detail *detail, struct cache_head *h)</span>
 	}
 
 	crq-&gt;q.reader = 0;
<span class="p_del">-	crq-&gt;item = cache_get(h);</span>
 	crq-&gt;buf = buf;
 	crq-&gt;len = 0;
 	crq-&gt;readers = 0;
 	spin_lock(&amp;queue_lock);
<span class="p_del">-	if (test_bit(CACHE_PENDING, &amp;h-&gt;flags))</span>
<span class="p_add">+	if (test_bit(CACHE_PENDING, &amp;h-&gt;flags)) {</span>
<span class="p_add">+		crq-&gt;item = cache_get(h);</span>
 		list_add_tail(&amp;crq-&gt;q.list, &amp;detail-&gt;queue);
<span class="p_del">-	else</span>
<span class="p_add">+	} else</span>
 		/* Lost a race, no longer PENDING, so don&#39;t enqueue */
 		ret = -EAGAIN;
 	spin_unlock(&amp;queue_lock);
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 711cb7ad6ae0..ab62d305b48b 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -13201,7 +13201,7 @@</span> <span class="p_context"> static int nl80211_netlink_notify(struct notifier_block * nb,</span>
 	struct wireless_dev *wdev;
 	struct cfg80211_beacon_registration *reg, *tmp;
 
<span class="p_del">-	if (state != NETLINK_URELEASE)</span>
<span class="p_add">+	if (state != NETLINK_URELEASE || notify-&gt;protocol != NETLINK_GENERIC)</span>
 		return NOTIFY_DONE;
 
 	rcu_read_lock();
<span class="p_header">diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c</span>
<span class="p_header">index 0b7dc2fd7bac..dd243d2abd87 100644</span>
<span class="p_header">--- a/scripts/kconfig/confdata.c</span>
<span class="p_header">+++ b/scripts/kconfig/confdata.c</span>
<span class="p_chunk">@@ -267,10 +267,8 @@</span> <span class="p_context"> int conf_read_simple(const char *name, int def)</span>
 		if (in)
 			goto load;
 		sym_add_change_count(1);
<span class="p_del">-		if (!sym_defconfig_list) {</span>
<span class="p_del">-			sym_calc_value(modules_sym);</span>
<span class="p_add">+		if (!sym_defconfig_list)</span>
 			return 1;
<span class="p_del">-		}</span>
 
 		for_all_defaults(sym_defconfig_list, prop) {
 			if (expr_calc_value(prop-&gt;visible.expr) == no ||
<span class="p_chunk">@@ -403,7 +401,6 @@</span> <span class="p_context"> setsym:</span>
 	}
 	free(line);
 	fclose(in);
<span class="p_del">-	sym_calc_value(modules_sym);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -414,8 +411,12 @@</span> <span class="p_context"> int conf_read(const char *name)</span>
 
 	sym_set_change_count(0);
 
<span class="p_del">-	if (conf_read_simple(name, S_DEF_USER))</span>
<span class="p_add">+	if (conf_read_simple(name, S_DEF_USER)) {</span>
<span class="p_add">+		sym_calc_value(modules_sym);</span>
 		return 1;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	sym_calc_value(modules_sym);</span>
 
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
<span class="p_chunk">@@ -846,6 +847,7 @@</span> <span class="p_context"> static int conf_split_config(void)</span>
 
 	name = conf_get_autoconfig_name();
 	conf_read_simple(name, S_DEF_AUTO);
<span class="p_add">+	sym_calc_value(modules_sym);</span>
 
 	if (chdir(&quot;include/config&quot;))
 		return 1;
<span class="p_header">diff --git a/security/keys/trusted.c b/security/keys/trusted.c</span>
<span class="p_header">index 0dcab20cdacd..90d61751ff12 100644</span>
<span class="p_header">--- a/security/keys/trusted.c</span>
<span class="p_header">+++ b/security/keys/trusted.c</span>
<span class="p_chunk">@@ -744,6 +744,7 @@</span> <span class="p_context"> static int getoptions(char *c, struct trusted_key_payload *pay,</span>
 	unsigned long handle;
 	unsigned long lock;
 	unsigned long token_mask = 0;
<span class="p_add">+	unsigned int digest_len;</span>
 	int i;
 	int tpm2;
 
<span class="p_chunk">@@ -752,7 +753,6 @@</span> <span class="p_context"> static int getoptions(char *c, struct trusted_key_payload *pay,</span>
 		return tpm2;
 
 	opt-&gt;hash = tpm2 ? HASH_ALGO_SHA256 : HASH_ALGO_SHA1;
<span class="p_del">-	opt-&gt;digest_len = hash_digest_size[opt-&gt;hash];</span>
 
 	while ((p = strsep(&amp;c, &quot; \t&quot;))) {
 		if (*p == &#39;\0&#39; || *p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="p_chunk">@@ -812,8 +812,6 @@</span> <span class="p_context"> static int getoptions(char *c, struct trusted_key_payload *pay,</span>
 			for (i = 0; i &lt; HASH_ALGO__LAST; i++) {
 				if (!strcmp(args[0].from, hash_algo_name[i])) {
 					opt-&gt;hash = i;
<span class="p_del">-					opt-&gt;digest_len =</span>
<span class="p_del">-						hash_digest_size[opt-&gt;hash];</span>
 					break;
 				}
 			}
<span class="p_chunk">@@ -825,13 +823,14 @@</span> <span class="p_context"> static int getoptions(char *c, struct trusted_key_payload *pay,</span>
 			}
 			break;
 		case Opt_policydigest:
<span class="p_del">-			if (!tpm2 ||</span>
<span class="p_del">-			    strlen(args[0].from) != (2 * opt-&gt;digest_len))</span>
<span class="p_add">+			digest_len = hash_digest_size[opt-&gt;hash];</span>
<span class="p_add">+			if (!tpm2 || strlen(args[0].from) != (2 * digest_len))</span>
 				return -EINVAL;
 			res = hex2bin(opt-&gt;policydigest, args[0].from,
<span class="p_del">-				      opt-&gt;digest_len);</span>
<span class="p_add">+				      digest_len);</span>
 			if (res &lt; 0)
 				return -EINVAL;
<span class="p_add">+			opt-&gt;policydigest_len = digest_len;</span>
 			break;
 		case Opt_policyhandle:
 			if (!tpm2)
<span class="p_header">diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c</span>
<span class="p_header">index f6854dbd7d8d..69ead7150a5c 100644</span>
<span class="p_header">--- a/sound/hda/hdac_i915.c</span>
<span class="p_header">+++ b/sound/hda/hdac_i915.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;sound/core.h&gt;
 #include &lt;sound/hdaudio.h&gt;
 #include &lt;sound/hda_i915.h&gt;
<span class="p_add">+#include &lt;sound/hda_register.h&gt;</span>
 
 static struct i915_audio_component *hdac_acomp;
 
<span class="p_chunk">@@ -97,26 +98,65 @@</span> <span class="p_context"> int snd_hdac_display_power(struct hdac_bus *bus, bool enable)</span>
 }
 EXPORT_SYMBOL_GPL(snd_hdac_display_power);
 
<span class="p_add">+#define CONTROLLER_IN_GPU(pci) (((pci)-&gt;device == 0x0a0c) || \</span>
<span class="p_add">+				((pci)-&gt;device == 0x0c0c) || \</span>
<span class="p_add">+				((pci)-&gt;device == 0x0d0c) || \</span>
<span class="p_add">+				((pci)-&gt;device == 0x160c))</span>
<span class="p_add">+</span>
 /**
<span class="p_del">- * snd_hdac_get_display_clk - Get CDCLK in kHz</span>
<span class="p_add">+ * snd_hdac_i915_set_bclk - Reprogram BCLK for HSW/BDW</span>
  * @bus: HDA core bus
  *
<span class="p_del">- * This function is supposed to be used only by a HD-audio controller</span>
<span class="p_del">- * driver that needs the interaction with i915 graphics.</span>
<span class="p_add">+ * Intel HSW/BDW display HDA controller is in GPU. Both its power and link BCLK</span>
<span class="p_add">+ * depends on GPU. Two Extended Mode registers EM4 (M value) and EM5 (N Value)</span>
<span class="p_add">+ * are used to convert CDClk (Core Display Clock) to 24MHz BCLK:</span>
<span class="p_add">+ * BCLK = CDCLK * M / N</span>
<span class="p_add">+ * The values will be lost when the display power well is disabled and need to</span>
<span class="p_add">+ * be restored to avoid abnormal playback speed.</span>
  *
<span class="p_del">- * This function queries CDCLK value in kHz from the graphics driver and</span>
<span class="p_del">- * returns the value.  A negative code is returned in error.</span>
<span class="p_add">+ * Call this function at initializing and changing power well, as well as</span>
<span class="p_add">+ * at ELD notifier for the hotplug.</span>
  */
<span class="p_del">-int snd_hdac_get_display_clk(struct hdac_bus *bus)</span>
<span class="p_add">+void snd_hdac_i915_set_bclk(struct hdac_bus *bus)</span>
 {
 	struct i915_audio_component *acomp = bus-&gt;audio_component;
<span class="p_add">+	struct pci_dev *pci = to_pci_dev(bus-&gt;dev);</span>
<span class="p_add">+	int cdclk_freq;</span>
<span class="p_add">+	unsigned int bclk_m, bclk_n;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!acomp || !acomp-&gt;ops || !acomp-&gt;ops-&gt;get_cdclk_freq)</span>
<span class="p_add">+		return; /* only for i915 binding */</span>
<span class="p_add">+	if (!CONTROLLER_IN_GPU(pci))</span>
<span class="p_add">+		return; /* only HSW/BDW */</span>
<span class="p_add">+</span>
<span class="p_add">+	cdclk_freq = acomp-&gt;ops-&gt;get_cdclk_freq(acomp-&gt;dev);</span>
<span class="p_add">+	switch (cdclk_freq) {</span>
<span class="p_add">+	case 337500:</span>
<span class="p_add">+		bclk_m = 16;</span>
<span class="p_add">+		bclk_n = 225;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 450000:</span>
<span class="p_add">+	default: /* default CDCLK 450MHz */</span>
<span class="p_add">+		bclk_m = 4;</span>
<span class="p_add">+		bclk_n = 75;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 540000:</span>
<span class="p_add">+		bclk_m = 4;</span>
<span class="p_add">+		bclk_n = 90;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 675000:</span>
<span class="p_add">+		bclk_m = 8;</span>
<span class="p_add">+		bclk_n = 225;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	if (!acomp || !acomp-&gt;ops)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
<span class="p_del">-	return acomp-&gt;ops-&gt;get_cdclk_freq(acomp-&gt;dev);</span>
<span class="p_add">+	snd_hdac_chip_writew(bus, HSW_EM4, bclk_m);</span>
<span class="p_add">+	snd_hdac_chip_writew(bus, HSW_EM5, bclk_n);</span>
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(snd_hdac_get_display_clk);</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(snd_hdac_i915_set_bclk);</span>
 
 /* There is a fixed mapping between audio pin node and display port
  * on current Intel platforms:
<span class="p_header">diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c</span>
<span class="p_header">index 7ca5b89f088a..dfaf1a93fb8a 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_generic.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_generic.c</span>
<span class="p_chunk">@@ -826,7 +826,7 @@</span> <span class="p_context"> static hda_nid_t path_power_update(struct hda_codec *codec,</span>
 				   bool allow_powerdown)
 {
 	hda_nid_t nid, changed = 0;
<span class="p_del">-	int i, state;</span>
<span class="p_add">+	int i, state, power;</span>
 
 	for (i = 0; i &lt; path-&gt;depth; i++) {
 		nid = path-&gt;path[i];
<span class="p_chunk">@@ -838,7 +838,9 @@</span> <span class="p_context"> static hda_nid_t path_power_update(struct hda_codec *codec,</span>
 			state = AC_PWRST_D0;
 		else
 			state = AC_PWRST_D3;
<span class="p_del">-		if (!snd_hda_check_power_state(codec, nid, state)) {</span>
<span class="p_add">+		power = snd_hda_codec_read(codec, nid, 0,</span>
<span class="p_add">+					   AC_VERB_GET_POWER_STATE, 0);</span>
<span class="p_add">+		if (power != (state | (state &lt;&lt; 4))) {</span>
 			snd_hda_codec_write(codec, nid, 0,
 					    AC_VERB_SET_POWER_STATE, state);
 			changed = nid;
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index e5240cb3749f..c0b772bb49af 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -857,50 +857,6 @@</span> <span class="p_context"> static int param_set_xint(const char *val, const struct kernel_param *kp)</span>
 #define azx_del_card_list(chip) /* NOP */
 #endif /* CONFIG_PM */
 
<span class="p_del">-/* Intel HSW/BDW display HDA controller is in GPU. Both its power and link BCLK</span>
<span class="p_del">- * depends on GPU. Two Extended Mode registers EM4 (M value) and EM5 (N Value)</span>
<span class="p_del">- * are used to convert CDClk (Core Display Clock) to 24MHz BCLK:</span>
<span class="p_del">- * BCLK = CDCLK * M / N</span>
<span class="p_del">- * The values will be lost when the display power well is disabled and need to</span>
<span class="p_del">- * be restored to avoid abnormal playback speed.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void haswell_set_bclk(struct hda_intel *hda)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct azx *chip = &amp;hda-&gt;chip;</span>
<span class="p_del">-	int cdclk_freq;</span>
<span class="p_del">-	unsigned int bclk_m, bclk_n;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!hda-&gt;need_i915_power)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	cdclk_freq = snd_hdac_get_display_clk(azx_bus(chip));</span>
<span class="p_del">-	switch (cdclk_freq) {</span>
<span class="p_del">-	case 337500:</span>
<span class="p_del">-		bclk_m = 16;</span>
<span class="p_del">-		bclk_n = 225;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case 450000:</span>
<span class="p_del">-	default: /* default CDCLK 450MHz */</span>
<span class="p_del">-		bclk_m = 4;</span>
<span class="p_del">-		bclk_n = 75;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case 540000:</span>
<span class="p_del">-		bclk_m = 4;</span>
<span class="p_del">-		bclk_n = 90;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case 675000:</span>
<span class="p_del">-		bclk_m = 8;</span>
<span class="p_del">-		bclk_n = 225;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	azx_writew(chip, HSW_EM4, bclk_m);</span>
<span class="p_del">-	azx_writew(chip, HSW_EM5, bclk_n);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #if defined(CONFIG_PM_SLEEP) || defined(SUPPORT_VGA_SWITCHEROO)
 /*
  * power management
<span class="p_chunk">@@ -958,7 +914,7 @@</span> <span class="p_context"> static int azx_resume(struct device *dev)</span>
 	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL
 		&amp;&amp; hda-&gt;need_i915_power) {
 		snd_hdac_display_power(azx_bus(chip), true);
<span class="p_del">-		haswell_set_bclk(hda);</span>
<span class="p_add">+		snd_hdac_i915_set_bclk(azx_bus(chip));</span>
 	}
 	if (chip-&gt;msi)
 		if (pci_enable_msi(pci) &lt; 0)
<span class="p_chunk">@@ -1058,7 +1014,7 @@</span> <span class="p_context"> static int azx_runtime_resume(struct device *dev)</span>
 		bus = azx_bus(chip);
 		if (hda-&gt;need_i915_power) {
 			snd_hdac_display_power(bus, true);
<span class="p_del">-			haswell_set_bclk(hda);</span>
<span class="p_add">+			snd_hdac_i915_set_bclk(bus);</span>
 		} else {
 			/* toggle codec wakeup bit for STATESTS read */
 			snd_hdac_set_codec_wakeup(bus, true);
<span class="p_chunk">@@ -1796,12 +1752,8 @@</span> <span class="p_context"> static int azx_first_init(struct azx *chip)</span>
 	/* initialize chip */
 	azx_init_pci(chip);
 
<span class="p_del">-	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL) {</span>
<span class="p_del">-		struct hda_intel *hda;</span>
<span class="p_del">-</span>
<span class="p_del">-		hda = container_of(chip, struct hda_intel, chip);</span>
<span class="p_del">-		haswell_set_bclk(hda);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL)</span>
<span class="p_add">+		snd_hdac_i915_set_bclk(bus);</span>
 
 	hda_intel_init_chip(chip, (probe_only[dev] &amp; 2) == 0);
 
<span class="p_chunk">@@ -2232,6 +2184,9 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	/* Broxton-P(Apollolake) */
 	{ PCI_DEVICE(0x8086, 0x5a98),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_BROXTON },
<span class="p_add">+	/* Broxton-T */</span>
<span class="p_add">+	{ PCI_DEVICE(0x8086, 0x1a98),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_BROXTON },</span>
 	/* Haswell */
 	{ PCI_DEVICE(0x8086, 0x0a0c),
 	  .driver_data = AZX_DRIVER_HDMI | AZX_DCAPS_INTEL_HASWELL },
<span class="p_header">diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">index a47e8ae0eb30..80bbadc83721 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_chunk">@@ -361,6 +361,7 @@</span> <span class="p_context"> static int cs_parse_auto_config(struct hda_codec *codec)</span>
 {
 	struct cs_spec *spec = codec-&gt;spec;
 	int err;
<span class="p_add">+	int i;</span>
 
 	err = snd_hda_parse_pin_defcfg(codec, &amp;spec-&gt;gen.autocfg, NULL, 0);
 	if (err &lt; 0)
<span class="p_chunk">@@ -370,6 +371,19 @@</span> <span class="p_context"> static int cs_parse_auto_config(struct hda_codec *codec)</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_add">+	/* keep the ADCs powered up when it&#39;s dynamically switchable */</span>
<span class="p_add">+	if (spec-&gt;gen.dyn_adc_switch) {</span>
<span class="p_add">+		unsigned int done = 0;</span>
<span class="p_add">+		for (i = 0; i &lt; spec-&gt;gen.input_mux.num_items; i++) {</span>
<span class="p_add">+			int idx = spec-&gt;gen.dyn_adc_idx[i];</span>
<span class="p_add">+			if (done &amp; (1 &lt;&lt; idx))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			snd_hda_gen_fix_pin_power(codec,</span>
<span class="p_add">+						  spec-&gt;gen.adc_nids[idx]);</span>
<span class="p_add">+			done |= 1 &lt;&lt; idx;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index 0c9585602bf3..c98e404afbe0 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -2452,6 +2452,7 @@</span> <span class="p_context"> static void intel_pin_eld_notify(void *audio_ptr, int port)</span>
 	if (atomic_read(&amp;(codec)-&gt;core.in_pm))
 		return;
 
<span class="p_add">+	snd_hdac_i915_set_bclk(&amp;codec-&gt;bus-&gt;core);</span>
 	check_presence_and_report(codec, pin_nid);
 }
 
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 1402ba954b3d..ac4490a96863 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5449,6 +5449,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x064a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x064b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0665, &quot;Dell XPS 13&quot;, ALC288_FIXUP_DELL_XPS_13),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x0669, &quot;Dell Optiplex 9020m&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),</span>
 	SND_PCI_QUIRK(0x1028, 0x069a, &quot;Dell Vostro 5480&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),
 	SND_PCI_QUIRK(0x1028, 0x06c7, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06d9, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_chunk">@@ -5583,6 +5584,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x5034, &quot;Thinkpad T450&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5036, &quot;Thinkpad T450s&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x503c, &quot;Thinkpad L450&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x504a, &quot;ThinkPad X260&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x504b, &quot;Thinkpad&quot;, ALC293_FIXUP_LENOVO_SPK_NOISE),
 	SND_PCI_QUIRK(0x17aa, 0x5109, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x3bf8, &quot;Quanta FL1&quot;, ALC269_FIXUP_PCM_44K),
<span class="p_header">diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c</span>
<span class="p_header">index c5194f5b150a..d7e71f309299 100644</span>
<span class="p_header">--- a/sound/pci/pcxhr/pcxhr_core.c</span>
<span class="p_header">+++ b/sound/pci/pcxhr/pcxhr_core.c</span>
<span class="p_chunk">@@ -1341,5 +1341,6 @@</span> <span class="p_context"> irqreturn_t pcxhr_threaded_irq(int irq, void *dev_id)</span>
 	}
 
 	pcxhr_msg_thread(mgr);
<span class="p_add">+	mutex_unlock(&amp;mgr-&gt;lock);</span>
 	return IRQ_HANDLED;
 }
<span class="p_header">diff --git a/sound/soc/codecs/rt5640.c b/sound/soc/codecs/rt5640.c</span>
<span class="p_header">index 11d032cdc658..48dbb2fdeb09 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5640.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5640.c</span>
<span class="p_chunk">@@ -359,7 +359,7 @@</span> <span class="p_context"> static const DECLARE_TLV_DB_RANGE(bst_tlv,</span>
 
 /* Interface data select */
 static const char * const rt5640_data_select[] = {
<span class="p_del">-	&quot;Normal&quot;, &quot;left copy to right&quot;, &quot;right copy to left&quot;, &quot;Swap&quot;};</span>
<span class="p_add">+	&quot;Normal&quot;, &quot;Swap&quot;, &quot;left copy to right&quot;, &quot;right copy to left&quot;};</span>
 
 static SOC_ENUM_SINGLE_DECL(rt5640_if1_dac_enum, RT5640_DIG_INF_DATA,
 			    RT5640_IF1_DAC_SEL_SFT, rt5640_data_select);
<span class="p_header">diff --git a/sound/soc/codecs/rt5640.h b/sound/soc/codecs/rt5640.h</span>
<span class="p_header">index 83a7150ddc24..f84231e7d1dd 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5640.h</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5640.h</span>
<span class="p_chunk">@@ -442,39 +442,39 @@</span> <span class="p_context"></span>
 #define RT5640_IF1_DAC_SEL_MASK			(0x3 &lt;&lt; 14)
 #define RT5640_IF1_DAC_SEL_SFT			14
 #define RT5640_IF1_DAC_SEL_NOR			(0x0 &lt;&lt; 14)
<span class="p_del">-#define RT5640_IF1_DAC_SEL_L2R			(0x1 &lt;&lt; 14)</span>
<span class="p_del">-#define RT5640_IF1_DAC_SEL_R2L			(0x2 &lt;&lt; 14)</span>
<span class="p_del">-#define RT5640_IF1_DAC_SEL_SWAP			(0x3 &lt;&lt; 14)</span>
<span class="p_add">+#define RT5640_IF1_DAC_SEL_SWAP			(0x1 &lt;&lt; 14)</span>
<span class="p_add">+#define RT5640_IF1_DAC_SEL_L2R			(0x2 &lt;&lt; 14)</span>
<span class="p_add">+#define RT5640_IF1_DAC_SEL_R2L			(0x3 &lt;&lt; 14)</span>
 #define RT5640_IF1_ADC_SEL_MASK			(0x3 &lt;&lt; 12)
 #define RT5640_IF1_ADC_SEL_SFT			12
 #define RT5640_IF1_ADC_SEL_NOR			(0x0 &lt;&lt; 12)
<span class="p_del">-#define RT5640_IF1_ADC_SEL_L2R			(0x1 &lt;&lt; 12)</span>
<span class="p_del">-#define RT5640_IF1_ADC_SEL_R2L			(0x2 &lt;&lt; 12)</span>
<span class="p_del">-#define RT5640_IF1_ADC_SEL_SWAP			(0x3 &lt;&lt; 12)</span>
<span class="p_add">+#define RT5640_IF1_ADC_SEL_SWAP			(0x1 &lt;&lt; 12)</span>
<span class="p_add">+#define RT5640_IF1_ADC_SEL_L2R			(0x2 &lt;&lt; 12)</span>
<span class="p_add">+#define RT5640_IF1_ADC_SEL_R2L			(0x3 &lt;&lt; 12)</span>
 #define RT5640_IF2_DAC_SEL_MASK			(0x3 &lt;&lt; 10)
 #define RT5640_IF2_DAC_SEL_SFT			10
 #define RT5640_IF2_DAC_SEL_NOR			(0x0 &lt;&lt; 10)
<span class="p_del">-#define RT5640_IF2_DAC_SEL_L2R			(0x1 &lt;&lt; 10)</span>
<span class="p_del">-#define RT5640_IF2_DAC_SEL_R2L			(0x2 &lt;&lt; 10)</span>
<span class="p_del">-#define RT5640_IF2_DAC_SEL_SWAP			(0x3 &lt;&lt; 10)</span>
<span class="p_add">+#define RT5640_IF2_DAC_SEL_SWAP			(0x1 &lt;&lt; 10)</span>
<span class="p_add">+#define RT5640_IF2_DAC_SEL_L2R			(0x2 &lt;&lt; 10)</span>
<span class="p_add">+#define RT5640_IF2_DAC_SEL_R2L			(0x3 &lt;&lt; 10)</span>
 #define RT5640_IF2_ADC_SEL_MASK			(0x3 &lt;&lt; 8)
 #define RT5640_IF2_ADC_SEL_SFT			8
 #define RT5640_IF2_ADC_SEL_NOR			(0x0 &lt;&lt; 8)
<span class="p_del">-#define RT5640_IF2_ADC_SEL_L2R			(0x1 &lt;&lt; 8)</span>
<span class="p_del">-#define RT5640_IF2_ADC_SEL_R2L			(0x2 &lt;&lt; 8)</span>
<span class="p_del">-#define RT5640_IF2_ADC_SEL_SWAP			(0x3 &lt;&lt; 8)</span>
<span class="p_add">+#define RT5640_IF2_ADC_SEL_SWAP			(0x1 &lt;&lt; 8)</span>
<span class="p_add">+#define RT5640_IF2_ADC_SEL_L2R			(0x2 &lt;&lt; 8)</span>
<span class="p_add">+#define RT5640_IF2_ADC_SEL_R2L			(0x3 &lt;&lt; 8)</span>
 #define RT5640_IF3_DAC_SEL_MASK			(0x3 &lt;&lt; 6)
 #define RT5640_IF3_DAC_SEL_SFT			6
 #define RT5640_IF3_DAC_SEL_NOR			(0x0 &lt;&lt; 6)
<span class="p_del">-#define RT5640_IF3_DAC_SEL_L2R			(0x1 &lt;&lt; 6)</span>
<span class="p_del">-#define RT5640_IF3_DAC_SEL_R2L			(0x2 &lt;&lt; 6)</span>
<span class="p_del">-#define RT5640_IF3_DAC_SEL_SWAP			(0x3 &lt;&lt; 6)</span>
<span class="p_add">+#define RT5640_IF3_DAC_SEL_SWAP			(0x1 &lt;&lt; 6)</span>
<span class="p_add">+#define RT5640_IF3_DAC_SEL_L2R			(0x2 &lt;&lt; 6)</span>
<span class="p_add">+#define RT5640_IF3_DAC_SEL_R2L			(0x3 &lt;&lt; 6)</span>
 #define RT5640_IF3_ADC_SEL_MASK			(0x3 &lt;&lt; 4)
 #define RT5640_IF3_ADC_SEL_SFT			4
 #define RT5640_IF3_ADC_SEL_NOR			(0x0 &lt;&lt; 4)
<span class="p_del">-#define RT5640_IF3_ADC_SEL_L2R			(0x1 &lt;&lt; 4)</span>
<span class="p_del">-#define RT5640_IF3_ADC_SEL_R2L			(0x2 &lt;&lt; 4)</span>
<span class="p_del">-#define RT5640_IF3_ADC_SEL_SWAP			(0x3 &lt;&lt; 4)</span>
<span class="p_add">+#define RT5640_IF3_ADC_SEL_SWAP			(0x1 &lt;&lt; 4)</span>
<span class="p_add">+#define RT5640_IF3_ADC_SEL_L2R			(0x2 &lt;&lt; 4)</span>
<span class="p_add">+#define RT5640_IF3_ADC_SEL_R2L			(0x3 &lt;&lt; 4)</span>
 
 /* REC Left Mixer Control 1 (0x3b) */
 #define RT5640_G_HP_L_RM_L_MASK			(0x7 &lt;&lt; 13)
<span class="p_header">diff --git a/sound/soc/codecs/ssm4567.c b/sound/soc/codecs/ssm4567.c</span>
<span class="p_header">index e619d5651b09..080c78e88e10 100644</span>
<span class="p_header">--- a/sound/soc/codecs/ssm4567.c</span>
<span class="p_header">+++ b/sound/soc/codecs/ssm4567.c</span>
<span class="p_chunk">@@ -352,6 +352,11 @@</span> <span class="p_context"> static int ssm4567_set_power(struct ssm4567 *ssm4567, bool enable)</span>
 	regcache_cache_only(ssm4567-&gt;regmap, !enable);
 
 	if (enable) {
<span class="p_add">+		ret = regmap_write(ssm4567-&gt;regmap, SSM4567_REG_SOFT_RESET,</span>
<span class="p_add">+			0x00);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
 		ret = regmap_update_bits(ssm4567-&gt;regmap,
 			SSM4567_REG_POWER_CTRL,
 			SSM4567_POWER_SPWDN, 0x00);
<span class="p_header">diff --git a/sound/soc/samsung/s3c-i2s-v2.c b/sound/soc/samsung/s3c-i2s-v2.c</span>
<span class="p_header">index df65c5b494b1..b6ab3fc5789e 100644</span>
<span class="p_header">--- a/sound/soc/samsung/s3c-i2s-v2.c</span>
<span class="p_header">+++ b/sound/soc/samsung/s3c-i2s-v2.c</span>
<span class="p_chunk">@@ -709,7 +709,7 @@</span> <span class="p_context"> static int s3c2412_i2s_resume(struct snd_soc_dai *dai)</span>
 #endif
 
 int s3c_i2sv2_register_component(struct device *dev, int id,
<span class="p_del">-			   struct snd_soc_component_driver *cmp_drv,</span>
<span class="p_add">+			   const struct snd_soc_component_driver *cmp_drv,</span>
 			   struct snd_soc_dai_driver *dai_drv)
 {
 	struct snd_soc_dai_ops *ops = (struct snd_soc_dai_ops *)dai_drv-&gt;ops;
<span class="p_header">diff --git a/sound/soc/samsung/s3c-i2s-v2.h b/sound/soc/samsung/s3c-i2s-v2.h</span>
<span class="p_header">index 90abab364b49..d0684145ed1f 100644</span>
<span class="p_header">--- a/sound/soc/samsung/s3c-i2s-v2.h</span>
<span class="p_header">+++ b/sound/soc/samsung/s3c-i2s-v2.h</span>
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"> extern int s3c_i2sv2_probe(struct snd_soc_dai *dai,</span>
  * soc core.
  */
 extern int s3c_i2sv2_register_component(struct device *dev, int id,
<span class="p_del">-					struct snd_soc_component_driver *cmp_drv,</span>
<span class="p_add">+					const struct snd_soc_component_driver *cmp_drv,</span>
 					struct snd_soc_dai_driver *dai_drv);
 
 #endif /* __SND_SOC_S3C24XX_S3C_I2SV2_I2S_H */
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index 581175a51ecf..5e811dc02fb9 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -2188,6 +2188,13 @@</span> <span class="p_context"> static ssize_t dapm_widget_show_component(struct snd_soc_component *cmpnt,</span>
 	int count = 0;
 	char *state = &quot;not set&quot;;
 
<span class="p_add">+	/* card won&#39;t be set for the dummy component, as a spot fix</span>
<span class="p_add">+	 * we&#39;re checking for that case specifically here but in future</span>
<span class="p_add">+	 * we will ensure that the dummy component looks like others.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!cmpnt-&gt;card)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	list_for_each_entry(w, &amp;cmpnt-&gt;card-&gt;widgets, list) {
 		if (w-&gt;dapm != dapm)
 			continue;
<span class="p_header">diff --git a/tools/perf/Documentation/perf-stat.txt b/tools/perf/Documentation/perf-stat.txt</span>
<span class="p_header">index 52ef7a9d50aa..14d9e8ffaff7 100644</span>
<span class="p_header">--- a/tools/perf/Documentation/perf-stat.txt</span>
<span class="p_header">+++ b/tools/perf/Documentation/perf-stat.txt</span>
<span class="p_chunk">@@ -69,6 +69,14 @@</span> <span class="p_context"> report::</span>
 --scale::
 	scale/normalize counter values
 
<span class="p_add">+-d::</span>
<span class="p_add">+--detailed::</span>
<span class="p_add">+	print more detailed statistics, can be specified up to 3 times</span>
<span class="p_add">+</span>
<span class="p_add">+	   -d:          detailed events, L1 and LLC data cache</span>
<span class="p_add">+        -d -d:     more detailed events, dTLB and iTLB events</span>
<span class="p_add">+     -d -d -d:     very detailed events, adding prefetch events</span>
<span class="p_add">+</span>
 -r::
 --repeat=&lt;n&gt;::
 	repeat command and print average + stddev (max: 100). 0 means forever.
<span class="p_header">diff --git a/tools/perf/ui/browsers/hists.c b/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">index 08c09ad755d2..7bb47424bc49 100644</span>
<span class="p_header">--- a/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">+++ b/tools/perf/ui/browsers/hists.c</span>
<span class="p_chunk">@@ -302,7 +302,7 @@</span> <span class="p_context"> static void callchain_node__init_have_children(struct callchain_node *node,</span>
 	chain = list_entry(node-&gt;val.next, struct callchain_list, list);
 	chain-&gt;has_children = has_sibling;
 
<span class="p_del">-	if (node-&gt;val.next != node-&gt;val.prev) {</span>
<span class="p_add">+	if (!list_empty(&amp;node-&gt;val)) {</span>
 		chain = list_entry(node-&gt;val.prev, struct callchain_list, list);
 		chain-&gt;has_children = !RB_EMPTY_ROOT(&amp;node-&gt;rb_root);
 	}
<span class="p_chunk">@@ -844,7 +844,7 @@</span> <span class="p_context"> next:</span>
 	return row - first_row;
 }
 
<span class="p_del">-static int hist_browser__show_callchain(struct hist_browser *browser,</span>
<span class="p_add">+static int hist_browser__show_callchain_graph(struct hist_browser *browser,</span>
 					struct rb_root *root, int level,
 					unsigned short row, u64 total,
 					print_callchain_entry_fn print,
<span class="p_chunk">@@ -898,7 +898,7 @@</span> <span class="p_context"> static int hist_browser__show_callchain(struct hist_browser *browser,</span>
 			else
 				new_total = total;
 
<span class="p_del">-			row += hist_browser__show_callchain(browser, &amp;child-&gt;rb_root,</span>
<span class="p_add">+			row += hist_browser__show_callchain_graph(browser, &amp;child-&gt;rb_root,</span>
 							    new_level, row, new_total,
 							    print, arg, is_output_full);
 		}
<span class="p_chunk">@@ -910,6 +910,43 @@</span> <span class="p_context"> out:</span>
 	return row - first_row;
 }
 
<span class="p_add">+static int hist_browser__show_callchain(struct hist_browser *browser,</span>
<span class="p_add">+					struct hist_entry *entry, int level,</span>
<span class="p_add">+					unsigned short row,</span>
<span class="p_add">+					print_callchain_entry_fn print,</span>
<span class="p_add">+					struct callchain_print_arg *arg,</span>
<span class="p_add">+					check_output_full_fn is_output_full)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 total = hists__total_period(entry-&gt;hists);</span>
<span class="p_add">+	int printed;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (callchain_param.mode == CHAIN_GRAPH_REL) {</span>
<span class="p_add">+		if (symbol_conf.cumulate_callchain)</span>
<span class="p_add">+			total = entry-&gt;stat_acc-&gt;period;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			total = entry-&gt;stat.period;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (callchain_param.mode == CHAIN_FLAT) {</span>
<span class="p_add">+		printed = hist_browser__show_callchain_flat(browser,</span>
<span class="p_add">+						&amp;entry-&gt;sorted_chain, row, total,</span>
<span class="p_add">+						print, arg, is_output_full);</span>
<span class="p_add">+	} else if (callchain_param.mode == CHAIN_FOLDED) {</span>
<span class="p_add">+		printed = hist_browser__show_callchain_folded(browser,</span>
<span class="p_add">+						&amp;entry-&gt;sorted_chain, row, total,</span>
<span class="p_add">+						print, arg, is_output_full);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		printed = hist_browser__show_callchain_graph(browser,</span>
<span class="p_add">+						&amp;entry-&gt;sorted_chain, level, row, total,</span>
<span class="p_add">+						print, arg, is_output_full);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (arg-&gt;is_current_entry)</span>
<span class="p_add">+		browser-&gt;he_selection = entry;</span>
<span class="p_add">+</span>
<span class="p_add">+	return printed;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct hpp_arg {
 	struct ui_browser *b;
 	char folded_sign;
<span class="p_chunk">@@ -1084,38 +1121,14 @@</span> <span class="p_context"> static int hist_browser__show_entry(struct hist_browser *browser,</span>
 		--row_offset;
 
 	if (folded_sign == &#39;-&#39; &amp;&amp; row != browser-&gt;b.rows) {
<span class="p_del">-		u64 total = hists__total_period(entry-&gt;hists);</span>
 		struct callchain_print_arg arg = {
 			.row_offset = row_offset,
 			.is_current_entry = current_entry,
 		};
 
<span class="p_del">-		if (callchain_param.mode == CHAIN_GRAPH_REL) {</span>
<span class="p_del">-			if (symbol_conf.cumulate_callchain)</span>
<span class="p_del">-				total = entry-&gt;stat_acc-&gt;period;</span>
<span class="p_del">-			else</span>
<span class="p_del">-				total = entry-&gt;stat.period;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		if (callchain_param.mode == CHAIN_FLAT) {</span>
<span class="p_del">-			printed += hist_browser__show_callchain_flat(browser,</span>
<span class="p_del">-					&amp;entry-&gt;sorted_chain, row, total,</span>
<span class="p_add">+		printed += hist_browser__show_callchain(browser, entry, 1, row,</span>
 					hist_browser__show_callchain_entry, &amp;arg,
 					hist_browser__check_output_full);
<span class="p_del">-		} else if (callchain_param.mode == CHAIN_FOLDED) {</span>
<span class="p_del">-			printed += hist_browser__show_callchain_folded(browser,</span>
<span class="p_del">-					&amp;entry-&gt;sorted_chain, row, total,</span>
<span class="p_del">-					hist_browser__show_callchain_entry, &amp;arg,</span>
<span class="p_del">-					hist_browser__check_output_full);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			printed += hist_browser__show_callchain(browser,</span>
<span class="p_del">-					&amp;entry-&gt;sorted_chain, 1, row, total,</span>
<span class="p_del">-					hist_browser__show_callchain_entry, &amp;arg,</span>
<span class="p_del">-					hist_browser__check_output_full);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		if (arg.is_current_entry)</span>
<span class="p_del">-			browser-&gt;he_selection = entry;</span>
 	}
 
 	return printed;
<span class="p_chunk">@@ -1380,15 +1393,11 @@</span> <span class="p_context"> do_offset:</span>
 static int hist_browser__fprintf_callchain(struct hist_browser *browser,
 					   struct hist_entry *he, FILE *fp)
 {
<span class="p_del">-	u64 total = hists__total_period(he-&gt;hists);</span>
 	struct callchain_print_arg arg  = {
 		.fp = fp,
 	};
 
<span class="p_del">-	if (symbol_conf.cumulate_callchain)</span>
<span class="p_del">-		total = he-&gt;stat_acc-&gt;period;</span>
<span class="p_del">-</span>
<span class="p_del">-	hist_browser__show_callchain(browser, &amp;he-&gt;sorted_chain, 1, 0, total,</span>
<span class="p_add">+	hist_browser__show_callchain(browser, he, 1, 0,</span>
 				     hist_browser__fprintf_callchain_entry, &amp;arg,
 				     hist_browser__check_dump_full);
 	return arg.printed;
<span class="p_chunk">@@ -2320,10 +2329,12 @@</span> <span class="p_context"> skip_annotation:</span>
 			 *
 			 * See hist_browser__show_entry.
 			 */
<span class="p_del">-			nr_options += add_script_opt(browser,</span>
<span class="p_del">-						     &amp;actions[nr_options],</span>
<span class="p_del">-						     &amp;options[nr_options],</span>
<span class="p_del">-						     NULL, browser-&gt;selection-&gt;sym);</span>
<span class="p_add">+			if (sort__has_sym &amp;&amp; browser-&gt;selection-&gt;sym) {</span>
<span class="p_add">+				nr_options += add_script_opt(browser,</span>
<span class="p_add">+							     &amp;actions[nr_options],</span>
<span class="p_add">+							     &amp;options[nr_options],</span>
<span class="p_add">+							     NULL, browser-&gt;selection-&gt;sym);</span>
<span class="p_add">+			}</span>
 		}
 		nr_options += add_script_opt(browser, &amp;actions[nr_options],
 					     &amp;options[nr_options], NULL, NULL);
<span class="p_header">diff --git a/tools/perf/util/event.c b/tools/perf/util/event.c</span>
<span class="p_header">index 85155e91b61b..7bad5c3fa7b7 100644</span>
<span class="p_header">--- a/tools/perf/util/event.c</span>
<span class="p_header">+++ b/tools/perf/util/event.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> int perf_event__synthesize_mmap_events(struct perf_tool *tool,</span>
 		strcpy(execname, &quot;&quot;);
 
 		/* 00400000-0040c000 r-xp 00000000 fd:01 41038  /bin/cat */
<span class="p_del">-		n = sscanf(bf, &quot;%&quot;PRIx64&quot;-%&quot;PRIx64&quot; %s %&quot;PRIx64&quot; %x:%x %u %s\n&quot;,</span>
<span class="p_add">+		n = sscanf(bf, &quot;%&quot;PRIx64&quot;-%&quot;PRIx64&quot; %s %&quot;PRIx64&quot; %x:%x %u %[^\n]\n&quot;,</span>
 		       &amp;event-&gt;mmap2.start, &amp;event-&gt;mmap2.len, prot,
 		       &amp;event-&gt;mmap2.pgoff, &amp;event-&gt;mmap2.maj,
 		       &amp;event-&gt;mmap2.min,
<span class="p_header">diff --git a/tools/perf/util/evlist.c b/tools/perf/util/evlist.c</span>
<span class="p_header">index d81f13de2476..a7eb0eae9938 100644</span>
<span class="p_header">--- a/tools/perf/util/evlist.c</span>
<span class="p_header">+++ b/tools/perf/util/evlist.c</span>
<span class="p_chunk">@@ -1181,12 +1181,12 @@</span> <span class="p_context"> void perf_evlist__set_maps(struct perf_evlist *evlist, struct cpu_map *cpus,</span>
 	 */
 	if (cpus != evlist-&gt;cpus) {
 		cpu_map__put(evlist-&gt;cpus);
<span class="p_del">-		evlist-&gt;cpus = cpus;</span>
<span class="p_add">+		evlist-&gt;cpus = cpu_map__get(cpus);</span>
 	}
 
 	if (threads != evlist-&gt;threads) {
 		thread_map__put(evlist-&gt;threads);
<span class="p_del">-		evlist-&gt;threads = threads;</span>
<span class="p_add">+		evlist-&gt;threads = thread_map__get(threads);</span>
 	}
 
 	perf_evlist__propagate_maps(evlist);
<span class="p_header">diff --git a/tools/perf/util/evsel.h b/tools/perf/util/evsel.h</span>
<span class="p_header">index 8e75434bd01c..4d8037a3d8a4 100644</span>
<span class="p_header">--- a/tools/perf/util/evsel.h</span>
<span class="p_header">+++ b/tools/perf/util/evsel.h</span>
<span class="p_chunk">@@ -93,10 +93,8 @@</span> <span class="p_context"> struct perf_evsel {</span>
 	const char		*unit;
 	struct event_format	*tp_format;
 	off_t			id_offset;
<span class="p_del">-	union {</span>
<span class="p_del">-		void		*priv;</span>
<span class="p_del">-		u64		db_id;</span>
<span class="p_del">-	};</span>
<span class="p_add">+	void			*priv;</span>
<span class="p_add">+	u64			db_id;</span>
 	struct cgroup_sel	*cgrp;
 	void			*handler;
 	struct cpu_map		*cpus;
<span class="p_header">diff --git a/tools/perf/util/intel-pt.c b/tools/perf/util/intel-pt.c</span>
<span class="p_header">index 05d815851be1..4e1590ba8902 100644</span>
<span class="p_header">--- a/tools/perf/util/intel-pt.c</span>
<span class="p_header">+++ b/tools/perf/util/intel-pt.c</span>
<span class="p_chunk">@@ -1127,7 +1127,7 @@</span> <span class="p_context"> static int intel_pt_synth_transaction_sample(struct intel_pt_queue *ptq)</span>
 		pr_err(&quot;Intel Processor Trace: failed to deliver transaction event, error %d\n&quot;,
 		       ret);
 
<span class="p_del">-	if (pt-&gt;synth_opts.callchain)</span>
<span class="p_add">+	if (pt-&gt;synth_opts.last_branch)</span>
 		intel_pt_reset_last_branch_rb(ptq);
 
 	return ret;
<span class="p_header">diff --git a/virt/kvm/arm/arch_timer.c b/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">index ea6064696fe4..a7b9022b5c8f 100644</span>
<span class="p_header">--- a/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">+++ b/virt/kvm/arm/arch_timer.c</span>
<span class="p_chunk">@@ -86,6 +86,8 @@</span> <span class="p_context"> static void kvm_timer_inject_irq_work(struct work_struct *work)</span>
 	vcpu = container_of(work, struct kvm_vcpu, arch.timer_cpu.expired);
 	vcpu-&gt;arch.timer_cpu.armed = false;
 
<span class="p_add">+	WARN_ON(!kvm_timer_should_fire(vcpu));</span>
<span class="p_add">+</span>
 	/*
 	 * If the vcpu is blocked we want to wake it up so that it will see
 	 * the timer has expired when entering the guest.
<span class="p_chunk">@@ -93,10 +95,46 @@</span> <span class="p_context"> static void kvm_timer_inject_irq_work(struct work_struct *work)</span>
 	kvm_vcpu_kick(vcpu);
 }
 
<span class="p_add">+static u64 kvm_timer_compute_delta(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cycle_t cval, now;</span>
<span class="p_add">+</span>
<span class="p_add">+	cval = vcpu-&gt;arch.timer_cpu.cntv_cval;</span>
<span class="p_add">+	now = kvm_phys_timer_read() - vcpu-&gt;kvm-&gt;arch.timer.cntvoff;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (now &lt; cval) {</span>
<span class="p_add">+		u64 ns;</span>
<span class="p_add">+</span>
<span class="p_add">+		ns = cyclecounter_cyc2ns(timecounter-&gt;cc,</span>
<span class="p_add">+					 cval - now,</span>
<span class="p_add">+					 timecounter-&gt;mask,</span>
<span class="p_add">+					 &amp;timecounter-&gt;frac);</span>
<span class="p_add">+		return ns;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static enum hrtimer_restart kvm_timer_expire(struct hrtimer *hrt)
 {
 	struct arch_timer_cpu *timer;
<span class="p_add">+	struct kvm_vcpu *vcpu;</span>
<span class="p_add">+	u64 ns;</span>
<span class="p_add">+</span>
 	timer = container_of(hrt, struct arch_timer_cpu, timer);
<span class="p_add">+	vcpu = container_of(timer, struct kvm_vcpu, arch.timer_cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check that the timer has really expired from the guest&#39;s</span>
<span class="p_add">+	 * PoV (NTP on the host may have forced it to expire</span>
<span class="p_add">+	 * early). If we should have slept longer, restart it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ns = kvm_timer_compute_delta(vcpu);</span>
<span class="p_add">+	if (unlikely(ns)) {</span>
<span class="p_add">+		hrtimer_forward_now(hrt, ns_to_ktime(ns));</span>
<span class="p_add">+		return HRTIMER_RESTART;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	queue_work(wqueue, &amp;timer-&gt;expired);
 	return HRTIMER_NORESTART;
 }
<span class="p_chunk">@@ -170,8 +208,6 @@</span> <span class="p_context"> static int kvm_timer_update_state(struct kvm_vcpu *vcpu)</span>
 void kvm_timer_schedule(struct kvm_vcpu *vcpu)
 {
 	struct arch_timer_cpu *timer = &amp;vcpu-&gt;arch.timer_cpu;
<span class="p_del">-	u64 ns;</span>
<span class="p_del">-	cycle_t cval, now;</span>
 
 	BUG_ON(timer_is_armed(timer));
 
<span class="p_chunk">@@ -191,14 +227,7 @@</span> <span class="p_context"> void kvm_timer_schedule(struct kvm_vcpu *vcpu)</span>
 		return;
 
 	/*  The timer has not yet expired, schedule a background timer */
<span class="p_del">-	cval = timer-&gt;cntv_cval;</span>
<span class="p_del">-	now = kvm_phys_timer_read() - vcpu-&gt;kvm-&gt;arch.timer.cntvoff;</span>
<span class="p_del">-</span>
<span class="p_del">-	ns = cyclecounter_cyc2ns(timecounter-&gt;cc,</span>
<span class="p_del">-				 cval - now,</span>
<span class="p_del">-				 timecounter-&gt;mask,</span>
<span class="p_del">-				 &amp;timecounter-&gt;frac);</span>
<span class="p_del">-	timer_arm(timer, ns);</span>
<span class="p_add">+	timer_arm(timer, kvm_timer_compute_delta(vcpu));</span>
 }
 
 void kvm_timer_unschedule(struct kvm_vcpu *vcpu)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



