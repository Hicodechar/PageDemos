
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.14.49 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.14.49</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 3, 2015, 6:04 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150803180433.GB4618@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6932381/mbox/"
   >mbox</a>
|
   <a href="/patch/6932381/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6932381/">/patch/6932381/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id BEEBB9F373
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 18:05:17 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 3BD6D20641
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 18:05:10 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 5338320638
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 18:05:01 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932114AbbHCSEn (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 3 Aug 2015 14:04:43 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:37292 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1754391AbbHCSEf (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 3 Aug 2015 14:04:35 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 22A8E7AD;
	Mon,  3 Aug 2015 18:04:34 +0000 (UTC)
Date: Mon, 3 Aug 2015 11:04:33 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.14.49
Message-ID: &lt;20150803180433.GB4618@kroah.com&gt;
References: &lt;20150803180428.GA4618@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150803180428.GA4618@kroah.com&gt;
User-Agent: Mutt/1.5.23+102 (2ca89bed6448) (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 3, 2015, 6:04 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">index 01ef408e205f..8faff12e7014 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_chunk">@@ -91,5 +91,5 @@</span> <span class="p_context"> mpp61         61       gpo, dev(wen1), uart1(txd), audio(rclk)</span>
 mpp62         62       gpio, dev(a2), uart1(cts), tdm(drx), pcie(clkreq0),
                        audio(mclk), uart0(cts)
 mpp63         63       gpo, spi0(sck), tclk
<span class="p_del">-mpp64         64       gpio, spi0(miso), spi0-1(cs1)</span>
<span class="p_del">-mpp65         65       gpio, spi0(mosi), spi0-1(cs2)</span>
<span class="p_add">+mpp64         64       gpio, spi0(miso), spi0(cs1)</span>
<span class="p_add">+mpp65         65       gpio, spi0(mosi), spi0(cs2)</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">index bfa0a2e5e0cb..86dec67e5450 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_chunk">@@ -41,15 +41,15 @@</span> <span class="p_context"> mpp20         20       gpio, ge0(rxd4), ge1(rxd2), lcd(d20), ptp(clk)</span>
 mpp21         21       gpio, ge0(rxd5), ge1(rxd3), lcd(d21), mem(bat)
 mpp22         22       gpio, ge0(rxd6), ge1(rxctl), lcd(d22), sata0(prsnt)
 mpp23         23       gpio, ge0(rxd7), ge1(rxclk), lcd(d23), sata1(prsnt)
<span class="p_del">-mpp24         24       gpio, lcd(hsync), sata1(prsnt), nf(bootcs-re), tdm(rst)</span>
<span class="p_del">-mpp25         25       gpio, lcd(vsync), sata0(prsnt), nf(bootcs-we), tdm(pclk)</span>
<span class="p_del">-mpp26         26       gpio, lcd(clk), tdm(fsync), vdd(cpu1-pd)</span>
<span class="p_add">+mpp24         24       gpio, lcd(hsync), sata1(prsnt), tdm(rst)</span>
<span class="p_add">+mpp25         25       gpio, lcd(vsync), sata0(prsnt), tdm(pclk)</span>
<span class="p_add">+mpp26         26       gpio, lcd(clk), tdm(fsync)</span>
 mpp27         27       gpio, lcd(e), tdm(dtx), ptp(trig)
 mpp28         28       gpio, lcd(pwm), tdm(drx), ptp(evreq)
<span class="p_del">-mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk), vdd(cpu0-pd)</span>
<span class="p_add">+mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk)</span>
 mpp30         30       gpio, tdm(int1), sd0(clk)
<span class="p_del">-mpp31         31       gpio, tdm(int2), sd0(cmd), vdd(cpu0-pd)</span>
<span class="p_del">-mpp32         32       gpio, tdm(int3), sd0(d0), vdd(cpu1-pd)</span>
<span class="p_add">+mpp31         31       gpio, tdm(int2), sd0(cmd)</span>
<span class="p_add">+mpp32         32       gpio, tdm(int3), sd0(d0)</span>
 mpp33         33       gpio, tdm(int4), sd0(d1), mem(bat)
 mpp34         34       gpio, tdm(int5), sd0(d2), sata0(prsnt)
 mpp35         35       gpio, tdm(int6), sd0(d3), sata1(prsnt)
<span class="p_chunk">@@ -57,21 +57,18 @@</span> <span class="p_context"> mpp36         36       gpio, spi(mosi)</span>
 mpp37         37       gpio, spi(miso)
 mpp38         38       gpio, spi(sck)
 mpp39         39       gpio, spi(cs0)
<span class="p_del">-mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), vdd(cpu1-pd),</span>
<span class="p_del">-                       pcie(clkreq0)</span>
<span class="p_add">+mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), pcie(clkreq0)</span>
 mpp41         41       gpio, spi(cs2), uart2(rts), lcd(vga-vsync), sata1(prsnt),
                        pcie(clkreq1)
<span class="p_del">-mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer),</span>
<span class="p_del">-                       vdd(cpu0-pd)</span>
<span class="p_del">-mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout),</span>
<span class="p_del">-                       vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer)</span>
<span class="p_add">+mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout)</span>
 mpp44         44       gpio, uart2(cts), uart3(rxd), spi(cs4), pcie(clkreq2),
                        mem(bat)
 mpp45         45       gpio, uart2(rts), uart3(txd), spi(cs5), sata1(prsnt)
 mpp46         46       gpio, uart3(rts), uart1(rts), spi(cs6), sata0(prsnt)
 mpp47         47       gpio, uart3(cts), uart1(cts), spi(cs7), pcie(clkreq3),
                        ref(clkout)
<span class="p_del">-mpp48         48       gpio, tclk, dev(burst/last)</span>
<span class="p_add">+mpp48         48       gpio, dev(clkout), dev(burst/last)</span>
 
 * Marvell Armada XP (mv78260 and mv78460 only)
 
<span class="p_chunk">@@ -83,9 +80,9 @@</span> <span class="p_context"> mpp51         51       gpio, dev(ad16)</span>
 mpp52         52       gpio, dev(ad17)
 mpp53         53       gpio, dev(ad18)
 mpp54         54       gpio, dev(ad19)
<span class="p_del">-mpp55         55       gpio, dev(ad20), vdd(cpu0-pd)</span>
<span class="p_del">-mpp56         56       gpio, dev(ad21), vdd(cpu1-pd)</span>
<span class="p_del">-mpp57         57       gpio, dev(ad22), vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp55         55       gpio, dev(ad20)</span>
<span class="p_add">+mpp56         56       gpio, dev(ad21)</span>
<span class="p_add">+mpp57         57       gpio, dev(ad22)</span>
 mpp58         58       gpio, dev(ad23)
 mpp59         59       gpio, dev(ad24)
 mpp60         60       gpio, dev(ad25)
<span class="p_chunk">@@ -95,6 +92,3 @@</span> <span class="p_context"> mpp63         63       gpio, dev(ad28)</span>
 mpp64         64       gpio, dev(ad29)
 mpp65         65       gpio, dev(ad30)
 mpp66         66       gpio, dev(ad31)
<span class="p_del">-</span>
<span class="p_del">-Notes:</span>
<span class="p_del">-* {1} vdd(cpu2-3-pd) only available on mv78460.</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/spi/spi_pl022.txt b/Documentation/devicetree/bindings/spi/spi_pl022.txt</span>
<span class="p_header">index 22ed6797216d..4d1673ca8cf8 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/spi/spi_pl022.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/spi/spi_pl022.txt</span>
<span class="p_chunk">@@ -4,9 +4,9 @@</span> <span class="p_context"> Required properties:</span>
 - compatible : &quot;arm,pl022&quot;, &quot;arm,primecell&quot;
 - reg : Offset and length of the register set for the device
 - interrupts : Should contain SPI controller interrupt
<span class="p_add">+- num-cs : total number of chipselects</span>
 
 Optional properties:
<span class="p_del">-- num-cs : total number of chipselects</span>
 - cs-gpios : should specify GPIOs used for chipselects.
   The gpios will be referred to as reg = &lt;index&gt; in the SPI child nodes.
   If unspecified, a single SPI device without a chip select can be used.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 25393e89051c..fee84602e999 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 48</span>
<span class="p_add">+SUBLEVEL = 49</span>
 EXTRAVERSION =
 NAME = Remembering Coco
 
<span class="p_header">diff --git a/arch/arc/include/asm/cmpxchg.h b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">index 03cd6894855d..90de5c528da2 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_chunk">@@ -25,10 +25,11 @@</span> <span class="p_context"> __cmpxchg(volatile void *ptr, unsigned long expected, unsigned long new)</span>
 	&quot;	scond   %3, [%1]	\n&quot;
 	&quot;	bnz     1b		\n&quot;
 	&quot;2:				\n&quot;
<span class="p_del">-	: &quot;=&amp;r&quot;(prev)</span>
<span class="p_del">-	: &quot;r&quot;(ptr), &quot;ir&quot;(expected),</span>
<span class="p_del">-	  &quot;r&quot;(new) /* can&#39;t be &quot;ir&quot;. scond can&#39;t take limm for &quot;b&quot; */</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_add">+	: &quot;=&amp;r&quot;(prev)	/* Early clobber, to prevent reg reuse */</span>
<span class="p_add">+	: &quot;r&quot;(ptr),	/* Not &quot;m&quot;: llock only supports reg direct addr mode */</span>
<span class="p_add">+	  &quot;ir&quot;(expected),</span>
<span class="p_add">+	  &quot;r&quot;(new)	/* can&#39;t be &quot;ir&quot;. scond can&#39;t take LIMM for &quot;b&quot; */</span>
<span class="p_add">+	: &quot;cc&quot;, &quot;memory&quot;); /* so that gcc knows memory is being written here */</span>
 
 	return prev;
 }
<span class="p_header">diff --git a/arch/arm64/kernel/vdso/Makefile b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">index a268a9af0c2d..a622dd0be9c4 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_chunk">@@ -15,6 +15,10 @@</span> <span class="p_context"> ccflags-y := -shared -fno-common -fno-builtin</span>
 ccflags-y += -nostdlib -Wl,-soname=linux-vdso.so.1 \
 		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
 
<span class="p_add">+# Workaround for bare-metal (ELF) toolchains that neglect to pass -shared</span>
<span class="p_add">+# down to collect2, resulting in silent corruption of the vDSO image.</span>
<span class="p_add">+ccflags-y += -Wl,-shared</span>
<span class="p_add">+</span>
 obj-y += vdso.o
 extra-y += vdso.lds vdso-offsets.h
 CPPFLAGS_vdso.lds += -P -C -U$(ARCH)
<span class="p_header">diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c</span>
<span class="p_header">index baa758d37021..76c1e6cd36fc 100644</span>
<span class="p_header">--- a/arch/arm64/mm/context.c</span>
<span class="p_header">+++ b/arch/arm64/mm/context.c</span>
<span class="p_chunk">@@ -92,6 +92,14 @@</span> <span class="p_context"> static void reset_context(void *info)</span>
 	unsigned int cpu = smp_processor_id();
 	struct mm_struct *mm = current-&gt;active_mm;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * current-&gt;active_mm could be init_mm for the idle thread immediately</span>
<span class="p_add">+	 * after secondary CPU boot or hotplug. TTBR0_EL1 is already set to</span>
<span class="p_add">+	 * the reserved value, so no need to reset any context.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mm == &amp;init_mm)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	smp_rmb();
 	asid = cpu_last_asid + cpu;
 
<span class="p_header">diff --git a/arch/arm64/mm/hugetlbpage.c b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">index 023747bf4dd7..e3a24b75e53c 100644</span>
<span class="p_header">--- a/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -46,13 +46,13 @@</span> <span class="p_context"> struct page *follow_huge_addr(struct mm_struct *mm, unsigned long address,</span>
 
 int pmd_huge(pmd_t pmd)
 {
<span class="p_del">-	return !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
<span class="p_add">+	return pmd_val(pmd) &amp;&amp; !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
 }
 
 int pud_huge(pud_t pud)
 {
 #ifndef __PAGETABLE_PMD_FOLDED
<span class="p_del">-	return !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
<span class="p_add">+	return pud_val(pud) &amp;&amp; !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
 #else
 	return 0;
 #endif
<span class="p_header">diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c</span>
<span class="p_header">index d0b4c2efda90..aeb95a15cc9a 100644</span>
<span class="p_header">--- a/arch/arm64/mm/init.c</span>
<span class="p_header">+++ b/arch/arm64/mm/init.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static void __init free_unused_memmap(void)</span>
 		 * memmap entries are valid from the bank end aligned to
 		 * MAX_ORDER_NR_PAGES.
 		 */
<span class="p_del">-		prev_end = ALIGN(start + __phys_to_pfn(reg-&gt;size),</span>
<span class="p_add">+		prev_end = ALIGN(__phys_to_pfn(reg-&gt;base + reg-&gt;size),</span>
 				 MAX_ORDER_NR_PAGES);
 	}
 
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">index e75ef8219caf..c76f297b7149 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_chunk">@@ -1626,7 +1626,7 @@</span> <span class="p_context"> kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 		if (vcpu-&gt;mmio_needed == 2)
 			*gpr = *(int16_t *) run-&gt;mmio.data;
 		else
<span class="p_del">-			*gpr = *(int16_t *) run-&gt;mmio.data;</span>
<span class="p_add">+			*gpr = *(uint16_t *)run-&gt;mmio.data;</span>
 
 		break;
 	case 1:
<span class="p_header">diff --git a/drivers/acpi/acpica/utxfinit.c b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">index 246ef68681f4..2c3c578faa0a 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_chunk">@@ -175,10 +175,12 @@</span> <span class="p_context"> acpi_status __init acpi_enable_subsystem(u32 flags)</span>
 	 * Obtain a permanent mapping for the FACS. This is required for the
 	 * Global Lock and the Firmware Waking Vector
 	 */
<span class="p_del">-	status = acpi_tb_initialize_facs();</span>
<span class="p_del">-	if (ACPI_FAILURE(status)) {</span>
<span class="p_del">-		ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_del">-		return_ACPI_STATUS(status);</span>
<span class="p_add">+	if (!(flags &amp; ACPI_NO_FACS_INIT)) {</span>
<span class="p_add">+		status = acpi_tb_initialize_facs();</span>
<span class="p_add">+		if (ACPI_FAILURE(status)) {</span>
<span class="p_add">+			ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_add">+			return_ACPI_STATUS(status);</span>
<span class="p_add">+		}</span>
 	}
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
<span class="p_header">diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c</span>
<span class="p_header">index b48aefab57e8..60be8d0ef100 100644</span>
<span class="p_header">--- a/drivers/acpi/bus.c</span>
<span class="p_header">+++ b/drivers/acpi/bus.c</span>
<span class="p_chunk">@@ -450,6 +450,16 @@</span> <span class="p_context"> static int __init acpi_bus_init_irq(void)</span>
 u8 acpi_gbl_permanent_mmap;
 
 
<span class="p_add">+/**</span>
<span class="p_add">+ * acpi_early_init - Initialize ACPICA and populate the ACPI namespace.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The ACPI tables are accessible after this, but the handling of events has not</span>
<span class="p_add">+ * been initialized and the global lock is not available yet, so AML should not</span>
<span class="p_add">+ * be executed at this point.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Doing this before switching the EFI runtime services to virtual mode allows</span>
<span class="p_add">+ * the EfiBootServices memory to be freed slightly earlier on boot.</span>
<span class="p_add">+ */</span>
 void __init acpi_early_init(void)
 {
 	acpi_status status;
<span class="p_chunk">@@ -510,26 +520,42 @@</span> <span class="p_context"> void __init acpi_early_init(void)</span>
 		acpi_gbl_FADT.sci_interrupt = acpi_sci_override_gsi;
 	}
 #endif
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+ error0:</span>
<span class="p_add">+	disable_acpi();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * acpi_subsystem_init - Finalize the early initialization of ACPI.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Switch over the platform to the ACPI mode (if possible), initialize the</span>
<span class="p_add">+ * handling of ACPI events, install the interrupt and global lock handlers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Doing this too early is generally unsafe, but at the same time it needs to be</span>
<span class="p_add">+ * done before all things that really depend on ACPI.  The right spot appears to</span>
<span class="p_add">+ * be before finalizing the EFI initialization.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __init acpi_subsystem_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	acpi_status status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (acpi_disabled)</span>
<span class="p_add">+		return;</span>
 
 	status = acpi_enable_subsystem(~ACPI_NO_ACPI_ENABLE);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX &quot;Unable to enable ACPI\n&quot;);
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		disable_acpi();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If the system is using ACPI then we can be reasonably</span>
<span class="p_add">+		 * confident that any regulators are managed by the firmware</span>
<span class="p_add">+		 * so tell the regulator core it has everything it needs to</span>
<span class="p_add">+		 * know.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		regulator_has_full_constraints();</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If the system is using ACPI then we can be reasonably</span>
<span class="p_del">-	 * confident that any regulators are managed by the firmware</span>
<span class="p_del">-	 * so tell the regulator core it has everything it needs to</span>
<span class="p_del">-	 * know.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	regulator_has_full_constraints();</span>
<span class="p_del">-</span>
<span class="p_del">-	return;</span>
<span class="p_del">-</span>
<span class="p_del">-      error0:</span>
<span class="p_del">-	disable_acpi();</span>
<span class="p_del">-	return;</span>
 }
 
 static int __init acpi_bus_init(void)
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index b1c0fcdf46fc..b0e6691faf18 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4173,9 +4173,10 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;ST3320[68]13AS&quot;,	&quot;SD1[5-9]&quot;,	ATA_HORKAGE_NONCQ |
 						ATA_HORKAGE_FIRMWARE_WARN },
 
<span class="p_del">-	/* Seagate Momentus SpinPoint M8 seem to have FPMDA_AA issues */</span>
<span class="p_add">+	/* drives which fail FPDMA_AA activation (some may freeze afterwards) */</span>
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2AR10001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2BA30001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
<span class="p_add">+	{ &quot;VB0250EAVER&quot;,	&quot;HPG7&quot;,		ATA_HORKAGE_BROKEN_FPDMA_AA },</span>
 
 	/* Blacklist entries taken from Silicon Image 3124/3132
 	   Windows driver .inf file - also several Linux problem reports */
<span class="p_chunk">@@ -4229,6 +4230,9 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;Micron_M550*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Crucial_CT*M550SSD*&quot;,	NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 
<span class="p_add">+	/* devices that don&#39;t properly handle TRIM commands */</span>
<span class="p_add">+	{ &quot;SuperSSpeed S238*&quot;,		NULL,	ATA_HORKAGE_NOTRIM, },</span>
<span class="p_add">+</span>
 	/*
 	 * Some WD SATA-I drives spin up and down erratically when the link
 	 * is put into the slumber mode.  We don&#39;t have full list of the
<span class="p_chunk">@@ -4533,7 +4537,8 @@</span> <span class="p_context"> static unsigned int ata_dev_set_xfermode(struct ata_device *dev)</span>
 	else /* In the ancient relic department - skip all of this */
 		return 0;
 
<span class="p_del">-	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 0);</span>
<span class="p_add">+	/* On some disks, this command causes spin-up, so we need longer timeout */</span>
<span class="p_add">+	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 15000);</span>
 
 	DPRINTK(&quot;EXIT, err_mask=%x\n&quot;, err_mask);
 	return err_mask;
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index ef8567de6a75..6fecf0bde105 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -2510,7 +2510,8 @@</span> <span class="p_context"> static unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)</span>
 		rbuf[14] = (lowest_aligned &gt;&gt; 8) &amp; 0x3f;
 		rbuf[15] = lowest_aligned;
 
<span class="p_del">-		if (ata_id_has_trim(args-&gt;id)) {</span>
<span class="p_add">+		if (ata_id_has_trim(args-&gt;id) &amp;&amp;</span>
<span class="p_add">+		    !(dev-&gt;horkage &amp; ATA_HORKAGE_NOTRIM)) {</span>
 			rbuf[14] |= 0x80; /* TPE */
 
 			if (ata_id_has_zero_after_trim(args-&gt;id))
<span class="p_header">diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c</span>
<span class="p_header">index 2495ee577a64..f0c15f9c2b2f 100644</span>
<span class="p_header">--- a/drivers/base/firmware_class.c</span>
<span class="p_header">+++ b/drivers/base/firmware_class.c</span>
<span class="p_chunk">@@ -544,10 +544,8 @@</span> <span class="p_context"> static void fw_dev_release(struct device *dev)</span>
 	kfree(fw_priv);
 }
 
<span class="p_del">-static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+static int do_firmware_uevent(struct firmware_priv *fw_priv, struct kobj_uevent_env *env)</span>
 {
<span class="p_del">-	struct firmware_priv *fw_priv = to_firmware_priv(dev);</span>
<span class="p_del">-</span>
 	if (add_uevent_var(env, &quot;FIRMWARE=%s&quot;, fw_priv-&gt;buf-&gt;fw_id))
 		return -ENOMEM;
 	if (add_uevent_var(env, &quot;TIMEOUT=%i&quot;, loading_timeout))
<span class="p_chunk">@@ -558,6 +556,18 @@</span> <span class="p_context"> static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
 	return 0;
 }
 
<span class="p_add">+static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct firmware_priv *fw_priv = to_firmware_priv(dev);</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;fw_lock);</span>
<span class="p_add">+	if (fw_priv-&gt;buf)</span>
<span class="p_add">+		err = do_firmware_uevent(fw_priv, env);</span>
<span class="p_add">+	mutex_unlock(&amp;fw_lock);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct class firmware_class = {
 	.name		= &quot;firmware&quot;,
 	.class_attrs	= firmware_class_attrs,
<span class="p_header">diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c</span>
<span class="p_header">index 2f9a3d8ecbbf..58559d75d02c 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regmap.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regmap.c</span>
<span class="p_chunk">@@ -808,11 +808,10 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(devm_regmap_init);</span>
 static void regmap_field_init(struct regmap_field *rm_field,
 	struct regmap *regmap, struct reg_field reg_field)
 {
<span class="p_del">-	int field_bits = reg_field.msb - reg_field.lsb + 1;</span>
 	rm_field-&gt;regmap = regmap;
 	rm_field-&gt;reg = reg_field.reg;
 	rm_field-&gt;shift = reg_field.lsb;
<span class="p_del">-	rm_field-&gt;mask = ((BIT(field_bits) - 1) &lt;&lt; reg_field.lsb);</span>
<span class="p_add">+	rm_field-&gt;mask = GENMASK(reg_field.msb, reg_field.lsb);</span>
 	rm_field-&gt;id_size = reg_field.id_size;
 	rm_field-&gt;id_offset = reg_field.id_offset;
 }
<span class="p_chunk">@@ -1947,7 +1946,7 @@</span> <span class="p_context"> int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val,</span>
 					  &amp;ival);
 			if (ret != 0)
 				return ret;
<span class="p_del">-			memcpy(val + (i * val_bytes), &amp;ival, val_bytes);</span>
<span class="p_add">+			map-&gt;format.format_val(val + (i * val_bytes), ival, 0);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index 63688d3a6ea0..12be7cbfba4f 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -1826,11 +1826,11 @@</span> <span class="p_context"> static struct rbd_obj_request *rbd_obj_request_create(const char *object_name,</span>
 	rbd_assert(obj_request_type_valid(type));
 
 	size = strlen(object_name) + 1;
<span class="p_del">-	name = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+	name = kmalloc(size, GFP_NOIO);</span>
 	if (!name)
 		return NULL;
 
<span class="p_del">-	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_KERNEL);</span>
<span class="p_add">+	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_NOIO);</span>
 	if (!obj_request) {
 		kfree(name);
 		return NULL;
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index c0e7a9aa97a4..c23658e42fc3 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -1293,6 +1293,8 @@</span> <span class="p_context"> static int btusb_setup_intel(struct hci_dev *hdev)</span>
 	}
 	fw_ptr = fw-&gt;data;
 
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+</span>
 	/* This Intel specific command enables the manufacturer mode of the
 	 * controller.
 	 *
<span class="p_header">diff --git a/drivers/char/agp/intel-gtt.c b/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">index 5c85350f4c3d..19e301f9d549 100644</span>
<span class="p_header">--- a/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">+++ b/drivers/char/agp/intel-gtt.c</span>
<span class="p_chunk">@@ -586,7 +586,7 @@</span> <span class="p_context"> static inline int needs_ilk_vtd_wa(void)</span>
 	/* Query intel_iommu to see if we need the workaround. Presumably that
 	 * was loaded first.
 	 */
<span class="p_del">-	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_HB ||</span>
<span class="p_add">+	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_D_IG ||</span>
 	     gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_IG) &amp;&amp;
 	     intel_iommu_gfx_mapped)
 		return 1;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">index 102463ba745d..643bba7d6f81 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_chunk">@@ -579,6 +579,9 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	ibmvtpm-&gt;dev = dev;</span>
<span class="p_add">+	ibmvtpm-&gt;vdev = vio_dev;</span>
<span class="p_add">+</span>
 	crq_q = &amp;ibmvtpm-&gt;crq_queue;
 	crq_q-&gt;crq_addr = (struct ibmvtpm_crq *)get_zeroed_page(GFP_KERNEL);
 	if (!crq_q-&gt;crq_addr) {
<span class="p_chunk">@@ -623,8 +626,6 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 
 	crq_q-&gt;index = 0;
 
<span class="p_del">-	ibmvtpm-&gt;dev = dev;</span>
<span class="p_del">-	ibmvtpm-&gt;vdev = vio_dev;</span>
 	TPM_VPRIV(chip) = (void *)ibmvtpm;
 
 	spin_lock_init(&amp;ibmvtpm-&gt;rtce_lock);
<span class="p_header">diff --git a/drivers/clocksource/exynos_mct.c b/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">index 831b48287a22..ddd03f8037a7 100644</span>
<span class="p_header">--- a/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">+++ b/drivers/clocksource/exynos_mct.c</span>
<span class="p_chunk">@@ -422,15 +422,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 	exynos4_mct_write(TICK_BASE_CNT, mevt-&gt;base + MCT_L_TCNTB_OFFSET);
 
 	if (mct_int_type == MCT_INT_SPI) {
<span class="p_del">-		evt-&gt;irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_del">-		if (request_irq(evt-&gt;irq, exynos4_mct_tick_isr,</span>
<span class="p_del">-				IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_del">-				evt-&gt;name, mevt)) {</span>
<span class="p_del">-			pr_err(&quot;exynos-mct: cannot register IRQ %d\n&quot;,</span>
<span class="p_del">-				evt-&gt;irq);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (evt-&gt;irq == -1)</span>
 			return -EIO;
<span class="p_del">-		}</span>
<span class="p_del">-		irq_force_affinity(mct_irqs[MCT_L0_IRQ + cpu], cpumask_of(cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+		irq_force_affinity(evt-&gt;irq, cpumask_of(cpu));</span>
<span class="p_add">+		enable_irq(evt-&gt;irq);</span>
 	} else {
 		enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);
 	}
<span class="p_chunk">@@ -443,10 +440,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 static void exynos4_local_timer_stop(struct clock_event_device *evt)
 {
 	evt-&gt;set_mode(CLOCK_EVT_MODE_UNUSED, evt);
<span class="p_del">-	if (mct_int_type == MCT_INT_SPI)</span>
<span class="p_del">-		free_irq(evt-&gt;irq, this_cpu_ptr(&amp;percpu_mct_tick));</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (mct_int_type == MCT_INT_SPI) {</span>
<span class="p_add">+		if (evt-&gt;irq != -1)</span>
<span class="p_add">+			disable_irq_nosync(evt-&gt;irq);</span>
<span class="p_add">+	} else {</span>
 		disable_percpu_irq(mct_irqs[MCT_L0_IRQ]);
<span class="p_add">+	}</span>
 }
 
 static int exynos4_mct_cpu_notify(struct notifier_block *self,
<span class="p_chunk">@@ -478,7 +477,7 @@</span> <span class="p_context"> static struct notifier_block exynos4_mct_cpu_nb = {</span>
 
 static void __init exynos4_timer_resources(struct device_node *np, void __iomem *base)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err, cpu;</span>
 	struct mct_clock_event_device *mevt = this_cpu_ptr(&amp;percpu_mct_tick);
 	struct clk *mct_clk, *tick_clk;
 
<span class="p_chunk">@@ -505,7 +504,25 @@</span> <span class="p_context"> static void __init exynos4_timer_resources(struct device_node *np, void __iomem</span>
 		WARN(err, &quot;MCT: can&#39;t request IRQ %d (%d)\n&quot;,
 		     mct_irqs[MCT_L0_IRQ], err);
 	} else {
<span class="p_del">-		irq_set_affinity(mct_irqs[MCT_L0_IRQ], cpumask_of(0));</span>
<span class="p_add">+		for_each_possible_cpu(cpu) {</span>
<span class="p_add">+			int mct_irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_add">+			struct mct_clock_event_device *pcpu_mevt =</span>
<span class="p_add">+				per_cpu_ptr(&amp;percpu_mct_tick, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+			irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span>
<span class="p_add">+			if (request_irq(mct_irq,</span>
<span class="p_add">+					exynos4_mct_tick_isr,</span>
<span class="p_add">+					IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_add">+					pcpu_mevt-&gt;name, pcpu_mevt)) {</span>
<span class="p_add">+				pr_err(&quot;exynos-mct: cannot register IRQ (cpu%d)\n&quot;,</span>
<span class="p_add">+									cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = mct_irq;</span>
<span class="p_add">+		}</span>
 	}
 
 	err = register_cpu_notifier(&amp;exynos4_mct_cpu_nb);
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">index e3d2052e7552..1adc039fe74d 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle.c</span>
<span class="p_chunk">@@ -131,6 +131,9 @@</span> <span class="p_context"> int cpuidle_idle_call(void)</span>
 
 	/* ask the governor for the next state */
 	next_state = cpuidle_curr_governor-&gt;select(drv, dev);
<span class="p_add">+	if (next_state &lt; 0)</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
 	if (need_resched()) {
 		dev-&gt;last_residency = 0;
 		/* give the governor an opportunity to reflect on the outcome */
<span class="p_header">diff --git a/drivers/cpuidle/governors/menu.c b/drivers/cpuidle/governors/menu.c</span>
<span class="p_header">index cf7f2f0e4ef5..027c484e1ec9 100644</span>
<span class="p_header">--- a/drivers/cpuidle/governors/menu.c</span>
<span class="p_header">+++ b/drivers/cpuidle/governors/menu.c</span>
<span class="p_chunk">@@ -297,7 +297,7 @@</span> <span class="p_context"> static int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev)</span>
 		data-&gt;needs_update = 0;
 	}
 
<span class="p_del">-	data-&gt;last_state_idx = 0;</span>
<span class="p_add">+	data-&gt;last_state_idx = CPUIDLE_DRIVER_STATE_START - 1;</span>
 	data-&gt;exit_us = 0;
 
 	/* Special case when user has set very strict latency requirement */
<span class="p_header">diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c</span>
<span class="p_header">index 394cbc5c93e3..6b2f01d60527 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.c</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.c</span>
<span class="p_chunk">@@ -316,7 +316,8 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 	dma_cookie_t cookie = 0;
 	int busy = mv_chan_is_busy(mv_chan);
 	u32 current_desc = mv_chan_get_current_desc(mv_chan);
<span class="p_del">-	int seen_current = 0;</span>
<span class="p_add">+	int current_cleaned = 0;</span>
<span class="p_add">+	struct mv_xor_desc *hw_desc;</span>
 
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;%s %d\n&quot;, __func__, __LINE__);
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;current_desc %x\n&quot;, current_desc);
<span class="p_chunk">@@ -328,38 +329,57 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 
 	list_for_each_entry_safe(iter, _iter, &amp;mv_chan-&gt;chain,
 					chain_node) {
<span class="p_del">-		prefetch(_iter);</span>
<span class="p_del">-		prefetch(&amp;_iter-&gt;async_tx);</span>
 
<span class="p_del">-		/* do not advance past the current descriptor loaded into the</span>
<span class="p_del">-		 * hardware channel, subsequent descriptors are either in</span>
<span class="p_del">-		 * process or have not been submitted</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (seen_current)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		/* clean finished descriptors */</span>
<span class="p_add">+		hw_desc = iter-&gt;hw_desc;</span>
<span class="p_add">+		if (hw_desc-&gt;status &amp; XOR_DESC_SUCCESS) {</span>
<span class="p_add">+			cookie = mv_xor_run_tx_complete_actions(iter, mv_chan,</span>
<span class="p_add">+								cookie);</span>
 
<span class="p_del">-		/* stop the search if we reach the current descriptor and the</span>
<span class="p_del">-		 * channel is busy</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_del">-			seen_current = 1;</span>
<span class="p_del">-			if (busy)</span>
<span class="p_add">+			/* done processing desc, clean slot */</span>
<span class="p_add">+			mv_xor_clean_slot(iter, mv_chan);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* break if we did cleaned the current */</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 0;</span>
 				break;
<span class="p_add">+			}</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		cookie = mv_xor_run_tx_complete_actions(iter, mv_chan, cookie);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mv_xor_clean_slot(iter, mv_chan))</span>
<span class="p_del">-			break;</span>
 	}
 
 	if ((busy == 0) &amp;&amp; !list_empty(&amp;mv_chan-&gt;chain)) {
<span class="p_del">-		struct mv_xor_desc_slot *chain_head;</span>
<span class="p_del">-		chain_head = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_del">-					struct mv_xor_desc_slot,</span>
<span class="p_del">-					chain_node);</span>
<span class="p_del">-</span>
<span class="p_del">-		mv_xor_start_new_chain(mv_chan, chain_head);</span>
<span class="p_add">+		if (current_cleaned) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * current descriptor cleaned and removed, run</span>
<span class="p_add">+			 * from list head</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			iter = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_add">+					  struct mv_xor_desc_slot,</span>
<span class="p_add">+					  chain_node);</span>
<span class="p_add">+			mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (!list_is_last(&amp;iter-&gt;chain_node, &amp;mv_chan-&gt;chain)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * descriptors are still waiting after</span>
<span class="p_add">+				 * current, trigger them</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				iter = list_entry(iter-&gt;chain_node.next,</span>
<span class="p_add">+						  struct mv_xor_desc_slot,</span>
<span class="p_add">+						  chain_node);</span>
<span class="p_add">+				mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * some descriptors are still waiting</span>
<span class="p_add">+				 * to be cleaned</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				tasklet_schedule(&amp;mv_chan-&gt;irq_tasklet);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cookie &gt; 0)
<span class="p_header">diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h</span>
<span class="p_header">index d0749229c875..5d14e4b21692 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.h</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.h</span>
<span class="p_chunk">@@ -33,6 +33,7 @@</span> <span class="p_context"></span>
 #define XOR_OPERATION_MODE_XOR		0
 #define XOR_OPERATION_MODE_MEMCPY	2
 #define XOR_DESCRIPTOR_SWAP		BIT(14)
<span class="p_add">+#define XOR_DESC_SUCCESS		0x40000000</span>
 
 #define XOR_CURR_DESC(chan)	(chan-&gt;mmr_high_base + 0x10 + (chan-&gt;idx * 4))
 #define XOR_NEXT_DESC(chan)	(chan-&gt;mmr_high_base + 0x00 + (chan-&gt;idx * 4))
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index 3b7d32da1604..903db3cf288a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -2155,8 +2155,11 @@</span> <span class="p_context"> int drm_mode_setcrtc(struct drm_device *dev, void *data,</span>
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EINVAL;
 
<span class="p_del">-	/* For some reason crtc x/y offsets are signed internally. */</span>
<span class="p_del">-	if (crtc_req-&gt;x &gt; INT_MAX || crtc_req-&gt;y &gt; INT_MAX)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Universal plane src offsets are only 16.16, prevent havoc for</span>
<span class="p_add">+	 * drivers using universal plane code internally.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (crtc_req-&gt;x &amp; 0xffff0000 || crtc_req-&gt;y &amp; 0xffff0000)</span>
 		return -ERANGE;
 
 	drm_modeset_lock_all(dev);
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_cmd.c b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">index eb89653a7a17..c5e96a38f859 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_chunk">@@ -505,6 +505,7 @@</span> <span class="p_context"> int qxl_hw_surface_alloc(struct qxl_device *qdev,</span>
 
 	cmd = (struct qxl_surface_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_SURFACE_CMD_CREATE;
<span class="p_add">+	cmd-&gt;flags = QXL_SURF_FLAG_KEEP_DATA;</span>
 	cmd-&gt;u.surface_create.format = surf-&gt;surf.format;
 	cmd-&gt;u.surface_create.width = surf-&gt;surf.width;
 	cmd-&gt;u.surface_create.height = surf-&gt;surf.height;
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_ioctl.c b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">index 0bb86e6d41b4..56a13a915155 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_chunk">@@ -122,8 +122,10 @@</span> <span class="p_context"> static struct qxl_bo *qxlhw_handle_to_bo(struct qxl_device *qdev,</span>
 	qobj = gem_to_qxl_bo(gobj);
 
 	ret = qxl_release_list_add(release, qobj);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(gobj);</span>
 		return NULL;
<span class="p_add">+	}</span>
 
 	return qobj;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index c4558bdb0584..2fd2fb3f735f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -4148,6 +4148,31 @@</span> <span class="p_context"> void cik_compute_set_wptr(struct radeon_device *rdev,</span>
 	WDOORBELL32(ring-&gt;doorbell_index, ring-&gt;wptr);
 }
 
<span class="p_add">+static void cik_compute_stop(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 j, tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	cik_srbm_select(rdev, ring-&gt;me, ring-&gt;pipe, ring-&gt;queue, 0);</span>
<span class="p_add">+	/* Disable wptr polling. */</span>
<span class="p_add">+	tmp = RREG32(CP_PQ_WPTR_POLL_CNTL);</span>
<span class="p_add">+	tmp &amp;= ~WPTR_POLL_EN;</span>
<span class="p_add">+	WREG32(CP_PQ_WPTR_POLL_CNTL, tmp);</span>
<span class="p_add">+	/* Disable HQD. */</span>
<span class="p_add">+	if (RREG32(CP_HQD_ACTIVE) &amp; 1) {</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 1);</span>
<span class="p_add">+		for (j = 0; j &lt; rdev-&gt;usec_timeout; j++) {</span>
<span class="p_add">+			if (!(RREG32(CP_HQD_ACTIVE) &amp; 1))</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			udelay(1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_RPTR, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_WPTR, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	cik_srbm_select(rdev, 0, 0, 0, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * cik_cp_compute_enable - enable/disable the compute CP MEs
  *
<span class="p_chunk">@@ -4161,6 +4186,15 @@</span> <span class="p_context"> static void cik_cp_compute_enable(struct radeon_device *rdev, bool enable)</span>
 	if (enable)
 		WREG32(CP_MEC_CNTL, 0);
 	else {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * To make hibernation reliable we need to clear compute ring</span>
<span class="p_add">+		 * configuration before halting the compute ring.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mutex_lock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX]);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX]);</span>
<span class="p_add">+		mutex_unlock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+</span>
 		WREG32(CP_MEC_CNTL, (MEC_ME1_HALT | MEC_ME2_HALT));
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik_sdma.c b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">index 66ba713ba7d7..e590aec50c7d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_chunk">@@ -266,6 +266,17 @@</span> <span class="p_context"> static void cik_sdma_gfx_stop(struct radeon_device *rdev)</span>
 	}
 	rdev-&gt;ring[R600_RING_TYPE_DMA_INDEX].ready = false;
 	rdev-&gt;ring[CAYMAN_RING_TYPE_DMA1_INDEX].ready = false;
<span class="p_add">+</span>
<span class="p_add">+	/* FIXME use something else than big hammer but after few days can not</span>
<span class="p_add">+	 * seem to find good combination so reset SDMA blocks as it seems we</span>
<span class="p_add">+	 * do not shut them down properly. This fix hibernation and does not</span>
<span class="p_add">+	 * affect suspend to ram.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, SOFT_RESET_SDMA | SOFT_RESET_SDMA1);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, 0);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_gart.c b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">index a8f9b463bf2a..e60972290be6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_chunk">@@ -251,8 +251,10 @@</span> <span class="p_context"> void radeon_gart_unbind(struct radeon_device *rdev, unsigned offset,</span>
 			}
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -294,8 +296,10 @@</span> <span class="p_context"> int radeon_gart_bind(struct radeon_device *rdev, unsigned offset,</span>
 			}
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index b3f0293ba0d8..f8b20e1c0820 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -79,10 +79,12 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	mutex_lock(&amp;mode_config-&gt;mutex);</span>
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
 			radeon_connector_hotplug(connector);
 	}
<span class="p_add">+	mutex_unlock(&amp;mode_config-&gt;mutex);</span>
 	/* Just fire off a uevent and let userspace tell us what to do */
 	drm_helper_hpd_irq_event(dev);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 11804cc1e11f..c9053f799abe 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2914,6 +2914,7 @@</span> <span class="p_context"> static struct si_dpm_quirk si_dpm_quirk_list[] = {</span>
 	/* PITCAIRN - https://bugs.freedesktop.org/show_bug.cgi?id=76490 */
 	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1462, 0x3036, 0, 120000 },
 	{ PCI_VENDOR_ID_ATI, 0x6811, 0x174b, 0xe271, 0, 120000 },
<span class="p_add">+	{ PCI_VENDOR_ID_ATI, 0x6810, 0x174b, 0xe271, 85000, 90000 },</span>
 	{ 0, 0, 0, 0 },
 };
 
<span class="p_header">diff --git a/drivers/hwmon/mcp3021.c b/drivers/hwmon/mcp3021.c</span>
<span class="p_header">index d219c06a857b..972444a14cca 100644</span>
<span class="p_header">--- a/drivers/hwmon/mcp3021.c</span>
<span class="p_header">+++ b/drivers/hwmon/mcp3021.c</span>
<span class="p_chunk">@@ -31,14 +31,11 @@</span> <span class="p_context"></span>
 /* output format */
 #define MCP3021_SAR_SHIFT	2
 #define MCP3021_SAR_MASK	0x3ff
<span class="p_del">-</span>
 #define MCP3021_OUTPUT_RES	10	/* 10-bit resolution */
<span class="p_del">-#define MCP3021_OUTPUT_SCALE	4</span>
 
 #define MCP3221_SAR_SHIFT	0
 #define MCP3221_SAR_MASK	0xfff
 #define MCP3221_OUTPUT_RES	12	/* 12-bit resolution */
<span class="p_del">-#define MCP3221_OUTPUT_SCALE	1</span>
 
 enum chips {
 	mcp3021,
<span class="p_chunk">@@ -54,7 +51,6 @@</span> <span class="p_context"> struct mcp3021_data {</span>
 	u16 sar_shift;
 	u16 sar_mask;
 	u8 output_res;
<span class="p_del">-	u8 output_scale;</span>
 };
 
 static int mcp3021_read16(struct i2c_client *client)
<span class="p_chunk">@@ -84,13 +80,7 @@</span> <span class="p_context"> static int mcp3021_read16(struct i2c_client *client)</span>
 
 static inline u16 volts_from_reg(struct mcp3021_data *data, u16 val)
 {
<span class="p_del">-	if (val == 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	val = val * data-&gt;output_scale - data-&gt;output_scale / 2;</span>
<span class="p_del">-</span>
<span class="p_del">-	return val * DIV_ROUND_CLOSEST(data-&gt;vdd,</span>
<span class="p_del">-			(1 &lt;&lt; data-&gt;output_res) * data-&gt;output_scale);</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(data-&gt;vdd * val, 1 &lt;&lt; data-&gt;output_res);</span>
 }
 
 static ssize_t show_in_input(struct device *dev, struct device_attribute *attr,
<span class="p_chunk">@@ -132,14 +122,12 @@</span> <span class="p_context"> static int mcp3021_probe(struct i2c_client *client,</span>
 		data-&gt;sar_shift = MCP3021_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3021_SAR_MASK;
 		data-&gt;output_res = MCP3021_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3021_OUTPUT_SCALE;</span>
 		break;
 
 	case mcp3221:
 		data-&gt;sar_shift = MCP3221_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3221_SAR_MASK;
 		data-&gt;output_res = MCP3221_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3221_OUTPUT_SCALE;</span>
 		break;
 	}
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">index 8873d84e1d4f..50862c948217 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_chunk">@@ -62,6 +62,9 @@</span> <span class="p_context"></span>
 #define	AT91_TWI_UNRE		0x0080	/* Underrun Error */
 #define	AT91_TWI_NACK		0x0100	/* Not Acknowledged */
 
<span class="p_add">+#define	AT91_TWI_INT_MASK \</span>
<span class="p_add">+	(AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY | AT91_TWI_NACK)</span>
<span class="p_add">+</span>
 #define	AT91_TWI_IER		0x0024	/* Interrupt Enable Register */
 #define	AT91_TWI_IDR		0x0028	/* Interrupt Disable Register */
 #define	AT91_TWI_IMR		0x002c	/* Interrupt Mask Register */
<span class="p_chunk">@@ -117,13 +120,12 @@</span> <span class="p_context"> static void at91_twi_write(struct at91_twi_dev *dev, unsigned reg, unsigned val)</span>
 
 static void at91_disable_twi_interrupts(struct at91_twi_dev *dev)
 {
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IDR,</span>
<span class="p_del">-		       AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_INT_MASK);</span>
 }
 
 static void at91_twi_irq_save(struct at91_twi_dev *dev)
 {
<span class="p_del">-	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; 0x7;</span>
<span class="p_add">+	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; AT91_TWI_INT_MASK;</span>
 	at91_disable_twi_interrupts(dev);
 }
 
<span class="p_chunk">@@ -213,6 +215,14 @@</span> <span class="p_context"> static void at91_twi_write_data_dma_callback(void *data)</span>
 	dma_unmap_single(dev-&gt;dev, sg_dma_address(&amp;dev-&gt;dma.sg),
 			 dev-&gt;buf_len, DMA_TO_DEVICE);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When this callback is called, THR/TX FIFO is likely not to be empty</span>
<span class="p_add">+	 * yet. So we have to wait for TXCOMP or NACK bits to be set into the</span>
<span class="p_add">+	 * Status Register to be sure that the STOP bit has been sent and the</span>
<span class="p_add">+	 * transfer is completed. The NACK interrupt has already been enabled,</span>
<span class="p_add">+	 * we just have to enable TXCOMP one.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);
 }
 
<span class="p_chunk">@@ -307,7 +317,7 @@</span> <span class="p_context"> static void at91_twi_read_data_dma_callback(void *data)</span>
 	/* The last two bytes have to be read without using dma */
 	dev-&gt;buf += dev-&gt;buf_len - 2;
 	dev-&gt;buf_len = 2;
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY | AT91_TWI_TXCOMP);</span>
 }
 
 static void at91_twi_read_data_dma(struct at91_twi_dev *dev)
<span class="p_chunk">@@ -368,7 +378,7 @@</span> <span class="p_context"> static irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)</span>
 	/* catch error flags */
 	dev-&gt;transfer_status |= status;
 
<span class="p_del">-	if (irqstatus &amp; AT91_TWI_TXCOMP) {</span>
<span class="p_add">+	if (irqstatus &amp; (AT91_TWI_TXCOMP | AT91_TWI_NACK)) {</span>
 		at91_disable_twi_interrupts(dev);
 		complete(&amp;dev-&gt;cmd_complete);
 	}
<span class="p_chunk">@@ -381,6 +391,34 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 	int ret;
 	bool has_unre_flag = dev-&gt;pdata-&gt;has_unre_flag;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * WARNING: the TXCOMP bit in the Status Register is NOT a clear on</span>
<span class="p_add">+	 * read flag but shows the state of the transmission at the time the</span>
<span class="p_add">+	 * Status Register is read. According to the programmer datasheet,</span>
<span class="p_add">+	 * TXCOMP is set when both holding register and internal shifter are</span>
<span class="p_add">+	 * empty and STOP condition has been sent.</span>
<span class="p_add">+	 * Consequently, we should enable NACK interrupt rather than TXCOMP to</span>
<span class="p_add">+	 * detect transmission failure.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Besides, the TXCOMP bit is already set before the i2c transaction</span>
<span class="p_add">+	 * has been started. For read transactions, this bit is cleared when</span>
<span class="p_add">+	 * writing the START bit into the Control Register. So the</span>
<span class="p_add">+	 * corresponding interrupt can safely be enabled just after.</span>
<span class="p_add">+	 * However for write transactions managed by the CPU, we first write</span>
<span class="p_add">+	 * into THR, so TXCOMP is cleared. Then we can safely enable TXCOMP</span>
<span class="p_add">+	 * interrupt. If TXCOMP interrupt were enabled before writing into THR,</span>
<span class="p_add">+	 * the interrupt handler would be called immediately and the i2c command</span>
<span class="p_add">+	 * would be reported as completed.</span>
<span class="p_add">+	 * Also when a write transaction is managed by the DMA controller,</span>
<span class="p_add">+	 * enabling the TXCOMP interrupt in this function may lead to a race</span>
<span class="p_add">+	 * condition since we don&#39;t know whether the TXCOMP interrupt is enabled</span>
<span class="p_add">+	 * before or after the DMA has started to write into THR. So the TXCOMP</span>
<span class="p_add">+	 * interrupt is enabled later by at91_twi_write_data_dma_callback().</span>
<span class="p_add">+	 * Immediately after in that DMA callback, we still need to send the</span>
<span class="p_add">+	 * STOP condition manually writing the corresponding bit into the</span>
<span class="p_add">+	 * Control Register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	dev_dbg(dev-&gt;dev, &quot;transfer: %s %d bytes.\n&quot;,
 		(dev-&gt;msg-&gt;flags &amp; I2C_M_RD) ? &quot;read&quot; : &quot;write&quot;, dev-&gt;buf_len);
 
<span class="p_chunk">@@ -411,26 +449,24 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 		 * seems to be the best solution.
 		 */
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_read_data_dma(dev);
<span class="p_del">-			/*</span>
<span class="p_del">-			 * It is important to enable TXCOMP irq here because</span>
<span class="p_del">-			 * doing it only when transferring the last two bytes</span>
<span class="p_del">-			 * will mask NACK errors since TXCOMP is set when a</span>
<span class="p_del">-			 * NACK occurs.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER,</span>
<span class="p_del">-			       AT91_TWI_TXCOMP);</span>
<span class="p_del">-		} else</span>
<span class="p_add">+		} else {</span>
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-			       AT91_TWI_TXCOMP | AT91_TWI_RXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_RXRDY);</span>
<span class="p_add">+		}</span>
 	} else {
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_write_data_dma(dev);
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 		} else {
 			at91_twi_write_next_byte(dev);
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-				AT91_TWI_TXCOMP | AT91_TWI_TXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_TXRDY);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/iio/adc/at91_adc.c b/drivers/iio/adc/at91_adc.c</span>
<span class="p_header">index e6bf77d1ec08..ed4e45f53e20 100644</span>
<span class="p_header">--- a/drivers/iio/adc/at91_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/at91_adc.c</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> struct at91_adc_caps {</span>
 	u8	ts_pen_detect_sensitivity;
 
 	/* startup time calculate function */
<span class="p_del">-	u32 (*calc_startup_ticks)(u8 startup_time, u32 adc_clk_khz);</span>
<span class="p_add">+	u32 (*calc_startup_ticks)(u32 startup_time, u32 adc_clk_khz);</span>
 
 	u8	num_channels;
 	struct at91_adc_reg_desc registers;
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> struct at91_adc_state {</span>
 	u8			num_channels;
 	void __iomem		*reg_base;
 	struct at91_adc_reg_desc *registers;
<span class="p_del">-	u8			startup_time;</span>
<span class="p_add">+	u32			startup_time;</span>
 	u8			sample_hold_time;
 	bool			sleep_mode;
 	struct iio_trigger	**trig;
<span class="p_chunk">@@ -590,7 +590,7 @@</span> <span class="p_context"> ret:</span>
 	return ret;
 }
 
<span class="p_del">-static u32 calc_startup_ticks_9260(u8 startup_time, u32 adc_clk_khz)</span>
<span class="p_add">+static u32 calc_startup_ticks_9260(u32 startup_time, u32 adc_clk_khz)</span>
 {
 	/*
 	 * Number of ticks needed to cover the startup time of the ADC
<span class="p_chunk">@@ -601,7 +601,7 @@</span> <span class="p_context"> static u32 calc_startup_ticks_9260(u8 startup_time, u32 adc_clk_khz)</span>
 	return round_up((startup_time * adc_clk_khz / 1000) - 1, 8) / 8;
 }
 
<span class="p_del">-static u32 calc_startup_ticks_9x5(u8 startup_time, u32 adc_clk_khz)</span>
<span class="p_add">+static u32 calc_startup_ticks_9x5(u32 startup_time, u32 adc_clk_khz)</span>
 {
 	/*
 	 * For sama5d3x and at91sam9x5, the formula changes to:
<span class="p_header">diff --git a/drivers/iio/dac/ad5624r_spi.c b/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_header">index e8199cce2aea..1e666510c672 100644</span>
<span class="p_header">--- a/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_header">+++ b/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_chunk">@@ -22,7 +22,7 @@</span> <span class="p_context"></span>
 #include &quot;ad5624r.h&quot;
 
 static int ad5624r_spi_write(struct spi_device *spi,
<span class="p_del">-			     u8 cmd, u8 addr, u16 val, u8 len)</span>
<span class="p_add">+			     u8 cmd, u8 addr, u16 val, u8 shift)</span>
 {
 	u32 data;
 	u8 msg[3];
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> static int ad5624r_spi_write(struct spi_device *spi,</span>
 	 * 14-, 12-bit input code followed by 0, 2, or 4 don&#39;t care bits,
 	 * for the AD5664R, AD5644R, and AD5624R, respectively.
 	 */
<span class="p_del">-	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; (16 - len));</span>
<span class="p_add">+	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; shift);</span>
 	msg[0] = data &gt;&gt; 16;
 	msg[1] = data &gt;&gt; 8;
 	msg[2] = data;
<span class="p_header">diff --git a/drivers/iio/temperature/tmp006.c b/drivers/iio/temperature/tmp006.c</span>
<span class="p_header">index 84a0789c3d96..7a8050996b4e 100644</span>
<span class="p_header">--- a/drivers/iio/temperature/tmp006.c</span>
<span class="p_header">+++ b/drivers/iio/temperature/tmp006.c</span>
<span class="p_chunk">@@ -132,6 +132,9 @@</span> <span class="p_context"> static int tmp006_write_raw(struct iio_dev *indio_dev,</span>
 	struct tmp006_data *data = iio_priv(indio_dev);
 	int i;
 
<span class="p_add">+	if (mask != IIO_CHAN_INFO_SAMP_FREQ)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; ARRAY_SIZE(tmp006_freqs); i++)
 		if ((val == tmp006_freqs[i][0]) &amp;&amp;
 		    (val2 == tmp006_freqs[i][1])) {
<span class="p_header">diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">index 60142274fe4b..dd2b610552d5 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_chunk">@@ -59,6 +59,8 @@</span> <span class="p_context"> static int</span>
 isert_rdma_accept(struct isert_conn *isert_conn);
 struct rdma_cm_id *isert_setup_id(struct isert_np *isert_np);
 
<span class="p_add">+static void isert_release_work(struct work_struct *work);</span>
<span class="p_add">+</span>
 static void
 isert_qp_event_callback(struct ib_event *e, void *context)
 {
<span class="p_chunk">@@ -206,7 +208,7 @@</span> <span class="p_context"> fail:</span>
 static void
 isert_free_rx_descriptors(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
<span class="p_add">+	struct ib_device *ib_dev = isert_conn-&gt;conn_device-&gt;ib_device;</span>
 	struct iser_rx_desc *rx_desc;
 	int i;
 
<span class="p_chunk">@@ -534,6 +536,7 @@</span> <span class="p_context"> isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)</span>
 	mutex_init(&amp;isert_conn-&gt;conn_mutex);
 	spin_lock_init(&amp;isert_conn-&gt;conn_lock);
 	INIT_LIST_HEAD(&amp;isert_conn-&gt;conn_fr_pool);
<span class="p_add">+	INIT_WORK(&amp;isert_conn-&gt;release_work, isert_release_work);</span>
 
 	isert_conn-&gt;conn_cm_id = cma_id;
 	isert_conn-&gt;responder_resources = event-&gt;param.conn.responder_resources;
<span class="p_chunk">@@ -647,9 +650,9 @@</span> <span class="p_context"> out:</span>
 static void
 isert_connect_release(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
 	struct isert_device *device = isert_conn-&gt;conn_device;
 	int cq_index;
<span class="p_add">+	struct ib_device *ib_dev = device-&gt;ib_device;</span>
 
 	pr_debug(&quot;Entering isert_connect_release(): &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;);
 
<span class="p_chunk">@@ -657,7 +660,8 @@</span> <span class="p_context"> isert_connect_release(struct isert_conn *isert_conn)</span>
 		isert_conn_free_fastreg_pool(isert_conn);
 
 	isert_free_rx_descriptors(isert_conn);
<span class="p_del">-	rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
<span class="p_add">+	if (isert_conn-&gt;conn_cm_id)</span>
<span class="p_add">+		rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
 
 	if (isert_conn-&gt;conn_qp) {
 		cq_index = ((struct isert_cq_desc *)
<span class="p_chunk">@@ -799,6 +803,7 @@</span> <span class="p_context"> isert_disconnected_handler(struct rdma_cm_id *cma_id,</span>
 {
 	struct isert_np *isert_np = cma_id-&gt;context;
 	struct isert_conn *isert_conn;
<span class="p_add">+	bool terminating = false;</span>
 
 	if (isert_np-&gt;np_cm_id == cma_id)
 		return isert_np_cma_handler(cma_id-&gt;context, event);
<span class="p_chunk">@@ -806,21 +811,37 @@</span> <span class="p_context"> isert_disconnected_handler(struct rdma_cm_id *cma_id,</span>
 	isert_conn = cma_id-&gt;qp-&gt;qp_context;
 
 	mutex_lock(&amp;isert_conn-&gt;conn_mutex);
<span class="p_add">+	terminating = (isert_conn-&gt;state == ISER_CONN_TERMINATING);</span>
 	isert_conn_terminate(isert_conn);
 	mutex_unlock(&amp;isert_conn-&gt;conn_mutex);
 
 	pr_info(&quot;conn %p completing conn_wait\n&quot;, isert_conn);
 	complete(&amp;isert_conn-&gt;conn_wait);
 
<span class="p_add">+	if (terminating)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;isert_np-&gt;np_accept_mutex);</span>
<span class="p_add">+	if (!list_empty(&amp;isert_conn-&gt;conn_accept_node)) {</span>
<span class="p_add">+		list_del_init(&amp;isert_conn-&gt;conn_accept_node);</span>
<span class="p_add">+		isert_put_conn(isert_conn);</span>
<span class="p_add">+		queue_work(isert_release_wq, &amp;isert_conn-&gt;release_work);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_unlock(&amp;isert_np-&gt;np_accept_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
 	return 0;
 }
 
<span class="p_del">-static void</span>
<span class="p_add">+static int</span>
 isert_connect_error(struct rdma_cm_id *cma_id)
 {
 	struct isert_conn *isert_conn = cma_id-&gt;qp-&gt;qp_context;
 
<span class="p_add">+	isert_conn-&gt;conn_cm_id = NULL;</span>
 	isert_put_conn(isert_conn);
<span class="p_add">+</span>
<span class="p_add">+	return -1;</span>
 }
 
 static int
<span class="p_chunk">@@ -850,7 +871,7 @@</span> <span class="p_context"> isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)</span>
 	case RDMA_CM_EVENT_REJECTED:       /* FALLTHRU */
 	case RDMA_CM_EVENT_UNREACHABLE:    /* FALLTHRU */
 	case RDMA_CM_EVENT_CONNECT_ERROR:
<span class="p_del">-		isert_connect_error(cma_id);</span>
<span class="p_add">+		ret = isert_connect_error(cma_id);</span>
 		break;
 	default:
 		pr_err(&quot;Unhandled RDMA CMA event: %d\n&quot;, event-&gt;event);
<span class="p_chunk">@@ -2944,7 +2965,6 @@</span> <span class="p_context"> static void isert_wait_conn(struct iscsi_conn *conn)</span>
 
 	wait_for_completion(&amp;isert_conn-&gt;conn_wait_comp_err);
 
<span class="p_del">-	INIT_WORK(&amp;isert_conn-&gt;release_work, isert_release_work);</span>
 	queue_work(isert_release_wq, &amp;isert_conn-&gt;release_work);
 }
 
<span class="p_header">diff --git a/drivers/leds/led-class.c b/drivers/leds/led-class.c</span>
<span class="p_header">index f37d63cf726b..825545cdfb10 100644</span>
<span class="p_header">--- a/drivers/leds/led-class.c</span>
<span class="p_header">+++ b/drivers/leds/led-class.c</span>
<span class="p_chunk">@@ -178,6 +178,7 @@</span> <span class="p_context"> void led_classdev_resume(struct led_classdev *led_cdev)</span>
 }
 EXPORT_SYMBOL_GPL(led_classdev_resume);
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
 static int led_suspend(struct device *dev)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
<span class="p_chunk">@@ -197,11 +198,9 @@</span> <span class="p_context"> static int led_resume(struct device *dev)</span>
 
 	return 0;
 }
<span class="p_add">+#endif</span>
 
<span class="p_del">-static const struct dev_pm_ops leds_class_dev_pm_ops = {</span>
<span class="p_del">-	.suspend        = led_suspend,</span>
<span class="p_del">-	.resume         = led_resume,</span>
<span class="p_del">-};</span>
<span class="p_add">+static SIMPLE_DEV_PM_OPS(leds_class_dev_pm_ops, led_suspend, led_resume);</span>
 
 /**
  * led_classdev_register - register a new object of led_classdev class.
<span class="p_header">diff --git a/drivers/md/dm-stats.c b/drivers/md/dm-stats.c</span>
<span class="p_header">index 28a90122a5a8..b3b0697a9fd7 100644</span>
<span class="p_header">--- a/drivers/md/dm-stats.c</span>
<span class="p_header">+++ b/drivers/md/dm-stats.c</span>
<span class="p_chunk">@@ -795,6 +795,8 @@</span> <span class="p_context"> static int message_stats_create(struct mapped_device *md,</span>
 		return -EINVAL;
 
 	if (sscanf(argv[2], &quot;/%u%c&quot;, &amp;divisor, &amp;dummy) == 1) {
<span class="p_add">+		if (!divisor)</span>
<span class="p_add">+			return -EINVAL;</span>
 		step = end - start;
 		if (do_div(step, divisor))
 			step++;
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 40959ee73583..b4067b9afd38 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -6232,7 +6232,7 @@</span> <span class="p_context"> static int update_array_info(struct mddev *mddev, mdu_array_info_t *info)</span>
 	    mddev-&gt;ctime         != info-&gt;ctime         ||
 	    mddev-&gt;level         != info-&gt;level         ||
 /*	    mddev-&gt;layout        != info-&gt;layout        || */
<span class="p_del">-	    !mddev-&gt;persistent	 != info-&gt;not_persistent||</span>
<span class="p_add">+	    mddev-&gt;persistent	 != !info-&gt;not_persistent ||</span>
 	    mddev-&gt;chunk_sectors != info-&gt;chunk_size &gt;&gt; 9 ||
 	    /* ignore bottom 8 bits of state, and allow SB_BITMAP_PRESENT to change */
 	    ((state^info-&gt;state) &amp; 0xfffffe00)
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">index b88757cd0d1d..a03178e91a79 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_chunk">@@ -309,8 +309,8 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 
 		if (s &lt; 0 &amp;&amp; nr_center &lt; -s) {
 			/* not enough in central node */
<span class="p_del">-			shift(left, center, nr_center);</span>
<span class="p_del">-			s = nr_center - target;</span>
<span class="p_add">+			shift(left, center, -nr_center);</span>
<span class="p_add">+			s += nr_center;</span>
 			shift(left, right, s);
 			nr_right += s;
 		} else
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 		if (s &gt; 0 &amp;&amp; nr_center &lt; s) {
 			/* not enough in central node */
 			shift(center, right, nr_center);
<span class="p_del">-			s = target - nr_center;</span>
<span class="p_add">+			s -= nr_center;</span>
 			shift(left, right, s);
 			nr_left -= s;
 		} else
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 200ac12a1d40..fdd3793e22f9 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 	int r;
 	struct del_stack *s;
 
<span class="p_del">-	s = kmalloc(sizeof(*s), GFP_KERNEL);</span>
<span class="p_add">+	s = kmalloc(sizeof(*s), GFP_NOIO);</span>
 	if (!s)
 		return -ENOMEM;
 	s-&gt;info = info;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index f4e22bcc7fb8..199c9ccd1f5d 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -204,6 +204,27 @@</span> <span class="p_context"> static void in(struct sm_metadata *smm)</span>
 	smm-&gt;recursion_count++;
 }
 
<span class="p_add">+static int apply_bops(struct sm_metadata *smm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int r = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_add">+		struct block_op bop;</span>
<span class="p_add">+</span>
<span class="p_add">+		r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		r = commit_bop(smm, &amp;bop);</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return r;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int out(struct sm_metadata *smm)
 {
 	int r = 0;
<span class="p_chunk">@@ -216,21 +237,8 @@</span> <span class="p_context"> static int out(struct sm_metadata *smm)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	if (smm-&gt;recursion_count == 1) {</span>
<span class="p_del">-		while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_del">-			struct block_op bop;</span>
<span class="p_del">-</span>
<span class="p_del">-			r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_del">-			if (r) {</span>
<span class="p_del">-				DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			r = commit_bop(smm, &amp;bop);</span>
<span class="p_del">-			if (r)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (smm-&gt;recursion_count == 1)</span>
<span class="p_add">+		apply_bops(smm);</span>
 
 	smm-&gt;recursion_count--;
 
<span class="p_chunk">@@ -702,6 +710,12 @@</span> <span class="p_context"> static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)</span>
 		}
 		old_len = smm-&gt;begin;
 
<span class="p_add">+		r = apply_bops(smm);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		r = sm_ll_commit(&amp;smm-&gt;ll);
 		if (r)
 			goto out;
<span class="p_chunk">@@ -771,6 +785,12 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 	if (r)
 		return r;
 
<span class="p_add">+	r = apply_bops(smm);</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return sm_metadata_commit(sm);
 }
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">index fb504f1e9125..5930aee6b5d0 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_chunk">@@ -606,6 +606,10 @@</span> <span class="p_context"> static int af9013_set_frontend(struct dvb_frontend *fe)</span>
 			}
 		}
 
<span class="p_add">+		/* Return an error if can&#39;t find bandwidth or the right clock */</span>
<span class="p_add">+		if (i == ARRAY_SIZE(coeff_lut))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
 			sizeof(coeff_lut[i].val));
 	}
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24116.c b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">index 2916d7c74a1d..7bc68b355c0b 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_chunk">@@ -963,6 +963,10 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	struct cx24116_state *state = fe-&gt;demodulator_priv;
 	int i, ret;
 
<span class="p_add">+	/* Validate length */</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
<span class="p_add">+                return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Dump DiSEqC message */
 	if (debug) {
 		printk(KERN_INFO &quot;cx24116: %s(&quot;, __func__);
<span class="p_chunk">@@ -974,10 +978,6 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 		printk(&quot;) toneburst=%d\n&quot;, toneburst);
 	}
 
<span class="p_del">-	/* Validate length */</span>
<span class="p_del">-	if (d-&gt;msg_len &gt; (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	/* DiSEqC message */
 	for (i = 0; i &lt; d-&gt;msg_len; i++)
 		state-&gt;dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d-&gt;msg[i];
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24117.c b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">index a6c3c9e2e897..d2eab0676d30 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_chunk">@@ -1043,7 +1043,7 @@</span> <span class="p_context"> static int cx24117_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	dev_dbg(&amp;state-&gt;priv-&gt;i2c-&gt;dev, &quot;)\n&quot;);
 
 	/* Validate length */
<span class="p_del">-	if (d-&gt;msg_len &gt; 15)</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
 		return -EINVAL;
 
 	/* DiSEqC message */
<span class="p_header">diff --git a/drivers/media/dvb-frontends/s5h1420.c b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">index 93eeaf7118fd..0b4f8fe6bf99 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static int s5h1420_send_master_cmd (struct dvb_frontend* fe,</span>
 	int result = 0;
 
 	dprintk(&quot;enter %s\n&quot;, __func__);
<span class="p_del">-	if (cmd-&gt;msg_len &gt; 8)</span>
<span class="p_add">+	if (cmd-&gt;msg_len &gt; sizeof(cmd-&gt;msg))</span>
 		return -EINVAL;
 
 	/* setup for DISEQC */
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index b1e21fc869c3..d71f5ef036e0 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -205,6 +205,8 @@</span> <span class="p_context"> static ssize_t power_ro_lock_show(struct device *dev,</span>
 
 	ret = snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, locked);
 
<span class="p_add">+	mmc_blk_put(md);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1861,9 +1863,11 @@</span> <span class="p_context"> static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)</span>
 			break;
 		case MMC_BLK_CMD_ERR:
 			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
<span class="p_del">-			if (!mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			goto cmd_abort;</span>
<span class="p_add">+			if (mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_add">+				goto cmd_abort;</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				goto start_new_req;</span>
<span class="p_add">+			break;</span>
 		case MMC_BLK_RETRY:
 			if (retry++ &lt; 5)
 				break;
<span class="p_header">diff --git a/drivers/mtd/maps/dc21285.c b/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">index f8a7dd14cee0..70a3db3ab856 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/dc21285.c</span>
<span class="p_chunk">@@ -38,9 +38,9 @@</span> <span class="p_context"> static void nw_en_write(void)</span>
 	 * we want to write a bit pattern XXX1 to Xilinx to enable
 	 * the write gate, which will be open for about the next 2ms.
 	 */
<span class="p_del">-	spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
 	nw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);
<span class="p_del">-	spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
 
 	/*
 	 * let the ISA bus to catch on...
<span class="p_header">diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">index 5073cbc796d8..32d5e40c6863 100644</span>
<span class="p_header">--- a/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">+++ b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_chunk">@@ -199,6 +199,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 		return -ERESTARTSYS; /* FIXME: busy loop! -arnd*/
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -222,6 +223,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 
 unlock:
 	dev-&gt;open++;
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -232,6 +234,7 @@</span> <span class="p_context"> error_release:</span>
 error_put:
 	module_put(dev-&gt;tr-&gt;owner);
 	kref_put(&amp;dev-&gt;ref, blktrans_dev_release);
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -245,6 +248,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		return;
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (--dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -258,6 +262,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		__put_mtd_device(dev-&gt;mtd);
 	}
 unlock:
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 }
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 9715a7ba164a..efc542d00c84 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2000,7 +2000,7 @@</span> <span class="p_context"> static int nand_write_page_raw_syndrome(struct mtd_info *mtd,</span>
 			oob += chip-&gt;ecc.prepad;
 		}
 
<span class="p_del">-		chip-&gt;read_buf(mtd, oob, eccbytes);</span>
<span class="p_add">+		chip-&gt;write_buf(mtd, oob, eccbytes);</span>
 		oob += eccbytes;
 
 		if (chip-&gt;ecc.postpad) {
<span class="p_chunk">@@ -3063,7 +3063,7 @@</span> <span class="p_context"> static int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,</span>
 					int *busw)
 {
 	struct nand_onfi_params *p = &amp;chip-&gt;onfi_params;
<span class="p_del">-	int i;</span>
<span class="p_add">+	int i, j;</span>
 	int val;
 
 	/* Try ONFI for unknown chip or LP */
<span class="p_chunk">@@ -3072,18 +3072,10 @@</span> <span class="p_context"> static int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,</span>
 		chip-&gt;read_byte(mtd) != &#39;F&#39; || chip-&gt;read_byte(mtd) != &#39;I&#39;)
 		return 0;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * ONFI must be probed in 8-bit mode or with NAND_BUSWIDTH_AUTO, not</span>
<span class="p_del">-	 * with NAND_BUSWIDTH_16</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (chip-&gt;options &amp; NAND_BUSWIDTH_16) {</span>
<span class="p_del">-		pr_err(&quot;ONFI cannot be probed in 16-bit mode; aborting\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	chip-&gt;cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);
 	for (i = 0; i &lt; 3; i++) {
<span class="p_del">-		chip-&gt;read_buf(mtd, (uint8_t *)p, sizeof(*p));</span>
<span class="p_add">+		for (j = 0; j &lt; sizeof(*p); j++)</span>
<span class="p_add">+			((uint8_t *)p)[j] = chip-&gt;read_byte(mtd);</span>
 		if (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 254) ==
 				le16_to_cpu(p-&gt;crc)) {
 			break;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">index 5924f72dd493..f35ce8e50e65 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_chunk">@@ -205,11 +205,13 @@</span> <span class="p_context"> static bool ath_prepare_reset(struct ath_softc *sc)</span>
 	ath_stop_ani(sc);
 	ath9k_hw_disable_interrupts(ah);
 
<span class="p_del">-	if (!ath_drain_all_txq(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ath_stoprecv(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_add">+	if (AR_SREV_9300_20_OR_LATER(ah)) {</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+	}</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index 3935614274eb..e99f329c905e 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(of_n_size_cells);</span>
 #ifdef CONFIG_NUMA
 int __weak of_node_to_nid(struct device_node *np)
 {
<span class="p_del">-	return numa_node_id();</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
 }
 #endif
 
<span class="p_header">diff --git a/drivers/pcmcia/topic.h b/drivers/pcmcia/topic.h</span>
<span class="p_header">index 615a45a8fe86..582688fe7505 100644</span>
<span class="p_header">--- a/drivers/pcmcia/topic.h</span>
<span class="p_header">+++ b/drivers/pcmcia/topic.h</span>
<span class="p_chunk">@@ -104,6 +104,9 @@</span> <span class="p_context"></span>
 #define TOPIC_EXCA_IF_CONTROL		0x3e	/* 8 bit */
 #define TOPIC_EXCA_IFC_33V_ENA		0x01
 
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN		0x3e	/* 16-bit */</span>
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN_WBEN	0x0400</span>
<span class="p_add">+</span>
 static void topic97_zoom_video(struct pcmcia_socket *sock, int onoff)
 {
 	struct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);
<span class="p_chunk">@@ -138,6 +141,7 @@</span> <span class="p_context"> static int topic97_override(struct yenta_socket *socket)</span>
 static int topic95_override(struct yenta_socket *socket)
 {
 	u8 fctrl;
<span class="p_add">+	u16 ppbcn;</span>
 
 	/* enable 3.3V support for 16bit cards */
 	fctrl = exca_readb(socket, TOPIC_EXCA_IF_CONTROL);
<span class="p_chunk">@@ -146,6 +150,18 @@</span> <span class="p_context"> static int topic95_override(struct yenta_socket *socket)</span>
 	/* tell yenta to use exca registers to power 16bit cards */
 	socket-&gt;flags |= YENTA_16BIT_POWER_EXCA | YENTA_16BIT_POWER_DF;
 
<span class="p_add">+	/* Disable write buffers to prevent lockups under load with numerous</span>
<span class="p_add">+	   Cardbus cards, observed on Tecra 500CDT and reported elsewhere on the</span>
<span class="p_add">+	   net.  This is not a power-on default according to the datasheet</span>
<span class="p_add">+	   but some BIOSes seem to set it. */</span>
<span class="p_add">+	if (pci_read_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, &amp;ppbcn) == 0</span>
<span class="p_add">+	    &amp;&amp; socket-&gt;dev-&gt;revision &lt;= 7</span>
<span class="p_add">+	    &amp;&amp; (ppbcn &amp; TOPIC_PCI_CFG_PPBCN_WBEN)) {</span>
<span class="p_add">+		ppbcn &amp;= ~TOPIC_PCI_CFG_PPBCN_WBEN;</span>
<span class="p_add">+		pci_write_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, ppbcn);</span>
<span class="p_add">+		dev_info(&amp;socket-&gt;dev-&gt;dev, &quot;Disabled ToPIC95 Cardbus write buffers.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-370.c b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">index ae1f760cbdd2..bb525b19be77 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_chunk">@@ -358,11 +358,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode mv88f6710_mpp_modes[] = {</span>
 	MPP_MODE(64,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;miso&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs1&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs1&quot;)),</span>
 	MPP_MODE(65,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;mosi&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs2&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs2&quot;)),</span>
 };
 
 static struct mvebu_pinctrl_soc_info armada_370_pinctrl_info;
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">index 843a51f9d129..d918c5186061 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_chunk">@@ -14,10 +14,7 @@</span> <span class="p_context"></span>
  * available: mv78230, mv78260 and mv78460. From a pin muxing
  * perspective, the mv78230 has 49 MPP pins. The mv78260 and mv78460
  * both have 67 MPP pins (more GPIOs and address lines for the memory
<span class="p_del">- * bus mainly). The only difference between the mv78260 and the</span>
<span class="p_del">- * mv78460 in terms of pin muxing is the addition of two functions on</span>
<span class="p_del">- * pins 43 and 56 to access the VDD of the CPU2 and 3 (mv78260 has two</span>
<span class="p_del">- * cores, mv78460 has four cores).</span>
<span class="p_add">+ * bus mainly).</span>
  */
 
 #include &lt;linux/err.h&gt;
<span class="p_chunk">@@ -159,20 +156,17 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(24,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata1&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-re&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;rst&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;hsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(25,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata0&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-we&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;pclk&quot;,       V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(26,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;fsync&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS)),</span>
 	MPP_MODE(27,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;trig&quot;,       V_MV78230_PLUS),
<span class="p_chunk">@@ -187,8 +181,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int0&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(30,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
<span class="p_chunk">@@ -196,13 +189,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(31,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;cmd&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(32,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d0&quot;,         V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(33,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d1&quot;,         V_MV78230_PLUS),
<span class="p_chunk">@@ -234,7 +225,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;spi&quot;, &quot;cs1&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vga-hsync&quot;,  V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq0&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(41,
<span class="p_chunk">@@ -249,15 +239,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;rxd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int7&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(43,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;txd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;rts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;spi&quot;, &quot;cs3&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_chunk">@@ -286,7 +274,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq3&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;tclk&quot;, NULL,        V_MV78230_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;clkout&quot;,     V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x2, &quot;dev&quot;, &quot;burst/last&quot;, V_MV78230_PLUS)),
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_chunk">@@ -308,16 +296,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad19&quot;,       V_MV78260_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(56,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(57,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(58,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad23&quot;,       V_MV78260_PLUS)),
<span class="p_header">diff --git a/drivers/platform/x86/dell-laptop.c b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">index fed4111ac31a..1beb232ef03b 100644</span>
<span class="p_header">--- a/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_chunk">@@ -272,7 +272,6 @@</span> <span class="p_context"> static struct dmi_system_id dell_quirks[] = {</span>
 };
 
 static struct calling_interface_buffer *buffer;
<span class="p_del">-static struct page *bufferpage;</span>
 static DEFINE_MUTEX(buffer_mutex);
 
 static int hwswitch_state;
<span class="p_chunk">@@ -825,12 +824,11 @@</span> <span class="p_context"> static int __init dell_init(void)</span>
 	 * Allocate buffer below 4GB for SMI data--only 32-bit physical addr
 	 * is passed to SMI handler.
 	 */
<span class="p_del">-	bufferpage = alloc_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_del">-	if (!bufferpage) {</span>
<span class="p_add">+	buffer = (void *)__get_free_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_add">+	if (!buffer) {</span>
 		ret = -ENOMEM;
 		goto fail_buffer;
 	}
<span class="p_del">-	buffer = page_address(bufferpage);</span>
 
 	ret = dell_setup_rfkill();
 
<span class="p_chunk">@@ -892,7 +890,7 @@</span> <span class="p_context"> fail_backlight:</span>
 	cancel_delayed_work_sync(&amp;dell_rfkill_work);
 	dell_cleanup_rfkill();
 fail_rfkill:
<span class="p_del">-	free_page((unsigned long)bufferpage);</span>
<span class="p_add">+	free_page((unsigned long)buffer);</span>
 fail_buffer:
 	platform_device_del(platform_device);
 fail_platform_device2:
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index 6dd060a0bb65..0d1a5d497ce0 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -461,8 +461,9 @@</span> <span class="p_context"> const struct ideapad_rfk_data ideapad_rfk_data[] = {</span>
 static int ideapad_rfk_set(void *data, bool blocked)
 {
 	struct ideapad_rfk_priv *priv = data;
<span class="p_add">+	int opcode = ideapad_rfk_data[priv-&gt;dev].opcode;</span>
 
<span class="p_del">-	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, priv-&gt;dev, !blocked);</span>
<span class="p_add">+	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, opcode, !blocked);</span>
 }
 
 static struct rfkill_ops ideapad_rfk_ops = {
<span class="p_header">diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c</span>
<span class="p_header">index 5d8d2dcd975e..427cb625af0a 100644</span>
<span class="p_header">--- a/drivers/regulator/core.c</span>
<span class="p_header">+++ b/drivers/regulator/core.c</span>
<span class="p_chunk">@@ -773,7 +773,7 @@</span> <span class="p_context"> static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)</span>
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev-&gt;constraints;
<span class="p_del">-	char buf[80] = &quot;&quot;;</span>
<span class="p_add">+	char buf[160] = &quot;&quot;;</span>
 	int count = 0;
 	int ret;
 
<span class="p_header">diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h</span>
<span class="p_header">index 0801f3df4b27..02edae714b0e 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.h</span>
<span class="p_header">+++ b/drivers/scsi/ipr.h</span>
<span class="p_chunk">@@ -264,7 +264,7 @@</span> <span class="p_context"></span>
 #define IPR_RUNTIME_RESET				0x40000000
 
 #define IPR_IPL_INIT_MIN_STAGE_TIME			5
<span class="p_del">-#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 15</span>
<span class="p_add">+#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 30</span>
 #define IPR_IPL_INIT_STAGE_UNKNOWN			0x0
 #define IPR_IPL_INIT_STAGE_TRANSOP			0xB0000000
 #define IPR_IPL_INIT_STAGE_MASK				0xff000000
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">index 0a1dcb43d18b..13f4bef214dc 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_chunk">@@ -572,8 +572,9 @@</span> <span class="p_context"> qla2x00_async_event(scsi_qla_host_t *vha, struct rsp_que *rsp, uint16_t *mb)</span>
 	struct device_reg_2xxx __iomem *reg = &amp;ha-&gt;iobase-&gt;isp;
 	struct device_reg_24xx __iomem *reg24 = &amp;ha-&gt;iobase-&gt;isp24;
 	struct device_reg_82xx __iomem *reg82 = &amp;ha-&gt;iobase-&gt;isp82;
<span class="p_del">-	uint32_t	rscn_entry, host_pid;</span>
<span class="p_add">+	uint32_t	rscn_entry, host_pid, tmp_pid;</span>
 	unsigned long	flags;
<span class="p_add">+	fc_port_t	*fcport = NULL;</span>
 
 	/* Setup to process RIO completion. */
 	handle_cnt = 0;
<span class="p_chunk">@@ -968,6 +969,20 @@</span> <span class="p_context"> skip_rio:</span>
 		if (qla2x00_is_a_vp_did(vha, rscn_entry))
 			break;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Search for the rport related to this RSCN entry and mark it</span>
<span class="p_add">+		 * as lost.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		list_for_each_entry(fcport, &amp;vha-&gt;vp_fcports, list) {</span>
<span class="p_add">+			if (atomic_read(&amp;fcport-&gt;state) != FCS_ONLINE)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			tmp_pid = fcport-&gt;d_id.b24;</span>
<span class="p_add">+			if (fcport-&gt;d_id.b24 == rscn_entry) {</span>
<span class="p_add">+				qla2x00_mark_device_lost(vha, fcport, 0, 0);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		atomic_set(&amp;vha-&gt;loop_down_timer, 0);
 		vha-&gt;flags.management_server_logged_in = 0;
 
<span class="p_header">diff --git a/drivers/scsi/scsi_transport_srp.c b/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_header">index e3e794ee7ddd..b85eaa0d75c2 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_chunk">@@ -397,6 +397,36 @@</span> <span class="p_context"> static void srp_reconnect_work(struct work_struct *work)</span>
 	}
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * scsi_request_fn_active() - number of kernel threads inside scsi_request_fn()</span>
<span class="p_add">+ * @shost: SCSI host for which to count the number of scsi_request_fn() callers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * To do: add support for scsi-mq in this function.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int scsi_request_fn_active(struct Scsi_Host *shost)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct scsi_device *sdev;</span>
<span class="p_add">+	struct request_queue *q;</span>
<span class="p_add">+	int request_fn_active = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	shost_for_each_device(sdev, shost) {</span>
<span class="p_add">+		q = sdev-&gt;request_queue;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+		request_fn_active += q-&gt;request_fn_active;</span>
<span class="p_add">+		spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return request_fn_active;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Wait until ongoing shost-&gt;hostt-&gt;queuecommand() calls have finished. */</span>
<span class="p_add">+static void srp_wait_for_queuecommand(struct Scsi_Host *shost)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (scsi_request_fn_active(shost))</span>
<span class="p_add">+		msleep(20);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __rport_fail_io_fast(struct srp_rport *rport)
 {
 	struct Scsi_Host *shost = rport_to_shost(rport);
<span class="p_chunk">@@ -410,8 +440,10 @@</span> <span class="p_context"> static void __rport_fail_io_fast(struct srp_rport *rport)</span>
 
 	/* Involve the LLD if possible to terminate all I/O on the rport. */
 	i = to_srp_internal(shost-&gt;transportt);
<span class="p_del">-	if (i-&gt;f-&gt;terminate_rport_io)</span>
<span class="p_add">+	if (i-&gt;f-&gt;terminate_rport_io) {</span>
<span class="p_add">+		srp_wait_for_queuecommand(shost);</span>
 		i-&gt;f-&gt;terminate_rport_io(rport);
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -505,27 +537,6 @@</span> <span class="p_context"> void srp_start_tl_fail_timers(struct srp_rport *rport)</span>
 EXPORT_SYMBOL(srp_start_tl_fail_timers);
 
 /**
<span class="p_del">- * scsi_request_fn_active() - number of kernel threads inside scsi_request_fn()</span>
<span class="p_del">- * @shost: SCSI host for which to count the number of scsi_request_fn() callers.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int scsi_request_fn_active(struct Scsi_Host *shost)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_device *sdev;</span>
<span class="p_del">-	struct request_queue *q;</span>
<span class="p_del">-	int request_fn_active = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	shost_for_each_device(sdev, shost) {</span>
<span class="p_del">-		q = sdev-&gt;request_queue;</span>
<span class="p_del">-</span>
<span class="p_del">-		spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_del">-		request_fn_active += q-&gt;request_fn_active;</span>
<span class="p_del">-		spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return request_fn_active;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  * srp_reconnect_rport() - reconnect to an SRP target port
  * @rport: SRP target port.
  *
<span class="p_chunk">@@ -560,8 +571,7 @@</span> <span class="p_context"> int srp_reconnect_rport(struct srp_rport *rport)</span>
 	if (res)
 		goto out;
 	scsi_target_block(&amp;shost-&gt;shost_gendev);
<span class="p_del">-	while (scsi_request_fn_active(shost))</span>
<span class="p_del">-		msleep(20);</span>
<span class="p_add">+	srp_wait_for_queuecommand(shost);</span>
 	res = rport-&gt;state != SRP_RPORT_LOST ? i-&gt;f-&gt;reconnect(rport) : -ENODEV;
 	pr_debug(&quot;%s (state %d): transport.reconnect() returned %d\n&quot;,
 		 dev_name(&amp;shost-&gt;shost_gendev), rport-&gt;state, res);
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index d6563ec700d4..f3e3ae8af709 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -834,9 +834,6 @@</span> <span class="p_context"> void spi_finalize_current_message(struct spi_master *master)</span>
 
 	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);
 	mesg = master-&gt;cur_msg;
<span class="p_del">-	master-&gt;cur_msg = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	queue_kthread_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span>
 	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);
 
 	if (master-&gt;cur_msg_prepared &amp;&amp; master-&gt;unprepare_message) {
<span class="p_chunk">@@ -847,9 +844,13 @@</span> <span class="p_context"> void spi_finalize_current_message(struct spi_master *master)</span>
 		}
 	}
 
<span class="p_del">-	trace_spi_message_done(mesg);</span>
<span class="p_del">-</span>
<span class="p_add">+	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);</span>
<span class="p_add">+	master-&gt;cur_msg = NULL;</span>
 	master-&gt;cur_msg_prepared = false;
<span class="p_add">+	queue_kthread_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_spi_message_done(mesg);</span>
 
 	mesg-&gt;state = NULL;
 	if (mesg-&gt;complete)
<span class="p_header">diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">index ea965370d1ac..d060b1f4f092 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_chunk">@@ -1075,7 +1075,8 @@</span> <span class="p_context"> static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)</span>
 		/* for first fragment packet, driver need allocate 1536 +
 		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
 		if ((mf == 1) &amp;&amp; (frag == 0))
<span class="p_del">-			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			alloc_sz = max_t(u16, tmp_len, 1658);</span>
 		else
 			alloc_sz = tmp_len;
 		/* 2 is for IP header 4 bytes alignment in QoS packet case.
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index b61c555a5a8f..c8d7b3009c7e 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -518,7 +518,7 @@</span> <span class="p_context"> static struct iscsit_transport iscsi_target_transport = {</span>
 
 static int __init iscsi_target_init_module(void)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = 0, size;</span>
 
 	pr_debug(&quot;iSCSI-Target &quot;ISCSIT_VERSION&quot;\n&quot;);
 
<span class="p_chunk">@@ -527,6 +527,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 		pr_err(&quot;Unable to allocate memory for iscsit_global\n&quot;);
 		return -1;
 	}
<span class="p_add">+	spin_lock_init(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 	mutex_init(&amp;auth_id_lock);
 	spin_lock_init(&amp;sess_idr_lock);
 	idr_init(&amp;tiqn_idr);
<span class="p_chunk">@@ -536,15 +537,11 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (ret &lt; 0)
 		goto out;
 
<span class="p_del">-	ret = iscsi_thread_set_init();</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	size = BITS_TO_LONGS(ISCSIT_BITMAP_BITS) * sizeof(long);</span>
<span class="p_add">+	iscsit_global-&gt;ts_bitmap = vzalloc(size);</span>
<span class="p_add">+	if (!iscsit_global-&gt;ts_bitmap) {</span>
<span class="p_add">+		pr_err(&quot;Unable to allocate iscsit_global-&gt;ts_bitmap\n&quot;);</span>
 		goto configfs_out;
<span class="p_del">-</span>
<span class="p_del">-	if (iscsi_allocate_thread_sets(TARGET_THREAD_SET_COUNT) !=</span>
<span class="p_del">-			TARGET_THREAD_SET_COUNT) {</span>
<span class="p_del">-		pr_err(&quot;iscsi_allocate_thread_sets() returned&quot;</span>
<span class="p_del">-			&quot; unexpected value!\n&quot;);</span>
<span class="p_del">-		goto ts_out1;</span>
 	}
 
 	lio_qr_cache = kmem_cache_create(&quot;lio_qr_cache&quot;,
<span class="p_chunk">@@ -553,7 +550,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (!lio_qr_cache) {
 		pr_err(&quot;nable to kmem_cache_create() for&quot;
 				&quot; lio_qr_cache\n&quot;);
<span class="p_del">-		goto ts_out2;</span>
<span class="p_add">+		goto bitmap_out;</span>
 	}
 
 	lio_dr_cache = kmem_cache_create(&quot;lio_dr_cache&quot;,
<span class="p_chunk">@@ -597,10 +594,8 @@</span> <span class="p_context"> dr_out:</span>
 	kmem_cache_destroy(lio_dr_cache);
 qr_out:
 	kmem_cache_destroy(lio_qr_cache);
<span class="p_del">-ts_out2:</span>
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-ts_out1:</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
<span class="p_add">+bitmap_out:</span>
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 configfs_out:
 	iscsi_target_deregister_configfs();
 out:
<span class="p_chunk">@@ -610,8 +605,6 @@</span> <span class="p_context"> out:</span>
 
 static void __exit iscsi_target_cleanup_module(void)
 {
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
 	iscsit_release_discovery_tpg();
 	iscsit_unregister_transport(&amp;iscsi_target_transport);
 	kmem_cache_destroy(lio_qr_cache);
<span class="p_chunk">@@ -621,6 +614,7 @@</span> <span class="p_context"> static void __exit iscsi_target_cleanup_module(void)</span>
 
 	iscsi_target_deregister_configfs();
 
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 	kfree(iscsit_global);
 }
 
<span class="p_chunk">@@ -3653,17 +3647,16 @@</span> <span class="p_context"> static int iscsit_send_reject(</span>
 
 void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
 {
<span class="p_del">-	struct iscsi_thread_set *ts = conn-&gt;thread_set;</span>
 	int ord, cpu;
 	/*
<span class="p_del">-	 * thread_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_del">-	 * within iscsi_thread_set.c:iscsi_allocate_thread_sets()</span>
<span class="p_add">+	 * bitmap_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_add">+	 * within iscsit_start_kthreads()</span>
 	 *
<span class="p_del">-	 * Here we use thread_id to determine which CPU that this</span>
<span class="p_del">-	 * iSCSI connection&#39;s iscsi_thread_set will be scheduled to</span>
<span class="p_add">+	 * Here we use bitmap_id to determine which CPU that this</span>
<span class="p_add">+	 * iSCSI connection&#39;s RX/TX threads will be scheduled to</span>
 	 * execute upon.
 	 */
<span class="p_del">-	ord = ts-&gt;thread_id % cpumask_weight(cpu_online_mask);</span>
<span class="p_add">+	ord = conn-&gt;bitmap_id % cpumask_weight(cpu_online_mask);</span>
 	for_each_online_cpu(cpu) {
 		if (ord-- == 0) {
 			cpumask_set_cpu(cpu, conn-&gt;conn_cpumask);
<span class="p_chunk">@@ -3855,7 +3848,7 @@</span> <span class="p_context"> check_rsp_state:</span>
 	switch (state) {
 	case ISTATE_SEND_LOGOUTRSP:
 		if (!iscsit_logout_post_handler(cmd, conn))
<span class="p_del">-			goto restart;</span>
<span class="p_add">+			return -ECONNRESET;</span>
 		/* fall through */
 	case ISTATE_SEND_STATUS:
 	case ISTATE_SEND_ASYNCMSG:
<span class="p_chunk">@@ -3883,8 +3876,6 @@</span> <span class="p_context"> check_rsp_state:</span>
 
 err:
 	return -1;
<span class="p_del">-restart:</span>
<span class="p_del">-	return -EAGAIN;</span>
 }
 
 static int iscsit_handle_response_queue(struct iscsi_conn *conn)
<span class="p_chunk">@@ -3911,21 +3902,13 @@</span> <span class="p_context"> static int iscsit_handle_response_queue(struct iscsi_conn *conn)</span>
 int iscsi_target_tx_thread(void *arg)
 {
 	int ret = 0;
<span class="p_del">-	struct iscsi_conn *conn;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
 
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_tx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-</span>
 	while (!kthread_should_stop()) {
 		/*
 		 * Ensure that both TX and RX per connection kthreads
<span class="p_chunk">@@ -3934,11 +3917,9 @@</span> <span class="p_context"> restart:</span>
 		iscsit_thread_check_cpumask(conn, current, 1);
 
 		wait_event_interruptible(conn-&gt;queues_wq,
<span class="p_del">-					 !iscsit_conn_all_queues_empty(conn) ||</span>
<span class="p_del">-					 ts-&gt;status == ISCSI_THREAD_SET_RESET);</span>
<span class="p_add">+					 !iscsit_conn_all_queues_empty(conn));</span>
 
<span class="p_del">-		if ((ts-&gt;status == ISCSI_THREAD_SET_RESET) ||</span>
<span class="p_del">-		     signal_pending(current))</span>
<span class="p_add">+		if (signal_pending(current))</span>
 			goto transport_err;
 
 get_immediate:
<span class="p_chunk">@@ -3949,15 +3930,14 @@</span> <span class="p_context"> get_immediate:</span>
 		ret = iscsit_handle_response_queue(conn);
 		if (ret == 1)
 			goto get_immediate;
<span class="p_del">-		else if (ret == -EAGAIN)</span>
<span class="p_del">-			goto restart;</span>
<span class="p_add">+		else if (ret == -ECONNRESET)</span>
<span class="p_add">+			goto out;</span>
 		else if (ret &lt; 0)
 			goto transport_err;
 	}
 
 transport_err:
 	iscsit_take_action_for_connection_exit(conn);
<span class="p_del">-	goto restart;</span>
 out:
 	return 0;
 }
<span class="p_chunk">@@ -4046,8 +4026,7 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	int ret;
 	u8 buffer[ISCSI_HDR_LEN], opcode;
 	u32 checksum = 0, digest = 0;
<span class="p_del">-	struct iscsi_conn *conn = NULL;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	struct kvec iov;
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
<span class="p_chunk">@@ -4055,11 +4034,6 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	 */
 	allow_signal(SIGINT);
 
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_rx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
 		int rc;
<span class="p_chunk">@@ -4069,7 +4043,7 @@</span> <span class="p_context"> restart:</span>
 		if (rc &lt; 0)
 			goto transport_err;
 
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto transport_err;</span>
 	}
 
 	while (!kthread_should_stop()) {
<span class="p_chunk">@@ -4145,8 +4119,6 @@</span> <span class="p_context"> transport_err:</span>
 	if (!signal_pending(current))
 		atomic_set(&amp;conn-&gt;transport_failed, 1);
 	iscsit_take_action_for_connection_exit(conn);
<span class="p_del">-	goto restart;</span>
<span class="p_del">-out:</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4208,7 +4180,24 @@</span> <span class="p_context"> int iscsit_close_connection(</span>
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)
 		complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsi_release_thread_set(conn);</span>
<span class="p_add">+	if (!strcmp(current-&gt;comm, ISCSI_RX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;tx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;tx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (!strcmp(current-&gt;comm, ISCSI_TX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;rx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;rx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;rx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 
 	iscsit_stop_timers_for_cmds(conn);
 	iscsit_stop_nopin_response_timer(conn);
<span class="p_chunk">@@ -4487,15 +4476,13 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 	struct iscsi_conn *conn)
 {
 	struct iscsi_session *sess = conn-&gt;sess;
<span class="p_del">-</span>
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
 	iscsit_dec_conn_usage_count(conn);
<span class="p_del">-	iscsit_stop_session(sess, 1, 1);</span>
<span class="p_add">+	iscsit_stop_session(sess, sleep, sleep);</span>
 	iscsit_dec_session_usage_count(sess);
 	target_put_session(sess-&gt;se_sess);
 }
<span class="p_chunk">@@ -4503,13 +4490,12 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 static void iscsit_logout_post_handler_samecid(
 	struct iscsi_conn *conn)
 {
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsit_cause_connection_reinstatement(conn, 1);</span>
<span class="p_add">+	iscsit_cause_connection_reinstatement(conn, sleep);</span>
 	iscsit_dec_conn_usage_count(conn);
 }
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index 1d4a8c86551f..825b579ebca8 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -601,6 +601,11 @@</span> <span class="p_context"> struct iscsi_conn {</span>
 	struct iscsi_session	*sess;
 	/* Pointer to thread_set in use for this conn&#39;s threads */
 	struct iscsi_thread_set	*thread_set;
<span class="p_add">+	int			bitmap_id;</span>
<span class="p_add">+	int			rx_thread_active;</span>
<span class="p_add">+	struct task_struct	*rx_thread;</span>
<span class="p_add">+	int			tx_thread_active;</span>
<span class="p_add">+	struct task_struct	*tx_thread;</span>
 	/* list_head for session connection list */
 	struct list_head	conn_list;
 } ____cacheline_aligned;
<span class="p_chunk">@@ -869,10 +874,12 @@</span> <span class="p_context"> struct iscsit_global {</span>
 	/* Unique identifier used for the authentication daemon */
 	u32			auth_id;
 	u32			inactive_ts;
<span class="p_add">+#define ISCSIT_BITMAP_BITS	262144</span>
 	/* Thread Set bitmap count */
 	int			ts_bitmap_count;
 	/* Thread Set bitmap pointer */
 	unsigned long		*ts_bitmap;
<span class="p_add">+	spinlock_t		ts_bitmap_lock;</span>
 	/* Used for iSCSI discovery session authentication */
 	struct iscsi_node_acl	discovery_acl;
 	struct iscsi_portal_group	*discovery_tpg;
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_erl0.c b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">index 0d1e6ee3e992..7396d90d96b2 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_chunk">@@ -864,7 +864,10 @@</span> <span class="p_context"> void iscsit_connection_reinstatement_rcfr(struct iscsi_conn *conn)</span>
 	}
 	spin_unlock_bh(&amp;conn-&gt;state_lock);
 
<span class="p_del">-	iscsi_thread_set_force_reinstatement(conn);</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 sleep:
 	wait_for_completion(&amp;conn-&gt;conn_wait_rcfr_comp);
<span class="p_chunk">@@ -889,10 +892,10 @@</span> <span class="p_context"> void iscsit_cause_connection_reinstatement(struct iscsi_conn *conn, int sleep)</span>
 		return;
 	}
 
<span class="p_del">-	if (iscsi_thread_set_force_reinstatement(conn) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_bh(&amp;conn-&gt;state_lock);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 	atomic_set(&amp;conn-&gt;connection_reinstatement, 1);
 	if (!sleep) {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index c5d3811a7b8c..449df092bfa0 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -681,6 +681,51 @@</span> <span class="p_context"> static void iscsi_post_login_start_timers(struct iscsi_conn *conn)</span>
 		iscsit_start_nopin_timer(conn);
 }
 
<span class="p_add">+int iscsit_start_kthreads(struct iscsi_conn *conn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	conn-&gt;bitmap_id = bitmap_find_free_region(iscsit_global-&gt;ts_bitmap,</span>
<span class="p_add">+					ISCSIT_BITMAP_BITS, get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;bitmap_id &lt; 0) {</span>
<span class="p_add">+		pr_err(&quot;bitmap_find_free_region() failed for&quot;</span>
<span class="p_add">+		       &quot; iscsit_start_kthreads()\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;tx_thread = kthread_run(iscsi_target_tx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_TX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;tx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_tx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;tx_thread);</span>
<span class="p_add">+		goto out_bitmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;tx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;rx_thread = kthread_run(iscsi_target_rx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_RX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;rx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_rx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;rx_thread);</span>
<span class="p_add">+		goto out_tx;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;rx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+out_tx:</span>
<span class="p_add">+	kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+	conn-&gt;tx_thread_active = false;</span>
<span class="p_add">+out_bitmap:</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int iscsi_post_login_handler(
 	struct iscsi_np *np,
 	struct iscsi_conn *conn,
<span class="p_chunk">@@ -691,7 +736,7 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	struct se_session *se_sess = sess-&gt;se_sess;
 	struct iscsi_portal_group *tpg = sess-&gt;tpg;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
<span class="p_del">-	struct iscsi_thread_set *ts;</span>
<span class="p_add">+	int rc;</span>
 
 	iscsit_inc_conn_usage_count(conn);
 
<span class="p_chunk">@@ -706,7 +751,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	/*
 	 * SCSI Initiator -&gt; SCSI Target Port Mapping
 	 */
<span class="p_del">-	ts = iscsi_get_thread_set();</span>
 	if (!zero_tsih) {
 		iscsi_set_session_parameters(sess-&gt;sess_ops,
 				conn-&gt;param_list, 0);
<span class="p_chunk">@@ -733,9 +777,11 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 			sess-&gt;sess_ops-&gt;InitiatorName);
 		spin_unlock_bh(&amp;sess-&gt;conn_lock);
 
<span class="p_del">-		iscsi_post_login_start_timers(conn);</span>
<span class="p_add">+		rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+		if (rc)</span>
<span class="p_add">+			return rc;</span>
 
<span class="p_del">-		iscsi_activate_thread_set(conn, ts);</span>
<span class="p_add">+		iscsi_post_login_start_timers(conn);</span>
 		/*
 		 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 		 * are scheduled on the same CPU.
<span class="p_chunk">@@ -792,8 +838,11 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 		&quot; iSCSI Target Portal Group: %hu\n&quot;, tpg-&gt;nsessions, tpg-&gt;tpgt);
 	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 
<span class="p_add">+	rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
 	iscsi_post_login_start_timers(conn);
<span class="p_del">-	iscsi_activate_thread_set(conn, ts);</span>
 	/*
 	 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 	 * are scheduled on the same CPU.
<span class="p_header">diff --git a/drivers/thermal/step_wise.c b/drivers/thermal/step_wise.c</span>
<span class="p_header">index ee52ab7d3730..c501eba601da 100644</span>
<span class="p_header">--- a/drivers/thermal/step_wise.c</span>
<span class="p_header">+++ b/drivers/thermal/step_wise.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static unsigned long get_target_state(struct thermal_instance *instance,</span>
 			next_target = instance-&gt;upper;
 		break;
 	case THERMAL_TREND_DROPPING:
<span class="p_del">-		if (cur_state == instance-&gt;lower) {</span>
<span class="p_add">+		if (cur_state &lt;= instance-&gt;lower) {</span>
 			if (!throttle)
 				next_target = THERMAL_NO_TARGET;
 		} else {
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 45b7b96f9ed3..8016aaa158f2 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 	snoop(&amp;urb-&gt;dev-&gt;dev, &quot;urb complete\n&quot;);
 	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
 			as-&gt;status, COMPLETE, NULL, 0);
<span class="p_del">-	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == USB_DIR_IN)</span>
<span class="p_add">+	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_IN)</span>
 		snoop_urb_data(urb, urb-&gt;actual_length);
 
 	if (as-&gt;status &lt; 0 &amp;&amp; as-&gt;bulk_addr &amp;&amp; as-&gt;status != -ECONNRESET &amp;&amp;
<span class="p_chunk">@@ -1591,7 +1591,7 @@</span> <span class="p_context"> static struct async *reap_as(struct dev_state *ps)</span>
 	for (;;) {
 		__set_current_state(TASK_INTERRUPTIBLE);
 		as = async_getcompleted(ps);
<span class="p_del">-		if (as)</span>
<span class="p_add">+		if (as || !connected(ps))</span>
 			break;
 		if (signal_pending(current))
 			break;
<span class="p_chunk">@@ -1614,7 +1614,7 @@</span> <span class="p_context"> static int proc_reapurb(struct dev_state *ps, void __user *arg)</span>
 	}
 	if (signal_pending(current))
 		return -EINTR;
<span class="p_del">-	return -EIO;</span>
<span class="p_add">+	return -ENODEV;</span>
 }
 
 static int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)
<span class="p_chunk">@@ -1623,10 +1623,11 @@</span> <span class="p_context"> static int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)</span>
 	struct async *as;
 
 	as = async_getcompleted(ps);
<span class="p_del">-	retval = -EAGAIN;</span>
 	if (as) {
 		retval = processcompl(as, (void __user * __user *)arg);
 		free_async(as);
<span class="p_add">+	} else {</span>
<span class="p_add">+		retval = (connected(ps) ? -EAGAIN : -ENODEV);</span>
 	}
 	return retval;
 }
<span class="p_chunk">@@ -1756,7 +1757,7 @@</span> <span class="p_context"> static int proc_reapurb_compat(struct dev_state *ps, void __user *arg)</span>
 	}
 	if (signal_pending(current))
 		return -EINTR;
<span class="p_del">-	return -EIO;</span>
<span class="p_add">+	return -ENODEV;</span>
 }
 
 static int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)
<span class="p_chunk">@@ -1764,11 +1765,12 @@</span> <span class="p_context"> static int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)</span>
 	int retval;
 	struct async *as;
 
<span class="p_del">-	retval = -EAGAIN;</span>
 	as = async_getcompleted(ps);
 	if (as) {
 		retval = processcompl_compat(as, (void __user * __user *)arg);
 		free_async(as);
<span class="p_add">+	} else {</span>
<span class="p_add">+		retval = (connected(ps) ? -EAGAIN : -ENODEV);</span>
 	}
 	return retval;
 }
<span class="p_chunk">@@ -1940,7 +1942,8 @@</span> <span class="p_context"> static int proc_get_capabilities(struct dev_state *ps, void __user *arg)</span>
 {
 	__u32 caps;
 
<span class="p_del">-	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM;</span>
<span class="p_add">+	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM |</span>
<span class="p_add">+			USBDEVFS_CAP_REAP_AFTER_DISCONNECT;</span>
 	if (!ps-&gt;dev-&gt;bus-&gt;no_stop_on_short)
 		caps |= USBDEVFS_CAP_BULK_CONTINUATION;
 	if (ps-&gt;dev-&gt;bus-&gt;sg_tablesize)
<span class="p_chunk">@@ -2001,6 +2004,32 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 		return -EPERM;
 
 	usb_lock_device(dev);
<span class="p_add">+</span>
<span class="p_add">+	/* Reap operations are allowed even after disconnection */</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case USBDEVFS_REAPURB:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurb(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	case USBDEVFS_REAPURBNDELAY:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurbnonblock(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+	case USBDEVFS_REAPURB32:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB32\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurb_compat(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	case USBDEVFS_REAPURBNDELAY32:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY32\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurbnonblock_compat(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!connected(ps)) {
 		usb_unlock_device(dev);
 		return -ENODEV;
<span class="p_chunk">@@ -2094,16 +2123,6 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 			inode-&gt;i_mtime = CURRENT_TIME;
 		break;
 
<span class="p_del">-	case USBDEVFS_REAPURB32:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB32\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurb_compat(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case USBDEVFS_REAPURBNDELAY32:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY32\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurbnonblock_compat(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
 	case USBDEVFS_IOCTL32:
 		snoop(&amp;dev-&gt;dev, &quot;%s: IOCTL32\n&quot;, __func__);
 		ret = proc_ioctl_compat(ps, ptr_to_compat(p));
<span class="p_chunk">@@ -2115,16 +2134,6 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 		ret = proc_unlinkurb(ps, p);
 		break;
 
<span class="p_del">-	case USBDEVFS_REAPURB:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurb(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case USBDEVFS_REAPURBNDELAY:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurbnonblock(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
 	case USBDEVFS_DISCSIGNAL:
 		snoop(&amp;dev-&gt;dev, &quot;%s: DISCSIGNAL\n&quot;, __func__);
 		ret = proc_disconnectsignal(ps, p);
<span class="p_chunk">@@ -2161,6 +2170,8 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 		ret = proc_disconnect_claim(ps, p);
 		break;
 	}
<span class="p_add">+</span>
<span class="p_add">+ done:</span>
 	usb_unlock_device(dev);
 	if (ret &gt;= 0)
 		inode-&gt;i_atime = CURRENT_TIME;
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index 0985ff715c0c..a05fc58d9b60 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -707,6 +707,10 @@</span> <span class="p_context"> static int dwc3_ep0_std_request(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)</span>
 		dev_vdbg(dwc-&gt;dev, &quot;USB_REQ_SET_ISOCH_DELAY\n&quot;);
 		ret = dwc3_ep0_set_isoch_delay(dwc, ctrl);
 		break;
<span class="p_add">+	case USB_REQ_SET_INTERFACE:</span>
<span class="p_add">+		dev_vdbg(dwc-&gt;dev, &quot;USB_REQ_SET_INTERFACE\n&quot;);</span>
<span class="p_add">+		dwc-&gt;start_config_issued = false;</span>
<span class="p_add">+		/* Fall through */</span>
 	default:
 		dev_vdbg(dwc-&gt;dev, &quot;Forwarding to gadget driver\n&quot;);
 		ret = dwc3_ep0_delegate_req(dwc, ctrl);
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 8f6738d46b14..a57ad1f52f79 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -299,6 +299,8 @@</span> <span class="p_context"> int dwc3_send_gadget_generic_command(struct dwc3 *dwc, int cmd, u32 param)</span>
 		if (!(reg &amp; DWC3_DGCMD_CMDACT)) {
 			dev_vdbg(dwc-&gt;dev, &quot;Command Complete --&gt; %d\n&quot;,
 					DWC3_DGCMD_STATUS(reg));
<span class="p_add">+			if (DWC3_DGCMD_STATUS(reg))</span>
<span class="p_add">+				return -EINVAL;</span>
 			return 0;
 		}
 
<span class="p_chunk">@@ -335,6 +337,8 @@</span> <span class="p_context"> int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,</span>
 		if (!(reg &amp; DWC3_DEPCMD_CMDACT)) {
 			dev_vdbg(dwc-&gt;dev, &quot;Command Complete --&gt; %d\n&quot;,
 					DWC3_DEPCMD_STATUS(reg));
<span class="p_add">+			if (DWC3_DEPCMD_STATUS(reg))</span>
<span class="p_add">+				return -EINVAL;</span>
 			return 0;
 		}
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 9bce4f0e99be..f8893b32bbb6 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1331,10 +1331,10 @@</span> <span class="p_context"> int xhci_endpoint_init(struct xhci_hcd *xhci,</span>
 		/* Attempt to use the ring cache */
 		if (virt_dev-&gt;num_rings_cached == 0)
 			return -ENOMEM;
<span class="p_add">+		virt_dev-&gt;num_rings_cached--;</span>
 		virt_dev-&gt;eps[ep_index].new_ring =
 			virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached];
 		virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached] = NULL;
<span class="p_del">-		virt_dev-&gt;num_rings_cached--;</span>
 		xhci_reinit_cached_ring(xhci, virt_dev-&gt;eps[ep_index].new_ring,
 					1, type);
 	}
<span class="p_header">diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">index 0241a3a0d63e..1e9bde4fe785 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_chunk">@@ -273,9 +273,7 @@</span> <span class="p_context"> static int musb_has_gadget(struct musb *musb)</span>
 #ifdef CONFIG_USB_MUSB_HOST
 	return 1;
 #else
<span class="p_del">-	if (musb-&gt;port_mode == MUSB_PORT_MODE_HOST)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	return musb-&gt;g.dev.driver != NULL;</span>
<span class="p_add">+	return musb-&gt;port_mode == MUSB_PORT_MODE_HOST;</span>
 #endif
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 73c7292f48e5..d11335d4395d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -187,6 +187,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1FB9, 0x0602) }, /* Lake Shore Model 648 Magnet Power Supply */
 	{ USB_DEVICE(0x1FB9, 0x0700) }, /* Lake Shore Model 737 VSM Controller */
 	{ USB_DEVICE(0x1FB9, 0x0701) }, /* Lake Shore Model 776 Hall Matrix */
<span class="p_add">+	{ USB_DEVICE(0x2626, 0xEA60) }, /* Aruba Networks 7xxx USB Serial Console */</span>
 	{ USB_DEVICE(0x3195, 0xF190) }, /* Link Instruments MSO-19 */
 	{ USB_DEVICE(0x3195, 0xF280) }, /* Link Instruments MSO-28 */
 	{ USB_DEVICE(0x3195, 0xF281) }, /* Link Instruments MSO-28 */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 8b3484134ab0..096438e4fb0c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -1755,6 +1755,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */</span>
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
 	{ } /* Terminating entry */
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">index 9a08e18e09b9..3d66e9c5a95d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial.c</span>
<span class="p_chunk">@@ -1300,6 +1300,7 @@</span> <span class="p_context"> static void __exit usb_serial_exit(void)</span>
 	tty_unregister_driver(usb_serial_tty_driver);
 	put_tty_driver(usb_serial_tty_driver);
 	bus_unregister(&amp;usb_serial_bus_type);
<span class="p_add">+	idr_destroy(&amp;serial_minors);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">index 09cf0135e8ac..90a6406111f5 100644</span>
<span class="p_header">--- a/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/omap_wdt.c</span>
<span class="p_chunk">@@ -134,6 +134,13 @@</span> <span class="p_context"> static int omap_wdt_start(struct watchdog_device *wdog)</span>
 
 	pm_runtime_get_sync(wdev-&gt;dev);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure the watchdog is disabled. This is unfortunately required</span>
<span class="p_add">+	 * because writing to various registers with the watchdog running has no</span>
<span class="p_add">+	 * effect.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	omap_wdt_disable(wdev);</span>
<span class="p_add">+</span>
 	/* initialize prescaler */
 	while (readl_relaxed(base + OMAP_WATCHDOG_WPS) &amp; 0x01)
 		cpu_relax();
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index bb7991c7e5c7..bfdeadb7c243 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -540,8 +540,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">index 59dc8e87647f..de8606c3a9da 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_chunk">@@ -149,8 +149,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/bio.c b/fs/bio.c</span>
<span class="p_header">index 8754e7b6eb49..b2b1451912b5 100644</span>
<span class="p_header">--- a/fs/bio.c</span>
<span class="p_header">+++ b/fs/bio.c</span>
<span class="p_chunk">@@ -1806,8 +1806,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(bio_endio_nodec);</span>
  * Allocates and returns a new bio which represents @sectors from the start of
  * @bio, and updates @bio to represent the remaining sectors.
  *
<span class="p_del">- * The newly allocated bio will point to @bio&#39;s bi_io_vec; it is the caller&#39;s</span>
<span class="p_del">- * responsibility to ensure that @bio is not freed before the split.</span>
<span class="p_add">+ * Unless this is a discard request the newly allocated bio will point</span>
<span class="p_add">+ * to @bio&#39;s bi_io_vec; it is the caller&#39;s responsibility to ensure that</span>
<span class="p_add">+ * @bio is not freed before the split.</span>
  */
 struct bio *bio_split(struct bio *bio, int sectors,
 		      gfp_t gfp, struct bio_set *bs)
<span class="p_chunk">@@ -1817,7 +1818,15 @@</span> <span class="p_context"> struct bio *bio_split(struct bio *bio, int sectors,</span>
 	BUG_ON(sectors &lt;= 0);
 	BUG_ON(sectors &gt;= bio_sectors(bio));
 
<span class="p_del">-	split = bio_clone_fast(bio, gfp, bs);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Discards need a mutable bio_vec to accommodate the payload</span>
<span class="p_add">+	 * required by the DSM TRIM and UNMAP commands.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bio-&gt;bi_rw &amp; REQ_DISCARD)</span>
<span class="p_add">+		split = bio_clone_bioset(bio, gfp, bs);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		split = bio_clone_fast(bio, gfp, bs);</span>
<span class="p_add">+</span>
 	if (!split)
 		return NULL;
 
<span class="p_header">diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c</span>
<span class="p_header">index ab485e57b6fe..644942aeaeda 100644</span>
<span class="p_header">--- a/fs/btrfs/inode-map.c</span>
<span class="p_header">+++ b/fs/btrfs/inode-map.c</span>
<span class="p_chunk">@@ -281,7 +281,7 @@</span> <span class="p_context"> void btrfs_unpin_free_ino(struct btrfs_root *root)</span>
 		__btrfs_add_free_space(ctl, info-&gt;offset, count);
 free:
 		rb_erase(&amp;info-&gt;offset_index, rbroot);
<span class="p_del">-		kfree(info);</span>
<span class="p_add">+		kmem_cache_free(btrfs_free_space_cachep, info);</span>
 	}
 }
 
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 3e16042338e4..d40ae42ba6d4 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2743,7 +2743,7 @@</span> <span class="p_context"> out_unlock:</span>
 static long btrfs_ioctl_file_extent_same(struct file *file,
 			struct btrfs_ioctl_same_args __user *argp)
 {
<span class="p_del">-	struct btrfs_ioctl_same_args *same;</span>
<span class="p_add">+	struct btrfs_ioctl_same_args *same = NULL;</span>
 	struct btrfs_ioctl_same_extent_info *info;
 	struct inode *src = file_inode(file);
 	u64 off;
<span class="p_chunk">@@ -2773,6 +2773,7 @@</span> <span class="p_context"> static long btrfs_ioctl_file_extent_same(struct file *file,</span>
 
 	if (IS_ERR(same)) {
 		ret = PTR_ERR(same);
<span class="p_add">+		same = NULL;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -2843,6 +2844,7 @@</span> <span class="p_context"> static long btrfs_ioctl_file_extent_same(struct file *file,</span>
 
 out:
 	mnt_drop_write_file(file);
<span class="p_add">+	kfree(same);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c</span>
<span class="p_header">index e6574d7b6642..a7c5277a728f 100644</span>
<span class="p_header">--- a/fs/ext4/indirect.c</span>
<span class="p_header">+++ b/fs/ext4/indirect.c</span>
<span class="p_chunk">@@ -576,7 +576,7 @@</span> <span class="p_context"> int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {
 		EXT4_ERROR_INODE(inode, &quot;Can&#39;t allocate blocks for &quot;
 				 &quot;non-extent mapped inodes with bigalloc&quot;);
<span class="p_del">-		return -ENOSPC;</span>
<span class="p_add">+		return -EUCLEAN;</span>
 	}
 
 	goal = ext4_find_goal(inode, map-&gt;m_lblk, partial);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index da03340fdb17..f9c63ae7276a 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1357,7 +1357,7 @@</span> <span class="p_context"> static void ext4_da_page_release_reservation(struct page *page,</span>
 					     unsigned int offset,
 					     unsigned int length)
 {
<span class="p_del">-	int to_release = 0;</span>
<span class="p_add">+	int to_release = 0, contiguous_blks = 0;</span>
 	struct buffer_head *head, *bh;
 	unsigned int curr_off = 0;
 	struct inode *inode = page-&gt;mapping-&gt;host;
<span class="p_chunk">@@ -1378,14 +1378,23 @@</span> <span class="p_context"> static void ext4_da_page_release_reservation(struct page *page,</span>
 
 		if ((offset &lt;= curr_off) &amp;&amp; (buffer_delay(bh))) {
 			to_release++;
<span class="p_add">+			contiguous_blks++;</span>
 			clear_buffer_delay(bh);
<span class="p_add">+		} else if (contiguous_blks) {</span>
<span class="p_add">+			lblk = page-&gt;index &lt;&lt;</span>
<span class="p_add">+			       (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);</span>
<span class="p_add">+			lblk += (curr_off &gt;&gt; inode-&gt;i_blkbits) -</span>
<span class="p_add">+				contiguous_blks;</span>
<span class="p_add">+			ext4_es_remove_extent(inode, lblk, contiguous_blks);</span>
<span class="p_add">+			contiguous_blks = 0;</span>
 		}
 		curr_off = next_off;
 	} while ((bh = bh-&gt;b_this_page) != head);
 
<span class="p_del">-	if (to_release) {</span>
<span class="p_add">+	if (contiguous_blks) {</span>
 		lblk = page-&gt;index &lt;&lt; (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);
<span class="p_del">-		ext4_es_remove_extent(inode, lblk, to_release);</span>
<span class="p_add">+		lblk += (curr_off &gt;&gt; inode-&gt;i_blkbits) - contiguous_blks;</span>
<span class="p_add">+		ext4_es_remove_extent(inode, lblk, contiguous_blks);</span>
 	}
 
 	/* If we have released all the blocks belonging to a cluster, then we
<span class="p_chunk">@@ -1744,19 +1753,32 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 		ext4_walk_page_buffers(handle, page_bufs, 0, len,
 				       NULL, bget_one);
 	}
<span class="p_del">-	/* As soon as we unlock the page, it can go away, but we have</span>
<span class="p_del">-	 * references to buffers so we are safe */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to release the page lock before we start the</span>
<span class="p_add">+	 * journal, so grab a reference so the page won&#39;t disappear</span>
<span class="p_add">+	 * out from under us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	get_page(page);</span>
 	unlock_page(page);
 
 	handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,
 				    ext4_writepage_trans_blocks(inode));
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		put_page(page);</span>
<span class="p_add">+		goto out_no_pagelock;</span>
 	}
<span class="p_del">-</span>
 	BUG_ON(!ext4_handle_valid(handle));
 
<span class="p_add">+	lock_page(page);</span>
<span class="p_add">+	put_page(page);</span>
<span class="p_add">+	if (page-&gt;mapping != mapping) {</span>
<span class="p_add">+		/* The page got truncated from under us */</span>
<span class="p_add">+		ext4_journal_stop(handle);</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (inline_data) {
 		ret = ext4_journal_get_write_access(handle, inode_bh);
 
<span class="p_chunk">@@ -1781,6 +1803,8 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 				       NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:
<span class="p_add">+	unlock_page(page);</span>
<span class="p_add">+out_no_pagelock:</span>
 	brelse(inode_bh);
 	return ret;
 }
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index 7620133f78bf..c4a5e4df8ca3 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -4793,18 +4793,12 @@</span> <span class="p_context"> do_more:</span>
 		/*
 		 * blocks being freed are metadata. these blocks shouldn&#39;t
 		 * be used until this transaction is committed
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed</span>
<span class="p_add">+		 * to fail.</span>
 		 */
<span class="p_del">-	retry:</span>
<span class="p_del">-		new_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);</span>
<span class="p_del">-		if (!new_entry) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We use a retry loop because</span>
<span class="p_del">-			 * ext4_free_blocks() is not allowed to fail.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			cond_resched();</span>
<span class="p_del">-			congestion_wait(BLK_RW_ASYNC, HZ/50);</span>
<span class="p_del">-			goto retry;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		new_entry = kmem_cache_alloc(ext4_free_data_cachep,</span>
<span class="p_add">+				GFP_NOFS|__GFP_NOFAIL);</span>
 		new_entry-&gt;efd_start_cluster = bit;
 		new_entry-&gt;efd_group = block_group;
 		new_entry-&gt;efd_count = count_clusters;
<span class="p_header">diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c</span>
<span class="p_header">index 2ae73a80c19b..be92ed2609bc 100644</span>
<span class="p_header">--- a/fs/ext4/migrate.c</span>
<span class="p_header">+++ b/fs/ext4/migrate.c</span>
<span class="p_chunk">@@ -616,6 +616,7 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 	struct ext4_inode_info		*ei = EXT4_I(inode);
 	struct ext4_extent		*ex;
 	unsigned int			i, len;
<span class="p_add">+	ext4_lblk_t			start, end;</span>
 	ext4_fsblk_t			blk;
 	handle_t			*handle;
 	int				ret;
<span class="p_chunk">@@ -629,6 +630,14 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC))
 		return -EOPNOTSUPP;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In order to get correct extent info, force all delayed allocation</span>
<span class="p_add">+	 * blocks to be allocated, otherwise delayed allocation blocks may not</span>
<span class="p_add">+	 * be reflected and bypass the checks on extent header.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (test_opt(inode-&gt;i_sb, DELALLOC))</span>
<span class="p_add">+		ext4_alloc_da_blocks(inode);</span>
<span class="p_add">+</span>
 	handle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
<span class="p_chunk">@@ -646,11 +655,13 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 		goto errout;
 	}
 	if (eh-&gt;eh_entries == 0)
<span class="p_del">-		blk = len = 0;</span>
<span class="p_add">+		blk = len = start = end = 0;</span>
 	else {
 		len = le16_to_cpu(ex-&gt;ee_len);
 		blk = ext4_ext_pblock(ex);
<span class="p_del">-		if (len &gt; EXT4_NDIR_BLOCKS) {</span>
<span class="p_add">+		start = le32_to_cpu(ex-&gt;ee_block);</span>
<span class="p_add">+		end = start + len - 1;</span>
<span class="p_add">+		if (end &gt;= EXT4_NDIR_BLOCKS) {</span>
 			ret = -EOPNOTSUPP;
 			goto errout;
 		}
<span class="p_chunk">@@ -658,7 +669,7 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 
 	ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);
 	memset(ei-&gt;i_data, 0, sizeof(ei-&gt;i_data));
<span class="p_del">-	for (i=0; i &lt; len; i++)</span>
<span class="p_add">+	for (i = start; i &lt;= end; i++)</span>
 		ei-&gt;i_data[i] = cpu_to_le32(blk++);
 	ext4_mark_inode_dirty(handle, inode);
 errout:
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 9fb3e6c0c578..a07af5b7a575 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -832,6 +832,7 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 		dump_orphan_list(sb, sbi);
 	J_ASSERT(list_empty(&amp;sbi-&gt;s_orphan));
 
<span class="p_add">+	sync_blockdev(sb-&gt;s_bdev);</span>
 	invalidate_bdev(sb-&gt;s_bdev);
 	if (sbi-&gt;journal_bdev &amp;&amp; sbi-&gt;journal_bdev != sb-&gt;s_bdev) {
 		/*
<span class="p_header">diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c</span>
<span class="p_header">index 73f6bcb44ea8..faf00af7f3d7 100644</span>
<span class="p_header">--- a/fs/fuse/inode.c</span>
<span class="p_header">+++ b/fs/fuse/inode.c</span>
<span class="p_chunk">@@ -1026,6 +1026,7 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		goto err_fput;
 
 	fuse_conn_init(fc);
<span class="p_add">+	fc-&gt;release = fuse_free_conn;</span>
 
 	fc-&gt;dev = sb-&gt;s_dev;
 	fc-&gt;sb = sb;
<span class="p_chunk">@@ -1040,7 +1041,6 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		fc-&gt;dont_mask = 1;
 	sb-&gt;s_flags |= MS_POSIXACL;
 
<span class="p_del">-	fc-&gt;release = fuse_free_conn;</span>
 	fc-&gt;flags = d.flags;
 	fc-&gt;user_id = d.user_id;
 	fc-&gt;group_id = d.group_id;
<span class="p_header">diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c</span>
<span class="p_header">index 4534ff688b76..77b583da187f 100644</span>
<span class="p_header">--- a/fs/hpfs/super.c</span>
<span class="p_header">+++ b/fs/hpfs/super.c</span>
<span class="p_chunk">@@ -52,17 +52,20 @@</span> <span class="p_context"> static void unmark_dirty(struct super_block *s)</span>
 }
 
 /* Filesystem error... */
<span class="p_del">-static char err_buf[1024];</span>
<span class="p_del">-</span>
 void hpfs_error(struct super_block *s, const char *fmt, ...)
 {
<span class="p_add">+	struct va_format vaf;</span>
 	va_list args;
 
 	va_start(args, fmt);
<span class="p_del">-	vsnprintf(err_buf, sizeof(err_buf), fmt, args);</span>
<span class="p_add">+</span>
<span class="p_add">+	vaf.fmt = fmt;</span>
<span class="p_add">+	vaf.va = &amp;args;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_err(&quot;filesystem error: %pV&quot;, &amp;vaf);</span>
<span class="p_add">+</span>
 	va_end(args);
 
<span class="p_del">-	printk(&quot;HPFS: filesystem error: %s&quot;, err_buf);</span>
 	if (!hpfs_sb(s)-&gt;sb_was_error) {
 		if (hpfs_sb(s)-&gt;sb_err == 2) {
 			printk(&quot;; crashing the system because you wanted it\n&quot;);
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index 7f34f4716165..b892355f1944 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	unsigned long	blocknr;
 
 	if (is_journal_aborted(journal))
<span class="p_del">-		return 1;</span>
<span class="p_add">+		return -EIO;</span>
 
 	if (!jbd2_journal_get_log_tail(journal, &amp;first_tid, &amp;blocknr))
 		return 1;
<span class="p_chunk">@@ -463,10 +463,9 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	 * jbd2_cleanup_journal_tail() doesn&#39;t get called all that often.
 	 */
 	if (journal-&gt;j_flags &amp; JBD2_BARRIER)
<span class="p_del">-		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_KERNEL, NULL);</span>
<span class="p_add">+		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_NOFS, NULL);</span>
 
<span class="p_del">-	__jbd2_update_log_tail(journal, first_tid, blocknr);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return __jbd2_update_log_tail(journal, first_tid, blocknr);</span>
 }
 
 
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index f2d78a3dae43..e8d62d742435 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -885,9 +885,10 @@</span> <span class="p_context"> int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,</span>
  *
  * Requires j_checkpoint_mutex
  */
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 {
 	unsigned long freed;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 
<span class="p_chunk">@@ -897,7 +898,10 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	 * space and if we lose sb update during power failure we&#39;d replay
 	 * old transaction with possibly newly overwritten data.
 	 */
<span class="p_del">-	jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	ret = jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	write_lock(&amp;journal-&gt;j_state_lock);
 	freed = block - journal-&gt;j_tail;
 	if (block &lt; journal-&gt;j_tail)
<span class="p_chunk">@@ -913,6 +917,9 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	journal-&gt;j_tail_sequence = tid;
 	journal-&gt;j_tail = block;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_chunk">@@ -1331,7 +1338,7 @@</span> <span class="p_context"> static int journal_reset(journal_t *journal)</span>
 	return jbd2_journal_start_thread(journal);
 }
 
<span class="p_del">-static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
<span class="p_add">+static int jbd2_write_superblock(journal_t *journal, int write_op)</span>
 {
 	struct buffer_head *bh = journal-&gt;j_sb_buffer;
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_chunk">@@ -1370,7 +1377,10 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
 		printk(KERN_ERR &quot;JBD2: Error %d detected when updating &quot;
 		       &quot;journal superblock for %s.\n&quot;, ret,
 		       journal-&gt;j_devname);
<span class="p_add">+		jbd2_journal_abort(journal, ret);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1383,10 +1393,11 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
  * Update a journal&#39;s superblock information about log tail and write it to
  * disk, waiting for the IO to complete.
  */
<span class="p_del">-void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
<span class="p_add">+int jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 				     unsigned long tail_block, int write_op)
 {
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 	jbd_debug(1, &quot;JBD2: updating superblock (start %lu, seq %u)\n&quot;,
<span class="p_chunk">@@ -1395,13 +1406,18 @@</span> <span class="p_context"> void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 	sb-&gt;s_sequence = cpu_to_be32(tail_tid);
 	sb-&gt;s_start    = cpu_to_be32(tail_block);
 
<span class="p_del">-	jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	ret = jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
 
 	/* Log is no longer empty */
 	write_lock(&amp;journal-&gt;j_state_lock);
 	WARN_ON(!sb-&gt;s_sequence);
 	journal-&gt;j_flags &amp;= ~JBD2_FLUSHED;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1952,7 +1968,14 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 		return -EIO;
 
 	mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-	jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		err = jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+	}</span>
 
 	/* Finally, mark the journal as really needing no recovery.
 	 * This sets s_start==0 in the underlying superblock, which is
<span class="p_chunk">@@ -1968,7 +1991,8 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	J_ASSERT(journal-&gt;j_head == journal-&gt;j_tail);
 	J_ASSERT(journal-&gt;j_tail_sequence == journal-&gt;j_transaction_sequence);
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	return 0;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return err;</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c</span>
<span class="p_header">index fa6d72131c19..4495cad189c3 100644</span>
<span class="p_header">--- a/fs/nfs/nfs3xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs3xdr.c</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> static void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,</span>
 	if (args-&gt;npages != 0)
 		xdr_write_pages(xdr, args-&gt;pages, 0, args-&gt;len);
 	else
<span class="p_del">-		xdr_reserve_space(xdr, NFS_ACL_INLINE_BUFSIZE);</span>
<span class="p_add">+		xdr_reserve_space(xdr, args-&gt;len);</span>
 
 	error = nfsacl_encode(xdr-&gt;buf, base, args-&gt;inode,
 			    (args-&gt;mask &amp; NFS_ACL) ?
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index b4f177f1d405..c402b672a474 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1482,6 +1482,8 @@</span> <span class="p_context"> restart:</span>
 					spin_unlock(&amp;state-&gt;state_lock);
 				}
 				nfs4_put_open_state(state);
<span class="p_add">+				clear_bit(NFS4CLNT_RECLAIM_NOGRACE,</span>
<span class="p_add">+					&amp;state-&gt;flags);</span>
 				spin_lock(&amp;sp-&gt;so_lock);
 				goto restart;
 			}
<span class="p_header">diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c</span>
<span class="p_header">index 14e58f2c96bd..98d4948feba0 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_symlink.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_symlink.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> xfs_readlink_bmap(</span>
 			cur_chunk += sizeof(struct xfs_dsymlink_hdr);
 		}
 
<span class="p_del">-		memcpy(link + offset, bp-&gt;b_addr, byte_cnt);</span>
<span class="p_add">+		memcpy(link + offset, cur_chunk, byte_cnt);</span>
 
 		pathlen -= byte_cnt;
 		offset += byte_cnt;
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index 8fc12f80b616..69afb5780815 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -561,6 +561,7 @@</span> <span class="p_context"> typedef u64 acpi_integer;</span>
 #define ACPI_NO_ACPI_ENABLE             0x10
 #define ACPI_NO_DEVICE_INIT             0x20
 #define ACPI_NO_OBJECT_INIT             0x40
<span class="p_add">+#define ACPI_NO_FACS_INIT               0x80</span>
 
 /*
  * Initialization state
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index cd80aa80d03e..77af62187e7a 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -402,6 +402,7 @@</span> <span class="p_context"> extern acpi_status acpi_pci_osc_control_set(acpi_handle handle,</span>
 #define ACPI_OST_SC_INSERT_NOT_SUPPORTED	0x82
 
 extern void acpi_early_init(void);
<span class="p_add">+extern void acpi_subsystem_init(void);</span>
 
 extern int acpi_nvs_register(__u64 start, __u64 size);
 
<span class="p_chunk">@@ -436,6 +437,7 @@</span> <span class="p_context"> static inline const char *acpi_dev_name(struct acpi_device *adev)</span>
 }
 
 static inline void acpi_early_init(void) { }
<span class="p_add">+static inline void acpi_subsystem_init(void) { }</span>
 
 static inline int early_acpi_boot_init(void)
 {
<span class="p_header">diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h</span>
<span class="p_header">index 0dae71e9971c..e1fb0f613a99 100644</span>
<span class="p_header">--- a/include/linux/jbd2.h</span>
<span class="p_header">+++ b/include/linux/jbd2.h</span>
<span class="p_chunk">@@ -1035,7 +1035,7 @@</span> <span class="p_context"> struct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal);</span>
 int jbd2_journal_next_log_block(journal_t *, unsigned long long *);
 int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,
 			      unsigned long *block);
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
 void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);
 
 /* Commit management */
<span class="p_chunk">@@ -1157,7 +1157,7 @@</span> <span class="p_context"> extern int	   jbd2_journal_recover    (journal_t *journal);</span>
 extern int	   jbd2_journal_wipe       (journal_t *, int);
 extern int	   jbd2_journal_skip_recovery	(journal_t *);
 extern void	   jbd2_journal_update_sb_errno(journal_t *);
<span class="p_del">-extern void	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
<span class="p_add">+extern int	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
 				unsigned long, int);
 extern void	   __jbd2_journal_abort_hard	(journal_t *);
 extern void	   jbd2_journal_abort      (journal_t *, int);
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index b84e786ff990..189c9ff97b29 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -428,6 +428,7 @@</span> <span class="p_context"> enum {</span>
 	ATA_HORKAGE_NO_NCQ_TRIM	= (1 &lt;&lt; 19),	/* don&#39;t use queued TRIM */
 	ATA_HORKAGE_NOLPM	= (1 &lt;&lt; 20),	/* don&#39;t use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 &lt;&lt; 21),	/* some WDs have broken LPM */
<span class="p_add">+	ATA_HORKAGE_NOTRIM = (1 &lt;&lt; 24),		/* don&#39;t use TRIM */</span>
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */
<span class="p_header">diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h</span>
<span class="p_header">index 53988cb3c05a..3a36a2c33aef 100644</span>
<span class="p_header">--- a/include/linux/nfs_xdr.h</span>
<span class="p_header">+++ b/include/linux/nfs_xdr.h</span>
<span class="p_chunk">@@ -1155,7 +1155,7 @@</span> <span class="p_context"> struct nfs41_state_protection {</span>
 	struct nfs4_op_map allow;
 };
 
<span class="p_del">-#define NFS4_EXCHANGE_ID_LEN	(48)</span>
<span class="p_add">+#define NFS4_EXCHANGE_ID_LEN	(127)</span>
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;
<span class="p_header">diff --git a/include/linux/of.h b/include/linux/of.h</span>
<span class="p_header">index 3f8144dadaef..9f2698de732b 100644</span>
<span class="p_header">--- a/include/linux/of.h</span>
<span class="p_header">+++ b/include/linux/of.h</span>
<span class="p_chunk">@@ -517,7 +517,10 @@</span> <span class="p_context"> static inline const char *of_prop_next_string(struct property *prop,</span>
 #if defined(CONFIG_OF) &amp;&amp; defined(CONFIG_NUMA)
 extern int of_node_to_nid(struct device_node *np);
 #else
<span class="p_del">-static inline int of_node_to_nid(struct device_node *device) { return 0; }</span>
<span class="p_add">+static inline int of_node_to_nid(struct device_node *device)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
<span class="p_add">+}</span>
 #endif
 
 static inline struct device_node *of_find_matching_node(
<span class="p_header">diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h</span>
<span class="p_header">index 0c65e4b12617..ef29266ef77a 100644</span>
<span class="p_header">--- a/include/uapi/linux/usbdevice_fs.h</span>
<span class="p_header">+++ b/include/uapi/linux/usbdevice_fs.h</span>
<span class="p_chunk">@@ -125,11 +125,12 @@</span> <span class="p_context"> struct usbdevfs_hub_portinfo {</span>
 	char port [127];	/* e.g. port 3 connects to device 27 */
 };
 
<span class="p_del">-/* Device capability flags */</span>
<span class="p_add">+/* System and bus capability flags */</span>
 #define USBDEVFS_CAP_ZERO_PACKET		0x01
 #define USBDEVFS_CAP_BULK_CONTINUATION		0x02
 #define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
 #define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
<span class="p_add">+#define USBDEVFS_CAP_REAP_AFTER_DISCONNECT	0x10</span>
 
 /* USBDEVFS_DISCONNECT_CLAIM flags &amp; struct */
 
<span class="p_header">diff --git a/init/main.c b/init/main.c</span>
<span class="p_header">index 58c132d7de4b..008edceecf03 100644</span>
<span class="p_header">--- a/init/main.c</span>
<span class="p_header">+++ b/init/main.c</span>
<span class="p_chunk">@@ -643,6 +643,7 @@</span> <span class="p_context"> asmlinkage void __init start_kernel(void)</span>
 
 	check_bugs();
 
<span class="p_add">+	acpi_subsystem_init();</span>
 	sfi_init_late();
 
 	if (efi_enabled(EFI_RUNTIME_SERVICES)) {
<span class="p_header">diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c</span>
<span class="p_header">index 1ef0606797c9..0296d6fd7d4e 100644</span>
<span class="p_header">--- a/kernel/irq/devres.c</span>
<span class="p_header">+++ b/kernel/irq/devres.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> int devm_request_any_context_irq(struct device *dev, unsigned int irq,</span>
 		return -ENOMEM;
 
 	rc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);
<span class="p_del">-	if (rc) {</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
 		devres_free(dr);
 		return rc;
 	}
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> int devm_request_any_context_irq(struct device *dev, unsigned int irq,</span>
 	dr-&gt;dev_id = dev_id;
 	devres_add(dev, dr);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return rc;</span>
 }
 EXPORT_SYMBOL(devm_request_any_context_irq);
 
<span class="p_header">diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig</span>
<span class="p_header">index 2fac9cc79b3d..9d1862866786 100644</span>
<span class="p_header">--- a/kernel/power/Kconfig</span>
<span class="p_header">+++ b/kernel/power/Kconfig</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> config DPM_WATCHDOG</span>
 config DPM_WATCHDOG_TIMEOUT
 	int &quot;Watchdog timeout in seconds&quot;
 	range 1 120
<span class="p_del">-	default 12</span>
<span class="p_add">+	default 60</span>
 	depends on DPM_WATCHDOG
 
 config PM_TRACE
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index a755ad70fe8f..02e7fb4edb93 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -383,11 +383,11 @@</span> <span class="p_context"> static int check_syslog_permissions(int type, bool from_file)</span>
 	 * already done the capabilities checks at open time.
 	 */
 	if (from_file &amp;&amp; type != SYSLOG_ACTION_OPEN)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto ok;</span>
 
 	if (syslog_action_restricted(type)) {
 		if (capable(CAP_SYSLOG))
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		/*
 		 * For historical reasons, accept CAP_SYS_ADMIN too, with
 		 * a warning.
<span class="p_chunk">@@ -397,10 +397,11 @@</span> <span class="p_context"> static int check_syslog_permissions(int type, bool from_file)</span>
 				     &quot;CAP_SYS_ADMIN but no CAP_SYSLOG &quot;
 				     &quot;(deprecated).\n&quot;,
 				 current-&gt;comm, task_pid_nr(current));
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		}
 		return -EPERM;
 	}
<span class="p_add">+ok:</span>
 	return security_syslog(type);
 }
 
<span class="p_chunk">@@ -1126,10 +1127,6 @@</span> <span class="p_context"> int do_syslog(int type, char __user *buf, int len, bool from_file)</span>
 	if (error)
 		goto out;
 
<span class="p_del">-	error = security_syslog(type);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	switch (type) {
 	case SYSLOG_ACTION_CLOSE:	/* Close log */
 		break;
<span class="p_header">diff --git a/kernel/rcu/tiny.c b/kernel/rcu/tiny.c</span>
<span class="p_header">index 1254f312d024..ae359f0302c4 100644</span>
<span class="p_header">--- a/kernel/rcu/tiny.c</span>
<span class="p_header">+++ b/kernel/rcu/tiny.c</span>
<span class="p_chunk">@@ -284,6 +284,11 @@</span> <span class="p_context"> static void __rcu_process_callbacks(struct rcu_ctrlblk *rcp)</span>
 
 	/* Move the ready-to-invoke callbacks to a local list. */
 	local_irq_save(flags);
<span class="p_add">+	if (rcp-&gt;donetail == &amp;rcp-&gt;rcucblist) {</span>
<span class="p_add">+		/* No callbacks ready, so just leave. */</span>
<span class="p_add">+		local_irq_restore(flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	RCU_TRACE(trace_rcu_batch_start(rcp-&gt;name, 0, rcp-&gt;qlen, -1));
 	list = rcp-&gt;rcucblist;
 	rcp-&gt;rcucblist = *rcp-&gt;donetail;
<span class="p_header">diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h</span>
<span class="p_header">index c8bd809cbd1c..c1be95c26046 100644</span>
<span class="p_header">--- a/kernel/trace/trace.h</span>
<span class="p_header">+++ b/kernel/trace/trace.h</span>
<span class="p_chunk">@@ -422,6 +422,7 @@</span> <span class="p_context"> enum {</span>
 
 	TRACE_CONTROL_BIT,
 
<span class="p_add">+	TRACE_BRANCH_BIT,</span>
 /*
  * Abuse of the trace_recursion.
  * As we need a way to maintain state if we are tracing the function
<span class="p_header">diff --git a/kernel/trace/trace_branch.c b/kernel/trace/trace_branch.c</span>
<span class="p_header">index 697fb9bac8f0..60850b4fcb04 100644</span>
<span class="p_header">--- a/kernel/trace/trace_branch.c</span>
<span class="p_header">+++ b/kernel/trace/trace_branch.c</span>
<span class="p_chunk">@@ -37,9 +37,12 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 	struct trace_branch *entry;
 	struct ring_buffer *buffer;
 	unsigned long flags;
<span class="p_del">-	int cpu, pc;</span>
<span class="p_add">+	int pc;</span>
 	const char *p;
 
<span class="p_add">+	if (current-&gt;trace_recursion &amp; TRACE_BRANCH_BIT)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/*
 	 * I would love to save just the ftrace_likely_data pointer, but
 	 * this code can also be used by modules. Ugly things can happen
<span class="p_chunk">@@ -50,10 +53,10 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 	if (unlikely(!tr))
 		return;
 
<span class="p_del">-	local_irq_save(flags);</span>
<span class="p_del">-	cpu = raw_smp_processor_id();</span>
<span class="p_del">-	data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);</span>
<span class="p_del">-	if (atomic_inc_return(&amp;data-&gt;disabled) != 1)</span>
<span class="p_add">+	raw_local_irq_save(flags);</span>
<span class="p_add">+	current-&gt;trace_recursion |= TRACE_BRANCH_BIT;</span>
<span class="p_add">+	data = this_cpu_ptr(tr-&gt;trace_buffer.data);</span>
<span class="p_add">+	if (atomic_read(&amp;data-&gt;disabled))</span>
 		goto out;
 
 	pc = preempt_count();
<span class="p_chunk">@@ -82,8 +85,8 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 		__buffer_unlock_commit(buffer, event);
 
  out:
<span class="p_del">-	atomic_dec(&amp;data-&gt;disabled);</span>
<span class="p_del">-	local_irq_restore(flags);</span>
<span class="p_add">+	current-&gt;trace_recursion &amp;= ~TRACE_BRANCH_BIT;</span>
<span class="p_add">+	raw_local_irq_restore(flags);</span>
 }
 
 static inline
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index cb347e85f75e..7b244d004d68 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1086,6 +1086,9 @@</span> <span class="p_context"> static void parse_init(struct filter_parse_state *ps,</span>
 
 static char infix_next(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 
 	return ps-&gt;infix.string[ps-&gt;infix.tail++];
<span class="p_chunk">@@ -1101,6 +1104,9 @@</span> <span class="p_context"> static char infix_peek(struct filter_parse_state *ps)</span>
 
 static void infix_advance(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 	ps-&gt;infix.tail++;
 }
<span class="p_chunk">@@ -1413,7 +1419,9 @@</span> <span class="p_context"> static int check_preds(struct filter_parse_state *ps)</span>
 			continue;
 		}
 		n_normal_preds++;
<span class="p_del">-		WARN_ON_ONCE(cnt &lt; 0);</span>
<span class="p_add">+		/* all ops should have operands */</span>
<span class="p_add">+		if (cnt &lt; 0)</span>
<span class="p_add">+			break;</span>
 	}
 
 	if (cnt != 1 || !n_normal_preds || n_logical_preds &gt;= n_normal_preds) {
<span class="p_header">diff --git a/lib/bitmap.c b/lib/bitmap.c</span>
<span class="p_header">index e5c4ebe586ba..c0634aa923a6 100644</span>
<span class="p_header">--- a/lib/bitmap.c</span>
<span class="p_header">+++ b/lib/bitmap.c</span>
<span class="p_chunk">@@ -603,12 +603,12 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 	unsigned a, b;
 	int c, old_c, totaldigits;
 	const char __user __force *ubuf = (const char __user __force *)buf;
<span class="p_del">-	int exp_digit, in_range;</span>
<span class="p_add">+	int at_start, in_range;</span>
 
 	totaldigits = c = 0;
 	bitmap_zero(maskp, nmaskbits);
 	do {
<span class="p_del">-		exp_digit = 1;</span>
<span class="p_add">+		at_start = 1;</span>
 		in_range = 0;
 		a = b = 0;
 
<span class="p_chunk">@@ -637,11 +637,10 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 				break;
 
 			if (c == &#39;-&#39;) {
<span class="p_del">-				if (exp_digit || in_range)</span>
<span class="p_add">+				if (at_start || in_range)</span>
 					return -EINVAL;
 				b = 0;
 				in_range = 1;
<span class="p_del">-				exp_digit = 1;</span>
 				continue;
 			}
 
<span class="p_chunk">@@ -651,16 +650,18 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 			b = b * 10 + (c - &#39;0&#39;);
 			if (!in_range)
 				a = b;
<span class="p_del">-			exp_digit = 0;</span>
<span class="p_add">+			at_start = 0;</span>
 			totaldigits++;
 		}
 		if (!(a &lt;= b))
 			return -EINVAL;
 		if (b &gt;= nmaskbits)
 			return -ERANGE;
<span class="p_del">-		while (a &lt;= b) {</span>
<span class="p_del">-			set_bit(a, maskp);</span>
<span class="p_del">-			a++;</span>
<span class="p_add">+		if (!at_start) {</span>
<span class="p_add">+			while (a &lt;= b) {</span>
<span class="p_add">+				set_bit(a, maskp);</span>
<span class="p_add">+				a++;</span>
<span class="p_add">+			}</span>
 		}
 	} while (buflen &amp;&amp; c == &#39;,&#39;);
 	return 0;
<span class="p_header">diff --git a/net/9p/client.c b/net/9p/client.c</span>
<span class="p_header">index 9186550d77a6..08046f39f09c 100644</span>
<span class="p_header">--- a/net/9p/client.c</span>
<span class="p_header">+++ b/net/9p/client.c</span>
<span class="p_chunk">@@ -839,7 +839,8 @@</span> <span class="p_context"> static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,</span>
 	if (err &lt; 0) {
 		if (err == -EIO)
 			c-&gt;status = Disconnected;
<span class="p_del">-		goto reterr;</span>
<span class="p_add">+		if (err != -ERESTARTSYS)</span>
<span class="p_add">+			goto reterr;</span>
 	}
 	if (req-&gt;status == REQ_STATUS_ERROR) {
 		p9_debug(P9_DEBUG_ERROR, &quot;req_status error %d\n&quot;, req-&gt;t_err);
<span class="p_header">diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c</span>
<span class="p_header">index aade4a5c1c07..bde94d853b2b 100644</span>
<span class="p_header">--- a/net/ceph/osdmap.c</span>
<span class="p_header">+++ b/net/ceph/osdmap.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> static int crush_decode_tree_bucket(void **p, void *end,</span>
 {
 	int j;
 	dout(&quot;crush_decode_tree_bucket %p to %p\n&quot;, *p, end);
<span class="p_del">-	ceph_decode_32_safe(p, end, b-&gt;num_nodes, bad);</span>
<span class="p_add">+	ceph_decode_8_safe(p, end, b-&gt;num_nodes, bad);</span>
 	b-&gt;node_weights = kcalloc(b-&gt;num_nodes, sizeof(u32), GFP_NOFS);
 	if (b-&gt;node_weights == NULL)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/mac80211/main.c b/net/mac80211/main.c</span>
<span class="p_header">index c7a7a86afdb8..9e58c99e3bdc 100644</span>
<span class="p_header">--- a/net/mac80211/main.c</span>
<span class="p_header">+++ b/net/mac80211/main.c</span>
<span class="p_chunk">@@ -248,6 +248,7 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 {
 	struct ieee80211_local *local =
 		container_of(work, struct ieee80211_local, restart_work);
<span class="p_add">+	struct ieee80211_sub_if_data *sdata;</span>
 
 	/* wait for scan work complete */
 	flush_workqueue(local-&gt;workqueue);
<span class="p_chunk">@@ -256,6 +257,8 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 	     &quot;%s called with hardware scan in progress\n&quot;, __func__);
 
 	rtnl_lock();
<span class="p_add">+	list_for_each_entry(sdata, &amp;local-&gt;interfaces, list)</span>
<span class="p_add">+		flush_delayed_work(&amp;sdata-&gt;dec_tailroom_needed_wk);</span>
 	ieee80211_scan_cancel(local);
 	ieee80211_reconfig(local);
 	rtnl_unlock();
<span class="p_header">diff --git a/net/sunrpc/backchannel_rqst.c b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">index e860d4f7ed2a..ab219685336c 100644</span>
<span class="p_header">--- a/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">+++ b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> static void xprt_free_allocation(struct rpc_rqst *req)</span>
 
 	dprintk(&quot;RPC:        free allocations for req= %p\n&quot;, req);
 	WARN_ON_ONCE(test_bit(RPC_BC_PA_IN_USE, &amp;req-&gt;rq_bc_pa_state));
<span class="p_del">-	xbufp = &amp;req-&gt;rq_private_buf;</span>
<span class="p_add">+	xbufp = &amp;req-&gt;rq_rcv_buf;</span>
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
 	xbufp = &amp;req-&gt;rq_snd_buf;
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
<span class="p_header">diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c</span>
<span class="p_header">index 7e71e066198f..048550aacffc 100644</span>
<span class="p_header">--- a/security/integrity/evm/evm_main.c</span>
<span class="p_header">+++ b/security/integrity/evm/evm_main.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/xattr.h&gt;
 #include &lt;linux/integrity.h&gt;
 #include &lt;linux/evm.h&gt;
<span class="p_add">+#include &lt;linux/magic.h&gt;</span>
 #include &lt;crypto/hash.h&gt;
 #include &quot;evm.h&quot;
 
<span class="p_chunk">@@ -275,6 +276,17 @@</span> <span class="p_context"> static int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,</span>
 		iint = integrity_iint_find(dentry-&gt;d_inode);
 		if (iint &amp;&amp; (iint-&gt;flags &amp; IMA_NEW_FILE))
 			return 0;
<span class="p_add">+</span>
<span class="p_add">+		/* exception for pseudo filesystems */</span>
<span class="p_add">+		if (dentry-&gt;d_inode-&gt;i_sb-&gt;s_magic == TMPFS_MAGIC</span>
<span class="p_add">+		    || dentry-&gt;d_inode-&gt;i_sb-&gt;s_magic == SYSFS_MAGIC)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		integrity_audit_msg(AUDIT_INTEGRITY_METADATA,</span>
<span class="p_add">+				    dentry-&gt;d_inode, dentry-&gt;d_name.name,</span>
<span class="p_add">+				    &quot;update_metadata&quot;,</span>
<span class="p_add">+				    integrity_status_msg[evm_status],</span>
<span class="p_add">+				    -EPERM, 0);</span>
 	}
 out:
 	if (evm_status != INTEGRITY_PASS)
<span class="p_header">diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h</span>
<span class="p_header">index f79fa8be203c..5cb7de9046fa 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima.h</span>
<span class="p_header">+++ b/security/integrity/ima/ima.h</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> void ima_add_violation(struct file *file, const unsigned char *filename,</span>
 		       const char *op, const char *cause);
 int ima_init_crypto(void);
 void ima_putc(struct seq_file *m, void *data, int datalen);
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size);</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size);</span>
 struct ima_template_desc *ima_template_desc_current(void);
 int ima_init_template(void);
 
<span class="p_header">diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c</span>
<span class="p_header">index 468a3ba3c539..35f3c900f801 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_fs.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_fs.c</span>
<span class="p_chunk">@@ -186,9 +186,9 @@</span> <span class="p_context"> static const struct file_operations ima_measurements_ops = {</span>
 	.release = seq_release,
 };
 
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size)</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size)</span>
 {
<span class="p_del">-	int i;</span>
<span class="p_add">+	u32 i;</span>
 
 	for (i = 0; i &lt; size; i++)
 		seq_printf(m, &quot;%02x&quot;, *(digest + i));
<span class="p_header">diff --git a/security/integrity/ima/ima_template_lib.c b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">index e8592e7bfc21..dcf77b77d2fc 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_chunk">@@ -79,7 +79,8 @@</span> <span class="p_context"> static void ima_show_template_data_ascii(struct seq_file *m,</span>
 					 enum data_formats datafmt,
 					 struct ima_field_data *field_data)
 {
<span class="p_del">-	u8 *buf_ptr = field_data-&gt;data, buflen = field_data-&gt;len;</span>
<span class="p_add">+	u8 *buf_ptr = field_data-&gt;data;</span>
<span class="p_add">+	u32 buflen = field_data-&gt;len;</span>
 
 	switch (datafmt) {
 	case DATA_FMT_DIGEST_WITH_ALGO:
<span class="p_header">diff --git a/security/keys/keyring.c b/security/keys/keyring.c</span>
<span class="p_header">index 2fb2576dc644..04d0d7c2ab0e 100644</span>
<span class="p_header">--- a/security/keys/keyring.c</span>
<span class="p_header">+++ b/security/keys/keyring.c</span>
<span class="p_chunk">@@ -1151,9 +1151,11 @@</span> <span class="p_context"> void __key_link_end(struct key *keyring,</span>
 	if (index_key-&gt;type == &amp;key_type_keyring)
 		up_write(&amp;keyring_serialise_link_sem);
 
<span class="p_del">-	if (edit &amp;&amp; !edit-&gt;dead_leaf) {</span>
<span class="p_del">-		key_payload_reserve(keyring,</span>
<span class="p_del">-				    keyring-&gt;datalen - KEYQUOTA_LINK_BYTES);</span>
<span class="p_add">+	if (edit) {</span>
<span class="p_add">+		if (!edit-&gt;dead_leaf) {</span>
<span class="p_add">+			key_payload_reserve(keyring,</span>
<span class="p_add">+				keyring-&gt;datalen - KEYQUOTA_LINK_BYTES);</span>
<span class="p_add">+		}</span>
 		assoc_array_cancel_edit(edit);
 	}
 	up_write(&amp;keyring-&gt;sem);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index ba175226da78..2f503c0836a9 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -3955,6 +3955,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_LIFEBOOK,
 	ALC269_FIXUP_LIFEBOOK_EXTMIC,
 	ALC269_FIXUP_LIFEBOOK_HP_PIN,
<span class="p_add">+	ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT,</span>
 	ALC269_FIXUP_AMIC,
 	ALC269_FIXUP_DMIC,
 	ALC269VB_FIXUP_AMIC,
<span class="p_chunk">@@ -3973,6 +3974,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_DELL3_MIC_NO_PRESENCE,
 	ALC269_FIXUP_HEADSET_MODE,
 	ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC,
<span class="p_add">+	ALC269_FIXUP_ASPIRE_HEADSET_MIC,</span>
 	ALC269_FIXUP_ASUS_X101_FUNC,
 	ALC269_FIXUP_ASUS_X101_VERB,
 	ALC269_FIXUP_ASUS_X101,
<span class="p_chunk">@@ -4096,6 +4098,10 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{ }
 		},
 	},
<span class="p_add">+	[ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc269_fixup_pincfg_no_hp_to_lineout,</span>
<span class="p_add">+	},</span>
 	[ALC269_FIXUP_AMIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -4214,6 +4220,15 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_headset_mode_no_hp_mic,
 	},
<span class="p_add">+	[ALC269_FIXUP_ASPIRE_HEADSET_MIC] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x19, 0x01a1913c }, /* headset mic w/o jack detect */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_HEADSET_MODE,</span>
<span class="p_add">+	},</span>
 	[ALC286_FIXUP_SONY_MIC_NO_PRESENCE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -4397,6 +4412,8 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x029b, &quot;Acer 1810TZ&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x0349, &quot;Acer AOD260&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x047c, &quot;Acer AC700&quot;, ALC269_FIXUP_ACER_AC700),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x072d, &quot;Acer Aspire V5-571G&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x080d, &quot;Acer Aspire V5-122P&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
 	SND_PCI_QUIRK(0x1025, 0x0740, &quot;Acer AO725&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0742, &quot;Acer AO756&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK_VENDOR(0x1025, &quot;Acer Aspire&quot;, ALC271_FIXUP_DMIC),
<span class="p_chunk">@@ -4549,6 +4566,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x104d, 0x9084, &quot;Sony VAIO&quot;, ALC275_FIXUP_SONY_HWEQ),
 	SND_PCI_QUIRK_VENDOR(0x104d, &quot;Sony VAIO&quot;, ALC269_FIXUP_SONY_VAIO),
 	SND_PCI_QUIRK(0x10cf, 0x1475, &quot;Lifebook&quot;, ALC269_FIXUP_LIFEBOOK),
<span class="p_add">+	SND_PCI_QUIRK(0x10cf, 0x159f, &quot;Lifebook E780&quot;, ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT),</span>
 	SND_PCI_QUIRK(0x10cf, 0x15dc, &quot;Lifebook T731&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1757, &quot;Lifebook E752&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1845, &quot;Lifebook U904&quot;, ALC269_FIXUP_LIFEBOOK_EXTMIC),
<span class="p_header">diff --git a/sound/soc/codecs/wm5102.c b/sound/soc/codecs/wm5102.c</span>
<span class="p_header">index ce9c8e14d4bd..fbee45c82a44 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5102.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5102.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> struct wm5102_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct wm_adsp_region wm5102_dsp1_regions[] = {
<span class="p_header">diff --git a/sound/soc/codecs/wm5110.c b/sound/soc/codecs/wm5110.c</span>
<span class="p_header">index 2c3c962d9a85..0fce853bda44 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5110.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5110.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> static int wm5110_sysclk_ev(struct snd_soc_dapm_widget *w,</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 #define WM5110_NG_SRC(name, base) \
<span class="p_header">diff --git a/sound/soc/codecs/wm8737.c b/sound/soc/codecs/wm8737.c</span>
<span class="p_header">index 2f167a8ca01b..62bacb8536e6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8737.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8737.c</span>
<span class="p_chunk">@@ -494,7 +494,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 			/* Fast VMID ramp at 2*2.5k */
 			snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-					    WM8737_VMIDSEL_MASK, 0x4);</span>
<span class="p_add">+					    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+					    2 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 			/* Bring VMID up */
 			snd_soc_update_bits(codec, WM8737_POWER_MANAGEMENT,
<span class="p_chunk">@@ -508,7 +509,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 		/* VMID at 2*300k */
 		snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-				    WM8737_VMIDSEL_MASK, 2);</span>
<span class="p_add">+				    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+				    1 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 		break;
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8903.h b/sound/soc/codecs/wm8903.h</span>
<span class="p_header">index db949311c0f2..0bb4a647755d 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8903.h</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8903.h</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> extern int wm8903_mic_detect(struct snd_soc_codec *codec,</span>
 #define WM8903_VMID_BUF_ENA_WIDTH                    1  /* VMID_BUF_ENA */
 
 #define WM8903_VMID_RES_50K                          2
<span class="p_del">-#define WM8903_VMID_RES_250K                         3</span>
<span class="p_add">+#define WM8903_VMID_RES_250K                         4</span>
 #define WM8903_VMID_RES_5K                           6
 
 /*
<span class="p_header">diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c</span>
<span class="p_header">index 1c1fc6119758..475fc24c8ff6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8955.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8955.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> static int wm8955_configure_clocking(struct snd_soc_codec *codec)</span>
 		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_17_9_MASK,
 				    (pll.k &gt;&gt; 9) &amp; WM8955_K_17_9_MASK);
<span class="p_del">-		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_3,</span>
 				    WM8955_K_8_0_MASK,
 				    pll.k &amp; WM8955_K_8_0_MASK);
 		if (pll.k)
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index edfd4edaa864..e04dbaa1de8f 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> SOC_SINGLE(&quot;PCM Playback -6dB Switch&quot;, WM8960_DACCTL1, 7, 1, 0),</span>
 SOC_ENUM(&quot;ADC Polarity&quot;, wm8960_enum[0]),
 SOC_SINGLE(&quot;ADC High Pass Filter Switch&quot;, WM8960_DACCTL1, 0, 1, 0),
 
<span class="p_del">-SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[2]),</span>
<span class="p_add">+SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[1]),</span>
 SOC_SINGLE_BOOL_EXT(&quot;DAC Deemphasis Switch&quot;, 0,
 		    wm8960_get_deemph, wm8960_put_deemph),
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8997.c b/sound/soc/codecs/wm8997.c</span>
<span class="p_header">index 555115ee2159..1461ae611f31 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8997.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8997.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> struct wm8997_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct reg_default wm8997_sysclk_reva_patch[] = {
<span class="p_header">diff --git a/sound/soc/fsl/imx-wm8962.c b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">index 3a3d17ce6ba4..664452599497 100644</span>
<span class="p_header">--- a/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">+++ b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> static int imx_wm8962_probe(struct platform_device *pdev)</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;audmux internal port setup failed\n&quot;);
 		return ret;
 	}
<span class="p_del">-	imx_audmux_v2_configure_port(ext_port,</span>
<span class="p_add">+	ret = imx_audmux_v2_configure_port(ext_port,</span>
 			IMX_AUDMUX_V2_PTCR_SYN,
 			IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));
 	if (ret) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



