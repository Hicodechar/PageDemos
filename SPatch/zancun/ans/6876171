
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v7,2/2] ARM: imx: Add suspend codes for imx7D - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v7,2/2] ARM: imx: Add suspend codes for imx7D</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 27, 2015, 7:30 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1438025400-5919-3-git-send-email-shenwei.wang@freescale.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6876171/mbox/"
   >mbox</a>
|
   <a href="/patch/6876171/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6876171/">/patch/6876171/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 54873C05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 27 Jul 2015 19:31:05 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 8A61820713
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 27 Jul 2015 19:31:02 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id A782E20719
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 27 Jul 2015 19:30:59 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754171AbbG0Tan (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 27 Jul 2015 15:30:43 -0400
Received: from mail-by2on0113.outbound.protection.outlook.com
	([207.46.100.113]:33427
	&quot;EHLO na01-by2-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1753460AbbG0Tak (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 27 Jul 2015 15:30:40 -0400
Received: from CH1PR03CA002.namprd03.prod.outlook.com (10.255.156.147) by
	BN3PR03MB1368.namprd03.prod.outlook.com (10.163.34.154) with
	Microsoft SMTP
	Server (TLS) id 15.1.225.19; Mon, 27 Jul 2015 19:30:37 +0000
Received: from BN1AFFO11FD032.protection.gbl (10.255.156.132) by
	CH1PR03CA002.outlook.office365.com (10.255.156.147) with Microsoft
	SMTP Server (TLS) id 15.1.213.14 via Frontend Transport;
	Mon, 27 Jul 2015 19:30:37 +0000
Authentication-Results: spf=fail (sender IP is 192.88.168.50)
	smtp.mailfrom=freescale.com; freescale.mail.onmicrosoft.com; dkim=none
	(message not signed) header.d=none;
Received-SPF: Fail (protection.outlook.com: domain of freescale.com does not
	designate 192.88.168.50 as permitted sender)
	receiver=protection.outlook.com; 
	client-ip=192.88.168.50; helo=tx30smr01.am.freescale.net;
Received: from tx30smr01.am.freescale.net (192.88.168.50) by
	BN1AFFO11FD032.mail.protection.outlook.com (10.58.52.186) with
	Microsoft SMTP Server (TLS) id 15.1.231.11 via Frontend Transport;
	Mon, 27 Jul 2015 19:30:36 +0000
Received: from [tx30smr01.am.freescale.net (B38339-11.am.freescale.net
	[10.81.93.199])
	by tx30smr01.am.freescale.net (8.14.3/8.14.0) with ESMTP id
	t6RJUJY8012880; Mon, 27 Jul 2015 12:30:36 -0700
From: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;
To: &lt;shawn.guo@linaro.org&gt;, &lt;tglx@linutronix.de&gt;,
	&lt;jason@lakedaemon.net&gt;
CC: &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;b20788@freescale.com&gt;
Subject: [PATCH v7 2/2] ARM: imx: Add suspend codes for imx7D
Date: Mon, 27 Jul 2015 14:30:00 -0500
Message-ID: &lt;1438025400-5919-3-git-send-email-shenwei.wang@freescale.com&gt;
X-Mailer: git-send-email 2.5.0.rc2
In-Reply-To: &lt;1438025400-5919-1-git-send-email-shenwei.wang@freescale.com&gt;
References: &lt;1438025400-5919-1-git-send-email-shenwei.wang@freescale.com&gt;
X-EOPAttributedMessage: 0
X-Microsoft-Exchange-Diagnostics: 1; BN1AFFO11FD032;
	1:x5Oa4GjqoPLInvssPfxKu3Cr5524Iz7X9Jq9x7h6eBGfkyghXzQBmnK2SJicuqzEv99OlUd3m88B8NNCrAuiiTBGqS0pqj1sm2+VwlasFQB/zug7UaMnFp/+CEjnEQKxkxgQn2AWT3wLaxMXKxmtNoIM6Q+JX8Ig0FBIhzy9N0SVzCzSQcAsKSdV7yLBkDPcqk6+krj3MfmMED0bjH24ZwkH1mDplRZ7mSGOLYXKQ3RTKTbO6YENxcwBtHhcg4+8XtwQfC3Y7j+l5g/xyjVBHVMXL7UL/xdVyKFd8lPflE2L+KzbqZYQWcjWRLhJUY9LJ3tXxD5TXta6UPCXLawH6w==
X-Forefront-Antispam-Report: CIP:192.88.168.50; CTRY:US; IPV:NLI; EFV:NLI;
	SFV:NSPM;
	SFS:(10019020)(6009001)(2980300002)(339900001)(199003)(189002)(106466001)(50986999)(6806004)(85426001)(229853001)(87936001)(76176999)(46102003)(5001960100002)(33646002)(107886002)(5001770100001)(86362001)(105606002)(92566002)(15975445007)(50466002)(77096005)(62966003)(19580405001)(47776003)(2201001)(77156002)(189998001)(104016003)(50226001)(48376002)(36756003)(2950100001)(4001430100001)(579004);
	DIR:OUT; SFP:1102; SCL:1; SRVR:BN3PR03MB1368;
	H:tx30smr01.am.freescale.net; FPR:; SPF:Fail; MLV:sfv; A:1;
	MX:1; LANG:en; 
MIME-Version: 1.0
Content-Type: text/plain
X-Microsoft-Exchange-Diagnostics: 1; BN3PR03MB1368;
	2:Az0y24v0U7st0g+BQUdJMDb6Wz9Bztna/Vm3wpFo4BvJ1R3w0WRBmijB0jv4rgTQzSePI6v6JGnTcRXDW0GBJznw3eAxBnUx4AETOxm8OGQpUK92SglEK8SGtm0m+m03X6cJwbYRFTarmZ2PAnMIrzIO6CqIZrteI61+S1q7XMo=;
	3:pYs0pJSRuZ9AvnT8yEW/zlpAQlJQa/CF69P/m//dfv1OP929saK05xsobGvzK6r88I9iXn7jiFVv6JL9GEQgWpZpjbxjx2gs+WVIX6K1LaR9GYq9b83PN6YkJn7ZwvrFmqq//G772HPRiYQVjPgx/s1rQyABV6NQ7TDOW19LkFZxbjd1PgTrO4Hvmgprk3SQBWQohfy8sUpXPCX/roQPzXWanfo/SDXCj9ehFJpdHw0=;
	25:h98CukWvoCtiZU8C3wg1cqdoUhVmjopjB3sn4DBG1jIXo2jF1d2MhEnvcoo0ezwT3RGgRLum2RYhgif6rlKNPyGMWz+ngtXPT82rjCmpAO0aTTfujKA0nHtd/wBiATRJshKqyylZX72Cjhi7E3wDRzetX6Bi7QQOhvNTGgTStsjvPAjUeywpGyFgqPbFYwhisOZ1/y7vqoRTzxbBNi0nqxyLuYitnGQsbuqeeQ5YrkbB2gwNjJUX9eAqK8G7ydrdRukqfZx8uaH7mBKulQxu6g==
X-Microsoft-Antispam: UriScan:;BCL:0;PCL:0;RULEID:;SRVR:BN3PR03MB1368;
X-Microsoft-Exchange-Diagnostics: 1; BN3PR03MB1368;
	20:4D1WofWkaPeTgAQahX1KvbgcqBWHTi88tK/K4ij5c27hmQy3U6O57uPVlhPyM62RvHjxFvPWiFgK8k22fmISE066MRISpKV9XR/3HSp3ddX1Ay3f4aFgTX9fZOI0NsFIBB3b0fyUR6+UxVcC8pIaK5jQcMLq2NJO3PAtDqUlC4CUbz70qLc6/UG0AEKOmn4vsXPcfpMAnDtq4boalgGgfzcGyRqx3j2bpnur+ZQZ4ZaImct8u65YXHfXYkDuO+lg0UM9h94eb/phcNStc6IJBdM9spSXSzxUSTnC6qDAK9cZydtEM0uxXP1P9SuQaq5hjoG74hbijDNNBs6s6TSXKDyX3rQKUCzNxhKq3BLsZCY=;
	4:gPbS8nmw90txmsp15Yali/H4tidCfZ8YZM9sua3WEXrhRlWZQG+izgN+DD6Zy+5m1ymdwpCzXKLymuhF2jSdYbpOb3hbS+pob1NiiHQoYu9pwRqpELJrgk4Q9jdtZd2aZhfc14sj9/GAFyEYqi8v5mmIA5NB91ERuDbbpUwWNQ1fbVlyROiwtJc+2UwUTg1bArB56XXXwKcvtaumpbXc9fHQNu2WFCBBpBzmlJFfGQn6faiv6PmuM7FSyDSXRWZOd0Z22CgWDN3mQ6+T6Muyt7eGCRdpLDPBURdOF031Hw0=
BN3PR03MB1368: X-MS-Exchange-Organization-RulesExecuted
X-Microsoft-Antispam-PRVS: &lt;BN3PR03MB1368A017DD50442938A070FB838E0@BN3PR03MB1368.namprd03.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:;
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(601004)(5005006)(3002001); SRVR:BN3PR03MB1368; BCL:0;
	PCL:0; RULEID:; SRVR:BN3PR03MB1368; 
X-Forefront-PRVS: 0650714AAA
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; BN3PR03MB1368;
	23:nx2ZflgtbJz77o9l9xGgtv5vaCqHSV8v8AjIPxn6Z?=
	=?us-ascii?Q?lW5HmfDEVEYSKFLQQnOXNqI76SY0AnDF9jSnRfriO6FVwbRLS+v3NHLfOkha?=
	=?us-ascii?Q?1PfQrMOapoJ2DREaijvGP2a3J+9aw3T3MbIjMdwgR92R2jBGg6o1iTYeGa3T?=
	=?us-ascii?Q?M896zPjb8zqf+iI2//oOyIBAoMw164grVP+dSyliY2w0Kmb6PGLuMznAZzCg?=
	=?us-ascii?Q?P8xG27DhVlO3wOx5sxZLG45gmDJIiq16qfxTkEfl2AwIDbqkXEPRIoQLB9lw?=
	=?us-ascii?Q?1eHjtLZRMm8/nyHEAc3LgrfLtlqXHmiU4h/E4WdaPbaz2Tyr+MbymWVwFoL9?=
	=?us-ascii?Q?6Sk7l0AhONGm+WXKU7sx9Nm8CEeVIl33tlW3X5nEx4Q4sH+fRlrCulA0GPph?=
	=?us-ascii?Q?1fpjx0zsDvFVyX4RtleG78qlB6tTvjyGsrNc7isnFhbNniSIVTyJreIVJ5QM?=
	=?us-ascii?Q?OVJ8ncKgbm44hp+SpNBz9VdYUvbN74Ps9J6chADWpQVM4LORzeTCmCIxqdVW?=
	=?us-ascii?Q?prTqNWg5dsuBy/o/WfiHu5lGmq/QzwCpKdnY+tu1EmZDk7ZO7UlZ09OL9c0E?=
	=?us-ascii?Q?Sy+A8foprclTJOZQ3f7VJCinnU9fqyDqF/w4mtYcgdyAQNM3rRbA5Y54fWci?=
	=?us-ascii?Q?mO33CDTvSp8AWaLyMWHwJT6q3qKsUYEWxEm6at3UZmw5EYLkxuI12xLRyInZ?=
	=?us-ascii?Q?X5duKg0aS/sJFubX+dOqJeBkjt8L0yNcDEPo58v5hedwadC0vRecG8/IYegs?=
	=?us-ascii?Q?TpE6ScYQpgkynxyjZ5r8Rc1S+5j2sZaQv0r2CtNUjItwqew65OxLyQ+6AGJs?=
	=?us-ascii?Q?HNSJ683hDx3LVj/WCbXeQlGTpArMhvnzJSqYLYpfyCpcJlASsuvTh8hJAfzr?=
	=?us-ascii?Q?cx7oLLNMuHT/GdNVH2xvZqmF3eSt9Fou+G4CPXC5p2I91lIrjLDpbuXTiKGg?=
	=?us-ascii?Q?hpnc1G7kr8p6Oo4JhkeaDUst3ME7wy443y8fh2cBg=3D=3D?=
X-Microsoft-Exchange-Diagnostics: 1; BN3PR03MB1368;
	5:93MYrCmWwfvtwKnIaDWApgpvyTMtxYxOY6ceAkVi8J7Y0S8CaYD88mwRPUHkAMpvaSUa3kP80IF/eeO6iWeRYeRf/w1/Zi97KIZWNQAuAabQqCMHSD+6IjMRqx5WEv/xV3/GucR2ISjBGU7F7e3PSw==;
	24:AJ9ISndwdWvVemktJBMWti2awgKMm4QG5DxW1HTpnuHVTexQ4MQc/QcKO/vlVqwMz55+VxDg6uodd1J/xyepQK73O4MYfkAYSmLfTlViOx8=;
	20:i6mtOMF8vdCbW6Df4NGZEDNG+2dGtIguit0A1Txn6+94I3Cn1DvPZyUKfiodL/pUXiSEEDae4RdZbqKZOZvMDA==
X-OriginatorOrg: freescale.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 27 Jul 2015 19:30:36.8410
	(UTC)
X-MS-Exchange-CrossTenant-Id: 710a03f5-10f6-4d38-9ff4-a80b81da590d
X-MS-Exchange-CrossTenant-OriginalAttributedTenantConnectingIp: TenantId=710a03f5-10f6-4d38-9ff4-a80b81da590d;
	Ip=[192.88.168.50]; Helo=[tx30smr01.am.freescale.net]
X-MS-Exchange-CrossTenant-FromEntityHeader: HybridOnPrem
X-MS-Exchange-Transport-CrossTenantHeadersStamped: BN3PR03MB1368
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.2 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD, UNPARSEABLE_RELAY autolearn=ham version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a> - July 27, 2015, 7:30 p.m.</div>
<pre class="content">
IMX7D contains a new version of GPC IP block (GPCv2). It has two
major functions: power management and wakeup source management.

GPCv2 provides low power mode control for Cortex-A7 and Cortex-M4
domains. And it can support WAIT, STOP, and DSM(Deep Sleep Mode) modes.
After configuring the GPCv2 module, the platform can enter into a
selected mode either automatically triggered by ARM WFI instruction or
manually by software. The system will exit the low power states
by the predefined wakeup sources which are managed by the gpcv2
irqchip driver.

This patch adds a new suspend driver to manage the power states on IMX7D.
It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.
<span class="signed-off-by">
Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Anson Huang &lt;b20788@freescale.com&gt;</span>
---
 arch/arm/mach-imx/Kconfig        |   1 +
 arch/arm/mach-imx/Makefile       |   2 +
 arch/arm/mach-imx/pm-imx7.c      | 901 +++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-imx/suspend-imx7.S | 529 +++++++++++++++++++++++
 4 files changed, 1433 insertions(+)
 create mode 100644 arch/arm/mach-imx/pm-imx7.c
 create mode 100644 arch/arm/mach-imx/suspend-imx7.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=71861">Stefan Agner</a> - July 30, 2015, 10:44 p.m.</div>
<pre class="content">
Hi Shenwei,

The Subject sounds somewhat strange, if you mean your program code, then
you should not use the plural. Or maybe &quot;add suspend states...&quot; or
&quot;support suspend states...&quot;?

On 2015-07-27 21:30, Shenwei Wang wrote:
<span class="quote">&gt; IMX7D contains a new version of GPC IP block (GPCv2). It has two</span>
<span class="quote">&gt; major functions: power management and wakeup source management.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; GPCv2 provides low power mode control for Cortex-A7 and Cortex-M4</span>
<span class="quote">&gt; domains. And it can support WAIT, STOP, and DSM(Deep Sleep Mode) modes.</span>
<span class="quote">&gt; After configuring the GPCv2 module, the platform can enter into a</span>
<span class="quote">&gt; selected mode either automatically triggered by ARM WFI instruction or</span>
<span class="quote">&gt; manually by software. The system will exit the low power states</span>
<span class="quote">&gt; by the predefined wakeup sources which are managed by the gpcv2</span>
<span class="quote">&gt; irqchip driver.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This patch adds a new suspend driver to manage the power states on IMX7D.</span>
<span class="quote">&gt; It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Anson Huang &lt;b20788@freescale.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/arm/mach-imx/Kconfig        |   1 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/Makefile       |   2 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/pm-imx7.c      | 901 +++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/arm/mach-imx/suspend-imx7.S | 529 +++++++++++++++++++++++</span>
<span class="quote">&gt;  4 files changed, 1433 insertions(+)</span>
<span class="quote">&gt;  create mode 100644 arch/arm/mach-imx/pm-imx7.c</span>
<span class="quote">&gt;  create mode 100644 arch/arm/mach-imx/suspend-imx7.S</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; index 8ceda28..54f8553 100644</span>
<span class="quote">&gt; --- a/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; @@ -562,6 +562,7 @@ config SOC_IMX7D</span>
<span class="quote">&gt;  	select ARM_GIC</span>
<span class="quote">&gt;  	select HAVE_IMX_ANATOP</span>
<span class="quote">&gt;  	select HAVE_IMX_MMDC</span>
<span class="quote">&gt; +	select IMX_GPCV2</span>
<span class="quote">&gt;  	help</span>
<span class="quote">&gt;  		This enables support for Freescale i.MX7 Dual processor.</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; index fb689d8..ca4c566 100644</span>
<span class="quote">&gt; --- a/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; @@ -88,6 +88,8 @@ obj-$(CONFIG_SOC_IMX7D) += mach-imx7d.o</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  ifeq ($(CONFIG_SUSPEND),y)</span>
<span class="quote">&gt;  AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; +AFLAGS_suspend-imx7.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; +obj-$(CONFIG_IMX_GPCV2)	+= suspend-imx7.o pm-imx7.o</span>
<span class="quote">&gt;  obj-$(CONFIG_SOC_IMX6) += suspend-imx6.o</span>

A rather strange ordering, can you keep the AFLAGS near the object file?
<span class="quote">
&gt;  obj-$(CONFIG_SOC_IMX53) += suspend-imx53.o</span>
<span class="quote">&gt;  endif</span>
<span class="quote">&gt; diff --git a/arch/arm/mach-imx/pm-imx7.c b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..9035368</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="quote">&gt; @@ -0,0 +1,901 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/mfd/syscon.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/regmap.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/suspend.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/suspend.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/fncpy.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;soc/imx/gpcv2.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_L2PGE			0x10000</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C1_PUP			0x800</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C1_IRQ_PUP		0x400</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C0_PUP			0x200</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C0_IRQ_PUP		0x100</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_PLAT_PDN		0x10</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C1_PDN			0x8</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C1_WFI_PDN		0x4</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C0_PDN			0x2</span>
<span class="quote">&gt; +#define BM_LPCR_A7_AD_EN_C0_WFI_PDN		0x1</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP	0x70000000</span>
<span class="quote">&gt; +#define BM_LPCR_A7_BSC_CPU_CLK_ON_LPM		0x4000</span>
<span class="quote">&gt; +#define BM_LPCR_A7_BSC_LPM1			0xc</span>
<span class="quote">&gt; +#define BM_LPCR_A7_BSC_LPM0			0x3</span>
<span class="quote">&gt; +#define BP_LPCR_A7_BSC_LPM1			2</span>
<span class="quote">&gt; +#define BP_LPCR_A7_BSC_LPM0			0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_LPCR_M4_MASK_DSM_TRIGGER		0x80000000</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_SLPCR_EN_DSM				0x80000000</span>
<span class="quote">&gt; +#define BM_SLPCR_RBC_EN				0x40000000</span>
<span class="quote">&gt; +#define BM_SLPCR_VSTBY				0x4</span>
<span class="quote">&gt; +#define BM_SLPCR_SBYOS				0x2</span>
<span class="quote">&gt; +#define BM_SLPCR_BYPASS_PMIC_READY		0x1</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP_ACK	0x80000000</span>
<span class="quote">&gt; +#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN_ACK	0x8000</span>

Typically the bit field size + shifts is used here, e.g.

#define BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP	(0x7 &lt;&lt; 28)
#define BM_LPCR_A7_BSC_CPU_CLK_ON_LPM		(0x1 &lt;&lt; 14)

This is much easier to verify against the data sheet.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +#define GPC_LPCR_A7_BSC		0x0</span>
<span class="quote">&gt; +#define GPC_LPCR_A7_AD		0x4</span>
<span class="quote">&gt; +#define GPC_LPCR_M4		0x8</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GPC_PGC_CPU_MAPPING	0xec</span>
<span class="quote">&gt; +#define GPC_PGC_SCU_TIMING	0x890</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GPC_SLPCR		0x14</span>
<span class="quote">&gt; +#define GPC_PGC_ACK_SEL_A7	0x24</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GPC_SLOT0_CFG		0xb0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define GPC_PGC_C0		0x800</span>
<span class="quote">&gt; +#define GPC_PGC_SCU_TIMING	0x890</span>
<span class="quote">&gt; +#define GPC_PGC_C1		0x840</span>
<span class="quote">&gt; +#define GPC_PGC_SCU		0x880</span>
<span class="quote">&gt; +#define GPC_PGC_FM		0xa00</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ANADIG_ARM_PLL		0x60</span>
<span class="quote">&gt; +#define ANADIG_DDR_PLL		0x70</span>
<span class="quote">&gt; +#define ANADIG_SYS_PLL		0xb0</span>
<span class="quote">&gt; +#define ANADIG_ENET_PLL		0xe0</span>
<span class="quote">&gt; +#define ANADIG_AUDIO_PLL	0xf0</span>
<span class="quote">&gt; +#define ANADIG_VIDEO_PLL	0x130</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define MAX_SLOT_NUMBER		10</span>
<span class="quote">&gt; +#define A7_LPM_WAIT		0x5</span>
<span class="quote">&gt; +#define A7_LPM_STOP		0xa</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_SET			0x4</span>
<span class="quote">&gt; +#define REG_CLR			0x8</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +enum gpcv2_mode {</span>
<span class="quote">&gt; +	WAIT_CLOCKED,</span>
<span class="quote">&gt; +	WAIT_UNCLOCKED,</span>
<span class="quote">&gt; +	WAIT_UNCLOCKED_POWER_OFF,</span>
<span class="quote">&gt; +	STOP_POWER_ON,</span>
<span class="quote">&gt; +	STOP_POWER_OFF,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* GPCv2 has the following power domains, and each domain can be power-up</span>
<span class="quote">&gt; + * and power-down via GPC settings.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * 	Core 0 of A7 power domain</span>
<span class="quote">&gt; + * 	Core1 of A7 power domain</span>
<span class="quote">&gt; + * 	SCU/L2 cache RAM of A7 power domain</span>
<span class="quote">&gt; + * 	Fastmix and megamix power domain</span>
<span class="quote">&gt; + * 	USB OTG1 PHY power domain</span>
<span class="quote">&gt; + * 	USB OTG2 PHY power domain</span>
<span class="quote">&gt; + * 	PCIE PHY power domain</span>
<span class="quote">&gt; + * 	USB HSIC PHY power domain</span>
<span class="quote">&gt; + *	Core 0 of M4 power domain</span>
<span class="quote">&gt; + */</span>

Nit: a empty line is the preferred format in this part of the kernel:

/*
 * Start here...
<span class="quote">
&gt; +enum gpcv2_slot {</span>
<span class="quote">&gt; +	CORE0_A7,</span>
<span class="quote">&gt; +	CORE1_A7,</span>
<span class="quote">&gt; +	SCU_A7,</span>
<span class="quote">&gt; +	FAST_MEGA_MIX,</span>
<span class="quote">&gt; +	MIPI_PHY,</span>
<span class="quote">&gt; +	PCIE_PHY,</span>
<span class="quote">&gt; +	USB_OTG1_PHY,</span>
<span class="quote">&gt; +	USB_OTG2_PHY,</span>
<span class="quote">&gt; +	USB_HSIC_PHY,</span>
<span class="quote">&gt; +	CORE0_M4,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx_gpcv2;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx_gpcv2_suspend {</span>
<span class="quote">&gt; +	struct regmap *anatop;</span>
<span class="quote">&gt; +	struct regmap *imx_src;</span>
<span class="quote">&gt; +	u32 mfmix_mask[IMR_NUM];</span>
<span class="quote">&gt; +	u32 wakeupmix_mask[IMR_NUM];</span>
<span class="quote">&gt; +	u32 lpsrmix_mask[IMR_NUM];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	void (*set_mode)(struct imx_gpcv2 *, enum gpcv2_mode mode);</span>
<span class="quote">&gt; +	void (*lpm_cpu_power_gate)(struct imx_gpcv2 *, u32, bool);</span>
<span class="quote">&gt; +	void (*lpm_plat_power_gate)(struct imx_gpcv2 *, bool);</span>
<span class="quote">&gt; +	void (*lpm_env_setup)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +	void (*lpm_env_clean)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	void (*set_slot)(struct imx_gpcv2 *cd, u32 index,</span>
<span class="quote">&gt; +			enum gpcv2_slot m_core, bool mode, bool ack);</span>
<span class="quote">&gt; +	void (*clear_slots)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +	void (*lpm_enable_core)(struct imx_gpcv2 *,</span>
<span class="quote">&gt; +			bool enable, u32 offset);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	void (*standby)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +	void (*suspend)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	void (*suspend_fn_in_ocram)(void __iomem *ocram_vbase);</span>
<span class="quote">&gt; +	void __iomem *ocram_vbase;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx_gpcv2 {</span>
<span class="quote">&gt; +	spinlock_t lock;</span>
<span class="quote">&gt; +	struct imx_gpcv2_irq *irqchip;</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +extern struct imx_gpcv2_irq *gpcv2_irq_instance;</span>
<span class="quote">&gt; +static struct imx_gpcv2 *gpcv2_instance;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_clear_slots(struct imx_gpcv2 *gpc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	int i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +	for (i = 0; i &lt; MAX_SLOT_NUMBER; i++)</span>
<span class="quote">&gt; +		writel_relaxed(0x0, cd-&gt;gpc_base + GPC_SLOT0_CFG + i * 0x4);</span>
<span class="quote">&gt; +	writel_relaxed(BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP_ACK |</span>
<span class="quote">&gt; +		BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN_ACK,</span>
<span class="quote">&gt; +		cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_enable_core(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; +			bool enable, u32 offset)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +	writel_relaxed(enable, cd-&gt;gpc_base + offset);</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_slot_setup(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; +		u32 index, enum gpcv2_slot m_core, bool mode, bool ack)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (index &gt;= MAX_SLOT_NUMBER)</span>
<span class="quote">&gt; +		pr_err(&quot;Invalid slot index!\n&quot;);</span>

Is a return missing here? The check seems rather useless otherwise.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +	/* set slot */</span>
<span class="quote">&gt; +	writel_relaxed((mode + 1) &lt;&lt; (m_core * 2), cd-&gt;gpc_base +</span>
<span class="quote">&gt; +		GPC_SLOT0_CFG + index * 4);</span>

Can you create a preprocessor for the slot register?

#define GPC_SLOTx_CFG(x) (0xb0 + 4 * (x))

The parameter m_core has a unintuitive name, slot sounds much better to
me.

Also boolean and an addition is somewhat strange, I would prefer
something like:
mode ? 0x2 : 0x1 &lt;&lt; (slot * 2)
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	if (ack) {</span>
<span class="quote">&gt; +		/* set ack */</span>
<span class="quote">&gt; +		val = readl_relaxed(cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="quote">&gt; +		/* clear dummy ack */</span>
<span class="quote">&gt; +		val &amp;= ~(1 &lt;&lt; (15 + (mode ? 16 : 0)));</span>
<span class="quote">&gt; +		val |= 1 &lt;&lt; (m_core + (mode ? 16 : 0));</span>

Can you come up with macros here too? That is not readable...

For the dummy ack I would suggest to create dedicated defines and for
the power domain acks something which takes the slot as argument...
<span class="quote">
&gt; +		writel_relaxed(val, cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_env_setup(struct imx_gpcv2 *gpc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* PLL and PFDs overwrite set */</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_ARM_PLL + REG_SET, 1 &lt;&lt; 20);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_DDR_PLL + REG_SET, 1 &lt;&lt; 19);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_SYS_PLL + REG_SET, 0x1ff &lt;&lt; 17);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_ENET_PLL + REG_SET, 1 &lt;&lt; 13);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_AUDIO_PLL + REG_SET, 1 &lt;&lt; 24);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_VIDEO_PLL + REG_SET, 1 &lt;&lt; 24);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_env_clean(struct imx_gpcv2 *gpc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* PLL and PFDs overwrite clear */</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_ARM_PLL + REG_CLR, 1 &lt;&lt; 20);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_DDR_PLL + REG_CLR, 1 &lt;&lt; 19);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_SYS_PLL + REG_CLR, 0x1ff &lt;&lt; 17);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_ENET_PLL + REG_CLR, 1 &lt;&lt; 13);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_AUDIO_PLL + REG_CLR, 1 &lt;&lt; 24);</span>
<span class="quote">&gt; +	regmap_write(pm-&gt;anatop, ANADIG_VIDEO_PLL + REG_CLR, 1 &lt;&lt; 24);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_set_mode(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; +		enum gpcv2_mode mode)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	u32 val1, val2;</span>

Please use names which say something. tmp and i is ok, if it&#39;s a
temporary variable or a counter, but not val1/val2...
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	val1 = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="quote">&gt; +	val2 = readl_relaxed(cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* all cores&#39; LPM settings must be same */</span>
<span class="quote">&gt; +	val1 &amp;= ~(BM_LPCR_A7_BSC_LPM0 | BM_LPCR_A7_BSC_LPM1);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	val1 |= BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	val2 &amp;= ~(BM_SLPCR_EN_DSM | BM_SLPCR_VSTBY | BM_SLPCR_RBC_EN |</span>
<span class="quote">&gt; +		BM_SLPCR_SBYOS | BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * GPCv2: When improper low-power sequence is used,</span>
<span class="quote">&gt; +	 * the SoC enters low power mode before the ARM core executes WFI.</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * Software workaround:</span>
<span class="quote">&gt; +	 * 1) Software should trigger IRQ #32 (IOMUX) to be always pending</span>
<span class="quote">&gt; +	 *    by setting IOMUX_GPR1_IRQ.</span>
<span class="quote">&gt; +	 * 2) Software should then unmask IRQ #32 in GPC before setting GPC</span>
<span class="quote">&gt; +	 *    Low-Power mode.</span>
<span class="quote">&gt; +	 * 3) Software should mask IRQ #32 right after GPC Low-Power mode</span>
<span class="quote">&gt; +	 *    is set.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	switch (mode) {</span>
<span class="quote">&gt; +	case WAIT_CLOCKED:</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case WAIT_UNCLOCKED:</span>
<span class="quote">&gt; +		val1 |= A7_LPM_WAIT &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="quote">&gt; +		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case STOP_POWER_ON:</span>
<span class="quote">&gt; +		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="quote">&gt; +		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; +		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="quote">&gt; +		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="quote">&gt; +		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case STOP_POWER_OFF:</span>
<span class="quote">&gt; +		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="quote">&gt; +		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; +		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="quote">&gt; +		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="quote">&gt; +		val2 |= BM_SLPCR_SBYOS;</span>
<span class="quote">&gt; +		val2 |= BM_SLPCR_VSTBY;</span>
<span class="quote">&gt; +		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	default:</span>
<span class="quote">&gt; +		return;</span>

What about the spin lock?
<span class="quote">
&gt; +	}</span>
<span class="quote">&gt; +	writel_relaxed(val1, cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="quote">&gt; +	writel_relaxed(val2, cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_cpu_power_gate(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; +				u32 cpu, bool pdn)</span>

Hm, pdn is somewhat overused here. Your bool pdn says that you want to
power gate a certain core. Below you then set PDN and PUP, that is
somewhat confusing. Maybe bool engate or en_lpm?
<span class="quote">
&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	const u32 val_pdn[2] = {</span>
<span class="quote">&gt; +		BM_LPCR_A7_AD_EN_C0_PDN | BM_LPCR_A7_AD_EN_C0_PUP,</span>
<span class="quote">&gt; +		BM_LPCR_A7_AD_EN_C1_PDN | BM_LPCR_A7_AD_EN_C1_PUP,</span>
<span class="quote">&gt; +	};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="quote">&gt; +	if (pdn)</span>
<span class="quote">&gt; +		val |= val_pdn[cpu];</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		val &amp;= ~val_pdn[cpu];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_lpm_plat_power_gate(struct imx_gpcv2 *gpc, bool pdn)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="quote">&gt; +	val &amp;= ~(BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE);</span>
<span class="quote">&gt; +	if (pdn)</span>
<span class="quote">&gt; +		val |= BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_standby(struct imx_gpcv2 *gpc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_setup(gpc);</span>
<span class="quote">&gt; +	/* pm-&gt;set_mode(gpc, STOP_POWER_OFF); */</span>
<span class="quote">&gt; +	pm-&gt;set_mode(gpc, WAIT_UNCLOCKED);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pr_debug(&quot;[GPCv2] %s %d\r\n&quot;, __func__, __LINE__);</span>
<span class="quote">&gt; +	/* Zzz ... */</span>
<span class="quote">&gt; +	cpu_do_idle();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;set_mode(gpc, WAIT_CLOCKED);</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_clean(gpc);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int gpcv2_suspend_finish(unsigned long val)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm = (struct imx_gpcv2_suspend *)val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!pm-&gt;suspend_fn_in_ocram) {</span>
<span class="quote">&gt; +		cpu_do_idle();</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * call low level suspend function in ocram,</span>
<span class="quote">&gt; +		 * as we need to float DDR IO.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		local_flush_tlb_all();</span>
<span class="quote">&gt; +		pm-&gt;suspend_fn_in_ocram(pm-&gt;ocram_vbase);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +static void imx_gpcv2_lpm_suspend(struct imx_gpcv2 *gpc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; +	int i = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_setup(gpc);</span>
<span class="quote">&gt; +	pm-&gt;set_mode(gpc, STOP_POWER_OFF);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enable core0 power down/up with low power mode */</span>
<span class="quote">&gt; +	pm-&gt;lpm_cpu_power_gate(gpc, 0, true);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enable plat power down with low power mode */</span>
<span class="quote">&gt; +	pm-&gt;lpm_plat_power_gate(gpc, true);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * To avoid confuse, we use slot 0~4 for power down,</span>
<span class="quote">&gt; +	 * slot 5~9 for power up.</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * Power down slot sequence:</span>
<span class="quote">&gt; +	 * Slot0 -&gt; CORE0</span>
<span class="quote">&gt; +	 * Slot1 -&gt; Mega/Fast MIX</span>
<span class="quote">&gt; +	 * Slot2 -&gt; SCU</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * Power up slot sequence:</span>
<span class="quote">&gt; +	 * Slot5 -&gt; Mega/Fast MIX</span>
<span class="quote">&gt; +	 * Slot6 -&gt; SCU</span>
<span class="quote">&gt; +	 * Slot7 -&gt; CORE0</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	pm-&gt;set_slot(gpc, 0, CORE0_A7, false, false);</span>
<span class="quote">&gt; +	pm-&gt;set_slot(gpc, 2, SCU_A7, false, true);</span>

Maybe it would be better to introduce a enum for the
power-up/power-down?
<span class="quote">

&gt; +</span>
<span class="quote">&gt; +	for (i = 0; i &lt; IMR_NUM; i++) {</span>
<span class="quote">&gt; +		if ((~cd-&gt;wakeup_sources[i] &amp; pm-&gt;mfmix_mask[i]) != 0)</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pm-&gt;set_slot(gpc, 1, FAST_MEGA_MIX, false, false);</span>
<span class="quote">&gt; +		pm-&gt;set_slot(gpc, 5, FAST_MEGA_MIX, true, false);</span>
<span class="quote">&gt; +		pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_FM);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	}</span>

This is somewhat weird. You break either way in the first loop don&#39;t
you? Why using a loop then?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	pm-&gt;set_slot(gpc, 6, SCU_A7, true, false);</span>
<span class="quote">&gt; +	pm-&gt;set_slot(gpc, 7, CORE0_A7, true, true);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enable core0, scu */</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_C0);</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_SCU);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Suspend to MEM has not been implemented yet */</span>
<span class="quote">&gt; +	cpu_suspend((unsigned long)pm, gpcv2_suspend_finish);</span>

What does that mean?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_clean(gpc);</span>
<span class="quote">&gt; +	pm-&gt;set_mode(gpc, WAIT_CLOCKED);</span>
<span class="quote">&gt; +	pm-&gt;lpm_cpu_power_gate(gpc, 0, false);</span>
<span class="quote">&gt; +	pm-&gt;lpm_plat_power_gate(gpc, false);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_C0);</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_SCU);</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_FM);</span>
<span class="quote">&gt; +	pm-&gt;clear_slots(gpc);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int imx_gpcv2_pm_enter(suspend_state_t state)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	BUG_ON(!gpcv2_instance);</span>
<span class="quote">&gt; +	pm = gpcv2_instance-&gt;pm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	switch (state) {</span>
<span class="quote">&gt; +	case PM_SUSPEND_STANDBY:</span>
<span class="quote">&gt; +		pm-&gt;standby(gpcv2_instance);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	case PM_SUSPEND_MEM:</span>
<span class="quote">&gt; +		pm-&gt;suspend(gpcv2_instance);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	default:</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int imx_gpcv2_pm_valid(suspend_state_t state)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define MX7_MAX_DDRC_NUM		32</span>
<span class="quote">&gt; +#define MX7_MAX_DDRC_PHY_NUM		16</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define READ_DATA_FROM_HARDWARE		0</span>
<span class="quote">&gt; +#define MX7_SUSPEND_OCRAM_SIZE		0x1000</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx7_pm_base {</span>
<span class="quote">&gt; +	phys_addr_t pbase;</span>
<span class="quote">&gt; +	void __iomem *vbase;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct imx7_pm_socdata {</span>
<span class="quote">&gt; +	u32 ddr_type;</span>
<span class="quote">&gt; +	const char *ddrc_compat;</span>
<span class="quote">&gt; +	const char *ddrc_phy_compat;</span>
<span class="quote">&gt; +	const char *src_compat;</span>
<span class="quote">&gt; +	const char *iomuxc_gpr_compat;</span>
<span class="quote">&gt; +	const char *ccm_compat;</span>
<span class="quote">&gt; +	const char *gpc_compat;</span>
<span class="quote">&gt; +	const char *anatop_compat;</span>
<span class="quote">&gt; +	const u32 ddrc_num;</span>
<span class="quote">&gt; +	const u32 (*ddrc_offset)[2];</span>
<span class="quote">&gt; +	const u32 ddrc_phy_num;</span>
<span class="quote">&gt; +	const u32 (*ddrc_phy_offset)[2];</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * This structure is for passing necessary data for low level ocram</span>
<span class="quote">&gt; + * suspend code(arch/arm/mach-imx/suspend-imx7.S), if this struct</span>
<span class="quote">&gt; + * definition is changed, the offset definition in</span>
<span class="quote">&gt; + * arch/arm/mach-imx/suspend-imx7.S must be also changed accordingly,</span>
<span class="quote">&gt; + * otherwise, the suspend to ocram function will be broken!</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +struct imx7_cpu_pm_info {</span>
<span class="quote">&gt; +	u32 m4_reserve0;</span>
<span class="quote">&gt; +	u32 m4_reserve1;</span>
<span class="quote">&gt; +	u32 m4_reserve2;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* The physical address of pm_info. */</span>
<span class="quote">&gt; +	phys_addr_t pbase;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* The physical resume address for asm code */</span>
<span class="quote">&gt; +	phys_addr_t resume_addr;</span>
<span class="quote">&gt; +	u32 ddr_type;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	u32 pm_info_size;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	struct imx7_pm_base ddrc_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base ddrc_phy_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base src_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base iomuxc_gpr_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base ccm_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base gpc_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base l2_base;</span>
<span class="quote">&gt; +	struct imx7_pm_base anatop_base;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	u32 ttbr1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Number of DDRC which need saved/restored. */</span>
<span class="quote">&gt; +	u32 ddrc_num;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* To save offset and value */</span>
<span class="quote">&gt; +	u32 ddrc_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Number of DDRC which need saved/restored. */</span>
<span class="quote">&gt; +	u32 ddrc_phy_num;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* To save offset and value */</span>
<span class="quote">&gt; +	u32 ddrc_phy_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="quote">&gt; +} __aligned(8);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_get_base_from_node(struct device_node *node,</span>
<span class="quote">&gt; +			struct imx7_pm_base *base)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct resource res;</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		goto put_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	base-&gt;pbase = res.start;</span>
<span class="quote">&gt; +	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="quote">&gt; +	if (!base-&gt;vbase) {</span>
<span class="quote">&gt; +		iounmap(base-&gt;vbase);</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +put_node:</span>
<span class="quote">&gt; +	of_node_put(node);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_get_base_from_dt(struct imx7_pm_base *base,</span>
<span class="quote">&gt; +				const char *compat)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct device_node *node;</span>
<span class="quote">&gt; +	struct resource res;</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="quote">&gt; +	if (!node) {</span>
<span class="quote">&gt; +		ret = -ENODEV;</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		goto put_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	base-&gt;pbase = res.start;</span>
<span class="quote">&gt; +	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="quote">&gt; +	if (!base-&gt;vbase)</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +put_node:</span>
<span class="quote">&gt; +	of_node_put(node);</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_get_exec_base_from_dt(struct imx7_pm_base *base,</span>
<span class="quote">&gt; +				const char *compat)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct device_node *node;</span>
<span class="quote">&gt; +	struct resource res;</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="quote">&gt; +	if (!node) {</span>
<span class="quote">&gt; +		ret = -ENODEV;</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		goto put_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	base-&gt;pbase = res.start;</span>
<span class="quote">&gt; +	base-&gt;vbase = __arm_ioremap_exec(res.start, resource_size(&amp;res), false);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!base-&gt;vbase)</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +put_node:</span>
<span class="quote">&gt; +	of_node_put(node);</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const u32 imx7d_ddrc_ddr3_setting[][2] __initconst = {</span>
<span class="quote">&gt; +	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x1a0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x1a4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x1a8, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x64, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x490, 0x00000001 },</span>
<span class="quote">&gt; +	{ 0xd0, 0xc0020001 },</span>
<span class="quote">&gt; +	{ 0xd4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0xdc, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0xe0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0xe4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0xf4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x100, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x104, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x108, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x10c, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x110, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x114, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x120, 0x03030803 },</span>
<span class="quote">&gt; +	{ 0x180, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x190, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x194, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x200, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x204, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x214, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x218, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x240, 0x06000601 },</span>
<span class="quote">&gt; +	{ 0x244, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const u32 imx7d_ddrc_phy_ddr3_setting[][2] __initconst = {</span>
<span class="quote">&gt; +	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x10, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x9c, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x20, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x30, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; +	{ 0x50, 0x01000010 },</span>
<span class="quote">&gt; +	{ 0x50, 0x00000010 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e407304 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e447304 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e447306 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e447304 },</span>
<span class="quote">&gt; +	{ 0xc0, 0x0e407306 },</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct imx7_pm_socdata imx7d_pm_data_ddr3 __initconst = {</span>
<span class="quote">&gt; +	.iomuxc_gpr_compat = &quot;fsl,imx7d-iomuxc&quot;,</span>
<span class="quote">&gt; +	.ddrc_phy_compat = &quot;fsl,imx7d-ddrc-phy&quot;,</span>
<span class="quote">&gt; +	.anatop_compat = &quot;fsl,imx7d-anatop&quot;,</span>
<span class="quote">&gt; +	.ddrc_compat = &quot;fsl,imx7d-ddrc&quot;,</span>
<span class="quote">&gt; +	.ccm_compat = &quot;fsl,imx7d-ccm&quot;,</span>
<span class="quote">&gt; +	.src_compat = &quot;fsl,imx7d-src&quot;,</span>
<span class="quote">&gt; +	.gpc_compat = &quot;fsl,imx7d-gpc&quot;,</span>
<span class="quote">&gt; +	.ddrc_phy_num = ARRAY_SIZE(imx7d_ddrc_phy_ddr3_setting),</span>
<span class="quote">&gt; +	.ddrc_phy_offset = imx7d_ddrc_phy_ddr3_setting,</span>
<span class="quote">&gt; +	.ddrc_num = ARRAY_SIZE(imx7d_ddrc_ddr3_setting),</span>
<span class="quote">&gt; +	.ddrc_offset = imx7d_ddrc_ddr3_setting,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_gpcv2_suspend_init(struct imx_gpcv2_suspend *pm,</span>
<span class="quote">&gt; +			const struct imx7_pm_socdata *socdata)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx7_pm_base aips_base[3] = { {0, 0}, {0, 0}, {0, 0} };</span>
<span class="quote">&gt; +	struct imx7_pm_base sram_base = {0, 0};</span>
<span class="quote">&gt; +	struct imx7_cpu_pm_info *pm_info;</span>
<span class="quote">&gt; +	struct device_node *node;</span>
<span class="quote">&gt; +	int i, ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	const u32 (*ddrc_phy_offset_array)[2];</span>
<span class="quote">&gt; +	const u32 (*ddrc_offset_array)[2];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!socdata || !pm) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: invalid argument!\n&quot;, __func__);</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	node = NULL;</span>

You can do the initialization on top.
<span class="quote">
&gt; +	for (i = 0; i &lt; 3; i++) {</span>
<span class="quote">&gt; +		node = of_find_compatible_node(node, NULL, &quot;fsl,aips-bus&quot;);</span>
<span class="quote">&gt; +		if (!node) {</span>
<span class="quote">&gt; +			pr_warn(&quot;%s: failed to find aips %d node!\n&quot;,</span>
<span class="quote">&gt; +					__func__, i);</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		ret = imx_get_base_from_node(node, &amp;aips_base[i]);</span>
<span class="quote">&gt; +		if (ret) {</span>
<span class="quote">&gt; +			pr_warn(&quot;%s: failed to get aips[%d] base %d!\n&quot;,</span>
<span class="quote">&gt; +					__func__, i, ret);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>

What are the aips_base used for? You would need to call of_node_put for
each of them.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_exec_base_from_dt(&amp;sram_base, &quot;fsl,lpm-sram&quot;);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get lpm-sram base %d!\n&quot;,</span>
<span class="quote">&gt; +				__func__, ret);</span>
<span class="quote">&gt; +		goto lpm_sram_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm_info = sram_base.vbase;</span>
<span class="quote">&gt; +	pm_info-&gt;pbase = sram_base.pbase;</span>
<span class="quote">&gt; +	pm_info-&gt;resume_addr = virt_to_phys(ca7_cpu_resume);</span>
<span class="quote">&gt; +	pm_info-&gt;pm_info_size = sizeof(*pm_info);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ccm_base, socdata-&gt;ccm_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get ccm base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto ccm_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_base, socdata-&gt;ddrc_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get ddrc base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto ddrc_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_phy_base,</span>
<span class="quote">&gt; +				socdata-&gt;ddrc_phy_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get ddrc_phy base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto ddrc_phy_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;src_base, socdata-&gt;src_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get src base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto src_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;iomuxc_gpr_base,</span>
<span class="quote">&gt; +				socdata-&gt;iomuxc_gpr_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get iomuxc_gpr base %d!\n&quot;,</span>
<span class="quote">&gt; +					__func__, ret);</span>
<span class="quote">&gt; +		goto iomuxc_gpr_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;gpc_base, socdata-&gt;gpc_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get gpc base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto gpc_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;anatop_base,</span>
<span class="quote">&gt; +				socdata-&gt;anatop_compat);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		pr_warn(&quot;%s: failed to get anatop base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; +		goto anatop_map_failed;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm_info-&gt;ddrc_num = socdata-&gt;ddrc_num;</span>
<span class="quote">&gt; +	ddrc_offset_array = socdata-&gt;ddrc_offset;</span>
<span class="quote">&gt; +	pm_info-&gt;ddrc_phy_num = socdata-&gt;ddrc_phy_num;</span>
<span class="quote">&gt; +	ddrc_phy_offset_array = socdata-&gt;ddrc_phy_offset;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* initialize DDRC settings */</span>
<span class="quote">&gt; +	for (i = 0; i &lt; pm_info-&gt;ddrc_num; i++) {</span>
<span class="quote">&gt; +		pm_info-&gt;ddrc_val[i][0] = ddrc_offset_array[i][0];</span>
<span class="quote">&gt; +		if (ddrc_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="quote">&gt; +			pm_info-&gt;ddrc_val[i][1] =</span>
<span class="quote">&gt; +				readl_relaxed(pm_info-&gt;ddrc_base.vbase +</span>
<span class="quote">&gt; +				ddrc_offset_array[i][0]);</span>
<span class="quote">&gt; +		else</span>
<span class="quote">&gt; +			pm_info-&gt;ddrc_val[i][1] = ddrc_offset_array[i][1];</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* initialize DDRC PHY settings */</span>
<span class="quote">&gt; +	for (i = 0; i &lt; pm_info-&gt;ddrc_phy_num; i++) {</span>
<span class="quote">&gt; +		pm_info-&gt;ddrc_phy_val[i][0] =</span>
<span class="quote">&gt; +			ddrc_phy_offset_array[i][0];</span>
<span class="quote">&gt; +		if (ddrc_phy_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="quote">&gt; +			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="quote">&gt; +				readl_relaxed(pm_info-&gt;ddrc_phy_base.vbase +</span>
<span class="quote">&gt; +				ddrc_phy_offset_array[i][0]);</span>
<span class="quote">&gt; +		else</span>
<span class="quote">&gt; +			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="quote">&gt; +				ddrc_phy_offset_array[i][1];</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;suspend_fn_in_ocram = fncpy(</span>
<span class="quote">&gt; +		sram_base.vbase + sizeof(*pm_info),</span>
<span class="quote">&gt; +		&amp;imx7_suspend,</span>
<span class="quote">&gt; +		MX7_SUSPEND_OCRAM_SIZE - sizeof(*pm_info));</span>
<span class="quote">&gt; +	pm-&gt;ocram_vbase = sram_base.vbase;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	goto put_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +anatop_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;anatop_base.vbase);</span>
<span class="quote">&gt; +gpc_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;gpc_base.vbase);</span>
<span class="quote">&gt; +iomuxc_gpr_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;iomuxc_gpr_base.vbase);</span>
<span class="quote">&gt; +src_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;src_base.vbase);</span>
<span class="quote">&gt; +ddrc_phy_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;ddrc_phy_base.vbase);</span>
<span class="quote">&gt; +ddrc_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;ddrc_base.vbase);</span>
<span class="quote">&gt; +ccm_map_failed:</span>
<span class="quote">&gt; +	iounmap(pm_info-&gt;ccm_base.vbase);</span>
<span class="quote">&gt; +lpm_sram_map_failed:</span>
<span class="quote">&gt; +	iounmap(sram_base.vbase);</span>
<span class="quote">&gt; +put_node:</span>
<span class="quote">&gt; +	of_node_put(node);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct platform_suspend_ops imx_gpcv2_pm_ops = {</span>
<span class="quote">&gt; +	.enter = imx_gpcv2_pm_enter,</span>
<span class="quote">&gt; +	.valid = imx_gpcv2_pm_valid,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init imx_gpcv2_pm_init(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct imx_gpcv2_suspend *pm;</span>
<span class="quote">&gt; +	struct imx_gpcv2_irq *cd;</span>
<span class="quote">&gt; +	struct imx_gpcv2 *gpc;</span>
<span class="quote">&gt; +	int val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm = kzalloc(sizeof(struct imx_gpcv2_suspend), GFP_KERNEL);</span>
<span class="quote">&gt; +	gpc = kzalloc(sizeof(struct imx_gpcv2), GFP_KERNEL);</span>
<span class="quote">&gt; +	cd = gpcv2_irq_instance;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!cd || !pm || !gpc) {</span>
<span class="quote">&gt; +		pr_debug(&quot;[GPCv2] %s init failed\r\n&quot;, __func__);</span>
<span class="quote">&gt; +		return 0;</span>
<span class="quote">&gt; +	}</span>

This shortcut doesn&#39;t work, what if allocating pm succeeds and gpc does
not?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	imx_gpcv2_suspend_init(pm, &amp;imx7d_pm_data_ddr3);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_setup = imx_gpcv2_lpm_env_setup;</span>
<span class="quote">&gt; +	pm-&gt;lpm_env_clean = imx_gpcv2_lpm_env_clean;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;lpm_cpu_power_gate = imx_gpcv2_lpm_cpu_power_gate;</span>
<span class="quote">&gt; +	pm-&gt;lpm_plat_power_gate = imx_lpm_plat_power_gate;</span>
<span class="quote">&gt; +	pm-&gt;lpm_enable_core = imx_gpcv2_lpm_enable_core;</span>
<span class="quote">&gt; +	pm-&gt;set_mode = imx_gpcv2_lpm_set_mode;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;clear_slots = imx_gpcv2_lpm_clear_slots;</span>
<span class="quote">&gt; +	pm-&gt;set_slot = imx_gpcv2_lpm_slot_setup;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pm-&gt;standby = imx_gpcv2_lpm_standby;</span>
<span class="quote">&gt; +	pm-&gt;suspend = imx_gpcv2_lpm_suspend;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pr_debug(&quot;[GPCv2] %s \r\n&quot;, __func__);</span>
<span class="quote">&gt; +	pm-&gt;anatop = syscon_regmap_lookup_by_compatible(&quot;fsl,imx6q-anatop&quot;);</span>
<span class="quote">&gt; +	WARN_ON(!pm-&gt;anatop);</span>
<span class="quote">&gt; +	pm-&gt;imx_src = syscon_regmap_lookup_by_compatible(&quot;fsl,imx7d-src&quot;);</span>
<span class="quote">&gt; +	WARN_ON(!pm-&gt;imx_src);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Due to hardware design failure, need to make sure GPR</span>
<span class="quote">&gt; +	 * interrupt(#32) is unmasked during RUN mode to avoid entering</span>
<span class="quote">&gt; +	 * DSM by mistake.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	writel_relaxed(~0x1, cd-&gt;gpc_base + cd-&gt;cpu2wakeup);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* only external IRQs to wake up LPM and core 0/1 */</span>
<span class="quote">&gt; +	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="quote">&gt; +	val |= BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP;</span>
<span class="quote">&gt; +	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="quote">&gt; +	/* mask m4 dsm trigger */</span>
<span class="quote">&gt; +	writel_relaxed(readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_M4) |</span>
<span class="quote">&gt; +		BM_LPCR_M4_MASK_DSM_TRIGGER, cd-&gt;gpc_base + GPC_LPCR_M4);</span>
<span class="quote">&gt; +	/* set mega/fast mix in A7 domain */</span>
<span class="quote">&gt; +	writel_relaxed(0x1, cd-&gt;gpc_base + GPC_PGC_CPU_MAPPING);</span>
<span class="quote">&gt; +	/* set SCU timing */</span>
<span class="quote">&gt; +	writel_relaxed((0x59 &lt;&lt; 10) | 0x5B | (0x51 &lt;&lt; 20),</span>
<span class="quote">&gt; +		cd-&gt;gpc_base + GPC_PGC_SCU_TIMING);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Mask the wakeup sources in M/F power domain */</span>
<span class="quote">&gt; +	pm-&gt;mfmix_mask[0] = 0x54010000;</span>
<span class="quote">&gt; +	pm-&gt;mfmix_mask[1] = 0xc00;</span>
<span class="quote">&gt; +	pm-&gt;mfmix_mask[2] = 0x0;</span>
<span class="quote">&gt; +	pm-&gt;mfmix_mask[3] = 0x400010;</span>

What is this doing?

I stop here for now, will have a look at the assembly part another time.

--
Stefan
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a> - July 31, 2015, 3:26 p.m.</div>
<pre class="content">
Hi Stefan,
<span class="quote">
&gt; -----Original Message-----</span>
<span class="quote">&gt; From: Stefan Agner [mailto:stefan@agner.ch]</span>
<span class="quote">&gt; Sent: 2015?7?30? 17:44</span>
<span class="quote">&gt; To: Wang Shenwei-B38339</span>
<span class="quote">&gt; Cc: shawn.guo@linaro.org; tglx@linutronix.de; jason@lakedaemon.net; Huang</span>
<span class="quote">&gt; Yongcai-B20788; linux-kernel@vger.kernel.org;</span>
<span class="quote">&gt; linux-arm-kernel@lists.infradead.org</span>
<span class="quote">&gt; Subject: Re: [PATCH v7 2/2] ARM: imx: Add suspend codes for imx7D</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi Shenwei,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The Subject sounds somewhat strange, if you mean your program code, then you</span>
<span class="quote">&gt; should not use the plural. Or maybe &quot;add suspend states...&quot; or &quot;support suspend</span>
<span class="quote">&gt; states...&quot;?</span>

Good suggestion! Will change to support suspend states on imx7d.
<span class="quote">
&gt; On 2015-07-27 21:30, Shenwei Wang wrote:</span>
<span class="quote">&gt; &gt; IMX7D contains a new version of GPC IP block (GPCv2). It has two major</span>
<span class="quote">&gt; &gt; functions: power management and wakeup source management.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; GPCv2 provides low power mode control for Cortex-A7 and Cortex-M4</span>
<span class="quote">&gt; &gt; domains. And it can support WAIT, STOP, and DSM(Deep Sleep Mode) modes.</span>
<span class="quote">&gt; &gt; After configuring the GPCv2 module, the platform can enter into a</span>
<span class="quote">&gt; &gt; selected mode either automatically triggered by ARM WFI instruction or</span>
<span class="quote">&gt; &gt; manually by software. The system will exit the low power states by the</span>
<span class="quote">&gt; &gt; predefined wakeup sources which are managed by the gpcv2 irqchip</span>
<span class="quote">&gt; &gt; driver.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This patch adds a new suspend driver to manage the power states on IMX7D.</span>
<span class="quote">&gt; &gt; It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Anson Huang &lt;b20788@freescale.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  arch/arm/mach-imx/Kconfig        |   1 +</span>
<span class="quote">&gt; &gt;  arch/arm/mach-imx/Makefile       |   2 +</span>
<span class="quote">&gt; &gt;  arch/arm/mach-imx/pm-imx7.c      | 901</span>
<span class="quote">&gt; +++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;  arch/arm/mach-imx/suspend-imx7.S | 529 +++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;  4 files changed, 1433 insertions(+)</span>
<span class="quote">&gt; &gt;  create mode 100644 arch/arm/mach-imx/pm-imx7.c  create mode 100644</span>
<span class="quote">&gt; &gt; arch/arm/mach-imx/suspend-imx7.S</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; &gt; index 8ceda28..54f8553 100644</span>
<span class="quote">&gt; &gt; --- a/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; &gt; +++ b/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; &gt; @@ -562,6 +562,7 @@ config SOC_IMX7D</span>
<span class="quote">&gt; &gt;  	select ARM_GIC</span>
<span class="quote">&gt; &gt;  	select HAVE_IMX_ANATOP</span>
<span class="quote">&gt; &gt;  	select HAVE_IMX_MMDC</span>
<span class="quote">&gt; &gt; +	select IMX_GPCV2</span>
<span class="quote">&gt; &gt;  	help</span>
<span class="quote">&gt; &gt;  		This enables support for Freescale i.MX7 Dual processor.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; &gt; index fb689d8..ca4c566 100644</span>
<span class="quote">&gt; &gt; --- a/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; &gt; +++ b/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; &gt; @@ -88,6 +88,8 @@ obj-$(CONFIG_SOC_IMX7D) += mach-imx7d.o</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;  ifeq ($(CONFIG_SUSPEND),y)</span>
<span class="quote">&gt; &gt;  AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; &gt; +AFLAGS_suspend-imx7.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; &gt; +obj-$(CONFIG_IMX_GPCV2)	+= suspend-imx7.o pm-imx7.o</span>
<span class="quote">&gt; &gt;  obj-$(CONFIG_SOC_IMX6) += suspend-imx6.o</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; A rather strange ordering, can you keep the AFLAGS near the object file?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;  obj-$(CONFIG_SOC_IMX53) += suspend-imx53.o  endif diff --git</span>
<span class="quote">&gt; &gt; a/arch/arm/mach-imx/pm-imx7.c b/arch/arm/mach-imx/pm-imx7.c new file</span>
<span class="quote">&gt; &gt; mode 100644 index 0000000..9035368</span>
<span class="quote">&gt; &gt; --- /dev/null</span>
<span class="quote">&gt; &gt; +++ b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="quote">&gt; &gt; @@ -0,0 +1,901 @@</span>
<span class="quote">&gt; &gt; +/*</span>
<span class="quote">&gt; &gt; + * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="quote">&gt; &gt; + *</span>
<span class="quote">&gt; &gt; + * This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; &gt; +modify</span>
<span class="quote">&gt; &gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; &gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#include &lt;linux/mfd/syscon.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/regmap.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/suspend.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;asm/suspend.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;asm/fncpy.h&gt;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#include &lt;soc/imx/gpcv2.h&gt;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_L2PGE			0x10000</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_EN_C1_PUP			0x800</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_EN_C1_IRQ_PUP		0x400</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_EN_C0_PUP			0x200</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_EN_C0_IRQ_PUP		0x100</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_EN_PLAT_PDN		0x10</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_EN_C1_PDN			0x8</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_EN_C1_WFI_PDN		0x4</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_EN_C0_PDN			0x2</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_AD_EN_C0_WFI_PDN		0x1</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP	0x70000000</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_BSC_CPU_CLK_ON_LPM		0x4000</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_BSC_LPM1			0xc</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_A7_BSC_LPM0			0x3</span>
<span class="quote">&gt; &gt; +#define BP_LPCR_A7_BSC_LPM1			2</span>
<span class="quote">&gt; &gt; +#define BP_LPCR_A7_BSC_LPM0			0</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define BM_LPCR_M4_MASK_DSM_TRIGGER		0x80000000</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define BM_SLPCR_EN_DSM				0x80000000</span>
<span class="quote">&gt; &gt; +#define BM_SLPCR_RBC_EN				0x40000000</span>
<span class="quote">&gt; &gt; +#define BM_SLPCR_VSTBY				0x4</span>
<span class="quote">&gt; &gt; +#define BM_SLPCR_SBYOS				0x2</span>
<span class="quote">&gt; &gt; +#define BM_SLPCR_BYPASS_PMIC_READY		0x1</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP_ACK	0x80000000</span>
<span class="quote">&gt; &gt; +#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN_ACK	0x8000</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Typically the bit field size + shifts is used here, e.g.</span>

Okay.
<span class="quote">
&gt; #define BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP	(0x7 &lt;&lt; 28)</span>
<span class="quote">&gt; #define BM_LPCR_A7_BSC_CPU_CLK_ON_LPM		(0x1 &lt;&lt; 14)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is much easier to verify against the data sheet.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define GPC_LPCR_A7_BSC		0x0</span>
<span class="quote">&gt; &gt; +#define GPC_LPCR_A7_AD		0x4</span>
<span class="quote">&gt; &gt; +#define GPC_LPCR_M4		0x8</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define GPC_PGC_CPU_MAPPING	0xec</span>
<span class="quote">&gt; &gt; +#define GPC_PGC_SCU_TIMING	0x890</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define GPC_SLPCR		0x14</span>
<span class="quote">&gt; &gt; +#define GPC_PGC_ACK_SEL_A7	0x24</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define GPC_SLOT0_CFG		0xb0</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define GPC_PGC_C0		0x800</span>
<span class="quote">&gt; &gt; +#define GPC_PGC_SCU_TIMING	0x890</span>
<span class="quote">&gt; &gt; +#define GPC_PGC_C1		0x840</span>
<span class="quote">&gt; &gt; +#define GPC_PGC_SCU		0x880</span>
<span class="quote">&gt; &gt; +#define GPC_PGC_FM		0xa00</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define ANADIG_ARM_PLL		0x60</span>
<span class="quote">&gt; &gt; +#define ANADIG_DDR_PLL		0x70</span>
<span class="quote">&gt; &gt; +#define ANADIG_SYS_PLL		0xb0</span>
<span class="quote">&gt; &gt; +#define ANADIG_ENET_PLL		0xe0</span>
<span class="quote">&gt; &gt; +#define ANADIG_AUDIO_PLL	0xf0</span>
<span class="quote">&gt; &gt; +#define ANADIG_VIDEO_PLL	0x130</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define MAX_SLOT_NUMBER		10</span>
<span class="quote">&gt; &gt; +#define A7_LPM_WAIT		0x5</span>
<span class="quote">&gt; &gt; +#define A7_LPM_STOP		0xa</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define REG_SET			0x4</span>
<span class="quote">&gt; &gt; +#define REG_CLR			0x8</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +enum gpcv2_mode {</span>
<span class="quote">&gt; &gt; +	WAIT_CLOCKED,</span>
<span class="quote">&gt; &gt; +	WAIT_UNCLOCKED,</span>
<span class="quote">&gt; &gt; +	WAIT_UNCLOCKED_POWER_OFF,</span>
<span class="quote">&gt; &gt; +	STOP_POWER_ON,</span>
<span class="quote">&gt; &gt; +	STOP_POWER_OFF,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +/* GPCv2 has the following power domains, and each domain can be</span>
<span class="quote">&gt; &gt; +power-up</span>
<span class="quote">&gt; &gt; + * and power-down via GPC settings.</span>
<span class="quote">&gt; &gt; + *</span>
<span class="quote">&gt; &gt; + * 	Core 0 of A7 power domain</span>
<span class="quote">&gt; &gt; + * 	Core1 of A7 power domain</span>
<span class="quote">&gt; &gt; + * 	SCU/L2 cache RAM of A7 power domain</span>
<span class="quote">&gt; &gt; + * 	Fastmix and megamix power domain</span>
<span class="quote">&gt; &gt; + * 	USB OTG1 PHY power domain</span>
<span class="quote">&gt; &gt; + * 	USB OTG2 PHY power domain</span>
<span class="quote">&gt; &gt; + * 	PCIE PHY power domain</span>
<span class="quote">&gt; &gt; + * 	USB HSIC PHY power domain</span>
<span class="quote">&gt; &gt; + *	Core 0 of M4 power domain</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: a empty line is the preferred format in this part of the kernel:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; /*</span>
<span class="quote">&gt;  * Start here...</span>
<span class="quote">&gt; </span>

Okay.
<span class="quote">
&gt; &gt; +enum gpcv2_slot {</span>
<span class="quote">&gt; &gt; +	CORE0_A7,</span>
<span class="quote">&gt; &gt; +	CORE1_A7,</span>
<span class="quote">&gt; &gt; +	SCU_A7,</span>
<span class="quote">&gt; &gt; +	FAST_MEGA_MIX,</span>
<span class="quote">&gt; &gt; +	MIPI_PHY,</span>
<span class="quote">&gt; &gt; +	PCIE_PHY,</span>
<span class="quote">&gt; &gt; +	USB_OTG1_PHY,</span>
<span class="quote">&gt; &gt; +	USB_OTG2_PHY,</span>
<span class="quote">&gt; &gt; +	USB_HSIC_PHY,</span>
<span class="quote">&gt; &gt; +	CORE0_M4,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +struct imx_gpcv2;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +struct imx_gpcv2_suspend {</span>
<span class="quote">&gt; &gt; +	struct regmap *anatop;</span>
<span class="quote">&gt; &gt; +	struct regmap *imx_src;</span>
<span class="quote">&gt; &gt; +	u32 mfmix_mask[IMR_NUM];</span>
<span class="quote">&gt; &gt; +	u32 wakeupmix_mask[IMR_NUM];</span>
<span class="quote">&gt; &gt; +	u32 lpsrmix_mask[IMR_NUM];</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	void (*set_mode)(struct imx_gpcv2 *, enum gpcv2_mode mode);</span>
<span class="quote">&gt; &gt; +	void (*lpm_cpu_power_gate)(struct imx_gpcv2 *, u32, bool);</span>
<span class="quote">&gt; &gt; +	void (*lpm_plat_power_gate)(struct imx_gpcv2 *, bool);</span>
<span class="quote">&gt; &gt; +	void (*lpm_env_setup)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; &gt; +	void (*lpm_env_clean)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	void (*set_slot)(struct imx_gpcv2 *cd, u32 index,</span>
<span class="quote">&gt; &gt; +			enum gpcv2_slot m_core, bool mode, bool ack);</span>
<span class="quote">&gt; &gt; +	void (*clear_slots)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; &gt; +	void (*lpm_enable_core)(struct imx_gpcv2 *,</span>
<span class="quote">&gt; &gt; +			bool enable, u32 offset);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	void (*standby)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; &gt; +	void (*suspend)(struct imx_gpcv2 *);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	void (*suspend_fn_in_ocram)(void __iomem *ocram_vbase);</span>
<span class="quote">&gt; &gt; +	void __iomem *ocram_vbase;</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +struct imx_gpcv2 {</span>
<span class="quote">&gt; &gt; +	spinlock_t lock;</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_irq *irqchip;</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_suspend *pm;</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +extern struct imx_gpcv2_irq *gpcv2_irq_instance; static struct</span>
<span class="quote">&gt; &gt; +imx_gpcv2 *gpcv2_instance;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void imx_gpcv2_lpm_clear_slots(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; &gt; +	unsigned long flags;</span>
<span class="quote">&gt; &gt; +	int i;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; MAX_SLOT_NUMBER; i++)</span>
<span class="quote">&gt; &gt; +		writel_relaxed(0x0, cd-&gt;gpc_base + GPC_SLOT0_CFG + i * 0x4);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP_ACK |</span>
<span class="quote">&gt; &gt; +		BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN_ACK,</span>
<span class="quote">&gt; &gt; +		cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags); }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void imx_gpcv2_lpm_enable_core(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; &gt; +			bool enable, u32 offset)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; &gt; +	unsigned long flags;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(enable, cd-&gt;gpc_base + offset);</span>
<span class="quote">&gt; &gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags); }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void imx_gpcv2_lpm_slot_setup(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; &gt; +		u32 index, enum gpcv2_slot m_core, bool mode, bool ack) {</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; &gt; +	unsigned long flags;</span>
<span class="quote">&gt; &gt; +	u32 val;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (index &gt;= MAX_SLOT_NUMBER)</span>
<span class="quote">&gt; &gt; +		pr_err(&quot;Invalid slot index!\n&quot;);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is a return missing here? The check seems rather useless otherwise.</span>

Yes, should return here.
<span class="quote">
&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; &gt; +	/* set slot */</span>
<span class="quote">&gt; &gt; +	writel_relaxed((mode + 1) &lt;&lt; (m_core * 2), cd-&gt;gpc_base +</span>
<span class="quote">&gt; &gt; +		GPC_SLOT0_CFG + index * 4);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Can you create a preprocessor for the slot register?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; #define GPC_SLOTx_CFG(x) (0xb0 + 4 * (x))</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The parameter m_core has a unintuitive name, slot sounds much better to me.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Also boolean and an addition is somewhat strange, I would prefer something like:</span>
<span class="quote">&gt; mode ? 0x2 : 0x1 &lt;&lt; (slot * 2)</span>

Yes. Will follow this idea in the new patch.
<span class="quote">
&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (ack) {</span>
<span class="quote">&gt; &gt; +		/* set ack */</span>
<span class="quote">&gt; &gt; +		val = readl_relaxed(cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="quote">&gt; &gt; +		/* clear dummy ack */</span>
<span class="quote">&gt; &gt; +		val &amp;= ~(1 &lt;&lt; (15 + (mode ? 16 : 0)));</span>
<span class="quote">&gt; &gt; +		val |= 1 &lt;&lt; (m_core + (mode ? 16 : 0));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Can you come up with macros here too? That is not readable...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For the dummy ack I would suggest to create dedicated defines and for the power</span>
<span class="quote">&gt; domain acks something which takes the slot as argument...</span>

Will consider that in new patch.
<span class="quote">

&gt; &gt; +		writel_relaxed(val, cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags); }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void imx_gpcv2_lpm_env_setup(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* PLL and PFDs overwrite set */</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_ARM_PLL + REG_SET, 1 &lt;&lt; 20);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_DDR_PLL + REG_SET, 1 &lt;&lt; 19);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_SYS_PLL + REG_SET, 0x1ff &lt;&lt; 17);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_ENET_PLL + REG_SET, 1 &lt;&lt; 13);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_AUDIO_PLL + REG_SET, 1 &lt;&lt; 24);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_VIDEO_PLL + REG_SET, 1 &lt;&lt; 24); }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void imx_gpcv2_lpm_env_clean(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* PLL and PFDs overwrite clear */</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_ARM_PLL + REG_CLR, 1 &lt;&lt; 20);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_DDR_PLL + REG_CLR, 1 &lt;&lt; 19);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_SYS_PLL + REG_CLR, 0x1ff &lt;&lt; 17);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_ENET_PLL + REG_CLR, 1 &lt;&lt; 13);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_AUDIO_PLL + REG_CLR, 1 &lt;&lt; 24);</span>
<span class="quote">&gt; &gt; +	regmap_write(pm-&gt;anatop, ANADIG_VIDEO_PLL + REG_CLR, 1 &lt;&lt; 24); }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void imx_gpcv2_lpm_set_mode(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; &gt; +		enum gpcv2_mode mode)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; &gt; +	unsigned long flags;</span>
<span class="quote">&gt; &gt; +	u32 val1, val2;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Please use names which say something. tmp and i is ok, if it&#39;s a temporary</span>
<span class="quote">&gt; variable or a counter, but not val1/val2...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	val1 = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="quote">&gt; &gt; +	val2 = readl_relaxed(cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* all cores&#39; LPM settings must be same */</span>
<span class="quote">&gt; &gt; +	val1 &amp;= ~(BM_LPCR_A7_BSC_LPM0 | BM_LPCR_A7_BSC_LPM1);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	val1 |= BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	val2 &amp;= ~(BM_SLPCR_EN_DSM | BM_SLPCR_VSTBY | BM_SLPCR_RBC_EN |</span>
<span class="quote">&gt; &gt; +		BM_SLPCR_SBYOS | BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * GPCv2: When improper low-power sequence is used,</span>
<span class="quote">&gt; &gt; +	 * the SoC enters low power mode before the ARM core executes WFI.</span>
<span class="quote">&gt; &gt; +	 *</span>
<span class="quote">&gt; &gt; +	 * Software workaround:</span>
<span class="quote">&gt; &gt; +	 * 1) Software should trigger IRQ #32 (IOMUX) to be always pending</span>
<span class="quote">&gt; &gt; +	 *    by setting IOMUX_GPR1_IRQ.</span>
<span class="quote">&gt; &gt; +	 * 2) Software should then unmask IRQ #32 in GPC before setting GPC</span>
<span class="quote">&gt; &gt; +	 *    Low-Power mode.</span>
<span class="quote">&gt; &gt; +	 * 3) Software should mask IRQ #32 right after GPC Low-Power mode</span>
<span class="quote">&gt; &gt; +	 *    is set.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	switch (mode) {</span>
<span class="quote">&gt; &gt; +	case WAIT_CLOCKED:</span>
<span class="quote">&gt; &gt; +		break;</span>
<span class="quote">&gt; &gt; +	case WAIT_UNCLOCKED:</span>
<span class="quote">&gt; &gt; +		val1 |= A7_LPM_WAIT &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="quote">&gt; &gt; +		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; &gt; +		break;</span>
<span class="quote">&gt; &gt; +	case STOP_POWER_ON:</span>
<span class="quote">&gt; &gt; +		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="quote">&gt; &gt; +		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; &gt; +		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="quote">&gt; &gt; +		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="quote">&gt; &gt; +		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="quote">&gt; &gt; +		break;</span>
<span class="quote">&gt; &gt; +	case STOP_POWER_OFF:</span>
<span class="quote">&gt; &gt; +		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="quote">&gt; &gt; +		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="quote">&gt; &gt; +		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="quote">&gt; &gt; +		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="quote">&gt; &gt; +		val2 |= BM_SLPCR_SBYOS;</span>
<span class="quote">&gt; &gt; +		val2 |= BM_SLPCR_VSTBY;</span>
<span class="quote">&gt; &gt; +		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="quote">&gt; &gt; +		break;</span>
<span class="quote">&gt; &gt; +	default:</span>
<span class="quote">&gt; &gt; +		return;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What about the spin lock?</span>

It is a bug.
<span class="quote">
&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +	writel_relaxed(val1, cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(val2, cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags); }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void imx_gpcv2_lpm_cpu_power_gate(struct imx_gpcv2 *gpc,</span>
<span class="quote">&gt; &gt; +				u32 cpu, bool pdn)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hm, pdn is somewhat overused here. Your bool pdn says that you want to power</span>
<span class="quote">&gt; gate a certain core. Below you then set PDN and PUP, that is somewhat confusing.</span>
<span class="quote">&gt; Maybe bool engate or en_lpm?</span>

Good suggestion!
<span class="quote">
&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; &gt; +	unsigned long flags;</span>
<span class="quote">&gt; &gt; +	u32 val;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	const u32 val_pdn[2] = {</span>
<span class="quote">&gt; &gt; +		BM_LPCR_A7_AD_EN_C0_PDN | BM_LPCR_A7_AD_EN_C0_PUP,</span>
<span class="quote">&gt; &gt; +		BM_LPCR_A7_AD_EN_C1_PDN | BM_LPCR_A7_AD_EN_C1_PUP,</span>
<span class="quote">&gt; &gt; +	};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="quote">&gt; &gt; +	if (pdn)</span>
<span class="quote">&gt; &gt; +		val |= val_pdn[cpu];</span>
<span class="quote">&gt; &gt; +	else</span>
<span class="quote">&gt; &gt; +		val &amp;= ~val_pdn[cpu];</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="quote">&gt; &gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags); }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void imx_lpm_plat_power_gate(struct imx_gpcv2 *gpc, bool pdn)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; &gt; +	unsigned long flags;</span>
<span class="quote">&gt; &gt; +	u32 val;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="quote">&gt; &gt; +	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="quote">&gt; &gt; +	val &amp;= ~(BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE);</span>
<span class="quote">&gt; &gt; +	if (pdn)</span>
<span class="quote">&gt; &gt; +		val |= BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="quote">&gt; &gt; +	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags); }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void imx_gpcv2_lpm_standby(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_env_setup(gpc);</span>
<span class="quote">&gt; &gt; +	/* pm-&gt;set_mode(gpc, STOP_POWER_OFF); */</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_mode(gpc, WAIT_UNCLOCKED);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pr_debug(&quot;[GPCv2] %s %d\r\n&quot;, __func__, __LINE__);</span>
<span class="quote">&gt; &gt; +	/* Zzz ... */</span>
<span class="quote">&gt; &gt; +	cpu_do_idle();</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_mode(gpc, WAIT_CLOCKED);</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_env_clean(gpc);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int gpcv2_suspend_finish(unsigned long val) {</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_suspend *pm = (struct imx_gpcv2_suspend *)val;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!pm-&gt;suspend_fn_in_ocram) {</span>
<span class="quote">&gt; &gt; +		cpu_do_idle();</span>
<span class="quote">&gt; &gt; +	} else {</span>
<span class="quote">&gt; &gt; +		/*</span>
<span class="quote">&gt; &gt; +		 * call low level suspend function in ocram,</span>
<span class="quote">&gt; &gt; +		 * as we need to float DDR IO.</span>
<span class="quote">&gt; &gt; +		 */</span>
<span class="quote">&gt; &gt; +		local_flush_tlb_all();</span>
<span class="quote">&gt; &gt; +		pm-&gt;suspend_fn_in_ocram(pm-&gt;ocram_vbase);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +static void imx_gpcv2_lpm_suspend(struct imx_gpcv2 *gpc) {</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="quote">&gt; &gt; +	int i = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_env_setup(gpc);</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_mode(gpc, STOP_POWER_OFF);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* enable core0 power down/up with low power mode */</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_cpu_power_gate(gpc, 0, true);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* enable plat power down with low power mode */</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_plat_power_gate(gpc, true);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * To avoid confuse, we use slot 0~4 for power down,</span>
<span class="quote">&gt; &gt; +	 * slot 5~9 for power up.</span>
<span class="quote">&gt; &gt; +	 *</span>
<span class="quote">&gt; &gt; +	 * Power down slot sequence:</span>
<span class="quote">&gt; &gt; +	 * Slot0 -&gt; CORE0</span>
<span class="quote">&gt; &gt; +	 * Slot1 -&gt; Mega/Fast MIX</span>
<span class="quote">&gt; &gt; +	 * Slot2 -&gt; SCU</span>
<span class="quote">&gt; &gt; +	 *</span>
<span class="quote">&gt; &gt; +	 * Power up slot sequence:</span>
<span class="quote">&gt; &gt; +	 * Slot5 -&gt; Mega/Fast MIX</span>
<span class="quote">&gt; &gt; +	 * Slot6 -&gt; SCU</span>
<span class="quote">&gt; &gt; +	 * Slot7 -&gt; CORE0</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_slot(gpc, 0, CORE0_A7, false, false);</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_slot(gpc, 2, SCU_A7, false, true);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Maybe it would be better to introduce a enum for the power-up/power-down?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; IMR_NUM; i++) {</span>
<span class="quote">&gt; &gt; +		if ((~cd-&gt;wakeup_sources[i] &amp; pm-&gt;mfmix_mask[i]) != 0)</span>
<span class="quote">&gt; &gt; +			break;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		pm-&gt;set_slot(gpc, 1, FAST_MEGA_MIX, false, false);</span>
<span class="quote">&gt; &gt; +		pm-&gt;set_slot(gpc, 5, FAST_MEGA_MIX, true, false);</span>
<span class="quote">&gt; &gt; +		pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_FM);</span>
<span class="quote">&gt; &gt; +		break;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is somewhat weird. You break either way in the first loop don&#39;t you? Why</span>
<span class="quote">&gt; using a loop then?</span>

It is a logic bug. Corrected it in the new patch.
<span class="quote">
&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_slot(gpc, 6, SCU_A7, true, false);</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_slot(gpc, 7, CORE0_A7, true, true);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* enable core0, scu */</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_C0);</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_SCU);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* Suspend to MEM has not been implemented yet */</span>
<span class="quote">&gt; &gt; +	cpu_suspend((unsigned long)pm, gpcv2_suspend_finish);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What does that mean?</span>

It is an old comment. Will remove it.
<span class="quote"> 

&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_env_clean(gpc);</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_mode(gpc, WAIT_CLOCKED);</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_cpu_power_gate(gpc, 0, false);</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_plat_power_gate(gpc, false);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_C0);</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_SCU);</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_FM);</span>
<span class="quote">&gt; &gt; +	pm-&gt;clear_slots(gpc);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int imx_gpcv2_pm_enter(suspend_state_t state) {</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_suspend *pm;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	BUG_ON(!gpcv2_instance);</span>
<span class="quote">&gt; &gt; +	pm = gpcv2_instance-&gt;pm;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	switch (state) {</span>
<span class="quote">&gt; &gt; +	case PM_SUSPEND_STANDBY:</span>
<span class="quote">&gt; &gt; +		pm-&gt;standby(gpcv2_instance);</span>
<span class="quote">&gt; &gt; +		break;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	case PM_SUSPEND_MEM:</span>
<span class="quote">&gt; &gt; +		pm-&gt;suspend(gpcv2_instance);</span>
<span class="quote">&gt; &gt; +		break;</span>
<span class="quote">&gt; &gt; +	default:</span>
<span class="quote">&gt; &gt; +		return -EINVAL;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int imx_gpcv2_pm_valid(suspend_state_t state) {</span>
<span class="quote">&gt; &gt; +	return state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY; }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define MX7_MAX_DDRC_NUM		32</span>
<span class="quote">&gt; &gt; +#define MX7_MAX_DDRC_PHY_NUM		16</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define READ_DATA_FROM_HARDWARE		0</span>
<span class="quote">&gt; &gt; +#define MX7_SUSPEND_OCRAM_SIZE		0x1000</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +struct imx7_pm_base {</span>
<span class="quote">&gt; &gt; +	phys_addr_t pbase;</span>
<span class="quote">&gt; &gt; +	void __iomem *vbase;</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +struct imx7_pm_socdata {</span>
<span class="quote">&gt; &gt; +	u32 ddr_type;</span>
<span class="quote">&gt; &gt; +	const char *ddrc_compat;</span>
<span class="quote">&gt; &gt; +	const char *ddrc_phy_compat;</span>
<span class="quote">&gt; &gt; +	const char *src_compat;</span>
<span class="quote">&gt; &gt; +	const char *iomuxc_gpr_compat;</span>
<span class="quote">&gt; &gt; +	const char *ccm_compat;</span>
<span class="quote">&gt; &gt; +	const char *gpc_compat;</span>
<span class="quote">&gt; &gt; +	const char *anatop_compat;</span>
<span class="quote">&gt; &gt; +	const u32 ddrc_num;</span>
<span class="quote">&gt; &gt; +	const u32 (*ddrc_offset)[2];</span>
<span class="quote">&gt; &gt; +	const u32 ddrc_phy_num;</span>
<span class="quote">&gt; &gt; +	const u32 (*ddrc_phy_offset)[2];</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +/*</span>
<span class="quote">&gt; &gt; + * This structure is for passing necessary data for low level ocram</span>
<span class="quote">&gt; &gt; + * suspend code(arch/arm/mach-imx/suspend-imx7.S), if this struct</span>
<span class="quote">&gt; &gt; + * definition is changed, the offset definition in</span>
<span class="quote">&gt; &gt; + * arch/arm/mach-imx/suspend-imx7.S must be also changed accordingly,</span>
<span class="quote">&gt; &gt; + * otherwise, the suspend to ocram function will be broken!</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; &gt; +struct imx7_cpu_pm_info {</span>
<span class="quote">&gt; &gt; +	u32 m4_reserve0;</span>
<span class="quote">&gt; &gt; +	u32 m4_reserve1;</span>
<span class="quote">&gt; &gt; +	u32 m4_reserve2;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* The physical address of pm_info. */</span>
<span class="quote">&gt; &gt; +	phys_addr_t pbase;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* The physical resume address for asm code */</span>
<span class="quote">&gt; &gt; +	phys_addr_t resume_addr;</span>
<span class="quote">&gt; &gt; +	u32 ddr_type;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	u32 pm_info_size;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base ddrc_base;</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base ddrc_phy_base;</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base src_base;</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base iomuxc_gpr_base;</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base ccm_base;</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base gpc_base;</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base l2_base;</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base anatop_base;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	u32 ttbr1;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* Number of DDRC which need saved/restored. */</span>
<span class="quote">&gt; &gt; +	u32 ddrc_num;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* To save offset and value */</span>
<span class="quote">&gt; &gt; +	u32 ddrc_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* Number of DDRC which need saved/restored. */</span>
<span class="quote">&gt; &gt; +	u32 ddrc_phy_num;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* To save offset and value */</span>
<span class="quote">&gt; &gt; +	u32 ddrc_phy_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="quote">&gt; &gt; +} __aligned(8);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int __init imx_get_base_from_node(struct device_node *node,</span>
<span class="quote">&gt; &gt; +			struct imx7_pm_base *base)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct resource res;</span>
<span class="quote">&gt; &gt; +	int ret = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="quote">&gt; &gt; +	if (ret)</span>
<span class="quote">&gt; &gt; +		goto put_node;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	base-&gt;pbase = res.start;</span>
<span class="quote">&gt; &gt; +	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="quote">&gt; &gt; +	if (!base-&gt;vbase) {</span>
<span class="quote">&gt; &gt; +		iounmap(base-&gt;vbase);</span>
<span class="quote">&gt; &gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +put_node:</span>
<span class="quote">&gt; &gt; +	of_node_put(node);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int __init imx_get_base_from_dt(struct imx7_pm_base *base,</span>
<span class="quote">&gt; &gt; +				const char *compat)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct device_node *node;</span>
<span class="quote">&gt; &gt; +	struct resource res;</span>
<span class="quote">&gt; &gt; +	int ret = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="quote">&gt; &gt; +	if (!node) {</span>
<span class="quote">&gt; &gt; +		ret = -ENODEV;</span>
<span class="quote">&gt; &gt; +		goto out;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="quote">&gt; &gt; +	if (ret)</span>
<span class="quote">&gt; &gt; +		goto put_node;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	base-&gt;pbase = res.start;</span>
<span class="quote">&gt; &gt; +	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="quote">&gt; &gt; +	if (!base-&gt;vbase)</span>
<span class="quote">&gt; &gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +put_node:</span>
<span class="quote">&gt; &gt; +	of_node_put(node);</span>
<span class="quote">&gt; &gt; +out:</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int __init imx_get_exec_base_from_dt(struct imx7_pm_base *base,</span>
<span class="quote">&gt; &gt; +				const char *compat)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct device_node *node;</span>
<span class="quote">&gt; &gt; +	struct resource res;</span>
<span class="quote">&gt; &gt; +	int ret = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="quote">&gt; &gt; +	if (!node) {</span>
<span class="quote">&gt; &gt; +		ret = -ENODEV;</span>
<span class="quote">&gt; &gt; +		goto out;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="quote">&gt; &gt; +	if (ret)</span>
<span class="quote">&gt; &gt; +		goto put_node;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	base-&gt;pbase = res.start;</span>
<span class="quote">&gt; &gt; +	base-&gt;vbase = __arm_ioremap_exec(res.start, resource_size(&amp;res),</span>
<span class="quote">&gt; &gt; +false);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!base-&gt;vbase)</span>
<span class="quote">&gt; &gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +put_node:</span>
<span class="quote">&gt; &gt; +	of_node_put(node);</span>
<span class="quote">&gt; &gt; +out:</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static const u32 imx7d_ddrc_ddr3_setting[][2] __initconst = {</span>
<span class="quote">&gt; &gt; +	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x1a0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x1a4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x1a8, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x64, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x490, 0x00000001 },</span>
<span class="quote">&gt; &gt; +	{ 0xd0, 0xc0020001 },</span>
<span class="quote">&gt; &gt; +	{ 0xd4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0xdc, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0xe0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0xe4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0xf4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x100, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x104, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x108, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x10c, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x110, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x114, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x120, 0x03030803 },</span>
<span class="quote">&gt; &gt; +	{ 0x180, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x190, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x194, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x200, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x204, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x214, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x218, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x240, 0x06000601 },</span>
<span class="quote">&gt; &gt; +	{ 0x244, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static const u32 imx7d_ddrc_phy_ddr3_setting[][2] __initconst = {</span>
<span class="quote">&gt; &gt; +	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x4, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x10, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x9c, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x20, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x30, READ_DATA_FROM_HARDWARE },</span>
<span class="quote">&gt; &gt; +	{ 0x50, 0x01000010 },</span>
<span class="quote">&gt; &gt; +	{ 0x50, 0x00000010 },</span>
<span class="quote">&gt; &gt; +	{ 0xc0, 0x0e407304 },</span>
<span class="quote">&gt; &gt; +	{ 0xc0, 0x0e447304 },</span>
<span class="quote">&gt; &gt; +	{ 0xc0, 0x0e447306 },</span>
<span class="quote">&gt; &gt; +	{ 0xc0, 0x0e447304 },</span>
<span class="quote">&gt; &gt; +	{ 0xc0, 0x0e407306 },</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static const struct imx7_pm_socdata imx7d_pm_data_ddr3 __initconst = {</span>
<span class="quote">&gt; &gt; +	.iomuxc_gpr_compat = &quot;fsl,imx7d-iomuxc&quot;,</span>
<span class="quote">&gt; &gt; +	.ddrc_phy_compat = &quot;fsl,imx7d-ddrc-phy&quot;,</span>
<span class="quote">&gt; &gt; +	.anatop_compat = &quot;fsl,imx7d-anatop&quot;,</span>
<span class="quote">&gt; &gt; +	.ddrc_compat = &quot;fsl,imx7d-ddrc&quot;,</span>
<span class="quote">&gt; &gt; +	.ccm_compat = &quot;fsl,imx7d-ccm&quot;,</span>
<span class="quote">&gt; &gt; +	.src_compat = &quot;fsl,imx7d-src&quot;,</span>
<span class="quote">&gt; &gt; +	.gpc_compat = &quot;fsl,imx7d-gpc&quot;,</span>
<span class="quote">&gt; &gt; +	.ddrc_phy_num = ARRAY_SIZE(imx7d_ddrc_phy_ddr3_setting),</span>
<span class="quote">&gt; &gt; +	.ddrc_phy_offset = imx7d_ddrc_phy_ddr3_setting,</span>
<span class="quote">&gt; &gt; +	.ddrc_num = ARRAY_SIZE(imx7d_ddrc_ddr3_setting),</span>
<span class="quote">&gt; &gt; +	.ddrc_offset = imx7d_ddrc_ddr3_setting, };</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int __init imx_gpcv2_suspend_init(struct imx_gpcv2_suspend *pm,</span>
<span class="quote">&gt; &gt; +			const struct imx7_pm_socdata *socdata) {</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base aips_base[3] = { {0, 0}, {0, 0}, {0, 0} };</span>
<span class="quote">&gt; &gt; +	struct imx7_pm_base sram_base = {0, 0};</span>
<span class="quote">&gt; &gt; +	struct imx7_cpu_pm_info *pm_info;</span>
<span class="quote">&gt; &gt; +	struct device_node *node;</span>
<span class="quote">&gt; &gt; +	int i, ret = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	const u32 (*ddrc_phy_offset_array)[2];</span>
<span class="quote">&gt; &gt; +	const u32 (*ddrc_offset_array)[2];</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!socdata || !pm) {</span>
<span class="quote">&gt; &gt; +		pr_warn(&quot;%s: invalid argument!\n&quot;, __func__);</span>
<span class="quote">&gt; &gt; +		return -EINVAL;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	node = NULL;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You can do the initialization on top.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; 3; i++) {</span>
<span class="quote">&gt; &gt; +		node = of_find_compatible_node(node, NULL, &quot;fsl,aips-bus&quot;);</span>
<span class="quote">&gt; &gt; +		if (!node) {</span>
<span class="quote">&gt; &gt; +			pr_warn(&quot;%s: failed to find aips %d node!\n&quot;,</span>
<span class="quote">&gt; &gt; +					__func__, i);</span>
<span class="quote">&gt; &gt; +			break;</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +		ret = imx_get_base_from_node(node, &amp;aips_base[i]);</span>
<span class="quote">&gt; &gt; +		if (ret) {</span>
<span class="quote">&gt; &gt; +			pr_warn(&quot;%s: failed to get aips[%d] base %d!\n&quot;,</span>
<span class="quote">&gt; &gt; +					__func__, i, ret);</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What are the aips_base used for? You would need to call of_node_put for each of</span>
<span class="quote">&gt; them.</span>

These addresses will be used in assemble codes.  
<span class="quote">
&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = imx_get_exec_base_from_dt(&amp;sram_base, &quot;fsl,lpm-sram&quot;);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		pr_warn(&quot;%s: failed to get lpm-sram base %d!\n&quot;,</span>
<span class="quote">&gt; &gt; +				__func__, ret);</span>
<span class="quote">&gt; &gt; +		goto lpm_sram_map_failed;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm_info = sram_base.vbase;</span>
<span class="quote">&gt; &gt; +	pm_info-&gt;pbase = sram_base.pbase;</span>
<span class="quote">&gt; &gt; +	pm_info-&gt;resume_addr = virt_to_phys(ca7_cpu_resume);</span>
<span class="quote">&gt; &gt; +	pm_info-&gt;pm_info_size = sizeof(*pm_info);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ccm_base,</span>
<span class="quote">&gt; socdata-&gt;ccm_compat);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		pr_warn(&quot;%s: failed to get ccm base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; &gt; +		goto ccm_map_failed;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_base,</span>
<span class="quote">&gt; socdata-&gt;ddrc_compat);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		pr_warn(&quot;%s: failed to get ddrc base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; &gt; +		goto ddrc_map_failed;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_phy_base,</span>
<span class="quote">&gt; &gt; +				socdata-&gt;ddrc_phy_compat);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		pr_warn(&quot;%s: failed to get ddrc_phy base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; &gt; +		goto ddrc_phy_map_failed;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;src_base, socdata-&gt;src_compat);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		pr_warn(&quot;%s: failed to get src base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; &gt; +		goto src_map_failed;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;iomuxc_gpr_base,</span>
<span class="quote">&gt; &gt; +				socdata-&gt;iomuxc_gpr_compat);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		pr_warn(&quot;%s: failed to get iomuxc_gpr base %d!\n&quot;,</span>
<span class="quote">&gt; &gt; +					__func__, ret);</span>
<span class="quote">&gt; &gt; +		goto iomuxc_gpr_map_failed;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;gpc_base, socdata-&gt;gpc_compat);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		pr_warn(&quot;%s: failed to get gpc base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; &gt; +		goto gpc_map_failed;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = imx_get_base_from_dt(&amp;pm_info-&gt;anatop_base,</span>
<span class="quote">&gt; &gt; +				socdata-&gt;anatop_compat);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		pr_warn(&quot;%s: failed to get anatop base %d!\n&quot;, __func__, ret);</span>
<span class="quote">&gt; &gt; +		goto anatop_map_failed;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm_info-&gt;ddrc_num = socdata-&gt;ddrc_num;</span>
<span class="quote">&gt; &gt; +	ddrc_offset_array = socdata-&gt;ddrc_offset;</span>
<span class="quote">&gt; &gt; +	pm_info-&gt;ddrc_phy_num = socdata-&gt;ddrc_phy_num;</span>
<span class="quote">&gt; &gt; +	ddrc_phy_offset_array = socdata-&gt;ddrc_phy_offset;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* initialize DDRC settings */</span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; pm_info-&gt;ddrc_num; i++) {</span>
<span class="quote">&gt; &gt; +		pm_info-&gt;ddrc_val[i][0] = ddrc_offset_array[i][0];</span>
<span class="quote">&gt; &gt; +		if (ddrc_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="quote">&gt; &gt; +			pm_info-&gt;ddrc_val[i][1] =</span>
<span class="quote">&gt; &gt; +				readl_relaxed(pm_info-&gt;ddrc_base.vbase +</span>
<span class="quote">&gt; &gt; +				ddrc_offset_array[i][0]);</span>
<span class="quote">&gt; &gt; +		else</span>
<span class="quote">&gt; &gt; +			pm_info-&gt;ddrc_val[i][1] = ddrc_offset_array[i][1];</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* initialize DDRC PHY settings */</span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; pm_info-&gt;ddrc_phy_num; i++) {</span>
<span class="quote">&gt; &gt; +		pm_info-&gt;ddrc_phy_val[i][0] =</span>
<span class="quote">&gt; &gt; +			ddrc_phy_offset_array[i][0];</span>
<span class="quote">&gt; &gt; +		if (ddrc_phy_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="quote">&gt; &gt; +			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="quote">&gt; &gt; +				readl_relaxed(pm_info-&gt;ddrc_phy_base.vbase +</span>
<span class="quote">&gt; &gt; +				ddrc_phy_offset_array[i][0]);</span>
<span class="quote">&gt; &gt; +		else</span>
<span class="quote">&gt; &gt; +			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="quote">&gt; &gt; +				ddrc_phy_offset_array[i][1];</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;suspend_fn_in_ocram = fncpy(</span>
<span class="quote">&gt; &gt; +		sram_base.vbase + sizeof(*pm_info),</span>
<span class="quote">&gt; &gt; +		&amp;imx7_suspend,</span>
<span class="quote">&gt; &gt; +		MX7_SUSPEND_OCRAM_SIZE - sizeof(*pm_info));</span>
<span class="quote">&gt; &gt; +	pm-&gt;ocram_vbase = sram_base.vbase;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	goto put_node;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +anatop_map_failed:</span>
<span class="quote">&gt; &gt; +	iounmap(pm_info-&gt;anatop_base.vbase);</span>
<span class="quote">&gt; &gt; +gpc_map_failed:</span>
<span class="quote">&gt; &gt; +	iounmap(pm_info-&gt;gpc_base.vbase);</span>
<span class="quote">&gt; &gt; +iomuxc_gpr_map_failed:</span>
<span class="quote">&gt; &gt; +	iounmap(pm_info-&gt;iomuxc_gpr_base.vbase);</span>
<span class="quote">&gt; &gt; +src_map_failed:</span>
<span class="quote">&gt; &gt; +	iounmap(pm_info-&gt;src_base.vbase);</span>
<span class="quote">&gt; &gt; +ddrc_phy_map_failed:</span>
<span class="quote">&gt; &gt; +	iounmap(pm_info-&gt;ddrc_phy_base.vbase);</span>
<span class="quote">&gt; &gt; +ddrc_map_failed:</span>
<span class="quote">&gt; &gt; +	iounmap(pm_info-&gt;ddrc_base.vbase);</span>
<span class="quote">&gt; &gt; +ccm_map_failed:</span>
<span class="quote">&gt; &gt; +	iounmap(pm_info-&gt;ccm_base.vbase);</span>
<span class="quote">&gt; &gt; +lpm_sram_map_failed:</span>
<span class="quote">&gt; &gt; +	iounmap(sram_base.vbase);</span>
<span class="quote">&gt; &gt; +put_node:</span>
<span class="quote">&gt; &gt; +	of_node_put(node);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static const struct platform_suspend_ops imx_gpcv2_pm_ops = {</span>
<span class="quote">&gt; &gt; +	.enter = imx_gpcv2_pm_enter,</span>
<span class="quote">&gt; &gt; +	.valid = imx_gpcv2_pm_valid,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int __init imx_gpcv2_pm_init(void) {</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_suspend *pm;</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2_irq *cd;</span>
<span class="quote">&gt; &gt; +	struct imx_gpcv2 *gpc;</span>
<span class="quote">&gt; &gt; +	int val;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm = kzalloc(sizeof(struct imx_gpcv2_suspend), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	gpc = kzalloc(sizeof(struct imx_gpcv2), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	cd = gpcv2_irq_instance;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!cd || !pm || !gpc) {</span>
<span class="quote">&gt; &gt; +		pr_debug(&quot;[GPCv2] %s init failed\r\n&quot;, __func__);</span>
<span class="quote">&gt; &gt; +		return 0;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This shortcut doesn&#39;t work, what if allocating pm succeeds and gpc does not?</span>

Any allocation failures here will cause the initialization to fail. I will have a better solution in new patch.
<span class="quote"> 
&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	imx_gpcv2_suspend_init(pm, &amp;imx7d_pm_data_ddr3);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_env_setup = imx_gpcv2_lpm_env_setup;</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_env_clean = imx_gpcv2_lpm_env_clean;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_cpu_power_gate = imx_gpcv2_lpm_cpu_power_gate;</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_plat_power_gate = imx_lpm_plat_power_gate;</span>
<span class="quote">&gt; &gt; +	pm-&gt;lpm_enable_core = imx_gpcv2_lpm_enable_core;</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_mode = imx_gpcv2_lpm_set_mode;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;clear_slots = imx_gpcv2_lpm_clear_slots;</span>
<span class="quote">&gt; &gt; +	pm-&gt;set_slot = imx_gpcv2_lpm_slot_setup;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pm-&gt;standby = imx_gpcv2_lpm_standby;</span>
<span class="quote">&gt; &gt; +	pm-&gt;suspend = imx_gpcv2_lpm_suspend;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pr_debug(&quot;[GPCv2] %s \r\n&quot;, __func__);</span>
<span class="quote">&gt; &gt; +	pm-&gt;anatop = syscon_regmap_lookup_by_compatible(&quot;fsl,imx6q-anatop&quot;);</span>
<span class="quote">&gt; &gt; +	WARN_ON(!pm-&gt;anatop);</span>
<span class="quote">&gt; &gt; +	pm-&gt;imx_src = syscon_regmap_lookup_by_compatible(&quot;fsl,imx7d-src&quot;);</span>
<span class="quote">&gt; &gt; +	WARN_ON(!pm-&gt;imx_src);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * Due to hardware design failure, need to make sure GPR</span>
<span class="quote">&gt; &gt; +	 * interrupt(#32) is unmasked during RUN mode to avoid entering</span>
<span class="quote">&gt; &gt; +	 * DSM by mistake.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	writel_relaxed(~0x1, cd-&gt;gpc_base + cd-&gt;cpu2wakeup);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* only external IRQs to wake up LPM and core 0/1 */</span>
<span class="quote">&gt; &gt; +	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="quote">&gt; &gt; +	val |= BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP;</span>
<span class="quote">&gt; &gt; +	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="quote">&gt; &gt; +	/* mask m4 dsm trigger */</span>
<span class="quote">&gt; &gt; +	writel_relaxed(readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_M4) |</span>
<span class="quote">&gt; &gt; +		BM_LPCR_M4_MASK_DSM_TRIGGER, cd-&gt;gpc_base +</span>
<span class="quote">&gt; GPC_LPCR_M4);</span>
<span class="quote">&gt; &gt; +	/* set mega/fast mix in A7 domain */</span>
<span class="quote">&gt; &gt; +	writel_relaxed(0x1, cd-&gt;gpc_base + GPC_PGC_CPU_MAPPING);</span>
<span class="quote">&gt; &gt; +	/* set SCU timing */</span>
<span class="quote">&gt; &gt; +	writel_relaxed((0x59 &lt;&lt; 10) | 0x5B | (0x51 &lt;&lt; 20),</span>
<span class="quote">&gt; &gt; +		cd-&gt;gpc_base + GPC_PGC_SCU_TIMING);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* Mask the wakeup sources in M/F power domain */</span>
<span class="quote">&gt; &gt; +	pm-&gt;mfmix_mask[0] = 0x54010000;</span>
<span class="quote">&gt; &gt; +	pm-&gt;mfmix_mask[1] = 0xc00;</span>
<span class="quote">&gt; &gt; +	pm-&gt;mfmix_mask[2] = 0x0;</span>
<span class="quote">&gt; &gt; +	pm-&gt;mfmix_mask[3] = 0x400010;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What is this doing?</span>

The IP blocks which may be the wakeup sources are allocated into several power domains. MFMIX is one
of those power domains. If a bit is &#39;1&#39;, it means the IP block is inside MFMIX power domain. We will use it
to decide if a power domain should be power gated or not.
<span class="quote">
&gt; I stop here for now, will have a look at the assembly part another time.</span>

Thank you very much for the excellent review!

Shenwei
<span class="quote">
&gt; --</span>
<span class="quote">&gt; Stefan</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">index 8ceda28..54f8553 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Kconfig</span>
<span class="p_chunk">@@ -562,6 +562,7 @@</span> <span class="p_context"> config SOC_IMX7D</span>
 	select ARM_GIC
 	select HAVE_IMX_ANATOP
 	select HAVE_IMX_MMDC
<span class="p_add">+	select IMX_GPCV2</span>
 	help
 		This enables support for Freescale i.MX7 Dual processor.
 
<span class="p_header">diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile</span>
<span class="p_header">index fb689d8..ca4c566 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Makefile</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Makefile</span>
<span class="p_chunk">@@ -88,6 +88,8 @@</span> <span class="p_context"> obj-$(CONFIG_SOC_IMX7D) += mach-imx7d.o</span>
 
 ifeq ($(CONFIG_SUSPEND),y)
 AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a
<span class="p_add">+AFLAGS_suspend-imx7.o :=-Wa,-march=armv7-a</span>
<span class="p_add">+obj-$(CONFIG_IMX_GPCV2)	+= suspend-imx7.o pm-imx7.o</span>
 obj-$(CONFIG_SOC_IMX6) += suspend-imx6.o
 obj-$(CONFIG_SOC_IMX53) += suspend-imx53.o
 endif
<span class="p_header">diff --git a/arch/arm/mach-imx/pm-imx7.c b/arch/arm/mach-imx/pm-imx7.c</span>
new file mode 100644
<span class="p_header">index 0000000..9035368</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="p_chunk">@@ -0,0 +1,901 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/mfd/syscon.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/regmap.h&gt;</span>
<span class="p_add">+#include &lt;linux/suspend.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;asm/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/fncpy.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;soc/imx/gpcv2.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_LPCR_A7_AD_L2PGE			0x10000</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C1_PUP			0x800</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C1_IRQ_PUP		0x400</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C0_PUP			0x200</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C0_IRQ_PUP		0x100</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_PLAT_PDN		0x10</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C1_PDN			0x8</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C1_WFI_PDN		0x4</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C0_PDN			0x2</span>
<span class="p_add">+#define BM_LPCR_A7_AD_EN_C0_WFI_PDN		0x1</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP	0x70000000</span>
<span class="p_add">+#define BM_LPCR_A7_BSC_CPU_CLK_ON_LPM		0x4000</span>
<span class="p_add">+#define BM_LPCR_A7_BSC_LPM1			0xc</span>
<span class="p_add">+#define BM_LPCR_A7_BSC_LPM0			0x3</span>
<span class="p_add">+#define BP_LPCR_A7_BSC_LPM1			2</span>
<span class="p_add">+#define BP_LPCR_A7_BSC_LPM0			0</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_LPCR_M4_MASK_DSM_TRIGGER		0x80000000</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_SLPCR_EN_DSM				0x80000000</span>
<span class="p_add">+#define BM_SLPCR_RBC_EN				0x40000000</span>
<span class="p_add">+#define BM_SLPCR_VSTBY				0x4</span>
<span class="p_add">+#define BM_SLPCR_SBYOS				0x2</span>
<span class="p_add">+#define BM_SLPCR_BYPASS_PMIC_READY		0x1</span>
<span class="p_add">+</span>
<span class="p_add">+#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP_ACK	0x80000000</span>
<span class="p_add">+#define BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN_ACK	0x8000</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_LPCR_A7_BSC		0x0</span>
<span class="p_add">+#define GPC_LPCR_A7_AD		0x4</span>
<span class="p_add">+#define GPC_LPCR_M4		0x8</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_PGC_CPU_MAPPING	0xec</span>
<span class="p_add">+#define GPC_PGC_SCU_TIMING	0x890</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_SLPCR		0x14</span>
<span class="p_add">+#define GPC_PGC_ACK_SEL_A7	0x24</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_SLOT0_CFG		0xb0</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_PGC_C0		0x800</span>
<span class="p_add">+#define GPC_PGC_SCU_TIMING	0x890</span>
<span class="p_add">+#define GPC_PGC_C1		0x840</span>
<span class="p_add">+#define GPC_PGC_SCU		0x880</span>
<span class="p_add">+#define GPC_PGC_FM		0xa00</span>
<span class="p_add">+</span>
<span class="p_add">+#define ANADIG_ARM_PLL		0x60</span>
<span class="p_add">+#define ANADIG_DDR_PLL		0x70</span>
<span class="p_add">+#define ANADIG_SYS_PLL		0xb0</span>
<span class="p_add">+#define ANADIG_ENET_PLL		0xe0</span>
<span class="p_add">+#define ANADIG_AUDIO_PLL	0xf0</span>
<span class="p_add">+#define ANADIG_VIDEO_PLL	0x130</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAX_SLOT_NUMBER		10</span>
<span class="p_add">+#define A7_LPM_WAIT		0x5</span>
<span class="p_add">+#define A7_LPM_STOP		0xa</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_SET			0x4</span>
<span class="p_add">+#define REG_CLR			0x8</span>
<span class="p_add">+</span>
<span class="p_add">+enum gpcv2_mode {</span>
<span class="p_add">+	WAIT_CLOCKED,</span>
<span class="p_add">+	WAIT_UNCLOCKED,</span>
<span class="p_add">+	WAIT_UNCLOCKED_POWER_OFF,</span>
<span class="p_add">+	STOP_POWER_ON,</span>
<span class="p_add">+	STOP_POWER_OFF,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* GPCv2 has the following power domains, and each domain can be power-up</span>
<span class="p_add">+ * and power-down via GPC settings.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * 	Core 0 of A7 power domain</span>
<span class="p_add">+ * 	Core1 of A7 power domain</span>
<span class="p_add">+ * 	SCU/L2 cache RAM of A7 power domain</span>
<span class="p_add">+ * 	Fastmix and megamix power domain</span>
<span class="p_add">+ * 	USB OTG1 PHY power domain</span>
<span class="p_add">+ * 	USB OTG2 PHY power domain</span>
<span class="p_add">+ * 	PCIE PHY power domain</span>
<span class="p_add">+ * 	USB HSIC PHY power domain</span>
<span class="p_add">+ *	Core 0 of M4 power domain</span>
<span class="p_add">+ */</span>
<span class="p_add">+enum gpcv2_slot {</span>
<span class="p_add">+	CORE0_A7,</span>
<span class="p_add">+	CORE1_A7,</span>
<span class="p_add">+	SCU_A7,</span>
<span class="p_add">+	FAST_MEGA_MIX,</span>
<span class="p_add">+	MIPI_PHY,</span>
<span class="p_add">+	PCIE_PHY,</span>
<span class="p_add">+	USB_OTG1_PHY,</span>
<span class="p_add">+	USB_OTG2_PHY,</span>
<span class="p_add">+	USB_HSIC_PHY,</span>
<span class="p_add">+	CORE0_M4,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx_gpcv2;</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx_gpcv2_suspend {</span>
<span class="p_add">+	struct regmap *anatop;</span>
<span class="p_add">+	struct regmap *imx_src;</span>
<span class="p_add">+	u32 mfmix_mask[IMR_NUM];</span>
<span class="p_add">+	u32 wakeupmix_mask[IMR_NUM];</span>
<span class="p_add">+	u32 lpsrmix_mask[IMR_NUM];</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*set_mode)(struct imx_gpcv2 *, enum gpcv2_mode mode);</span>
<span class="p_add">+	void (*lpm_cpu_power_gate)(struct imx_gpcv2 *, u32, bool);</span>
<span class="p_add">+	void (*lpm_plat_power_gate)(struct imx_gpcv2 *, bool);</span>
<span class="p_add">+	void (*lpm_env_setup)(struct imx_gpcv2 *);</span>
<span class="p_add">+	void (*lpm_env_clean)(struct imx_gpcv2 *);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*set_slot)(struct imx_gpcv2 *cd, u32 index,</span>
<span class="p_add">+			enum gpcv2_slot m_core, bool mode, bool ack);</span>
<span class="p_add">+	void (*clear_slots)(struct imx_gpcv2 *);</span>
<span class="p_add">+	void (*lpm_enable_core)(struct imx_gpcv2 *,</span>
<span class="p_add">+			bool enable, u32 offset);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*standby)(struct imx_gpcv2 *);</span>
<span class="p_add">+	void (*suspend)(struct imx_gpcv2 *);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*suspend_fn_in_ocram)(void __iomem *ocram_vbase);</span>
<span class="p_add">+	void __iomem *ocram_vbase;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx_gpcv2 {</span>
<span class="p_add">+	spinlock_t lock;</span>
<span class="p_add">+	struct imx_gpcv2_irq *irqchip;</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct imx_gpcv2_irq *gpcv2_irq_instance;</span>
<span class="p_add">+static struct imx_gpcv2 *gpcv2_instance;</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_clear_slots(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_SLOT_NUMBER; i++)</span>
<span class="p_add">+		writel_relaxed(0x0, cd-&gt;gpc_base + GPC_SLOT0_CFG + i * 0x4);</span>
<span class="p_add">+	writel_relaxed(BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP_ACK |</span>
<span class="p_add">+		BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN_ACK,</span>
<span class="p_add">+		cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_enable_core(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+			bool enable, u32 offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+	writel_relaxed(enable, cd-&gt;gpc_base + offset);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_slot_setup(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+		u32 index, enum gpcv2_slot m_core, bool mode, bool ack)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (index &gt;= MAX_SLOT_NUMBER)</span>
<span class="p_add">+		pr_err(&quot;Invalid slot index!\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+	/* set slot */</span>
<span class="p_add">+	writel_relaxed((mode + 1) &lt;&lt; (m_core * 2), cd-&gt;gpc_base +</span>
<span class="p_add">+		GPC_SLOT0_CFG + index * 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ack) {</span>
<span class="p_add">+		/* set ack */</span>
<span class="p_add">+		val = readl_relaxed(cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="p_add">+		/* clear dummy ack */</span>
<span class="p_add">+		val &amp;= ~(1 &lt;&lt; (15 + (mode ? 16 : 0)));</span>
<span class="p_add">+		val |= 1 &lt;&lt; (m_core + (mode ? 16 : 0));</span>
<span class="p_add">+		writel_relaxed(val, cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_env_setup(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PLL and PFDs overwrite set */</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_ARM_PLL + REG_SET, 1 &lt;&lt; 20);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_DDR_PLL + REG_SET, 1 &lt;&lt; 19);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_SYS_PLL + REG_SET, 0x1ff &lt;&lt; 17);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_ENET_PLL + REG_SET, 1 &lt;&lt; 13);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_AUDIO_PLL + REG_SET, 1 &lt;&lt; 24);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_VIDEO_PLL + REG_SET, 1 &lt;&lt; 24);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_env_clean(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PLL and PFDs overwrite clear */</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_ARM_PLL + REG_CLR, 1 &lt;&lt; 20);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_DDR_PLL + REG_CLR, 1 &lt;&lt; 19);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_SYS_PLL + REG_CLR, 0x1ff &lt;&lt; 17);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_ENET_PLL + REG_CLR, 1 &lt;&lt; 13);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_AUDIO_PLL + REG_CLR, 1 &lt;&lt; 24);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_VIDEO_PLL + REG_CLR, 1 &lt;&lt; 24);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_set_mode(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+		enum gpcv2_mode mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val1, val2;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	val1 = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="p_add">+	val2 = readl_relaxed(cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all cores&#39; LPM settings must be same */</span>
<span class="p_add">+	val1 &amp;= ~(BM_LPCR_A7_BSC_LPM0 | BM_LPCR_A7_BSC_LPM1);</span>
<span class="p_add">+</span>
<span class="p_add">+	val1 |= BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+</span>
<span class="p_add">+	val2 &amp;= ~(BM_SLPCR_EN_DSM | BM_SLPCR_VSTBY | BM_SLPCR_RBC_EN |</span>
<span class="p_add">+		BM_SLPCR_SBYOS | BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * GPCv2: When improper low-power sequence is used,</span>
<span class="p_add">+	 * the SoC enters low power mode before the ARM core executes WFI.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Software workaround:</span>
<span class="p_add">+	 * 1) Software should trigger IRQ #32 (IOMUX) to be always pending</span>
<span class="p_add">+	 *    by setting IOMUX_GPR1_IRQ.</span>
<span class="p_add">+	 * 2) Software should then unmask IRQ #32 in GPC before setting GPC</span>
<span class="p_add">+	 *    Low-Power mode.</span>
<span class="p_add">+	 * 3) Software should mask IRQ #32 right after GPC Low-Power mode</span>
<span class="p_add">+	 *    is set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	switch (mode) {</span>
<span class="p_add">+	case WAIT_CLOCKED:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case WAIT_UNCLOCKED:</span>
<span class="p_add">+		val1 |= A7_LPM_WAIT &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="p_add">+		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case STOP_POWER_ON:</span>
<span class="p_add">+		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="p_add">+		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="p_add">+		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case STOP_POWER_OFF:</span>
<span class="p_add">+		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="p_add">+		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="p_add">+		val2 |= BM_SLPCR_SBYOS;</span>
<span class="p_add">+		val2 |= BM_SLPCR_VSTBY;</span>
<span class="p_add">+		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	writel_relaxed(val1, cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="p_add">+	writel_relaxed(val2, cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_cpu_power_gate(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+				u32 cpu, bool pdn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	const u32 val_pdn[2] = {</span>
<span class="p_add">+		BM_LPCR_A7_AD_EN_C0_PDN | BM_LPCR_A7_AD_EN_C0_PUP,</span>
<span class="p_add">+		BM_LPCR_A7_AD_EN_C1_PDN | BM_LPCR_A7_AD_EN_C1_PUP,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	if (pdn)</span>
<span class="p_add">+		val |= val_pdn[cpu];</span>
<span class="p_add">+	else</span>
<span class="p_add">+		val &amp;= ~val_pdn[cpu];</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_lpm_plat_power_gate(struct imx_gpcv2 *gpc, bool pdn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	val &amp;= ~(BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE);</span>
<span class="p_add">+	if (pdn)</span>
<span class="p_add">+		val |= BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;gpc-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_standby(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_setup(gpc);</span>
<span class="p_add">+	/* pm-&gt;set_mode(gpc, STOP_POWER_OFF); */</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, WAIT_UNCLOCKED);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;[GPCv2] %s %d\r\n&quot;, __func__, __LINE__);</span>
<span class="p_add">+	/* Zzz ... */</span>
<span class="p_add">+	cpu_do_idle();</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, WAIT_CLOCKED);</span>
<span class="p_add">+	pm-&gt;lpm_env_clean(gpc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int gpcv2_suspend_finish(unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = (struct imx_gpcv2_suspend *)val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pm-&gt;suspend_fn_in_ocram) {</span>
<span class="p_add">+		cpu_do_idle();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * call low level suspend function in ocram,</span>
<span class="p_add">+		 * as we need to float DDR IO.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		local_flush_tlb_all();</span>
<span class="p_add">+		pm-&gt;suspend_fn_in_ocram(pm-&gt;ocram_vbase);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+static void imx_gpcv2_lpm_suspend(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_setup(gpc);</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, STOP_POWER_OFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable core0 power down/up with low power mode */</span>
<span class="p_add">+	pm-&gt;lpm_cpu_power_gate(gpc, 0, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable plat power down with low power mode */</span>
<span class="p_add">+	pm-&gt;lpm_plat_power_gate(gpc, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * To avoid confuse, we use slot 0~4 for power down,</span>
<span class="p_add">+	 * slot 5~9 for power up.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Power down slot sequence:</span>
<span class="p_add">+	 * Slot0 -&gt; CORE0</span>
<span class="p_add">+	 * Slot1 -&gt; Mega/Fast MIX</span>
<span class="p_add">+	 * Slot2 -&gt; SCU</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Power up slot sequence:</span>
<span class="p_add">+	 * Slot5 -&gt; Mega/Fast MIX</span>
<span class="p_add">+	 * Slot6 -&gt; SCU</span>
<span class="p_add">+	 * Slot7 -&gt; CORE0</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 0, CORE0_A7, false, false);</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 2, SCU_A7, false, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; IMR_NUM; i++) {</span>
<span class="p_add">+		if ((~cd-&gt;wakeup_sources[i] &amp; pm-&gt;mfmix_mask[i]) != 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		pm-&gt;set_slot(gpc, 1, FAST_MEGA_MIX, false, false);</span>
<span class="p_add">+		pm-&gt;set_slot(gpc, 5, FAST_MEGA_MIX, true, false);</span>
<span class="p_add">+		pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_FM);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 6, SCU_A7, true, false);</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 7, CORE0_A7, true, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable core0, scu */</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_C0);</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_SCU);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Suspend to MEM has not been implemented yet */</span>
<span class="p_add">+	cpu_suspend((unsigned long)pm, gpcv2_suspend_finish);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_clean(gpc);</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, WAIT_CLOCKED);</span>
<span class="p_add">+	pm-&gt;lpm_cpu_power_gate(gpc, 0, false);</span>
<span class="p_add">+	pm-&gt;lpm_plat_power_gate(gpc, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_C0);</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_SCU);</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_FM);</span>
<span class="p_add">+	pm-&gt;clear_slots(gpc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int imx_gpcv2_pm_enter(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!gpcv2_instance);</span>
<span class="p_add">+	pm = gpcv2_instance-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (state) {</span>
<span class="p_add">+	case PM_SUSPEND_STANDBY:</span>
<span class="p_add">+		pm-&gt;standby(gpcv2_instance);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case PM_SUSPEND_MEM:</span>
<span class="p_add">+		pm-&gt;suspend(gpcv2_instance);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int imx_gpcv2_pm_valid(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define MX7_MAX_DDRC_NUM		32</span>
<span class="p_add">+#define MX7_MAX_DDRC_PHY_NUM		16</span>
<span class="p_add">+</span>
<span class="p_add">+#define READ_DATA_FROM_HARDWARE		0</span>
<span class="p_add">+#define MX7_SUSPEND_OCRAM_SIZE		0x1000</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx7_pm_base {</span>
<span class="p_add">+	phys_addr_t pbase;</span>
<span class="p_add">+	void __iomem *vbase;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx7_pm_socdata {</span>
<span class="p_add">+	u32 ddr_type;</span>
<span class="p_add">+	const char *ddrc_compat;</span>
<span class="p_add">+	const char *ddrc_phy_compat;</span>
<span class="p_add">+	const char *src_compat;</span>
<span class="p_add">+	const char *iomuxc_gpr_compat;</span>
<span class="p_add">+	const char *ccm_compat;</span>
<span class="p_add">+	const char *gpc_compat;</span>
<span class="p_add">+	const char *anatop_compat;</span>
<span class="p_add">+	const u32 ddrc_num;</span>
<span class="p_add">+	const u32 (*ddrc_offset)[2];</span>
<span class="p_add">+	const u32 ddrc_phy_num;</span>
<span class="p_add">+	const u32 (*ddrc_phy_offset)[2];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This structure is for passing necessary data for low level ocram</span>
<span class="p_add">+ * suspend code(arch/arm/mach-imx/suspend-imx7.S), if this struct</span>
<span class="p_add">+ * definition is changed, the offset definition in</span>
<span class="p_add">+ * arch/arm/mach-imx/suspend-imx7.S must be also changed accordingly,</span>
<span class="p_add">+ * otherwise, the suspend to ocram function will be broken!</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct imx7_cpu_pm_info {</span>
<span class="p_add">+	u32 m4_reserve0;</span>
<span class="p_add">+	u32 m4_reserve1;</span>
<span class="p_add">+	u32 m4_reserve2;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The physical address of pm_info. */</span>
<span class="p_add">+	phys_addr_t pbase;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The physical resume address for asm code */</span>
<span class="p_add">+	phys_addr_t resume_addr;</span>
<span class="p_add">+	u32 ddr_type;</span>
<span class="p_add">+</span>
<span class="p_add">+	u32 pm_info_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct imx7_pm_base ddrc_base;</span>
<span class="p_add">+	struct imx7_pm_base ddrc_phy_base;</span>
<span class="p_add">+	struct imx7_pm_base src_base;</span>
<span class="p_add">+	struct imx7_pm_base iomuxc_gpr_base;</span>
<span class="p_add">+	struct imx7_pm_base ccm_base;</span>
<span class="p_add">+	struct imx7_pm_base gpc_base;</span>
<span class="p_add">+	struct imx7_pm_base l2_base;</span>
<span class="p_add">+	struct imx7_pm_base anatop_base;</span>
<span class="p_add">+</span>
<span class="p_add">+	u32 ttbr1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Number of DDRC which need saved/restored. */</span>
<span class="p_add">+	u32 ddrc_num;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* To save offset and value */</span>
<span class="p_add">+	u32 ddrc_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Number of DDRC which need saved/restored. */</span>
<span class="p_add">+	u32 ddrc_phy_num;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* To save offset and value */</span>
<span class="p_add">+	u32 ddrc_phy_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="p_add">+} __aligned(8);</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_base_from_node(struct device_node *node,</span>
<span class="p_add">+			struct imx7_pm_base *base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="p_add">+	if (!base-&gt;vbase) {</span>
<span class="p_add">+		iounmap(base-&gt;vbase);</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_base_from_dt(struct imx7_pm_base *base,</span>
<span class="p_add">+				const char *compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="p_add">+	if (!base-&gt;vbase)</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_exec_base_from_dt(struct imx7_pm_base *base,</span>
<span class="p_add">+				const char *compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = __arm_ioremap_exec(res.start, resource_size(&amp;res), false);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!base-&gt;vbase)</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 imx7d_ddrc_ddr3_setting[][2] __initconst = {</span>
<span class="p_add">+	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a8, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x64, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x490, 0x00000001 },</span>
<span class="p_add">+	{ 0xd0, 0xc0020001 },</span>
<span class="p_add">+	{ 0xd4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xdc, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xe0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xe4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xf4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x100, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x104, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x108, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x10c, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x110, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x114, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x120, 0x03030803 },</span>
<span class="p_add">+	{ 0x180, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x190, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x194, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x200, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x204, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x214, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x218, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x240, 0x06000601 },</span>
<span class="p_add">+	{ 0x244, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 imx7d_ddrc_phy_ddr3_setting[][2] __initconst = {</span>
<span class="p_add">+	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x10, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x9c, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x20, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x30, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x50, 0x01000010 },</span>
<span class="p_add">+	{ 0x50, 0x00000010 },</span>
<span class="p_add">+	{ 0xc0, 0x0e407304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447306 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e407306 },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct imx7_pm_socdata imx7d_pm_data_ddr3 __initconst = {</span>
<span class="p_add">+	.iomuxc_gpr_compat = &quot;fsl,imx7d-iomuxc&quot;,</span>
<span class="p_add">+	.ddrc_phy_compat = &quot;fsl,imx7d-ddrc-phy&quot;,</span>
<span class="p_add">+	.anatop_compat = &quot;fsl,imx7d-anatop&quot;,</span>
<span class="p_add">+	.ddrc_compat = &quot;fsl,imx7d-ddrc&quot;,</span>
<span class="p_add">+	.ccm_compat = &quot;fsl,imx7d-ccm&quot;,</span>
<span class="p_add">+	.src_compat = &quot;fsl,imx7d-src&quot;,</span>
<span class="p_add">+	.gpc_compat = &quot;fsl,imx7d-gpc&quot;,</span>
<span class="p_add">+	.ddrc_phy_num = ARRAY_SIZE(imx7d_ddrc_phy_ddr3_setting),</span>
<span class="p_add">+	.ddrc_phy_offset = imx7d_ddrc_phy_ddr3_setting,</span>
<span class="p_add">+	.ddrc_num = ARRAY_SIZE(imx7d_ddrc_ddr3_setting),</span>
<span class="p_add">+	.ddrc_offset = imx7d_ddrc_ddr3_setting,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_gpcv2_suspend_init(struct imx_gpcv2_suspend *pm,</span>
<span class="p_add">+			const struct imx7_pm_socdata *socdata)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx7_pm_base aips_base[3] = { {0, 0}, {0, 0}, {0, 0} };</span>
<span class="p_add">+	struct imx7_pm_base sram_base = {0, 0};</span>
<span class="p_add">+	struct imx7_cpu_pm_info *pm_info;</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	int i, ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	const u32 (*ddrc_phy_offset_array)[2];</span>
<span class="p_add">+	const u32 (*ddrc_offset_array)[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!socdata || !pm) {</span>
<span class="p_add">+		pr_warn(&quot;%s: invalid argument!\n&quot;, __func__);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	node = NULL;</span>
<span class="p_add">+	for (i = 0; i &lt; 3; i++) {</span>
<span class="p_add">+		node = of_find_compatible_node(node, NULL, &quot;fsl,aips-bus&quot;);</span>
<span class="p_add">+		if (!node) {</span>
<span class="p_add">+			pr_warn(&quot;%s: failed to find aips %d node!\n&quot;,</span>
<span class="p_add">+					__func__, i);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ret = imx_get_base_from_node(node, &amp;aips_base[i]);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			pr_warn(&quot;%s: failed to get aips[%d] base %d!\n&quot;,</span>
<span class="p_add">+					__func__, i, ret);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_exec_base_from_dt(&amp;sram_base, &quot;fsl,lpm-sram&quot;);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get lpm-sram base %d!\n&quot;,</span>
<span class="p_add">+				__func__, ret);</span>
<span class="p_add">+		goto lpm_sram_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info = sram_base.vbase;</span>
<span class="p_add">+	pm_info-&gt;pbase = sram_base.pbase;</span>
<span class="p_add">+	pm_info-&gt;resume_addr = virt_to_phys(ca7_cpu_resume);</span>
<span class="p_add">+	pm_info-&gt;pm_info_size = sizeof(*pm_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ccm_base, socdata-&gt;ccm_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ccm base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ccm_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_base, socdata-&gt;ddrc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ddrc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ddrc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_phy_base,</span>
<span class="p_add">+				socdata-&gt;ddrc_phy_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ddrc_phy base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ddrc_phy_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;src_base, socdata-&gt;src_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get src base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto src_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;iomuxc_gpr_base,</span>
<span class="p_add">+				socdata-&gt;iomuxc_gpr_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get iomuxc_gpr base %d!\n&quot;,</span>
<span class="p_add">+					__func__, ret);</span>
<span class="p_add">+		goto iomuxc_gpr_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;gpc_base, socdata-&gt;gpc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get gpc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto gpc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;anatop_base,</span>
<span class="p_add">+				socdata-&gt;anatop_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get anatop base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto anatop_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info-&gt;ddrc_num = socdata-&gt;ddrc_num;</span>
<span class="p_add">+	ddrc_offset_array = socdata-&gt;ddrc_offset;</span>
<span class="p_add">+	pm_info-&gt;ddrc_phy_num = socdata-&gt;ddrc_phy_num;</span>
<span class="p_add">+	ddrc_phy_offset_array = socdata-&gt;ddrc_phy_offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* initialize DDRC settings */</span>
<span class="p_add">+	for (i = 0; i &lt; pm_info-&gt;ddrc_num; i++) {</span>
<span class="p_add">+		pm_info-&gt;ddrc_val[i][0] = ddrc_offset_array[i][0];</span>
<span class="p_add">+		if (ddrc_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="p_add">+			pm_info-&gt;ddrc_val[i][1] =</span>
<span class="p_add">+				readl_relaxed(pm_info-&gt;ddrc_base.vbase +</span>
<span class="p_add">+				ddrc_offset_array[i][0]);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pm_info-&gt;ddrc_val[i][1] = ddrc_offset_array[i][1];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* initialize DDRC PHY settings */</span>
<span class="p_add">+	for (i = 0; i &lt; pm_info-&gt;ddrc_phy_num; i++) {</span>
<span class="p_add">+		pm_info-&gt;ddrc_phy_val[i][0] =</span>
<span class="p_add">+			ddrc_phy_offset_array[i][0];</span>
<span class="p_add">+		if (ddrc_phy_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="p_add">+			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="p_add">+				readl_relaxed(pm_info-&gt;ddrc_phy_base.vbase +</span>
<span class="p_add">+				ddrc_phy_offset_array[i][0]);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="p_add">+				ddrc_phy_offset_array[i][1];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;suspend_fn_in_ocram = fncpy(</span>
<span class="p_add">+		sram_base.vbase + sizeof(*pm_info),</span>
<span class="p_add">+		&amp;imx7_suspend,</span>
<span class="p_add">+		MX7_SUSPEND_OCRAM_SIZE - sizeof(*pm_info));</span>
<span class="p_add">+	pm-&gt;ocram_vbase = sram_base.vbase;</span>
<span class="p_add">+</span>
<span class="p_add">+	goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+anatop_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;anatop_base.vbase);</span>
<span class="p_add">+gpc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;gpc_base.vbase);</span>
<span class="p_add">+iomuxc_gpr_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;iomuxc_gpr_base.vbase);</span>
<span class="p_add">+src_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;src_base.vbase);</span>
<span class="p_add">+ddrc_phy_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ddrc_phy_base.vbase);</span>
<span class="p_add">+ddrc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ddrc_base.vbase);</span>
<span class="p_add">+ccm_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ccm_base.vbase);</span>
<span class="p_add">+lpm_sram_map_failed:</span>
<span class="p_add">+	iounmap(sram_base.vbase);</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct platform_suspend_ops imx_gpcv2_pm_ops = {</span>
<span class="p_add">+	.enter = imx_gpcv2_pm_enter,</span>
<span class="p_add">+	.valid = imx_gpcv2_pm_valid,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_gpcv2_pm_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm;</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd;</span>
<span class="p_add">+	struct imx_gpcv2 *gpc;</span>
<span class="p_add">+	int val;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm = kzalloc(sizeof(struct imx_gpcv2_suspend), GFP_KERNEL);</span>
<span class="p_add">+	gpc = kzalloc(sizeof(struct imx_gpcv2), GFP_KERNEL);</span>
<span class="p_add">+	cd = gpcv2_irq_instance;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cd || !pm || !gpc) {</span>
<span class="p_add">+		pr_debug(&quot;[GPCv2] %s init failed\r\n&quot;, __func__);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	imx_gpcv2_suspend_init(pm, &amp;imx7d_pm_data_ddr3);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_setup = imx_gpcv2_lpm_env_setup;</span>
<span class="p_add">+	pm-&gt;lpm_env_clean = imx_gpcv2_lpm_env_clean;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_cpu_power_gate = imx_gpcv2_lpm_cpu_power_gate;</span>
<span class="p_add">+	pm-&gt;lpm_plat_power_gate = imx_lpm_plat_power_gate;</span>
<span class="p_add">+	pm-&gt;lpm_enable_core = imx_gpcv2_lpm_enable_core;</span>
<span class="p_add">+	pm-&gt;set_mode = imx_gpcv2_lpm_set_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;clear_slots = imx_gpcv2_lpm_clear_slots;</span>
<span class="p_add">+	pm-&gt;set_slot = imx_gpcv2_lpm_slot_setup;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;standby = imx_gpcv2_lpm_standby;</span>
<span class="p_add">+	pm-&gt;suspend = imx_gpcv2_lpm_suspend;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;[GPCv2] %s \r\n&quot;, __func__);</span>
<span class="p_add">+	pm-&gt;anatop = syscon_regmap_lookup_by_compatible(&quot;fsl,imx6q-anatop&quot;);</span>
<span class="p_add">+	WARN_ON(!pm-&gt;anatop);</span>
<span class="p_add">+	pm-&gt;imx_src = syscon_regmap_lookup_by_compatible(&quot;fsl,imx7d-src&quot;);</span>
<span class="p_add">+	WARN_ON(!pm-&gt;imx_src);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Due to hardware design failure, need to make sure GPR</span>
<span class="p_add">+	 * interrupt(#32) is unmasked during RUN mode to avoid entering</span>
<span class="p_add">+	 * DSM by mistake.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	writel_relaxed(~0x1, cd-&gt;gpc_base + cd-&gt;cpu2wakeup);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* only external IRQs to wake up LPM and core 0/1 */</span>
<span class="p_add">+	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="p_add">+	val |= BM_LPCR_A7_BSC_IRQ_SRC_A7_WAKEUP;</span>
<span class="p_add">+	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="p_add">+	/* mask m4 dsm trigger */</span>
<span class="p_add">+	writel_relaxed(readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_M4) |</span>
<span class="p_add">+		BM_LPCR_M4_MASK_DSM_TRIGGER, cd-&gt;gpc_base + GPC_LPCR_M4);</span>
<span class="p_add">+	/* set mega/fast mix in A7 domain */</span>
<span class="p_add">+	writel_relaxed(0x1, cd-&gt;gpc_base + GPC_PGC_CPU_MAPPING);</span>
<span class="p_add">+	/* set SCU timing */</span>
<span class="p_add">+	writel_relaxed((0x59 &lt;&lt; 10) | 0x5B | (0x51 &lt;&lt; 20),</span>
<span class="p_add">+		cd-&gt;gpc_base + GPC_PGC_SCU_TIMING);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Mask the wakeup sources in M/F power domain */</span>
<span class="p_add">+	pm-&gt;mfmix_mask[0] = 0x54010000;</span>
<span class="p_add">+	pm-&gt;mfmix_mask[1] = 0xc00;</span>
<span class="p_add">+	pm-&gt;mfmix_mask[2] = 0x0;</span>
<span class="p_add">+	pm-&gt;mfmix_mask[3] = 0x400010;</span>
<span class="p_add">+</span>
<span class="p_add">+	gpc-&gt;pm = pm;</span>
<span class="p_add">+	gpc-&gt;irqchip = cd;</span>
<span class="p_add">+	gpcv2_instance = gpc;</span>
<span class="p_add">+</span>
<span class="p_add">+	suspend_set_ops(&amp;imx_gpcv2_pm_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+device_initcall(imx_gpcv2_pm_init);</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/arm/mach-imx/suspend-imx7.S b/arch/arm/mach-imx/suspend-imx7.S</span>
new file mode 100644
<span class="p_header">index 0000000..8c3f516</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/suspend-imx7.S</span>
<span class="p_chunk">@@ -0,0 +1,529 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The code contained herein is licensed under the GNU General Public</span>
<span class="p_add">+ * License. You may obtain a copy of the GNU General Public License</span>
<span class="p_add">+ * Version 2 or later at the following locations:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * http://www.opensource.org/licenses/gpl-license.html</span>
<span class="p_add">+ * http://www.gnu.org/copyleft/gpl.html</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &quot;hardware.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ==================== low level suspend ====================</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Better to follow below rules to use ARM registers:</span>
<span class="p_add">+ * r0: pm_info structure address;</span>
<span class="p_add">+ * r1 ~ r4: for saving pm_info members;</span>
<span class="p_add">+ * r5 ~ r10: free registers;</span>
<span class="p_add">+ * r11: io base address.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * suspend ocram space layout:</span>
<span class="p_add">+ * ======================== high address ======================</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                      imx7_suspend code</span>
<span class="p_add">+ *              PM_INFO structure(imx7_cpu_pm_info)</span>
<span class="p_add">+ * ======================== low address =======================</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Below offsets are based on struct imx7_cpu_pm_info</span>
<span class="p_add">+ * which defined in arch/arm/mach-imx/pm-imx7.c, this</span>
<span class="p_add">+ * structure contains necessary pm info for low level</span>
<span class="p_add">+ * suspend related code.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE0_OFFSET		0x0</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE1_OFFSET		0x4</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE2_OFFSET		0x8</span>
<span class="p_add">+#define PM_INFO_PBASE_OFFSET			0xc</span>
<span class="p_add">+#define PM_INFO_RESUME_ADDR_OFFSET		0x10</span>
<span class="p_add">+#define PM_INFO_DDR_TYPE_OFFSET			0x14</span>
<span class="p_add">+#define PM_INFO_PM_INFO_SIZE_OFFSET		0x18</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_P_OFFSET		0x1c</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_V_OFFSET		0x20</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_PHY_P_OFFSET		0x24</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_PHY_V_OFFSET		0x28</span>
<span class="p_add">+#define PM_INFO_MX7_SRC_P_OFFSET		0x2c</span>
<span class="p_add">+#define PM_INFO_MX7_SRC_V_OFFSET		0x30</span>
<span class="p_add">+#define PM_INFO_MX7_IOMUXC_GPR_P_OFFSET		0x34</span>
<span class="p_add">+#define PM_INFO_MX7_IOMUXC_GPR_V_OFFSET		0x38</span>
<span class="p_add">+#define PM_INFO_MX7_CCM_P_OFFSET		0x3c</span>
<span class="p_add">+#define PM_INFO_MX7_CCM_V_OFFSET		0x40</span>
<span class="p_add">+#define PM_INFO_MX7_GPC_P_OFFSET		0x44</span>
<span class="p_add">+#define PM_INFO_MX7_GPC_V_OFFSET		0x48</span>
<span class="p_add">+#define PM_INFO_MX7_L2_P_OFFSET			0x4c</span>
<span class="p_add">+#define PM_INFO_MX7_L2_V_OFFSET			0x50</span>
<span class="p_add">+#define PM_INFO_MX7_ANATOP_P_OFFSET		0x54</span>
<span class="p_add">+#define PM_INFO_MX7_ANATOP_V_OFFSET		0x58</span>
<span class="p_add">+#define PM_INFO_MX7_TTBR1_V_OFFSET		0x5c</span>
<span class="p_add">+#define PM_INFO_DDRC_REG_NUM_OFFSET		0x60</span>
<span class="p_add">+#define PM_INFO_DDRC_REG_OFFSET			0x64</span>
<span class="p_add">+#define PM_INFO_DDRC_VALUE_OFFSET		0x68</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_REG_NUM_OFFSET		0x164</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_REG_OFFSET		0x168</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_VALUE_OFFSET		0x16c</span>
<span class="p_add">+</span>
<span class="p_add">+#define MX7_SRC_GPR1	0x74</span>
<span class="p_add">+#define MX7_SRC_GPR2	0x78</span>
<span class="p_add">+#define GPC_PGC_FM	0xa00</span>
<span class="p_add">+#define ANADIG_SNVS_MISC_CTRL	0x380</span>
<span class="p_add">+#define DDRC_STAT	0x4</span>
<span class="p_add">+#define DDRC_PWRCTL	0x30</span>
<span class="p_add">+#define DDRC_PSTAT	0x3fc</span>
<span class="p_add">+#define DDRC_PCTRL_0	0x490</span>
<span class="p_add">+#define DDRC_DFIMISC	0x1b0</span>
<span class="p_add">+#define DDRC_SWCTL	0x320</span>
<span class="p_add">+#define DDRC_SWSTAT	0x324</span>
<span class="p_add">+#define DDRPHY_LP_CON0	0x18</span>
<span class="p_add">+</span>
<span class="p_add">+	.align 3</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	disable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Flush all data from the L1 data cache before disabling</span>
<span class="p_add">+	 * SCTLR.C bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	push	{r0 - r10, lr}</span>
<span class="p_add">+	ldr	r7, =v7_flush_dcache_all</span>
<span class="p_add">+	mov	lr, pc</span>
<span class="p_add">+	mov	pc, r7</span>
<span class="p_add">+	pop	{r0 - r10, lr}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable d-cache */</span>
<span class="p_add">+	mrc	p15, 0, r7, c1, c0, 0</span>
<span class="p_add">+	bic	r7, r7, #(1 &lt;&lt; 2)</span>
<span class="p_add">+	mcr	p15, 0, r7, c1, c0, 0</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	push	{r0 - r10, lr}</span>
<span class="p_add">+	ldr	r7, =v7_flush_dcache_all</span>
<span class="p_add">+	mov	lr, pc</span>
<span class="p_add">+	mov	pc, r7</span>
<span class="p_add">+	pop	{r0 - r10, lr}</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro enable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable L1 data cache. */</span>
<span class="p_add">+	mrc	p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+	orr	r6, r6, #0x4</span>
<span class="p_add">+	mcr	p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddrc_enter_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait rw port_busy clear */</span>
<span class="p_add">+	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="p_add">+	orr	r6, r6, #0x1</span>
<span class="p_add">+1:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="p_add">+	ands	r7, r7, r6</span>
<span class="p_add">+	bne	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enter self-refresh bit 5 */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+2:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	2b</span>
<span class="p_add">+3:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	ands	r7, r7, #0x20</span>
<span class="p_add">+	beq	3b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable dram clk */</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddrc_exit_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	ldreq	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r11, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+4:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	beq	4b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable auto self-refresh */</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 0)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro wait_delay</span>
<span class="p_add">+5:</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	5b</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddr_enter_retention</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PCTRL_0]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait rw port_busy clear */</span>
<span class="p_add">+	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="p_add">+	orr	r6, r6, #0x1</span>
<span class="p_add">+6:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="p_add">+	ands	r7, r7, r6</span>
<span class="p_add">+	bne	6b</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	/* enter self-refresh bit 5 */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+7:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	7b</span>
<span class="p_add">+8:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	ands	r7, r7, #0x20</span>
<span class="p_add">+	beq	8b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable dram clk */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* reset ddr_phy  */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* delay 7 us */</span>
<span class="p_add">+	ldr	r6, =6000</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r11, r6]</span>
<span class="p_add">+	orr	r7, r7, #0x1</span>
<span class="p_add">+	str	r7, [r11, r6]</span>
<span class="p_add">+	/* turn off ddr power */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="p_add">+	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddr_exit_retention</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	ldreq	r1, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldrne	r1, [r0, #PM_INFO_MX7_ANATOP_P_OFFSET]</span>
<span class="p_add">+	ldreq	r2, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r2, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="p_add">+	ldreq	r3, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r3, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="p_add">+	ldreq	r4, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="p_add">+	ldrne	r4, [r0, #PM_INFO_MX7_DDRC_PHY_P_OFFSET]</span>
<span class="p_add">+	ldreq	r10, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="p_add">+	ldrne	r10, [r0, #PM_INFO_MX7_CCM_P_OFFSET]</span>
<span class="p_add">+	ldreq	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldrne	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* turn on ddr power */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, =50</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear ddr_phy reset */</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	orr	r7, r7, #0x3</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	bic	r7, r7, #0x1</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_DDRC_REG_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_DDRC_REG_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+9:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r3, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	9b</span>
<span class="p_add">+	ldr	r7, =0x20</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* do PHY, clear ddr_phy reset */</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	bic	r7, r7, #0x2</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 30)</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* need to delay ~5mS */</span>
<span class="p_add">+	ldr	r6, =0x100000</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_DDRC_PHY_REG_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_DDRC_PHY_REG_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+</span>
<span class="p_add">+10:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r4, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	10b</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	add	r9, r10, #0x4000</span>
<span class="p_add">+	str	r7, [r9, #0x130]</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	beq	101f</span>
<span class="p_add">+	ldr	r7, =0x170</span>
<span class="p_add">+	orr	r7, r7, #0x8</span>
<span class="p_add">+	str	r7, [r11, #0x20]</span>
<span class="p_add">+</span>
<span class="p_add">+101:</span>
<span class="p_add">+	ldr	r7, =0x2</span>
<span class="p_add">+	add	r9, r10, #0x4000</span>
<span class="p_add">+	str	r7, [r9, #0x130]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0xf</span>
<span class="p_add">+	str	r7, [r4, #DDRPHY_LP_CON0]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+11:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	11b</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="p_add">+12:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_SWSTAT]</span>
<span class="p_add">+	and	r7, r7, #0x1</span>
<span class="p_add">+	cmp	r7, #0x1</span>
<span class="p_add">+	bne	12b</span>
<span class="p_add">+13:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x20</span>
<span class="p_add">+	cmp	r7, #0x20</span>
<span class="p_add">+	bne	13b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="p_add">+14:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x30</span>
<span class="p_add">+	cmp	r7, #0x0</span>
<span class="p_add">+	bne	14b</span>
<span class="p_add">+</span>
<span class="p_add">+15:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x1</span>
<span class="p_add">+	bne	15b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable port */</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PCTRL_0]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(imx7_suspend)</span>
<span class="p_add">+	push	{r4-r12}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The value of r0 is mapped the same in origin table and IRAM table,</span>
<span class="p_add">+	 * thus no need to care r0 here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r1, [r0, #PM_INFO_PBASE_OFFSET]</span>
<span class="p_add">+	ldr	r2, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+	ldr	r3, [r0, #PM_INFO_DDR_TYPE_OFFSET]</span>
<span class="p_add">+	ldr	r4, [r0, #PM_INFO_PM_INFO_SIZE_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * counting the resume address in iram</span>
<span class="p_add">+	 * to set it in SRC register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r6, =imx7_suspend</span>
<span class="p_add">+	ldr	r7, =resume</span>
<span class="p_add">+	sub	r7, r7, r6</span>
<span class="p_add">+	add	r8, r1, r4</span>
<span class="p_add">+	add	r9, r8, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	/* store physical resume addr and pm_info address. */</span>
<span class="p_add">+	str	r9, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r1, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	disable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * make sure TLB contain the addr we want,</span>
<span class="p_add">+	 * as we will access them after DDR is in</span>
<span class="p_add">+	 * self-refresh mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r0, #0x0]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="p_add">+	add	r6, #0x4000</span>
<span class="p_add">+	ldr	r7, [r6]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	add	r6, #0x1000</span>
<span class="p_add">+	ldr	r7, [r6]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	ldr	r7, [r6, #0x490]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	ddr_only_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_enter_retention</span>
<span class="p_add">+	b	ddr_retention_enter_out</span>
<span class="p_add">+ddr_only_self_refresh:</span>
<span class="p_add">+	ddrc_enter_self_refresh</span>
<span class="p_add">+ddr_retention_enter_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Zzz, enter stop mode */</span>
<span class="p_add">+	wfi</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	r5, #0x0</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	wfi_ddr_self_refresh_out</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_exit_retention</span>
<span class="p_add">+	b	wfi_ddr_retention_out</span>
<span class="p_add">+wfi_ddr_self_refresh_out:</span>
<span class="p_add">+	ddrc_exit_self_refresh</span>
<span class="p_add">+wfi_ddr_retention_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =0x170</span>
<span class="p_add">+	orr	r7, r7, #0x8</span>
<span class="p_add">+	str	r7, [r11, #0x20]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear core0&#39;s entry and parameter */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	mov	r7, #0x0</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	enable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	pop	{r4-r12}</span>
<span class="p_add">+	/* return to suspend finish */</span>
<span class="p_add">+	mov	pc, lr</span>
<span class="p_add">+</span>
<span class="p_add">+resume:</span>
<span class="p_add">+	/* invalidate L1 I-cache first */</span>
<span class="p_add">+	mov     r6, #0x0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 6</span>
<span class="p_add">+	/* enable the Icache and branch prediction */</span>
<span class="p_add">+	mov     r6, #0x1800</span>
<span class="p_add">+	mcr     p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get physical resume address from pm_info. */</span>
<span class="p_add">+	ldr	lr, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+	/* clear core0&#39;s entry and parameter */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="p_add">+	mov	r7, #0x0</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	r5, #0x1</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_P_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	dsm_ddr_self_refresh_out</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_exit_retention</span>
<span class="p_add">+	b	dsm_ddr_retention_out</span>
<span class="p_add">+dsm_ddr_self_refresh_out:</span>
<span class="p_add">+	ddrc_exit_self_refresh</span>
<span class="p_add">+dsm_ddr_retention_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	pc, lr</span>
<span class="p_add">+ENDPROC(imx7_suspend)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ca7_cpu_resume)</span>
<span class="p_add">+	bl	v7_invalidate_l1</span>
<span class="p_add">+	b	cpu_resume</span>
<span class="p_add">+ENDPROC(ca7_cpu_resume)</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



