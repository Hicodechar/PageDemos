
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.111 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.111</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 10, 2018, 9:10 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180110091021.GB18514@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10154607/mbox/"
   >mbox</a>
|
   <a href="/patch/10154607/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10154607/">/patch/10154607/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	C865C602D8 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 10 Jan 2018 09:10:42 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B685228332
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 10 Jan 2018 09:10:42 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id A9CAE28418; Wed, 10 Jan 2018 09:10:42 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2F1BF28332
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 10 Jan 2018 09:10:41 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755905AbeAJJKj (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 10 Jan 2018 04:10:39 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:53208 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755583AbeAJJKW (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 10 Jan 2018 04:10:22 -0500
Received: from localhost (unknown [37.170.134.120])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id C8767ED4;
	Wed, 10 Jan 2018 09:10:20 +0000 (UTC)
Date: Wed, 10 Jan 2018 10:10:21 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.111
Message-ID: &lt;20180110091021.GB18514@kroah.com&gt;
References: &lt;20180110091015.GA18514@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20180110091015.GA18514@kroah.com&gt;
User-Agent: Mutt/1.9.2 (2017-12-15)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 10, 2018, 9:10 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index b028c106535b..4779517d9bf0 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 110</span>
<span class="p_add">+SUBLEVEL = 111</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arc/include/asm/uaccess.h b/arch/arc/include/asm/uaccess.h</span>
<span class="p_header">index d4d8df706efa..57387b567f34 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -673,6 +673,7 @@</span> <span class="p_context"> __arc_strncpy_from_user(char *dst, const char __user *src, long count)</span>
 		return 0;
 
 	__asm__ __volatile__(
<span class="p_add">+	&quot;	mov	lp_count, %5		\n&quot;</span>
 	&quot;	lp	3f			\n&quot;
 	&quot;1:	ldb.ab  %3, [%2, 1]		\n&quot;
 	&quot;	breq.d	%3, 0, 3f               \n&quot;
<span class="p_chunk">@@ -689,8 +690,8 @@</span> <span class="p_context"> __arc_strncpy_from_user(char *dst, const char __user *src, long count)</span>
 	&quot;	.word   1b, 4b			\n&quot;
 	&quot;	.previous			\n&quot;
 	: &quot;+r&quot;(res), &quot;+r&quot;(dst), &quot;+r&quot;(src), &quot;=r&quot;(val)
<span class="p_del">-	: &quot;g&quot;(-EFAULT), &quot;l&quot;(count)</span>
<span class="p_del">-	: &quot;memory&quot;);</span>
<span class="p_add">+	: &quot;g&quot;(-EFAULT), &quot;r&quot;(count)</span>
<span class="p_add">+	: &quot;lp_count&quot;, &quot;lp_start&quot;, &quot;lp_end&quot;, &quot;memory&quot;);</span>
 
 	return res;
 }
<span class="p_header">diff --git a/arch/parisc/include/asm/ldcw.h b/arch/parisc/include/asm/ldcw.h</span>
<span class="p_header">index 8121aa6db2ff..51bb6b8eade6 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/ldcw.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/ldcw.h</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
    for the semaphore.  */
 
 #define __PA_LDCW_ALIGNMENT	16
<span class="p_add">+#define __PA_LDCW_ALIGN_ORDER	4</span>
 #define __ldcw_align(a) ({					\
 	unsigned long __ret = (unsigned long) &amp;(a)-&gt;lock[0];	\
 	__ret = (__ret + __PA_LDCW_ALIGNMENT - 1)		\
<span class="p_chunk">@@ -28,6 +29,7 @@</span> <span class="p_context"></span>
    ldcd). */
 
 #define __PA_LDCW_ALIGNMENT	4
<span class="p_add">+#define __PA_LDCW_ALIGN_ORDER	2</span>
 #define __ldcw_align(a) (&amp;(a)-&gt;slock)
 #define __LDCW	&quot;ldcw,co&quot;
 
<span class="p_header">diff --git a/arch/parisc/kernel/entry.S b/arch/parisc/kernel/entry.S</span>
<span class="p_header">index 623496c11756..5dc831955de5 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/entry.S</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/signal.h&gt;
 #include &lt;asm/unistd.h&gt;
<span class="p_add">+#include &lt;asm/ldcw.h&gt;</span>
 #include &lt;asm/thread_info.h&gt;
 
 #include &lt;linux/linkage.h&gt;
<span class="p_chunk">@@ -46,6 +47,14 @@</span> <span class="p_context"></span>
 #endif
 
 	.import		pa_tlb_lock,data
<span class="p_add">+	.macro  load_pa_tlb_lock reg</span>
<span class="p_add">+#if __PA_LDCW_ALIGNMENT &gt; 4</span>
<span class="p_add">+	load32	PA(pa_tlb_lock) + __PA_LDCW_ALIGNMENT-1, \reg</span>
<span class="p_add">+	depi	0,31,__PA_LDCW_ALIGN_ORDER, \reg</span>
<span class="p_add">+#else</span>
<span class="p_add">+	load32	PA(pa_tlb_lock), \reg</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	.endm</span>
 
 	/* space_to_prot macro creates a prot id from a space id */
 
<span class="p_chunk">@@ -457,7 +466,7 @@</span> <span class="p_context"></span>
 	.macro		tlb_lock	spc,ptp,pte,tmp,tmp1,fault
 #ifdef CONFIG_SMP
 	cmpib,COND(=),n	0,\spc,2f
<span class="p_del">-	load32		PA(pa_tlb_lock),\tmp</span>
<span class="p_add">+	load_pa_tlb_lock \tmp</span>
 1:	LDCW		0(\tmp),\tmp1
 	cmpib,COND(=)	0,\tmp1,1b
 	nop
<span class="p_chunk">@@ -480,7 +489,7 @@</span> <span class="p_context"></span>
 	/* Release pa_tlb_lock lock. */
 	.macro		tlb_unlock1	spc,tmp
 #ifdef CONFIG_SMP
<span class="p_del">-	load32		PA(pa_tlb_lock),\tmp</span>
<span class="p_add">+	load_pa_tlb_lock \tmp</span>
 	tlb_unlock0	\spc,\tmp
 #endif
 	.endm
<span class="p_header">diff --git a/arch/parisc/kernel/pacache.S b/arch/parisc/kernel/pacache.S</span>
<span class="p_header">index a4761b772406..16073f472118 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pacache.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/pacache.S</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/assembly.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/cache.h&gt;
<span class="p_add">+#include &lt;asm/ldcw.h&gt;</span>
 #include &lt;linux/linkage.h&gt;
 
 	.text
<span class="p_chunk">@@ -333,8 +334,12 @@</span> <span class="p_context"> ENDPROC(flush_data_cache_local)</span>
 
 	.macro	tlb_lock	la,flags,tmp
 #ifdef CONFIG_SMP
<span class="p_del">-	ldil		L%pa_tlb_lock,%r1</span>
<span class="p_del">-	ldo		R%pa_tlb_lock(%r1),\la</span>
<span class="p_add">+#if __PA_LDCW_ALIGNMENT &gt; 4</span>
<span class="p_add">+	load32		pa_tlb_lock + __PA_LDCW_ALIGNMENT-1, \la</span>
<span class="p_add">+	depi		0,31,__PA_LDCW_ALIGN_ORDER, \la</span>
<span class="p_add">+#else</span>
<span class="p_add">+	load32		pa_tlb_lock, \la</span>
<span class="p_add">+#endif</span>
 	rsm		PSW_SM_I,\flags
 1:	LDCW		0(\la),\tmp
 	cmpib,&lt;&gt;,n	0,\tmp,3f
<span class="p_header">diff --git a/arch/s390/kernel/compat_linux.c b/arch/s390/kernel/compat_linux.c</span>
<span class="p_header">index 437e61159279..0176ebc97bfd 100644</span>
<span class="p_header">--- a/arch/s390/kernel/compat_linux.c</span>
<span class="p_header">+++ b/arch/s390/kernel/compat_linux.c</span>
<span class="p_chunk">@@ -263,6 +263,7 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE2(s390_setgroups16, int, gidsetsize, u16 __user *, grouplis</span>
 		return retval;
 	}
 
<span class="p_add">+	groups_sort(group_info);</span>
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
<span class="p_header">diff --git a/arch/x86/entry/vdso/vma.c b/arch/x86/entry/vdso/vma.c</span>
<span class="p_header">index aa828191c654..b8f69e264ac4 100644</span>
<span class="p_header">--- a/arch/x86/entry/vdso/vma.c</span>
<span class="p_header">+++ b/arch/x86/entry/vdso/vma.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/random.h&gt;
 #include &lt;linux/elf.h&gt;
 #include &lt;linux/cpu.h&gt;
<span class="p_add">+#include &lt;asm/pvclock.h&gt;</span>
 #include &lt;asm/vgtod.h&gt;
 #include &lt;asm/proto.h&gt;
 #include &lt;asm/vdso.h&gt;
<span class="p_header">diff --git a/arch/x86/entry/vsyscall/vsyscall_64.c b/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_header">index 174c2549939d..112178b401a1 100644</span>
<span class="p_header">--- a/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_header">+++ b/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_chunk">@@ -66,6 +66,11 @@</span> <span class="p_context"> static int __init vsyscall_setup(char *str)</span>
 }
 early_param(&quot;vsyscall&quot;, vsyscall_setup);
 
<span class="p_add">+bool vsyscall_enabled(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return vsyscall_mode != NONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void warn_bad_vsyscall(const char *level, struct pt_regs *regs,
 			      const char *message)
 {
<span class="p_header">diff --git a/arch/x86/include/asm/vsyscall.h b/arch/x86/include/asm/vsyscall.h</span>
<span class="p_header">index 6ba66ee79710..4865e10dbb55 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/vsyscall.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/vsyscall.h</span>
<span class="p_chunk">@@ -12,12 +12,14 @@</span> <span class="p_context"> extern void map_vsyscall(void);</span>
  * Returns true if handled.
  */
 extern bool emulate_vsyscall(struct pt_regs *regs, unsigned long address);
<span class="p_add">+extern bool vsyscall_enabled(void);</span>
 #else
 static inline void map_vsyscall(void) {}
 static inline bool emulate_vsyscall(struct pt_regs *regs, unsigned long address)
 {
 	return false;
 }
<span class="p_add">+static inline bool vsyscall_enabled(void) { return false; }</span>
 #endif
 
 #endif /* _ASM_X86_VSYSCALL_H */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/amd.c b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">index 2233f8a76615..2a0f44d225fe 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_chunk">@@ -580,6 +580,7 @@</span> <span class="p_context"> static unsigned int verify_patch_size(u8 family, u32 patch_size,</span>
 #define F14H_MPB_MAX_SIZE 1824
 #define F15H_MPB_MAX_SIZE 4096
 #define F16H_MPB_MAX_SIZE 3458
<span class="p_add">+#define F17H_MPB_MAX_SIZE 3200</span>
 
 	switch (family) {
 	case 0x14:
<span class="p_chunk">@@ -591,6 +592,9 @@</span> <span class="p_context"> static unsigned int verify_patch_size(u8 family, u32 patch_size,</span>
 	case 0x16:
 		max_size = F16H_MPB_MAX_SIZE;
 		break;
<span class="p_add">+	case 0x17:</span>
<span class="p_add">+		max_size = F17H_MPB_MAX_SIZE;</span>
<span class="p_add">+		break;</span>
 	default:
 		max_size = F1XH_MPB_MAX_SIZE;
 		break;
<span class="p_header">diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c</span>
<span class="p_header">index 2bd45ae91eb3..151fd33e9043 100644</span>
<span class="p_header">--- a/arch/x86/mm/init.c</span>
<span class="p_header">+++ b/arch/x86/mm/init.c</span>
<span class="p_chunk">@@ -757,7 +757,7 @@</span> <span class="p_context"> DEFINE_PER_CPU_SHARED_ALIGNED(struct tlb_state, cpu_tlbstate) = {</span>
 	.state = 0,
 	.cr4 = ~0UL,	/* fail hard if we screw up cr4 shadow initialization */
 };
<span class="p_del">-EXPORT_SYMBOL_GPL(cpu_tlbstate);</span>
<span class="p_add">+EXPORT_PER_CPU_SYMBOL(cpu_tlbstate);</span>
 
 void update_cache_mode_entry(unsigned entry, enum page_cache_mode cache)
 {
<span class="p_header">diff --git a/arch/x86/mm/kaiser.c b/arch/x86/mm/kaiser.c</span>
<span class="p_header">index b0b3a69f1c7f..6a7a77929a8c 100644</span>
<span class="p_header">--- a/arch/x86/mm/kaiser.c</span>
<span class="p_header">+++ b/arch/x86/mm/kaiser.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/pgalloc.h&gt;
 #include &lt;asm/desc.h&gt;
 #include &lt;asm/cmdline.h&gt;
<span class="p_add">+#include &lt;asm/vsyscall.h&gt;</span>
 
 int kaiser_enabled __read_mostly = 1;
 EXPORT_SYMBOL(kaiser_enabled);	/* for inlined TLB flush functions */
<span class="p_chunk">@@ -111,12 +112,13 @@</span> <span class="p_context"> static inline unsigned long get_pa_from_mapping(unsigned long vaddr)</span>
  *
  * Returns a pointer to a PTE on success, or NULL on failure.
  */
<span class="p_del">-static pte_t *kaiser_pagetable_walk(unsigned long address)</span>
<span class="p_add">+static pte_t *kaiser_pagetable_walk(unsigned long address, bool user)</span>
 {
 	pmd_t *pmd;
 	pud_t *pud;
 	pgd_t *pgd = native_get_shadow_pgd(pgd_offset_k(address));
 	gfp_t gfp = (GFP_KERNEL | __GFP_NOTRACK | __GFP_ZERO);
<span class="p_add">+	unsigned long prot = _KERNPG_TABLE;</span>
 
 	if (pgd_none(*pgd)) {
 		WARN_ONCE(1, &quot;All shadow pgds should have been populated&quot;);
<span class="p_chunk">@@ -124,6 +126,17 @@</span> <span class="p_context"> static pte_t *kaiser_pagetable_walk(unsigned long address)</span>
 	}
 	BUILD_BUG_ON(pgd_large(*pgd) != 0);
 
<span class="p_add">+	if (user) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The vsyscall page is the only page that will have</span>
<span class="p_add">+		 *  _PAGE_USER set. Catch everything else.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		BUG_ON(address != VSYSCALL_ADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+		set_pgd(pgd, __pgd(pgd_val(*pgd) | _PAGE_USER));</span>
<span class="p_add">+		prot = _PAGE_TABLE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pud = pud_offset(pgd, address);
 	/* The shadow page tables do not use large mappings: */
 	if (pud_large(*pud)) {
<span class="p_chunk">@@ -136,7 +149,7 @@</span> <span class="p_context"> static pte_t *kaiser_pagetable_walk(unsigned long address)</span>
 			return NULL;
 		spin_lock(&amp;shadow_table_allocation_lock);
 		if (pud_none(*pud)) {
<span class="p_del">-			set_pud(pud, __pud(_KERNPG_TABLE | __pa(new_pmd_page)));</span>
<span class="p_add">+			set_pud(pud, __pud(prot | __pa(new_pmd_page)));</span>
 			__inc_zone_page_state(virt_to_page((void *)
 						new_pmd_page), NR_KAISERTABLE);
 		} else
<span class="p_chunk">@@ -156,7 +169,7 @@</span> <span class="p_context"> static pte_t *kaiser_pagetable_walk(unsigned long address)</span>
 			return NULL;
 		spin_lock(&amp;shadow_table_allocation_lock);
 		if (pmd_none(*pmd)) {
<span class="p_del">-			set_pmd(pmd, __pmd(_KERNPG_TABLE | __pa(new_pte_page)));</span>
<span class="p_add">+			set_pmd(pmd, __pmd(prot | __pa(new_pte_page)));</span>
 			__inc_zone_page_state(virt_to_page((void *)
 						new_pte_page), NR_KAISERTABLE);
 		} else
<span class="p_chunk">@@ -192,7 +205,7 @@</span> <span class="p_context"> static int kaiser_add_user_map(const void *__start_addr, unsigned long size,</span>
 			ret = -EIO;
 			break;
 		}
<span class="p_del">-		pte = kaiser_pagetable_walk(address);</span>
<span class="p_add">+		pte = kaiser_pagetable_walk(address, flags &amp; _PAGE_USER);</span>
 		if (!pte) {
 			ret = -ENOMEM;
 			break;
<span class="p_chunk">@@ -319,6 +332,19 @@</span> <span class="p_context"> void __init kaiser_init(void)</span>
 
 	kaiser_init_all_pgds();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note that this sets _PAGE_USER and it needs to happen when the</span>
<span class="p_add">+	 * pagetable hierarchy gets created, i.e., early. Otherwise</span>
<span class="p_add">+	 * kaiser_pagetable_walk() will encounter initialized PTEs in the</span>
<span class="p_add">+	 * hierarchy and not set the proper permissions, leading to the</span>
<span class="p_add">+	 * pagefaults with page-protection violations when trying to read the</span>
<span class="p_add">+	 * vsyscall page. For example.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (vsyscall_enabled())</span>
<span class="p_add">+		kaiser_add_user_map_early((void *)VSYSCALL_ADDR,</span>
<span class="p_add">+					  PAGE_SIZE,</span>
<span class="p_add">+					   __PAGE_KERNEL_VSYSCALL);</span>
<span class="p_add">+</span>
 	for_each_possible_cpu(cpu) {
 		void *percpu_vaddr = __per_cpu_user_mapped_start +
 				     per_cpu_offset(cpu);
<span class="p_header">diff --git a/arch/x86/mm/kasan_init_64.c b/arch/x86/mm/kasan_init_64.c</span>
<span class="p_header">index 81ec7c02f968..fdfa25c83119 100644</span>
<span class="p_header">--- a/arch/x86/mm/kasan_init_64.c</span>
<span class="p_header">+++ b/arch/x86/mm/kasan_init_64.c</span>
<span class="p_chunk">@@ -126,10 +126,16 @@</span> <span class="p_context"> void __init kasan_init(void)</span>
 
 	/*
 	 * kasan_zero_page has been used as early shadow memory, thus it may
<span class="p_del">-	 * contain some garbage. Now we can clear it, since after the TLB flush</span>
<span class="p_del">-	 * no one should write to it.</span>
<span class="p_add">+	 * contain some garbage. Now we can clear and write protect it, since</span>
<span class="p_add">+	 * after the TLB flush no one should write to it.</span>
 	 */
 	memset(kasan_zero_page, 0, PAGE_SIZE);
<span class="p_add">+	for (i = 0; i &lt; PTRS_PER_PTE; i++) {</span>
<span class="p_add">+		pte_t pte = __pte(__pa(kasan_zero_page) | __PAGE_KERNEL_RO);</span>
<span class="p_add">+		set_pte(&amp;kasan_zero_pte[i], pte);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Flush TLBs again to be sure that write protection applied. */</span>
<span class="p_add">+	__flush_tlb_all();</span>
 
 	init_task.kasan_depth = 0;
 	pr_info(&quot;KernelAddressSanitizer initialized\n&quot;);
<span class="p_header">diff --git a/crypto/chacha20poly1305.c b/crypto/chacha20poly1305.c</span>
<span class="p_header">index 99c3cce01290..0214600ba071 100644</span>
<span class="p_header">--- a/crypto/chacha20poly1305.c</span>
<span class="p_header">+++ b/crypto/chacha20poly1305.c</span>
<span class="p_chunk">@@ -600,6 +600,11 @@</span> <span class="p_context"> static int chachapoly_create(struct crypto_template *tmpl, struct rtattr **tb,</span>
 			       CRYPTO_ALG_TYPE_AHASH_MASK);
 	if (IS_ERR(poly))
 		return PTR_ERR(poly);
<span class="p_add">+	poly_hash = __crypto_hash_alg_common(poly);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -EINVAL;</span>
<span class="p_add">+	if (poly_hash-&gt;digestsize != POLY1305_DIGEST_SIZE)</span>
<span class="p_add">+		goto out_put_poly;</span>
 
 	err = -ENOMEM;
 	inst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);
<span class="p_chunk">@@ -608,7 +613,6 @@</span> <span class="p_context"> static int chachapoly_create(struct crypto_template *tmpl, struct rtattr **tb,</span>
 
 	ctx = aead_instance_ctx(inst);
 	ctx-&gt;saltlen = CHACHAPOLY_IV_SIZE - ivsize;
<span class="p_del">-	poly_hash = __crypto_hash_alg_common(poly);</span>
 	err = crypto_init_ahash_spawn(&amp;ctx-&gt;poly, poly_hash,
 				      aead_crypto_instance(inst));
 	if (err)
<span class="p_header">diff --git a/crypto/pcrypt.c b/crypto/pcrypt.c</span>
<span class="p_header">index ee9cfb99fe25..f8ec3d4ba4a8 100644</span>
<span class="p_header">--- a/crypto/pcrypt.c</span>
<span class="p_header">+++ b/crypto/pcrypt.c</span>
<span class="p_chunk">@@ -254,6 +254,14 @@</span> <span class="p_context"> static void pcrypt_aead_exit_tfm(struct crypto_aead *tfm)</span>
 	crypto_free_aead(ctx-&gt;child);
 }
 
<span class="p_add">+static void pcrypt_free(struct aead_instance *inst)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pcrypt_instance_ctx *ctx = aead_instance_ctx(inst);</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_drop_aead(&amp;ctx-&gt;spawn);</span>
<span class="p_add">+	kfree(inst);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int pcrypt_init_instance(struct crypto_instance *inst,
 				struct crypto_alg *alg)
 {
<span class="p_chunk">@@ -319,6 +327,8 @@</span> <span class="p_context"> static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,</span>
 	inst-&gt;alg.encrypt = pcrypt_aead_encrypt;
 	inst-&gt;alg.decrypt = pcrypt_aead_decrypt;
 
<span class="p_add">+	inst-&gt;free = pcrypt_free;</span>
<span class="p_add">+</span>
 	err = aead_register_instance(tmpl, inst);
 	if (err)
 		goto out_drop_aead;
<span class="p_chunk">@@ -349,14 +359,6 @@</span> <span class="p_context"> static int pcrypt_create(struct crypto_template *tmpl, struct rtattr **tb)</span>
 	return -EINVAL;
 }
 
<span class="p_del">-static void pcrypt_free(struct crypto_instance *inst)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);</span>
<span class="p_del">-</span>
<span class="p_del">-	crypto_drop_aead(&amp;ctx-&gt;spawn);</span>
<span class="p_del">-	kfree(inst);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int pcrypt_cpumask_change_notify(struct notifier_block *self,
 					unsigned long val, void *data)
 {
<span class="p_chunk">@@ -469,7 +471,6 @@</span> <span class="p_context"> static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)</span>
 static struct crypto_template pcrypt_tmpl = {
 	.name = &quot;pcrypt&quot;,
 	.create = pcrypt_create,
<span class="p_del">-	.free = pcrypt_free,</span>
 	.module = THIS_MODULE,
 };
 
<span class="p_header">diff --git a/drivers/bus/sunxi-rsb.c b/drivers/bus/sunxi-rsb.c</span>
<span class="p_header">index 25996e256110..0ffb247b42d6 100644</span>
<span class="p_header">--- a/drivers/bus/sunxi-rsb.c</span>
<span class="p_header">+++ b/drivers/bus/sunxi-rsb.c</span>
<span class="p_chunk">@@ -178,6 +178,7 @@</span> <span class="p_context"> static struct bus_type sunxi_rsb_bus = {</span>
 	.match		= sunxi_rsb_device_match,
 	.probe		= sunxi_rsb_device_probe,
 	.remove		= sunxi_rsb_device_remove,
<span class="p_add">+	.uevent		= of_device_uevent_modalias,</span>
 };
 
 static void sunxi_rsb_dev_release(struct device *dev)
<span class="p_header">diff --git a/drivers/crypto/n2_core.c b/drivers/crypto/n2_core.c</span>
<span class="p_header">index 5450880abb7b..5a9083021fa0 100644</span>
<span class="p_header">--- a/drivers/crypto/n2_core.c</span>
<span class="p_header">+++ b/drivers/crypto/n2_core.c</span>
<span class="p_chunk">@@ -1641,6 +1641,7 @@</span> <span class="p_context"> static int queue_cache_init(void)</span>
 					  CWQ_ENTRY_SIZE, 0, NULL);
 	if (!queue_cache[HV_NCS_QTYPE_CWQ - 1]) {
 		kmem_cache_destroy(queue_cache[HV_NCS_QTYPE_MAU - 1]);
<span class="p_add">+		queue_cache[HV_NCS_QTYPE_MAU - 1] = NULL;</span>
 		return -ENOMEM;
 	}
 	return 0;
<span class="p_chunk">@@ -1650,6 +1651,8 @@</span> <span class="p_context"> static void queue_cache_destroy(void)</span>
 {
 	kmem_cache_destroy(queue_cache[HV_NCS_QTYPE_MAU - 1]);
 	kmem_cache_destroy(queue_cache[HV_NCS_QTYPE_CWQ - 1]);
<span class="p_add">+	queue_cache[HV_NCS_QTYPE_MAU - 1] = NULL;</span>
<span class="p_add">+	queue_cache[HV_NCS_QTYPE_CWQ - 1] = NULL;</span>
 }
 
 static int spu_queue_register(struct spu_queue *p, unsigned long q_type)
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 6f4dc0fd2ca3..51b96e9bf793 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -1613,7 +1613,7 @@</span> <span class="p_context"> static int elantech_set_properties(struct elantech_data *etd)</span>
 		case 5:
 			etd-&gt;hw_version = 3;
 			break;
<span class="p_del">-		case 6 ... 14:</span>
<span class="p_add">+		case 6 ... 15:</span>
 			etd-&gt;hw_version = 4;
 			break;
 		default:
<span class="p_header">diff --git a/fs/nfsd/auth.c b/fs/nfsd/auth.c</span>
<span class="p_header">index 9d46a0bdd9f9..a260060042ad 100644</span>
<span class="p_header">--- a/fs/nfsd/auth.c</span>
<span class="p_header">+++ b/fs/nfsd/auth.c</span>
<span class="p_chunk">@@ -59,6 +59,9 @@</span> <span class="p_context"> int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)</span>
 				GROUP_AT(gi, i) = exp-&gt;ex_anon_gid;
 			else
 				GROUP_AT(gi, i) = GROUP_AT(rqgi, i);
<span class="p_add">+</span>
<span class="p_add">+			/* Each thread allocates its own gi, no race */</span>
<span class="p_add">+			groups_sort(gi);</span>
 		}
 	} else {
 		gi = get_group_info(rqgi);
<span class="p_header">diff --git a/include/linux/cred.h b/include/linux/cred.h</span>
<span class="p_header">index 257db64562e5..9e120c92551b 100644</span>
<span class="p_header">--- a/include/linux/cred.h</span>
<span class="p_header">+++ b/include/linux/cred.h</span>
<span class="p_chunk">@@ -87,6 +87,7 @@</span> <span class="p_context"> extern int set_current_groups(struct group_info *);</span>
 extern void set_groups(struct cred *, struct group_info *);
 extern int groups_search(const struct group_info *, kgid_t);
 extern bool may_setgroups(void);
<span class="p_add">+extern void groups_sort(struct group_info *);</span>
 
 /* access the groups &quot;array&quot; with this macro */
 #define GROUP_AT(gi, i) \
<span class="p_header">diff --git a/include/linux/fscache.h b/include/linux/fscache.h</span>
<span class="p_header">index 115bb81912cc..94a8aae8f9e2 100644</span>
<span class="p_header">--- a/include/linux/fscache.h</span>
<span class="p_header">+++ b/include/linux/fscache.h</span>
<span class="p_chunk">@@ -764,7 +764,7 @@</span> <span class="p_context"> bool fscache_maybe_release_page(struct fscache_cookie *cookie,</span>
 {
 	if (fscache_cookie_valid(cookie) &amp;&amp; PageFsCache(page))
 		return __fscache_maybe_release_page(cookie, page, gfp);
<span class="p_del">-	return false;</span>
<span class="p_add">+	return true;</span>
 }
 
 /**
<span class="p_header">diff --git a/kernel/acct.c b/kernel/acct.c</span>
<span class="p_header">index 74963d192c5d..37f1dc696fbd 100644</span>
<span class="p_header">--- a/kernel/acct.c</span>
<span class="p_header">+++ b/kernel/acct.c</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> static int check_free_space(struct bsd_acct_struct *acct)</span>
 {
 	struct kstatfs sbuf;
 
<span class="p_del">-	if (time_is_before_jiffies(acct-&gt;needcheck))</span>
<span class="p_add">+	if (time_is_after_jiffies(acct-&gt;needcheck))</span>
 		goto out;
 
 	/* May block */
<span class="p_header">diff --git a/kernel/groups.c b/kernel/groups.c</span>
<span class="p_header">index 74d431d25251..5ea9847f172f 100644</span>
<span class="p_header">--- a/kernel/groups.c</span>
<span class="p_header">+++ b/kernel/groups.c</span>
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"> static int groups_from_user(struct group_info *group_info,</span>
 }
 
 /* a simple Shell sort */
<span class="p_del">-static void groups_sort(struct group_info *group_info)</span>
<span class="p_add">+void groups_sort(struct group_info *group_info)</span>
 {
 	int base, max, stride;
 	int gidsetsize = group_info-&gt;ngroups;
<span class="p_chunk">@@ -128,6 +128,7 @@</span> <span class="p_context"> static void groups_sort(struct group_info *group_info)</span>
 		stride /= 3;
 	}
 }
<span class="p_add">+EXPORT_SYMBOL(groups_sort);</span>
 
 /* a simple bsearch */
 int groups_search(const struct group_info *group_info, kgid_t grp)
<span class="p_chunk">@@ -159,7 +160,6 @@</span> <span class="p_context"> int groups_search(const struct group_info *group_info, kgid_t grp)</span>
 void set_groups(struct cred *new, struct group_info *group_info)
 {
 	put_group_info(new-&gt;group_info);
<span class="p_del">-	groups_sort(group_info);</span>
 	get_group_info(group_info);
 	new-&gt;group_info = group_info;
 }
<span class="p_chunk">@@ -243,6 +243,7 @@</span> <span class="p_context"> SYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)</span>
 		return retval;
 	}
 
<span class="p_add">+	groups_sort(group_info);</span>
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index b14a4f31221f..0a56098d3738 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -2404,7 +2404,7 @@</span> <span class="p_context"> static char elf_type(const Elf_Sym *sym, const struct load_info *info)</span>
 	}
 	if (sym-&gt;st_shndx == SHN_UNDEF)
 		return &#39;U&#39;;
<span class="p_del">-	if (sym-&gt;st_shndx == SHN_ABS)</span>
<span class="p_add">+	if (sym-&gt;st_shndx == SHN_ABS || sym-&gt;st_shndx == info-&gt;index.pcpu)</span>
 		return &#39;a&#39;;
 	if (sym-&gt;st_shndx &gt;= SHN_LORESERVE)
 		return &#39;?&#39;;
<span class="p_chunk">@@ -2433,7 +2433,7 @@</span> <span class="p_context"> static char elf_type(const Elf_Sym *sym, const struct load_info *info)</span>
 }
 
 static bool is_core_symbol(const Elf_Sym *src, const Elf_Shdr *sechdrs,
<span class="p_del">-			unsigned int shnum)</span>
<span class="p_add">+			unsigned int shnum, unsigned int pcpundx)</span>
 {
 	const Elf_Shdr *sec;
 
<span class="p_chunk">@@ -2442,6 +2442,11 @@</span> <span class="p_context"> static bool is_core_symbol(const Elf_Sym *src, const Elf_Shdr *sechdrs,</span>
 	    || !src-&gt;st_name)
 		return false;
 
<span class="p_add">+#ifdef CONFIG_KALLSYMS_ALL</span>
<span class="p_add">+	if (src-&gt;st_shndx == pcpundx)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	sec = sechdrs + src-&gt;st_shndx;
 	if (!(sec-&gt;sh_flags &amp; SHF_ALLOC)
 #ifndef CONFIG_KALLSYMS_ALL
<span class="p_chunk">@@ -2479,7 +2484,8 @@</span> <span class="p_context"> static void layout_symtab(struct module *mod, struct load_info *info)</span>
 	/* Compute total space required for the core symbols&#39; strtab. */
 	for (ndst = i = 0; i &lt; nsrc; i++) {
 		if (i == 0 ||
<span class="p_del">-		    is_core_symbol(src+i, info-&gt;sechdrs, info-&gt;hdr-&gt;e_shnum)) {</span>
<span class="p_add">+		    is_core_symbol(src+i, info-&gt;sechdrs, info-&gt;hdr-&gt;e_shnum,</span>
<span class="p_add">+				   info-&gt;index.pcpu)) {</span>
 			strtab_size += strlen(&amp;info-&gt;strtab[src[i].st_name])+1;
 			ndst++;
 		}
<span class="p_chunk">@@ -2537,7 +2543,8 @@</span> <span class="p_context"> static void add_kallsyms(struct module *mod, const struct load_info *info)</span>
 	src = mod-&gt;kallsyms-&gt;symtab;
 	for (ndst = i = 0; i &lt; mod-&gt;kallsyms-&gt;num_symtab; i++) {
 		if (i == 0 ||
<span class="p_del">-		    is_core_symbol(src+i, info-&gt;sechdrs, info-&gt;hdr-&gt;e_shnum)) {</span>
<span class="p_add">+		    is_core_symbol(src+i, info-&gt;sechdrs, info-&gt;hdr-&gt;e_shnum,</span>
<span class="p_add">+				   info-&gt;index.pcpu)) {</span>
 			dst[ndst] = src[i];
 			dst[ndst++].st_name = s - mod-&gt;core_kallsyms.strtab;
 			s += strlcpy(s, &amp;mod-&gt;kallsyms-&gt;strtab[src[i].st_name],
<span class="p_chunk">@@ -2881,8 +2888,12 @@</span> <span class="p_context"> static int check_modinfo(struct module *mod, struct load_info *info, int flags)</span>
 		return -ENOEXEC;
 	}
 
<span class="p_del">-	if (!get_modinfo(info, &quot;intree&quot;))</span>
<span class="p_add">+	if (!get_modinfo(info, &quot;intree&quot;)) {</span>
<span class="p_add">+		if (!test_taint(TAINT_OOT_MODULE))</span>
<span class="p_add">+			pr_warn(&quot;%s: loading out-of-tree module taints kernel.\n&quot;,</span>
<span class="p_add">+				mod-&gt;name);</span>
 		add_taint_module(mod, TAINT_OOT_MODULE, LOCKDEP_STILL_OK);
<span class="p_add">+	}</span>
 
 	if (get_modinfo(info, &quot;staging&quot;)) {
 		add_taint_module(mod, TAINT_CRAP, LOCKDEP_STILL_OK);
<span class="p_chunk">@@ -3047,6 +3058,8 @@</span> <span class="p_context"> static int move_module(struct module *mod, struct load_info *info)</span>
 
 static int check_module_license_and_versions(struct module *mod)
 {
<span class="p_add">+	int prev_taint = test_taint(TAINT_PROPRIETARY_MODULE);</span>
<span class="p_add">+</span>
 	/*
 	 * ndiswrapper is under GPL by itself, but loads proprietary modules.
 	 * Don&#39;t use add_taint_module(), as it would prevent ndiswrapper from
<span class="p_chunk">@@ -3065,6 +3078,9 @@</span> <span class="p_context"> static int check_module_license_and_versions(struct module *mod)</span>
 		add_taint_module(mod, TAINT_PROPRIETARY_MODULE,
 				 LOCKDEP_NOW_UNRELIABLE);
 
<span class="p_add">+	if (!prev_taint &amp;&amp; test_taint(TAINT_PROPRIETARY_MODULE))</span>
<span class="p_add">+		pr_warn(&quot;%s: module license taints kernel.\n&quot;, mod-&gt;name);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_MODVERSIONS
 	if ((mod-&gt;num_syms &amp;&amp; !mod-&gt;crcs)
 	    || (mod-&gt;num_gpl_syms &amp;&amp; !mod-&gt;gpl_crcs)
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index 5d50ea899b6d..4a548c6a4118 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> static int sig_task_ignored(struct task_struct *t, int sig, bool force)</span>
 	handler = sig_handler(t, sig);
 
 	if (unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;
<span class="p_del">-			handler == SIG_DFL &amp;&amp; !force)</span>
<span class="p_add">+	    handler == SIG_DFL &amp;&amp; !(force &amp;&amp; sig_kernel_only(sig)))</span>
 		return 1;
 
 	return sig_handler_ignored(handler, sig);
<span class="p_chunk">@@ -88,13 +88,15 @@</span> <span class="p_context"> static int sig_ignored(struct task_struct *t, int sig, bool force)</span>
 	if (sigismember(&amp;t-&gt;blocked, sig) || sigismember(&amp;t-&gt;real_blocked, sig))
 		return 0;
 
<span class="p_del">-	if (!sig_task_ignored(t, sig, force))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	/*
<span class="p_del">-	 * Tracers may want to know about even ignored signals.</span>
<span class="p_add">+	 * Tracers may want to know about even ignored signal unless it</span>
<span class="p_add">+	 * is SIGKILL which can&#39;t be reported anyway but can be ignored</span>
<span class="p_add">+	 * by SIGNAL_UNKILLABLE task.</span>
 	 */
<span class="p_del">-	return !t-&gt;ptrace;</span>
<span class="p_add">+	if (t-&gt;ptrace &amp;&amp; sig != SIGKILL)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return sig_task_ignored(t, sig, force);</span>
 }
 
 /*
<span class="p_chunk">@@ -917,9 +919,9 @@</span> <span class="p_context"> static void complete_signal(int sig, struct task_struct *p, int group)</span>
 	 * then start taking the whole group down immediately.
 	 */
 	if (sig_fatal(p, sig) &amp;&amp;
<span class="p_del">-	    !(signal-&gt;flags &amp; (SIGNAL_UNKILLABLE | SIGNAL_GROUP_EXIT)) &amp;&amp;</span>
<span class="p_add">+	    !(signal-&gt;flags &amp; SIGNAL_GROUP_EXIT) &amp;&amp;</span>
 	    !sigismember(&amp;t-&gt;real_blocked, sig) &amp;&amp;
<span class="p_del">-	    (sig == SIGKILL || !t-&gt;ptrace)) {</span>
<span class="p_add">+	    (sig == SIGKILL || !p-&gt;ptrace)) {</span>
 		/*
 		 * This signal will be fatal to the whole group.
 		 */
<span class="p_header">diff --git a/kernel/uid16.c b/kernel/uid16.c</span>
<span class="p_header">index d58cc4d8f0d1..651aaa5221ec 100644</span>
<span class="p_header">--- a/kernel/uid16.c</span>
<span class="p_header">+++ b/kernel/uid16.c</span>
<span class="p_chunk">@@ -190,6 +190,7 @@</span> <span class="p_context"> SYSCALL_DEFINE2(setgroups16, int, gidsetsize, old_gid_t __user *, grouplist)</span>
 		return retval;
 	}
 
<span class="p_add">+	groups_sort(group_info);</span>
 	retval = set_current_groups(group_info);
 	put_group_info(group_info);
 
<span class="p_header">diff --git a/mm/vmstat.c b/mm/vmstat.c</span>
<span class="p_header">index 324b7e90b4c5..5712cdaae964 100644</span>
<span class="p_header">--- a/mm/vmstat.c</span>
<span class="p_header">+++ b/mm/vmstat.c</span>
<span class="p_chunk">@@ -1351,7 +1351,9 @@</span> <span class="p_context"> static int vmstat_show(struct seq_file *m, void *arg)</span>
 	unsigned long *l = arg;
 	unsigned long off = l - (unsigned long *)m-&gt;private;
 
<span class="p_del">-	seq_printf(m, &quot;%s %lu\n&quot;, vmstat_text[off], *l);</span>
<span class="p_add">+	seq_puts(m, vmstat_text[off]);</span>
<span class="p_add">+	seq_put_decimal_ull(m, &#39; &#39;, *l);</span>
<span class="p_add">+	seq_putc(m, &#39;\n&#39;);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sunrpc/auth_gss/gss_rpc_xdr.c b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">index 2410d557ae39..89731c9023f0 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_chunk">@@ -231,6 +231,7 @@</span> <span class="p_context"> static int gssx_dec_linux_creds(struct xdr_stream *xdr,</span>
 			goto out_free_groups;
 		GROUP_AT(creds-&gt;cr_group_info, i) = kgid;
 	}
<span class="p_add">+	groups_sort(creds-&gt;cr_group_info);</span>
 
 	return 0;
 out_free_groups:
<span class="p_header">diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">index 033fec307528..036bbf2b44c1 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_chunk">@@ -481,6 +481,7 @@</span> <span class="p_context"> static int rsc_parse(struct cache_detail *cd,</span>
 				goto out;
 			GROUP_AT(rsci.cred.cr_group_info, i) = kgid;
 		}
<span class="p_add">+		groups_sort(rsci.cred.cr_group_info);</span>
 
 		/* mech name */
 		len = qword_get(&amp;mesg, buf, mlen);
<span class="p_header">diff --git a/net/sunrpc/svcauth_unix.c b/net/sunrpc/svcauth_unix.c</span>
<span class="p_header">index 621ca7b4a155..98db1715cb17 100644</span>
<span class="p_header">--- a/net/sunrpc/svcauth_unix.c</span>
<span class="p_header">+++ b/net/sunrpc/svcauth_unix.c</span>
<span class="p_chunk">@@ -520,6 +520,7 @@</span> <span class="p_context"> static int unix_gid_parse(struct cache_detail *cd,</span>
 		GROUP_AT(ug.gi, i) = kgid;
 	}
 
<span class="p_add">+	groups_sort(ug.gi);</span>
 	ugp = unix_gid_lookup(cd, uid);
 	if (ugp) {
 		struct cache_head *ch;
<span class="p_chunk">@@ -827,6 +828,7 @@</span> <span class="p_context"> svcauth_unix_accept(struct svc_rqst *rqstp, __be32 *authp)</span>
 		kgid_t kgid = make_kgid(&amp;init_user_ns, svc_getnl(argv));
 		GROUP_AT(cred-&gt;cr_group_info, i) = kgid;
 	}
<span class="p_add">+	groups_sort(cred-&gt;cr_group_info);</span>
 	if (svc_getu32(argv) != htonl(RPC_AUTH_NULL) || svc_getu32(argv) != 0) {
 		*authp = rpc_autherr_badverf;
 		return SVC_DENIED;
<span class="p_header">diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c</span>
<span class="p_header">index 88632df4381b..dafaf96e0a34 100644</span>
<span class="p_header">--- a/scripts/genksyms/genksyms.c</span>
<span class="p_header">+++ b/scripts/genksyms/genksyms.c</span>
<span class="p_chunk">@@ -423,13 +423,15 @@</span> <span class="p_context"> static struct string_list *read_node(FILE *f)</span>
 	struct string_list node = {
 		.string = buffer,
 		.tag = SYM_NORMAL };
<span class="p_del">-	int c;</span>
<span class="p_add">+	int c, in_string = 0;</span>
 
 	while ((c = fgetc(f)) != EOF) {
<span class="p_del">-		if (c == &#39; &#39;) {</span>
<span class="p_add">+		if (!in_string &amp;&amp; c == &#39; &#39;) {</span>
 			if (node.string == buffer)
 				continue;
 			break;
<span class="p_add">+		} else if (c == &#39;&quot;&#39;) {</span>
<span class="p_add">+			in_string = !in_string;</span>
 		} else if (c == &#39;\n&#39;) {
 			if (node.string == buffer)
 				return NULL;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



