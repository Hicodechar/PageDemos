
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] core kernel resource handling changes to support NVDIMM error injection, for v4.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] core kernel resource handling changes to support NVDIMM error injection, for v4.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 14, 2016, 11:03 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160314110312.GA6968@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8578291/mbox/"
   >mbox</a>
|
   <a href="/patch/8578291/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8578291/">/patch/8578291/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 398499F54C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 14 Mar 2016 11:03:52 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 273B12041D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 14 Mar 2016 11:03:49 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 03D4E2041C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 14 Mar 2016 11:03:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S964911AbcCNLDb (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 14 Mar 2016 07:03:31 -0400
Received: from mail-wm0-f68.google.com ([74.125.82.68]:36012 &quot;EHLO
	mail-wm0-f68.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S964861AbcCNLDR (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 14 Mar 2016 07:03:17 -0400
Received: by mail-wm0-f68.google.com with SMTP id l68so14438625wml.3
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 14 Mar 2016 04:03:16 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=+UKRf9rh9cephYtkT0tR8Z7HEKe2UuueIBIpg7uTlNY=;
	b=FKhzGpual/lWxRtQNPEYVQVG/+YGhlSKiZK7BdSW1H+vSGliynW8+SO4nAxWJU8549
	dP21IUNTMGbBkCHjfrZX302483GpUJOlvcEL0QppQp0yrpP1r96mLNYu8lVzQV8FyS0t
	m1nPcZnxkcijBa0Q3FjvRN9pORTNOaZyM6FsXFHTYLmQi1rv89CbM947CJkOeMZynpBd
	NefSSHcnHGQDENJaOunlsFbiLwFSNSrcZdIw2AQmi6imSuhx6HKQ9hKCWbCWYunnL5cJ
	cg7byrqUqAC6Gx+kUFRVWL+z+xpnohmCoCASyX2lBdUlc3sko2I+d0FSk/rHVs6RYWnz
	7/Cg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=+UKRf9rh9cephYtkT0tR8Z7HEKe2UuueIBIpg7uTlNY=;
	b=O635IcM2RIzWJU4FYMvRKenN3mm9n7lHu4KYmDJiIkpfOrYFvrTzJHpqQmXcRVNjbl
	n6aqYrHrqeS0ynqcK1capDPLwdQTFEkINVpwf81iOLbE1sNY2sVCgzIIeT/vlnFkB8+t
	cD7igzQG6DpVVD/DvCaR8teWe4bPSguNkgEfZkaI6e8fyGIZ6TAXyVz5Qjg/W0e5tMAg
	opLb03lIt6FD/H6oeqWxL+Ce5ROFrmPGxKuADmOhtSwNkSZx3lEcV3BzWysDVr4kMGhP
	R3TBQfkV8OYqQuhWpTveJtqOzTJxO0Yae//eqJLHiQO/rXcit7TeJ3s5lqypvwACevS7
	AzRg==
X-Gm-Message-State: AD7BkJKqYhceC57GRCh56plE4iSc5ESUvEbAVf/EFjvNmTaa64puJz9HF2VYy6g3tVnNsQ==
X-Received: by 10.28.53.4 with SMTP id c4mr17448499wma.34.1457953395457;
	Mon, 14 Mar 2016 04:03:15 -0700 (PDT)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	u14sm15520610wmu.8.2016.03.14.04.03.14
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 14 Mar 2016 04:03:14 -0700 (PDT)
Date: Mon, 14 Mar 2016 12:03:12 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Toshi Kani &lt;toshi.kani@hpe.com&gt;,
	&quot;Rafael J. Wysocki&quot; &lt;rjw@rjwysocki.net&gt;,
	Dan Williams &lt;dan.j.williams@intel.com&gt;, Borislav Petkov &lt;bp@suse.de&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;
Subject: [GIT PULL] core kernel resource handling changes to support NVDIMM
	error injection, for v4.6
Message-ID: &lt;20160314110312.GA6968@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.8 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,RP_MATCHES_RCVD,T_DKIM_INVALID,UNPARSEABLE_RELAY
	autolearn=ham version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - March 14, 2016, 11:03 a.m.</div>
<pre class="content">
Linus,

Please pull the latest core-resources-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git core-resources-for-linus

   # HEAD: bc94b99636dc7bcccce439a9fb9c00065e2e2627 Merge tag &#39;v4.5-rc6&#39; into core/resources, to resolve conflict

This tree introduces a new I/O resource type, IORESOURCE_SYSTEM_RAM, for System 
RAM while keeping the current IORESOURCE_MEM type bit set for all memory-mapped 
ranges (including System RAM) for backward compatibility.

With this resource flag it no longer takes a strcmp() loop through the resource 
tree to find &quot;System RAM&quot; resources.

The new resource type is then used to extend ACPI/APEI error injection facility to 
also support NVDIMM.

 Thanks,

	Ingo

------------------&gt;
Toshi Kani (17):
      resource: Add System RAM resource type
      resource: Handle resource flags properly
      resource: Add I/O resource descriptor
      x86/e820: Set System RAM type and descriptor
      ia64: Set System RAM type and descriptor
      arch: Set IORESOURCE_SYSTEM_RAM flag for System RAM
      kexec: Set IORESOURCE_SYSTEM_RAM for System RAM
      xen, mm: Set IORESOURCE_SYSTEM_RAM to System RAM
      drivers: Initialize resource entry to zero
      resource: Change walk_system_ram() to use System RAM type
      arm/samsung: Change s3c_pm_run_res() to use System RAM type
      memremap: Change region_intersects() to take @flags and @desc
      resource: Add walk_iomem_res_desc()
      x86, kexec, nvdimm: Use walk_iomem_res_desc() for iomem search
      x86/kexec: Remove walk_iomem_res() call with GART type
      resource: Kill walk_iomem_res()
      ACPI/EINJ: Allow memory error injection to NVDIMM


 arch/arm/kernel/setup.c            |  6 +--
 arch/arm/plat-samsung/pm-check.c   |  4 +-
 arch/arm64/kernel/setup.c          |  6 +--
 arch/avr32/kernel/setup.c          |  6 +--
 arch/ia64/kernel/efi.c             | 13 ++++--
 arch/ia64/kernel/setup.c           |  6 +--
 arch/m32r/kernel/setup.c           |  4 +-
 arch/mips/kernel/setup.c           | 10 ++--
 arch/parisc/mm/init.c              |  6 +--
 arch/powerpc/mm/mem.c              |  2 +-
 arch/s390/kernel/setup.c           |  8 ++--
 arch/score/kernel/setup.c          |  2 +-
 arch/sh/kernel/setup.c             |  8 ++--
 arch/sparc/mm/init_64.c            |  8 ++--
 arch/tile/kernel/setup.c           | 11 +++--
 arch/unicore32/kernel/setup.c      |  6 +--
 arch/x86/kernel/crash.c            | 41 ++---------------
 arch/x86/kernel/e820.c             | 38 +++++++++++++++-
 arch/x86/kernel/pmem.c             |  4 +-
 arch/x86/kernel/setup.c            |  6 +--
 drivers/acpi/acpi_platform.c       |  2 +-
 drivers/acpi/apei/einj.c           | 15 ++++--
 drivers/nvdimm/e820.c              |  2 +-
 drivers/parisc/eisa_enumerator.c   |  4 +-
 drivers/rapidio/rio.c              |  8 ++--
 drivers/sh/superhyway/superhyway.c |  2 +-
 drivers/xen/balloon.c              |  2 +-
 include/linux/ioport.h             | 33 +++++++++++++-
 include/linux/mm.h                 |  3 +-
 kernel/kexec_core.c                |  8 ++--
 kernel/kexec_file.c                |  8 ++--
 kernel/memremap.c                  | 13 +++---
 kernel/resource.c                  | 93 ++++++++++++++++++++++----------------
 mm/memory_hotplug.c                |  2 +-
 34 files changed, 231 insertions(+), 159 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c</span>
<span class="p_header">index 7d0cba6f1cc5..139791ed473d 100644</span>
<span class="p_header">--- a/arch/arm/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm/kernel/setup.c</span>
<span class="p_chunk">@@ -176,13 +176,13 @@</span> <span class="p_context"> static struct resource mem_res[] = {</span>
 		.name = &quot;Kernel code&quot;,
 		.start = 0,
 		.end = 0,
<span class="p_del">-		.flags = IORESOURCE_MEM</span>
<span class="p_add">+		.flags = IORESOURCE_SYSTEM_RAM</span>
 	},
 	{
 		.name = &quot;Kernel data&quot;,
 		.start = 0,
 		.end = 0,
<span class="p_del">-		.flags = IORESOURCE_MEM</span>
<span class="p_add">+		.flags = IORESOURCE_SYSTEM_RAM</span>
 	}
 };
 
<span class="p_chunk">@@ -851,7 +851,7 @@</span> <span class="p_context"> static void __init request_standard_resources(const struct machine_desc *mdesc)</span>
 		res-&gt;name  = &quot;System RAM&quot;;
 		res-&gt;start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
 		res-&gt;end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;
<span class="p_del">-		res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+		res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 
 		request_resource(&amp;iomem_resource, res);
 
<span class="p_header">diff --git a/arch/arm/plat-samsung/pm-check.c b/arch/arm/plat-samsung/pm-check.c</span>
<span class="p_header">index 04aff2c31b46..70f2f699bed3 100644</span>
<span class="p_header">--- a/arch/arm/plat-samsung/pm-check.c</span>
<span class="p_header">+++ b/arch/arm/plat-samsung/pm-check.c</span>
<span class="p_chunk">@@ -53,8 +53,8 @@</span> <span class="p_context"> static void s3c_pm_run_res(struct resource *ptr, run_fn_t fn, u32 *arg)</span>
 		if (ptr-&gt;child != NULL)
 			s3c_pm_run_res(ptr-&gt;child, fn, arg);
 
<span class="p_del">-		if ((ptr-&gt;flags &amp; IORESOURCE_MEM) &amp;&amp;</span>
<span class="p_del">-		    strcmp(ptr-&gt;name, &quot;System RAM&quot;) == 0) {</span>
<span class="p_add">+		if ((ptr-&gt;flags &amp; IORESOURCE_SYSTEM_RAM)</span>
<span class="p_add">+				== IORESOURCE_SYSTEM_RAM) {</span>
 			S3C_PMDBG(&quot;Found system RAM at %08lx..%08lx\n&quot;,
 				  (unsigned long)ptr-&gt;start,
 				  (unsigned long)ptr-&gt;end);
<span class="p_header">diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c</span>
<span class="p_header">index 8119479147db..450987d99b9b 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/setup.c</span>
<span class="p_chunk">@@ -73,13 +73,13 @@</span> <span class="p_context"> static struct resource mem_res[] = {</span>
 		.name = &quot;Kernel code&quot;,
 		.start = 0,
 		.end = 0,
<span class="p_del">-		.flags = IORESOURCE_MEM</span>
<span class="p_add">+		.flags = IORESOURCE_SYSTEM_RAM</span>
 	},
 	{
 		.name = &quot;Kernel data&quot;,
 		.start = 0,
 		.end = 0,
<span class="p_del">-		.flags = IORESOURCE_MEM</span>
<span class="p_add">+		.flags = IORESOURCE_SYSTEM_RAM</span>
 	}
 };
 
<span class="p_chunk">@@ -210,7 +210,7 @@</span> <span class="p_context"> static void __init request_standard_resources(void)</span>
 		res-&gt;name  = &quot;System RAM&quot;;
 		res-&gt;start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
 		res-&gt;end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;
<span class="p_del">-		res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+		res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 
 		request_resource(&amp;iomem_resource, res);
 
<span class="p_header">diff --git a/arch/avr32/kernel/setup.c b/arch/avr32/kernel/setup.c</span>
<span class="p_header">index 209ae5ad3495..e6928896da2a 100644</span>
<span class="p_header">--- a/arch/avr32/kernel/setup.c</span>
<span class="p_header">+++ b/arch/avr32/kernel/setup.c</span>
<span class="p_chunk">@@ -49,13 +49,13 @@</span> <span class="p_context"> static struct resource __initdata kernel_data = {</span>
 	.name	= &quot;Kernel data&quot;,
 	.start	= 0,
 	.end	= 0,
<span class="p_del">-	.flags	= IORESOURCE_MEM,</span>
<span class="p_add">+	.flags	= IORESOURCE_SYSTEM_RAM,</span>
 };
 static struct resource __initdata kernel_code = {
 	.name	= &quot;Kernel code&quot;,
 	.start	= 0,
 	.end	= 0,
<span class="p_del">-	.flags	= IORESOURCE_MEM,</span>
<span class="p_add">+	.flags	= IORESOURCE_SYSTEM_RAM,</span>
 	.sibling = &amp;kernel_data,
 };
 
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> add_physical_memory(resource_size_t start, resource_size_t end)</span>
 	new-&gt;start = start;
 	new-&gt;end = end;
 	new-&gt;name = &quot;System RAM&quot;;
<span class="p_del">-	new-&gt;flags = IORESOURCE_MEM;</span>
<span class="p_add">+	new-&gt;flags = IORESOURCE_SYSTEM_RAM;</span>
 
 	*pprev = new;
 }
<span class="p_header">diff --git a/arch/ia64/kernel/efi.c b/arch/ia64/kernel/efi.c</span>
<span class="p_header">index caae3f4e4341..300dac3702f1 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/efi.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/efi.c</span>
<span class="p_chunk">@@ -1178,7 +1178,7 @@</span> <span class="p_context"> efi_initialize_iomem_resources(struct resource *code_resource,</span>
 	efi_memory_desc_t *md;
 	u64 efi_desc_size;
 	char *name;
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	unsigned long flags, desc;</span>
 
 	efi_map_start = __va(ia64_boot_param-&gt;efi_memmap);
 	efi_map_end   = efi_map_start + ia64_boot_param-&gt;efi_memmap_size;
<span class="p_chunk">@@ -1193,6 +1193,8 @@</span> <span class="p_context"> efi_initialize_iomem_resources(struct resource *code_resource,</span>
 			continue;
 
 		flags = IORESOURCE_MEM | IORESOURCE_BUSY;
<span class="p_add">+		desc = IORES_DESC_NONE;</span>
<span class="p_add">+</span>
 		switch (md-&gt;type) {
 
 			case EFI_MEMORY_MAPPED_IO:
<span class="p_chunk">@@ -1207,14 +1209,17 @@</span> <span class="p_context"> efi_initialize_iomem_resources(struct resource *code_resource,</span>
 				if (md-&gt;attribute &amp; EFI_MEMORY_WP) {
 					name = &quot;System ROM&quot;;
 					flags |= IORESOURCE_READONLY;
<span class="p_del">-				} else if (md-&gt;attribute == EFI_MEMORY_UC)</span>
<span class="p_add">+				} else if (md-&gt;attribute == EFI_MEMORY_UC) {</span>
 					name = &quot;Uncached RAM&quot;;
<span class="p_del">-				else</span>
<span class="p_add">+				} else {</span>
 					name = &quot;System RAM&quot;;
<span class="p_add">+					flags |= IORESOURCE_SYSRAM;</span>
<span class="p_add">+				}</span>
 				break;
 
 			case EFI_ACPI_MEMORY_NVS:
 				name = &quot;ACPI Non-volatile Storage&quot;;
<span class="p_add">+				desc = IORES_DESC_ACPI_NV_STORAGE;</span>
 				break;
 
 			case EFI_UNUSABLE_MEMORY:
<span class="p_chunk">@@ -1224,6 +1229,7 @@</span> <span class="p_context"> efi_initialize_iomem_resources(struct resource *code_resource,</span>
 
 			case EFI_PERSISTENT_MEMORY:
 				name = &quot;Persistent Memory&quot;;
<span class="p_add">+				desc = IORES_DESC_PERSISTENT_MEMORY;</span>
 				break;
 
 			case EFI_RESERVED_TYPE:
<span class="p_chunk">@@ -1246,6 +1252,7 @@</span> <span class="p_context"> efi_initialize_iomem_resources(struct resource *code_resource,</span>
 		res-&gt;start = md-&gt;phys_addr;
 		res-&gt;end = md-&gt;phys_addr + efi_md_size(md) - 1;
 		res-&gt;flags = flags;
<span class="p_add">+		res-&gt;desc = desc;</span>
 
 		if (insert_resource(&amp;iomem_resource, res) &lt; 0)
 			kfree(res);
<span class="p_header">diff --git a/arch/ia64/kernel/setup.c b/arch/ia64/kernel/setup.c</span>
<span class="p_header">index 4f118b0d3091..2029a38a72ae 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/setup.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/setup.c</span>
<span class="p_chunk">@@ -80,17 +80,17 @@</span> <span class="p_context"> unsigned long vga_console_membase;</span>
 
 static struct resource data_resource = {
 	.name	= &quot;Kernel data&quot;,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 static struct resource code_resource = {
 	.name	= &quot;Kernel code&quot;,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 static struct resource bss_resource = {
 	.name	= &quot;Kernel bss&quot;,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 unsigned long ia64_max_cacheline_size;
<span class="p_header">diff --git a/arch/m32r/kernel/setup.c b/arch/m32r/kernel/setup.c</span>
<span class="p_header">index a5ecef7188ba..136c69f1fb8a 100644</span>
<span class="p_header">--- a/arch/m32r/kernel/setup.c</span>
<span class="p_header">+++ b/arch/m32r/kernel/setup.c</span>
<span class="p_chunk">@@ -70,14 +70,14 @@</span> <span class="p_context"> static struct resource data_resource = {</span>
 	.name   = &quot;Kernel data&quot;,
 	.start  = 0,
 	.end    = 0,
<span class="p_del">-	.flags  = IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags  = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 static struct resource code_resource = {
 	.name   = &quot;Kernel code&quot;,
 	.start  = 0,
 	.end    = 0,
<span class="p_del">-	.flags  = IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags  = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 unsigned long memory_start;
<span class="p_header">diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c</span>
<span class="p_header">index 5fdaf8bdcd2e..4f607341a793 100644</span>
<span class="p_header">--- a/arch/mips/kernel/setup.c</span>
<span class="p_header">+++ b/arch/mips/kernel/setup.c</span>
<span class="p_chunk">@@ -732,21 +732,23 @@</span> <span class="p_context"> static void __init resource_init(void)</span>
 			end = HIGHMEM_START - 1;
 
 		res = alloc_bootmem(sizeof(struct resource));
<span class="p_add">+</span>
<span class="p_add">+		res-&gt;start = start;</span>
<span class="p_add">+		res-&gt;end = end;</span>
<span class="p_add">+		res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+</span>
 		switch (boot_mem_map.map[i].type) {
 		case BOOT_MEM_RAM:
 		case BOOT_MEM_INIT_RAM:
 		case BOOT_MEM_ROM_DATA:
 			res-&gt;name = &quot;System RAM&quot;;
<span class="p_add">+			res-&gt;flags |= IORESOURCE_SYSRAM;</span>
 			break;
 		case BOOT_MEM_RESERVED:
 		default:
 			res-&gt;name = &quot;reserved&quot;;
 		}
 
<span class="p_del">-		res-&gt;start = start;</span>
<span class="p_del">-		res-&gt;end = end;</span>
<span class="p_del">-</span>
<span class="p_del">-		res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
 		request_resource(&amp;iomem_resource, res);
 
 		/*
<span class="p_header">diff --git a/arch/parisc/mm/init.c b/arch/parisc/mm/init.c</span>
<span class="p_header">index 1b366c477687..3c07d6b96877 100644</span>
<span class="p_header">--- a/arch/parisc/mm/init.c</span>
<span class="p_header">+++ b/arch/parisc/mm/init.c</span>
<span class="p_chunk">@@ -55,12 +55,12 @@</span> <span class="p_context"> signed char pfnnid_map[PFNNID_MAP_MAX] __read_mostly;</span>
 
 static struct resource data_resource = {
 	.name	= &quot;Kernel data&quot;,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM,</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
 };
 
 static struct resource code_resource = {
 	.name	= &quot;Kernel code&quot;,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM,</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
 };
 
 static struct resource pdcdata_resource = {
<span class="p_chunk">@@ -201,7 +201,7 @@</span> <span class="p_context"> static void __init setup_bootmem(void)</span>
 		res-&gt;name = &quot;System RAM&quot;;
 		res-&gt;start = pmem_ranges[i].start_pfn &lt;&lt; PAGE_SHIFT;
 		res-&gt;end = res-&gt;start + (pmem_ranges[i].pages &lt;&lt; PAGE_SHIFT)-1;
<span class="p_del">-		res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+		res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 		request_resource(&amp;iomem_resource, res);
 	}
 
<span class="p_header">diff --git a/arch/powerpc/mm/mem.c b/arch/powerpc/mm/mem.c</span>
<span class="p_header">index d0f0a514b04e..f078a1f94fc2 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/mem.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/mem.c</span>
<span class="p_chunk">@@ -541,7 +541,7 @@</span> <span class="p_context"> static int __init add_system_ram_resources(void)</span>
 			res-&gt;name = &quot;System RAM&quot;;
 			res-&gt;start = base;
 			res-&gt;end = base + size - 1;
<span class="p_del">-			res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+			res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 			WARN_ON(request_resource(&amp;iomem_resource, res) &lt; 0);
 		}
 	}
<span class="p_header">diff --git a/arch/s390/kernel/setup.c b/arch/s390/kernel/setup.c</span>
<span class="p_header">index 9220db5c996a..cedb0198675f 100644</span>
<span class="p_header">--- a/arch/s390/kernel/setup.c</span>
<span class="p_header">+++ b/arch/s390/kernel/setup.c</span>
<span class="p_chunk">@@ -374,17 +374,17 @@</span> <span class="p_context"> static void __init setup_lowcore(void)</span>
 
 static struct resource code_resource = {
 	.name  = &quot;Kernel code&quot;,
<span class="p_del">-	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,</span>
<span class="p_add">+	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
 };
 
 static struct resource data_resource = {
 	.name = &quot;Kernel data&quot;,
<span class="p_del">-	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,</span>
<span class="p_add">+	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
 };
 
 static struct resource bss_resource = {
 	.name = &quot;Kernel bss&quot;,
<span class="p_del">-	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,</span>
<span class="p_add">+	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
 };
 
 static struct resource __initdata *standard_resources[] = {
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> static void __init setup_resources(void)</span>
 
 	for_each_memblock(memory, reg) {
 		res = alloc_bootmem_low(sizeof(*res));
<span class="p_del">-		res-&gt;flags = IORESOURCE_BUSY | IORESOURCE_MEM;</span>
<span class="p_add">+		res-&gt;flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM;</span>
 
 		res-&gt;name = &quot;System RAM&quot;;
 		res-&gt;start = reg-&gt;base;
<span class="p_header">diff --git a/arch/score/kernel/setup.c b/arch/score/kernel/setup.c</span>
<span class="p_header">index b48459afefdd..f3a0649ab521 100644</span>
<span class="p_header">--- a/arch/score/kernel/setup.c</span>
<span class="p_header">+++ b/arch/score/kernel/setup.c</span>
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"> static void __init resource_init(void)</span>
 	res-&gt;name = &quot;System RAM&quot;;
 	res-&gt;start = MEMORY_START;
 	res-&gt;end = MEMORY_START + MEMORY_SIZE - 1;
<span class="p_del">-	res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+	res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 	request_resource(&amp;iomem_resource, res);
 
 	request_resource(res, &amp;code_resource);
<span class="p_header">diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c</span>
<span class="p_header">index de19cfa768f2..3f1c18b28e8a 100644</span>
<span class="p_header">--- a/arch/sh/kernel/setup.c</span>
<span class="p_header">+++ b/arch/sh/kernel/setup.c</span>
<span class="p_chunk">@@ -78,17 +78,17 @@</span> <span class="p_context"> static char __initdata command_line[COMMAND_LINE_SIZE] = { 0, };</span>
 
 static struct resource code_resource = {
 	.name = &quot;Kernel code&quot;,
<span class="p_del">-	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,</span>
<span class="p_add">+	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
 };
 
 static struct resource data_resource = {
 	.name = &quot;Kernel data&quot;,
<span class="p_del">-	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,</span>
<span class="p_add">+	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
 };
 
 static struct resource bss_resource = {
 	.name	= &quot;Kernel bss&quot;,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM,</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
 };
 
 unsigned long memory_start;
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> void __init __add_active_range(unsigned int nid, unsigned long start_pfn,</span>
 	res-&gt;name = &quot;System RAM&quot;;
 	res-&gt;start = start;
 	res-&gt;end = end - 1;
<span class="p_del">-	res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+	res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 
 	if (request_resource(&amp;iomem_resource, res)) {
 		pr_err(&quot;unable to request memory_resource 0x%lx 0x%lx\n&quot;,
<span class="p_header">diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c</span>
<span class="p_header">index 6f216853f272..1cfe6aab7a11 100644</span>
<span class="p_header">--- a/arch/sparc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/sparc/mm/init_64.c</span>
<span class="p_chunk">@@ -2863,17 +2863,17 @@</span> <span class="p_context"> void hugetlb_setup(struct pt_regs *regs)</span>
 
 static struct resource code_resource = {
 	.name	= &quot;Kernel code&quot;,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 static struct resource data_resource = {
 	.name	= &quot;Kernel data&quot;,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 static struct resource bss_resource = {
 	.name	= &quot;Kernel bss&quot;,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 static inline resource_size_t compute_kern_paddr(void *addr)
<span class="p_chunk">@@ -2909,7 +2909,7 @@</span> <span class="p_context"> static int __init report_memory(void)</span>
 		res-&gt;name = &quot;System RAM&quot;;
 		res-&gt;start = pavail[i].phys_addr;
 		res-&gt;end = pavail[i].phys_addr + pavail[i].reg_size - 1;
<span class="p_del">-		res-&gt;flags = IORESOURCE_BUSY | IORESOURCE_MEM;</span>
<span class="p_add">+		res-&gt;flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM;</span>
 
 		if (insert_resource(&amp;iomem_resource, res) &lt; 0) {
 			pr_warn(&quot;Resource insertion failed.\n&quot;);
<span class="p_header">diff --git a/arch/tile/kernel/setup.c b/arch/tile/kernel/setup.c</span>
<span class="p_header">index bbb855de6569..a992238e9b58 100644</span>
<span class="p_header">--- a/arch/tile/kernel/setup.c</span>
<span class="p_header">+++ b/arch/tile/kernel/setup.c</span>
<span class="p_chunk">@@ -1632,14 +1632,14 @@</span> <span class="p_context"> static struct resource data_resource = {</span>
 	.name	= &quot;Kernel data&quot;,
 	.start	= 0,
 	.end	= 0,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 static struct resource code_resource = {
 	.name	= &quot;Kernel code&quot;,
 	.start	= 0,
 	.end	= 0,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 /*
<span class="p_chunk">@@ -1673,10 +1673,15 @@</span> <span class="p_context"> insert_ram_resource(u64 start_pfn, u64 end_pfn, bool reserved)</span>
 		kzalloc(sizeof(struct resource), GFP_ATOMIC);
 	if (!res)
 		return NULL;
<span class="p_del">-	res-&gt;name = reserved ? &quot;Reserved&quot; : &quot;System RAM&quot;;</span>
 	res-&gt;start = start_pfn &lt;&lt; PAGE_SHIFT;
 	res-&gt;end = (end_pfn &lt;&lt; PAGE_SHIFT) - 1;
 	res-&gt;flags = IORESOURCE_BUSY | IORESOURCE_MEM;
<span class="p_add">+	if (reserved) {</span>
<span class="p_add">+		res-&gt;name = &quot;Reserved&quot;;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		res-&gt;name = &quot;System RAM&quot;;</span>
<span class="p_add">+		res-&gt;flags |= IORESOURCE_SYSRAM;</span>
<span class="p_add">+	}</span>
 	if (insert_resource(&amp;iomem_resource, res)) {
 		kfree(res);
 		return NULL;
<span class="p_header">diff --git a/arch/unicore32/kernel/setup.c b/arch/unicore32/kernel/setup.c</span>
<span class="p_header">index 3fa317f96122..c2bffa5614a4 100644</span>
<span class="p_header">--- a/arch/unicore32/kernel/setup.c</span>
<span class="p_header">+++ b/arch/unicore32/kernel/setup.c</span>
<span class="p_chunk">@@ -72,13 +72,13 @@</span> <span class="p_context"> static struct resource mem_res[] = {</span>
 		.name = &quot;Kernel code&quot;,
 		.start = 0,
 		.end = 0,
<span class="p_del">-		.flags = IORESOURCE_MEM</span>
<span class="p_add">+		.flags = IORESOURCE_SYSTEM_RAM</span>
 	},
 	{
 		.name = &quot;Kernel data&quot;,
 		.start = 0,
 		.end = 0,
<span class="p_del">-		.flags = IORESOURCE_MEM</span>
<span class="p_add">+		.flags = IORESOURCE_SYSTEM_RAM</span>
 	}
 };
 
<span class="p_chunk">@@ -211,7 +211,7 @@</span> <span class="p_context"> request_standard_resources(struct meminfo *mi)</span>
 		res-&gt;name  = &quot;System RAM&quot;;
 		res-&gt;start = mi-&gt;bank[i].start;
 		res-&gt;end   = mi-&gt;bank[i].start + mi-&gt;bank[i].size - 1;
<span class="p_del">-		res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+		res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 
 		request_resource(&amp;iomem_resource, res);
 
<span class="p_header">diff --git a/arch/x86/kernel/crash.c b/arch/x86/kernel/crash.c</span>
<span class="p_header">index 58f34319b29a..9ef978d69c22 100644</span>
<span class="p_header">--- a/arch/x86/kernel/crash.c</span>
<span class="p_header">+++ b/arch/x86/kernel/crash.c</span>
<span class="p_chunk">@@ -57,10 +57,9 @@</span> <span class="p_context"> struct crash_elf_data {</span>
 	struct kimage *image;
 	/*
 	 * Total number of ram ranges we have after various adjustments for
<span class="p_del">-	 * GART, crash reserved region etc.</span>
<span class="p_add">+	 * crash reserved region, etc.</span>
 	 */
 	unsigned int max_nr_ranges;
<span class="p_del">-	unsigned long gart_start, gart_end;</span>
 
 	/* Pointer to elf header */
 	void *ehdr;
<span class="p_chunk">@@ -201,17 +200,6 @@</span> <span class="p_context"> static int get_nr_ram_ranges_callback(u64 start, u64 end, void *arg)</span>
 	return 0;
 }
 
<span class="p_del">-static int get_gart_ranges_callback(u64 start, u64 end, void *arg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct crash_elf_data *ced = arg;</span>
<span class="p_del">-</span>
<span class="p_del">-	ced-&gt;gart_start = start;</span>
<span class="p_del">-	ced-&gt;gart_end = end;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Not expecting more than 1 gart aperture */</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 
 /* Gather all the required information to prepare elf headers for ram regions */
 static void fill_up_crash_elf_data(struct crash_elf_data *ced,
<span class="p_chunk">@@ -226,22 +214,6 @@</span> <span class="p_context"> static void fill_up_crash_elf_data(struct crash_elf_data *ced,</span>
 
 	ced-&gt;max_nr_ranges = nr_ranges;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We don&#39;t create ELF headers for GART aperture as an attempt</span>
<span class="p_del">-	 * to dump this memory in second kernel leads to hang/crash.</span>
<span class="p_del">-	 * If gart aperture is present, one needs to exclude that region</span>
<span class="p_del">-	 * and that could lead to need of extra phdr.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	walk_iomem_res(&quot;GART&quot;, IORESOURCE_MEM, 0, -1,</span>
<span class="p_del">-				ced, get_gart_ranges_callback);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If we have gart region, excluding that could potentially split</span>
<span class="p_del">-	 * a memory range, resulting in extra header. Account for  that.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (ced-&gt;gart_end)</span>
<span class="p_del">-		ced-&gt;max_nr_ranges++;</span>
<span class="p_del">-</span>
 	/* Exclusion of crash region could split memory ranges */
 	ced-&gt;max_nr_ranges++;
 
<span class="p_chunk">@@ -350,13 +322,6 @@</span> <span class="p_context"> static int elf_header_exclude_ranges(struct crash_elf_data *ced,</span>
 			return ret;
 	}
 
<span class="p_del">-	/* Exclude GART region */</span>
<span class="p_del">-	if (ced-&gt;gart_end) {</span>
<span class="p_del">-		ret = exclude_mem_range(cmem, ced-&gt;gart_start, ced-&gt;gart_end);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -599,12 +564,12 @@</span> <span class="p_context"> int crash_setup_memmap_entries(struct kimage *image, struct boot_params *params)</span>
 	/* Add ACPI tables */
 	cmd.type = E820_ACPI;
 	flags = IORESOURCE_MEM | IORESOURCE_BUSY;
<span class="p_del">-	walk_iomem_res(&quot;ACPI Tables&quot;, flags, 0, -1, &amp;cmd,</span>
<span class="p_add">+	walk_iomem_res_desc(IORES_DESC_ACPI_TABLES, flags, 0, -1, &amp;cmd,</span>
 		       memmap_entry_callback);
 
 	/* Add ACPI Non-volatile Storage */
 	cmd.type = E820_NVS;
<span class="p_del">-	walk_iomem_res(&quot;ACPI Non-volatile Storage&quot;, flags, 0, -1, &amp;cmd,</span>
<span class="p_add">+	walk_iomem_res_desc(IORES_DESC_ACPI_NV_STORAGE, flags, 0, -1, &amp;cmd,</span>
 			memmap_entry_callback);
 
 	/* Add crashk_low_res region */
<span class="p_header">diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c</span>
<span class="p_header">index 569c1e4f96fe..837365f10912 100644</span>
<span class="p_header">--- a/arch/x86/kernel/e820.c</span>
<span class="p_header">+++ b/arch/x86/kernel/e820.c</span>
<span class="p_chunk">@@ -925,6 +925,41 @@</span> <span class="p_context"> static const char *e820_type_to_string(int e820_type)</span>
 	}
 }
 
<span class="p_add">+static unsigned long e820_type_to_iomem_type(int e820_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (e820_type) {</span>
<span class="p_add">+	case E820_RESERVED_KERN:</span>
<span class="p_add">+	case E820_RAM:</span>
<span class="p_add">+		return IORESOURCE_SYSTEM_RAM;</span>
<span class="p_add">+	case E820_ACPI:</span>
<span class="p_add">+	case E820_NVS:</span>
<span class="p_add">+	case E820_UNUSABLE:</span>
<span class="p_add">+	case E820_PRAM:</span>
<span class="p_add">+	case E820_PMEM:</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return IORESOURCE_MEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long e820_type_to_iores_desc(int e820_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (e820_type) {</span>
<span class="p_add">+	case E820_ACPI:</span>
<span class="p_add">+		return IORES_DESC_ACPI_TABLES;</span>
<span class="p_add">+	case E820_NVS:</span>
<span class="p_add">+		return IORES_DESC_ACPI_NV_STORAGE;</span>
<span class="p_add">+	case E820_PMEM:</span>
<span class="p_add">+		return IORES_DESC_PERSISTENT_MEMORY;</span>
<span class="p_add">+	case E820_PRAM:</span>
<span class="p_add">+		return IORES_DESC_PERSISTENT_MEMORY_LEGACY;</span>
<span class="p_add">+	case E820_RESERVED_KERN:</span>
<span class="p_add">+	case E820_RAM:</span>
<span class="p_add">+	case E820_UNUSABLE:</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return IORES_DESC_NONE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool do_mark_busy(u32 type, struct resource *res)
 {
 	/* this is the legacy bios/dos rom-shadow + mmio region */
<span class="p_chunk">@@ -967,7 +1002,8 @@</span> <span class="p_context"> void __init e820_reserve_resources(void)</span>
 		res-&gt;start = e820.map[i].addr;
 		res-&gt;end = end;
 
<span class="p_del">-		res-&gt;flags = IORESOURCE_MEM;</span>
<span class="p_add">+		res-&gt;flags = e820_type_to_iomem_type(e820.map[i].type);</span>
<span class="p_add">+		res-&gt;desc = e820_type_to_iores_desc(e820.map[i].type);</span>
 
 		/*
 		 * don&#39;t register the region that could be conflicted with
<span class="p_header">diff --git a/arch/x86/kernel/pmem.c b/arch/x86/kernel/pmem.c</span>
<span class="p_header">index 14415aff1813..92f70147a9a6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pmem.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pmem.c</span>
<span class="p_chunk">@@ -13,11 +13,11 @@</span> <span class="p_context"> static int found(u64 start, u64 end, void *data)</span>
 
 static __init int register_e820_pmem(void)
 {
<span class="p_del">-	char *pmem = &quot;Persistent Memory (legacy)&quot;;</span>
 	struct platform_device *pdev;
 	int rc;
 
<span class="p_del">-	rc = walk_iomem_res(pmem, IORESOURCE_MEM, 0, -1, NULL, found);</span>
<span class="p_add">+	rc = walk_iomem_res_desc(IORES_DESC_PERSISTENT_MEMORY_LEGACY,</span>
<span class="p_add">+				 IORESOURCE_MEM, 0, -1, NULL, found);</span>
 	if (rc &lt;= 0)
 		return 0;
 
<span class="p_header">diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c</span>
<span class="p_header">index d3d80e6d42a2..aa52c1009475 100644</span>
<span class="p_header">--- a/arch/x86/kernel/setup.c</span>
<span class="p_header">+++ b/arch/x86/kernel/setup.c</span>
<span class="p_chunk">@@ -152,21 +152,21 @@</span> <span class="p_context"> static struct resource data_resource = {</span>
 	.name	= &quot;Kernel data&quot;,
 	.start	= 0,
 	.end	= 0,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 static struct resource code_resource = {
 	.name	= &quot;Kernel code&quot;,
 	.start	= 0,
 	.end	= 0,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 static struct resource bss_resource = {
 	.name	= &quot;Kernel bss&quot;,
 	.start	= 0,
 	.end	= 0,
<span class="p_del">-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM</span>
 };
 
 
<span class="p_header">diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c</span>
<span class="p_header">index 296b7a14893a..b6f7fa3a1d40 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_platform.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_platform.c</span>
<span class="p_chunk">@@ -62,7 +62,7 @@</span> <span class="p_context"> struct platform_device *acpi_create_platform_device(struct acpi_device *adev)</span>
 	if (count &lt; 0) {
 		return NULL;
 	} else if (count &gt; 0) {
<span class="p_del">-		resources = kmalloc(count * sizeof(struct resource),</span>
<span class="p_add">+		resources = kzalloc(count * sizeof(struct resource),</span>
 				    GFP_KERNEL);
 		if (!resources) {
 			dev_err(&amp;adev-&gt;dev, &quot;No memory for resources\n&quot;);
<span class="p_header">diff --git a/drivers/acpi/apei/einj.c b/drivers/acpi/apei/einj.c</span>
<span class="p_header">index 0431883653be..559c1173de1c 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/einj.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/einj.c</span>
<span class="p_chunk">@@ -519,7 +519,7 @@</span> <span class="p_context"> static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,</span>
 			     u64 param3, u64 param4)
 {
 	int rc;
<span class="p_del">-	unsigned long pfn;</span>
<span class="p_add">+	u64 base_addr, size;</span>
 
 	/* If user manually set &quot;flags&quot;, make sure it is legal */
 	if (flags &amp;&amp; (flags &amp;
<span class="p_chunk">@@ -545,10 +545,17 @@</span> <span class="p_context"> static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,</span>
 	/*
 	 * Disallow crazy address masks that give BIOS leeway to pick
 	 * injection address almost anywhere. Insist on page or
<span class="p_del">-	 * better granularity and that target address is normal RAM.</span>
<span class="p_add">+	 * better granularity and that target address is normal RAM or</span>
<span class="p_add">+	 * NVDIMM.</span>
 	 */
<span class="p_del">-	pfn = PFN_DOWN(param1 &amp; param2);</span>
<span class="p_del">-	if (!page_is_ram(pfn) || ((param2 &amp; PAGE_MASK) != PAGE_MASK))</span>
<span class="p_add">+	base_addr = param1 &amp; param2;</span>
<span class="p_add">+	size = ~param2 + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (((param2 &amp; PAGE_MASK) != PAGE_MASK) ||</span>
<span class="p_add">+	    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)</span>
<span class="p_add">+				!= REGION_INTERSECTS) &amp;&amp;</span>
<span class="p_add">+	     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)</span>
<span class="p_add">+				!= REGION_INTERSECTS)))</span>
 		return -EINVAL;
 
 inject:
<span class="p_header">diff --git a/drivers/nvdimm/e820.c b/drivers/nvdimm/e820.c</span>
<span class="p_header">index b0045a505dc8..95825b38559a 100644</span>
<span class="p_header">--- a/drivers/nvdimm/e820.c</span>
<span class="p_header">+++ b/drivers/nvdimm/e820.c</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> static int e820_pmem_probe(struct platform_device *pdev)</span>
 	for (p = iomem_resource.child; p ; p = p-&gt;sibling) {
 		struct nd_region_desc ndr_desc;
 
<span class="p_del">-		if (strncmp(p-&gt;name, &quot;Persistent Memory (legacy)&quot;, 26) != 0)</span>
<span class="p_add">+		if (p-&gt;desc != IORES_DESC_PERSISTENT_MEMORY_LEGACY)</span>
 			continue;
 
 		memset(&amp;ndr_desc, 0, sizeof(ndr_desc));
<span class="p_header">diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c</span>
<span class="p_header">index a656d9e83343..21905fef2cbf 100644</span>
<span class="p_header">--- a/drivers/parisc/eisa_enumerator.c</span>
<span class="p_header">+++ b/drivers/parisc/eisa_enumerator.c</span>
<span class="p_chunk">@@ -91,7 +91,7 @@</span> <span class="p_context"> static int configure_memory(const unsigned char *buf,</span>
 	for (i=0;i&lt;HPEE_MEMORY_MAX_ENT;i++) {
 		c = get_8(buf+len);
 		
<span class="p_del">-		if (NULL != (res = kmalloc(sizeof(struct resource), GFP_KERNEL))) {</span>
<span class="p_add">+		if (NULL != (res = kzalloc(sizeof(struct resource), GFP_KERNEL))) {</span>
 			int result;
 			
 			res-&gt;name = name;
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static int configure_port(const unsigned char *buf, struct resource *io_parent,</span>
 	for (i=0;i&lt;HPEE_PORT_MAX_ENT;i++) {
 		c = get_8(buf+len);
 		
<span class="p_del">-		if (NULL != (res = kmalloc(sizeof(struct resource), GFP_KERNEL))) {</span>
<span class="p_add">+		if (NULL != (res = kzalloc(sizeof(struct resource), GFP_KERNEL))) {</span>
 			res-&gt;name = board;
 			res-&gt;start = get_16(buf+len+1);
 			res-&gt;end = get_16(buf+len+1)+(c&amp;HPEE_PORT_SIZE_MASK)+1;
<span class="p_header">diff --git a/drivers/rapidio/rio.c b/drivers/rapidio/rio.c</span>
<span class="p_header">index d7b87c64b7cd..e220edc85c68 100644</span>
<span class="p_header">--- a/drivers/rapidio/rio.c</span>
<span class="p_header">+++ b/drivers/rapidio/rio.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> int rio_request_inb_mbox(struct rio_mport *mport,</span>
 	if (mport-&gt;ops-&gt;open_inb_mbox == NULL)
 		goto out;
 
<span class="p_del">-	res = kmalloc(sizeof(struct resource), GFP_KERNEL);</span>
<span class="p_add">+	res = kzalloc(sizeof(struct resource), GFP_KERNEL);</span>
 
 	if (res) {
 		rio_init_mbox_res(res, mbox, mbox);
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"> int rio_request_outb_mbox(struct rio_mport *mport,</span>
 	if (mport-&gt;ops-&gt;open_outb_mbox == NULL)
 		goto out;
 
<span class="p_del">-	res = kmalloc(sizeof(struct resource), GFP_KERNEL);</span>
<span class="p_add">+	res = kzalloc(sizeof(struct resource), GFP_KERNEL);</span>
 
 	if (res) {
 		rio_init_mbox_res(res, mbox, mbox);
<span class="p_chunk">@@ -285,7 +285,7 @@</span> <span class="p_context"> int rio_request_inb_dbell(struct rio_mport *mport,</span>
 {
 	int rc = 0;
 
<span class="p_del">-	struct resource *res = kmalloc(sizeof(struct resource), GFP_KERNEL);</span>
<span class="p_add">+	struct resource *res = kzalloc(sizeof(struct resource), GFP_KERNEL);</span>
 
 	if (res) {
 		rio_init_dbell_res(res, start, end);
<span class="p_chunk">@@ -360,7 +360,7 @@</span> <span class="p_context"> int rio_release_inb_dbell(struct rio_mport *mport, u16 start, u16 end)</span>
 struct resource *rio_request_outb_dbell(struct rio_dev *rdev, u16 start,
 					u16 end)
 {
<span class="p_del">-	struct resource *res = kmalloc(sizeof(struct resource), GFP_KERNEL);</span>
<span class="p_add">+	struct resource *res = kzalloc(sizeof(struct resource), GFP_KERNEL);</span>
 
 	if (res) {
 		rio_init_dbell_res(res, start, end);
<span class="p_header">diff --git a/drivers/sh/superhyway/superhyway.c b/drivers/sh/superhyway/superhyway.c</span>
<span class="p_header">index 2d9e7f3d5611..bb1fb7712134 100644</span>
<span class="p_header">--- a/drivers/sh/superhyway/superhyway.c</span>
<span class="p_header">+++ b/drivers/sh/superhyway/superhyway.c</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> int superhyway_add_device(unsigned long base, struct superhyway_device *sdev,</span>
 	superhyway_read_vcr(dev, base, &amp;dev-&gt;vcr);
 
 	if (!dev-&gt;resource) {
<span class="p_del">-		dev-&gt;resource = kmalloc(sizeof(struct resource), GFP_KERNEL);</span>
<span class="p_add">+		dev-&gt;resource = kzalloc(sizeof(struct resource), GFP_KERNEL);</span>
 		if (!dev-&gt;resource) {
 			kfree(dev);
 			return -ENOMEM;
<span class="p_header">diff --git a/drivers/xen/balloon.c b/drivers/xen/balloon.c</span>
<span class="p_header">index 12eab503efd1..dc4305b407bf 100644</span>
<span class="p_header">--- a/drivers/xen/balloon.c</span>
<span class="p_header">+++ b/drivers/xen/balloon.c</span>
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> static struct resource *additional_memory_resource(phys_addr_t size)</span>
 		return NULL;
 
 	res-&gt;name = &quot;System RAM&quot;;
<span class="p_del">-	res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+	res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 
 	ret = allocate_resource(&amp;iomem_resource, res,
 				size, 0, -1,
<span class="p_header">diff --git a/include/linux/ioport.h b/include/linux/ioport.h</span>
<span class="p_header">index 24bea087e7af..afb45597fb5f 100644</span>
<span class="p_header">--- a/include/linux/ioport.h</span>
<span class="p_header">+++ b/include/linux/ioport.h</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"> struct resource {</span>
 	resource_size_t end;
 	const char *name;
 	unsigned long flags;
<span class="p_add">+	unsigned long desc;</span>
 	struct resource *parent, *sibling, *child;
 };
 
<span class="p_chunk">@@ -49,12 +50,19 @@</span> <span class="p_context"> struct resource {</span>
 #define IORESOURCE_WINDOW	0x00200000	/* forwarded by bridge */
 #define IORESOURCE_MUXED	0x00400000	/* Resource is software muxed */
 
<span class="p_add">+#define IORESOURCE_EXT_TYPE_BITS 0x01000000	/* Resource extended types */</span>
<span class="p_add">+#define IORESOURCE_SYSRAM	0x01000000	/* System RAM (modifier) */</span>
<span class="p_add">+</span>
 #define IORESOURCE_EXCLUSIVE	0x08000000	/* Userland may not map this resource */
<span class="p_add">+</span>
 #define IORESOURCE_DISABLED	0x10000000
 #define IORESOURCE_UNSET	0x20000000	/* No address assigned yet */
 #define IORESOURCE_AUTO		0x40000000
 #define IORESOURCE_BUSY		0x80000000	/* Driver has marked this resource busy */
 
<span class="p_add">+/* I/O resource extended types */</span>
<span class="p_add">+#define IORESOURCE_SYSTEM_RAM		(IORESOURCE_MEM|IORESOURCE_SYSRAM)</span>
<span class="p_add">+</span>
 /* PnP IRQ specific bits (IORESOURCE_BITS) */
 #define IORESOURCE_IRQ_HIGHEDGE		(1&lt;&lt;0)
 #define IORESOURCE_IRQ_LOWEDGE		(1&lt;&lt;1)
<span class="p_chunk">@@ -105,6 +113,22 @@</span> <span class="p_context"> struct resource {</span>
 /* PCI control bits.  Shares IORESOURCE_BITS with above PCI ROM.  */
 #define IORESOURCE_PCI_FIXED		(1&lt;&lt;4)	/* Do not move resource */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * I/O Resource Descriptors</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Descriptors are used by walk_iomem_res_desc() and region_intersects()</span>
<span class="p_add">+ * for searching a specific resource range in the iomem table.  Assign</span>
<span class="p_add">+ * a new descriptor when a resource range supports the search interfaces.</span>
<span class="p_add">+ * Otherwise, resource.desc must be set to IORES_DESC_NONE (0).</span>
<span class="p_add">+ */</span>
<span class="p_add">+enum {</span>
<span class="p_add">+	IORES_DESC_NONE				= 0,</span>
<span class="p_add">+	IORES_DESC_CRASH_KERNEL			= 1,</span>
<span class="p_add">+	IORES_DESC_ACPI_TABLES			= 2,</span>
<span class="p_add">+	IORES_DESC_ACPI_NV_STORAGE		= 3,</span>
<span class="p_add">+	IORES_DESC_PERSISTENT_MEMORY		= 4,</span>
<span class="p_add">+	IORES_DESC_PERSISTENT_MEMORY_LEGACY	= 5,</span>
<span class="p_add">+};</span>
 
 /* helpers to define resources */
 #define DEFINE_RES_NAMED(_start, _size, _name, _flags)			\
<span class="p_chunk">@@ -113,6 +137,7 @@</span> <span class="p_context"> struct resource {</span>
 		.end = (_start) + (_size) - 1,				\
 		.name = (_name),					\
 		.flags = (_flags),					\
<span class="p_add">+		.desc = IORES_DESC_NONE,				\</span>
 	}
 
 #define DEFINE_RES_IO_NAMED(_start, _size, _name)			\
<span class="p_chunk">@@ -170,6 +195,10 @@</span> <span class="p_context"> static inline unsigned long resource_type(const struct resource *res)</span>
 {
 	return res-&gt;flags &amp; IORESOURCE_TYPE_BITS;
 }
<span class="p_add">+static inline unsigned long resource_ext_type(const struct resource *res)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return res-&gt;flags &amp; IORESOURCE_EXT_TYPE_BITS;</span>
<span class="p_add">+}</span>
 /* True iff r1 completely contains r2 */
 static inline bool resource_contains(struct resource *r1, struct resource *r2)
 {
<span class="p_chunk">@@ -239,8 +268,8 @@</span> <span class="p_context"> extern int</span>
 walk_system_ram_res(u64 start, u64 end, void *arg,
 		    int (*func)(u64, u64, void *));
 extern int
<span class="p_del">-walk_iomem_res(char *name, unsigned long flags, u64 start, u64 end, void *arg,</span>
<span class="p_del">-	       int (*func)(u64, u64, void *));</span>
<span class="p_add">+walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start, u64 end,</span>
<span class="p_add">+		    void *arg, int (*func)(u64, u64, void *));</span>
 
 /* True if any part of r1 overlaps r2 */
 static inline bool resource_overlaps(struct resource *r1, struct resource *r2)
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 516e14944339..2b6e22782699 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -387,7 +387,8 @@</span> <span class="p_context"> enum {</span>
 	REGION_MIXED,
 };
 
<span class="p_del">-int region_intersects(resource_size_t offset, size_t size, const char *type);</span>
<span class="p_add">+int region_intersects(resource_size_t offset, size_t size, unsigned long flags,</span>
<span class="p_add">+		      unsigned long desc);</span>
 
 /* Support for virtually mapped pages */
 struct page *vmalloc_to_page(const void *addr);
<span class="p_header">diff --git a/kernel/kexec_core.c b/kernel/kexec_core.c</span>
<span class="p_header">index 8dc659144869..8d34308ea449 100644</span>
<span class="p_header">--- a/kernel/kexec_core.c</span>
<span class="p_header">+++ b/kernel/kexec_core.c</span>
<span class="p_chunk">@@ -66,13 +66,15 @@</span> <span class="p_context"> struct resource crashk_res = {</span>
 	.name  = &quot;Crash kernel&quot;,
 	.start = 0,
 	.end   = 0,
<span class="p_del">-	.flags = IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
<span class="p_add">+	.desc  = IORES_DESC_CRASH_KERNEL</span>
 };
 struct resource crashk_low_res = {
 	.name  = &quot;Crash kernel&quot;,
 	.start = 0,
 	.end   = 0,
<span class="p_del">-	.flags = IORESOURCE_BUSY | IORESOURCE_MEM</span>
<span class="p_add">+	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,</span>
<span class="p_add">+	.desc  = IORES_DESC_CRASH_KERNEL</span>
 };
 
 int kexec_should_crash(struct task_struct *p)
<span class="p_chunk">@@ -959,7 +961,7 @@</span> <span class="p_context"> int crash_shrink_memory(unsigned long new_size)</span>
 
 	ram_res-&gt;start = end;
 	ram_res-&gt;end = crashk_res.end;
<span class="p_del">-	ram_res-&gt;flags = IORESOURCE_BUSY | IORESOURCE_MEM;</span>
<span class="p_add">+	ram_res-&gt;flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM;</span>
 	ram_res-&gt;name = &quot;System RAM&quot;;
 
 	crashk_res.end = end - 1;
<span class="p_header">diff --git a/kernel/kexec_file.c b/kernel/kexec_file.c</span>
<span class="p_header">index 007b791f676d..56b18eb1f001 100644</span>
<span class="p_header">--- a/kernel/kexec_file.c</span>
<span class="p_header">+++ b/kernel/kexec_file.c</span>
<span class="p_chunk">@@ -524,10 +524,10 @@</span> <span class="p_context"> int kexec_add_buffer(struct kimage *image, char *buffer, unsigned long bufsz,</span>
 
 	/* Walk the RAM ranges and allocate a suitable range for the buffer */
 	if (image-&gt;type == KEXEC_TYPE_CRASH)
<span class="p_del">-		ret = walk_iomem_res(&quot;Crash kernel&quot;,</span>
<span class="p_del">-				     IORESOURCE_MEM | IORESOURCE_BUSY,</span>
<span class="p_del">-				     crashk_res.start, crashk_res.end, kbuf,</span>
<span class="p_del">-				     locate_mem_hole_callback);</span>
<span class="p_add">+		ret = walk_iomem_res_desc(crashk_res.desc,</span>
<span class="p_add">+				IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,</span>
<span class="p_add">+				crashk_res.start, crashk_res.end, kbuf,</span>
<span class="p_add">+				locate_mem_hole_callback);</span>
 	else
 		ret = walk_system_ram_res(0, -1, kbuf,
 					  locate_mem_hole_callback);
<span class="p_header">diff --git a/kernel/memremap.c b/kernel/memremap.c</span>
<span class="p_header">index b981a7b023f0..97b31c774274 100644</span>
<span class="p_header">--- a/kernel/memremap.c</span>
<span class="p_header">+++ b/kernel/memremap.c</span>
<span class="p_chunk">@@ -47,7 +47,7 @@</span> <span class="p_context"> static void *try_ram_remap(resource_size_t offset, size_t size)</span>
  * being mapped does not have i/o side effects and the __iomem
  * annotation is not applicable.
  *
<span class="p_del">- * MEMREMAP_WB - matches the default mapping for &quot;System RAM&quot; on</span>
<span class="p_add">+ * MEMREMAP_WB - matches the default mapping for System RAM on</span>
  * the architecture.  This is usually a read-allocate write-back cache.
  * Morever, if MEMREMAP_WB is specified and the requested remap region is RAM
  * memremap() will bypass establishing a new mapping and instead return
<span class="p_chunk">@@ -56,11 +56,12 @@</span> <span class="p_context"> static void *try_ram_remap(resource_size_t offset, size_t size)</span>
  * MEMREMAP_WT - establish a mapping whereby writes either bypass the
  * cache or are written through to memory and never exist in a
  * cache-dirty state with respect to program visibility.  Attempts to
<span class="p_del">- * map &quot;System RAM&quot; with this mapping type will fail.</span>
<span class="p_add">+ * map System RAM with this mapping type will fail.</span>
  */
 void *memremap(resource_size_t offset, size_t size, unsigned long flags)
 {
<span class="p_del">-	int is_ram = region_intersects(offset, size, &quot;System RAM&quot;);</span>
<span class="p_add">+	int is_ram = region_intersects(offset, size,</span>
<span class="p_add">+				       IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);</span>
 	void *addr = NULL;
 
 	if (is_ram == REGION_MIXED) {
<span class="p_chunk">@@ -76,7 +77,7 @@</span> <span class="p_context"> void *memremap(resource_size_t offset, size_t size, unsigned long flags)</span>
 		 * MEMREMAP_WB is special in that it can be satisifed
 		 * from the direct map.  Some archs depend on the
 		 * capability of memremap() to autodetect cases where
<span class="p_del">-		 * the requested range is potentially in &quot;System RAM&quot;</span>
<span class="p_add">+		 * the requested range is potentially in System RAM.</span>
 		 */
 		if (is_ram == REGION_INTERSECTS)
 			addr = try_ram_remap(offset, size);
<span class="p_chunk">@@ -88,7 +89,7 @@</span> <span class="p_context"> void *memremap(resource_size_t offset, size_t size, unsigned long flags)</span>
 	 * If we don&#39;t have a mapping yet and more request flags are
 	 * pending then we will be attempting to establish a new virtual
 	 * address mapping.  Enforce that this mapping is not aliasing
<span class="p_del">-	 * &quot;System RAM&quot;</span>
<span class="p_add">+	 * System RAM.</span>
 	 */
 	if (!addr &amp;&amp; is_ram == REGION_INTERSECTS &amp;&amp; flags) {
 		WARN_ONCE(1, &quot;memremap attempted on ram %pa size: %#lx\n&quot;,
<span class="p_chunk">@@ -271,7 +272,7 @@</span> <span class="p_context"> void *devm_memremap_pages(struct device *dev, struct resource *res,</span>
 		struct percpu_ref *ref, struct vmem_altmap *altmap)
 {
 	int is_ram = region_intersects(res-&gt;start, resource_size(res),
<span class="p_del">-			&quot;System RAM&quot;);</span>
<span class="p_add">+				       IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);</span>
 	resource_size_t key, align_start, align_size, align_end;
 	struct dev_pagemap *pgmap;
 	struct page_map *page_map;
<span class="p_header">diff --git a/kernel/resource.c b/kernel/resource.c</span>
<span class="p_header">index 3669d1bfc425..4d466052426b 100644</span>
<span class="p_header">--- a/kernel/resource.c</span>
<span class="p_header">+++ b/kernel/resource.c</span>
<span class="p_chunk">@@ -333,13 +333,13 @@</span> <span class="p_context"> int release_resource(struct resource *old)</span>
 EXPORT_SYMBOL(release_resource);
 
 /*
<span class="p_del">- * Finds the lowest iomem reosurce exists with-in [res-&gt;start.res-&gt;end)</span>
<span class="p_del">- * the caller must specify res-&gt;start, res-&gt;end, res-&gt;flags and &quot;name&quot;.</span>
<span class="p_del">- * If found, returns 0, res is overwritten, if not found, returns -1.</span>
<span class="p_del">- * This walks through whole tree and not just first level children</span>
<span class="p_del">- * until and unless first_level_children_only is true.</span>
<span class="p_add">+ * Finds the lowest iomem resource existing within [res-&gt;start.res-&gt;end).</span>
<span class="p_add">+ * The caller must specify res-&gt;start, res-&gt;end, res-&gt;flags, and optionally</span>
<span class="p_add">+ * desc.  If found, returns 0, res is overwritten, if not found, returns -1.</span>
<span class="p_add">+ * This function walks the whole tree and not just first level children until</span>
<span class="p_add">+ * and unless first_level_children_only is true.</span>
  */
<span class="p_del">-static int find_next_iomem_res(struct resource *res, char *name,</span>
<span class="p_add">+static int find_next_iomem_res(struct resource *res, unsigned long desc,</span>
 			       bool first_level_children_only)
 {
 	resource_size_t start, end;
<span class="p_chunk">@@ -358,9 +358,9 @@</span> <span class="p_context"> static int find_next_iomem_res(struct resource *res, char *name,</span>
 	read_lock(&amp;resource_lock);
 
 	for (p = iomem_resource.child; p; p = next_resource(p, sibling_only)) {
<span class="p_del">-		if (p-&gt;flags != res-&gt;flags)</span>
<span class="p_add">+		if ((p-&gt;flags &amp; res-&gt;flags) != res-&gt;flags)</span>
 			continue;
<span class="p_del">-		if (name &amp;&amp; strcmp(p-&gt;name, name))</span>
<span class="p_add">+		if ((desc != IORES_DESC_NONE) &amp;&amp; (desc != p-&gt;desc))</span>
 			continue;
 		if (p-&gt;start &gt; end) {
 			p = NULL;
<span class="p_chunk">@@ -385,15 +385,18 @@</span> <span class="p_context"> static int find_next_iomem_res(struct resource *res, char *name,</span>
  * Walks through iomem resources and calls func() with matching resource
  * ranges. This walks through whole tree and not just first level children.
  * All the memory ranges which overlap start,end and also match flags and
<span class="p_del">- * name are valid candidates.</span>
<span class="p_add">+ * desc are valid candidates.</span>
  *
<span class="p_del">- * @name: name of resource</span>
<span class="p_del">- * @flags: resource flags</span>
<span class="p_add">+ * @desc: I/O resource descriptor. Use IORES_DESC_NONE to skip @desc check.</span>
<span class="p_add">+ * @flags: I/O resource flags</span>
  * @start: start addr
  * @end: end addr
<span class="p_add">+ *</span>
<span class="p_add">+ * NOTE: For a new descriptor search, define a new IORES_DESC in</span>
<span class="p_add">+ * &lt;linux/ioport.h&gt; and set it in &#39;desc&#39; of a target resource entry.</span>
  */
<span class="p_del">-int walk_iomem_res(char *name, unsigned long flags, u64 start, u64 end,</span>
<span class="p_del">-		void *arg, int (*func)(u64, u64, void *))</span>
<span class="p_add">+int walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,</span>
<span class="p_add">+		u64 end, void *arg, int (*func)(u64, u64, void *))</span>
 {
 	struct resource res;
 	u64 orig_end;
<span class="p_chunk">@@ -403,23 +406,27 @@</span> <span class="p_context"> int walk_iomem_res(char *name, unsigned long flags, u64 start, u64 end,</span>
 	res.end = end;
 	res.flags = flags;
 	orig_end = res.end;
<span class="p_add">+</span>
 	while ((res.start &lt; res.end) &amp;&amp;
<span class="p_del">-		(!find_next_iomem_res(&amp;res, name, false))) {</span>
<span class="p_add">+		(!find_next_iomem_res(&amp;res, desc, false))) {</span>
<span class="p_add">+</span>
 		ret = (*func)(res.start, res.end, arg);
 		if (ret)
 			break;
<span class="p_add">+</span>
 		res.start = res.end + 1;
 		res.end = orig_end;
 	}
<span class="p_add">+</span>
 	return ret;
 }
 
 /*
<span class="p_del">- * This function calls callback against all memory range of &quot;System RAM&quot;</span>
<span class="p_del">- * which are marked as IORESOURCE_MEM and IORESOUCE_BUSY.</span>
<span class="p_del">- * Now, this function is only for &quot;System RAM&quot;. This function deals with</span>
<span class="p_del">- * full ranges and not pfn. If resources are not pfn aligned, dealing</span>
<span class="p_del">- * with pfn can truncate ranges.</span>
<span class="p_add">+ * This function calls the @func callback against all memory ranges of type</span>
<span class="p_add">+ * System RAM which are marked as IORESOURCE_SYSTEM_RAM and IORESOUCE_BUSY.</span>
<span class="p_add">+ * Now, this function is only for System RAM, it deals with full ranges and</span>
<span class="p_add">+ * not PFNs. If resources are not PFN-aligned, dealing with PFNs can truncate</span>
<span class="p_add">+ * ranges.</span>
  */
 int walk_system_ram_res(u64 start, u64 end, void *arg,
 				int (*func)(u64, u64, void *))
<span class="p_chunk">@@ -430,10 +437,10 @@</span> <span class="p_context"> int walk_system_ram_res(u64 start, u64 end, void *arg,</span>
 
 	res.start = start;
 	res.end = end;
<span class="p_del">-	res.flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+	res.flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 	orig_end = res.end;
 	while ((res.start &lt; res.end) &amp;&amp;
<span class="p_del">-		(!find_next_iomem_res(&amp;res, &quot;System RAM&quot;, true))) {</span>
<span class="p_add">+		(!find_next_iomem_res(&amp;res, IORES_DESC_NONE, true))) {</span>
 		ret = (*func)(res.start, res.end, arg);
 		if (ret)
 			break;
<span class="p_chunk">@@ -446,9 +453,9 @@</span> <span class="p_context"> int walk_system_ram_res(u64 start, u64 end, void *arg,</span>
 #if !defined(CONFIG_ARCH_HAS_WALK_MEMORY)
 
 /*
<span class="p_del">- * This function calls callback against all memory range of &quot;System RAM&quot;</span>
<span class="p_del">- * which are marked as IORESOURCE_MEM and IORESOUCE_BUSY.</span>
<span class="p_del">- * Now, this function is only for &quot;System RAM&quot;.</span>
<span class="p_add">+ * This function calls the @func callback against all memory ranges of type</span>
<span class="p_add">+ * System RAM which are marked as IORESOURCE_SYSTEM_RAM and IORESOUCE_BUSY.</span>
<span class="p_add">+ * It is to be used only for System RAM.</span>
  */
 int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,
 		void *arg, int (*func)(unsigned long, unsigned long, void *))
<span class="p_chunk">@@ -460,10 +467,10 @@</span> <span class="p_context"> int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,</span>
 
 	res.start = (u64) start_pfn &lt;&lt; PAGE_SHIFT;
 	res.end = ((u64)(start_pfn + nr_pages) &lt;&lt; PAGE_SHIFT) - 1;
<span class="p_del">-	res.flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+	res.flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 	orig_end = res.end;
 	while ((res.start &lt; res.end) &amp;&amp;
<span class="p_del">-		(find_next_iomem_res(&amp;res, &quot;System RAM&quot;, true) &gt;= 0)) {</span>
<span class="p_add">+		(find_next_iomem_res(&amp;res, IORES_DESC_NONE, true) &gt;= 0)) {</span>
 		pfn = (res.start + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT;
 		end_pfn = (res.end + 1) &gt;&gt; PAGE_SHIFT;
 		if (end_pfn &gt; pfn)
<span class="p_chunk">@@ -484,7 +491,7 @@</span> <span class="p_context"> static int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)</span>
 }
 /*
  * This generic page_is_ram() returns true if specified address is
<span class="p_del">- * registered as &quot;System RAM&quot; in iomem_resource list.</span>
<span class="p_add">+ * registered as System RAM in iomem_resource list.</span>
  */
 int __weak page_is_ram(unsigned long pfn)
 {
<span class="p_chunk">@@ -496,30 +503,34 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(page_is_ram);</span>
  * region_intersects() - determine intersection of region with known resources
  * @start: region start address
  * @size: size of region
<span class="p_del">- * @name: name of resource (in iomem_resource)</span>
<span class="p_add">+ * @flags: flags of resource (in iomem_resource)</span>
<span class="p_add">+ * @desc: descriptor of resource (in iomem_resource) or IORES_DESC_NONE</span>
  *
  * Check if the specified region partially overlaps or fully eclipses a
<span class="p_del">- * resource identified by @name.  Return REGION_DISJOINT if the region</span>
<span class="p_del">- * does not overlap @name, return REGION_MIXED if the region overlaps</span>
<span class="p_del">- * @type and another resource, and return REGION_INTERSECTS if the</span>
<span class="p_del">- * region overlaps @type and no other defined resource. Note, that</span>
<span class="p_del">- * REGION_INTERSECTS is also returned in the case when the specified</span>
<span class="p_del">- * region overlaps RAM and undefined memory holes.</span>
<span class="p_add">+ * resource identified by @flags and @desc (optional with IORES_DESC_NONE).</span>
<span class="p_add">+ * Return REGION_DISJOINT if the region does not overlap @flags/@desc,</span>
<span class="p_add">+ * return REGION_MIXED if the region overlaps @flags/@desc and another</span>
<span class="p_add">+ * resource, and return REGION_INTERSECTS if the region overlaps @flags/@desc</span>
<span class="p_add">+ * and no other defined resource. Note that REGION_INTERSECTS is also</span>
<span class="p_add">+ * returned in the case when the specified region overlaps RAM and undefined</span>
<span class="p_add">+ * memory holes.</span>
  *
  * region_intersect() is used by memory remapping functions to ensure
  * the user is not remapping RAM and is a vast speed up over walking
  * through the resource table page by page.
  */
<span class="p_del">-int region_intersects(resource_size_t start, size_t size, const char *name)</span>
<span class="p_add">+int region_intersects(resource_size_t start, size_t size, unsigned long flags,</span>
<span class="p_add">+		      unsigned long desc)</span>
 {
<span class="p_del">-	unsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
 	resource_size_t end = start + size - 1;
 	int type = 0; int other = 0;
 	struct resource *p;
 
 	read_lock(&amp;resource_lock);
 	for (p = iomem_resource.child; p ; p = p-&gt;sibling) {
<span class="p_del">-		bool is_type = strcmp(p-&gt;name, name) == 0 &amp;&amp; p-&gt;flags == flags;</span>
<span class="p_add">+		bool is_type = (((p-&gt;flags &amp; flags) == flags) &amp;&amp;</span>
<span class="p_add">+				((desc == IORES_DESC_NONE) ||</span>
<span class="p_add">+				 (desc == p-&gt;desc)));</span>
 
 		if (start &gt;= p-&gt;start &amp;&amp; start &lt;= p-&gt;end)
 			is_type ? type++ : other++;
<span class="p_chunk">@@ -538,6 +549,7 @@</span> <span class="p_context"> int region_intersects(resource_size_t start, size_t size, const char *name)</span>
 
 	return REGION_DISJOINT;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(region_intersects);</span>
 
 void __weak arch_remove_reservations(struct resource *avail)
 {
<span class="p_chunk">@@ -948,6 +960,7 @@</span> <span class="p_context"> static void __init __reserve_region_with_split(struct resource *root,</span>
 	res-&gt;start = start;
 	res-&gt;end = end;
 	res-&gt;flags = IORESOURCE_BUSY;
<span class="p_add">+	res-&gt;desc = IORES_DESC_NONE;</span>
 
 	while (1) {
 
<span class="p_chunk">@@ -982,6 +995,7 @@</span> <span class="p_context"> static void __init __reserve_region_with_split(struct resource *root,</span>
 				next_res-&gt;start = conflict-&gt;end + 1;
 				next_res-&gt;end = end;
 				next_res-&gt;flags = IORESOURCE_BUSY;
<span class="p_add">+				next_res-&gt;desc = IORES_DESC_NONE;</span>
 			}
 		} else {
 			res-&gt;start = conflict-&gt;end + 1;
<span class="p_chunk">@@ -1071,8 +1085,9 @@</span> <span class="p_context"> struct resource * __request_region(struct resource *parent,</span>
 	res-&gt;name = name;
 	res-&gt;start = start;
 	res-&gt;end = start + n - 1;
<span class="p_del">-	res-&gt;flags = resource_type(parent);</span>
<span class="p_add">+	res-&gt;flags = resource_type(parent) | resource_ext_type(parent);</span>
 	res-&gt;flags |= IORESOURCE_BUSY | flags;
<span class="p_add">+	res-&gt;desc = IORES_DESC_NONE;</span>
 
 	write_lock(&amp;resource_lock);
 
<span class="p_chunk">@@ -1238,6 +1253,7 @@</span> <span class="p_context"> int release_mem_region_adjustable(struct resource *parent,</span>
 			new_res-&gt;start = end + 1;
 			new_res-&gt;end = res-&gt;end;
 			new_res-&gt;flags = res-&gt;flags;
<span class="p_add">+			new_res-&gt;desc = res-&gt;desc;</span>
 			new_res-&gt;parent = res-&gt;parent;
 			new_res-&gt;sibling = res-&gt;sibling;
 			new_res-&gt;child = NULL;
<span class="p_chunk">@@ -1413,6 +1429,7 @@</span> <span class="p_context"> static int __init reserve_setup(char *str)</span>
 			res-&gt;start = io_start;
 			res-&gt;end = io_start + io_num - 1;
 			res-&gt;flags = IORESOURCE_BUSY;
<span class="p_add">+			res-&gt;desc = IORES_DESC_NONE;</span>
 			res-&gt;child = NULL;
 			if (request_resource(res-&gt;start &gt;= 0x10000 ? &amp;iomem_resource : &amp;ioport_resource, res) == 0)
 				reserved = x+1;
<span class="p_header">diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c</span>
<span class="p_header">index 4af58a3a8ffa..979b18cbd343 100644</span>
<span class="p_header">--- a/mm/memory_hotplug.c</span>
<span class="p_header">+++ b/mm/memory_hotplug.c</span>
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"> static struct resource *register_memory_resource(u64 start, u64 size)</span>
 	res-&gt;name = &quot;System RAM&quot;;
 	res-&gt;start = start;
 	res-&gt;end = start + size - 1;
<span class="p_del">-	res-&gt;flags = IORESOURCE_MEM | IORESOURCE_BUSY;</span>
<span class="p_add">+	res-&gt;flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;</span>
 	if (request_resource(&amp;iomem_resource, res) &lt; 0) {
 		pr_debug(&quot;System RAM resource %pR cannot be added\n&quot;, res);
 		kfree(res);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



