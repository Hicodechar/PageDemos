
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.9 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.9</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 4, 2016, 10:21 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160504222131.GB8146@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9019171/mbox/"
   >mbox</a>
|
   <a href="/patch/9019171/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9019171/">/patch/9019171/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 386DABF29F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  4 May 2016 22:22:12 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 0F4A72041B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  4 May 2016 22:22:02 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 9ECDE20414
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  4 May 2016 22:21:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754651AbcEDWVm (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 4 May 2016 18:21:42 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:38101 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1754377AbcEDWVd (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 4 May 2016 18:21:33 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 20742411;
	Wed,  4 May 2016 22:21:32 +0000 (UTC)
Date: Wed, 4 May 2016 15:21:31 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.9
Message-ID: &lt;20160504222131.GB8146@kroah.com&gt;
References: &lt;20160504222117.GA8146@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160504222117.GA8146@kroah.com&gt;
User-Agent: Mutt/1.6.1 (2016-04-27)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-9.0 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - May 4, 2016, 10:21 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 1928fcd539cc..0722cdf52152 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 8</span>
<span class="p_add">+SUBLEVEL = 9</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/am43x-epos-evm.dts b/arch/arm/boot/dts/am43x-epos-evm.dts</span>
<span class="p_header">index 47954ed990f8..00707aac72fc 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am43x-epos-evm.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am43x-epos-evm.dts</span>
<span class="p_chunk">@@ -792,3 +792,8 @@</span> <span class="p_context"></span>
 	tx-num-evt = &lt;32&gt;;
 	rx-num-evt = &lt;32&gt;;
 };
<span class="p_add">+</span>
<span class="p_add">+&amp;synctimer_32kclk {</span>
<span class="p_add">+	assigned-clocks = &lt;&amp;mux_synctimer32k_ck&gt;;</span>
<span class="p_add">+	assigned-clock-parents = &lt;&amp;clkdiv32k_ick&gt;;</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-375.dtsi b/arch/arm/boot/dts/armada-375.dtsi</span>
<span class="p_header">index 7ccce7529b0c..cc952cf8ec30 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-375.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-375.dtsi</span>
<span class="p_chunk">@@ -529,7 +529,7 @@</span> <span class="p_context"></span>
 			};
 
 			sata@a0000 {
<span class="p_del">-				compatible = &quot;marvell,orion-sata&quot;;</span>
<span class="p_add">+				compatible = &quot;marvell,armada-370-sata&quot;;</span>
 				reg = &lt;0xa0000 0x5000&gt;;
 				interrupts = &lt;GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH&gt;;
 				clocks = &lt;&amp;gateclk 14&gt;, &lt;&amp;gateclk 20&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-385-linksys.dtsi b/arch/arm/boot/dts/armada-385-linksys.dtsi</span>
<span class="p_header">index 3710755c6d76..85d2c377c332 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-385-linksys.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-385-linksys.dtsi</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"></span>
 			};
 
 			/* USB part of the eSATA/USB 2.0 port */
<span class="p_del">-			usb@50000 {</span>
<span class="p_add">+			usb@58000 {</span>
 				status = &quot;okay&quot;;
 			};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/pxa3xx.dtsi b/arch/arm/boot/dts/pxa3xx.dtsi</span>
<span class="p_header">index cf6998a0804d..564341af7e97 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/pxa3xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/pxa3xx.dtsi</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"></span>
 			reg = &lt;0x43100000 90&gt;;
 			interrupts = &lt;45&gt;;
 			clocks = &lt;&amp;clks CLK_NAND&gt;;
<span class="p_del">-			dmas = &lt;&amp;pdma 97&gt;;</span>
<span class="p_add">+			dmas = &lt;&amp;pdma 97 3&gt;;</span>
 			dma-names = &quot;data&quot;;
 			#address-cells = &lt;1&gt;;
 			#size-cells = &lt;1&gt;;	
<span class="p_header">diff --git a/arch/arm/mach-exynos/Kconfig b/arch/arm/mach-exynos/Kconfig</span>
<span class="p_header">index 3a10f1a8317a..bfd8bb371477 100644</span>
<span class="p_header">--- a/arch/arm/mach-exynos/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-exynos/Kconfig</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"> menuconfig ARCH_EXYNOS</span>
 	select S5P_DEV_MFC
 	select SRAM
 	select THERMAL
<span class="p_add">+	select THERMAL_OF</span>
 	select MFD_SYSCON
 	help
 	  Support for SAMSUNG EXYNOS SoCs (EXYNOS4/5)
<span class="p_header">diff --git a/arch/arm/mach-omap2/cpuidle34xx.c b/arch/arm/mach-omap2/cpuidle34xx.c</span>
<span class="p_header">index aa7b379e2661..2a3db0bd9e15 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/cpuidle34xx.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/cpuidle34xx.c</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"></span>
 #include &quot;pm.h&quot;
 #include &quot;control.h&quot;
 #include &quot;common.h&quot;
<span class="p_add">+#include &quot;soc.h&quot;</span>
 
 /* Mach specific information to be recorded in the C-state driver_data */
 struct omap3_idle_statedata {
<span class="p_chunk">@@ -315,6 +316,69 @@</span> <span class="p_context"> static struct cpuidle_driver omap3_idle_driver = {</span>
 	.safe_state_index = 0,
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Numbers based on measurements made in October 2009 for PM optimized kernel</span>
<span class="p_add">+ * with CPU freq enabled on device Nokia N900. Assumes OPP2 (main idle OPP,</span>
<span class="p_add">+ * and worst case latencies).</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct cpuidle_driver omap3430_idle_driver = {</span>
<span class="p_add">+	.name             = &quot;omap3430_idle&quot;,</span>
<span class="p_add">+	.owner            = THIS_MODULE,</span>
<span class="p_add">+	.states = {</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 110 + 162,</span>
<span class="p_add">+			.target_residency = 5,</span>
<span class="p_add">+			.name		  = &quot;C1&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU ON + CORE ON&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 106 + 180,</span>
<span class="p_add">+			.target_residency = 309,</span>
<span class="p_add">+			.name		  = &quot;C2&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU ON + CORE ON&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 107 + 410,</span>
<span class="p_add">+			.target_residency = 46057,</span>
<span class="p_add">+			.name		  = &quot;C3&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU RET + CORE ON&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 121 + 3374,</span>
<span class="p_add">+			.target_residency = 46057,</span>
<span class="p_add">+			.name		  = &quot;C4&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU OFF + CORE ON&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 855 + 1146,</span>
<span class="p_add">+			.target_residency = 46057,</span>
<span class="p_add">+			.name		  = &quot;C5&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU RET + CORE RET&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 7580 + 4134,</span>
<span class="p_add">+			.target_residency = 484329,</span>
<span class="p_add">+			.name		  = &quot;C6&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU OFF + CORE RET&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+		{</span>
<span class="p_add">+			.enter		  = omap3_enter_idle_bm,</span>
<span class="p_add">+			.exit_latency	  = 7505 + 15274,</span>
<span class="p_add">+			.target_residency = 484329,</span>
<span class="p_add">+			.name		  = &quot;C7&quot;,</span>
<span class="p_add">+			.desc		  = &quot;MPU OFF + CORE OFF&quot;,</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	.state_count = ARRAY_SIZE(omap3_idle_data),</span>
<span class="p_add">+	.safe_state_index = 0,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /* Public functions */
 
 /**
<span class="p_chunk">@@ -333,5 +397,8 @@</span> <span class="p_context"> int __init omap3_idle_init(void)</span>
 	if (!mpu_pd || !core_pd || !per_pd || !cam_pd)
 		return -ENODEV;
 
<span class="p_del">-	return cpuidle_register(&amp;omap3_idle_driver, NULL);</span>
<span class="p_add">+	if (cpu_is_omap3430())</span>
<span class="p_add">+		return cpuidle_register(&amp;omap3430_idle_driver, NULL);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return cpuidle_register(&amp;omap3_idle_driver, NULL);</span>
 }
<span class="p_header">diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c</span>
<span class="p_header">index 3eaeaca5da05..3a911d8dea8b 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/io.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/io.c</span>
<span class="p_chunk">@@ -368,6 +368,7 @@</span> <span class="p_context"> void __init omap5_map_io(void)</span>
 void __init dra7xx_map_io(void)
 {
 	iotable_init(dra7xx_io_desc, ARRAY_SIZE(dra7xx_io_desc));
<span class="p_add">+	omap_barriers_init();</span>
 }
 #endif
 /*
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">index 8e0bd5939e5a..147c90e70b2e 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_chunk">@@ -1416,9 +1416,7 @@</span> <span class="p_context"> static void _enable_sysc(struct omap_hwmod *oh)</span>
 	    (sf &amp; SYSC_HAS_CLOCKACTIVITY))
 		_set_clockactivity(oh, oh-&gt;class-&gt;sysc-&gt;clockact, &amp;v);
 
<span class="p_del">-	/* If the cached value is the same as the new value, skip the write */</span>
<span class="p_del">-	if (oh-&gt;_sysc_cache != v)</span>
<span class="p_del">-		_write_sysconfig(v, oh);</span>
<span class="p_add">+	_write_sysconfig(v, oh);</span>
 
 	/*
 	 * Set the autoidle bit only after setting the smartidle bit
<span class="p_chunk">@@ -1481,7 +1479,9 @@</span> <span class="p_context"> static void _idle_sysc(struct omap_hwmod *oh)</span>
 		_set_master_standbymode(oh, idlemode, &amp;v);
 	}
 
<span class="p_del">-	_write_sysconfig(v, oh);</span>
<span class="p_add">+	/* If the cached value is the same as the new value, skip the write */</span>
<span class="p_add">+	if (oh-&gt;_sysc_cache != v)</span>
<span class="p_add">+		_write_sysconfig(v, oh);</span>
 }
 
 /**
<span class="p_header">diff --git a/arch/arm/mach-prima2/Kconfig b/arch/arm/mach-prima2/Kconfig</span>
<span class="p_header">index 9ab8932403e5..56e55fd37d13 100644</span>
<span class="p_header">--- a/arch/arm/mach-prima2/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-prima2/Kconfig</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 menuconfig ARCH_SIRF
 	bool &quot;CSR SiRF&quot; if ARCH_MULTI_V7
 	select ARCH_HAS_RESET_CONTROLLER
<span class="p_add">+	select RESET_CONTROLLER</span>
 	select ARCH_REQUIRE_GPIOLIB
 	select GENERIC_IRQ_CHIP
 	select NO_IOPORT_MAP
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">index eaa9cabf4066..c63868ae9a4a 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -69,11 +69,11 @@</span> <span class="p_context"> extern void __pgd_error(const char *file, int line, unsigned long val);</span>
 #define PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_SHARED)
 #define PROT_SECT_DEFAULT	(PMD_TYPE_SECT | PMD_SECT_AF | PMD_SECT_S)
 
<span class="p_del">-#define PROT_DEVICE_nGnRnE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_DEVICE_nGnRnE))</span>
<span class="p_del">-#define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_DEVICE_nGnRE))</span>
<span class="p_del">-#define PROT_NORMAL_NC		(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_NORMAL_NC))</span>
<span class="p_del">-#define PROT_NORMAL_WT		(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_NORMAL_WT))</span>
<span class="p_del">-#define PROT_NORMAL		(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_ATTRINDX(MT_NORMAL))</span>
<span class="p_add">+#define PROT_DEVICE_nGnRnE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_WRITE | PTE_ATTRINDX(MT_DEVICE_nGnRnE))</span>
<span class="p_add">+#define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_WRITE | PTE_ATTRINDX(MT_DEVICE_nGnRE))</span>
<span class="p_add">+#define PROT_NORMAL_NC		(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_WRITE | PTE_ATTRINDX(MT_NORMAL_NC))</span>
<span class="p_add">+#define PROT_NORMAL_WT		(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_WRITE | PTE_ATTRINDX(MT_NORMAL_WT))</span>
<span class="p_add">+#define PROT_NORMAL		(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_WRITE | PTE_ATTRINDX(MT_NORMAL))</span>
 
 #define PROT_SECT_DEVICE_nGnRE	(PROT_SECT_DEFAULT | PMD_SECT_PXN | PMD_SECT_UXN | PMD_ATTRINDX(MT_DEVICE_nGnRE))
 #define PROT_SECT_NORMAL	(PROT_SECT_DEFAULT | PMD_SECT_PXN | PMD_SECT_UXN | PMD_ATTRINDX(MT_NORMAL))
<span class="p_chunk">@@ -83,7 +83,7 @@</span> <span class="p_context"> extern void __pgd_error(const char *file, int line, unsigned long val);</span>
 
 #define PAGE_KERNEL		__pgprot(_PAGE_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_WRITE)
 #define PAGE_KERNEL_RO		__pgprot(_PAGE_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_RDONLY)
<span class="p_del">-#define PAGE_KERNEL_ROX	__pgprot(_PAGE_DEFAULT | PTE_UXN | PTE_DIRTY | PTE_RDONLY)</span>
<span class="p_add">+#define PAGE_KERNEL_ROX		__pgprot(_PAGE_DEFAULT | PTE_UXN | PTE_DIRTY | PTE_RDONLY)</span>
 #define PAGE_KERNEL_EXEC	__pgprot(_PAGE_DEFAULT | PTE_UXN | PTE_DIRTY | PTE_WRITE)
 #define PAGE_KERNEL_EXEC_CONT	__pgprot(_PAGE_DEFAULT | PTE_UXN | PTE_DIRTY | PTE_WRITE | PTE_CONT)
 
<span class="p_chunk">@@ -155,6 +155,7 @@</span> <span class="p_context"> extern struct page *empty_zero_page;</span>
 #define pte_write(pte)		(!!(pte_val(pte) &amp; PTE_WRITE))
 #define pte_exec(pte)		(!(pte_val(pte) &amp; PTE_UXN))
 #define pte_cont(pte)		(!!(pte_val(pte) &amp; PTE_CONT))
<span class="p_add">+#define pte_user(pte)		(!!(pte_val(pte) &amp; PTE_USER))</span>
 
 #ifdef CONFIG_ARM64_HW_AFDBM
 #define pte_hw_dirty(pte)	(pte_write(pte) &amp;&amp; !(pte_val(pte) &amp; PTE_RDONLY))
<span class="p_chunk">@@ -165,8 +166,6 @@</span> <span class="p_context"> extern struct page *empty_zero_page;</span>
 #define pte_dirty(pte)		(pte_sw_dirty(pte) || pte_hw_dirty(pte))
 
 #define pte_valid(pte)		(!!(pte_val(pte) &amp; PTE_VALID))
<span class="p_del">-#define pte_valid_user(pte) \</span>
<span class="p_del">-	((pte_val(pte) &amp; (PTE_VALID | PTE_USER)) == (PTE_VALID | PTE_USER))</span>
 #define pte_valid_not_user(pte) \
 	((pte_val(pte) &amp; (PTE_VALID | PTE_USER)) == PTE_VALID)
 
<span class="p_chunk">@@ -264,13 +263,13 @@</span> <span class="p_context"> extern void __sync_icache_dcache(pte_t pteval, unsigned long addr);</span>
 static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,
 			      pte_t *ptep, pte_t pte)
 {
<span class="p_del">-	if (pte_valid_user(pte)) {</span>
<span class="p_del">-		if (!pte_special(pte) &amp;&amp; pte_exec(pte))</span>
<span class="p_del">-			__sync_icache_dcache(pte, addr);</span>
<span class="p_add">+	if (pte_present(pte)) {</span>
 		if (pte_sw_dirty(pte) &amp;&amp; pte_write(pte))
 			pte_val(pte) &amp;= ~PTE_RDONLY;
 		else
 			pte_val(pte) |= PTE_RDONLY;
<span class="p_add">+		if (pte_user(pte) &amp;&amp; pte_exec(pte) &amp;&amp; !pte_special(pte))</span>
<span class="p_add">+			__sync_icache_dcache(pte, addr);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -641,6 +640,7 @@</span> <span class="p_context"> extern pgd_t idmap_pg_dir[PTRS_PER_PGD];</span>
  *	bits 0-1:	present (must be zero)
  *	bits 2-7:	swap type
  *	bits 8-57:	swap offset
<span class="p_add">+ *	bit  58:	PTE_PROT_NONE (must be zero)</span>
  */
 #define __SWP_TYPE_SHIFT	2
 #define __SWP_TYPE_BITS		6
<span class="p_header">diff --git a/arch/powerpc/include/uapi/asm/cputable.h b/arch/powerpc/include/uapi/asm/cputable.h</span>
<span class="p_header">index 43686043e297..2734c005da21 100644</span>
<span class="p_header">--- a/arch/powerpc/include/uapi/asm/cputable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/uapi/asm/cputable.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 #define PPC_FEATURE_PSERIES_PERFMON_COMPAT \
 					0x00000040
 
<span class="p_add">+/* Reserved - do not use		0x00000004 */</span>
 #define PPC_FEATURE_TRUE_LE		0x00000002
 #define PPC_FEATURE_PPC_LE		0x00000001
 
<span class="p_header">diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c</span>
<span class="p_header">index 7030b035905d..a15fe1d4e84a 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/prom.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/prom.c</span>
<span class="p_chunk">@@ -148,23 +148,25 @@</span> <span class="p_context"> static struct ibm_pa_feature {</span>
 	unsigned long	cpu_features;	/* CPU_FTR_xxx bit */
 	unsigned long	mmu_features;	/* MMU_FTR_xxx bit */
 	unsigned int	cpu_user_ftrs;	/* PPC_FEATURE_xxx bit */
<span class="p_add">+	unsigned int	cpu_user_ftrs2;	/* PPC_FEATURE2_xxx bit */</span>
 	unsigned char	pabyte;		/* byte number in ibm,pa-features */
 	unsigned char	pabit;		/* bit number (big-endian) */
 	unsigned char	invert;		/* if 1, pa bit set =&gt; clear feature */
 } ibm_pa_features[] __initdata = {
<span class="p_del">-	{0, 0, PPC_FEATURE_HAS_MMU,	0, 0, 0},</span>
<span class="p_del">-	{0, 0, PPC_FEATURE_HAS_FPU,	0, 1, 0},</span>
<span class="p_del">-	{CPU_FTR_CTRL, 0, 0,		0, 3, 0},</span>
<span class="p_del">-	{CPU_FTR_NOEXECUTE, 0, 0,	0, 6, 0},</span>
<span class="p_del">-	{CPU_FTR_NODSISRALIGN, 0, 0,	1, 1, 1},</span>
<span class="p_del">-	{0, MMU_FTR_CI_LARGE_PAGE, 0,	1, 2, 0},</span>
<span class="p_del">-	{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},</span>
<span class="p_add">+	{0, 0, PPC_FEATURE_HAS_MMU, 0,		0, 0, 0},</span>
<span class="p_add">+	{0, 0, PPC_FEATURE_HAS_FPU, 0,		0, 1, 0},</span>
<span class="p_add">+	{CPU_FTR_CTRL, 0, 0, 0,			0, 3, 0},</span>
<span class="p_add">+	{CPU_FTR_NOEXECUTE, 0, 0, 0,		0, 6, 0},</span>
<span class="p_add">+	{CPU_FTR_NODSISRALIGN, 0, 0, 0,		1, 1, 1},</span>
<span class="p_add">+	{0, MMU_FTR_CI_LARGE_PAGE, 0, 0,		1, 2, 0},</span>
<span class="p_add">+	{CPU_FTR_REAL_LE, 0, PPC_FEATURE_TRUE_LE, 0, 5, 0, 0},</span>
 	/*
<span class="p_del">-	 * If the kernel doesn&#39;t support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),</span>
<span class="p_del">-	 * we don&#39;t want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP</span>
<span class="p_del">-	 * which is 0 if the kernel doesn&#39;t support TM.</span>
<span class="p_add">+	 * If the kernel doesn&#39;t support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),</span>
<span class="p_add">+	 * we don&#39;t want to turn on TM here, so we use the *_COMP versions</span>
<span class="p_add">+	 * which are 0 if the kernel doesn&#39;t support TM.</span>
 	 */
<span class="p_del">-	{CPU_FTR_TM_COMP, 0, 0,		22, 0, 0},</span>
<span class="p_add">+	{CPU_FTR_TM_COMP, 0, 0,</span>
<span class="p_add">+	 PPC_FEATURE2_HTM_COMP|PPC_FEATURE2_HTM_NOSC_COMP, 22, 0, 0},</span>
 };
 
 static void __init scan_features(unsigned long node, const unsigned char *ftrs,
<span class="p_chunk">@@ -195,10 +197,12 @@</span> <span class="p_context"> static void __init scan_features(unsigned long node, const unsigned char *ftrs,</span>
 		if (bit ^ fp-&gt;invert) {
 			cur_cpu_spec-&gt;cpu_features |= fp-&gt;cpu_features;
 			cur_cpu_spec-&gt;cpu_user_features |= fp-&gt;cpu_user_ftrs;
<span class="p_add">+			cur_cpu_spec-&gt;cpu_user_features2 |= fp-&gt;cpu_user_ftrs2;</span>
 			cur_cpu_spec-&gt;mmu_features |= fp-&gt;mmu_features;
 		} else {
 			cur_cpu_spec-&gt;cpu_features &amp;= ~fp-&gt;cpu_features;
 			cur_cpu_spec-&gt;cpu_user_features &amp;= ~fp-&gt;cpu_user_ftrs;
<span class="p_add">+			cur_cpu_spec-&gt;cpu_user_features2 &amp;= ~fp-&gt;cpu_user_ftrs2;</span>
 			cur_cpu_spec-&gt;mmu_features &amp;= ~fp-&gt;mmu_features;
 		}
 	}
<span class="p_header">diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.h</span>
<span class="p_header">index 2b2ced9dc00a..6dafabb6ae1a 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pci.h</span>
<span class="p_chunk">@@ -45,7 +45,8 @@</span> <span class="p_context"> struct zpci_fmb {</span>
 	u64 rpcit_ops;
 	u64 dma_rbytes;
 	u64 dma_wbytes;
<span class="p_del">-} __packed __aligned(64);</span>
<span class="p_add">+	u64 pad[2];</span>
<span class="p_add">+} __packed __aligned(128);</span>
 
 enum zpci_state {
 	ZPCI_FN_STATE_RESERVED,
<span class="p_header">diff --git a/arch/x86/crypto/sha-mb/sha1_mb.c b/arch/x86/crypto/sha-mb/sha1_mb.c</span>
<span class="p_header">index a841e9765bd6..8381c09d2870 100644</span>
<span class="p_header">--- a/arch/x86/crypto/sha-mb/sha1_mb.c</span>
<span class="p_header">+++ b/arch/x86/crypto/sha-mb/sha1_mb.c</span>
<span class="p_chunk">@@ -453,10 +453,10 @@</span> <span class="p_context"> static int sha_complete_job(struct mcryptd_hash_request_ctx *rctx,</span>
 
 			req = cast_mcryptd_ctx_to_req(req_ctx);
 			if (irqs_disabled())
<span class="p_del">-				rctx-&gt;complete(&amp;req-&gt;base, ret);</span>
<span class="p_add">+				req_ctx-&gt;complete(&amp;req-&gt;base, ret);</span>
 			else {
 				local_bh_disable();
<span class="p_del">-				rctx-&gt;complete(&amp;req-&gt;base, ret);</span>
<span class="p_add">+				req_ctx-&gt;complete(&amp;req-&gt;base, ret);</span>
 				local_bh_enable();
 			}
 		}
<span class="p_header">diff --git a/arch/x86/include/asm/hugetlb.h b/arch/x86/include/asm/hugetlb.h</span>
<span class="p_header">index f8a29d2c97b0..e6a8613fbfb0 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -4,6 +4,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm-generic/hugetlb.h&gt;
 
<span class="p_add">+#define hugepages_supported() cpu_has_pse</span>
 
 static inline int is_hugepage_only_range(struct mm_struct *mm,
 					 unsigned long addr,
<span class="p_header">diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">index 7af2505f20c2..df6b4eeac0bd 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/vector.c</span>
<span class="p_chunk">@@ -254,7 +254,8 @@</span> <span class="p_context"> static void clear_irq_vector(int irq, struct apic_chip_data *data)</span>
 	struct irq_desc *desc;
 	int cpu, vector;
 
<span class="p_del">-	BUG_ON(!data-&gt;cfg.vector);</span>
<span class="p_add">+	if (!data-&gt;cfg.vector)</span>
<span class="p_add">+		return;</span>
 
 	vector = data-&gt;cfg.vector;
 	for_each_cpu_and(cpu, data-&gt;domain, cpu_online_mask)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce-genpool.c b/arch/x86/kernel/cpu/mcheck/mce-genpool.c</span>
<span class="p_header">index 0a850100c594..2658e2af74ec 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce-genpool.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce-genpool.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"> static char gen_pool_buf[MCE_POOLSZ];</span>
 void mce_gen_pool_process(void)
 {
 	struct llist_node *head;
<span class="p_del">-	struct mce_evt_llist *node;</span>
<span class="p_add">+	struct mce_evt_llist *node, *tmp;</span>
 	struct mce *mce;
 
 	head = llist_del_all(&amp;mce_event_llist);
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"> void mce_gen_pool_process(void)</span>
 		return;
 
 	head = llist_reverse_order(head);
<span class="p_del">-	llist_for_each_entry(node, head, llnode) {</span>
<span class="p_add">+	llist_for_each_entry_safe(node, tmp, head, llnode) {</span>
 		mce = &amp;node-&gt;mce;
 		atomic_notifier_call_chain(&amp;x86_mce_decoder_chain, 0, mce);
 		gen_pool_free(mce_evt_pool, (unsigned long)node, sizeof(*node));
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 7eb4ebd3ebea..605cea75eb0d 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -697,7 +697,6 @@</span> <span class="p_context"> static int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)</span>
 		if ((xcr0 &amp; XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)
 			return 1;
 	}
<span class="p_del">-	kvm_put_guest_xcr0(vcpu);</span>
 	vcpu-&gt;arch.xcr0 = xcr0;
 
 	if ((xcr0 ^ old_xcr0) &amp; XFEATURE_MASK_EXTEND)
<span class="p_chunk">@@ -6495,8 +6494,6 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 	kvm_x86_ops-&gt;prepare_guest_switch(vcpu);
 	if (vcpu-&gt;fpu_active)
 		kvm_load_guest_fpu(vcpu);
<span class="p_del">-	kvm_load_guest_xcr0(vcpu);</span>
<span class="p_del">-</span>
 	vcpu-&gt;mode = IN_GUEST_MODE;
 
 	srcu_read_unlock(&amp;vcpu-&gt;kvm-&gt;srcu, vcpu-&gt;srcu_idx);
<span class="p_chunk">@@ -6519,6 +6516,8 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 		goto cancel_injection;
 	}
 
<span class="p_add">+	kvm_load_guest_xcr0(vcpu);</span>
<span class="p_add">+</span>
 	if (req_immediate_exit)
 		smp_send_reschedule(vcpu-&gt;cpu);
 
<span class="p_chunk">@@ -6568,6 +6567,8 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 	vcpu-&gt;mode = OUTSIDE_GUEST_MODE;
 	smp_wmb();
 
<span class="p_add">+	kvm_put_guest_xcr0(vcpu);</span>
<span class="p_add">+</span>
 	/* Interrupt is enabled by handle_external_intr() */
 	kvm_x86_ops-&gt;handle_external_intr(vcpu);
 
<span class="p_chunk">@@ -7215,7 +7216,6 @@</span> <span class="p_context"> void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)</span>
 	 * and assume host would use all available bits.
 	 * Guest xcr0 would be loaded later.
 	 */
<span class="p_del">-	kvm_put_guest_xcr0(vcpu);</span>
 	vcpu-&gt;guest_fpu_loaded = 1;
 	__kernel_fpu_begin();
 	__copy_kernel_to_fpregs(&amp;vcpu-&gt;arch.guest_fpu.state);
<span class="p_chunk">@@ -7224,8 +7224,6 @@</span> <span class="p_context"> void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)</span>
 
 void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	kvm_put_guest_xcr0(vcpu);</span>
<span class="p_del">-</span>
 	if (!vcpu-&gt;guest_fpu_loaded) {
 		vcpu-&gt;fpu_counter = 0;
 		return;
<span class="p_header">diff --git a/arch/x86/mm/kmmio.c b/arch/x86/mm/kmmio.c</span>
<span class="p_header">index 637ab34ed632..ddb2244b06a1 100644</span>
<span class="p_header">--- a/arch/x86/mm/kmmio.c</span>
<span class="p_header">+++ b/arch/x86/mm/kmmio.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"></span>
 struct kmmio_fault_page {
 	struct list_head list;
 	struct kmmio_fault_page *release_next;
<span class="p_del">-	unsigned long page; /* location of the fault page */</span>
<span class="p_add">+	unsigned long addr; /* the requested address */</span>
 	pteval_t old_presence; /* page presence prior to arming */
 	bool armed;
 
<span class="p_chunk">@@ -70,9 +70,16 @@</span> <span class="p_context"> unsigned int kmmio_count;</span>
 static struct list_head kmmio_page_table[KMMIO_PAGE_TABLE_SIZE];
 static LIST_HEAD(kmmio_probes);
 
<span class="p_del">-static struct list_head *kmmio_page_list(unsigned long page)</span>
<span class="p_add">+static struct list_head *kmmio_page_list(unsigned long addr)</span>
 {
<span class="p_del">-	return &amp;kmmio_page_table[hash_long(page, KMMIO_PAGE_HASH_BITS)];</span>
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte = lookup_address(addr, &amp;l);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pte)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	addr &amp;= page_level_mask(l);</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;kmmio_page_table[hash_long(addr, KMMIO_PAGE_HASH_BITS)];</span>
 }
 
 /* Accessed per-cpu */
<span class="p_chunk">@@ -98,15 +105,19 @@</span> <span class="p_context"> static struct kmmio_probe *get_kmmio_probe(unsigned long addr)</span>
 }
 
 /* You must be holding RCU read lock. */
<span class="p_del">-static struct kmmio_fault_page *get_kmmio_fault_page(unsigned long page)</span>
<span class="p_add">+static struct kmmio_fault_page *get_kmmio_fault_page(unsigned long addr)</span>
 {
 	struct list_head *head;
 	struct kmmio_fault_page *f;
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte = lookup_address(addr, &amp;l);</span>
 
<span class="p_del">-	page &amp;= PAGE_MASK;</span>
<span class="p_del">-	head = kmmio_page_list(page);</span>
<span class="p_add">+	if (!pte)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	addr &amp;= page_level_mask(l);</span>
<span class="p_add">+	head = kmmio_page_list(addr);</span>
 	list_for_each_entry_rcu(f, head, list) {
<span class="p_del">-		if (f-&gt;page == page)</span>
<span class="p_add">+		if (f-&gt;addr == addr)</span>
 			return f;
 	}
 	return NULL;
<span class="p_chunk">@@ -137,10 +148,10 @@</span> <span class="p_context"> static void clear_pte_presence(pte_t *pte, bool clear, pteval_t *old)</span>
 static int clear_page_presence(struct kmmio_fault_page *f, bool clear)
 {
 	unsigned int level;
<span class="p_del">-	pte_t *pte = lookup_address(f-&gt;page, &amp;level);</span>
<span class="p_add">+	pte_t *pte = lookup_address(f-&gt;addr, &amp;level);</span>
 
 	if (!pte) {
<span class="p_del">-		pr_err(&quot;no pte for page 0x%08lx\n&quot;, f-&gt;page);</span>
<span class="p_add">+		pr_err(&quot;no pte for addr 0x%08lx\n&quot;, f-&gt;addr);</span>
 		return -1;
 	}
 
<span class="p_chunk">@@ -156,7 +167,7 @@</span> <span class="p_context"> static int clear_page_presence(struct kmmio_fault_page *f, bool clear)</span>
 		return -1;
 	}
 
<span class="p_del">-	__flush_tlb_one(f-&gt;page);</span>
<span class="p_add">+	__flush_tlb_one(f-&gt;addr);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -176,12 +187,12 @@</span> <span class="p_context"> static int arm_kmmio_fault_page(struct kmmio_fault_page *f)</span>
 	int ret;
 	WARN_ONCE(f-&gt;armed, KERN_ERR pr_fmt(&quot;kmmio page already armed.\n&quot;));
 	if (f-&gt;armed) {
<span class="p_del">-		pr_warning(&quot;double-arm: page 0x%08lx, ref %d, old %d\n&quot;,</span>
<span class="p_del">-			   f-&gt;page, f-&gt;count, !!f-&gt;old_presence);</span>
<span class="p_add">+		pr_warning(&quot;double-arm: addr 0x%08lx, ref %d, old %d\n&quot;,</span>
<span class="p_add">+			   f-&gt;addr, f-&gt;count, !!f-&gt;old_presence);</span>
 	}
 	ret = clear_page_presence(f, true);
<span class="p_del">-	WARN_ONCE(ret &lt; 0, KERN_ERR pr_fmt(&quot;arming 0x%08lx failed.\n&quot;),</span>
<span class="p_del">-		  f-&gt;page);</span>
<span class="p_add">+	WARN_ONCE(ret &lt; 0, KERN_ERR pr_fmt(&quot;arming at 0x%08lx failed.\n&quot;),</span>
<span class="p_add">+		  f-&gt;addr);</span>
 	f-&gt;armed = true;
 	return ret;
 }
<span class="p_chunk">@@ -191,7 +202,7 @@</span> <span class="p_context"> static void disarm_kmmio_fault_page(struct kmmio_fault_page *f)</span>
 {
 	int ret = clear_page_presence(f, false);
 	WARN_ONCE(ret &lt; 0,
<span class="p_del">-			KERN_ERR &quot;kmmio disarming 0x%08lx failed.\n&quot;, f-&gt;page);</span>
<span class="p_add">+			KERN_ERR &quot;kmmio disarming at 0x%08lx failed.\n&quot;, f-&gt;addr);</span>
 	f-&gt;armed = false;
 }
 
<span class="p_chunk">@@ -215,6 +226,12 @@</span> <span class="p_context"> int kmmio_handler(struct pt_regs *regs, unsigned long addr)</span>
 	struct kmmio_context *ctx;
 	struct kmmio_fault_page *faultpage;
 	int ret = 0; /* default to fault not handled */
<span class="p_add">+	unsigned long page_base = addr;</span>
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte = lookup_address(addr, &amp;l);</span>
<span class="p_add">+	if (!pte)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	page_base &amp;= page_level_mask(l);</span>
 
 	/*
 	 * Preemption is now disabled to prevent process switch during
<span class="p_chunk">@@ -227,7 +244,7 @@</span> <span class="p_context"> int kmmio_handler(struct pt_regs *regs, unsigned long addr)</span>
 	preempt_disable();
 	rcu_read_lock();
 
<span class="p_del">-	faultpage = get_kmmio_fault_page(addr);</span>
<span class="p_add">+	faultpage = get_kmmio_fault_page(page_base);</span>
 	if (!faultpage) {
 		/*
 		 * Either this page fault is not caused by kmmio, or
<span class="p_chunk">@@ -239,7 +256,7 @@</span> <span class="p_context"> int kmmio_handler(struct pt_regs *regs, unsigned long addr)</span>
 
 	ctx = &amp;get_cpu_var(kmmio_ctx);
 	if (ctx-&gt;active) {
<span class="p_del">-		if (addr == ctx-&gt;addr) {</span>
<span class="p_add">+		if (page_base == ctx-&gt;addr) {</span>
 			/*
 			 * A second fault on the same page means some other
 			 * condition needs handling by do_page_fault(), the
<span class="p_chunk">@@ -267,9 +284,9 @@</span> <span class="p_context"> int kmmio_handler(struct pt_regs *regs, unsigned long addr)</span>
 	ctx-&gt;active++;
 
 	ctx-&gt;fpage = faultpage;
<span class="p_del">-	ctx-&gt;probe = get_kmmio_probe(addr);</span>
<span class="p_add">+	ctx-&gt;probe = get_kmmio_probe(page_base);</span>
 	ctx-&gt;saved_flags = (regs-&gt;flags &amp; (X86_EFLAGS_TF | X86_EFLAGS_IF));
<span class="p_del">-	ctx-&gt;addr = addr;</span>
<span class="p_add">+	ctx-&gt;addr = page_base;</span>
 
 	if (ctx-&gt;probe &amp;&amp; ctx-&gt;probe-&gt;pre_handler)
 		ctx-&gt;probe-&gt;pre_handler(ctx-&gt;probe, regs, addr);
<span class="p_chunk">@@ -354,12 +371,11 @@</span> <span class="p_context"> out:</span>
 }
 
 /* You must be holding kmmio_lock. */
<span class="p_del">-static int add_kmmio_fault_page(unsigned long page)</span>
<span class="p_add">+static int add_kmmio_fault_page(unsigned long addr)</span>
 {
 	struct kmmio_fault_page *f;
 
<span class="p_del">-	page &amp;= PAGE_MASK;</span>
<span class="p_del">-	f = get_kmmio_fault_page(page);</span>
<span class="p_add">+	f = get_kmmio_fault_page(addr);</span>
 	if (f) {
 		if (!f-&gt;count)
 			arm_kmmio_fault_page(f);
<span class="p_chunk">@@ -372,26 +388,25 @@</span> <span class="p_context"> static int add_kmmio_fault_page(unsigned long page)</span>
 		return -1;
 
 	f-&gt;count = 1;
<span class="p_del">-	f-&gt;page = page;</span>
<span class="p_add">+	f-&gt;addr = addr;</span>
 
 	if (arm_kmmio_fault_page(f)) {
 		kfree(f);
 		return -1;
 	}
 
<span class="p_del">-	list_add_rcu(&amp;f-&gt;list, kmmio_page_list(f-&gt;page));</span>
<span class="p_add">+	list_add_rcu(&amp;f-&gt;list, kmmio_page_list(f-&gt;addr));</span>
 
 	return 0;
 }
 
 /* You must be holding kmmio_lock. */
<span class="p_del">-static void release_kmmio_fault_page(unsigned long page,</span>
<span class="p_add">+static void release_kmmio_fault_page(unsigned long addr,</span>
 				struct kmmio_fault_page **release_list)
 {
 	struct kmmio_fault_page *f;
 
<span class="p_del">-	page &amp;= PAGE_MASK;</span>
<span class="p_del">-	f = get_kmmio_fault_page(page);</span>
<span class="p_add">+	f = get_kmmio_fault_page(addr);</span>
 	if (!f)
 		return;
 
<span class="p_chunk">@@ -420,18 +435,27 @@</span> <span class="p_context"> int register_kmmio_probe(struct kmmio_probe *p)</span>
 	int ret = 0;
 	unsigned long size = 0;
 	const unsigned long size_lim = p-&gt;len + (p-&gt;addr &amp; ~PAGE_MASK);
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte;</span>
 
 	spin_lock_irqsave(&amp;kmmio_lock, flags);
 	if (get_kmmio_probe(p-&gt;addr)) {
 		ret = -EEXIST;
 		goto out;
 	}
<span class="p_add">+</span>
<span class="p_add">+	pte = lookup_address(p-&gt;addr, &amp;l);</span>
<span class="p_add">+	if (!pte) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kmmio_count++;
 	list_add_rcu(&amp;p-&gt;list, &amp;kmmio_probes);
 	while (size &lt; size_lim) {
 		if (add_kmmio_fault_page(p-&gt;addr + size))
 			pr_err(&quot;Unable to set page fault.\n&quot;);
<span class="p_del">-		size += PAGE_SIZE;</span>
<span class="p_add">+		size += page_level_size(l);</span>
 	}
 out:
 	spin_unlock_irqrestore(&amp;kmmio_lock, flags);
<span class="p_chunk">@@ -506,11 +530,17 @@</span> <span class="p_context"> void unregister_kmmio_probe(struct kmmio_probe *p)</span>
 	const unsigned long size_lim = p-&gt;len + (p-&gt;addr &amp; ~PAGE_MASK);
 	struct kmmio_fault_page *release_list = NULL;
 	struct kmmio_delayed_release *drelease;
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	pte_t *pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = lookup_address(p-&gt;addr, &amp;l);</span>
<span class="p_add">+	if (!pte)</span>
<span class="p_add">+		return;</span>
 
 	spin_lock_irqsave(&amp;kmmio_lock, flags);
 	while (size &lt; size_lim) {
 		release_kmmio_fault_page(p-&gt;addr + size, &amp;release_list);
<span class="p_del">-		size += PAGE_SIZE;</span>
<span class="p_add">+		size += page_level_size(l);</span>
 	}
 	list_del_rcu(&amp;p-&gt;list);
 	kmmio_count--;
<span class="p_header">diff --git a/block/partition-generic.c b/block/partition-generic.c</span>
<span class="p_header">index 746935a5973c..a241e3900bc9 100644</span>
<span class="p_header">--- a/block/partition-generic.c</span>
<span class="p_header">+++ b/block/partition-generic.c</span>
<span class="p_chunk">@@ -349,15 +349,20 @@</span> <span class="p_context"> struct hd_struct *add_partition(struct gendisk *disk, int partno,</span>
 			goto out_del;
 	}
 
<span class="p_add">+	err = hd_ref_init(p);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		if (flags &amp; ADDPART_FLAG_WHOLEDISK)</span>
<span class="p_add">+			goto out_remove_file;</span>
<span class="p_add">+		goto out_del;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* everything is up and running, commence */
 	rcu_assign_pointer(ptbl-&gt;part[partno], p);
 
 	/* suppress uevent if the disk suppresses it */
 	if (!dev_get_uevent_suppress(ddev))
 		kobject_uevent(&amp;pdev-&gt;kobj, KOBJ_ADD);
<span class="p_del">-</span>
<span class="p_del">-	if (!hd_ref_init(p))</span>
<span class="p_del">-		return p;</span>
<span class="p_add">+	return p;</span>
 
 out_free_info:
 	free_part_info(p);
<span class="p_chunk">@@ -366,6 +371,8 @@</span> <span class="p_context"> out_free_stats:</span>
 out_free:
 	kfree(p);
 	return ERR_PTR(err);
<span class="p_add">+out_remove_file:</span>
<span class="p_add">+	device_remove_file(pdev, &amp;dev_attr_whole_disk);</span>
 out_del:
 	kobject_put(p-&gt;holder_dir);
 	device_del(pdev);
<span class="p_header">diff --git a/drivers/base/power/domain.c b/drivers/base/power/domain.c</span>
<span class="p_header">index 65f50eccd49b..a48824deabc5 100644</span>
<span class="p_header">--- a/drivers/base/power/domain.c</span>
<span class="p_header">+++ b/drivers/base/power/domain.c</span>
<span class="p_chunk">@@ -1381,7 +1381,7 @@</span> <span class="p_context"> int pm_genpd_remove_subdomain(struct generic_pm_domain *genpd,</span>
 
 	mutex_lock(&amp;genpd-&gt;lock);
 
<span class="p_del">-	if (!list_empty(&amp;subdomain-&gt;slave_links) || subdomain-&gt;device_count) {</span>
<span class="p_add">+	if (!list_empty(&amp;subdomain-&gt;master_links) || subdomain-&gt;device_count) {</span>
 		pr_warn(&quot;%s: unable to remove subdomain %s\n&quot;, genpd-&gt;name,
 			subdomain-&gt;name);
 		ret = -EBUSY;
<span class="p_header">diff --git a/drivers/base/power/opp/core.c b/drivers/base/power/opp/core.c</span>
<span class="p_header">index b8e76f75073b..f8580900c273 100644</span>
<span class="p_header">--- a/drivers/base/power/opp/core.c</span>
<span class="p_header">+++ b/drivers/base/power/opp/core.c</span>
<span class="p_chunk">@@ -809,8 +809,14 @@</span> <span class="p_context"> static int opp_parse_supplies(struct dev_pm_opp *opp, struct device *dev)</span>
 	}
 
 	opp-&gt;u_volt = microvolt[0];
<span class="p_del">-	opp-&gt;u_volt_min = microvolt[1];</span>
<span class="p_del">-	opp-&gt;u_volt_max = microvolt[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (count == 1) {</span>
<span class="p_add">+		opp-&gt;u_volt_min = opp-&gt;u_volt;</span>
<span class="p_add">+		opp-&gt;u_volt_max = opp-&gt;u_volt;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		opp-&gt;u_volt_min = microvolt[1];</span>
<span class="p_add">+		opp-&gt;u_volt_max = microvolt[2];</span>
<span class="p_add">+	}</span>
 
 	if (!of_property_read_u32(opp-&gt;np, &quot;opp-microamp&quot;, &amp;val))
 		opp-&gt;u_amp = val;
<span class="p_header">diff --git a/drivers/block/loop.c b/drivers/block/loop.c</span>
<span class="p_header">index 423f4ca7d712..80cf8add46ff 100644</span>
<span class="p_header">--- a/drivers/block/loop.c</span>
<span class="p_header">+++ b/drivers/block/loop.c</span>
<span class="p_chunk">@@ -488,6 +488,12 @@</span> <span class="p_context"> static int lo_rw_aio(struct loop_device *lo, struct loop_cmd *cmd,</span>
 	bvec = __bvec_iter_bvec(bio-&gt;bi_io_vec, bio-&gt;bi_iter);
 	iov_iter_bvec(&amp;iter, ITER_BVEC | rw, bvec,
 		      bio_segments(bio), blk_rq_bytes(cmd-&gt;rq));
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This bio may be started from the middle of the &#39;bvec&#39;</span>
<span class="p_add">+	 * because of bio splitting, so offset from the bvec must</span>
<span class="p_add">+	 * be passed to iov iterator</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	iter.iov_offset = bio-&gt;bi_iter.bi_bvec_done;</span>
 
 	cmd-&gt;iocb.ki_pos = pos;
 	cmd-&gt;iocb.ki_filp = file;
<span class="p_header">diff --git a/drivers/block/paride/pd.c b/drivers/block/paride/pd.c</span>
<span class="p_header">index 562b5a4ca7b7..78a39f736c64 100644</span>
<span class="p_header">--- a/drivers/block/paride/pd.c</span>
<span class="p_header">+++ b/drivers/block/paride/pd.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"></span>
 */
 #include &lt;linux/types.h&gt;
 
<span class="p_del">-static bool verbose = 0;</span>
<span class="p_add">+static int verbose = 0;</span>
 static int major = PD_MAJOR;
 static char *name = PD_NAME;
 static int cluster = 64;
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> enum {D_PRT, D_PRO, D_UNI, D_MOD, D_GEO, D_SBY, D_DLY, D_SLV};</span>
 static DEFINE_MUTEX(pd_mutex);
 static DEFINE_SPINLOCK(pd_lock);
 
<span class="p_del">-module_param(verbose, bool, 0);</span>
<span class="p_add">+module_param(verbose, int, 0);</span>
 module_param(major, int, 0);
 module_param(name, charp, 0);
 module_param(cluster, int, 0);
<span class="p_header">diff --git a/drivers/block/paride/pt.c b/drivers/block/paride/pt.c</span>
<span class="p_header">index 1740d75e8a32..216a94fed5b4 100644</span>
<span class="p_header">--- a/drivers/block/paride/pt.c</span>
<span class="p_header">+++ b/drivers/block/paride/pt.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"></span>
 
 */
 
<span class="p_del">-static bool verbose = 0;</span>
<span class="p_add">+static int verbose = 0;</span>
 static int major = PT_MAJOR;
 static char *name = PT_NAME;
 static int disable = 0;
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> static int (*drives[4])[6] = {&amp;drive0, &amp;drive1, &amp;drive2, &amp;drive3};</span>
 
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_del">-module_param(verbose, bool, 0);</span>
<span class="p_add">+module_param(verbose, int, 0);</span>
 module_param(major, int, 0);
 module_param(name, charp, 0);
 module_param_array(drive0, int, NULL, 0);
<span class="p_header">diff --git a/drivers/bus/imx-weim.c b/drivers/bus/imx-weim.c</span>
<span class="p_header">index e98d15eaa799..1827fc4d15c1 100644</span>
<span class="p_header">--- a/drivers/bus/imx-weim.c</span>
<span class="p_header">+++ b/drivers/bus/imx-weim.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static int __init weim_parse_dt(struct platform_device *pdev,</span>
 			return ret;
 	}
 
<span class="p_del">-	for_each_child_of_node(pdev-&gt;dev.of_node, child) {</span>
<span class="p_add">+	for_each_available_child_of_node(pdev-&gt;dev.of_node, child) {</span>
 		if (!child-&gt;name)
 			continue;
 
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index 98fb8821382d..f53b02a6bc05 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -667,6 +667,11 @@</span> <span class="p_context"> static int core_get_max_pstate(void)</span>
 			if (err)
 				goto skip_tar;
 
<span class="p_add">+			/* For level 1 and 2, bits[23:16] contain the ratio */</span>
<span class="p_add">+			if (tdp_ctrl)</span>
<span class="p_add">+				tdp_ratio &gt;&gt;= 16;</span>
<span class="p_add">+</span>
<span class="p_add">+			tdp_ratio &amp;= 0xff; /* ratios are only 8 bits long */</span>
 			if (tdp_ratio - 1 == tar) {
 				max_pstate = tar;
 				pr_debug(&quot;max_pstate=TAC %x\n&quot;, max_pstate);
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto-aes-cmac.c b/drivers/crypto/ccp/ccp-crypto-aes-cmac.c</span>
<span class="p_header">index 3d9acc53d247..60fc0fa26fd3 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto-aes-cmac.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto-aes-cmac.c</span>
<span class="p_chunk">@@ -225,6 +225,9 @@</span> <span class="p_context"> static int ccp_aes_cmac_export(struct ahash_request *req, void *out)</span>
 	struct ccp_aes_cmac_req_ctx *rctx = ahash_request_ctx(req);
 	struct ccp_aes_cmac_exp_ctx state;
 
<span class="p_add">+	/* Don&#39;t let anything leak to &#39;out&#39; */</span>
<span class="p_add">+	memset(&amp;state, 0, sizeof(state));</span>
<span class="p_add">+</span>
 	state.null_msg = rctx-&gt;null_msg;
 	memcpy(state.iv, rctx-&gt;iv, sizeof(state.iv));
 	state.buf_count = rctx-&gt;buf_count;
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto-sha.c b/drivers/crypto/ccp/ccp-crypto-sha.c</span>
<span class="p_header">index 8ef06fad8b14..ab9945f2cb7a 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto-sha.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto-sha.c</span>
<span class="p_chunk">@@ -212,6 +212,9 @@</span> <span class="p_context"> static int ccp_sha_export(struct ahash_request *req, void *out)</span>
 	struct ccp_sha_req_ctx *rctx = ahash_request_ctx(req);
 	struct ccp_sha_exp_ctx state;
 
<span class="p_add">+	/* Don&#39;t let anything leak to &#39;out&#39; */</span>
<span class="p_add">+	memset(&amp;state, 0, sizeof(state));</span>
<span class="p_add">+</span>
 	state.type = rctx-&gt;type;
 	state.msg_bits = rctx-&gt;msg_bits;
 	state.first = rctx-&gt;first;
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index b6f9f42e2985..a04fea4d0063 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -63,6 +63,14 @@</span> <span class="p_context"> static void to_talitos_ptr(struct talitos_ptr *ptr, dma_addr_t dma_addr,</span>
 		ptr-&gt;eptr = upper_32_bits(dma_addr);
 }
 
<span class="p_add">+static void copy_talitos_ptr(struct talitos_ptr *dst_ptr,</span>
<span class="p_add">+			     struct talitos_ptr *src_ptr, bool is_sec1)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dst_ptr-&gt;ptr = src_ptr-&gt;ptr;</span>
<span class="p_add">+	if (!is_sec1)</span>
<span class="p_add">+		dst_ptr-&gt;eptr = src_ptr-&gt;eptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void to_talitos_ptr_len(struct talitos_ptr *ptr, unsigned int len,
 			       bool is_sec1)
 {
<span class="p_chunk">@@ -1083,21 +1091,20 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 	sg_count = dma_map_sg(dev, areq-&gt;src, edesc-&gt;src_nents ?: 1,
 			      (areq-&gt;src == areq-&gt;dst) ? DMA_BIDIRECTIONAL
 							   : DMA_TO_DEVICE);
<span class="p_del">-</span>
 	/* hmac data */
 	desc-&gt;ptr[1].len = cpu_to_be16(areq-&gt;assoclen);
 	if (sg_count &gt; 1 &amp;&amp;
 	    (ret = sg_to_link_tbl_offset(areq-&gt;src, sg_count, 0,
 					 areq-&gt;assoclen,
 					 &amp;edesc-&gt;link_tbl[tbl_off])) &gt; 1) {
<span class="p_del">-		tbl_off += ret;</span>
<span class="p_del">-</span>
 		to_talitos_ptr(&amp;desc-&gt;ptr[1], edesc-&gt;dma_link_tbl + tbl_off *
 			       sizeof(struct talitos_ptr), 0);
 		desc-&gt;ptr[1].j_extent = DESC_PTR_LNKTBL_JUMP;
 
 		dma_sync_single_for_device(dev, edesc-&gt;dma_link_tbl,
 					   edesc-&gt;dma_len, DMA_BIDIRECTIONAL);
<span class="p_add">+</span>
<span class="p_add">+		tbl_off += ret;</span>
 	} else {
 		to_talitos_ptr(&amp;desc-&gt;ptr[1], sg_dma_address(areq-&gt;src), 0);
 		desc-&gt;ptr[1].j_extent = 0;
<span class="p_chunk">@@ -1126,11 +1133,13 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 	if (edesc-&gt;desc.hdr &amp; DESC_HDR_MODE1_MDEU_CICV)
 		sg_link_tbl_len += authsize;
 
<span class="p_del">-	if (sg_count &gt; 1 &amp;&amp;</span>
<span class="p_del">-	    (ret = sg_to_link_tbl_offset(areq-&gt;src, sg_count, areq-&gt;assoclen,</span>
<span class="p_del">-					 sg_link_tbl_len,</span>
<span class="p_del">-					 &amp;edesc-&gt;link_tbl[tbl_off])) &gt; 1) {</span>
<span class="p_del">-		tbl_off += ret;</span>
<span class="p_add">+	if (sg_count == 1) {</span>
<span class="p_add">+		to_talitos_ptr(&amp;desc-&gt;ptr[4], sg_dma_address(areq-&gt;src) +</span>
<span class="p_add">+			       areq-&gt;assoclen, 0);</span>
<span class="p_add">+	} else if ((ret = sg_to_link_tbl_offset(areq-&gt;src, sg_count,</span>
<span class="p_add">+						areq-&gt;assoclen, sg_link_tbl_len,</span>
<span class="p_add">+						&amp;edesc-&gt;link_tbl[tbl_off])) &gt;</span>
<span class="p_add">+		   1) {</span>
 		desc-&gt;ptr[4].j_extent |= DESC_PTR_LNKTBL_JUMP;
 		to_talitos_ptr(&amp;desc-&gt;ptr[4], edesc-&gt;dma_link_tbl +
 					      tbl_off *
<span class="p_chunk">@@ -1138,8 +1147,10 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 		dma_sync_single_for_device(dev, edesc-&gt;dma_link_tbl,
 					   edesc-&gt;dma_len,
 					   DMA_BIDIRECTIONAL);
<span class="p_del">-	} else</span>
<span class="p_del">-		to_talitos_ptr(&amp;desc-&gt;ptr[4], sg_dma_address(areq-&gt;src), 0);</span>
<span class="p_add">+		tbl_off += ret;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		copy_talitos_ptr(&amp;desc-&gt;ptr[4], &amp;edesc-&gt;link_tbl[tbl_off], 0);</span>
<span class="p_add">+	}</span>
 
 	/* cipher out */
 	desc-&gt;ptr[5].len = cpu_to_be16(cryptlen);
<span class="p_chunk">@@ -1151,11 +1162,13 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 
 	edesc-&gt;icv_ool = false;
 
<span class="p_del">-	if (sg_count &gt; 1 &amp;&amp;</span>
<span class="p_del">-	    (sg_count = sg_to_link_tbl_offset(areq-&gt;dst, sg_count,</span>
<span class="p_add">+	if (sg_count == 1) {</span>
<span class="p_add">+		to_talitos_ptr(&amp;desc-&gt;ptr[5], sg_dma_address(areq-&gt;dst) +</span>
<span class="p_add">+			       areq-&gt;assoclen, 0);</span>
<span class="p_add">+	} else if ((sg_count =</span>
<span class="p_add">+			sg_to_link_tbl_offset(areq-&gt;dst, sg_count,</span>
 					      areq-&gt;assoclen, cryptlen,
<span class="p_del">-					      &amp;edesc-&gt;link_tbl[tbl_off])) &gt;</span>
<span class="p_del">-	    1) {</span>
<span class="p_add">+					      &amp;edesc-&gt;link_tbl[tbl_off])) &gt; 1) {</span>
 		struct talitos_ptr *tbl_ptr = &amp;edesc-&gt;link_tbl[tbl_off];
 
 		to_talitos_ptr(&amp;desc-&gt;ptr[5], edesc-&gt;dma_link_tbl +
<span class="p_chunk">@@ -1178,8 +1191,9 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 					   edesc-&gt;dma_len, DMA_BIDIRECTIONAL);
 
 		edesc-&gt;icv_ool = true;
<span class="p_del">-	} else</span>
<span class="p_del">-		to_talitos_ptr(&amp;desc-&gt;ptr[5], sg_dma_address(areq-&gt;dst), 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		copy_talitos_ptr(&amp;desc-&gt;ptr[5], &amp;edesc-&gt;link_tbl[tbl_off], 0);</span>
<span class="p_add">+	}</span>
 
 	/* iv out */
 	map_single_talitos_ptr(dev, &amp;desc-&gt;ptr[6], ivsize, ctx-&gt;iv,
<span class="p_chunk">@@ -2519,21 +2533,11 @@</span> <span class="p_context"> struct talitos_crypto_alg {</span>
 	struct talitos_alg_template algt;
 };
 
<span class="p_del">-static int talitos_cra_init(struct crypto_tfm *tfm)</span>
<span class="p_add">+static int talitos_init_common(struct talitos_ctx *ctx,</span>
<span class="p_add">+			       struct talitos_crypto_alg *talitos_alg)</span>
 {
<span class="p_del">-	struct crypto_alg *alg = tfm-&gt;__crt_alg;</span>
<span class="p_del">-	struct talitos_crypto_alg *talitos_alg;</span>
<span class="p_del">-	struct talitos_ctx *ctx = crypto_tfm_ctx(tfm);</span>
 	struct talitos_private *priv;
 
<span class="p_del">-	if ((alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK) == CRYPTO_ALG_TYPE_AHASH)</span>
<span class="p_del">-		talitos_alg = container_of(__crypto_ahash_alg(alg),</span>
<span class="p_del">-					   struct talitos_crypto_alg,</span>
<span class="p_del">-					   algt.alg.hash);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		talitos_alg = container_of(alg, struct talitos_crypto_alg,</span>
<span class="p_del">-					   algt.alg.crypto);</span>
<span class="p_del">-</span>
 	/* update context with ptr to dev */
 	ctx-&gt;dev = talitos_alg-&gt;dev;
 
<span class="p_chunk">@@ -2551,10 +2555,33 @@</span> <span class="p_context"> static int talitos_cra_init(struct crypto_tfm *tfm)</span>
 	return 0;
 }
 
<span class="p_add">+static int talitos_cra_init(struct crypto_tfm *tfm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct crypto_alg *alg = tfm-&gt;__crt_alg;</span>
<span class="p_add">+	struct talitos_crypto_alg *talitos_alg;</span>
<span class="p_add">+	struct talitos_ctx *ctx = crypto_tfm_ctx(tfm);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((alg-&gt;cra_flags &amp; CRYPTO_ALG_TYPE_MASK) == CRYPTO_ALG_TYPE_AHASH)</span>
<span class="p_add">+		talitos_alg = container_of(__crypto_ahash_alg(alg),</span>
<span class="p_add">+					   struct talitos_crypto_alg,</span>
<span class="p_add">+					   algt.alg.hash);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		talitos_alg = container_of(alg, struct talitos_crypto_alg,</span>
<span class="p_add">+					   algt.alg.crypto);</span>
<span class="p_add">+</span>
<span class="p_add">+	return talitos_init_common(ctx, talitos_alg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int talitos_cra_init_aead(struct crypto_aead *tfm)
 {
<span class="p_del">-	talitos_cra_init(crypto_aead_tfm(tfm));</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	struct aead_alg *alg = crypto_aead_alg(tfm);</span>
<span class="p_add">+	struct talitos_crypto_alg *talitos_alg;</span>
<span class="p_add">+	struct talitos_ctx *ctx = crypto_aead_ctx(tfm);</span>
<span class="p_add">+</span>
<span class="p_add">+	talitos_alg = container_of(alg, struct talitos_crypto_alg,</span>
<span class="p_add">+				   algt.alg.aead);</span>
<span class="p_add">+</span>
<span class="p_add">+	return talitos_init_common(ctx, talitos_alg);</span>
 }
 
 static int talitos_cra_init_ahash(struct crypto_tfm *tfm)
<span class="p_header">diff --git a/drivers/dma/dw/core.c b/drivers/dma/dw/core.c</span>
<span class="p_header">index 4f099ea29f83..c66133b5e852 100644</span>
<span class="p_header">--- a/drivers/dma/dw/core.c</span>
<span class="p_header">+++ b/drivers/dma/dw/core.c</span>
<span class="p_chunk">@@ -130,26 +130,14 @@</span> <span class="p_context"> static void dwc_desc_put(struct dw_dma_chan *dwc, struct dw_desc *desc)</span>
 static void dwc_initialize(struct dw_dma_chan *dwc)
 {
 	struct dw_dma *dw = to_dw_dma(dwc-&gt;chan.device);
<span class="p_del">-	struct dw_dma_slave *dws = dwc-&gt;chan.private;</span>
 	u32 cfghi = DWC_CFGH_FIFO_MODE;
 	u32 cfglo = DWC_CFGL_CH_PRIOR(dwc-&gt;priority);
 
 	if (dwc-&gt;initialized == true)
 		return;
 
<span class="p_del">-	if (dws) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We need controller-specific data to set up slave</span>
<span class="p_del">-		 * transfers.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		BUG_ON(!dws-&gt;dma_dev || dws-&gt;dma_dev != dw-&gt;dma.dev);</span>
<span class="p_del">-</span>
<span class="p_del">-		cfghi |= DWC_CFGH_DST_PER(dws-&gt;dst_id);</span>
<span class="p_del">-		cfghi |= DWC_CFGH_SRC_PER(dws-&gt;src_id);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		cfghi |= DWC_CFGH_DST_PER(dwc-&gt;dst_id);</span>
<span class="p_del">-		cfghi |= DWC_CFGH_SRC_PER(dwc-&gt;src_id);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	cfghi |= DWC_CFGH_DST_PER(dwc-&gt;dst_id);</span>
<span class="p_add">+	cfghi |= DWC_CFGH_SRC_PER(dwc-&gt;src_id);</span>
 
 	channel_writel(dwc, CFG_LO, cfglo);
 	channel_writel(dwc, CFG_HI, cfghi);
<span class="p_chunk">@@ -936,7 +924,7 @@</span> <span class="p_context"> bool dw_dma_filter(struct dma_chan *chan, void *param)</span>
 	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
 	struct dw_dma_slave *dws = param;
 
<span class="p_del">-	if (!dws || dws-&gt;dma_dev != chan-&gt;device-&gt;dev)</span>
<span class="p_add">+	if (dws-&gt;dma_dev != chan-&gt;device-&gt;dev)</span>
 		return false;
 
 	/* We have to copy data since dws can be temporary storage */
<span class="p_chunk">@@ -1160,6 +1148,14 @@</span> <span class="p_context"> static int dwc_alloc_chan_resources(struct dma_chan *chan)</span>
 	 * doesn&#39;t mean what you think it means), and status writeback.
 	 */
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need controller-specific data to set up slave transfers.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (chan-&gt;private &amp;&amp; !dw_dma_filter(chan, chan-&gt;private)) {</span>
<span class="p_add">+		dev_warn(chan2dev(chan), &quot;Wrong controller-specific data\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Enable controller here if needed */
 	if (!dw-&gt;in_use)
 		dw_dma_on(dw);
<span class="p_chunk">@@ -1221,6 +1217,14 @@</span> <span class="p_context"> static void dwc_free_chan_resources(struct dma_chan *chan)</span>
 	spin_lock_irqsave(&amp;dwc-&gt;lock, flags);
 	list_splice_init(&amp;dwc-&gt;free_list, &amp;list);
 	dwc-&gt;descs_allocated = 0;
<span class="p_add">+</span>
<span class="p_add">+	/* Clear custom channel configuration */</span>
<span class="p_add">+	dwc-&gt;src_id = 0;</span>
<span class="p_add">+	dwc-&gt;dst_id = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	dwc-&gt;src_master = 0;</span>
<span class="p_add">+	dwc-&gt;dst_master = 0;</span>
<span class="p_add">+</span>
 	dwc-&gt;initialized = false;
 
 	/* Disable interrupts */
<span class="p_header">diff --git a/drivers/dma/hsu/hsu.c b/drivers/dma/hsu/hsu.c</span>
<span class="p_header">index 823ad728aecf..efc02b98e6ba 100644</span>
<span class="p_header">--- a/drivers/dma/hsu/hsu.c</span>
<span class="p_header">+++ b/drivers/dma/hsu/hsu.c</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> static u32 hsu_dma_chan_get_sr(struct hsu_dma_chan *hsuc)</span>
 	sr = hsu_chan_readl(hsuc, HSU_CH_SR);
 	spin_unlock_irqrestore(&amp;hsuc-&gt;vchan.lock, flags);
 
<span class="p_del">-	return sr;</span>
<span class="p_add">+	return sr &amp; ~(HSU_CH_SR_DESCE_ANY | HSU_CH_SR_CDESC_ANY);</span>
 }
 
 irqreturn_t hsu_dma_irq(struct hsu_dma_chip *chip, unsigned short nr)
<span class="p_header">diff --git a/drivers/dma/hsu/hsu.h b/drivers/dma/hsu/hsu.h</span>
<span class="p_header">index f06579c6d548..26da2865b025 100644</span>
<span class="p_header">--- a/drivers/dma/hsu/hsu.h</span>
<span class="p_header">+++ b/drivers/dma/hsu/hsu.h</span>
<span class="p_chunk">@@ -41,6 +41,9 @@</span> <span class="p_context"></span>
 #define HSU_CH_SR_DESCTO(x)	BIT(8 + (x))
 #define HSU_CH_SR_DESCTO_ANY	(BIT(11) | BIT(10) | BIT(9) | BIT(8))
 #define HSU_CH_SR_CHE		BIT(15)
<span class="p_add">+#define HSU_CH_SR_DESCE(x)	BIT(16 + (x))</span>
<span class="p_add">+#define HSU_CH_SR_DESCE_ANY	(BIT(19) | BIT(18) | BIT(17) | BIT(16))</span>
<span class="p_add">+#define HSU_CH_SR_CDESC_ANY	(BIT(31) | BIT(30))</span>
 
 /* Bits in HSU_CH_CR */
 #define HSU_CH_CR_CHA		BIT(0)
<span class="p_header">diff --git a/drivers/dma/pxa_dma.c b/drivers/dma/pxa_dma.c</span>
<span class="p_header">index a59061e4221a..55f5d33f6dc7 100644</span>
<span class="p_header">--- a/drivers/dma/pxa_dma.c</span>
<span class="p_header">+++ b/drivers/dma/pxa_dma.c</span>
<span class="p_chunk">@@ -122,6 +122,7 @@</span> <span class="p_context"> struct pxad_chan {</span>
 struct pxad_device {
 	struct dma_device		slave;
 	int				nr_chans;
<span class="p_add">+	int				nr_requestors;</span>
 	void __iomem			*base;
 	struct pxad_phy			*phys;
 	spinlock_t			phy_lock;	/* Phy association */
<span class="p_chunk">@@ -473,7 +474,7 @@</span> <span class="p_context"> static void pxad_free_phy(struct pxad_chan *chan)</span>
 		return;
 
 	/* clear the channel mapping in DRCMR */
<span class="p_del">-	if (chan-&gt;drcmr &lt;= DRCMR_CHLNUM) {</span>
<span class="p_add">+	if (chan-&gt;drcmr &lt;= pdev-&gt;nr_requestors) {</span>
 		reg = pxad_drcmr(chan-&gt;drcmr);
 		writel_relaxed(0, chan-&gt;phy-&gt;base + reg);
 	}
<span class="p_chunk">@@ -509,6 +510,7 @@</span> <span class="p_context"> static bool is_running_chan_misaligned(struct pxad_chan *chan)</span>
 
 static void phy_enable(struct pxad_phy *phy, bool misaligned)
 {
<span class="p_add">+	struct pxad_device *pdev;</span>
 	u32 reg, dalgn;
 
 	if (!phy-&gt;vchan)
<span class="p_chunk">@@ -518,7 +520,8 @@</span> <span class="p_context"> static void phy_enable(struct pxad_phy *phy, bool misaligned)</span>
 		&quot;%s(); phy=%p(%d) misaligned=%d\n&quot;, __func__,
 		phy, phy-&gt;idx, misaligned);
 
<span class="p_del">-	if (phy-&gt;vchan-&gt;drcmr &lt;= DRCMR_CHLNUM) {</span>
<span class="p_add">+	pdev = to_pxad_dev(phy-&gt;vchan-&gt;vc.chan.device);</span>
<span class="p_add">+	if (phy-&gt;vchan-&gt;drcmr &lt;= pdev-&gt;nr_requestors) {</span>
 		reg = pxad_drcmr(phy-&gt;vchan-&gt;drcmr);
 		writel_relaxed(DRCMR_MAPVLD | phy-&gt;idx, phy-&gt;base + reg);
 	}
<span class="p_chunk">@@ -914,6 +917,7 @@</span> <span class="p_context"> static void pxad_get_config(struct pxad_chan *chan,</span>
 {
 	u32 maxburst = 0, dev_addr = 0;
 	enum dma_slave_buswidth width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
<span class="p_add">+	struct pxad_device *pdev = to_pxad_dev(chan-&gt;vc.chan.device);</span>
 
 	*dcmd = 0;
 	if (dir == DMA_DEV_TO_MEM) {
<span class="p_chunk">@@ -922,7 +926,7 @@</span> <span class="p_context"> static void pxad_get_config(struct pxad_chan *chan,</span>
 		dev_addr = chan-&gt;cfg.src_addr;
 		*dev_src = dev_addr;
 		*dcmd |= PXA_DCMD_INCTRGADDR;
<span class="p_del">-		if (chan-&gt;drcmr &lt;= DRCMR_CHLNUM)</span>
<span class="p_add">+		if (chan-&gt;drcmr &lt;= pdev-&gt;nr_requestors)</span>
 			*dcmd |= PXA_DCMD_FLOWSRC;
 	}
 	if (dir == DMA_MEM_TO_DEV) {
<span class="p_chunk">@@ -931,7 +935,7 @@</span> <span class="p_context"> static void pxad_get_config(struct pxad_chan *chan,</span>
 		dev_addr = chan-&gt;cfg.dst_addr;
 		*dev_dst = dev_addr;
 		*dcmd |= PXA_DCMD_INCSRCADDR;
<span class="p_del">-		if (chan-&gt;drcmr &lt;= DRCMR_CHLNUM)</span>
<span class="p_add">+		if (chan-&gt;drcmr &lt;= pdev-&gt;nr_requestors)</span>
 			*dcmd |= PXA_DCMD_FLOWTRG;
 	}
 	if (dir == DMA_MEM_TO_MEM)
<span class="p_chunk">@@ -1341,13 +1345,15 @@</span> <span class="p_context"> static struct dma_chan *pxad_dma_xlate(struct of_phandle_args *dma_spec,</span>
 
 static int pxad_init_dmadev(struct platform_device *op,
 			    struct pxad_device *pdev,
<span class="p_del">-			    unsigned int nr_phy_chans)</span>
<span class="p_add">+			    unsigned int nr_phy_chans,</span>
<span class="p_add">+			    unsigned int nr_requestors)</span>
 {
 	int ret;
 	unsigned int i;
 	struct pxad_chan *c;
 
 	pdev-&gt;nr_chans = nr_phy_chans;
<span class="p_add">+	pdev-&gt;nr_requestors = nr_requestors;</span>
 	INIT_LIST_HEAD(&amp;pdev-&gt;slave.channels);
 	pdev-&gt;slave.device_alloc_chan_resources = pxad_alloc_chan_resources;
 	pdev-&gt;slave.device_free_chan_resources = pxad_free_chan_resources;
<span class="p_chunk">@@ -1382,7 +1388,7 @@</span> <span class="p_context"> static int pxad_probe(struct platform_device *op)</span>
 	const struct of_device_id *of_id;
 	struct mmp_dma_platdata *pdata = dev_get_platdata(&amp;op-&gt;dev);
 	struct resource *iores;
<span class="p_del">-	int ret, dma_channels = 0;</span>
<span class="p_add">+	int ret, dma_channels = 0, nb_requestors = 0;</span>
 	const enum dma_slave_buswidth widths =
 		DMA_SLAVE_BUSWIDTH_1_BYTE   | DMA_SLAVE_BUSWIDTH_2_BYTES |
 		DMA_SLAVE_BUSWIDTH_4_BYTES;
<span class="p_chunk">@@ -1399,13 +1405,23 @@</span> <span class="p_context"> static int pxad_probe(struct platform_device *op)</span>
 		return PTR_ERR(pdev-&gt;base);
 
 	of_id = of_match_device(pxad_dt_ids, &amp;op-&gt;dev);
<span class="p_del">-	if (of_id)</span>
<span class="p_add">+	if (of_id) {</span>
 		of_property_read_u32(op-&gt;dev.of_node, &quot;#dma-channels&quot;,
 				     &amp;dma_channels);
<span class="p_del">-	else if (pdata &amp;&amp; pdata-&gt;dma_channels)</span>
<span class="p_add">+		ret = of_property_read_u32(op-&gt;dev.of_node, &quot;#dma-requests&quot;,</span>
<span class="p_add">+					   &amp;nb_requestors);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_warn(pdev-&gt;slave.dev,</span>
<span class="p_add">+				 &quot;#dma-requests set to default 32 as missing in OF: %d&quot;,</span>
<span class="p_add">+				 ret);</span>
<span class="p_add">+			nb_requestors = 32;</span>
<span class="p_add">+		};</span>
<span class="p_add">+	} else if (pdata &amp;&amp; pdata-&gt;dma_channels) {</span>
 		dma_channels = pdata-&gt;dma_channels;
<span class="p_del">-	else</span>
<span class="p_add">+		nb_requestors = pdata-&gt;nb_requestors;</span>
<span class="p_add">+	} else {</span>
 		dma_channels = 32;	/* default 32 channel */
<span class="p_add">+	}</span>
 
 	dma_cap_set(DMA_SLAVE, pdev-&gt;slave.cap_mask);
 	dma_cap_set(DMA_MEMCPY, pdev-&gt;slave.cap_mask);
<span class="p_chunk">@@ -1422,7 +1438,7 @@</span> <span class="p_context"> static int pxad_probe(struct platform_device *op)</span>
 	pdev-&gt;slave.residue_granularity = DMA_RESIDUE_GRANULARITY_DESCRIPTOR;
 
 	pdev-&gt;slave.dev = &amp;op-&gt;dev;
<span class="p_del">-	ret = pxad_init_dmadev(op, pdev, dma_channels);</span>
<span class="p_add">+	ret = pxad_init_dmadev(op, pdev, dma_channels, nb_requestors);</span>
 	if (ret) {
 		dev_err(pdev-&gt;slave.dev, &quot;unable to register\n&quot;);
 		return ret;
<span class="p_chunk">@@ -1441,7 +1457,8 @@</span> <span class="p_context"> static int pxad_probe(struct platform_device *op)</span>
 
 	platform_set_drvdata(op, pdev);
 	pxad_init_debugfs(pdev);
<span class="p_del">-	dev_info(pdev-&gt;slave.dev, &quot;initialized %d channels\n&quot;, dma_channels);</span>
<span class="p_add">+	dev_info(pdev-&gt;slave.dev, &quot;initialized %d channels on %d requestors\n&quot;,</span>
<span class="p_add">+		 dma_channels, nb_requestors);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c</span>
<span class="p_header">index 01087a38da22..792bdae2b91d 100644</span>
<span class="p_header">--- a/drivers/edac/i7core_edac.c</span>
<span class="p_header">+++ b/drivers/edac/i7core_edac.c</span>
<span class="p_chunk">@@ -1866,7 +1866,7 @@</span> <span class="p_context"> static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,</span>
 
 	i7_dev = get_i7core_dev(mce-&gt;socketid);
 	if (!i7_dev)
<span class="p_del">-		return NOTIFY_BAD;</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
 
 	mci = i7_dev-&gt;mci;
 	pvt = mci-&gt;pvt_info;
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index cbee3179ec08..37649221f81c 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -1396,7 +1396,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 	}
 
 	ch_way = TAD_CH(reg) + 1;
<span class="p_del">-	sck_way = 1 &lt;&lt; TAD_SOCK(reg);</span>
<span class="p_add">+	sck_way = TAD_SOCK(reg);</span>
 
 	if (ch_way == 3)
 		idx = addr &gt;&gt; 6;
<span class="p_chunk">@@ -1435,7 +1435,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 		switch(ch_way) {
 		case 2:
 		case 4:
<span class="p_del">-			sck_xch = 1 &lt;&lt; sck_way * (ch_way &gt;&gt; 1);</span>
<span class="p_add">+			sck_xch = (1 &lt;&lt; sck_way) * (ch_way &gt;&gt; 1);</span>
 			break;
 		default:
 			sprintf(msg, &quot;Invalid mirror set. Can&#39;t decode addr&quot;);
<span class="p_chunk">@@ -1471,7 +1471,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 
 	ch_addr = addr - offset;
 	ch_addr &gt;&gt;= (6 + shiftup);
<span class="p_del">-	ch_addr /= ch_way * sck_way;</span>
<span class="p_add">+	ch_addr /= sck_xch;</span>
 	ch_addr &lt;&lt;= (6 + shiftup);
 	ch_addr |= addr &amp; ((1 &lt;&lt; (6 + shiftup)) - 1);
 
<span class="p_chunk">@@ -2254,7 +2254,7 @@</span> <span class="p_context"> static int sbridge_mce_check_error(struct notifier_block *nb, unsigned long val,</span>
 
 	mci = get_mci_for_node_id(mce-&gt;socketid);
 	if (!mci)
<span class="p_del">-		return NOTIFY_BAD;</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
 	pvt = mci-&gt;pvt_info;
 
 	/*
<span class="p_header">diff --git a/drivers/extcon/extcon-max77843.c b/drivers/extcon/extcon-max77843.c</span>
<span class="p_header">index 9f9ea334399c..b6cb30d207be 100644</span>
<span class="p_header">--- a/drivers/extcon/extcon-max77843.c</span>
<span class="p_header">+++ b/drivers/extcon/extcon-max77843.c</span>
<span class="p_chunk">@@ -803,7 +803,7 @@</span> <span class="p_context"> static int max77843_muic_probe(struct platform_device *pdev)</span>
 	/* Clear IRQ bits before request IRQs */
 	ret = regmap_bulk_read(max77843-&gt;regmap_muic,
 			MAX77843_MUIC_REG_INT1, info-&gt;status,
<span class="p_del">-			MAX77843_MUIC_IRQ_NUM);</span>
<span class="p_add">+			MAX77843_MUIC_STATUS_NUM);</span>
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to Clear IRQ bits\n&quot;);
 		goto err_muic_irq;
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index 027ca212179f..3b52677f459a 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -180,6 +180,7 @@</span> <span class="p_context"> static int generic_ops_register(void)</span>
 {
 	generic_ops.get_variable = efi.get_variable;
 	generic_ops.set_variable = efi.set_variable;
<span class="p_add">+	generic_ops.set_variable_nonblocking = efi.set_variable_nonblocking;</span>
 	generic_ops.get_next_variable = efi.get_next_variable;
 	generic_ops.query_variable_store = efi_query_variable_store;
 
<span class="p_header">diff --git a/drivers/firmware/efi/vars.c b/drivers/firmware/efi/vars.c</span>
<span class="p_header">index 7f2ea21c730d..6f182fd91a6d 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/vars.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/vars.c</span>
<span class="p_chunk">@@ -202,29 +202,44 @@</span> <span class="p_context"> static const struct variable_validate variable_validate[] = {</span>
 	{ NULL_GUID, &quot;&quot;, NULL },
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Check if @var_name matches the pattern given in @match_name.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @var_name: an array of @len non-NUL characters.</span>
<span class="p_add">+ * @match_name: a NUL-terminated pattern string, optionally ending in &quot;*&quot;. A</span>
<span class="p_add">+ *              final &quot;*&quot; character matches any trailing characters @var_name,</span>
<span class="p_add">+ *              including the case when there are none left in @var_name.</span>
<span class="p_add">+ * @match: on output, the number of non-wildcard characters in @match_name</span>
<span class="p_add">+ *         that @var_name matches, regardless of the return value.</span>
<span class="p_add">+ * @return: whether @var_name fully matches @match_name.</span>
<span class="p_add">+ */</span>
 static bool
 variable_matches(const char *var_name, size_t len, const char *match_name,
 		 int *match)
 {
 	for (*match = 0; ; (*match)++) {
 		char c = match_name[*match];
<span class="p_del">-		char u = var_name[*match];</span>
 
<span class="p_del">-		/* Wildcard in the matching name means we&#39;ve matched */</span>
<span class="p_del">-		if (c == &#39;*&#39;)</span>
<span class="p_add">+		switch (c) {</span>
<span class="p_add">+		case &#39;*&#39;:</span>
<span class="p_add">+			/* Wildcard in @match_name means we&#39;ve matched. */</span>
 			return true;
 
<span class="p_del">-		/* Case sensitive match */</span>
<span class="p_del">-		if (!c &amp;&amp; *match == len)</span>
<span class="p_del">-			return true;</span>
<span class="p_add">+		case &#39;\0&#39;:</span>
<span class="p_add">+			/* @match_name has ended. Has @var_name too? */</span>
<span class="p_add">+			return (*match == len);</span>
 
<span class="p_del">-		if (c != u)</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We&#39;ve reached a non-wildcard char in @match_name.</span>
<span class="p_add">+			 * Continue only if there&#39;s an identical character in</span>
<span class="p_add">+			 * @var_name.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (*match &lt; len &amp;&amp; c == var_name[*match])</span>
<span class="p_add">+				continue;</span>
 			return false;
<span class="p_del">-</span>
<span class="p_del">-		if (!c)</span>
<span class="p_del">-			return true;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-	return true;</span>
 }
 
 bool
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">index bb1099c549df..053fc2f465df 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_chunk">@@ -1673,6 +1673,7 @@</span> <span class="p_context"> struct amdgpu_uvd {</span>
 	struct amdgpu_bo	*vcpu_bo;
 	void			*cpu_addr;
 	uint64_t		gpu_addr;
<span class="p_add">+	unsigned		fw_version;</span>
 	atomic_t		handles[AMDGPU_MAX_UVD_HANDLES];
 	struct drm_file		*filp[AMDGPU_MAX_UVD_HANDLES];
 	struct delayed_work	idle_work;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">index 8ac49812a716..5a8fbadbd27b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_chunk">@@ -63,10 +63,6 @@</span> <span class="p_context"> bool amdgpu_has_atpx(void) {</span>
 	return amdgpu_atpx_priv.atpx_detected;
 }
 
<span class="p_del">-bool amdgpu_has_atpx_dgpu_power_cntl(void) {</span>
<span class="p_del">-	return amdgpu_atpx_priv.atpx.functions.power_cntl;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * amdgpu_atpx_call - call an ATPX method
  *
<span class="p_chunk">@@ -146,6 +142,10 @@</span> <span class="p_context"> static void amdgpu_atpx_parse_functions(struct amdgpu_atpx_functions *f, u32 mas</span>
  */
 static int amdgpu_atpx_validate(struct amdgpu_atpx *atpx)
 {
<span class="p_add">+	/* make sure required functions are enabled */</span>
<span class="p_add">+	/* dGPU power control is required */</span>
<span class="p_add">+	atpx-&gt;functions.power_cntl = true;</span>
<span class="p_add">+</span>
 	if (atpx-&gt;functions.px_params) {
 		union acpi_object *info;
 		struct atpx_px_params output;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">index 9d88023df836..c961fe093e12 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_chunk">@@ -61,12 +61,6 @@</span> <span class="p_context"> static const char *amdgpu_asic_name[] = {</span>
 	&quot;LAST&quot;,
 };
 
<span class="p_del">-#if defined(CONFIG_VGA_SWITCHEROO)</span>
<span class="p_del">-bool amdgpu_has_atpx_dgpu_power_cntl(void);</span>
<span class="p_del">-#else</span>
<span class="p_del">-static inline bool amdgpu_has_atpx_dgpu_power_cntl(void) { return false; }</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 bool amdgpu_device_is_px(struct drm_device *dev)
 {
 	struct amdgpu_device *adev = dev-&gt;dev_private;
<span class="p_chunk">@@ -1475,7 +1469,7 @@</span> <span class="p_context"> int amdgpu_device_init(struct amdgpu_device *adev,</span>
 
 	if (amdgpu_runtime_pm == 1)
 		runtime = true;
<span class="p_del">-	if (amdgpu_device_is_px(ddev) &amp;&amp; amdgpu_has_atpx_dgpu_power_cntl())</span>
<span class="p_add">+	if (amdgpu_device_is_px(ddev))</span>
 		runtime = true;
 	vga_switcheroo_register_client(adev-&gt;pdev, &amp;amdgpu_switcheroo_ops, runtime);
 	if (runtime)
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_header">index e23843f4d877..4488e82f87b0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_chunk">@@ -303,7 +303,7 @@</span> <span class="p_context"> static int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file</span>
 			fw_info.feature = adev-&gt;vce.fb_version;
 			break;
 		case AMDGPU_INFO_FW_UVD:
<span class="p_del">-			fw_info.ver = 0;</span>
<span class="p_add">+			fw_info.ver = adev-&gt;uvd.fw_version;</span>
 			fw_info.feature = 0;
 			break;
 		case AMDGPU_INFO_FW_GMC:
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h</span>
<span class="p_header">index 064ebb347074..89df7871653d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> struct amdgpu_hpd;</span>
 
 #define AMDGPU_MAX_HPD_PINS 6
 #define AMDGPU_MAX_CRTCS 6
<span class="p_del">-#define AMDGPU_MAX_AFMT_BLOCKS 7</span>
<span class="p_add">+#define AMDGPU_MAX_AFMT_BLOCKS 9</span>
 
 enum amdgpu_rmx_type {
 	RMX_OFF,
<span class="p_chunk">@@ -308,8 +308,8 @@</span> <span class="p_context"> struct amdgpu_mode_info {</span>
 	struct atom_context *atom_context;
 	struct card_info *atom_card_info;
 	bool mode_config_initialized;
<span class="p_del">-	struct amdgpu_crtc *crtcs[6];</span>
<span class="p_del">-	struct amdgpu_afmt *afmt[7];</span>
<span class="p_add">+	struct amdgpu_crtc *crtcs[AMDGPU_MAX_CRTCS];</span>
<span class="p_add">+	struct amdgpu_afmt *afmt[AMDGPU_MAX_AFMT_BLOCKS];</span>
 	/* DVI-I properties */
 	struct drm_property *coherent_mode_property;
 	/* DAC enable load detect */
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c</span>
<span class="p_header">index 53f987aeeacf..3b35ad83867c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c</span>
<span class="p_chunk">@@ -156,6 +156,9 @@</span> <span class="p_context"> int amdgpu_uvd_sw_init(struct amdgpu_device *adev)</span>
 	DRM_INFO(&quot;Found UVD firmware Version: %hu.%hu Family ID: %hu\n&quot;,
 		version_major, version_minor, family_id);
 
<span class="p_add">+	adev-&gt;uvd.fw_version = ((version_major &lt;&lt; 24) | (version_minor &lt;&lt; 16) |</span>
<span class="p_add">+				(family_id &lt;&lt; 8));</span>
<span class="p_add">+</span>
 	bo_size = AMDGPU_GPU_PAGE_ALIGN(le32_to_cpu(hdr-&gt;ucode_size_bytes) + 8)
 		 +  AMDGPU_UVD_STACK_SIZE + AMDGPU_UVD_HEAP_SIZE;
 	r = amdgpu_bo_create(adev, bo_size, PAGE_SIZE, true,
<span class="p_chunk">@@ -273,6 +276,8 @@</span> <span class="p_context"> int amdgpu_uvd_resume(struct amdgpu_device *adev)</span>
 	memcpy(adev-&gt;uvd.cpu_addr, (adev-&gt;uvd.fw-&gt;data) + offset,
 		(adev-&gt;uvd.fw-&gt;size) - offset);
 
<span class="p_add">+	cancel_delayed_work_sync(&amp;adev-&gt;uvd.idle_work);</span>
<span class="p_add">+</span>
 	size = amdgpu_bo_size(adev-&gt;uvd.vcpu_bo);
 	size -= le32_to_cpu(hdr-&gt;ucode_size_bytes);
 	ptr = adev-&gt;uvd.cpu_addr;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_header">index a745eeeb5d82..bb0da76051a1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_chunk">@@ -220,6 +220,7 @@</span> <span class="p_context"> int amdgpu_vce_suspend(struct amdgpu_device *adev)</span>
 	if (i == AMDGPU_MAX_VCE_HANDLES)
 		return 0;
 
<span class="p_add">+	cancel_delayed_work_sync(&amp;adev-&gt;vce.idle_work);</span>
 	/* TODO: suspending running encoding sessions isn&#39;t supported */
 	return -EINVAL;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c</span>
<span class="p_header">index aa491540ba85..946300764609 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c</span>
<span class="p_chunk">@@ -3628,7 +3628,7 @@</span> <span class="p_context"> static void gfx_v7_0_ring_emit_vm_flush(struct amdgpu_ring *ring,</span>
 					unsigned vm_id, uint64_t pd_addr)
 {
 	int usepfp = (ring-&gt;type == AMDGPU_RING_TYPE_GFX);
<span class="p_del">-	uint32_t seq = ring-&gt;fence_drv.sync_seq;</span>
<span class="p_add">+	uint32_t seq = ring-&gt;fence_drv.sync_seq[ring-&gt;idx];</span>
 	uint64_t addr = ring-&gt;fence_drv.gpu_addr;
 
 	amdgpu_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_dbgdev.c b/drivers/gpu/drm/amd/amdkfd/kfd_dbgdev.c</span>
<span class="p_header">index c34c393e9aea..d5e19b5fbbfb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdkfd/kfd_dbgdev.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdkfd/kfd_dbgdev.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static int dbgdev_wave_control_set_registers(</span>
 				union SQ_CMD_BITS *in_reg_sq_cmd,
 				union GRBM_GFX_INDEX_BITS *in_reg_gfx_index)
 {
<span class="p_del">-	int status;</span>
<span class="p_add">+	int status = 0;</span>
 	union SQ_CMD_BITS reg_sq_cmd;
 	union GRBM_GFX_INDEX_BITS reg_gfx_index;
 	struct HsaDbgWaveMsgAMDGen2 *pMsg;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">index 39d7e2e15c11..d268bf18a662 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_chunk">@@ -1665,13 +1665,19 @@</span> <span class="p_context"> static int drm_dp_payload_send_msg(struct drm_dp_mst_topology_mgr *mgr,</span>
 	struct drm_dp_mst_branch *mstb;
 	int len, ret, port_num;
 
<span class="p_add">+	port = drm_dp_get_validated_port_ref(mgr, port);</span>
<span class="p_add">+	if (!port)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	port_num = port-&gt;port_num;
 	mstb = drm_dp_get_validated_mstb_ref(mgr, port-&gt;parent);
 	if (!mstb) {
 		mstb = drm_dp_get_last_connected_port_and_mstb(mgr, port-&gt;parent, &amp;port_num);
 
<span class="p_del">-		if (!mstb)</span>
<span class="p_add">+		if (!mstb) {</span>
<span class="p_add">+			drm_dp_put_port(port);</span>
 			return -EINVAL;
<span class="p_add">+		}</span>
 	}
 
 	txmsg = kzalloc(sizeof(*txmsg), GFP_KERNEL);
<span class="p_chunk">@@ -1697,6 +1703,7 @@</span> <span class="p_context"> static int drm_dp_payload_send_msg(struct drm_dp_mst_topology_mgr *mgr,</span>
 	kfree(txmsg);
 fail_put:
 	drm_dp_put_mst_branch_device(mstb);
<span class="p_add">+	drm_dp_put_port(port);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1779,6 +1786,11 @@</span> <span class="p_context"> int drm_dp_update_payload_part1(struct drm_dp_mst_topology_mgr *mgr)</span>
 		req_payload.start_slot = cur_slots;
 		if (mgr-&gt;proposed_vcpis[i]) {
 			port = container_of(mgr-&gt;proposed_vcpis[i], struct drm_dp_mst_port, vcpi);
<span class="p_add">+			port = drm_dp_get_validated_port_ref(mgr, port);</span>
<span class="p_add">+			if (!port) {</span>
<span class="p_add">+				mutex_unlock(&amp;mgr-&gt;payload_lock);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
 			req_payload.num_slots = mgr-&gt;proposed_vcpis[i]-&gt;num_slots;
 		} else {
 			port = NULL;
<span class="p_chunk">@@ -1804,6 +1816,9 @@</span> <span class="p_context"> int drm_dp_update_payload_part1(struct drm_dp_mst_topology_mgr *mgr)</span>
 			mgr-&gt;payloads[i].payload_state = req_payload.payload_state;
 		}
 		cur_slots += req_payload.num_slots;
<span class="p_add">+</span>
<span class="p_add">+		if (port)</span>
<span class="p_add">+			drm_dp_put_port(port);</span>
 	}
 
 	for (i = 0; i &lt; mgr-&gt;max_payloads; i++) {
<span class="p_chunk">@@ -2109,6 +2124,8 @@</span> <span class="p_context"> int drm_dp_mst_topology_mgr_resume(struct drm_dp_mst_topology_mgr *mgr)</span>
 
 	if (mgr-&gt;mst_primary) {
 		int sret;
<span class="p_add">+		u8 guid[16];</span>
<span class="p_add">+</span>
 		sret = drm_dp_dpcd_read(mgr-&gt;aux, DP_DPCD_REV, mgr-&gt;dpcd, DP_RECEIVER_CAP_SIZE);
 		if (sret != DP_RECEIVER_CAP_SIZE) {
 			DRM_DEBUG_KMS(&quot;dpcd read failed - undocked during suspend?\n&quot;);
<span class="p_chunk">@@ -2123,6 +2140,16 @@</span> <span class="p_context"> int drm_dp_mst_topology_mgr_resume(struct drm_dp_mst_topology_mgr *mgr)</span>
 			ret = -1;
 			goto out_unlock;
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* Some hubs forget their guids after they resume */</span>
<span class="p_add">+		sret = drm_dp_dpcd_read(mgr-&gt;aux, DP_GUID, guid, 16);</span>
<span class="p_add">+		if (sret != 16) {</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;dpcd read failed - undocked during suspend?\n&quot;);</span>
<span class="p_add">+			ret = -1;</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		drm_dp_check_mstb_guid(mgr-&gt;mst_primary, guid);</span>
<span class="p_add">+</span>
 		ret = 0;
 	} else
 		ret = -1;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index f859a5b87ed4..afa81691163d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -4447,7 +4447,7 @@</span> <span class="p_context"> int skl_update_scaler_crtc(struct intel_crtc_state *state)</span>
 		      intel_crtc-&gt;base.base.id, intel_crtc-&gt;pipe, SKL_CRTC_INDEX);
 
 	return skl_update_scaler(state, !state-&gt;base.active, SKL_CRTC_INDEX,
<span class="p_del">-		&amp;state-&gt;scaler_state.scaler_id, DRM_ROTATE_0,</span>
<span class="p_add">+		&amp;state-&gt;scaler_state.scaler_id, BIT(DRM_ROTATE_0),</span>
 		state-&gt;pipe_src_w, state-&gt;pipe_src_h,
 		adjusted_mode-&gt;crtc_hdisplay, adjusted_mode-&gt;crtc_vdisplay);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp_mst.c b/drivers/gpu/drm/i915/intel_dp_mst.c</span>
<span class="p_header">index 0639275fc471..06bd9257acdc 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp_mst.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp_mst.c</span>
<span class="p_chunk">@@ -477,6 +477,8 @@</span> <span class="p_context"> static void intel_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,</span>
 	struct intel_connector *intel_connector = to_intel_connector(connector);
 	struct drm_device *dev = connector-&gt;dev;
 
<span class="p_add">+	intel_connector-&gt;unregister(intel_connector);</span>
<span class="p_add">+</span>
 	/* need to nuke the connector */
 	drm_modeset_lock_all(dev);
 	if (connector-&gt;state-&gt;crtc) {
<span class="p_chunk">@@ -490,11 +492,7 @@</span> <span class="p_context"> static void intel_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,</span>
 
 		WARN(ret, &quot;Disabling mst crtc failed with %i\n&quot;, ret);
 	}
<span class="p_del">-	drm_modeset_unlock_all(dev);</span>
 
<span class="p_del">-	intel_connector-&gt;unregister(intel_connector);</span>
<span class="p_del">-</span>
<span class="p_del">-	drm_modeset_lock_all(dev);</span>
 	intel_connector_remove_from_fbdev(intel_connector);
 	drm_connector_cleanup(connector);
 	drm_modeset_unlock_all(dev);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">index d69547a65dbb..7058f75c7b42 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_chunk">@@ -776,11 +776,11 @@</span> <span class="p_context"> static int logical_ring_prepare(struct drm_i915_gem_request *req, int bytes)</span>
 		if (unlikely(total_bytes &gt; remain_usable)) {
 			/*
 			 * The base request will fit but the reserved space
<span class="p_del">-			 * falls off the end. So only need to to wait for the</span>
<span class="p_del">-			 * reserved size after flushing out the remainder.</span>
<span class="p_add">+			 * falls off the end. So don&#39;t need an immediate wrap</span>
<span class="p_add">+			 * and only need to effectively wait for the reserved</span>
<span class="p_add">+			 * size space from the start of ringbuffer.</span>
 			 */
 			wait_bytes = remain_actual + ringbuf-&gt;reserved_size;
<span class="p_del">-			need_wrap = true;</span>
 		} else if (total_bytes &gt; ringbuf-&gt;space) {
 			/* No wrapping required, just waiting. */
 			wait_bytes = total_bytes;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.c b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">index f6b2a814e629..9d48443bca2e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_chunk">@@ -1922,6 +1922,17 @@</span> <span class="p_context"> i915_dispatch_execbuffer(struct drm_i915_gem_request *req,</span>
 	return 0;
 }
 
<span class="p_add">+static void cleanup_phys_status_page(struct intel_engine_cs *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(ring-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev_priv-&gt;status_page_dmah)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	drm_pci_free(ring-&gt;dev, dev_priv-&gt;status_page_dmah);</span>
<span class="p_add">+	ring-&gt;status_page.page_addr = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cleanup_status_page(struct intel_engine_cs *ring)
 {
 	struct drm_i915_gem_object *obj;
<span class="p_chunk">@@ -1938,9 +1949,9 @@</span> <span class="p_context"> static void cleanup_status_page(struct intel_engine_cs *ring)</span>
 
 static int init_status_page(struct intel_engine_cs *ring)
 {
<span class="p_del">-	struct drm_i915_gem_object *obj;</span>
<span class="p_add">+	struct drm_i915_gem_object *obj = ring-&gt;status_page.obj;</span>
 
<span class="p_del">-	if ((obj = ring-&gt;status_page.obj) == NULL) {</span>
<span class="p_add">+	if (obj == NULL) {</span>
 		unsigned flags;
 		int ret;
 
<span class="p_chunk">@@ -2134,7 +2145,7 @@</span> <span class="p_context"> static int intel_init_ring_buffer(struct drm_device *dev,</span>
 		if (ret)
 			goto error;
 	} else {
<span class="p_del">-		BUG_ON(ring-&gt;id != RCS);</span>
<span class="p_add">+		WARN_ON(ring-&gt;id != RCS);</span>
 		ret = init_phys_status_page(ring);
 		if (ret)
 			goto error;
<span class="p_chunk">@@ -2179,7 +2190,12 @@</span> <span class="p_context"> void intel_cleanup_ring_buffer(struct intel_engine_cs *ring)</span>
 	if (ring-&gt;cleanup)
 		ring-&gt;cleanup(ring);
 
<span class="p_del">-	cleanup_status_page(ring);</span>
<span class="p_add">+	if (I915_NEED_GFX_HWS(ring-&gt;dev)) {</span>
<span class="p_add">+		cleanup_status_page(ring);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		WARN_ON(ring-&gt;id != RCS);</span>
<span class="p_add">+		cleanup_phys_status_page(ring);</span>
<span class="p_add">+	}</span>
 
 	i915_cmd_parser_fini_ring(ring);
 	i915_gem_batch_pool_fini(&amp;ring-&gt;batch_pool);
<span class="p_chunk">@@ -2341,11 +2357,11 @@</span> <span class="p_context"> static int __intel_ring_prepare(struct intel_engine_cs *ring, int bytes)</span>
 		if (unlikely(total_bytes &gt; remain_usable)) {
 			/*
 			 * The base request will fit but the reserved space
<span class="p_del">-			 * falls off the end. So only need to to wait for the</span>
<span class="p_del">-			 * reserved size after flushing out the remainder.</span>
<span class="p_add">+			 * falls off the end. So don&#39;t need an immediate wrap</span>
<span class="p_add">+			 * and only need to effectively wait for the reserved</span>
<span class="p_add">+			 * size space from the start of ringbuffer.</span>
 			 */
 			wait_bytes = remain_actual + ringbuf-&gt;reserved_size;
<span class="p_del">-			need_wrap = true;</span>
 		} else if (total_bytes &gt; ringbuf-&gt;space) {
 			/* No wrapping required, just waiting. */
 			wait_bytes = total_bytes;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_uncore.c b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">index 43cba129a0c0..cc91ae832ffb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_chunk">@@ -1132,7 +1132,11 @@</span> <span class="p_context"> static void intel_uncore_fw_domains_init(struct drm_device *dev)</span>
 	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
 		dev_priv-&gt;uncore.funcs.force_wake_get =
 			fw_domains_get_with_thread_status;
<span class="p_del">-		dev_priv-&gt;uncore.funcs.force_wake_put = fw_domains_put;</span>
<span class="p_add">+		if (IS_HASWELL(dev))</span>
<span class="p_add">+			dev_priv-&gt;uncore.funcs.force_wake_put =</span>
<span class="p_add">+				fw_domains_put_with_fifo;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			dev_priv-&gt;uncore.funcs.force_wake_put = fw_domains_put;</span>
 		fw_domain_init(dev_priv, FW_DOMAIN_ID_RENDER,
 			       FORCEWAKE_MT, FORCEWAKE_ACK_HSW);
 	} else if (IS_IVYBRIDGE(dev)) {
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c</span>
<span class="p_header">index 3216e157a8a0..89da47234016 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c</span>
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> nvkm_ramht_del(struct nvkm_ramht **pramht)</span>
 	struct nvkm_ramht *ramht = *pramht;
 	if (ramht) {
 		nvkm_gpuobj_del(&amp;ramht-&gt;gpuobj);
<span class="p_del">-		kfree(*pramht);</span>
<span class="p_add">+		vfree(*pramht);</span>
 		*pramht = NULL;
 	}
 }
<span class="p_chunk">@@ -143,8 +143,8 @@</span> <span class="p_context"> nvkm_ramht_new(struct nvkm_device *device, u32 size, u32 align,</span>
 	struct nvkm_ramht *ramht;
 	int ret, i;
 
<span class="p_del">-	if (!(ramht = *pramht = kzalloc(sizeof(*ramht) + (size &gt;&gt; 3) *</span>
<span class="p_del">-					sizeof(*ramht-&gt;data), GFP_KERNEL)))</span>
<span class="p_add">+	if (!(ramht = *pramht = vzalloc(sizeof(*ramht) +</span>
<span class="p_add">+					(size &gt;&gt; 3) * sizeof(*ramht-&gt;data))))</span>
 		return -ENOMEM;
 
 	ramht-&gt;device = device;
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c</span>
<span class="p_header">index 9f5dfc85147a..36655a74c538 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c</span>
<span class="p_chunk">@@ -1717,6 +1717,8 @@</span> <span class="p_context"> gf100_gr_init(struct gf100_gr *gr)</span>
 
 	gf100_gr_mmio(gr, gr-&gt;func-&gt;mmio);
 
<span class="p_add">+	nvkm_mask(device, TPC_UNIT(0, 0, 0x05c), 0x00000001, 0x00000001);</span>
<span class="p_add">+</span>
 	memcpy(tpcnr, gr-&gt;tpc_nr, sizeof(gr-&gt;tpc_nr));
 	for (i = 0, gpc = -1; i &lt; gr-&gt;tpc_total; i++) {
 		do {
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_display.c b/drivers/gpu/drm/qxl/qxl_display.c</span>
<span class="p_header">index 183aea1abebc..5edebf495c07 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_display.c</span>
<span class="p_chunk">@@ -375,10 +375,15 @@</span> <span class="p_context"> static int qxl_crtc_cursor_set2(struct drm_crtc *crtc,</span>
 
 	qxl_bo_kunmap(user_bo);
 
<span class="p_add">+	qcrtc-&gt;cur_x += qcrtc-&gt;hot_spot_x - hot_x;</span>
<span class="p_add">+	qcrtc-&gt;cur_y += qcrtc-&gt;hot_spot_y - hot_y;</span>
<span class="p_add">+	qcrtc-&gt;hot_spot_x = hot_x;</span>
<span class="p_add">+	qcrtc-&gt;hot_spot_y = hot_y;</span>
<span class="p_add">+</span>
 	cmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_CURSOR_SET;
<span class="p_del">-	cmd-&gt;u.set.position.x = qcrtc-&gt;cur_x;</span>
<span class="p_del">-	cmd-&gt;u.set.position.y = qcrtc-&gt;cur_y;</span>
<span class="p_add">+	cmd-&gt;u.set.position.x = qcrtc-&gt;cur_x + qcrtc-&gt;hot_spot_x;</span>
<span class="p_add">+	cmd-&gt;u.set.position.y = qcrtc-&gt;cur_y + qcrtc-&gt;hot_spot_y;</span>
 
 	cmd-&gt;u.set.shape = qxl_bo_physical_address(qdev, cursor_bo, 0);
 
<span class="p_chunk">@@ -441,8 +446,8 @@</span> <span class="p_context"> static int qxl_crtc_cursor_move(struct drm_crtc *crtc,</span>
 
 	cmd = (struct qxl_cursor_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_CURSOR_MOVE;
<span class="p_del">-	cmd-&gt;u.position.x = qcrtc-&gt;cur_x;</span>
<span class="p_del">-	cmd-&gt;u.position.y = qcrtc-&gt;cur_y;</span>
<span class="p_add">+	cmd-&gt;u.position.x = qcrtc-&gt;cur_x + qcrtc-&gt;hot_spot_x;</span>
<span class="p_add">+	cmd-&gt;u.position.y = qcrtc-&gt;cur_y + qcrtc-&gt;hot_spot_y;</span>
 	qxl_release_unmap(qdev, release, &amp;cmd-&gt;release_info);
 
 	qxl_push_cursor_ring_release(qdev, release, QXL_CMD_CURSOR, false);
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h</span>
<span class="p_header">index 01a86948eb8c..3ab90179e9ab 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_drv.h</span>
<span class="p_chunk">@@ -135,6 +135,8 @@</span> <span class="p_context"> struct qxl_crtc {</span>
 	int index;
 	int cur_x;
 	int cur_y;
<span class="p_add">+	int hot_spot_x;</span>
<span class="p_add">+	int hot_spot_y;</span>
 };
 
 struct qxl_output {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">index 2ad462896896..32491355a1d4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_chunk">@@ -2608,10 +2608,152 @@</span> <span class="p_context"> static void evergreen_agp_enable(struct radeon_device *rdev)</span>
 	WREG32(VM_CONTEXT1_CNTL, 0);
 }
 
<span class="p_add">+static const unsigned ni_dig_offsets[] =</span>
<span class="p_add">+{</span>
<span class="p_add">+	NI_DIG0_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG1_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG2_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG3_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG4_REGISTER_OFFSET,</span>
<span class="p_add">+	NI_DIG5_REGISTER_OFFSET</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const unsigned ni_tx_offsets[] =</span>
<span class="p_add">+{</span>
<span class="p_add">+	NI_DCIO_UNIPHY0_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY1_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY2_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY3_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY4_UNIPHY_TX_CONTROL1,</span>
<span class="p_add">+	NI_DCIO_UNIPHY5_UNIPHY_TX_CONTROL1</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const unsigned evergreen_dp_offsets[] =</span>
<span class="p_add">+{</span>
<span class="p_add">+	EVERGREEN_DP0_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP1_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP2_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP3_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP4_REGISTER_OFFSET,</span>
<span class="p_add">+	EVERGREEN_DP5_REGISTER_OFFSET</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Assumption is that EVERGREEN_CRTC_MASTER_EN enable for requested crtc</span>
<span class="p_add">+ * We go from crtc to connector and it is not relible  since it</span>
<span class="p_add">+ * should be an opposite direction .If crtc is enable then</span>
<span class="p_add">+ * find the dig_fe which selects this crtc and insure that it enable.</span>
<span class="p_add">+ * if such dig_fe is found then find dig_be which selects found dig_be and</span>
<span class="p_add">+ * insure that it enable and in DP_SST mode.</span>
<span class="p_add">+ * if UNIPHY_PLL_CONTROL1.enable then we should disconnect timing</span>
<span class="p_add">+ * from dp symbols clocks .</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool evergreen_is_dp_sst_stream_enabled(struct radeon_device *rdev,</span>
<span class="p_add">+					       unsigned crtc_id, unsigned *ret_dig_fe)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned i;</span>
<span class="p_add">+	unsigned dig_fe;</span>
<span class="p_add">+	unsigned dig_be;</span>
<span class="p_add">+	unsigned dig_en_be;</span>
<span class="p_add">+	unsigned uniphy_pll;</span>
<span class="p_add">+	unsigned digs_fe_selected;</span>
<span class="p_add">+	unsigned dig_be_mode;</span>
<span class="p_add">+	unsigned dig_fe_mask;</span>
<span class="p_add">+	bool is_enabled = false;</span>
<span class="p_add">+	bool found_crtc = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* loop through all running dig_fe to find selected crtc */</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(ni_dig_offsets); i++) {</span>
<span class="p_add">+		dig_fe = RREG32(NI_DIG_FE_CNTL + ni_dig_offsets[i]);</span>
<span class="p_add">+		if (dig_fe &amp; NI_DIG_FE_CNTL_SYMCLK_FE_ON &amp;&amp;</span>
<span class="p_add">+		    crtc_id == NI_DIG_FE_CNTL_SOURCE_SELECT(dig_fe)) {</span>
<span class="p_add">+			/* found running pipe */</span>
<span class="p_add">+			found_crtc = true;</span>
<span class="p_add">+			dig_fe_mask = 1 &lt;&lt; i;</span>
<span class="p_add">+			dig_fe = i;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (found_crtc) {</span>
<span class="p_add">+		/* loop through all running dig_be to find selected dig_fe */</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(ni_dig_offsets); i++) {</span>
<span class="p_add">+			dig_be = RREG32(NI_DIG_BE_CNTL + ni_dig_offsets[i]);</span>
<span class="p_add">+			/* if dig_fe_selected by dig_be? */</span>
<span class="p_add">+			digs_fe_selected = NI_DIG_BE_CNTL_FE_SOURCE_SELECT(dig_be);</span>
<span class="p_add">+			dig_be_mode = NI_DIG_FE_CNTL_MODE(dig_be);</span>
<span class="p_add">+			if (dig_fe_mask &amp;  digs_fe_selected &amp;&amp;</span>
<span class="p_add">+			    /* if dig_be in sst mode? */</span>
<span class="p_add">+			    dig_be_mode == NI_DIG_BE_DPSST) {</span>
<span class="p_add">+				dig_en_be = RREG32(NI_DIG_BE_EN_CNTL +</span>
<span class="p_add">+						   ni_dig_offsets[i]);</span>
<span class="p_add">+				uniphy_pll = RREG32(NI_DCIO_UNIPHY0_PLL_CONTROL1 +</span>
<span class="p_add">+						    ni_tx_offsets[i]);</span>
<span class="p_add">+				/* dig_be enable and tx is running */</span>
<span class="p_add">+				if (dig_en_be &amp; NI_DIG_BE_EN_CNTL_ENABLE &amp;&amp;</span>
<span class="p_add">+				    dig_en_be &amp; NI_DIG_BE_EN_CNTL_SYMBCLK_ON &amp;&amp;</span>
<span class="p_add">+				    uniphy_pll &amp; NI_DCIO_UNIPHY0_PLL_CONTROL1_ENABLE) {</span>
<span class="p_add">+					is_enabled = true;</span>
<span class="p_add">+					*ret_dig_fe = dig_fe;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return is_enabled;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Blank dig when in dp sst mode</span>
<span class="p_add">+ * Dig ignores crtc timing</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void evergreen_blank_dp_output(struct radeon_device *rdev,</span>
<span class="p_add">+				      unsigned dig_fe)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned stream_ctrl;</span>
<span class="p_add">+	unsigned fifo_ctrl;</span>
<span class="p_add">+	unsigned counter = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dig_fe &gt;= ARRAY_SIZE(evergreen_dp_offsets)) {</span>
<span class="p_add">+		DRM_ERROR(&quot;invalid dig_fe %d\n&quot;, dig_fe);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	stream_ctrl = RREG32(EVERGREEN_DP_VID_STREAM_CNTL +</span>
<span class="p_add">+			     evergreen_dp_offsets[dig_fe]);</span>
<span class="p_add">+	if (!(stream_ctrl &amp; EVERGREEN_DP_VID_STREAM_CNTL_ENABLE)) {</span>
<span class="p_add">+		DRM_ERROR(&quot;dig %d , should be enable\n&quot;, dig_fe);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	stream_ctrl &amp;=~EVERGREEN_DP_VID_STREAM_CNTL_ENABLE;</span>
<span class="p_add">+	WREG32(EVERGREEN_DP_VID_STREAM_CNTL +</span>
<span class="p_add">+	       evergreen_dp_offsets[dig_fe], stream_ctrl);</span>
<span class="p_add">+</span>
<span class="p_add">+	stream_ctrl = RREG32(EVERGREEN_DP_VID_STREAM_CNTL +</span>
<span class="p_add">+			     evergreen_dp_offsets[dig_fe]);</span>
<span class="p_add">+	while (counter &lt; 32 &amp;&amp; stream_ctrl &amp; EVERGREEN_DP_VID_STREAM_STATUS) {</span>
<span class="p_add">+		msleep(1);</span>
<span class="p_add">+		counter++;</span>
<span class="p_add">+		stream_ctrl = RREG32(EVERGREEN_DP_VID_STREAM_CNTL +</span>
<span class="p_add">+				     evergreen_dp_offsets[dig_fe]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (counter &gt;= 32 )</span>
<span class="p_add">+		DRM_ERROR(&quot;counter exceeds %d\n&quot;, counter);</span>
<span class="p_add">+</span>
<span class="p_add">+	fifo_ctrl = RREG32(EVERGREEN_DP_STEER_FIFO + evergreen_dp_offsets[dig_fe]);</span>
<span class="p_add">+	fifo_ctrl |= EVERGREEN_DP_STEER_FIFO_RESET;</span>
<span class="p_add">+	WREG32(EVERGREEN_DP_STEER_FIFO + evergreen_dp_offsets[dig_fe], fifo_ctrl);</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void evergreen_mc_stop(struct radeon_device *rdev, struct evergreen_mc_save *save)
 {
 	u32 crtc_enabled, tmp, frame_count, blackout;
 	int i, j;
<span class="p_add">+	unsigned dig_fe;</span>
 
 	if (!ASIC_IS_NODCE(rdev)) {
 		save-&gt;vga_render_control = RREG32(VGA_RENDER_CONTROL);
<span class="p_chunk">@@ -2651,7 +2793,17 @@</span> <span class="p_context"> void evergreen_mc_stop(struct radeon_device *rdev, struct evergreen_mc_save *sav</span>
 					break;
 				udelay(1);
 			}
<span class="p_del">-</span>
<span class="p_add">+			/*we should disable dig if it drives dp sst*/</span>
<span class="p_add">+			/*but we are in radeon_device_init and the topology is unknown*/</span>
<span class="p_add">+			/*and it is available after radeon_modeset_init*/</span>
<span class="p_add">+			/*the following method radeon_atom_encoder_dpms_dig*/</span>
<span class="p_add">+			/*does the job if we initialize it properly*/</span>
<span class="p_add">+			/*for now we do it this manually*/</span>
<span class="p_add">+			/**/</span>
<span class="p_add">+			if (ASIC_IS_DCE5(rdev) &amp;&amp;</span>
<span class="p_add">+			    evergreen_is_dp_sst_stream_enabled(rdev, i ,&amp;dig_fe))</span>
<span class="p_add">+				evergreen_blank_dp_output(rdev, dig_fe);</span>
<span class="p_add">+			/*we could remove 6 lines below*/</span>
 			/* XXX this is a hack to avoid strange behavior with EFI on certain systems */
 			WREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 1);
 			tmp = RREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i]);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen_reg.h b/drivers/gpu/drm/radeon/evergreen_reg.h</span>
<span class="p_header">index aa939dfed3a3..b436badf9efa 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen_reg.h</span>
<span class="p_chunk">@@ -250,8 +250,43 @@</span> <span class="p_context"></span>
 
 /* HDMI blocks at 0x7030, 0x7c30, 0x10830, 0x11430, 0x12030, 0x12c30 */
 #define EVERGREEN_HDMI_BASE				0x7030
<span class="p_add">+/*DIG block*/</span>
<span class="p_add">+#define NI_DIG0_REGISTER_OFFSET                 (0x7000  - 0x7000)</span>
<span class="p_add">+#define NI_DIG1_REGISTER_OFFSET                 (0x7C00  - 0x7000)</span>
<span class="p_add">+#define NI_DIG2_REGISTER_OFFSET                 (0x10800 - 0x7000)</span>
<span class="p_add">+#define NI_DIG3_REGISTER_OFFSET                 (0x11400 - 0x7000)</span>
<span class="p_add">+#define NI_DIG4_REGISTER_OFFSET                 (0x12000 - 0x7000)</span>
<span class="p_add">+#define NI_DIG5_REGISTER_OFFSET                 (0x12C00 - 0x7000)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define NI_DIG_FE_CNTL                               0x7000</span>
<span class="p_add">+#       define NI_DIG_FE_CNTL_SOURCE_SELECT(x)        ((x) &amp; 0x3)</span>
<span class="p_add">+#       define NI_DIG_FE_CNTL_SYMCLK_FE_ON            (1&lt;&lt;24)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define NI_DIG_BE_CNTL                    0x7140</span>
<span class="p_add">+#       define NI_DIG_BE_CNTL_FE_SOURCE_SELECT(x)     (((x) &gt;&gt; 8 ) &amp; 0x3F)</span>
<span class="p_add">+#       define NI_DIG_FE_CNTL_MODE(x)                 (((x) &gt;&gt; 16) &amp; 0x7 )</span>
<span class="p_add">+</span>
<span class="p_add">+#define NI_DIG_BE_EN_CNTL                              0x7144</span>
<span class="p_add">+#       define NI_DIG_BE_EN_CNTL_ENABLE               (1 &lt;&lt; 0)</span>
<span class="p_add">+#       define NI_DIG_BE_EN_CNTL_SYMBCLK_ON           (1 &lt;&lt; 8)</span>
<span class="p_add">+#       define NI_DIG_BE_DPSST 0</span>
 
 /* Display Port block */
<span class="p_add">+#define EVERGREEN_DP0_REGISTER_OFFSET                 (0x730C  - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP1_REGISTER_OFFSET                 (0x7F0C  - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP2_REGISTER_OFFSET                 (0x10B0C - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP3_REGISTER_OFFSET                 (0x1170C - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP4_REGISTER_OFFSET                 (0x1230C - 0x730C)</span>
<span class="p_add">+#define EVERGREEN_DP5_REGISTER_OFFSET                 (0x12F0C - 0x730C)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define EVERGREEN_DP_VID_STREAM_CNTL                    0x730C</span>
<span class="p_add">+#       define EVERGREEN_DP_VID_STREAM_CNTL_ENABLE     (1 &lt;&lt; 0)</span>
<span class="p_add">+#       define EVERGREEN_DP_VID_STREAM_STATUS          (1 &lt;&lt;16)</span>
<span class="p_add">+#define EVERGREEN_DP_STEER_FIFO                         0x7310</span>
<span class="p_add">+#       define EVERGREEN_DP_STEER_FIFO_RESET           (1 &lt;&lt; 0)</span>
 #define EVERGREEN_DP_SEC_CNTL                           0x7280
 #       define EVERGREEN_DP_SEC_STREAM_ENABLE           (1 &lt;&lt; 0)
 #       define EVERGREEN_DP_SEC_ASP_ENABLE              (1 &lt;&lt; 4)
<span class="p_chunk">@@ -266,4 +301,15 @@</span> <span class="p_context"></span>
 #       define EVERGREEN_DP_SEC_N_BASE_MULTIPLE(x)      (((x) &amp; 0xf) &lt;&lt; 24)
 #       define EVERGREEN_DP_SEC_SS_EN                   (1 &lt;&lt; 28)
 
<span class="p_add">+/*DCIO_UNIPHY block*/</span>
<span class="p_add">+#define NI_DCIO_UNIPHY0_UNIPHY_TX_CONTROL1            (0x6600  -0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY1_UNIPHY_TX_CONTROL1            (0x6640  -0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY2_UNIPHY_TX_CONTROL1            (0x6680 - 0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY3_UNIPHY_TX_CONTROL1            (0x66C0 - 0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY4_UNIPHY_TX_CONTROL1            (0x6700 - 0x6600)</span>
<span class="p_add">+#define NI_DCIO_UNIPHY5_UNIPHY_TX_CONTROL1            (0x6740 - 0x6600)</span>
<span class="p_add">+</span>
<span class="p_add">+#define NI_DCIO_UNIPHY0_PLL_CONTROL1                   0x6618</span>
<span class="p_add">+#       define NI_DCIO_UNIPHY0_PLL_CONTROL1_ENABLE     (1 &lt;&lt; 0)</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">index 9bc408c9f9f6..c4b4f298a283 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_chunk">@@ -62,10 +62,6 @@</span> <span class="p_context"> bool radeon_has_atpx(void) {</span>
 	return radeon_atpx_priv.atpx_detected;
 }
 
<span class="p_del">-bool radeon_has_atpx_dgpu_power_cntl(void) {</span>
<span class="p_del">-	return radeon_atpx_priv.atpx.functions.power_cntl;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * radeon_atpx_call - call an ATPX method
  *
<span class="p_chunk">@@ -145,6 +141,10 @@</span> <span class="p_context"> static void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mas</span>
  */
 static int radeon_atpx_validate(struct radeon_atpx *atpx)
 {
<span class="p_add">+	/* make sure required functions are enabled */</span>
<span class="p_add">+	/* dGPU power control is required */</span>
<span class="p_add">+	atpx-&gt;functions.power_cntl = true;</span>
<span class="p_add">+</span>
 	if (atpx-&gt;functions.px_params) {
 		union acpi_object *info;
 		struct atpx_px_params output;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 340f3f549f29..9cfc1c3e1965 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -1996,10 +1996,12 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 						   rdev-&gt;mode_info.dither_property,
 						   RADEON_FMT_DITHER_DISABLE);
 
<span class="p_del">-			if (radeon_audio != 0)</span>
<span class="p_add">+			if (radeon_audio != 0) {</span>
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.audio_property,
 							   RADEON_AUDIO_AUTO);
<span class="p_add">+				radeon_connector-&gt;audio = RADEON_AUDIO_AUTO;</span>
<span class="p_add">+			}</span>
 			if (ASIC_IS_DCE5(rdev))
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.output_csc_property,
<span class="p_chunk">@@ -2124,6 +2126,7 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.audio_property,
 							   RADEON_AUDIO_AUTO);
<span class="p_add">+				radeon_connector-&gt;audio = RADEON_AUDIO_AUTO;</span>
 			}
 			if (connector_type == DRM_MODE_CONNECTOR_DVII) {
 				radeon_connector-&gt;dac_load_detect = true;
<span class="p_chunk">@@ -2179,6 +2182,7 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.audio_property,
 							   RADEON_AUDIO_AUTO);
<span class="p_add">+				radeon_connector-&gt;audio = RADEON_AUDIO_AUTO;</span>
 			}
 			if (ASIC_IS_DCE5(rdev))
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
<span class="p_chunk">@@ -2231,6 +2235,7 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
 							   rdev-&gt;mode_info.audio_property,
 							   RADEON_AUDIO_AUTO);
<span class="p_add">+				radeon_connector-&gt;audio = RADEON_AUDIO_AUTO;</span>
 			}
 			if (ASIC_IS_DCE5(rdev))
 				drm_object_attach_property(&amp;radeon_connector-&gt;base.base,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index f78f111e68de..c566993a2ec3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -103,12 +103,6 @@</span> <span class="p_context"> static const char radeon_family_name[][16] = {</span>
 	&quot;LAST&quot;,
 };
 
<span class="p_del">-#if defined(CONFIG_VGA_SWITCHEROO)</span>
<span class="p_del">-bool radeon_has_atpx_dgpu_power_cntl(void);</span>
<span class="p_del">-#else</span>
<span class="p_del">-static inline bool radeon_has_atpx_dgpu_power_cntl(void) { return false; }</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 #define RADEON_PX_QUIRK_DISABLE_PX  (1 &lt;&lt; 0)
 #define RADEON_PX_QUIRK_LONG_WAKEUP (1 &lt;&lt; 1)
 
<span class="p_chunk">@@ -1439,7 +1433,7 @@</span> <span class="p_context"> int radeon_device_init(struct radeon_device *rdev,</span>
 	 * ignore it */
 	vga_client_register(rdev-&gt;pdev, rdev, NULL, radeon_vga_set_decode);
 
<span class="p_del">-	if ((rdev-&gt;flags &amp; RADEON_IS_PX) &amp;&amp; radeon_has_atpx_dgpu_power_cntl())</span>
<span class="p_add">+	if (rdev-&gt;flags &amp; RADEON_IS_PX)</span>
 		runtime = true;
 	vga_switcheroo_register_client(rdev-&gt;pdev, &amp;radeon_switcheroo_ops, runtime);
 	if (runtime)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">index e06ac546a90f..f342aad79cc6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_chunk">@@ -235,6 +235,8 @@</span> <span class="p_context"> static int radeon_verify_access(struct ttm_buffer_object *bo, struct file *filp)</span>
 {
 	struct radeon_bo *rbo = container_of(bo, struct radeon_bo, tbo);
 
<span class="p_add">+	if (radeon_ttm_tt_has_userptr(bo-&gt;ttm))</span>
<span class="p_add">+		return -EPERM;</span>
 	return drm_vma_node_verify_access(&amp;rbo-&gt;gem_base.vma_node, filp);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 7285adb27099..caa73de584a5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2931,6 +2931,7 @@</span> <span class="p_context"> static struct si_dpm_quirk si_dpm_quirk_list[] = {</span>
 	{ PCI_VENDOR_ID_ATI, 0x6811, 0x1462, 0x2015, 0, 120000 },
 	{ PCI_VENDOR_ID_ATI, 0x6811, 0x1043, 0x2015, 0, 120000 },
 	{ PCI_VENDOR_ID_ATI, 0x6811, 0x148c, 0x2015, 0, 120000 },
<span class="p_add">+	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1682, 0x9275, 0, 120000 },</span>
 	{ 0, 0, 0, 0 },
 };
 
<span class="p_header">diff --git a/drivers/hwtracing/stm/Kconfig b/drivers/hwtracing/stm/Kconfig</span>
<span class="p_header">index 83e9f591a54b..e7a348807f0c 100644</span>
<span class="p_header">--- a/drivers/hwtracing/stm/Kconfig</span>
<span class="p_header">+++ b/drivers/hwtracing/stm/Kconfig</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 config STM
 	tristate &quot;System Trace Module devices&quot;
 	select CONFIGFS_FS
<span class="p_add">+	select SRCU</span>
 	help
 	  A System Trace Module (STM) is a device exporting data in System
 	  Trace Protocol (STP) format as defined by MIPI STP standards.
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-cpm.c b/drivers/i2c/busses/i2c-cpm.c</span>
<span class="p_header">index 714bdc837769..b167ab25310a 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-cpm.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-cpm.c</span>
<span class="p_chunk">@@ -116,8 +116,8 @@</span> <span class="p_context"> struct cpm_i2c {</span>
 	cbd_t __iomem *rbase;
 	u_char *txbuf[CPM_MAXBD];
 	u_char *rxbuf[CPM_MAXBD];
<span class="p_del">-	u32 txdma[CPM_MAXBD];</span>
<span class="p_del">-	u32 rxdma[CPM_MAXBD];</span>
<span class="p_add">+	dma_addr_t txdma[CPM_MAXBD];</span>
<span class="p_add">+	dma_addr_t rxdma[CPM_MAXBD];</span>
 };
 
 static irqreturn_t cpm_i2c_interrupt(int irq, void *dev_id)
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-exynos5.c b/drivers/i2c/busses/i2c-exynos5.c</span>
<span class="p_header">index b29c7500461a..f54ece8fce78 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-exynos5.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-exynos5.c</span>
<span class="p_chunk">@@ -671,7 +671,9 @@</span> <span class="p_context"> static int exynos5_i2c_xfer(struct i2c_adapter *adap,</span>
 		return -EIO;
 	}
 
<span class="p_del">-	clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	ret = clk_enable(i2c-&gt;clk);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	for (i = 0; i &lt; num; i++, msgs++) {
 		stop = (i == num - 1);
<span class="p_chunk">@@ -695,7 +697,7 @@</span> <span class="p_context"> static int exynos5_i2c_xfer(struct i2c_adapter *adap,</span>
 	}
 
  out:
<span class="p_del">-	clk_disable_unprepare(i2c-&gt;clk);</span>
<span class="p_add">+	clk_disable(i2c-&gt;clk);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -747,7 +749,9 @@</span> <span class="p_context"> static int exynos5_i2c_probe(struct platform_device *pdev)</span>
 		return -ENOENT;
 	}
 
<span class="p_del">-	clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	ret = clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	i2c-&gt;regs = devm_ioremap_resource(&amp;pdev-&gt;dev, mem);
<span class="p_chunk">@@ -799,6 +803,10 @@</span> <span class="p_context"> static int exynos5_i2c_probe(struct platform_device *pdev)</span>
 
 	platform_set_drvdata(pdev, i2c);
 
<span class="p_add">+	clk_disable(i2c-&gt;clk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
  err_clk:
 	clk_disable_unprepare(i2c-&gt;clk);
 	return ret;
<span class="p_chunk">@@ -810,6 +818,8 @@</span> <span class="p_context"> static int exynos5_i2c_remove(struct platform_device *pdev)</span>
 
 	i2c_del_adapter(&amp;i2c-&gt;adap);
 
<span class="p_add">+	clk_unprepare(i2c-&gt;clk);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -821,6 +831,8 @@</span> <span class="p_context"> static int exynos5_i2c_suspend_noirq(struct device *dev)</span>
 
 	i2c-&gt;suspended = 1;
 
<span class="p_add">+	clk_unprepare(i2c-&gt;clk);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -830,7 +842,9 @@</span> <span class="p_context"> static int exynos5_i2c_resume_noirq(struct device *dev)</span>
 	struct exynos5_i2c *i2c = platform_get_drvdata(pdev);
 	int ret = 0;
 
<span class="p_del">-	clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	ret = clk_prepare_enable(i2c-&gt;clk);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	ret = exynos5_hsi2c_clock_setup(i2c);
 	if (ret) {
<span class="p_chunk">@@ -839,7 +853,7 @@</span> <span class="p_context"> static int exynos5_i2c_resume_noirq(struct device *dev)</span>
 	}
 
 	exynos5_i2c_init(i2c);
<span class="p_del">-	clk_disable_unprepare(i2c-&gt;clk);</span>
<span class="p_add">+	clk_disable(i2c-&gt;clk);</span>
 	i2c-&gt;suspended = 0;
 
 	return 0;
<span class="p_header">diff --git a/drivers/infiniband/core/ucm.c b/drivers/infiniband/core/ucm.c</span>
<span class="p_header">index 6b4e8a008bc0..564adf3116e8 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/ucm.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/ucm.c</span>
<span class="p_chunk">@@ -48,6 +48,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
 #include &lt;rdma/ib_cm.h&gt;
 #include &lt;rdma/ib_user_cm.h&gt;
 #include &lt;rdma/ib_marshall.h&gt;
<span class="p_chunk">@@ -1103,6 +1104,9 @@</span> <span class="p_context"> static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,</span>
 	struct ib_ucm_cmd_hdr hdr;
 	ssize_t result;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (len &lt; sizeof(hdr))
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/infiniband/core/ucma.c b/drivers/infiniband/core/ucma.c</span>
<span class="p_header">index 8b5a934e1133..886f61ea6cc7 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/ucma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/ucma.c</span>
<span class="p_chunk">@@ -1574,6 +1574,9 @@</span> <span class="p_context"> static ssize_t ucma_write(struct file *filp, const char __user *buf,</span>
 	struct rdma_ucm_cmd_hdr hdr;
 	ssize_t ret;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (len &lt; sizeof(hdr))
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index e3ef28861be6..24f3ca2c4ad7 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -48,6 +48,8 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;uverbs.h&quot;
 
 MODULE_AUTHOR(&quot;Roland Dreier&quot;);
<span class="p_chunk">@@ -682,6 +684,9 @@</span> <span class="p_context"> static ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,</span>
 	int srcu_key;
 	ssize_t ret;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (count &lt; sizeof hdr)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index c4e091528390..721d63f5b461 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -273,7 +273,7 @@</span> <span class="p_context"> static int mlx5_ib_query_device(struct ib_device *ibdev,</span>
 		     sizeof(struct mlx5_wqe_ctrl_seg)) /
 		     sizeof(struct mlx5_wqe_data_seg);
 	props-&gt;max_sge = min(max_rq_sg, max_sq_sg);
<span class="p_del">-	props-&gt;max_sge_rd = props-&gt;max_sge;</span>
<span class="p_add">+	props-&gt;max_sge_rd	   = MLX5_MAX_SGE_RD;</span>
 	props-&gt;max_cq		   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_cq);
 	props-&gt;max_cqe = (1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_cq_sz)) - 1;
 	props-&gt;max_mr		   = 1 &lt;&lt; MLX5_CAP_GEN(mdev, log_max_mkey);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_file_ops.c b/drivers/infiniband/hw/qib/qib_file_ops.c</span>
<span class="p_header">index e449e394963f..24f4a782e0f4 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_file_ops.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_file_ops.c</span>
<span class="p_chunk">@@ -45,6 +45,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/export.h&gt;
 #include &lt;linux/uio.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;qib.h&quot;
 #include &quot;qib_common.h&quot;
 #include &quot;qib_user_sdma.h&quot;
<span class="p_chunk">@@ -2067,6 +2069,9 @@</span> <span class="p_context"> static ssize_t qib_write(struct file *fp, const char __user *data,</span>
 	ssize_t ret = 0;
 	void *dest;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (count &lt; sizeof(cmd.type)) {
 		ret = -EINVAL;
 		goto bail;
<span class="p_header">diff --git a/drivers/input/misc/pmic8xxx-pwrkey.c b/drivers/input/misc/pmic8xxx-pwrkey.c</span>
<span class="p_header">index 3f02e0e03d12..67aab86048ad 100644</span>
<span class="p_header">--- a/drivers/input/misc/pmic8xxx-pwrkey.c</span>
<span class="p_header">+++ b/drivers/input/misc/pmic8xxx-pwrkey.c</span>
<span class="p_chunk">@@ -353,7 +353,8 @@</span> <span class="p_context"> static int pmic8xxx_pwrkey_probe(struct platform_device *pdev)</span>
 	if (of_property_read_u32(pdev-&gt;dev.of_node, &quot;debounce&quot;, &amp;kpd_delay))
 		kpd_delay = 15625;
 
<span class="p_del">-	if (kpd_delay &gt; 62500 || kpd_delay == 0) {</span>
<span class="p_add">+	/* Valid range of pwr key trigger delay is 1/64 sec to 2 seconds. */</span>
<span class="p_add">+	if (kpd_delay &gt; USEC_PER_SEC * 2 || kpd_delay &lt; USEC_PER_SEC / 64) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;invalid power key trigger delay\n&quot;);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -385,8 +386,8 @@</span> <span class="p_context"> static int pmic8xxx_pwrkey_probe(struct platform_device *pdev)</span>
 	pwr-&gt;name = &quot;pmic8xxx_pwrkey&quot;;
 	pwr-&gt;phys = &quot;pmic8xxx_pwrkey/input0&quot;;
 
<span class="p_del">-	delay = (kpd_delay &lt;&lt; 10) / USEC_PER_SEC;</span>
<span class="p_del">-	delay = 1 + ilog2(delay);</span>
<span class="p_add">+	delay = (kpd_delay &lt;&lt; 6) / USEC_PER_SEC;</span>
<span class="p_add">+	delay = ilog2(delay);</span>
 
 	err = regmap_read(regmap, PON_CNTL_1, &amp;pon_cntl);
 	if (err &lt; 0) {
<span class="p_header">diff --git a/drivers/input/tablet/gtco.c b/drivers/input/tablet/gtco.c</span>
<span class="p_header">index 3a7f3a4a4396..7c18249d6c8e 100644</span>
<span class="p_header">--- a/drivers/input/tablet/gtco.c</span>
<span class="p_header">+++ b/drivers/input/tablet/gtco.c</span>
<span class="p_chunk">@@ -858,6 +858,14 @@</span> <span class="p_context"> static int gtco_probe(struct usb_interface *usbinterface,</span>
 		goto err_free_buf;
 	}
 
<span class="p_add">+	/* Sanity check that a device has an endpoint */</span>
<span class="p_add">+	if (usbinterface-&gt;altsetting[0].desc.bNumEndpoints &lt; 1) {</span>
<span class="p_add">+		dev_err(&amp;usbinterface-&gt;dev,</span>
<span class="p_add">+			&quot;Invalid number of endpoints\n&quot;);</span>
<span class="p_add">+		error = -EINVAL;</span>
<span class="p_add">+		goto err_free_urb;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * The endpoint is always altsetting 0, we know this since we know
 	 * this device only has one interrupt endpoint
<span class="p_chunk">@@ -879,7 +887,7 @@</span> <span class="p_context"> static int gtco_probe(struct usb_interface *usbinterface,</span>
 	 * HID report descriptor
 	 */
 	if (usb_get_extra_descriptor(usbinterface-&gt;cur_altsetting,
<span class="p_del">-				     HID_DEVICE_TYPE, &amp;hid_desc) != 0){</span>
<span class="p_add">+				     HID_DEVICE_TYPE, &amp;hid_desc) != 0) {</span>
 		dev_err(&amp;usbinterface-&gt;dev,
 			&quot;Can&#39;t retrieve exta USB descriptor to get hid report descriptor length\n&quot;);
 		error = -EIO;
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index fc836f523afa..b9319b76a8a1 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -91,6 +91,7 @@</span> <span class="p_context"> struct iommu_dev_data {</span>
 	struct list_head dev_data_list;	  /* For global dev_data_list */
 	struct protection_domain *domain; /* Domain the device is bound to */
 	u16 devid;			  /* PCI Device ID */
<span class="p_add">+	u16 alias;			  /* Alias Device ID */</span>
 	bool iommu_v2;			  /* Device can make use of IOMMUv2 */
 	bool passthrough;		  /* Device is identity mapped */
 	struct {
<span class="p_chunk">@@ -125,6 +126,13 @@</span> <span class="p_context"> static struct protection_domain *to_pdomain(struct iommu_domain *dom)</span>
 	return container_of(dom, struct protection_domain, domain);
 }
 
<span class="p_add">+static inline u16 get_device_id(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pdev = to_pci_dev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return PCI_DEVID(pdev-&gt;bus-&gt;number, pdev-&gt;devfn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct iommu_dev_data *alloc_dev_data(u16 devid)
 {
 	struct iommu_dev_data *dev_data;
<span class="p_chunk">@@ -162,6 +170,68 @@</span> <span class="p_context"> out_unlock:</span>
 	return dev_data;
 }
 
<span class="p_add">+static int __last_alias(struct pci_dev *pdev, u16 alias, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*(u16 *)data = alias;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u16 get_alias(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pdev = to_pci_dev(dev);</span>
<span class="p_add">+	u16 devid, ivrs_alias, pci_alias;</span>
<span class="p_add">+</span>
<span class="p_add">+	devid = get_device_id(dev);</span>
<span class="p_add">+	ivrs_alias = amd_iommu_alias_table[devid];</span>
<span class="p_add">+	pci_for_each_dma_alias(pdev, __last_alias, &amp;pci_alias);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ivrs_alias == pci_alias)</span>
<span class="p_add">+		return ivrs_alias;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * DMA alias showdown</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The IVRS is fairly reliable in telling us about aliases, but it</span>
<span class="p_add">+	 * can&#39;t know about every screwy device.  If we don&#39;t have an IVRS</span>
<span class="p_add">+	 * reported alias, use the PCI reported alias.  In that case we may</span>
<span class="p_add">+	 * still need to initialize the rlookup and dev_table entries if the</span>
<span class="p_add">+	 * alias is to a non-existent device.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ivrs_alias == devid) {</span>
<span class="p_add">+		if (!amd_iommu_rlookup_table[pci_alias]) {</span>
<span class="p_add">+			amd_iommu_rlookup_table[pci_alias] =</span>
<span class="p_add">+				amd_iommu_rlookup_table[devid];</span>
<span class="p_add">+			memcpy(amd_iommu_dev_table[pci_alias].data,</span>
<span class="p_add">+			       amd_iommu_dev_table[devid].data,</span>
<span class="p_add">+			       sizeof(amd_iommu_dev_table[pci_alias].data));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		return pci_alias;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;AMD-Vi: Using IVRS reported alias %02x:%02x.%d &quot;</span>
<span class="p_add">+		&quot;for device %s[%04x:%04x], kernel reported alias &quot;</span>
<span class="p_add">+		&quot;%02x:%02x.%d\n&quot;, PCI_BUS_NUM(ivrs_alias), PCI_SLOT(ivrs_alias),</span>
<span class="p_add">+		PCI_FUNC(ivrs_alias), dev_name(dev), pdev-&gt;vendor, pdev-&gt;device,</span>
<span class="p_add">+		PCI_BUS_NUM(pci_alias), PCI_SLOT(pci_alias),</span>
<span class="p_add">+		PCI_FUNC(pci_alias));</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we don&#39;t have a PCI DMA alias and the IVRS alias is on the same</span>
<span class="p_add">+	 * bus, then the IVRS table may know about a quirk that we don&#39;t.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pci_alias == devid &amp;&amp;</span>
<span class="p_add">+	    PCI_BUS_NUM(ivrs_alias) == pdev-&gt;bus-&gt;number) {</span>
<span class="p_add">+		pdev-&gt;dev_flags |= PCI_DEV_FLAGS_DMA_ALIAS_DEVFN;</span>
<span class="p_add">+		pdev-&gt;dma_alias_devfn = ivrs_alias &amp; 0xff;</span>
<span class="p_add">+		pr_info(&quot;AMD-Vi: Added PCI DMA alias %02x.%d for %s\n&quot;,</span>
<span class="p_add">+			PCI_SLOT(ivrs_alias), PCI_FUNC(ivrs_alias),</span>
<span class="p_add">+			dev_name(dev));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ivrs_alias;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct iommu_dev_data *find_dev_data(u16 devid)
 {
 	struct iommu_dev_data *dev_data;
<span class="p_chunk">@@ -174,13 +244,6 @@</span> <span class="p_context"> static struct iommu_dev_data *find_dev_data(u16 devid)</span>
 	return dev_data;
 }
 
<span class="p_del">-static inline u16 get_device_id(struct device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pci_dev *pdev = to_pci_dev(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	return PCI_DEVID(pdev-&gt;bus-&gt;number, pdev-&gt;devfn);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct iommu_dev_data *get_dev_data(struct device *dev)
 {
 	return dev-&gt;archdata.iommu;
<span class="p_chunk">@@ -308,6 +371,8 @@</span> <span class="p_context"> static int iommu_init_device(struct device *dev)</span>
 	if (!dev_data)
 		return -ENOMEM;
 
<span class="p_add">+	dev_data-&gt;alias = get_alias(dev);</span>
<span class="p_add">+</span>
 	if (pci_iommuv2_capable(pdev)) {
 		struct amd_iommu *iommu;
 
<span class="p_chunk">@@ -328,7 +393,7 @@</span> <span class="p_context"> static void iommu_ignore_device(struct device *dev)</span>
 	u16 devid, alias;
 
 	devid = get_device_id(dev);
<span class="p_del">-	alias = amd_iommu_alias_table[devid];</span>
<span class="p_add">+	alias = get_alias(dev);</span>
 
 	memset(&amp;amd_iommu_dev_table[devid], 0, sizeof(struct dev_table_entry));
 	memset(&amp;amd_iommu_dev_table[alias], 0, sizeof(struct dev_table_entry));
<span class="p_chunk">@@ -1017,7 +1082,7 @@</span> <span class="p_context"> static int device_flush_dte(struct iommu_dev_data *dev_data)</span>
 	int ret;
 
 	iommu = amd_iommu_rlookup_table[dev_data-&gt;devid];
<span class="p_del">-	alias = amd_iommu_alias_table[dev_data-&gt;devid];</span>
<span class="p_add">+	alias = dev_data-&gt;alias;</span>
 
 	ret = iommu_flush_dte(iommu, dev_data-&gt;devid);
 	if (!ret &amp;&amp; alias != dev_data-&gt;devid)
<span class="p_chunk">@@ -1891,7 +1956,7 @@</span> <span class="p_context"> static void do_attach(struct iommu_dev_data *dev_data,</span>
 	bool ats;
 
 	iommu = amd_iommu_rlookup_table[dev_data-&gt;devid];
<span class="p_del">-	alias = amd_iommu_alias_table[dev_data-&gt;devid];</span>
<span class="p_add">+	alias = dev_data-&gt;alias;</span>
 	ats   = dev_data-&gt;ats.enabled;
 
 	/* Update data structures */
<span class="p_chunk">@@ -1925,7 +1990,7 @@</span> <span class="p_context"> static void do_detach(struct iommu_dev_data *dev_data)</span>
 		return;
 
 	iommu = amd_iommu_rlookup_table[dev_data-&gt;devid];
<span class="p_del">-	alias = amd_iommu_alias_table[dev_data-&gt;devid];</span>
<span class="p_add">+	alias = dev_data-&gt;alias;</span>
 
 	/* decrease reference counters */
 	dev_data-&gt;domain-&gt;dev_iommu[iommu-&gt;index] -= 1;
<span class="p_header">diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c</span>
<span class="p_header">index 72d6182666cb..58f2fe687a24 100644</span>
<span class="p_header">--- a/drivers/iommu/dma-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/dma-iommu.c</span>
<span class="p_chunk">@@ -403,7 +403,7 @@</span> <span class="p_context"> static int __finalise_sg(struct device *dev, struct scatterlist *sg, int nents,</span>
 		unsigned int s_length = sg_dma_len(s);
 		unsigned int s_dma_len = s-&gt;length;
 
<span class="p_del">-		s-&gt;offset = s_offset;</span>
<span class="p_add">+		s-&gt;offset += s_offset;</span>
 		s-&gt;length = s_length;
 		sg_dma_address(s) = dma_addr + s_offset;
 		dma_addr += s_dma_len;
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> static void __invalidate_sg(struct scatterlist *sg, int nents)</span>
 
 	for_each_sg(sg, s, nents, i) {
 		if (sg_dma_address(s) != DMA_ERROR_CODE)
<span class="p_del">-			s-&gt;offset = sg_dma_address(s);</span>
<span class="p_add">+			s-&gt;offset += sg_dma_address(s);</span>
 		if (sg_dma_len(s))
 			s-&gt;length = sg_dma_len(s);
 		sg_dma_address(s) = DMA_ERROR_CODE;
<span class="p_header">diff --git a/drivers/irqchip/irq-mxs.c b/drivers/irqchip/irq-mxs.c</span>
<span class="p_header">index efe50845939d..17304705f2cf 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-mxs.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-mxs.c</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static void __iomem * __init icoll_init_iobase(struct device_node *np)</span>
 	void __iomem *icoll_base;
 
 	icoll_base = of_io_request_and_map(np, 0, np-&gt;name);
<span class="p_del">-	if (!icoll_base)</span>
<span class="p_add">+	if (IS_ERR(icoll_base))</span>
 		panic(&quot;%s: unable to map resource&quot;, np-&gt;full_name);
 	return icoll_base;
 }
<span class="p_header">diff --git a/drivers/irqchip/irq-sunxi-nmi.c b/drivers/irqchip/irq-sunxi-nmi.c</span>
<span class="p_header">index 4ef178078e5b..1254e98f6b57 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-sunxi-nmi.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-sunxi-nmi.c</span>
<span class="p_chunk">@@ -154,9 +154,9 @@</span> <span class="p_context"> static int __init sunxi_sc_nmi_irq_init(struct device_node *node,</span>
 
 	gc = irq_get_domain_generic_chip(domain, 0);
 	gc-&gt;reg_base = of_io_request_and_map(node, 0, of_node_full_name(node));
<span class="p_del">-	if (!gc-&gt;reg_base) {</span>
<span class="p_add">+	if (IS_ERR(gc-&gt;reg_base)) {</span>
 		pr_err(&quot;unable to map resource\n&quot;);
<span class="p_del">-		ret = -ENOMEM;</span>
<span class="p_add">+		ret = PTR_ERR(gc-&gt;reg_base);</span>
 		goto fail_irqd_remove;
 	}
 
<span class="p_header">diff --git a/drivers/md/dm-cache-metadata.c b/drivers/md/dm-cache-metadata.c</span>
<span class="p_header">index 27f2ef300f8b..3970cda10080 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-metadata.c</span>
<span class="p_chunk">@@ -867,39 +867,55 @@</span> <span class="p_context"> static int blocks_are_unmapped_or_clean(struct dm_cache_metadata *cmd,</span>
 	return 0;
 }
 
<span class="p_del">-#define WRITE_LOCK(cmd)	\</span>
<span class="p_del">-	down_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_del">-		up_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-		return -EINVAL; \</span>
<span class="p_add">+static bool cmd_write_lock(struct dm_cache_metadata *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	down_write(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) {</span>
<span class="p_add">+		up_write(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+		return false;</span>
 	}
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#define WRITE_LOCK_VOID(cmd) \</span>
<span class="p_del">-	down_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_del">-		up_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-		return; \</span>
<span class="p_del">-	}</span>
<span class="p_add">+#define WRITE_LOCK(cmd)				\</span>
<span class="p_add">+	do {					\</span>
<span class="p_add">+		if (!cmd_write_lock((cmd)))	\</span>
<span class="p_add">+			return -EINVAL;		\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define WRITE_LOCK_VOID(cmd)			\</span>
<span class="p_add">+	do {					\</span>
<span class="p_add">+		if (!cmd_write_lock((cmd)))	\</span>
<span class="p_add">+			return;			\</span>
<span class="p_add">+	} while(0)</span>
 
 #define WRITE_UNLOCK(cmd) \
<span class="p_del">-	up_write(&amp;cmd-&gt;root_lock)</span>
<span class="p_add">+	up_write(&amp;(cmd)-&gt;root_lock)</span>
 
<span class="p_del">-#define READ_LOCK(cmd) \</span>
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_del">-		up_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-		return -EINVAL; \</span>
<span class="p_add">+static bool cmd_read_lock(struct dm_cache_metadata *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	if (cmd-&gt;fail_io) {</span>
<span class="p_add">+		up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+		return false;</span>
 	}
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#define READ_LOCK_VOID(cmd)	\</span>
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_del">-		up_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_del">-		return; \</span>
<span class="p_del">-	}</span>
<span class="p_add">+#define READ_LOCK(cmd)				\</span>
<span class="p_add">+	do {					\</span>
<span class="p_add">+		if (!cmd_read_lock((cmd)))	\</span>
<span class="p_add">+			return -EINVAL;		\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define READ_LOCK_VOID(cmd)			\</span>
<span class="p_add">+	do {					\</span>
<span class="p_add">+		if (!cmd_read_lock((cmd)))	\</span>
<span class="p_add">+			return;			\</span>
<span class="p_add">+	} while(0)</span>
 
 #define READ_UNLOCK(cmd) \
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock)</span>
<span class="p_add">+	up_read(&amp;(cmd)-&gt;root_lock)</span>
 
 int dm_cache_resize(struct dm_cache_metadata *cmd, dm_cblock_t new_cache_size)
 {
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index 33bdd81065e8..11f39791ec33 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -1502,7 +1502,7 @@</span> <span class="p_context"> static int __vb2_wait_for_done_vb(struct vb2_queue *q, int nonblocking)</span>
  * Will sleep if required for nonblocking == false.
  */
 static int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,
<span class="p_del">-				int nonblocking)</span>
<span class="p_add">+			     void *pb, int nonblocking)</span>
 {
 	unsigned long flags;
 	int ret;
<span class="p_chunk">@@ -1523,10 +1523,10 @@</span> <span class="p_context"> static int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,</span>
 	/*
 	 * Only remove the buffer from done_list if v4l2_buffer can handle all
 	 * the planes.
<span class="p_del">-	 * Verifying planes is NOT necessary since it already has been checked</span>
<span class="p_del">-	 * before the buffer is queued/prepared. So it can never fail.</span>
 	 */
<span class="p_del">-	list_del(&amp;(*vb)-&gt;done_entry);</span>
<span class="p_add">+	ret = call_bufop(q, verify_planes_array, *vb, pb);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		list_del(&amp;(*vb)-&gt;done_entry);</span>
 	spin_unlock_irqrestore(&amp;q-&gt;done_lock, flags);
 
 	return ret;
<span class="p_chunk">@@ -1604,7 +1604,7 @@</span> <span class="p_context"> int vb2_core_dqbuf(struct vb2_queue *q, void *pb, bool nonblocking)</span>
 	struct vb2_buffer *vb = NULL;
 	int ret;
 
<span class="p_del">-	ret = __vb2_get_done_vb(q, &amp;vb, nonblocking);</span>
<span class="p_add">+	ret = __vb2_get_done_vb(q, &amp;vb, pb, nonblocking);</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-memops.c b/drivers/media/v4l2-core/videobuf2-memops.c</span>
<span class="p_header">index dbec5923fcf0..3c3b517f1d1c 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-memops.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-memops.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> struct frame_vector *vb2_create_framevec(unsigned long start,</span>
 	vec = frame_vector_create(nr);
 	if (!vec)
 		return ERR_PTR(-ENOMEM);
<span class="p_del">-	ret = get_vaddr_frames(start, nr, write, 1, vec);</span>
<span class="p_add">+	ret = get_vaddr_frames(start &amp; PAGE_MASK, nr, write, true, vec);</span>
 	if (ret &lt; 0)
 		goto out_destroy;
 	/* We accept only complete set of PFNs */
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-v4l2.c b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">index 502984c724ff..6c441be8f893 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_chunk">@@ -67,6 +67,11 @@</span> <span class="p_context"> static int __verify_planes_array(struct vb2_buffer *vb, const struct v4l2_buffer</span>
 	return 0;
 }
 
<span class="p_add">+static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __verify_planes_array(vb, pb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * __verify_length() - Verify that the bytesused value for each plane fits in
  * the plane length and that the data offset doesn&#39;t exceed the bytesused value.
<span class="p_chunk">@@ -432,6 +437,7 @@</span> <span class="p_context"> static int __fill_vb2_buffer(struct vb2_buffer *vb,</span>
 }
 
 static const struct vb2_buf_ops v4l2_buf_ops = {
<span class="p_add">+	.verify_planes_array	= __verify_planes_array_core,</span>
 	.fill_user_buffer	= __fill_v4l2_buffer,
 	.fill_vb2_buffer	= __fill_vb2_buffer,
 	.set_timestamp		= __set_timestamp,
<span class="p_header">diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig</span>
<span class="p_header">index 22892c701c63..4bf7d50b1bc7 100644</span>
<span class="p_header">--- a/drivers/misc/Kconfig</span>
<span class="p_header">+++ b/drivers/misc/Kconfig</span>
<span class="p_chunk">@@ -439,7 +439,7 @@</span> <span class="p_context"> config ARM_CHARLCD</span>
 	  still useful.
 
 config BMP085
<span class="p_del">-	bool</span>
<span class="p_add">+	tristate</span>
 	depends on SYSFS
 
 config BMP085_I2C
<span class="p_header">diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c</span>
<span class="p_header">index 15e88078ba1e..f1a0b99f5a9a 100644</span>
<span class="p_header">--- a/drivers/misc/ad525x_dpot.c</span>
<span class="p_header">+++ b/drivers/misc/ad525x_dpot.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)</span>
 			 */
 			value = swab16(value);
 
<span class="p_del">-			if (dpot-&gt;uid == DPOT_UID(AD5271_ID))</span>
<span class="p_add">+			if (dpot-&gt;uid == DPOT_UID(AD5274_ID))</span>
 				value = value &gt;&gt; 2;
 		return value;
 	default:
<span class="p_header">diff --git a/drivers/misc/cxl/irq.c b/drivers/misc/cxl/irq.c</span>
<span class="p_header">index 09a406058c46..efbb6945eb18 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/irq.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/irq.c</span>
<span class="p_chunk">@@ -288,7 +288,6 @@</span> <span class="p_context"> unsigned int cxl_map_irq(struct cxl *adapter, irq_hw_number_t hwirq,</span>
 void cxl_unmap_irq(unsigned int virq, void *cookie)
 {
 	free_irq(virq, cookie);
<span class="p_del">-	irq_dispose_mapping(virq);</span>
 }
 
 static int cxl_register_one_irq(struct cxl *adapter,
<span class="p_header">diff --git a/drivers/misc/mic/scif/scif_rma.c b/drivers/misc/mic/scif/scif_rma.c</span>
<span class="p_header">index 8310b4dbff06..6a451bd65bf3 100644</span>
<span class="p_header">--- a/drivers/misc/mic/scif/scif_rma.c</span>
<span class="p_header">+++ b/drivers/misc/mic/scif/scif_rma.c</span>
<span class="p_chunk">@@ -1511,7 +1511,7 @@</span> <span class="p_context"> off_t scif_register_pinned_pages(scif_epd_t epd,</span>
 	if ((map_flags &amp; SCIF_MAP_FIXED) &amp;&amp;
 	    ((ALIGN(offset, PAGE_SIZE) != offset) ||
 	    (offset &lt; 0) ||
<span class="p_del">-	    (offset + (off_t)len &lt; offset)))</span>
<span class="p_add">+	    (len &gt; LONG_MAX - offset)))</span>
 		return -EINVAL;
 
 	might_sleep();
<span class="p_chunk">@@ -1614,7 +1614,7 @@</span> <span class="p_context"> off_t scif_register(scif_epd_t epd, void *addr, size_t len, off_t offset,</span>
 	if ((map_flags &amp; SCIF_MAP_FIXED) &amp;&amp;
 	    ((ALIGN(offset, PAGE_SIZE) != offset) ||
 	    (offset &lt; 0) ||
<span class="p_del">-	    (offset + (off_t)len &lt; offset)))</span>
<span class="p_add">+	    (len &gt; LONG_MAX - offset)))</span>
 		return -EINVAL;
 
 	/* Unsupported protection requested */
<span class="p_chunk">@@ -1732,7 +1732,8 @@</span> <span class="p_context"> scif_unregister(scif_epd_t epd, off_t offset, size_t len)</span>
 
 	/* Offset is not page aligned or offset+len wraps around */
 	if ((ALIGN(offset, PAGE_SIZE) != offset) ||
<span class="p_del">-	    (offset + (off_t)len &lt; offset))</span>
<span class="p_add">+	    (offset &lt; 0) ||</span>
<span class="p_add">+	    (len &gt; LONG_MAX - offset))</span>
 		return -EINVAL;
 
 	err = scif_verify_epd(ep);
<span class="p_header">diff --git a/drivers/mtd/nand/brcmnand/brcmnand.c b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">index 12c6190c6e33..4a07ba1195b5 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_chunk">@@ -309,6 +309,36 @@</span> <span class="p_context"> static const u16 brcmnand_regs_v60[] = {</span>
 	[BRCMNAND_FC_BASE]		= 0x400,
 };
 
<span class="p_add">+/* BRCMNAND v7.1 */</span>
<span class="p_add">+static const u16 brcmnand_regs_v71[] = {</span>
<span class="p_add">+	[BRCMNAND_CMD_START]		=  0x04,</span>
<span class="p_add">+	[BRCMNAND_CMD_EXT_ADDRESS]	=  0x08,</span>
<span class="p_add">+	[BRCMNAND_CMD_ADDRESS]		=  0x0c,</span>
<span class="p_add">+	[BRCMNAND_INTFC_STATUS]		=  0x14,</span>
<span class="p_add">+	[BRCMNAND_CS_SELECT]		=  0x18,</span>
<span class="p_add">+	[BRCMNAND_CS_XOR]		=  0x1c,</span>
<span class="p_add">+	[BRCMNAND_LL_OP]		=  0x20,</span>
<span class="p_add">+	[BRCMNAND_CS0_BASE]		=  0x50,</span>
<span class="p_add">+	[BRCMNAND_CS1_BASE]		=     0,</span>
<span class="p_add">+	[BRCMNAND_CORR_THRESHOLD]	=  0xdc,</span>
<span class="p_add">+	[BRCMNAND_CORR_THRESHOLD_EXT]	=  0xe0,</span>
<span class="p_add">+	[BRCMNAND_UNCORR_COUNT]		=  0xfc,</span>
<span class="p_add">+	[BRCMNAND_CORR_COUNT]		= 0x100,</span>
<span class="p_add">+	[BRCMNAND_CORR_EXT_ADDR]	= 0x10c,</span>
<span class="p_add">+	[BRCMNAND_CORR_ADDR]		= 0x110,</span>
<span class="p_add">+	[BRCMNAND_UNCORR_EXT_ADDR]	= 0x114,</span>
<span class="p_add">+	[BRCMNAND_UNCORR_ADDR]		= 0x118,</span>
<span class="p_add">+	[BRCMNAND_SEMAPHORE]		= 0x150,</span>
<span class="p_add">+	[BRCMNAND_ID]			= 0x194,</span>
<span class="p_add">+	[BRCMNAND_ID_EXT]		= 0x198,</span>
<span class="p_add">+	[BRCMNAND_LL_RDATA]		= 0x19c,</span>
<span class="p_add">+	[BRCMNAND_OOB_READ_BASE]	= 0x200,</span>
<span class="p_add">+	[BRCMNAND_OOB_READ_10_BASE]	=     0,</span>
<span class="p_add">+	[BRCMNAND_OOB_WRITE_BASE]	= 0x280,</span>
<span class="p_add">+	[BRCMNAND_OOB_WRITE_10_BASE]	=     0,</span>
<span class="p_add">+	[BRCMNAND_FC_BASE]		= 0x400,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 enum brcmnand_cs_reg {
 	BRCMNAND_CS_CFG_EXT = 0,
 	BRCMNAND_CS_CFG,
<span class="p_chunk">@@ -404,7 +434,9 @@</span> <span class="p_context"> static int brcmnand_revision_init(struct brcmnand_controller *ctrl)</span>
 	}
 
 	/* Register offsets */
<span class="p_del">-	if (ctrl-&gt;nand_version &gt;= 0x0600)</span>
<span class="p_add">+	if (ctrl-&gt;nand_version &gt;= 0x0701)</span>
<span class="p_add">+		ctrl-&gt;reg_offsets = brcmnand_regs_v71;</span>
<span class="p_add">+	else if (ctrl-&gt;nand_version &gt;= 0x0600)</span>
 		ctrl-&gt;reg_offsets = brcmnand_regs_v60;
 	else if (ctrl-&gt;nand_version &gt;= 0x0500)
 		ctrl-&gt;reg_offsets = brcmnand_regs_v50;
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 3ff583f165cd..ce7b2cab5762 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -3979,7 +3979,6 @@</span> <span class="p_context"> static int nand_dt_init(struct mtd_info *mtd, struct nand_chip *chip,</span>
  * This is the first phase of the normal nand_scan() function. It reads the
  * flash ID and sets up MTD fields accordingly.
  *
<span class="p_del">- * The mtd-&gt;owner field must be set to the module of the caller.</span>
  */
 int nand_scan_ident(struct mtd_info *mtd, int maxchips,
 		    struct nand_flash_dev *table)
<span class="p_chunk">@@ -4403,19 +4402,12 @@</span> <span class="p_context"> EXPORT_SYMBOL(nand_scan_tail);</span>
  *
  * This fills out all the uninitialized function pointers with the defaults.
  * The flash ID is read and the mtd/chip structures are filled with the
<span class="p_del">- * appropriate values. The mtd-&gt;owner field must be set to the module of the</span>
<span class="p_del">- * caller.</span>
<span class="p_add">+ * appropriate values.</span>
  */
 int nand_scan(struct mtd_info *mtd, int maxchips)
 {
 	int ret;
 
<span class="p_del">-	/* Many callers got this wrong, so check for it for a while... */</span>
<span class="p_del">-	if (!mtd-&gt;owner &amp;&amp; caller_is_module()) {</span>
<span class="p_del">-		pr_crit(&quot;%s called with NULL mtd-&gt;owner!\n&quot;, __func__);</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = nand_scan_ident(mtd, maxchips, NULL);
 	if (!ret)
 		ret = nand_scan_tail(mtd);
<span class="p_header">diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c</span>
<span class="p_header">index 32477c4eb421..37e4135ab213 100644</span>
<span class="p_header">--- a/drivers/mtd/spi-nor/spi-nor.c</span>
<span class="p_header">+++ b/drivers/mtd/spi-nor/spi-nor.c</span>
<span class="p_chunk">@@ -1067,45 +1067,6 @@</span> <span class="p_context"> static int spansion_quad_enable(struct spi_nor *nor)</span>
 	return 0;
 }
 
<span class="p_del">-static int micron_quad_enable(struct spi_nor *nor)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	u8 val;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = nor-&gt;read_reg(nor, SPINOR_OP_RD_EVCR, &amp;val, 1);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(nor-&gt;dev, &quot;error %d reading EVCR\n&quot;, ret);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	write_enable(nor);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* set EVCR, enable quad I/O */</span>
<span class="p_del">-	nor-&gt;cmd_buf[0] = val &amp; ~EVCR_QUAD_EN_MICRON;</span>
<span class="p_del">-	ret = nor-&gt;write_reg(nor, SPINOR_OP_WD_EVCR, nor-&gt;cmd_buf, 1);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(nor-&gt;dev, &quot;error while writing EVCR register\n&quot;);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = spi_nor_wait_till_ready(nor);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* read EVCR and check it */</span>
<span class="p_del">-	ret = nor-&gt;read_reg(nor, SPINOR_OP_RD_EVCR, &amp;val, 1);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(nor-&gt;dev, &quot;error %d reading EVCR\n&quot;, ret);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (val &amp; EVCR_QUAD_EN_MICRON) {</span>
<span class="p_del">-		dev_err(nor-&gt;dev, &quot;Micron EVCR Quad bit not clear\n&quot;);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int set_quad_mode(struct spi_nor *nor, const struct flash_info *info)
 {
 	int status;
<span class="p_chunk">@@ -1119,12 +1080,7 @@</span> <span class="p_context"> static int set_quad_mode(struct spi_nor *nor, const struct flash_info *info)</span>
 		}
 		return status;
 	case SNOR_MFR_MICRON:
<span class="p_del">-		status = micron_quad_enable(nor);</span>
<span class="p_del">-		if (status) {</span>
<span class="p_del">-			dev_err(nor-&gt;dev, &quot;Micron quad-read not enabled\n&quot;);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		return status;</span>
<span class="p_add">+		return 0;</span>
 	default:
 		status = spansion_quad_enable(nor);
 		if (status) {
<span class="p_header">diff --git a/drivers/net/ethernet/jme.c b/drivers/net/ethernet/jme.c</span>
<span class="p_header">index 973dade2d07f..1257b18e6b90 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/jme.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/jme.c</span>
<span class="p_chunk">@@ -270,11 +270,17 @@</span> <span class="p_context"> jme_reset_mac_processor(struct jme_adapter *jme)</span>
 }
 
 static inline void
<span class="p_del">-jme_clear_pm(struct jme_adapter *jme)</span>
<span class="p_add">+jme_clear_pm_enable_wol(struct jme_adapter *jme)</span>
 {
 	jwrite32(jme, JME_PMCS, PMCS_STMASK | jme-&gt;reg_pmcs);
 }
 
<span class="p_add">+static inline void</span>
<span class="p_add">+jme_clear_pm_disable_wol(struct jme_adapter *jme)</span>
<span class="p_add">+{</span>
<span class="p_add">+	jwrite32(jme, JME_PMCS, PMCS_STMASK);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 jme_reload_eeprom(struct jme_adapter *jme)
 {
<span class="p_chunk">@@ -1853,7 +1859,7 @@</span> <span class="p_context"> jme_open(struct net_device *netdev)</span>
 	struct jme_adapter *jme = netdev_priv(netdev);
 	int rc;
 
<span class="p_del">-	jme_clear_pm(jme);</span>
<span class="p_add">+	jme_clear_pm_disable_wol(jme);</span>
 	JME_NAPI_ENABLE(jme);
 
 	tasklet_init(&amp;jme-&gt;linkch_task, jme_link_change_tasklet,
<span class="p_chunk">@@ -1925,11 +1931,11 @@</span> <span class="p_context"> jme_wait_link(struct jme_adapter *jme)</span>
 static void
 jme_powersave_phy(struct jme_adapter *jme)
 {
<span class="p_del">-	if (jme-&gt;reg_pmcs) {</span>
<span class="p_add">+	if (jme-&gt;reg_pmcs &amp;&amp; device_may_wakeup(&amp;jme-&gt;pdev-&gt;dev)) {</span>
 		jme_set_100m_half(jme);
 		if (jme-&gt;reg_pmcs &amp; (PMCS_LFEN | PMCS_LREN))
 			jme_wait_link(jme);
<span class="p_del">-		jme_clear_pm(jme);</span>
<span class="p_add">+		jme_clear_pm_enable_wol(jme);</span>
 	} else {
 		jme_phy_off(jme);
 	}
<span class="p_chunk">@@ -2646,9 +2652,6 @@</span> <span class="p_context"> jme_set_wol(struct net_device *netdev,</span>
 	if (wol-&gt;wolopts &amp; WAKE_MAGIC)
 		jme-&gt;reg_pmcs |= PMCS_MFEN;
 
<span class="p_del">-	jwrite32(jme, JME_PMCS, jme-&gt;reg_pmcs);</span>
<span class="p_del">-	device_set_wakeup_enable(&amp;jme-&gt;pdev-&gt;dev, !!(jme-&gt;reg_pmcs));</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3172,8 +3175,8 @@</span> <span class="p_context"> jme_init_one(struct pci_dev *pdev,</span>
 	jme-&gt;mii_if.mdio_read = jme_mdio_read;
 	jme-&gt;mii_if.mdio_write = jme_mdio_write;
 
<span class="p_del">-	jme_clear_pm(jme);</span>
<span class="p_del">-	device_set_wakeup_enable(&amp;pdev-&gt;dev, true);</span>
<span class="p_add">+	jme_clear_pm_disable_wol(jme);</span>
<span class="p_add">+	device_init_wakeup(&amp;pdev-&gt;dev, true);</span>
 
 	jme_set_phyfifo_5level(jme);
 	jme-&gt;pcirev = pdev-&gt;revision;
<span class="p_chunk">@@ -3304,7 +3307,7 @@</span> <span class="p_context"> jme_resume(struct device *dev)</span>
 	if (!netif_running(netdev))
 		return 0;
 
<span class="p_del">-	jme_clear_pm(jme);</span>
<span class="p_add">+	jme_clear_pm_disable_wol(jme);</span>
 	jme_phy_on(jme);
 	if (test_bit(JME_FLAG_SSET, &amp;jme-&gt;flags))
 		jme_set_settings(netdev, &amp;jme-&gt;old_ecmd);
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index e88afac51c5d..f96ab2f4b90e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -1557,6 +1557,8 @@</span> <span class="p_context"> void __iwl_mvm_mac_stop(struct iwl_mvm *mvm)</span>
 	/* the fw is stopped, the aux sta is dead: clean up driver state */
 	iwl_mvm_del_aux_sta(mvm);
 
<span class="p_add">+	iwl_free_fw_paging(mvm);</span>
<span class="p_add">+</span>
 	/*
 	 * Clear IN_HW_RESTART flag when stopping the hw (as restart_complete()
 	 * won&#39;t be called in this case).
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/ops.c b/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_header">index c3adf2bcdc85..13c97f665ba8 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_chunk">@@ -645,8 +645,6 @@</span> <span class="p_context"> static void iwl_op_mode_mvm_stop(struct iwl_op_mode *op_mode)</span>
 	for (i = 0; i &lt; NVM_MAX_NUM_SECTIONS; i++)
 		kfree(mvm-&gt;nvm_sections[i].data);
 
<span class="p_del">-	iwl_free_fw_paging(mvm);</span>
<span class="p_del">-</span>
 	iwl_mvm_tof_clean(mvm);
 
 	ieee80211_free_hw(mvm-&gt;hw);
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/trans.c b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">index 8c7204738aa3..00e0332e2544 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_chunk">@@ -731,8 +731,8 @@</span> <span class="p_context"> static int iwl_pcie_rsa_race_bug_wa(struct iwl_trans *trans)</span>
 	 */
 	val = iwl_read_prph(trans, PREG_AUX_BUS_WPROT_0);
 	if (val &amp; (BIT(1) | BIT(17))) {
<span class="p_del">-		IWL_INFO(trans,</span>
<span class="p_del">-			 &quot;can&#39;t access the RSA semaphore it is write protected\n&quot;);</span>
<span class="p_add">+		IWL_DEBUG_INFO(trans,</span>
<span class="p_add">+			       &quot;can&#39;t access the RSA semaphore it is write protected\n&quot;);</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/drivers/pinctrl/mediatek/pinctrl-mtk-common.c b/drivers/pinctrl/mediatek/pinctrl-mtk-common.c</span>
<span class="p_header">index 5c717275a7fa..3d8019eb3d84 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mediatek/pinctrl-mtk-common.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mediatek/pinctrl-mtk-common.c</span>
<span class="p_chunk">@@ -939,7 +939,8 @@</span> <span class="p_context"> static int mtk_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,</span>
 	struct mtk_pinctrl *pctl = dev_get_drvdata(chip-&gt;dev);
 	int eint_num, virq, eint_offset;
 	unsigned int set_offset, bit, clr_bit, clr_offset, rst, i, unmask, dbnc;
<span class="p_del">-	static const unsigned int dbnc_arr[] = {0 , 1, 16, 32, 64, 128, 256};</span>
<span class="p_add">+	static const unsigned int debounce_time[] = {500, 1000, 16000, 32000, 64000,</span>
<span class="p_add">+						128000, 256000};</span>
 	const struct mtk_desc_pin *pin;
 	struct irq_data *d;
 
<span class="p_chunk">@@ -957,9 +958,9 @@</span> <span class="p_context"> static int mtk_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,</span>
 	if (!mtk_eint_can_en_debounce(pctl, eint_num))
 		return -ENOSYS;
 
<span class="p_del">-	dbnc = ARRAY_SIZE(dbnc_arr);</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(dbnc_arr); i++) {</span>
<span class="p_del">-		if (debounce &lt;= dbnc_arr[i]) {</span>
<span class="p_add">+	dbnc = ARRAY_SIZE(debounce_time);</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(debounce_time); i++) {</span>
<span class="p_add">+		if (debounce &lt;= debounce_time[i]) {</span>
 			dbnc = i;
 			break;
 		}
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-single.c b/drivers/pinctrl/pinctrl-single.c</span>
<span class="p_header">index ef04b962c3d5..23b6b8c29a99 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-single.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-single.c</span>
<span class="p_chunk">@@ -1273,9 +1273,9 @@</span> <span class="p_context"> static int pcs_parse_bits_in_pinctrl_entry(struct pcs_device *pcs,</span>
 
 		/* Parse pins in each row from LSB */
 		while (mask) {
<span class="p_del">-			bit_pos = ffs(mask);</span>
<span class="p_add">+			bit_pos = __ffs(mask);</span>
 			pin_num_from_lsb = bit_pos / pcs-&gt;bits_per_pin;
<span class="p_del">-			mask_pos = ((pcs-&gt;fmask) &lt;&lt; (bit_pos - 1));</span>
<span class="p_add">+			mask_pos = ((pcs-&gt;fmask) &lt;&lt; bit_pos);</span>
 			val_pos = val &amp; mask_pos;
 			submask = mask &amp; mask_pos;
 
<span class="p_chunk">@@ -1847,7 +1847,7 @@</span> <span class="p_context"> static int pcs_probe(struct platform_device *pdev)</span>
 	ret = of_property_read_u32(np, &quot;pinctrl-single,function-mask&quot;,
 				   &amp;pcs-&gt;fmask);
 	if (!ret) {
<span class="p_del">-		pcs-&gt;fshift = ffs(pcs-&gt;fmask) - 1;</span>
<span class="p_add">+		pcs-&gt;fshift = __ffs(pcs-&gt;fmask);</span>
 		pcs-&gt;fmax = pcs-&gt;fmask &gt;&gt; pcs-&gt;fshift;
 	} else {
 		/* If mask property doesn&#39;t exist, function mux is invalid. */
<span class="p_header">diff --git a/drivers/platform/x86/toshiba_acpi.c b/drivers/platform/x86/toshiba_acpi.c</span>
<span class="p_header">index b0f62141ea4d..f774cb576ffa 100644</span>
<span class="p_header">--- a/drivers/platform/x86/toshiba_acpi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/toshiba_acpi.c</span>
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> MODULE_LICENSE(&quot;GPL&quot;);</span>
 /* Field definitions */
 #define HCI_ACCEL_MASK			0x7fff
 #define HCI_HOTKEY_DISABLE		0x0b
<span class="p_del">-#define HCI_HOTKEY_ENABLE		0x01</span>
<span class="p_add">+#define HCI_HOTKEY_ENABLE		0x09</span>
 #define HCI_HOTKEY_SPECIAL_FUNCTIONS	0x10
 #define HCI_LCD_BRIGHTNESS_BITS		3
 #define HCI_LCD_BRIGHTNESS_SHIFT	(16-HCI_LCD_BRIGHTNESS_BITS)
<span class="p_header">diff --git a/drivers/pwm/pwm-brcmstb.c b/drivers/pwm/pwm-brcmstb.c</span>
<span class="p_header">index 423ce087cd9c..5d5adee16886 100644</span>
<span class="p_header">--- a/drivers/pwm/pwm-brcmstb.c</span>
<span class="p_header">+++ b/drivers/pwm/pwm-brcmstb.c</span>
<span class="p_chunk">@@ -274,8 +274,8 @@</span> <span class="p_context"> static int brcmstb_pwm_probe(struct platform_device *pdev)</span>
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	p-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);
<span class="p_del">-	if (!p-&gt;base) {</span>
<span class="p_del">-		ret = -ENOMEM;</span>
<span class="p_add">+	if (IS_ERR(p-&gt;base)) {</span>
<span class="p_add">+		ret = PTR_ERR(p-&gt;base);</span>
 		goto out_clk;
 	}
 
<span class="p_header">diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c</span>
<span class="p_header">index 7b94b8ee087c..732ac71b82cd 100644</span>
<span class="p_header">--- a/drivers/regulator/core.c</span>
<span class="p_header">+++ b/drivers/regulator/core.c</span>
<span class="p_chunk">@@ -148,7 +148,7 @@</span> <span class="p_context"> static void regulator_lock_supply(struct regulator_dev *rdev)</span>
 {
 	int i;
 
<span class="p_del">-	for (i = 0; rdev-&gt;supply; rdev = rdev_get_supply(rdev), i++)</span>
<span class="p_add">+	for (i = 0; rdev; rdev = rdev_get_supply(rdev), i++)</span>
 		mutex_lock_nested(&amp;rdev-&gt;mutex, i);
 }
 
<span class="p_header">diff --git a/drivers/regulator/s5m8767.c b/drivers/regulator/s5m8767.c</span>
<span class="p_header">index 58f5d3b8e981..27343e1c43ef 100644</span>
<span class="p_header">--- a/drivers/regulator/s5m8767.c</span>
<span class="p_header">+++ b/drivers/regulator/s5m8767.c</span>
<span class="p_chunk">@@ -202,9 +202,10 @@</span> <span class="p_context"> static int s5m8767_get_register(struct s5m8767_info *s5m8767, int reg_id,</span>
 		}
 	}
 
<span class="p_del">-	if (i &lt; s5m8767-&gt;num_regulators)</span>
<span class="p_del">-		*enable_ctrl =</span>
<span class="p_del">-		s5m8767_opmode_reg[reg_id][mode] &lt;&lt; S5M8767_ENCTRL_SHIFT;</span>
<span class="p_add">+	if (i &gt;= s5m8767-&gt;num_regulators)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	*enable_ctrl = s5m8767_opmode_reg[reg_id][mode] &lt;&lt; S5M8767_ENCTRL_SHIFT;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -937,8 +938,12 @@</span> <span class="p_context"> static int s5m8767_pmic_probe(struct platform_device *pdev)</span>
 			else
 				regulators[id].vsel_mask = 0xff;
 
<span class="p_del">-			s5m8767_get_register(s5m8767, id, &amp;enable_reg,</span>
<span class="p_add">+			ret = s5m8767_get_register(s5m8767, id, &amp;enable_reg,</span>
 					     &amp;enable_val);
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				dev_err(s5m8767-&gt;dev, &quot;error reading registers\n&quot;);</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+			}</span>
 			regulators[id].enable_reg = enable_reg;
 			regulators[id].enable_mask = S5M8767_ENCTRL_MASK;
 			regulators[id].enable_val = enable_val;
<span class="p_header">diff --git a/drivers/rtc/rtc-ds1685.c b/drivers/rtc/rtc-ds1685.c</span>
<span class="p_header">index 05a51ef52703..d5c1b057a739 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-ds1685.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-ds1685.c</span>
<span class="p_chunk">@@ -187,9 +187,9 @@</span> <span class="p_context"> ds1685_rtc_end_data_access(struct ds1685_priv *rtc)</span>
  * Only use this where you are certain another lock will not be held.
  */
 static inline void
<span class="p_del">-ds1685_rtc_begin_ctrl_access(struct ds1685_priv *rtc, unsigned long flags)</span>
<span class="p_add">+ds1685_rtc_begin_ctrl_access(struct ds1685_priv *rtc, unsigned long *flags)</span>
 {
<span class="p_del">-	spin_lock_irqsave(&amp;rtc-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;rtc-&gt;lock, *flags);</span>
 	ds1685_rtc_switch_to_bank1(rtc);
 }
 
<span class="p_chunk">@@ -1304,7 +1304,7 @@</span> <span class="p_context"> ds1685_rtc_sysfs_ctrl_regs_store(struct device *dev,</span>
 {
 	struct ds1685_priv *rtc = dev_get_drvdata(dev);
 	u8 reg = 0, bit = 0, tmp;
<span class="p_del">-	unsigned long flags = 0;</span>
<span class="p_add">+	unsigned long flags;</span>
 	long int val = 0;
 	const struct ds1685_rtc_ctrl_regs *reg_info =
 		ds1685_rtc_sysfs_ctrl_regs_lookup(attr-&gt;attr.name);
<span class="p_chunk">@@ -1325,7 +1325,7 @@</span> <span class="p_context"> ds1685_rtc_sysfs_ctrl_regs_store(struct device *dev,</span>
 	bit = reg_info-&gt;bit;
 
 	/* Safe to spinlock during a write. */
<span class="p_del">-	ds1685_rtc_begin_ctrl_access(rtc, flags);</span>
<span class="p_add">+	ds1685_rtc_begin_ctrl_access(rtc, &amp;flags);</span>
 	tmp = rtc-&gt;read(rtc, reg);
 	rtc-&gt;write(rtc, reg, (val ? (tmp | bit) : (tmp &amp; ~(bit))));
 	ds1685_rtc_end_ctrl_access(rtc, flags);
<span class="p_header">diff --git a/drivers/rtc/rtc-hym8563.c b/drivers/rtc/rtc-hym8563.c</span>
<span class="p_header">index 097325d96db5..b1b4746a0eab 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-hym8563.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-hym8563.c</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static int hym8563_rtc_set_time(struct device *dev, struct rtc_time *tm)</span>
 	 * it does not seem to carry it over a subsequent write/read.
 	 * So we&#39;ll limit ourself to 100 years, starting at 2000 for now.
 	 */
<span class="p_del">-	buf[6] = tm-&gt;tm_year - 100;</span>
<span class="p_add">+	buf[6] = bin2bcd(tm-&gt;tm_year - 100);</span>
 
 	/*
 	 * CTL1 only contains TEST-mode bits apart from stop,
<span class="p_header">diff --git a/drivers/rtc/rtc-max77686.c b/drivers/rtc/rtc-max77686.c</span>
<span class="p_header">index 7184a0eda793..725dccae24e7 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-max77686.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-max77686.c</span>
<span class="p_chunk">@@ -465,7 +465,7 @@</span> <span class="p_context"> static int max77686_rtc_probe(struct platform_device *pdev)</span>
 
 	info-&gt;virq = regmap_irq_get_virq(max77686-&gt;rtc_irq_data,
 					 MAX77686_RTCIRQ_RTCA1);
<span class="p_del">-	if (!info-&gt;virq) {</span>
<span class="p_add">+	if (info-&gt;virq &lt;= 0) {</span>
 		ret = -ENXIO;
 		goto err_rtc;
 	}
<span class="p_header">diff --git a/drivers/rtc/rtc-rx8025.c b/drivers/rtc/rtc-rx8025.c</span>
<span class="p_header">index bd911bafb809..17341feadad1 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-rx8025.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-rx8025.c</span>
<span class="p_chunk">@@ -65,7 +65,6 @@</span> <span class="p_context"></span>
 
 static const struct i2c_device_id rx8025_id[] = {
 	{ &quot;rx8025&quot;, 0 },
<span class="p_del">-	{ &quot;rv8803&quot;, 1 },</span>
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, rx8025_id);
<span class="p_header">diff --git a/drivers/rtc/rtc-vr41xx.c b/drivers/rtc/rtc-vr41xx.c</span>
<span class="p_header">index f64c282275b3..e1b86bb01062 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-vr41xx.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-vr41xx.c</span>
<span class="p_chunk">@@ -272,12 +272,13 @@</span> <span class="p_context"> static irqreturn_t rtclong1_interrupt(int irq, void *dev_id)</span>
 }
 
 static const struct rtc_class_ops vr41xx_rtc_ops = {
<span class="p_del">-	.release	= vr41xx_rtc_release,</span>
<span class="p_del">-	.ioctl		= vr41xx_rtc_ioctl,</span>
<span class="p_del">-	.read_time	= vr41xx_rtc_read_time,</span>
<span class="p_del">-	.set_time	= vr41xx_rtc_set_time,</span>
<span class="p_del">-	.read_alarm	= vr41xx_rtc_read_alarm,</span>
<span class="p_del">-	.set_alarm	= vr41xx_rtc_set_alarm,</span>
<span class="p_add">+	.release		= vr41xx_rtc_release,</span>
<span class="p_add">+	.ioctl			= vr41xx_rtc_ioctl,</span>
<span class="p_add">+	.read_time		= vr41xx_rtc_read_time,</span>
<span class="p_add">+	.set_time		= vr41xx_rtc_set_time,</span>
<span class="p_add">+	.read_alarm		= vr41xx_rtc_read_alarm,</span>
<span class="p_add">+	.set_alarm		= vr41xx_rtc_set_alarm,</span>
<span class="p_add">+	.alarm_irq_enable	= vr41xx_rtc_alarm_irq_enable,</span>
 };
 
 static int rtc_probe(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/scsi/device_handler/Kconfig b/drivers/scsi/device_handler/Kconfig</span>
<span class="p_header">index e5647d59224f..0b331c9c0a8f 100644</span>
<span class="p_header">--- a/drivers/scsi/device_handler/Kconfig</span>
<span class="p_header">+++ b/drivers/scsi/device_handler/Kconfig</span>
<span class="p_chunk">@@ -13,13 +13,13 @@</span> <span class="p_context"> menuconfig SCSI_DH</span>
 
 config SCSI_DH_RDAC
 	tristate &quot;LSI RDAC Device Handler&quot;
<span class="p_del">-	depends on SCSI_DH</span>
<span class="p_add">+	depends on SCSI_DH &amp;&amp; SCSI</span>
 	help
 	If you have a LSI RDAC select y. Otherwise, say N.
 
 config SCSI_DH_HP_SW
 	tristate &quot;HP/COMPAQ MSA Device Handler&quot;
<span class="p_del">-	depends on SCSI_DH</span>
<span class="p_add">+	depends on SCSI_DH &amp;&amp; SCSI</span>
 	help
 	If you have a HP/COMPAQ MSA device that requires START_STOP to
 	be sent to start it and cannot upgrade the firmware then select y.
<span class="p_chunk">@@ -27,13 +27,13 @@</span> <span class="p_context"> config SCSI_DH_HP_SW</span>
 
 config SCSI_DH_EMC
 	tristate &quot;EMC CLARiiON Device Handler&quot;
<span class="p_del">-	depends on SCSI_DH</span>
<span class="p_add">+	depends on SCSI_DH &amp;&amp; SCSI</span>
 	help
 	If you have a EMC CLARiiON select y. Otherwise, say N.
 
 config SCSI_DH_ALUA
 	tristate &quot;SPC-3 ALUA Device Handler&quot;
<span class="p_del">-	depends on SCSI_DH</span>
<span class="p_add">+	depends on SCSI_DH &amp;&amp; SCSI</span>
 	help
 	  SCSI Device handler for generic SPC-3 Asymmetric Logical Unit
 	  Access (ALUA).
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 97a1c1c33b05..00ce3e269a43 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -6282,12 +6282,13 @@</span> <span class="p_context"> out:</span>
 	}
 
 	for (i = 0; i &lt; ioc-&gt;sge_count; i++) {
<span class="p_del">-		if (kbuff_arr[i])</span>
<span class="p_add">+		if (kbuff_arr[i]) {</span>
 			dma_free_coherent(&amp;instance-&gt;pdev-&gt;dev,
 					  le32_to_cpu(kern_sge32[i].length),
 					  kbuff_arr[i],
 					  le32_to_cpu(kern_sge32[i].phys_addr));
 			kbuff_arr[i] = NULL;
<span class="p_add">+		}</span>
 	}
 
 	megasas_return_cmd(instance, cmd);
<span class="p_header">diff --git a/drivers/spi/spi-rockchip.c b/drivers/spi/spi-rockchip.c</span>
<span class="p_header">index 79a8bc4f6cec..035767c02072 100644</span>
<span class="p_header">--- a/drivers/spi/spi-rockchip.c</span>
<span class="p_header">+++ b/drivers/spi/spi-rockchip.c</span>
<span class="p_chunk">@@ -265,7 +265,10 @@</span> <span class="p_context"> static inline u32 rx_max(struct rockchip_spi *rs)</span>
 static void rockchip_spi_set_cs(struct spi_device *spi, bool enable)
 {
 	u32 ser;
<span class="p_del">-	struct rockchip_spi *rs = spi_master_get_devdata(spi-&gt;master);</span>
<span class="p_add">+	struct spi_master *master = spi-&gt;master;</span>
<span class="p_add">+	struct rockchip_spi *rs = spi_master_get_devdata(master);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_runtime_get_sync(rs-&gt;dev);</span>
 
 	ser = readl_relaxed(rs-&gt;regs + ROCKCHIP_SPI_SER) &amp; SER_MASK;
 
<span class="p_chunk">@@ -290,6 +293,8 @@</span> <span class="p_context"> static void rockchip_spi_set_cs(struct spi_device *spi, bool enable)</span>
 		ser &amp;= ~(1 &lt;&lt; spi-&gt;chip_select);
 
 	writel_relaxed(ser, rs-&gt;regs + ROCKCHIP_SPI_SER);
<span class="p_add">+</span>
<span class="p_add">+	pm_runtime_put_sync(rs-&gt;dev);</span>
 }
 
 static int rockchip_spi_prepare_message(struct spi_master *master,
<span class="p_header">diff --git a/drivers/staging/rdma/hfi1/TODO b/drivers/staging/rdma/hfi1/TODO</span>
<span class="p_header">index 05de0dad8762..4c6f1d7d2eaf 100644</span>
<span class="p_header">--- a/drivers/staging/rdma/hfi1/TODO</span>
<span class="p_header">+++ b/drivers/staging/rdma/hfi1/TODO</span>
<span class="p_chunk">@@ -3,4 +3,4 @@</span> <span class="p_context"> July, 2015</span>
 - Remove unneeded file entries in sysfs
 - Remove software processing of IB protocol and place in library for use
   by qib, ipath (if still present), hfi1, and eventually soft-roce
<span class="p_del">-</span>
<span class="p_add">+- Replace incorrect uAPI</span>
<span class="p_header">diff --git a/drivers/staging/rdma/hfi1/file_ops.c b/drivers/staging/rdma/hfi1/file_ops.c</span>
<span class="p_header">index aae9826ec62b..c851e51b1dc3 100644</span>
<span class="p_header">--- a/drivers/staging/rdma/hfi1/file_ops.c</span>
<span class="p_header">+++ b/drivers/staging/rdma/hfi1/file_ops.c</span>
<span class="p_chunk">@@ -62,6 +62,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/cred.h&gt;
 #include &lt;linux/uio.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;hfi.h&quot;
 #include &quot;pio.h&quot;
 #include &quot;device.h&quot;
<span class="p_chunk">@@ -214,6 +216,10 @@</span> <span class="p_context"> static ssize_t hfi1_file_write(struct file *fp, const char __user *data,</span>
 	int uctxt_required = 1;
 	int must_be_root = 0;
 
<span class="p_add">+	/* FIXME: This interface cannot continue out of staging */</span>
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (count &lt; sizeof(cmd)) {
 		ret = -EINVAL;
 		goto bail;
<span class="p_header">diff --git a/drivers/thermal/rockchip_thermal.c b/drivers/thermal/rockchip_thermal.c</span>
<span class="p_header">index e845841ab036..7106288efae3 100644</span>
<span class="p_header">--- a/drivers/thermal/rockchip_thermal.c</span>
<span class="p_header">+++ b/drivers/thermal/rockchip_thermal.c</span>
<span class="p_chunk">@@ -545,15 +545,14 @@</span> <span class="p_context"> static int rockchip_configure_from_dt(struct device *dev,</span>
 			 thermal-&gt;chip-&gt;tshut_temp);
 		thermal-&gt;tshut_temp = thermal-&gt;chip-&gt;tshut_temp;
 	} else {
<span class="p_add">+		if (shut_temp &gt; INT_MAX) {</span>
<span class="p_add">+			dev_err(dev, &quot;Invalid tshut temperature specified: %d\n&quot;,</span>
<span class="p_add">+				shut_temp);</span>
<span class="p_add">+			return -ERANGE;</span>
<span class="p_add">+		}</span>
 		thermal-&gt;tshut_temp = shut_temp;
 	}
 
<span class="p_del">-	if (thermal-&gt;tshut_temp &gt; INT_MAX) {</span>
<span class="p_del">-		dev_err(dev, &quot;Invalid tshut temperature specified: %d\n&quot;,</span>
<span class="p_del">-			thermal-&gt;tshut_temp);</span>
<span class="p_del">-		return -ERANGE;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (of_property_read_u32(np, &quot;rockchip,hw-tshut-mode&quot;, &amp;tshut_mode)) {
 		dev_warn(dev,
 			 &quot;Missing tshut mode property, using default (%s)\n&quot;,
<span class="p_header">diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c</span>
<span class="p_header">index 51c7507b0444..63a06ab6ba03 100644</span>
<span class="p_header">--- a/drivers/tty/serial/sh-sci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/sh-sci.c</span>
<span class="p_chunk">@@ -38,7 +38,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/major.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/mm.h&gt;
<span class="p_del">-#include &lt;linux/notifier.h&gt;</span>
 #include &lt;linux/of.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/pm_runtime.h&gt;
<span class="p_chunk">@@ -116,8 +115,6 @@</span> <span class="p_context"> struct sci_port {</span>
 	struct timer_list		rx_timer;
 	unsigned int			rx_timeout;
 #endif
<span class="p_del">-</span>
<span class="p_del">-	struct notifier_block		freq_transition;</span>
 };
 
 #define SCI_NPORTS CONFIG_SERIAL_SH_SCI_NR_UARTS
<span class="p_chunk">@@ -1606,29 +1603,6 @@</span> <span class="p_context"> static irqreturn_t sci_mpxed_interrupt(int irq, void *ptr)</span>
 	return ret;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Here we define a transition notifier so that we can update all of our</span>
<span class="p_del">- * ports&#39; baud rate when the peripheral clock changes.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int sci_notifier(struct notifier_block *self,</span>
<span class="p_del">-			unsigned long phase, void *p)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct sci_port *sci_port;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	sci_port = container_of(self, struct sci_port, freq_transition);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (phase == CPUFREQ_POSTCHANGE) {</span>
<span class="p_del">-		struct uart_port *port = &amp;sci_port-&gt;port;</span>
<span class="p_del">-</span>
<span class="p_del">-		spin_lock_irqsave(&amp;port-&gt;lock, flags);</span>
<span class="p_del">-		port-&gt;uartclk = clk_get_rate(sci_port-&gt;iclk);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;port-&gt;lock, flags);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return NOTIFY_OK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static const struct sci_irq_desc {
 	const char	*desc;
 	irq_handler_t	handler;
<span class="p_chunk">@@ -2559,9 +2533,6 @@</span> <span class="p_context"> static int sci_remove(struct platform_device *dev)</span>
 {
 	struct sci_port *port = platform_get_drvdata(dev);
 
<span class="p_del">-	cpufreq_unregister_notifier(&amp;port-&gt;freq_transition,</span>
<span class="p_del">-				    CPUFREQ_TRANSITION_NOTIFIER);</span>
<span class="p_del">-</span>
 	uart_remove_one_port(&amp;sci_uart_driver, &amp;port-&gt;port);
 
 	sci_cleanup_single(port);
<span class="p_chunk">@@ -2714,16 +2685,6 @@</span> <span class="p_context"> static int sci_probe(struct platform_device *dev)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	sp-&gt;freq_transition.notifier_call = sci_notifier;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = cpufreq_register_notifier(&amp;sp-&gt;freq_transition,</span>
<span class="p_del">-					CPUFREQ_TRANSITION_NOTIFIER);</span>
<span class="p_del">-	if (unlikely(ret &lt; 0)) {</span>
<span class="p_del">-		uart_remove_one_port(&amp;sci_uart_driver, &amp;sp-&gt;port);</span>
<span class="p_del">-		sci_cleanup_single(sp);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_SH_STANDARD_BIOS
 	sh_bios_gdb_detach();
 #endif
<span class="p_header">diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">index 9eb1cff28bd4..b8b580e5ae6e 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd-pci.c</span>
<span class="p_chunk">@@ -74,6 +74,15 @@</span> <span class="p_context"> static void for_each_companion(struct pci_dev *pdev, struct usb_hcd *hcd,</span>
 		if (companion-&gt;bus != pdev-&gt;bus ||
 				PCI_SLOT(companion-&gt;devfn) != slot)
 			continue;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Companion device should be either UHCI,OHCI or EHCI host</span>
<span class="p_add">+		 * controller, otherwise skip.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (companion-&gt;class != CL_UHCI &amp;&amp; companion-&gt;class != CL_OHCI &amp;&amp;</span>
<span class="p_add">+				companion-&gt;class != CL_EHCI)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		companion_hcd = pci_get_drvdata(companion);
 		if (!companion_hcd || !companion_hcd-&gt;self.root_hub)
 			continue;
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index cf43e9e18368..79d895c2dd71 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -646,6 +646,7 @@</span> <span class="p_context"> static void ffs_user_copy_worker(struct work_struct *work)</span>
 						   work);
 	int ret = io_data-&gt;req-&gt;status ? io_data-&gt;req-&gt;status :
 					 io_data-&gt;req-&gt;actual;
<span class="p_add">+	bool kiocb_has_eventfd = io_data-&gt;kiocb-&gt;ki_flags &amp; IOCB_EVENTFD;</span>
 
 	if (io_data-&gt;read &amp;&amp; ret &gt; 0) {
 		use_mm(io_data-&gt;mm);
<span class="p_chunk">@@ -657,13 +658,11 @@</span> <span class="p_context"> static void ffs_user_copy_worker(struct work_struct *work)</span>
 
 	io_data-&gt;kiocb-&gt;ki_complete(io_data-&gt;kiocb, ret, ret);
 
<span class="p_del">-	if (io_data-&gt;ffs-&gt;ffs_eventfd &amp;&amp;</span>
<span class="p_del">-	    !(io_data-&gt;kiocb-&gt;ki_flags &amp; IOCB_EVENTFD))</span>
<span class="p_add">+	if (io_data-&gt;ffs-&gt;ffs_eventfd &amp;&amp; !kiocb_has_eventfd)</span>
 		eventfd_signal(io_data-&gt;ffs-&gt;ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data-&gt;ep, io_data-&gt;req);
 
<span class="p_del">-	io_data-&gt;kiocb-&gt;private = NULL;</span>
 	if (io_data-&gt;read)
 		kfree(io_data-&gt;to_free);
 	kfree(io_data-&gt;buf);
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index c48cbe731356..d8dbd7e5194b 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1875,6 +1875,12 @@</span> <span class="p_context"> no_bw:</span>
 	kfree(xhci-&gt;rh_bw);
 	kfree(xhci-&gt;ext_caps);
 
<span class="p_add">+	xhci-&gt;usb2_ports = NULL;</span>
<span class="p_add">+	xhci-&gt;usb3_ports = NULL;</span>
<span class="p_add">+	xhci-&gt;port_array = NULL;</span>
<span class="p_add">+	xhci-&gt;rh_bw = NULL;</span>
<span class="p_add">+	xhci-&gt;ext_caps = NULL;</span>
<span class="p_add">+</span>
 	xhci-&gt;page_size = 0;
 	xhci-&gt;page_shift = 0;
 	xhci-&gt;bus_state[0].bus_suspended = 0;
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index c2d65206ec6c..ea4fb4b0cd44 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -48,6 +48,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
 #define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI		0x1aa8</span>
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
<span class="p_chunk">@@ -156,7 +157,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
<span class="p_del">-		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI)) {</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI)) {</span>
 		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ETRON &amp;&amp;
<span class="p_chunk">@@ -299,6 +301,7 @@</span> <span class="p_context"> static void xhci_pci_remove(struct pci_dev *dev)</span>
 	struct xhci_hcd *xhci;
 
 	xhci = hcd_to_xhci(pci_get_drvdata(dev));
<span class="p_add">+	xhci-&gt;xhc_state |= XHCI_STATE_REMOVING;</span>
 	if (xhci-&gt;shared_hcd) {
 		usb_remove_hcd(xhci-&gt;shared_hcd);
 		usb_put_hcd(xhci-&gt;shared_hcd);
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index db0f0831b94f..2b63969c2bbf 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -4008,7 +4008,8 @@</span> <span class="p_context"> static int queue_command(struct xhci_hcd *xhci, struct xhci_command *cmd,</span>
 	int reserved_trbs = xhci-&gt;cmd_ring_reserved_trbs;
 	int ret;
 
<span class="p_del">-	if (xhci-&gt;xhc_state) {</span>
<span class="p_add">+	if ((xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) ||</span>
<span class="p_add">+		(xhci-&gt;xhc_state &amp; XHCI_STATE_HALTED)) {</span>
 		xhci_dbg(xhci, &quot;xHCI dying or halted, can&#39;t queue_command\n&quot;);
 		return -ESHUTDOWN;
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 776d59c32bc5..ec9e758d5fcd 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -146,7 +146,8 @@</span> <span class="p_context"> static int xhci_start(struct xhci_hcd *xhci)</span>
 				&quot;waited %u microseconds.\n&quot;,
 				XHCI_MAX_HALT_USEC);
 	if (!ret)
<span class="p_del">-		xhci-&gt;xhc_state &amp;= ~(XHCI_STATE_HALTED | XHCI_STATE_DYING);</span>
<span class="p_add">+		/* clear state flags. Including dying, halted or removing */</span>
<span class="p_add">+		xhci-&gt;xhc_state = 0;</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1103,8 +1104,8 @@</span> <span class="p_context"> int xhci_resume(struct xhci_hcd *xhci, bool hibernated)</span>
 		/* Resume root hubs only when have pending events. */
 		status = readl(&amp;xhci-&gt;op_regs-&gt;status);
 		if (status &amp; STS_EINT) {
<span class="p_del">-			usb_hcd_resume_root_hub(hcd);</span>
 			usb_hcd_resume_root_hub(xhci-&gt;shared_hcd);
<span class="p_add">+			usb_hcd_resume_root_hub(hcd);</span>
 		}
 	}
 
<span class="p_chunk">@@ -1119,10 +1120,10 @@</span> <span class="p_context"> int xhci_resume(struct xhci_hcd *xhci, bool hibernated)</span>
 
 	/* Re-enable port polling. */
 	xhci_dbg(xhci, &quot;%s: starting port polling.\n&quot;, __func__);
<span class="p_del">-	set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);</span>
<span class="p_del">-	usb_hcd_poll_rh_status(hcd);</span>
 	set_bit(HCD_FLAG_POLL_RH, &amp;xhci-&gt;shared_hcd-&gt;flags);
 	usb_hcd_poll_rh_status(xhci-&gt;shared_hcd);
<span class="p_add">+	set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);</span>
<span class="p_add">+	usb_hcd_poll_rh_status(hcd);</span>
 
 	return retval;
 }
<span class="p_chunk">@@ -2753,7 +2754,8 @@</span> <span class="p_context"> int xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev)</span>
 	if (ret &lt;= 0)
 		return ret;
 	xhci = hcd_to_xhci(hcd);
<span class="p_del">-	if (xhci-&gt;xhc_state &amp; XHCI_STATE_DYING)</span>
<span class="p_add">+	if ((xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) ||</span>
<span class="p_add">+		(xhci-&gt;xhc_state &amp; XHCI_STATE_REMOVING))</span>
 		return -ENODEV;
 
 	xhci_dbg(xhci, &quot;%s called for udev %p\n&quot;, __func__, udev);
<span class="p_chunk">@@ -3800,7 +3802,7 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 
 	mutex_lock(&amp;xhci-&gt;mutex);
 
<span class="p_del">-	if (xhci-&gt;xhc_state)	/* dying or halted */</span>
<span class="p_add">+	if (xhci-&gt;xhc_state)	/* dying, removing or halted */</span>
 		goto out;
 
 	if (!udev-&gt;slot_id) {
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 0b9451250e33..99ac2289dbf3 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1596,6 +1596,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
  */
 #define XHCI_STATE_DYING	(1 &lt;&lt; 0)
 #define XHCI_STATE_HALTED	(1 &lt;&lt; 1)
<span class="p_add">+#define XHCI_STATE_REMOVING	(1 &lt;&lt; 2)</span>
 	/* Statistics */
 	int			error_bitmask;
 	unsigned int		quirks;
<span class="p_header">diff --git a/drivers/usb/usbip/usbip_common.c b/drivers/usb/usbip/usbip_common.c</span>
<span class="p_header">index facaaf003f19..e40da7759a0e 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/usbip_common.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/usbip_common.c</span>
<span class="p_chunk">@@ -741,6 +741,17 @@</span> <span class="p_context"> int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)</span>
 	if (!(size &gt; 0))
 		return 0;
 
<span class="p_add">+	if (size &gt; urb-&gt;transfer_buffer_length) {</span>
<span class="p_add">+		/* should not happen, probably malicious packet */</span>
<span class="p_add">+		if (ud-&gt;side == USBIP_STUB) {</span>
<span class="p_add">+			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);</span>
<span class="p_add">+			return -EPIPE;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = usbip_recv(ud-&gt;tcp_socket, urb-&gt;transfer_buffer, size);
 	if (ret != size) {
 		dev_err(&amp;urb-&gt;dev-&gt;dev, &quot;recv xbuf, %d\n&quot;, ret);
<span class="p_header">diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig</span>
<span class="p_header">index e6d16d65e4e6..f07a0974fda2 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/Kconfig</span>
<span class="p_header">+++ b/drivers/video/fbdev/Kconfig</span>
<span class="p_chunk">@@ -2249,7 +2249,6 @@</span> <span class="p_context"> config XEN_FBDEV_FRONTEND</span>
 	select FB_SYS_IMAGEBLIT
 	select FB_SYS_FOPS
 	select FB_DEFERRED_IO
<span class="p_del">-	select INPUT_XEN_KBDDEV_FRONTEND if INPUT_MISC</span>
 	select XEN_XENBUS_FRONTEND
 	default y
 	help
<span class="p_header">diff --git a/drivers/video/fbdev/da8xx-fb.c b/drivers/video/fbdev/da8xx-fb.c</span>
<span class="p_header">index 0081725c6b5b..d00510029c93 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/da8xx-fb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/da8xx-fb.c</span>
<span class="p_chunk">@@ -209,8 +209,7 @@</span> <span class="p_context"> static struct fb_videomode known_lcd_panels[] = {</span>
 		.lower_margin   = 2,
 		.hsync_len      = 0,
 		.vsync_len      = 0,
<span class="p_del">-		.sync           = FB_SYNC_CLK_INVERT |</span>
<span class="p_del">-			FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,</span>
<span class="p_add">+		.sync           = FB_SYNC_CLK_INVERT,</span>
 	},
 	/* Sharp LK043T1DG01 */
 	[1] = {
<span class="p_chunk">@@ -224,7 +223,7 @@</span> <span class="p_context"> static struct fb_videomode known_lcd_panels[] = {</span>
 		.lower_margin   = 2,
 		.hsync_len      = 41,
 		.vsync_len      = 10,
<span class="p_del">-		.sync           = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,</span>
<span class="p_add">+		.sync           = 0,</span>
 		.flag           = 0,
 	},
 	[2] = {
<span class="p_chunk">@@ -239,7 +238,7 @@</span> <span class="p_context"> static struct fb_videomode known_lcd_panels[] = {</span>
 		.lower_margin   = 10,
 		.hsync_len      = 10,
 		.vsync_len      = 10,
<span class="p_del">-		.sync           = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,</span>
<span class="p_add">+		.sync           = 0,</span>
 		.flag           = 0,
 	},
 	[3] = {
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index b7fcc0de0b2f..0f5d05bf2131 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"> struct dentry *debugfs_create_automount(const char *name,</span>
 	if (unlikely(!inode))
 		return failed_creating(dentry);
 
<span class="p_del">-	inode-&gt;i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;</span>
<span class="p_add">+	make_empty_dir_inode(inode);</span>
 	inode-&gt;i_flags |= S_AUTOMOUNT;
 	inode-&gt;i_private = data;
 	dentry-&gt;d_fsdata = (void *)f;
<span class="p_header">diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h</span>
<span class="p_header">index d4156e1c128d..b7e921d207fb 100644</span>
<span class="p_header">--- a/fs/ext4/ext4.h</span>
<span class="p_header">+++ b/fs/ext4/ext4.h</span>
<span class="p_chunk">@@ -933,6 +933,15 @@</span> <span class="p_context"> struct ext4_inode_info {</span>
 	 * by other means, so we have i_data_sem.
 	 */
 	struct rw_semaphore i_data_sem;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * i_mmap_sem is for serializing page faults with truncate / punch hole</span>
<span class="p_add">+	 * operations. We have to make sure that new page cannot be faulted in</span>
<span class="p_add">+	 * a section of the inode that is being punched. We cannot easily use</span>
<span class="p_add">+	 * i_data_sem for this since we need protection for the whole punch</span>
<span class="p_add">+	 * operation and i_data_sem ranks below transaction start so we have</span>
<span class="p_add">+	 * to occasionally drop it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct rw_semaphore i_mmap_sem;</span>
 	struct inode vfs_inode;
 	struct jbd2_inode *jinode;
 
<span class="p_chunk">@@ -2507,6 +2516,7 @@</span> <span class="p_context"> extern int ext4_chunk_trans_blocks(struct inode *, int nrblocks);</span>
 extern int ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,
 			     loff_t lstart, loff_t lend);
 extern int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);
<span class="p_add">+extern int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf);</span>
 extern qsize_t *ext4_get_reserved_space(struct inode *inode);
 extern void ext4_da_update_reserve_space(struct inode *inode,
 					int used, int quota_claim);
<span class="p_chunk">@@ -2871,6 +2881,9 @@</span> <span class="p_context"> static inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)</span>
 	return changed;
 }
 
<span class="p_add">+int ext4_update_disksize_before_punch(struct inode *inode, loff_t offset,</span>
<span class="p_add">+				      loff_t len);</span>
<span class="p_add">+</span>
 struct ext4_group_info {
 	unsigned long   bb_state;
 	struct rb_root  bb_free_root;
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index 551353b1b17a..3578b25fccfd 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -4685,10 +4685,6 @@</span> <span class="p_context"> static int ext4_alloc_file_blocks(struct file *file, ext4_lblk_t offset,</span>
 	if (len &lt;= EXT_UNWRITTEN_MAX_LEN)
 		flags |= EXT4_GET_BLOCKS_NO_NORMALIZE;
 
<span class="p_del">-	/* Wait all existing dio workers, newcomers will block on i_mutex */</span>
<span class="p_del">-	ext4_inode_block_unlocked_dio(inode);</span>
<span class="p_del">-	inode_dio_wait(inode);</span>
<span class="p_del">-</span>
 	/*
 	 * credits to insert 1 extent into extent tree
 	 */
<span class="p_chunk">@@ -4752,8 +4748,6 @@</span> <span class="p_context"> retry:</span>
 		goto retry;
 	}
 
<span class="p_del">-	ext4_inode_resume_unlocked_dio(inode);</span>
<span class="p_del">-</span>
 	return ret &gt; 0 ? ret2 : ret;
 }
 
<span class="p_chunk">@@ -4770,7 +4764,6 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 	int partial_begin, partial_end;
 	loff_t start, end;
 	ext4_lblk_t lblk;
<span class="p_del">-	struct address_space *mapping = inode-&gt;i_mapping;</span>
 	unsigned int blkbits = inode-&gt;i_blkbits;
 
 	trace_ext4_zero_range(inode, offset, len, mode);
<span class="p_chunk">@@ -4786,17 +4779,6 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 	}
 
 	/*
<span class="p_del">-	 * Write out all dirty pages to avoid race conditions</span>
<span class="p_del">-	 * Then release them.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mapping-&gt;nrpages &amp;&amp; mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {</span>
<span class="p_del">-		ret = filemap_write_and_wait_range(mapping, offset,</span>
<span class="p_del">-						   offset + len - 1);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
 	 * Round up offset. This is not fallocate, we neet to zero out
 	 * blocks, so convert interior block aligned part of the range to
 	 * unwritten and possibly manually zero out unaligned parts of the
<span class="p_chunk">@@ -4839,6 +4821,10 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 	if (mode &amp; FALLOC_FL_KEEP_SIZE)
 		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
 
<span class="p_add">+	/* Wait all existing dio workers, newcomers will block on i_mutex */</span>
<span class="p_add">+	ext4_inode_block_unlocked_dio(inode);</span>
<span class="p_add">+	inode_dio_wait(inode);</span>
<span class="p_add">+</span>
 	/* Preallocate the range including the unaligned edges */
 	if (partial_begin || partial_end) {
 		ret = ext4_alloc_file_blocks(file,
<span class="p_chunk">@@ -4847,7 +4833,7 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 				 round_down(offset, 1 &lt;&lt; blkbits)) &gt;&gt; blkbits,
 				new_size, flags, mode);
 		if (ret)
<span class="p_del">-			goto out_mutex;</span>
<span class="p_add">+			goto out_dio;</span>
 
 	}
 
<span class="p_chunk">@@ -4856,16 +4842,23 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
 			  EXT4_EX_NOCACHE);
 
<span class="p_del">-		/* Now release the pages and zero block aligned part of pages*/</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Prevent page faults from reinstantiating pages we have</span>
<span class="p_add">+		 * released from page cache.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		down_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+		ret = ext4_update_disksize_before_punch(inode, offset, len);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			up_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+			goto out_dio;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* Now release the pages and zero block aligned part of pages */</span>
 		truncate_pagecache_range(inode, start, end - 1);
 		inode-&gt;i_mtime = inode-&gt;i_ctime = ext4_current_time(inode);
 
<span class="p_del">-		/* Wait all existing dio workers, newcomers will block on i_mutex */</span>
<span class="p_del">-		ext4_inode_block_unlocked_dio(inode);</span>
<span class="p_del">-		inode_dio_wait(inode);</span>
<span class="p_del">-</span>
 		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
 					     flags, mode);
<span class="p_add">+		up_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 		if (ret)
 			goto out_dio;
 	}
<span class="p_chunk">@@ -4998,8 +4991,13 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 			goto out;
 	}
 
<span class="p_add">+	/* Wait all existing dio workers, newcomers will block on i_mutex */</span>
<span class="p_add">+	ext4_inode_block_unlocked_dio(inode);</span>
<span class="p_add">+	inode_dio_wait(inode);</span>
<span class="p_add">+</span>
 	ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
 				     flags, mode);
<span class="p_add">+	ext4_inode_resume_unlocked_dio(inode);</span>
 	if (ret)
 		goto out;
 
<span class="p_chunk">@@ -5494,21 +5492,7 @@</span> <span class="p_context"> int ext4_collapse_range(struct inode *inode, loff_t offset, loff_t len)</span>
 			return ret;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Need to round down offset to be aligned with page size boundary</span>
<span class="p_del">-	 * for page size &gt; block size.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ioffset = round_down(offset, PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Write out all dirty pages */</span>
<span class="p_del">-	ret = filemap_write_and_wait_range(inode-&gt;i_mapping, ioffset,</span>
<span class="p_del">-					   LLONG_MAX);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Take mutex lock */</span>
 	mutex_lock(&amp;inode-&gt;i_mutex);
<span class="p_del">-</span>
 	/*
 	 * There is no need to overlap collapse range with EOF, in which case
 	 * it is effectively a truncate operation
<span class="p_chunk">@@ -5524,17 +5508,43 @@</span> <span class="p_context"> int ext4_collapse_range(struct inode *inode, loff_t offset, loff_t len)</span>
 		goto out_mutex;
 	}
 
<span class="p_del">-	truncate_pagecache(inode, ioffset);</span>
<span class="p_del">-</span>
 	/* Wait for existing dio to complete */
 	ext4_inode_block_unlocked_dio(inode);
 	inode_dio_wait(inode);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Prevent page faults from reinstantiating pages we have released from</span>
<span class="p_add">+	 * page cache.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	down_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Need to round down offset to be aligned with page size boundary</span>
<span class="p_add">+	 * for page size &gt; block size.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ioffset = round_down(offset, PAGE_SIZE);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Write tail of the last page before removed range since it will get</span>
<span class="p_add">+	 * removed from the page cache below.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = filemap_write_and_wait_range(inode-&gt;i_mapping, ioffset, offset);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out_mmap;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Write data that will be shifted to preserve them when discarding</span>
<span class="p_add">+	 * page cache below. We are also protected from pages becoming dirty</span>
<span class="p_add">+	 * by i_mmap_sem.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = filemap_write_and_wait_range(inode-&gt;i_mapping, offset + len,</span>
<span class="p_add">+					   LLONG_MAX);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out_mmap;</span>
<span class="p_add">+	truncate_pagecache(inode, ioffset);</span>
<span class="p_add">+</span>
 	credits = ext4_writepage_trans_blocks(inode);
 	handle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
<span class="p_del">-		goto out_dio;</span>
<span class="p_add">+		goto out_mmap;</span>
 	}
 
 	down_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
<span class="p_chunk">@@ -5573,7 +5583,8 @@</span> <span class="p_context"> int ext4_collapse_range(struct inode *inode, loff_t offset, loff_t len)</span>
 
 out_stop:
 	ext4_journal_stop(handle);
<span class="p_del">-out_dio:</span>
<span class="p_add">+out_mmap:</span>
<span class="p_add">+	up_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 	ext4_inode_resume_unlocked_dio(inode);
 out_mutex:
 	mutex_unlock(&amp;inode-&gt;i_mutex);
<span class="p_chunk">@@ -5627,21 +5638,7 @@</span> <span class="p_context"> int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len)</span>
 			return ret;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Need to round down to align start offset to page size boundary</span>
<span class="p_del">-	 * for page size &gt; block size.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ioffset = round_down(offset, PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Write out all dirty pages */</span>
<span class="p_del">-	ret = filemap_write_and_wait_range(inode-&gt;i_mapping, ioffset,</span>
<span class="p_del">-			LLONG_MAX);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Take mutex lock */</span>
 	mutex_lock(&amp;inode-&gt;i_mutex);
<span class="p_del">-</span>
 	/* Currently just for extent based files */
 	if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {
 		ret = -EOPNOTSUPP;
<span class="p_chunk">@@ -5660,17 +5657,32 @@</span> <span class="p_context"> int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len)</span>
 		goto out_mutex;
 	}
 
<span class="p_del">-	truncate_pagecache(inode, ioffset);</span>
<span class="p_del">-</span>
 	/* Wait for existing dio to complete */
 	ext4_inode_block_unlocked_dio(inode);
 	inode_dio_wait(inode);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Prevent page faults from reinstantiating pages we have released from</span>
<span class="p_add">+	 * page cache.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	down_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Need to round down to align start offset to page size boundary</span>
<span class="p_add">+	 * for page size &gt; block size.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ioffset = round_down(offset, PAGE_SIZE);</span>
<span class="p_add">+	/* Write out all dirty pages */</span>
<span class="p_add">+	ret = filemap_write_and_wait_range(inode-&gt;i_mapping, ioffset,</span>
<span class="p_add">+			LLONG_MAX);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out_mmap;</span>
<span class="p_add">+	truncate_pagecache(inode, ioffset);</span>
<span class="p_add">+</span>
 	credits = ext4_writepage_trans_blocks(inode);
 	handle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
<span class="p_del">-		goto out_dio;</span>
<span class="p_add">+		goto out_mmap;</span>
 	}
 
 	/* Expand file to avoid data loss if there is error while shifting */
<span class="p_chunk">@@ -5741,7 +5753,8 @@</span> <span class="p_context"> int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len)</span>
 
 out_stop:
 	ext4_journal_stop(handle);
<span class="p_del">-out_dio:</span>
<span class="p_add">+out_mmap:</span>
<span class="p_add">+	up_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 	ext4_inode_resume_unlocked_dio(inode);
 out_mutex:
 	mutex_unlock(&amp;inode-&gt;i_mutex);
<span class="p_header">diff --git a/fs/ext4/file.c b/fs/ext4/file.c</span>
<span class="p_header">index 113837e7ba98..0d24ebcd7c9e 100644</span>
<span class="p_header">--- a/fs/ext4/file.c</span>
<span class="p_header">+++ b/fs/ext4/file.c</span>
<span class="p_chunk">@@ -209,15 +209,18 @@</span> <span class="p_context"> static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)</span>
 {
 	int result;
 	handle_t *handle = NULL;
<span class="p_del">-	struct super_block *sb = file_inode(vma-&gt;vm_file)-&gt;i_sb;</span>
<span class="p_add">+	struct inode *inode = file_inode(vma-&gt;vm_file);</span>
<span class="p_add">+	struct super_block *sb = inode-&gt;i_sb;</span>
 	bool write = vmf-&gt;flags &amp; FAULT_FLAG_WRITE;
 
 	if (write) {
 		sb_start_pagefault(sb);
 		file_update_time(vma-&gt;vm_file);
<span class="p_add">+		down_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
 						EXT4_DATA_TRANS_BLOCKS(sb));
<span class="p_del">-	}</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		down_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 
 	if (IS_ERR(handle))
 		result = VM_FAULT_SIGBUS;
<span class="p_chunk">@@ -228,8 +231,10 @@</span> <span class="p_context"> static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)</span>
 	if (write) {
 		if (!IS_ERR(handle))
 			ext4_journal_stop(handle);
<span class="p_add">+		up_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 		sb_end_pagefault(sb);
<span class="p_del">-	}</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		up_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 
 	return result;
 }
<span class="p_chunk">@@ -246,10 +251,12 @@</span> <span class="p_context"> static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,</span>
 	if (write) {
 		sb_start_pagefault(sb);
 		file_update_time(vma-&gt;vm_file);
<span class="p_add">+		down_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
 				ext4_chunk_trans_blocks(inode,
 							PMD_SIZE / PAGE_SIZE));
<span class="p_del">-	}</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		down_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 
 	if (IS_ERR(handle))
 		result = VM_FAULT_SIGBUS;
<span class="p_chunk">@@ -260,30 +267,71 @@</span> <span class="p_context"> static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,</span>
 	if (write) {
 		if (!IS_ERR(handle))
 			ext4_journal_stop(handle);
<span class="p_add">+		up_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 		sb_end_pagefault(sb);
<span class="p_del">-	}</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		up_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 
 	return result;
 }
 
 static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
<span class="p_del">-	return dax_mkwrite(vma, vmf, ext4_get_block_dax,</span>
<span class="p_del">-				ext4_end_io_unwritten);</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	struct inode *inode = file_inode(vma-&gt;vm_file);</span>
<span class="p_add">+</span>
<span class="p_add">+	sb_start_pagefault(inode-&gt;i_sb);</span>
<span class="p_add">+	file_update_time(vma-&gt;vm_file);</span>
<span class="p_add">+	down_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+	err = __dax_mkwrite(vma, vmf, ext4_get_block_dax,</span>
<span class="p_add">+			    ext4_end_io_unwritten);</span>
<span class="p_add">+	up_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+	sb_end_pagefault(inode-&gt;i_sb);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Handle write fault for VM_MIXEDMAP mappings. Similarly to ext4_dax_mkwrite()</span>
<span class="p_add">+ * handler we check for races agaist truncate. Note that since we cycle through</span>
<span class="p_add">+ * i_mmap_sem, we are sure that also any hole punching that began before we</span>
<span class="p_add">+ * were called is finished by now and so if it included part of the file we</span>
<span class="p_add">+ * are working on, our pte will get unmapped and the check for pte_same() in</span>
<span class="p_add">+ * wp_pfn_shared() fails. Thus fault gets retried and things work out as</span>
<span class="p_add">+ * desired.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,</span>
<span class="p_add">+				struct vm_fault *vmf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = file_inode(vma-&gt;vm_file);</span>
<span class="p_add">+	struct super_block *sb = inode-&gt;i_sb;</span>
<span class="p_add">+	int ret = VM_FAULT_NOPAGE;</span>
<span class="p_add">+	loff_t size;</span>
<span class="p_add">+</span>
<span class="p_add">+	sb_start_pagefault(sb);</span>
<span class="p_add">+	file_update_time(vma-&gt;vm_file);</span>
<span class="p_add">+	down_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+	size = (i_size_read(inode) + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (vmf-&gt;pgoff &gt;= size)</span>
<span class="p_add">+		ret = VM_FAULT_SIGBUS;</span>
<span class="p_add">+	up_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+	sb_end_pagefault(sb);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static const struct vm_operations_struct ext4_dax_vm_ops = {
 	.fault		= ext4_dax_fault,
 	.pmd_fault	= ext4_dax_pmd_fault,
 	.page_mkwrite	= ext4_dax_mkwrite,
<span class="p_del">-	.pfn_mkwrite	= dax_pfn_mkwrite,</span>
<span class="p_add">+	.pfn_mkwrite	= ext4_dax_pfn_mkwrite,</span>
 };
 #else
 #define ext4_dax_vm_ops	ext4_file_vm_ops
 #endif
 
 static const struct vm_operations_struct ext4_file_vm_ops = {
<span class="p_del">-	.fault		= filemap_fault,</span>
<span class="p_add">+	.fault		= ext4_filemap_fault,</span>
 	.map_pages	= filemap_map_pages,
 	.page_mkwrite   = ext4_page_mkwrite,
 };
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 06bda0361e7c..e31d762eedce 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -3587,6 +3587,35 @@</span> <span class="p_context"> int ext4_can_truncate(struct inode *inode)</span>
 }
 
 /*
<span class="p_add">+ * We have to make sure i_disksize gets properly updated before we truncate</span>
<span class="p_add">+ * page cache due to hole punching or zero range. Otherwise i_disksize update</span>
<span class="p_add">+ * can get lost as it may have been postponed to submission of writeback but</span>
<span class="p_add">+ * that will never happen after we truncate page cache.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int ext4_update_disksize_before_punch(struct inode *inode, loff_t offset,</span>
<span class="p_add">+				      loff_t len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	handle_t *handle;</span>
<span class="p_add">+	loff_t size = i_size_read(inode);</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(!mutex_is_locked(&amp;inode-&gt;i_mutex));</span>
<span class="p_add">+	if (offset &gt; size || offset + len &lt; size)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (EXT4_I(inode)-&gt;i_disksize &gt;= size)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	handle = ext4_journal_start(inode, EXT4_HT_MISC, 1);</span>
<span class="p_add">+	if (IS_ERR(handle))</span>
<span class="p_add">+		return PTR_ERR(handle);</span>
<span class="p_add">+	ext4_update_i_disksize(inode, size);</span>
<span class="p_add">+	ext4_mark_inode_dirty(handle, inode);</span>
<span class="p_add">+	ext4_journal_stop(handle);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * ext4_punch_hole: punches a hole in a file by releaseing the blocks
  * associated with the given offset and length
  *
<span class="p_chunk">@@ -3651,17 +3680,26 @@</span> <span class="p_context"> int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)</span>
 
 	}
 
<span class="p_add">+	/* Wait all existing dio workers, newcomers will block on i_mutex */</span>
<span class="p_add">+	ext4_inode_block_unlocked_dio(inode);</span>
<span class="p_add">+	inode_dio_wait(inode);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Prevent page faults from reinstantiating pages we have released from</span>
<span class="p_add">+	 * page cache.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	down_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 	first_block_offset = round_up(offset, sb-&gt;s_blocksize);
 	last_block_offset = round_down((offset + length), sb-&gt;s_blocksize) - 1;
 
 	/* Now release the pages and zero block aligned part of pages*/
<span class="p_del">-	if (last_block_offset &gt; first_block_offset)</span>
<span class="p_add">+	if (last_block_offset &gt; first_block_offset) {</span>
<span class="p_add">+		ret = ext4_update_disksize_before_punch(inode, offset, length);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_dio;</span>
 		truncate_pagecache_range(inode, first_block_offset,
 					 last_block_offset);
<span class="p_del">-</span>
<span class="p_del">-	/* Wait all existing dio workers, newcomers will block on i_mutex */</span>
<span class="p_del">-	ext4_inode_block_unlocked_dio(inode);</span>
<span class="p_del">-	inode_dio_wait(inode);</span>
<span class="p_add">+	}</span>
 
 	if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))
 		credits = ext4_writepage_trans_blocks(inode);
<span class="p_chunk">@@ -3708,16 +3746,12 @@</span> <span class="p_context"> int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)</span>
 	if (IS_SYNC(inode))
 		ext4_handle_sync(handle);
 
<span class="p_del">-	/* Now release the pages again to reduce race window */</span>
<span class="p_del">-	if (last_block_offset &gt; first_block_offset)</span>
<span class="p_del">-		truncate_pagecache_range(inode, first_block_offset,</span>
<span class="p_del">-					 last_block_offset);</span>
<span class="p_del">-</span>
 	inode-&gt;i_mtime = inode-&gt;i_ctime = ext4_current_time(inode);
 	ext4_mark_inode_dirty(handle, inode);
 out_stop:
 	ext4_journal_stop(handle);
 out_dio:
<span class="p_add">+	up_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 	ext4_inode_resume_unlocked_dio(inode);
 out_mutex:
 	mutex_unlock(&amp;inode-&gt;i_mutex);
<span class="p_chunk">@@ -4851,6 +4885,7 @@</span> <span class="p_context"> int ext4_setattr(struct dentry *dentry, struct iattr *attr)</span>
 			} else
 				ext4_wait_for_tail_page_commit(inode);
 		}
<span class="p_add">+		down_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 		/*
 		 * Truncate pagecache after we&#39;ve waited for commit
 		 * in data=journal mode to make pages freeable.
<span class="p_chunk">@@ -4858,6 +4893,7 @@</span> <span class="p_context"> int ext4_setattr(struct dentry *dentry, struct iattr *attr)</span>
 		truncate_pagecache(inode, inode-&gt;i_size);
 		if (shrink)
 			ext4_truncate(inode);
<span class="p_add">+		up_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 	}
 
 	if (!rc) {
<span class="p_chunk">@@ -5109,6 +5145,8 @@</span> <span class="p_context"> int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)</span>
 	might_sleep();
 	trace_ext4_mark_inode_dirty(inode, _RET_IP_);
 	err = ext4_reserve_inode_write(handle, inode, &amp;iloc);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 	if (ext4_handle_valid(handle) &amp;&amp;
 	    EXT4_I(inode)-&gt;i_extra_isize &lt; sbi-&gt;s_want_extra_isize &amp;&amp;
 	    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {
<span class="p_chunk">@@ -5139,9 +5177,7 @@</span> <span class="p_context"> int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)</span>
 			}
 		}
 	}
<span class="p_del">-	if (!err)</span>
<span class="p_del">-		err = ext4_mark_iloc_dirty(handle, inode, &amp;iloc);</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	return ext4_mark_iloc_dirty(handle, inode, &amp;iloc);</span>
 }
 
 /*
<span class="p_chunk">@@ -5306,6 +5342,8 @@</span> <span class="p_context"> int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)</span>
 
 	sb_start_pagefault(inode-&gt;i_sb);
 	file_update_time(vma-&gt;vm_file);
<span class="p_add">+</span>
<span class="p_add">+	down_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 	/* Delalloc case is easy... */
 	if (test_opt(inode-&gt;i_sb, DELALLOC) &amp;&amp;
 	    !ext4_should_journal_data(inode) &amp;&amp;
<span class="p_chunk">@@ -5375,6 +5413,19 @@</span> <span class="p_context"> retry_alloc:</span>
 out_ret:
 	ret = block_page_mkwrite_return(ret);
 out:
<span class="p_add">+	up_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 	sb_end_pagefault(inode-&gt;i_sb);
 	return ret;
 }
<span class="p_add">+</span>
<span class="p_add">+int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = file_inode(vma-&gt;vm_file);</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	down_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+	err = filemap_fault(vma, vmf);</span>
<span class="p_add">+	up_read(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index ba1cf0bf2f81..852c26806af2 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -958,6 +958,7 @@</span> <span class="p_context"> static void init_once(void *foo)</span>
 	INIT_LIST_HEAD(&amp;ei-&gt;i_orphan);
 	init_rwsem(&amp;ei-&gt;xattr_sem);
 	init_rwsem(&amp;ei-&gt;i_data_sem);
<span class="p_add">+	init_rwsem(&amp;ei-&gt;i_mmap_sem);</span>
 	inode_init_once(&amp;ei-&gt;vfs_inode);
 }
 
<span class="p_header">diff --git a/fs/ext4/truncate.h b/fs/ext4/truncate.h</span>
<span class="p_header">index 011ba6670d99..c70d06a383e2 100644</span>
<span class="p_header">--- a/fs/ext4/truncate.h</span>
<span class="p_header">+++ b/fs/ext4/truncate.h</span>
<span class="p_chunk">@@ -10,8 +10,10 @@</span> <span class="p_context"></span>
  */
 static inline void ext4_truncate_failed_write(struct inode *inode)
 {
<span class="p_add">+	down_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 	truncate_inode_pages(inode-&gt;i_mapping, inode-&gt;i_size);
 	ext4_truncate(inode);
<span class="p_add">+	up_write(&amp;EXT4_I(inode)-&gt;i_mmap_sem);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index 09cd3edde08a..f6478301db00 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -1435,6 +1435,32 @@</span> <span class="p_context"> static struct page *can_gather_numa_stats(pte_t pte, struct vm_area_struct *vma,</span>
 	return page;
 }
 
<span class="p_add">+#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="p_add">+static struct page *can_gather_numa_stats_pmd(pmd_t pmd,</span>
<span class="p_add">+					      struct vm_area_struct *vma,</span>
<span class="p_add">+					      unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct page *page;</span>
<span class="p_add">+	int nid;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pmd_present(pmd))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	page = vm_normal_page_pmd(vma, addr, pmd);</span>
<span class="p_add">+	if (!page)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PageReserved(page))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	nid = page_to_nid(page);</span>
<span class="p_add">+	if (!node_isset(nid, node_states[N_MEMORY]))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return page;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static int gather_pte_stats(pmd_t *pmd, unsigned long addr,
 		unsigned long end, struct mm_walk *walk)
 {
<span class="p_chunk">@@ -1444,13 +1470,13 @@</span> <span class="p_context"> static int gather_pte_stats(pmd_t *pmd, unsigned long addr,</span>
 	pte_t *orig_pte;
 	pte_t *pte;
 
<span class="p_add">+#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
 	if (pmd_trans_huge_lock(pmd, vma, &amp;ptl) == 1) {
<span class="p_del">-		pte_t huge_pte = *(pte_t *)pmd;</span>
 		struct page *page;
 
<span class="p_del">-		page = can_gather_numa_stats(huge_pte, vma, addr);</span>
<span class="p_add">+		page = can_gather_numa_stats_pmd(*pmd, vma, addr);</span>
 		if (page)
<span class="p_del">-			gather_stats(page, md, pte_dirty(huge_pte),</span>
<span class="p_add">+			gather_stats(page, md, pmd_dirty(*pmd),</span>
 				     HPAGE_PMD_SIZE/PAGE_SIZE);
 		spin_unlock(ptl);
 		return 0;
<span class="p_chunk">@@ -1458,6 +1484,7 @@</span> <span class="p_context"> static int gather_pte_stats(pmd_t *pmd, unsigned long addr,</span>
 
 	if (pmd_trans_unstable(pmd))
 		return 0;
<span class="p_add">+#endif</span>
 	orig_pte = pte = pte_offset_map_lock(walk-&gt;mm, pmd, addr, &amp;ptl);
 	do {
 		struct page *page = can_gather_numa_stats(*pte, vma, addr);
<span class="p_header">diff --git a/include/asm-generic/futex.h b/include/asm-generic/futex.h</span>
<span class="p_header">index e56272c919b5..bf2d34c9d804 100644</span>
<span class="p_header">--- a/include/asm-generic/futex.h</span>
<span class="p_header">+++ b/include/asm-generic/futex.h</span>
<span class="p_chunk">@@ -108,11 +108,15 @@</span> <span class="p_context"> futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,</span>
 	u32 val;
 
 	preempt_disable();
<span class="p_del">-	if (unlikely(get_user(val, uaddr) != 0))</span>
<span class="p_add">+	if (unlikely(get_user(val, uaddr) != 0)) {</span>
<span class="p_add">+		preempt_enable();</span>
 		return -EFAULT;
<span class="p_add">+	}</span>
 
<span class="p_del">-	if (val == oldval &amp;&amp; unlikely(put_user(newval, uaddr) != 0))</span>
<span class="p_add">+	if (val == oldval &amp;&amp; unlikely(put_user(newval, uaddr) != 0)) {</span>
<span class="p_add">+		preempt_enable();</span>
 		return -EFAULT;
<span class="p_add">+	}</span>
 
 	*uval = val;
 	preempt_enable();
<span class="p_header">diff --git a/include/drm/drm_cache.h b/include/drm/drm_cache.h</span>
<span class="p_header">index 461a0558bca4..cebecff536a3 100644</span>
<span class="p_header">--- a/include/drm/drm_cache.h</span>
<span class="p_header">+++ b/include/drm/drm_cache.h</span>
<span class="p_chunk">@@ -39,6 +39,8 @@</span> <span class="p_context"> static inline bool drm_arch_can_wc_memory(void)</span>
 {
 #if defined(CONFIG_PPC) &amp;&amp; !defined(CONFIG_NOT_COHERENT_CACHE)
 	return false;
<span class="p_add">+#elif defined(CONFIG_MIPS) &amp;&amp; defined(CONFIG_CPU_LOONGSON3)</span>
<span class="p_add">+	return false;</span>
 #else
 	return true;
 #endif
<span class="p_header">diff --git a/include/linux/cgroup-defs.h b/include/linux/cgroup-defs.h</span>
<span class="p_header">index a7c7f74808a4..8da263299754 100644</span>
<span class="p_header">--- a/include/linux/cgroup-defs.h</span>
<span class="p_header">+++ b/include/linux/cgroup-defs.h</span>
<span class="p_chunk">@@ -434,6 +434,7 @@</span> <span class="p_context"> struct cgroup_subsys {</span>
 	int (*can_attach)(struct cgroup_taskset *tset);
 	void (*cancel_attach)(struct cgroup_taskset *tset);
 	void (*attach)(struct cgroup_taskset *tset);
<span class="p_add">+	void (*post_attach)(void);</span>
 	int (*can_fork)(struct task_struct *task, void **priv_p);
 	void (*cancel_fork)(struct task_struct *task, void *priv);
 	void (*fork)(struct task_struct *task, void *priv);
<span class="p_header">diff --git a/include/linux/cpuset.h b/include/linux/cpuset.h</span>
<span class="p_header">index fea160ee5803..85a868ccb493 100644</span>
<span class="p_header">--- a/include/linux/cpuset.h</span>
<span class="p_header">+++ b/include/linux/cpuset.h</span>
<span class="p_chunk">@@ -137,8 +137,6 @@</span> <span class="p_context"> static inline void set_mems_allowed(nodemask_t nodemask)</span>
 	task_unlock(current);
 }
 
<span class="p_del">-extern void cpuset_post_attach_flush(void);</span>
<span class="p_del">-</span>
 #else /* !CONFIG_CPUSETS */
 
 static inline bool cpusets_enabled(void) { return false; }
<span class="p_chunk">@@ -245,10 +243,6 @@</span> <span class="p_context"> static inline bool read_mems_allowed_retry(unsigned int seq)</span>
 	return false;
 }
 
<span class="p_del">-static inline void cpuset_post_attach_flush(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #endif /* !CONFIG_CPUSETS */
 
 #endif /* _LINUX_CPUSET_H */
<span class="p_header">diff --git a/include/linux/mlx5/device.h b/include/linux/mlx5/device.h</span>
<span class="p_header">index 0b473cbfa7ef..a91b67b18a73 100644</span>
<span class="p_header">--- a/include/linux/mlx5/device.h</span>
<span class="p_header">+++ b/include/linux/mlx5/device.h</span>
<span class="p_chunk">@@ -334,6 +334,17 @@</span> <span class="p_context"> enum {</span>
 	MLX5_CAP_OFF_CMDIF_CSUM		= 46,
 };
 
<span class="p_add">+enum {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Max wqe size for rdma read is 512 bytes, so this</span>
<span class="p_add">+	 * limits our max_sge_rd as the wqe needs to fit:</span>
<span class="p_add">+	 * - ctrl segment (16 bytes)</span>
<span class="p_add">+	 * - rdma segment (16 bytes)</span>
<span class="p_add">+	 * - scatter elements (16 bytes each)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	MLX5_MAX_SGE_RD	= (512 - 16 - 16) / 16</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct mlx5_inbox_hdr {
 	__be16		opcode;
 	u8		rsvd[4];
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 00bad7793788..fb8b20e5d021 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1084,6 +1084,8 @@</span> <span class="p_context"> struct zap_details {</span>
 
 struct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,
 		pte_t pte);
<span class="p_add">+struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,</span>
<span class="p_add">+				pmd_t pmd);</span>
 
 int zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,
 		unsigned long size);
<span class="p_header">diff --git a/include/media/videobuf2-core.h b/include/media/videobuf2-core.h</span>
<span class="p_header">index 647ebfe5174f..d4227a8a2a23 100644</span>
<span class="p_header">--- a/include/media/videobuf2-core.h</span>
<span class="p_header">+++ b/include/media/videobuf2-core.h</span>
<span class="p_chunk">@@ -363,6 +363,7 @@</span> <span class="p_context"> struct vb2_ops {</span>
 };
 
 struct vb2_buf_ops {
<span class="p_add">+	int (*verify_planes_array)(struct vb2_buffer *vb, const void *pb);</span>
 	int (*fill_user_buffer)(struct vb2_buffer *vb, void *pb);
 	int (*fill_vb2_buffer)(struct vb2_buffer *vb, const void *pb,
 				struct vb2_plane *planes);
<span class="p_header">diff --git a/include/rdma/ib.h b/include/rdma/ib.h</span>
<span class="p_header">index cf8f9e700e48..a6b93706b0fc 100644</span>
<span class="p_header">--- a/include/rdma/ib.h</span>
<span class="p_header">+++ b/include/rdma/ib.h</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"></span>
 #define _RDMA_IB_H
 
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
 
 struct ib_addr {
 	union {
<span class="p_chunk">@@ -86,4 +87,19 @@</span> <span class="p_context"> struct sockaddr_ib {</span>
 	__u64			sib_scope_id;
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The IB interfaces that use write() as bi-directional ioctl() are</span>
<span class="p_add">+ * fundamentally unsafe, since there are lots of ways to trigger &quot;write()&quot;</span>
<span class="p_add">+ * calls from various contexts with elevated privileges. That includes the</span>
<span class="p_add">+ * traditional suid executable error message writes, but also various kernel</span>
<span class="p_add">+ * interfaces that can write to file descriptors.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function provides protection for the legacy API by restricting the</span>
<span class="p_add">+ * calling context.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool ib_safe_file_access(struct file *filp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return filp-&gt;f_cred == current_cred() &amp;&amp; segment_eq(get_fs(), USER_DS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* _RDMA_IB_H */
<span class="p_header">diff --git a/include/uapi/linux/v4l2-dv-timings.h b/include/uapi/linux/v4l2-dv-timings.h</span>
<span class="p_header">index c039f1d68a09..086168e18ca8 100644</span>
<span class="p_header">--- a/include/uapi/linux/v4l2-dv-timings.h</span>
<span class="p_header">+++ b/include/uapi/linux/v4l2-dv-timings.h</span>
<span class="p_chunk">@@ -183,7 +183,8 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_3840X2160P24 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 1276, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -191,14 +192,16 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_3840X2160P25 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 1056, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_IS_CE_VIDEO) \
 }
 
 #define V4L2_DV_BT_CEA_3840X2160P30 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 176, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -206,14 +209,16 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_3840X2160P50 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 1056, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_IS_CE_VIDEO) \
 }
 
 #define V4L2_DV_BT_CEA_3840X2160P60 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 176, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -221,7 +226,8 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_4096X2160P24 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 1020, 88, 296, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -229,14 +235,16 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_4096X2160P25 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 968, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_IS_CE_VIDEO) \
 }
 
 #define V4L2_DV_BT_CEA_4096X2160P30 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		297000000, 88, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_chunk">@@ -244,14 +252,16 @@</span> <span class="p_context"></span>
 
 #define V4L2_DV_BT_CEA_4096X2160P50 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 968, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, V4L2_DV_FL_IS_CE_VIDEO) \
 }
 
 #define V4L2_DV_BT_CEA_4096X2160P60 { \
 	.type = V4L2_DV_BT_656_1120, \
<span class="p_del">-	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, V4L2_DV_HSYNC_POS_POL, \</span>
<span class="p_add">+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \</span>
<span class="p_add">+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \</span>
 		594000000, 88, 88, 128, 8, 10, 72, 0, 0, 0, \
 		V4L2_DV_BT_STD_CEA861, \
 		V4L2_DV_FL_CAN_REDUCE_FPS | V4L2_DV_FL_IS_CE_VIDEO) \
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index dc94f8beb097..1c9d701f7a72 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -2721,9 +2721,10 @@</span> <span class="p_context"> static ssize_t __cgroup_procs_write(struct kernfs_open_file *of, char *buf,</span>
 				    size_t nbytes, loff_t off, bool threadgroup)
 {
 	struct task_struct *tsk;
<span class="p_add">+	struct cgroup_subsys *ss;</span>
 	struct cgroup *cgrp;
 	pid_t pid;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ssid, ret;</span>
 
 	if (kstrtoint(strstrip(buf), 0, &amp;pid) || pid &lt; 0)
 		return -EINVAL;
<span class="p_chunk">@@ -2771,8 +2772,10 @@</span> <span class="p_context"> out_unlock_rcu:</span>
 	rcu_read_unlock();
 out_unlock_threadgroup:
 	percpu_up_write(&amp;cgroup_threadgroup_rwsem);
<span class="p_add">+	for_each_subsys(ss, ssid)</span>
<span class="p_add">+		if (ss-&gt;post_attach)</span>
<span class="p_add">+			ss-&gt;post_attach();</span>
 	cgroup_kn_unlock(of-&gt;kn);
<span class="p_del">-	cpuset_post_attach_flush();</span>
 	return ret ?: nbytes;
 }
 
<span class="p_chunk">@@ -4689,14 +4692,15 @@</span> <span class="p_context"> static void css_free_work_fn(struct work_struct *work)</span>
 
 	if (ss) {
 		/* css free path */
<span class="p_add">+		struct cgroup_subsys_state *parent = css-&gt;parent;</span>
 		int id = css-&gt;id;
 
<span class="p_del">-		if (css-&gt;parent)</span>
<span class="p_del">-			css_put(css-&gt;parent);</span>
<span class="p_del">-</span>
 		ss-&gt;css_free(css);
 		cgroup_idr_remove(&amp;ss-&gt;css_idr, id);
 		cgroup_put(cgrp);
<span class="p_add">+</span>
<span class="p_add">+		if (parent)</span>
<span class="p_add">+			css_put(parent);</span>
 	} else {
 		/* cgroup free path */
 		atomic_dec(&amp;cgrp-&gt;root-&gt;nr_cgrps);
<span class="p_header">diff --git a/kernel/cpuset.c b/kernel/cpuset.c</span>
<span class="p_header">index 2ade632197d5..11eaf14b52c2 100644</span>
<span class="p_header">--- a/kernel/cpuset.c</span>
<span class="p_header">+++ b/kernel/cpuset.c</span>
<span class="p_chunk">@@ -57,7 +57,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/uaccess.h&gt;
 #include &lt;linux/atomic.h&gt;
 #include &lt;linux/mutex.h&gt;
<span class="p_del">-#include &lt;linux/workqueue.h&gt;</span>
 #include &lt;linux/cgroup.h&gt;
 #include &lt;linux/wait.h&gt;
 
<span class="p_chunk">@@ -1015,7 +1014,7 @@</span> <span class="p_context"> static void cpuset_migrate_mm(struct mm_struct *mm, const nodemask_t *from,</span>
 	}
 }
 
<span class="p_del">-void cpuset_post_attach_flush(void)</span>
<span class="p_add">+static void cpuset_post_attach(void)</span>
 {
 	flush_workqueue(cpuset_migrate_mm_wq);
 }
<span class="p_chunk">@@ -2083,6 +2082,7 @@</span> <span class="p_context"> struct cgroup_subsys cpuset_cgrp_subsys = {</span>
 	.can_attach	= cpuset_can_attach,
 	.cancel_attach	= cpuset_cancel_attach,
 	.attach		= cpuset_attach,
<span class="p_add">+	.post_attach	= cpuset_post_attach,</span>
 	.bind		= cpuset_bind,
 	.legacy_cftypes	= files,
 	.early_init	= 1,
<span class="p_header">diff --git a/kernel/futex.c b/kernel/futex.c</span>
<span class="p_header">index 461c72b2dac2..9d8163afd87c 100644</span>
<span class="p_header">--- a/kernel/futex.c</span>
<span class="p_header">+++ b/kernel/futex.c</span>
<span class="p_chunk">@@ -1244,10 +1244,20 @@</span> <span class="p_context"> static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this,</span>
 	if (unlikely(should_fail_futex(true)))
 		ret = -EFAULT;
 
<span class="p_del">-	if (cmpxchg_futex_value_locked(&amp;curval, uaddr, uval, newval))</span>
<span class="p_add">+	if (cmpxchg_futex_value_locked(&amp;curval, uaddr, uval, newval)) {</span>
 		ret = -EFAULT;
<span class="p_del">-	else if (curval != uval)</span>
<span class="p_del">-		ret = -EINVAL;</span>
<span class="p_add">+	} else if (curval != uval) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If a unconditional UNLOCK_PI operation (user space did not</span>
<span class="p_add">+		 * try the TID-&gt;0 transition) raced with a waiter setting the</span>
<span class="p_add">+		 * FUTEX_WAITERS flag between get_user() and locking the hash</span>
<span class="p_add">+		 * bucket lock, retry the operation.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((FUTEX_TID_MASK &amp; curval) == uval)</span>
<span class="p_add">+			ret = -EAGAIN;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+	}</span>
 	if (ret) {
 		raw_spin_unlock(&amp;pi_state-&gt;pi_mutex.wait_lock);
 		return ret;
<span class="p_chunk">@@ -1474,8 +1484,8 @@</span> <span class="p_context"> void requeue_futex(struct futex_q *q, struct futex_hash_bucket *hb1,</span>
 	if (likely(&amp;hb1-&gt;chain != &amp;hb2-&gt;chain)) {
 		plist_del(&amp;q-&gt;list, &amp;hb1-&gt;chain);
 		hb_waiters_dec(hb1);
<span class="p_del">-		plist_add(&amp;q-&gt;list, &amp;hb2-&gt;chain);</span>
 		hb_waiters_inc(hb2);
<span class="p_add">+		plist_add(&amp;q-&gt;list, &amp;hb2-&gt;chain);</span>
 		q-&gt;lock_ptr = &amp;hb2-&gt;lock;
 	}
 	get_futex_key_refs(key2);
<span class="p_chunk">@@ -2538,6 +2548,15 @@</span> <span class="p_context"> retry:</span>
 		if (ret == -EFAULT)
 			goto pi_faulted;
 		/*
<span class="p_add">+		 * A unconditional UNLOCK_PI op raced against a waiter</span>
<span class="p_add">+		 * setting the FUTEX_WAITERS bit. Try again.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (ret == -EAGAIN) {</span>
<span class="p_add">+			spin_unlock(&amp;hb-&gt;lock);</span>
<span class="p_add">+			put_futex_key(&amp;key);</span>
<span class="p_add">+			goto retry;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/*</span>
 		 * wake_futex_pi has detected invalid state. Tell user
 		 * space.
 		 */
<span class="p_header">diff --git a/kernel/locking/mcs_spinlock.h b/kernel/locking/mcs_spinlock.h</span>
<span class="p_header">index 5b9102a47ea5..c835270f0c2f 100644</span>
<span class="p_header">--- a/kernel/locking/mcs_spinlock.h</span>
<span class="p_header">+++ b/kernel/locking/mcs_spinlock.h</span>
<span class="p_chunk">@@ -67,7 +67,13 @@</span> <span class="p_context"> void mcs_spin_lock(struct mcs_spinlock **lock, struct mcs_spinlock *node)</span>
 	node-&gt;locked = 0;
 	node-&gt;next   = NULL;
 
<span class="p_del">-	prev = xchg_acquire(lock, node);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We rely on the full barrier with global transitivity implied by the</span>
<span class="p_add">+	 * below xchg() to order the initialization stores above against any</span>
<span class="p_add">+	 * observation of @node. And to provide the ACQUIRE ordering associated</span>
<span class="p_add">+	 * with a LOCK primitive.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	prev = xchg(lock, node);</span>
 	if (likely(prev == NULL)) {
 		/*
 		 * Lock acquired, don&#39;t need to set node-&gt;locked to 1. Threads
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 70e5e09341f1..55bebf924946 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -7693,7 +7693,7 @@</span> <span class="p_context"> void set_curr_task(int cpu, struct task_struct *p)</span>
 /* task_group_lock serializes the addition/removal of task groups */
 static DEFINE_SPINLOCK(task_group_lock);
 
<span class="p_del">-static void free_sched_group(struct task_group *tg)</span>
<span class="p_add">+static void sched_free_group(struct task_group *tg)</span>
 {
 	free_fair_sched_group(tg);
 	free_rt_sched_group(tg);
<span class="p_chunk">@@ -7719,7 +7719,7 @@</span> <span class="p_context"> struct task_group *sched_create_group(struct task_group *parent)</span>
 	return tg;
 
 err:
<span class="p_del">-	free_sched_group(tg);</span>
<span class="p_add">+	sched_free_group(tg);</span>
 	return ERR_PTR(-ENOMEM);
 }
 
<span class="p_chunk">@@ -7739,17 +7739,16 @@</span> <span class="p_context"> void sched_online_group(struct task_group *tg, struct task_group *parent)</span>
 }
 
 /* rcu callback to free various structures associated with a task group */
<span class="p_del">-static void free_sched_group_rcu(struct rcu_head *rhp)</span>
<span class="p_add">+static void sched_free_group_rcu(struct rcu_head *rhp)</span>
 {
 	/* now it should be safe to free those cfs_rqs */
<span class="p_del">-	free_sched_group(container_of(rhp, struct task_group, rcu));</span>
<span class="p_add">+	sched_free_group(container_of(rhp, struct task_group, rcu));</span>
 }
 
<span class="p_del">-/* Destroy runqueue etc associated with a task group */</span>
 void sched_destroy_group(struct task_group *tg)
 {
 	/* wait for possible concurrent references to cfs_rqs complete */
<span class="p_del">-	call_rcu(&amp;tg-&gt;rcu, free_sched_group_rcu);</span>
<span class="p_add">+	call_rcu(&amp;tg-&gt;rcu, sched_free_group_rcu);</span>
 }
 
 void sched_offline_group(struct task_group *tg)
<span class="p_chunk">@@ -8210,31 +8209,26 @@</span> <span class="p_context"> cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)</span>
 	if (IS_ERR(tg))
 		return ERR_PTR(-ENOMEM);
 
<span class="p_add">+	sched_online_group(tg, parent);</span>
<span class="p_add">+</span>
 	return &amp;tg-&gt;css;
 }
 
<span class="p_del">-static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)</span>
<span class="p_add">+static void cpu_cgroup_css_released(struct cgroup_subsys_state *css)</span>
 {
 	struct task_group *tg = css_tg(css);
<span class="p_del">-	struct task_group *parent = css_tg(css-&gt;parent);</span>
 
<span class="p_del">-	if (parent)</span>
<span class="p_del">-		sched_online_group(tg, parent);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	sched_offline_group(tg);</span>
 }
 
 static void cpu_cgroup_css_free(struct cgroup_subsys_state *css)
 {
 	struct task_group *tg = css_tg(css);
 
<span class="p_del">-	sched_destroy_group(tg);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void cpu_cgroup_css_offline(struct cgroup_subsys_state *css)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct task_group *tg = css_tg(css);</span>
<span class="p_del">-</span>
<span class="p_del">-	sched_offline_group(tg);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Relies on the RCU grace period between css_released() and this.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sched_free_group(tg);</span>
 }
 
 static void cpu_cgroup_fork(struct task_struct *task, void *private)
<span class="p_chunk">@@ -8594,9 +8588,8 @@</span> <span class="p_context"> static struct cftype cpu_files[] = {</span>
 
 struct cgroup_subsys cpu_cgrp_subsys = {
 	.css_alloc	= cpu_cgroup_css_alloc,
<span class="p_add">+	.css_released	= cpu_cgroup_css_released,</span>
 	.css_free	= cpu_cgroup_css_free,
<span class="p_del">-	.css_online	= cpu_cgroup_css_online,</span>
<span class="p_del">-	.css_offline	= cpu_cgroup_css_offline,</span>
 	.fork		= cpu_cgroup_fork,
 	.can_attach	= cpu_cgroup_can_attach,
 	.attach		= cpu_cgroup_attach,
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index 450c21fd0e6e..0ec05948a97b 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -649,6 +649,35 @@</span> <span class="p_context"> static void set_work_pool_and_clear_pending(struct work_struct *work,</span>
 	 */
 	smp_wmb();
 	set_work_data(work, (unsigned long)pool_id &lt;&lt; WORK_OFFQ_POOL_SHIFT, 0);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The following mb guarantees that previous clear of a PENDING bit</span>
<span class="p_add">+	 * will not be reordered with any speculative LOADS or STORES from</span>
<span class="p_add">+	 * work-&gt;current_func, which is executed afterwards.  This possible</span>
<span class="p_add">+	 * reordering can lead to a missed execution on attempt to qeueue</span>
<span class="p_add">+	 * the same @work.  E.g. consider this case:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   CPU#0                         CPU#1</span>
<span class="p_add">+	 *   ----------------------------  --------------------------------</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * 1  STORE event_indicated</span>
<span class="p_add">+	 * 2  queue_work_on() {</span>
<span class="p_add">+	 * 3    test_and_set_bit(PENDING)</span>
<span class="p_add">+	 * 4 }                             set_..._and_clear_pending() {</span>
<span class="p_add">+	 * 5                                 set_work_data() # clear bit</span>
<span class="p_add">+	 * 6                                 smp_mb()</span>
<span class="p_add">+	 * 7                               work-&gt;current_func() {</span>
<span class="p_add">+	 * 8				      LOAD event_indicated</span>
<span class="p_add">+	 *				   }</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Without an explicit full barrier speculative LOAD on line 8 can</span>
<span class="p_add">+	 * be executed before CPU#0 does STORE on line 1.  If that happens,</span>
<span class="p_add">+	 * CPU#0 observes the PENDING bit is still set and new execution of</span>
<span class="p_add">+	 * a @work is not queued in a hope, that CPU#1 will eventually</span>
<span class="p_add">+	 * finish the queued @work.  Meanwhile CPU#1 does not see</span>
<span class="p_add">+	 * event_indicated is set, because speculative LOAD was executed</span>
<span class="p_add">+	 * before actual STORE.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
 }
 
 static void clear_work_data(struct work_struct *work)
<span class="p_header">diff --git a/lib/assoc_array.c b/lib/assoc_array.c</span>
<span class="p_header">index 03dd576e6773..59fd7c0b119c 100644</span>
<span class="p_header">--- a/lib/assoc_array.c</span>
<span class="p_header">+++ b/lib/assoc_array.c</span>
<span class="p_chunk">@@ -524,7 +524,9 @@</span> <span class="p_context"> static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,</span>
 			free_slot = i;
 			continue;
 		}
<span class="p_del">-		if (ops-&gt;compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) {</span>
<span class="p_add">+		if (assoc_array_ptr_is_leaf(ptr) &amp;&amp;</span>
<span class="p_add">+		    ops-&gt;compare_object(assoc_array_ptr_to_leaf(ptr),</span>
<span class="p_add">+					index_key)) {</span>
 			pr_devel(&quot;replace in slot %d\n&quot;, i);
 			edit-&gt;leaf_p = &amp;node-&gt;slots[i];
 			edit-&gt;dead_leaf = node-&gt;slots[i];
<span class="p_header">diff --git a/lib/lz4/lz4defs.h b/lib/lz4/lz4defs.h</span>
<span class="p_header">index abcecdc2d0f2..0710a62ad2f6 100644</span>
<span class="p_header">--- a/lib/lz4/lz4defs.h</span>
<span class="p_header">+++ b/lib/lz4/lz4defs.h</span>
<span class="p_chunk">@@ -11,8 +11,7 @@</span> <span class="p_context"></span>
 /*
  * Detects 64 bits mode
  */
<span class="p_del">-#if (defined(__x86_64__) || defined(__x86_64) || defined(__amd64__) \</span>
<span class="p_del">-	|| defined(__ppc64__) || defined(__LP64__))</span>
<span class="p_add">+#if defined(CONFIG_64BIT)</span>
 #define LZ4_ARCH64 1
 #else
 #define LZ4_ARCH64 0
<span class="p_chunk">@@ -35,6 +34,10 @@</span> <span class="p_context"> typedef struct _U64_S { u64 v; } U64_S;</span>
 
 #define PUT4(s, d) (A32(d) = A32(s))
 #define PUT8(s, d) (A64(d) = A64(s))
<span class="p_add">+</span>
<span class="p_add">+#define LZ4_READ_LITTLEENDIAN_16(d, s, p)	\</span>
<span class="p_add">+	(d = s - A16(p))</span>
<span class="p_add">+</span>
 #define LZ4_WRITE_LITTLEENDIAN_16(p, v)	\
 	do {	\
 		A16(p) = v; \
<span class="p_chunk">@@ -51,10 +54,13 @@</span> <span class="p_context"> typedef struct _U64_S { u64 v; } U64_S;</span>
 #define PUT8(s, d) \
 	put_unaligned(get_unaligned((const u64 *) s), (u64 *) d)
 
<span class="p_del">-#define LZ4_WRITE_LITTLEENDIAN_16(p, v)	\</span>
<span class="p_del">-	do {	\</span>
<span class="p_del">-		put_unaligned(v, (u16 *)(p)); \</span>
<span class="p_del">-		p += 2; \</span>
<span class="p_add">+#define LZ4_READ_LITTLEENDIAN_16(d, s, p)	\</span>
<span class="p_add">+	(d = s - get_unaligned_le16(p))</span>
<span class="p_add">+</span>
<span class="p_add">+#define LZ4_WRITE_LITTLEENDIAN_16(p, v)			\</span>
<span class="p_add">+	do {						\</span>
<span class="p_add">+		put_unaligned_le16(v, (u16 *)(p));	\</span>
<span class="p_add">+		p += 2;					\</span>
 	} while (0)
 #endif
 
<span class="p_chunk">@@ -140,9 +146,6 @@</span> <span class="p_context"> typedef struct _U64_S { u64 v; } U64_S;</span>
 
 #endif
 
<span class="p_del">-#define LZ4_READ_LITTLEENDIAN_16(d, s, p) \</span>
<span class="p_del">-	(d = s - get_unaligned_le16(p))</span>
<span class="p_del">-</span>
 #define LZ4_WILDCOPY(s, d, e)		\
 	do {				\
 		LZ4_COPYPACKET(s, d);	\
<span class="p_header">diff --git a/lib/mpi/mpicoder.c b/lib/mpi/mpicoder.c</span>
<span class="p_header">index 3db76b8c1115..e00ff00e861c 100644</span>
<span class="p_header">--- a/lib/mpi/mpicoder.c</span>
<span class="p_header">+++ b/lib/mpi/mpicoder.c</span>
<span class="p_chunk">@@ -128,6 +128,23 @@</span> <span class="p_context"> leave:</span>
 }
 EXPORT_SYMBOL_GPL(mpi_read_from_buffer);
 
<span class="p_add">+static int count_lzeros(MPI a)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mpi_limb_t alimb;</span>
<span class="p_add">+	int i, lzeros = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = a-&gt;nlimbs - 1; i &gt;= 0; i--) {</span>
<span class="p_add">+		alimb = a-&gt;d[i];</span>
<span class="p_add">+		if (alimb == 0) {</span>
<span class="p_add">+			lzeros += sizeof(mpi_limb_t);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			lzeros += count_leading_zeros(alimb) / 8;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return lzeros;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * mpi_read_buffer() - read MPI to a bufer provided by user (msb first)
  *
<span class="p_chunk">@@ -146,7 +163,7 @@</span> <span class="p_context"> int mpi_read_buffer(MPI a, uint8_t *buf, unsigned buf_len, unsigned *nbytes,</span>
 	uint8_t *p;
 	mpi_limb_t alimb;
 	unsigned int n = mpi_get_size(a);
<span class="p_del">-	int i, lzeros = 0;</span>
<span class="p_add">+	int i, lzeros;</span>
 
 	if (buf_len &lt; n || !buf || !nbytes)
 		return -EINVAL;
<span class="p_chunk">@@ -154,14 +171,7 @@</span> <span class="p_context"> int mpi_read_buffer(MPI a, uint8_t *buf, unsigned buf_len, unsigned *nbytes,</span>
 	if (sign)
 		*sign = a-&gt;sign;
 
<span class="p_del">-	p = (void *)&amp;a-&gt;d[a-&gt;nlimbs] - 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = a-&gt;nlimbs * sizeof(alimb) - 1; i &gt;= 0; i--, p--) {</span>
<span class="p_del">-		if (!*p)</span>
<span class="p_del">-			lzeros++;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	lzeros = count_lzeros(a);</span>
 
 	p = buf;
 	*nbytes = n - lzeros;
<span class="p_chunk">@@ -343,7 +353,7 @@</span> <span class="p_context"> int mpi_write_to_sgl(MPI a, struct scatterlist *sgl, unsigned *nbytes,</span>
 	u8 *p, *p2;
 	mpi_limb_t alimb, alimb2;
 	unsigned int n = mpi_get_size(a);
<span class="p_del">-	int i, x, y = 0, lzeros = 0, buf_len;</span>
<span class="p_add">+	int i, x, y = 0, lzeros, buf_len;</span>
 
 	if (!nbytes || *nbytes &lt; n)
 		return -EINVAL;
<span class="p_chunk">@@ -351,14 +361,7 @@</span> <span class="p_context"> int mpi_write_to_sgl(MPI a, struct scatterlist *sgl, unsigned *nbytes,</span>
 	if (sign)
 		*sign = a-&gt;sign;
 
<span class="p_del">-	p = (void *)&amp;a-&gt;d[a-&gt;nlimbs] - 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = a-&gt;nlimbs * sizeof(alimb) - 1; i &gt;= 0; i--, p--) {</span>
<span class="p_del">-		if (!*p)</span>
<span class="p_del">-			lzeros++;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	lzeros = count_lzeros(a);</span>
 
 	*nbytes = n - lzeros;
 	buf_len = sgl-&gt;length;
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 62fe06bb7d04..530e6427f823 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -2134,10 +2134,9 @@</span> <span class="p_context"> int khugepaged_enter_vma_merge(struct vm_area_struct *vma,</span>
 		 * page fault if needed.
 		 */
 		return 0;
<span class="p_del">-	if (vma-&gt;vm_ops)</span>
<span class="p_add">+	if (vma-&gt;vm_ops || (vm_flags &amp; VM_NO_THP))</span>
 		/* khugepaged not yet working on file or special mappings */
 		return 0;
<span class="p_del">-	VM_BUG_ON_VMA(vm_flags &amp; VM_NO_THP, vma);</span>
 	hstart = (vma-&gt;vm_start + ~HPAGE_PMD_MASK) &amp; HPAGE_PMD_MASK;
 	hend = vma-&gt;vm_end &amp; HPAGE_PMD_MASK;
 	if (hstart &lt; hend)
<span class="p_chunk">@@ -2498,8 +2497,7 @@</span> <span class="p_context"> static bool hugepage_vma_check(struct vm_area_struct *vma)</span>
 		return false;
 	if (is_vma_temporary_stack(vma))
 		return false;
<span class="p_del">-	VM_BUG_ON_VMA(vma-&gt;vm_flags &amp; VM_NO_THP, vma);</span>
<span class="p_del">-	return true;</span>
<span class="p_add">+	return !(vma-&gt;vm_flags &amp; VM_NO_THP);</span>
 }
 
 static void collapse_huge_page(struct mm_struct *mm,
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index fc0bcc41d57f..6ba4dd988e2e 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -196,6 +196,7 @@</span> <span class="p_context"> static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);</span>
 /* &quot;mc&quot; and its members are protected by cgroup_mutex */
 static struct move_charge_struct {
 	spinlock_t	  lock; /* for from, to */
<span class="p_add">+	struct mm_struct  *mm;</span>
 	struct mem_cgroup *from;
 	struct mem_cgroup *to;
 	unsigned long flags;
<span class="p_chunk">@@ -4800,6 +4801,8 @@</span> <span class="p_context"> static void __mem_cgroup_clear_mc(void)</span>
 
 static void mem_cgroup_clear_mc(void)
 {
<span class="p_add">+	struct mm_struct *mm = mc.mm;</span>
<span class="p_add">+</span>
 	/*
 	 * we must clear moving_task before waking up waiters at the end of
 	 * task migration.
<span class="p_chunk">@@ -4809,7 +4812,10 @@</span> <span class="p_context"> static void mem_cgroup_clear_mc(void)</span>
 	spin_lock(&amp;mc.lock);
 	mc.from = NULL;
 	mc.to = NULL;
<span class="p_add">+	mc.mm = NULL;</span>
 	spin_unlock(&amp;mc.lock);
<span class="p_add">+</span>
<span class="p_add">+	mmput(mm);</span>
 }
 
 static int mem_cgroup_can_attach(struct cgroup_taskset *tset)
<span class="p_chunk">@@ -4866,6 +4872,7 @@</span> <span class="p_context"> static int mem_cgroup_can_attach(struct cgroup_taskset *tset)</span>
 		VM_BUG_ON(mc.moved_swap);
 
 		spin_lock(&amp;mc.lock);
<span class="p_add">+		mc.mm = mm;</span>
 		mc.from = from;
 		mc.to = memcg;
 		mc.flags = move_flags;
<span class="p_chunk">@@ -4875,8 +4882,9 @@</span> <span class="p_context"> static int mem_cgroup_can_attach(struct cgroup_taskset *tset)</span>
 		ret = mem_cgroup_precharge_mc(mm);
 		if (ret)
 			mem_cgroup_clear_mc();
<span class="p_add">+	} else {</span>
<span class="p_add">+		mmput(mm);</span>
 	}
<span class="p_del">-	mmput(mm);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -4985,11 +4993,11 @@</span> <span class="p_context"> put:			/* get_mctgt_type() gets the page */</span>
 	return ret;
 }
 
<span class="p_del">-static void mem_cgroup_move_charge(struct mm_struct *mm)</span>
<span class="p_add">+static void mem_cgroup_move_charge(void)</span>
 {
 	struct mm_walk mem_cgroup_move_charge_walk = {
 		.pmd_entry = mem_cgroup_move_charge_pte_range,
<span class="p_del">-		.mm = mm,</span>
<span class="p_add">+		.mm = mc.mm,</span>
 	};
 
 	lru_add_drain_all();
<span class="p_chunk">@@ -5001,7 +5009,7 @@</span> <span class="p_context"> static void mem_cgroup_move_charge(struct mm_struct *mm)</span>
 	atomic_inc(&amp;mc.from-&gt;moving_account);
 	synchronize_rcu();
 retry:
<span class="p_del">-	if (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) {</span>
<span class="p_add">+	if (unlikely(!down_read_trylock(&amp;mc.mm-&gt;mmap_sem))) {</span>
 		/*
 		 * Someone who are holding the mmap_sem might be waiting in
 		 * waitq. So we cancel all extra charges, wake up all waiters,
<span class="p_chunk">@@ -5018,23 +5026,16 @@</span> <span class="p_context"> retry:</span>
 	 * additional charge, the page walk just aborts.
 	 */
 	walk_page_range(0, ~0UL, &amp;mem_cgroup_move_charge_walk);
<span class="p_del">-	up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	up_read(&amp;mc.mm-&gt;mmap_sem);</span>
 	atomic_dec(&amp;mc.from-&gt;moving_account);
 }
 
<span class="p_del">-static void mem_cgroup_move_task(struct cgroup_taskset *tset)</span>
<span class="p_add">+static void mem_cgroup_move_task(void)</span>
 {
<span class="p_del">-	struct cgroup_subsys_state *css;</span>
<span class="p_del">-	struct task_struct *p = cgroup_taskset_first(tset, &amp;css);</span>
<span class="p_del">-	struct mm_struct *mm = get_task_mm(p);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mm) {</span>
<span class="p_del">-		if (mc.to)</span>
<span class="p_del">-			mem_cgroup_move_charge(mm);</span>
<span class="p_del">-		mmput(mm);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (mc.to)</span>
<span class="p_add">+	if (mc.to) {</span>
<span class="p_add">+		mem_cgroup_move_charge();</span>
 		mem_cgroup_clear_mc();
<span class="p_add">+	}</span>
 }
 #else	/* !CONFIG_MMU */
 static int mem_cgroup_can_attach(struct cgroup_taskset *tset)
<span class="p_chunk">@@ -5044,7 +5045,7 @@</span> <span class="p_context"> static int mem_cgroup_can_attach(struct cgroup_taskset *tset)</span>
 static void mem_cgroup_cancel_attach(struct cgroup_taskset *tset)
 {
 }
<span class="p_del">-static void mem_cgroup_move_task(struct cgroup_taskset *tset)</span>
<span class="p_add">+static void mem_cgroup_move_task(void)</span>
 {
 }
 #endif
<span class="p_chunk">@@ -5258,7 +5259,7 @@</span> <span class="p_context"> struct cgroup_subsys memory_cgrp_subsys = {</span>
 	.css_reset = mem_cgroup_css_reset,
 	.can_attach = mem_cgroup_can_attach,
 	.cancel_attach = mem_cgroup_cancel_attach,
<span class="p_del">-	.attach = mem_cgroup_move_task,</span>
<span class="p_add">+	.post_attach = mem_cgroup_move_task,</span>
 	.bind = mem_cgroup_bind,
 	.dfl_cftypes = memory_files,
 	.legacy_cftypes = mem_cgroup_legacy_files,
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index b80bf4746b67..76dcee317714 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -797,6 +797,46 @@</span> <span class="p_context"> out:</span>
 	return pfn_to_page(pfn);
 }
 
<span class="p_add">+#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="p_add">+struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,</span>
<span class="p_add">+				pmd_t pmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pfn = pmd_pfn(pmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * There is no pmd_special() but there may be special pmds, e.g.</span>
<span class="p_add">+	 * in a direct-access (dax) mapping, so let&#39;s just replicate the</span>
<span class="p_add">+	 * !HAVE_PTE_SPECIAL case from vm_normal_page() here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(vma-&gt;vm_flags &amp; (VM_PFNMAP|VM_MIXEDMAP))) {</span>
<span class="p_add">+		if (vma-&gt;vm_flags &amp; VM_MIXEDMAP) {</span>
<span class="p_add">+			if (!pfn_valid(pfn))</span>
<span class="p_add">+				return NULL;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			unsigned long off;</span>
<span class="p_add">+			off = (addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+			if (pfn == vma-&gt;vm_pgoff + off)</span>
<span class="p_add">+				return NULL;</span>
<span class="p_add">+			if (!is_cow_mapping(vma-&gt;vm_flags))</span>
<span class="p_add">+				return NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_zero_pfn(pfn))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	if (unlikely(pfn &gt; highest_memmap_pfn))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * NOTE! We still have PageReserved() pages in the page tables.</span>
<span class="p_add">+	 * eg. VDSO mappings can cause them to exist.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return pfn_to_page(pfn);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * copy one vm_area from one task to the other. Assumes the page tables
  * already present in the new task to be cleared in the whole range
<span class="p_header">diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="p_header">index 6d17e0ab42d4..bbeb0b71fcf4 100644</span>
<span class="p_header">--- a/mm/migrate.c</span>
<span class="p_header">+++ b/mm/migrate.c</span>
<span class="p_chunk">@@ -963,7 +963,13 @@</span> <span class="p_context"> out:</span>
 		dec_zone_page_state(page, NR_ISOLATED_ANON +
 				page_is_file_cache(page));
 		/* Soft-offlined page shouldn&#39;t go through lru cache list */
<span class="p_del">-		if (reason == MR_MEMORY_FAILURE) {</span>
<span class="p_add">+		if (reason == MR_MEMORY_FAILURE &amp;&amp; rc == MIGRATEPAGE_SUCCESS) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * With this release, we free successfully migrated</span>
<span class="p_add">+			 * page and set PG_HWPoison on just freed page</span>
<span class="p_add">+			 * intentionally. Although it&#39;s rather weird, it&#39;s how</span>
<span class="p_add">+			 * HWPoison flag works at the moment.</span>
<span class="p_add">+			 */</span>
 			put_page(page);
 			if (!test_set_page_hwpoison(page))
 				num_poisoned_pages_inc();
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index 46997517406e..65d5f92d51d2 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -2819,6 +2819,7 @@</span> <span class="p_context"> struct detached_freelist {</span>
 	void *tail;
 	void *freelist;
 	int cnt;
<span class="p_add">+	struct kmem_cache *s;</span>
 };
 
 /*
<span class="p_chunk">@@ -2833,8 +2834,9 @@</span> <span class="p_context"> struct detached_freelist {</span>
  * synchronization primitive.  Look ahead in the array is limited due
  * to performance reasons.
  */
<span class="p_del">-static int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
<span class="p_del">-				   void **p, struct detached_freelist *df)</span>
<span class="p_add">+static inline</span>
<span class="p_add">+int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
<span class="p_add">+			    void **p, struct detached_freelist *df)</span>
 {
 	size_t first_skipped_index = 0;
 	int lookahead = 3;
<span class="p_chunk">@@ -2850,8 +2852,11 @@</span> <span class="p_context"> static int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
 	if (!object)
 		return 0;
 
<span class="p_add">+	/* Support for memcg, compiler can optimize this out */</span>
<span class="p_add">+	df-&gt;s = cache_from_obj(s, object);</span>
<span class="p_add">+</span>
 	/* Start new detached freelist */
<span class="p_del">-	set_freepointer(s, object, NULL);</span>
<span class="p_add">+	set_freepointer(df-&gt;s, object, NULL);</span>
 	df-&gt;page = virt_to_head_page(object);
 	df-&gt;tail = object;
 	df-&gt;freelist = object;
<span class="p_chunk">@@ -2866,7 +2871,7 @@</span> <span class="p_context"> static int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
 		/* df-&gt;page is always set at this point */
 		if (df-&gt;page == virt_to_head_page(object)) {
 			/* Opportunity build freelist */
<span class="p_del">-			set_freepointer(s, object, df-&gt;freelist);</span>
<span class="p_add">+			set_freepointer(df-&gt;s, object, df-&gt;freelist);</span>
 			df-&gt;freelist = object;
 			df-&gt;cnt++;
 			p[size] = NULL; /* mark object processed */
<span class="p_chunk">@@ -2885,25 +2890,20 @@</span> <span class="p_context"> static int build_detached_freelist(struct kmem_cache *s, size_t size,</span>
 	return first_skipped_index;
 }
 
<span class="p_del">-</span>
 /* Note that interrupts must be enabled when calling this function. */
<span class="p_del">-void kmem_cache_free_bulk(struct kmem_cache *orig_s, size_t size, void **p)</span>
<span class="p_add">+void kmem_cache_free_bulk(struct kmem_cache *s, size_t size, void **p)</span>
 {
 	if (WARN_ON(!size))
 		return;
 
 	do {
 		struct detached_freelist df;
<span class="p_del">-		struct kmem_cache *s;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Support for memcg */</span>
<span class="p_del">-		s = cache_from_obj(orig_s, p[size - 1]);</span>
 
 		size = build_detached_freelist(s, size, p, &amp;df);
 		if (unlikely(!df.page))
 			continue;
 
<span class="p_del">-		slab_free(s, df.page, df.freelist, df.tail, df.cnt, _RET_IP_);</span>
<span class="p_add">+		slab_free(df.s, df.page, df.freelist, df.tail, df.cnt,_RET_IP_);</span>
 	} while (likely(size));
 }
 EXPORT_SYMBOL(kmem_cache_free_bulk);
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index 2aec4241b42a..0c114e2b01d3 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -2534,7 +2534,7 @@</span> <span class="p_context"> static bool shrink_zones(struct zonelist *zonelist, struct scan_control *sc)</span>
 		sc-&gt;gfp_mask |= __GFP_HIGHMEM;
 
 	for_each_zone_zonelist_nodemask(zone, z, zonelist,
<span class="p_del">-					requested_highidx, sc-&gt;nodemask) {</span>
<span class="p_add">+					gfp_zone(sc-&gt;gfp_mask), sc-&gt;nodemask) {</span>
 		enum zone_type classzone_idx;
 
 		if (!populated_zone(zone))
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 59651af8cc27..992b35fb8615 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -1305,7 +1305,7 @@</span> <span class="p_context"> static int netlink_release(struct socket *sock)</span>
 
 	skb_queue_purge(&amp;sk-&gt;sk_write_queue);
 
<span class="p_del">-	if (nlk-&gt;portid) {</span>
<span class="p_add">+	if (nlk-&gt;portid &amp;&amp; nlk-&gt;bound) {</span>
 		struct netlink_notify n = {
 						.net = sock_net(sk),
 						.protocol = sk-&gt;sk_protocol,
<span class="p_header">diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c</span>
<span class="p_header">index 21e20353178e..63fb5ee212cf 100644</span>
<span class="p_header">--- a/net/sunrpc/cache.c</span>
<span class="p_header">+++ b/net/sunrpc/cache.c</span>
<span class="p_chunk">@@ -1182,14 +1182,14 @@</span> <span class="p_context"> int sunrpc_cache_pipe_upcall(struct cache_detail *detail, struct cache_head *h)</span>
 	}
 
 	crq-&gt;q.reader = 0;
<span class="p_del">-	crq-&gt;item = cache_get(h);</span>
 	crq-&gt;buf = buf;
 	crq-&gt;len = 0;
 	crq-&gt;readers = 0;
 	spin_lock(&amp;queue_lock);
<span class="p_del">-	if (test_bit(CACHE_PENDING, &amp;h-&gt;flags))</span>
<span class="p_add">+	if (test_bit(CACHE_PENDING, &amp;h-&gt;flags)) {</span>
<span class="p_add">+		crq-&gt;item = cache_get(h);</span>
 		list_add_tail(&amp;crq-&gt;q.list, &amp;detail-&gt;queue);
<span class="p_del">-	else</span>
<span class="p_add">+	} else</span>
 		/* Lost a race, no longer PENDING, so don&#39;t enqueue */
 		ret = -EAGAIN;
 	spin_unlock(&amp;queue_lock);
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 75b0d23ee882..5d89f13a98db 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -13161,7 +13161,7 @@</span> <span class="p_context"> static int nl80211_netlink_notify(struct notifier_block * nb,</span>
 	struct wireless_dev *wdev;
 	struct cfg80211_beacon_registration *reg, *tmp;
 
<span class="p_del">-	if (state != NETLINK_URELEASE)</span>
<span class="p_add">+	if (state != NETLINK_URELEASE || notify-&gt;protocol != NETLINK_GENERIC)</span>
 		return NOTIFY_DONE;
 
 	rcu_read_lock();
<span class="p_header">diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c</span>
<span class="p_header">index 0b7dc2fd7bac..dd243d2abd87 100644</span>
<span class="p_header">--- a/scripts/kconfig/confdata.c</span>
<span class="p_header">+++ b/scripts/kconfig/confdata.c</span>
<span class="p_chunk">@@ -267,10 +267,8 @@</span> <span class="p_context"> int conf_read_simple(const char *name, int def)</span>
 		if (in)
 			goto load;
 		sym_add_change_count(1);
<span class="p_del">-		if (!sym_defconfig_list) {</span>
<span class="p_del">-			sym_calc_value(modules_sym);</span>
<span class="p_add">+		if (!sym_defconfig_list)</span>
 			return 1;
<span class="p_del">-		}</span>
 
 		for_all_defaults(sym_defconfig_list, prop) {
 			if (expr_calc_value(prop-&gt;visible.expr) == no ||
<span class="p_chunk">@@ -403,7 +401,6 @@</span> <span class="p_context"> setsym:</span>
 	}
 	free(line);
 	fclose(in);
<span class="p_del">-	sym_calc_value(modules_sym);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -414,8 +411,12 @@</span> <span class="p_context"> int conf_read(const char *name)</span>
 
 	sym_set_change_count(0);
 
<span class="p_del">-	if (conf_read_simple(name, S_DEF_USER))</span>
<span class="p_add">+	if (conf_read_simple(name, S_DEF_USER)) {</span>
<span class="p_add">+		sym_calc_value(modules_sym);</span>
 		return 1;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	sym_calc_value(modules_sym);</span>
 
 	for_all_symbols(i, sym) {
 		sym_calc_value(sym);
<span class="p_chunk">@@ -846,6 +847,7 @@</span> <span class="p_context"> static int conf_split_config(void)</span>
 
 	name = conf_get_autoconfig_name();
 	conf_read_simple(name, S_DEF_AUTO);
<span class="p_add">+	sym_calc_value(modules_sym);</span>
 
 	if (chdir(&quot;include/config&quot;))
 		return 1;
<span class="p_header">diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c</span>
<span class="p_header">index 5c4fa8eba1d0..367dbf0d285e 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_generic.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_generic.c</span>
<span class="p_chunk">@@ -843,7 +843,7 @@</span> <span class="p_context"> static hda_nid_t path_power_update(struct hda_codec *codec,</span>
 				   bool allow_powerdown)
 {
 	hda_nid_t nid, changed = 0;
<span class="p_del">-	int i, state;</span>
<span class="p_add">+	int i, state, power;</span>
 
 	for (i = 0; i &lt; path-&gt;depth; i++) {
 		nid = path-&gt;path[i];
<span class="p_chunk">@@ -855,7 +855,9 @@</span> <span class="p_context"> static hda_nid_t path_power_update(struct hda_codec *codec,</span>
 			state = AC_PWRST_D0;
 		else
 			state = AC_PWRST_D3;
<span class="p_del">-		if (!snd_hda_check_power_state(codec, nid, state)) {</span>
<span class="p_add">+		power = snd_hda_codec_read(codec, nid, 0,</span>
<span class="p_add">+					   AC_VERB_GET_POWER_STATE, 0);</span>
<span class="p_add">+		if (power != (state | (state &lt;&lt; 4))) {</span>
 			snd_hda_codec_write(codec, nid, 0,
 					    AC_VERB_SET_POWER_STATE, state);
 			changed = nid;
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 2ff692dd2c5f..411630e9c034 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2207,6 +2207,9 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	/* Broxton-P(Apollolake) */
 	{ PCI_DEVICE(0x8086, 0x5a98),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_BROXTON },
<span class="p_add">+	/* Broxton-T */</span>
<span class="p_add">+	{ PCI_DEVICE(0x8086, 0x1a98),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_BROXTON },</span>
 	/* Haswell */
 	{ PCI_DEVICE(0x8086, 0x0a0c),
 	  .driver_data = AZX_DRIVER_HDMI | AZX_DCAPS_INTEL_HASWELL },
<span class="p_header">diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">index a47e8ae0eb30..80bbadc83721 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_chunk">@@ -361,6 +361,7 @@</span> <span class="p_context"> static int cs_parse_auto_config(struct hda_codec *codec)</span>
 {
 	struct cs_spec *spec = codec-&gt;spec;
 	int err;
<span class="p_add">+	int i;</span>
 
 	err = snd_hda_parse_pin_defcfg(codec, &amp;spec-&gt;gen.autocfg, NULL, 0);
 	if (err &lt; 0)
<span class="p_chunk">@@ -370,6 +371,19 @@</span> <span class="p_context"> static int cs_parse_auto_config(struct hda_codec *codec)</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_add">+	/* keep the ADCs powered up when it&#39;s dynamically switchable */</span>
<span class="p_add">+	if (spec-&gt;gen.dyn_adc_switch) {</span>
<span class="p_add">+		unsigned int done = 0;</span>
<span class="p_add">+		for (i = 0; i &lt; spec-&gt;gen.input_mux.num_items; i++) {</span>
<span class="p_add">+			int idx = spec-&gt;gen.dyn_adc_idx[i];</span>
<span class="p_add">+			if (done &amp; (1 &lt;&lt; idx))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			snd_hda_gen_fix_pin_power(codec,</span>
<span class="p_add">+						  spec-&gt;gen.adc_nids[idx]);</span>
<span class="p_add">+			done |= 1 &lt;&lt; idx;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 1402ba954b3d..ac4490a96863 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5449,6 +5449,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x064a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x064b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0665, &quot;Dell XPS 13&quot;, ALC288_FIXUP_DELL_XPS_13),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x0669, &quot;Dell Optiplex 9020m&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),</span>
 	SND_PCI_QUIRK(0x1028, 0x069a, &quot;Dell Vostro 5480&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),
 	SND_PCI_QUIRK(0x1028, 0x06c7, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06d9, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_chunk">@@ -5583,6 +5584,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x5034, &quot;Thinkpad T450&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5036, &quot;Thinkpad T450s&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x503c, &quot;Thinkpad L450&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x504a, &quot;ThinkPad X260&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x504b, &quot;Thinkpad&quot;, ALC293_FIXUP_LENOVO_SPK_NOISE),
 	SND_PCI_QUIRK(0x17aa, 0x5109, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x3bf8, &quot;Quanta FL1&quot;, ALC269_FIXUP_PCM_44K),
<span class="p_header">diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c</span>
<span class="p_header">index c5194f5b150a..d7e71f309299 100644</span>
<span class="p_header">--- a/sound/pci/pcxhr/pcxhr_core.c</span>
<span class="p_header">+++ b/sound/pci/pcxhr/pcxhr_core.c</span>
<span class="p_chunk">@@ -1341,5 +1341,6 @@</span> <span class="p_context"> irqreturn_t pcxhr_threaded_irq(int irq, void *dev_id)</span>
 	}
 
 	pcxhr_msg_thread(mgr);
<span class="p_add">+	mutex_unlock(&amp;mgr-&gt;lock);</span>
 	return IRQ_HANDLED;
 }
<span class="p_header">diff --git a/sound/soc/codecs/rt5640.c b/sound/soc/codecs/rt5640.c</span>
<span class="p_header">index f2beb1aa5763..b1c8bb39cdf1 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5640.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5640.c</span>
<span class="p_chunk">@@ -359,7 +359,7 @@</span> <span class="p_context"> static const DECLARE_TLV_DB_RANGE(bst_tlv,</span>
 
 /* Interface data select */
 static const char * const rt5640_data_select[] = {
<span class="p_del">-	&quot;Normal&quot;, &quot;left copy to right&quot;, &quot;right copy to left&quot;, &quot;Swap&quot;};</span>
<span class="p_add">+	&quot;Normal&quot;, &quot;Swap&quot;, &quot;left copy to right&quot;, &quot;right copy to left&quot;};</span>
 
 static SOC_ENUM_SINGLE_DECL(rt5640_if1_dac_enum, RT5640_DIG_INF_DATA,
 			    RT5640_IF1_DAC_SEL_SFT, rt5640_data_select);
<span class="p_header">diff --git a/sound/soc/codecs/rt5640.h b/sound/soc/codecs/rt5640.h</span>
<span class="p_header">index 3deb8babeabb..243f42633989 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5640.h</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5640.h</span>
<span class="p_chunk">@@ -442,39 +442,39 @@</span> <span class="p_context"></span>
 #define RT5640_IF1_DAC_SEL_MASK			(0x3 &lt;&lt; 14)
 #define RT5640_IF1_DAC_SEL_SFT			14
 #define RT5640_IF1_DAC_SEL_NOR			(0x0 &lt;&lt; 14)
<span class="p_del">-#define RT5640_IF1_DAC_SEL_L2R			(0x1 &lt;&lt; 14)</span>
<span class="p_del">-#define RT5640_IF1_DAC_SEL_R2L			(0x2 &lt;&lt; 14)</span>
<span class="p_del">-#define RT5640_IF1_DAC_SEL_SWAP			(0x3 &lt;&lt; 14)</span>
<span class="p_add">+#define RT5640_IF1_DAC_SEL_SWAP			(0x1 &lt;&lt; 14)</span>
<span class="p_add">+#define RT5640_IF1_DAC_SEL_L2R			(0x2 &lt;&lt; 14)</span>
<span class="p_add">+#define RT5640_IF1_DAC_SEL_R2L			(0x3 &lt;&lt; 14)</span>
 #define RT5640_IF1_ADC_SEL_MASK			(0x3 &lt;&lt; 12)
 #define RT5640_IF1_ADC_SEL_SFT			12
 #define RT5640_IF1_ADC_SEL_NOR			(0x0 &lt;&lt; 12)
<span class="p_del">-#define RT5640_IF1_ADC_SEL_L2R			(0x1 &lt;&lt; 12)</span>
<span class="p_del">-#define RT5640_IF1_ADC_SEL_R2L			(0x2 &lt;&lt; 12)</span>
<span class="p_del">-#define RT5640_IF1_ADC_SEL_SWAP			(0x3 &lt;&lt; 12)</span>
<span class="p_add">+#define RT5640_IF1_ADC_SEL_SWAP			(0x1 &lt;&lt; 12)</span>
<span class="p_add">+#define RT5640_IF1_ADC_SEL_L2R			(0x2 &lt;&lt; 12)</span>
<span class="p_add">+#define RT5640_IF1_ADC_SEL_R2L			(0x3 &lt;&lt; 12)</span>
 #define RT5640_IF2_DAC_SEL_MASK			(0x3 &lt;&lt; 10)
 #define RT5640_IF2_DAC_SEL_SFT			10
 #define RT5640_IF2_DAC_SEL_NOR			(0x0 &lt;&lt; 10)
<span class="p_del">-#define RT5640_IF2_DAC_SEL_L2R			(0x1 &lt;&lt; 10)</span>
<span class="p_del">-#define RT5640_IF2_DAC_SEL_R2L			(0x2 &lt;&lt; 10)</span>
<span class="p_del">-#define RT5640_IF2_DAC_SEL_SWAP			(0x3 &lt;&lt; 10)</span>
<span class="p_add">+#define RT5640_IF2_DAC_SEL_SWAP			(0x1 &lt;&lt; 10)</span>
<span class="p_add">+#define RT5640_IF2_DAC_SEL_L2R			(0x2 &lt;&lt; 10)</span>
<span class="p_add">+#define RT5640_IF2_DAC_SEL_R2L			(0x3 &lt;&lt; 10)</span>
 #define RT5640_IF2_ADC_SEL_MASK			(0x3 &lt;&lt; 8)
 #define RT5640_IF2_ADC_SEL_SFT			8
 #define RT5640_IF2_ADC_SEL_NOR			(0x0 &lt;&lt; 8)
<span class="p_del">-#define RT5640_IF2_ADC_SEL_L2R			(0x1 &lt;&lt; 8)</span>
<span class="p_del">-#define RT5640_IF2_ADC_SEL_R2L			(0x2 &lt;&lt; 8)</span>
<span class="p_del">-#define RT5640_IF2_ADC_SEL_SWAP			(0x3 &lt;&lt; 8)</span>
<span class="p_add">+#define RT5640_IF2_ADC_SEL_SWAP			(0x1 &lt;&lt; 8)</span>
<span class="p_add">+#define RT5640_IF2_ADC_SEL_L2R			(0x2 &lt;&lt; 8)</span>
<span class="p_add">+#define RT5640_IF2_ADC_SEL_R2L			(0x3 &lt;&lt; 8)</span>
 #define RT5640_IF3_DAC_SEL_MASK			(0x3 &lt;&lt; 6)
 #define RT5640_IF3_DAC_SEL_SFT			6
 #define RT5640_IF3_DAC_SEL_NOR			(0x0 &lt;&lt; 6)
<span class="p_del">-#define RT5640_IF3_DAC_SEL_L2R			(0x1 &lt;&lt; 6)</span>
<span class="p_del">-#define RT5640_IF3_DAC_SEL_R2L			(0x2 &lt;&lt; 6)</span>
<span class="p_del">-#define RT5640_IF3_DAC_SEL_SWAP			(0x3 &lt;&lt; 6)</span>
<span class="p_add">+#define RT5640_IF3_DAC_SEL_SWAP			(0x1 &lt;&lt; 6)</span>
<span class="p_add">+#define RT5640_IF3_DAC_SEL_L2R			(0x2 &lt;&lt; 6)</span>
<span class="p_add">+#define RT5640_IF3_DAC_SEL_R2L			(0x3 &lt;&lt; 6)</span>
 #define RT5640_IF3_ADC_SEL_MASK			(0x3 &lt;&lt; 4)
 #define RT5640_IF3_ADC_SEL_SFT			4
 #define RT5640_IF3_ADC_SEL_NOR			(0x0 &lt;&lt; 4)
<span class="p_del">-#define RT5640_IF3_ADC_SEL_L2R			(0x1 &lt;&lt; 4)</span>
<span class="p_del">-#define RT5640_IF3_ADC_SEL_R2L			(0x2 &lt;&lt; 4)</span>
<span class="p_del">-#define RT5640_IF3_ADC_SEL_SWAP			(0x3 &lt;&lt; 4)</span>
<span class="p_add">+#define RT5640_IF3_ADC_SEL_SWAP			(0x1 &lt;&lt; 4)</span>
<span class="p_add">+#define RT5640_IF3_ADC_SEL_L2R			(0x2 &lt;&lt; 4)</span>
<span class="p_add">+#define RT5640_IF3_ADC_SEL_R2L			(0x3 &lt;&lt; 4)</span>
 
 /* REC Left Mixer Control 1 (0x3b) */
 #define RT5640_G_HP_L_RM_L_MASK			(0x7 &lt;&lt; 13)
<span class="p_header">diff --git a/sound/soc/codecs/ssm4567.c b/sound/soc/codecs/ssm4567.c</span>
<span class="p_header">index e619d5651b09..080c78e88e10 100644</span>
<span class="p_header">--- a/sound/soc/codecs/ssm4567.c</span>
<span class="p_header">+++ b/sound/soc/codecs/ssm4567.c</span>
<span class="p_chunk">@@ -352,6 +352,11 @@</span> <span class="p_context"> static int ssm4567_set_power(struct ssm4567 *ssm4567, bool enable)</span>
 	regcache_cache_only(ssm4567-&gt;regmap, !enable);
 
 	if (enable) {
<span class="p_add">+		ret = regmap_write(ssm4567-&gt;regmap, SSM4567_REG_SOFT_RESET,</span>
<span class="p_add">+			0x00);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
 		ret = regmap_update_bits(ssm4567-&gt;regmap,
 			SSM4567_REG_POWER_CTRL,
 			SSM4567_POWER_SPWDN, 0x00);
<span class="p_header">diff --git a/sound/soc/samsung/s3c-i2s-v2.c b/sound/soc/samsung/s3c-i2s-v2.c</span>
<span class="p_header">index df65c5b494b1..b6ab3fc5789e 100644</span>
<span class="p_header">--- a/sound/soc/samsung/s3c-i2s-v2.c</span>
<span class="p_header">+++ b/sound/soc/samsung/s3c-i2s-v2.c</span>
<span class="p_chunk">@@ -709,7 +709,7 @@</span> <span class="p_context"> static int s3c2412_i2s_resume(struct snd_soc_dai *dai)</span>
 #endif
 
 int s3c_i2sv2_register_component(struct device *dev, int id,
<span class="p_del">-			   struct snd_soc_component_driver *cmp_drv,</span>
<span class="p_add">+			   const struct snd_soc_component_driver *cmp_drv,</span>
 			   struct snd_soc_dai_driver *dai_drv)
 {
 	struct snd_soc_dai_ops *ops = (struct snd_soc_dai_ops *)dai_drv-&gt;ops;
<span class="p_header">diff --git a/sound/soc/samsung/s3c-i2s-v2.h b/sound/soc/samsung/s3c-i2s-v2.h</span>
<span class="p_header">index 90abab364b49..d0684145ed1f 100644</span>
<span class="p_header">--- a/sound/soc/samsung/s3c-i2s-v2.h</span>
<span class="p_header">+++ b/sound/soc/samsung/s3c-i2s-v2.h</span>
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"> extern int s3c_i2sv2_probe(struct snd_soc_dai *dai,</span>
  * soc core.
  */
 extern int s3c_i2sv2_register_component(struct device *dev, int id,
<span class="p_del">-					struct snd_soc_component_driver *cmp_drv,</span>
<span class="p_add">+					const struct snd_soc_component_driver *cmp_drv,</span>
 					struct snd_soc_dai_driver *dai_drv);
 
 #endif /* __SND_SOC_S3C24XX_S3C_I2SV2_I2S_H */
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index 416514fe9e63..afb70a5d4fd3 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -2188,6 +2188,13 @@</span> <span class="p_context"> static ssize_t dapm_widget_show_component(struct snd_soc_component *cmpnt,</span>
 	int count = 0;
 	char *state = &quot;not set&quot;;
 
<span class="p_add">+	/* card won&#39;t be set for the dummy component, as a spot fix</span>
<span class="p_add">+	 * we&#39;re checking for that case specifically here but in future</span>
<span class="p_add">+	 * we will ensure that the dummy component looks like others.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!cmpnt-&gt;card)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	list_for_each_entry(w, &amp;cmpnt-&gt;card-&gt;widgets, list) {
 		if (w-&gt;dapm != dapm)
 			continue;
<span class="p_header">diff --git a/tools/perf/Documentation/perf-stat.txt b/tools/perf/Documentation/perf-stat.txt</span>
<span class="p_header">index 4e074a660826..90c3558c2c12 100644</span>
<span class="p_header">--- a/tools/perf/Documentation/perf-stat.txt</span>
<span class="p_header">+++ b/tools/perf/Documentation/perf-stat.txt</span>
<span class="p_chunk">@@ -62,6 +62,14 @@</span> <span class="p_context"> OPTIONS</span>
 --scale::
 	scale/normalize counter values
 
<span class="p_add">+-d::</span>
<span class="p_add">+--detailed::</span>
<span class="p_add">+	print more detailed statistics, can be specified up to 3 times</span>
<span class="p_add">+</span>
<span class="p_add">+	   -d:          detailed events, L1 and LLC data cache</span>
<span class="p_add">+        -d -d:     more detailed events, dTLB and iTLB events</span>
<span class="p_add">+     -d -d -d:     very detailed events, adding prefetch events</span>
<span class="p_add">+</span>
 -r::
 --repeat=&lt;n&gt;::
 	repeat command and print average + stddev (max: 100). 0 means forever.
<span class="p_header">diff --git a/tools/perf/ui/browsers/hists.c b/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">index 81def6c3f24b..3900386a3629 100644</span>
<span class="p_header">--- a/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">+++ b/tools/perf/ui/browsers/hists.c</span>
<span class="p_chunk">@@ -2059,10 +2059,12 @@</span> <span class="p_context"> skip_annotation:</span>
 			 *
 			 * See hist_browser__show_entry.
 			 */
<span class="p_del">-			nr_options += add_script_opt(browser,</span>
<span class="p_del">-						     &amp;actions[nr_options],</span>
<span class="p_del">-						     &amp;options[nr_options],</span>
<span class="p_del">-						     NULL, browser-&gt;selection-&gt;sym);</span>
<span class="p_add">+			if (sort__has_sym &amp;&amp; browser-&gt;selection-&gt;sym) {</span>
<span class="p_add">+				nr_options += add_script_opt(browser,</span>
<span class="p_add">+							     &amp;actions[nr_options],</span>
<span class="p_add">+							     &amp;options[nr_options],</span>
<span class="p_add">+							     NULL, browser-&gt;selection-&gt;sym);</span>
<span class="p_add">+			}</span>
 		}
 		nr_options += add_script_opt(browser, &amp;actions[nr_options],
 					     &amp;options[nr_options], NULL, NULL);
<span class="p_header">diff --git a/tools/perf/util/event.c b/tools/perf/util/event.c</span>
<span class="p_header">index 8b10621b415c..956187bf1a85 100644</span>
<span class="p_header">--- a/tools/perf/util/event.c</span>
<span class="p_header">+++ b/tools/perf/util/event.c</span>
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> int perf_event__synthesize_mmap_events(struct perf_tool *tool,</span>
 		strcpy(execname, &quot;&quot;);
 
 		/* 00400000-0040c000 r-xp 00000000 fd:01 41038  /bin/cat */
<span class="p_del">-		n = sscanf(bf, &quot;%&quot;PRIx64&quot;-%&quot;PRIx64&quot; %s %&quot;PRIx64&quot; %x:%x %u %s\n&quot;,</span>
<span class="p_add">+		n = sscanf(bf, &quot;%&quot;PRIx64&quot;-%&quot;PRIx64&quot; %s %&quot;PRIx64&quot; %x:%x %u %[^\n]\n&quot;,</span>
 		       &amp;event-&gt;mmap2.start, &amp;event-&gt;mmap2.len, prot,
 		       &amp;event-&gt;mmap2.pgoff, &amp;event-&gt;mmap2.maj,
 		       &amp;event-&gt;mmap2.min,
<span class="p_header">diff --git a/tools/perf/util/evlist.c b/tools/perf/util/evlist.c</span>
<span class="p_header">index d1392194a9a9..b4b96120fc3b 100644</span>
<span class="p_header">--- a/tools/perf/util/evlist.c</span>
<span class="p_header">+++ b/tools/perf/util/evlist.c</span>
<span class="p_chunk">@@ -1211,12 +1211,12 @@</span> <span class="p_context"> void perf_evlist__set_maps(struct perf_evlist *evlist, struct cpu_map *cpus,</span>
 	 */
 	if (cpus != evlist-&gt;cpus) {
 		cpu_map__put(evlist-&gt;cpus);
<span class="p_del">-		evlist-&gt;cpus = cpus;</span>
<span class="p_add">+		evlist-&gt;cpus = cpu_map__get(cpus);</span>
 	}
 
 	if (threads != evlist-&gt;threads) {
 		thread_map__put(evlist-&gt;threads);
<span class="p_del">-		evlist-&gt;threads = threads;</span>
<span class="p_add">+		evlist-&gt;threads = thread_map__get(threads);</span>
 	}
 
 	perf_evlist__propagate_maps(evlist);
<span class="p_header">diff --git a/tools/perf/util/intel-pt.c b/tools/perf/util/intel-pt.c</span>
<span class="p_header">index 97f963a3dcb9..9227c2f076c3 100644</span>
<span class="p_header">--- a/tools/perf/util/intel-pt.c</span>
<span class="p_header">+++ b/tools/perf/util/intel-pt.c</span>
<span class="p_chunk">@@ -1127,7 +1127,7 @@</span> <span class="p_context"> static int intel_pt_synth_transaction_sample(struct intel_pt_queue *ptq)</span>
 		pr_err(&quot;Intel Processor Trace: failed to deliver transaction event, error %d\n&quot;,
 		       ret);
 
<span class="p_del">-	if (pt-&gt;synth_opts.callchain)</span>
<span class="p_add">+	if (pt-&gt;synth_opts.last_branch)</span>
 		intel_pt_reset_last_branch_rb(ptq);
 
 	return ret;
<span class="p_header">diff --git a/virt/kvm/arm/arch_timer.c b/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">index ea6064696fe4..a7b9022b5c8f 100644</span>
<span class="p_header">--- a/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">+++ b/virt/kvm/arm/arch_timer.c</span>
<span class="p_chunk">@@ -86,6 +86,8 @@</span> <span class="p_context"> static void kvm_timer_inject_irq_work(struct work_struct *work)</span>
 	vcpu = container_of(work, struct kvm_vcpu, arch.timer_cpu.expired);
 	vcpu-&gt;arch.timer_cpu.armed = false;
 
<span class="p_add">+	WARN_ON(!kvm_timer_should_fire(vcpu));</span>
<span class="p_add">+</span>
 	/*
 	 * If the vcpu is blocked we want to wake it up so that it will see
 	 * the timer has expired when entering the guest.
<span class="p_chunk">@@ -93,10 +95,46 @@</span> <span class="p_context"> static void kvm_timer_inject_irq_work(struct work_struct *work)</span>
 	kvm_vcpu_kick(vcpu);
 }
 
<span class="p_add">+static u64 kvm_timer_compute_delta(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cycle_t cval, now;</span>
<span class="p_add">+</span>
<span class="p_add">+	cval = vcpu-&gt;arch.timer_cpu.cntv_cval;</span>
<span class="p_add">+	now = kvm_phys_timer_read() - vcpu-&gt;kvm-&gt;arch.timer.cntvoff;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (now &lt; cval) {</span>
<span class="p_add">+		u64 ns;</span>
<span class="p_add">+</span>
<span class="p_add">+		ns = cyclecounter_cyc2ns(timecounter-&gt;cc,</span>
<span class="p_add">+					 cval - now,</span>
<span class="p_add">+					 timecounter-&gt;mask,</span>
<span class="p_add">+					 &amp;timecounter-&gt;frac);</span>
<span class="p_add">+		return ns;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static enum hrtimer_restart kvm_timer_expire(struct hrtimer *hrt)
 {
 	struct arch_timer_cpu *timer;
<span class="p_add">+	struct kvm_vcpu *vcpu;</span>
<span class="p_add">+	u64 ns;</span>
<span class="p_add">+</span>
 	timer = container_of(hrt, struct arch_timer_cpu, timer);
<span class="p_add">+	vcpu = container_of(timer, struct kvm_vcpu, arch.timer_cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check that the timer has really expired from the guest&#39;s</span>
<span class="p_add">+	 * PoV (NTP on the host may have forced it to expire</span>
<span class="p_add">+	 * early). If we should have slept longer, restart it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ns = kvm_timer_compute_delta(vcpu);</span>
<span class="p_add">+	if (unlikely(ns)) {</span>
<span class="p_add">+		hrtimer_forward_now(hrt, ns_to_ktime(ns));</span>
<span class="p_add">+		return HRTIMER_RESTART;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	queue_work(wqueue, &amp;timer-&gt;expired);
 	return HRTIMER_NORESTART;
 }
<span class="p_chunk">@@ -170,8 +208,6 @@</span> <span class="p_context"> static int kvm_timer_update_state(struct kvm_vcpu *vcpu)</span>
 void kvm_timer_schedule(struct kvm_vcpu *vcpu)
 {
 	struct arch_timer_cpu *timer = &amp;vcpu-&gt;arch.timer_cpu;
<span class="p_del">-	u64 ns;</span>
<span class="p_del">-	cycle_t cval, now;</span>
 
 	BUG_ON(timer_is_armed(timer));
 
<span class="p_chunk">@@ -191,14 +227,7 @@</span> <span class="p_context"> void kvm_timer_schedule(struct kvm_vcpu *vcpu)</span>
 		return;
 
 	/*  The timer has not yet expired, schedule a background timer */
<span class="p_del">-	cval = timer-&gt;cntv_cval;</span>
<span class="p_del">-	now = kvm_phys_timer_read() - vcpu-&gt;kvm-&gt;arch.timer.cntvoff;</span>
<span class="p_del">-</span>
<span class="p_del">-	ns = cyclecounter_cyc2ns(timecounter-&gt;cc,</span>
<span class="p_del">-				 cval - now,</span>
<span class="p_del">-				 timecounter-&gt;mask,</span>
<span class="p_del">-				 &amp;timecounter-&gt;frac);</span>
<span class="p_del">-	timer_arm(timer, ns);</span>
<span class="p_add">+	timer_arm(timer, kvm_timer_compute_delta(vcpu));</span>
 }
 
 void kvm_timer_unschedule(struct kvm_vcpu *vcpu)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



