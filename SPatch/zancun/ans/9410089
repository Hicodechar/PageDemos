
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3,2/3] mm: add LSM hook for writes to readonly memory - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3,2/3] mm: add LSM hook for writes to readonly memory</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=96711">Jann Horn</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 3, 2016, 3:04 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1478142286-18427-5-git-send-email-jann@thejh.net&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9410089/mbox/"
   >mbox</a>
|
   <a href="/patch/9410089/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9410089/">/patch/9410089/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	94479601C2 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  3 Nov 2016 03:05:13 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 845932A6B9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  3 Nov 2016 03:05:13 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 7843E2A6BF; Thu,  3 Nov 2016 03:05:13 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A8CB02A6BA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  3 Nov 2016 03:05:11 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751950AbcKCDFB (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 2 Nov 2016 23:05:01 -0400
Received: from thejh.net ([37.221.195.125]:35364 &quot;EHLO thejh.net&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751561AbcKCDE5 (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 2 Nov 2016 23:04:57 -0400
Received: from pc.thejh.net (pc.vpn [192.168.44.2])
	by thejh.net (Postfix) with ESMTPSA id 94D30180A36;
	Thu,  3 Nov 2016 04:04:54 +0100 (CET)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=thejh.net; s=s2016;
	t=1478142295; bh=PmhXpsBWZolLPcnJanK5T9z3A4ZLQTH671XkVwItZzk=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
	b=JZobM4GtUYC9HtD5CADCKCQQmmEGrNpMQ15SMe8lTTyJtCcVy1a/pPzu+SN5Z9nTf
	re/0y+kG+W2WOfJFcs42t5GByjy+inJN+94MPibYzN0ixOXAMjki1XI3M69b12BSp2
	EfbMeRDBSSJVqwIErEV3bosDDQgwyNMc+17L+DqFMESHVW/wT+xprcRQqV4jZoupnc
	EiG62pFBrVd+JZ5fmU1UwcNZV4cZeLIUui/PlZgp9zgfjDQUisNkaInQhhE4JVgIyn
	fZBWufbktrKT6HxrKNUJ5YPdSZANuyfljI+9GFB306OMHa3XQO8WBT8btBbMucjK0v
	LtZ3oMSqDvTvg==
From: Jann Horn &lt;jann@thejh.net&gt;
To: security@kernel.org, Alexander Viro &lt;viro@zeniv.linux.org.uk&gt;,
	Paul Moore &lt;paul@paul-moore.com&gt;, Stephen Smalley &lt;sds@tycho.nsa.gov&gt;,
	Eric Paris &lt;eparis@parisplace.org&gt;,
	James Morris &lt;james.l.morris@oracle.com&gt;,
	&quot;Serge E. Hallyn&quot; &lt;serge@hallyn.com&gt;, mchong@google.com,
	Andy Lutomirski &lt;luto@amacapital.net&gt;, Ingo Molnar &lt;mingo@kernel.org&gt;,
	Oleg Nesterov &lt;oleg@redhat.com&gt;, Nick Kralevich &lt;nnk@google.com&gt;,
	Janis Danisevskis &lt;jdanis@google.com&gt;
Cc: linux-security-module@vger.kernel.org, linux-mm@kvack.org,
	linux-kernel@vger.kernel.org
Subject: [PATCH v3 2/3] mm: add LSM hook for writes to readonly memory
Date: Thu,  3 Nov 2016 04:04:45 +0100
Message-Id: &lt;1478142286-18427-5-git-send-email-jann@thejh.net&gt;
X-Mailer: git-send-email 2.1.4
In-Reply-To: &lt;1478142286-18427-1-git-send-email-jann@thejh.net&gt;
References: &lt;1478142286-18427-1-git-send-email-jann@thejh.net&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96711">Jann Horn</a> - Nov. 3, 2016, 3:04 a.m.</div>
<pre class="content">
SELinux attempts to make it possible to whitelist trustworthy sources of
code that may be mapped into memory, and Android makes use of this feature.
To prevent an attacker from bypassing this by modifying R+X memory through
/proc/$pid/mem, PTRACE_POKETEXT or DMA, it is necessary to call a security
hook in check_vma_flags().

PTRACE_POKETEXT can also be mitigated by blocking ptrace access, and
/proc/$pid/mem can also be blocked at the VFS layer, but DMA is harder to
deal with: Some driver functions (e.g. videobuf_dma_init_user_locked)
write to user-specified DMA mappings even if those mappings are readonly
or R+X.

The new security hook security_forced_write() takes three arguments:

 - The modified VMA, so the security check can e.g. test for executability.
 - The subject performing the access. For remote accesses, this may be
   different from the target of the access. This can e.g. be used to create
   a security policy that permits a privileged debugger to set software
   breakpoints in the address space of a sandboxed process.
 - The target of the access. This is useful if only a subset of the
   processes on the system should be prevented from executing arbitrary
   code, as is the case on Android.

changed in v2:
 - fix comment (Janis Danisevsk)
 - simplify code a bit (Janis Danisevsk)

changed in v3:
 - rebase
 - no need to pass in creds in populate_vma_page_range()
 - reword check_vma_flags() comment (Ingo Molnar)
 - use helper struct gup_creds (Ingo Molnar)
<span class="signed-off-by">
Signed-off-by: Jann Horn &lt;jann@thejh.net&gt;</span>
---
 drivers/gpu/drm/etnaviv/etnaviv_gem.c   |  5 ++-
 drivers/gpu/drm/i915/i915_gem_userptr.c |  2 +-
 drivers/infiniband/core/umem_odp.c      |  2 +-
 fs/exec.c                               |  2 +-
 fs/proc/base.c                          | 70 +++++++++++++++++++++++++--------
 fs/proc/internal.h                      |  4 +-
 fs/proc/task_mmu.c                      |  4 +-
 fs/proc/task_nommu.c                    |  2 +-
 include/linux/lsm_hooks.h               |  9 +++++
 include/linux/mm.h                      | 19 ++++++++-
 include/linux/sched.h                   |  4 +-
 include/linux/security.h                |  8 ++++
 kernel/events/uprobes.c                 |  8 ++--
 kernel/fork.c                           |  6 ++-
 mm/gup.c                                | 66 ++++++++++++++++++++++---------
 mm/memory.c                             | 22 ++++++-----
 mm/nommu.c                              | 13 +++---
 mm/process_vm_access.c                  |  4 +-
 security/security.c                     | 14 +++++++
 security/tomoyo/domain.c                |  4 +-
 virt/kvm/async_pf.c                     |  2 +-
 virt/kvm/kvm_main.c                     |  4 +-
 22 files changed, 200 insertions(+), 74 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96711">Jann Horn</a> - Nov. 3, 2016, 3:10 a.m.</div>
<pre class="content">
On Thu, Nov 03, 2016 at 04:04:45AM +0100, Jann Horn wrote:
<span class="quote">&gt; SELinux attempts to make it possible to whitelist trustworthy sources of</span>
<span class="quote">&gt; code that may be mapped into memory, and Android makes use of this feature.</span>
<span class="quote">&gt; To prevent an attacker from bypassing this by modifying R+X memory through</span>
<span class="quote">&gt; /proc/$pid/mem, PTRACE_POKETEXT or DMA, it is necessary to call a security</span>
<span class="quote">&gt; hook in check_vma_flags().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; PTRACE_POKETEXT can also be mitigated by blocking ptrace access, and</span>
<span class="quote">&gt; /proc/$pid/mem can also be blocked at the VFS layer, but DMA is harder to</span>
<span class="quote">&gt; deal with: Some driver functions (e.g. videobuf_dma_init_user_locked)</span>
<span class="quote">&gt; write to user-specified DMA mappings even if those mappings are readonly</span>
<span class="quote">&gt; or R+X.</span>

Whoops, sorry for sending that twice. :/

A comment regarding the whole series: I&#39;m not entirely sure whether this is
the best way to fix this after all. It&#39;s quite a bit of code churn, but it
has the benefit of having a single check in a central place.

As an alternative to this patch, it might be possible to break the ABIs
of the drivers that access DMA buffers with FOLL_FORCE by simply removing
FOLL_FORCE from those drivers. However, I&#39;m not sure how much that would
break existing userspace code.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/gpu/drm/etnaviv/etnaviv_gem.c b/drivers/gpu/drm/etnaviv/etnaviv_gem.c</span>
<span class="p_header">index 0370b842d9cc..a10bb860b8b7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/etnaviv/etnaviv_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/etnaviv/etnaviv_gem.c</span>
<span class="p_chunk">@@ -762,8 +762,9 @@</span> <span class="p_context"> static struct page **etnaviv_gem_userptr_do_get_pages(</span>
 
 	down_read(&amp;mm-&gt;mmap_sem);
 	while (pinned &lt; npages) {
<span class="p_del">-		ret = get_user_pages_remote(task, mm, ptr, npages - pinned,</span>
<span class="p_del">-					    flags, pvec + pinned, NULL);</span>
<span class="p_add">+		ret = get_user_pages_remote(task, mm, NULL, ptr,</span>
<span class="p_add">+					    npages - pinned, flags,</span>
<span class="p_add">+					    pvec + pinned, NULL);</span>
 		if (ret &lt; 0)
 			break;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_userptr.c b/drivers/gpu/drm/i915/i915_gem_userptr.c</span>
<span class="p_header">index c6f780f5abc9..d5d2e69baabe 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_userptr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_userptr.c</span>
<span class="p_chunk">@@ -518,7 +518,7 @@</span> <span class="p_context"> __i915_gem_userptr_get_pages_worker(struct work_struct *_work)</span>
 			down_read(&amp;mm-&gt;mmap_sem);
 			while (pinned &lt; npages) {
 				ret = get_user_pages_remote
<span class="p_del">-					(work-&gt;task, mm,</span>
<span class="p_add">+					(work-&gt;task, mm, NULL,</span>
 					 obj-&gt;userptr.ptr + pinned * PAGE_SIZE,
 					 npages - pinned,
 					 flags,
<span class="p_header">diff --git a/drivers/infiniband/core/umem_odp.c b/drivers/infiniband/core/umem_odp.c</span>
<span class="p_header">index 1f0fe3217f23..cb4e805dc0ac 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem_odp.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem_odp.c</span>
<span class="p_chunk">@@ -577,7 +577,7 @@</span> <span class="p_context"> int ib_umem_odp_map_dma_pages(struct ib_umem *umem, u64 user_virt, u64 bcnt,</span>
 		 * cases).
 		 */
 		npages = get_user_pages_remote(owning_process, owning_mm,
<span class="p_del">-				user_virt, gup_num_pages,</span>
<span class="p_add">+				NULL, user_virt, gup_num_pages,</span>
 				flags, local_page_list, NULL);
 		up_read(&amp;owning_mm-&gt;mmap_sem);
 
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index dbc2dd2f0829..3d9ee5a52ca4 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -208,7 +208,7 @@</span> <span class="p_context"> static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,</span>
 	 * We are doing an exec().  &#39;current&#39; is the process
 	 * doing the exec and bprm-&gt;mm is the new process&#39;s mm.
 	 */
<span class="p_del">-	ret = get_user_pages_remote(current, bprm-&gt;mm, pos, 1, gup_flags,</span>
<span class="p_add">+	ret = get_user_pages_remote(current, bprm-&gt;mm, NULL, pos, 1, gup_flags,</span>
 			&amp;page, NULL);
 	if (ret &lt;= 0)
 		return NULL;
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index ca651ac00660..e9542240408c 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -113,6 +113,11 @@</span> <span class="p_context"> struct pid_entry {</span>
 	union proc_op op;
 };
 
<span class="p_add">+struct mem_private {</span>
<span class="p_add">+	struct mm_struct *mm;</span>
<span class="p_add">+	const struct cred *object_cred;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 #define NOD(NAME, MODE, IOP, FOP, OP) {			\
 	.name = (NAME),					\
 	.len  = sizeof(NAME) - 1,			\
<span class="p_chunk">@@ -252,7 +257,7 @@</span> <span class="p_context"> static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,</span>
 	 * Inherently racy -- command line shares address space
 	 * with code and data.
 	 */
<span class="p_del">-	rv = access_remote_vm(mm, arg_end - 1, &amp;c, 1, 0);</span>
<span class="p_add">+	rv = access_remote_vm(mm, NULL, arg_end - 1, &amp;c, 1, 0);</span>
 	if (rv &lt;= 0)
 		goto out_free_page;
 
<span class="p_chunk">@@ -270,7 +275,8 @@</span> <span class="p_context"> static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,</span>
 			int nr_read;
 
 			_count = min3(count, len, PAGE_SIZE);
<span class="p_del">-			nr_read = access_remote_vm(mm, p, page, _count, 0);</span>
<span class="p_add">+			nr_read = access_remote_vm(mm, NULL, p, page,</span>
<span class="p_add">+						   _count, 0);</span>
 			if (nr_read &lt; 0)
 				rv = nr_read;
 			if (nr_read &lt;= 0)
<span class="p_chunk">@@ -305,7 +311,8 @@</span> <span class="p_context"> static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,</span>
 			bool final;
 
 			_count = min3(count, len, PAGE_SIZE);
<span class="p_del">-			nr_read = access_remote_vm(mm, p, page, _count, 0);</span>
<span class="p_add">+			nr_read = access_remote_vm(mm, NULL, p, page,</span>
<span class="p_add">+						   _count, 0);</span>
 			if (nr_read &lt; 0)
 				rv = nr_read;
 			if (nr_read &lt;= 0)
<span class="p_chunk">@@ -354,7 +361,8 @@</span> <span class="p_context"> static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,</span>
 			bool final;
 
 			_count = min3(count, len, PAGE_SIZE);
<span class="p_del">-			nr_read = access_remote_vm(mm, p, page, _count, 0);</span>
<span class="p_add">+			nr_read = access_remote_vm(mm, NULL, p, page,</span>
<span class="p_add">+						   _count, 0);</span>
 			if (nr_read &lt; 0)
 				rv = nr_read;
 			if (nr_read &lt;= 0)
<span class="p_chunk">@@ -784,13 +792,15 @@</span> <span class="p_context"> static const struct file_operations proc_single_file_operations = {</span>
 };
 
 
<span class="p_del">-struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)</span>
<span class="p_add">+struct mm_struct *proc_mem_open(struct inode *inode,</span>
<span class="p_add">+				const struct cred **object_cred,</span>
<span class="p_add">+				unsigned int mode)</span>
 {
 	struct task_struct *task = get_proc_task(inode);
 	struct mm_struct *mm = ERR_PTR(-ESRCH);
 
 	if (task) {
<span class="p_del">-		mm = mm_access(task, mode | PTRACE_MODE_FSCREDS);</span>
<span class="p_add">+		mm = mm_access(task, object_cred, mode | PTRACE_MODE_FSCREDS);</span>
 		put_task_struct(task);
 
 		if (!IS_ERR_OR_NULL(mm)) {
<span class="p_chunk">@@ -806,7 +816,7 @@</span> <span class="p_context"> struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)</span>
 
 static int __mem_open(struct inode *inode, struct file *file, unsigned int mode)
 {
<span class="p_del">-	struct mm_struct *mm = proc_mem_open(inode, mode);</span>
<span class="p_add">+	struct mm_struct *mm = proc_mem_open(inode, NULL, mode);</span>
 
 	if (IS_ERR(mm))
 		return PTR_ERR(mm);
<span class="p_chunk">@@ -817,22 +827,41 @@</span> <span class="p_context"> static int __mem_open(struct inode *inode, struct file *file, unsigned int mode)</span>
 
 static int mem_open(struct inode *inode, struct file *file)
 {
<span class="p_del">-	int ret = __mem_open(inode, file, PTRACE_MODE_ATTACH);</span>
<span class="p_add">+	struct mem_private *private = kmalloc(sizeof(*private), GFP_KERNEL);</span>
<span class="p_add">+	struct mm_struct *mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!private)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	mm = proc_mem_open(inode, &amp;private-&gt;object_cred, PTRACE_MODE_ATTACH);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mm)</span>
<span class="p_add">+		private-&gt;object_cred = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ERR(mm)) {</span>
<span class="p_add">+		kfree(private);</span>
<span class="p_add">+		return PTR_ERR(mm);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	private-&gt;mm = mm;</span>
<span class="p_add">+	file-&gt;private_data = private;</span>
 
 	/* OK to pass negative loff_t, we can catch out-of-range */
 	file-&gt;f_mode |= FMODE_UNSIGNED_OFFSET;
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static ssize_t mem_rw(struct file *file, char __user *buf,
 			size_t count, loff_t *ppos, int write)
 {
<span class="p_del">-	struct mm_struct *mm = file-&gt;private_data;</span>
<span class="p_add">+	struct mem_private *private = file-&gt;private_data;</span>
<span class="p_add">+	struct mm_struct *mm = private-&gt;mm;</span>
 	unsigned long addr = *ppos;
 	ssize_t copied;
 	char *page;
 	unsigned int flags;
<span class="p_add">+	struct gup_creds creds;</span>
 
 	if (!mm)
 		return 0;
<span class="p_chunk">@@ -850,6 +879,9 @@</span> <span class="p_context"> static ssize_t mem_rw(struct file *file, char __user *buf,</span>
 	if (write)
 		flags |= FOLL_WRITE;
 
<span class="p_add">+	creds.subject = file-&gt;f_cred;</span>
<span class="p_add">+	creds.object = private-&gt;object_cred;</span>
<span class="p_add">+</span>
 	while (count &gt; 0) {
 		int this_len = min_t(int, count, PAGE_SIZE);
 
<span class="p_chunk">@@ -858,7 +890,8 @@</span> <span class="p_context"> static ssize_t mem_rw(struct file *file, char __user *buf,</span>
 			break;
 		}
 
<span class="p_del">-		this_len = access_remote_vm(mm, addr, page, this_len, flags);</span>
<span class="p_add">+		this_len = access_remote_vm(mm, &amp;creds, addr, page, this_len,</span>
<span class="p_add">+					    flags);</span>
 		if (!this_len) {
 			if (!copied)
 				copied = -EIO;
<span class="p_chunk">@@ -913,9 +946,13 @@</span> <span class="p_context"> loff_t mem_lseek(struct file *file, loff_t offset, int orig)</span>
 
 static int mem_release(struct inode *inode, struct file *file)
 {
<span class="p_del">-	struct mm_struct *mm = file-&gt;private_data;</span>
<span class="p_del">-	if (mm)</span>
<span class="p_del">-		mmdrop(mm);</span>
<span class="p_add">+	struct mem_private *private = file-&gt;private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (private-&gt;mm) {</span>
<span class="p_add">+		mmdrop(private-&gt;mm);</span>
<span class="p_add">+		put_cred(private-&gt;object_cred);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kfree(private);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -970,7 +1007,8 @@</span> <span class="p_context"> static ssize_t environ_read(struct file *file, char __user *buf,</span>
 		max_len = min_t(size_t, PAGE_SIZE, count);
 		this_len = min(max_len, this_len);
 
<span class="p_del">-		retval = access_remote_vm(mm, (env_start + src), page, this_len, 0);</span>
<span class="p_add">+		retval = access_remote_vm(mm, NULL, (env_start + src),</span>
<span class="p_add">+					  page, this_len, 0);</span>
 
 		if (retval &lt;= 0) {
 			ret = retval;
<span class="p_chunk">@@ -1888,7 +1926,7 @@</span> <span class="p_context"> static int map_files_d_revalidate(struct dentry *dentry, unsigned int flags)</span>
 	if (!task)
 		goto out_notask;
 
<span class="p_del">-	mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);</span>
<span class="p_add">+	mm = mm_access(task, NULL, PTRACE_MODE_READ_FSCREDS);</span>
 	if (IS_ERR_OR_NULL(mm))
 		goto out;
 
<span class="p_header">diff --git a/fs/proc/internal.h b/fs/proc/internal.h</span>
<span class="p_header">index 5378441ec1b7..1b5b737ba5a7 100644</span>
<span class="p_header">--- a/fs/proc/internal.h</span>
<span class="p_header">+++ b/fs/proc/internal.h</span>
<span class="p_chunk">@@ -288,7 +288,9 @@</span> <span class="p_context"> struct proc_maps_private {</span>
 #endif
 };
 
<span class="p_del">-struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode);</span>
<span class="p_add">+struct mm_struct *proc_mem_open(struct inode *inode,</span>
<span class="p_add">+				const struct cred **object_cred,</span>
<span class="p_add">+				unsigned int mode);</span>
 
 extern const struct file_operations proc_pid_maps_operations;
 extern const struct file_operations proc_tid_maps_operations;
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index 35b92d81692f..fc5024dd8ee6 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -232,7 +232,7 @@</span> <span class="p_context"> static int proc_maps_open(struct inode *inode, struct file *file,</span>
 		return -ENOMEM;
 
 	priv-&gt;inode = inode;
<span class="p_del">-	priv-&gt;mm = proc_mem_open(inode, PTRACE_MODE_READ);</span>
<span class="p_add">+	priv-&gt;mm = proc_mem_open(inode, NULL, PTRACE_MODE_READ);</span>
 	if (IS_ERR(priv-&gt;mm)) {
 		int err = PTR_ERR(priv-&gt;mm);
 
<span class="p_chunk">@@ -1436,7 +1436,7 @@</span> <span class="p_context"> static int pagemap_open(struct inode *inode, struct file *file)</span>
 {
 	struct mm_struct *mm;
 
<span class="p_del">-	mm = proc_mem_open(inode, PTRACE_MODE_READ);</span>
<span class="p_add">+	mm = proc_mem_open(inode, NULL, PTRACE_MODE_READ);</span>
 	if (IS_ERR(mm))
 		return PTR_ERR(mm);
 	file-&gt;private_data = mm;
<span class="p_header">diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c</span>
<span class="p_header">index 37175621e890..cb6e0f612c6b 100644</span>
<span class="p_header">--- a/fs/proc/task_nommu.c</span>
<span class="p_header">+++ b/fs/proc/task_nommu.c</span>
<span class="p_chunk">@@ -279,7 +279,7 @@</span> <span class="p_context"> static int maps_open(struct inode *inode, struct file *file,</span>
 		return -ENOMEM;
 
 	priv-&gt;inode = inode;
<span class="p_del">-	priv-&gt;mm = proc_mem_open(inode, PTRACE_MODE_READ);</span>
<span class="p_add">+	priv-&gt;mm = proc_mem_open(inode, NULL, PTRACE_MODE_READ);</span>
 	if (IS_ERR(priv-&gt;mm)) {
 		int err = PTR_ERR(priv-&gt;mm);
 
<span class="p_header">diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h</span>
<span class="p_header">index 558adfa5c8a8..cfa2d454fb3f 100644</span>
<span class="p_header">--- a/include/linux/lsm_hooks.h</span>
<span class="p_header">+++ b/include/linux/lsm_hooks.h</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/security.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/rculist.h&gt;
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
 
 /**
  * Security hooks for program execution operations.
<span class="p_chunk">@@ -1181,6 +1182,11 @@</span> <span class="p_context"></span>
  *	to the @parent process for tracing.
  *	@parent contains the task_struct structure for debugger process.
  *	Return 0 if permission is granted.
<span class="p_add">+ * @forced_write:</span>
<span class="p_add">+ *	Check whether @creds-&gt;subject is permitted to forcibly write to the</span>
<span class="p_add">+ *	non-writable mapping @vma that belongs to a process with objective</span>
<span class="p_add">+ *	credentials @creds-&gt;object.</span>
<span class="p_add">+ *	Return 0 if permission is granted.</span>
  * @capget:
  *	Get the @effective, @inheritable, and @permitted capability sets for
  *	the @target process.  The hook may also perform permission checking to
<span class="p_chunk">@@ -1344,6 +1350,8 @@</span> <span class="p_context"> union security_list_options {</span>
 	int (*ptrace_access_check)(struct task_struct *child,
 					unsigned int mode);
 	int (*ptrace_traceme)(struct task_struct *parent);
<span class="p_add">+	int (*forced_write)(struct vm_area_struct *vma,</span>
<span class="p_add">+			const struct gup_creds *creds);</span>
 	int (*capget)(struct task_struct *target, kernel_cap_t *effective,
 			kernel_cap_t *inheritable, kernel_cap_t *permitted);
 	int (*capset)(struct cred *new, const struct cred *old,
<span class="p_chunk">@@ -1661,6 +1669,7 @@</span> <span class="p_context"> struct security_hook_heads {</span>
 	struct list_head binder_transfer_file;
 	struct list_head ptrace_access_check;
 	struct list_head ptrace_traceme;
<span class="p_add">+	struct list_head forced_write;</span>
 	struct list_head capget;
 	struct list_head capset;
 	struct list_head capable;
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index a92c8d73aeaf..e67639d6661a 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/page_ext.h&gt;
 #include &lt;linux/err.h&gt;
 #include &lt;linux/page_ref.h&gt;
<span class="p_add">+#include &lt;linux/cred.h&gt;</span>
 
 struct mempolicy;
 struct anon_vma;
<span class="p_chunk">@@ -1266,12 +1267,25 @@</span> <span class="p_context"> static inline int fixup_user_fault(struct task_struct *tsk,</span>
 }
 #endif
 
<span class="p_add">+/*</span>
<span class="p_add">+ * used to pass security information to LSMs through get_user_pages* for forced</span>
<span class="p_add">+ * writes (FOLL_WRITE|FOLL_FORCE)</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct gup_creds {</span>
<span class="p_add">+	const struct cred *subject; /* who is trying to write? */</span>
<span class="p_add">+	const struct cred *object; /* whose memory is written to? */</span>
<span class="p_add">+};</span>
<span class="p_add">+/* use when current is writing to its own memory */</span>
<span class="p_add">+#define GUP_CREDS_CURRENT ((struct gup_creds *)0x1UL)</span>
<span class="p_add">+</span>
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len,
 		unsigned int gup_flags);
<span class="p_del">-extern int access_remote_vm(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-		void *buf, int len, unsigned int gup_flags);</span>
<span class="p_add">+extern int access_remote_vm(struct mm_struct *mm,</span>
<span class="p_add">+		const struct gup_creds *creds, unsigned long addr, void *buf,</span>
<span class="p_add">+		int len, unsigned int gup_flags);</span>
 
 long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
<span class="p_add">+			    const struct gup_creds *creds,</span>
 			    unsigned long start, unsigned long nr_pages,
 			    unsigned int gup_flags, struct page **pages,
 			    struct vm_area_struct **vmas);
<span class="p_chunk">@@ -1281,6 +1295,7 @@</span> <span class="p_context"> long get_user_pages(unsigned long start, unsigned long nr_pages,</span>
 long get_user_pages_locked(unsigned long start, unsigned long nr_pages,
 		    unsigned int gup_flags, struct page **pages, int *locked);
 long __get_user_pages_unlocked(struct task_struct *tsk, struct mm_struct *mm,
<span class="p_add">+			       const struct gup_creds *creds,</span>
 			       unsigned long start, unsigned long nr_pages,
 			       struct page **pages, unsigned int gup_flags);
 long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index 348f51b0ec92..c8d6e85292c5 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -2913,7 +2913,9 @@</span> <span class="p_context"> extern struct mm_struct *get_task_mm(struct task_struct *task);</span>
  * and ptrace_may_access with the mode parameter passed to it
  * succeeds.
  */
<span class="p_del">-extern struct mm_struct *mm_access(struct task_struct *task, unsigned int mode);</span>
<span class="p_add">+extern struct mm_struct *mm_access(struct task_struct *task,</span>
<span class="p_add">+				   const struct cred **object_cred,</span>
<span class="p_add">+				   unsigned int mode);</span>
 /* Remove the current tasks stale references to the old mm_struct */
 extern void mm_release(struct task_struct *, struct mm_struct *);
 
<span class="p_header">diff --git a/include/linux/security.h b/include/linux/security.h</span>
<span class="p_header">index c2125e9093e8..e9229e263d39 100644</span>
<span class="p_header">--- a/include/linux/security.h</span>
<span class="p_header">+++ b/include/linux/security.h</span>
<span class="p_chunk">@@ -193,6 +193,8 @@</span> <span class="p_context"> int security_binder_transfer_file(struct task_struct *from,</span>
 				  struct task_struct *to, struct file *file);
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode);
 int security_ptrace_traceme(struct task_struct *parent);
<span class="p_add">+int security_forced_write(struct vm_area_struct *vma,</span>
<span class="p_add">+			  const struct gup_creds *creds);</span>
 int security_capget(struct task_struct *target,
 		    kernel_cap_t *effective,
 		    kernel_cap_t *inheritable,
<span class="p_chunk">@@ -429,6 +431,12 @@</span> <span class="p_context"> static inline int security_ptrace_traceme(struct task_struct *parent)</span>
 	return cap_ptrace_traceme(parent);
 }
 
<span class="p_add">+static inline int security_forced_write(struct vm_area_struct *vma,</span>
<span class="p_add">+					const struct gup_creds *creds)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int security_capget(struct task_struct *target,
 				   kernel_cap_t *effective,
 				   kernel_cap_t *inheritable,
<span class="p_header">diff --git a/kernel/events/uprobes.c b/kernel/events/uprobes.c</span>
<span class="p_header">index f9ec9add2164..7d91c732cfc5 100644</span>
<span class="p_header">--- a/kernel/events/uprobes.c</span>
<span class="p_header">+++ b/kernel/events/uprobes.c</span>
<span class="p_chunk">@@ -300,8 +300,8 @@</span> <span class="p_context"> int uprobe_write_opcode(struct mm_struct *mm, unsigned long vaddr,</span>
 
 retry:
 	/* Read the page with vaddr into memory */
<span class="p_del">-	ret = get_user_pages_remote(NULL, mm, vaddr, 1, FOLL_FORCE, &amp;old_page,</span>
<span class="p_del">-			&amp;vma);</span>
<span class="p_add">+	ret = get_user_pages_remote(NULL, mm, NULL, vaddr, 1, FOLL_FORCE,</span>
<span class="p_add">+			&amp;old_page, &amp;vma);</span>
 	if (ret &lt;= 0)
 		return ret;
 
<span class="p_chunk">@@ -1711,8 +1711,8 @@</span> <span class="p_context"> static int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr)</span>
 	 * but we treat this as a &#39;remote&#39; access since it is
 	 * essentially a kernel access to the memory.
 	 */
<span class="p_del">-	result = get_user_pages_remote(NULL, mm, vaddr, 1, FOLL_FORCE, &amp;page,</span>
<span class="p_del">-			NULL);</span>
<span class="p_add">+	result = get_user_pages_remote(NULL, mm, NULL, vaddr, 1, FOLL_FORCE,</span>
<span class="p_add">+				       &amp;page, NULL);</span>
 	if (result &lt; 0)
 		return result;
 
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index 623259fc794d..997432afad63 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -993,7 +993,8 @@</span> <span class="p_context"> struct mm_struct *get_task_mm(struct task_struct *task)</span>
 }
 EXPORT_SYMBOL_GPL(get_task_mm);
 
<span class="p_del">-struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)</span>
<span class="p_add">+struct mm_struct *mm_access(struct task_struct *task,</span>
<span class="p_add">+			    const struct cred **object_cred, unsigned int mode)</span>
 {
 	struct mm_struct *mm;
 	int err;
<span class="p_chunk">@@ -1008,6 +1009,9 @@</span> <span class="p_context"> struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)</span>
 		mmput(mm);
 		mm = ERR_PTR(-EACCES);
 	}
<span class="p_add">+	if (!IS_ERR_OR_NULL(mm) &amp;&amp; object_cred)</span>
<span class="p_add">+		*object_cred = get_task_cred(task);</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;task-&gt;signal-&gt;cred_guard_mutex);
 
 	return mm;
<span class="p_header">diff --git a/mm/gup.c b/mm/gup.c</span>
<span class="p_header">index ec4f82704b6f..b702e3929fa8 100644</span>
<span class="p_header">--- a/mm/gup.c</span>
<span class="p_header">+++ b/mm/gup.c</span>
<span class="p_chunk">@@ -2,6 +2,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/err.h&gt;
 #include &lt;linux/spinlock.h&gt;
<span class="p_add">+#include &lt;linux/security.h&gt;</span>
 
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/memremap.h&gt;
<span class="p_chunk">@@ -426,7 +427,15 @@</span> <span class="p_context"> static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,</span>
 	return 0;
 }
 
<span class="p_del">-static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * @creds-&gt;subject is the subject on whose behalf memory is accessed.</span>
<span class="p_add">+ * @creds-&gt;object contains the objective credentials of the target task at the</span>
<span class="p_add">+ * time the mm_struct was looked up.</span>
<span class="p_add">+ * @creds may be NULL if FOLL_FORCE is unset or FOLL_WRITE is unset.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int check_vma_flags(struct vm_area_struct *vma,</span>
<span class="p_add">+			   const struct gup_creds *creds,</span>
<span class="p_add">+			   unsigned long gup_flags)</span>
 {
 	vm_flags_t vm_flags = vma-&gt;vm_flags;
 	int write = (gup_flags &amp; FOLL_WRITE);
<span class="p_chunk">@@ -436,9 +445,18 @@</span> <span class="p_context"> static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)</span>
 		return -EFAULT;
 
 	if (write) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If one of the cred parameters is missing and the WRITE and</span>
<span class="p_add">+		 * FORCE flags are set, that&#39;s a kernel bug.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (WARN_ON((gup_flags &amp; FOLL_FORCE) &amp;&amp; creds == NULL))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+</span>
 		if (!(vm_flags &amp; VM_WRITE)) {
 			if (!(gup_flags &amp; FOLL_FORCE))
 				return -EFAULT;
<span class="p_add">+			if (security_forced_write(vma, creds))</span>
<span class="p_add">+				return -EFAULT;</span>
 			/*
 			 * We used to let the write,force case do COW in a
 			 * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could
<span class="p_chunk">@@ -527,6 +545,7 @@</span> <span class="p_context"> static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)</span>
  * you need some special @gup_flags.
  */
 static long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
<span class="p_add">+		const struct gup_creds *creds,</span>
 		unsigned long start, unsigned long nr_pages,
 		unsigned int gup_flags, struct page **pages,
 		struct vm_area_struct **vmas, int *nonblocking)
<span class="p_chunk">@@ -567,7 +586,7 @@</span> <span class="p_context"> static long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span>
 				goto next_page;
 			}
 
<span class="p_del">-			if (!vma || check_vma_flags(vma, gup_flags))</span>
<span class="p_add">+			if (!vma || check_vma_flags(vma, creds, gup_flags))</span>
 				return i ? : -EFAULT;
 			if (is_vm_hugetlb_page(vma)) {
 				i = follow_hugetlb_page(mm, vma, pages, vmas,
<span class="p_chunk">@@ -736,6 +755,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(fixup_user_fault);</span>
 
 static __always_inline long __get_user_pages_locked(struct task_struct *tsk,
 						struct mm_struct *mm,
<span class="p_add">+						const struct gup_creds *creds,</span>
 						unsigned long start,
 						unsigned long nr_pages,
 						struct page **pages,
<span class="p_chunk">@@ -759,8 +779,8 @@</span> <span class="p_context"> static __always_inline long __get_user_pages_locked(struct task_struct *tsk,</span>
 	pages_done = 0;
 	lock_dropped = false;
 	for (;;) {
<span class="p_del">-		ret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,</span>
<span class="p_del">-				       vmas, locked);</span>
<span class="p_add">+		ret = __get_user_pages(tsk, mm, creds, start, nr_pages, flags,</span>
<span class="p_add">+				       pages, vmas, locked);</span>
 		if (!locked)
 			/* VM_FAULT_RETRY couldn&#39;t trigger, bypass */
 			return ret;
<span class="p_chunk">@@ -799,8 +819,8 @@</span> <span class="p_context"> static __always_inline long __get_user_pages_locked(struct task_struct *tsk,</span>
 		*locked = 1;
 		lock_dropped = true;
 		down_read(&amp;mm-&gt;mmap_sem);
<span class="p_del">-		ret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,</span>
<span class="p_del">-				       pages, NULL, NULL);</span>
<span class="p_add">+		ret = __get_user_pages(tsk, mm, creds, start, 1,</span>
<span class="p_add">+				       flags | FOLL_TRIED, pages, NULL, NULL);</span>
 		if (ret != 1) {
 			BUG_ON(ret &gt; 1);
 			if (!pages_done)
<span class="p_chunk">@@ -850,9 +870,9 @@</span> <span class="p_context"> long get_user_pages_locked(unsigned long start, unsigned long nr_pages,</span>
 			   unsigned int gup_flags, struct page **pages,
 			   int *locked)
 {
<span class="p_del">-	return __get_user_pages_locked(current, current-&gt;mm, start, nr_pages,</span>
<span class="p_del">-				       pages, NULL, locked, true,</span>
<span class="p_del">-				       gup_flags | FOLL_TOUCH);</span>
<span class="p_add">+	return __get_user_pages_locked(current, current-&gt;mm, GUP_CREDS_CURRENT,</span>
<span class="p_add">+				       start, nr_pages, pages, NULL, locked,</span>
<span class="p_add">+				       true, gup_flags | FOLL_TOUCH);</span>
 }
 EXPORT_SYMBOL(get_user_pages_locked);
 
<span class="p_chunk">@@ -867,6 +887,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(get_user_pages_locked);</span>
  * respectively.
  */
 __always_inline long __get_user_pages_unlocked(struct task_struct *tsk, struct mm_struct *mm,
<span class="p_add">+					       const struct gup_creds *creds,</span>
 					       unsigned long start, unsigned long nr_pages,
 					       struct page **pages, unsigned int gup_flags)
 {
<span class="p_chunk">@@ -874,8 +895,8 @@</span> <span class="p_context"> __always_inline long __get_user_pages_unlocked(struct task_struct *tsk, struct m</span>
 	int locked = 1;
 
 	down_read(&amp;mm-&gt;mmap_sem);
<span class="p_del">-	ret = __get_user_pages_locked(tsk, mm, start, nr_pages, pages, NULL,</span>
<span class="p_del">-				      &amp;locked, false, gup_flags);</span>
<span class="p_add">+	ret = __get_user_pages_locked(tsk, mm, creds, start, nr_pages, pages,</span>
<span class="p_add">+				      NULL, &amp;locked, false, gup_flags);</span>
 	if (locked)
 		up_read(&amp;mm-&gt;mmap_sem);
 	return ret;
<span class="p_chunk">@@ -902,7 +923,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(__get_user_pages_unlocked);</span>
 long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,
 			     struct page **pages, unsigned int gup_flags)
 {
<span class="p_del">-	return __get_user_pages_unlocked(current, current-&gt;mm, start, nr_pages,</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * None of the current callers actually pass write=1 together with</span>
<span class="p_add">+	 * force=1, but pass in current_cred() and current_read_cred() in case</span>
<span class="p_add">+	 * that changes in the future.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return __get_user_pages_unlocked(current, current-&gt;mm,</span>
<span class="p_add">+					 GUP_CREDS_CURRENT, start, nr_pages,</span>
 					 pages, gup_flags | FOLL_TOUCH);
 }
 EXPORT_SYMBOL(get_user_pages_unlocked);
<span class="p_chunk">@@ -961,12 +988,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(get_user_pages_unlocked);</span>
  * FAULT_FLAG_ALLOW_RETRY to handle_mm_fault.
  */
 long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
<span class="p_add">+		const struct gup_creds *creds,</span>
 		unsigned long start, unsigned long nr_pages,
 		unsigned int gup_flags, struct page **pages,
 		struct vm_area_struct **vmas)
 {
<span class="p_del">-	return __get_user_pages_locked(tsk, mm, start, nr_pages, pages, vmas,</span>
<span class="p_del">-				       NULL, false,</span>
<span class="p_add">+	return __get_user_pages_locked(tsk, mm, creds, start, nr_pages, pages,</span>
<span class="p_add">+				       vmas, NULL, false,</span>
 				       gup_flags | FOLL_TOUCH | FOLL_REMOTE);
 }
 EXPORT_SYMBOL(get_user_pages_remote);
<span class="p_chunk">@@ -981,9 +1009,9 @@</span> <span class="p_context"> long get_user_pages(unsigned long start, unsigned long nr_pages,</span>
 		unsigned int gup_flags, struct page **pages,
 		struct vm_area_struct **vmas)
 {
<span class="p_del">-	return __get_user_pages_locked(current, current-&gt;mm, start, nr_pages,</span>
<span class="p_del">-				       pages, vmas, NULL, false,</span>
<span class="p_del">-				       gup_flags | FOLL_TOUCH);</span>
<span class="p_add">+	return __get_user_pages_locked(current, current-&gt;mm, GUP_CREDS_CURRENT,</span>
<span class="p_add">+				       start, nr_pages, pages, vmas, NULL,</span>
<span class="p_add">+				       false, gup_flags | FOLL_TOUCH);</span>
 }
 EXPORT_SYMBOL(get_user_pages);
 
<span class="p_chunk">@@ -1041,7 +1069,7 @@</span> <span class="p_context"> long populate_vma_page_range(struct vm_area_struct *vma,</span>
 	 * We made sure addr is within a VMA, so the following will
 	 * not result in a stack expansion that recurses back here.
 	 */
<span class="p_del">-	return __get_user_pages(current, mm, start, nr_pages, gup_flags,</span>
<span class="p_add">+	return __get_user_pages(current, mm, NULL, start, nr_pages, gup_flags,</span>
 				NULL, NULL, nonblocking);
 }
 
<span class="p_chunk">@@ -1127,7 +1155,7 @@</span> <span class="p_context"> struct page *get_dump_page(unsigned long addr)</span>
 	struct vm_area_struct *vma;
 	struct page *page;
 
<span class="p_del">-	if (__get_user_pages(current, current-&gt;mm, addr, 1,</span>
<span class="p_add">+	if (__get_user_pages(current, current-&gt;mm, NULL, addr, 1,</span>
 			     FOLL_FORCE | FOLL_DUMP | FOLL_GET, &amp;page, &amp;vma,
 			     NULL) &lt; 1)
 		return NULL;
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index e18c57bdc75c..2a8ec5ab7550 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -3869,6 +3869,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(generic_access_phys);</span>
  * given task for page fault accounting.
  */
 static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
<span class="p_add">+		const struct gup_creds *creds,</span>
 		unsigned long addr, void *buf, int len, unsigned int gup_flags)
 {
 	struct vm_area_struct *vma;
<span class="p_chunk">@@ -3882,8 +3883,8 @@</span> <span class="p_context"> static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span>
 		void *maddr;
 		struct page *page = NULL;
 
<span class="p_del">-		ret = get_user_pages_remote(tsk, mm, addr, 1,</span>
<span class="p_del">-				gup_flags, &amp;page, &amp;vma);</span>
<span class="p_add">+		ret = get_user_pages_remote(tsk, mm, creds,</span>
<span class="p_add">+				addr, 1, gup_flags, &amp;page, &amp;vma);</span>
 		if (ret &lt;= 0) {
 #ifndef CONFIG_HAVE_IOREMAP_PROT
 			break;
<span class="p_chunk">@@ -3939,29 +3940,32 @@</span> <span class="p_context"> static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span>
  *
  * The caller must hold a reference on @mm.
  */
<span class="p_del">-int access_remote_vm(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-		void *buf, int len, unsigned int gup_flags)</span>
<span class="p_add">+int access_remote_vm(struct mm_struct *mm, const struct gup_creds *creds,</span>
<span class="p_add">+		unsigned long addr, void *buf, int len, unsigned int gup_flags)</span>
 {
<span class="p_del">-	return __access_remote_vm(NULL, mm, addr, buf, len, gup_flags);</span>
<span class="p_add">+	return __access_remote_vm(NULL, mm, creds, addr, buf, len, gup_flags);</span>
 }
 
 /*
  * Access another process&#39; address space.
  * Source/target buffer must be kernel space,
<span class="p_del">- * Do not walk the page table directly, use get_user_pages</span>
<span class="p_add">+ * Do not walk the page table directly, use get_user_pages.</span>
<span class="p_add">+ * @tsk must be ptrace-stopped by current.</span>
  */
 int access_process_vm(struct task_struct *tsk, unsigned long addr,
 		void *buf, int len, unsigned int gup_flags)
 {
 	struct mm_struct *mm;
 	int ret;
<span class="p_add">+	struct gup_creds creds;</span>
 
 	mm = get_task_mm(tsk);
 	if (!mm)
 		return 0;
<span class="p_del">-</span>
<span class="p_del">-	ret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);</span>
<span class="p_del">-</span>
<span class="p_add">+	creds.subject = current_cred();</span>
<span class="p_add">+	creds.object = get_task_cred(tsk);</span>
<span class="p_add">+	ret = __access_remote_vm(tsk, mm, &amp;creds, addr, buf, len, gup_flags);</span>
<span class="p_add">+	put_cred(creds.object);</span>
 	mmput(mm);
 
 	return ret;
<span class="p_header">diff --git a/mm/nommu.c b/mm/nommu.c</span>
<span class="p_header">index 8b8faaf2a9e9..222cebcdc231 100644</span>
<span class="p_header">--- a/mm/nommu.c</span>
<span class="p_header">+++ b/mm/nommu.c</span>
<span class="p_chunk">@@ -177,13 +177,14 @@</span> <span class="p_context"> long get_user_pages_locked(unsigned long start, unsigned long nr_pages,</span>
 EXPORT_SYMBOL(get_user_pages_locked);
 
 long __get_user_pages_unlocked(struct task_struct *tsk, struct mm_struct *mm,
<span class="p_add">+			       const struct gup_creds *creds,</span>
 			       unsigned long start, unsigned long nr_pages,
 			       struct page **pages, unsigned int gup_flags)
 {
 	long ret;
 	down_read(&amp;mm-&gt;mmap_sem);
<span class="p_del">-	ret = __get_user_pages(tsk, mm, start, nr_pages, gup_flags, pages,</span>
<span class="p_del">-				NULL, NULL);</span>
<span class="p_add">+	ret = __get_user_pages(tsk, mm, start, nr_pages, gup_flags, pages, NULL,</span>
<span class="p_add">+			       NULL);</span>
 	up_read(&amp;mm-&gt;mmap_sem);
 	return ret;
 }
<span class="p_chunk">@@ -192,8 +193,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(__get_user_pages_unlocked);</span>
 long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,
 			     struct page **pages, unsigned int gup_flags)
 {
<span class="p_del">-	return __get_user_pages_unlocked(current, current-&gt;mm, start, nr_pages,</span>
<span class="p_del">-					 pages, gup_flags);</span>
<span class="p_add">+	return __get_user_pages_unlocked(current, current-&gt;mm, NULL,</span>
<span class="p_add">+					 start, nr_pages, pages, gup_flags);</span>
 }
 EXPORT_SYMBOL(get_user_pages_unlocked);
 
<span class="p_chunk">@@ -1851,8 +1852,8 @@</span> <span class="p_context"> static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span>
  *
  * The caller must hold a reference on @mm.
  */
<span class="p_del">-int access_remote_vm(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-		void *buf, int len, unsigned int gup_flags)</span>
<span class="p_add">+int access_remote_vm(struct mm_struct *mm, const struct gup_creds *creds,</span>
<span class="p_add">+		unsigned long addr, void *buf, int len, unsigned int gup_flags)</span>
 {
 	return __access_remote_vm(NULL, mm, addr, buf, len, gup_flags);
 }
<span class="p_header">diff --git a/mm/process_vm_access.c b/mm/process_vm_access.c</span>
<span class="p_header">index be8dc8d1edb9..671d53548bd9 100644</span>
<span class="p_header">--- a/mm/process_vm_access.c</span>
<span class="p_header">+++ b/mm/process_vm_access.c</span>
<span class="p_chunk">@@ -107,7 +107,7 @@</span> <span class="p_context"> static int process_vm_rw_single_vec(unsigned long addr,</span>
 		 * add FOLL_REMOTE because task/mm might not
 		 * current/current-&gt;mm
 		 */
<span class="p_del">-		pages = __get_user_pages_unlocked(task, mm, pa, pages,</span>
<span class="p_add">+		pages = __get_user_pages_unlocked(task, mm, NULL, pa, pages,</span>
 						  process_pages, flags);
 		if (pages &lt;= 0)
 			return -EFAULT;
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,</span>
 		goto free_proc_pages;
 	}
 
<span class="p_del">-	mm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);</span>
<span class="p_add">+	mm = mm_access(task, NULL, PTRACE_MODE_ATTACH_REALCREDS);</span>
 	if (!mm || IS_ERR(mm)) {
 		rc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;
 		/*
<span class="p_header">diff --git a/security/security.c b/security/security.c</span>
<span class="p_header">index f825304f04a7..00573d98aec0 100644</span>
<span class="p_header">--- a/security/security.c</span>
<span class="p_header">+++ b/security/security.c</span>
<span class="p_chunk">@@ -164,6 +164,19 @@</span> <span class="p_context"> int security_ptrace_traceme(struct task_struct *parent)</span>
 	return call_int_hook(ptrace_traceme, 0, parent);
 }
 
<span class="p_add">+int security_forced_write(struct vm_area_struct *vma,</span>
<span class="p_add">+			  const struct gup_creds *creds)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct gup_creds current_creds;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (creds == GUP_CREDS_CURRENT) {</span>
<span class="p_add">+		current_creds.subject = current_cred();</span>
<span class="p_add">+		current_creds.object = current_real_cred();</span>
<span class="p_add">+		creds = &amp;current_creds;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return call_int_hook(forced_write, 0, vma, creds);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int security_capget(struct task_struct *target,
 		     kernel_cap_t *effective,
 		     kernel_cap_t *inheritable,
<span class="p_chunk">@@ -1603,6 +1616,7 @@</span> <span class="p_context"> struct security_hook_heads security_hook_heads = {</span>
 		LIST_HEAD_INIT(security_hook_heads.ptrace_access_check),
 	.ptrace_traceme =
 		LIST_HEAD_INIT(security_hook_heads.ptrace_traceme),
<span class="p_add">+	.forced_write =	LIST_HEAD_INIT(security_hook_heads.forced_write),</span>
 	.capget =	LIST_HEAD_INIT(security_hook_heads.capget),
 	.capset =	LIST_HEAD_INIT(security_hook_heads.capset),
 	.capable =	LIST_HEAD_INIT(security_hook_heads.capable),
<span class="p_header">diff --git a/security/tomoyo/domain.c b/security/tomoyo/domain.c</span>
<span class="p_header">index 682b73af7766..9373fc0c7f8e 100644</span>
<span class="p_header">--- a/security/tomoyo/domain.c</span>
<span class="p_header">+++ b/security/tomoyo/domain.c</span>
<span class="p_chunk">@@ -880,8 +880,8 @@</span> <span class="p_context"> bool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,</span>
 	 * (represented by bprm).  &#39;current&#39; is the process doing
 	 * the execve().
 	 */
<span class="p_del">-	if (get_user_pages_remote(current, bprm-&gt;mm, pos, 1,</span>
<span class="p_del">-				FOLL_FORCE, &amp;page, NULL) &lt;= 0)</span>
<span class="p_add">+	if (get_user_pages_remote(current, bprm-&gt;mm, NULL, pos, 1, FOLL_FORCE,</span>
<span class="p_add">+				  &amp;page, NULL) &lt;= 0)</span>
 		return false;
 #else
 	page = bprm-&gt;page[pos / PAGE_SIZE];
<span class="p_header">diff --git a/virt/kvm/async_pf.c b/virt/kvm/async_pf.c</span>
<span class="p_header">index 8035cc1eb955..2ec0a4a0f502 100644</span>
<span class="p_header">--- a/virt/kvm/async_pf.c</span>
<span class="p_header">+++ b/virt/kvm/async_pf.c</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> static void async_pf_execute(struct work_struct *work)</span>
 	 * mm and might be done in another context, so we must
 	 * use FOLL_REMOTE.
 	 */
<span class="p_del">-	__get_user_pages_unlocked(NULL, mm, addr, 1, NULL,</span>
<span class="p_add">+	__get_user_pages_unlocked(NULL, mm, NULL, addr, 1, NULL,</span>
 			FOLL_WRITE | FOLL_REMOTE);
 
 	kvm_async_page_present_sync(vcpu, apf);
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 2907b7b78654..8df6969cfce1 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -1420,8 +1420,8 @@</span> <span class="p_context"> static int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,</span>
 		if (write_fault)
 			flags |= FOLL_WRITE;
 
<span class="p_del">-		npages = __get_user_pages_unlocked(current, current-&gt;mm, addr, 1,</span>
<span class="p_del">-						   page, flags);</span>
<span class="p_add">+		npages = __get_user_pages_unlocked(current, current-&gt;mm, NULL,</span>
<span class="p_add">+						   addr, 1, page, flags);</span>
 	}
 	if (npages != 1)
 		return npages;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



