
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.39 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.39</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 15, 2016, 5:32 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161215173256.GB26648@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9476637/mbox/"
   >mbox</a>
|
   <a href="/patch/9476637/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9476637/">/patch/9476637/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	085A660826 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 17:34:09 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id EECE6284AE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 17:34:08 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E1D22287CD; Thu, 15 Dec 2016 17:34:08 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CAE9D284AE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 17:34:07 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1757371AbcLORdx (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 15 Dec 2016 12:33:53 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:41206 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1757243AbcLORdR (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 15 Dec 2016 12:33:17 -0500
Received: from localhost (unknown [104.132.0.97])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id CEBA9BC5;
	Thu, 15 Dec 2016 17:32:50 +0000 (UTC)
Date: Thu, 15 Dec 2016 09:32:56 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.39
Message-ID: &lt;20161215173256.GB26648@kroah.com&gt;
References: &lt;20161215173250.GA26648@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161215173250.GA26648@kroah.com&gt;
User-Agent: Mutt/1.7.2 (2016-11-26)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 15, 2016, 5:32 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 6876efe0d735..88d26a632bef 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 38</span>
<span class="p_add">+SUBLEVEL = 39</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm64/include/asm/futex.h b/arch/arm64/include/asm/futex.h</span>
<span class="p_header">index 007a69fc4f40..5f3ab8c1db55 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/futex.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/futex.h</span>
<span class="p_chunk">@@ -121,6 +121,7 @@</span> <span class="p_context"> futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,</span>
 		return -EFAULT;
 
 	asm volatile(&quot;// futex_atomic_cmpxchg_inatomic\n&quot;
<span class="p_add">+ALTERNATIVE(&quot;nop&quot;, SET_PSTATE_PAN(0), ARM64_HAS_PAN, CONFIG_ARM64_PAN)</span>
 &quot;	prfm	pstl1strm, %2\n&quot;
 &quot;1:	ldxr	%w1, %2\n&quot;
 &quot;	sub	%w3, %w1, %w4\n&quot;
<span class="p_chunk">@@ -137,6 +138,7 @@</span> <span class="p_context"> futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,</span>
 &quot;	.align	3\n&quot;
 &quot;	.quad	1b, 4b, 2b, 4b\n&quot;
 &quot;	.popsection\n&quot;
<span class="p_add">+ALTERNATIVE(&quot;nop&quot;, SET_PSTATE_PAN(1), ARM64_HAS_PAN, CONFIG_ARM64_PAN)</span>
 	: &quot;+r&quot; (ret), &quot;=&amp;r&quot; (val), &quot;+Q&quot; (*uaddr), &quot;=&amp;r&quot; (tmp)
 	: &quot;r&quot; (oldval), &quot;r&quot; (newval), &quot;Ir&quot; (-EFAULT)
 	: &quot;memory&quot;);
<span class="p_header">diff --git a/arch/m68k/include/asm/delay.h b/arch/m68k/include/asm/delay.h</span>
<span class="p_header">index d28fa8fe26fe..c598d847d56b 100644</span>
<span class="p_header">--- a/arch/m68k/include/asm/delay.h</span>
<span class="p_header">+++ b/arch/m68k/include/asm/delay.h</span>
<span class="p_chunk">@@ -114,6 +114,6 @@</span> <span class="p_context"> static inline void __udelay(unsigned long usecs)</span>
  */
 #define	HZSCALE		(268435456 / (1000000 / HZ))
 
<span class="p_del">-#define ndelay(n) __delay(DIV_ROUND_UP((n) * ((((HZSCALE) &gt;&gt; 11) * (loops_per_jiffy &gt;&gt; 11)) &gt;&gt; 6), 1000));</span>
<span class="p_add">+#define ndelay(n) __delay(DIV_ROUND_UP((n) * ((((HZSCALE) &gt;&gt; 11) * (loops_per_jiffy &gt;&gt; 11)) &gt;&gt; 6), 1000))</span>
 
 #endif /* defined(_M68K_DELAY_H) */
<span class="p_header">diff --git a/arch/parisc/include/asm/pgtable.h b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">index c2c43f714684..3a4ed9f91d57 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -65,9 +65,9 @@</span> <span class="p_context"> static inline void purge_tlb_entries(struct mm_struct *mm, unsigned long addr)</span>
 		unsigned long flags;				\
 		spin_lock_irqsave(&amp;pa_tlb_lock, flags);		\
 		old_pte = *ptep;				\
<span class="p_del">-		set_pte(ptep, pteval);				\</span>
 		if (pte_inserted(old_pte))			\
 			purge_tlb_entries(mm, addr);		\
<span class="p_add">+		set_pte(ptep, pteval);				\</span>
 		spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);	\
 	} while (0)
 
<span class="p_chunk">@@ -478,8 +478,8 @@</span> <span class="p_context"> static inline int ptep_test_and_clear_young(struct vm_area_struct *vma, unsigned</span>
 		spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);
 		return 0;
 	}
<span class="p_del">-	set_pte(ptep, pte_mkold(pte));</span>
 	purge_tlb_entries(vma-&gt;vm_mm, addr);
<span class="p_add">+	set_pte(ptep, pte_mkold(pte));</span>
 	spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);
 	return 1;
 }
<span class="p_chunk">@@ -492,9 +492,9 @@</span> <span class="p_context"> static inline pte_t ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,</span>
 
 	spin_lock_irqsave(&amp;pa_tlb_lock, flags);
 	old_pte = *ptep;
<span class="p_del">-	set_pte(ptep, __pte(0));</span>
 	if (pte_inserted(old_pte))
 		purge_tlb_entries(mm, addr);
<span class="p_add">+	set_pte(ptep, __pte(0));</span>
 	spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);
 
 	return old_pte;
<span class="p_chunk">@@ -504,8 +504,8 @@</span> <span class="p_context"> static inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr,</span>
 {
 	unsigned long flags;
 	spin_lock_irqsave(&amp;pa_tlb_lock, flags);
<span class="p_del">-	set_pte(ptep, pte_wrprotect(*ptep));</span>
 	purge_tlb_entries(mm, addr);
<span class="p_add">+	set_pte(ptep, pte_wrprotect(*ptep));</span>
 	spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);
 }
 
<span class="p_header">diff --git a/arch/parisc/kernel/cache.c b/arch/parisc/kernel/cache.c</span>
<span class="p_header">index fd5979f28ada..6857a104b2f9 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/cache.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/cache.c</span>
<span class="p_chunk">@@ -375,6 +375,15 @@</span> <span class="p_context"> void __init parisc_setup_cache_timing(void)</span>
 
 	/* calculate TLB flush threshold */
 
<span class="p_add">+	/* On SMP machines, skip the TLB measure of kernel text which</span>
<span class="p_add">+	 * has been mapped as huge pages. */</span>
<span class="p_add">+	if (num_online_cpus() &gt; 1 &amp;&amp; !parisc_requires_coherency()) {</span>
<span class="p_add">+		threshold = max(cache_info.it_size, cache_info.dt_size);</span>
<span class="p_add">+		threshold *= PAGE_SIZE;</span>
<span class="p_add">+		threshold /= num_online_cpus();</span>
<span class="p_add">+		goto set_tlb_threshold;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	alltime = mfctl(16);
 	flush_tlb_all();
 	alltime = mfctl(16) - alltime;
<span class="p_chunk">@@ -393,6 +402,8 @@</span> <span class="p_context"> void __init parisc_setup_cache_timing(void)</span>
 		alltime, size, rangetime);
 
 	threshold = PAGE_ALIGN(num_online_cpus() * size * alltime / rangetime);
<span class="p_add">+</span>
<span class="p_add">+set_tlb_threshold:</span>
 	if (threshold)
 		parisc_tlb_flush_threshold = threshold;
 	printk(KERN_INFO &quot;TLB flush threshold set to %lu KiB\n&quot;,
<span class="p_header">diff --git a/arch/parisc/kernel/pacache.S b/arch/parisc/kernel/pacache.S</span>
<span class="p_header">index 675521919229..a4761b772406 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pacache.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/pacache.S</span>
<span class="p_chunk">@@ -886,19 +886,10 @@</span> <span class="p_context"> ENTRY(flush_dcache_page_asm)</span>
 	fdc,m		r31(%r28)
 	fdc,m		r31(%r28)
 	fdc,m		r31(%r28)
<span class="p_del">-	cmpb,COND(&lt;&lt;)		%r28, %r25,1b</span>
<span class="p_add">+	cmpb,COND(&lt;&lt;)	%r28, %r25,1b</span>
 	fdc,m		r31(%r28)
 
 	sync
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_PA20</span>
<span class="p_del">-	pdtlb,l		%r0(%r25)</span>
<span class="p_del">-#else</span>
<span class="p_del">-	tlb_lock	%r20,%r21,%r22</span>
<span class="p_del">-	pdtlb		%r0(%r25)</span>
<span class="p_del">-	tlb_unlock	%r20,%r21,%r22</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	bv		%r0(%r2)
 	nop
 	.exit
<span class="p_chunk">@@ -973,17 +964,6 @@</span> <span class="p_context"> ENTRY(flush_icache_page_asm)</span>
 	fic,m		%r31(%sr4,%r28)
 
 	sync
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_PA20</span>
<span class="p_del">-	pdtlb,l		%r0(%r28)</span>
<span class="p_del">-	pitlb,l         %r0(%sr4,%r25)</span>
<span class="p_del">-#else</span>
<span class="p_del">-	tlb_lock        %r20,%r21,%r22</span>
<span class="p_del">-	pdtlb		%r0(%r28)</span>
<span class="p_del">-	pitlb           %r0(%sr4,%r25)</span>
<span class="p_del">-	tlb_unlock      %r20,%r21,%r22</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	bv		%r0(%r2)
 	nop
 	.exit
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh_driver.c b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">index c07bfb52275e..300382e5a2cc 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_chunk">@@ -612,8 +612,10 @@</span> <span class="p_context"> static int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)</span>
 
 	/* Clear frozen state */
 	rc = eeh_clear_pe_frozen_state(pe, false);
<span class="p_del">-	if (rc)</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		pci_unlock_rescan_remove();</span>
 		return rc;
<span class="p_add">+	}</span>
 
 	/* Give the system 5 seconds to finish running the user-space
 	 * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">index a3aeb2cc361e..1a8256dd6729 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> u64 x86_perf_event_update(struct perf_event *event)</span>
 	int shift = 64 - x86_pmu.cntval_bits;
 	u64 prev_raw_count, new_raw_count;
 	int idx = hwc-&gt;idx;
<span class="p_del">-	s64 delta;</span>
<span class="p_add">+	u64 delta;</span>
 
 	if (idx == INTEL_PMC_IDX_FIXED_BTS)
 		return 0;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel.c b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">index 5f82cd59f0e5..5cc2242d77c6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_chunk">@@ -3636,7 +3636,7 @@</span> <span class="p_context"> __init int intel_pmu_init(void)</span>
 
 	/* Support full width counters using alternative MSR range */
 	if (x86_pmu.intel_cap.full_width_write) {
<span class="p_del">-		x86_pmu.max_period = x86_pmu.cntval_mask;</span>
<span class="p_add">+		x86_pmu.max_period = x86_pmu.cntval_mask &gt;&gt; 1;</span>
 		x86_pmu.perfctr = MSR_IA32_PMC0;
 		pr_cont(&quot;full-width counters, &quot;);
 	}
<span class="p_header">diff --git a/crypto/Makefile b/crypto/Makefile</span>
<span class="p_header">index f7aba923458d..82fbff180ad3 100644</span>
<span class="p_header">--- a/crypto/Makefile</span>
<span class="p_header">+++ b/crypto/Makefile</span>
<span class="p_chunk">@@ -33,6 +33,7 @@</span> <span class="p_context"> obj-$(CONFIG_CRYPTO_AKCIPHER2) += akcipher.o</span>
 
 $(obj)/rsapubkey-asn1.o: $(obj)/rsapubkey-asn1.c $(obj)/rsapubkey-asn1.h
 $(obj)/rsaprivkey-asn1.o: $(obj)/rsaprivkey-asn1.c $(obj)/rsaprivkey-asn1.h
<span class="p_add">+$(obj)/rsa_helper.o: $(obj)/rsapubkey-asn1.h $(obj)/rsaprivkey-asn1.h</span>
 clean-files += rsapubkey-asn1.c rsapubkey-asn1.h
 clean-files += rsaprivkey-asn1.c rsaprivkey-asn1.h
 
<span class="p_header">diff --git a/crypto/mcryptd.c b/crypto/mcryptd.c</span>
<span class="p_header">index fe5b495a434d..a0ceb41d5ccc 100644</span>
<span class="p_header">--- a/crypto/mcryptd.c</span>
<span class="p_header">+++ b/crypto/mcryptd.c</span>
<span class="p_chunk">@@ -258,18 +258,22 @@</span> <span class="p_context"> out_free_inst:</span>
 	goto out;
 }
 
<span class="p_del">-static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,</span>
<span class="p_add">+static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,</span>
 					  u32 *mask)
 {
 	struct crypto_attr_type *algt;
 
 	algt = crypto_get_attr_type(tb);
 	if (IS_ERR(algt))
<span class="p_del">-		return;</span>
<span class="p_del">-	if ((algt-&gt;type &amp; CRYPTO_ALG_INTERNAL))</span>
<span class="p_del">-		*type |= CRYPTO_ALG_INTERNAL;</span>
<span class="p_del">-	if ((algt-&gt;mask &amp; CRYPTO_ALG_INTERNAL))</span>
<span class="p_del">-		*mask |= CRYPTO_ALG_INTERNAL;</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	*type |= algt-&gt;type &amp; CRYPTO_ALG_INTERNAL;</span>
<span class="p_add">+	*mask |= algt-&gt;mask &amp; CRYPTO_ALG_INTERNAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (*type &amp; *mask &amp; CRYPTO_ALG_INTERNAL)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return false;</span>
 }
 
 static int mcryptd_hash_init_tfm(struct crypto_tfm *tfm)
<span class="p_chunk">@@ -498,7 +502,8 @@</span> <span class="p_context"> static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,</span>
 	u32 mask = 0;
 	int err;
 
<span class="p_del">-	mcryptd_check_internal(tb, &amp;type, &amp;mask);</span>
<span class="p_add">+	if (!mcryptd_check_internal(tb, &amp;type, &amp;mask))</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	salg = shash_attr_alg(tb[1], type, mask);
 	if (IS_ERR(salg))
<span class="p_header">diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c</span>
<span class="p_header">index 1770c455dfdd..1648de80e230 100644</span>
<span class="p_header">--- a/drivers/block/zram/zram_drv.c</span>
<span class="p_header">+++ b/drivers/block/zram/zram_drv.c</span>
<span class="p_chunk">@@ -1378,8 +1378,14 @@</span> <span class="p_context"> static ssize_t hot_remove_store(struct class *class,</span>
 	return ret ? ret : count;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * NOTE: hot_add attribute is not the usual read-only sysfs attribute. In a</span>
<span class="p_add">+ * sense that reading from this file does alter the state of your system -- it</span>
<span class="p_add">+ * creates a new un-initialized zram device and returns back this device&#39;s</span>
<span class="p_add">+ * device_id (or an error code if it fails to create a new device).</span>
<span class="p_add">+ */</span>
 static struct class_attribute zram_control_class_attrs[] = {
<span class="p_del">-	__ATTR_RO(hot_add),</span>
<span class="p_add">+	__ATTR(hot_add, 0400, hot_add_show, NULL),</span>
 	__ATTR_WO(hot_remove),
 	__ATTR_NULL,
 };
<span class="p_header">diff --git a/drivers/net/can/usb/peak_usb/pcan_usb_core.c b/drivers/net/can/usb/peak_usb/pcan_usb_core.c</span>
<span class="p_header">index 5a2e341a6d1e..91be4575b524 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/peak_usb/pcan_usb_core.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/peak_usb/pcan_usb_core.c</span>
<span class="p_chunk">@@ -872,23 +872,25 @@</span> <span class="p_context"> lbl_free_candev:</span>
 static void peak_usb_disconnect(struct usb_interface *intf)
 {
 	struct peak_usb_device *dev;
<span class="p_add">+	struct peak_usb_device *dev_prev_siblings;</span>
 
 	/* unregister as many netdev devices as siblings */
<span class="p_del">-	for (dev = usb_get_intfdata(intf); dev; dev = dev-&gt;prev_siblings) {</span>
<span class="p_add">+	for (dev = usb_get_intfdata(intf); dev; dev = dev_prev_siblings) {</span>
 		struct net_device *netdev = dev-&gt;netdev;
 		char name[IFNAMSIZ];
 
<span class="p_add">+		dev_prev_siblings = dev-&gt;prev_siblings;</span>
 		dev-&gt;state &amp;= ~PCAN_USB_STATE_CONNECTED;
 		strncpy(name, netdev-&gt;name, IFNAMSIZ);
 
 		unregister_netdev(netdev);
<span class="p_del">-		free_candev(netdev);</span>
 
 		kfree(dev-&gt;cmd_buf);
 		dev-&gt;next_siblings = NULL;
 		if (dev-&gt;adapter-&gt;dev_free)
 			dev-&gt;adapter-&gt;dev_free(dev);
 
<span class="p_add">+		free_candev(netdev);</span>
 		dev_info(&amp;intf-&gt;dev, &quot;%s removed\n&quot;, name);
 	}
 
<span class="p_header">diff --git a/include/linux/cpu.h b/include/linux/cpu.h</span>
<span class="p_header">index d2ca8c38f9c4..3ea9aae2387d 100644</span>
<span class="p_header">--- a/include/linux/cpu.h</span>
<span class="p_header">+++ b/include/linux/cpu.h</span>
<span class="p_chunk">@@ -131,22 +131,16 @@</span> <span class="p_context"> enum {</span>
 		{ .notifier_call = fn, .priority = pri };	\
 	__register_cpu_notifier(&amp;fn##_nb);			\
 }
<span class="p_del">-#else /* #if defined(CONFIG_HOTPLUG_CPU) || !defined(MODULE) */</span>
<span class="p_del">-#define cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_del">-#define __cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_del">-#endif /* #else #if defined(CONFIG_HOTPLUG_CPU) || !defined(MODULE) */</span>
 
<span class="p_del">-#ifdef CONFIG_HOTPLUG_CPU</span>
 extern int register_cpu_notifier(struct notifier_block *nb);
 extern int __register_cpu_notifier(struct notifier_block *nb);
 extern void unregister_cpu_notifier(struct notifier_block *nb);
 extern void __unregister_cpu_notifier(struct notifier_block *nb);
<span class="p_del">-#else</span>
 
<span class="p_del">-#ifndef MODULE</span>
<span class="p_del">-extern int register_cpu_notifier(struct notifier_block *nb);</span>
<span class="p_del">-extern int __register_cpu_notifier(struct notifier_block *nb);</span>
<span class="p_del">-#else</span>
<span class="p_add">+#else /* #if defined(CONFIG_HOTPLUG_CPU) || !defined(MODULE) */</span>
<span class="p_add">+#define cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_add">+#define __cpu_notifier(fn, pri)	do { (void)(fn); } while (0)</span>
<span class="p_add">+</span>
 static inline int register_cpu_notifier(struct notifier_block *nb)
 {
 	return 0;
<span class="p_chunk">@@ -156,7 +150,6 @@</span> <span class="p_context"> static inline int __register_cpu_notifier(struct notifier_block *nb)</span>
 {
 	return 0;
 }
<span class="p_del">-#endif</span>
 
 static inline void unregister_cpu_notifier(struct notifier_block *nb)
 {
<span class="p_header">diff --git a/include/uapi/linux/can.h b/include/uapi/linux/can.h</span>
<span class="p_header">index 9692cda5f8fc..c48d93a28d1a 100644</span>
<span class="p_header">--- a/include/uapi/linux/can.h</span>
<span class="p_header">+++ b/include/uapi/linux/can.h</span>
<span class="p_chunk">@@ -196,5 +196,6 @@</span> <span class="p_context"> struct can_filter {</span>
 };
 
 #define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
<span class="p_add">+#define CAN_RAW_FILTER_MAX 512 /* maximum number of can_filter set via setsockopt() */</span>
 
 #endif /* !_UAPI_CAN_H */
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index 85ff5e26e23b..cd6d1258554e 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -223,8 +223,6 @@</span> <span class="p_context"> static int cpu_notify(unsigned long val, void *v)</span>
 	return __cpu_notify(val, v, -1, NULL);
 }
 
<span class="p_del">-#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="p_del">-</span>
 static void cpu_notify_nofail(unsigned long val, void *v)
 {
 	BUG_ON(cpu_notify(val, v));
<span class="p_chunk">@@ -246,6 +244,7 @@</span> <span class="p_context"> void __unregister_cpu_notifier(struct notifier_block *nb)</span>
 }
 EXPORT_SYMBOL(__unregister_cpu_notifier);
 
<span class="p_add">+#ifdef CONFIG_HOTPLUG_CPU</span>
 /**
  * clear_tasks_mm_cpumask - Safely clear tasks&#39; mm_cpumask for a CPU
  * @cpu: a CPU id
<span class="p_header">diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c</span>
<span class="p_header">index 8251e75dd9c0..b066724d7a5b 100644</span>
<span class="p_header">--- a/kernel/locking/rtmutex.c</span>
<span class="p_header">+++ b/kernel/locking/rtmutex.c</span>
<span class="p_chunk">@@ -65,8 +65,72 @@</span> <span class="p_context"> static inline void clear_rt_mutex_waiters(struct rt_mutex *lock)</span>
 
 static void fixup_rt_mutex_waiters(struct rt_mutex *lock)
 {
<span class="p_del">-	if (!rt_mutex_has_waiters(lock))</span>
<span class="p_del">-		clear_rt_mutex_waiters(lock);</span>
<span class="p_add">+	unsigned long owner, *p = (unsigned long *) &amp;lock-&gt;owner;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rt_mutex_has_waiters(lock))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The rbtree has no waiters enqueued, now make sure that the</span>
<span class="p_add">+	 * lock-&gt;owner still has the waiters bit set, otherwise the</span>
<span class="p_add">+	 * following can happen:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * CPU 0	CPU 1		CPU2</span>
<span class="p_add">+	 * l-&gt;owner=T1</span>
<span class="p_add">+	 *		rt_mutex_lock(l)</span>
<span class="p_add">+	 *		lock(l-&gt;lock)</span>
<span class="p_add">+	 *		l-&gt;owner = T1 | HAS_WAITERS;</span>
<span class="p_add">+	 *		enqueue(T2)</span>
<span class="p_add">+	 *		boost()</span>
<span class="p_add">+	 *		  unlock(l-&gt;lock)</span>
<span class="p_add">+	 *		block()</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *				rt_mutex_lock(l)</span>
<span class="p_add">+	 *				lock(l-&gt;lock)</span>
<span class="p_add">+	 *				l-&gt;owner = T1 | HAS_WAITERS;</span>
<span class="p_add">+	 *				enqueue(T3)</span>
<span class="p_add">+	 *				boost()</span>
<span class="p_add">+	 *				  unlock(l-&gt;lock)</span>
<span class="p_add">+	 *				block()</span>
<span class="p_add">+	 *		signal(-&gt;T2)	signal(-&gt;T3)</span>
<span class="p_add">+	 *		lock(l-&gt;lock)</span>
<span class="p_add">+	 *		dequeue(T2)</span>
<span class="p_add">+	 *		deboost()</span>
<span class="p_add">+	 *		  unlock(l-&gt;lock)</span>
<span class="p_add">+	 *				lock(l-&gt;lock)</span>
<span class="p_add">+	 *				dequeue(T3)</span>
<span class="p_add">+	 *				 ==&gt; wait list is empty</span>
<span class="p_add">+	 *				deboost()</span>
<span class="p_add">+	 *				 unlock(l-&gt;lock)</span>
<span class="p_add">+	 *		lock(l-&gt;lock)</span>
<span class="p_add">+	 *		fixup_rt_mutex_waiters()</span>
<span class="p_add">+	 *		  if (wait_list_empty(l) {</span>
<span class="p_add">+	 *		    l-&gt;owner = owner</span>
<span class="p_add">+	 *		    owner = l-&gt;owner &amp; ~HAS_WAITERS;</span>
<span class="p_add">+	 *		      ==&gt; l-&gt;owner = T1</span>
<span class="p_add">+	 *		  }</span>
<span class="p_add">+	 *				lock(l-&gt;lock)</span>
<span class="p_add">+	 * rt_mutex_unlock(l)		fixup_rt_mutex_waiters()</span>
<span class="p_add">+	 *				  if (wait_list_empty(l) {</span>
<span class="p_add">+	 *				    owner = l-&gt;owner &amp; ~HAS_WAITERS;</span>
<span class="p_add">+	 * cmpxchg(l-&gt;owner, T1, NULL)</span>
<span class="p_add">+	 *  ===&gt; Success (l-&gt;owner = NULL)</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *				    l-&gt;owner = owner</span>
<span class="p_add">+	 *				      ==&gt; l-&gt;owner = T1</span>
<span class="p_add">+	 *				  }</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * With the check for the waiter bit in place T3 on CPU2 will not</span>
<span class="p_add">+	 * overwrite. All tasks fiddling with the waiters bit are</span>
<span class="p_add">+	 * serialized by l-&gt;lock, so nothing else can modify the waiters</span>
<span class="p_add">+	 * bit. If the bit is set then nothing can change l-&gt;owner either</span>
<span class="p_add">+	 * so the simple RMW is safe. The cmpxchg() will simply fail if it</span>
<span class="p_add">+	 * happens in the middle of the RMW because the waiters bit is</span>
<span class="p_add">+	 * still set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	owner = READ_ONCE(*p);</span>
<span class="p_add">+	if (owner &amp; RT_MUTEX_HAS_WAITERS)</span>
<span class="p_add">+		WRITE_ONCE(*p, owner &amp; ~RT_MUTEX_HAS_WAITERS);</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/locking/rtmutex_common.h b/kernel/locking/rtmutex_common.h</span>
<span class="p_header">index 4f5f83c7d2d3..e317e1cbb3eb 100644</span>
<span class="p_header">--- a/kernel/locking/rtmutex_common.h</span>
<span class="p_header">+++ b/kernel/locking/rtmutex_common.h</span>
<span class="p_chunk">@@ -75,8 +75,9 @@</span> <span class="p_context"> task_top_pi_waiter(struct task_struct *p)</span>
 
 static inline struct task_struct *rt_mutex_owner(struct rt_mutex *lock)
 {
<span class="p_del">-	return (struct task_struct *)</span>
<span class="p_del">-		((unsigned long)lock-&gt;owner &amp; ~RT_MUTEX_OWNER_MASKALL);</span>
<span class="p_add">+	unsigned long owner = (unsigned long) READ_ONCE(lock-&gt;owner);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (struct task_struct *) (owner &amp; ~RT_MUTEX_OWNER_MASKALL);</span>
 }
 
 /*
<span class="p_header">diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c</span>
<span class="p_header">index 83b0ca27a45e..f2079acb555d 100644</span>
<span class="p_header">--- a/net/batman-adv/translation-table.c</span>
<span class="p_header">+++ b/net/batman-adv/translation-table.c</span>
<span class="p_chunk">@@ -2764,7 +2764,7 @@</span> <span class="p_context"> static bool batadv_send_my_tt_response(struct batadv_priv *bat_priv,</span>
 							     &amp;tvlv_tt_data,
 							     &amp;tt_change,
 							     &amp;tt_len);
<span class="p_del">-		if (!tt_len)</span>
<span class="p_add">+		if (!tt_len || !tvlv_len)</span>
 			goto unlock;
 
 		/* Copy the last orig_node&#39;s OGM buffer */
<span class="p_chunk">@@ -2782,7 +2782,7 @@</span> <span class="p_context"> static bool batadv_send_my_tt_response(struct batadv_priv *bat_priv,</span>
 							     &amp;tvlv_tt_data,
 							     &amp;tt_change,
 							     &amp;tt_len);
<span class="p_del">-		if (!tt_len)</span>
<span class="p_add">+		if (!tt_len || !tvlv_len)</span>
 			goto out;
 
 		/* fill the rest of the tvlv with the real TT entries */
<span class="p_header">diff --git a/net/can/raw.c b/net/can/raw.c</span>
<span class="p_header">index 2e67b1423cd3..56af689ca999 100644</span>
<span class="p_header">--- a/net/can/raw.c</span>
<span class="p_header">+++ b/net/can/raw.c</span>
<span class="p_chunk">@@ -499,6 +499,9 @@</span> <span class="p_context"> static int raw_setsockopt(struct socket *sock, int level, int optname,</span>
 		if (optlen % sizeof(struct can_filter) != 0)
 			return -EINVAL;
 
<span class="p_add">+		if (optlen &gt; CAN_RAW_FILTER_MAX * sizeof(struct can_filter))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		count = optlen / sizeof(struct can_filter);
 
 		if (count &gt; 1) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



