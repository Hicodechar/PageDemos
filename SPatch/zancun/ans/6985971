
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.1.5 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.1.5</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 10, 2015, 8:25 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150810202523.GB31763@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6985971/mbox/"
   >mbox</a>
|
   <a href="/patch/6985971/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6985971/">/patch/6985971/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 4D5879F373
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 10 Aug 2015 20:26:04 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 0CB182061C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 10 Aug 2015 20:25:55 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 5BD982060B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 10 Aug 2015 20:25:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933033AbbHJUZk (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 10 Aug 2015 16:25:40 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:49774 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932491AbbHJUZY (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 10 Aug 2015 16:25:24 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 6D84F9A;
	Mon, 10 Aug 2015 20:25:23 +0000 (UTC)
Date: Mon, 10 Aug 2015 13:25:23 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.1.5
Message-ID: &lt;20150810202523.GB31763@kroah.com&gt;
References: &lt;20150810202511.GA31763@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150810202511.GA31763@kroah.com&gt;
User-Agent: Mutt/1.5.23+102 (2ca89bed6448) (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 10, 2015, 8:25 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/hwmon/nct7904 b/Documentation/hwmon/nct7904</span>
<span class="p_header">index 014f112e2a14..57fffe33ebfc 100644</span>
<span class="p_header">--- a/Documentation/hwmon/nct7904</span>
<span class="p_header">+++ b/Documentation/hwmon/nct7904</span>
<span class="p_chunk">@@ -35,11 +35,11 @@</span> <span class="p_context"> temp1_input		Local temperature (1/1000 degree,</span>
 temp[2-9]_input		CPU temperatures (1/1000 degree,
 			0.125 degree resolution)
 
<span class="p_del">-fan[1-4]_mode		R/W, 0/1 for manual or SmartFan mode</span>
<span class="p_add">+pwm[1-4]_enable		R/W, 1/2 for manual or SmartFan mode</span>
 			Setting SmartFan mode is supported only if it has been
 			previously configured by BIOS (or configuration EEPROM)
 
<span class="p_del">-fan[1-4]_pwm		R/O in SmartFan mode, R/W in manual control mode</span>
<span class="p_add">+pwm[1-4]		R/O in SmartFan mode, R/W in manual control mode</span>
 
 The driver checks sensor control registers and does not export the sensors
 that are not enabled. Anyway, a sensor that is enabled may actually be not
<span class="p_header">diff --git a/Documentation/kbuild/makefiles.txt b/Documentation/kbuild/makefiles.txt</span>
<span class="p_header">index 74b6c6d97210..d2b1c40cb666 100644</span>
<span class="p_header">--- a/Documentation/kbuild/makefiles.txt</span>
<span class="p_header">+++ b/Documentation/kbuild/makefiles.txt</span>
<span class="p_chunk">@@ -952,6 +952,14 @@</span> <span class="p_context"> When kbuild executes, the following steps are followed (roughly):</span>
 	$(KBUILD_ARFLAGS) set by the top level Makefile to &quot;D&quot; (deterministic
 	mode) if this option is supported by $(AR).
 
<span class="p_add">+    ARCH_CPPFLAGS, ARCH_AFLAGS, ARCH_CFLAGS   Overrides the kbuild defaults</span>
<span class="p_add">+</span>
<span class="p_add">+	These variables are appended to the KBUILD_CPPFLAGS,</span>
<span class="p_add">+	KBUILD_AFLAGS, and KBUILD_CFLAGS, respectively, after the</span>
<span class="p_add">+	top-level Makefile has set any other flags. This provides a</span>
<span class="p_add">+	means for an architecture to override the defaults.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 --- 6.2 Add prerequisites to archheaders:
 
 	The archheaders: rule is used to generate header files that
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 36f3225cdf1f..068dd690933d 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 1
<span class="p_del">-SUBLEVEL = 4</span>
<span class="p_add">+SUBLEVEL = 5</span>
 EXTRAVERSION =
 NAME = Series 4800
 
<span class="p_chunk">@@ -783,10 +783,11 @@</span> <span class="p_context"> endif</span>
 include scripts/Makefile.kasan
 include scripts/Makefile.extrawarn
 
<span class="p_del">-# Add user supplied CPPFLAGS, AFLAGS and CFLAGS as the last assignments</span>
<span class="p_del">-KBUILD_CPPFLAGS += $(KCPPFLAGS)</span>
<span class="p_del">-KBUILD_AFLAGS += $(KAFLAGS)</span>
<span class="p_del">-KBUILD_CFLAGS += $(KCFLAGS)</span>
<span class="p_add">+# Add any arch overrides and user supplied CPPFLAGS, AFLAGS and CFLAGS as the</span>
<span class="p_add">+# last assignments</span>
<span class="p_add">+KBUILD_CPPFLAGS += $(ARCH_CPPFLAGS) $(KCPPFLAGS)</span>
<span class="p_add">+KBUILD_AFLAGS   += $(ARCH_AFLAGS)   $(KAFLAGS)</span>
<span class="p_add">+KBUILD_CFLAGS   += $(ARCH_CFLAGS)   $(KCFLAGS)</span>
 
 # Use --build-id when available.
 LDFLAGS_BUILD_ID = $(patsubst -Wl$(comma)%,%,\
<span class="p_header">diff --git a/arch/arc/Makefile b/arch/arc/Makefile</span>
<span class="p_header">index db72fec0e160..2f21e1e0ecf7 100644</span>
<span class="p_header">--- a/arch/arc/Makefile</span>
<span class="p_header">+++ b/arch/arc/Makefile</span>
<span class="p_chunk">@@ -43,7 +43,8 @@</span> <span class="p_context"> endif</span>
 
 ifndef CONFIG_CC_OPTIMIZE_FOR_SIZE
 # Generic build system uses -O2, we want -O3
<span class="p_del">-cflags-y  += -O3</span>
<span class="p_add">+# Note: No need to add to cflags-y as that happens anyways</span>
<span class="p_add">+ARCH_CFLAGS += -O3</span>
 endif
 
 # small data is default for elf32 tool-chain. If not usable, disable it
<span class="p_header">diff --git a/arch/arc/include/asm/bitops.h b/arch/arc/include/asm/bitops.h</span>
<span class="p_header">index 624a9d048ca9..dae03e66fa9e 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/bitops.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/bitops.h</span>
<span class="p_chunk">@@ -18,83 +18,49 @@</span> <span class="p_context"></span>
 #include &lt;linux/types.h&gt;
 #include &lt;linux/compiler.h&gt;
 #include &lt;asm/barrier.h&gt;
<span class="p_add">+#ifndef CONFIG_ARC_HAS_LLSC</span>
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
<span class="p_add">+#endif</span>
 
<span class="p_del">-/*</span>
<span class="p_del">- * Hardware assisted read-modify-write using ARC700 LLOCK/SCOND insns.</span>
<span class="p_del">- * The Kconfig glue ensures that in SMP, this is only set if the container</span>
<span class="p_del">- * SoC/platform has cross-core coherent LLOCK/SCOND</span>
<span class="p_del">- */</span>
 #if defined(CONFIG_ARC_HAS_LLSC)
 
<span class="p_del">-static inline void set_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * ARC ISA micro-optimization:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Instructions dealing with bitpos only consider lower 5 bits (0-31)</span>
<span class="p_del">-	 * e.g (x &lt;&lt; 33) is handled like (x &lt;&lt; 1) by ASL instruction</span>
<span class="p_del">-	 *  (mem pointer still needs adjustment to point to next word)</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Hence the masking to clamp @nr arg can be elided in general.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * However if @nr is a constant (above assumed it in a register),</span>
<span class="p_del">-	 * and greater than 31, gcc can optimize away (x &lt;&lt; 33) to 0,</span>
<span class="p_del">-	 * as overflow, given the 32-bit ISA. Thus masking needs to be done</span>
<span class="p_del">-	 * for constant @nr, but no code is generated due to const prop.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bset    %0, %0, %2	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b	\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(m), &quot;ir&quot;(nr)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void clear_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bclr    %0, %0, %2	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b	\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(m), &quot;ir&quot;(nr)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void change_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Hardware assisted Atomic-R-M-W</span>
<span class="p_add">+ */</span>
 
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bxor    %0, %0, %2	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b		\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(m), &quot;ir&quot;(nr)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_add">+#define BIT_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+static inline void op##_bit(unsigned long nr, volatile unsigned long *m)\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned int temp;						\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	m += nr &gt;&gt; 5;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	/*								\</span>
<span class="p_add">+	 * ARC ISA micro-optimization:					\</span>
<span class="p_add">+	 *								\</span>
<span class="p_add">+	 * Instructions dealing with bitpos only consider lower 5 bits	\</span>
<span class="p_add">+	 * e.g (x &lt;&lt; 33) is handled like (x &lt;&lt; 1) by ASL instruction	\</span>
<span class="p_add">+	 *  (mem pointer still needs adjustment to point to next word)	\</span>
<span class="p_add">+	 *								\</span>
<span class="p_add">+	 * Hence the masking to clamp @nr arg can be elided in general.	\</span>
<span class="p_add">+	 *								\</span>
<span class="p_add">+	 * However if @nr is a constant (above assumed in a register),	\</span>
<span class="p_add">+	 * and greater than 31, gcc can optimize away (x &lt;&lt; 33) to 0,	\</span>
<span class="p_add">+	 * as overflow, given the 32-bit ISA. Thus masking needs to be	\</span>
<span class="p_add">+	 * done for const @nr, but no code is generated due to gcc	\</span>
<span class="p_add">+	 * const prop.							\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	nr &amp;= 0x1f;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	__asm__ __volatile__(						\</span>
<span class="p_add">+	&quot;1:	llock       %0, [%1]		\n&quot;			\</span>
<span class="p_add">+	&quot;	&quot; #asm_op &quot; %0, %0, %2	\n&quot;				\</span>
<span class="p_add">+	&quot;	scond       %0, [%1]		\n&quot;			\</span>
<span class="p_add">+	&quot;	bnz         1b			\n&quot;			\</span>
<span class="p_add">+	: &quot;=&amp;r&quot;(temp)	/* Early clobber, to prevent reg reuse */	\</span>
<span class="p_add">+	: &quot;r&quot;(m),	/* Not &quot;m&quot;: llock only supports reg direct addr mode */	\</span>
<span class="p_add">+	  &quot;ir&quot;(nr)							\</span>
<span class="p_add">+	: &quot;cc&quot;);							\</span>
 }
 
 /*
<span class="p_chunk">@@ -108,91 +74,37 @@</span> <span class="p_context"> static inline void change_bit(unsigned long nr, volatile unsigned long *m)</span>
  * Since ARC lacks a equivalent h/w primitive, the bit is set unconditionally
  * and the old value of bit is returned
  */
<span class="p_del">-static inline int test_and_set_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long old, temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Explicit full memory barrier needed before/after as</span>
<span class="p_del">-	 * LLOCK/SCOND themselves don&#39;t provide any such semantics</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	smp_mb();</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%2]	\n&quot;</span>
<span class="p_del">-	&quot;	bset    %1, %0, %3	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %1, [%2]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b		\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(old), &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(m), &quot;ir&quot;(nr)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	smp_mb();</span>
<span class="p_del">-</span>
<span class="p_del">-	return (old &amp; (1 &lt;&lt; nr)) != 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int</span>
<span class="p_del">-test_and_clear_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int old, temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	smp_mb();</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%2]	\n&quot;</span>
<span class="p_del">-	&quot;	bclr    %1, %0, %3	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %1, [%2]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b		\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(old), &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(m), &quot;ir&quot;(nr)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	smp_mb();</span>
<span class="p_del">-</span>
<span class="p_del">-	return (old &amp; (1 &lt;&lt; nr)) != 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int</span>
<span class="p_del">-test_and_change_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int old, temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	smp_mb();</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%2]	\n&quot;</span>
<span class="p_del">-	&quot;	bxor    %1, %0, %3	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %1, [%2]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b		\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(old), &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(m), &quot;ir&quot;(nr)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	smp_mb();</span>
<span class="p_del">-</span>
<span class="p_del">-	return (old &amp; (1 &lt;&lt; nr)) != 0;</span>
<span class="p_add">+#define TEST_N_BIT_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+static inline int test_and_##op##_bit(unsigned long nr, volatile unsigned long *m)\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned long old, temp;					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	m += nr &gt;&gt; 5;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	nr &amp;= 0x1f;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	/*								\</span>
<span class="p_add">+	 * Explicit full memory barrier needed before/after as		\</span>
<span class="p_add">+	 * LLOCK/SCOND themselves don&#39;t provide any such smenatic	\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	__asm__ __volatile__(						\</span>
<span class="p_add">+	&quot;1:	llock       %0, [%2]	\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot; #asm_op &quot; %1, %0, %3	\n&quot;				\</span>
<span class="p_add">+	&quot;	scond       %1, [%2]	\n&quot;				\</span>
<span class="p_add">+	&quot;	bnz         1b		\n&quot;				\</span>
<span class="p_add">+	: &quot;=&amp;r&quot;(old), &quot;=&amp;r&quot;(temp)					\</span>
<span class="p_add">+	: &quot;r&quot;(m), &quot;ir&quot;(nr)						\</span>
<span class="p_add">+	: &quot;cc&quot;);							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	return (old &amp; (1 &lt;&lt; nr)) != 0;					\</span>
 }
 
 #else	/* !CONFIG_ARC_HAS_LLSC */
 
<span class="p_del">-#include &lt;asm/smp.h&gt;</span>
<span class="p_del">-</span>
 /*
  * Non hardware assisted Atomic-R-M-W
  * Locking would change to irq-disabling only (UP) and spinlocks (SMP)
<span class="p_chunk">@@ -209,111 +121,37 @@</span> <span class="p_context"> test_and_change_bit(unsigned long nr, volatile unsigned long *m)</span>
  *             at compile time)
  */
 
<span class="p_del">-static inline void set_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long temp, flags;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_lock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	temp = *m;</span>
<span class="p_del">-	*m = temp | (1UL &lt;&lt; nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_unlock(flags);</span>
<span class="p_add">+#define BIT_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+static inline void op##_bit(unsigned long nr, volatile unsigned long *m)\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned long temp, flags;					\</span>
<span class="p_add">+	m += nr &gt;&gt; 5;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	/*								\</span>
<span class="p_add">+	 * spin lock/unlock provide the needed smp_mb() before/after	\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	bitops_lock(flags);						\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	temp = *m;							\</span>
<span class="p_add">+	*m = temp c_op (1UL &lt;&lt; (nr &amp; 0x1f));					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	bitops_unlock(flags);						\</span>
 }
 
<span class="p_del">-static inline void clear_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long temp, flags;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_lock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	temp = *m;</span>
<span class="p_del">-	*m = temp &amp; ~(1UL &lt;&lt; nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_unlock(flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void change_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long temp, flags;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_lock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	temp = *m;</span>
<span class="p_del">-	*m = temp ^ (1UL &lt;&lt; nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_unlock(flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int test_and_set_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long old, flags;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * spin lock/unlock provide the needed smp_mb() before/after</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	bitops_lock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	old = *m;</span>
<span class="p_del">-	*m = old | (1 &lt;&lt; nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_unlock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	return (old &amp; (1 &lt;&lt; nr)) != 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int</span>
<span class="p_del">-test_and_clear_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long old, flags;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_lock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	old = *m;</span>
<span class="p_del">-	*m = old &amp; ~(1 &lt;&lt; nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_unlock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	return (old &amp; (1 &lt;&lt; nr)) != 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int</span>
<span class="p_del">-test_and_change_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long old, flags;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_lock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	old = *m;</span>
<span class="p_del">-	*m = old ^ (1 &lt;&lt; nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	bitops_unlock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	return (old &amp; (1 &lt;&lt; nr)) != 0;</span>
<span class="p_add">+#define TEST_N_BIT_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+static inline int test_and_##op##_bit(unsigned long nr, volatile unsigned long *m)\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned long old, flags;					\</span>
<span class="p_add">+	m += nr &gt;&gt; 5;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	bitops_lock(flags);						\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	old = *m;							\</span>
<span class="p_add">+	*m = old c_op (1UL &lt;&lt; (nr &amp; 0x1f));				\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	bitops_unlock(flags);						\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	return (old &amp; (1UL &lt;&lt; (nr &amp; 0x1f))) != 0;			\</span>
 }
 
 #endif /* CONFIG_ARC_HAS_LLSC */
<span class="p_chunk">@@ -322,86 +160,45 @@</span> <span class="p_context"> test_and_change_bit(unsigned long nr, volatile unsigned long *m)</span>
  * Non atomic variants
  **************************************/
 
<span class="p_del">-static inline void __set_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long temp;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	temp = *m;</span>
<span class="p_del">-	*m = temp | (1UL &lt;&lt; nr);</span>
<span class="p_add">+#define __BIT_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+static inline void __##op##_bit(unsigned long nr, volatile unsigned long *m)	\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned long temp;						\</span>
<span class="p_add">+	m += nr &gt;&gt; 5;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	temp = *m;							\</span>
<span class="p_add">+	*m = temp c_op (1UL &lt;&lt; (nr &amp; 0x1f));				\</span>
 }
 
<span class="p_del">-static inline void __clear_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long temp;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	temp = *m;</span>
<span class="p_del">-	*m = temp &amp; ~(1UL &lt;&lt; nr);</span>
<span class="p_add">+#define __TEST_N_BIT_OP(op, c_op, asm_op)				\</span>
<span class="p_add">+static inline int __test_and_##op##_bit(unsigned long nr, volatile unsigned long *m)\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned long old;						\</span>
<span class="p_add">+	m += nr &gt;&gt; 5;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	old = *m;							\</span>
<span class="p_add">+	*m = old c_op (1UL &lt;&lt; (nr &amp; 0x1f));				\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	return (old &amp; (1UL &lt;&lt; (nr &amp; 0x1f))) != 0;			\</span>
 }
 
<span class="p_del">-static inline void __change_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long temp;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	temp = *m;</span>
<span class="p_del">-	*m = temp ^ (1UL &lt;&lt; nr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int</span>
<span class="p_del">-__test_and_set_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long old;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	old = *m;</span>
<span class="p_del">-	*m = old | (1 &lt;&lt; nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	return (old &amp; (1 &lt;&lt; nr)) != 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int</span>
<span class="p_del">-__test_and_clear_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long old;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	old = *m;</span>
<span class="p_del">-	*m = old &amp; ~(1 &lt;&lt; nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	return (old &amp; (1 &lt;&lt; nr)) != 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int</span>
<span class="p_del">-__test_and_change_bit(unsigned long nr, volatile unsigned long *m)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long old;</span>
<span class="p_del">-	m += nr &gt;&gt; 5;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	old = *m;</span>
<span class="p_del">-	*m = old ^ (1 &lt;&lt; nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	return (old &amp; (1 &lt;&lt; nr)) != 0;</span>
<span class="p_del">-}</span>
<span class="p_add">+#define BIT_OPS(op, c_op, asm_op)					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	/* set_bit(), clear_bit(), change_bit() */			\</span>
<span class="p_add">+	BIT_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	/* test_and_set_bit(), test_and_clear_bit(), test_and_change_bit() */\</span>
<span class="p_add">+	TEST_N_BIT_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	/* __set_bit(), __clear_bit(), __change_bit() */		\</span>
<span class="p_add">+	__BIT_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	/* __test_and_set_bit(), __test_and_clear_bit(), __test_and_change_bit() */\</span>
<span class="p_add">+	__TEST_N_BIT_OP(op, c_op, asm_op)</span>
<span class="p_add">+</span>
<span class="p_add">+BIT_OPS(set, |, bset)</span>
<span class="p_add">+BIT_OPS(clear, &amp; ~, bclr)</span>
<span class="p_add">+BIT_OPS(change, ^, bxor)</span>
 
 /*
  * This routine doesn&#39;t need to be atomic.
<span class="p_chunk">@@ -413,10 +210,7 @@</span> <span class="p_context"> test_bit(unsigned int nr, const volatile unsigned long *addr)</span>
 
 	addr += nr &gt;&gt; 5;
 
<span class="p_del">-	if (__builtin_constant_p(nr))</span>
<span class="p_del">-		nr &amp;= 0x1f;</span>
<span class="p_del">-</span>
<span class="p_del">-	mask = 1 &lt;&lt; nr;</span>
<span class="p_add">+	mask = 1UL &lt;&lt; (nr &amp; 0x1f);</span>
 
 	return ((mask &amp; *addr) != 0);
 }
<span class="p_header">diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h</span>
<span class="p_header">index 1bfeec2c0558..2a58af7a2e3a 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> struct callee_regs {</span>
 	long r25, r24, r23, r22, r21, r20, r19, r18, r17, r16, r15, r14, r13;
 };
 
<span class="p_del">-#define instruction_pointer(regs)	((regs)-&gt;ret)</span>
<span class="p_add">+#define instruction_pointer(regs)	(unsigned long)((regs)-&gt;ret)</span>
 #define profile_pc(regs)		instruction_pointer(regs)
 
 /* return 1 if user mode or 0 if kernel mode */
<span class="p_header">diff --git a/arch/arm/boot/dts/am57xx-beagle-x15.dts b/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_header">index 7128fad991ac..c9df40e5cd3b 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_chunk">@@ -544,6 +544,10 @@</span> <span class="p_context"></span>
 	phy-supply = &lt;&amp;ldousb_reg&gt;;
 };
 
<span class="p_add">+&amp;usb2_phy2 {</span>
<span class="p_add">+	phy-supply = &lt;&amp;ldousb_reg&gt;;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 &amp;usb1 {
 	dr_mode = &quot;host&quot;;
 	pinctrl-names = &quot;default&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/dra7-evm.dts b/arch/arm/boot/dts/dra7-evm.dts</span>
<span class="p_header">index aa465904f6cc..096f68be99e2 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dra7-evm.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dra7-evm.dts</span>
<span class="p_chunk">@@ -686,7 +686,8 @@</span> <span class="p_context"></span>
 
 &amp;dcan1 {
 	status = &quot;ok&quot;;
<span class="p_del">-	pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span>
<span class="p_del">-	pinctrl-0 = &lt;&amp;dcan1_pins_default&gt;;</span>
<span class="p_add">+	pinctrl-names = &quot;default&quot;, &quot;sleep&quot;, &quot;active&quot;;</span>
<span class="p_add">+	pinctrl-0 = &lt;&amp;dcan1_pins_sleep&gt;;</span>
 	pinctrl-1 = &lt;&amp;dcan1_pins_sleep&gt;;
<span class="p_add">+	pinctrl-2 = &lt;&amp;dcan1_pins_default&gt;;</span>
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/dra72-evm.dts b/arch/arm/boot/dts/dra72-evm.dts</span>
<span class="p_header">index ce0390f081d9..6b05f6a0ba84 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dra72-evm.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dra72-evm.dts</span>
<span class="p_chunk">@@ -497,9 +497,10 @@</span> <span class="p_context"></span>
 
 &amp;dcan1 {
 	status = &quot;ok&quot;;
<span class="p_del">-	pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;</span>
<span class="p_del">-	pinctrl-0 = &lt;&amp;dcan1_pins_default&gt;;</span>
<span class="p_add">+	pinctrl-names = &quot;default&quot;, &quot;sleep&quot;, &quot;active&quot;;</span>
<span class="p_add">+	pinctrl-0 = &lt;&amp;dcan1_pins_sleep&gt;;</span>
 	pinctrl-1 = &lt;&amp;dcan1_pins_sleep&gt;;
<span class="p_add">+	pinctrl-2 = &lt;&amp;dcan1_pins_default&gt;;</span>
 };
 
 &amp;qspi {
<span class="p_header">diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c</span>
<span class="p_header">index 6d0893a3828e..78b6fd0b86e6 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/gpc.c</span>
<span class="p_header">+++ b/arch/arm/mach-imx/gpc.c</span>
<span class="p_chunk">@@ -291,8 +291,6 @@</span> <span class="p_context"> void __init imx_gpc_check_dt(void)</span>
 	}
 }
 
<span class="p_del">-#ifdef CONFIG_PM_GENERIC_DOMAINS</span>
<span class="p_del">-</span>
 static void _imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)
 {
 	int iso, iso2sw;
<span class="p_chunk">@@ -399,7 +397,6 @@</span> <span class="p_context"> static struct genpd_onecell_data imx_gpc_onecell_data = {</span>
 static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
 {
 	struct clk *clk;
<span class="p_del">-	bool is_off;</span>
 	int i;
 
 	imx6q_pu_domain.reg = pu_reg;
<span class="p_chunk">@@ -416,18 +413,13 @@</span> <span class="p_context"> static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)</span>
 	}
 	imx6q_pu_domain.num_clks = i;
 
<span class="p_del">-	is_off = IS_ENABLED(CONFIG_PM);</span>
<span class="p_del">-	if (is_off) {</span>
<span class="p_del">-		_imx6q_pm_pu_power_off(&amp;imx6q_pu_domain.base);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Enable power if compiled without CONFIG_PM in case the</span>
<span class="p_del">-		 * bootloader disabled it.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		imx6q_pm_pu_power_on(&amp;imx6q_pu_domain.base);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Enable power always in case bootloader disabled it. */</span>
<span class="p_add">+	imx6q_pm_pu_power_on(&amp;imx6q_pu_domain.base);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS))</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-	pm_genpd_init(&amp;imx6q_pu_domain.base, NULL, is_off);</span>
<span class="p_add">+	pm_genpd_init(&amp;imx6q_pu_domain.base, NULL, false);</span>
 	return of_genpd_add_provider_onecell(dev-&gt;of_node,
 					     &amp;imx_gpc_onecell_data);
 
<span class="p_chunk">@@ -437,13 +429,6 @@</span> <span class="p_context"> clk_err:</span>
 	return -EINVAL;
 }
 
<span class="p_del">-#else</span>
<span class="p_del">-static inline int imx_gpc_genpd_init(struct device *dev, struct regulator *reg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif /* CONFIG_PM_GENERIC_DOMAINS */</span>
<span class="p_del">-</span>
 static int imx_gpc_probe(struct platform_device *pdev)
 {
 	struct regulator *pu_reg;
<span class="p_header">diff --git a/arch/arm/mach-pxa/capc7117.c b/arch/arm/mach-pxa/capc7117.c</span>
<span class="p_header">index c092730749b9..bf366b39fa61 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/capc7117.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/capc7117.c</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/ata_platform.h&gt;
 #include &lt;linux/serial_8250.h&gt;
 #include &lt;linux/gpio.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 
 #include &lt;asm/mach-types.h&gt;
 #include &lt;asm/mach/arch.h&gt;
<span class="p_chunk">@@ -144,6 +145,8 @@</span> <span class="p_context"> static void __init capc7117_init(void)</span>
 
 	capc7117_uarts_init();
 	capc7117_ide_init();
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 MACHINE_START(CAPC7117,
<span class="p_header">diff --git a/arch/arm/mach-pxa/cm-x2xx.c b/arch/arm/mach-pxa/cm-x2xx.c</span>
<span class="p_header">index bb99f59a36d8..a17a91eb8e9a 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/cm-x2xx.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/cm-x2xx.c</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/syscore_ops.h&gt;
 #include &lt;linux/irq.h&gt;
 #include &lt;linux/gpio.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 
 #include &lt;linux/dm9000.h&gt;
 #include &lt;linux/leds.h&gt;
<span class="p_chunk">@@ -466,6 +467,8 @@</span> <span class="p_context"> static void __init cmx2xx_init(void)</span>
 	cmx2xx_init_ac97();
 	cmx2xx_init_touchscreen();
 	cmx2xx_init_leds();
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static void __init cmx2xx_init_irq(void)
<span class="p_header">diff --git a/arch/arm/mach-pxa/cm-x300.c b/arch/arm/mach-pxa/cm-x300.c</span>
<span class="p_header">index 4d3588d26c2a..5851f4c254c1 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/cm-x300.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/cm-x300.c</span>
<span class="p_chunk">@@ -835,6 +835,8 @@</span> <span class="p_context"> static void __init cm_x300_init(void)</span>
 	cm_x300_init_ac97();
 	cm_x300_init_wi2wi();
 	cm_x300_init_bl();
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static void __init cm_x300_fixup(struct tag *tags, char **cmdline)
<span class="p_header">diff --git a/arch/arm/mach-pxa/colibri-pxa270.c b/arch/arm/mach-pxa/colibri-pxa270.c</span>
<span class="p_header">index 5f9d9303b346..3503826333c7 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/colibri-pxa270.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/colibri-pxa270.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mtd/partitions.h&gt;
 #include &lt;linux/mtd/physmap.h&gt;
 #include &lt;linux/platform_device.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 #include &lt;linux/ucb1400.h&gt;
 
 #include &lt;asm/mach/arch.h&gt;
<span class="p_chunk">@@ -294,6 +295,8 @@</span> <span class="p_context"> static void __init colibri_pxa270_init(void)</span>
 		printk(KERN_ERR &quot;Illegal colibri_pxa270_baseboard type %d\n&quot;,
 				colibri_pxa270_baseboard);
 	}
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 /* The &quot;Income s.r.o. SH-Dmaster PXA270 SBC&quot; board can be booted either
<span class="p_header">diff --git a/arch/arm/mach-pxa/em-x270.c b/arch/arm/mach-pxa/em-x270.c</span>
<span class="p_header">index 51531ecffca8..9d7072b04045 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/em-x270.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/em-x270.c</span>
<span class="p_chunk">@@ -1306,6 +1306,8 @@</span> <span class="p_context"> static void __init em_x270_init(void)</span>
 	em_x270_init_i2c();
 	em_x270_init_camera();
 	em_x270_userspace_consumers_init();
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 MACHINE_START(EM_X270, &quot;Compulab EM-X270&quot;)
<span class="p_header">diff --git a/arch/arm/mach-pxa/icontrol.c b/arch/arm/mach-pxa/icontrol.c</span>
<span class="p_header">index c98511c5abd1..9b0eb0252af6 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/icontrol.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/icontrol.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/spi/spi.h&gt;
 #include &lt;linux/spi/pxa2xx_spi.h&gt;
 #include &lt;linux/can/platform/mcp251x.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 
 #include &quot;generic.h&quot;
 
<span class="p_chunk">@@ -185,6 +186,8 @@</span> <span class="p_context"> static void __init icontrol_init(void)</span>
 	mxm_8x10_mmc_init();
 
 	icontrol_can_init();
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 MACHINE_START(ICONTROL, &quot;iControl/SafeTcam boards using Embedian MXM-8x10 CoM&quot;)
<span class="p_header">diff --git a/arch/arm/mach-pxa/trizeps4.c b/arch/arm/mach-pxa/trizeps4.c</span>
<span class="p_header">index 872dcb20e757..066e3a250ee0 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/trizeps4.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/trizeps4.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/dm9000.h&gt;
 #include &lt;linux/mtd/physmap.h&gt;
 #include &lt;linux/mtd/partitions.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 #include &lt;linux/i2c/pxa-i2c.h&gt;
 
 #include &lt;asm/types.h&gt;
<span class="p_chunk">@@ -534,6 +535,8 @@</span> <span class="p_context"> static void __init trizeps4_init(void)</span>
 
 	BCR_writew(trizeps_conxs_bcr);
 	board_backlight_power(1);
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static void __init trizeps4_map_io(void)
<span class="p_header">diff --git a/arch/arm/mach-pxa/vpac270.c b/arch/arm/mach-pxa/vpac270.c</span>
<span class="p_header">index aa89488f961e..54122a983ae3 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/vpac270.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/vpac270.c</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/dm9000.h&gt;
 #include &lt;linux/ucb1400.h&gt;
 #include &lt;linux/ata_platform.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 #include &lt;linux/regulator/max1586.h&gt;
 #include &lt;linux/i2c/pxa-i2c.h&gt;
 
<span class="p_chunk">@@ -711,6 +712,8 @@</span> <span class="p_context"> static void __init vpac270_init(void)</span>
 	vpac270_ts_init();
 	vpac270_rtc_init();
 	vpac270_ide_init();
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 MACHINE_START(VPAC270, &quot;Voipac PXA270&quot;)
<span class="p_header">diff --git a/arch/arm/mach-pxa/zeus.c b/arch/arm/mach-pxa/zeus.c</span>
<span class="p_header">index ac2ae5c71ab4..6158566fa0f7 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/zeus.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/zeus.c</span>
<span class="p_chunk">@@ -868,6 +868,8 @@</span> <span class="p_context"> static void __init zeus_init(void)</span>
 	i2c_register_board_info(0, ARRAY_AND_SIZE(zeus_i2c_devices));
 	pxa2xx_set_spi_info(3, &amp;pxa2xx_spi_ssp3_master_info);
 	spi_register_board_info(zeus_spi_board_info, ARRAY_SIZE(zeus_spi_board_info));
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static struct map_desc zeus_io_desc[] __initdata = {
<span class="p_header">diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">index 7e7583ddd607..6e4b9ff22ef3 100644</span>
<span class="p_header">--- a/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -1953,7 +1953,7 @@</span> <span class="p_context"> static int extend_iommu_mapping(struct dma_iommu_mapping *mapping)</span>
 {
 	int next_bitmap;
 
<span class="p_del">-	if (mapping-&gt;nr_bitmaps &gt; mapping-&gt;extensions)</span>
<span class="p_add">+	if (mapping-&gt;nr_bitmaps &gt;= mapping-&gt;extensions)</span>
 		return -EINVAL;
 
 	next_bitmap = mapping-&gt;nr_bitmaps;
<span class="p_header">diff --git a/arch/arm64/kernel/efi.c b/arch/arm64/kernel/efi.c</span>
<span class="p_header">index ab21e0d58278..352962bc2e78 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/efi.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/efi.c</span>
<span class="p_chunk">@@ -122,12 +122,12 @@</span> <span class="p_context"> static int __init uefi_init(void)</span>
 
 	/* Show what we know for posterity */
 	c16 = early_memremap(efi_to_phys(efi.systab-&gt;fw_vendor),
<span class="p_del">-			     sizeof(vendor));</span>
<span class="p_add">+			     sizeof(vendor) * sizeof(efi_char16_t));</span>
 	if (c16) {
 		for (i = 0; i &lt; (int) sizeof(vendor) - 1 &amp;&amp; *c16; ++i)
 			vendor[i] = c16[i];
 		vendor[i] = &#39;\0&#39;;
<span class="p_del">-		early_memunmap(c16, sizeof(vendor));</span>
<span class="p_add">+		early_memunmap(c16, sizeof(vendor) * sizeof(efi_char16_t));</span>
 	}
 
 	pr_info(&quot;EFI v%u.%.02u by %s\n&quot;,
<span class="p_header">diff --git a/arch/avr32/mach-at32ap/clock.c b/arch/avr32/mach-at32ap/clock.c</span>
<span class="p_header">index 23b1a97fae7a..52c179bec0cc 100644</span>
<span class="p_header">--- a/arch/avr32/mach-at32ap/clock.c</span>
<span class="p_header">+++ b/arch/avr32/mach-at32ap/clock.c</span>
<span class="p_chunk">@@ -80,6 +80,9 @@</span> <span class="p_context"> int clk_enable(struct clk *clk)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;clk_lock, flags);
 	__clk_enable(clk);
 	spin_unlock_irqrestore(&amp;clk_lock, flags);
<span class="p_chunk">@@ -106,6 +109,9 @@</span> <span class="p_context"> void clk_disable(struct clk *clk)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (IS_ERR_OR_NULL(clk))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;clk_lock, flags);
 	__clk_disable(clk);
 	spin_unlock_irqrestore(&amp;clk_lock, flags);
<span class="p_chunk">@@ -117,6 +123,9 @@</span> <span class="p_context"> unsigned long clk_get_rate(struct clk *clk)</span>
 	unsigned long flags;
 	unsigned long rate;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;clk_lock, flags);
 	rate = clk-&gt;get_rate(clk);
 	spin_unlock_irqrestore(&amp;clk_lock, flags);
<span class="p_chunk">@@ -129,6 +138,9 @@</span> <span class="p_context"> long clk_round_rate(struct clk *clk, unsigned long rate)</span>
 {
 	unsigned long flags, actual_rate;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!clk-&gt;set_rate)
 		return -ENOSYS;
 
<span class="p_chunk">@@ -145,6 +157,9 @@</span> <span class="p_context"> int clk_set_rate(struct clk *clk, unsigned long rate)</span>
 	unsigned long flags;
 	long ret;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!clk-&gt;set_rate)
 		return -ENOSYS;
 
<span class="p_chunk">@@ -161,6 +176,9 @@</span> <span class="p_context"> int clk_set_parent(struct clk *clk, struct clk *parent)</span>
 	unsigned long flags;
 	int ret;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!clk-&gt;set_parent)
 		return -ENOSYS;
 
<span class="p_chunk">@@ -174,7 +192,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(clk_set_parent);</span>
 
 struct clk *clk_get_parent(struct clk *clk)
 {
<span class="p_del">-	return clk-&gt;parent;</span>
<span class="p_add">+	return !clk ? NULL : clk-&gt;parent;</span>
 }
 EXPORT_SYMBOL(clk_get_parent);
 
<span class="p_header">diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig</span>
<span class="p_header">index f5016656494f..a3b1ffe50aa0 100644</span>
<span class="p_header">--- a/arch/mips/Kconfig</span>
<span class="p_header">+++ b/arch/mips/Kconfig</span>
<span class="p_chunk">@@ -1417,6 +1417,7 @@</span> <span class="p_context"> config CPU_MIPS64_R6</span>
 	select CPU_SUPPORTS_HIGHMEM
 	select CPU_SUPPORTS_MSA
 	select GENERIC_CSUM
<span class="p_add">+	select MIPS_O32_FP64_SUPPORT if MIPS32_O32</span>
 	help
 	  Choose this option to build a kernel for release 6 or later of the
 	  MIPS64 architecture.  New MIPS processors, starting with the Warrior
<span class="p_header">diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h</span>
<span class="p_header">index 084780b355aa..1b0625189835 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/fpu.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/fpu.h</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> static inline int __enable_fpu(enum fpu_mode mode)</span>
 		goto fr_common;
 
 	case FPU_64BIT:
<span class="p_del">-#if !(defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_CPU_MIPS32_R6) \</span>
<span class="p_add">+#if !(defined(CONFIG_CPU_MIPSR2) || defined(CONFIG_CPU_MIPSR6) \</span>
       || defined(CONFIG_64BIT))
 		/* we only have a 32-bit FPU */
 		return SIGFPE;
<span class="p_header">diff --git a/arch/mips/include/asm/smp.h b/arch/mips/include/asm/smp.h</span>
<span class="p_header">index 2b25d1ba1ea0..16f1ea9ab191 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/smp.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/smp.h</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 extern int smp_num_siblings;
 extern cpumask_t cpu_sibling_map[];
 extern cpumask_t cpu_core_map[];
<span class="p_add">+extern cpumask_t cpu_foreign_map;</span>
 
 #define raw_smp_processor_id() (current_thread_info()-&gt;cpu)
 
<span class="p_header">diff --git a/arch/mips/kernel/smp.c b/arch/mips/kernel/smp.c</span>
<span class="p_header">index faa46ebd9dda..d0744cc77ea7 100644</span>
<span class="p_header">--- a/arch/mips/kernel/smp.c</span>
<span class="p_header">+++ b/arch/mips/kernel/smp.c</span>
<span class="p_chunk">@@ -63,6 +63,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(cpu_sibling_map);</span>
 cpumask_t cpu_core_map[NR_CPUS] __read_mostly;
 EXPORT_SYMBOL(cpu_core_map);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * A logcal cpu mask containing only one VPE per core to</span>
<span class="p_add">+ * reduce the number of IPIs on large MT systems.</span>
<span class="p_add">+ */</span>
<span class="p_add">+cpumask_t cpu_foreign_map __read_mostly;</span>
<span class="p_add">+EXPORT_SYMBOL(cpu_foreign_map);</span>
<span class="p_add">+</span>
 /* representing cpus for which sibling maps can be computed */
 static cpumask_t cpu_sibling_setup_map;
 
<span class="p_chunk">@@ -103,6 +110,29 @@</span> <span class="p_context"> static inline void set_cpu_core_map(int cpu)</span>
 	}
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Calculate a new cpu_foreign_map mask whenever a</span>
<span class="p_add">+ * new cpu appears or disappears.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void calculate_cpu_foreign_map(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i, k, core_present;</span>
<span class="p_add">+	cpumask_t temp_foreign_map;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Re-calculate the mask */</span>
<span class="p_add">+	for_each_online_cpu(i) {</span>
<span class="p_add">+		core_present = 0;</span>
<span class="p_add">+		for_each_cpu(k, &amp;temp_foreign_map)</span>
<span class="p_add">+			if (cpu_data[i].package == cpu_data[k].package &amp;&amp;</span>
<span class="p_add">+			    cpu_data[i].core == cpu_data[k].core)</span>
<span class="p_add">+				core_present = 1;</span>
<span class="p_add">+		if (!core_present)</span>
<span class="p_add">+			cpumask_set_cpu(i, &amp;temp_foreign_map);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cpumask_copy(&amp;cpu_foreign_map, &amp;temp_foreign_map);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct plat_smp_ops *mp_ops;
 EXPORT_SYMBOL(mp_ops);
 
<span class="p_chunk">@@ -146,6 +176,8 @@</span> <span class="p_context"> asmlinkage void start_secondary(void)</span>
 	set_cpu_sibling_map(cpu);
 	set_cpu_core_map(cpu);
 
<span class="p_add">+	calculate_cpu_foreign_map();</span>
<span class="p_add">+</span>
 	cpumask_set_cpu(cpu, &amp;cpu_callin_map);
 
 	synchronise_count_slave(cpu);
<span class="p_chunk">@@ -173,9 +205,18 @@</span> <span class="p_context"> void __irq_entry smp_call_function_interrupt(void)</span>
 static void stop_this_cpu(void *dummy)
 {
 	/*
<span class="p_del">-	 * Remove this CPU:</span>
<span class="p_add">+	 * Remove this CPU. Be a bit slow here and</span>
<span class="p_add">+	 * set the bits for every online CPU so we don&#39;t miss</span>
<span class="p_add">+	 * any IPI whilst taking this VPE down.</span>
 	 */
<span class="p_add">+</span>
<span class="p_add">+	cpumask_copy(&amp;cpu_foreign_map, cpu_online_mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make it visible to every other CPU */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	set_cpu_online(smp_processor_id(), false);
<span class="p_add">+	calculate_cpu_foreign_map();</span>
 	local_irq_disable();
 	while (1);
 }
<span class="p_chunk">@@ -197,6 +238,7 @@</span> <span class="p_context"> void __init smp_prepare_cpus(unsigned int max_cpus)</span>
 	mp_ops-&gt;prepare_cpus(max_cpus);
 	set_cpu_sibling_map(0);
 	set_cpu_core_map(0);
<span class="p_add">+	calculate_cpu_foreign_map();</span>
 #ifndef CONFIG_HOTPLUG_CPU
 	init_cpu_present(cpu_possible_mask);
 #endif
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index 22b9b2cb9219..6983fcd48131 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -451,7 +451,7 @@</span> <span class="p_context"> static int isBranchInstr(struct pt_regs *regs, struct mm_decoded_insn dec_insn,</span>
 			/* Fall through */
 		case jr_op:
 			/* For R6, JR already emulated in jalr_op */
<span class="p_del">-			if (NO_R6EMU &amp;&amp; insn.r_format.opcode == jr_op)</span>
<span class="p_add">+			if (NO_R6EMU &amp;&amp; insn.r_format.func == jr_op)</span>
 				break;
 			*contpc = regs-&gt;regs[insn.r_format.rs];
 			return 1;
<span class="p_header">diff --git a/arch/mips/mm/c-r4k.c b/arch/mips/mm/c-r4k.c</span>
<span class="p_header">index 2e03ab173591..dca0efc078c1 100644</span>
<span class="p_header">--- a/arch/mips/mm/c-r4k.c</span>
<span class="p_header">+++ b/arch/mips/mm/c-r4k.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/cacheflush.h&gt; /* for run_uncached() */
 #include &lt;asm/traps.h&gt;
 #include &lt;asm/dma-coherence.h&gt;
<span class="p_add">+#include &lt;asm/mips-cm.h&gt;</span>
 
 /*
  * Special Variant of smp_call_function for use by cache functions:
<span class="p_chunk">@@ -51,9 +52,16 @@</span> <span class="p_context"> static inline void r4k_on_each_cpu(void (*func) (void *info), void *info)</span>
 {
 	preempt_disable();
 
<span class="p_del">-#ifndef CONFIG_MIPS_MT_SMP</span>
<span class="p_del">-	smp_call_function(func, info, 1);</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The Coherent Manager propagates address-based cache ops to other</span>
<span class="p_add">+	 * cores but not index-based ops. However, r4k_on_each_cpu is used</span>
<span class="p_add">+	 * in both cases so there is no easy way to tell what kind of op is</span>
<span class="p_add">+	 * executed to the other cores. The best we can probably do is</span>
<span class="p_add">+	 * to restrict that call when a CM is not present because both</span>
<span class="p_add">+	 * CM-based SMP protocols (CMP &amp; CPS) restrict index-based cache ops.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!mips_cm_present())</span>
<span class="p_add">+		smp_call_function_many(&amp;cpu_foreign_map, func, info, 1);</span>
 	func(info);
 	preempt_enable();
 }
<span class="p_header">diff --git a/arch/parisc/include/asm/pgalloc.h b/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_header">index 3a08eae3318f..3edbb9fc91b4 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 
 static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)
 {
<span class="p_del">-	if(pmd_flag(*pmd) &amp; PxD_FLAG_ATTACHED)</span>
<span class="p_add">+	if (pmd_flag(*pmd) &amp; PxD_FLAG_ATTACHED) {</span>
 		/*
 		 * This is the permanent pmd attached to the pgd;
 		 * cannot free it.
<span class="p_chunk">@@ -81,6 +81,7 @@</span> <span class="p_context"> static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)</span>
 		 */
 		mm_inc_nr_pmds(mm);
 		return;
<span class="p_add">+	}</span>
 	free_pages((unsigned long)pmd, PMD_ORDER);
 }
 
<span class="p_header">diff --git a/arch/parisc/include/asm/pgtable.h b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">index 0a183756d6ec..f93c4a4e6580 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/processor.h&gt;
 #include &lt;asm/cache.h&gt;
 
<span class="p_del">-extern spinlock_t pa_dbit_lock;</span>
<span class="p_add">+extern spinlock_t pa_tlb_lock;</span>
 
 /*
  * kern_addr_valid(ADDR) tests if ADDR is pointing to valid kernel
<span class="p_chunk">@@ -33,6 +33,19 @@</span> <span class="p_context"> extern spinlock_t pa_dbit_lock;</span>
  */
 #define kern_addr_valid(addr)	(1)
 
<span class="p_add">+/* Purge data and instruction TLB entries.  Must be called holding</span>
<span class="p_add">+ * the pa_tlb_lock.  The TLB purge instructions are slow on SMP</span>
<span class="p_add">+ * machines since the purge must be broadcast to all CPUs.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void purge_tlb_entries(struct mm_struct *mm, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mtsp(mm-&gt;context, 1);</span>
<span class="p_add">+	pdtlb(addr);</span>
<span class="p_add">+	if (unlikely(split_tlb))</span>
<span class="p_add">+		pitlb(addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Certain architectures need to do special things when PTEs
  * within a page table are directly modified.  Thus, the following
  * hook is made available.
<span class="p_chunk">@@ -42,15 +55,20 @@</span> <span class="p_context"> extern spinlock_t pa_dbit_lock;</span>
                 *(pteptr) = (pteval);                           \
         } while(0)
 
<span class="p_del">-extern void purge_tlb_entries(struct mm_struct *, unsigned long);</span>
<span class="p_add">+#define pte_inserted(x)						\</span>
<span class="p_add">+	((pte_val(x) &amp; (_PAGE_PRESENT|_PAGE_ACCESSED))		\</span>
<span class="p_add">+	 == (_PAGE_PRESENT|_PAGE_ACCESSED))</span>
 
<span class="p_del">-#define set_pte_at(mm, addr, ptep, pteval)                      \</span>
<span class="p_del">-	do {                                                    \</span>
<span class="p_add">+#define set_pte_at(mm, addr, ptep, pteval)			\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		pte_t old_pte;					\</span>
 		unsigned long flags;				\
<span class="p_del">-		spin_lock_irqsave(&amp;pa_dbit_lock, flags);	\</span>
<span class="p_del">-		set_pte(ptep, pteval);                          \</span>
<span class="p_del">-		purge_tlb_entries(mm, addr);                    \</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);	\</span>
<span class="p_add">+		spin_lock_irqsave(&amp;pa_tlb_lock, flags);		\</span>
<span class="p_add">+		old_pte = *ptep;				\</span>
<span class="p_add">+		set_pte(ptep, pteval);				\</span>
<span class="p_add">+		if (pte_inserted(old_pte))			\</span>
<span class="p_add">+			purge_tlb_entries(mm, addr);		\</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);	\</span>
 	} while (0)
 
 #endif /* !__ASSEMBLY__ */
<span class="p_chunk">@@ -268,7 +286,7 @@</span> <span class="p_context"> extern unsigned long *empty_zero_page;</span>
 
 #define pte_none(x)     (pte_val(x) == 0)
 #define pte_present(x)	(pte_val(x) &amp; _PAGE_PRESENT)
<span class="p_del">-#define pte_clear(mm,addr,xp)	do { pte_val(*(xp)) = 0; } while (0)</span>
<span class="p_add">+#define pte_clear(mm, addr, xp)  set_pte_at(mm, addr, xp, __pte(0))</span>
 
 #define pmd_flag(x)	(pmd_val(x) &amp; PxD_FLAG_MASK)
 #define pmd_address(x)	((unsigned long)(pmd_val(x) &amp;~ PxD_FLAG_MASK) &lt;&lt; PxD_VALUE_SHIFT)
<span class="p_chunk">@@ -435,15 +453,15 @@</span> <span class="p_context"> static inline int ptep_test_and_clear_young(struct vm_area_struct *vma, unsigned</span>
 	if (!pte_young(*ptep))
 		return 0;
 
<span class="p_del">-	spin_lock_irqsave(&amp;pa_dbit_lock, flags);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;pa_tlb_lock, flags);</span>
 	pte = *ptep;
 	if (!pte_young(pte)) {
<span class="p_del">-		spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);</span>
 		return 0;
 	}
 	set_pte(ptep, pte_mkold(pte));
 	purge_tlb_entries(vma-&gt;vm_mm, addr);
<span class="p_del">-	spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);</span>
 	return 1;
 }
 
<span class="p_chunk">@@ -453,11 +471,12 @@</span> <span class="p_context"> static inline pte_t ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,</span>
 	pte_t old_pte;
 	unsigned long flags;
 
<span class="p_del">-	spin_lock_irqsave(&amp;pa_dbit_lock, flags);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;pa_tlb_lock, flags);</span>
 	old_pte = *ptep;
<span class="p_del">-	pte_clear(mm,addr,ptep);</span>
<span class="p_del">-	purge_tlb_entries(mm, addr);</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);</span>
<span class="p_add">+	set_pte(ptep, __pte(0));</span>
<span class="p_add">+	if (pte_inserted(old_pte))</span>
<span class="p_add">+		purge_tlb_entries(mm, addr);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);</span>
 
 	return old_pte;
 }
<span class="p_chunk">@@ -465,10 +484,10 @@</span> <span class="p_context"> static inline pte_t ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,</span>
 static inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
 	unsigned long flags;
<span class="p_del">-	spin_lock_irqsave(&amp;pa_dbit_lock, flags);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;pa_tlb_lock, flags);</span>
 	set_pte(ptep, pte_wrprotect(*ptep));
 	purge_tlb_entries(mm, addr);
<span class="p_del">-	spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;pa_tlb_lock, flags);</span>
 }
 
 #define pte_same(A,B)	(pte_val(A) == pte_val(B))
<span class="p_header">diff --git a/arch/parisc/include/asm/tlbflush.h b/arch/parisc/include/asm/tlbflush.h</span>
<span class="p_header">index 9d086a599fa0..e84b96478193 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -13,6 +13,9 @@</span> <span class="p_context"></span>
  * active at any one time on the Merced bus.  This tlb purge
  * synchronisation is fairly lightweight and harmless so we activate
  * it on all systems not just the N class.
<span class="p_add">+</span>
<span class="p_add">+ * It is also used to ensure PTE updates are atomic and consistent</span>
<span class="p_add">+ * with the TLB.</span>
  */
 extern spinlock_t pa_tlb_lock;
 
<span class="p_chunk">@@ -24,20 +27,24 @@</span> <span class="p_context"> extern void flush_tlb_all_local(void *);</span>
 
 #define smp_flush_tlb_all()	flush_tlb_all()
 
<span class="p_add">+int __flush_tlb_range(unsigned long sid,</span>
<span class="p_add">+	unsigned long start, unsigned long end);</span>
<span class="p_add">+</span>
<span class="p_add">+#define flush_tlb_range(vma, start, end) \</span>
<span class="p_add">+	__flush_tlb_range((vma)-&gt;vm_mm-&gt;context, start, end)</span>
<span class="p_add">+</span>
<span class="p_add">+#define flush_tlb_kernel_range(start, end) \</span>
<span class="p_add">+	__flush_tlb_range(0, start, end)</span>
<span class="p_add">+</span>
 /*
  * flush_tlb_mm()
  *
<span class="p_del">- * XXX This code is NOT valid for HP-UX compatibility processes,</span>
<span class="p_del">- * (although it will probably work 99% of the time). HP-UX</span>
<span class="p_del">- * processes are free to play with the space id&#39;s and save them</span>
<span class="p_del">- * over long periods of time, etc. so we have to preserve the</span>
<span class="p_del">- * space and just flush the entire tlb. We need to check the</span>
<span class="p_del">- * personality in order to do that, but the personality is not</span>
<span class="p_del">- * currently being set correctly.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Of course, Linux processes could do the same thing, but</span>
<span class="p_del">- * we don&#39;t support that (and the compilers, dynamic linker,</span>
<span class="p_del">- * etc. do not do that).</span>
<span class="p_add">+ * The code to switch to a new context is NOT valid for processes</span>
<span class="p_add">+ * which play with the space id&#39;s.  Thus, we have to preserve the</span>
<span class="p_add">+ * space and just flush the entire tlb.  However, the compilers,</span>
<span class="p_add">+ * dynamic linker, etc, do not manipulate space id&#39;s, so there</span>
<span class="p_add">+ * could be a significant performance benefit in switching contexts</span>
<span class="p_add">+ * and not flushing the whole tlb.</span>
  */
 
 static inline void flush_tlb_mm(struct mm_struct *mm)
<span class="p_chunk">@@ -45,10 +52,18 @@</span> <span class="p_context"> static inline void flush_tlb_mm(struct mm_struct *mm)</span>
 	BUG_ON(mm == &amp;init_mm); /* Should never happen */
 
 #if 1 || defined(CONFIG_SMP)
<span class="p_add">+	/* Except for very small threads, flushing the whole TLB is</span>
<span class="p_add">+	 * faster than using __flush_tlb_range.  The pdtlb and pitlb</span>
<span class="p_add">+	 * instructions are very slow because of the TLB broadcast.</span>
<span class="p_add">+	 * It might be faster to do local range flushes on all CPUs</span>
<span class="p_add">+	 * on PA 2.0 systems.</span>
<span class="p_add">+	 */</span>
 	flush_tlb_all();
 #else
 	/* FIXME: currently broken, causing space id and protection ids
<span class="p_del">-	 *  to go out of sync, resulting in faults on userspace accesses.</span>
<span class="p_add">+	 * to go out of sync, resulting in faults on userspace accesses.</span>
<span class="p_add">+	 * This approach needs further investigation since running many</span>
<span class="p_add">+	 * small applications (e.g., GCC testsuite) is faster on HP-UX.</span>
 	 */
 	if (mm) {
 		if (mm-&gt;context != 0)
<span class="p_chunk">@@ -65,22 +80,12 @@</span> <span class="p_context"> static inline void flush_tlb_page(struct vm_area_struct *vma,</span>
 {
 	unsigned long flags, sid;
 
<span class="p_del">-	/* For one page, it&#39;s not worth testing the split_tlb variable */</span>
<span class="p_del">-</span>
<span class="p_del">-	mb();</span>
 	sid = vma-&gt;vm_mm-&gt;context;
 	purge_tlb_start(flags);
 	mtsp(sid, 1);
 	pdtlb(addr);
<span class="p_del">-	pitlb(addr);</span>
<span class="p_add">+	if (unlikely(split_tlb))</span>
<span class="p_add">+		pitlb(addr);</span>
 	purge_tlb_end(flags);
 }
<span class="p_del">-</span>
<span class="p_del">-void __flush_tlb_range(unsigned long sid,</span>
<span class="p_del">-	unsigned long start, unsigned long end);</span>
<span class="p_del">-</span>
<span class="p_del">-#define flush_tlb_range(vma,start,end) __flush_tlb_range((vma)-&gt;vm_mm-&gt;context,start,end)</span>
<span class="p_del">-</span>
<span class="p_del">-#define flush_tlb_kernel_range(start, end) __flush_tlb_range(0,start,end)</span>
<span class="p_del">-</span>
 #endif
<span class="p_header">diff --git a/arch/parisc/kernel/cache.c b/arch/parisc/kernel/cache.c</span>
<span class="p_header">index f6448c7c62b5..cda6dbbe9842 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/cache.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/cache.c</span>
<span class="p_chunk">@@ -342,12 +342,15 @@</span> <span class="p_context"> EXPORT_SYMBOL(flush_data_cache_local);</span>
 EXPORT_SYMBOL(flush_kernel_icache_range_asm);
 
 #define FLUSH_THRESHOLD 0x80000 /* 0.5MB */
<span class="p_del">-int parisc_cache_flush_threshold __read_mostly = FLUSH_THRESHOLD;</span>
<span class="p_add">+static unsigned long parisc_cache_flush_threshold __read_mostly = FLUSH_THRESHOLD;</span>
<span class="p_add">+</span>
<span class="p_add">+#define FLUSH_TLB_THRESHOLD (2*1024*1024) /* 2MB initial TLB threshold */</span>
<span class="p_add">+static unsigned long parisc_tlb_flush_threshold __read_mostly = FLUSH_TLB_THRESHOLD;</span>
 
 void __init parisc_setup_cache_timing(void)
 {
 	unsigned long rangetime, alltime;
<span class="p_del">-	unsigned long size;</span>
<span class="p_add">+	unsigned long size, start;</span>
 
 	alltime = mfctl(16);
 	flush_data_cache();
<span class="p_chunk">@@ -364,14 +367,43 @@</span> <span class="p_context"> void __init parisc_setup_cache_timing(void)</span>
 	/* Racy, but if we see an intermediate value, it&#39;s ok too... */
 	parisc_cache_flush_threshold = size * alltime / rangetime;
 
<span class="p_del">-	parisc_cache_flush_threshold = (parisc_cache_flush_threshold + L1_CACHE_BYTES - 1) &amp;~ (L1_CACHE_BYTES - 1); </span>
<span class="p_add">+	parisc_cache_flush_threshold = L1_CACHE_ALIGN(parisc_cache_flush_threshold);</span>
 	if (!parisc_cache_flush_threshold)
 		parisc_cache_flush_threshold = FLUSH_THRESHOLD;
 
 	if (parisc_cache_flush_threshold &gt; cache_info.dc_size)
 		parisc_cache_flush_threshold = cache_info.dc_size;
 
<span class="p_del">-	printk(KERN_INFO &quot;Setting cache flush threshold to %x (%d CPUs online)\n&quot;, parisc_cache_flush_threshold, num_online_cpus());</span>
<span class="p_add">+	printk(KERN_INFO &quot;Setting cache flush threshold to %lu kB\n&quot;,</span>
<span class="p_add">+		parisc_cache_flush_threshold/1024);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* calculate TLB flush threshold */</span>
<span class="p_add">+</span>
<span class="p_add">+	alltime = mfctl(16);</span>
<span class="p_add">+	flush_tlb_all();</span>
<span class="p_add">+	alltime = mfctl(16) - alltime;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = PAGE_SIZE;</span>
<span class="p_add">+	start = (unsigned long) _text;</span>
<span class="p_add">+	rangetime = mfctl(16);</span>
<span class="p_add">+	while (start &lt; (unsigned long) _end) {</span>
<span class="p_add">+		flush_tlb_kernel_range(start, start + PAGE_SIZE);</span>
<span class="p_add">+		start += PAGE_SIZE;</span>
<span class="p_add">+		size += PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rangetime = mfctl(16) - rangetime;</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(KERN_DEBUG &quot;Whole TLB flush %lu cycles, flushing %lu bytes %lu cycles\n&quot;,</span>
<span class="p_add">+		alltime, size, rangetime);</span>
<span class="p_add">+</span>
<span class="p_add">+	parisc_tlb_flush_threshold = size * alltime / rangetime;</span>
<span class="p_add">+	parisc_tlb_flush_threshold *= num_online_cpus();</span>
<span class="p_add">+	parisc_tlb_flush_threshold = PAGE_ALIGN(parisc_tlb_flush_threshold);</span>
<span class="p_add">+	if (!parisc_tlb_flush_threshold)</span>
<span class="p_add">+		parisc_tlb_flush_threshold = FLUSH_TLB_THRESHOLD;</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(KERN_INFO &quot;Setting TLB flush threshold to %lu kB\n&quot;,</span>
<span class="p_add">+		parisc_tlb_flush_threshold/1024);</span>
 }
 
 extern void purge_kernel_dcache_page_asm(unsigned long);
<span class="p_chunk">@@ -403,48 +435,45 @@</span> <span class="p_context"> void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,</span>
 }
 EXPORT_SYMBOL(copy_user_page);
 
<span class="p_del">-void purge_tlb_entries(struct mm_struct *mm, unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Note: purge_tlb_entries can be called at startup with</span>
<span class="p_del">-	   no context.  */</span>
<span class="p_del">-</span>
<span class="p_del">-	purge_tlb_start(flags);</span>
<span class="p_del">-	mtsp(mm-&gt;context, 1);</span>
<span class="p_del">-	pdtlb(addr);</span>
<span class="p_del">-	pitlb(addr);</span>
<span class="p_del">-	purge_tlb_end(flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(purge_tlb_entries);</span>
<span class="p_del">-</span>
<span class="p_del">-void __flush_tlb_range(unsigned long sid, unsigned long start,</span>
<span class="p_del">-		       unsigned long end)</span>
<span class="p_add">+/* __flush_tlb_range()</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * returns 1 if all TLBs were flushed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __flush_tlb_range(unsigned long sid, unsigned long start,</span>
<span class="p_add">+		      unsigned long end)</span>
 {
<span class="p_del">-	unsigned long npages;</span>
<span class="p_add">+	unsigned long flags, size;</span>
 
<span class="p_del">-	npages = ((end - (start &amp; PAGE_MASK)) + (PAGE_SIZE - 1)) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-	if (npages &gt;= 512)  /* 2MB of space: arbitrary, should be tuned */</span>
<span class="p_add">+	size = (end - start);</span>
<span class="p_add">+	if (size &gt;= parisc_tlb_flush_threshold) {</span>
 		flush_tlb_all();
<span class="p_del">-	else {</span>
<span class="p_del">-		unsigned long flags;</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	/* Purge TLB entries for small ranges using the pdtlb and</span>
<span class="p_add">+	   pitlb instructions.  These instructions execute locally</span>
<span class="p_add">+	   but cause a purge request to be broadcast to other TLBs.  */</span>
<span class="p_add">+	if (likely(!split_tlb)) {</span>
<span class="p_add">+		while (start &lt; end) {</span>
<span class="p_add">+			purge_tlb_start(flags);</span>
<span class="p_add">+			mtsp(sid, 1);</span>
<span class="p_add">+			pdtlb(start);</span>
<span class="p_add">+			purge_tlb_end(flags);</span>
<span class="p_add">+			start += PAGE_SIZE;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* split TLB case */</span>
<span class="p_add">+	while (start &lt; end) {</span>
 		purge_tlb_start(flags);
 		mtsp(sid, 1);
<span class="p_del">-		if (split_tlb) {</span>
<span class="p_del">-			while (npages--) {</span>
<span class="p_del">-				pdtlb(start);</span>
<span class="p_del">-				pitlb(start);</span>
<span class="p_del">-				start += PAGE_SIZE;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			while (npages--) {</span>
<span class="p_del">-				pdtlb(start);</span>
<span class="p_del">-				start += PAGE_SIZE;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_add">+		pdtlb(start);</span>
<span class="p_add">+		pitlb(start);</span>
 		purge_tlb_end(flags);
<span class="p_add">+		start += PAGE_SIZE;</span>
 	}
<span class="p_add">+	return 0;</span>
 }
 
 static void cacheflush_h_tmp_function(void *dummy)
<span class="p_header">diff --git a/arch/parisc/kernel/entry.S b/arch/parisc/kernel/entry.S</span>
<span class="p_header">index 75819617f93b..c5ef4081b01d 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/entry.S</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"></span>
 	.level 2.0
 #endif
 
<span class="p_del">-	.import         pa_dbit_lock,data</span>
<span class="p_add">+	.import		pa_tlb_lock,data</span>
 
 	/* space_to_prot macro creates a prot id from a space id */
 
<span class="p_chunk">@@ -420,8 +420,8 @@</span> <span class="p_context"></span>
 	SHLREG		%r9,PxD_VALUE_SHIFT,\pmd
 	extru		\va,31-PAGE_SHIFT,ASM_BITS_PER_PTE,\index
 	dep		%r0,31,PAGE_SHIFT,\pmd  /* clear offset */
<span class="p_del">-	shladd		\index,BITS_PER_PTE_ENTRY,\pmd,\pmd</span>
<span class="p_del">-	LDREG		%r0(\pmd),\pte		/* pmd is now pte */</span>
<span class="p_add">+	shladd		\index,BITS_PER_PTE_ENTRY,\pmd,\pmd /* pmd is now pte */</span>
<span class="p_add">+	LDREG		%r0(\pmd),\pte</span>
 	bb,&gt;=,n		\pte,_PAGE_PRESENT_BIT,\fault
 	.endm
 
<span class="p_chunk">@@ -453,57 +453,53 @@</span> <span class="p_context"></span>
 	L2_ptep		\pgd,\pte,\index,\va,\fault
 	.endm
 
<span class="p_del">-	/* Acquire pa_dbit_lock lock. */</span>
<span class="p_del">-	.macro		dbit_lock	spc,tmp,tmp1</span>
<span class="p_add">+	/* Acquire pa_tlb_lock lock and recheck page is still present. */</span>
<span class="p_add">+	.macro		tlb_lock	spc,ptp,pte,tmp,tmp1,fault</span>
 #ifdef CONFIG_SMP
 	cmpib,COND(=),n	0,\spc,2f
<span class="p_del">-	load32		PA(pa_dbit_lock),\tmp</span>
<span class="p_add">+	load32		PA(pa_tlb_lock),\tmp</span>
 1:	LDCW		0(\tmp),\tmp1
 	cmpib,COND(=)	0,\tmp1,1b
 	nop
<span class="p_add">+	LDREG		0(\ptp),\pte</span>
<span class="p_add">+	bb,&lt;,n		\pte,_PAGE_PRESENT_BIT,2f</span>
<span class="p_add">+	b		\fault</span>
<span class="p_add">+	stw		 \spc,0(\tmp)</span>
 2:
 #endif
 	.endm
 
<span class="p_del">-	/* Release pa_dbit_lock lock without reloading lock address. */</span>
<span class="p_del">-	.macro		dbit_unlock0	spc,tmp</span>
<span class="p_add">+	/* Release pa_tlb_lock lock without reloading lock address. */</span>
<span class="p_add">+	.macro		tlb_unlock0	spc,tmp</span>
 #ifdef CONFIG_SMP
 	or,COND(=)	%r0,\spc,%r0
 	stw             \spc,0(\tmp)
 #endif
 	.endm
 
<span class="p_del">-	/* Release pa_dbit_lock lock. */</span>
<span class="p_del">-	.macro		dbit_unlock1	spc,tmp</span>
<span class="p_add">+	/* Release pa_tlb_lock lock. */</span>
<span class="p_add">+	.macro		tlb_unlock1	spc,tmp</span>
 #ifdef CONFIG_SMP
<span class="p_del">-	load32		PA(pa_dbit_lock),\tmp</span>
<span class="p_del">-	dbit_unlock0	\spc,\tmp</span>
<span class="p_add">+	load32		PA(pa_tlb_lock),\tmp</span>
<span class="p_add">+	tlb_unlock0	\spc,\tmp</span>
 #endif
 	.endm
 
 	/* Set the _PAGE_ACCESSED bit of the PTE.  Be clever and
 	 * don&#39;t needlessly dirty the cache line if it was already set */
<span class="p_del">-	.macro		update_ptep	spc,ptep,pte,tmp,tmp1</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-	or,COND(=)	%r0,\spc,%r0</span>
<span class="p_del">-	LDREG		0(\ptep),\pte</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	.macro		update_accessed	ptp,pte,tmp,tmp1</span>
 	ldi		_PAGE_ACCESSED,\tmp1
 	or		\tmp1,\pte,\tmp
 	and,COND(&lt;&gt;)	\tmp1,\pte,%r0
<span class="p_del">-	STREG		\tmp,0(\ptep)</span>
<span class="p_add">+	STREG		\tmp,0(\ptp)</span>
 	.endm
 
 	/* Set the dirty bit (and accessed bit).  No need to be
 	 * clever, this is only used from the dirty fault */
<span class="p_del">-	.macro		update_dirty	spc,ptep,pte,tmp</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-	or,COND(=)	%r0,\spc,%r0</span>
<span class="p_del">-	LDREG		0(\ptep),\pte</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	.macro		update_dirty	ptp,pte,tmp</span>
 	ldi		_PAGE_ACCESSED|_PAGE_DIRTY,\tmp
 	or		\tmp,\pte,\pte
<span class="p_del">-	STREG		\pte,0(\ptep)</span>
<span class="p_add">+	STREG		\pte,0(\ptp)</span>
 	.endm
 
 	/* bitshift difference between a PFN (based on kernel&#39;s PAGE_SIZE)
<span class="p_chunk">@@ -1148,14 +1144,14 @@</span> <span class="p_context"> dtlb_miss_20w:</span>
 
 	L3_ptep		ptp,pte,t0,va,dtlb_check_alias_20w
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,dtlb_check_alias_20w</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 	
 	idtlbt          pte,prot
<span class="p_del">-	dbit_unlock1	spc,t0</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1174,14 +1170,14 @@</span> <span class="p_context"> nadtlb_miss_20w:</span>
 
 	L3_ptep		ptp,pte,t0,va,nadtlb_check_alias_20w
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,nadtlb_check_alias_20w</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 
 	idtlbt          pte,prot
<span class="p_del">-	dbit_unlock1	spc,t0</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1202,20 +1198,20 @@</span> <span class="p_context"> dtlb_miss_11:</span>
 
 	L2_ptep		ptp,pte,t0,va,dtlb_check_alias_11
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,dtlb_check_alias_11</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb_11	spc,pte,prot
 
<span class="p_del">-	mfsp		%sr1,t0  /* Save sr1 so we can use it in tlb inserts */</span>
<span class="p_add">+	mfsp		%sr1,t1  /* Save sr1 so we can use it in tlb inserts */</span>
 	mtsp		spc,%sr1
 
 	idtlba		pte,(%sr1,va)
 	idtlbp		prot,(%sr1,va)
 
<span class="p_del">-	mtsp		t0, %sr1	/* Restore sr1 */</span>
<span class="p_del">-	dbit_unlock1	spc,t0</span>
<span class="p_add">+	mtsp		t1, %sr1	/* Restore sr1 */</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1235,21 +1231,20 @@</span> <span class="p_context"> nadtlb_miss_11:</span>
 
 	L2_ptep		ptp,pte,t0,va,nadtlb_check_alias_11
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,nadtlb_check_alias_11</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb_11	spc,pte,prot
 
<span class="p_del">-</span>
<span class="p_del">-	mfsp		%sr1,t0  /* Save sr1 so we can use it in tlb inserts */</span>
<span class="p_add">+	mfsp		%sr1,t1  /* Save sr1 so we can use it in tlb inserts */</span>
 	mtsp		spc,%sr1
 
 	idtlba		pte,(%sr1,va)
 	idtlbp		prot,(%sr1,va)
 
<span class="p_del">-	mtsp		t0, %sr1	/* Restore sr1 */</span>
<span class="p_del">-	dbit_unlock1	spc,t0</span>
<span class="p_add">+	mtsp		t1, %sr1	/* Restore sr1 */</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1269,16 +1264,16 @@</span> <span class="p_context"> dtlb_miss_20:</span>
 
 	L2_ptep		ptp,pte,t0,va,dtlb_check_alias_20
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,dtlb_check_alias_20</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 
<span class="p_del">-	f_extend	pte,t0</span>
<span class="p_add">+	f_extend	pte,t1</span>
 
 	idtlbt          pte,prot
<span class="p_del">-	dbit_unlock1	spc,t0</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1297,16 +1292,16 @@</span> <span class="p_context"> nadtlb_miss_20:</span>
 
 	L2_ptep		ptp,pte,t0,va,nadtlb_check_alias_20
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,nadtlb_check_alias_20</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 
<span class="p_del">-	f_extend	pte,t0</span>
<span class="p_add">+	f_extend	pte,t1</span>
 	
<span class="p_del">-        idtlbt          pte,prot</span>
<span class="p_del">-	dbit_unlock1	spc,t0</span>
<span class="p_add">+	idtlbt		pte,prot</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1406,14 +1401,14 @@</span> <span class="p_context"> itlb_miss_20w:</span>
 
 	L3_ptep		ptp,pte,t0,va,itlb_fault
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,itlb_fault</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 	
 	iitlbt          pte,prot
<span class="p_del">-	dbit_unlock1	spc,t0</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1430,14 +1425,14 @@</span> <span class="p_context"> naitlb_miss_20w:</span>
 
 	L3_ptep		ptp,pte,t0,va,naitlb_check_alias_20w
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,naitlb_check_alias_20w</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 
 	iitlbt          pte,prot
<span class="p_del">-	dbit_unlock1	spc,t0</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1458,20 +1453,20 @@</span> <span class="p_context"> itlb_miss_11:</span>
 
 	L2_ptep		ptp,pte,t0,va,itlb_fault
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,itlb_fault</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb_11	spc,pte,prot
 
<span class="p_del">-	mfsp		%sr1,t0  /* Save sr1 so we can use it in tlb inserts */</span>
<span class="p_add">+	mfsp		%sr1,t1  /* Save sr1 so we can use it in tlb inserts */</span>
 	mtsp		spc,%sr1
 
 	iitlba		pte,(%sr1,va)
 	iitlbp		prot,(%sr1,va)
 
<span class="p_del">-	mtsp		t0, %sr1	/* Restore sr1 */</span>
<span class="p_del">-	dbit_unlock1	spc,t0</span>
<span class="p_add">+	mtsp		t1, %sr1	/* Restore sr1 */</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1482,20 +1477,20 @@</span> <span class="p_context"> naitlb_miss_11:</span>
 
 	L2_ptep		ptp,pte,t0,va,naitlb_check_alias_11
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,naitlb_check_alias_11</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb_11	spc,pte,prot
 
<span class="p_del">-	mfsp		%sr1,t0  /* Save sr1 so we can use it in tlb inserts */</span>
<span class="p_add">+	mfsp		%sr1,t1  /* Save sr1 so we can use it in tlb inserts */</span>
 	mtsp		spc,%sr1
 
 	iitlba		pte,(%sr1,va)
 	iitlbp		prot,(%sr1,va)
 
<span class="p_del">-	mtsp		t0, %sr1	/* Restore sr1 */</span>
<span class="p_del">-	dbit_unlock1	spc,t0</span>
<span class="p_add">+	mtsp		t1, %sr1	/* Restore sr1 */</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1516,16 +1511,16 @@</span> <span class="p_context"> itlb_miss_20:</span>
 
 	L2_ptep		ptp,pte,t0,va,itlb_fault
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,itlb_fault</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 
<span class="p_del">-	f_extend	pte,t0	</span>
<span class="p_add">+	f_extend	pte,t1</span>
 
 	iitlbt          pte,prot
<span class="p_del">-	dbit_unlock1	spc,t0</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1536,16 +1531,16 @@</span> <span class="p_context"> naitlb_miss_20:</span>
 
 	L2_ptep		ptp,pte,t0,va,naitlb_check_alias_20
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_ptep	spc,ptp,pte,t0,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,naitlb_check_alias_20</span>
<span class="p_add">+	update_accessed	ptp,pte,t0,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 
<span class="p_del">-	f_extend	pte,t0</span>
<span class="p_add">+	f_extend	pte,t1</span>
 
 	iitlbt          pte,prot
<span class="p_del">-	dbit_unlock1	spc,t0</span>
 
<span class="p_add">+	tlb_unlock1	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1568,14 +1563,14 @@</span> <span class="p_context"> dbit_trap_20w:</span>
 
 	L3_ptep		ptp,pte,t0,va,dbit_fault
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_dirty	spc,ptp,pte,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,dbit_fault</span>
<span class="p_add">+	update_dirty	ptp,pte,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 		
 	idtlbt          pte,prot
<span class="p_del">-	dbit_unlock0	spc,t0</span>
 
<span class="p_add">+	tlb_unlock0	spc,t0</span>
 	rfir
 	nop
 #else
<span class="p_chunk">@@ -1588,8 +1583,8 @@</span> <span class="p_context"> dbit_trap_11:</span>
 
 	L2_ptep		ptp,pte,t0,va,dbit_fault
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_dirty	spc,ptp,pte,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,dbit_fault</span>
<span class="p_add">+	update_dirty	ptp,pte,t1</span>
 
 	make_insert_tlb_11	spc,pte,prot
 
<span class="p_chunk">@@ -1600,8 +1595,8 @@</span> <span class="p_context"> dbit_trap_11:</span>
 	idtlbp		prot,(%sr1,va)
 
 	mtsp            t1, %sr1     /* Restore sr1 */
<span class="p_del">-	dbit_unlock0	spc,t0</span>
 
<span class="p_add">+	tlb_unlock0	spc,t0</span>
 	rfir
 	nop
 
<span class="p_chunk">@@ -1612,16 +1607,16 @@</span> <span class="p_context"> dbit_trap_20:</span>
 
 	L2_ptep		ptp,pte,t0,va,dbit_fault
 
<span class="p_del">-	dbit_lock	spc,t0,t1</span>
<span class="p_del">-	update_dirty	spc,ptp,pte,t1</span>
<span class="p_add">+	tlb_lock	spc,ptp,pte,t0,t1,dbit_fault</span>
<span class="p_add">+	update_dirty	ptp,pte,t1</span>
 
 	make_insert_tlb	spc,pte,prot
 
 	f_extend	pte,t1
 	
<span class="p_del">-        idtlbt          pte,prot</span>
<span class="p_del">-	dbit_unlock0	spc,t0</span>
<span class="p_add">+	idtlbt		pte,prot</span>
 
<span class="p_add">+	tlb_unlock0	spc,t0</span>
 	rfir
 	nop
 #endif
<span class="p_header">diff --git a/arch/parisc/kernel/traps.c b/arch/parisc/kernel/traps.c</span>
<span class="p_header">index 47ee620d15d2..7f67c4c96a7a 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/traps.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/traps.c</span>
<span class="p_chunk">@@ -43,10 +43,6 @@</span> <span class="p_context"></span>
 
 #include &quot;../math-emu/math-emu.h&quot;	/* for handle_fpe() */
 
<span class="p_del">-#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)</span>
<span class="p_del">-DEFINE_SPINLOCK(pa_dbit_lock);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 static void parisc_show_stack(struct task_struct *task, unsigned long *sp,
 	struct pt_regs *regs);
 
<span class="p_header">diff --git a/arch/powerpc/kernel/idle_power7.S b/arch/powerpc/kernel/idle_power7.S</span>
<span class="p_header">index ccde8f084ce4..112ccf497562 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/idle_power7.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/idle_power7.S</span>
<span class="p_chunk">@@ -52,6 +52,22 @@</span> <span class="p_context"></span>
 	.text
 
 /*
<span class="p_add">+ * Used by threads when the lock bit of core_idle_state is set.</span>
<span class="p_add">+ * Threads will spin in HMT_LOW until the lock bit is cleared.</span>
<span class="p_add">+ * r14 - pointer to core_idle_state</span>
<span class="p_add">+ * r15 - used to load contents of core_idle_state</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+core_idle_lock_held:</span>
<span class="p_add">+	HMT_LOW</span>
<span class="p_add">+3:	lwz	r15,0(r14)</span>
<span class="p_add">+	andi.   r15,r15,PNV_CORE_IDLE_LOCK_BIT</span>
<span class="p_add">+	bne	3b</span>
<span class="p_add">+	HMT_MEDIUM</span>
<span class="p_add">+	lwarx	r15,0,r14</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Pass requested state in r3:
  *	r3 - PNV_THREAD_NAP/SLEEP/WINKLE
  *
<span class="p_chunk">@@ -150,6 +166,10 @@</span> <span class="p_context"> power7_enter_nap_mode:</span>
 	ld	r14,PACA_CORE_IDLE_STATE_PTR(r13)
 lwarx_loop1:
 	lwarx	r15,0,r14
<span class="p_add">+</span>
<span class="p_add">+	andi.   r9,r15,PNV_CORE_IDLE_LOCK_BIT</span>
<span class="p_add">+	bnel	core_idle_lock_held</span>
<span class="p_add">+</span>
 	andc	r15,r15,r7			/* Clear thread bit */
 
 	andi.	r15,r15,PNV_CORE_IDLE_THREAD_BITS
<span class="p_chunk">@@ -294,7 +314,7 @@</span> <span class="p_context"> lwarx_loop2:</span>
 	 * workaround undo code or resyncing timebase or restoring context
 	 * In either case loop until the lock bit is cleared.
 	 */
<span class="p_del">-	bne	core_idle_lock_held</span>
<span class="p_add">+	bnel	core_idle_lock_held</span>
 
 	cmpwi	cr2,r15,0
 	lbz	r4,PACA_SUBCORE_SIBLING_MASK(r13)
<span class="p_chunk">@@ -319,15 +339,6 @@</span> <span class="p_context"> lwarx_loop2:</span>
 	isync
 	b	common_exit
 
<span class="p_del">-core_idle_lock_held:</span>
<span class="p_del">-	HMT_LOW</span>
<span class="p_del">-core_idle_lock_loop:</span>
<span class="p_del">-	lwz	r15,0(14)</span>
<span class="p_del">-	andi.   r9,r15,PNV_CORE_IDLE_LOCK_BIT</span>
<span class="p_del">-	bne	core_idle_lock_loop</span>
<span class="p_del">-	HMT_MEDIUM</span>
<span class="p_del">-	b	lwarx_loop2</span>
<span class="p_del">-</span>
 first_thread_in_subcore:
 	/* First thread in subcore to wakeup */
 	ori	r15,r15,PNV_CORE_IDLE_LOCK_BIT
<span class="p_header">diff --git a/arch/s390/include/asm/ctl_reg.h b/arch/s390/include/asm/ctl_reg.h</span>
<span class="p_header">index cfad7fca01d6..d7697ab802f6 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/ctl_reg.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/ctl_reg.h</span>
<span class="p_chunk">@@ -57,7 +57,10 @@</span> <span class="p_context"> union ctlreg0 {</span>
 		unsigned long lap  : 1; /* Low-address-protection control */
 		unsigned long	   : 4;
 		unsigned long edat : 1; /* Enhanced-DAT-enablement control */
<span class="p_del">-		unsigned long	   : 23;</span>
<span class="p_add">+		unsigned long	   : 4;</span>
<span class="p_add">+		unsigned long afp  : 1; /* AFP-register control */</span>
<span class="p_add">+		unsigned long vx   : 1; /* Vector enablement control */</span>
<span class="p_add">+		unsigned long	   : 17;</span>
 	};
 };
 
<span class="p_header">diff --git a/arch/s390/kernel/cache.c b/arch/s390/kernel/cache.c</span>
<span class="p_header">index bff5e3b6d822..8ba32436effe 100644</span>
<span class="p_header">--- a/arch/s390/kernel/cache.c</span>
<span class="p_header">+++ b/arch/s390/kernel/cache.c</span>
<span class="p_chunk">@@ -138,6 +138,8 @@</span> <span class="p_context"> int init_cache_level(unsigned int cpu)</span>
 	union cache_topology ct;
 	enum cache_type ctype;
 
<span class="p_add">+	if (!test_facility(34))</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
 	if (!this_cpu_ci)
 		return -EINVAL;
 	ct.raw = ecag(EXTRACT_TOPOLOGY, 0, 0);
<span class="p_header">diff --git a/arch/s390/kernel/nmi.c b/arch/s390/kernel/nmi.c</span>
<span class="p_header">index 505c17c0ae1a..56b550893593 100644</span>
<span class="p_header">--- a/arch/s390/kernel/nmi.c</span>
<span class="p_header">+++ b/arch/s390/kernel/nmi.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/nmi.h&gt;
 #include &lt;asm/crw.h&gt;
 #include &lt;asm/switch_to.h&gt;
<span class="p_add">+#include &lt;asm/ctl_reg.h&gt;</span>
 
 struct mcck_struct {
 	int kill_task;
<span class="p_chunk">@@ -129,26 +130,30 @@</span> <span class="p_context"> static int notrace s390_revalidate_registers(struct mci *mci)</span>
 	} else
 		asm volatile(&quot;lfpc 0(%0)&quot; : : &quot;a&quot; (fpt_creg_save_area));
 
<span class="p_del">-	asm volatile(</span>
<span class="p_del">-		&quot;	ld	0,0(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	1,8(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	2,16(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	3,24(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	4,32(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	5,40(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	6,48(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	7,56(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	8,64(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	9,72(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	10,80(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	11,88(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	12,96(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	13,104(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	14,112(%0)\n&quot;</span>
<span class="p_del">-		&quot;	ld	15,120(%0)\n&quot;</span>
<span class="p_del">-		: : &quot;a&quot; (fpt_save_area));</span>
<span class="p_del">-	/* Revalidate vector registers */</span>
<span class="p_del">-	if (MACHINE_HAS_VX &amp;&amp; current-&gt;thread.vxrs) {</span>
<span class="p_add">+	if (!MACHINE_HAS_VX) {</span>
<span class="p_add">+		/* Revalidate floating point registers */</span>
<span class="p_add">+		asm volatile(</span>
<span class="p_add">+			&quot;	ld	0,0(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	1,8(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	2,16(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	3,24(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	4,32(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	5,40(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	6,48(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	7,56(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	8,64(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	9,72(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	10,80(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	11,88(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	12,96(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	13,104(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	14,112(%0)\n&quot;</span>
<span class="p_add">+			&quot;	ld	15,120(%0)\n&quot;</span>
<span class="p_add">+			: : &quot;a&quot; (fpt_save_area));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Revalidate vector registers */</span>
<span class="p_add">+		union ctlreg0 cr0;</span>
<span class="p_add">+</span>
 		if (!mci-&gt;vr) {
 			/*
 			 * Vector registers can&#39;t be restored and therefore
<span class="p_chunk">@@ -156,8 +161,12 @@</span> <span class="p_context"> static int notrace s390_revalidate_registers(struct mci *mci)</span>
 			 */
 			kill_task = 1;
 		}
<span class="p_add">+		cr0.val = S390_lowcore.cregs_save_area[0];</span>
<span class="p_add">+		cr0.afp = cr0.vx = 1;</span>
<span class="p_add">+		__ctl_load(cr0.val, 0, 0);</span>
 		restore_vx_regs((__vector128 *)
<span class="p_del">-				S390_lowcore.vector_save_area_addr);</span>
<span class="p_add">+				&amp;S390_lowcore.vector_save_area);</span>
<span class="p_add">+		__ctl_load(S390_lowcore.cregs_save_area[0], 0, 0);</span>
 	}
 	/* Revalidate access registers */
 	asm volatile(
<span class="p_header">diff --git a/arch/s390/kernel/process.c b/arch/s390/kernel/process.c</span>
<span class="p_header">index dc5edc29b73a..8f587d871b9f 100644</span>
<span class="p_header">--- a/arch/s390/kernel/process.c</span>
<span class="p_header">+++ b/arch/s390/kernel/process.c</span>
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> int copy_thread(unsigned long clone_flags, unsigned long new_stackp,</span>
 asmlinkage void execve_tail(void)
 {
 	current-&gt;thread.fp_regs.fpc = 0;
<span class="p_del">-	asm volatile(&quot;sfpc %0,%0&quot; : : &quot;d&quot; (0));</span>
<span class="p_add">+	asm volatile(&quot;sfpc %0&quot; : : &quot;d&quot; (0));</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/s390/kernel/sclp.S b/arch/s390/kernel/sclp.S</span>
<span class="p_header">index 43c3169ea49c..ada0c07fe1a8 100644</span>
<span class="p_header">--- a/arch/s390/kernel/sclp.S</span>
<span class="p_header">+++ b/arch/s390/kernel/sclp.S</span>
<span class="p_chunk">@@ -270,6 +270,8 @@</span> <span class="p_context"> ENTRY(_sclp_print_early)</span>
 	jno	.Lesa2
 	ahi	%r15,-80
 	stmh	%r6,%r15,96(%r15)		# store upper register halves
<span class="p_add">+	basr	%r13,0</span>
<span class="p_add">+	lmh	%r0,%r15,.Lzeroes-.(%r13)	# clear upper register halves</span>
 .Lesa2:
 	lr	%r10,%r2			# save string pointer
 	lhi	%r2,0
<span class="p_chunk">@@ -291,6 +293,8 @@</span> <span class="p_context"> ENTRY(_sclp_print_early)</span>
 .Lesa3:
 	lm	%r6,%r15,120(%r15)		# restore registers
 	br	%r14
<span class="p_add">+.Lzeroes:</span>
<span class="p_add">+	.fill	64,4,0</span>
 
 .LwritedataS4:
 	.long	0x00760005			# SCLP command for write data
<span class="p_header">diff --git a/arch/s390/net/bpf_jit_comp.c b/arch/s390/net/bpf_jit_comp.c</span>
<span class="p_header">index 9afb9d602f84..dc2d7aa56440 100644</span>
<span class="p_header">--- a/arch/s390/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/s390/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -415,13 +415,13 @@</span> <span class="p_context"> static void bpf_jit_prologue(struct bpf_jit *jit)</span>
 		EMIT6_DISP_LH(0xe3000000, 0x0004, REG_SKB_DATA, REG_0,
 			      BPF_REG_1, offsetof(struct sk_buff, data));
 	}
<span class="p_del">-	/* BPF compatibility: clear A (%b7) and X (%b8) registers */</span>
<span class="p_del">-	if (REG_SEEN(BPF_REG_7))</span>
<span class="p_del">-		/* lghi %b7,0 */</span>
<span class="p_del">-		EMIT4_IMM(0xa7090000, BPF_REG_7, 0);</span>
<span class="p_del">-	if (REG_SEEN(BPF_REG_8))</span>
<span class="p_del">-		/* lghi %b8,0 */</span>
<span class="p_del">-		EMIT4_IMM(0xa7090000, BPF_REG_8, 0);</span>
<span class="p_add">+	/* BPF compatibility: clear A (%b0) and X (%b7) registers */</span>
<span class="p_add">+	if (REG_SEEN(BPF_REG_A))</span>
<span class="p_add">+		/* lghi %ba,0 */</span>
<span class="p_add">+		EMIT4_IMM(0xa7090000, BPF_REG_A, 0);</span>
<span class="p_add">+	if (REG_SEEN(BPF_REG_X))</span>
<span class="p_add">+		/* lghi %bx,0 */</span>
<span class="p_add">+		EMIT4_IMM(0xa7090000, BPF_REG_X, 0);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/tile/kernel/setup.c b/arch/tile/kernel/setup.c</span>
<span class="p_header">index d366675e4bf8..396b5c96e272 100644</span>
<span class="p_header">--- a/arch/tile/kernel/setup.c</span>
<span class="p_header">+++ b/arch/tile/kernel/setup.c</span>
<span class="p_chunk">@@ -1139,7 +1139,7 @@</span> <span class="p_context"> static void __init load_hv_initrd(void)</span>
 
 void __init free_initrd_mem(unsigned long begin, unsigned long end)
 {
<span class="p_del">-	free_bootmem(__pa(begin), end - begin);</span>
<span class="p_add">+	free_bootmem_late(__pa(begin), end - begin);</span>
 }
 
 static int __init setup_initrd(char *str)
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">index 48304b89b601..0cdc154a22b5 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_chunk">@@ -1193,6 +1193,10 @@</span> <span class="p_context"> static efi_status_t setup_e820(struct boot_params *params,</span>
 		unsigned int e820_type = 0;
 		unsigned long m = efi-&gt;efi_memmap;
 
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+		m |= (u64)efi-&gt;efi_memmap_hi &lt;&lt; 32;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 		d = (efi_memory_desc_t *)(m + (i * efi-&gt;efi_memdesc_size));
 		switch (d-&gt;type) {
 		case EFI_RESERVED_TYPE:
<span class="p_header">diff --git a/arch/x86/include/asm/kasan.h b/arch/x86/include/asm/kasan.h</span>
<span class="p_header">index 8b22422fbad8..74a2a8dc9908 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kasan.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kasan.h</span>
<span class="p_chunk">@@ -14,15 +14,11 @@</span> <span class="p_context"></span>
 
 #ifndef __ASSEMBLY__
 
<span class="p_del">-extern pte_t kasan_zero_pte[];</span>
<span class="p_del">-extern pte_t kasan_zero_pmd[];</span>
<span class="p_del">-extern pte_t kasan_zero_pud[];</span>
<span class="p_del">-</span>
 #ifdef CONFIG_KASAN
<span class="p_del">-void __init kasan_map_early_shadow(pgd_t *pgd);</span>
<span class="p_add">+void __init kasan_early_init(void);</span>
 void __init kasan_init(void);
 #else
<span class="p_del">-static inline void kasan_map_early_shadow(pgd_t *pgd) { }</span>
<span class="p_add">+static inline void kasan_early_init(void) { }</span>
 static inline void kasan_init(void) { }
 #endif
 
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index 883f6b933fa4..e997f70f80c4 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -23,7 +23,7 @@</span> <span class="p_context"> extern struct static_key rdpmc_always_available;</span>
 
 static inline void load_mm_cr4(struct mm_struct *mm)
 {
<span class="p_del">-	if (static_key_true(&amp;rdpmc_always_available) ||</span>
<span class="p_add">+	if (static_key_false(&amp;rdpmc_always_available) ||</span>
 	    atomic_read(&amp;mm-&gt;context.perf_rdpmc_allowed))
 		cr4_set_bits(X86_CR4_PCE);
 	else
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel_cqm.c b/arch/x86/kernel/cpu/perf_event_intel_cqm.c</span>
<span class="p_header">index e4d1b8b738fa..cb77b11bc414 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel_cqm.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel_cqm.c</span>
<span class="p_chunk">@@ -934,6 +934,14 @@</span> <span class="p_context"> static u64 intel_cqm_event_count(struct perf_event *event)</span>
 		return 0;
 
 	/*
<span class="p_add">+	 * Getting up-to-date values requires an SMP IPI which is not</span>
<span class="p_add">+	 * possible if we&#39;re being called in interrupt context. Return</span>
<span class="p_add">+	 * the cached values instead.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(in_interrupt()))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Notice that we don&#39;t perform the reading of an RMID
 	 * atomically, because we can&#39;t hold a spin lock across the
 	 * IPIs.
<span class="p_header">diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c</span>
<span class="p_header">index 5a4668136e98..f129a9af6357 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/head64.c</span>
<span class="p_chunk">@@ -161,11 +161,12 @@</span> <span class="p_context"> asmlinkage __visible void __init x86_64_start_kernel(char * real_mode_data)</span>
 	/* Kill off the identity-map trampoline */
 	reset_early_page_tables();
 
<span class="p_del">-	kasan_map_early_shadow(early_level4_pgt);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* clear bss before set_intr_gate with early_idt_handler */</span>
 	clear_bss();
 
<span class="p_add">+	clear_page(init_level4_pgt);</span>
<span class="p_add">+</span>
<span class="p_add">+	kasan_early_init();</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; NUM_EXCEPTION_VECTORS; i++)
 		set_intr_gate(i, early_idt_handler_array[i]);
 	load_idt((const struct desc_ptr *)&amp;idt_descr);
<span class="p_chunk">@@ -177,12 +178,9 @@</span> <span class="p_context"> asmlinkage __visible void __init x86_64_start_kernel(char * real_mode_data)</span>
 	 */
 	load_ucode_bsp();
 
<span class="p_del">-	clear_page(init_level4_pgt);</span>
 	/* set init_level4_pgt kernel high mapping*/
 	init_level4_pgt[511] = early_level4_pgt[511];
 
<span class="p_del">-	kasan_map_early_shadow(init_level4_pgt);</span>
<span class="p_del">-</span>
 	x86_64_start_reservations(real_mode_data);
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S</span>
<span class="p_header">index df7e78057ae0..7e5da2cbe59e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/head_64.S</span>
<span class="p_chunk">@@ -516,38 +516,9 @@</span> <span class="p_context"> ENTRY(phys_base)</span>
 	/* This must match the first entry in level2_kernel_pgt */
 	.quad   0x0000000000000000
 
<span class="p_del">-#ifdef CONFIG_KASAN</span>
<span class="p_del">-#define FILL(VAL, COUNT)				\</span>
<span class="p_del">-	.rept (COUNT) ;					\</span>
<span class="p_del">-	.quad	(VAL) ;					\</span>
<span class="p_del">-	.endr</span>
<span class="p_del">-</span>
<span class="p_del">-NEXT_PAGE(kasan_zero_pte)</span>
<span class="p_del">-	FILL(kasan_zero_page - __START_KERNEL_map + _KERNPG_TABLE, 512)</span>
<span class="p_del">-NEXT_PAGE(kasan_zero_pmd)</span>
<span class="p_del">-	FILL(kasan_zero_pte - __START_KERNEL_map + _KERNPG_TABLE, 512)</span>
<span class="p_del">-NEXT_PAGE(kasan_zero_pud)</span>
<span class="p_del">-	FILL(kasan_zero_pmd - __START_KERNEL_map + _KERNPG_TABLE, 512)</span>
<span class="p_del">-</span>
<span class="p_del">-#undef FILL</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 #include &quot;../../x86/xen/xen-head.S&quot;
 	
 	__PAGE_ALIGNED_BSS
 NEXT_PAGE(empty_zero_page)
 	.skip PAGE_SIZE
 
<span class="p_del">-#ifdef CONFIG_KASAN</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This page used as early shadow. We don&#39;t use empty_zero_page</span>
<span class="p_del">- * at early stages, stack instrumentation could write some garbage</span>
<span class="p_del">- * to this page.</span>
<span class="p_del">- * Latter we reuse it as zero shadow for large ranges of memory</span>
<span class="p_del">- * that allowed to access, but not instrumented by kasan</span>
<span class="p_del">- * (vmalloc/vmemmap ...).</span>
<span class="p_del">- */</span>
<span class="p_del">-NEXT_PAGE(kasan_zero_page)</span>
<span class="p_del">-	.skip PAGE_SIZE</span>
<span class="p_del">-#endif</span>
<span class="p_header">diff --git a/arch/x86/mm/kasan_init_64.c b/arch/x86/mm/kasan_init_64.c</span>
<span class="p_header">index 4860906c6b9f..9a54dbe98064 100644</span>
<span class="p_header">--- a/arch/x86/mm/kasan_init_64.c</span>
<span class="p_header">+++ b/arch/x86/mm/kasan_init_64.c</span>
<span class="p_chunk">@@ -11,7 +11,19 @@</span> <span class="p_context"></span>
 extern pgd_t early_level4_pgt[PTRS_PER_PGD];
 extern struct range pfn_mapped[E820_X_MAX];
 
<span class="p_del">-extern unsigned char kasan_zero_page[PAGE_SIZE];</span>
<span class="p_add">+static pud_t kasan_zero_pud[PTRS_PER_PUD] __page_aligned_bss;</span>
<span class="p_add">+static pmd_t kasan_zero_pmd[PTRS_PER_PMD] __page_aligned_bss;</span>
<span class="p_add">+static pte_t kasan_zero_pte[PTRS_PER_PTE] __page_aligned_bss;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This page used as early shadow. We don&#39;t use empty_zero_page</span>
<span class="p_add">+ * at early stages, stack instrumentation could write some garbage</span>
<span class="p_add">+ * to this page.</span>
<span class="p_add">+ * Latter we reuse it as zero shadow for large ranges of memory</span>
<span class="p_add">+ * that allowed to access, but not instrumented by kasan</span>
<span class="p_add">+ * (vmalloc/vmemmap ...).</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned char kasan_zero_page[PAGE_SIZE] __page_aligned_bss;</span>
 
 static int __init map_range(struct range *range)
 {
<span class="p_chunk">@@ -36,7 +48,7 @@</span> <span class="p_context"> static void __init clear_pgds(unsigned long start,</span>
 		pgd_clear(pgd_offset_k(start));
 }
 
<span class="p_del">-void __init kasan_map_early_shadow(pgd_t *pgd)</span>
<span class="p_add">+static void __init kasan_map_early_shadow(pgd_t *pgd)</span>
 {
 	int i;
 	unsigned long start = KASAN_SHADOW_START;
<span class="p_chunk">@@ -73,7 +85,7 @@</span> <span class="p_context"> static int __init zero_pmd_populate(pud_t *pud, unsigned long addr,</span>
 	while (IS_ALIGNED(addr, PMD_SIZE) &amp;&amp; addr + PMD_SIZE &lt;= end) {
 		WARN_ON(!pmd_none(*pmd));
 		set_pmd(pmd, __pmd(__pa_nodebug(kasan_zero_pte)
<span class="p_del">-					| __PAGE_KERNEL_RO));</span>
<span class="p_add">+					| _KERNPG_TABLE));</span>
 		addr += PMD_SIZE;
 		pmd = pmd_offset(pud, addr);
 	}
<span class="p_chunk">@@ -99,7 +111,7 @@</span> <span class="p_context"> static int __init zero_pud_populate(pgd_t *pgd, unsigned long addr,</span>
 	while (IS_ALIGNED(addr, PUD_SIZE) &amp;&amp; addr + PUD_SIZE &lt;= end) {
 		WARN_ON(!pud_none(*pud));
 		set_pud(pud, __pud(__pa_nodebug(kasan_zero_pmd)
<span class="p_del">-					| __PAGE_KERNEL_RO));</span>
<span class="p_add">+					| _KERNPG_TABLE));</span>
 		addr += PUD_SIZE;
 		pud = pud_offset(pgd, addr);
 	}
<span class="p_chunk">@@ -124,7 +136,7 @@</span> <span class="p_context"> static int __init zero_pgd_populate(unsigned long addr, unsigned long end)</span>
 	while (IS_ALIGNED(addr, PGDIR_SIZE) &amp;&amp; addr + PGDIR_SIZE &lt;= end) {
 		WARN_ON(!pgd_none(*pgd));
 		set_pgd(pgd, __pgd(__pa_nodebug(kasan_zero_pud)
<span class="p_del">-					| __PAGE_KERNEL_RO));</span>
<span class="p_add">+					| _KERNPG_TABLE));</span>
 		addr += PGDIR_SIZE;
 		pgd = pgd_offset_k(addr);
 	}
<span class="p_chunk">@@ -166,6 +178,26 @@</span> <span class="p_context"> static struct notifier_block kasan_die_notifier = {</span>
 };
 #endif
 
<span class="p_add">+void __init kasan_early_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	pteval_t pte_val = __pa_nodebug(kasan_zero_page) | __PAGE_KERNEL;</span>
<span class="p_add">+	pmdval_t pmd_val = __pa_nodebug(kasan_zero_pte) | _KERNPG_TABLE;</span>
<span class="p_add">+	pudval_t pud_val = __pa_nodebug(kasan_zero_pmd) | _KERNPG_TABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; PTRS_PER_PTE; i++)</span>
<span class="p_add">+		kasan_zero_pte[i] = __pte(pte_val);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; PTRS_PER_PMD; i++)</span>
<span class="p_add">+		kasan_zero_pmd[i] = __pmd(pmd_val);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; PTRS_PER_PUD; i++)</span>
<span class="p_add">+		kasan_zero_pud[i] = __pud(pud_val);</span>
<span class="p_add">+</span>
<span class="p_add">+	kasan_map_early_shadow(early_level4_pgt);</span>
<span class="p_add">+	kasan_map_early_shadow(init_level4_pgt);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init kasan_init(void)
 {
 	int i;
<span class="p_chunk">@@ -176,6 +208,7 @@</span> <span class="p_context"> void __init kasan_init(void)</span>
 
 	memcpy(early_level4_pgt, init_level4_pgt, sizeof(early_level4_pgt));
 	load_cr3(early_level4_pgt);
<span class="p_add">+	__flush_tlb_all();</span>
 
 	clear_pgds(KASAN_SHADOW_START, KASAN_SHADOW_END);
 
<span class="p_chunk">@@ -202,5 +235,6 @@</span> <span class="p_context"> void __init kasan_init(void)</span>
 	memset(kasan_zero_page, 0, PAGE_SIZE);
 
 	load_cr3(init_level4_pgt);
<span class="p_add">+	__flush_tlb_all();</span>
 	init_task.kasan_depth = 0;
 }
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 3250f2371aea..90b924acd982 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static void flush_tlb_func(void *info)</span>
 		} else {
 			unsigned long addr;
 			unsigned long nr_pages =
<span class="p_del">-				f-&gt;flush_end - f-&gt;flush_start / PAGE_SIZE;</span>
<span class="p_add">+				(f-&gt;flush_end - f-&gt;flush_start) / PAGE_SIZE;</span>
 			addr = f-&gt;flush_start;
 			while (addr &lt; f-&gt;flush_end) {
 				__flush_tlb_single(addr);
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index 02744df576d5..841ea05e1b02 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -946,6 +946,11 @@</span> <span class="p_context"> u64 efi_mem_attributes(unsigned long phys_addr)</span>
 
 static int __init arch_parse_efi_cmdline(char *str)
 {
<span class="p_add">+	if (!str) {</span>
<span class="p_add">+		pr_warn(&quot;need at least one option\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (parse_option_str(str, &quot;old_map&quot;))
 		set_bit(EFI_OLD_MEMMAP, &amp;efi.flags);
 	if (parse_option_str(str, &quot;debug&quot;))
<span class="p_header">diff --git a/block/bio-integrity.c b/block/bio-integrity.c</span>
<span class="p_header">index 5cbd5d9ea61d..39ce74d10e2b 100644</span>
<span class="p_header">--- a/block/bio-integrity.c</span>
<span class="p_header">+++ b/block/bio-integrity.c</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> struct bio_integrity_payload *bio_integrity_alloc(struct bio *bio,</span>
 	unsigned long idx = BIO_POOL_NONE;
 	unsigned inline_vecs;
 
<span class="p_del">-	if (!bs) {</span>
<span class="p_add">+	if (!bs || !bs-&gt;bio_integrity_pool) {</span>
 		bip = kmalloc(sizeof(struct bio_integrity_payload) +
 			      sizeof(struct bio_vec) * nr_vecs, gfp_mask);
 		inline_vecs = nr_vecs;
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> void bio_integrity_free(struct bio *bio)</span>
 		kfree(page_address(bip-&gt;bip_vec-&gt;bv_page) +
 		      bip-&gt;bip_vec-&gt;bv_offset);
 
<span class="p_del">-	if (bs) {</span>
<span class="p_add">+	if (bs &amp;&amp; bs-&gt;bio_integrity_pool) {</span>
 		if (bip-&gt;bip_slab != BIO_POOL_NONE)
 			bvec_free(bs-&gt;bvec_integrity_pool, bip-&gt;bip_vec,
 				  bip-&gt;bip_slab);
<span class="p_header">diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c</span>
<span class="p_header">index 0ac817b750db..6817e28960b7 100644</span>
<span class="p_header">--- a/block/blk-cgroup.c</span>
<span class="p_header">+++ b/block/blk-cgroup.c</span>
<span class="p_chunk">@@ -716,8 +716,12 @@</span> <span class="p_context"> int blkg_conf_prep(struct blkcg *blkcg, const struct blkcg_policy *pol,</span>
 		return -EINVAL;
 
 	disk = get_gendisk(MKDEV(major, minor), &amp;part);
<span class="p_del">-	if (!disk || part)</span>
<span class="p_add">+	if (!disk)</span>
 		return -EINVAL;
<span class="p_add">+	if (part) {</span>
<span class="p_add">+		put_disk(disk);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
 
 	rcu_read_lock();
 	spin_lock_irq(disk-&gt;queue-&gt;queue_lock);
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 594eea04266e..2dc1fd6c5bdb 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -1968,7 +1968,7 @@</span> <span class="p_context"> struct request_queue *blk_mq_init_allocated_queue(struct blk_mq_tag_set *set,</span>
 		goto err_hctxs;
 
 	setup_timer(&amp;q-&gt;timeout, blk_mq_rq_timer, (unsigned long) q);
<span class="p_del">-	blk_queue_rq_timeout(q, set-&gt;timeout ? set-&gt;timeout : 30000);</span>
<span class="p_add">+	blk_queue_rq_timeout(q, set-&gt;timeout ? set-&gt;timeout : 30 * HZ);</span>
 
 	q-&gt;nr_queues = nr_cpu_ids;
 	q-&gt;nr_hw_queues = set-&gt;nr_hw_queues;
<span class="p_header">diff --git a/drivers/ata/libata-pmp.c b/drivers/ata/libata-pmp.c</span>
<span class="p_header">index 7ccc084bf1df..85aa76116a30 100644</span>
<span class="p_header">--- a/drivers/ata/libata-pmp.c</span>
<span class="p_header">+++ b/drivers/ata/libata-pmp.c</span>
<span class="p_chunk">@@ -460,6 +460,13 @@</span> <span class="p_context"> static void sata_pmp_quirks(struct ata_port *ap)</span>
 				       ATA_LFLAG_NO_SRST |
 				       ATA_LFLAG_ASSUME_ATA;
 		}
<span class="p_add">+	} else if (vendor == 0x11ab &amp;&amp; devid == 0x4140) {</span>
<span class="p_add">+		/* Marvell 4140 quirks */</span>
<span class="p_add">+		ata_for_each_link(link, ap, EDGE) {</span>
<span class="p_add">+			/* port 4 is for SEMB device and it doesn&#39;t like SRST */</span>
<span class="p_add">+			if (link-&gt;pmp == 4)</span>
<span class="p_add">+				link-&gt;flags |= ATA_LFLAG_DISABLED;</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c</span>
<span class="p_header">index bf12a25eb3a2..0f8db28353c5 100644</span>
<span class="p_header">--- a/drivers/clk/st/clk-flexgen.c</span>
<span class="p_header">+++ b/drivers/clk/st/clk-flexgen.c</span>
<span class="p_chunk">@@ -303,6 +303,8 @@</span> <span class="p_context"> void __init st_of_flexgen_setup(struct device_node *np)</span>
 	if (!rlock)
 		goto err;
 
<span class="p_add">+	spin_lock_init(rlock);</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; clk_data-&gt;clk_num; i++) {
 		struct clk *clk;
 		const char *clk_name;
<span class="p_header">diff --git a/drivers/clk/st/clkgen-fsyn.c b/drivers/clk/st/clkgen-fsyn.c</span>
<span class="p_header">index a917c4c7eaa9..6ae068ab07c8 100644</span>
<span class="p_header">--- a/drivers/clk/st/clkgen-fsyn.c</span>
<span class="p_header">+++ b/drivers/clk/st/clkgen-fsyn.c</span>
<span class="p_chunk">@@ -340,7 +340,7 @@</span> <span class="p_context"> static const struct clkgen_quadfs_data st_fs660c32_C_407 = {</span>
 		    CLKGEN_FIELD(0x30c, 0xf, 20),
 		    CLKGEN_FIELD(0x310, 0xf, 20) },
 	.lockstatus_present = true,
<span class="p_del">-	.lock_status = CLKGEN_FIELD(0x2A0, 0x1, 24),</span>
<span class="p_add">+	.lock_status = CLKGEN_FIELD(0x2f0, 0x1, 24),</span>
 	.powerup_polarity = 1,
 	.standby_polarity = 1,
 	.pll_ops	= &amp;st_quadfs_pll_c32_ops,
<span class="p_header">diff --git a/drivers/clk/st/clkgen-mux.c b/drivers/clk/st/clkgen-mux.c</span>
<span class="p_header">index fdcff10f6d30..ef6514636bfc 100644</span>
<span class="p_header">--- a/drivers/clk/st/clkgen-mux.c</span>
<span class="p_header">+++ b/drivers/clk/st/clkgen-mux.c</span>
<span class="p_chunk">@@ -582,7 +582,7 @@</span> <span class="p_context"> static struct clkgen_mux_data stih416_a9_mux_data = {</span>
 };
 static struct clkgen_mux_data stih407_a9_mux_data = {
 	.offset = 0x1a4,
<span class="p_del">-	.shift = 1,</span>
<span class="p_add">+	.shift = 0,</span>
 	.width = 2,
 };
 
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index c45d274a75c8..6f9d27f9001c 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -678,6 +678,7 @@</span> <span class="p_context"> static struct cpu_defaults knl_params = {</span>
 		.get_max = core_get_max_pstate,
 		.get_min = core_get_min_pstate,
 		.get_turbo = knl_get_turbo_pstate,
<span class="p_add">+		.get_scaling = core_get_scaling,</span>
 		.set = core_set_pstate,
 	},
 };
<span class="p_header">diff --git a/drivers/crypto/omap-des.c b/drivers/crypto/omap-des.c</span>
<span class="p_header">index 46307098f8ba..0a70e46d5416 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-des.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-des.c</span>
<span class="p_chunk">@@ -536,9 +536,6 @@</span> <span class="p_context"> static int omap_des_crypt_dma_stop(struct omap_des_dev *dd)</span>
 	dmaengine_terminate_all(dd-&gt;dma_lch_in);
 	dmaengine_terminate_all(dd-&gt;dma_lch_out);
 
<span class="p_del">-	dma_unmap_sg(dd-&gt;dev, dd-&gt;in_sg, dd-&gt;in_sg_len, DMA_TO_DEVICE);</span>
<span class="p_del">-	dma_unmap_sg(dd-&gt;dev, dd-&gt;out_sg, dd-&gt;out_sg_len, DMA_FROM_DEVICE);</span>
<span class="p_del">-</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/firmware/efi/cper.c b/drivers/firmware/efi/cper.c</span>
<span class="p_header">index 4fd9961d552e..d42537425438 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/cper.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/cper.c</span>
<span class="p_chunk">@@ -305,10 +305,17 @@</span> <span class="p_context"> const char *cper_mem_err_unpack(struct trace_seq *p,</span>
 	return ret;
 }
 
<span class="p_del">-static void cper_print_mem(const char *pfx, const struct cper_sec_mem_err *mem)</span>
<span class="p_add">+static void cper_print_mem(const char *pfx, const struct cper_sec_mem_err *mem,</span>
<span class="p_add">+	int len)</span>
 {
 	struct cper_mem_err_compact cmem;
 
<span class="p_add">+	/* Don&#39;t trust UEFI 2.1/2.2 structure with bad validation bits */</span>
<span class="p_add">+	if (len == sizeof(struct cper_sec_mem_err_old) &amp;&amp;</span>
<span class="p_add">+	    (mem-&gt;validation_bits &amp; ~(CPER_MEM_VALID_RANK_NUMBER - 1))) {</span>
<span class="p_add">+		pr_err(FW_WARN &quot;valid bits set for fields beyond structure\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	if (mem-&gt;validation_bits &amp; CPER_MEM_VALID_ERROR_STATUS)
 		printk(&quot;%s&quot;&quot;error_status: 0x%016llx\n&quot;, pfx, mem-&gt;error_status);
 	if (mem-&gt;validation_bits &amp; CPER_MEM_VALID_PA)
<span class="p_chunk">@@ -405,8 +412,10 @@</span> <span class="p_context"> static void cper_estatus_print_section(</span>
 	} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PLATFORM_MEM)) {
 		struct cper_sec_mem_err *mem_err = (void *)(gdata + 1);
 		printk(&quot;%s&quot;&quot;section_type: memory error\n&quot;, newpfx);
<span class="p_del">-		if (gdata-&gt;error_data_length &gt;= sizeof(*mem_err))</span>
<span class="p_del">-			cper_print_mem(newpfx, mem_err);</span>
<span class="p_add">+		if (gdata-&gt;error_data_length &gt;=</span>
<span class="p_add">+		    sizeof(struct cper_sec_mem_err_old))</span>
<span class="p_add">+			cper_print_mem(newpfx, mem_err,</span>
<span class="p_add">+				       gdata-&gt;error_data_length);</span>
 		else
 			goto err_section_too_small;
 	} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PCIE)) {
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index e14363d12690..63226e9036a1 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -57,6 +57,11 @@</span> <span class="p_context"> bool efi_runtime_disabled(void)</span>
 
 static int __init parse_efi_cmdline(char *str)
 {
<span class="p_add">+	if (!str) {</span>
<span class="p_add">+		pr_warn(&quot;need at least one option\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (parse_option_str(str, &quot;noruntime&quot;))
 		disable_runtime = true;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_drm.c b/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_header">index 89049335b738..cd6dae08175e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_chunk">@@ -863,8 +863,10 @@</span> <span class="p_context"> nouveau_drm_preclose(struct drm_device *dev, struct drm_file *fpriv)</span>
 
 	pm_runtime_get_sync(dev-&gt;dev);
 
<span class="p_add">+	mutex_lock(&amp;cli-&gt;mutex);</span>
 	if (cli-&gt;abi16)
 		nouveau_abi16_fini(cli-&gt;abi16);
<span class="p_add">+	mutex_unlock(&amp;cli-&gt;mutex);</span>
 
 	mutex_lock(&amp;drm-&gt;client.mutex);
 	list_del(&amp;cli-&gt;head);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv04_fbcon.c b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">index 4ef602c5469d..495c57644ced 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_chunk">@@ -203,7 +203,7 @@</span> <span class="p_context"> nv04_fbcon_accel_init(struct fb_info *info)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	if (RING_SPACE(chan, 49)) {</span>
<span class="p_add">+	if (RING_SPACE(chan, 49 + (device-&gt;info.chipset &gt;= 0x11 ? 4 : 0))) {</span>
 		nouveau_fbcon_gpu_lockup(info);
 		return 0;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv50_display.c b/drivers/gpu/drm/nouveau/nv50_display.c</span>
<span class="p_header">index 7da7958556a3..981342d142ff 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv50_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv50_display.c</span>
<span class="p_chunk">@@ -979,7 +979,7 @@</span> <span class="p_context"> nv50_crtc_cursor_show_hide(struct nouveau_crtc *nv_crtc, bool show, bool update)</span>
 {
 	struct nv50_mast *mast = nv50_mast(nv_crtc-&gt;base.dev);
 
<span class="p_del">-	if (show &amp;&amp; nv_crtc-&gt;cursor.nvbo)</span>
<span class="p_add">+	if (show &amp;&amp; nv_crtc-&gt;cursor.nvbo &amp;&amp; nv_crtc-&gt;base.enabled)</span>
 		nv50_crtc_cursor_show(nv_crtc);
 	else
 		nv50_crtc_cursor_hide(nv_crtc);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv04.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv04.c</span>
<span class="p_header">index 80614f1b2074..282143f49d72 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv04.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv04.c</span>
<span class="p_chunk">@@ -50,7 +50,12 @@</span> <span class="p_context"> nv04_instobj_dtor(struct nvkm_object *object)</span>
 {
 	struct nv04_instmem_priv *priv = (void *)nvkm_instmem(object);
 	struct nv04_instobj_priv *node = (void *)object;
<span class="p_add">+	struct nvkm_subdev *subdev = (void *)priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;subdev-&gt;mutex);</span>
 	nvkm_mm_free(&amp;priv-&gt;heap, &amp;node-&gt;mem);
<span class="p_add">+	mutex_unlock(&amp;subdev-&gt;mutex);</span>
<span class="p_add">+</span>
 	nvkm_instobj_destroy(&amp;node-&gt;base);
 }
 
<span class="p_chunk">@@ -62,6 +67,7 @@</span> <span class="p_context"> nv04_instobj_ctor(struct nvkm_object *parent, struct nvkm_object *engine,</span>
 	struct nv04_instmem_priv *priv = (void *)nvkm_instmem(parent);
 	struct nv04_instobj_priv *node;
 	struct nvkm_instobj_args *args = data;
<span class="p_add">+	struct nvkm_subdev *subdev = (void *)priv;</span>
 	int ret;
 
 	if (!args-&gt;align)
<span class="p_chunk">@@ -72,8 +78,10 @@</span> <span class="p_context"> nv04_instobj_ctor(struct nvkm_object *parent, struct nvkm_object *engine,</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	mutex_lock(&amp;subdev-&gt;mutex);</span>
 	ret = nvkm_mm_head(&amp;priv-&gt;heap, 0, 1, args-&gt;size, args-&gt;size,
 			   args-&gt;align, &amp;node-&gt;mem);
<span class="p_add">+	mutex_unlock(&amp;subdev-&gt;mutex);</span>
 	if (ret)
 		return ret;
 
<span class="p_header">diff --git a/drivers/hid/hid-cp2112.c b/drivers/hid/hid-cp2112.c</span>
<span class="p_header">index 3318de690e00..a2dbbbe0d8d7 100644</span>
<span class="p_header">--- a/drivers/hid/hid-cp2112.c</span>
<span class="p_header">+++ b/drivers/hid/hid-cp2112.c</span>
<span class="p_chunk">@@ -356,6 +356,8 @@</span> <span class="p_context"> static int cp2112_read(struct cp2112_device *dev, u8 *data, size_t size)</span>
 	struct cp2112_force_read_report report;
 	int ret;
 
<span class="p_add">+	if (size &gt; sizeof(dev-&gt;read_data))</span>
<span class="p_add">+		size = sizeof(dev-&gt;read_data);</span>
 	report.report = CP2112_DATA_READ_FORCE_SEND;
 	report.length = cpu_to_be16(size);
 
<span class="p_header">diff --git a/drivers/hwmon/nct7802.c b/drivers/hwmon/nct7802.c</span>
<span class="p_header">index 28fcb2e246d5..fbfc02bb2cfa 100644</span>
<span class="p_header">--- a/drivers/hwmon/nct7802.c</span>
<span class="p_header">+++ b/drivers/hwmon/nct7802.c</span>
<span class="p_chunk">@@ -195,7 +195,7 @@</span> <span class="p_context"> abort:</span>
 }
 
 static int nct7802_write_voltage(struct nct7802_data *data, int nr, int index,
<span class="p_del">-				 unsigned int voltage)</span>
<span class="p_add">+				 unsigned long voltage)</span>
 {
 	int shift = 8 - REG_VOLTAGE_LIMIT_MSB_SHIFT[index - 1][nr];
 	int err;
<span class="p_header">diff --git a/drivers/hwmon/nct7904.c b/drivers/hwmon/nct7904.c</span>
<span class="p_header">index b77b82f24480..6153df735e82 100644</span>
<span class="p_header">--- a/drivers/hwmon/nct7904.c</span>
<span class="p_header">+++ b/drivers/hwmon/nct7904.c</span>
<span class="p_chunk">@@ -412,8 +412,9 @@</span> <span class="p_context"> static ssize_t show_pwm(struct device *dev,</span>
 	return sprintf(buf, &quot;%d\n&quot;, val);
 }
 
<span class="p_del">-static ssize_t store_mode(struct device *dev, struct device_attribute *devattr,</span>
<span class="p_del">-			  const char *buf, size_t count)</span>
<span class="p_add">+static ssize_t store_enable(struct device *dev,</span>
<span class="p_add">+			    struct device_attribute *devattr,</span>
<span class="p_add">+			    const char *buf, size_t count)</span>
 {
 	int index = to_sensor_dev_attr(devattr)-&gt;index;
 	struct nct7904_data *data = dev_get_drvdata(dev);
<span class="p_chunk">@@ -422,18 +423,18 @@</span> <span class="p_context"> static ssize_t store_mode(struct device *dev, struct device_attribute *devattr,</span>
 
 	if (kstrtoul(buf, 10, &amp;val) &lt; 0)
 		return -EINVAL;
<span class="p_del">-	if (val &gt; 1 || (val &amp;&amp; !data-&gt;fan_mode[index]))</span>
<span class="p_add">+	if (val &lt; 1 || val &gt; 2 || (val == 2 &amp;&amp; !data-&gt;fan_mode[index]))</span>
 		return -EINVAL;
 
 	ret = nct7904_write_reg(data, BANK_3, FANCTL1_FMR_REG + index,
<span class="p_del">-				val ? data-&gt;fan_mode[index] : 0);</span>
<span class="p_add">+				val == 2 ? data-&gt;fan_mode[index] : 0);</span>
 
 	return ret ? ret : count;
 }
 
<span class="p_del">-/* Return 0 for manual mode or 1 for SmartFan mode */</span>
<span class="p_del">-static ssize_t show_mode(struct device *dev,</span>
<span class="p_del">-			 struct device_attribute *devattr, char *buf)</span>
<span class="p_add">+/* Return 1 for manual mode or 2 for SmartFan mode */</span>
<span class="p_add">+static ssize_t show_enable(struct device *dev,</span>
<span class="p_add">+			   struct device_attribute *devattr, char *buf)</span>
 {
 	int index = to_sensor_dev_attr(devattr)-&gt;index;
 	struct nct7904_data *data = dev_get_drvdata(dev);
<span class="p_chunk">@@ -443,36 +444,36 @@</span> <span class="p_context"> static ssize_t show_mode(struct device *dev,</span>
 	if (val &lt; 0)
 		return val;
 
<span class="p_del">-	return sprintf(buf, &quot;%d\n&quot;, val ? 1 : 0);</span>
<span class="p_add">+	return sprintf(buf, &quot;%d\n&quot;, val ? 2 : 1);</span>
 }
 
 /* 2 attributes per channel: pwm and mode */
<span class="p_del">-static SENSOR_DEVICE_ATTR(fan1_pwm, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+static SENSOR_DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR,</span>
 			show_pwm, store_pwm, 0);
<span class="p_del">-static SENSOR_DEVICE_ATTR(fan1_mode, S_IRUGO | S_IWUSR,</span>
<span class="p_del">-			show_mode, store_mode, 0);</span>
<span class="p_del">-static SENSOR_DEVICE_ATTR(fan2_pwm, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+static SENSOR_DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+			show_enable, store_enable, 0);</span>
<span class="p_add">+static SENSOR_DEVICE_ATTR(pwm2, S_IRUGO | S_IWUSR,</span>
 			show_pwm, store_pwm, 1);
<span class="p_del">-static SENSOR_DEVICE_ATTR(fan2_mode, S_IRUGO | S_IWUSR,</span>
<span class="p_del">-			show_mode, store_mode, 1);</span>
<span class="p_del">-static SENSOR_DEVICE_ATTR(fan3_pwm, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+static SENSOR_DEVICE_ATTR(pwm2_enable, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+			show_enable, store_enable, 1);</span>
<span class="p_add">+static SENSOR_DEVICE_ATTR(pwm3, S_IRUGO | S_IWUSR,</span>
 			show_pwm, store_pwm, 2);
<span class="p_del">-static SENSOR_DEVICE_ATTR(fan3_mode, S_IRUGO | S_IWUSR,</span>
<span class="p_del">-			show_mode, store_mode, 2);</span>
<span class="p_del">-static SENSOR_DEVICE_ATTR(fan4_pwm, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+static SENSOR_DEVICE_ATTR(pwm3_enable, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+			show_enable, store_enable, 2);</span>
<span class="p_add">+static SENSOR_DEVICE_ATTR(pwm4, S_IRUGO | S_IWUSR,</span>
 			show_pwm, store_pwm, 3);
<span class="p_del">-static SENSOR_DEVICE_ATTR(fan4_mode, S_IRUGO | S_IWUSR,</span>
<span class="p_del">-			show_mode, store_mode, 3);</span>
<span class="p_add">+static SENSOR_DEVICE_ATTR(pwm4_enable, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+			show_enable, store_enable, 3);</span>
 
 static struct attribute *nct7904_fanctl_attrs[] = {
<span class="p_del">-	&amp;sensor_dev_attr_fan1_pwm.dev_attr.attr,</span>
<span class="p_del">-	&amp;sensor_dev_attr_fan1_mode.dev_attr.attr,</span>
<span class="p_del">-	&amp;sensor_dev_attr_fan2_pwm.dev_attr.attr,</span>
<span class="p_del">-	&amp;sensor_dev_attr_fan2_mode.dev_attr.attr,</span>
<span class="p_del">-	&amp;sensor_dev_attr_fan3_pwm.dev_attr.attr,</span>
<span class="p_del">-	&amp;sensor_dev_attr_fan3_mode.dev_attr.attr,</span>
<span class="p_del">-	&amp;sensor_dev_attr_fan4_pwm.dev_attr.attr,</span>
<span class="p_del">-	&amp;sensor_dev_attr_fan4_mode.dev_attr.attr,</span>
<span class="p_add">+	&amp;sensor_dev_attr_pwm1.dev_attr.attr,</span>
<span class="p_add">+	&amp;sensor_dev_attr_pwm1_enable.dev_attr.attr,</span>
<span class="p_add">+	&amp;sensor_dev_attr_pwm2.dev_attr.attr,</span>
<span class="p_add">+	&amp;sensor_dev_attr_pwm2_enable.dev_attr.attr,</span>
<span class="p_add">+	&amp;sensor_dev_attr_pwm3.dev_attr.attr,</span>
<span class="p_add">+	&amp;sensor_dev_attr_pwm3_enable.dev_attr.attr,</span>
<span class="p_add">+	&amp;sensor_dev_attr_pwm4.dev_attr.attr,</span>
<span class="p_add">+	&amp;sensor_dev_attr_pwm4_enable.dev_attr.attr,</span>
 	NULL
 };
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_verbs.c b/drivers/infiniband/ulp/ipoib/ipoib_verbs.c</span>
<span class="p_header">index e5cc43074196..2d13fd08ceb7 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_verbs.c</span>
<span class="p_chunk">@@ -176,7 +176,8 @@</span> <span class="p_context"> int ipoib_transport_dev_init(struct net_device *dev, struct ib_device *ca)</span>
 		else
 			size += ipoib_recvq_size * ipoib_max_conn_qp;
 	} else
<span class="p_del">-		goto out_free_wq;</span>
<span class="p_add">+		if (ret != -ENOSYS)</span>
<span class="p_add">+			goto out_free_wq;</span>
 
 	priv-&gt;recv_cq = ib_create_cq(priv-&gt;ca, ipoib_ib_completion, NULL, dev, size, 0);
 	if (IS_ERR(priv-&gt;recv_cq)) {
<span class="p_header">diff --git a/drivers/input/mouse/synaptics.c b/drivers/input/mouse/synaptics.c</span>
<span class="p_header">index 35c8d0ceabee..3a32caf06bf1 100644</span>
<span class="p_header">--- a/drivers/input/mouse/synaptics.c</span>
<span class="p_header">+++ b/drivers/input/mouse/synaptics.c</span>
<span class="p_chunk">@@ -1199,7 +1199,7 @@</span> <span class="p_context"> static void set_input_params(struct psmouse *psmouse,</span>
 					ABS_MT_POSITION_Y);
 		/* Image sensors can report per-contact pressure */
 		input_set_abs_params(dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
<span class="p_del">-		input_mt_init_slots(dev, 3, INPUT_MT_POINTER | INPUT_MT_TRACK);</span>
<span class="p_add">+		input_mt_init_slots(dev, 2, INPUT_MT_POINTER | INPUT_MT_TRACK);</span>
 
 		/* Image sensors can signal 4 and 5 finger clicks */
 		__set_bit(BTN_TOOL_QUADTAP, dev-&gt;keybit);
<span class="p_header">diff --git a/drivers/input/touchscreen/usbtouchscreen.c b/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_header">index f2c6c352c55a..2c41107240de 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_chunk">@@ -627,6 +627,9 @@</span> <span class="p_context"> static int dmc_tsc10_init(struct usbtouch_usb *usbtouch)</span>
 		goto err_out;
 	}
 
<span class="p_add">+	/* TSC-25 data sheet specifies a delay after the RESET command */</span>
<span class="p_add">+	msleep(150);</span>
<span class="p_add">+</span>
 	/* set coordinate output rate */
 	buf[0] = buf[1] = 0xFF;
 	ret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 5ecfaf29933a..c87c4b1bfc00 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -1756,8 +1756,9 @@</span> <span class="p_context"> static int domain_init(struct dmar_domain *domain, int guest_width)</span>
 
 static void domain_exit(struct dmar_domain *domain)
 {
<span class="p_add">+	struct dmar_drhd_unit *drhd;</span>
<span class="p_add">+	struct intel_iommu *iommu;</span>
 	struct page *freelist = NULL;
<span class="p_del">-	int i;</span>
 
 	/* Domain 0 is reserved, so dont process it */
 	if (!domain)
<span class="p_chunk">@@ -1777,8 +1778,10 @@</span> <span class="p_context"> static void domain_exit(struct dmar_domain *domain)</span>
 
 	/* clear attached or cached domains */
 	rcu_read_lock();
<span class="p_del">-	for_each_set_bit(i, domain-&gt;iommu_bmp, g_num_of_iommus)</span>
<span class="p_del">-		iommu_detach_domain(domain, g_iommus[i]);</span>
<span class="p_add">+	for_each_active_iommu(iommu, drhd)</span>
<span class="p_add">+		if (domain_type_is_vm(domain) ||</span>
<span class="p_add">+		    test_bit(iommu-&gt;seq_id, domain-&gt;iommu_bmp))</span>
<span class="p_add">+			iommu_detach_domain(domain, iommu);</span>
 	rcu_read_unlock();
 
 	dma_free_pagelist(freelist);
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="p_header">index 1b7e155869f6..c00e2db351ba 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="p_chunk">@@ -75,6 +75,13 @@</span> <span class="p_context"> struct its_node {</span>
 
 #define ITS_ITT_ALIGN		SZ_256
 
<span class="p_add">+struct event_lpi_map {</span>
<span class="p_add">+	unsigned long		*lpi_map;</span>
<span class="p_add">+	u16			*col_map;</span>
<span class="p_add">+	irq_hw_number_t		lpi_base;</span>
<span class="p_add">+	int			nr_lpis;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * The ITS view of a device - belongs to an ITS, a collection, owns an
  * interrupt translation table, and a list of interrupts.
<span class="p_chunk">@@ -82,11 +89,8 @@</span> <span class="p_context"> struct its_node {</span>
 struct its_device {
 	struct list_head	entry;
 	struct its_node		*its;
<span class="p_del">-	struct its_collection	*collection;</span>
<span class="p_add">+	struct event_lpi_map	event_map;</span>
 	void			*itt;
<span class="p_del">-	unsigned long		*lpi_map;</span>
<span class="p_del">-	irq_hw_number_t		lpi_base;</span>
<span class="p_del">-	int			nr_lpis;</span>
 	u32			nr_ites;
 	u32			device_id;
 };
<span class="p_chunk">@@ -99,6 +103,14 @@</span> <span class="p_context"> static struct rdists *gic_rdists;</span>
 #define gic_data_rdist()		(raw_cpu_ptr(gic_rdists-&gt;rdist))
 #define gic_data_rdist_rd_base()	(gic_data_rdist()-&gt;rd_base)
 
<span class="p_add">+static struct its_collection *dev_event_to_col(struct its_device *its_dev,</span>
<span class="p_add">+					       u32 event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct its_node *its = its_dev-&gt;its;</span>
<span class="p_add">+</span>
<span class="p_add">+	return its-&gt;collections + its_dev-&gt;event_map.col_map[event];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * ITS command descriptors - parameters to be encoded in a command
  * block.
<span class="p_chunk">@@ -134,7 +146,7 @@</span> <span class="p_context"> struct its_cmd_desc {</span>
 		struct {
 			struct its_device *dev;
 			struct its_collection *col;
<span class="p_del">-			u32 id;</span>
<span class="p_add">+			u32 event_id;</span>
 		} its_movi_cmd;
 
 		struct {
<span class="p_chunk">@@ -241,7 +253,7 @@</span> <span class="p_context"> static struct its_collection *its_build_mapd_cmd(struct its_cmd_block *cmd,</span>
 
 	its_fixup_cmd(cmd);
 
<span class="p_del">-	return desc-&gt;its_mapd_cmd.dev-&gt;collection;</span>
<span class="p_add">+	return NULL;</span>
 }
 
 static struct its_collection *its_build_mapc_cmd(struct its_cmd_block *cmd,
<span class="p_chunk">@@ -260,52 +272,72 @@</span> <span class="p_context"> static struct its_collection *its_build_mapc_cmd(struct its_cmd_block *cmd,</span>
 static struct its_collection *its_build_mapvi_cmd(struct its_cmd_block *cmd,
 						  struct its_cmd_desc *desc)
 {
<span class="p_add">+	struct its_collection *col;</span>
<span class="p_add">+</span>
<span class="p_add">+	col = dev_event_to_col(desc-&gt;its_mapvi_cmd.dev,</span>
<span class="p_add">+			       desc-&gt;its_mapvi_cmd.event_id);</span>
<span class="p_add">+</span>
 	its_encode_cmd(cmd, GITS_CMD_MAPVI);
 	its_encode_devid(cmd, desc-&gt;its_mapvi_cmd.dev-&gt;device_id);
 	its_encode_event_id(cmd, desc-&gt;its_mapvi_cmd.event_id);
 	its_encode_phys_id(cmd, desc-&gt;its_mapvi_cmd.phys_id);
<span class="p_del">-	its_encode_collection(cmd, desc-&gt;its_mapvi_cmd.dev-&gt;collection-&gt;col_id);</span>
<span class="p_add">+	its_encode_collection(cmd, col-&gt;col_id);</span>
 
 	its_fixup_cmd(cmd);
 
<span class="p_del">-	return desc-&gt;its_mapvi_cmd.dev-&gt;collection;</span>
<span class="p_add">+	return col;</span>
 }
 
 static struct its_collection *its_build_movi_cmd(struct its_cmd_block *cmd,
 						 struct its_cmd_desc *desc)
 {
<span class="p_add">+	struct its_collection *col;</span>
<span class="p_add">+</span>
<span class="p_add">+	col = dev_event_to_col(desc-&gt;its_movi_cmd.dev,</span>
<span class="p_add">+			       desc-&gt;its_movi_cmd.event_id);</span>
<span class="p_add">+</span>
 	its_encode_cmd(cmd, GITS_CMD_MOVI);
 	its_encode_devid(cmd, desc-&gt;its_movi_cmd.dev-&gt;device_id);
<span class="p_del">-	its_encode_event_id(cmd, desc-&gt;its_movi_cmd.id);</span>
<span class="p_add">+	its_encode_event_id(cmd, desc-&gt;its_movi_cmd.event_id);</span>
 	its_encode_collection(cmd, desc-&gt;its_movi_cmd.col-&gt;col_id);
 
 	its_fixup_cmd(cmd);
 
<span class="p_del">-	return desc-&gt;its_movi_cmd.dev-&gt;collection;</span>
<span class="p_add">+	return col;</span>
 }
 
 static struct its_collection *its_build_discard_cmd(struct its_cmd_block *cmd,
 						    struct its_cmd_desc *desc)
 {
<span class="p_add">+	struct its_collection *col;</span>
<span class="p_add">+</span>
<span class="p_add">+	col = dev_event_to_col(desc-&gt;its_discard_cmd.dev,</span>
<span class="p_add">+			       desc-&gt;its_discard_cmd.event_id);</span>
<span class="p_add">+</span>
 	its_encode_cmd(cmd, GITS_CMD_DISCARD);
 	its_encode_devid(cmd, desc-&gt;its_discard_cmd.dev-&gt;device_id);
 	its_encode_event_id(cmd, desc-&gt;its_discard_cmd.event_id);
 
 	its_fixup_cmd(cmd);
 
<span class="p_del">-	return desc-&gt;its_discard_cmd.dev-&gt;collection;</span>
<span class="p_add">+	return col;</span>
 }
 
 static struct its_collection *its_build_inv_cmd(struct its_cmd_block *cmd,
 						struct its_cmd_desc *desc)
 {
<span class="p_add">+	struct its_collection *col;</span>
<span class="p_add">+</span>
<span class="p_add">+	col = dev_event_to_col(desc-&gt;its_inv_cmd.dev,</span>
<span class="p_add">+			       desc-&gt;its_inv_cmd.event_id);</span>
<span class="p_add">+</span>
 	its_encode_cmd(cmd, GITS_CMD_INV);
 	its_encode_devid(cmd, desc-&gt;its_inv_cmd.dev-&gt;device_id);
 	its_encode_event_id(cmd, desc-&gt;its_inv_cmd.event_id);
 
 	its_fixup_cmd(cmd);
 
<span class="p_del">-	return desc-&gt;its_inv_cmd.dev-&gt;collection;</span>
<span class="p_add">+	return col;</span>
 }
 
 static struct its_collection *its_build_invall_cmd(struct its_cmd_block *cmd,
<span class="p_chunk">@@ -497,7 +529,7 @@</span> <span class="p_context"> static void its_send_movi(struct its_device *dev,</span>
 
 	desc.its_movi_cmd.dev = dev;
 	desc.its_movi_cmd.col = col;
<span class="p_del">-	desc.its_movi_cmd.id = id;</span>
<span class="p_add">+	desc.its_movi_cmd.event_id = id;</span>
 
 	its_send_single_command(dev-&gt;its, its_build_movi_cmd, &amp;desc);
 }
<span class="p_chunk">@@ -528,7 +560,7 @@</span> <span class="p_context"> static void its_send_invall(struct its_node *its, struct its_collection *col)</span>
 static inline u32 its_get_event_id(struct irq_data *d)
 {
 	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
<span class="p_del">-	return d-&gt;hwirq - its_dev-&gt;lpi_base;</span>
<span class="p_add">+	return d-&gt;hwirq - its_dev-&gt;event_map.lpi_base;</span>
 }
 
 static void lpi_set_config(struct irq_data *d, bool enable)
<span class="p_chunk">@@ -583,7 +615,7 @@</span> <span class="p_context"> static int its_set_affinity(struct irq_data *d, const struct cpumask *mask_val,</span>
 
 	target_col = &amp;its_dev-&gt;its-&gt;collections[cpu];
 	its_send_movi(its_dev, target_col, id);
<span class="p_del">-	its_dev-&gt;collection = target_col;</span>
<span class="p_add">+	its_dev-&gt;event_map.col_map[id] = cpu;</span>
 
 	return IRQ_SET_MASK_OK_DONE;
 }
<span class="p_chunk">@@ -713,8 +745,10 @@</span> <span class="p_context"> out:</span>
 	return bitmap;
 }
 
<span class="p_del">-static void its_lpi_free(unsigned long *bitmap, int base, int nr_ids)</span>
<span class="p_add">+static void its_lpi_free(struct event_lpi_map *map)</span>
 {
<span class="p_add">+	int base = map-&gt;lpi_base;</span>
<span class="p_add">+	int nr_ids = map-&gt;nr_lpis;</span>
 	int lpi;
 
 	spin_lock(&amp;lpi_lock);
<span class="p_chunk">@@ -731,7 +765,8 @@</span> <span class="p_context"> static void its_lpi_free(unsigned long *bitmap, int base, int nr_ids)</span>
 
 	spin_unlock(&amp;lpi_lock);
 
<span class="p_del">-	kfree(bitmap);</span>
<span class="p_add">+	kfree(map-&gt;lpi_map);</span>
<span class="p_add">+	kfree(map-&gt;col_map);</span>
 }
 
 /*
<span class="p_chunk">@@ -1099,11 +1134,11 @@</span> <span class="p_context"> static struct its_device *its_create_device(struct its_node *its, u32 dev_id,</span>
 	struct its_device *dev;
 	unsigned long *lpi_map;
 	unsigned long flags;
<span class="p_add">+	u16 *col_map = NULL;</span>
 	void *itt;
 	int lpi_base;
 	int nr_lpis;
 	int nr_ites;
<span class="p_del">-	int cpu;</span>
 	int sz;
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
<span class="p_chunk">@@ -1117,20 +1152,24 @@</span> <span class="p_context"> static struct its_device *its_create_device(struct its_node *its, u32 dev_id,</span>
 	sz = max(sz, ITS_ITT_ALIGN) + ITS_ITT_ALIGN - 1;
 	itt = kzalloc(sz, GFP_KERNEL);
 	lpi_map = its_lpi_alloc_chunks(nvecs, &amp;lpi_base, &amp;nr_lpis);
<span class="p_add">+	if (lpi_map)</span>
<span class="p_add">+		col_map = kzalloc(sizeof(*col_map) * nr_lpis, GFP_KERNEL);</span>
 
<span class="p_del">-	if (!dev || !itt || !lpi_map) {</span>
<span class="p_add">+	if (!dev || !itt || !lpi_map || !col_map) {</span>
 		kfree(dev);
 		kfree(itt);
 		kfree(lpi_map);
<span class="p_add">+		kfree(col_map);</span>
 		return NULL;
 	}
 
 	dev-&gt;its = its;
 	dev-&gt;itt = itt;
 	dev-&gt;nr_ites = nr_ites;
<span class="p_del">-	dev-&gt;lpi_map = lpi_map;</span>
<span class="p_del">-	dev-&gt;lpi_base = lpi_base;</span>
<span class="p_del">-	dev-&gt;nr_lpis = nr_lpis;</span>
<span class="p_add">+	dev-&gt;event_map.lpi_map = lpi_map;</span>
<span class="p_add">+	dev-&gt;event_map.col_map = col_map;</span>
<span class="p_add">+	dev-&gt;event_map.lpi_base = lpi_base;</span>
<span class="p_add">+	dev-&gt;event_map.nr_lpis = nr_lpis;</span>
 	dev-&gt;device_id = dev_id;
 	INIT_LIST_HEAD(&amp;dev-&gt;entry);
 
<span class="p_chunk">@@ -1138,10 +1177,6 @@</span> <span class="p_context"> static struct its_device *its_create_device(struct its_node *its, u32 dev_id,</span>
 	list_add(&amp;dev-&gt;entry, &amp;its-&gt;its_device_list);
 	raw_spin_unlock_irqrestore(&amp;its-&gt;lock, flags);
 
<span class="p_del">-	/* Bind the device to the first possible CPU */</span>
<span class="p_del">-	cpu = cpumask_first(cpu_online_mask);</span>
<span class="p_del">-	dev-&gt;collection = &amp;its-&gt;collections[cpu];</span>
<span class="p_del">-</span>
 	/* Map device to its ITT */
 	its_send_mapd(dev, 1);
 
<span class="p_chunk">@@ -1163,12 +1198,13 @@</span> <span class="p_context"> static int its_alloc_device_irq(struct its_device *dev, irq_hw_number_t *hwirq)</span>
 {
 	int idx;
 
<span class="p_del">-	idx = find_first_zero_bit(dev-&gt;lpi_map, dev-&gt;nr_lpis);</span>
<span class="p_del">-	if (idx == dev-&gt;nr_lpis)</span>
<span class="p_add">+	idx = find_first_zero_bit(dev-&gt;event_map.lpi_map,</span>
<span class="p_add">+				  dev-&gt;event_map.nr_lpis);</span>
<span class="p_add">+	if (idx == dev-&gt;event_map.nr_lpis)</span>
 		return -ENOSPC;
 
<span class="p_del">-	*hwirq = dev-&gt;lpi_base + idx;</span>
<span class="p_del">-	set_bit(idx, dev-&gt;lpi_map);</span>
<span class="p_add">+	*hwirq = dev-&gt;event_map.lpi_base + idx;</span>
<span class="p_add">+	set_bit(idx, dev-&gt;event_map.lpi_map);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1288,7 +1324,8 @@</span> <span class="p_context"> static int its_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,</span>
 		irq_domain_set_hwirq_and_chip(domain, virq + i,
 					      hwirq, &amp;its_irq_chip, its_dev);
 		dev_dbg(info-&gt;scratchpad[1].ptr, &quot;ID:%d pID:%d vID:%d\n&quot;,
<span class="p_del">-			(int)(hwirq - its_dev-&gt;lpi_base), (int)hwirq, virq + i);</span>
<span class="p_add">+			(int)(hwirq - its_dev-&gt;event_map.lpi_base),</span>
<span class="p_add">+			(int)hwirq, virq + i);</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -1300,6 +1337,9 @@</span> <span class="p_context"> static void its_irq_domain_activate(struct irq_domain *domain,</span>
 	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
 	u32 event = its_get_event_id(d);
 
<span class="p_add">+	/* Bind the LPI to the first possible CPU */</span>
<span class="p_add">+	its_dev-&gt;event_map.col_map[event] = cpumask_first(cpu_online_mask);</span>
<span class="p_add">+</span>
 	/* Map the GIC IRQ and event to the device */
 	its_send_mapvi(its_dev, d-&gt;hwirq, event);
 }
<span class="p_chunk">@@ -1327,17 +1367,16 @@</span> <span class="p_context"> static void its_irq_domain_free(struct irq_domain *domain, unsigned int virq,</span>
 		u32 event = its_get_event_id(data);
 
 		/* Mark interrupt index as unused */
<span class="p_del">-		clear_bit(event, its_dev-&gt;lpi_map);</span>
<span class="p_add">+		clear_bit(event, its_dev-&gt;event_map.lpi_map);</span>
 
 		/* Nuke the entry in the domain */
 		irq_domain_reset_irq_data(data);
 	}
 
 	/* If all interrupts have been freed, start mopping the floor */
<span class="p_del">-	if (bitmap_empty(its_dev-&gt;lpi_map, its_dev-&gt;nr_lpis)) {</span>
<span class="p_del">-		its_lpi_free(its_dev-&gt;lpi_map,</span>
<span class="p_del">-			     its_dev-&gt;lpi_base,</span>
<span class="p_del">-			     its_dev-&gt;nr_lpis);</span>
<span class="p_add">+	if (bitmap_empty(its_dev-&gt;event_map.lpi_map,</span>
<span class="p_add">+			 its_dev-&gt;event_map.nr_lpis)) {</span>
<span class="p_add">+		its_lpi_free(&amp;its_dev-&gt;event_map);</span>
 
 		/* Unmap device/itt */
 		its_send_mapd(its_dev, 0);
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 2caf492890d6..e8d84566f311 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -1053,13 +1053,10 @@</span> <span class="p_context"> static struct dm_rq_target_io *tio_from_request(struct request *rq)</span>
  */
 static void rq_completed(struct mapped_device *md, int rw, bool run_queue)
 {
<span class="p_del">-	int nr_requests_pending;</span>
<span class="p_del">-</span>
 	atomic_dec(&amp;md-&gt;pending[rw]);
 
 	/* nudge anyone waiting on suspend queue */
<span class="p_del">-	nr_requests_pending = md_in_flight(md);</span>
<span class="p_del">-	if (!nr_requests_pending)</span>
<span class="p_add">+	if (!md_in_flight(md))</span>
 		wake_up(&amp;md-&gt;wait);
 
 	/*
<span class="p_chunk">@@ -1071,8 +1068,7 @@</span> <span class="p_context"> static void rq_completed(struct mapped_device *md, int rw, bool run_queue)</span>
 	if (run_queue) {
 		if (md-&gt;queue-&gt;mq_ops)
 			blk_mq_run_hw_queues(md-&gt;queue, true);
<span class="p_del">-		else if (!nr_requests_pending ||</span>
<span class="p_del">-			 (nr_requests_pending &gt;= md-&gt;queue-&gt;nr_congestion_on))</span>
<span class="p_add">+		else</span>
 			blk_run_queue_async(md-&gt;queue);
 	}
 
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 9157a29c8dbf..cd7b0c1e882d 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -336,7 +336,7 @@</span> <span class="p_context"> static void raid1_end_read_request(struct bio *bio, int error)</span>
 		spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);
 		if (r1_bio-&gt;mddev-&gt;degraded == conf-&gt;raid_disks ||
 		    (r1_bio-&gt;mddev-&gt;degraded == conf-&gt;raid_disks-1 &amp;&amp;
<span class="p_del">-		     !test_bit(Faulty, &amp;conf-&gt;mirrors[mirror].rdev-&gt;flags)))</span>
<span class="p_add">+		     test_bit(In_sync, &amp;conf-&gt;mirrors[mirror].rdev-&gt;flags)))</span>
 			uptodate = 1;
 		spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
 	}
<span class="p_header">diff --git a/drivers/misc/cxl/context.c b/drivers/misc/cxl/context.c</span>
<span class="p_header">index d1b55fe62817..e4dc8cdf67a3 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/context.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/context.c</span>
<span class="p_chunk">@@ -113,11 +113,11 @@</span> <span class="p_context"> static int cxl_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)</span>
 
 	if (ctx-&gt;afu-&gt;current_mode == CXL_MODE_DEDICATED) {
 		area = ctx-&gt;afu-&gt;psn_phys;
<span class="p_del">-		if (offset &gt; ctx-&gt;afu-&gt;adapter-&gt;ps_size)</span>
<span class="p_add">+		if (offset &gt;= ctx-&gt;afu-&gt;adapter-&gt;ps_size)</span>
 			return VM_FAULT_SIGBUS;
 	} else {
 		area = ctx-&gt;psn_phys;
<span class="p_del">-		if (offset &gt; ctx-&gt;psn_size)</span>
<span class="p_add">+		if (offset &gt;= ctx-&gt;psn_size)</span>
 			return VM_FAULT_SIGBUS;
 	}
 
<span class="p_header">diff --git a/drivers/misc/cxl/main.c b/drivers/misc/cxl/main.c</span>
<span class="p_header">index 8ccddceead66..de350dd46218 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/main.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/main.c</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> static inline void cxl_slbia_core(struct mm_struct *mm)</span>
 		spin_lock(&amp;adapter-&gt;afu_list_lock);
 		for (slice = 0; slice &lt; adapter-&gt;slices; slice++) {
 			afu = adapter-&gt;afu[slice];
<span class="p_del">-			if (!afu-&gt;enabled)</span>
<span class="p_add">+			if (!afu || !afu-&gt;enabled)</span>
 				continue;
 			rcu_read_lock();
 			idr_for_each_entry(&amp;afu-&gt;contexts_idr, ctx, id)
<span class="p_header">diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c</span>
<span class="p_header">index 3e2968159506..e40bcd03bd47 100644</span>
<span class="p_header">--- a/drivers/misc/mei/main.c</span>
<span class="p_header">+++ b/drivers/misc/mei/main.c</span>
<span class="p_chunk">@@ -685,7 +685,7 @@</span> <span class="p_context"> int mei_register(struct mei_device *dev, struct device *parent)</span>
 	/* Fill in the data structures */
 	devno = MKDEV(MAJOR(mei_devt), dev-&gt;minor);
 	cdev_init(&amp;dev-&gt;cdev, &amp;mei_fops);
<span class="p_del">-	dev-&gt;cdev.owner = mei_fops.owner;</span>
<span class="p_add">+	dev-&gt;cdev.owner = parent-&gt;driver-&gt;owner;</span>
 
 	/* Add the device */
 	ret = cdev_add(&amp;dev-&gt;cdev, devno, 1);
<span class="p_header">diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c</span>
<span class="p_header">index 9df2b6801f76..d0abdffb0d7c 100644</span>
<span class="p_header">--- a/drivers/mmc/host/omap_hsmmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/omap_hsmmc.c</span>
<span class="p_chunk">@@ -1062,6 +1062,10 @@</span> <span class="p_context"> static void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)</span>
 
 		if (status &amp; (CTO_EN | CCRC_EN))
 			end_cmd = 1;
<span class="p_add">+		if (host-&gt;data || host-&gt;response_busy) {</span>
<span class="p_add">+			end_trans = !end_cmd;</span>
<span class="p_add">+			host-&gt;response_busy = 0;</span>
<span class="p_add">+		}</span>
 		if (status &amp; (CTO_EN | DTO_EN))
 			hsmmc_command_incomplete(host, -ETIMEDOUT, end_cmd);
 		else if (status &amp; (CCRC_EN | DCRC_EN))
<span class="p_chunk">@@ -1081,10 +1085,6 @@</span> <span class="p_context"> static void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)</span>
 			}
 			dev_dbg(mmc_dev(host-&gt;mmc), &quot;AC12 err: 0x%x\n&quot;, ac12);
 		}
<span class="p_del">-		if (host-&gt;data || host-&gt;response_busy) {</span>
<span class="p_del">-			end_trans = !end_cmd;</span>
<span class="p_del">-			host-&gt;response_busy = 0;</span>
<span class="p_del">-		}</span>
 	}
 
 	OMAP_HSMMC_WRITE(host-&gt;base, STAT, status);
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h</span>
<span class="p_header">index 3497cfaf683c..a870c42731d7 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-esdhc.h</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-esdhc.h</span>
<span class="p_chunk">@@ -45,6 +45,6 @@</span> <span class="p_context"></span>
 #define ESDHC_DMA_SYSCTL	0x40c
 #define ESDHC_DMA_SNOOP		0x00000040
 
<span class="p_del">-#define ESDHC_HOST_CONTROL_RES	0x05</span>
<span class="p_add">+#define ESDHC_HOST_CONTROL_RES	0x01</span>
 
 #endif /* _DRIVERS_MMC_SDHCI_ESDHC_H */
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-pxav3.c b/drivers/mmc/host/sdhci-pxav3.c</span>
<span class="p_header">index b5103a247bc1..065dc70caa1d 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-pxav3.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-pxav3.c</span>
<span class="p_chunk">@@ -411,6 +411,7 @@</span> <span class="p_context"> static int sdhci_pxav3_probe(struct platform_device *pdev)</span>
 			goto err_of_parse;
 		sdhci_get_of_property(pdev);
 		pdata = pxav3_get_mmc_pdata(dev);
<span class="p_add">+		pdev-&gt;dev.platform_data = pdata;</span>
 	} else if (pdata) {
 		/* on-chip device */
 		if (pdata-&gt;flags &amp; PXA_FLAG_CARD_PERMANENT)
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index d3dbb28057e9..bec8a307f8cd 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -3037,8 +3037,11 @@</span> <span class="p_context"> int sdhci_add_host(struct sdhci_host *host)</span>
 						      GFP_KERNEL);
 		host-&gt;align_buffer = kmalloc(host-&gt;align_buffer_sz, GFP_KERNEL);
 		if (!host-&gt;adma_table || !host-&gt;align_buffer) {
<span class="p_del">-			dma_free_coherent(mmc_dev(mmc), host-&gt;adma_table_sz,</span>
<span class="p_del">-					  host-&gt;adma_table, host-&gt;adma_addr);</span>
<span class="p_add">+			if (host-&gt;adma_table)</span>
<span class="p_add">+				dma_free_coherent(mmc_dev(mmc),</span>
<span class="p_add">+						  host-&gt;adma_table_sz,</span>
<span class="p_add">+						  host-&gt;adma_table,</span>
<span class="p_add">+						  host-&gt;adma_addr);</span>
 			kfree(host-&gt;align_buffer);
 			pr_warn(&quot;%s: Unable to allocate ADMA buffers - falling back to standard DMA\n&quot;,
 				mmc_hostname(mmc));
<span class="p_header">diff --git a/drivers/net/can/c_can/c_can.c b/drivers/net/can/c_can/c_can.c</span>
<span class="p_header">index 041525d2595c..5d214d135332 100644</span>
<span class="p_header">--- a/drivers/net/can/c_can/c_can.c</span>
<span class="p_header">+++ b/drivers/net/can/c_can/c_can.c</span>
<span class="p_chunk">@@ -592,6 +592,7 @@</span> <span class="p_context"> static int c_can_start(struct net_device *dev)</span>
 {
 	struct c_can_priv *priv = netdev_priv(dev);
 	int err;
<span class="p_add">+	struct pinctrl *p;</span>
 
 	/* basic c_can configuration */
 	err = c_can_chip_config(dev);
<span class="p_chunk">@@ -604,8 +605,13 @@</span> <span class="p_context"> static int c_can_start(struct net_device *dev)</span>
 
 	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
 
<span class="p_del">-	/* activate pins */</span>
<span class="p_del">-	pinctrl_pm_select_default_state(dev-&gt;dev.parent);</span>
<span class="p_add">+	/* Attempt to use &quot;active&quot; if available else use &quot;default&quot; */</span>
<span class="p_add">+	p = pinctrl_get_select(priv-&gt;device, &quot;active&quot;);</span>
<span class="p_add">+	if (!IS_ERR(p))</span>
<span class="p_add">+		pinctrl_put(p);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		pinctrl_pm_select_default_state(priv-&gt;device);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index e9b1810d319f..aede704605c6 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -440,9 +440,6 @@</span> <span class="p_context"> unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx)</span>
 		struct can_frame *cf = (struct can_frame *)skb-&gt;data;
 		u8 dlc = cf-&gt;can_dlc;
 
<span class="p_del">-		if (!(skb-&gt;tstamp.tv64))</span>
<span class="p_del">-			__net_timestamp(skb);</span>
<span class="p_del">-</span>
 		netif_rx(priv-&gt;echo_skb[idx]);
 		priv-&gt;echo_skb[idx] = NULL;
 
<span class="p_chunk">@@ -578,7 +575,6 @@</span> <span class="p_context"> struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf)</span>
 	if (unlikely(!skb))
 		return NULL;
 
<span class="p_del">-	__net_timestamp(skb);</span>
 	skb-&gt;protocol = htons(ETH_P_CAN);
 	skb-&gt;pkt_type = PACKET_BROADCAST;
 	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
<span class="p_chunk">@@ -589,6 +585,7 @@</span> <span class="p_context"> struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf)</span>
 
 	can_skb_reserve(skb);
 	can_skb_prv(skb)-&gt;ifindex = dev-&gt;ifindex;
<span class="p_add">+	can_skb_prv(skb)-&gt;skbcnt = 0;</span>
 
 	*cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
 	memset(*cf, 0, sizeof(struct can_frame));
<span class="p_chunk">@@ -607,7 +604,6 @@</span> <span class="p_context"> struct sk_buff *alloc_canfd_skb(struct net_device *dev,</span>
 	if (unlikely(!skb))
 		return NULL;
 
<span class="p_del">-	__net_timestamp(skb);</span>
 	skb-&gt;protocol = htons(ETH_P_CANFD);
 	skb-&gt;pkt_type = PACKET_BROADCAST;
 	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
<span class="p_chunk">@@ -618,6 +614,7 @@</span> <span class="p_context"> struct sk_buff *alloc_canfd_skb(struct net_device *dev,</span>
 
 	can_skb_reserve(skb);
 	can_skb_prv(skb)-&gt;ifindex = dev-&gt;ifindex;
<span class="p_add">+	can_skb_prv(skb)-&gt;skbcnt = 0;</span>
 
 	*cfd = (struct canfd_frame *)skb_put(skb, sizeof(struct canfd_frame));
 	memset(*cfd, 0, sizeof(struct canfd_frame));
<span class="p_header">diff --git a/drivers/net/can/rcar_can.c b/drivers/net/can/rcar_can.c</span>
<span class="p_header">index 7deb80dcbe8c..2f9ebad4ff56 100644</span>
<span class="p_header">--- a/drivers/net/can/rcar_can.c</span>
<span class="p_header">+++ b/drivers/net/can/rcar_can.c</span>
<span class="p_chunk">@@ -526,7 +526,7 @@</span> <span class="p_context"> static int rcar_can_open(struct net_device *ndev)</span>
 	napi_enable(&amp;priv-&gt;napi);
 	err = request_irq(ndev-&gt;irq, rcar_can_interrupt, 0, ndev-&gt;name, ndev);
 	if (err) {
<span class="p_del">-		netdev_err(ndev, &quot;error requesting interrupt %x\n&quot;, ndev-&gt;irq);</span>
<span class="p_add">+		netdev_err(ndev, &quot;error requesting interrupt %d\n&quot;, ndev-&gt;irq);</span>
 		goto out_close;
 	}
 	can_led_event(ndev, CAN_LED_EVENT_OPEN);
<span class="p_chunk">@@ -758,8 +758,9 @@</span> <span class="p_context"> static int rcar_can_probe(struct platform_device *pdev)</span>
 	}
 
 	irq = platform_get_irq(pdev, 0);
<span class="p_del">-	if (!irq) {</span>
<span class="p_add">+	if (irq &lt; 0) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;No IRQ resource\n&quot;);
<span class="p_add">+		err = irq;</span>
 		goto fail;
 	}
 
<span class="p_chunk">@@ -823,7 +824,7 @@</span> <span class="p_context"> static int rcar_can_probe(struct platform_device *pdev)</span>
 
 	devm_can_led_init(ndev);
 
<span class="p_del">-	dev_info(&amp;pdev-&gt;dev, &quot;device registered (reg_base=%p, irq=%u)\n&quot;,</span>
<span class="p_add">+	dev_info(&amp;pdev-&gt;dev, &quot;device registered (regs @ %p, IRQ%d)\n&quot;,</span>
 		 priv-&gt;regs, ndev-&gt;irq);
 
 	return 0;
<span class="p_header">diff --git a/drivers/net/can/slcan.c b/drivers/net/can/slcan.c</span>
<span class="p_header">index f64f5290d6f8..a23a7af8eb9a 100644</span>
<span class="p_header">--- a/drivers/net/can/slcan.c</span>
<span class="p_header">+++ b/drivers/net/can/slcan.c</span>
<span class="p_chunk">@@ -207,7 +207,6 @@</span> <span class="p_context"> static void slc_bump(struct slcan *sl)</span>
 	if (!skb)
 		return;
 
<span class="p_del">-	__net_timestamp(skb);</span>
 	skb-&gt;dev = sl-&gt;dev;
 	skb-&gt;protocol = htons(ETH_P_CAN);
 	skb-&gt;pkt_type = PACKET_BROADCAST;
<span class="p_chunk">@@ -215,6 +214,7 @@</span> <span class="p_context"> static void slc_bump(struct slcan *sl)</span>
 
 	can_skb_reserve(skb);
 	can_skb_prv(skb)-&gt;ifindex = sl-&gt;dev-&gt;ifindex;
<span class="p_add">+	can_skb_prv(skb)-&gt;skbcnt = 0;</span>
 
 	memcpy(skb_put(skb, sizeof(struct can_frame)),
 	       &amp;cf, sizeof(struct can_frame));
<span class="p_header">diff --git a/drivers/net/can/spi/mcp251x.c b/drivers/net/can/spi/mcp251x.c</span>
<span class="p_header">index bf63fee4e743..34c625ea2801 100644</span>
<span class="p_header">--- a/drivers/net/can/spi/mcp251x.c</span>
<span class="p_header">+++ b/drivers/net/can/spi/mcp251x.c</span>
<span class="p_chunk">@@ -1221,17 +1221,16 @@</span> <span class="p_context"> static int __maybe_unused mcp251x_can_resume(struct device *dev)</span>
 	struct spi_device *spi = to_spi_device(dev);
 	struct mcp251x_priv *priv = spi_get_drvdata(spi);
 
<span class="p_del">-	if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_POWER) {</span>
<span class="p_add">+	if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_POWER)</span>
 		mcp251x_power_enable(priv-&gt;power, 1);
<span class="p_add">+</span>
<span class="p_add">+	if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_UP) {</span>
<span class="p_add">+		mcp251x_power_enable(priv-&gt;transceiver, 1);</span>
 		queue_work(priv-&gt;wq, &amp;priv-&gt;restart_work);
 	} else {
<span class="p_del">-		if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_UP) {</span>
<span class="p_del">-			mcp251x_power_enable(priv-&gt;transceiver, 1);</span>
<span class="p_del">-			queue_work(priv-&gt;wq, &amp;priv-&gt;restart_work);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			priv-&gt;after_suspend = 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		priv-&gt;after_suspend = 0;</span>
 	}
<span class="p_add">+</span>
 	priv-&gt;force_quit = 0;
 	enable_irq(spi-&gt;irq);
 	return 0;
<span class="p_header">diff --git a/drivers/net/can/vcan.c b/drivers/net/can/vcan.c</span>
<span class="p_header">index 0ce868de855d..674f367087c5 100644</span>
<span class="p_header">--- a/drivers/net/can/vcan.c</span>
<span class="p_header">+++ b/drivers/net/can/vcan.c</span>
<span class="p_chunk">@@ -78,9 +78,6 @@</span> <span class="p_context"> static void vcan_rx(struct sk_buff *skb, struct net_device *dev)</span>
 	skb-&gt;dev       = dev;
 	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
 
<span class="p_del">-	if (!(skb-&gt;tstamp.tv64))</span>
<span class="p_del">-		__net_timestamp(skb);</span>
<span class="p_del">-</span>
 	netif_rx_ni(skb);
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c b/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c</span>
<span class="p_header">index 8e604a3931ca..ef20be084b24 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c</span>
<span class="p_chunk">@@ -540,13 +540,11 @@</span> <span class="p_context"> static void iwl_set_hw_address_family_8000(struct device *dev,</span>
 		hw_addr = (const u8 *)(mac_override +
 				 MAC_ADDRESS_OVERRIDE_FAMILY_8000);
 
<span class="p_del">-		/* The byte order is little endian 16 bit, meaning 214365 */</span>
<span class="p_del">-		data-&gt;hw_addr[0] = hw_addr[1];</span>
<span class="p_del">-		data-&gt;hw_addr[1] = hw_addr[0];</span>
<span class="p_del">-		data-&gt;hw_addr[2] = hw_addr[3];</span>
<span class="p_del">-		data-&gt;hw_addr[3] = hw_addr[2];</span>
<span class="p_del">-		data-&gt;hw_addr[4] = hw_addr[5];</span>
<span class="p_del">-		data-&gt;hw_addr[5] = hw_addr[4];</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Store the MAC address from MAO section.</span>
<span class="p_add">+		 * No byte swapping is required in MAO section</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		memcpy(data-&gt;hw_addr, hw_addr, ETH_ALEN);</span>
 
 		/*
 		 * Force the use of the OTP MAC address in case of reserved MAC
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/tx.c b/drivers/net/wireless/iwlwifi/mvm/tx.c</span>
<span class="p_header">index ef32e177f662..281451c274ca 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/tx.c</span>
<span class="p_chunk">@@ -225,7 +225,7 @@</span> <span class="p_context"> void iwl_mvm_set_tx_cmd_rate(struct iwl_mvm *mvm, struct iwl_tx_cmd *tx_cmd,</span>
 
 	if (info-&gt;band == IEEE80211_BAND_2GHZ &amp;&amp;
 	    !iwl_mvm_bt_coex_is_shared_ant_avail(mvm))
<span class="p_del">-		rate_flags = BIT(mvm-&gt;cfg-&gt;non_shared_ant) &lt;&lt; RATE_MCS_ANT_POS;</span>
<span class="p_add">+		rate_flags = mvm-&gt;cfg-&gt;non_shared_ant &lt;&lt; RATE_MCS_ANT_POS;</span>
 	else
 		rate_flags =
 			BIT(mvm-&gt;mgmt_last_antenna_idx) &lt;&lt; RATE_MCS_ANT_POS;
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/trans.c b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">index dc179094e6a0..37e6a6f91487 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_chunk">@@ -2515,6 +2515,12 @@</span> <span class="p_context"> struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,</span>
 		trans-&gt;hw_rev = (trans-&gt;hw_rev &amp; 0xfff0) |
 				(CSR_HW_REV_STEP(trans-&gt;hw_rev &lt;&lt; 2) &lt;&lt; 2);
 
<span class="p_add">+		ret = iwl_pcie_prepare_card_hw(trans);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			IWL_WARN(trans, &quot;Exit HW not ready\n&quot;);</span>
<span class="p_add">+			goto out_pci_disable_msi;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/*
 		 * in-order to recognize C step driver should read chip version
 		 * id located at the AUX bus MISC address space.
<span class="p_header">diff --git a/drivers/pinctrl/freescale/pinctrl-imx1-core.c b/drivers/pinctrl/freescale/pinctrl-imx1-core.c</span>
<span class="p_header">index 5ac59fbb2440..d3a3be7476e1 100644</span>
<span class="p_header">--- a/drivers/pinctrl/freescale/pinctrl-imx1-core.c</span>
<span class="p_header">+++ b/drivers/pinctrl/freescale/pinctrl-imx1-core.c</span>
<span class="p_chunk">@@ -403,14 +403,13 @@</span> <span class="p_context"> static int imx1_pinconf_set(struct pinctrl_dev *pctldev,</span>
 			     unsigned num_configs)
 {
 	struct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
<span class="p_del">-	const struct imx1_pinctrl_soc_info *info = ipctl-&gt;info;</span>
 	int i;
 
 	for (i = 0; i != num_configs; ++i) {
 		imx1_write_bit(ipctl, pin_id, configs[i] &amp; 0x01, MX1_PUEN);
 
 		dev_dbg(ipctl-&gt;dev, &quot;pinconf set pullup pin %s\n&quot;,
<span class="p_del">-			info-&gt;pins[pin_id].name);</span>
<span class="p_add">+			pin_desc_get(pctldev, pin_id)-&gt;name);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/regulator/s2mps11.c b/drivers/regulator/s2mps11.c</span>
<span class="p_header">index ff828117798f..8de135174e82 100644</span>
<span class="p_header">--- a/drivers/regulator/s2mps11.c</span>
<span class="p_header">+++ b/drivers/regulator/s2mps11.c</span>
<span class="p_chunk">@@ -34,6 +34,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/mfd/samsung/s2mps14.h&gt;
 #include &lt;linux/mfd/samsung/s2mpu02.h&gt;
 
<span class="p_add">+/* The highest number of possible regulators for supported devices. */</span>
<span class="p_add">+#define S2MPS_REGULATOR_MAX		S2MPS13_REGULATOR_MAX</span>
 struct s2mps11_info {
 	unsigned int rdev_num;
 	int ramp_delay2;
<span class="p_chunk">@@ -49,7 +51,7 @@</span> <span class="p_context"> struct s2mps11_info {</span>
 	 * One bit for each S2MPS13/S2MPS14/S2MPU02 regulator whether
 	 * the suspend mode was enabled.
 	 */
<span class="p_del">-	unsigned long long s2mps14_suspend_state:50;</span>
<span class="p_add">+	DECLARE_BITMAP(suspend_state, S2MPS_REGULATOR_MAX);</span>
 
 	/* Array of size rdev_num with GPIO-s for external sleep control */
 	int *ext_control_gpio;
<span class="p_chunk">@@ -500,7 +502,7 @@</span> <span class="p_context"> static int s2mps14_regulator_enable(struct regulator_dev *rdev)</span>
 	switch (s2mps11-&gt;dev_type) {
 	case S2MPS13X:
 	case S2MPS14X:
<span class="p_del">-		if (s2mps11-&gt;s2mps14_suspend_state &amp; (1 &lt;&lt; rdev_get_id(rdev)))</span>
<span class="p_add">+		if (test_bit(rdev_get_id(rdev), s2mps11-&gt;suspend_state))</span>
 			val = S2MPS14_ENABLE_SUSPEND;
 		else if (gpio_is_valid(s2mps11-&gt;ext_control_gpio[rdev_get_id(rdev)]))
 			val = S2MPS14_ENABLE_EXT_CONTROL;
<span class="p_chunk">@@ -508,7 +510,7 @@</span> <span class="p_context"> static int s2mps14_regulator_enable(struct regulator_dev *rdev)</span>
 			val = rdev-&gt;desc-&gt;enable_mask;
 		break;
 	case S2MPU02:
<span class="p_del">-		if (s2mps11-&gt;s2mps14_suspend_state &amp; (1 &lt;&lt; rdev_get_id(rdev)))</span>
<span class="p_add">+		if (test_bit(rdev_get_id(rdev), s2mps11-&gt;suspend_state))</span>
 			val = S2MPU02_ENABLE_SUSPEND;
 		else
 			val = rdev-&gt;desc-&gt;enable_mask;
<span class="p_chunk">@@ -562,7 +564,7 @@</span> <span class="p_context"> static int s2mps14_regulator_set_suspend_disable(struct regulator_dev *rdev)</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	s2mps11-&gt;s2mps14_suspend_state |= (1 &lt;&lt; rdev_get_id(rdev));</span>
<span class="p_add">+	set_bit(rdev_get_id(rdev), s2mps11-&gt;suspend_state);</span>
 	/*
 	 * Don&#39;t enable suspend mode if regulator is already disabled because
 	 * this would effectively for a short time turn on the regulator after
<span class="p_chunk">@@ -960,18 +962,22 @@</span> <span class="p_context"> static int s2mps11_pmic_probe(struct platform_device *pdev)</span>
 	case S2MPS11X:
 		s2mps11-&gt;rdev_num = ARRAY_SIZE(s2mps11_regulators);
 		regulators = s2mps11_regulators;
<span class="p_add">+		BUILD_BUG_ON(S2MPS_REGULATOR_MAX &lt; s2mps11-&gt;rdev_num);</span>
 		break;
 	case S2MPS13X:
 		s2mps11-&gt;rdev_num = ARRAY_SIZE(s2mps13_regulators);
 		regulators = s2mps13_regulators;
<span class="p_add">+		BUILD_BUG_ON(S2MPS_REGULATOR_MAX &lt; s2mps11-&gt;rdev_num);</span>
 		break;
 	case S2MPS14X:
 		s2mps11-&gt;rdev_num = ARRAY_SIZE(s2mps14_regulators);
 		regulators = s2mps14_regulators;
<span class="p_add">+		BUILD_BUG_ON(S2MPS_REGULATOR_MAX &lt; s2mps11-&gt;rdev_num);</span>
 		break;
 	case S2MPU02:
 		s2mps11-&gt;rdev_num = ARRAY_SIZE(s2mpu02_regulators);
 		regulators = s2mpu02_regulators;
<span class="p_add">+		BUILD_BUG_ON(S2MPS_REGULATOR_MAX &lt; s2mps11-&gt;rdev_num);</span>
 		break;
 	default:
 		dev_err(&amp;pdev-&gt;dev, &quot;Invalid device type: %u\n&quot;,
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c</span>
<span class="p_header">index 0e6ee3ca30e6..e9ae6b924c70 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_dbg.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_dbg.c</span>
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"></span>
  * |                              |                    | 0xd101-0xd1fe	|
  * |                              |                    | 0xd214-0xd2fe	|
  * | Target Mode		  |	  0xe079       |		|
<span class="p_del">- * | Target Mode Management	  |	  0xf072       | 0xf002		|</span>
<span class="p_add">+ * | Target Mode Management	  |	  0xf080       | 0xf002		|</span>
  * |                              |                    | 0xf046-0xf049  |
  * | Target Mode Task Management  |	  0x1000b      |		|
  * ----------------------------------------------------------------------
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c</span>
<span class="p_header">index 285cb204f300..998498e2341b 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_init.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_init.c</span>
<span class="p_chunk">@@ -2924,6 +2924,7 @@</span> <span class="p_context"> qla2x00_rport_del(void *data)</span>
 	struct fc_rport *rport;
 	scsi_qla_host_t *vha = fcport-&gt;vha;
 	unsigned long flags;
<span class="p_add">+	unsigned long vha_flags;</span>
 
 	spin_lock_irqsave(fcport-&gt;vha-&gt;host-&gt;host_lock, flags);
 	rport = fcport-&gt;drport ? fcport-&gt;drport: fcport-&gt;rport;
<span class="p_chunk">@@ -2935,7 +2936,9 @@</span> <span class="p_context"> qla2x00_rport_del(void *data)</span>
 		 * Release the target mode FC NEXUS in qla_target.c code
 		 * if target mod is enabled.
 		 */
<span class="p_add">+		spin_lock_irqsave(&amp;vha-&gt;hw-&gt;hardware_lock, vha_flags);</span>
 		qlt_fc_port_deleted(vha, fcport);
<span class="p_add">+		spin_unlock_irqrestore(&amp;vha-&gt;hw-&gt;hardware_lock, vha_flags);</span>
 	}
 }
 
<span class="p_chunk">@@ -3303,6 +3306,7 @@</span> <span class="p_context"> qla2x00_reg_remote_port(scsi_qla_host_t *vha, fc_port_t *fcport)</span>
 	 * Create target mode FC NEXUS in qla_target.c if target mode is
 	 * enabled..
 	 */
<span class="p_add">+</span>
 	qlt_fc_port_added(vha, fcport);
 
 	spin_lock_irqsave(fcport-&gt;vha-&gt;host-&gt;host_lock, flags);
<span class="p_chunk">@@ -3460,20 +3464,43 @@</span> <span class="p_context"> qla2x00_configure_fabric(scsi_qla_host_t *vha)</span>
 			if ((fcport-&gt;flags &amp; FCF_FABRIC_DEVICE) == 0)
 				continue;
 
<span class="p_del">-			if (fcport-&gt;scan_state == QLA_FCPORT_SCAN &amp;&amp;</span>
<span class="p_del">-			    atomic_read(&amp;fcport-&gt;state) == FCS_ONLINE) {</span>
<span class="p_del">-				qla2x00_mark_device_lost(vha, fcport,</span>
<span class="p_del">-				    ql2xplogiabsentdevice, 0);</span>
<span class="p_del">-				if (fcport-&gt;loop_id != FC_NO_LOOP_ID &amp;&amp;</span>
<span class="p_del">-				    (fcport-&gt;flags &amp; FCF_FCP2_DEVICE) == 0 &amp;&amp;</span>
<span class="p_del">-				    fcport-&gt;port_type != FCT_INITIATOR &amp;&amp;</span>
<span class="p_del">-				    fcport-&gt;port_type != FCT_BROADCAST) {</span>
<span class="p_del">-					ha-&gt;isp_ops-&gt;fabric_logout(vha,</span>
<span class="p_del">-					    fcport-&gt;loop_id,</span>
<span class="p_del">-					    fcport-&gt;d_id.b.domain,</span>
<span class="p_del">-					    fcport-&gt;d_id.b.area,</span>
<span class="p_del">-					    fcport-&gt;d_id.b.al_pa);</span>
<span class="p_del">-					qla2x00_clear_loop_id(fcport);</span>
<span class="p_add">+			if (fcport-&gt;scan_state == QLA_FCPORT_SCAN) {</span>
<span class="p_add">+				if (qla_ini_mode_enabled(base_vha) &amp;&amp;</span>
<span class="p_add">+				    atomic_read(&amp;fcport-&gt;state) == FCS_ONLINE) {</span>
<span class="p_add">+					qla2x00_mark_device_lost(vha, fcport,</span>
<span class="p_add">+					    ql2xplogiabsentdevice, 0);</span>
<span class="p_add">+					if (fcport-&gt;loop_id != FC_NO_LOOP_ID &amp;&amp;</span>
<span class="p_add">+					    (fcport-&gt;flags &amp; FCF_FCP2_DEVICE) == 0 &amp;&amp;</span>
<span class="p_add">+					    fcport-&gt;port_type != FCT_INITIATOR &amp;&amp;</span>
<span class="p_add">+					    fcport-&gt;port_type != FCT_BROADCAST) {</span>
<span class="p_add">+						ha-&gt;isp_ops-&gt;fabric_logout(vha,</span>
<span class="p_add">+						    fcport-&gt;loop_id,</span>
<span class="p_add">+						    fcport-&gt;d_id.b.domain,</span>
<span class="p_add">+						    fcport-&gt;d_id.b.area,</span>
<span class="p_add">+						    fcport-&gt;d_id.b.al_pa);</span>
<span class="p_add">+						qla2x00_clear_loop_id(fcport);</span>
<span class="p_add">+					}</span>
<span class="p_add">+				} else if (!qla_ini_mode_enabled(base_vha)) {</span>
<span class="p_add">+					/*</span>
<span class="p_add">+					 * In target mode, explicitly kill</span>
<span class="p_add">+					 * sessions and log out of devices</span>
<span class="p_add">+					 * that are gone, so that we don&#39;t</span>
<span class="p_add">+					 * end up with an initiator using the</span>
<span class="p_add">+					 * wrong ACL (if the fabric recycles</span>
<span class="p_add">+					 * an FC address and we have a stale</span>
<span class="p_add">+					 * session around) and so that we don&#39;t</span>
<span class="p_add">+					 * report initiators that are no longer</span>
<span class="p_add">+					 * on the fabric.</span>
<span class="p_add">+					 */</span>
<span class="p_add">+					ql_dbg(ql_dbg_tgt_mgt, vha, 0xf077,</span>
<span class="p_add">+					    &quot;port gone, logging out/killing session: &quot;</span>
<span class="p_add">+					    &quot;%8phC state 0x%x flags 0x%x fc4_type 0x%x &quot;</span>
<span class="p_add">+					    &quot;scan_state %d\n&quot;,</span>
<span class="p_add">+					    fcport-&gt;port_name,</span>
<span class="p_add">+					    atomic_read(&amp;fcport-&gt;state),</span>
<span class="p_add">+					    fcport-&gt;flags, fcport-&gt;fc4_type,</span>
<span class="p_add">+					    fcport-&gt;scan_state);</span>
<span class="p_add">+					qlt_fc_port_deleted(vha, fcport);</span>
 				}
 			}
 		}
<span class="p_chunk">@@ -3494,6 +3521,28 @@</span> <span class="p_context"> qla2x00_configure_fabric(scsi_qla_host_t *vha)</span>
 			    (fcport-&gt;flags &amp; FCF_LOGIN_NEEDED) == 0)
 				continue;
 
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If we&#39;re not an initiator, skip looking for devices</span>
<span class="p_add">+			 * and logging in.  There&#39;s no reason for us to do it,</span>
<span class="p_add">+			 * and it seems to actively cause problems in target</span>
<span class="p_add">+			 * mode if we race with the initiator logging into us</span>
<span class="p_add">+			 * (we might get the &quot;port ID used&quot; status back from</span>
<span class="p_add">+			 * our login command and log out the initiator, which</span>
<span class="p_add">+			 * seems to cause havoc).</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!qla_ini_mode_enabled(base_vha)) {</span>
<span class="p_add">+				if (fcport-&gt;scan_state == QLA_FCPORT_FOUND) {</span>
<span class="p_add">+					ql_dbg(ql_dbg_tgt_mgt, vha, 0xf078,</span>
<span class="p_add">+					    &quot;port %8phC state 0x%x flags 0x%x fc4_type 0x%x &quot;</span>
<span class="p_add">+					    &quot;scan_state %d (initiator mode disabled; skipping &quot;</span>
<span class="p_add">+					    &quot;login)\n&quot;, fcport-&gt;port_name,</span>
<span class="p_add">+					    atomic_read(&amp;fcport-&gt;state),</span>
<span class="p_add">+					    fcport-&gt;flags, fcport-&gt;fc4_type,</span>
<span class="p_add">+					    fcport-&gt;scan_state);</span>
<span class="p_add">+				}</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (fcport-&gt;loop_id == FC_NO_LOOP_ID) {
 				fcport-&gt;loop_id = next_loopid;
 				rval = qla2x00_find_new_loop_id(
<span class="p_chunk">@@ -3520,16 +3569,38 @@</span> <span class="p_context"> qla2x00_configure_fabric(scsi_qla_host_t *vha)</span>
 			    test_bit(LOOP_RESYNC_NEEDED, &amp;vha-&gt;dpc_flags))
 				break;
 
<span class="p_del">-			/* Find a new loop ID to use. */</span>
<span class="p_del">-			fcport-&gt;loop_id = next_loopid;</span>
<span class="p_del">-			rval = qla2x00_find_new_loop_id(base_vha, fcport);</span>
<span class="p_del">-			if (rval != QLA_SUCCESS) {</span>
<span class="p_del">-				/* Ran out of IDs to use */</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If we&#39;re not an initiator, skip looking for devices</span>
<span class="p_add">+			 * and logging in.  There&#39;s no reason for us to do it,</span>
<span class="p_add">+			 * and it seems to actively cause problems in target</span>
<span class="p_add">+			 * mode if we race with the initiator logging into us</span>
<span class="p_add">+			 * (we might get the &quot;port ID used&quot; status back from</span>
<span class="p_add">+			 * our login command and log out the initiator, which</span>
<span class="p_add">+			 * seems to cause havoc).</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (qla_ini_mode_enabled(base_vha)) {</span>
<span class="p_add">+				/* Find a new loop ID to use. */</span>
<span class="p_add">+				fcport-&gt;loop_id = next_loopid;</span>
<span class="p_add">+				rval = qla2x00_find_new_loop_id(base_vha,</span>
<span class="p_add">+				    fcport);</span>
<span class="p_add">+				if (rval != QLA_SUCCESS) {</span>
<span class="p_add">+					/* Ran out of IDs to use */</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
<span class="p_del">-			/* Login and update database */</span>
<span class="p_del">-			qla2x00_fabric_dev_login(vha, fcport, &amp;next_loopid);</span>
<span class="p_add">+				/* Login and update database */</span>
<span class="p_add">+				qla2x00_fabric_dev_login(vha, fcport,</span>
<span class="p_add">+				    &amp;next_loopid);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf079,</span>
<span class="p_add">+					&quot;new port %8phC state 0x%x flags 0x%x fc4_type &quot;</span>
<span class="p_add">+					&quot;0x%x scan_state %d (initiator mode disabled; &quot;</span>
<span class="p_add">+					&quot;skipping login)\n&quot;,</span>
<span class="p_add">+					fcport-&gt;port_name,</span>
<span class="p_add">+					atomic_read(&amp;fcport-&gt;state),</span>
<span class="p_add">+					fcport-&gt;flags, fcport-&gt;fc4_type,</span>
<span class="p_add">+					fcport-&gt;scan_state);</span>
<span class="p_add">+			}</span>
 
 			list_move_tail(&amp;fcport-&gt;list, &amp;vha-&gt;vp_fcports);
 		}
<span class="p_chunk">@@ -3725,11 +3796,12 @@</span> <span class="p_context"> qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha,</span>
 			fcport-&gt;fp_speed = new_fcport-&gt;fp_speed;
 
 			/*
<span class="p_del">-			 * If address the same and state FCS_ONLINE, nothing</span>
<span class="p_del">-			 * changed.</span>
<span class="p_add">+			 * If address the same and state FCS_ONLINE</span>
<span class="p_add">+			 * (or in target mode), nothing changed.</span>
 			 */
 			if (fcport-&gt;d_id.b24 == new_fcport-&gt;d_id.b24 &amp;&amp;
<span class="p_del">-			    atomic_read(&amp;fcport-&gt;state) == FCS_ONLINE) {</span>
<span class="p_add">+			    (atomic_read(&amp;fcport-&gt;state) == FCS_ONLINE ||</span>
<span class="p_add">+			     !qla_ini_mode_enabled(base_vha))) {</span>
 				break;
 			}
 
<span class="p_chunk">@@ -3749,6 +3821,22 @@</span> <span class="p_context"> qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha,</span>
 			 * Log it out if still logged in and mark it for
 			 * relogin later.
 			 */
<span class="p_add">+			if (!qla_ini_mode_enabled(base_vha)) {</span>
<span class="p_add">+				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf080,</span>
<span class="p_add">+					 &quot;port changed FC ID, %8phC&quot;</span>
<span class="p_add">+					 &quot; old %x:%x:%x (loop_id 0x%04x)-&gt; new %x:%x:%x\n&quot;,</span>
<span class="p_add">+					 fcport-&gt;port_name,</span>
<span class="p_add">+					 fcport-&gt;d_id.b.domain,</span>
<span class="p_add">+					 fcport-&gt;d_id.b.area,</span>
<span class="p_add">+					 fcport-&gt;d_id.b.al_pa,</span>
<span class="p_add">+					 fcport-&gt;loop_id,</span>
<span class="p_add">+					 new_fcport-&gt;d_id.b.domain,</span>
<span class="p_add">+					 new_fcport-&gt;d_id.b.area,</span>
<span class="p_add">+					 new_fcport-&gt;d_id.b.al_pa);</span>
<span class="p_add">+				fcport-&gt;d_id.b24 = new_fcport-&gt;d_id.b24;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			fcport-&gt;d_id.b24 = new_fcport-&gt;d_id.b24;
 			fcport-&gt;flags |= FCF_LOGIN_NEEDED;
 			if (fcport-&gt;loop_id != FC_NO_LOOP_ID &amp;&amp;
<span class="p_chunk">@@ -3768,6 +3856,7 @@</span> <span class="p_context"> qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha,</span>
 		if (found)
 			continue;
 		/* If device was not in our fcports list, then add it. */
<span class="p_add">+		new_fcport-&gt;scan_state = QLA_FCPORT_FOUND;</span>
 		list_add_tail(&amp;new_fcport-&gt;list, new_fcports);
 
 		/* Allocate a new replacement fcport. */
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">index fe8a8d157e22..496a733d0ca3 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_chunk">@@ -113,6 +113,7 @@</span> <span class="p_context"> static void qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha,</span>
 static void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
 	struct atio_from_isp *atio, uint16_t status, int qfull);
 static void qlt_disable_vha(struct scsi_qla_host *vha);
<span class="p_add">+static void qlt_clear_tgt_db(struct qla_tgt *tgt);</span>
 /*
  * Global Variables
  */
<span class="p_chunk">@@ -431,10 +432,10 @@</span> <span class="p_context"> static int qlt_reset(struct scsi_qla_host *vha, void *iocb, int mcmd)</span>
 
 	loop_id = le16_to_cpu(n-&gt;u.isp24.nport_handle);
 	if (loop_id == 0xFFFF) {
<span class="p_del">-#if 0 /* FIXME: Re-enable Global event handling.. */</span>
 		/* Global event */
<span class="p_del">-		atomic_inc(&amp;ha-&gt;tgt.qla_tgt-&gt;tgt_global_resets_count);</span>
<span class="p_del">-		qlt_clear_tgt_db(ha-&gt;tgt.qla_tgt);</span>
<span class="p_add">+		atomic_inc(&amp;vha-&gt;vha_tgt.qla_tgt-&gt;tgt_global_resets_count);</span>
<span class="p_add">+		qlt_clear_tgt_db(vha-&gt;vha_tgt.qla_tgt);</span>
<span class="p_add">+#if 0 /* FIXME: do we need to choose a session here? */</span>
 		if (!list_empty(&amp;ha-&gt;tgt.qla_tgt-&gt;sess_list)) {
 			sess = list_entry(ha-&gt;tgt.qla_tgt-&gt;sess_list.next,
 			    typeof(*sess), sess_list_entry);
<span class="p_chunk">@@ -782,25 +783,20 @@</span> <span class="p_context"> void qlt_fc_port_added(struct scsi_qla_host *vha, fc_port_t *fcport)</span>
 
 void qlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport)
 {
<span class="p_del">-	struct qla_hw_data *ha = vha-&gt;hw;</span>
 	struct qla_tgt *tgt = vha-&gt;vha_tgt.qla_tgt;
 	struct qla_tgt_sess *sess;
<span class="p_del">-	unsigned long flags;</span>
 
 	if (!vha-&gt;hw-&gt;tgt.tgt_ops)
 		return;
 
<span class="p_del">-	if (!tgt || (fcport-&gt;port_type != FCT_INITIATOR))</span>
<span class="p_add">+	if (!tgt)</span>
 		return;
 
<span class="p_del">-	spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);</span>
 	if (tgt-&gt;tgt_stop) {
<span class="p_del">-		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
 		return;
 	}
 	sess = qlt_find_sess_by_port_name(tgt, fcport-&gt;port_name);
 	if (!sess) {
<span class="p_del">-		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -808,7 +804,6 @@</span> <span class="p_context"> void qlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport)</span>
 
 	sess-&gt;local = 1;
 	qlt_schedule_sess_for_deletion(sess, false);
<span class="p_del">-	spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
 }
 
 static inline int test_tgt_sess_count(struct qla_tgt *tgt)
<span class="p_chunk">@@ -2347,9 +2342,10 @@</span> <span class="p_context"> int qlt_xmit_response(struct qla_tgt_cmd *cmd, int xmit_type,</span>
 		res = qlt_build_ctio_crc2_pkt(&amp;prm, vha);
 	else
 		res = qlt_24xx_build_ctio_pkt(&amp;prm, vha);
<span class="p_del">-	if (unlikely(res != 0))</span>
<span class="p_add">+	if (unlikely(res != 0)) {</span>
<span class="p_add">+		vha-&gt;req-&gt;cnt += full_req_cnt;</span>
 		goto out_unmap_unlock;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
 
 	pkt = (struct ctio7_to_24xx *)prm.pkt;
 
<span class="p_chunk">@@ -2487,8 +2483,11 @@</span> <span class="p_context"> int qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd)</span>
 	else
 		res = qlt_24xx_build_ctio_pkt(&amp;prm, vha);
 
<span class="p_del">-	if (unlikely(res != 0))</span>
<span class="p_add">+	if (unlikely(res != 0)) {</span>
<span class="p_add">+		vha-&gt;req-&gt;cnt += prm.req_cnt;</span>
 		goto out_unlock_free_unmap;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pkt = (struct ctio7_to_24xx *)prm.pkt;
 	pkt-&gt;u.status0.flags |= __constant_cpu_to_le16(CTIO7_FLAGS_DATA_OUT |
 	    CTIO7_FLAGS_STATUS_MODE_0);
<span class="p_chunk">@@ -2717,7 +2716,7 @@</span> <span class="p_context"> static int __qlt_send_term_exchange(struct scsi_qla_host *vha,</span>
 static void qlt_send_term_exchange(struct scsi_qla_host *vha,
 	struct qla_tgt_cmd *cmd, struct atio_from_isp *atio, int ha_locked)
 {
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	unsigned long flags = 0;</span>
 	int rc;
 
 	if (qlt_issue_marker(vha, ha_locked) &lt; 0)
<span class="p_chunk">@@ -2733,17 +2732,18 @@</span> <span class="p_context"> static void qlt_send_term_exchange(struct scsi_qla_host *vha,</span>
 	rc = __qlt_send_term_exchange(vha, cmd, atio);
 	if (rc == -ENOMEM)
 		qlt_alloc_qfull_cmd(vha, atio, 0, 0);
<span class="p_del">-	spin_unlock_irqrestore(&amp;vha-&gt;hw-&gt;hardware_lock, flags);</span>
 
 done:
 	if (cmd &amp;&amp; ((cmd-&gt;state != QLA_TGT_STATE_ABORTED) ||
 	    !cmd-&gt;cmd_sent_to_fw)) {
<span class="p_del">-		if (!ha_locked &amp;&amp; !in_interrupt())</span>
<span class="p_del">-			msleep(250); /* just in case */</span>
<span class="p_del">-</span>
<span class="p_del">-		qlt_unmap_sg(vha, cmd);</span>
<span class="p_add">+		if (cmd-&gt;sg_mapped)</span>
<span class="p_add">+			qlt_unmap_sg(vha, cmd);</span>
 		vha-&gt;hw-&gt;tgt.tgt_ops-&gt;free_cmd(cmd);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!ha_locked)</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;vha-&gt;hw-&gt;hardware_lock, flags);</span>
<span class="p_add">+</span>
 	return;
 }
 
<span class="p_chunk">@@ -3347,6 +3347,11 @@</span> <span class="p_context"> static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,</span>
 	cmd-&gt;loop_id = sess-&gt;loop_id;
 	cmd-&gt;conf_compl_supported = sess-&gt;conf_compl_supported;
 
<span class="p_add">+	cmd-&gt;cmd_flags = 0;</span>
<span class="p_add">+	cmd-&gt;jiffies_at_alloc = get_jiffies_64();</span>
<span class="p_add">+</span>
<span class="p_add">+	cmd-&gt;reset_count = vha-&gt;hw-&gt;chip_reset;</span>
<span class="p_add">+</span>
 	return cmd;
 }
 
<span class="p_chunk">@@ -3453,11 +3458,6 @@</span> <span class="p_context"> static int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha,</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	cmd-&gt;cmd_flags = 0;</span>
<span class="p_del">-	cmd-&gt;jiffies_at_alloc = get_jiffies_64();</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;reset_count = vha-&gt;hw-&gt;chip_reset;</span>
<span class="p_del">-</span>
 	cmd-&gt;cmd_in_wq = 1;
 	cmd-&gt;cmd_flags |= BIT_0;
 	INIT_WORK(&amp;cmd-&gt;work, qlt_do_work);
<span class="p_header">diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c</span>
<span class="p_header">index c95a4e943fc6..59c31bf88d92 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_error.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_error.c</span>
<span class="p_chunk">@@ -944,7 +944,7 @@</span> <span class="p_context"> void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,</span>
 			    scmd-&gt;sdb.length);
 		scmd-&gt;sdb.table.sgl = &amp;ses-&gt;sense_sgl;
 		scmd-&gt;sc_data_direction = DMA_FROM_DEVICE;
<span class="p_del">-		scmd-&gt;sdb.table.nents = 1;</span>
<span class="p_add">+		scmd-&gt;sdb.table.nents = scmd-&gt;sdb.table.orig_nents = 1;</span>
 		scmd-&gt;cmnd[0] = REQUEST_SENSE;
 		scmd-&gt;cmnd[4] = scmd-&gt;sdb.length;
 		scmd-&gt;cmd_len = COMMAND_SIZE(scmd-&gt;cmnd[0]);
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index b1a263137a23..448ebdaa3d69 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -583,7 +583,7 @@</span> <span class="p_context"> static struct scatterlist *scsi_sg_alloc(unsigned int nents, gfp_t gfp_mask)</span>
 
 static void scsi_free_sgtable(struct scsi_data_buffer *sdb, bool mq)
 {
<span class="p_del">-	if (mq &amp;&amp; sdb-&gt;table.nents &lt;= SCSI_MAX_SG_SEGMENTS)</span>
<span class="p_add">+	if (mq &amp;&amp; sdb-&gt;table.orig_nents &lt;= SCSI_MAX_SG_SEGMENTS)</span>
 		return;
 	__sg_free_table(&amp;sdb-&gt;table, SCSI_MAX_SG_SEGMENTS, mq, scsi_sg_free);
 }
<span class="p_chunk">@@ -597,8 +597,8 @@</span> <span class="p_context"> static int scsi_alloc_sgtable(struct scsi_data_buffer *sdb, int nents, bool mq)</span>
 
 	if (mq) {
 		if (nents &lt;= SCSI_MAX_SG_SEGMENTS) {
<span class="p_del">-			sdb-&gt;table.nents = nents;</span>
<span class="p_del">-			sg_init_table(sdb-&gt;table.sgl, sdb-&gt;table.nents);</span>
<span class="p_add">+			sdb-&gt;table.nents = sdb-&gt;table.orig_nents = nents;</span>
<span class="p_add">+			sg_init_table(sdb-&gt;table.sgl, nents);</span>
 			return 0;
 		}
 		first_chunk = sdb-&gt;table.sgl;
<span class="p_header">diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">index 1ac38e73df7e..9ad41168d26d 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_chunk">@@ -859,7 +859,7 @@</span> <span class="p_context"> sdev_store_queue_depth(struct device *dev, struct device_attribute *attr,</span>
 
 	depth = simple_strtoul(buf, NULL, 0);
 
<span class="p_del">-	if (depth &lt; 1 || depth &gt; sht-&gt;can_queue)</span>
<span class="p_add">+	if (depth &lt; 1 || depth &gt; sdev-&gt;host-&gt;can_queue)</span>
 		return -EINVAL;
 
 	retval = sht-&gt;change_queue_depth(sdev, depth);
<span class="p_header">diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c</span>
<span class="p_header">index 9a1c34205254..525ab4c1f306 100644</span>
<span class="p_header">--- a/drivers/scsi/st.c</span>
<span class="p_header">+++ b/drivers/scsi/st.c</span>
<span class="p_chunk">@@ -1274,9 +1274,9 @@</span> <span class="p_context"> static int st_open(struct inode *inode, struct file *filp)</span>
 	spin_lock(&amp;st_use_lock);
 	STp-&gt;in_use = 0;
 	spin_unlock(&amp;st_use_lock);
<span class="p_del">-	scsi_tape_put(STp);</span>
 	if (resumed)
 		scsi_autopm_put_device(STp-&gt;device);
<span class="p_add">+	scsi_tape_put(STp);</span>
 	return retval;
 
 }
<span class="p_header">diff --git a/drivers/spi/spi-img-spfi.c b/drivers/spi/spi-img-spfi.c</span>
<span class="p_header">index 788e2b176a4f..acce90ac7371 100644</span>
<span class="p_header">--- a/drivers/spi/spi-img-spfi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-img-spfi.c</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"></span>
 #define SPFI_CONTROL_SOFT_RESET			BIT(11)
 #define SPFI_CONTROL_SEND_DMA			BIT(10)
 #define SPFI_CONTROL_GET_DMA			BIT(9)
<span class="p_add">+#define SPFI_CONTROL_SE			BIT(8)</span>
 #define SPFI_CONTROL_TMODE_SHIFT		5
 #define SPFI_CONTROL_TMODE_MASK			0x7
 #define SPFI_CONTROL_TMODE_SINGLE		0
<span class="p_chunk">@@ -491,6 +492,7 @@</span> <span class="p_context"> static void img_spfi_config(struct spi_master *master, struct spi_device *spi,</span>
 	else if (xfer-&gt;tx_nbits == SPI_NBITS_QUAD &amp;&amp;
 		 xfer-&gt;rx_nbits == SPI_NBITS_QUAD)
 		val |= SPFI_CONTROL_TMODE_QUAD &lt;&lt; SPFI_CONTROL_TMODE_SHIFT;
<span class="p_add">+	val |= SPFI_CONTROL_SE;</span>
 	spfi_writel(spfi, val, SPFI_CONTROL);
 }
 
<span class="p_header">diff --git a/drivers/spi/spi-imx.c b/drivers/spi/spi-imx.c</span>
<span class="p_header">index f08e812b2984..412b9c86b997 100644</span>
<span class="p_header">--- a/drivers/spi/spi-imx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-imx.c</span>
<span class="p_chunk">@@ -201,8 +201,9 @@</span> <span class="p_context"> static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,</span>
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
 
<span class="p_del">-	if (spi_imx-&gt;dma_is_inited &amp;&amp; (transfer-&gt;len &gt; spi_imx-&gt;rx_wml)</span>
<span class="p_del">-	    &amp;&amp; (transfer-&gt;len &gt; spi_imx-&gt;tx_wml))</span>
<span class="p_add">+	if (spi_imx-&gt;dma_is_inited</span>
<span class="p_add">+	    &amp;&amp; transfer-&gt;len &gt; spi_imx-&gt;rx_wml * sizeof(u32)</span>
<span class="p_add">+	    &amp;&amp; transfer-&gt;len &gt; spi_imx-&gt;tx_wml * sizeof(u32))</span>
 		return true;
 	return false;
 }
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 74e6114ff18f..305a5cbc099a 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -4001,7 +4001,13 @@</span> <span class="p_context"> get_immediate:</span>
 	}
 
 transport_err:
<span class="p_del">-	iscsit_take_action_for_connection_exit(conn);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Avoid the normal connection failure code-path if this connection</span>
<span class="p_add">+	 * is still within LOGIN mode, and iscsi_np process context is</span>
<span class="p_add">+	 * responsible for cleaning up the early connection failure.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (conn-&gt;conn_state != TARG_CONN_STATE_IN_LOGIN)</span>
<span class="p_add">+		iscsit_take_action_for_connection_exit(conn);</span>
 out:
 	return 0;
 }
<span class="p_chunk">@@ -4093,7 +4099,7 @@</span> <span class="p_context"> reject:</span>
 
 int iscsi_target_rx_thread(void *arg)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, rc;</span>
 	u8 buffer[ISCSI_HDR_LEN], opcode;
 	u32 checksum = 0, digest = 0;
 	struct iscsi_conn *conn = arg;
<span class="p_chunk">@@ -4103,10 +4109,16 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait for iscsi_post_login_handler() to complete before allowing</span>
<span class="p_add">+	 * incoming iscsi/tcp socket I/O, and/or failing the connection.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rc = wait_for_completion_interruptible(&amp;conn-&gt;rx_login_comp);</span>
<span class="p_add">+	if (rc &lt; 0)</span>
<span class="p_add">+		return 0;</span>
 
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
<span class="p_del">-		int rc;</span>
 
 		init_completion(&amp;comp);
 		rc = wait_for_completion_interruptible(&amp;comp);
<span class="p_chunk">@@ -4543,7 +4555,18 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 	struct iscsi_conn *conn)
 {
 	struct iscsi_session *sess = conn-&gt;sess;
<span class="p_del">-	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
<span class="p_add">+	int sleep = 1;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Traditional iscsi/tcp will invoke this logic from TX thread</span>
<span class="p_add">+	 * context during session logout, so clear tx_thread_active and</span>
<span class="p_add">+	 * sleep if iscsit_close_connection() has not already occured.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Since iser-target invokes this logic from it&#39;s own workqueue,</span>
<span class="p_add">+	 * always sleep waiting for RX/TX thread shutdown to complete</span>
<span class="p_add">+	 * within iscsit_close_connection().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)</span>
<span class="p_add">+		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
<span class="p_chunk">@@ -4557,7 +4580,10 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 static void iscsit_logout_post_handler_samecid(
 	struct iscsi_conn *conn)
 {
<span class="p_del">-	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
<span class="p_add">+	int sleep = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)</span>
<span class="p_add">+		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
<span class="p_chunk">@@ -4776,6 +4802,7 @@</span> <span class="p_context"> int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)</span>
 	struct iscsi_session *sess;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
 	struct se_session *se_sess, *se_sess_tmp;
<span class="p_add">+	LIST_HEAD(free_list);</span>
 	int session_count = 0;
 
 	spin_lock_bh(&amp;se_tpg-&gt;session_lock);
<span class="p_chunk">@@ -4797,14 +4824,17 @@</span> <span class="p_context"> int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)</span>
 		}
 		atomic_set(&amp;sess-&gt;session_reinstatement, 1);
 		spin_unlock(&amp;sess-&gt;conn_lock);
<span class="p_del">-		spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
<span class="p_del">-		iscsit_free_session(sess);</span>
<span class="p_del">-		spin_lock_bh(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+		list_move_tail(&amp;se_sess-&gt;sess_list, &amp;free_list);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(se_sess, se_sess_tmp, &amp;free_list, sess_list) {</span>
<span class="p_add">+		sess = (struct iscsi_session *)se_sess-&gt;fabric_sess_ptr;</span>
 
<span class="p_add">+		iscsit_free_session(sess);</span>
 		session_count++;
 	}
<span class="p_del">-	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
 	pr_debug(&quot;Released %d iSCSI Session(s) from Target Portal&quot;
 			&quot; Group: %hu\n&quot;, session_count, tpg-&gt;tpgt);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index 70d799dfab03..c3bccaddb592 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -82,6 +82,7 @@</span> <span class="p_context"> static struct iscsi_login *iscsi_login_init_conn(struct iscsi_conn *conn)</span>
 	init_completion(&amp;conn-&gt;conn_logout_comp);
 	init_completion(&amp;conn-&gt;rx_half_close_comp);
 	init_completion(&amp;conn-&gt;tx_half_close_comp);
<span class="p_add">+	init_completion(&amp;conn-&gt;rx_login_comp);</span>
 	spin_lock_init(&amp;conn-&gt;cmd_lock);
 	spin_lock_init(&amp;conn-&gt;conn_usage_lock);
 	spin_lock_init(&amp;conn-&gt;immed_queue_lock);
<span class="p_chunk">@@ -699,7 +700,7 @@</span> <span class="p_context"> static void iscsi_post_login_start_timers(struct iscsi_conn *conn)</span>
 		iscsit_start_nopin_timer(conn);
 }
 
<span class="p_del">-static int iscsit_start_kthreads(struct iscsi_conn *conn)</span>
<span class="p_add">+int iscsit_start_kthreads(struct iscsi_conn *conn)</span>
 {
 	int ret = 0;
 
<span class="p_chunk">@@ -734,6 +735,7 @@</span> <span class="p_context"> static int iscsit_start_kthreads(struct iscsi_conn *conn)</span>
 
 	return 0;
 out_tx:
<span class="p_add">+	send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
 	kthread_stop(conn-&gt;tx_thread);
 	conn-&gt;tx_thread_active = false;
 out_bitmap:
<span class="p_chunk">@@ -744,7 +746,7 @@</span> <span class="p_context"> out_bitmap:</span>
 	return ret;
 }
 
<span class="p_del">-int iscsi_post_login_handler(</span>
<span class="p_add">+void iscsi_post_login_handler(</span>
 	struct iscsi_np *np,
 	struct iscsi_conn *conn,
 	u8 zero_tsih)
<span class="p_chunk">@@ -754,7 +756,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	struct se_session *se_sess = sess-&gt;se_sess;
 	struct iscsi_portal_group *tpg = sess-&gt;tpg;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
<span class="p_del">-	int rc;</span>
 
 	iscsit_inc_conn_usage_count(conn);
 
<span class="p_chunk">@@ -795,10 +796,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 			sess-&gt;sess_ops-&gt;InitiatorName);
 		spin_unlock_bh(&amp;sess-&gt;conn_lock);
 
<span class="p_del">-		rc = iscsit_start_kthreads(conn);</span>
<span class="p_del">-		if (rc)</span>
<span class="p_del">-			return rc;</span>
<span class="p_del">-</span>
 		iscsi_post_login_start_timers(conn);
 		/*
 		 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
<span class="p_chunk">@@ -807,15 +804,20 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 		iscsit_thread_get_cpumask(conn);
 		conn-&gt;conn_rx_reset_cpumask = 1;
 		conn-&gt;conn_tx_reset_cpumask = 1;
<span class="p_del">-</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Wakeup the sleeping iscsi_target_rx_thread() now that</span>
<span class="p_add">+		 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		complete(&amp;conn-&gt;rx_login_comp);</span>
 		iscsit_dec_conn_usage_count(conn);
<span class="p_add">+</span>
 		if (stop_timer) {
 			spin_lock_bh(&amp;se_tpg-&gt;session_lock);
 			iscsit_stop_time2retain_timer(sess);
 			spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 		}
 		iscsit_dec_session_usage_count(sess);
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return;</span>
 	}
 
 	iscsi_set_session_parameters(sess-&gt;sess_ops, conn-&gt;param_list, 1);
<span class="p_chunk">@@ -856,10 +858,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 		&quot; iSCSI Target Portal Group: %hu\n&quot;, tpg-&gt;nsessions, tpg-&gt;tpgt);
 	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 
<span class="p_del">-	rc = iscsit_start_kthreads(conn);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
 	iscsi_post_login_start_timers(conn);
 	/*
 	 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
<span class="p_chunk">@@ -868,10 +866,12 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	iscsit_thread_get_cpumask(conn);
 	conn-&gt;conn_rx_reset_cpumask = 1;
 	conn-&gt;conn_tx_reset_cpumask = 1;
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wakeup the sleeping iscsi_target_rx_thread() now that</span>
<span class="p_add">+	 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	complete(&amp;conn-&gt;rx_login_comp);</span>
 	iscsit_dec_conn_usage_count(conn);
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
 
 static void iscsi_handle_login_thread_timeout(unsigned long data)
<span class="p_chunk">@@ -1436,23 +1436,12 @@</span> <span class="p_context"> static int __iscsi_target_login_thread(struct iscsi_np *np)</span>
 	if (ret &lt; 0)
 		goto new_sess_out;
 
<span class="p_del">-	if (!conn-&gt;sess) {</span>
<span class="p_del">-		pr_err(&quot;struct iscsi_conn session pointer is NULL!\n&quot;);</span>
<span class="p_del">-		goto new_sess_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	iscsi_stop_login_thread_timer(np);
 
<span class="p_del">-	if (signal_pending(current))</span>
<span class="p_del">-		goto new_sess_out;</span>
<span class="p_del">-</span>
 	if (ret == 1) {
 		tpg_np = conn-&gt;tpg_np;
 
<span class="p_del">-		ret = iscsi_post_login_handler(np, conn, zero_tsih);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			goto new_sess_out;</span>
<span class="p_del">-</span>
<span class="p_add">+		iscsi_post_login_handler(np, conn, zero_tsih);</span>
 		iscsit_deaccess_np(np, tpg, tpg_np);
 	}
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.h b/drivers/target/iscsi/iscsi_target_login.h</span>
<span class="p_header">index 29d098324b7f..55cbf4533544 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.h</span>
<span class="p_chunk">@@ -12,7 +12,8 @@</span> <span class="p_context"> extern int iscsit_accept_np(struct iscsi_np *, struct iscsi_conn *);</span>
 extern int iscsit_get_login_rx(struct iscsi_conn *, struct iscsi_login *);
 extern int iscsit_put_login_tx(struct iscsi_conn *, struct iscsi_login *, u32);
 extern void iscsit_free_conn(struct iscsi_np *, struct iscsi_conn *);
<span class="p_del">-extern int iscsi_post_login_handler(struct iscsi_np *, struct iscsi_conn *, u8);</span>
<span class="p_add">+extern int iscsit_start_kthreads(struct iscsi_conn *);</span>
<span class="p_add">+extern void iscsi_post_login_handler(struct iscsi_np *, struct iscsi_conn *, u8);</span>
 extern void iscsi_target_login_sess_out(struct iscsi_conn *, struct iscsi_np *,
 				bool, bool);
 extern int iscsi_target_login_thread(void *);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">index 8c02fa34716f..f9cde9141836 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
  ******************************************************************************/
 
 #include &lt;linux/ctype.h&gt;
<span class="p_add">+#include &lt;linux/kthread.h&gt;</span>
 #include &lt;scsi/iscsi_proto.h&gt;
 #include &lt;target/target_core_base.h&gt;
 #include &lt;target/target_core_fabric.h&gt;
<span class="p_chunk">@@ -361,10 +362,24 @@</span> <span class="p_context"> static int iscsi_target_do_tx_login_io(struct iscsi_conn *conn, struct iscsi_log</span>
 		ntohl(login_rsp-&gt;statsn), login-&gt;rsp_length);
 
 	padding = ((-login-&gt;rsp_length) &amp; 3);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Before sending the last login response containing the transition</span>
<span class="p_add">+	 * bit for full-feature-phase, go ahead and start up TX/RX threads</span>
<span class="p_add">+	 * now to avoid potential resource allocation failures after the</span>
<span class="p_add">+	 * final login response has been sent.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (login-&gt;login_complete) {</span>
<span class="p_add">+		int rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,</span>
<span class="p_add">+					    ISCSI_LOGIN_STATUS_NO_RESOURCES);</span>
<span class="p_add">+			return -1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	if (conn-&gt;conn_transport-&gt;iscsit_put_login_tx(conn, login,
 					login-&gt;rsp_length + padding) &lt; 0)
<span class="p_del">-		return -1;</span>
<span class="p_add">+		goto err;</span>
 
 	login-&gt;rsp_length		= 0;
 	mutex_lock(&amp;sess-&gt;cmdsn_mutex);
<span class="p_chunk">@@ -373,6 +388,23 @@</span> <span class="p_context"> static int iscsi_target_do_tx_login_io(struct iscsi_conn *conn, struct iscsi_log</span>
 	mutex_unlock(&amp;sess-&gt;cmdsn_mutex);
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	if (login-&gt;login_complete) {</span>
<span class="p_add">+		if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;rx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+		bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+				      get_order(1));</span>
<span class="p_add">+		spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return -1;</span>
 }
 
 static void iscsi_target_sk_data_ready(struct sock *sk)
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index 396344cb011f..16ed0b6c7f9c 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -1108,19 +1108,29 @@</span> <span class="p_context"> static void eraser(unsigned char c, struct tty_struct *tty)</span>
  *	Locking: ctrl_lock
  */
 
<span class="p_del">-static void isig(int sig, struct tty_struct *tty)</span>
<span class="p_add">+static void __isig(int sig, struct tty_struct *tty)</span>
 {
<span class="p_del">-	struct n_tty_data *ldata = tty-&gt;disc_data;</span>
 	struct pid *tty_pgrp = tty_get_pgrp(tty);
 	if (tty_pgrp) {
 		kill_pgrp(tty_pgrp, sig, 1);
 		put_pid(tty_pgrp);
 	}
<span class="p_add">+}</span>
 
<span class="p_del">-	if (!L_NOFLSH(tty)) {</span>
<span class="p_add">+static void isig(int sig, struct tty_struct *tty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct n_tty_data *ldata = tty-&gt;disc_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (L_NOFLSH(tty)) {</span>
<span class="p_add">+		/* signal only */</span>
<span class="p_add">+		__isig(sig, tty);</span>
<span class="p_add">+</span>
<span class="p_add">+	} else { /* signal and flush */</span>
 		up_read(&amp;tty-&gt;termios_rwsem);
 		down_write(&amp;tty-&gt;termios_rwsem);
 
<span class="p_add">+		__isig(sig, tty);</span>
<span class="p_add">+</span>
 		/* clear echo buffer */
 		mutex_lock(&amp;ldata-&gt;output_lock);
 		ldata-&gt;echo_head = ldata-&gt;echo_tail = 0;
<span class="p_header">diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c</span>
<span class="p_header">index 88250395b0ce..01aa52f574e5 100644</span>
<span class="p_header">--- a/drivers/tty/serial/imx.c</span>
<span class="p_header">+++ b/drivers/tty/serial/imx.c</span>
<span class="p_chunk">@@ -1132,11 +1132,6 @@</span> <span class="p_context"> static int imx_startup(struct uart_port *port)</span>
 	while (!(readl(sport-&gt;port.membase + UCR2) &amp; UCR2_SRST) &amp;&amp; (--i &gt; 0))
 		udelay(1);
 
<span class="p_del">-	/* Can we enable the DMA support? */</span>
<span class="p_del">-	if (is_imx6q_uart(sport) &amp;&amp; !uart_console(port) &amp;&amp;</span>
<span class="p_del">-	    !sport-&gt;dma_is_inited)</span>
<span class="p_del">-		imx_uart_dma_init(sport);</span>
<span class="p_del">-</span>
 	spin_lock_irqsave(&amp;sport-&gt;port.lock, flags);
 
 	/*
<span class="p_chunk">@@ -1145,9 +1140,6 @@</span> <span class="p_context"> static int imx_startup(struct uart_port *port)</span>
 	writel(USR1_RTSD, sport-&gt;port.membase + USR1);
 	writel(USR2_ORE, sport-&gt;port.membase + USR2);
 
<span class="p_del">-	if (sport-&gt;dma_is_inited &amp;&amp; !sport-&gt;dma_is_enabled)</span>
<span class="p_del">-		imx_enable_dma(sport);</span>
<span class="p_del">-</span>
 	temp = readl(sport-&gt;port.membase + UCR1);
 	temp |= UCR1_RRDYEN | UCR1_RTSDEN | UCR1_UARTEN;
 
<span class="p_chunk">@@ -1318,6 +1310,11 @@</span> <span class="p_context"> imx_set_termios(struct uart_port *port, struct ktermios *termios,</span>
 			} else {
 				ucr2 |= UCR2_CTSC;
 			}
<span class="p_add">+</span>
<span class="p_add">+			/* Can we enable the DMA support? */</span>
<span class="p_add">+			if (is_imx6q_uart(sport) &amp;&amp; !uart_console(port)</span>
<span class="p_add">+				&amp;&amp; !sport-&gt;dma_is_inited)</span>
<span class="p_add">+				imx_uart_dma_init(sport);</span>
 		} else {
 			termios-&gt;c_cflag &amp;= ~CRTSCTS;
 		}
<span class="p_chunk">@@ -1434,6 +1431,8 @@</span> <span class="p_context"> imx_set_termios(struct uart_port *port, struct ktermios *termios,</span>
 	if (UART_ENABLE_MS(&amp;sport-&gt;port, termios-&gt;c_cflag))
 		imx_enable_ms(&amp;sport-&gt;port);
 
<span class="p_add">+	if (sport-&gt;dma_is_inited &amp;&amp; !sport-&gt;dma_is_enabled)</span>
<span class="p_add">+		imx_enable_dma(sport);</span>
 	spin_unlock_irqrestore(&amp;sport-&gt;port.lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c</span>
<span class="p_header">index 0b7bb12dfc68..ec540445bb71 100644</span>
<span class="p_header">--- a/drivers/tty/serial/serial_core.c</span>
<span class="p_header">+++ b/drivers/tty/serial/serial_core.c</span>
<span class="p_chunk">@@ -1409,7 +1409,7 @@</span> <span class="p_context"> static void uart_close(struct tty_struct *tty, struct file *filp)</span>
 	mutex_lock(&amp;port-&gt;mutex);
 	uart_shutdown(tty, state);
 	tty_port_tty_set(port, NULL);
<span class="p_del">-	tty-&gt;closing = 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;port-&gt;lock, flags);
 
 	if (port-&gt;blocked_open) {
<span class="p_chunk">@@ -1435,6 +1435,7 @@</span> <span class="p_context"> static void uart_close(struct tty_struct *tty, struct file *filp)</span>
 	mutex_unlock(&amp;port-&gt;mutex);
 
 	tty_ldisc_flush(tty);
<span class="p_add">+	tty-&gt;closing = 0;</span>
 }
 
 static void uart_wait_until_sent(struct tty_struct *tty, int timeout)
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 0827d7c96527..ee07ba41c8db 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -484,10 +484,13 @@</span> <span class="p_context"> static void xhci_hub_report_usb3_link_state(struct xhci_hcd *xhci,</span>
 	u32 pls = status_reg &amp; PORT_PLS_MASK;
 
 	/* resume state is a xHCI internal state.
<span class="p_del">-	 * Do not report it to usb core.</span>
<span class="p_add">+	 * Do not report it to usb core, instead, pretend to be U3,</span>
<span class="p_add">+	 * thus usb core knows it&#39;s not ready for transfer</span>
 	 */
<span class="p_del">-	if (pls == XDEV_RESUME)</span>
<span class="p_add">+	if (pls == XDEV_RESUME) {</span>
<span class="p_add">+		*status |= USB_SS_PORT_LS_U3;</span>
 		return;
<span class="p_add">+	}</span>
 
 	/* When the CAS bit is set then warm reset
 	 * should be performed on port
<span class="p_chunk">@@ -588,7 +591,14 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 		status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 	/* USB3.0 only */
 	if (hcd-&gt;speed == HCD_USB3) {
<span class="p_del">-		if ((raw_port_status &amp; PORT_PLC))</span>
<span class="p_add">+		/* Port link change with port in resume state should not be</span>
<span class="p_add">+		 * reported to usbcore, as this is an internal state to be</span>
<span class="p_add">+		 * handled by xhci driver. Reporting PLC to usbcore may</span>
<span class="p_add">+		 * cause usbcore clearing PLC first and port change event</span>
<span class="p_add">+		 * irq won&#39;t be generated.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((raw_port_status &amp; PORT_PLC) &amp;&amp;</span>
<span class="p_add">+			(raw_port_status &amp; PORT_PLS_MASK) != XDEV_RESUME)</span>
 			status |= USB_PORT_STAT_C_LINK_STATE &lt;&lt; 16;
 		if ((raw_port_status &amp; PORT_WRC))
 			status |= USB_PORT_STAT_C_BH_RESET &lt;&lt; 16;
<span class="p_chunk">@@ -1120,10 +1130,10 @@</span> <span class="p_context"> int xhci_bus_suspend(struct usb_hcd *hcd)</span>
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 
 	if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
<span class="p_del">-		if (bus_state-&gt;resuming_ports) {</span>
<span class="p_add">+		if (bus_state-&gt;resuming_ports ||	/* USB2 */</span>
<span class="p_add">+		    bus_state-&gt;port_remote_wakeup) {	/* USB3 */</span>
 			spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_del">-			xhci_dbg(xhci, &quot;suspend failed because &quot;</span>
<span class="p_del">-						&quot;a port is resuming\n&quot;);</span>
<span class="p_add">+			xhci_dbg(xhci, &quot;suspend failed because a port is resuming\n&quot;);</span>
 			return -EBUSY;
 		}
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 7d34cbfaf373..d095677a0702 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1546,6 +1546,9 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 		usb_hcd_resume_root_hub(hcd);
 	}
 
<span class="p_add">+	if (hcd-&gt;speed == HCD_USB3 &amp;&amp; (temp &amp; PORT_PLS_MASK) == XDEV_INACTIVE)</span>
<span class="p_add">+		bus_state-&gt;port_remote_wakeup &amp;= ~(1 &lt;&lt; faked_port_index);</span>
<span class="p_add">+</span>
 	if ((temp &amp; PORT_PLC) &amp;&amp; (temp &amp; PORT_PLS_MASK) == XDEV_RESUME) {
 		xhci_dbg(xhci, &quot;port resume event for port %d\n&quot;, port_id);
 
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 36bf089b708f..c502c2277aeb 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -3453,6 +3453,9 @@</span> <span class="p_context"> int xhci_discover_or_reset_device(struct usb_hcd *hcd, struct usb_device *udev)</span>
 			return -EINVAL;
 	}
 
<span class="p_add">+	if (virt_dev-&gt;tt_info)</span>
<span class="p_add">+		old_active_eps = virt_dev-&gt;tt_info-&gt;active_eps;</span>
<span class="p_add">+</span>
 	if (virt_dev-&gt;udev != udev) {
 		/* If the virt_dev and the udev does not match, this virt_dev
 		 * may belong to another udev.
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 6977f8491fa7..0f26dd2697b6 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -285,6 +285,7 @@</span> <span class="p_context"> struct xhci_op_regs {</span>
 #define XDEV_U0		(0x0 &lt;&lt; 5)
 #define XDEV_U2		(0x2 &lt;&lt; 5)
 #define XDEV_U3		(0x3 &lt;&lt; 5)
<span class="p_add">+#define XDEV_INACTIVE	(0x6 &lt;&lt; 5)</span>
 #define XDEV_RESUME	(0xf &lt;&lt; 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 &lt;&lt; 9)
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index caf188800c67..87898ca2ed17 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -2065,6 +2065,18 @@</span> <span class="p_context"> UNUSUAL_DEV( 0x1908, 0x3335, 0x0200, 0x0200,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_NO_READ_DISC_INFO ),
 
<span class="p_add">+/* Reported by Oliver Neukum &lt;oneukum@suse.com&gt;</span>
<span class="p_add">+ * This device morphes spontaneously into another device if the access</span>
<span class="p_add">+ * pattern of Windows isn&#39;t followed. Thus writable media would be dirty</span>
<span class="p_add">+ * if the initial instance is used. So the device is limited to its</span>
<span class="p_add">+ * virtual CD.</span>
<span class="p_add">+ * And yes, the concept that BCD goes up to 9 is not heeded */</span>
<span class="p_add">+UNUSUAL_DEV( 0x19d2, 0x1225, 0x0000, 0xffff,</span>
<span class="p_add">+		&quot;ZTE,Incorporated&quot;,</span>
<span class="p_add">+		&quot;ZTE WCDMA Technologies MSM&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_SINGLE_LUN ),</span>
<span class="p_add">+</span>
 /* Reported by Sven Geggus &lt;sven-usbst@geggus.net&gt;
  * This encrypted pen drive returns bogus data for the initial READ(10).
  */
<span class="p_header">diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c</span>
<span class="p_header">index 2ee28266fd07..fa49d3294cd5 100644</span>
<span class="p_header">--- a/drivers/vhost/vhost.c</span>
<span class="p_header">+++ b/drivers/vhost/vhost.c</span>
<span class="p_chunk">@@ -886,6 +886,7 @@</span> <span class="p_context"> long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)</span>
 		}
 		if (eventfp != d-&gt;log_file) {
 			filep = d-&gt;log_file;
<span class="p_add">+			d-&gt;log_file = eventfp;</span>
 			ctx = d-&gt;log_ctx;
 			d-&gt;log_ctx = eventfp ?
 				eventfd_ctx_fileget(eventfp) : NULL;
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 50bb3c207621..5d03eb0ec0ac 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -642,7 +642,7 @@</span> <span class="p_context"> static inline bool fast_dput(struct dentry *dentry)</span>
 
 	/*
 	 * If we have a d_op-&gt;d_delete() operation, we sould not
<span class="p_del">-	 * let the dentry count go to zero, so use &quot;put__or_lock&quot;.</span>
<span class="p_add">+	 * let the dentry count go to zero, so use &quot;put_or_lock&quot;.</span>
 	 */
 	if (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_DELETE))
 		return lockref_put_or_lock(&amp;dentry-&gt;d_lockref);
<span class="p_chunk">@@ -697,7 +697,7 @@</span> <span class="p_context"> static inline bool fast_dput(struct dentry *dentry)</span>
 	 */
 	smp_rmb();
 	d_flags = ACCESS_ONCE(dentry-&gt;d_flags);
<span class="p_del">-	d_flags &amp;= DCACHE_REFERENCED | DCACHE_LRU_LIST;</span>
<span class="p_add">+	d_flags &amp;= DCACHE_REFERENCED | DCACHE_LRU_LIST | DCACHE_DISCONNECTED;</span>
 
 	/* Nothing to do? Dropping the reference was all we needed? */
 	if (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) &amp;&amp; !d_unhashed(dentry))
<span class="p_chunk">@@ -776,6 +776,9 @@</span> <span class="p_context"> repeat:</span>
 	if (unlikely(d_unhashed(dentry)))
 		goto kill_it;
 
<span class="p_add">+	if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DISCONNECTED))</span>
<span class="p_add">+		goto kill_it;</span>
<span class="p_add">+</span>
 	if (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_DELETE)) {
 		if (dentry-&gt;d_op-&gt;d_delete(dentry))
 			goto kill_it;
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 02c6875dd945..fce3cc1a3fa7 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -1350,6 +1350,36 @@</span> <span class="p_context"> enum umount_tree_flags {</span>
 	UMOUNT_PROPAGATE = 2,
 	UMOUNT_CONNECTED = 4,
 };
<span class="p_add">+</span>
<span class="p_add">+static bool disconnect_mount(struct mount *mnt, enum umount_tree_flags how)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Leaving mounts connected is only valid for lazy umounts */</span>
<span class="p_add">+	if (how &amp; UMOUNT_SYNC)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* A mount without a parent has nothing to be connected to */</span>
<span class="p_add">+	if (!mnt_has_parent(mnt))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Because the reference counting rules change when mounts are</span>
<span class="p_add">+	 * unmounted and connected, umounted mounts may not be</span>
<span class="p_add">+	 * connected to mounted mounts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(mnt-&gt;mnt_parent-&gt;mnt.mnt_flags &amp; MNT_UMOUNT))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Has it been requested that the mount remain connected? */</span>
<span class="p_add">+	if (how &amp; UMOUNT_CONNECTED)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Is the mount locked such that it needs to remain connected? */</span>
<span class="p_add">+	if (IS_MNT_LOCKED(mnt))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* By default disconnect the mount */</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * mount_lock must be held
  * namespace_sem must be held for write
<span class="p_chunk">@@ -1387,10 +1417,7 @@</span> <span class="p_context"> static void umount_tree(struct mount *mnt, enum umount_tree_flags how)</span>
 		if (how &amp; UMOUNT_SYNC)
 			p-&gt;mnt.mnt_flags |= MNT_SYNC_UMOUNT;
 
<span class="p_del">-		disconnect = !(((how &amp; UMOUNT_CONNECTED) &amp;&amp;</span>
<span class="p_del">-				mnt_has_parent(p) &amp;&amp;</span>
<span class="p_del">-				(p-&gt;mnt_parent-&gt;mnt.mnt_flags &amp; MNT_UMOUNT)) ||</span>
<span class="p_del">-			       IS_MNT_LOCKED_AND_LAZY(p));</span>
<span class="p_add">+		disconnect = disconnect_mount(p, how);</span>
 
 		pin_insert_group(&amp;p-&gt;mnt_umount, &amp;p-&gt;mnt_parent-&gt;mnt,
 				 disconnect ? &amp;unmounted : NULL);
<span class="p_chunk">@@ -1527,11 +1554,8 @@</span> <span class="p_context"> void __detach_mounts(struct dentry *dentry)</span>
 	while (!hlist_empty(&amp;mp-&gt;m_list)) {
 		mnt = hlist_entry(mp-&gt;m_list.first, struct mount, mnt_mp_list);
 		if (mnt-&gt;mnt.mnt_flags &amp; MNT_UMOUNT) {
<span class="p_del">-			struct mount *p, *tmp;</span>
<span class="p_del">-			list_for_each_entry_safe(p, tmp, &amp;mnt-&gt;mnt_mounts,  mnt_child) {</span>
<span class="p_del">-				hlist_add_head(&amp;p-&gt;mnt_umount.s_list, &amp;unmounted);</span>
<span class="p_del">-				umount_mnt(p);</span>
<span class="p_del">-			}</span>
<span class="p_add">+			hlist_add_head(&amp;mnt-&gt;mnt_umount.s_list, &amp;unmounted);</span>
<span class="p_add">+			umount_mnt(mnt);</span>
 		}
 		else umount_tree(mnt, UMOUNT_CONNECTED);
 	}
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index f734562c6d24..5d25b9d97c29 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -1242,9 +1242,11 @@</span> <span class="p_context"> static int nfs_check_inode_attributes(struct inode *inode, struct nfs_fattr *fat</span>
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_SIZE) {
 		cur_size = i_size_read(inode);
 		new_isize = nfs_size_to_loff_t(fattr-&gt;size);
<span class="p_del">-		if (cur_size != new_isize &amp;&amp; nfsi-&gt;nrequests == 0)</span>
<span class="p_add">+		if (cur_size != new_isize)</span>
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;
 	}
<span class="p_add">+	if (nfsi-&gt;nrequests != 0)</span>
<span class="p_add">+		invalid &amp;= ~NFS_INO_REVAL_PAGECACHE;</span>
 
 	/* Have any file permissions changed? */
 	if ((fattr-&gt;valid &amp; NFS_ATTR_FATTR_MODE) &amp;&amp; (inode-&gt;i_mode &amp; S_IALLUGO) != (fattr-&gt;mode &amp; S_IALLUGO))
<span class="p_chunk">@@ -1682,8 +1684,7 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			invalid |= NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_DATA
 				| NFS_INO_INVALID_ACCESS
<span class="p_del">-				| NFS_INO_INVALID_ACL</span>
<span class="p_del">-				| NFS_INO_REVAL_PAGECACHE;</span>
<span class="p_add">+				| NFS_INO_INVALID_ACL;</span>
 			if (S_ISDIR(inode-&gt;i_mode))
 				nfs_force_lookup_revalidate(inode);
 			inode-&gt;i_version = fattr-&gt;change_attr;
<span class="p_chunk">@@ -1715,7 +1716,6 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			if ((nfsi-&gt;nrequests == 0) || new_isize &gt; cur_isize) {
 				i_size_write(inode, new_isize);
 				invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA;
<span class="p_del">-				invalid &amp;= ~NFS_INO_REVAL_PAGECACHE;</span>
 			}
 			dprintk(&quot;NFS: isize change on server for file %s/%ld &quot;
 					&quot;(%Ld to %Ld)\n&quot;,
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 55e1e3af23a3..d3f205126609 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -1204,12 +1204,15 @@</span> <span class="p_context"> static bool nfs_need_update_open_stateid(struct nfs4_state *state,</span>
 
 static void nfs_resync_open_stateid_locked(struct nfs4_state *state)
 {
<span class="p_add">+	if (!(state-&gt;n_wronly || state-&gt;n_rdonly || state-&gt;n_rdwr))</span>
<span class="p_add">+		return;</span>
 	if (state-&gt;n_wronly)
 		set_bit(NFS_O_WRONLY_STATE, &amp;state-&gt;flags);
 	if (state-&gt;n_rdonly)
 		set_bit(NFS_O_RDONLY_STATE, &amp;state-&gt;flags);
 	if (state-&gt;n_rdwr)
 		set_bit(NFS_O_RDWR_STATE, &amp;state-&gt;flags);
<span class="p_add">+	set_bit(NFS_OPEN_STATE, &amp;state-&gt;flags);</span>
 }
 
 static void nfs_clear_open_stateid_locked(struct nfs4_state *state,
<span class="p_header">diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c</span>
<span class="p_header">index 282b39369510..7b4552678536 100644</span>
<span class="p_header">--- a/fs/nfs/pagelist.c</span>
<span class="p_header">+++ b/fs/nfs/pagelist.c</span>
<span class="p_chunk">@@ -1110,8 +1110,11 @@</span> <span class="p_context"> static int nfs_do_recoalesce(struct nfs_pageio_descriptor *desc)</span>
 			nfs_list_remove_request(req);
 			if (__nfs_pageio_add_request(desc, req))
 				continue;
<span class="p_del">-			if (desc-&gt;pg_error &lt; 0)</span>
<span class="p_add">+			if (desc-&gt;pg_error &lt; 0) {</span>
<span class="p_add">+				list_splice_tail(&amp;head, &amp;mirror-&gt;pg_list);</span>
<span class="p_add">+				mirror-&gt;pg_recoalesce = 1;</span>
 				return 0;
<span class="p_add">+			}</span>
 			break;
 		}
 	} while (mirror-&gt;pg_recoalesce);
<span class="p_header">diff --git a/fs/pnode.h b/fs/pnode.h</span>
<span class="p_header">index 7114ce6e6b9e..0fcdbe7ca648 100644</span>
<span class="p_header">--- a/fs/pnode.h</span>
<span class="p_header">+++ b/fs/pnode.h</span>
<span class="p_chunk">@@ -20,8 +20,6 @@</span> <span class="p_context"></span>
 #define SET_MNT_MARK(m) ((m)-&gt;mnt.mnt_flags |= MNT_MARKED)
 #define CLEAR_MNT_MARK(m) ((m)-&gt;mnt.mnt_flags &amp;= ~MNT_MARKED)
 #define IS_MNT_LOCKED(m) ((m)-&gt;mnt.mnt_flags &amp; MNT_LOCKED)
<span class="p_del">-#define IS_MNT_LOCKED_AND_LAZY(m) \</span>
<span class="p_del">-	(((m)-&gt;mnt.mnt_flags &amp; (MNT_LOCKED|MNT_SYNC_UMOUNT)) == MNT_LOCKED)</span>
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_attr_remote.c b/fs/xfs/libxfs/xfs_attr_remote.c</span>
<span class="p_header">index 20de88d1bf86..dd714037c322 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_attr_remote.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_attr_remote.c</span>
<span class="p_chunk">@@ -159,11 +159,10 @@</span> <span class="p_context"> xfs_attr3_rmt_write_verify(</span>
 	struct xfs_buf	*bp)
 {
 	struct xfs_mount *mp = bp-&gt;b_target-&gt;bt_mount;
<span class="p_del">-	struct xfs_buf_log_item	*bip = bp-&gt;b_fspriv;</span>
<span class="p_add">+	int		blksize = mp-&gt;m_attr_geo-&gt;blksize;</span>
 	char		*ptr;
 	int		len;
 	xfs_daddr_t	bno;
<span class="p_del">-	int		blksize = mp-&gt;m_attr_geo-&gt;blksize;</span>
 
 	/* no verification of non-crc buffers */
 	if (!xfs_sb_version_hascrc(&amp;mp-&gt;m_sb))
<span class="p_chunk">@@ -175,16 +174,22 @@</span> <span class="p_context"> xfs_attr3_rmt_write_verify(</span>
 	ASSERT(len &gt;= blksize);
 
 	while (len &gt; 0) {
<span class="p_add">+		struct xfs_attr3_rmt_hdr *rmt = (struct xfs_attr3_rmt_hdr *)ptr;</span>
<span class="p_add">+</span>
 		if (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
 			xfs_buf_ioerror(bp, -EFSCORRUPTED);
 			xfs_verifier_error(bp);
 			return;
 		}
<span class="p_del">-		if (bip) {</span>
<span class="p_del">-			struct xfs_attr3_rmt_hdr *rmt;</span>
 
<span class="p_del">-			rmt = (struct xfs_attr3_rmt_hdr *)ptr;</span>
<span class="p_del">-			rmt-&gt;rm_lsn = cpu_to_be64(bip-&gt;bli_item.li_lsn);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Ensure we aren&#39;t writing bogus LSNs to disk. See</span>
<span class="p_add">+		 * xfs_attr3_rmt_hdr_set() for the explanation.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (rmt-&gt;rm_lsn != cpu_to_be64(NULLCOMMITLSN)) {</span>
<span class="p_add">+			xfs_buf_ioerror(bp, -EFSCORRUPTED);</span>
<span class="p_add">+			xfs_verifier_error(bp);</span>
<span class="p_add">+			return;</span>
 		}
 		xfs_update_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF);
 
<span class="p_chunk">@@ -221,6 +226,18 @@</span> <span class="p_context"> xfs_attr3_rmt_hdr_set(</span>
 	rmt-&gt;rm_owner = cpu_to_be64(ino);
 	rmt-&gt;rm_blkno = cpu_to_be64(bno);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Remote attribute blocks are written synchronously, so we don&#39;t</span>
<span class="p_add">+	 * have an LSN that we can stamp in them that makes any sense to log</span>
<span class="p_add">+	 * recovery. To ensure that log recovery handles overwrites of these</span>
<span class="p_add">+	 * blocks sanely (i.e. once they&#39;ve been freed and reallocated as some</span>
<span class="p_add">+	 * other type of metadata) we need to ensure that the LSN has a value</span>
<span class="p_add">+	 * that tells log recovery to ignore the LSN and overwrite the buffer</span>
<span class="p_add">+	 * with whatever is in it&#39;s log. To do this, we use the magic</span>
<span class="p_add">+	 * NULLCOMMITLSN to indicate that the LSN is invalid.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rmt-&gt;rm_lsn = cpu_to_be64(NULLCOMMITLSN);</span>
<span class="p_add">+</span>
 	return sizeof(struct xfs_attr3_rmt_hdr);
 }
 
<span class="p_chunk">@@ -434,14 +451,21 @@</span> <span class="p_context"> xfs_attr_rmtval_set(</span>
 
 		/*
 		 * Allocate a single extent, up to the size of the value.
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Note that we have to consider this a data allocation as we</span>
<span class="p_add">+		 * write the remote attribute without logging the contents.</span>
<span class="p_add">+		 * Hence we must ensure that we aren&#39;t using blocks that are on</span>
<span class="p_add">+		 * the busy list so that we don&#39;t overwrite blocks which have</span>
<span class="p_add">+		 * recently been freed but their transactions are not yet</span>
<span class="p_add">+		 * committed to disk. If we overwrite the contents of a busy</span>
<span class="p_add">+		 * extent and then crash then the block may not contain the</span>
<span class="p_add">+		 * correct metadata after log recovery occurs.</span>
 		 */
 		xfs_bmap_init(args-&gt;flist, args-&gt;firstblock);
 		nmap = 1;
 		error = xfs_bmapi_write(args-&gt;trans, dp, (xfs_fileoff_t)lblkno,
<span class="p_del">-				  blkcnt,</span>
<span class="p_del">-				  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,</span>
<span class="p_del">-				  args-&gt;firstblock, args-&gt;total, &amp;map, &amp;nmap,</span>
<span class="p_del">-				  args-&gt;flist);</span>
<span class="p_add">+				  blkcnt, XFS_BMAPI_ATTRFORK, args-&gt;firstblock,</span>
<span class="p_add">+				  args-&gt;total, &amp;map, &amp;nmap, args-&gt;flist);</span>
 		if (!error) {
 			error = xfs_bmap_finish(&amp;args-&gt;trans, args-&gt;flist,
 						&amp;committed);
<span class="p_header">diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">index 4f5784f85a5b..a5d03396dda0 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_log_recover.c</span>
<span class="p_chunk">@@ -1887,9 +1887,14 @@</span> <span class="p_context"> xlog_recover_get_buf_lsn(</span>
 		uuid = &amp;((struct xfs_dir3_blk_hdr *)blk)-&gt;uuid;
 		break;
 	case XFS_ATTR3_RMT_MAGIC:
<span class="p_del">-		lsn = be64_to_cpu(((struct xfs_attr3_rmt_hdr *)blk)-&gt;rm_lsn);</span>
<span class="p_del">-		uuid = &amp;((struct xfs_attr3_rmt_hdr *)blk)-&gt;rm_uuid;</span>
<span class="p_del">-		break;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Remote attr blocks are written synchronously, rather than</span>
<span class="p_add">+		 * being logged. That means they do not contain a valid LSN</span>
<span class="p_add">+		 * (i.e. transactionally ordered) in them, and hence any time we</span>
<span class="p_add">+		 * see a buffer to replay over the top of a remote attribute</span>
<span class="p_add">+		 * block we should simply do so.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		goto recover_immediately;</span>
 	case XFS_SB_MAGIC:
 		lsn = be64_to_cpu(((struct xfs_dsb *)blk)-&gt;sb_lsn);
 		uuid = &amp;((struct xfs_dsb *)blk)-&gt;sb_uuid;
<span class="p_header">diff --git a/include/linux/can/skb.h b/include/linux/can/skb.h</span>
<span class="p_header">index b6a52a4b457a..51bb6532785c 100644</span>
<span class="p_header">--- a/include/linux/can/skb.h</span>
<span class="p_header">+++ b/include/linux/can/skb.h</span>
<span class="p_chunk">@@ -27,10 +27,12 @@</span> <span class="p_context"></span>
 /**
  * struct can_skb_priv - private additional data inside CAN sk_buffs
  * @ifindex:	ifindex of the first interface the CAN frame appeared on
<span class="p_add">+ * @skbcnt:	atomic counter to have an unique id together with skb pointer</span>
  * @cf:		align to the following CAN frame at skb-&gt;data
  */
 struct can_skb_priv {
 	int ifindex;
<span class="p_add">+	int skbcnt;</span>
 	struct can_frame cf[0];
 };
 
<span class="p_header">diff --git a/include/linux/cper.h b/include/linux/cper.h</span>
<span class="p_header">index 76abba4b238e..dcacb1a72e26 100644</span>
<span class="p_header">--- a/include/linux/cper.h</span>
<span class="p_header">+++ b/include/linux/cper.h</span>
<span class="p_chunk">@@ -340,7 +340,27 @@</span> <span class="p_context"> struct cper_ia_proc_ctx {</span>
 	__u64	mm_reg_addr;
 };
 
<span class="p_del">-/* Memory Error Section */</span>
<span class="p_add">+/* Old Memory Error Section UEFI 2.1, 2.2 */</span>
<span class="p_add">+struct cper_sec_mem_err_old {</span>
<span class="p_add">+	__u64	validation_bits;</span>
<span class="p_add">+	__u64	error_status;</span>
<span class="p_add">+	__u64	physical_addr;</span>
<span class="p_add">+	__u64	physical_addr_mask;</span>
<span class="p_add">+	__u16	node;</span>
<span class="p_add">+	__u16	card;</span>
<span class="p_add">+	__u16	module;</span>
<span class="p_add">+	__u16	bank;</span>
<span class="p_add">+	__u16	device;</span>
<span class="p_add">+	__u16	row;</span>
<span class="p_add">+	__u16	column;</span>
<span class="p_add">+	__u16	bit_pos;</span>
<span class="p_add">+	__u64	requestor_id;</span>
<span class="p_add">+	__u64	responder_id;</span>
<span class="p_add">+	__u64	target_id;</span>
<span class="p_add">+	__u8	error_type;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Memory Error Section UEFI &gt;= 2.3 */</span>
 struct cper_sec_mem_err {
 	__u64	validation_bits;
 	__u64	error_status;
<span class="p_header">diff --git a/include/linux/ftrace.h b/include/linux/ftrace.h</span>
<span class="p_header">index 1da602982cf9..6cd8c0ee4b6f 100644</span>
<span class="p_header">--- a/include/linux/ftrace.h</span>
<span class="p_header">+++ b/include/linux/ftrace.h</span>
<span class="p_chunk">@@ -116,6 +116,7 @@</span> <span class="p_context"> ftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops);</span>
  *            SAVE_REGS. If another ops with this flag set is already registered
  *            for any of the functions that this ops will be registered for, then
  *            this ops will fail to register or set_filter_ip.
<span class="p_add">+ * PID     - Is affected by set_ftrace_pid (allows filtering on those pids)</span>
  */
 enum {
 	FTRACE_OPS_FL_ENABLED			= 1 &lt;&lt; 0,
<span class="p_chunk">@@ -132,6 +133,7 @@</span> <span class="p_context"> enum {</span>
 	FTRACE_OPS_FL_MODIFYING			= 1 &lt;&lt; 11,
 	FTRACE_OPS_FL_ALLOC_TRAMP		= 1 &lt;&lt; 12,
 	FTRACE_OPS_FL_IPMODIFY			= 1 &lt;&lt; 13,
<span class="p_add">+	FTRACE_OPS_FL_PID			= 1 &lt;&lt; 14,</span>
 };
 
 #ifdef CONFIG_DYNAMIC_FTRACE
<span class="p_chunk">@@ -159,6 +161,7 @@</span> <span class="p_context"> struct ftrace_ops {</span>
 	struct ftrace_ops		*next;
 	unsigned long			flags;
 	void				*private;
<span class="p_add">+	ftrace_func_t			saved_func;</span>
 	int __percpu			*disabled;
 #ifdef CONFIG_DYNAMIC_FTRACE
 	int				nr_trampolines;
<span class="p_header">diff --git a/include/target/iscsi/iscsi_target_core.h b/include/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index 54e7af301888..73abbc54063d 100644</span>
<span class="p_header">--- a/include/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/include/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -606,6 +606,7 @@</span> <span class="p_context"> struct iscsi_conn {</span>
 	int			bitmap_id;
 	int			rx_thread_active;
 	struct task_struct	*rx_thread;
<span class="p_add">+	struct completion	rx_login_comp;</span>
 	int			tx_thread_active;
 	struct task_struct	*tx_thread;
 	/* list_head for session connection list */
<span class="p_header">diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c</span>
<span class="p_header">index 9065107f083e..7a5237a1bce5 100644</span>
<span class="p_header">--- a/kernel/irq/resend.c</span>
<span class="p_header">+++ b/kernel/irq/resend.c</span>
<span class="p_chunk">@@ -75,13 +75,21 @@</span> <span class="p_context"> void check_irq_resend(struct irq_desc *desc, unsigned int irq)</span>
 		    !desc-&gt;irq_data.chip-&gt;irq_retrigger(&amp;desc-&gt;irq_data)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 			/*
<span class="p_del">-			 * If the interrupt has a parent irq and runs</span>
<span class="p_del">-			 * in the thread context of the parent irq,</span>
<span class="p_del">-			 * retrigger the parent.</span>
<span class="p_add">+			 * If the interrupt is running in the thread</span>
<span class="p_add">+			 * context of the parent irq we need to be</span>
<span class="p_add">+			 * careful, because we cannot trigger it</span>
<span class="p_add">+			 * directly.</span>
 			 */
<span class="p_del">-			if (desc-&gt;parent_irq &amp;&amp;</span>
<span class="p_del">-			    irq_settings_is_nested_thread(desc))</span>
<span class="p_add">+			if (irq_settings_is_nested_thread(desc)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * If the parent_irq is valid, we</span>
<span class="p_add">+				 * retrigger the parent, otherwise we</span>
<span class="p_add">+				 * do nothing.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (!desc-&gt;parent_irq)</span>
<span class="p_add">+					return;</span>
 				irq = desc-&gt;parent_irq;
<span class="p_add">+			}</span>
 			/* Set it pending and activate the softirq: */
 			set_bit(irq, irqs_resend);
 			tasklet_schedule(&amp;resend_tasklet);
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index 02bece4a99ea..eb11011b5292 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -98,6 +98,13 @@</span> <span class="p_context"> struct ftrace_pid {</span>
 	struct pid *pid;
 };
 
<span class="p_add">+static bool ftrace_pids_enabled(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !list_empty(&amp;ftrace_pids);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void ftrace_update_trampoline(struct ftrace_ops *ops);</span>
<span class="p_add">+</span>
 /*
  * ftrace_disabled is set when an anomaly is discovered.
  * ftrace_disabled is much stronger than ftrace_enabled.
<span class="p_chunk">@@ -109,7 +116,6 @@</span> <span class="p_context"> static DEFINE_MUTEX(ftrace_lock);</span>
 static struct ftrace_ops *ftrace_control_list __read_mostly = &amp;ftrace_list_end;
 static struct ftrace_ops *ftrace_ops_list __read_mostly = &amp;ftrace_list_end;
 ftrace_func_t ftrace_trace_function __read_mostly = ftrace_stub;
<span class="p_del">-ftrace_func_t ftrace_pid_function __read_mostly = ftrace_stub;</span>
 static struct ftrace_ops global_ops;
 static struct ftrace_ops control_ops;
 
<span class="p_chunk">@@ -183,14 +189,7 @@</span> <span class="p_context"> static void ftrace_pid_func(unsigned long ip, unsigned long parent_ip,</span>
 	if (!test_tsk_trace_trace(current))
 		return;
 
<span class="p_del">-	ftrace_pid_function(ip, parent_ip, op, regs);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void set_ftrace_pid_function(ftrace_func_t func)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* do not set ftrace_pid_function to itself! */</span>
<span class="p_del">-	if (func != ftrace_pid_func)</span>
<span class="p_del">-		ftrace_pid_function = func;</span>
<span class="p_add">+	op-&gt;saved_func(ip, parent_ip, op, regs);</span>
 }
 
 /**
<span class="p_chunk">@@ -202,7 +201,6 @@</span> <span class="p_context"> static void set_ftrace_pid_function(ftrace_func_t func)</span>
 void clear_ftrace_function(void)
 {
 	ftrace_trace_function = ftrace_stub;
<span class="p_del">-	ftrace_pid_function = ftrace_stub;</span>
 }
 
 static void control_ops_disable_all(struct ftrace_ops *ops)
<span class="p_chunk">@@ -436,6 +434,12 @@</span> <span class="p_context"> static int __register_ftrace_function(struct ftrace_ops *ops)</span>
 	} else
 		add_ftrace_ops(&amp;ftrace_ops_list, ops);
 
<span class="p_add">+	/* Always save the function, and reset at unregistering */</span>
<span class="p_add">+	ops-&gt;saved_func = ops-&gt;func;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ops-&gt;flags &amp; FTRACE_OPS_FL_PID &amp;&amp; ftrace_pids_enabled())</span>
<span class="p_add">+		ops-&gt;func = ftrace_pid_func;</span>
<span class="p_add">+</span>
 	ftrace_update_trampoline(ops);
 
 	if (ftrace_enabled)
<span class="p_chunk">@@ -463,15 +467,28 @@</span> <span class="p_context"> static int __unregister_ftrace_function(struct ftrace_ops *ops)</span>
 	if (ftrace_enabled)
 		update_ftrace_function();
 
<span class="p_add">+	ops-&gt;func = ops-&gt;saved_func;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
 static void ftrace_update_pid_func(void)
 {
<span class="p_add">+	bool enabled = ftrace_pids_enabled();</span>
<span class="p_add">+	struct ftrace_ops *op;</span>
<span class="p_add">+</span>
 	/* Only do something if we are tracing something */
 	if (ftrace_trace_function == ftrace_stub)
 		return;
 
<span class="p_add">+	do_for_each_ftrace_op(op, ftrace_ops_list) {</span>
<span class="p_add">+		if (op-&gt;flags &amp; FTRACE_OPS_FL_PID) {</span>
<span class="p_add">+			op-&gt;func = enabled ? ftrace_pid_func :</span>
<span class="p_add">+				op-&gt;saved_func;</span>
<span class="p_add">+			ftrace_update_trampoline(op);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while_for_each_ftrace_op(op);</span>
<span class="p_add">+</span>
 	update_ftrace_function();
 }
 
<span class="p_chunk">@@ -1133,7 +1150,8 @@</span> <span class="p_context"> static struct ftrace_ops global_ops = {</span>
 	.local_hash.filter_hash		= EMPTY_HASH,
 	INIT_OPS_HASH(global_ops)
 	.flags				= FTRACE_OPS_FL_RECURSION_SAFE |
<span class="p_del">-					  FTRACE_OPS_FL_INITIALIZED,</span>
<span class="p_add">+					  FTRACE_OPS_FL_INITIALIZED |</span>
<span class="p_add">+					  FTRACE_OPS_FL_PID,</span>
 };
 
 /*
<span class="p_chunk">@@ -5023,7 +5041,9 @@</span> <span class="p_context"> static void ftrace_update_trampoline(struct ftrace_ops *ops)</span>
 
 static struct ftrace_ops global_ops = {
 	.func			= ftrace_stub,
<span class="p_del">-	.flags			= FTRACE_OPS_FL_RECURSION_SAFE | FTRACE_OPS_FL_INITIALIZED,</span>
<span class="p_add">+	.flags			= FTRACE_OPS_FL_RECURSION_SAFE |</span>
<span class="p_add">+				  FTRACE_OPS_FL_INITIALIZED |</span>
<span class="p_add">+				  FTRACE_OPS_FL_PID,</span>
 };
 
 static int __init ftrace_nodyn_init(void)
<span class="p_chunk">@@ -5080,11 +5100,6 @@</span> <span class="p_context"> void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)</span>
 		if (WARN_ON(tr-&gt;ops-&gt;func != ftrace_stub))
 			printk(&quot;ftrace ops had %pS for function\n&quot;,
 			       tr-&gt;ops-&gt;func);
<span class="p_del">-		/* Only the top level instance does pid tracing */</span>
<span class="p_del">-		if (!list_empty(&amp;ftrace_pids)) {</span>
<span class="p_del">-			set_ftrace_pid_function(func);</span>
<span class="p_del">-			func = ftrace_pid_func;</span>
<span class="p_del">-		}</span>
 	}
 	tr-&gt;ops-&gt;func = func;
 	tr-&gt;ops-&gt;private = tr;
<span class="p_chunk">@@ -5371,7 +5386,7 @@</span> <span class="p_context"> static void *fpid_start(struct seq_file *m, loff_t *pos)</span>
 {
 	mutex_lock(&amp;ftrace_lock);
 
<span class="p_del">-	if (list_empty(&amp;ftrace_pids) &amp;&amp; (!*pos))</span>
<span class="p_add">+	if (!ftrace_pids_enabled() &amp;&amp; (!*pos))</span>
 		return (void *) 1;
 
 	return seq_list_start(&amp;ftrace_pids, *pos);
<span class="p_chunk">@@ -5610,6 +5625,7 @@</span> <span class="p_context"> static struct ftrace_ops graph_ops = {</span>
 	.func			= ftrace_stub,
 	.flags			= FTRACE_OPS_FL_RECURSION_SAFE |
 				   FTRACE_OPS_FL_INITIALIZED |
<span class="p_add">+				   FTRACE_OPS_FL_PID |</span>
 				   FTRACE_OPS_FL_STUB,
 #ifdef FTRACE_GRAPH_TRAMP_ADDR
 	.trampoline		= FTRACE_GRAPH_TRAMP_ADDR,
<span class="p_header">diff --git a/lib/dma-debug.c b/lib/dma-debug.c</span>
<span class="p_header">index ae4b65e17e64..dace71fe41f7 100644</span>
<span class="p_header">--- a/lib/dma-debug.c</span>
<span class="p_header">+++ b/lib/dma-debug.c</span>
<span class="p_chunk">@@ -574,6 +574,9 @@</span> <span class="p_context"> void debug_dma_assert_idle(struct page *page)</span>
 	unsigned long flags;
 	phys_addr_t cln;
 
<span class="p_add">+	if (dma_debug_disabled())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (!page)
 		return;
 
<span class="p_header">diff --git a/net/can/af_can.c b/net/can/af_can.c</span>
<span class="p_header">index 689c818ed007..62c635f2bcfc 100644</span>
<span class="p_header">--- a/net/can/af_can.c</span>
<span class="p_header">+++ b/net/can/af_can.c</span>
<span class="p_chunk">@@ -89,6 +89,8 @@</span> <span class="p_context"> struct timer_list can_stattimer;   /* timer for statistics update */</span>
 struct s_stats    can_stats;       /* packet statistics */
 struct s_pstats   can_pstats;      /* receive list statistics */
 
<span class="p_add">+static atomic_t skbcounter = ATOMIC_INIT(0);</span>
<span class="p_add">+</span>
 /*
  * af_can socket functions
  */
<span class="p_chunk">@@ -310,12 +312,8 @@</span> <span class="p_context"> int can_send(struct sk_buff *skb, int loop)</span>
 		return err;
 	}
 
<span class="p_del">-	if (newskb) {</span>
<span class="p_del">-		if (!(newskb-&gt;tstamp.tv64))</span>
<span class="p_del">-			__net_timestamp(newskb);</span>
<span class="p_del">-</span>
<span class="p_add">+	if (newskb)</span>
 		netif_rx_ni(newskb);
<span class="p_del">-	}</span>
 
 	/* update statistics */
 	can_stats.tx_frames++;
<span class="p_chunk">@@ -683,6 +681,10 @@</span> <span class="p_context"> static void can_receive(struct sk_buff *skb, struct net_device *dev)</span>
 	can_stats.rx_frames++;
 	can_stats.rx_frames_delta++;
 
<span class="p_add">+	/* create non-zero unique skb identifier together with *skb */</span>
<span class="p_add">+	while (!(can_skb_prv(skb)-&gt;skbcnt))</span>
<span class="p_add">+		can_skb_prv(skb)-&gt;skbcnt = atomic_inc_return(&amp;skbcounter);</span>
<span class="p_add">+</span>
 	rcu_read_lock();
 
 	/* deliver the packet to sockets listening on all devices */
<span class="p_header">diff --git a/net/can/bcm.c b/net/can/bcm.c</span>
<span class="p_header">index b523453585be..a1ba6875c2a2 100644</span>
<span class="p_header">--- a/net/can/bcm.c</span>
<span class="p_header">+++ b/net/can/bcm.c</span>
<span class="p_chunk">@@ -261,6 +261,7 @@</span> <span class="p_context"> static void bcm_can_tx(struct bcm_op *op)</span>
 
 	can_skb_reserve(skb);
 	can_skb_prv(skb)-&gt;ifindex = dev-&gt;ifindex;
<span class="p_add">+	can_skb_prv(skb)-&gt;skbcnt = 0;</span>
 
 	memcpy(skb_put(skb, CFSIZ), cf, CFSIZ);
 
<span class="p_chunk">@@ -1217,6 +1218,7 @@</span> <span class="p_context"> static int bcm_tx_send(struct msghdr *msg, int ifindex, struct sock *sk)</span>
 	}
 
 	can_skb_prv(skb)-&gt;ifindex = dev-&gt;ifindex;
<span class="p_add">+	can_skb_prv(skb)-&gt;skbcnt = 0;</span>
 	skb-&gt;dev = dev;
 	can_skb_set_owner(skb, sk);
 	err = can_send(skb, 1); /* send with loopback */
<span class="p_header">diff --git a/net/can/raw.c b/net/can/raw.c</span>
<span class="p_header">index 31b9748cbb4e..2e67b1423cd3 100644</span>
<span class="p_header">--- a/net/can/raw.c</span>
<span class="p_header">+++ b/net/can/raw.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;can-proto-1&quot;);</span>
  */
 
 struct uniqframe {
<span class="p_del">-	ktime_t tstamp;</span>
<span class="p_add">+	int skbcnt;</span>
 	const struct sk_buff *skb;
 	unsigned int join_rx_count;
 };
<span class="p_chunk">@@ -133,7 +133,7 @@</span> <span class="p_context"> static void raw_rcv(struct sk_buff *oskb, void *data)</span>
 
 	/* eliminate multiple filter matches for the same skb */
 	if (this_cpu_ptr(ro-&gt;uniq)-&gt;skb == oskb &amp;&amp;
<span class="p_del">-	    ktime_equal(this_cpu_ptr(ro-&gt;uniq)-&gt;tstamp, oskb-&gt;tstamp)) {</span>
<span class="p_add">+	    this_cpu_ptr(ro-&gt;uniq)-&gt;skbcnt == can_skb_prv(oskb)-&gt;skbcnt) {</span>
 		if (ro-&gt;join_filters) {
 			this_cpu_inc(ro-&gt;uniq-&gt;join_rx_count);
 			/* drop frame until all enabled filters matched */
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static void raw_rcv(struct sk_buff *oskb, void *data)</span>
 		}
 	} else {
 		this_cpu_ptr(ro-&gt;uniq)-&gt;skb = oskb;
<span class="p_del">-		this_cpu_ptr(ro-&gt;uniq)-&gt;tstamp = oskb-&gt;tstamp;</span>
<span class="p_add">+		this_cpu_ptr(ro-&gt;uniq)-&gt;skbcnt = can_skb_prv(oskb)-&gt;skbcnt;</span>
 		this_cpu_ptr(ro-&gt;uniq)-&gt;join_rx_count = 1;
 		/* drop first frame to check all enabled filters? */
 		if (ro-&gt;join_filters &amp;&amp; ro-&gt;count &gt; 1)
<span class="p_chunk">@@ -749,6 +749,7 @@</span> <span class="p_context"> static int raw_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)</span>
 
 	can_skb_reserve(skb);
 	can_skb_prv(skb)-&gt;ifindex = dev-&gt;ifindex;
<span class="p_add">+	can_skb_prv(skb)-&gt;skbcnt = 0;</span>
 
 	err = memcpy_from_msg(skb_put(skb, size), msg, size);
 	if (err &lt; 0)
<span class="p_header">diff --git a/net/mac80211/debugfs_netdev.c b/net/mac80211/debugfs_netdev.c</span>
<span class="p_header">index 29236e832e44..c09c0131bfa2 100644</span>
<span class="p_header">--- a/net/mac80211/debugfs_netdev.c</span>
<span class="p_header">+++ b/net/mac80211/debugfs_netdev.c</span>
<span class="p_chunk">@@ -723,6 +723,7 @@</span> <span class="p_context"> void ieee80211_debugfs_remove_netdev(struct ieee80211_sub_if_data *sdata)</span>
 
 	debugfs_remove_recursive(sdata-&gt;vif.debugfs_dir);
 	sdata-&gt;vif.debugfs_dir = NULL;
<span class="p_add">+	sdata-&gt;debugfs.subdir_stations = NULL;</span>
 }
 
 void ieee80211_debugfs_rename_netdev(struct ieee80211_sub_if_data *sdata)
<span class="p_header">diff --git a/net/rds/ib_rdma.c b/net/rds/ib_rdma.c</span>
<span class="p_header">index 273b8bff6ba4..657ba9f5d308 100644</span>
<span class="p_header">--- a/net/rds/ib_rdma.c</span>
<span class="p_header">+++ b/net/rds/ib_rdma.c</span>
<span class="p_chunk">@@ -759,8 +759,10 @@</span> <span class="p_context"> void *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,</span>
 	}
 
 	ibmr = rds_ib_alloc_fmr(rds_ibdev);
<span class="p_del">-	if (IS_ERR(ibmr))</span>
<span class="p_add">+	if (IS_ERR(ibmr)) {</span>
<span class="p_add">+		rds_ib_dev_put(rds_ibdev);</span>
 		return ibmr;
<span class="p_add">+	}</span>
 
 	ret = rds_ib_map_fmr(rds_ibdev, ibmr, sg, nents);
 	if (ret == 0)
<span class="p_header">diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c</span>
<span class="p_header">index d126c03361ae..75888dd38a7f 100644</span>
<span class="p_header">--- a/sound/core/pcm_native.c</span>
<span class="p_header">+++ b/sound/core/pcm_native.c</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static DECLARE_RWSEM(snd_pcm_link_rwsem);</span>
 void snd_pcm_stream_lock(struct snd_pcm_substream *substream)
 {
 	if (substream-&gt;pcm-&gt;nonatomic) {
<span class="p_del">-		down_read(&amp;snd_pcm_link_rwsem);</span>
<span class="p_add">+		down_read_nested(&amp;snd_pcm_link_rwsem, SINGLE_DEPTH_NESTING);</span>
 		mutex_lock(&amp;substream-&gt;self_group.mutex);
 	} else {
 		read_lock(&amp;snd_pcm_link_rwlock);
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index c403dd10d126..44dfc7b92bc3 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2056,6 +2056,8 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	/* ATI HDMI */
 	{ PCI_DEVICE(0x1002, 0x1308),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0x157a),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	{ PCI_DEVICE(0x1002, 0x793b),
 	  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },
 	{ PCI_DEVICE(0x1002, 0x7919),
<span class="p_chunk">@@ -2110,8 +2112,14 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
 	{ PCI_DEVICE(0x1002, 0xaab0),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0xaac0),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	{ PCI_DEVICE(0x1002, 0xaac8),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0xaad8),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0xaae8),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	/* VIA VT8251/VT8237A */
 	{ PCI_DEVICE(0x1106, 0x3288),
 	  .driver_data = AZX_DRIVER_VIA | AZX_DCAPS_POSFIX_VIA },
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index 5f44f60a6389..225b78b4ef12 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -3333,6 +3333,7 @@</span> <span class="p_context"> static const struct hda_codec_preset snd_hda_preset_hdmi[] = {</span>
 { .id = 0x10de0070, .name = &quot;GPU 70 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de0071, .name = &quot;GPU 71 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de0072, .name = &quot;GPU 72 HDMI/DP&quot;,	.patch = patch_nvhdmi },
<span class="p_add">+{ .id = 0x10de007d, .name = &quot;GPU 7d HDMI/DP&quot;,	.patch = patch_nvhdmi },</span>
 { .id = 0x10de8001, .name = &quot;MCP73 HDMI&quot;,	.patch = patch_nvhdmi_2ch },
 { .id = 0x11069f80, .name = &quot;VX900 HDMI/DP&quot;,	.patch = patch_via_hdmi },
 { .id = 0x11069f81, .name = &quot;VX900 HDMI/DP&quot;,	.patch = patch_via_hdmi },
<span class="p_chunk">@@ -3396,6 +3397,7 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;snd-hda-codec-id:10de0067&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de0070&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de0071&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de0072&quot;);
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:10de007d&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de8001&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:11069f80&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:11069f81&quot;);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 0e75998db39f..590bcfb0e82f 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -2224,7 +2224,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x106b, 0x4300, &quot;iMac 9,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4600, &quot;MacbookPro 5,2&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4900, &quot;iMac 9,1 Aluminum&quot;, ALC889_FIXUP_IMAC91_VREF),
<span class="p_del">-	SND_PCI_QUIRK(0x106b, 0x4a00, &quot;Macbook 5,2&quot;, ALC889_FIXUP_IMAC91_VREF),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x106b, 0x4a00, &quot;Macbook 5,2&quot;, ALC889_FIXUP_MBA11_VREF),</span>
 
 	SND_PCI_QUIRK(0x1071, 0x8258, &quot;Evesham Voyaeger&quot;, ALC882_FIXUP_EAPD),
 	SND_PCI_QUIRK(0x1462, 0x7350, &quot;MSI-7350&quot;, ALC889_FIXUP_CD),
<span class="p_chunk">@@ -5004,7 +5004,7 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{ 0x14, 0x90170110 },
 			{ 0x17, 0x40000008 },
 			{ 0x18, 0x411111f0 },
<span class="p_del">-			{ 0x19, 0x411111f0 },</span>
<span class="p_add">+			{ 0x19, 0x01a1913c },</span>
 			{ 0x1a, 0x411111f0 },
 			{ 0x1b, 0x411111f0 },
 			{ 0x1d, 0x40f89b2d },
<span class="p_chunk">@@ -5114,6 +5114,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x064a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x064b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0665, &quot;Dell XPS 13&quot;, ALC288_FIXUP_DELL_XPS_13),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x069a, &quot;Dell Vostro 5480&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),</span>
 	SND_PCI_QUIRK(0x1028, 0x06c7, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06d9, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06da, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_chunk">@@ -5382,6 +5383,17 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x1d, 0x40700001},
 		{0x21, 0x02211030}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x12, 0x40000000},</span>
<span class="p_add">+		{0x14, 0x90170130},</span>
<span class="p_add">+		{0x17, 0x411111f0},</span>
<span class="p_add">+		{0x18, 0x411111f0},</span>
<span class="p_add">+		{0x19, 0x411111f0},</span>
<span class="p_add">+		{0x1a, 0x411111f0},</span>
<span class="p_add">+		{0x1b, 0x01014020},</span>
<span class="p_add">+		{0x1d, 0x4054c029},</span>
<span class="p_add">+		{0x1e, 0x411111f0},</span>
<span class="p_add">+		{0x21, 0x0221103f}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x12, 0x90a60160},
 		{0x14, 0x90170120},
 		{0x17, 0x90170140},
<span class="p_header">diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">index 6c66d7e16439..25f0f45e6640 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_chunk">@@ -2920,7 +2920,8 @@</span> <span class="p_context"> static const struct snd_pci_quirk stac92hd83xxx_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(PCI_VENDOR_ID_HP, 0x148a,
 		      &quot;HP Mini&quot;, STAC_92HD83XXX_HP_LED),
 	SND_PCI_QUIRK_VENDOR(PCI_VENDOR_ID_HP, &quot;HP&quot;, STAC_92HD83XXX_HP),
<span class="p_del">-	SND_PCI_QUIRK(PCI_VENDOR_ID_TOSHIBA, 0xfa91,</span>
<span class="p_add">+	/* match both for 0xfa91 and 0xfa93 */</span>
<span class="p_add">+	SND_PCI_QUIRK_MASK(PCI_VENDOR_ID_TOSHIBA, 0xfffd, 0xfa91,</span>
 		      &quot;Toshiba Satellite S50D&quot;, STAC_92HD83XXX_GPIO10_EAPD),
 	{} /* terminator */
 };
<span class="p_header">diff --git a/sound/usb/line6/pcm.c b/sound/usb/line6/pcm.c</span>
<span class="p_header">index 8461d6bf992f..204cc074adb9 100644</span>
<span class="p_header">--- a/sound/usb/line6/pcm.c</span>
<span class="p_header">+++ b/sound/usb/line6/pcm.c</span>
<span class="p_chunk">@@ -186,12 +186,8 @@</span> <span class="p_context"> static int line6_stream_start(struct snd_line6_pcm *line6pcm, int direction,</span>
 	int ret = 0;
 
 	spin_lock_irqsave(&amp;pstr-&gt;lock, flags);
<span class="p_del">-	if (!test_and_set_bit(type, &amp;pstr-&gt;running)) {</span>
<span class="p_del">-		if (pstr-&gt;active_urbs || pstr-&gt;unlink_urbs) {</span>
<span class="p_del">-			ret = -EBUSY;</span>
<span class="p_del">-			goto error;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_add">+	if (!test_and_set_bit(type, &amp;pstr-&gt;running) &amp;&amp;</span>
<span class="p_add">+	    !(pstr-&gt;active_urbs || pstr-&gt;unlink_urbs)) {</span>
 		pstr-&gt;count = 0;
 		/* Submit all currently available URBs */
 		if (direction == SNDRV_PCM_STREAM_PLAYBACK)
<span class="p_chunk">@@ -199,7 +195,6 @@</span> <span class="p_context"> static int line6_stream_start(struct snd_line6_pcm *line6pcm, int direction,</span>
 		else
 			ret = line6_submit_audio_in_all_urbs(line6pcm);
 	}
<span class="p_del">- error:</span>
 	if (ret &lt; 0)
 		clear_bit(type, &amp;pstr-&gt;running);
 	spin_unlock_irqrestore(&amp;pstr-&gt;lock, flags);
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index e5000da9e9d7..6a803eff87f7 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -341,6 +341,20 @@</span> <span class="p_context"> static const struct usbmix_name_map scms_usb3318_map[] = {</span>
 	{ 0 }
 };
 
<span class="p_add">+/* Bose companion 5, the dB conversion factor is 16 instead of 256 */</span>
<span class="p_add">+static struct usbmix_dB_map bose_companion5_dB = {-5006, -6};</span>
<span class="p_add">+static struct usbmix_name_map bose_companion5_map[] = {</span>
<span class="p_add">+	{ 3, NULL, .dB = &amp;bose_companion5_dB },</span>
<span class="p_add">+	{ 0 }	/* terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Dragonfly DAC 1.2, the dB conversion factor is 1 instead of 256 */</span>
<span class="p_add">+static struct usbmix_dB_map dragonfly_1_2_dB = {0, 5000};</span>
<span class="p_add">+static struct usbmix_name_map dragonfly_1_2_map[] = {</span>
<span class="p_add">+	{ 7, NULL, .dB = &amp;dragonfly_1_2_dB },</span>
<span class="p_add">+	{ 0 }	/* terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Control map entries
  */
<span class="p_chunk">@@ -451,6 +465,16 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.id = USB_ID(0x25c4, 0x0003),
 		.map = scms_usb3318_map,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Bose Companion 5 */</span>
<span class="p_add">+		.id = USB_ID(0x05a7, 0x1020),</span>
<span class="p_add">+		.map = bose_companion5_map,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Dragonfly DAC 1.2 */</span>
<span class="p_add">+		.id = USB_ID(0x21b4, 0x0081),</span>
<span class="p_add">+		.map = dragonfly_1_2_map,</span>
<span class="p_add">+	},</span>
 	{ 0 } /* terminator */
 };
 
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index 2f6d3e9a1bcd..e4756651a52c 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -2512,6 +2512,74 @@</span> <span class="p_context"> YAMAHA_DEVICE(0x7010, &quot;UB99&quot;),</span>
 	}
 },
 
<span class="p_add">+/* Steinberg devices */</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Steinberg MI2 */</span>
<span class="p_add">+	USB_DEVICE_VENDOR_SPEC(0x0a4e, 0x2040),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp; (const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = &amp; (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 3,</span>
<span class="p_add">+				.type = QUIRK_MIDI_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp;(const struct snd_usb_midi_endpoint_info) {</span>
<span class="p_add">+					.out_cables = 0x0001,</span>
<span class="p_add">+					.in_cables  = 0x0001</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = -1</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Steinberg MI4 */</span>
<span class="p_add">+	USB_DEVICE_VENDOR_SPEC(0x0a4e, 0x4040),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp; (const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = &amp; (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 3,</span>
<span class="p_add">+				.type = QUIRK_MIDI_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp;(const struct snd_usb_midi_endpoint_info) {</span>
<span class="p_add">+					.out_cables = 0x0001,</span>
<span class="p_add">+					.in_cables  = 0x0001</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = -1</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 /* TerraTec devices */
 {
 	USB_DEVICE_VENDOR_SPEC(0x0ccd, 0x0012),
<span class="p_header">diff --git a/tools/perf/ui/browsers/hists.c b/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">index 995b7a8596b1..658b0a89796d 100644</span>
<span class="p_header">--- a/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">+++ b/tools/perf/ui/browsers/hists.c</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> static struct rb_node *hists__filter_entries(struct rb_node *nd,</span>
 
 static bool hist_browser__has_filter(struct hist_browser *hb)
 {
<span class="p_del">-	return hists__has_filter(hb-&gt;hists) || hb-&gt;min_pcnt;</span>
<span class="p_add">+	return hists__has_filter(hb-&gt;hists) || hb-&gt;min_pcnt || symbol_conf.has_filter;</span>
 }
 
 static int hist_browser__get_folding(struct hist_browser *browser)
<span class="p_header">diff --git a/tools/perf/util/symbol.c b/tools/perf/util/symbol.c</span>
<span class="p_header">index 201f6c4ca738..99378a5c57a7 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol.c</span>
<span class="p_chunk">@@ -1893,6 +1893,8 @@</span> <span class="p_context"> int setup_intlist(struct intlist **list, const char *list_str,</span>
 		pr_err(&quot;problems parsing %s list\n&quot;, list_name);
 		return -1;
 	}
<span class="p_add">+</span>
<span class="p_add">+	symbol_conf.has_filter = true;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/tools/perf/util/symbol.h b/tools/perf/util/symbol.h</span>
<span class="p_header">index 09561500164a..be0217989bcc 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol.h</span>
<span class="p_header">+++ b/tools/perf/util/symbol.h</span>
<span class="p_chunk">@@ -105,7 +105,8 @@</span> <span class="p_context"> struct symbol_conf {</span>
 			demangle_kernel,
 			filter_relative,
 			show_hist_headers,
<span class="p_del">-			branch_callstack;</span>
<span class="p_add">+			branch_callstack,</span>
<span class="p_add">+			has_filter;</span>
 	const char	*vmlinux_name,
 			*kallsyms_name,
 			*source_prefix,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



