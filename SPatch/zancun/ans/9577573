
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC,v4,28/28] x86: Add support to make use of Secure Memory Encryption - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC,v4,28/28] x86: Add support to make use of Secure Memory Encryption</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 16, 2017, 3:48 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170216154825.19244.32545.stgit@tlendack-t1.amdoffice.net&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9577573/mbox/"
   >mbox</a>
|
   <a href="/patch/9577573/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9577573/">/patch/9577573/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9670560244 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Feb 2017 15:49:02 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 85F5A2861F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Feb 2017 15:49:02 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 78AFC28621; Thu, 16 Feb 2017 15:49:02 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E0F9B2861F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Feb 2017 15:49:01 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932923AbdBPPsj (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 16 Feb 2017 10:48:39 -0500
Received: from mail-by2nam01on0066.outbound.protection.outlook.com
	([104.47.34.66]:60864
	&quot;EHLO NAM01-BY2-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S932442AbdBPPse (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 16 Feb 2017 10:48:34 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=amdcloud.onmicrosoft.com; s=selector1-amd-com;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version;
	bh=TAl4XuvmdH3weeBeVzy/CBVJUHTCJuphp43Azo5u6Bs=;
	b=gfOj/A9DPTtwEoUO1zesxLXbtWwpf29z5BMoHk+2PGAK9PB0gVf70wCKIOjh5DEaZ+6QJ7TWlPknwv/aGcYCig9Ellc5cvgd7F/SKSLXLV5IOnk6t2mJfyOl/W8uepOg+nKrHl1mHBh1+1U0FoMdb5mHCO9Mn6PQsdAGmqCg1aY=
Authentication-Results: spf=none (sender IP is )
	smtp.mailfrom=Thomas.Lendacky@amd.com; 
Received: from tlendack-t1.amdoffice.net (165.204.77.1) by
	MWHPR12MB1149.namprd12.prod.outlook.com (10.169.204.13) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384) id
	15.1.919.13; Thu, 16 Feb 2017 15:48:28 +0000
From: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
Subject: [RFC PATCH v4 28/28] x86: Add support to make use of Secure Memory
	Encryption
To: &lt;linux-arch@vger.kernel.org&gt;, &lt;linux-efi@vger.kernel.org&gt;,
	&lt;kvm@vger.kernel.org&gt;, &lt;linux-doc@vger.kernel.org&gt;,
	&lt;x86@kernel.org&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	&lt;kasan-dev@googlegroups.com&gt;, &lt;linux-mm@kvack.org&gt;,
	&lt;iommu@lists.linux-foundation.org&gt;
CC: Rik van Riel &lt;riel@redhat.com&gt;,
	Radim =?utf-8?b?S3LEjW3DocWZ?= &lt;rkrcmar@redhat.com&gt;,
	Toshimitsu Kani &lt;toshi.kani@hpe.com&gt;, Arnd Bergmann &lt;arnd@arndb.de&gt;,
	Jonathan Corbet &lt;corbet@lwn.net&gt;,
	Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	&quot;Michael S. Tsirkin&quot; &lt;mst@redhat.com&gt;, Joerg Roedel &lt;joro@8bytes.org&gt;,
	Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;,
	Paolo Bonzini &lt;pbonzini@redhat.com&gt;,
	Brijesh Singh &lt;brijesh.singh@amd.com&gt;, Ingo Molnar &lt;mingo@redhat.com&gt;,
	Alexander Potapenko &lt;glider@google.com&gt;,
	Andy Lutomirski &lt;luto@kernel.org&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;, Borislav Petkov &lt;bp@alien8.de&gt;,
	Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	Larry Woodman &lt;lwoodman@redhat.com&gt;, Dmitry Vyukov &lt;dvyukov@google.com&gt;
Date: Thu, 16 Feb 2017 09:48:25 -0600
Message-ID: &lt;20170216154825.19244.32545.stgit@tlendack-t1.amdoffice.net&gt;
In-Reply-To: &lt;20170216154158.19244.66630.stgit@tlendack-t1.amdoffice.net&gt;
References: &lt;20170216154158.19244.66630.stgit@tlendack-t1.amdoffice.net&gt;
User-Agent: StGit/0.17.1-dirty
MIME-Version: 1.0
Content-Type: text/plain; charset=&quot;utf-8&quot;
Content-Transfer-Encoding: 7bit
X-Originating-IP: [165.204.77.1]
X-ClientProxiedBy: CY1PR04CA0014.namprd04.prod.outlook.com (10.166.187.24) To
	MWHPR12MB1149.namprd12.prod.outlook.com (10.169.204.13)
X-MS-Office365-Filtering-Correlation-Id: d586611f-0c2f-4e5e-d9d7-08d456834137
X-MS-Office365-Filtering-HT: Tenant
X-Microsoft-Antispam: UriScan:; BCL:0; PCL:0; RULEID:(22001)(48565401081);
	SRVR:MWHPR12MB1149; 
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1149;
	3:uSVWZIDhHti8Y6i++B7+ANc25CJWh4/Xd6uKwh1VJPOrU3i7ziBoqnvtALYaT50AmAifM7t8DLukl28NkA3czxxrOh9t5Z09uzirOpzhix545lAW3zYNnvN6anjo2LwccQy3XV9DZ7XEWwFNsQkToEszR9+40TAwML4i/fXj7xQc2rL2e1LJErHDXT0HADWjUrrZX4oRnWNHwDjhsnNaVfSctHyd1aMAdsIrF3YvGPbx4BjHdNR/ZC5vwe6cBZFZXu+uVK1zoqLToK5HP6SD2mUgfXHXWRfHz0qRRLQi8AA=;
	25:vamZLwrJG+8YApScEQTFfmrtsti6IZG5bc++BYq++ljdeTDM05jUOOkkDbM3JraFTGHu/l1xBEL7pOWnDvH4hhJBmv0q+M/pP54VJvgbqfq4R3z6bf6fnGDFpZGEfDbT4ZxWfAPcC762SDejOY2qQS4y5EGASet95ioDoHxdIKc2u5DlmDuSMyLjzWwVBdhB5RWXc8IJFgz7ShZAjy3seqyf4MHGJpVY0Lb8luqi2mqHZC5O11SCEfQDWUVZVspNKEB5d48yQK1BhXi++aUIJNNWFaMXDwfKReiPT8piyYWdtYk51Lu1geT82w4P73sBjL5hBqk71C7BnWS0YU1N/Yzpr5RCFtgSLIZd15j3wemSCgJQhYorLKOfwLmS5vlGdvWiEY/RthXXJdg/LKNxmU4Jn6F9rM4R87xftXlczFJz+ql0K6XMZf+P0tkPQTjR8tIA/1cLIOSf/uky9Dri7A==
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1149;
	31:/gdGUueIoZMzCjdMh3lTufIUSHrS5oVrYeHHXB8AWlk6PWoqL7WMSizn/qQNPJ3B+17p6apNr89xZOJg06IL7f++1dnaNjB9RA2kYHyxj5YS4kDaxlCKi0Fs5k1DW56gMjsVDJnkPJDpVXLXLkz8UOpSoIiSbiJ8PcFPbizYJIJv5Bea9aRsEYu3rrfSQnhbDS5okSytlYzFZ0C6s4jD9lWyooJbig9jcxmo1br8RVo=;
	20:1yJVAq5zprsMbQzP+aiu/WWNrLrU2KlurJaw76OL4A5c+wjoDXO/IHIgakbEpRsohHBt1YEme35p//NtLAM57ZnLYmGIoOagTL8Mxgdze7xFmD6e2gETqBXNf7ea5ld/GChuQu6YWH8LuMWIkMxQhkP3+MNwacOB5Xgjl3HWEX1DogXgUeSFQFe5NtQcEBQr/aqXWUAhSeGf0WzVnalR2QRrw+iGFujmdlTTkwgvUr/hR10u2gSpd/XsP2n03KqZA+uAZ6s5Je1Q/RT7u0vPs3P9yWWhId9hBYpzAdCAJZ96vEoo4Ox7ei65/1nTROWO7QSLLxR+V4qBvIke/mQ5MkvYWSeeQPnRvI/KwRzhl/ojBIBi0/5fp/NG6CDovoDWOTzalCFQ2+nz4NgnvlFJJpWNbEGGYnCvlV9EypI0UhqcIvNI1u3EZkjZ0T02cy1LnrZR71gDEsxcCAImBEVpNFgpxftOmyKijNKRh+TbGFzeCWGTFVgEggzBh1U+6vum
X-Microsoft-Antispam-PRVS: &lt;MWHPR12MB1149E01651E0F3026EEE543DEC5A0@MWHPR12MB1149.namprd12.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:(767451399110);
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(6040375)(601004)(2401047)(8121501046)(5005006)(10201501046)(3002001)(6055026)(6041248)(20161123564025)(20161123560025)(20161123555025)(20161123558025)(20161123562025)(6072148);
	SRVR:MWHPR12MB1149; BCL:0; PCL:0; RULEID:; SRVR:MWHPR12MB1149;
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1149;
	4:2JJH/7kSUpQh4YdqOlmtATLfF5cbsbM1hacRwhTZMRIX+I8+mNSIwoP9L31SnVxiK+52SBKVGxCzx7LgjvboJzo8GSsornqINSEC8wvsEt5tYd5WKlGRtd/W/Eqfk2W7kuX6C7cSyOB10HJcmOPslT2kYXmUa50EZ/zR5U/JqyHp5bX9/UzMRPt1UR+HkMgjflO9tnwsGRjLKHEGdzAUG0Ro8Cdw+332NITUC8+DNSLp2vhQQBCzdIL4MsjCbEThChEP73jhS9zHWsOGtciNyS5cHKgZ1U7JmRz4HAc//8l7KJDNp9ie9TT/AaqsUm2tq26fjtkhlJ0m4H2yMbs4dmkvoIAkhAJXdu2hVIlhxultLxb0HeiBzdURVQiYzP2BMaGkAx8t9HCMIG6ttkpdujLj6sGUol9qOAdevmw0DkQj25HGpdzkKU4WydIHvuvHHVbKWzpXzsGaTxiqjsDAeNbAAw4Whukw5BP61C+KSczutCg/N8+G9JyNMK4xget8XFM+rEf8uMa0ThNsAZBRPBaSTZqTaA+MArmDjC7NzLK29NFAc02nGubQjKYpOtfiN2oRNxL7zIf44kdzXZjnWphGFkmiGfiw4BUuCIGiJk0amlleJCadL7pJxFuRr7HLCJEXjxoB7laQoU1C5bFW40E5Cwb0R4Aiq5ydhwdFiDc=
X-Forefront-PRVS: 0220D4B98D
X-Forefront-Antispam-Report: SFV:NSPM;
	SFS:(10009020)(4630300001)(6009001)(7916002)(39840400002)(39850400002)(39450400003)(39410400002)(39860400002)(199003)(189002)(92566002)(3846002)(305945005)(6506006)(5660300001)(6116002)(230700001)(8676002)(189998001)(83506001)(55016002)(54906002)(97736004)(81156014)(81166006)(7416002)(53416004)(389900003)(23676002)(4001350100001)(7736002)(42186005)(50466002)(69596002)(106356001)(38730400002)(101416001)(2950100002)(53936002)(97746001)(33646002)(6666003)(2201001)(47776003)(66066001)(103116003)(1076002)(50986999)(54356999)(25786008)(68736007)(2906002)(86362001)(76176999)(105586002)(4326007)(9686003)(71626007)(217873001);
	DIR:OUT; SFP:1101; SCL:1; SRVR:MWHPR12MB1149;
	H:tlendack-t1.amdoffice.net; FPR:; SPF:None; PTR:InfoNoRecords;
	A:1; MX:1; LANG:en; 
Received-SPF: None (protection.outlook.com: amd.com does not designate
	permitted sender hosts)
X-Microsoft-Exchange-Diagnostics: =?utf-8?B?MTtNV0hQUjEyTUIxMTQ5OzIzOmMxNjk1MFp1WUt5OThQRVdMcTRUbnhjTW1w?=
	=?utf-8?B?UWFhem9HTTJzQVVaM2hjUkJvYVhwYVBlTVBMZDQrZVMxUGZabE9GTTlyYXpl?=
	=?utf-8?B?MFdqUWFncEVGVjVmT20xNHZ0bjhPdGp6aHdISSt1Y1FSUWRlQzBuRmFCTXRy?=
	=?utf-8?B?c0tlVDhhTVowdzVkOGJjWEJ5NTJVNUtQUjNBTC9XQ3VWUXZDbVVGOVFwWWZt?=
	=?utf-8?B?ajMyOEhzUnNYNENjd2drWk1kRjBQMmV2V1BJSXhHcFRsUUQxR3RrblBkaVh3?=
	=?utf-8?B?V0gzdTFRTnJCMzRwbjduYk5yUTZma2crL1hsdmxDZlBYeG5uRFJWYng3R1Rt?=
	=?utf-8?B?d2JYWDJZSWxhWCttZk1WRmE0eFdYR1BsOFVCV1VieTA0QlBMVG1MSGJHUUtB?=
	=?utf-8?B?Z1VVcU9jMDBNVzJBV1ZwWVViK1NVdFlvS2ZpQlp0bnFuWWlkTTBHTVF4bkNE?=
	=?utf-8?B?d2dkMjVibGhoLy9WcUw2a3lyMlpXQU9qcDRKMVFxUFpNaVpxOWlFQWhxamdK?=
	=?utf-8?B?SFBROHl3T00weFAvK0R6bmlrUUZQT01DQ2xsVlg2WTN5bnJrb1hMdjVqTkQv?=
	=?utf-8?B?QVJtZFR2TjV4S3JLS3JlandKaXp4VFFoUzFudmR6SWU3T1krVVJIRWlNdmZZ?=
	=?utf-8?B?My9ZQjNWN2VENmtNM0FFaXhXMHRLanVOMnRiU1l5eWFGdWtpNk02cGlGTmwr?=
	=?utf-8?B?MWpLc2FZTXdHOWt6aEJlTmcxdVFNK3E0VTdPdDV0Q3FGVTR2aFI0ZjF0ZHhz?=
	=?utf-8?B?UHdBSmVDWWRXaENJVlBza0ExRzBnekxVRG9odmtkZkNxM1AzQXcrTTZMT3lm?=
	=?utf-8?B?N1U4STIwcitjMC9uaGh5ZlA2KytHbk9BS0xaZ3hDQkY1SXk2MDYxVlVMMnVV?=
	=?utf-8?B?cU1LWTBwZW9iWnZxeEJhazYwa2JGT1BQMDNCWkFudlVNTUtFczZkMjBjTEdi?=
	=?utf-8?B?aGVoUlZRV0h1MXY2WE85Zkt3cVkrN1BQMklHL2U2WmtPNSt1bXhBQ1RlMmha?=
	=?utf-8?B?ZHBBVEkxT1RFYlg2YWRqRk9nMVowOUs0aHRhQ2RpbUMxSjBpRDF1M3VBa09Y?=
	=?utf-8?B?TDVrNGZMYitCR0VIWDl5Y3lHVW9UdUlDdHRTU2V0Nk1mR2YxM1VMVVBQSUow?=
	=?utf-8?B?b2RRQWtuZm1KSVhyMzdBdGp0Y1N5dFFsL0VDcjU4ZkpKeTU2Z1M1R2lBcFdB?=
	=?utf-8?B?VG84RFl1Z3FQWENUSmM1NFVSY2xScnk4SWF3NkVyY1Zxd1dZUEt5SjN0VDJ1?=
	=?utf-8?B?U3hLQnRRSk51M2s3cmNzUkg0KzdzY3Q3UUJlbExsNzFhTEhzeEkxcnhxRTZC?=
	=?utf-8?B?bXE5TTJNeHdSVVBIVVRVYUdyRXlLd0FVM1B5amtkQVpBdzJFNlVzR2ZBcnBi?=
	=?utf-8?B?V21mQ1UveWZMVmN4WWd4YmdFOHRHM0dHTmg1cjZSMGZ4MjcwYndvRGdaejJw?=
	=?utf-8?B?RlUrQ2g0OXMxZ0ZZbUVESE1ZMXNtRnFaOVFqMzIyMlVzK0ZBNGl1TlNzQ1Ni?=
	=?utf-8?B?anRYcURjcWxGN2p3S3c1TlNURjJ2dk5sY2UrLysyME83UEZtUlNSdDJtNmlQ?=
	=?utf-8?B?M01DYkI3SmNCMTBhMVl5VW5pTWw5TGVNT0RnSWVlU0I1S3RWTW0rbmpsdG1w?=
	=?utf-8?B?clJaRTF4aEJXWDZvRmlVQUExODlBT2RVdnVKa2FQOXJwVk1mTlVsclRHRjhP?=
	=?utf-8?B?UlhSQWJndm9tQzNpUERHbisvbm1NNFBEMDVvbmJTZ1lWN2syN2R4RFlmQjhD?=
	=?utf-8?B?eXZQRmk2V3k1cWtSL3NXMkVBZFU3NjltZkZ4bjRYbVpKZFd3UG9UbEEyTXBq?=
	=?utf-8?B?RTZPMk5RdzY1eHBYQlhzWk9pNHhmSS9VcnRYZDFGdDBiSW9CeDNaKzdLbHNR?=
	=?utf-8?B?WUpYSVZLTjZJam1lOUpMMmppNEMxM0xtL3A1eDZVU3NlNmtWZS9nNTFhZGJY?=
	=?utf-8?B?VFJqVngranFRPT0=?=
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1149;
	6:rYaa7sKmGoiNcUW37OK5JHP3kjyh4cGEO3I2iA8BiU5GJuXoZ/N26iOu/Svz7T6Agie6qZLcay7j5nsLaFp3XQ4YIYUVo3jQcyzUDdNX8oquwnC4AijALe4SbFGP39san+Ak0oFOCo4PZI+msz1tE9t8K7VUlvSmnjgAW1jHplM5BYFcyntiqhGOqcDOZpY7hHbsXcI+EvciUjdnVJcFZegMXqigRky5bnhE0WEn1jJhbHvZ13IIPRqQQzlhBW2sD5BT6b7cfkIkmSHBgrTjIUGBo8oPY23U4IS8wrNEHErw+kP5Dt8HLASElV+t4+5+izukXBYKi4MTn5GYpv2rk6wHtHUir0ce4fqFIblc11Eie/xsbUr8K1jEmmGyezdptCbPzzFOZHBuzzmxBVQytiZa6hukW5KyXMlVs+LlKVE=;
	5:Y623z/3bVbr2zoweD48Z5FuYQ9elVfisw33sI5OtJWUPkhefugu0S6LWUK5E3yeNpAOd2cEELcnD9hKBe1ygZ9WlYoqxxpt1fnIlokWFMwYqrfLJ9mBKx1T/Jbsv4zIYCRCFsAa/RoR9C/mMqZnQKg==;
	24:Uz6ID0DAeEqOtMjF8/V3i2Rb8fvtksd2sKfISZ2vdugluSiYINpCTM7YfzjaNHMnobA2yROHd+zuWZnG/KasdSOgFe7e0Ygm0gIQRuAnRLc=
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-Microsoft-Exchange-Diagnostics: 1; MWHPR12MB1149;
	7:l3z1v2bbPHMepOty9yytDaX1rvRGEPHXISY8CcE5xEXAc99n5A/3/YI+/tvVAdR+RR0OziLElkPpb2gMut0FXCsnuqkollfBclvPK6H90rXwT/foVqpIibeXE41sL4BMwIr4DAQgBfElntYpoh+p6x0MMWnG/tnqh86pp7wETvCau6Hdhe6sPPmnvUYJlrFxbOrOhT64IS6yVJfIXeheoHFnvJTSPgvxzNHiVAoIKSWhqr+9cfOpP8v0Itx6O50G1mzlYhnIfMviEm9QjLm7pamI/Zzb0H8xgLc4CryDRJA728mJRL9IjhKlTpS6PiYSjBMdNDwu465/7L9fwdd7rw==;
	20:JFdWaBHyZNG6JXm1GRBLapMJeRYdD8TjPsD7lqvfzaLTuIWBxmzlaoTNpZcOGDHuWEGrgYhmyNNUhwD3Ewp+fsoduzrZ2K1vpNWX362xg5x2ukKZIMJmHTuK3Os2dGkTxKQD7uBfurPqIFpU7O8ckxnEUbRn5ATrxo7HNukwgLNys4g/HtpQS8mtAxy9fghi+fZRvgVhBuxzMDCZX7YSTu3HPSAv0zYpG1kdMRyF36bBt8PYQdaIqVS2/cQd9B9u
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 16 Feb 2017 15:48:28.4582
	(UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-Transport-CrossTenantHeadersStamped: MWHPR12MB1149
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - Feb. 16, 2017, 3:48 p.m.</div>
<pre class="content">
This patch adds the support to check if SME has been enabled and if
memory encryption should be activated (checking of command line option
based on the configuration of the default state).  If memory encryption
is to be activated, then the encryption mask is set and the kernel is
encrypted &quot;in place.&quot;
<span class="signed-off-by">
Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
---
 arch/x86/kernel/head_64.S          |    1 +
 arch/x86/kernel/mem_encrypt_init.c |   71 +++++++++++++++++++++++++++++++++++-
 arch/x86/mm/mem_encrypt.c          |    2 +
 3 files changed, 73 insertions(+), 1 deletion(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - March 1, 2017, 6:40 p.m.</div>
<pre class="content">
On Thu, Feb 16, 2017 at 09:48:25AM -0600, Tom Lendacky wrote:
<span class="quote">&gt; This patch adds the support to check if SME has been enabled and if</span>
<span class="quote">&gt; memory encryption should be activated (checking of command line option</span>
<span class="quote">&gt; based on the configuration of the default state).  If memory encryption</span>
<span class="quote">&gt; is to be activated, then the encryption mask is set and the kernel is</span>
<span class="quote">&gt; encrypted &quot;in place.&quot;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/kernel/head_64.S          |    1 +</span>
<span class="quote">&gt;  arch/x86/kernel/mem_encrypt_init.c |   71 +++++++++++++++++++++++++++++++++++-</span>
<span class="quote">&gt;  arch/x86/mm/mem_encrypt.c          |    2 +</span>
<span class="quote">&gt;  3 files changed, 73 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S</span>
<span class="quote">&gt; index edd2f14..e6820e7 100644</span>
<span class="quote">&gt; --- a/arch/x86/kernel/head_64.S</span>
<span class="quote">&gt; +++ b/arch/x86/kernel/head_64.S</span>
<span class="quote">&gt; @@ -97,6 +97,7 @@ startup_64:</span>
<span class="quote">&gt;  	 * Save the returned mask in %r12 for later use.</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt;  	push	%rsi</span>
<span class="quote">&gt; +	movq	%rsi, %rdi</span>
<span class="quote">&gt;  	call	sme_enable</span>
<span class="quote">&gt;  	pop	%rsi</span>
<span class="quote">&gt;  	movq	%rax, %r12</span>
<span class="quote">&gt; diff --git a/arch/x86/kernel/mem_encrypt_init.c b/arch/x86/kernel/mem_encrypt_init.c</span>
<span class="quote">&gt; index 07cbb90..35c5e3d 100644</span>
<span class="quote">&gt; --- a/arch/x86/kernel/mem_encrypt_init.c</span>
<span class="quote">&gt; +++ b/arch/x86/kernel/mem_encrypt_init.c</span>
<span class="quote">&gt; @@ -19,6 +19,12 @@</span>
<span class="quote">&gt;  #include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;asm/sections.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/processor-flags.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/msr.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/cmdline.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static char sme_cmdline_arg_on[] __initdata = &quot;mem_encrypt=on&quot;;</span>
<span class="quote">&gt; +static char sme_cmdline_arg_off[] __initdata = &quot;mem_encrypt=off&quot;;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  extern void sme_encrypt_execute(unsigned long, unsigned long, unsigned long,</span>
<span class="quote">&gt;  				void *, pgd_t *);</span>
<span class="quote">&gt; @@ -217,8 +223,71 @@ unsigned long __init sme_get_me_mask(void)</span>
<span class="quote">&gt;  	return sme_me_mask;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -unsigned long __init sme_enable(void)</span>
<span class="quote">&gt; +unsigned long __init sme_enable(void *boot_data)</span>

unsigned long __init sme_enable(struct boot_params *bp)

works too.

And then you need to correct the function signature in the
!CONFIG_AMD_MEM_ENCRYPT case, at the end of this file, too:

unsigned long __init sme_enable(struct boot_params *bp)		{ return 0; }
<span class="quote">
&gt;  {</span>
<span class="quote">&gt; +	struct boot_params *bp = boot_data;</span>
<span class="quote">&gt; +	unsigned int eax, ebx, ecx, edx;</span>
<span class="quote">&gt; +	unsigned long cmdline_ptr;</span>
<span class="quote">&gt; +	bool enable_if_found;</span>
<span class="quote">&gt; +	void *cmdline_arg;</span>
<span class="quote">&gt; +	u64 msr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Check for an AMD processor */</span>
<span class="quote">&gt; +	eax = 0;</span>
<span class="quote">&gt; +	ecx = 0;</span>
<span class="quote">&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; +	if ((ebx != 0x68747541) || (edx != 0x69746e65) || (ecx != 0x444d4163))</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Check for the SME support leaf */</span>
<span class="quote">&gt; +	eax = 0x80000000;</span>
<span class="quote">&gt; +	ecx = 0;</span>
<span class="quote">&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; +	if (eax &lt; 0x8000001f)</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Check for the SME feature:</span>
<span class="quote">&gt; +	 *   CPUID Fn8000_001F[EAX] - Bit 0</span>
<span class="quote">&gt; +	 *     Secure Memory Encryption support</span>
<span class="quote">&gt; +	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="quote">&gt; +	 *     Pagetable bit position used to indicate encryption</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	eax = 0x8000001f;</span>
<span class="quote">&gt; +	ecx = 0;</span>
<span class="quote">&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; +	if (!(eax &amp; 1))</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Check if SME is enabled */</span>
<span class="quote">&gt; +	msr = native_read_msr(MSR_K8_SYSCFG);</span>

This native_read_msr() wankery is adding this check:

	if (msr_tracepoint_active(__tracepoint_read_msr))

and here it is clearly too early for tracepoints. Please use __rdmsr()
which is purely doing the MSR operation. (... and exception handling for
when the RDMSR itself raises an exception but we&#39;re very early here too
so the MSR better be there, otherwise we&#39;ll blow up).
<span class="quote">
&gt; +	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Fixups have not been to applied phys_base yet, so we must obtain</span>

		...    not been applied to phys_base yet ...
<span class="quote">
&gt; +	 * the address to the SME command line option in the following way.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT)) {</span>
<span class="quote">&gt; +		asm (&quot;lea sme_cmdline_arg_off(%%rip), %0&quot;</span>
<span class="quote">&gt; +		     : &quot;=r&quot; (cmdline_arg)</span>
<span class="quote">&gt; +		     : &quot;p&quot; (sme_cmdline_arg_off));</span>
<span class="quote">&gt; +		enable_if_found = false;</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		asm (&quot;lea sme_cmdline_arg_on(%%rip), %0&quot;</span>
<span class="quote">&gt; +		     : &quot;=r&quot; (cmdline_arg)</span>
<span class="quote">&gt; +		     : &quot;p&quot; (sme_cmdline_arg_on));</span>
<span class="quote">&gt; +		enable_if_found = true;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cmdline_ptr = bp-&gt;hdr.cmd_line_ptr | ((u64)bp-&gt;ext_cmd_line_ptr &lt;&lt; 32);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (cmdline_find_option_bool((char *)cmdline_ptr, cmdline_arg))</span>
<span class="quote">&gt; +		sme_me_mask = enable_if_found ? 1UL &lt;&lt; (ebx &amp; 0x3f) : 0;</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		sme_me_mask = enable_if_found ? 0 : 1UL &lt;&lt; (ebx &amp; 0x3f);</span>

I have a better idea: you can copy __cmdline_find_option() +
cmdline_find_option() to arch/x86/lib/cmdline.c in a pre-patch. Then,
pass in a buffer and check for &quot;on&quot; and &quot;off&quot;. This way you don&#39;t
have to misuse the _bool() variant for something which is actually
&quot;option=argument&quot;.

Thanks.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - March 7, 2017, 4:05 p.m.</div>
<pre class="content">
On 3/1/2017 12:40 PM, Borislav Petkov wrote:
<span class="quote">&gt; On Thu, Feb 16, 2017 at 09:48:25AM -0600, Tom Lendacky wrote:</span>
<span class="quote">&gt;&gt; This patch adds the support to check if SME has been enabled and if</span>
<span class="quote">&gt;&gt; memory encryption should be activated (checking of command line option</span>
<span class="quote">&gt;&gt; based on the configuration of the default state).  If memory encryption</span>
<span class="quote">&gt;&gt; is to be activated, then the encryption mask is set and the kernel is</span>
<span class="quote">&gt;&gt; encrypted &quot;in place.&quot;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  arch/x86/kernel/head_64.S          |    1 +</span>
<span class="quote">&gt;&gt;  arch/x86/kernel/mem_encrypt_init.c |   71 +++++++++++++++++++++++++++++++++++-</span>
<span class="quote">&gt;&gt;  arch/x86/mm/mem_encrypt.c          |    2 +</span>
<span class="quote">&gt;&gt;  3 files changed, 73 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S</span>
<span class="quote">&gt;&gt; index edd2f14..e6820e7 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/kernel/head_64.S</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/kernel/head_64.S</span>
<span class="quote">&gt;&gt; @@ -97,6 +97,7 @@ startup_64:</span>
<span class="quote">&gt;&gt;  	 * Save the returned mask in %r12 for later use.</span>
<span class="quote">&gt;&gt;  	 */</span>
<span class="quote">&gt;&gt;  	push	%rsi</span>
<span class="quote">&gt;&gt; +	movq	%rsi, %rdi</span>
<span class="quote">&gt;&gt;  	call	sme_enable</span>
<span class="quote">&gt;&gt;  	pop	%rsi</span>
<span class="quote">&gt;&gt;  	movq	%rax, %r12</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/kernel/mem_encrypt_init.c b/arch/x86/kernel/mem_encrypt_init.c</span>
<span class="quote">&gt;&gt; index 07cbb90..35c5e3d 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/kernel/mem_encrypt_init.c</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/kernel/mem_encrypt_init.c</span>
<span class="quote">&gt;&gt; @@ -19,6 +19,12 @@</span>
<span class="quote">&gt;&gt;  #include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/sections.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/processor-flags.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/msr.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/cmdline.h&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static char sme_cmdline_arg_on[] __initdata = &quot;mem_encrypt=on&quot;;</span>
<span class="quote">&gt;&gt; +static char sme_cmdline_arg_off[] __initdata = &quot;mem_encrypt=off&quot;;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  extern void sme_encrypt_execute(unsigned long, unsigned long, unsigned long,</span>
<span class="quote">&gt;&gt;  				void *, pgd_t *);</span>
<span class="quote">&gt;&gt; @@ -217,8 +223,71 @@ unsigned long __init sme_get_me_mask(void)</span>
<span class="quote">&gt;&gt;  	return sme_me_mask;</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; -unsigned long __init sme_enable(void)</span>
<span class="quote">&gt;&gt; +unsigned long __init sme_enable(void *boot_data)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; unsigned long __init sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; works too.</span>

Ok, will do.
<span class="quote">
&gt;</span>
<span class="quote">&gt; And then you need to correct the function signature in the</span>
<span class="quote">&gt; !CONFIG_AMD_MEM_ENCRYPT case, at the end of this file, too:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; unsigned long __init sme_enable(struct boot_params *bp)		{ return 0; }</span>

Yup, missed that.  I&#39;ll make it match.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt; +	struct boot_params *bp = boot_data;</span>
<span class="quote">&gt;&gt; +	unsigned int eax, ebx, ecx, edx;</span>
<span class="quote">&gt;&gt; +	unsigned long cmdline_ptr;</span>
<span class="quote">&gt;&gt; +	bool enable_if_found;</span>
<span class="quote">&gt;&gt; +	void *cmdline_arg;</span>
<span class="quote">&gt;&gt; +	u64 msr;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Check for an AMD processor */</span>
<span class="quote">&gt;&gt; +	eax = 0;</span>
<span class="quote">&gt;&gt; +	ecx = 0;</span>
<span class="quote">&gt;&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt;&gt; +	if ((ebx != 0x68747541) || (edx != 0x69746e65) || (ecx != 0x444d4163))</span>
<span class="quote">&gt;&gt; +		goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Check for the SME support leaf */</span>
<span class="quote">&gt;&gt; +	eax = 0x80000000;</span>
<span class="quote">&gt;&gt; +	ecx = 0;</span>
<span class="quote">&gt;&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt;&gt; +	if (eax &lt; 0x8000001f)</span>
<span class="quote">&gt;&gt; +		goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Check for the SME feature:</span>
<span class="quote">&gt;&gt; +	 *   CPUID Fn8000_001F[EAX] - Bit 0</span>
<span class="quote">&gt;&gt; +	 *     Secure Memory Encryption support</span>
<span class="quote">&gt;&gt; +	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="quote">&gt;&gt; +	 *     Pagetable bit position used to indicate encryption</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt; +	eax = 0x8000001f;</span>
<span class="quote">&gt;&gt; +	ecx = 0;</span>
<span class="quote">&gt;&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt;&gt; +	if (!(eax &amp; 1))</span>
<span class="quote">&gt;&gt; +		goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Check if SME is enabled */</span>
<span class="quote">&gt;&gt; +	msr = native_read_msr(MSR_K8_SYSCFG);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This native_read_msr() wankery is adding this check:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 	if (msr_tracepoint_active(__tracepoint_read_msr))</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; and here it is clearly too early for tracepoints. Please use __rdmsr()</span>
<span class="quote">&gt; which is purely doing the MSR operation. (... and exception handling for</span>

Ah, good catch.  I&#39;ll switch to __rdmsr().
<span class="quote">
&gt; when the RDMSR itself raises an exception but we&#39;re very early here too</span>
<span class="quote">&gt; so the MSR better be there, otherwise we&#39;ll blow up).</span>

Yes, it will be there if SME support is indicated in the CPUID result.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="quote">&gt;&gt; +		goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Fixups have not been to applied phys_base yet, so we must obtain</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 		...    not been applied to phys_base yet ...</span>

Yup.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	 * the address to the SME command line option in the following way.</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt; +	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT)) {</span>
<span class="quote">&gt;&gt; +		asm (&quot;lea sme_cmdline_arg_off(%%rip), %0&quot;</span>
<span class="quote">&gt;&gt; +		     : &quot;=r&quot; (cmdline_arg)</span>
<span class="quote">&gt;&gt; +		     : &quot;p&quot; (sme_cmdline_arg_off));</span>
<span class="quote">&gt;&gt; +		enable_if_found = false;</span>
<span class="quote">&gt;&gt; +	} else {</span>
<span class="quote">&gt;&gt; +		asm (&quot;lea sme_cmdline_arg_on(%%rip), %0&quot;</span>
<span class="quote">&gt;&gt; +		     : &quot;=r&quot; (cmdline_arg)</span>
<span class="quote">&gt;&gt; +		     : &quot;p&quot; (sme_cmdline_arg_on));</span>
<span class="quote">&gt;&gt; +		enable_if_found = true;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	cmdline_ptr = bp-&gt;hdr.cmd_line_ptr | ((u64)bp-&gt;ext_cmd_line_ptr &lt;&lt; 32);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (cmdline_find_option_bool((char *)cmdline_ptr, cmdline_arg))</span>
<span class="quote">&gt;&gt; +		sme_me_mask = enable_if_found ? 1UL &lt;&lt; (ebx &amp; 0x3f) : 0;</span>
<span class="quote">&gt;&gt; +	else</span>
<span class="quote">&gt;&gt; +		sme_me_mask = enable_if_found ? 0 : 1UL &lt;&lt; (ebx &amp; 0x3f);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I have a better idea: you can copy __cmdline_find_option() +</span>
<span class="quote">&gt; cmdline_find_option() to arch/x86/lib/cmdline.c in a pre-patch. Then,</span>
<span class="quote">&gt; pass in a buffer and check for &quot;on&quot; and &quot;off&quot;. This way you don&#39;t</span>
<span class="quote">&gt; have to misuse the _bool() variant for something which is actually</span>
<span class="quote">&gt; &quot;option=argument&quot;.</span>

I can do that.  Because phys_base hasn&#39;t been updated yet, I&#39;ll have to
create &quot;on&quot; and &quot;off&quot; constants and get their address in a similar way
to the command line option so that I can do the strncmp properly.

Thanks,
Tom
<span class="quote">
&gt;</span>
<span class="quote">&gt; Thanks.</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - March 7, 2017, 5:42 p.m.</div>
<pre class="content">
On Tue, Mar 07, 2017 at 10:05:00AM -0600, Tom Lendacky wrote:
<span class="quote">&gt; I can do that.  Because phys_base hasn&#39;t been updated yet, I&#39;ll have to</span>
<span class="quote">&gt; create &quot;on&quot; and &quot;off&quot; constants and get their address in a similar way</span>
<span class="quote">&gt; to the command line option so that I can do the strncmp properly.</span>

Actually, wouldn&#39;t it be simpler to inspect the passed in buffer for
containing the chars &#39;o&#39;, &#39;n&#39; - in that order, or &#39;o&#39;, &#39;f&#39;, &#39;f&#39; - in
that order too? Because __cmdline_find_option() does copy the option
characters into the buffer.

Then you wouldn&#39;t need those &quot;on&quot; and &quot;off&quot; constants...
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - March 8, 2017, 3:05 p.m.</div>
<pre class="content">
On Tue, Mar 07, 2017 at 10:05:00AM -0600, Tom Lendacky wrote:
<span class="quote">&gt; &gt; And then you need to correct the function signature in the</span>
<span class="quote">&gt; &gt; !CONFIG_AMD_MEM_ENCRYPT case, at the end of this file, too:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; unsigned long __init sme_enable(struct boot_params *bp)		{ return 0; }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yup, missed that.  I&#39;ll make it match.</span>

Or, you can do this:

unsigned long __init sme_enable(void *boot_data)
{
#ifdef CONFIG_AMD_MEM_ENCRYPT
        struct boot_params *bp = boot_data;
        unsigned int eax, ebx, ecx, edx;
        unsigned long cmdline_ptr;

	...

out:
#endif /* CONFIG_AMD_MEM_ENCRYPT */
        return sme_me_mask;
}

and never worry for function headers going out of whack.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S</span>
<span class="p_header">index edd2f14..e6820e7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/head_64.S</span>
<span class="p_chunk">@@ -97,6 +97,7 @@</span> <span class="p_context"> startup_64:</span>
 	 * Save the returned mask in %r12 for later use.
 	 */
 	push	%rsi
<span class="p_add">+	movq	%rsi, %rdi</span>
 	call	sme_enable
 	pop	%rsi
 	movq	%rax, %r12
<span class="p_header">diff --git a/arch/x86/kernel/mem_encrypt_init.c b/arch/x86/kernel/mem_encrypt_init.c</span>
<span class="p_header">index 07cbb90..35c5e3d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/mem_encrypt_init.c</span>
<span class="p_header">+++ b/arch/x86/kernel/mem_encrypt_init.c</span>
<span class="p_chunk">@@ -19,6 +19,12 @@</span> <span class="p_context"></span>
 #include &lt;linux/mm.h&gt;
 
 #include &lt;asm/sections.h&gt;
<span class="p_add">+#include &lt;asm/processor-flags.h&gt;</span>
<span class="p_add">+#include &lt;asm/msr.h&gt;</span>
<span class="p_add">+#include &lt;asm/cmdline.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static char sme_cmdline_arg_on[] __initdata = &quot;mem_encrypt=on&quot;;</span>
<span class="p_add">+static char sme_cmdline_arg_off[] __initdata = &quot;mem_encrypt=off&quot;;</span>
 
 extern void sme_encrypt_execute(unsigned long, unsigned long, unsigned long,
 				void *, pgd_t *);
<span class="p_chunk">@@ -217,8 +223,71 @@</span> <span class="p_context"> unsigned long __init sme_get_me_mask(void)</span>
 	return sme_me_mask;
 }
 
<span class="p_del">-unsigned long __init sme_enable(void)</span>
<span class="p_add">+unsigned long __init sme_enable(void *boot_data)</span>
 {
<span class="p_add">+	struct boot_params *bp = boot_data;</span>
<span class="p_add">+	unsigned int eax, ebx, ecx, edx;</span>
<span class="p_add">+	unsigned long cmdline_ptr;</span>
<span class="p_add">+	bool enable_if_found;</span>
<span class="p_add">+	void *cmdline_arg;</span>
<span class="p_add">+	u64 msr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check for an AMD processor */</span>
<span class="p_add">+	eax = 0;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	if ((ebx != 0x68747541) || (edx != 0x69746e65) || (ecx != 0x444d4163))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check for the SME support leaf */</span>
<span class="p_add">+	eax = 0x80000000;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	if (eax &lt; 0x8000001f)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for the SME feature:</span>
<span class="p_add">+	 *   CPUID Fn8000_001F[EAX] - Bit 0</span>
<span class="p_add">+	 *     Secure Memory Encryption support</span>
<span class="p_add">+	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="p_add">+	 *     Pagetable bit position used to indicate encryption</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	eax = 0x8000001f;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	if (!(eax &amp; 1))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if SME is enabled */</span>
<span class="p_add">+	msr = native_read_msr(MSR_K8_SYSCFG);</span>
<span class="p_add">+	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fixups have not been to applied phys_base yet, so we must obtain</span>
<span class="p_add">+	 * the address to the SME command line option in the following way.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT)) {</span>
<span class="p_add">+		asm (&quot;lea sme_cmdline_arg_off(%%rip), %0&quot;</span>
<span class="p_add">+		     : &quot;=r&quot; (cmdline_arg)</span>
<span class="p_add">+		     : &quot;p&quot; (sme_cmdline_arg_off));</span>
<span class="p_add">+		enable_if_found = false;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		asm (&quot;lea sme_cmdline_arg_on(%%rip), %0&quot;</span>
<span class="p_add">+		     : &quot;=r&quot; (cmdline_arg)</span>
<span class="p_add">+		     : &quot;p&quot; (sme_cmdline_arg_on));</span>
<span class="p_add">+		enable_if_found = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cmdline_ptr = bp-&gt;hdr.cmd_line_ptr | ((u64)bp-&gt;ext_cmd_line_ptr &lt;&lt; 32);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cmdline_find_option_bool((char *)cmdline_ptr, cmdline_arg))</span>
<span class="p_add">+		sme_me_mask = enable_if_found ? 1UL &lt;&lt; (ebx &amp; 0x3f) : 0;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sme_me_mask = enable_if_found ? 0 : 1UL &lt;&lt; (ebx &amp; 0x3f);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
 	return sme_me_mask;
 }
 
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">index a46bcf4..c5062e1 100644</span>
<span class="p_header">--- a/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_chunk">@@ -204,6 +204,8 @@</span> <span class="p_context"> void __init mem_encrypt_init(void)</span>
 
 	/* Call into SWIOTLB to update the SWIOTLB DMA buffers */
 	swiotlb_update_mem_attributes();
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;AMD Secure Memory Encryption (SME) active\n&quot;);</span>
 }
 
 void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



