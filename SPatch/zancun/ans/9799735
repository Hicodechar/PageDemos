
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>mm: Refactor conversion of pages to bytes macro definitions - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    mm: Refactor conversion of pages to bytes macro definitions</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=172675">Nikolay Borisov</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 20, 2017, 3:14 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1497971668-30685-1-git-send-email-nborisov@suse.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9799735/mbox/"
   >mbox</a>
|
   <a href="/patch/9799735/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9799735/">/patch/9799735/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	3941360328 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 20 Jun 2017 15:15:03 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 17E9C27968
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 20 Jun 2017 15:15:03 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 0A8F42849E; Tue, 20 Jun 2017 15:15:03 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C5A6727968
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 20 Jun 2017 15:15:01 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752025AbdFTPO6 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 20 Jun 2017 11:14:58 -0400
Received: from mx2.suse.de ([195.135.220.15]:53174 &quot;EHLO mx1.suse.de&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1751135AbdFTPOv (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 20 Jun 2017 11:14:51 -0400
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay1.suse.de (charybdis-ext.suse.de [195.135.220.254])
	by mx1.suse.de (Postfix) with ESMTP id E9468AAB6;
	Tue, 20 Jun 2017 15:14:48 +0000 (UTC)
From: Nikolay Borisov &lt;nborisov@suse.com&gt;
To: linux-mm@kvack.org
Cc: mgorman@techsingularity.net, cmetcalf@mellanox.com,
	minchan@kernel.org, vbabka@suse.cz, mhocko@kernel.org,
	kirill.shutemov@linux.intel.com, tj@kernel.org,
	cgroups@vger.kernel.org, linux-kernel@vger.kernel.org,
	Nikolay Borisov &lt;nborisov@suse.com&gt;
Subject: [PATCH] mm: Refactor conversion of pages to bytes macro definitions
Date: Tue, 20 Jun 2017 18:14:28 +0300
Message-Id: &lt;1497971668-30685-1-git-send-email-nborisov@suse.com&gt;
X-Mailer: git-send-email 2.7.4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=172675">Nikolay Borisov</a> - June 20, 2017, 3:14 p.m.</div>
<pre class="content">
Currently there are a multiple files with the following code:
 #define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))
 ... some code..
 #undef K

This is mainly used to print out some memory-related statistics, where X is
given in pages and the macro just converts it to kilobytes. In the future
there is going to be more macros since there are intention to introduce
byte-based memory counters [1]. This could lead to proliferation of
multiple duplicated definition of various macros used to convert a quantity
from one unit to another. Let&#39;s try and consolidate such definition in the
mm.h header since currently it&#39;s being included in all files which exhibit
this pattern. Also let&#39;s rename it to something a bit more verbose.

This patch doesn&#39;t introduce any functional changes

[1] https://patchwork.kernel.org/patch/9395205/
<span class="signed-off-by">
Signed-off-by: Nikolay Borisov &lt;nborisov@suse.com&gt;</span>
---
 arch/tile/mm/pgtable.c      |  2 --
 drivers/base/node.c         | 66 ++++++++++++++++++-------------------
 include/linux/mm.h          |  2 ++
 kernel/debug/kdb/kdb_main.c |  3 +-
 mm/backing-dev.c            | 22 +++++--------
 mm/memcontrol.c             | 17 +++++-----
 mm/oom_kill.c               | 19 +++++------
 mm/page_alloc.c             | 80 ++++++++++++++++++++++-----------------------
 8 files changed, 100 insertions(+), 111 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - June 22, 2017, 6:44 a.m.</div>
<pre class="content">
On Tue 20-06-17 18:14:28, Nikolay Borisov wrote:
<span class="quote">&gt; Currently there are a multiple files with the following code:</span>
<span class="quote">&gt;  #define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt;  ... some code..</span>
<span class="quote">&gt;  #undef K</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is mainly used to print out some memory-related statistics, where X is</span>
<span class="quote">&gt; given in pages and the macro just converts it to kilobytes. In the future</span>
<span class="quote">&gt; there is going to be more macros since there are intention to introduce</span>
<span class="quote">&gt; byte-based memory counters [1]. This could lead to proliferation of</span>
<span class="quote">&gt; multiple duplicated definition of various macros used to convert a quantity</span>
<span class="quote">&gt; from one unit to another. Let&#39;s try and consolidate such definition in the</span>
<span class="quote">&gt; mm.h header since currently it&#39;s being included in all files which exhibit</span>
<span class="quote">&gt; this pattern. Also let&#39;s rename it to something a bit more verbose.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This patch doesn&#39;t introduce any functional changes</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [1] https://patchwork.kernel.org/patch/9395205/</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Nikolay Borisov &lt;nborisov@suse.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/tile/mm/pgtable.c      |  2 --</span>
<span class="quote">&gt;  drivers/base/node.c         | 66 ++++++++++++++++++-------------------</span>
<span class="quote">&gt;  include/linux/mm.h          |  2 ++</span>
<span class="quote">&gt;  kernel/debug/kdb/kdb_main.c |  3 +-</span>
<span class="quote">&gt;  mm/backing-dev.c            | 22 +++++--------</span>
<span class="quote">&gt;  mm/memcontrol.c             | 17 +++++-----</span>
<span class="quote">&gt;  mm/oom_kill.c               | 19 +++++------</span>
<span class="quote">&gt;  mm/page_alloc.c             | 80 ++++++++++++++++++++++-----------------------</span>
<span class="quote">&gt;  8 files changed, 100 insertions(+), 111 deletions(-)</span>

Those macros are quite trivial and we do not really save much code while
this touches a lot of code potentially causing some conflicts. So do we
really need this? I am usually very keen on removing duplication but
this doesn&#39;t seem to be worth all the troubles IMHO.
<span class="quote">
&gt; </span>
<span class="quote">&gt; diff --git a/arch/tile/mm/pgtable.c b/arch/tile/mm/pgtable.c</span>
<span class="quote">&gt; index 492a7361e58e..f04af570c1c2 100644</span>
<span class="quote">&gt; --- a/arch/tile/mm/pgtable.c</span>
<span class="quote">&gt; +++ b/arch/tile/mm/pgtable.c</span>
<span class="quote">&gt; @@ -34,8 +34,6 @@</span>
<span class="quote">&gt;  #include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/homecache.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  /**</span>
<span class="quote">&gt;   * shatter_huge_page() - ensure a given address is mapped by a small page.</span>
<span class="quote">&gt;   *</span>
<span class="quote">&gt; diff --git a/drivers/base/node.c b/drivers/base/node.c</span>
<span class="quote">&gt; index 5548f9686016..b6f563a3a3a9 100644</span>
<span class="quote">&gt; --- a/drivers/base/node.c</span>
<span class="quote">&gt; +++ b/drivers/base/node.c</span>
<span class="quote">&gt; @@ -50,7 +50,6 @@ static inline ssize_t node_read_cpulist(struct device *dev,</span>
<span class="quote">&gt;  static DEVICE_ATTR(cpumap,  S_IRUGO, node_read_cpumask, NULL);</span>
<span class="quote">&gt;  static DEVICE_ATTR(cpulist, S_IRUGO, node_read_cpulist, NULL);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt;  static ssize_t node_read_meminfo(struct device *dev,</span>
<span class="quote">&gt;  			struct device_attribute *attr, char *buf)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; @@ -72,19 +71,19 @@ static ssize_t node_read_meminfo(struct device *dev,</span>
<span class="quote">&gt;  		       &quot;Node %d Inactive(file): %8lu kB\n&quot;</span>
<span class="quote">&gt;  		       &quot;Node %d Unevictable:    %8lu kB\n&quot;</span>
<span class="quote">&gt;  		       &quot;Node %d Mlocked:        %8lu kB\n&quot;,</span>
<span class="quote">&gt; -		       nid, K(i.totalram),</span>
<span class="quote">&gt; -		       nid, K(i.freeram),</span>
<span class="quote">&gt; -		       nid, K(i.totalram - i.freeram),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_ACTIVE_ANON) +</span>
<span class="quote">&gt; +		       nid, PtoK(i.totalram),</span>
<span class="quote">&gt; +		       nid, PtoK(i.freeram),</span>
<span class="quote">&gt; +		       nid, PtoK(i.totalram - i.freeram),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_ACTIVE_ANON) +</span>
<span class="quote">&gt;  				node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_INACTIVE_ANON) +</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_INACTIVE_ANON) +</span>
<span class="quote">&gt;  				node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="quote">&gt; -		       nid, K(sum_zone_node_page_state(nid, NR_MLOCK)));</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="quote">&gt; +		       nid, PtoK(sum_zone_node_page_state(nid, NR_MLOCK)));</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #ifdef CONFIG_HIGHMEM</span>
<span class="quote">&gt;  	n += sprintf(buf + n,</span>
<span class="quote">&gt; @@ -92,10 +91,10 @@ static ssize_t node_read_meminfo(struct device *dev,</span>
<span class="quote">&gt;  		       &quot;Node %d HighFree:       %8lu kB\n&quot;</span>
<span class="quote">&gt;  		       &quot;Node %d LowTotal:       %8lu kB\n&quot;</span>
<span class="quote">&gt;  		       &quot;Node %d LowFree:        %8lu kB\n&quot;,</span>
<span class="quote">&gt; -		       nid, K(i.totalhigh),</span>
<span class="quote">&gt; -		       nid, K(i.freehigh),</span>
<span class="quote">&gt; -		       nid, K(i.totalram - i.totalhigh),</span>
<span class="quote">&gt; -		       nid, K(i.freeram - i.freehigh));</span>
<span class="quote">&gt; +		       nid, PtoK(i.totalhigh),</span>
<span class="quote">&gt; +		       nid, PtoK(i.freehigh),</span>
<span class="quote">&gt; +		       nid, PtoK(i.totalram - i.totalhigh),</span>
<span class="quote">&gt; +		       nid, PtoK(i.freeram - i.freehigh));</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  	n += sprintf(buf + n,</span>
<span class="quote">&gt;  		       &quot;Node %d Dirty:          %8lu kB\n&quot;</span>
<span class="quote">&gt; @@ -118,36 +117,35 @@ static ssize_t node_read_meminfo(struct device *dev,</span>
<span class="quote">&gt;  		       &quot;Node %d ShmemPmdMapped: %8lu kB\n&quot;</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  			,</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_WRITEBACK)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_FILE_PAGES)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_ANON_MAPPED)),</span>
<span class="quote">&gt; -		       nid, K(i.sharedram),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_WRITEBACK)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_FILE_PAGES)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_ANON_MAPPED)),</span>
<span class="quote">&gt; +		       nid, PtoK(i.sharedram),</span>
<span class="quote">&gt;  		       nid, sum_zone_node_page_state(nid, NR_KERNEL_STACK_KB),</span>
<span class="quote">&gt; -		       nid, K(sum_zone_node_page_state(nid, NR_PAGETABLE)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
<span class="quote">&gt; -		       nid, K(sum_zone_node_page_state(nid, NR_BOUNCE)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="quote">&gt; -		       nid, K(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE) +</span>
<span class="quote">&gt; +		       nid, PtoK(sum_zone_node_page_state(nid, NR_PAGETABLE)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
<span class="quote">&gt; +		       nid, PtoK(sum_zone_node_page_state(nid, NR_BOUNCE)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="quote">&gt; +		       nid, PtoK(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE) +</span>
<span class="quote">&gt;  				sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="quote">&gt; -		       nid, K(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE)),</span>
<span class="quote">&gt; +		       nid, PtoK(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE)),</span>
<span class="quote">&gt;  #ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="quote">&gt; -		       nid, K(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_ANON_THPS) *</span>
<span class="quote">&gt; +		       nid, PtoK(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_ANON_THPS) *</span>
<span class="quote">&gt;  				       HPAGE_PMD_NR),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_SHMEM_THPS) *</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_SHMEM_THPS) *</span>
<span class="quote">&gt;  				       HPAGE_PMD_NR),</span>
<span class="quote">&gt; -		       nid, K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED) *</span>
<span class="quote">&gt; +		       nid, PtoK(node_page_state(pgdat, NR_SHMEM_PMDMAPPED) *</span>
<span class="quote">&gt;  				       HPAGE_PMD_NR));</span>
<span class="quote">&gt;  #else</span>
<span class="quote">&gt; -		       nid, K(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)));</span>
<span class="quote">&gt; +		       nid, PtoK(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)));</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  	n += hugetlb_report_node_meminfo(nid, buf + n);</span>
<span class="quote">&gt;  	return n;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#undef K</span>
<span class="quote">&gt;  static DEVICE_ATTR(meminfo, S_IRUGO, node_read_meminfo, NULL);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static ssize_t node_read_numastat(struct device *dev,</span>
<span class="quote">&gt; diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="quote">&gt; index 6f543a47fc92..d8d80e2e9194 100644</span>
<span class="quote">&gt; --- a/include/linux/mm.h</span>
<span class="quote">&gt; +++ b/include/linux/mm.h</span>
<span class="quote">&gt; @@ -93,6 +93,8 @@ extern int mmap_rnd_compat_bits __read_mostly;</span>
<span class="quote">&gt;  #define mm_forbids_zeropage(X)	(0)</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#define PtoK(pages) ((pages) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Default maximum number of active map areas, this limits the number of vmas</span>
<span class="quote">&gt;   * per mm struct. Users can overwrite this number by sysctl but there is a</span>
<span class="quote">&gt; diff --git a/kernel/debug/kdb/kdb_main.c b/kernel/debug/kdb/kdb_main.c</span>
<span class="quote">&gt; index c8146d53ca67..e833cb02d2c8 100644</span>
<span class="quote">&gt; --- a/kernel/debug/kdb/kdb_main.c</span>
<span class="quote">&gt; +++ b/kernel/debug/kdb/kdb_main.c</span>
<span class="quote">&gt; @@ -2582,10 +2582,9 @@ static int kdb_summary(int argc, const char **argv)</span>
<span class="quote">&gt;  #undef LOAD_INT</span>
<span class="quote">&gt;  #undef LOAD_FRAC</span>
<span class="quote">&gt;  	/* Display in kilobytes */</span>
<span class="quote">&gt; -#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt;  	kdb_printf(&quot;\nMemTotal:       %8lu kB\nMemFree:        %8lu kB\n&quot;</span>
<span class="quote">&gt;  		   &quot;Buffers:        %8lu kB\n&quot;,</span>
<span class="quote">&gt; -		   K(val.totalram), K(val.freeram), K(val.bufferram));</span>
<span class="quote">&gt; +		   PtoK(val.totalram), PtoK(val.freeram), PtoK(val.bufferram));</span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="quote">&gt; index f028a9a472fd..0c09dd103109 100644</span>
<span class="quote">&gt; --- a/mm/backing-dev.c</span>
<span class="quote">&gt; +++ b/mm/backing-dev.c</span>
<span class="quote">&gt; @@ -67,7 +67,6 @@ static int bdi_debug_stats_show(struct seq_file *m, void *v)</span>
<span class="quote">&gt;  	global_dirty_limits(&amp;background_thresh, &amp;dirty_thresh);</span>
<span class="quote">&gt;  	wb_thresh = wb_calc_thresh(wb, dirty_thresh);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt;  	seq_printf(m,</span>
<span class="quote">&gt;  		   &quot;BdiWriteback:       %10lu kB\n&quot;</span>
<span class="quote">&gt;  		   &quot;BdiReclaimable:     %10lu kB\n&quot;</span>
<span class="quote">&gt; @@ -83,20 +82,19 @@ static int bdi_debug_stats_show(struct seq_file *m, void *v)</span>
<span class="quote">&gt;  		   &quot;b_dirty_time:       %10lu\n&quot;</span>
<span class="quote">&gt;  		   &quot;bdi_list:           %10u\n&quot;</span>
<span class="quote">&gt;  		   &quot;state:              %10lx\n&quot;,</span>
<span class="quote">&gt; -		   (unsigned long) K(wb_stat(wb, WB_WRITEBACK)),</span>
<span class="quote">&gt; -		   (unsigned long) K(wb_stat(wb, WB_RECLAIMABLE)),</span>
<span class="quote">&gt; -		   K(wb_thresh),</span>
<span class="quote">&gt; -		   K(dirty_thresh),</span>
<span class="quote">&gt; -		   K(background_thresh),</span>
<span class="quote">&gt; -		   (unsigned long) K(wb_stat(wb, WB_DIRTIED)),</span>
<span class="quote">&gt; -		   (unsigned long) K(wb_stat(wb, WB_WRITTEN)),</span>
<span class="quote">&gt; -		   (unsigned long) K(wb-&gt;write_bandwidth),</span>
<span class="quote">&gt; +		   (unsigned long) PtoK(wb_stat(wb, WB_WRITEBACK)),</span>
<span class="quote">&gt; +		   (unsigned long) PtoK(wb_stat(wb, WB_RECLAIMABLE)),</span>
<span class="quote">&gt; +		   PtoK(wb_thresh),</span>
<span class="quote">&gt; +		   PtoK(dirty_thresh),</span>
<span class="quote">&gt; +		   PtoK(background_thresh),</span>
<span class="quote">&gt; +		   (unsigned long) PtoK(wb_stat(wb, WB_DIRTIED)),</span>
<span class="quote">&gt; +		   (unsigned long) PtoK(wb_stat(wb, WB_WRITTEN)),</span>
<span class="quote">&gt; +		   (unsigned long) PtoK(wb-&gt;write_bandwidth),</span>
<span class="quote">&gt;  		   nr_dirty,</span>
<span class="quote">&gt;  		   nr_io,</span>
<span class="quote">&gt;  		   nr_more_io,</span>
<span class="quote">&gt;  		   nr_dirty_time,</span>
<span class="quote">&gt;  		   !list_empty(&amp;bdi-&gt;bdi_list), bdi-&gt;wb.state);</span>
<span class="quote">&gt; -#undef K</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt; @@ -155,8 +153,6 @@ static ssize_t read_ahead_kb_store(struct device *dev,</span>
<span class="quote">&gt;  	return count;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define K(pages) ((pages) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  #define BDI_SHOW(name, expr)						\</span>
<span class="quote">&gt;  static ssize_t name##_show(struct device *dev,				\</span>
<span class="quote">&gt;  			   struct device_attribute *attr, char *page)	\</span>
<span class="quote">&gt; @@ -167,7 +163,7 @@ static ssize_t name##_show(struct device *dev,				\</span>
<span class="quote">&gt;  }									\</span>
<span class="quote">&gt;  static DEVICE_ATTR_RW(name);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -BDI_SHOW(read_ahead_kb, K(bdi-&gt;ra_pages))</span>
<span class="quote">&gt; +BDI_SHOW(read_ahead_kb, PtoK(bdi-&gt;ra_pages))</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static ssize_t min_ratio_store(struct device *dev,</span>
<span class="quote">&gt;  		struct device_attribute *attr, const char *buf, size_t count)</span>
<span class="quote">&gt; diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="quote">&gt; index 94172089f52f..f0f1f4dbe816 100644</span>
<span class="quote">&gt; --- a/mm/memcontrol.c</span>
<span class="quote">&gt; +++ b/mm/memcontrol.c</span>
<span class="quote">&gt; @@ -1132,7 +1132,6 @@ static const char *const memcg1_stat_names[] = {</span>
<span class="quote">&gt;  	&quot;swap&quot;,</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="quote">&gt;  /**</span>
<span class="quote">&gt;   * mem_cgroup_print_oom_info: Print OOM information relevant to memory controller.</span>
<span class="quote">&gt;   * @memcg: The memory cgroup that went over limit</span>
<span class="quote">&gt; @@ -1162,14 +1161,14 @@ void mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)</span>
<span class="quote">&gt;  	rcu_read_unlock();</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	pr_info(&quot;memory: usage %llukB, limit %llukB, failcnt %lu\n&quot;,</span>
<span class="quote">&gt; -		K((u64)page_counter_read(&amp;memcg-&gt;memory)),</span>
<span class="quote">&gt; -		K((u64)memcg-&gt;memory.limit), memcg-&gt;memory.failcnt);</span>
<span class="quote">&gt; +		PtoK((u64)page_counter_read(&amp;memcg-&gt;memory)),</span>
<span class="quote">&gt; +		PtoK((u64)memcg-&gt;memory.limit), memcg-&gt;memory.failcnt);</span>
<span class="quote">&gt;  	pr_info(&quot;memory+swap: usage %llukB, limit %llukB, failcnt %lu\n&quot;,</span>
<span class="quote">&gt; -		K((u64)page_counter_read(&amp;memcg-&gt;memsw)),</span>
<span class="quote">&gt; -		K((u64)memcg-&gt;memsw.limit), memcg-&gt;memsw.failcnt);</span>
<span class="quote">&gt; +		PtoK((u64)page_counter_read(&amp;memcg-&gt;memsw)),</span>
<span class="quote">&gt; +		PtoK((u64)memcg-&gt;memsw.limit), memcg-&gt;memsw.failcnt);</span>
<span class="quote">&gt;  	pr_info(&quot;kmem: usage %llukB, limit %llukB, failcnt %lu\n&quot;,</span>
<span class="quote">&gt; -		K((u64)page_counter_read(&amp;memcg-&gt;kmem)),</span>
<span class="quote">&gt; -		K((u64)memcg-&gt;kmem.limit), memcg-&gt;kmem.failcnt);</span>
<span class="quote">&gt; +		PtoK((u64)page_counter_read(&amp;memcg-&gt;kmem)),</span>
<span class="quote">&gt; +		PtoK((u64)memcg-&gt;kmem.limit), memcg-&gt;kmem.failcnt);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	for_each_mem_cgroup_tree(iter, memcg) {</span>
<span class="quote">&gt;  		pr_info(&quot;Memory cgroup stats for &quot;);</span>
<span class="quote">&gt; @@ -1180,12 +1179,12 @@ void mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)</span>
<span class="quote">&gt;  			if (memcg1_stats[i] == MEMCG_SWAP &amp;&amp; !do_swap_account)</span>
<span class="quote">&gt;  				continue;</span>
<span class="quote">&gt;  			pr_cont(&quot; %s:%luKB&quot;, memcg1_stat_names[i],</span>
<span class="quote">&gt; -				K(memcg_page_state(iter, memcg1_stats[i])));</span>
<span class="quote">&gt; +				PtoK(memcg_page_state(iter, memcg1_stats[i])));</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  		for (i = 0; i &lt; NR_LRU_LISTS; i++)</span>
<span class="quote">&gt;  			pr_cont(&quot; %s:%luKB&quot;, mem_cgroup_lru_names[i],</span>
<span class="quote">&gt; -				K(mem_cgroup_nr_lru_pages(iter, BIT(i))));</span>
<span class="quote">&gt; +				PtoK(mem_cgroup_nr_lru_pages(iter, BIT(i))));</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  		pr_cont(&quot;\n&quot;);</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; diff --git a/mm/oom_kill.c b/mm/oom_kill.c</span>
<span class="quote">&gt; index 04c9143a8625..d83801347c96 100644</span>
<span class="quote">&gt; --- a/mm/oom_kill.c</span>
<span class="quote">&gt; +++ b/mm/oom_kill.c</span>
<span class="quote">&gt; @@ -1,6 +1,6 @@</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   *  linux/mm/oom_kill.c</span>
<span class="quote">&gt; - * </span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt;   *  Copyright (C)  1998,2000  Rik van Riel</span>
<span class="quote">&gt;   *	Thanks go out to Claus Fischer for some serious inspiration and</span>
<span class="quote">&gt;   *	for goading me into coding this file...</span>
<span class="quote">&gt; @@ -435,8 +435,6 @@ static DECLARE_WAIT_QUEUE_HEAD(oom_victims_wait);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static bool oom_killer_disabled __read_mostly;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * task-&gt;mm can be NULL if the task is the exited group leader.  So to</span>
<span class="quote">&gt;   * determine whether the task is using a particular mm, we examine all the</span>
<span class="quote">&gt; @@ -533,9 +531,9 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)</span>
<span class="quote">&gt;  	tlb_finish_mmu(&amp;tlb, 0, -1);</span>
<span class="quote">&gt;  	pr_info(&quot;oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n&quot;,</span>
<span class="quote">&gt;  			task_pid_nr(tsk), tsk-&gt;comm,</span>
<span class="quote">&gt; -			K(get_mm_counter(mm, MM_ANONPAGES)),</span>
<span class="quote">&gt; -			K(get_mm_counter(mm, MM_FILEPAGES)),</span>
<span class="quote">&gt; -			K(get_mm_counter(mm, MM_SHMEMPAGES)));</span>
<span class="quote">&gt; +			PtoK(get_mm_counter(mm, MM_ANONPAGES)),</span>
<span class="quote">&gt; +			PtoK(get_mm_counter(mm, MM_FILEPAGES)),</span>
<span class="quote">&gt; +			PtoK(get_mm_counter(mm, MM_SHMEMPAGES)));</span>
<span class="quote">&gt;  	up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt; @@ -884,10 +882,10 @@ static void oom_kill_process(struct oom_control *oc, const char *message)</span>
<span class="quote">&gt;  	do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);</span>
<span class="quote">&gt;  	mark_oom_victim(victim);</span>
<span class="quote">&gt;  	pr_err(&quot;Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n&quot;,</span>
<span class="quote">&gt; -		task_pid_nr(victim), victim-&gt;comm, K(victim-&gt;mm-&gt;total_vm),</span>
<span class="quote">&gt; -		K(get_mm_counter(victim-&gt;mm, MM_ANONPAGES)),</span>
<span class="quote">&gt; -		K(get_mm_counter(victim-&gt;mm, MM_FILEPAGES)),</span>
<span class="quote">&gt; -		K(get_mm_counter(victim-&gt;mm, MM_SHMEMPAGES)));</span>
<span class="quote">&gt; +		task_pid_nr(victim), victim-&gt;comm, PtoK(victim-&gt;mm-&gt;total_vm),</span>
<span class="quote">&gt; +		PtoK(get_mm_counter(victim-&gt;mm, MM_ANONPAGES)),</span>
<span class="quote">&gt; +		PtoK(get_mm_counter(victim-&gt;mm, MM_FILEPAGES)),</span>
<span class="quote">&gt; +		PtoK(get_mm_counter(victim-&gt;mm, MM_SHMEMPAGES)));</span>
<span class="quote">&gt;  	task_unlock(victim);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt; @@ -929,7 +927,6 @@ static void oom_kill_process(struct oom_control *oc, const char *message)</span>
<span class="quote">&gt;  	mmdrop(mm);</span>
<span class="quote">&gt;  	put_task_struct(victim);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt; -#undef K</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Determines whether the kernel must panic because of the panic_on_oom sysctl.</span>
<span class="quote">&gt; diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="quote">&gt; index 2302f250d6b1..5785a2f8d7db 100644</span>
<span class="quote">&gt; --- a/mm/page_alloc.c</span>
<span class="quote">&gt; +++ b/mm/page_alloc.c</span>
<span class="quote">&gt; @@ -4460,8 +4460,6 @@ static bool show_mem_node_skip(unsigned int flags, int nid, nodemask_t *nodemask</span>
<span class="quote">&gt;  	return !node_isset(nid, *nodemask);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  static void show_migration_types(unsigned char type)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	static const char types[MIGRATE_TYPES] = {</span>
<span class="quote">&gt; @@ -4565,25 +4563,27 @@ void show_free_areas(unsigned int filter, nodemask_t *nodemask)</span>
<span class="quote">&gt;  			&quot; all_unreclaimable? %s&quot;</span>
<span class="quote">&gt;  			&quot;\n&quot;,</span>
<span class="quote">&gt;  			pgdat-&gt;node_id,</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_ISOLATED_ANON)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_ISOLATED_FILE)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_WRITEBACK)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_SHMEM)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_ISOLATED_ANON)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_ISOLATED_FILE)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_WRITEBACK)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_SHMEM)),</span>
<span class="quote">&gt;  #ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_SHMEM_THPS) *</span>
<span class="quote">&gt; +			     HPAGE_PMD_NR),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)</span>
<span class="quote">&gt;  					* HPAGE_PMD_NR),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_ANON_THPS) *</span>
<span class="quote">&gt; +			     HPAGE_PMD_NR),</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="quote">&gt; -			K(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="quote">&gt; +			PtoK(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
<span class="quote">&gt;  			pgdat-&gt;kswapd_failures &gt;= MAX_RECLAIM_RETRIES ?</span>
<span class="quote">&gt;  				&quot;yes&quot; : &quot;no&quot;);</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; @@ -4624,27 +4624,27 @@ void show_free_areas(unsigned int filter, nodemask_t *nodemask)</span>
<span class="quote">&gt;  			&quot; free_cma:%lukB&quot;</span>
<span class="quote">&gt;  			&quot;\n&quot;,</span>
<span class="quote">&gt;  			zone-&gt;name,</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_FREE_PAGES)),</span>
<span class="quote">&gt; -			K(min_wmark_pages(zone)),</span>
<span class="quote">&gt; -			K(low_wmark_pages(zone)),</span>
<span class="quote">&gt; -			K(high_wmark_pages(zone)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),</span>
<span class="quote">&gt; -			K(zone-&gt;present_pages),</span>
<span class="quote">&gt; -			K(zone-&gt;managed_pages),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_MLOCK)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_SLAB_RECLAIMABLE)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_FREE_PAGES)),</span>
<span class="quote">&gt; +			PtoK(min_wmark_pages(zone)),</span>
<span class="quote">&gt; +			PtoK(low_wmark_pages(zone)),</span>
<span class="quote">&gt; +			PtoK(high_wmark_pages(zone)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),</span>
<span class="quote">&gt; +			PtoK(zone-&gt;present_pages),</span>
<span class="quote">&gt; +			PtoK(zone-&gt;managed_pages),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_MLOCK)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_SLAB_RECLAIMABLE)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="quote">&gt;  			zone_page_state(zone, NR_KERNEL_STACK_KB),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_PAGETABLE)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_BOUNCE)),</span>
<span class="quote">&gt; -			K(free_pcp),</span>
<span class="quote">&gt; -			K(this_cpu_read(zone-&gt;pageset-&gt;pcp.count)),</span>
<span class="quote">&gt; -			K(zone_page_state(zone, NR_FREE_CMA_PAGES)));</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_PAGETABLE)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_BOUNCE)),</span>
<span class="quote">&gt; +			PtoK(free_pcp),</span>
<span class="quote">&gt; +			PtoK(this_cpu_read(zone-&gt;pageset-&gt;pcp.count)),</span>
<span class="quote">&gt; +			PtoK(zone_page_state(zone, NR_FREE_CMA_PAGES)));</span>
<span class="quote">&gt;  		printk(&quot;lowmem_reserve[]:&quot;);</span>
<span class="quote">&gt;  		for (i = 0; i &lt; MAX_NR_ZONES; i++)</span>
<span class="quote">&gt;  			printk(KERN_CONT &quot; %ld&quot;, zone-&gt;lowmem_reserve[i]);</span>
<span class="quote">&gt; @@ -4678,11 +4678,11 @@ void show_free_areas(unsigned int filter, nodemask_t *nodemask)</span>
<span class="quote">&gt;  		spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span>
<span class="quote">&gt;  		for (order = 0; order &lt; MAX_ORDER; order++) {</span>
<span class="quote">&gt;  			printk(KERN_CONT &quot;%lu*%lukB &quot;,</span>
<span class="quote">&gt; -			       nr[order], K(1UL) &lt;&lt; order);</span>
<span class="quote">&gt; +			       nr[order], PtoK(1UL) &lt;&lt; order);</span>
<span class="quote">&gt;  			if (nr[order])</span>
<span class="quote">&gt;  				show_migration_types(types[order]);</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt; -		printk(KERN_CONT &quot;= %lukB\n&quot;, K(total));</span>
<span class="quote">&gt; +		printk(KERN_CONT &quot;= %lukB\n&quot;, PtoK(total));</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	hugetlb_show_meminfo();</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.7.4</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=172675">Nikolay Borisov</a> - June 22, 2017, 6:58 a.m.</div>
<pre class="content">
On 22.06.2017 09:44, Michal Hocko wrote:
<span class="quote">&gt; On Tue 20-06-17 18:14:28, Nikolay Borisov wrote:</span>
<span class="quote">&gt;&gt; Currently there are a multiple files with the following code:</span>
<span class="quote">&gt;&gt;  #define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt;&gt;  ... some code..</span>
<span class="quote">&gt;&gt;  #undef K</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This is mainly used to print out some memory-related statistics, where X is</span>
<span class="quote">&gt;&gt; given in pages and the macro just converts it to kilobytes. In the future</span>
<span class="quote">&gt;&gt; there is going to be more macros since there are intention to introduce</span>
<span class="quote">&gt;&gt; byte-based memory counters [1]. This could lead to proliferation of</span>
<span class="quote">&gt;&gt; multiple duplicated definition of various macros used to convert a quantity</span>
<span class="quote">&gt;&gt; from one unit to another. Let&#39;s try and consolidate such definition in the</span>
<span class="quote">&gt;&gt; mm.h header since currently it&#39;s being included in all files which exhibit</span>
<span class="quote">&gt;&gt; this pattern. Also let&#39;s rename it to something a bit more verbose.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This patch doesn&#39;t introduce any functional changes</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; [1] https://patchwork.kernel.org/patch/9395205/</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Nikolay Borisov &lt;nborisov@suse.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  arch/tile/mm/pgtable.c      |  2 --</span>
<span class="quote">&gt;&gt;  drivers/base/node.c         | 66 ++++++++++++++++++-------------------</span>
<span class="quote">&gt;&gt;  include/linux/mm.h          |  2 ++</span>
<span class="quote">&gt;&gt;  kernel/debug/kdb/kdb_main.c |  3 +-</span>
<span class="quote">&gt;&gt;  mm/backing-dev.c            | 22 +++++--------</span>
<span class="quote">&gt;&gt;  mm/memcontrol.c             | 17 +++++-----</span>
<span class="quote">&gt;&gt;  mm/oom_kill.c               | 19 +++++------</span>
<span class="quote">&gt;&gt;  mm/page_alloc.c             | 80 ++++++++++++++++++++++-----------------------</span>
<span class="quote">&gt;&gt;  8 files changed, 100 insertions(+), 111 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Those macros are quite trivial and we do not really save much code while</span>
<span class="quote">&gt; this touches a lot of code potentially causing some conflicts. So do we</span>
<span class="quote">&gt; really need this? I am usually very keen on removing duplication but</span>
<span class="quote">&gt; this doesn&#39;t seem to be worth all the troubles IMHO.</span>
<span class="quote">&gt; </span>

There are 2 problems I see: 

1. K is in fact used for other macros than converting pages to kbytes. 
Simple grep before my patch is applied yields the following: 

arch/tile/mm/pgtable.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))
arch/x86/crypto/serpent-sse2-i586-asm_32.S:#define K(x0, x1, x2, x3, x4, i) \
crypto/serpent_generic.c:#define K(x0, x1, x2, x3, i) ({                                \
drivers/base/node.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))
drivers/net/hamradio/scc.c:#define K(x) kiss-&gt;x
include/uapi/linux/keyboard.h:#define K(t,v)            (((t)&lt;&lt;8)|(v))
kernel/debug/kdb/kdb_main.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))
mm/backing-dev.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))
mm/backing-dev.c:#define K(pages) ((pages) &lt;&lt; (PAGE_SHIFT - 10))
mm/memcontrol.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))
mm/oom_kill.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))
mm/page_alloc.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))


Furthermore, I intend on sending another patchset which introduces 2 more macros:
drivers/base/node.c:#define BtoK(x) ((x) &gt;&gt; 10)
drivers/video/fbdev/intelfb/intelfb.h:#define BtoKB(x)          ((x) / 1024)
mm/backing-dev.c:#define BtoK(x) ((x) &gt;&gt; 10)
mm/page_alloc.c:#define BtoK(x) ((x) &gt;&gt; 10)

fs/fs-writeback.c:#define BtoP(x) ((x) &gt;&gt; PAGE_SHIFT)
include/trace/events/writeback.h:#define BtoP(x) ((x) &gt;&gt; PAGE_SHIFT)
mm/page_alloc.c:#define BtoP(x) ((x) &gt;&gt; PAGE_SHIFT)

As you can see this ends up in spreading those macros. Ideally 
they should be in a header which is shared among all affected 
files. This was inspired by the feedback that Tejun has given 
here: https://patchwork.kernel.org/patch/9395205/ and I believe
he is right.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - June 23, 2017, 11:48 a.m.</div>
<pre class="content">
On Thu 22-06-17 09:58:17, Nikolay Borisov wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 22.06.2017 09:44, Michal Hocko wrote:</span>
<span class="quote">&gt; &gt; On Tue 20-06-17 18:14:28, Nikolay Borisov wrote:</span>
<span class="quote">&gt; &gt;&gt; Currently there are a multiple files with the following code:</span>
<span class="quote">&gt; &gt;&gt;  #define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt; &gt;&gt;  ... some code..</span>
<span class="quote">&gt; &gt;&gt;  #undef K</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; This is mainly used to print out some memory-related statistics, where X is</span>
<span class="quote">&gt; &gt;&gt; given in pages and the macro just converts it to kilobytes. In the future</span>
<span class="quote">&gt; &gt;&gt; there is going to be more macros since there are intention to introduce</span>
<span class="quote">&gt; &gt;&gt; byte-based memory counters [1]. This could lead to proliferation of</span>
<span class="quote">&gt; &gt;&gt; multiple duplicated definition of various macros used to convert a quantity</span>
<span class="quote">&gt; &gt;&gt; from one unit to another. Let&#39;s try and consolidate such definition in the</span>
<span class="quote">&gt; &gt;&gt; mm.h header since currently it&#39;s being included in all files which exhibit</span>
<span class="quote">&gt; &gt;&gt; this pattern. Also let&#39;s rename it to something a bit more verbose.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; This patch doesn&#39;t introduce any functional changes</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; [1] https://patchwork.kernel.org/patch/9395205/</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Signed-off-by: Nikolay Borisov &lt;nborisov@suse.com&gt;</span>
<span class="quote">&gt; &gt;&gt; ---</span>
<span class="quote">&gt; &gt;&gt;  arch/tile/mm/pgtable.c      |  2 --</span>
<span class="quote">&gt; &gt;&gt;  drivers/base/node.c         | 66 ++++++++++++++++++-------------------</span>
<span class="quote">&gt; &gt;&gt;  include/linux/mm.h          |  2 ++</span>
<span class="quote">&gt; &gt;&gt;  kernel/debug/kdb/kdb_main.c |  3 +-</span>
<span class="quote">&gt; &gt;&gt;  mm/backing-dev.c            | 22 +++++--------</span>
<span class="quote">&gt; &gt;&gt;  mm/memcontrol.c             | 17 +++++-----</span>
<span class="quote">&gt; &gt;&gt;  mm/oom_kill.c               | 19 +++++------</span>
<span class="quote">&gt; &gt;&gt;  mm/page_alloc.c             | 80 ++++++++++++++++++++++-----------------------</span>
<span class="quote">&gt; &gt;&gt;  8 files changed, 100 insertions(+), 111 deletions(-)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Those macros are quite trivial and we do not really save much code while</span>
<span class="quote">&gt; &gt; this touches a lot of code potentially causing some conflicts. So do we</span>
<span class="quote">&gt; &gt; really need this? I am usually very keen on removing duplication but</span>
<span class="quote">&gt; &gt; this doesn&#39;t seem to be worth all the troubles IMHO.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There are 2 problems I see: </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 1. K is in fact used for other macros than converting pages to kbytes. </span>
<span class="quote">&gt; Simple grep before my patch is applied yields the following: </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; arch/tile/mm/pgtable.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="quote">&gt; arch/x86/crypto/serpent-sse2-i586-asm_32.S:#define K(x0, x1, x2, x3, x4, i) \</span>
<span class="quote">&gt; crypto/serpent_generic.c:#define K(x0, x1, x2, x3, i) ({                                \</span>
<span class="quote">&gt; drivers/base/node.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt; drivers/net/hamradio/scc.c:#define K(x) kiss-&gt;x</span>
<span class="quote">&gt; include/uapi/linux/keyboard.h:#define K(t,v)            (((t)&lt;&lt;8)|(v))</span>
<span class="quote">&gt; kernel/debug/kdb/kdb_main.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt; mm/backing-dev.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt; mm/backing-dev.c:#define K(pages) ((pages) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="quote">&gt; mm/memcontrol.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="quote">&gt; mm/oom_kill.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="quote">&gt; mm/page_alloc.c:#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Furthermore, I intend on sending another patchset which introduces 2 more macros:</span>
<span class="quote">&gt; drivers/base/node.c:#define BtoK(x) ((x) &gt;&gt; 10)</span>
<span class="quote">&gt; drivers/video/fbdev/intelfb/intelfb.h:#define BtoKB(x)          ((x) / 1024)</span>
<span class="quote">&gt; mm/backing-dev.c:#define BtoK(x) ((x) &gt;&gt; 10)</span>
<span class="quote">&gt; mm/page_alloc.c:#define BtoK(x) ((x) &gt;&gt; 10)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; fs/fs-writeback.c:#define BtoP(x) ((x) &gt;&gt; PAGE_SHIFT)</span>
<span class="quote">&gt; include/trace/events/writeback.h:#define BtoP(x) ((x) &gt;&gt; PAGE_SHIFT)</span>
<span class="quote">&gt; mm/page_alloc.c:#define BtoP(x) ((x) &gt;&gt; PAGE_SHIFT)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As you can see this ends up in spreading those macros. Ideally </span>
<span class="quote">&gt; they should be in a header which is shared among all affected </span>
<span class="quote">&gt; files. This was inspired by the feedback that Tejun has given </span>
<span class="quote">&gt; here: https://patchwork.kernel.org/patch/9395205/ and I believe</span>
<span class="quote">&gt; he is right. </span>

Fair enough, if this is part of a larger work then I would incline to do
all of them in a single series.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/tile/mm/pgtable.c b/arch/tile/mm/pgtable.c</span>
<span class="p_header">index 492a7361e58e..f04af570c1c2 100644</span>
<span class="p_header">--- a/arch/tile/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/tile/mm/pgtable.c</span>
<span class="p_chunk">@@ -34,8 +34,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/homecache.h&gt;
 
<span class="p_del">-#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="p_del">-</span>
 /**
  * shatter_huge_page() - ensure a given address is mapped by a small page.
  *
<span class="p_header">diff --git a/drivers/base/node.c b/drivers/base/node.c</span>
<span class="p_header">index 5548f9686016..b6f563a3a3a9 100644</span>
<span class="p_header">--- a/drivers/base/node.c</span>
<span class="p_header">+++ b/drivers/base/node.c</span>
<span class="p_chunk">@@ -50,7 +50,6 @@</span> <span class="p_context"> static inline ssize_t node_read_cpulist(struct device *dev,</span>
 static DEVICE_ATTR(cpumap,  S_IRUGO, node_read_cpumask, NULL);
 static DEVICE_ATTR(cpulist, S_IRUGO, node_read_cpulist, NULL);
 
<span class="p_del">-#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
 static ssize_t node_read_meminfo(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
<span class="p_chunk">@@ -72,19 +71,19 @@</span> <span class="p_context"> static ssize_t node_read_meminfo(struct device *dev,</span>
 		       &quot;Node %d Inactive(file): %8lu kB\n&quot;
 		       &quot;Node %d Unevictable:    %8lu kB\n&quot;
 		       &quot;Node %d Mlocked:        %8lu kB\n&quot;,
<span class="p_del">-		       nid, K(i.totalram),</span>
<span class="p_del">-		       nid, K(i.freeram),</span>
<span class="p_del">-		       nid, K(i.totalram - i.freeram),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_ACTIVE_ANON) +</span>
<span class="p_add">+		       nid, PtoK(i.totalram),</span>
<span class="p_add">+		       nid, PtoK(i.freeram),</span>
<span class="p_add">+		       nid, PtoK(i.totalram - i.freeram),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_ACTIVE_ANON) +</span>
 				node_page_state(pgdat, NR_ACTIVE_FILE)),
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_INACTIVE_ANON) +</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_INACTIVE_ANON) +</span>
 				node_page_state(pgdat, NR_INACTIVE_FILE)),
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="p_del">-		       nid, K(sum_zone_node_page_state(nid, NR_MLOCK)));</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="p_add">+		       nid, PtoK(sum_zone_node_page_state(nid, NR_MLOCK)));</span>
 
 #ifdef CONFIG_HIGHMEM
 	n += sprintf(buf + n,
<span class="p_chunk">@@ -92,10 +91,10 @@</span> <span class="p_context"> static ssize_t node_read_meminfo(struct device *dev,</span>
 		       &quot;Node %d HighFree:       %8lu kB\n&quot;
 		       &quot;Node %d LowTotal:       %8lu kB\n&quot;
 		       &quot;Node %d LowFree:        %8lu kB\n&quot;,
<span class="p_del">-		       nid, K(i.totalhigh),</span>
<span class="p_del">-		       nid, K(i.freehigh),</span>
<span class="p_del">-		       nid, K(i.totalram - i.totalhigh),</span>
<span class="p_del">-		       nid, K(i.freeram - i.freehigh));</span>
<span class="p_add">+		       nid, PtoK(i.totalhigh),</span>
<span class="p_add">+		       nid, PtoK(i.freehigh),</span>
<span class="p_add">+		       nid, PtoK(i.totalram - i.totalhigh),</span>
<span class="p_add">+		       nid, PtoK(i.freeram - i.freehigh));</span>
 #endif
 	n += sprintf(buf + n,
 		       &quot;Node %d Dirty:          %8lu kB\n&quot;
<span class="p_chunk">@@ -118,36 +117,35 @@</span> <span class="p_context"> static ssize_t node_read_meminfo(struct device *dev,</span>
 		       &quot;Node %d ShmemPmdMapped: %8lu kB\n&quot;
 #endif
 			,
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_WRITEBACK)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_FILE_PAGES)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_ANON_MAPPED)),</span>
<span class="p_del">-		       nid, K(i.sharedram),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_WRITEBACK)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_FILE_PAGES)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_ANON_MAPPED)),</span>
<span class="p_add">+		       nid, PtoK(i.sharedram),</span>
 		       nid, sum_zone_node_page_state(nid, NR_KERNEL_STACK_KB),
<span class="p_del">-		       nid, K(sum_zone_node_page_state(nid, NR_PAGETABLE)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
<span class="p_del">-		       nid, K(sum_zone_node_page_state(nid, NR_BOUNCE)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="p_del">-		       nid, K(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE) +</span>
<span class="p_add">+		       nid, PtoK(sum_zone_node_page_state(nid, NR_PAGETABLE)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
<span class="p_add">+		       nid, PtoK(sum_zone_node_page_state(nid, NR_BOUNCE)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="p_add">+		       nid, PtoK(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE) +</span>
 				sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)),
<span class="p_del">-		       nid, K(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE)),</span>
<span class="p_add">+		       nid, PtoK(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE)),</span>
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
<span class="p_del">-		       nid, K(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_ANON_THPS) *</span>
<span class="p_add">+		       nid, PtoK(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_ANON_THPS) *</span>
 				       HPAGE_PMD_NR),
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_SHMEM_THPS) *</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_SHMEM_THPS) *</span>
 				       HPAGE_PMD_NR),
<span class="p_del">-		       nid, K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED) *</span>
<span class="p_add">+		       nid, PtoK(node_page_state(pgdat, NR_SHMEM_PMDMAPPED) *</span>
 				       HPAGE_PMD_NR));
 #else
<span class="p_del">-		       nid, K(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)));</span>
<span class="p_add">+		       nid, PtoK(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)));</span>
 #endif
 	n += hugetlb_report_node_meminfo(nid, buf + n);
 	return n;
 }
 
<span class="p_del">-#undef K</span>
 static DEVICE_ATTR(meminfo, S_IRUGO, node_read_meminfo, NULL);
 
 static ssize_t node_read_numastat(struct device *dev,
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 6f543a47fc92..d8d80e2e9194 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -93,6 +93,8 @@</span> <span class="p_context"> extern int mmap_rnd_compat_bits __read_mostly;</span>
 #define mm_forbids_zeropage(X)	(0)
 #endif
 
<span class="p_add">+#define PtoK(pages) ((pages) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="p_add">+</span>
 /*
  * Default maximum number of active map areas, this limits the number of vmas
  * per mm struct. Users can overwrite this number by sysctl but there is a
<span class="p_header">diff --git a/kernel/debug/kdb/kdb_main.c b/kernel/debug/kdb/kdb_main.c</span>
<span class="p_header">index c8146d53ca67..e833cb02d2c8 100644</span>
<span class="p_header">--- a/kernel/debug/kdb/kdb_main.c</span>
<span class="p_header">+++ b/kernel/debug/kdb/kdb_main.c</span>
<span class="p_chunk">@@ -2582,10 +2582,9 @@</span> <span class="p_context"> static int kdb_summary(int argc, const char **argv)</span>
 #undef LOAD_INT
 #undef LOAD_FRAC
 	/* Display in kilobytes */
<span class="p_del">-#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
 	kdb_printf(&quot;\nMemTotal:       %8lu kB\nMemFree:        %8lu kB\n&quot;
 		   &quot;Buffers:        %8lu kB\n&quot;,
<span class="p_del">-		   K(val.totalram), K(val.freeram), K(val.bufferram));</span>
<span class="p_add">+		   PtoK(val.totalram), PtoK(val.freeram), PtoK(val.bufferram));</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index f028a9a472fd..0c09dd103109 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -67,7 +67,6 @@</span> <span class="p_context"> static int bdi_debug_stats_show(struct seq_file *m, void *v)</span>
 	global_dirty_limits(&amp;background_thresh, &amp;dirty_thresh);
 	wb_thresh = wb_calc_thresh(wb, dirty_thresh);
 
<span class="p_del">-#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
 	seq_printf(m,
 		   &quot;BdiWriteback:       %10lu kB\n&quot;
 		   &quot;BdiReclaimable:     %10lu kB\n&quot;
<span class="p_chunk">@@ -83,20 +82,19 @@</span> <span class="p_context"> static int bdi_debug_stats_show(struct seq_file *m, void *v)</span>
 		   &quot;b_dirty_time:       %10lu\n&quot;
 		   &quot;bdi_list:           %10u\n&quot;
 		   &quot;state:              %10lx\n&quot;,
<span class="p_del">-		   (unsigned long) K(wb_stat(wb, WB_WRITEBACK)),</span>
<span class="p_del">-		   (unsigned long) K(wb_stat(wb, WB_RECLAIMABLE)),</span>
<span class="p_del">-		   K(wb_thresh),</span>
<span class="p_del">-		   K(dirty_thresh),</span>
<span class="p_del">-		   K(background_thresh),</span>
<span class="p_del">-		   (unsigned long) K(wb_stat(wb, WB_DIRTIED)),</span>
<span class="p_del">-		   (unsigned long) K(wb_stat(wb, WB_WRITTEN)),</span>
<span class="p_del">-		   (unsigned long) K(wb-&gt;write_bandwidth),</span>
<span class="p_add">+		   (unsigned long) PtoK(wb_stat(wb, WB_WRITEBACK)),</span>
<span class="p_add">+		   (unsigned long) PtoK(wb_stat(wb, WB_RECLAIMABLE)),</span>
<span class="p_add">+		   PtoK(wb_thresh),</span>
<span class="p_add">+		   PtoK(dirty_thresh),</span>
<span class="p_add">+		   PtoK(background_thresh),</span>
<span class="p_add">+		   (unsigned long) PtoK(wb_stat(wb, WB_DIRTIED)),</span>
<span class="p_add">+		   (unsigned long) PtoK(wb_stat(wb, WB_WRITTEN)),</span>
<span class="p_add">+		   (unsigned long) PtoK(wb-&gt;write_bandwidth),</span>
 		   nr_dirty,
 		   nr_io,
 		   nr_more_io,
 		   nr_dirty_time,
 		   !list_empty(&amp;bdi-&gt;bdi_list), bdi-&gt;wb.state);
<span class="p_del">-#undef K</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -155,8 +153,6 @@</span> <span class="p_context"> static ssize_t read_ahead_kb_store(struct device *dev,</span>
 	return count;
 }
 
<span class="p_del">-#define K(pages) ((pages) &lt;&lt; (PAGE_SHIFT - 10))</span>
<span class="p_del">-</span>
 #define BDI_SHOW(name, expr)						\
 static ssize_t name##_show(struct device *dev,				\
 			   struct device_attribute *attr, char *page)	\
<span class="p_chunk">@@ -167,7 +163,7 @@</span> <span class="p_context"> static ssize_t name##_show(struct device *dev,				\</span>
 }									\
 static DEVICE_ATTR_RW(name);
 
<span class="p_del">-BDI_SHOW(read_ahead_kb, K(bdi-&gt;ra_pages))</span>
<span class="p_add">+BDI_SHOW(read_ahead_kb, PtoK(bdi-&gt;ra_pages))</span>
 
 static ssize_t min_ratio_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 94172089f52f..f0f1f4dbe816 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -1132,7 +1132,6 @@</span> <span class="p_context"> static const char *const memcg1_stat_names[] = {</span>
 	&quot;swap&quot;,
 };
 
<span class="p_del">-#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
 /**
  * mem_cgroup_print_oom_info: Print OOM information relevant to memory controller.
  * @memcg: The memory cgroup that went over limit
<span class="p_chunk">@@ -1162,14 +1161,14 @@</span> <span class="p_context"> void mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)</span>
 	rcu_read_unlock();
 
 	pr_info(&quot;memory: usage %llukB, limit %llukB, failcnt %lu\n&quot;,
<span class="p_del">-		K((u64)page_counter_read(&amp;memcg-&gt;memory)),</span>
<span class="p_del">-		K((u64)memcg-&gt;memory.limit), memcg-&gt;memory.failcnt);</span>
<span class="p_add">+		PtoK((u64)page_counter_read(&amp;memcg-&gt;memory)),</span>
<span class="p_add">+		PtoK((u64)memcg-&gt;memory.limit), memcg-&gt;memory.failcnt);</span>
 	pr_info(&quot;memory+swap: usage %llukB, limit %llukB, failcnt %lu\n&quot;,
<span class="p_del">-		K((u64)page_counter_read(&amp;memcg-&gt;memsw)),</span>
<span class="p_del">-		K((u64)memcg-&gt;memsw.limit), memcg-&gt;memsw.failcnt);</span>
<span class="p_add">+		PtoK((u64)page_counter_read(&amp;memcg-&gt;memsw)),</span>
<span class="p_add">+		PtoK((u64)memcg-&gt;memsw.limit), memcg-&gt;memsw.failcnt);</span>
 	pr_info(&quot;kmem: usage %llukB, limit %llukB, failcnt %lu\n&quot;,
<span class="p_del">-		K((u64)page_counter_read(&amp;memcg-&gt;kmem)),</span>
<span class="p_del">-		K((u64)memcg-&gt;kmem.limit), memcg-&gt;kmem.failcnt);</span>
<span class="p_add">+		PtoK((u64)page_counter_read(&amp;memcg-&gt;kmem)),</span>
<span class="p_add">+		PtoK((u64)memcg-&gt;kmem.limit), memcg-&gt;kmem.failcnt);</span>
 
 	for_each_mem_cgroup_tree(iter, memcg) {
 		pr_info(&quot;Memory cgroup stats for &quot;);
<span class="p_chunk">@@ -1180,12 +1179,12 @@</span> <span class="p_context"> void mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)</span>
 			if (memcg1_stats[i] == MEMCG_SWAP &amp;&amp; !do_swap_account)
 				continue;
 			pr_cont(&quot; %s:%luKB&quot;, memcg1_stat_names[i],
<span class="p_del">-				K(memcg_page_state(iter, memcg1_stats[i])));</span>
<span class="p_add">+				PtoK(memcg_page_state(iter, memcg1_stats[i])));</span>
 		}
 
 		for (i = 0; i &lt; NR_LRU_LISTS; i++)
 			pr_cont(&quot; %s:%luKB&quot;, mem_cgroup_lru_names[i],
<span class="p_del">-				K(mem_cgroup_nr_lru_pages(iter, BIT(i))));</span>
<span class="p_add">+				PtoK(mem_cgroup_nr_lru_pages(iter, BIT(i))));</span>
 
 		pr_cont(&quot;\n&quot;);
 	}
<span class="p_header">diff --git a/mm/oom_kill.c b/mm/oom_kill.c</span>
<span class="p_header">index 04c9143a8625..d83801347c96 100644</span>
<span class="p_header">--- a/mm/oom_kill.c</span>
<span class="p_header">+++ b/mm/oom_kill.c</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 /*
  *  linux/mm/oom_kill.c
<span class="p_del">- * </span>
<span class="p_add">+ *</span>
  *  Copyright (C)  1998,2000  Rik van Riel
  *	Thanks go out to Claus Fischer for some serious inspiration and
  *	for goading me into coding this file...
<span class="p_chunk">@@ -435,8 +435,6 @@</span> <span class="p_context"> static DECLARE_WAIT_QUEUE_HEAD(oom_victims_wait);</span>
 
 static bool oom_killer_disabled __read_mostly;
 
<span class="p_del">-#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="p_del">-</span>
 /*
  * task-&gt;mm can be NULL if the task is the exited group leader.  So to
  * determine whether the task is using a particular mm, we examine all the
<span class="p_chunk">@@ -533,9 +531,9 @@</span> <span class="p_context"> static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)</span>
 	tlb_finish_mmu(&amp;tlb, 0, -1);
 	pr_info(&quot;oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n&quot;,
 			task_pid_nr(tsk), tsk-&gt;comm,
<span class="p_del">-			K(get_mm_counter(mm, MM_ANONPAGES)),</span>
<span class="p_del">-			K(get_mm_counter(mm, MM_FILEPAGES)),</span>
<span class="p_del">-			K(get_mm_counter(mm, MM_SHMEMPAGES)));</span>
<span class="p_add">+			PtoK(get_mm_counter(mm, MM_ANONPAGES)),</span>
<span class="p_add">+			PtoK(get_mm_counter(mm, MM_FILEPAGES)),</span>
<span class="p_add">+			PtoK(get_mm_counter(mm, MM_SHMEMPAGES)));</span>
 	up_read(&amp;mm-&gt;mmap_sem);
 
 	/*
<span class="p_chunk">@@ -884,10 +882,10 @@</span> <span class="p_context"> static void oom_kill_process(struct oom_control *oc, const char *message)</span>
 	do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);
 	mark_oom_victim(victim);
 	pr_err(&quot;Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n&quot;,
<span class="p_del">-		task_pid_nr(victim), victim-&gt;comm, K(victim-&gt;mm-&gt;total_vm),</span>
<span class="p_del">-		K(get_mm_counter(victim-&gt;mm, MM_ANONPAGES)),</span>
<span class="p_del">-		K(get_mm_counter(victim-&gt;mm, MM_FILEPAGES)),</span>
<span class="p_del">-		K(get_mm_counter(victim-&gt;mm, MM_SHMEMPAGES)));</span>
<span class="p_add">+		task_pid_nr(victim), victim-&gt;comm, PtoK(victim-&gt;mm-&gt;total_vm),</span>
<span class="p_add">+		PtoK(get_mm_counter(victim-&gt;mm, MM_ANONPAGES)),</span>
<span class="p_add">+		PtoK(get_mm_counter(victim-&gt;mm, MM_FILEPAGES)),</span>
<span class="p_add">+		PtoK(get_mm_counter(victim-&gt;mm, MM_SHMEMPAGES)));</span>
 	task_unlock(victim);
 
 	/*
<span class="p_chunk">@@ -929,7 +927,6 @@</span> <span class="p_context"> static void oom_kill_process(struct oom_control *oc, const char *message)</span>
 	mmdrop(mm);
 	put_task_struct(victim);
 }
<span class="p_del">-#undef K</span>
 
 /*
  * Determines whether the kernel must panic because of the panic_on_oom sysctl.
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 2302f250d6b1..5785a2f8d7db 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -4460,8 +4460,6 @@</span> <span class="p_context"> static bool show_mem_node_skip(unsigned int flags, int nid, nodemask_t *nodemask</span>
 	return !node_isset(nid, *nodemask);
 }
 
<span class="p_del">-#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="p_del">-</span>
 static void show_migration_types(unsigned char type)
 {
 	static const char types[MIGRATE_TYPES] = {
<span class="p_chunk">@@ -4565,25 +4563,27 @@</span> <span class="p_context"> void show_free_areas(unsigned int filter, nodemask_t *nodemask)</span>
 			&quot; all_unreclaimable? %s&quot;
 			&quot;\n&quot;,
 			pgdat-&gt;node_id,
<span class="p_del">-			K(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_ISOLATED_ANON)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_ISOLATED_FILE)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_WRITEBACK)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_SHMEM)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_ISOLATED_ANON)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_ISOLATED_FILE)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_WRITEBACK)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_SHMEM)),</span>
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
<span class="p_del">-			K(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_SHMEM_THPS) *</span>
<span class="p_add">+			     HPAGE_PMD_NR),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)</span>
 					* HPAGE_PMD_NR),
<span class="p_del">-			K(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_ANON_THPS) *</span>
<span class="p_add">+			     HPAGE_PMD_NR),</span>
 #endif
<span class="p_del">-			K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="p_add">+			PtoK(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
 			pgdat-&gt;kswapd_failures &gt;= MAX_RECLAIM_RETRIES ?
 				&quot;yes&quot; : &quot;no&quot;);
 	}
<span class="p_chunk">@@ -4624,27 +4624,27 @@</span> <span class="p_context"> void show_free_areas(unsigned int filter, nodemask_t *nodemask)</span>
 			&quot; free_cma:%lukB&quot;
 			&quot;\n&quot;,
 			zone-&gt;name,
<span class="p_del">-			K(zone_page_state(zone, NR_FREE_PAGES)),</span>
<span class="p_del">-			K(min_wmark_pages(zone)),</span>
<span class="p_del">-			K(low_wmark_pages(zone)),</span>
<span class="p_del">-			K(high_wmark_pages(zone)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),</span>
<span class="p_del">-			K(zone-&gt;present_pages),</span>
<span class="p_del">-			K(zone-&gt;managed_pages),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_MLOCK)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_SLAB_RECLAIMABLE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_FREE_PAGES)),</span>
<span class="p_add">+			PtoK(min_wmark_pages(zone)),</span>
<span class="p_add">+			PtoK(low_wmark_pages(zone)),</span>
<span class="p_add">+			PtoK(high_wmark_pages(zone)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),</span>
<span class="p_add">+			PtoK(zone-&gt;present_pages),</span>
<span class="p_add">+			PtoK(zone-&gt;managed_pages),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_MLOCK)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_SLAB_RECLAIMABLE)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_SLAB_UNRECLAIMABLE)),</span>
 			zone_page_state(zone, NR_KERNEL_STACK_KB),
<span class="p_del">-			K(zone_page_state(zone, NR_PAGETABLE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_BOUNCE)),</span>
<span class="p_del">-			K(free_pcp),</span>
<span class="p_del">-			K(this_cpu_read(zone-&gt;pageset-&gt;pcp.count)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_FREE_CMA_PAGES)));</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_PAGETABLE)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_BOUNCE)),</span>
<span class="p_add">+			PtoK(free_pcp),</span>
<span class="p_add">+			PtoK(this_cpu_read(zone-&gt;pageset-&gt;pcp.count)),</span>
<span class="p_add">+			PtoK(zone_page_state(zone, NR_FREE_CMA_PAGES)));</span>
 		printk(&quot;lowmem_reserve[]:&quot;);
 		for (i = 0; i &lt; MAX_NR_ZONES; i++)
 			printk(KERN_CONT &quot; %ld&quot;, zone-&gt;lowmem_reserve[i]);
<span class="p_chunk">@@ -4678,11 +4678,11 @@</span> <span class="p_context"> void show_free_areas(unsigned int filter, nodemask_t *nodemask)</span>
 		spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);
 		for (order = 0; order &lt; MAX_ORDER; order++) {
 			printk(KERN_CONT &quot;%lu*%lukB &quot;,
<span class="p_del">-			       nr[order], K(1UL) &lt;&lt; order);</span>
<span class="p_add">+			       nr[order], PtoK(1UL) &lt;&lt; order);</span>
 			if (nr[order])
 				show_migration_types(types[order]);
 		}
<span class="p_del">-		printk(KERN_CONT &quot;= %lukB\n&quot;, K(total));</span>
<span class="p_add">+		printk(KERN_CONT &quot;= %lukB\n&quot;, PtoK(total));</span>
 	}
 
 	hugetlb_show_meminfo();

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



