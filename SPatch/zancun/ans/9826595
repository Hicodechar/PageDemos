
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.11.9 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.11.9</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 5, 2017, 2:10 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170705141014.GB6047@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9826595/mbox/"
   >mbox</a>
|
   <a href="/patch/9826595/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9826595/">/patch/9826595/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	0E4B960317 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Jul 2017 14:10:35 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D639B28542
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Jul 2017 14:10:34 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C9E3B2854A; Wed,  5 Jul 2017 14:10:34 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id AF2F32854F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Jul 2017 14:10:28 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752123AbdGEOKY (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 5 Jul 2017 10:10:24 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:60570 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752087AbdGEOKQ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 5 Jul 2017 10:10:16 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 81D2DBE7;
	Wed,  5 Jul 2017 14:10:14 +0000 (UTC)
Date: Wed, 5 Jul 2017 16:10:14 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.11.9
Message-ID: &lt;20170705141014.GB6047@kroah.com&gt;
References: &lt;20170705141007.GA6047@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170705141007.GA6047@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - July 5, 2017, 2:10 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 8c5c94ca56d9..9db9095e0d7b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 11
<span class="p_del">-SUBLEVEL = 8</span>
<span class="p_add">+SUBLEVEL = 9</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/arm/mach-davinci/pm.c b/arch/arm/mach-davinci/pm.c</span>
<span class="p_header">index 0afd201ab980..28255af5f2d8 100644</span>
<span class="p_header">--- a/arch/arm/mach-davinci/pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-davinci/pm.c</span>
<span class="p_chunk">@@ -154,7 +154,8 @@</span> <span class="p_context"> int __init davinci_pm_init(void)</span>
 	davinci_sram_suspend = sram_alloc(davinci_cpu_suspend_sz, NULL);
 	if (!davinci_sram_suspend) {
 		pr_err(&quot;PM: cannot allocate SRAM memory\n&quot;);
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto no_sram_mem;</span>
 	}
 
 	davinci_sram_push(davinci_sram_suspend, davinci_cpu_suspend,
<span class="p_chunk">@@ -162,6 +163,10 @@</span> <span class="p_context"> int __init davinci_pm_init(void)</span>
 
 	suspend_set_ops(&amp;davinci_pm_ops);
 
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+no_sram_mem:</span>
<span class="p_add">+	iounmap(pm_config.ddrpsc_reg_base);</span>
 no_ddrpsc_mem:
 	iounmap(pm_config.ddrpll_reg_base);
 no_ddrpll_mem:
<span class="p_header">diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c</span>
<span class="p_header">index 347cca965783..2a343349d4c4 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmu.c</span>
<span class="p_chunk">@@ -1216,15 +1216,15 @@</span> <span class="p_context"> void __init adjust_lowmem_bounds(void)</span>
 
 	high_memory = __va(arm_lowmem_limit - 1) + 1;
 
<span class="p_add">+	if (!memblock_limit)</span>
<span class="p_add">+		memblock_limit = arm_lowmem_limit;</span>
<span class="p_add">+</span>
 	/*
 	 * Round the memblock limit down to a pmd size.  This
 	 * helps to ensure that we will allocate memory from the
 	 * last full pmd, which should be mapped.
 	 */
<span class="p_del">-	if (memblock_limit)</span>
<span class="p_del">-		memblock_limit = round_down(memblock_limit, PMD_SIZE);</span>
<span class="p_del">-	if (!memblock_limit)</span>
<span class="p_del">-		memblock_limit = arm_lowmem_limit;</span>
<span class="p_add">+	memblock_limit = round_down(memblock_limit, PMD_SIZE);</span>
 
 	if (!IS_ENABLED(CONFIG_HIGHMEM) || cache_is_vipt_aliasing()) {
 		if (memblock_end_of_DRAM() &gt; arm_lowmem_limit) {
<span class="p_header">diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">index c1976c0adca7..ae66f5ef11f1 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/acpi.h</span>
<span class="p_chunk">@@ -23,9 +23,9 @@</span> <span class="p_context"></span>
 #define ACPI_MADT_GICC_LENGTH	\
 	(acpi_gbl_FADT.header.revision &lt; 6 ? 76 : 80)
 
<span class="p_del">-#define BAD_MADT_GICC_ENTRY(entry, end)						\</span>
<span class="p_del">-	(!(entry) || (unsigned long)(entry) + sizeof(*(entry)) &gt; (end) ||	\</span>
<span class="p_del">-	 (entry)-&gt;header.length != ACPI_MADT_GICC_LENGTH)</span>
<span class="p_add">+#define BAD_MADT_GICC_ENTRY(entry, end)					\</span>
<span class="p_add">+	(!(entry) || (entry)-&gt;header.length != ACPI_MADT_GICC_LENGTH ||	\</span>
<span class="p_add">+	(unsigned long)(entry) + ACPI_MADT_GICC_LENGTH &gt; (end))</span>
 
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI
<span class="p_header">diff --git a/arch/arm64/kernel/pci.c b/arch/arm64/kernel/pci.c</span>
<span class="p_header">index 4f0e3ebfea4b..c7e3e6387a49 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/pci.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/pci.c</span>
<span class="p_chunk">@@ -191,8 +191,10 @@</span> <span class="p_context"> struct pci_bus *pci_acpi_scan_root(struct acpi_pci_root *root)</span>
 		return NULL;
 
 	root_ops = kzalloc_node(sizeof(*root_ops), GFP_KERNEL, node);
<span class="p_del">-	if (!root_ops)</span>
<span class="p_add">+	if (!root_ops) {</span>
<span class="p_add">+		kfree(ri);</span>
 		return NULL;
<span class="p_add">+	}</span>
 
 	ri-&gt;cfg = pci_acpi_setup_ecam_mapping(root);
 	if (!ri-&gt;cfg) {
<span class="p_header">diff --git a/arch/mips/kernel/entry.S b/arch/mips/kernel/entry.S</span>
<span class="p_header">index 8d83fc2a96b7..38a302919e6b 100644</span>
<span class="p_header">--- a/arch/mips/kernel/entry.S</span>
<span class="p_header">+++ b/arch/mips/kernel/entry.S</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/asm.h&gt;
 #include &lt;asm/asmmacro.h&gt;
 #include &lt;asm/compiler.h&gt;
<span class="p_add">+#include &lt;asm/irqflags.h&gt;</span>
 #include &lt;asm/regdef.h&gt;
 #include &lt;asm/mipsregs.h&gt;
 #include &lt;asm/stackframe.h&gt;
<span class="p_chunk">@@ -119,6 +120,7 @@</span> <span class="p_context"> work_pending:</span>
 	andi	t0, a2, _TIF_NEED_RESCHED # a2 is preloaded with TI_FLAGS
 	beqz	t0, work_notifysig
 work_resched:
<span class="p_add">+	TRACE_IRQS_OFF</span>
 	jal	schedule
 
 	local_irq_disable		# make sure need_resched and
<span class="p_chunk">@@ -155,6 +157,7 @@</span> <span class="p_context"> syscall_exit_work:</span>
 	beqz	t0, work_pending	# trace bit set?
 	local_irq_enable		# could let syscall_trace_leave()
 					# call schedule() instead
<span class="p_add">+	TRACE_IRQS_ON</span>
 	move	a0, sp
 	jal	syscall_trace_leave
 	b	resume_userspace
<span class="p_header">diff --git a/arch/mips/kernel/head.S b/arch/mips/kernel/head.S</span>
<span class="p_header">index cf052204eb0a..d1bb506adc10 100644</span>
<span class="p_header">--- a/arch/mips/kernel/head.S</span>
<span class="p_header">+++ b/arch/mips/kernel/head.S</span>
<span class="p_chunk">@@ -106,8 +106,8 @@</span> <span class="p_context"> NESTED(kernel_entry, 16, sp)			# kernel entry point</span>
 	beq		t0, t1, dtb_found
 #endif
 	li		t1, -2
<span class="p_del">-	beq		a0, t1, dtb_found</span>
 	move		t2, a1
<span class="p_add">+	beq		a0, t1, dtb_found</span>
 
 	li		t2, 0
 dtb_found:
<span class="p_header">diff --git a/arch/mips/kernel/pm-cps.c b/arch/mips/kernel/pm-cps.c</span>
<span class="p_header">index 5f928c34c148..d99416094ba9 100644</span>
<span class="p_header">--- a/arch/mips/kernel/pm-cps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/pm-cps.c</span>
<span class="p_chunk">@@ -56,7 +56,6 @@</span> <span class="p_context"> DECLARE_BITMAP(state_support, CPS_PM_STATE_COUNT);</span>
  * state. Actually per-core rather than per-CPU.
  */
 static DEFINE_PER_CPU_ALIGNED(u32*, ready_count);
<span class="p_del">-static DEFINE_PER_CPU_ALIGNED(void*, ready_count_alloc);</span>
 
 /* Indicates online CPUs coupled with the current CPU */
 static DEFINE_PER_CPU_ALIGNED(cpumask_t, online_coupled);
<span class="p_chunk">@@ -642,7 +641,6 @@</span> <span class="p_context"> static int cps_pm_online_cpu(unsigned int cpu)</span>
 {
 	enum cps_pm_state state;
 	unsigned core = cpu_data[cpu].core;
<span class="p_del">-	unsigned dlinesz = cpu_data[cpu].dcache.linesz;</span>
 	void *entry_fn, *core_rc;
 
 	for (state = CPS_PM_NC_WAIT; state &lt; CPS_PM_STATE_COUNT; state++) {
<span class="p_chunk">@@ -662,16 +660,11 @@</span> <span class="p_context"> static int cps_pm_online_cpu(unsigned int cpu)</span>
 	}
 
 	if (!per_cpu(ready_count, core)) {
<span class="p_del">-		core_rc = kmalloc(dlinesz * 2, GFP_KERNEL);</span>
<span class="p_add">+		core_rc = kmalloc(sizeof(u32), GFP_KERNEL);</span>
 		if (!core_rc) {
 			pr_err(&quot;Failed allocate core %u ready_count\n&quot;, core);
 			return -ENOMEM;
 		}
<span class="p_del">-		per_cpu(ready_count_alloc, core) = core_rc;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Ensure ready_count is aligned to a cacheline boundary */</span>
<span class="p_del">-		core_rc += dlinesz - 1;</span>
<span class="p_del">-		core_rc = (void *)((unsigned long)core_rc &amp; ~(dlinesz - 1));</span>
 		per_cpu(ready_count, core) = core_rc;
 	}
 
<span class="p_header">diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c</span>
<span class="p_header">index b49e7bf9f950..0b675023b9c6 100644</span>
<span class="p_header">--- a/arch/mips/kernel/traps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/traps.c</span>
<span class="p_chunk">@@ -201,6 +201,8 @@</span> <span class="p_context"> void show_stack(struct task_struct *task, unsigned long *sp)</span>
 {
 	struct pt_regs regs;
 	mm_segment_t old_fs = get_fs();
<span class="p_add">+</span>
<span class="p_add">+	regs.cp0_status = KSU_KERNEL;</span>
 	if (sp) {
 		regs.regs[29] = (unsigned long)sp;
 		regs.regs[31] = 0;
<span class="p_header">diff --git a/arch/x86/boot/compressed/kaslr.c b/arch/x86/boot/compressed/kaslr.c</span>
<span class="p_header">index 8b7c9e75edcb..8fad8a64d670 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/kaslr.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/kaslr.c</span>
<span class="p_chunk">@@ -564,9 +564,6 @@</span> <span class="p_context"> void choose_random_location(unsigned long input,</span>
 {
 	unsigned long random_addr, min_addr;
 
<span class="p_del">-	/* By default, keep output position unchanged. */</span>
<span class="p_del">-	*virt_addr = *output;</span>
<span class="p_del">-</span>
 	if (cmdline_find_option_bool(&quot;nokaslr&quot;)) {
 		warn(&quot;KASLR disabled: &#39;nokaslr&#39; on cmdline.&quot;);
 		return;
<span class="p_header">diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c</span>
<span class="p_header">index b3c5a5f030ce..c945acd8fa33 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -338,7 +338,7 @@</span> <span class="p_context"> asmlinkage __visible void *extract_kernel(void *rmode, memptr heap,</span>
 				  unsigned long output_len)
 {
 	const unsigned long kernel_total_size = VO__end - VO__text;
<span class="p_del">-	unsigned long virt_addr = (unsigned long)output;</span>
<span class="p_add">+	unsigned long virt_addr = LOAD_PHYSICAL_ADDR;</span>
 
 	/* Retain x86 boot parameters pointer passed from startup_32/64. */
 	boot_params = rmode;
<span class="p_chunk">@@ -397,7 +397,7 @@</span> <span class="p_context"> asmlinkage __visible void *extract_kernel(void *rmode, memptr heap,</span>
 #ifndef CONFIG_RELOCATABLE
 	if ((unsigned long)output != LOAD_PHYSICAL_ADDR)
 		error(&quot;Destination address does not match LOAD_PHYSICAL_ADDR&quot;);
<span class="p_del">-	if ((unsigned long)output != virt_addr)</span>
<span class="p_add">+	if (virt_addr != LOAD_PHYSICAL_ADDR)</span>
 		error(&quot;Destination virtual address changed when not relocatable&quot;);
 #endif
 
<span class="p_header">diff --git a/arch/x86/boot/compressed/misc.h b/arch/x86/boot/compressed/misc.h</span>
<span class="p_header">index 1c8355eadbd1..766a5211f827 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/misc.h</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/misc.h</span>
<span class="p_chunk">@@ -81,8 +81,6 @@</span> <span class="p_context"> static inline void choose_random_location(unsigned long input,</span>
 					  unsigned long output_size,
 					  unsigned long *virt_addr)
 {
<span class="p_del">-	/* No change from existing output location. */</span>
<span class="p_del">-	*virt_addr = *output;</span>
 }
 #endif
 
<span class="p_header">diff --git a/arch/x86/entry/entry_32.S b/arch/x86/entry/entry_32.S</span>
<span class="p_header">index 57f7ec35216e..701d29f8e4d3 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_32.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_32.S</span>
<span class="p_chunk">@@ -255,6 +255,23 @@</span> <span class="p_context"> ENTRY(__switch_to_asm)</span>
 END(__switch_to_asm)
 
 /*
<span class="p_add">+ * The unwinder expects the last frame on the stack to always be at the same</span>
<span class="p_add">+ * offset from the end of the page, which allows it to validate the stack.</span>
<span class="p_add">+ * Calling schedule_tail() directly would break that convention because its an</span>
<span class="p_add">+ * asmlinkage function so its argument has to be pushed on the stack.  This</span>
<span class="p_add">+ * wrapper creates a proper &quot;end of stack&quot; frame header before the call.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(schedule_tail_wrapper)</span>
<span class="p_add">+	FRAME_BEGIN</span>
<span class="p_add">+</span>
<span class="p_add">+	pushl	%eax</span>
<span class="p_add">+	call	schedule_tail</span>
<span class="p_add">+	popl	%eax</span>
<span class="p_add">+</span>
<span class="p_add">+	FRAME_END</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(schedule_tail_wrapper)</span>
<span class="p_add">+/*</span>
  * A newly forked process directly context switches into this address.
  *
  * eax: prev task we switched from
<span class="p_chunk">@@ -262,24 +279,15 @@</span> <span class="p_context"> END(__switch_to_asm)</span>
  * edi: kernel thread arg
  */
 ENTRY(ret_from_fork)
<span class="p_del">-	FRAME_BEGIN		/* help unwinder find end of stack */</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * schedule_tail() is asmlinkage so we have to put its &#39;prev&#39; argument</span>
<span class="p_del">-	 * on the stack.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pushl	%eax</span>
<span class="p_del">-	call	schedule_tail</span>
<span class="p_del">-	popl	%eax</span>
<span class="p_add">+	call	schedule_tail_wrapper</span>
 
 	testl	%ebx, %ebx
 	jnz	1f		/* kernel threads are uncommon */
 
 2:
 	/* When we fork, we trace the syscall return in the child, too. */
<span class="p_del">-	leal	FRAME_OFFSET(%esp), %eax</span>
<span class="p_add">+	movl    %esp, %eax</span>
 	call    syscall_return_slowpath
<span class="p_del">-	FRAME_END</span>
 	jmp     restore_all
 
 	/* kernel thread */
<span class="p_header">diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S</span>
<span class="p_header">index 044d18ebc43c..5b219707c2f2 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_64.S</span>
<span class="p_chunk">@@ -36,7 +36,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/smap.h&gt;
 #include &lt;asm/pgtable_types.h&gt;
 #include &lt;asm/export.h&gt;
<span class="p_del">-#include &lt;asm/frame.h&gt;</span>
 #include &lt;linux/err.h&gt;
 
 .code64
<span class="p_chunk">@@ -409,19 +408,17 @@</span> <span class="p_context"> END(__switch_to_asm)</span>
  * r12: kernel thread arg
  */
 ENTRY(ret_from_fork)
<span class="p_del">-	FRAME_BEGIN			/* help unwinder find end of stack */</span>
 	movq	%rax, %rdi
<span class="p_del">-	call	schedule_tail		/* rdi: &#39;prev&#39; task parameter */</span>
<span class="p_add">+	call	schedule_tail			/* rdi: &#39;prev&#39; task parameter */</span>
 
<span class="p_del">-	testq	%rbx, %rbx		/* from kernel_thread? */</span>
<span class="p_del">-	jnz	1f			/* kernel threads are uncommon */</span>
<span class="p_add">+	testq	%rbx, %rbx			/* from kernel_thread? */</span>
<span class="p_add">+	jnz	1f				/* kernel threads are uncommon */</span>
 
 2:
<span class="p_del">-	leaq	FRAME_OFFSET(%rsp),%rdi	/* pt_regs pointer */</span>
<span class="p_add">+	movq	%rsp, %rdi</span>
 	call	syscall_return_slowpath	/* returns with IRQs disabled */
 	TRACE_IRQS_ON			/* user mode is traced as IRQS on */
 	SWAPGS
<span class="p_del">-	FRAME_END</span>
 	jmp	restore_regs_and_iret
 
 1:
<span class="p_header">diff --git a/arch/x86/events/intel/core.c b/arch/x86/events/intel/core.c</span>
<span class="p_header">index 65c2ca578556..78da7b646cd0 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/core.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/core.c</span>
<span class="p_chunk">@@ -2130,7 +2130,7 @@</span> <span class="p_context"> static int intel_pmu_handle_irq(struct pt_regs *regs)</span>
 	 * counters from the GLOBAL_STATUS mask and we always process PEBS
 	 * events via drain_pebs().
 	 */
<span class="p_del">-	status &amp;= ~cpuc-&gt;pebs_enabled;</span>
<span class="p_add">+	status &amp;= ~(cpuc-&gt;pebs_enabled &amp; PEBS_COUNTER_MASK);</span>
 
 	/*
 	 * PEBS overflow sets bit 62 in the global status register
<span class="p_header">diff --git a/arch/x86/events/intel/ds.c b/arch/x86/events/intel/ds.c</span>
<span class="p_header">index 9dfeeeca0ea8..c6d23ffe422d 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/ds.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/ds.c</span>
<span class="p_chunk">@@ -1222,7 +1222,7 @@</span> <span class="p_context"> get_next_pebs_record_by_bit(void *base, void *top, int bit)</span>
 
 			/* clear non-PEBS bit and re-check */
 			pebs_status = p-&gt;status &amp; cpuc-&gt;pebs_enabled;
<span class="p_del">-			pebs_status &amp;= (1ULL &lt;&lt; MAX_PEBS_EVENTS) - 1;</span>
<span class="p_add">+			pebs_status &amp;= PEBS_COUNTER_MASK;</span>
 			if (pebs_status == (1 &lt;&lt; bit))
 				return at;
 		}
<span class="p_header">diff --git a/arch/x86/events/intel/uncore.c b/arch/x86/events/intel/uncore.c</span>
<span class="p_header">index 758c1aa5009d..44ec523287f6 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/uncore.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/uncore.c</span>
<span class="p_chunk">@@ -1170,7 +1170,7 @@</span> <span class="p_context"> static int uncore_event_cpu_online(unsigned int cpu)</span>
 		pmu = type-&gt;pmus;
 		for (i = 0; i &lt; type-&gt;num_boxes; i++, pmu++) {
 			box = pmu-&gt;boxes[pkg];
<span class="p_del">-			if (!box &amp;&amp; atomic_inc_return(&amp;box-&gt;refcnt) == 1)</span>
<span class="p_add">+			if (box &amp;&amp; atomic_inc_return(&amp;box-&gt;refcnt) == 1)</span>
 				uncore_box_init(box);
 		}
 	}
<span class="p_header">diff --git a/arch/x86/events/perf_event.h b/arch/x86/events/perf_event.h</span>
<span class="p_header">index bcbb1d2ae10b..be3d36254040 100644</span>
<span class="p_header">--- a/arch/x86/events/perf_event.h</span>
<span class="p_header">+++ b/arch/x86/events/perf_event.h</span>
<span class="p_chunk">@@ -79,6 +79,7 @@</span> <span class="p_context"> struct amd_nb {</span>
 
 /* The maximal number of PEBS events: */
 #define MAX_PEBS_EVENTS		8
<span class="p_add">+#define PEBS_COUNTER_MASK	((1ULL &lt;&lt; MAX_PEBS_EVENTS) - 1)</span>
 
 /*
  * Flags PEBS can handle without an PMI.
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_emulate.h b/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_header">index d5f83cda1dea..722d0e568863 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -221,6 +221,9 @@</span> <span class="p_context"> struct x86_emulate_ops {</span>
 	void (*get_cpuid)(struct x86_emulate_ctxt *ctxt,
 			  u32 *eax, u32 *ebx, u32 *ecx, u32 *edx);
 	void (*set_nmi_mask)(struct x86_emulate_ctxt *ctxt, bool masked);
<span class="p_add">+</span>
<span class="p_add">+	unsigned (*get_hflags)(struct x86_emulate_ctxt *ctxt);</span>
<span class="p_add">+	void (*set_hflags)(struct x86_emulate_ctxt *ctxt, unsigned hflags);</span>
 };
 
 typedef u32 __attribute__((vector_size(16))) sse128_t;
<span class="p_chunk">@@ -290,7 +293,6 @@</span> <span class="p_context"> struct x86_emulate_ctxt {</span>
 
 	/* interruptibility state, as a result of execution of STI or MOV SS */
 	int interruptibility;
<span class="p_del">-	int emul_flags;</span>
 
 	bool perm_ok; /* do not check permissions if true */
 	bool ud;	/* inject an #UD if host doesn&#39;t support insn */
<span class="p_header">diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h</span>
<span class="p_header">index 7c9c895432a9..6a348b6f73a2 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mshyperv.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mshyperv.h</span>
<span class="p_chunk">@@ -2,8 +2,7 @@</span> <span class="p_context"></span>
 #define _ASM_X86_MSHYPER_H
 
 #include &lt;linux/types.h&gt;
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
<span class="p_del">-#include &lt;linux/clocksource.h&gt;</span>
<span class="p_add">+#include &lt;linux/atomic.h&gt;</span>
 #include &lt;asm/hyperv.h&gt;
 
 /*
<span class="p_header">diff --git a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c</span>
<span class="p_header">index 9ac2a5cdd9c2..e79fb6b3dffe 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c</span>
<span class="p_chunk">@@ -767,11 +767,13 @@</span> <span class="p_context"> static struct dentry *rdt_mount(struct file_system_type *fs_type,</span>
 	dentry = kernfs_mount(fs_type, flags, rdt_root,
 			      RDTGROUP_SUPER_MAGIC, NULL);
 	if (IS_ERR(dentry))
<span class="p_del">-		goto out_cdp;</span>
<span class="p_add">+		goto out_destroy;</span>
 
 	static_branch_enable(&amp;rdt_enable_key);
 	goto out;
 
<span class="p_add">+out_destroy:</span>
<span class="p_add">+	kernfs_remove(kn_info);</span>
 out_cdp:
 	cdp_disable();
 out:
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index ce7f80baa664..0fca363787ff 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -2547,7 +2547,7 @@</span> <span class="p_context"> static int em_rsm(struct x86_emulate_ctxt *ctxt)</span>
 	u64 smbase;
 	int ret;
 
<span class="p_del">-	if ((ctxt-&gt;emul_flags &amp; X86EMUL_SMM_MASK) == 0)</span>
<span class="p_add">+	if ((ctxt-&gt;ops-&gt;get_hflags(ctxt) &amp; X86EMUL_SMM_MASK) == 0)</span>
 		return emulate_ud(ctxt);
 
 	/*
<span class="p_chunk">@@ -2596,11 +2596,11 @@</span> <span class="p_context"> static int em_rsm(struct x86_emulate_ctxt *ctxt)</span>
 		return X86EMUL_UNHANDLEABLE;
 	}
 
<span class="p_del">-	if ((ctxt-&gt;emul_flags &amp; X86EMUL_SMM_INSIDE_NMI_MASK) == 0)</span>
<span class="p_add">+	if ((ctxt-&gt;ops-&gt;get_hflags(ctxt) &amp; X86EMUL_SMM_INSIDE_NMI_MASK) == 0)</span>
 		ctxt-&gt;ops-&gt;set_nmi_mask(ctxt, false);
 
<span class="p_del">-	ctxt-&gt;emul_flags &amp;= ~X86EMUL_SMM_INSIDE_NMI_MASK;</span>
<span class="p_del">-	ctxt-&gt;emul_flags &amp;= ~X86EMUL_SMM_MASK;</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;set_hflags(ctxt, ctxt-&gt;ops-&gt;get_hflags(ctxt) &amp;</span>
<span class="p_add">+		~(X86EMUL_SMM_INSIDE_NMI_MASK | X86EMUL_SMM_MASK));</span>
 	return X86EMUL_CONTINUE;
 }
 
<span class="p_chunk">@@ -5317,6 +5317,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 	const struct x86_emulate_ops *ops = ctxt-&gt;ops;
 	int rc = X86EMUL_CONTINUE;
 	int saved_dst_type = ctxt-&gt;dst.type;
<span class="p_add">+	unsigned emul_flags;</span>
 
 	ctxt-&gt;mem_read.pos = 0;
 
<span class="p_chunk">@@ -5331,6 +5332,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 		goto done;
 	}
 
<span class="p_add">+	emul_flags = ctxt-&gt;ops-&gt;get_hflags(ctxt);</span>
 	if (unlikely(ctxt-&gt;d &amp;
 		     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {
 		if ((ctxt-&gt;mode == X86EMUL_MODE_PROT64 &amp;&amp; (ctxt-&gt;d &amp; No64)) ||
<span class="p_chunk">@@ -5364,7 +5366,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 				fetch_possible_mmx_operand(ctxt, &amp;ctxt-&gt;dst);
 		}
 
<span class="p_del">-		if (unlikely(ctxt-&gt;emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; ctxt-&gt;intercept) {</span>
<span class="p_add">+		if (unlikely(emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; ctxt-&gt;intercept) {</span>
 			rc = emulator_check_intercept(ctxt, ctxt-&gt;intercept,
 						      X86_ICPT_PRE_EXCEPT);
 			if (rc != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -5393,7 +5395,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 				goto done;
 		}
 
<span class="p_del">-		if (unlikely(ctxt-&gt;emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
<span class="p_add">+		if (unlikely(emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
 			rc = emulator_check_intercept(ctxt, ctxt-&gt;intercept,
 						      X86_ICPT_POST_EXCEPT);
 			if (rc != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -5447,7 +5449,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 
 special_insn:
 
<span class="p_del">-	if (unlikely(ctxt-&gt;emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
<span class="p_add">+	if (unlikely(emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
 		rc = emulator_check_intercept(ctxt, ctxt-&gt;intercept,
 					      X86_ICPT_POST_MEMACCESS);
 		if (rc != X86EMUL_CONTINUE)
<span class="p_header">diff --git a/arch/x86/kvm/pmu_intel.c b/arch/x86/kvm/pmu_intel.c</span>
<span class="p_header">index 9d4a8504a95a..5ab4a364348e 100644</span>
<span class="p_header">--- a/arch/x86/kvm/pmu_intel.c</span>
<span class="p_header">+++ b/arch/x86/kvm/pmu_intel.c</span>
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> static void intel_pmu_refresh(struct kvm_vcpu *vcpu)</span>
 			((u64)1 &lt;&lt; edx.split.bit_width_fixed) - 1;
 	}
 
<span class="p_del">-	pmu-&gt;global_ctrl = ((1 &lt;&lt; pmu-&gt;nr_arch_gp_counters) - 1) |</span>
<span class="p_add">+	pmu-&gt;global_ctrl = ((1ull &lt;&lt; pmu-&gt;nr_arch_gp_counters) - 1) |</span>
 		(((1ull &lt;&lt; pmu-&gt;nr_arch_fixed_counters) - 1) &lt;&lt; INTEL_PMC_IDX_FIXED);
 	pmu-&gt;global_ctrl_mask = ~pmu-&gt;global_ctrl;
 
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 259e9b28ccf8..e06ec5333da1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -2436,7 +2436,7 @@</span> <span class="p_context"> static int nested_vmx_check_exception(struct kvm_vcpu *vcpu, unsigned nr)</span>
 	if (!(vmcs12-&gt;exception_bitmap &amp; (1u &lt;&lt; nr)))
 		return 0;
 
<span class="p_del">-	nested_vmx_vmexit(vcpu, to_vmx(vcpu)-&gt;exit_reason,</span>
<span class="p_add">+	nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,</span>
 			  vmcs_read32(VM_EXIT_INTR_INFO),
 			  vmcs_readl(EXIT_QUALIFICATION));
 	return 1;
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index dd1fe338c5f5..4e957185d5b3 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -5098,6 +5098,8 @@</span> <span class="p_context"> static bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,</span>
 
 	if (var.unusable) {
 		memset(desc, 0, sizeof(*desc));
<span class="p_add">+		if (base3)</span>
<span class="p_add">+			*base3 = 0;</span>
 		return false;
 	}
 
<span class="p_chunk">@@ -5248,6 +5250,16 @@</span> <span class="p_context"> static void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)</span>
 	kvm_x86_ops-&gt;set_nmi_mask(emul_to_vcpu(ctxt), masked);
 }
 
<span class="p_add">+static unsigned emulator_get_hflags(struct x86_emulate_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return emul_to_vcpu(ctxt)-&gt;arch.hflags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void emulator_set_hflags(struct x86_emulate_ctxt *ctxt, unsigned emul_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kvm_set_hflags(emul_to_vcpu(ctxt), emul_flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct x86_emulate_ops emulate_ops = {
 	.read_gpr            = emulator_read_gpr,
 	.write_gpr           = emulator_write_gpr,
<span class="p_chunk">@@ -5287,6 +5299,8 @@</span> <span class="p_context"> static const struct x86_emulate_ops emulate_ops = {</span>
 	.intercept           = emulator_intercept,
 	.get_cpuid           = emulator_get_cpuid,
 	.set_nmi_mask        = emulator_set_nmi_mask,
<span class="p_add">+	.get_hflags          = emulator_get_hflags,</span>
<span class="p_add">+	.set_hflags          = emulator_set_hflags,</span>
 };
 
 static void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)
<span class="p_chunk">@@ -5341,7 +5355,6 @@</span> <span class="p_context"> static void init_emulate_ctxt(struct kvm_vcpu *vcpu)</span>
 	BUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);
 	BUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);
 	BUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);
<span class="p_del">-	ctxt-&gt;emul_flags = vcpu-&gt;arch.hflags;</span>
 
 	init_decode_cache(ctxt);
 	vcpu-&gt;arch.emulate_regs_need_sync_from_vcpu = false;
<span class="p_chunk">@@ -5744,8 +5757,6 @@</span> <span class="p_context"> int x86_emulate_instruction(struct kvm_vcpu *vcpu,</span>
 		unsigned long rflags = kvm_x86_ops-&gt;get_rflags(vcpu);
 		toggle_interruptibility(vcpu, ctxt-&gt;interruptibility);
 		vcpu-&gt;arch.emulate_regs_need_sync_to_vcpu = false;
<span class="p_del">-		if (vcpu-&gt;arch.hflags != ctxt-&gt;emul_flags)</span>
<span class="p_del">-			kvm_set_hflags(vcpu, ctxt-&gt;emul_flags);</span>
 		kvm_rip_write(vcpu, ctxt-&gt;eip);
 		if (r == EMULATE_DONE &amp;&amp;
 		    (ctxt-&gt;tf || (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_SINGLESTEP)))
<span class="p_header">diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c</span>
<span class="p_header">index 15173d37f399..e1e3f7b4bdb0 100644</span>
<span class="p_header">--- a/arch/x86/mm/init_64.c</span>
<span class="p_header">+++ b/arch/x86/mm/init_64.c</span>
<span class="p_chunk">@@ -94,10 +94,10 @@</span> <span class="p_context"> __setup(&quot;noexec32=&quot;, nonx32_setup);</span>
  */
 void sync_global_pgds(unsigned long start, unsigned long end)
 {
<span class="p_del">-	unsigned long address;</span>
<span class="p_add">+	unsigned long addr;</span>
 
<span class="p_del">-	for (address = start; address &lt;= end; address += PGDIR_SIZE) {</span>
<span class="p_del">-		const pgd_t *pgd_ref = pgd_offset_k(address);</span>
<span class="p_add">+	for (addr = start; addr &lt;= end; addr = ALIGN(addr + 1, PGDIR_SIZE)) {</span>
<span class="p_add">+		const pgd_t *pgd_ref = pgd_offset_k(addr);</span>
 		struct page *page;
 
 		if (pgd_none(*pgd_ref))
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> void sync_global_pgds(unsigned long start, unsigned long end)</span>
 			pgd_t *pgd;
 			spinlock_t *pgt_lock;
 
<span class="p_del">-			pgd = (pgd_t *)page_address(page) + pgd_index(address);</span>
<span class="p_add">+			pgd = (pgd_t *)page_address(page) + pgd_index(addr);</span>
 			/* the pgt_lock only for Xen */
 			pgt_lock = &amp;pgd_page_get_mm(page)-&gt;page_table_lock;
 			spin_lock(pgt_lock);
<span class="p_header">diff --git a/arch/x86/mm/mpx.c b/arch/x86/mm/mpx.c</span>
<span class="p_header">index cd44ae727df7..1c34b767c84c 100644</span>
<span class="p_header">--- a/arch/x86/mm/mpx.c</span>
<span class="p_header">+++ b/arch/x86/mm/mpx.c</span>
<span class="p_chunk">@@ -526,15 +526,7 @@</span> <span class="p_context"> int mpx_handle_bd_fault(void)</span>
 	if (!kernel_managing_mpx_tables(current-&gt;mm))
 		return -EINVAL;
 
<span class="p_del">-	if (do_mpx_bt_fault()) {</span>
<span class="p_del">-		force_sig(SIGSEGV, current);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The force_sig() is essentially &quot;handling&quot; this</span>
<span class="p_del">-		 * exception, so we do not pass up the error</span>
<span class="p_del">-		 * from do_mpx_bt_fault().</span>
<span class="p_del">-		 */</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return do_mpx_bt_fault();</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index a7655f6caf7d..75fb01109f94 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -263,8 +263,6 @@</span> <span class="p_context"> void native_flush_tlb_others(const struct cpumask *cpumask,</span>
 {
 	struct flush_tlb_info info;
 
<span class="p_del">-	if (end == 0)</span>
<span class="p_del">-		end = start + PAGE_SIZE;</span>
 	info.flush_mm = mm;
 	info.flush_start = start;
 	info.flush_end = end;
<span class="p_chunk">@@ -393,7 +391,7 @@</span> <span class="p_context"> void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)</span>
 	}
 
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
<span class="p_del">-		flush_tlb_others(mm_cpumask(mm), mm, start, 0UL);</span>
<span class="p_add">+		flush_tlb_others(mm_cpumask(mm), mm, start, start + PAGE_SIZE);</span>
 
 	preempt_enable();
 }
<span class="p_header">diff --git a/drivers/block/xen-blkback/blkback.c b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">index fbe0dfdffc0d..0e824091a12f 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_chunk">@@ -609,8 +609,6 @@</span> <span class="p_context"> int xen_blkif_schedule(void *arg)</span>
 	unsigned long timeout;
 	int ret;
 
<span class="p_del">-	xen_blkif_get(blkif);</span>
<span class="p_del">-</span>
 	set_freezable();
 	while (!kthread_should_stop()) {
 		if (try_to_freeze())
<span class="p_chunk">@@ -665,7 +663,6 @@</span> <span class="p_context"> int xen_blkif_schedule(void *arg)</span>
 		print_stats(ring);
 
 	ring-&gt;xenblkd = NULL;
<span class="p_del">-	xen_blkif_put(blkif);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/block/xen-blkback/xenbus.c b/drivers/block/xen-blkback/xenbus.c</span>
<span class="p_header">index dcabf52425ff..1ccb5a7bbdfe 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/xenbus.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/xenbus.c</span>
<span class="p_chunk">@@ -255,7 +255,6 @@</span> <span class="p_context"> static int xen_blkif_disconnect(struct xen_blkif *blkif)</span>
 		if (ring-&gt;xenblkd) {
 			kthread_stop(ring-&gt;xenblkd);
 			wake_up(&amp;ring-&gt;shutdown_wq);
<span class="p_del">-			ring-&gt;xenblkd = NULL;</span>
 		}
 
 		/* The above kthread_stop() guarantees that at this point we
<span class="p_chunk">@@ -316,8 +315,10 @@</span> <span class="p_context"> static int xen_blkif_disconnect(struct xen_blkif *blkif)</span>
 static void xen_blkif_free(struct xen_blkif *blkif)
 {
 
<span class="p_del">-	xen_blkif_disconnect(blkif);</span>
<span class="p_add">+	WARN_ON(xen_blkif_disconnect(blkif));</span>
 	xen_vbd_free(&amp;blkif-&gt;vbd);
<span class="p_add">+	kfree(blkif-&gt;be-&gt;mode);</span>
<span class="p_add">+	kfree(blkif-&gt;be);</span>
 
 	/* Make sure everything is drained before shutting down */
 	kmem_cache_free(xen_blkif_cachep, blkif);
<span class="p_chunk">@@ -512,8 +513,6 @@</span> <span class="p_context"> static int xen_blkbk_remove(struct xenbus_device *dev)</span>
 
 	/* Put the reference we set in xen_blkif_alloc(). */
 	xen_blkif_put(be-&gt;blkif);
<span class="p_del">-	kfree(be-&gt;mode);</span>
<span class="p_del">-	kfree(be);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c</span>
<span class="p_header">index 8b4d721d6d63..b5a43d66878a 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib.c</span>
<span class="p_chunk">@@ -708,7 +708,8 @@</span> <span class="p_context"> static irqreturn_t lineevent_irq_thread(int irq, void *p)</span>
 
 	ge.timestamp = ktime_get_real_ns();
 
<span class="p_del">-	if (le-&gt;eflags &amp; GPIOEVENT_REQUEST_BOTH_EDGES) {</span>
<span class="p_add">+	if (le-&gt;eflags &amp; GPIOEVENT_REQUEST_RISING_EDGE</span>
<span class="p_add">+	    &amp;&amp; le-&gt;eflags &amp; GPIOEVENT_REQUEST_FALLING_EDGE) {</span>
 		int level = gpiod_get_value_cansleep(le-&gt;desc);
 
 		if (level)
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c b/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c</span>
<span class="p_header">index 13db8a2851ed..1f013d45c9e9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c</span>
<span class="p_chunk">@@ -321,6 +321,7 @@</span> <span class="p_context"> void vmw_cmdbuf_res_man_destroy(struct vmw_cmdbuf_res_manager *man)</span>
 	list_for_each_entry_safe(entry, next, &amp;man-&gt;list, head)
 		vmw_cmdbuf_res_free(man, entry);
 
<span class="p_add">+	drm_ht_remove(&amp;man-&gt;resources);</span>
 	kfree(man);
 }
 
<span class="p_header">diff --git a/drivers/hsi/clients/ssi_protocol.c b/drivers/hsi/clients/ssi_protocol.c</span>
<span class="p_header">index 7ef819680acd..8251fa2904b6 100644</span>
<span class="p_header">--- a/drivers/hsi/clients/ssi_protocol.c</span>
<span class="p_header">+++ b/drivers/hsi/clients/ssi_protocol.c</span>
<span class="p_chunk">@@ -1065,7 +1065,7 @@</span> <span class="p_context"> static void ssip_pn_setup(struct net_device *dev)</span>
 	dev-&gt;addr_len		= 1;
 	dev-&gt;tx_queue_len	= SSIP_TXQUEUE_LEN;
 
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 	dev-&gt;header_ops		= &amp;phonet_header_ops;
 }
 
<span class="p_header">diff --git a/drivers/infiniband/hw/hns/hns_roce_hw_v1.c b/drivers/infiniband/hw/hns/hns_roce_hw_v1.c</span>
<span class="p_header">index b8111b0c8877..d4b3ca3dd0e4 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hns/hns_roce_hw_v1.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hns/hns_roce_hw_v1.c</span>
<span class="p_chunk">@@ -1851,6 +1851,7 @@</span> <span class="p_context"> void hns_roce_v1_cq_set_ci(struct hns_roce_cq *hr_cq, u32 cons_index)</span>
 	u32 doorbell[2];
 
 	doorbell[0] = cons_index &amp; ((hr_cq-&gt;cq_depth &lt;&lt; 1) - 1);
<span class="p_add">+	doorbell[1] = 0;</span>
 	roce_set_bit(doorbell[1], ROCEE_DB_OTHERS_H_ROCEE_DB_OTH_HW_SYNS_S, 1);
 	roce_set_field(doorbell[1], ROCEE_DB_OTHERS_H_ROCEE_DB_OTH_CMD_M,
 		       ROCEE_DB_OTHERS_H_ROCEE_DB_OTH_CMD_S, 3);
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index b17536d6e69b..3f25d881b343 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -3879,11 +3879,9 @@</span> <span class="p_context"> static void irte_ga_prepare(void *entry,</span>
 			    u8 vector, u32 dest_apicid, int devid)
 {
 	struct irte_ga *irte = (struct irte_ga *) entry;
<span class="p_del">-	struct iommu_dev_data *dev_data = search_dev_data(devid);</span>
 
 	irte-&gt;lo.val                      = 0;
 	irte-&gt;hi.val                      = 0;
<span class="p_del">-	irte-&gt;lo.fields_remap.guest_mode  = dev_data ? dev_data-&gt;use_vapic : 0;</span>
 	irte-&gt;lo.fields_remap.int_type    = delivery_mode;
 	irte-&gt;lo.fields_remap.dm          = dest_mode;
 	irte-&gt;hi.fields.vector            = vector;
<span class="p_chunk">@@ -3939,10 +3937,10 @@</span> <span class="p_context"> static void irte_ga_set_affinity(void *entry, u16 devid, u16 index,</span>
 	struct irte_ga *irte = (struct irte_ga *) entry;
 	struct iommu_dev_data *dev_data = search_dev_data(devid);
 
<span class="p_del">-	if (!dev_data || !dev_data-&gt;use_vapic) {</span>
<span class="p_add">+	if (!dev_data || !dev_data-&gt;use_vapic ||</span>
<span class="p_add">+	    !irte-&gt;lo.fields_remap.guest_mode) {</span>
 		irte-&gt;hi.fields.vector = vector;
 		irte-&gt;lo.fields_remap.destination = dest_apicid;
<span class="p_del">-		irte-&gt;lo.fields_remap.guest_mode = 0;</span>
 		modify_irte_ga(devid, index, irte, NULL);
 	}
 }
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_v2.c b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">index 063343909b0d..6629c472eafd 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_chunk">@@ -696,9 +696,9 @@</span> <span class="p_context"> int amd_iommu_bind_pasid(struct pci_dev *pdev, int pasid,</span>
 
 out_unregister:
 	mmu_notifier_unregister(&amp;pasid_state-&gt;mn, mm);
<span class="p_add">+	mmput(mm);</span>
 
 out_free:
<span class="p_del">-	mmput(mm);</span>
 	free_pasid_state(pasid_state);
 
 out:
<span class="p_header">diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c</span>
<span class="p_header">index 48d36ce59efb..1e0983488a8d 100644</span>
<span class="p_header">--- a/drivers/iommu/dma-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/dma-iommu.c</span>
<span class="p_chunk">@@ -175,8 +175,7 @@</span> <span class="p_context"> static void iova_reserve_pci_windows(struct pci_dev *dev,</span>
 	unsigned long lo, hi;
 
 	resource_list_for_each_entry(window, &amp;bridge-&gt;windows) {
<span class="p_del">-		if (resource_type(window-&gt;res) != IORESOURCE_MEM &amp;&amp;</span>
<span class="p_del">-		    resource_type(window-&gt;res) != IORESOURCE_IO)</span>
<span class="p_add">+		if (resource_type(window-&gt;res) != IORESOURCE_MEM)</span>
 			continue;
 
 		lo = iova_pfn(iovad, window-&gt;res-&gt;start - window-&gt;offset);
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index 5742e5eb0704..f68e8c5ca386 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -1094,6 +1094,19 @@</span> <span class="p_context"> static void process_prepared_discard_passdown_pt1(struct dm_thin_new_mapping *m)</span>
 		return;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Increment the unmapped blocks.  This prevents a race between the</span>
<span class="p_add">+	 * passdown io and reallocation of freed blocks.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	r = dm_pool_inc_data_range(pool-&gt;pmd, m-&gt;data_block, data_end);</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		metadata_operation_failed(pool, &quot;dm_pool_inc_data_range&quot;, r);</span>
<span class="p_add">+		bio_io_error(m-&gt;bio);</span>
<span class="p_add">+		cell_defer_no_holder(tc, m-&gt;cell);</span>
<span class="p_add">+		mempool_free(m, pool-&gt;mapping_pool);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	discard_parent = bio_alloc(GFP_NOIO, 1);
 	if (!discard_parent) {
 		DMWARN(&quot;%s: unable to allocate top level discard bio for passdown. Skipping passdown.&quot;,
<span class="p_chunk">@@ -1114,19 +1127,6 @@</span> <span class="p_context"> static void process_prepared_discard_passdown_pt1(struct dm_thin_new_mapping *m)</span>
 			end_discard(&amp;op, r);
 		}
 	}
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Increment the unmapped blocks.  This prevents a race between the</span>
<span class="p_del">-	 * passdown io and reallocation of freed blocks.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	r = dm_pool_inc_data_range(pool-&gt;pmd, m-&gt;data_block, data_end);</span>
<span class="p_del">-	if (r) {</span>
<span class="p_del">-		metadata_operation_failed(pool, &quot;dm_pool_inc_data_range&quot;, r);</span>
<span class="p_del">-		bio_io_error(m-&gt;bio);</span>
<span class="p_del">-		cell_defer_no_holder(tc, m-&gt;cell);</span>
<span class="p_del">-		mempool_free(m, pool-&gt;mapping_pool);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
 }
 
 static void process_prepared_discard_passdown_pt2(struct dm_thin_new_mapping *m)
<span class="p_header">diff --git a/drivers/mtd/nand/brcmnand/brcmnand.c b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">index 42ebd73f821d..7419c5ce63f8 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_chunk">@@ -101,6 +101,9 @@</span> <span class="p_context"> struct brcm_nand_dma_desc {</span>
 #define BRCMNAND_MIN_BLOCKSIZE	(8 * 1024)
 #define BRCMNAND_MIN_DEVSIZE	(4ULL * 1024 * 1024)
 
<span class="p_add">+#define NAND_CTRL_RDY			(INTFC_CTLR_READY | INTFC_FLASH_READY)</span>
<span class="p_add">+#define NAND_POLL_STATUS_TIMEOUT_MS	100</span>
<span class="p_add">+</span>
 /* Controller feature flags */
 enum {
 	BRCMNAND_HAS_1K_SECTORS			= BIT(0),
<span class="p_chunk">@@ -765,6 +768,31 @@</span> <span class="p_context"> enum {</span>
 	CS_SELECT_AUTO_DEVICE_ID_CFG		= BIT(30),
 };
 
<span class="p_add">+static int bcmnand_ctrl_poll_status(struct brcmnand_controller *ctrl,</span>
<span class="p_add">+				    u32 mask, u32 expected_val,</span>
<span class="p_add">+				    unsigned long timeout_ms)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long limit;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!timeout_ms)</span>
<span class="p_add">+		timeout_ms = NAND_POLL_STATUS_TIMEOUT_MS;</span>
<span class="p_add">+</span>
<span class="p_add">+	limit = jiffies + msecs_to_jiffies(timeout_ms);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		val = brcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS);</span>
<span class="p_add">+		if ((val &amp; mask) == expected_val)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		cpu_relax();</span>
<span class="p_add">+	} while (time_after(limit, jiffies));</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_warn(ctrl-&gt;dev, &quot;timeout on status poll (expected %x got %x)\n&quot;,</span>
<span class="p_add">+		 expected_val, val &amp; mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -ETIMEDOUT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void brcmnand_set_wp(struct brcmnand_controller *ctrl, bool en)
 {
 	u32 val = en ? CS_SELECT_NAND_WP : 0;
<span class="p_chunk">@@ -1024,12 +1052,39 @@</span> <span class="p_context"> static void brcmnand_wp(struct mtd_info *mtd, int wp)</span>
 
 	if ((ctrl-&gt;features &amp; BRCMNAND_HAS_WP) &amp;&amp; wp_on == 1) {
 		static int old_wp = -1;
<span class="p_add">+		int ret;</span>
 
 		if (old_wp != wp) {
 			dev_dbg(ctrl-&gt;dev, &quot;WP %s\n&quot;, wp ? &quot;on&quot; : &quot;off&quot;);
 			old_wp = wp;
 		}
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * make sure ctrl/flash ready before and after</span>
<span class="p_add">+		 * changing state of #WP pin</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = bcmnand_ctrl_poll_status(ctrl, NAND_CTRL_RDY |</span>
<span class="p_add">+					       NAND_STATUS_READY,</span>
<span class="p_add">+					       NAND_CTRL_RDY |</span>
<span class="p_add">+					       NAND_STATUS_READY, 0);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
 		brcmnand_set_wp(ctrl, wp);
<span class="p_add">+		chip-&gt;cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);</span>
<span class="p_add">+		/* NAND_STATUS_WP 0x00 = protected, 0x80 = not protected */</span>
<span class="p_add">+		ret = bcmnand_ctrl_poll_status(ctrl,</span>
<span class="p_add">+					       NAND_CTRL_RDY |</span>
<span class="p_add">+					       NAND_STATUS_READY |</span>
<span class="p_add">+					       NAND_STATUS_WP,</span>
<span class="p_add">+					       NAND_CTRL_RDY |</span>
<span class="p_add">+					       NAND_STATUS_READY |</span>
<span class="p_add">+					       (wp ? 0 : NAND_STATUS_WP), 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			dev_err_ratelimited(&amp;host-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    &quot;nand #WP expected %s\n&quot;,</span>
<span class="p_add">+					    wp ? &quot;on&quot; : &quot;off&quot;);</span>
 	}
 }
 
<span class="p_chunk">@@ -1157,15 +1212,15 @@</span> <span class="p_context"> static irqreturn_t brcmnand_dma_irq(int irq, void *data)</span>
 static void brcmnand_send_cmd(struct brcmnand_host *host, int cmd)
 {
 	struct brcmnand_controller *ctrl = host-&gt;ctrl;
<span class="p_del">-	u32 intfc;</span>
<span class="p_add">+	int ret;</span>
 
 	dev_dbg(ctrl-&gt;dev, &quot;send native cmd %d addr_lo 0x%x\n&quot;, cmd,
 		brcmnand_read_reg(ctrl, BRCMNAND_CMD_ADDRESS));
 	BUG_ON(ctrl-&gt;cmd_pending != 0);
 	ctrl-&gt;cmd_pending = cmd;
 
<span class="p_del">-	intfc = brcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS);</span>
<span class="p_del">-	WARN_ON(!(intfc &amp; INTFC_CTLR_READY));</span>
<span class="p_add">+	ret = bcmnand_ctrl_poll_status(ctrl, NAND_CTRL_RDY, NAND_CTRL_RDY, 0);</span>
<span class="p_add">+	WARN_ON(ret);</span>
 
 	mb(); /* flush previous writes */
 	brcmnand_write_reg(ctrl, BRCMNAND_CMD_START,
<span class="p_header">diff --git a/drivers/mtd/nand/fsmc_nand.c b/drivers/mtd/nand/fsmc_nand.c</span>
<span class="p_header">index bda1e4667138..66aece9cc2cc 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/fsmc_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/fsmc_nand.c</span>
<span class="p_chunk">@@ -150,7 +150,6 @@</span> <span class="p_context"> struct fsmc_nand_platform_data {</span>
 	struct mtd_partition	*partitions;
 	unsigned int		nr_partitions;
 	unsigned int		options;
<span class="p_del">-	unsigned int		width;</span>
 	unsigned int		bank;
 
 	enum access_mode	mode;
<span class="p_chunk">@@ -844,18 +843,19 @@</span> <span class="p_context"> static int fsmc_nand_probe_config_dt(struct platform_device *pdev,</span>
 	u32 val;
 	int ret;
 
<span class="p_del">-	/* Set default NAND width to 8 bits */</span>
<span class="p_del">-	pdata-&gt;width = 8;</span>
<span class="p_add">+	pdata-&gt;options = 0;</span>
<span class="p_add">+</span>
 	if (!of_property_read_u32(np, &quot;bank-width&quot;, &amp;val)) {
 		if (val == 2) {
<span class="p_del">-			pdata-&gt;width = 16;</span>
<span class="p_add">+			pdata-&gt;options |= NAND_BUSWIDTH_16;</span>
 		} else if (val != 1) {
 			dev_err(&amp;pdev-&gt;dev, &quot;invalid bank-width %u\n&quot;, val);
 			return -EINVAL;
 		}
 	}
<span class="p_add">+</span>
 	if (of_get_property(np, &quot;nand-skip-bbtscan&quot;, NULL))
<span class="p_del">-		pdata-&gt;options = NAND_SKIP_BBTSCAN;</span>
<span class="p_add">+		pdata-&gt;options |= NAND_SKIP_BBTSCAN;</span>
 
 	pdata-&gt;nand_timings = devm_kzalloc(&amp;pdev-&gt;dev,
 				sizeof(*pdata-&gt;nand_timings), GFP_KERNEL);
<span class="p_chunk">@@ -992,9 +992,6 @@</span> <span class="p_context"> static int __init fsmc_nand_probe(struct platform_device *pdev)</span>
 	nand-&gt;badblockbits = 7;
 	nand_set_flash_node(nand, np);
 
<span class="p_del">-	if (pdata-&gt;width == FSMC_NAND_BW16)</span>
<span class="p_del">-		nand-&gt;options |= NAND_BUSWIDTH_16;</span>
<span class="p_del">-</span>
 	switch (host-&gt;mode) {
 	case USE_DMA_ACCESS:
 		dma_cap_zero(mask);
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index 34481c9be1d1..6d80067e087f 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -4163,7 +4163,6 @@</span> <span class="p_context"> static void bond_destructor(struct net_device *bond_dev)</span>
 	struct bonding *bond = netdev_priv(bond_dev);
 	if (bond-&gt;wq)
 		destroy_workqueue(bond-&gt;wq);
<span class="p_del">-	free_netdev(bond_dev);</span>
 }
 
 void bond_setup(struct net_device *bond_dev)
<span class="p_chunk">@@ -4183,7 +4182,8 @@</span> <span class="p_context"> void bond_setup(struct net_device *bond_dev)</span>
 	bond_dev-&gt;netdev_ops = &amp;bond_netdev_ops;
 	bond_dev-&gt;ethtool_ops = &amp;bond_ethtool_ops;
 
<span class="p_del">-	bond_dev-&gt;destructor = bond_destructor;</span>
<span class="p_add">+	bond_dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	bond_dev-&gt;priv_destructor = bond_destructor;</span>
 
 	SET_NETDEV_DEVTYPE(bond_dev, &amp;bond_type);
 
<span class="p_chunk">@@ -4689,7 +4689,7 @@</span> <span class="p_context"> int bond_create(struct net *net, const char *name)</span>
 
 	rtnl_unlock();
 	if (res &lt; 0)
<span class="p_del">-		bond_destructor(bond_dev);</span>
<span class="p_add">+		free_netdev(bond_dev);</span>
 	return res;
 }
 
<span class="p_header">diff --git a/drivers/net/caif/caif_hsi.c b/drivers/net/caif/caif_hsi.c</span>
<span class="p_header">index ddabce759456..71a7c3b44fdd 100644</span>
<span class="p_header">--- a/drivers/net/caif/caif_hsi.c</span>
<span class="p_header">+++ b/drivers/net/caif/caif_hsi.c</span>
<span class="p_chunk">@@ -1121,7 +1121,7 @@</span> <span class="p_context"> static void cfhsi_setup(struct net_device *dev)</span>
 	dev-&gt;flags = IFF_POINTOPOINT | IFF_NOARP;
 	dev-&gt;mtu = CFHSI_MAX_CAIF_FRAME_SZ;
 	dev-&gt;priv_flags |= IFF_NO_QUEUE;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	dev-&gt;netdev_ops = &amp;cfhsi_netdevops;
 	for (i = 0; i &lt; CFHSI_PRIO_LAST; ++i)
 		skb_queue_head_init(&amp;cfhsi-&gt;qhead[i]);
<span class="p_header">diff --git a/drivers/net/caif/caif_serial.c b/drivers/net/caif/caif_serial.c</span>
<span class="p_header">index c2dea4916e5d..76e1d3545105 100644</span>
<span class="p_header">--- a/drivers/net/caif/caif_serial.c</span>
<span class="p_header">+++ b/drivers/net/caif/caif_serial.c</span>
<span class="p_chunk">@@ -428,7 +428,7 @@</span> <span class="p_context"> static void caifdev_setup(struct net_device *dev)</span>
 	dev-&gt;flags = IFF_POINTOPOINT | IFF_NOARP;
 	dev-&gt;mtu = CAIF_MAX_MTU;
 	dev-&gt;priv_flags |= IFF_NO_QUEUE;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	skb_queue_head_init(&amp;serdev-&gt;head);
 	serdev-&gt;common.link_select = CAIF_LINK_LOW_LATENCY;
 	serdev-&gt;common.use_frag = true;
<span class="p_header">diff --git a/drivers/net/caif/caif_spi.c b/drivers/net/caif/caif_spi.c</span>
<span class="p_header">index 3a529fbe539f..fc21afe852b9 100644</span>
<span class="p_header">--- a/drivers/net/caif/caif_spi.c</span>
<span class="p_header">+++ b/drivers/net/caif/caif_spi.c</span>
<span class="p_chunk">@@ -712,7 +712,7 @@</span> <span class="p_context"> static void cfspi_setup(struct net_device *dev)</span>
 	dev-&gt;flags = IFF_NOARP | IFF_POINTOPOINT;
 	dev-&gt;priv_flags |= IFF_NO_QUEUE;
 	dev-&gt;mtu = SPI_MAX_PAYLOAD_SIZE;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	skb_queue_head_init(&amp;cfspi-&gt;qhead);
 	skb_queue_head_init(&amp;cfspi-&gt;chead);
 	cfspi-&gt;cfdev.link_select = CAIF_LINK_HIGH_BANDW;
<span class="p_header">diff --git a/drivers/net/caif/caif_virtio.c b/drivers/net/caif/caif_virtio.c</span>
<span class="p_header">index bc0eb47eccee..8bffd251165c 100644</span>
<span class="p_header">--- a/drivers/net/caif/caif_virtio.c</span>
<span class="p_header">+++ b/drivers/net/caif/caif_virtio.c</span>
<span class="p_chunk">@@ -617,7 +617,7 @@</span> <span class="p_context"> static void cfv_netdev_setup(struct net_device *netdev)</span>
 	netdev-&gt;tx_queue_len = 100;
 	netdev-&gt;flags = IFF_POINTOPOINT | IFF_NOARP;
 	netdev-&gt;mtu = CFV_DEF_MTU_SIZE;
<span class="p_del">-	netdev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	netdev-&gt;needs_free_netdev = true;</span>
 }
 
 /* Create debugfs counters for the device */
<span class="p_header">diff --git a/drivers/net/can/slcan.c b/drivers/net/can/slcan.c</span>
<span class="p_header">index eb7173713bbc..6a6e896e52fa 100644</span>
<span class="p_header">--- a/drivers/net/can/slcan.c</span>
<span class="p_header">+++ b/drivers/net/can/slcan.c</span>
<span class="p_chunk">@@ -417,7 +417,7 @@</span> <span class="p_context"> static int slc_open(struct net_device *dev)</span>
 static void slc_free_netdev(struct net_device *dev)
 {
 	int i = dev-&gt;base_addr;
<span class="p_del">-	free_netdev(dev);</span>
<span class="p_add">+</span>
 	slcan_devs[i] = NULL;
 }
 
<span class="p_chunk">@@ -436,7 +436,8 @@</span> <span class="p_context"> static const struct net_device_ops slc_netdev_ops = {</span>
 static void slc_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops		= &amp;slc_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= slc_free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
<span class="p_add">+	dev-&gt;priv_destructor	= slc_free_netdev;</span>
 
 	dev-&gt;hard_header_len	= 0;
 	dev-&gt;addr_len		= 0;
<span class="p_chunk">@@ -761,8 +762,6 @@</span> <span class="p_context"> static void __exit slcan_exit(void)</span>
 		if (sl-&gt;tty) {
 			printk(KERN_ERR &quot;%s: tty discipline still running\n&quot;,
 			       dev-&gt;name);
<span class="p_del">-			/* Intentionally leak the control block. */</span>
<span class="p_del">-			dev-&gt;destructor = NULL;</span>
 		}
 
 		unregister_netdev(dev);
<span class="p_header">diff --git a/drivers/net/can/vcan.c b/drivers/net/can/vcan.c</span>
<span class="p_header">index 674f367087c5..25d12099593e 100644</span>
<span class="p_header">--- a/drivers/net/can/vcan.c</span>
<span class="p_header">+++ b/drivers/net/can/vcan.c</span>
<span class="p_chunk">@@ -160,7 +160,7 @@</span> <span class="p_context"> static void vcan_setup(struct net_device *dev)</span>
 		dev-&gt;flags |= IFF_ECHO;
 
 	dev-&gt;netdev_ops		= &amp;vcan_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 }
 
 static struct rtnl_link_ops vcan_link_ops __read_mostly = {
<span class="p_header">diff --git a/drivers/net/dummy.c b/drivers/net/dummy.c</span>
<span class="p_header">index 2c80611b94ae..b66fbe51ceb1 100644</span>
<span class="p_header">--- a/drivers/net/dummy.c</span>
<span class="p_header">+++ b/drivers/net/dummy.c</span>
<span class="p_chunk">@@ -313,7 +313,6 @@</span> <span class="p_context"> static void dummy_free_netdev(struct net_device *dev)</span>
 	struct dummy_priv *priv = netdev_priv(dev);
 
 	kfree(priv-&gt;vfinfo);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static void dummy_setup(struct net_device *dev)
<span class="p_chunk">@@ -323,7 +322,8 @@</span> <span class="p_context"> static void dummy_setup(struct net_device *dev)</span>
 	/* Initialize the device structure. */
 	dev-&gt;netdev_ops = &amp;dummy_netdev_ops;
 	dev-&gt;ethtool_ops = &amp;dummy_ethtool_ops;
<span class="p_del">-	dev-&gt;destructor = dummy_free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = dummy_free_netdev;</span>
 
 	/* Fill in device structure with ethernet-generic values. */
 	dev-&gt;flags |= IFF_NOARP;
<span class="p_header">diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c</span>
<span class="p_header">index 1238c4ec5215..fb0951929be9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c</span>
<span class="p_chunk">@@ -4530,7 +4530,7 @@</span> <span class="p_context"> static void dummy_setup(struct net_device *dev)</span>
 	/* Initialize the device structure. */
 	dev-&gt;netdev_ops = &amp;cxgb4_mgmt_netdev_ops;
 	dev-&gt;ethtool_ops = &amp;cxgb4_mgmt_ethtool_ops;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 }
 
 static int config_mgmt_dev(struct pci_dev *pdev)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h</span>
<span class="p_header">index 3d9490cd2db1..8f7108c94802 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h</span>
<span class="p_chunk">@@ -313,13 +313,15 @@</span> <span class="p_context"> struct mlx5e_dma_info {</span>
 
 struct mlx5e_rx_am_stats {
 	int ppms; /* packets per msec */
<span class="p_add">+	int bpms; /* bytes per msec */</span>
 	int epms; /* events per msec */
 };
 
 struct mlx5e_rx_am_sample {
<span class="p_del">-	ktime_t		time;</span>
<span class="p_del">-	unsigned int	pkt_ctr;</span>
<span class="p_del">-	u16		event_ctr;</span>
<span class="p_add">+	ktime_t	time;</span>
<span class="p_add">+	u32	pkt_ctr;</span>
<span class="p_add">+	u32	byte_ctr;</span>
<span class="p_add">+	u16	event_ctr;</span>
 };
 
 struct mlx5e_rx_am { /* Adaptive Moderation */
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c</span>
<span class="p_header">index 949fbadd7817..aae8b6c0edbd 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c</span>
<span class="p_chunk">@@ -1205,11 +1205,11 @@</span> <span class="p_context"> static int mlx5e_get_ts_info(struct net_device *dev,</span>
 				 SOF_TIMESTAMPING_RX_HARDWARE |
 				 SOF_TIMESTAMPING_RAW_HARDWARE;
 
<span class="p_del">-	info-&gt;tx_types = (BIT(1) &lt;&lt; HWTSTAMP_TX_OFF) |</span>
<span class="p_del">-			 (BIT(1) &lt;&lt; HWTSTAMP_TX_ON);</span>
<span class="p_add">+	info-&gt;tx_types = BIT(HWTSTAMP_TX_OFF) |</span>
<span class="p_add">+			 BIT(HWTSTAMP_TX_ON);</span>
 
<span class="p_del">-	info-&gt;rx_filters = (BIT(1) &lt;&lt; HWTSTAMP_FILTER_NONE) |</span>
<span class="p_del">-			   (BIT(1) &lt;&lt; HWTSTAMP_FILTER_ALL);</span>
<span class="p_add">+	info-&gt;rx_filters = BIT(HWTSTAMP_FILTER_NONE) |</span>
<span class="p_add">+			   BIT(HWTSTAMP_FILTER_ALL);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">index 15cc7b469d2e..f778436a2d28 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_chunk">@@ -3885,7 +3885,8 @@</span> <span class="p_context"> struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,</span>
 	return netdev;
 
 err_cleanup_nic:
<span class="p_del">-	profile-&gt;cleanup(priv);</span>
<span class="p_add">+	if (profile-&gt;cleanup)</span>
<span class="p_add">+		profile-&gt;cleanup(priv);</span>
 	free_netdev(netdev);
 
 	return NULL;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c</span>
<span class="p_header">index f621373bd7a5..4be6b346f14a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c</span>
<span class="p_chunk">@@ -424,6 +424,8 @@</span> <span class="p_context"> static void mlx5e_build_rep_netdev_priv(struct mlx5_core_dev *mdev,</span>
 	priv-&gt;params.lro_wqe_sz            =
 		MLX5E_PARAMS_DEFAULT_LRO_WQE_SZ;
 
<span class="p_add">+	mlx5_query_min_inline(mdev, &amp;priv-&gt;params.tx_min_inline_mode);</span>
<span class="p_add">+</span>
 	priv-&gt;mdev                         = mdev;
 	priv-&gt;netdev                       = netdev;
 	priv-&gt;params.num_channels          = profile-&gt;max_nch(mdev);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c</span>
<span class="p_header">index cbfac06b7ffd..23ccec4cb7f5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c</span>
<span class="p_chunk">@@ -183,28 +183,27 @@</span> <span class="p_context"> static void mlx5e_am_exit_parking(struct mlx5e_rx_am *am)</span>
 	mlx5e_am_step(am);
 }
 
<span class="p_add">+#define IS_SIGNIFICANT_DIFF(val, ref) \</span>
<span class="p_add">+	(((100 * abs((val) - (ref))) / (ref)) &gt; 10) /* more than 10% difference */</span>
<span class="p_add">+</span>
 static int mlx5e_am_stats_compare(struct mlx5e_rx_am_stats *curr,
 				  struct mlx5e_rx_am_stats *prev)
 {
<span class="p_del">-	int diff;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!prev-&gt;ppms)</span>
<span class="p_del">-		return curr-&gt;ppms ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_add">+	if (!prev-&gt;bpms)</span>
<span class="p_add">+		return curr-&gt;bpms ? MLX5E_AM_STATS_BETTER :</span>
 				    MLX5E_AM_STATS_SAME;
 
<span class="p_del">-	diff = curr-&gt;ppms - prev-&gt;ppms;</span>
<span class="p_del">-	if (((100 * abs(diff)) / prev-&gt;ppms) &gt; 10) /* more than 10% diff */</span>
<span class="p_del">-		return (diff &gt; 0) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_del">-				    MLX5E_AM_STATS_WORSE;</span>
<span class="p_add">+	if (IS_SIGNIFICANT_DIFF(curr-&gt;bpms, prev-&gt;bpms))</span>
<span class="p_add">+		return (curr-&gt;bpms &gt; prev-&gt;bpms) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_add">+						   MLX5E_AM_STATS_WORSE;</span>
 
<span class="p_del">-	if (!prev-&gt;epms)</span>
<span class="p_del">-		return curr-&gt;epms ? MLX5E_AM_STATS_WORSE :</span>
<span class="p_del">-				    MLX5E_AM_STATS_SAME;</span>
<span class="p_add">+	if (IS_SIGNIFICANT_DIFF(curr-&gt;ppms, prev-&gt;ppms))</span>
<span class="p_add">+		return (curr-&gt;ppms &gt; prev-&gt;ppms) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_add">+						   MLX5E_AM_STATS_WORSE;</span>
 
<span class="p_del">-	diff = curr-&gt;epms - prev-&gt;epms;</span>
<span class="p_del">-	if (((100 * abs(diff)) / prev-&gt;epms) &gt; 10) /* more than 10% diff */</span>
<span class="p_del">-		return (diff &lt; 0) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_del">-				    MLX5E_AM_STATS_WORSE;</span>
<span class="p_add">+	if (IS_SIGNIFICANT_DIFF(curr-&gt;epms, prev-&gt;epms))</span>
<span class="p_add">+		return (curr-&gt;epms &lt; prev-&gt;epms) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_add">+						   MLX5E_AM_STATS_WORSE;</span>
 
 	return MLX5E_AM_STATS_SAME;
 }
<span class="p_chunk">@@ -266,10 +265,13 @@</span> <span class="p_context"> static void mlx5e_am_sample(struct mlx5e_rq *rq,</span>
 {
 	s-&gt;time	     = ktime_get();
 	s-&gt;pkt_ctr   = rq-&gt;stats.packets;
<span class="p_add">+	s-&gt;byte_ctr  = rq-&gt;stats.bytes;</span>
 	s-&gt;event_ctr = rq-&gt;cq.event_ctr;
 }
 
 #define MLX5E_AM_NEVENTS 64
<span class="p_add">+#define BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)</span>
<span class="p_add">+#define BIT_GAP(bits, end, start) ((((end) - (start)) + BIT_ULL(bits)) &amp; (BIT_ULL(bits) - 1))</span>
 
 static void mlx5e_am_calc_stats(struct mlx5e_rx_am_sample *start,
 				struct mlx5e_rx_am_sample *end,
<span class="p_chunk">@@ -277,13 +279,17 @@</span> <span class="p_context"> static void mlx5e_am_calc_stats(struct mlx5e_rx_am_sample *start,</span>
 {
 	/* u32 holds up to 71 minutes, should be enough */
 	u32 delta_us = ktime_us_delta(end-&gt;time, start-&gt;time);
<span class="p_del">-	unsigned int npkts = end-&gt;pkt_ctr - start-&gt;pkt_ctr;</span>
<span class="p_add">+	u32 npkts = BIT_GAP(BITS_PER_TYPE(u32), end-&gt;pkt_ctr, start-&gt;pkt_ctr);</span>
<span class="p_add">+	u32 nbytes = BIT_GAP(BITS_PER_TYPE(u32), end-&gt;byte_ctr,</span>
<span class="p_add">+			     start-&gt;byte_ctr);</span>
 
 	if (!delta_us)
 		return;
 
<span class="p_del">-	curr_stats-&gt;ppms =            (npkts * USEC_PER_MSEC) / delta_us;</span>
<span class="p_del">-	curr_stats-&gt;epms = (MLX5E_AM_NEVENTS * USEC_PER_MSEC) / delta_us;</span>
<span class="p_add">+	curr_stats-&gt;ppms = DIV_ROUND_UP(npkts * USEC_PER_MSEC, delta_us);</span>
<span class="p_add">+	curr_stats-&gt;bpms = DIV_ROUND_UP(nbytes * USEC_PER_MSEC, delta_us);</span>
<span class="p_add">+	curr_stats-&gt;epms = DIV_ROUND_UP(MLX5E_AM_NEVENTS * USEC_PER_MSEC,</span>
<span class="p_add">+					delta_us);</span>
 }
 
 void mlx5e_rx_am_work(struct work_struct *work)
<span class="p_chunk">@@ -308,7 +314,8 @@</span> <span class="p_context"> void mlx5e_rx_am(struct mlx5e_rq *rq)</span>
 
 	switch (am-&gt;state) {
 	case MLX5E_AM_MEASURE_IN_PROGRESS:
<span class="p_del">-		nevents = rq-&gt;cq.event_ctr - am-&gt;start_sample.event_ctr;</span>
<span class="p_add">+		nevents = BIT_GAP(BITS_PER_TYPE(u16), rq-&gt;cq.event_ctr,</span>
<span class="p_add">+				  am-&gt;start_sample.event_ctr);</span>
 		if (nevents &lt; MLX5E_AM_NEVENTS)
 			break;
 		mlx5e_am_sample(rq, &amp;end_sample);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h b/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h</span>
<span class="p_header">index 53e4992d6511..f81c3aa60b46 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h</span>
<span class="p_chunk">@@ -417,20 +417,13 @@</span> <span class="p_context"> struct mlx5e_stats {</span>
 };
 
 static const struct counter_desc mlx5e_pme_status_desc[] = {
<span class="p_del">-	{ &quot;module_plug&quot;, 0 },</span>
 	{ &quot;module_unplug&quot;, 8 },
 };
 
 static const struct counter_desc mlx5e_pme_error_desc[] = {
<span class="p_del">-	{ &quot;module_pwr_budget_exd&quot;, 0 },  /* power budget exceed */</span>
<span class="p_del">-	{ &quot;module_long_range&quot;, 8 },      /* long range for non MLNX cable */</span>
<span class="p_del">-	{ &quot;module_bus_stuck&quot;, 16 },      /* bus stuck (I2C or data shorted) */</span>
<span class="p_del">-	{ &quot;module_no_eeprom&quot;, 24 },      /* no eeprom/retry time out */</span>
<span class="p_del">-	{ &quot;module_enforce_part&quot;, 32 },   /* enforce part number list */</span>
<span class="p_del">-	{ &quot;module_unknown_id&quot;, 40 },     /* unknown identifier */</span>
<span class="p_del">-	{ &quot;module_high_temp&quot;, 48 },      /* high temperature */</span>
<span class="p_add">+	{ &quot;module_bus_stuck&quot;, 16 },       /* bus stuck (I2C or data shorted) */</span>
<span class="p_add">+	{ &quot;module_high_temp&quot;, 48 },       /* high temperature */</span>
 	{ &quot;module_bad_shorted&quot;, 56 },    /* bad or shorted cable/module */
<span class="p_del">-	{ &quot;module_unknown_status&quot;, 64 },</span>
 };
 
 #endif /* __MLX5_EN_STATS_H__ */
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">index 0ad66324247f..9862a741b32a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_chunk">@@ -175,8 +175,9 @@</span> <span class="p_context"> static struct mlx5_profile profile[] = {</span>
 	},
 };
 
<span class="p_del">-#define FW_INIT_TIMEOUT_MILI	2000</span>
<span class="p_del">-#define FW_INIT_WAIT_MS		2</span>
<span class="p_add">+#define FW_INIT_TIMEOUT_MILI		2000</span>
<span class="p_add">+#define FW_INIT_WAIT_MS			2</span>
<span class="p_add">+#define FW_PRE_INIT_TIMEOUT_MILI	10000</span>
 
 static int wait_fw_init(struct mlx5_core_dev *dev, u32 max_wait_mili)
 {
<span class="p_chunk">@@ -537,8 +538,10 @@</span> <span class="p_context"> static int handle_hca_cap(struct mlx5_core_dev *dev)</span>
 	/* disable cmdif checksum */
 	MLX5_SET(cmd_hca_cap, set_hca_cap, cmdif_checksum, 0);
 
<span class="p_del">-	/* If the HCA supports 4K UARs use it */</span>
<span class="p_del">-	if (MLX5_CAP_GEN_MAX(dev, uar_4k))</span>
<span class="p_add">+	/* Enable 4K UAR only when HCA supports it and page size is bigger</span>
<span class="p_add">+	 * than 4K.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (MLX5_CAP_GEN_MAX(dev, uar_4k) &amp;&amp; PAGE_SIZE &gt; 4096)</span>
 		MLX5_SET(cmd_hca_cap, set_hca_cap, uar_4k, 1);
 
 	MLX5_SET(cmd_hca_cap, set_hca_cap, log_uar_page_sz, PAGE_SHIFT - 12);
<span class="p_chunk">@@ -1019,6 +1022,15 @@</span> <span class="p_context"> static int mlx5_load_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv,</span>
 	 */
 	dev-&gt;state = MLX5_DEVICE_STATE_UP;
 
<span class="p_add">+	/* wait for firmware to accept initialization segments configurations</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = wait_fw_init(dev, FW_PRE_INIT_TIMEOUT_MILI);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;pdev-&gt;dev, &quot;Firmware over %d MS in pre-initializing state, aborting\n&quot;,</span>
<span class="p_add">+			FW_PRE_INIT_TIMEOUT_MILI);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = mlx5_cmd_init(dev);
 	if (err) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed initializing command interface, aborting\n&quot;);
<span class="p_header">diff --git a/drivers/net/geneve.c b/drivers/net/geneve.c</span>
<span class="p_header">index 6ebb0f559a42..199459bd6961 100644</span>
<span class="p_header">--- a/drivers/net/geneve.c</span>
<span class="p_header">+++ b/drivers/net/geneve.c</span>
<span class="p_chunk">@@ -1007,7 +1007,7 @@</span> <span class="p_context"> static void geneve_setup(struct net_device *dev)</span>
 
 	dev-&gt;netdev_ops = &amp;geneve_netdev_ops;
 	dev-&gt;ethtool_ops = &amp;geneve_ethtool_ops;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 
 	SET_NETDEV_DEVTYPE(dev, &amp;geneve_type);
 
<span class="p_header">diff --git a/drivers/net/gtp.c b/drivers/net/gtp.c</span>
<span class="p_header">index 89698741682f..429387083dce 100644</span>
<span class="p_header">--- a/drivers/net/gtp.c</span>
<span class="p_header">+++ b/drivers/net/gtp.c</span>
<span class="p_chunk">@@ -618,7 +618,7 @@</span> <span class="p_context"> static const struct net_device_ops gtp_netdev_ops = {</span>
 static void gtp_link_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops		= &amp;gtp_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 
 	dev-&gt;hard_header_len = 0;
 	dev-&gt;addr_len = 0;
<span class="p_header">diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c</span>
<span class="p_header">index 922bf440e9f1..021a8ec411ab 100644</span>
<span class="p_header">--- a/drivers/net/hamradio/6pack.c</span>
<span class="p_header">+++ b/drivers/net/hamradio/6pack.c</span>
<span class="p_chunk">@@ -311,7 +311,7 @@</span> <span class="p_context"> static void sp_setup(struct net_device *dev)</span>
 {
 	/* Finish setting up the DEVICE info. */
 	dev-&gt;netdev_ops		= &amp;sp_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 	dev-&gt;mtu		= SIXP_MTU;
 	dev-&gt;hard_header_len	= AX25_MAX_HEADER_LEN;
 	dev-&gt;header_ops 	= &amp;ax25_header_ops;
<span class="p_header">diff --git a/drivers/net/hamradio/bpqether.c b/drivers/net/hamradio/bpqether.c</span>
<span class="p_header">index f62e7f325cf9..78a6414c5fd9 100644</span>
<span class="p_header">--- a/drivers/net/hamradio/bpqether.c</span>
<span class="p_header">+++ b/drivers/net/hamradio/bpqether.c</span>
<span class="p_chunk">@@ -476,7 +476,7 @@</span> <span class="p_context"> static const struct net_device_ops bpq_netdev_ops = {</span>
 static void bpq_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops	     = &amp;bpq_netdev_ops;
<span class="p_del">-	dev-&gt;destructor	     = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 
 	memcpy(dev-&gt;broadcast, &amp;ax25_bcast, AX25_ADDR_LEN);
 	memcpy(dev-&gt;dev_addr,  &amp;ax25_defaddr, AX25_ADDR_LEN);
<span class="p_header">diff --git a/drivers/net/ifb.c b/drivers/net/ifb.c</span>
<span class="p_header">index 312fce7302d3..144ea5ae8ab4 100644</span>
<span class="p_header">--- a/drivers/net/ifb.c</span>
<span class="p_header">+++ b/drivers/net/ifb.c</span>
<span class="p_chunk">@@ -207,7 +207,6 @@</span> <span class="p_context"> static void ifb_dev_free(struct net_device *dev)</span>
 		__skb_queue_purge(&amp;txp-&gt;tq);
 	}
 	kfree(dp-&gt;tx_private);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static void ifb_setup(struct net_device *dev)
<span class="p_chunk">@@ -230,7 +229,8 @@</span> <span class="p_context"> static void ifb_setup(struct net_device *dev)</span>
 	dev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;
 	netif_keep_dst(dev);
 	eth_hw_addr_random(dev);
<span class="p_del">-	dev-&gt;destructor = ifb_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = ifb_dev_free;</span>
 }
 
 static netdev_tx_t ifb_xmit(struct sk_buff *skb, struct net_device *dev)
<span class="p_header">diff --git a/drivers/net/ipvlan/ipvlan_main.c b/drivers/net/ipvlan/ipvlan_main.c</span>
<span class="p_header">index aa8575ccbce3..48e6c4e4914e 100644</span>
<span class="p_header">--- a/drivers/net/ipvlan/ipvlan_main.c</span>
<span class="p_header">+++ b/drivers/net/ipvlan/ipvlan_main.c</span>
<span class="p_chunk">@@ -621,7 +621,7 @@</span> <span class="p_context"> void ipvlan_link_setup(struct net_device *dev)</span>
 	dev-&gt;priv_flags &amp;= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);
 	dev-&gt;priv_flags |= IFF_UNICAST_FLT | IFF_NO_QUEUE;
 	dev-&gt;netdev_ops = &amp;ipvlan_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	dev-&gt;header_ops = &amp;ipvlan_header_ops;
 	dev-&gt;ethtool_ops = &amp;ipvlan_ethtool_ops;
 }
<span class="p_header">diff --git a/drivers/net/loopback.c b/drivers/net/loopback.c</span>
<span class="p_header">index b23b71981fd5..80e3ace493cd 100644</span>
<span class="p_header">--- a/drivers/net/loopback.c</span>
<span class="p_header">+++ b/drivers/net/loopback.c</span>
<span class="p_chunk">@@ -145,7 +145,6 @@</span> <span class="p_context"> static void loopback_dev_free(struct net_device *dev)</span>
 {
 	dev_net(dev)-&gt;loopback_dev = NULL;
 	free_percpu(dev-&gt;lstats);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static const struct net_device_ops loopback_ops = {
<span class="p_chunk">@@ -183,7 +182,8 @@</span> <span class="p_context"> static void loopback_setup(struct net_device *dev)</span>
 	dev-&gt;ethtool_ops	= &amp;loopback_ethtool_ops;
 	dev-&gt;header_ops		= &amp;eth_header_ops;
 	dev-&gt;netdev_ops		= &amp;loopback_ops;
<span class="p_del">-	dev-&gt;destructor		= loopback_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
<span class="p_add">+	dev-&gt;priv_destructor	= loopback_dev_free;</span>
 }
 
 /* Setup and register the loopback device. */
<span class="p_header">diff --git a/drivers/net/macsec.c b/drivers/net/macsec.c</span>
<span class="p_header">index 49ce4e9f4a0f..43f3e1b2d3ca 100644</span>
<span class="p_header">--- a/drivers/net/macsec.c</span>
<span class="p_header">+++ b/drivers/net/macsec.c</span>
<span class="p_chunk">@@ -2994,7 +2994,6 @@</span> <span class="p_context"> static void macsec_free_netdev(struct net_device *dev)</span>
 	free_percpu(macsec-&gt;secy.tx_sc.stats);
 
 	dev_put(real_dev);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static void macsec_setup(struct net_device *dev)
<span class="p_chunk">@@ -3004,7 +3003,8 @@</span> <span class="p_context"> static void macsec_setup(struct net_device *dev)</span>
 	dev-&gt;max_mtu = ETH_MAX_MTU;
 	dev-&gt;priv_flags |= IFF_NO_QUEUE;
 	dev-&gt;netdev_ops = &amp;macsec_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = macsec_free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = macsec_free_netdev;</span>
 	SET_NETDEV_DEVTYPE(dev, &amp;macsec_type);
 
 	eth_zero_addr(dev-&gt;broadcast);
<span class="p_header">diff --git a/drivers/net/macvlan.c b/drivers/net/macvlan.c</span>
<span class="p_header">index b34eaaae03fd..b8cec52547d7 100644</span>
<span class="p_header">--- a/drivers/net/macvlan.c</span>
<span class="p_header">+++ b/drivers/net/macvlan.c</span>
<span class="p_chunk">@@ -1089,7 +1089,7 @@</span> <span class="p_context"> void macvlan_common_setup(struct net_device *dev)</span>
 	netif_keep_dst(dev);
 	dev-&gt;priv_flags	       |= IFF_UNICAST_FLT;
 	dev-&gt;netdev_ops		= &amp;macvlan_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 	dev-&gt;header_ops		= &amp;macvlan_hard_header_ops;
 	dev-&gt;ethtool_ops	= &amp;macvlan_ethtool_ops;
 }
<span class="p_header">diff --git a/drivers/net/nlmon.c b/drivers/net/nlmon.c</span>
<span class="p_header">index b91603835d26..c4b3362da4a2 100644</span>
<span class="p_header">--- a/drivers/net/nlmon.c</span>
<span class="p_header">+++ b/drivers/net/nlmon.c</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static void nlmon_setup(struct net_device *dev)</span>
 
 	dev-&gt;netdev_ops	= &amp;nlmon_ops;
 	dev-&gt;ethtool_ops = &amp;nlmon_ethtool_ops;
<span class="p_del">-	dev-&gt;destructor	= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 
 	dev-&gt;features = NETIF_F_SG | NETIF_F_FRAGLIST |
 			NETIF_F_HIGHDMA | NETIF_F_LLTX;
<span class="p_header">diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c</span>
<span class="p_header">index 1da31dc47f86..74b907206aa7 100644</span>
<span class="p_header">--- a/drivers/net/slip/slip.c</span>
<span class="p_header">+++ b/drivers/net/slip/slip.c</span>
<span class="p_chunk">@@ -629,7 +629,7 @@</span> <span class="p_context"> static void sl_uninit(struct net_device *dev)</span>
 static void sl_free_netdev(struct net_device *dev)
 {
 	int i = dev-&gt;base_addr;
<span class="p_del">-	free_netdev(dev);</span>
<span class="p_add">+</span>
 	slip_devs[i] = NULL;
 }
 
<span class="p_chunk">@@ -651,7 +651,8 @@</span> <span class="p_context"> static const struct net_device_ops sl_netdev_ops = {</span>
 static void sl_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops		= &amp;sl_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= sl_free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
<span class="p_add">+	dev-&gt;priv_destructor	= sl_free_netdev;</span>
 
 	dev-&gt;hard_header_len	= 0;
 	dev-&gt;addr_len		= 0;
<span class="p_chunk">@@ -1369,8 +1370,6 @@</span> <span class="p_context"> static void __exit slip_exit(void)</span>
 		if (sl-&gt;tty) {
 			printk(KERN_ERR &quot;%s: tty discipline still running\n&quot;,
 			       dev-&gt;name);
<span class="p_del">-			/* Intentionally leak the control block. */</span>
<span class="p_del">-			dev-&gt;destructor = NULL;</span>
 		}
 
 		unregister_netdev(dev);
<span class="p_header">diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c</span>
<span class="p_header">index 85c01247f2e3..eaa6ee762230 100644</span>
<span class="p_header">--- a/drivers/net/team/team.c</span>
<span class="p_header">+++ b/drivers/net/team/team.c</span>
<span class="p_chunk">@@ -1643,7 +1643,6 @@</span> <span class="p_context"> static void team_destructor(struct net_device *dev)</span>
 	struct team *team = netdev_priv(dev);
 
 	free_percpu(team-&gt;pcpu_stats);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static int team_open(struct net_device *dev)
<span class="p_chunk">@@ -2079,7 +2078,8 @@</span> <span class="p_context"> static void team_setup(struct net_device *dev)</span>
 
 	dev-&gt;netdev_ops = &amp;team_netdev_ops;
 	dev-&gt;ethtool_ops = &amp;team_ethtool_ops;
<span class="p_del">-	dev-&gt;destructor	= team_destructor;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = team_destructor;</span>
 	dev-&gt;priv_flags &amp;= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);
 	dev-&gt;priv_flags |= IFF_NO_QUEUE;
 	dev-&gt;priv_flags |= IFF_TEAM;
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index cc88cd7856f5..7f3db4963fdd 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -1560,7 +1560,6 @@</span> <span class="p_context"> static void tun_free_netdev(struct net_device *dev)</span>
 	free_percpu(tun-&gt;pcpu_stats);
 	tun_flow_uninit(tun);
 	security_tun_dev_free_security(tun-&gt;security);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static void tun_setup(struct net_device *dev)
<span class="p_chunk">@@ -1571,7 +1570,8 @@</span> <span class="p_context"> static void tun_setup(struct net_device *dev)</span>
 	tun-&gt;group = INVALID_GID;
 
 	dev-&gt;ethtool_ops = &amp;tun_ethtool_ops;
<span class="p_del">-	dev-&gt;destructor = tun_free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = tun_free_netdev;</span>
 	/* We prefer our own queue length */
 	dev-&gt;tx_queue_len = TUN_READQ_SIZE;
 }
<span class="p_header">diff --git a/drivers/net/usb/cdc-phonet.c b/drivers/net/usb/cdc-phonet.c</span>
<span class="p_header">index eb52de8205f0..c7a350bbaaa7 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc-phonet.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc-phonet.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> static void usbpn_setup(struct net_device *dev)</span>
 	dev-&gt;addr_len		= 1;
 	dev-&gt;tx_queue_len	= 3;
 
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">index 87746c2bc3d3..d4c8c96bc770 100644</span>
<span class="p_header">--- a/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">+++ b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_chunk">@@ -898,6 +898,8 @@</span> <span class="p_context"> static const struct usb_device_id products[] = {</span>
 	{QMI_FIXED_INTF(0x1199, 0x9056, 8)},	/* Sierra Wireless Modem */
 	{QMI_FIXED_INTF(0x1199, 0x9057, 8)},
 	{QMI_FIXED_INTF(0x1199, 0x9061, 8)},	/* Sierra Wireless Modem */
<span class="p_add">+	{QMI_FIXED_INTF(0x1199, 0x9063, 8)},	/* Sierra Wireless EM7305 */</span>
<span class="p_add">+	{QMI_FIXED_INTF(0x1199, 0x9063, 10)},	/* Sierra Wireless EM7305 */</span>
 	{QMI_FIXED_INTF(0x1199, 0x9071, 8)},	/* Sierra Wireless MC74xx */
 	{QMI_FIXED_INTF(0x1199, 0x9071, 10)},	/* Sierra Wireless MC74xx */
 	{QMI_FIXED_INTF(0x1199, 0x9079, 8)},	/* Sierra Wireless EM74xx */
<span class="p_chunk">@@ -912,6 +914,8 @@</span> <span class="p_context"> static const struct usb_device_id products[] = {</span>
 	{QMI_FIXED_INTF(0x1bc7, 0x1100, 3)},	/* Telit ME910 */
 	{QMI_FIXED_INTF(0x1bc7, 0x1200, 5)},	/* Telit LE920 */
 	{QMI_QUIRK_SET_DTR(0x1bc7, 0x1201, 2)},	/* Telit LE920, LE920A4 */
<span class="p_add">+	{QMI_FIXED_INTF(0x1c9e, 0x9801, 3)},	/* Telewell TW-3G HSPA+ */</span>
<span class="p_add">+	{QMI_FIXED_INTF(0x1c9e, 0x9803, 4)},	/* Telewell TW-3G HSPA+ */</span>
 	{QMI_FIXED_INTF(0x1c9e, 0x9b01, 3)},	/* XS Stick W100-2 from 4G Systems */
 	{QMI_FIXED_INTF(0x0b3c, 0xc000, 4)},	/* Olivetti Olicard 100 */
 	{QMI_FIXED_INTF(0x0b3c, 0xc001, 4)},	/* Olivetti Olicard 120 */
<span class="p_header">diff --git a/drivers/net/veth.c b/drivers/net/veth.c</span>
<span class="p_header">index 8c39d6d690e5..2efbe98d0c67 100644</span>
<span class="p_header">--- a/drivers/net/veth.c</span>
<span class="p_header">+++ b/drivers/net/veth.c</span>
<span class="p_chunk">@@ -227,7 +227,6 @@</span> <span class="p_context"> static int veth_dev_init(struct net_device *dev)</span>
 static void veth_dev_free(struct net_device *dev)
 {
 	free_percpu(dev-&gt;vstats);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
<span class="p_chunk">@@ -322,7 +321,8 @@</span> <span class="p_context"> static void veth_setup(struct net_device *dev)</span>
 			       NETIF_F_HW_VLAN_STAG_TX |
 			       NETIF_F_HW_VLAN_CTAG_RX |
 			       NETIF_F_HW_VLAN_STAG_RX);
<span class="p_del">-	dev-&gt;destructor = veth_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = veth_dev_free;</span>
 	dev-&gt;max_mtu = ETH_MAX_MTU;
 
 	dev-&gt;hw_features = VETH_FEATURES;
<span class="p_header">diff --git a/drivers/net/vrf.c b/drivers/net/vrf.c</span>
<span class="p_header">index df74efcf237b..2e62c4d1b220 100644</span>
<span class="p_header">--- a/drivers/net/vrf.c</span>
<span class="p_header">+++ b/drivers/net/vrf.c</span>
<span class="p_chunk">@@ -36,12 +36,14 @@</span> <span class="p_context"></span>
 #include &lt;net/addrconf.h&gt;
 #include &lt;net/l3mdev.h&gt;
 #include &lt;net/fib_rules.h&gt;
<span class="p_add">+#include &lt;net/netns/generic.h&gt;</span>
 
 #define DRV_NAME	&quot;vrf&quot;
 #define DRV_VERSION	&quot;1.0&quot;
 
 #define FIB_RULE_PREF  1000       /* default preference for FIB rules */
<span class="p_del">-static bool add_fib_rules = true;</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int vrf_net_id;</span>
 
 struct net_vrf {
 	struct rtable __rcu	*rth;
<span class="p_chunk">@@ -1206,7 +1208,7 @@</span> <span class="p_context"> static void vrf_setup(struct net_device *dev)</span>
 	dev-&gt;netdev_ops = &amp;vrf_netdev_ops;
 	dev-&gt;l3mdev_ops = &amp;vrf_l3mdev_ops;
 	dev-&gt;ethtool_ops = &amp;vrf_ethtool_ops;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 
 	/* Fill in device structure with ethernet-generic values. */
 	eth_hw_addr_random(dev);
<span class="p_chunk">@@ -1252,6 +1254,8 @@</span> <span class="p_context"> static int vrf_newlink(struct net *src_net, struct net_device *dev,</span>
 		       struct nlattr *tb[], struct nlattr *data[])
 {
 	struct net_vrf *vrf = netdev_priv(dev);
<span class="p_add">+	bool *add_fib_rules;</span>
<span class="p_add">+	struct net *net;</span>
 	int err;
 
 	if (!data || !data[IFLA_VRF_TABLE])
<span class="p_chunk">@@ -1267,13 +1271,15 @@</span> <span class="p_context"> static int vrf_newlink(struct net *src_net, struct net_device *dev,</span>
 	if (err)
 		goto out;
 
<span class="p_del">-	if (add_fib_rules) {</span>
<span class="p_add">+	net = dev_net(dev);</span>
<span class="p_add">+	add_fib_rules = net_generic(net, vrf_net_id);</span>
<span class="p_add">+	if (*add_fib_rules) {</span>
 		err = vrf_add_fib_rules(dev);
 		if (err) {
 			unregister_netdevice(dev);
 			goto out;
 		}
<span class="p_del">-		add_fib_rules = false;</span>
<span class="p_add">+		*add_fib_rules = false;</span>
 	}
 
 out:
<span class="p_chunk">@@ -1356,16 +1362,38 @@</span> <span class="p_context"> static struct notifier_block vrf_notifier_block __read_mostly = {</span>
 	.notifier_call = vrf_device_event,
 };
 
<span class="p_add">+/* Initialize per network namespace state */</span>
<span class="p_add">+static int __net_init vrf_netns_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool *add_fib_rules = net_generic(net, vrf_net_id);</span>
<span class="p_add">+</span>
<span class="p_add">+	*add_fib_rules = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct pernet_operations vrf_net_ops __net_initdata = {</span>
<span class="p_add">+	.init = vrf_netns_init,</span>
<span class="p_add">+	.id   = &amp;vrf_net_id,</span>
<span class="p_add">+	.size = sizeof(bool),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int __init vrf_init_module(void)
 {
 	int rc;
 
 	register_netdevice_notifier(&amp;vrf_notifier_block);
 
<span class="p_del">-	rc = rtnl_link_register(&amp;vrf_link_ops);</span>
<span class="p_add">+	rc = register_pernet_subsys(&amp;vrf_net_ops);</span>
 	if (rc &lt; 0)
 		goto error;
 
<span class="p_add">+	rc = rtnl_link_register(&amp;vrf_link_ops);</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
<span class="p_add">+		unregister_pernet_subsys(&amp;vrf_net_ops);</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 
 error:
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index 70dbd5a48b6b..4574b95c7938 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -2607,7 +2607,7 @@</span> <span class="p_context"> static void vxlan_setup(struct net_device *dev)</span>
 	eth_hw_addr_random(dev);
 	ether_setup(dev);
 
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	SET_NETDEV_DEVTYPE(dev, &amp;vxlan_type);
 
 	dev-&gt;features	|= NETIF_F_LLTX;
<span class="p_header">diff --git a/drivers/net/wan/dlci.c b/drivers/net/wan/dlci.c</span>
<span class="p_header">index 65ee2a6f248c..a0d76f70c428 100644</span>
<span class="p_header">--- a/drivers/net/wan/dlci.c</span>
<span class="p_header">+++ b/drivers/net/wan/dlci.c</span>
<span class="p_chunk">@@ -475,7 +475,7 @@</span> <span class="p_context"> static void dlci_setup(struct net_device *dev)</span>
 	dev-&gt;flags		= 0;
 	dev-&gt;header_ops		= &amp;dlci_header_ops;
 	dev-&gt;netdev_ops		= &amp;dlci_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 
 	dlp-&gt;receive		= dlci_receive;
 
<span class="p_header">diff --git a/drivers/net/wan/hdlc_fr.c b/drivers/net/wan/hdlc_fr.c</span>
<span class="p_header">index eb915281197e..78596e42a3f3 100644</span>
<span class="p_header">--- a/drivers/net/wan/hdlc_fr.c</span>
<span class="p_header">+++ b/drivers/net/wan/hdlc_fr.c</span>
<span class="p_chunk">@@ -1106,7 +1106,7 @@</span> <span class="p_context"> static int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)</span>
 		return -EIO;
 	}
 
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	*get_dev_p(pvc, type) = dev;
 	if (!used) {
 		state(hdlc)-&gt;dce_changed = 1;
<span class="p_header">diff --git a/drivers/net/wan/lapbether.c b/drivers/net/wan/lapbether.c</span>
<span class="p_header">index 9df9ed62beff..63f749078a1f 100644</span>
<span class="p_header">--- a/drivers/net/wan/lapbether.c</span>
<span class="p_header">+++ b/drivers/net/wan/lapbether.c</span>
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> static const struct net_device_ops lapbeth_netdev_ops = {</span>
 static void lapbeth_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops	     = &amp;lapbeth_netdev_ops;
<span class="p_del">-	dev-&gt;destructor	     = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	dev-&gt;type            = ARPHRD_X25;
 	dev-&gt;hard_header_len = 3;
 	dev-&gt;mtu             = 1000;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath6kl/main.c b/drivers/net/wireless/ath/ath6kl/main.c</span>
<span class="p_header">index 91ee542de3d7..b90c77ef792e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath6kl/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath6kl/main.c</span>
<span class="p_chunk">@@ -1287,7 +1287,7 @@</span> <span class="p_context"> void init_netdev(struct net_device *dev)</span>
 	struct ath6kl *ar = ath6kl_priv(dev);
 
 	dev-&gt;netdev_ops = &amp;ath6kl_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	dev-&gt;watchdog_timeo = ATH6KL_TX_TIMEOUT;
 
 	dev-&gt;needed_headroom = ETH_HLEN;
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">index 944b83cfc519..017e20b34304 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_chunk">@@ -5209,7 +5209,6 @@</span> <span class="p_context"> void brcmf_cfg80211_free_netdev(struct net_device *ndev)</span>
 
 	if (vif)
 		brcmf_free_vif(vif);
<span class="p_del">-	free_netdev(ndev);</span>
 }
 
 static bool brcmf_is_linkup(const struct brcmf_event_msg *e)
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c</span>
<span class="p_header">index f6b17fb58877..d02e7f6ec4e0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c</span>
<span class="p_chunk">@@ -652,7 +652,8 @@</span> <span class="p_context"> struct brcmf_if *brcmf_add_if(struct brcmf_pub *drvr, s32 bsscfgidx, s32 ifidx,</span>
 		if (!ndev)
 			return ERR_PTR(-ENOMEM);
 
<span class="p_del">-		ndev-&gt;destructor = brcmf_cfg80211_free_netdev;</span>
<span class="p_add">+		ndev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+		ndev-&gt;priv_destructor = brcmf_cfg80211_free_netdev;</span>
 		ifp = netdev_priv(ndev);
 		ifp-&gt;ndev = ndev;
 		/* store mapping ifidx to bsscfgidx */
<span class="p_header">diff --git a/drivers/net/wireless/intersil/hostap/hostap_main.c b/drivers/net/wireless/intersil/hostap/hostap_main.c</span>
<span class="p_header">index 544fc09dcb62..1372b20f931e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intersil/hostap/hostap_main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intersil/hostap/hostap_main.c</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> struct net_device * hostap_add_interface(struct local_info *local,</span>
 	dev-&gt;mem_end = mdev-&gt;mem_end;
 
 	hostap_setup_dev(dev, local, type);
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 
 	sprintf(dev-&gt;name, &quot;%s%s&quot;, prefix, name);
 	if (!rtnl_locked)
<span class="p_header">diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">index 50c219fb1a52..2aa5cc6e34ef 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_chunk">@@ -2807,7 +2807,7 @@</span> <span class="p_context"> static const struct net_device_ops hwsim_netdev_ops = {</span>
 static void hwsim_mon_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops = &amp;hwsim_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	ether_setup(dev);
 	dev-&gt;priv_flags |= IFF_NO_QUEUE;
 	dev-&gt;type = ARPHRD_IEEE80211_RADIOTAP;
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/main.c b/drivers/net/wireless/marvell/mwifiex/main.c</span>
<span class="p_header">index b62e03d11c2e..46073bb554dd 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/main.c</span>
<span class="p_chunk">@@ -1277,7 +1277,7 @@</span> <span class="p_context"> void mwifiex_init_priv_params(struct mwifiex_private *priv,</span>
 			      struct net_device *dev)
 {
 	dev-&gt;netdev_ops = &amp;mwifiex_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	/* Initialize private structure */
 	priv-&gt;current_key_index = 0;
 	priv-&gt;media_connected = false;
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-amd.c b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">index d69e357a7a98..d8e81045cffe 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_chunk">@@ -495,64 +495,54 @@</span> <span class="p_context"> static struct irq_chip amd_gpio_irqchip = {</span>
 	.flags        = IRQCHIP_SKIP_SET_WAKE,
 };
 
<span class="p_del">-static void amd_gpio_irq_handler(struct irq_desc *desc)</span>
<span class="p_add">+#define PIN_IRQ_PENDING	(BIT(INTERRUPT_STS_OFF) | BIT(WAKE_STS_OFF))</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t amd_gpio_irq_handler(int irq, void *dev_id)</span>
 {
<span class="p_del">-	u32 i;</span>
<span class="p_del">-	u32 off;</span>
<span class="p_del">-	u32 reg;</span>
<span class="p_del">-	u32 pin_reg;</span>
<span class="p_del">-	u64 reg64;</span>
<span class="p_del">-	int handled = 0;</span>
<span class="p_del">-	unsigned int irq;</span>
<span class="p_add">+	struct amd_gpio *gpio_dev = dev_id;</span>
<span class="p_add">+	struct gpio_chip *gc = &amp;gpio_dev-&gt;gc;</span>
<span class="p_add">+	irqreturn_t ret = IRQ_NONE;</span>
<span class="p_add">+	unsigned int i, irqnr;</span>
 	unsigned long flags;
<span class="p_del">-	struct irq_chip *chip = irq_desc_get_chip(desc);</span>
<span class="p_del">-	struct gpio_chip *gc = irq_desc_get_handler_data(desc);</span>
<span class="p_del">-	struct amd_gpio *gpio_dev = gpiochip_get_data(gc);</span>
<span class="p_add">+	u32 *regs, regval;</span>
<span class="p_add">+	u64 status, mask;</span>
 
<span class="p_del">-	chained_irq_enter(chip, desc);</span>
<span class="p_del">-	/*enable GPIO interrupt again*/</span>
<span class="p_add">+	/* Read the wake status */</span>
 	spin_lock_irqsave(&amp;gpio_dev-&gt;lock, flags);
<span class="p_del">-	reg = readl(gpio_dev-&gt;base + WAKE_INT_STATUS_REG1);</span>
<span class="p_del">-	reg64 = reg;</span>
<span class="p_del">-	reg64 = reg64 &lt;&lt; 32;</span>
<span class="p_del">-</span>
<span class="p_del">-	reg = readl(gpio_dev-&gt;base + WAKE_INT_STATUS_REG0);</span>
<span class="p_del">-	reg64 |= reg;</span>
<span class="p_add">+	status = readl(gpio_dev-&gt;base + WAKE_INT_STATUS_REG1);</span>
<span class="p_add">+	status &lt;&lt;= 32;</span>
<span class="p_add">+	status |= readl(gpio_dev-&gt;base + WAKE_INT_STATUS_REG0);</span>
 	spin_unlock_irqrestore(&amp;gpio_dev-&gt;lock, flags);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * first 46 bits indicates interrupt status.</span>
<span class="p_del">-	 * one bit represents four interrupt sources.</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	for (off = 0; off &lt; 46 ; off++) {</span>
<span class="p_del">-		if (reg64 &amp; BIT(off)) {</span>
<span class="p_del">-			for (i = 0; i &lt; 4; i++) {</span>
<span class="p_del">-				pin_reg = readl(gpio_dev-&gt;base +</span>
<span class="p_del">-						(off * 4 + i) * 4);</span>
<span class="p_del">-				if ((pin_reg &amp; BIT(INTERRUPT_STS_OFF)) ||</span>
<span class="p_del">-					(pin_reg &amp; BIT(WAKE_STS_OFF))) {</span>
<span class="p_del">-					irq = irq_find_mapping(gc-&gt;irqdomain,</span>
<span class="p_del">-								off * 4 + i);</span>
<span class="p_del">-					generic_handle_irq(irq);</span>
<span class="p_del">-					writel(pin_reg,</span>
<span class="p_del">-						gpio_dev-&gt;base</span>
<span class="p_del">-						+ (off * 4 + i) * 4);</span>
<span class="p_del">-					handled++;</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_add">+	/* Bit 0-45 contain the relevant status bits */</span>
<span class="p_add">+	status &amp;= (1ULL &lt;&lt; 46) - 1;</span>
<span class="p_add">+	regs = gpio_dev-&gt;base;</span>
<span class="p_add">+	for (mask = 1, irqnr = 0; status; mask &lt;&lt;= 1, regs += 4, irqnr += 4) {</span>
<span class="p_add">+		if (!(status &amp; mask))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		status &amp;= ~mask;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Each status bit covers four pins */</span>
<span class="p_add">+		for (i = 0; i &lt; 4; i++) {</span>
<span class="p_add">+			regval = readl(regs + i);</span>
<span class="p_add">+			if (!(regval &amp; PIN_IRQ_PENDING))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			irq = irq_find_mapping(gc-&gt;irqdomain, irqnr + i);</span>
<span class="p_add">+			generic_handle_irq(irq);</span>
<span class="p_add">+			/* Clear interrupt */</span>
<span class="p_add">+			writel(regval, regs + i);</span>
<span class="p_add">+			ret = IRQ_HANDLED;</span>
 		}
 	}
 
<span class="p_del">-	if (handled == 0)</span>
<span class="p_del">-		handle_bad_irq(desc);</span>
<span class="p_del">-</span>
<span class="p_add">+	/* Signal EOI to the GPIO unit */</span>
 	spin_lock_irqsave(&amp;gpio_dev-&gt;lock, flags);
<span class="p_del">-	reg = readl(gpio_dev-&gt;base + WAKE_INT_MASTER_REG);</span>
<span class="p_del">-	reg |= EOI_MASK;</span>
<span class="p_del">-	writel(reg, gpio_dev-&gt;base + WAKE_INT_MASTER_REG);</span>
<span class="p_add">+	regval = readl(gpio_dev-&gt;base + WAKE_INT_MASTER_REG);</span>
<span class="p_add">+	regval |= EOI_MASK;</span>
<span class="p_add">+	writel(regval, gpio_dev-&gt;base + WAKE_INT_MASTER_REG);</span>
 	spin_unlock_irqrestore(&amp;gpio_dev-&gt;lock, flags);
 
<span class="p_del">-	chained_irq_exit(chip, desc);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int amd_get_groups_count(struct pinctrl_dev *pctldev)
<span class="p_chunk">@@ -821,10 +811,11 @@</span> <span class="p_context"> static int amd_gpio_probe(struct platform_device *pdev)</span>
 		goto out2;
 	}
 
<span class="p_del">-	gpiochip_set_chained_irqchip(&amp;gpio_dev-&gt;gc,</span>
<span class="p_del">-				 &amp;amd_gpio_irqchip,</span>
<span class="p_del">-				 irq_base,</span>
<span class="p_del">-				 amd_gpio_irq_handler);</span>
<span class="p_add">+	ret = devm_request_irq(&amp;pdev-&gt;dev, irq_base, amd_gpio_irq_handler, 0,</span>
<span class="p_add">+			       KBUILD_MODNAME, gpio_dev);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out2;</span>
<span class="p_add">+</span>
 	platform_set_drvdata(pdev, gpio_dev);
 
 	dev_dbg(&amp;pdev-&gt;dev, &quot;amd gpio driver loaded\n&quot;);
<span class="p_header">diff --git a/drivers/s390/net/netiucv.c b/drivers/s390/net/netiucv.c</span>
<span class="p_header">index 3f85b97ab8d2..6d3494ba84cf 100644</span>
<span class="p_header">--- a/drivers/s390/net/netiucv.c</span>
<span class="p_header">+++ b/drivers/s390/net/netiucv.c</span>
<span class="p_chunk">@@ -1954,7 +1954,6 @@</span> <span class="p_context"> static void netiucv_free_netdevice(struct net_device *dev)</span>
 		privptr-&gt;conn = NULL; privptr-&gt;fsm = NULL;
 		/* privptr gets freed by free_netdev() */
 	}
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 /**
<span class="p_chunk">@@ -1972,7 +1971,8 @@</span> <span class="p_context"> static void netiucv_setup_netdevice(struct net_device *dev)</span>
 	dev-&gt;mtu	         = NETIUCV_MTU_DEFAULT;
 	dev-&gt;min_mtu		 = 576;
 	dev-&gt;max_mtu		 = NETIUCV_MTU_MAX;
<span class="p_del">-	dev-&gt;destructor          = netiucv_free_netdevice;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev   = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor     = netiucv_free_netdevice;</span>
 	dev-&gt;hard_header_len     = NETIUCV_HDRLEN;
 	dev-&gt;addr_len            = 0;
 	dev-&gt;type                = ARPHRD_SLIP;
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/os_dep/mon.c b/drivers/staging/rtl8188eu/os_dep/mon.c</span>
<span class="p_header">index cfe37eb026d6..859d0d6051cd 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/os_dep/mon.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/os_dep/mon.c</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> static const struct net_device_ops mon_netdev_ops = {</span>
 static void mon_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops = &amp;mon_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	ether_setup(dev);
 	dev-&gt;priv_flags |= IFF_NO_QUEUE;
 	dev-&gt;type = ARPHRD_IEEE80211;
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_phonet.c b/drivers/usb/gadget/function/f_phonet.c</span>
<span class="p_header">index b4058f0000e4..6a1ce6a55158 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_phonet.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_phonet.c</span>
<span class="p_chunk">@@ -281,7 +281,7 @@</span> <span class="p_context"> static void pn_net_setup(struct net_device *dev)</span>
 	dev-&gt;tx_queue_len	= 1;
 
 	dev-&gt;netdev_ops		= &amp;pn_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 	dev-&gt;header_ops		= &amp;phonet_header_ops;
 }
 
<span class="p_header">diff --git a/drivers/watchdog/bcm_kona_wdt.c b/drivers/watchdog/bcm_kona_wdt.c</span>
<span class="p_header">index 6fce17d5b9f1..a5775dfd8d5f 100644</span>
<span class="p_header">--- a/drivers/watchdog/bcm_kona_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/bcm_kona_wdt.c</span>
<span class="p_chunk">@@ -304,6 +304,8 @@</span> <span class="p_context"> static int bcm_kona_wdt_probe(struct platform_device *pdev)</span>
 	if (!wdt)
 		return -ENOMEM;
 
<span class="p_add">+	spin_lock_init(&amp;wdt-&gt;lock);</span>
<span class="p_add">+</span>
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	wdt-&gt;base = devm_ioremap_resource(dev, res);
 	if (IS_ERR(wdt-&gt;base))
<span class="p_chunk">@@ -316,7 +318,6 @@</span> <span class="p_context"> static int bcm_kona_wdt_probe(struct platform_device *pdev)</span>
 		return ret;
 	}
 
<span class="p_del">-	spin_lock_init(&amp;wdt-&gt;lock);</span>
 	platform_set_drvdata(pdev, wdt);
 	watchdog_set_drvdata(&amp;bcm_kona_wdt_wdd, wdt);
 	bcm_kona_wdt_wdd.parent = &amp;pdev-&gt;dev;
<span class="p_header">diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c</span>
<span class="p_header">index 773774531aff..c5e27ebd8da8 100644</span>
<span class="p_header">--- a/fs/nfs/callback.c</span>
<span class="p_header">+++ b/fs/nfs/callback.c</span>
<span class="p_chunk">@@ -280,7 +280,7 @@</span> <span class="p_context"> static struct svc_serv *nfs_callback_create_svc(int minorversion)</span>
 		printk(KERN_WARNING &quot;nfs_callback_create_svc: no kthread, %d users??\n&quot;,
 			cb_info-&gt;users);
 
<span class="p_del">-	serv = svc_create(&amp;nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);</span>
<span class="p_add">+	serv = svc_create_pooled(&amp;nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);</span>
 	if (!serv) {
 		printk(KERN_ERR &quot;nfs_callback_create_svc: create service failed\n&quot;);
 		return ERR_PTR(-ENOMEM);
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index f92ba8d6c556..66c743eddac9 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -2002,29 +2002,6 @@</span> <span class="p_context"> nfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)</span>
 }
 EXPORT_SYMBOL_GPL(nfs_link);
 
<span class="p_del">-static void</span>
<span class="p_del">-nfs_complete_rename(struct rpc_task *task, struct nfs_renamedata *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct dentry *old_dentry = data-&gt;old_dentry;</span>
<span class="p_del">-	struct dentry *new_dentry = data-&gt;new_dentry;</span>
<span class="p_del">-	struct inode *old_inode = d_inode(old_dentry);</span>
<span class="p_del">-	struct inode *new_inode = d_inode(new_dentry);</span>
<span class="p_del">-</span>
<span class="p_del">-	nfs_mark_for_revalidate(old_inode);</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (task-&gt;tk_status) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_del">-		if (new_inode != NULL)</span>
<span class="p_del">-			nfs_drop_nlink(new_inode);</span>
<span class="p_del">-		d_move(old_dentry, new_dentry);</span>
<span class="p_del">-		nfs_set_verifier(new_dentry,</span>
<span class="p_del">-					nfs_save_change_attribute(data-&gt;new_dir));</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case -ENOENT:</span>
<span class="p_del">-		nfs_dentry_handle_enoent(old_dentry);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * RENAME
  * FIXME: Some nfsds, like the Linux user space nfsd, may generate a
<span class="p_chunk">@@ -2055,7 +2032,7 @@</span> <span class="p_context"> int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 {
 	struct inode *old_inode = d_inode(old_dentry);
 	struct inode *new_inode = d_inode(new_dentry);
<span class="p_del">-	struct dentry *dentry = NULL;</span>
<span class="p_add">+	struct dentry *dentry = NULL, *rehash = NULL;</span>
 	struct rpc_task *task;
 	int error = -EBUSY;
 
<span class="p_chunk">@@ -2078,8 +2055,10 @@</span> <span class="p_context"> int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 		 * To prevent any new references to the target during the
 		 * rename, we unhash the dentry in advance.
 		 */
<span class="p_del">-		if (!d_unhashed(new_dentry))</span>
<span class="p_add">+		if (!d_unhashed(new_dentry)) {</span>
 			d_drop(new_dentry);
<span class="p_add">+			rehash = new_dentry;</span>
<span class="p_add">+		}</span>
 
 		if (d_count(new_dentry) &gt; 2) {
 			int err;
<span class="p_chunk">@@ -2096,6 +2075,7 @@</span> <span class="p_context"> int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 				goto out;
 
 			new_dentry = dentry;
<span class="p_add">+			rehash = NULL;</span>
 			new_inode = NULL;
 		}
 	}
<span class="p_chunk">@@ -2104,8 +2084,7 @@</span> <span class="p_context"> int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 	if (new_inode != NULL)
 		NFS_PROTO(new_inode)-&gt;return_delegation(new_inode);
 
<span class="p_del">-	task = nfs_async_rename(old_dir, new_dir, old_dentry, new_dentry,</span>
<span class="p_del">-					nfs_complete_rename);</span>
<span class="p_add">+	task = nfs_async_rename(old_dir, new_dir, old_dentry, new_dentry, NULL);</span>
 	if (IS_ERR(task)) {
 		error = PTR_ERR(task);
 		goto out;
<span class="p_chunk">@@ -2115,9 +2094,27 @@</span> <span class="p_context"> int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 	if (error == 0)
 		error = task-&gt;tk_status;
 	rpc_put_task(task);
<span class="p_add">+	nfs_mark_for_revalidate(old_inode);</span>
 out:
<span class="p_add">+	if (rehash)</span>
<span class="p_add">+		d_rehash(rehash);</span>
 	trace_nfs_rename_exit(old_dir, old_dentry,
 			new_dir, new_dentry, error);
<span class="p_add">+	if (!error) {</span>
<span class="p_add">+		if (new_inode != NULL)</span>
<span class="p_add">+			nfs_drop_nlink(new_inode);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The d_move() should be here instead of in an async RPC completion</span>
<span class="p_add">+		 * handler because we need the proper locks to move the dentry.  If</span>
<span class="p_add">+		 * we&#39;re interrupted by a signal, the async RPC completion handler</span>
<span class="p_add">+		 * should mark the directories for revalidation.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		d_move(old_dentry, new_dentry);</span>
<span class="p_add">+		nfs_set_verifier(new_dentry,</span>
<span class="p_add">+					nfs_save_change_attribute(new_dir));</span>
<span class="p_add">+	} else if (error == -ENOENT)</span>
<span class="p_add">+		nfs_dentry_handle_enoent(old_dentry);</span>
<span class="p_add">+</span>
 	/* new dentry created? */
 	if (dentry)
 		dput(dentry);
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 8ba6c0d4d499..932a1461758d 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -2588,7 +2588,8 @@</span> <span class="p_context"> static inline void nfs4_exclusive_attrset(struct nfs4_opendata *opendata,</span>
 
 	/* Except MODE, it seems harmless of setting twice. */
 	if (opendata-&gt;o_arg.createmode != NFS4_CREATE_EXCLUSIVE &amp;&amp;
<span class="p_del">-		attrset[1] &amp; FATTR4_WORD1_MODE)</span>
<span class="p_add">+		(attrset[1] &amp; FATTR4_WORD1_MODE ||</span>
<span class="p_add">+		 attrset[2] &amp; FATTR4_WORD2_MODE_UMASK))</span>
 		sattr-&gt;ia_valid &amp;= ~ATTR_MODE;
 
 	if (attrset[2] &amp; FATTR4_WORD2_SECURITY_LABEL)
<span class="p_chunk">@@ -8429,6 +8430,7 @@</span> <span class="p_context"> static void nfs4_layoutget_release(void *calldata)</span>
 	size_t max_pages = max_response_pages(server);
 
 	dprintk(&quot;--&gt; %s\n&quot;, __func__);
<span class="p_add">+	nfs4_sequence_free_slot(&amp;lgp-&gt;res.seq_res);</span>
 	nfs4_free_pages(lgp-&gt;args.layout.pages, max_pages);
 	pnfs_put_layout_hdr(NFS_I(inode)-&gt;layout);
 	put_nfs_open_context(lgp-&gt;args.ctx);
<span class="p_chunk">@@ -8503,7 +8505,6 @@</span> <span class="p_context"> nfs4_proc_layoutget(struct nfs4_layoutget *lgp, long *timeout, gfp_t gfp_flags)</span>
 	/* if layoutp-&gt;len is 0, nfs4_layoutget_prepare called rpc_exit */
 	if (status == 0 &amp;&amp; lgp-&gt;res.layoutp-&gt;len)
 		lseg = pnfs_layout_process(lgp);
<span class="p_del">-	nfs4_sequence_free_slot(&amp;lgp-&gt;res.seq_res);</span>
 	rpc_put_task(task);
 	dprintk(&quot;&lt;-- %s status=%d\n&quot;, __func__, status);
 	if (status)
<span class="p_header">diff --git a/fs/ocfs2/cluster/heartbeat.c b/fs/ocfs2/cluster/heartbeat.c</span>
<span class="p_header">index f6e871760f8d..0da0332725aa 100644</span>
<span class="p_header">--- a/fs/ocfs2/cluster/heartbeat.c</span>
<span class="p_header">+++ b/fs/ocfs2/cluster/heartbeat.c</span>
<span class="p_chunk">@@ -2242,13 +2242,13 @@</span> <span class="p_context"> static void o2hb_heartbeat_group_drop_item(struct config_group *group,</span>
 	spin_unlock(&amp;o2hb_live_lock);
 }
 
<span class="p_del">-static ssize_t o2hb_heartbeat_group_threshold_show(struct config_item *item,</span>
<span class="p_add">+static ssize_t o2hb_heartbeat_group_dead_threshold_show(struct config_item *item,</span>
 		char *page)
 {
 	return sprintf(page, &quot;%u\n&quot;, o2hb_dead_threshold);
 }
 
<span class="p_del">-static ssize_t o2hb_heartbeat_group_threshold_store(struct config_item *item,</span>
<span class="p_add">+static ssize_t o2hb_heartbeat_group_dead_threshold_store(struct config_item *item,</span>
 		const char *page, size_t count)
 {
 	unsigned long tmp;
<span class="p_chunk">@@ -2297,11 +2297,11 @@</span> <span class="p_context"> static ssize_t o2hb_heartbeat_group_mode_store(struct config_item *item,</span>
 
 }
 
<span class="p_del">-CONFIGFS_ATTR(o2hb_heartbeat_group_, threshold);</span>
<span class="p_add">+CONFIGFS_ATTR(o2hb_heartbeat_group_, dead_threshold);</span>
 CONFIGFS_ATTR(o2hb_heartbeat_group_, mode);
 
 static struct configfs_attribute *o2hb_heartbeat_group_attrs[] = {
<span class="p_del">-	&amp;o2hb_heartbeat_group_attr_threshold,</span>
<span class="p_add">+	&amp;o2hb_heartbeat_group_attr_dead_threshold,</span>
 	&amp;o2hb_heartbeat_group_attr_mode,
 	NULL,
 };
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index 3b7c937a36b5..4689940a953c 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -2591,6 +2591,10 @@</span> <span class="p_context"> void ocfs2_inode_unlock_tracker(struct inode *inode,</span>
 	struct ocfs2_lock_res *lockres;
 
 	lockres = &amp;OCFS2_I(inode)-&gt;ip_inode_lockres;
<span class="p_add">+	/* had_lock means that the currect process already takes the cluster</span>
<span class="p_add">+	 * lock previously. If had_lock is 1, we have nothing to do here, and</span>
<span class="p_add">+	 * it will get unlocked where we got the lock.</span>
<span class="p_add">+	 */</span>
 	if (!had_lock) {
 		ocfs2_remove_holder(lockres, oh);
 		ocfs2_inode_unlock(inode, ex);
<span class="p_header">diff --git a/fs/ocfs2/xattr.c b/fs/ocfs2/xattr.c</span>
<span class="p_header">index 3c5384d9b3a5..f70c3778d600 100644</span>
<span class="p_header">--- a/fs/ocfs2/xattr.c</span>
<span class="p_header">+++ b/fs/ocfs2/xattr.c</span>
<span class="p_chunk">@@ -1328,20 +1328,21 @@</span> <span class="p_context"> static int ocfs2_xattr_get(struct inode *inode,</span>
 			   void *buffer,
 			   size_t buffer_size)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, had_lock;</span>
 	struct buffer_head *di_bh = NULL;
<span class="p_add">+	struct ocfs2_lock_holder oh;</span>
 
<span class="p_del">-	ret = ocfs2_inode_lock(inode, &amp;di_bh, 0);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		mlog_errno(ret);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	had_lock = ocfs2_inode_lock_tracker(inode, &amp;di_bh, 0, &amp;oh);</span>
<span class="p_add">+	if (had_lock &lt; 0) {</span>
<span class="p_add">+		mlog_errno(had_lock);</span>
<span class="p_add">+		return had_lock;</span>
 	}
 	down_read(&amp;OCFS2_I(inode)-&gt;ip_xattr_sem);
 	ret = ocfs2_xattr_get_nolock(inode, di_bh, name_index,
 				     name, buffer, buffer_size);
 	up_read(&amp;OCFS2_I(inode)-&gt;ip_xattr_sem);
 
<span class="p_del">-	ocfs2_inode_unlock(inode, 0);</span>
<span class="p_add">+	ocfs2_inode_unlock_tracker(inode, 0, &amp;oh, had_lock);</span>
 
 	brelse(di_bh);
 
<span class="p_chunk">@@ -3537,11 +3538,12 @@</span> <span class="p_context"> int ocfs2_xattr_set(struct inode *inode,</span>
 {
 	struct buffer_head *di_bh = NULL;
 	struct ocfs2_dinode *di;
<span class="p_del">-	int ret, credits, ref_meta = 0, ref_credits = 0;</span>
<span class="p_add">+	int ret, credits, had_lock, ref_meta = 0, ref_credits = 0;</span>
 	struct ocfs2_super *osb = OCFS2_SB(inode-&gt;i_sb);
 	struct inode *tl_inode = osb-&gt;osb_tl_inode;
 	struct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, };
 	struct ocfs2_refcount_tree *ref_tree = NULL;
<span class="p_add">+	struct ocfs2_lock_holder oh;</span>
 
 	struct ocfs2_xattr_info xi = {
 		.xi_name_index = name_index,
<span class="p_chunk">@@ -3572,8 +3574,9 @@</span> <span class="p_context"> int ocfs2_xattr_set(struct inode *inode,</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	ret = ocfs2_inode_lock(inode, &amp;di_bh, 1);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_add">+	had_lock = ocfs2_inode_lock_tracker(inode, &amp;di_bh, 1, &amp;oh);</span>
<span class="p_add">+	if (had_lock &lt; 0) {</span>
<span class="p_add">+		ret = had_lock;</span>
 		mlog_errno(ret);
 		goto cleanup_nolock;
 	}
<span class="p_chunk">@@ -3670,7 +3673,7 @@</span> <span class="p_context"> int ocfs2_xattr_set(struct inode *inode,</span>
 		if (ret)
 			mlog_errno(ret);
 	}
<span class="p_del">-	ocfs2_inode_unlock(inode, 1);</span>
<span class="p_add">+	ocfs2_inode_unlock_tracker(inode, 1, &amp;oh, had_lock);</span>
 cleanup_nolock:
 	brelse(di_bh);
 	brelse(xbs.xattr_bh);
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index 5b14c16d1b77..e83e2dc7ae0b 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -252,15 +252,9 @@</span> <span class="p_context"> static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,</span>
 		.link = link
 	};
 
<span class="p_del">-	upper = lookup_one_len(dentry-&gt;d_name.name, upperdir,</span>
<span class="p_del">-			       dentry-&gt;d_name.len);</span>
<span class="p_del">-	err = PTR_ERR(upper);</span>
<span class="p_del">-	if (IS_ERR(upper))</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	err = security_inode_copy_up(dentry, &amp;new_creds);
 	if (err &lt; 0)
<span class="p_del">-		goto out1;</span>
<span class="p_add">+		goto out;</span>
 
 	if (new_creds)
 		old_creds = override_creds(new_creds);
<span class="p_chunk">@@ -284,7 +278,7 @@</span> <span class="p_context"> static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,</span>
 	}
 
 	if (err)
<span class="p_del">-		goto out2;</span>
<span class="p_add">+		goto out;</span>
 
 	if (S_ISREG(stat-&gt;mode)) {
 		struct path upperpath;
<span class="p_chunk">@@ -317,6 +311,14 @@</span> <span class="p_context"> static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,</span>
 	if (err)
 		goto out_cleanup;
 
<span class="p_add">+	upper = lookup_one_len(dentry-&gt;d_name.name, upperdir,</span>
<span class="p_add">+			       dentry-&gt;d_name.len);</span>
<span class="p_add">+	if (IS_ERR(upper)) {</span>
<span class="p_add">+		err = PTR_ERR(upper);</span>
<span class="p_add">+		upper = NULL;</span>
<span class="p_add">+		goto out_cleanup;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (tmpfile)
 		err = ovl_do_link(temp, udir, upper, true);
 	else
<span class="p_chunk">@@ -330,17 +332,15 @@</span> <span class="p_context"> static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,</span>
 
 	/* Restore timestamps on parent (best effort) */
 	ovl_set_timestamps(upperdir, pstat);
<span class="p_del">-out2:</span>
<span class="p_add">+out:</span>
 	dput(temp);
<span class="p_del">-out1:</span>
 	dput(upper);
<span class="p_del">-out:</span>
 	return err;
 
 out_cleanup:
 	if (!tmpfile)
 		ovl_cleanup(wdir, temp);
<span class="p_del">-	goto out2;</span>
<span class="p_add">+	goto out;</span>
 }
 
 /*
<span class="p_header">diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h</span>
<span class="p_header">index 97456b2539e4..aa38bb18c81c 100644</span>
<span class="p_header">--- a/include/linux/netdevice.h</span>
<span class="p_header">+++ b/include/linux/netdevice.h</span>
<span class="p_chunk">@@ -1581,8 +1581,8 @@</span> <span class="p_context"> enum netdev_priv_flags {</span>
  *	@rtnl_link_state:	This enum represents the phases of creating
  *				a new link
  *
<span class="p_del">- *	@destructor:		Called from unregister,</span>
<span class="p_del">- *				can be used to call free_netdev</span>
<span class="p_add">+ *	@needs_free_netdev:	Should unregister perform free_netdev?</span>
<span class="p_add">+ *	@priv_destructor:	Called from unregister</span>
  *	@npinfo:		XXX: need comments on this one
  * 	@nd_net:		Network namespace this network device is inside
  *
<span class="p_chunk">@@ -1838,7 +1838,8 @@</span> <span class="p_context"> struct net_device {</span>
 		RTNL_LINK_INITIALIZING,
 	} rtnl_link_state:16;
 
<span class="p_del">-	void (*destructor)(struct net_device *dev);</span>
<span class="p_add">+	bool needs_free_netdev;</span>
<span class="p_add">+	void (*priv_destructor)(struct net_device *dev);</span>
 
 #ifdef CONFIG_NETPOLL
 	struct netpoll_info __rcu	*npinfo;
<span class="p_chunk">@@ -4231,6 +4232,11 @@</span> <span class="p_context"> static inline const char *netdev_name(const struct net_device *dev)</span>
 	return dev-&gt;name;
 }
 
<span class="p_add">+static inline bool netdev_unregistering(const struct net_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev-&gt;reg_state == NETREG_UNREGISTERING;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline const char *netdev_reg_state(const struct net_device *dev)
 {
 	switch (dev-&gt;reg_state) {
<span class="p_header">diff --git a/include/net/xfrm.h b/include/net/xfrm.h</span>
<span class="p_header">index 14d82bf16692..85bc8e7ade2e 100644</span>
<span class="p_header">--- a/include/net/xfrm.h</span>
<span class="p_header">+++ b/include/net/xfrm.h</span>
<span class="p_chunk">@@ -945,10 +945,6 @@</span> <span class="p_context"> struct xfrm_dst {</span>
 	struct flow_cache_object flo;
 	struct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];
 	int num_pols, num_xfrms;
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	struct flowi *origin;</span>
<span class="p_del">-	struct xfrm_selector *partner;</span>
<span class="p_del">-#endif</span>
 	u32 xfrm_genid;
 	u32 policy_genid;
 	u32 route_mtu_cached;
<span class="p_chunk">@@ -964,12 +960,6 @@</span> <span class="p_context"> static inline void xfrm_dst_destroy(struct xfrm_dst *xdst)</span>
 	dst_release(xdst-&gt;route);
 	if (likely(xdst-&gt;u.dst.xfrm))
 		xfrm_state_put(xdst-&gt;u.dst.xfrm);
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	kfree(xdst-&gt;origin);</span>
<span class="p_del">-	xdst-&gt;origin = NULL;</span>
<span class="p_del">-	kfree(xdst-&gt;partner);</span>
<span class="p_del">-	xdst-&gt;partner = NULL;</span>
<span class="p_del">-#endif</span>
 }
 #endif
 
<span class="p_header">diff --git a/mm/vmalloc.c b/mm/vmalloc.c</span>
<span class="p_header">index 0b057628a7ba..926ef9e8c71b 100644</span>
<span class="p_header">--- a/mm/vmalloc.c</span>
<span class="p_header">+++ b/mm/vmalloc.c</span>
<span class="p_chunk">@@ -287,10 +287,21 @@</span> <span class="p_context"> struct page *vmalloc_to_page(const void *vmalloc_addr)</span>
 	if (p4d_none(*p4d))
 		return NULL;
 	pud = pud_offset(p4d, addr);
<span class="p_del">-	if (pud_none(*pud))</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t dereference bad PUD or PMD (below) entries. This will also</span>
<span class="p_add">+	 * identify huge mappings, which we may encounter on architectures</span>
<span class="p_add">+	 * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be</span>
<span class="p_add">+	 * identified as vmalloc addresses by is_vmalloc_addr(), but are</span>
<span class="p_add">+	 * not [unambiguously] associated with a struct page, so there is</span>
<span class="p_add">+	 * no correct value to return for them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WARN_ON_ONCE(pud_bad(*pud));</span>
<span class="p_add">+	if (pud_none(*pud) || pud_bad(*pud))</span>
 		return NULL;
 	pmd = pmd_offset(pud, addr);
<span class="p_del">-	if (pmd_none(*pmd))</span>
<span class="p_add">+	WARN_ON_ONCE(pmd_bad(*pmd));</span>
<span class="p_add">+	if (pmd_none(*pmd) || pmd_bad(*pmd))</span>
 		return NULL;
 
 	ptep = pte_offset_map(pmd, addr);
<span class="p_header">diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c</span>
<span class="p_header">index 467069b73ce1..9649579b5b9f 100644</span>
<span class="p_header">--- a/net/8021q/vlan.c</span>
<span class="p_header">+++ b/net/8021q/vlan.c</span>
<span class="p_chunk">@@ -277,7 +277,8 @@</span> <span class="p_context"> static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)</span>
 	return 0;
 
 out_free_newdev:
<span class="p_del">-	free_netdev(new_dev);</span>
<span class="p_add">+	if (new_dev-&gt;reg_state == NETREG_UNINITIALIZED)</span>
<span class="p_add">+		free_netdev(new_dev);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/net/8021q/vlan_dev.c b/net/8021q/vlan_dev.c</span>
<span class="p_header">index e97ab824e368..0064dfd328d4 100644</span>
<span class="p_header">--- a/net/8021q/vlan_dev.c</span>
<span class="p_header">+++ b/net/8021q/vlan_dev.c</span>
<span class="p_chunk">@@ -807,7 +807,6 @@</span> <span class="p_context"> static void vlan_dev_free(struct net_device *dev)</span>
 
 	free_percpu(vlan-&gt;vlan_pcpu_stats);
 	vlan-&gt;vlan_pcpu_stats = NULL;
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 void vlan_setup(struct net_device *dev)
<span class="p_chunk">@@ -820,7 +819,8 @@</span> <span class="p_context"> void vlan_setup(struct net_device *dev)</span>
 	netif_keep_dst(dev);
 
 	dev-&gt;netdev_ops		= &amp;vlan_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= vlan_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
<span class="p_add">+	dev-&gt;priv_destructor	= vlan_dev_free;</span>
 	dev-&gt;ethtool_ops	= &amp;vlan_ethtool_ops;
 
 	dev-&gt;min_mtu		= 0;
<span class="p_header">diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c</span>
<span class="p_header">index d042c99af028..07ca0e8f30b2 100644</span>
<span class="p_header">--- a/net/batman-adv/soft-interface.c</span>
<span class="p_header">+++ b/net/batman-adv/soft-interface.c</span>
<span class="p_chunk">@@ -961,8 +961,6 @@</span> <span class="p_context"> static void batadv_softif_free(struct net_device *dev)</span>
 	 * netdev and its private data (bat_priv)
 	 */
 	rcu_barrier();
<span class="p_del">-</span>
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 /**
<span class="p_chunk">@@ -976,7 +974,8 @@</span> <span class="p_context"> static void batadv_softif_init_early(struct net_device *dev)</span>
 	ether_setup(dev);
 
 	dev-&gt;netdev_ops = &amp;batadv_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = batadv_softif_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = batadv_softif_free;</span>
 	dev-&gt;features |= NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_NETNS_LOCAL;
 	dev-&gt;priv_flags |= IFF_NO_QUEUE;
 
<span class="p_header">diff --git a/net/bluetooth/6lowpan.c b/net/bluetooth/6lowpan.c</span>
<span class="p_header">index d491529332f4..7ffeca72e928 100644</span>
<span class="p_header">--- a/net/bluetooth/6lowpan.c</span>
<span class="p_header">+++ b/net/bluetooth/6lowpan.c</span>
<span class="p_chunk">@@ -653,7 +653,7 @@</span> <span class="p_context"> static void netdev_setup(struct net_device *dev)</span>
 
 	dev-&gt;netdev_ops		= &amp;netdev_ops;
 	dev-&gt;header_ops		= &amp;header_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 }
 
 static struct device_type bt_type = {
<span class="p_header">diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c</span>
<span class="p_header">index 430b53e7d941..f0f3447e8aa4 100644</span>
<span class="p_header">--- a/net/bridge/br_device.c</span>
<span class="p_header">+++ b/net/bridge/br_device.c</span>
<span class="p_chunk">@@ -379,7 +379,7 @@</span> <span class="p_context"> void br_dev_setup(struct net_device *dev)</span>
 	ether_setup(dev);
 
 	dev-&gt;netdev_ops = &amp;br_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
 	dev-&gt;ethtool_ops = &amp;br_ethtool_ops;
 	SET_NETDEV_DEVTYPE(dev, &amp;br_type);
 	dev-&gt;priv_flags = IFF_EBRIDGE | IFF_NO_QUEUE;
<span class="p_header">diff --git a/net/caif/cfpkt_skbuff.c b/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">index 59ce1fcc220c..71b6ab240dea 100644</span>
<span class="p_header">--- a/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">+++ b/net/caif/cfpkt_skbuff.c</span>
<span class="p_chunk">@@ -81,11 +81,7 @@</span> <span class="p_context"> static struct cfpkt *cfpkt_create_pfx(u16 len, u16 pfx)</span>
 {
 	struct sk_buff *skb;
 
<span class="p_del">-	if (likely(in_interrupt()))</span>
<span class="p_del">-		skb = alloc_skb(len + pfx, GFP_ATOMIC);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		skb = alloc_skb(len + pfx, GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_add">+	skb = alloc_skb(len + pfx, GFP_ATOMIC);</span>
 	if (unlikely(skb == NULL))
 		return NULL;
 
<span class="p_header">diff --git a/net/caif/chnl_net.c b/net/caif/chnl_net.c</span>
<span class="p_header">index 1816fc9f1ee7..fe3c53efb949 100644</span>
<span class="p_header">--- a/net/caif/chnl_net.c</span>
<span class="p_header">+++ b/net/caif/chnl_net.c</span>
<span class="p_chunk">@@ -392,14 +392,14 @@</span> <span class="p_context"> static void chnl_net_destructor(struct net_device *dev)</span>
 {
 	struct chnl_net *priv = netdev_priv(dev);
 	caif_free_client(&amp;priv-&gt;chnl);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static void ipcaif_net_setup(struct net_device *dev)
 {
 	struct chnl_net *priv;
 	dev-&gt;netdev_ops = &amp;netdev_ops;
<span class="p_del">-	dev-&gt;destructor = chnl_net_destructor;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = chnl_net_destructor;</span>
 	dev-&gt;flags |= IFF_NOARP;
 	dev-&gt;flags |= IFF_POINTOPOINT;
 	dev-&gt;mtu = GPRS_PDP_MTU;
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 9b5875388c23..9debc1b26ce9 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -1251,8 +1251,9 @@</span> <span class="p_context"> int dev_set_alias(struct net_device *dev, const char *alias, size_t len)</span>
 	if (!new_ifalias)
 		return -ENOMEM;
 	dev-&gt;ifalias = new_ifalias;
<span class="p_add">+	memcpy(dev-&gt;ifalias, alias, len);</span>
<span class="p_add">+	dev-&gt;ifalias[len] = 0;</span>
 
<span class="p_del">-	strlcpy(dev-&gt;ifalias, alias, len+1);</span>
 	return len;
 }
 
<span class="p_chunk">@@ -7345,6 +7346,8 @@</span> <span class="p_context"> int register_netdevice(struct net_device *dev)</span>
 err_uninit:
 	if (dev-&gt;netdev_ops-&gt;ndo_uninit)
 		dev-&gt;netdev_ops-&gt;ndo_uninit(dev);
<span class="p_add">+	if (dev-&gt;priv_destructor)</span>
<span class="p_add">+		dev-&gt;priv_destructor(dev);</span>
 	goto out;
 }
 EXPORT_SYMBOL(register_netdevice);
<span class="p_chunk">@@ -7552,8 +7555,10 @@</span> <span class="p_context"> void netdev_run_todo(void)</span>
 		WARN_ON(rcu_access_pointer(dev-&gt;ip6_ptr));
 		WARN_ON(dev-&gt;dn_ptr);
 
<span class="p_del">-		if (dev-&gt;destructor)</span>
<span class="p_del">-			dev-&gt;destructor(dev);</span>
<span class="p_add">+		if (dev-&gt;priv_destructor)</span>
<span class="p_add">+			dev-&gt;priv_destructor(dev);</span>
<span class="p_add">+		if (dev-&gt;needs_free_netdev)</span>
<span class="p_add">+			free_netdev(dev);</span>
 
 		/* Report a network device has been unregistered */
 		rtnl_lock();
<span class="p_header">diff --git a/net/core/dst.c b/net/core/dst.c</span>
<span class="p_header">index 6192f11beec9..13ba4a090c41 100644</span>
<span class="p_header">--- a/net/core/dst.c</span>
<span class="p_header">+++ b/net/core/dst.c</span>
<span class="p_chunk">@@ -469,6 +469,20 @@</span> <span class="p_context"> static int dst_dev_event(struct notifier_block *this, unsigned long event,</span>
 		spin_lock_bh(&amp;dst_garbage.lock);
 		dst = dst_garbage.list;
 		dst_garbage.list = NULL;
<span class="p_add">+		/* The code in dst_ifdown places a hold on the loopback device.</span>
<span class="p_add">+		 * If the gc entry processing is set to expire after a lengthy</span>
<span class="p_add">+		 * interval, this hold can cause netdev_wait_allrefs() to hang</span>
<span class="p_add">+		 * out and wait for a long time -- until the the loopback</span>
<span class="p_add">+		 * interface is released.  If we&#39;re really unlucky, it&#39;ll emit</span>
<span class="p_add">+		 * pr_emerg messages to console too.  Reset the interval here,</span>
<span class="p_add">+		 * so dst cleanups occur in a more timely fashion.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (dst_garbage.timer_inc &gt; DST_GC_INC) {</span>
<span class="p_add">+			dst_garbage.timer_inc = DST_GC_INC;</span>
<span class="p_add">+			dst_garbage.timer_expires = DST_GC_MIN;</span>
<span class="p_add">+			mod_delayed_work(system_wq, &amp;dst_gc_work,</span>
<span class="p_add">+					 dst_garbage.timer_expires);</span>
<span class="p_add">+		}</span>
 		spin_unlock_bh(&amp;dst_garbage.lock);
 
 		if (last)
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 8d4a185a8143..05436c02fb7b 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -934,6 +934,7 @@</span> <span class="p_context"> static noinline size_t if_nlmsg_size(const struct net_device *dev,</span>
 	       + nla_total_size(1) /* IFLA_LINKMODE */
 	       + nla_total_size(4) /* IFLA_CARRIER_CHANGES */
 	       + nla_total_size(4) /* IFLA_LINK_NETNSID */
<span class="p_add">+	       + nla_total_size(4) /* IFLA_GROUP */</span>
 	       + nla_total_size(ext_filter_mask
 			        &amp; RTEXT_FILTER_VF ? 4 : 0) /* IFLA_NUM_VF */
 	       + rtnl_vfinfo_size(dev, ext_filter_mask) /* IFLA_VFINFO_LIST */
<span class="p_chunk">@@ -1127,6 +1128,8 @@</span> <span class="p_context"> static noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,</span>
 	struct ifla_vf_mac vf_mac;
 	struct ifla_vf_info ivi;
 
<span class="p_add">+	memset(&amp;ivi, 0, sizeof(ivi));</span>
<span class="p_add">+</span>
 	/* Not all SR-IOV capable drivers support the
 	 * spoofcheck and &quot;RSS query enable&quot; query.  Preset to
 	 * -1 so the user space tool can detect that the driver
<span class="p_chunk">@@ -1135,7 +1138,6 @@</span> <span class="p_context"> static noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,</span>
 	ivi.spoofchk = -1;
 	ivi.rss_query_en = -1;
 	ivi.trusted = -1;
<span class="p_del">-	memset(ivi.mac, 0, sizeof(ivi.mac));</span>
 	/* The default value for VF link state is &quot;auto&quot;
 	 * IFLA_VF_LINK_STATE_AUTO which equals zero
 	 */
<span class="p_chunk">@@ -1461,6 +1463,7 @@</span> <span class="p_context"> static const struct nla_policy ifla_policy[IFLA_MAX+1] = {</span>
 	[IFLA_LINK_NETNSID]	= { .type = NLA_S32 },
 	[IFLA_PROTO_DOWN]	= { .type = NLA_U8 },
 	[IFLA_XDP]		= { .type = NLA_NESTED },
<span class="p_add">+	[IFLA_GROUP]		= { .type = NLA_U32 },</span>
 };
 
 static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {
<span class="p_header">diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c</span>
<span class="p_header">index b1dc096d22f8..403593bd2b83 100644</span>
<span class="p_header">--- a/net/decnet/dn_route.c</span>
<span class="p_header">+++ b/net/decnet/dn_route.c</span>
<span class="p_chunk">@@ -188,12 +188,6 @@</span> <span class="p_context"> static inline void dnrt_free(struct dn_route *rt)</span>
 	call_rcu_bh(&amp;rt-&gt;dst.rcu_head, dst_rcu_free);
 }
 
<span class="p_del">-static inline void dnrt_drop(struct dn_route *rt)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dst_release(&amp;rt-&gt;dst);</span>
<span class="p_del">-	call_rcu_bh(&amp;rt-&gt;dst.rcu_head, dst_rcu_free);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void dn_dst_check_expire(unsigned long dummy)
 {
 	int i;
<span class="p_chunk">@@ -248,7 +242,7 @@</span> <span class="p_context"> static int dn_dst_gc(struct dst_ops *ops)</span>
 			}
 			*rtp = rt-&gt;dst.dn_next;
 			rt-&gt;dst.dn_next = NULL;
<span class="p_del">-			dnrt_drop(rt);</span>
<span class="p_add">+			dnrt_free(rt);</span>
 			break;
 		}
 		spin_unlock_bh(&amp;dn_rt_hash_table[i].lock);
<span class="p_chunk">@@ -350,7 +344,7 @@</span> <span class="p_context"> static int dn_insert_route(struct dn_route *rt, unsigned int hash, struct dn_rou</span>
 			dst_use(&amp;rth-&gt;dst, now);
 			spin_unlock_bh(&amp;dn_rt_hash_table[hash].lock);
 
<span class="p_del">-			dnrt_drop(rt);</span>
<span class="p_add">+			dst_free(&amp;rt-&gt;dst);</span>
 			*rp = rth;
 			return 0;
 		}
<span class="p_chunk">@@ -380,7 +374,7 @@</span> <span class="p_context"> static void dn_run_flush(unsigned long dummy)</span>
 		for(; rt; rt = next) {
 			next = rcu_dereference_raw(rt-&gt;dst.dn_next);
 			RCU_INIT_POINTER(rt-&gt;dst.dn_next, NULL);
<span class="p_del">-			dst_free((struct dst_entry *)rt);</span>
<span class="p_add">+			dnrt_free(rt);</span>
 		}
 
 nothing_to_declare:
<span class="p_chunk">@@ -1187,7 +1181,7 @@</span> <span class="p_context"> static int dn_route_output_slow(struct dst_entry **pprt, const struct flowidn *o</span>
 	if (dev_out-&gt;flags &amp; IFF_LOOPBACK)
 		flags |= RTCF_LOCAL;
 
<span class="p_del">-	rt = dst_alloc(&amp;dn_dst_ops, dev_out, 1, DST_OBSOLETE_NONE, DST_HOST);</span>
<span class="p_add">+	rt = dst_alloc(&amp;dn_dst_ops, dev_out, 0, DST_OBSOLETE_NONE, DST_HOST);</span>
 	if (rt == NULL)
 		goto e_nobufs;
 
<span class="p_header">diff --git a/net/decnet/netfilter/dn_rtmsg.c b/net/decnet/netfilter/dn_rtmsg.c</span>
<span class="p_header">index 85f2fdc360c2..29246bc9a7b4 100644</span>
<span class="p_header">--- a/net/decnet/netfilter/dn_rtmsg.c</span>
<span class="p_header">+++ b/net/decnet/netfilter/dn_rtmsg.c</span>
<span class="p_chunk">@@ -102,7 +102,9 @@</span> <span class="p_context"> static inline void dnrmg_receive_user_skb(struct sk_buff *skb)</span>
 {
 	struct nlmsghdr *nlh = nlmsg_hdr(skb);
 
<span class="p_del">-	if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) || skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span>
<span class="p_add">+	if (skb-&gt;len &lt; sizeof(*nlh) ||</span>
<span class="p_add">+	    nlh-&gt;nlmsg_len &lt; sizeof(*nlh) ||</span>
<span class="p_add">+	    skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span>
 		return;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
<span class="p_header">diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c</span>
<span class="p_header">index c73160fb11e7..0a0a392dc2bd 100644</span>
<span class="p_header">--- a/net/hsr/hsr_device.c</span>
<span class="p_header">+++ b/net/hsr/hsr_device.c</span>
<span class="p_chunk">@@ -378,7 +378,6 @@</span> <span class="p_context"> static void hsr_dev_destroy(struct net_device *hsr_dev)</span>
 	del_timer_sync(&amp;hsr-&gt;announce_timer);
 
 	synchronize_rcu();
<span class="p_del">-	free_netdev(hsr_dev);</span>
 }
 
 static const struct net_device_ops hsr_device_ops = {
<span class="p_chunk">@@ -404,7 +403,8 @@</span> <span class="p_context"> void hsr_dev_setup(struct net_device *dev)</span>
 	SET_NETDEV_DEVTYPE(dev, &amp;hsr_type);
 	dev-&gt;priv_flags |= IFF_NO_QUEUE;
 
<span class="p_del">-	dev-&gt;destructor = hsr_dev_destroy;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = hsr_dev_destroy;</span>
 
 	dev-&gt;hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
 			   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |
<span class="p_header">diff --git a/net/ieee802154/6lowpan/core.c b/net/ieee802154/6lowpan/core.c</span>
<span class="p_header">index d7efbf0dad20..0a866f332290 100644</span>
<span class="p_header">--- a/net/ieee802154/6lowpan/core.c</span>
<span class="p_header">+++ b/net/ieee802154/6lowpan/core.c</span>
<span class="p_chunk">@@ -107,7 +107,7 @@</span> <span class="p_context"> static void lowpan_setup(struct net_device *ldev)</span>
 
 	ldev-&gt;netdev_ops	= &amp;lowpan_netdev_ops;
 	ldev-&gt;header_ops	= &amp;lowpan_header_ops;
<span class="p_del">-	ldev-&gt;destructor	= free_netdev;</span>
<span class="p_add">+	ldev-&gt;needs_free_netdev	= true;</span>
 	ldev-&gt;features		|= NETIF_F_NETNS_LOCAL;
 }
 
<span class="p_header">diff --git a/net/ipv4/esp4.c b/net/ipv4/esp4.c</span>
<span class="p_header">index b1e24446e297..9708a32b1f26 100644</span>
<span class="p_header">--- a/net/ipv4/esp4.c</span>
<span class="p_header">+++ b/net/ipv4/esp4.c</span>
<span class="p_chunk">@@ -212,6 +212,7 @@</span> <span class="p_context"> static int esp_output(struct xfrm_state *x, struct sk_buff *skb)</span>
 	u8 *iv;
 	u8 *tail;
 	u8 *vaddr;
<span class="p_add">+	int esph_offset;</span>
 	int blksize;
 	int clen;
 	int alen;
<span class="p_chunk">@@ -392,12 +393,14 @@</span> <span class="p_context"> static int esp_output(struct xfrm_state *x, struct sk_buff *skb)</span>
 	}
 
 cow:
<span class="p_add">+	esph_offset = (unsigned char *)esph - skb_transport_header(skb);</span>
<span class="p_add">+</span>
 	err = skb_cow_data(skb, tailen, &amp;trailer);
 	if (err &lt; 0)
 		goto error;
 	nfrags = err;
 	tail = skb_tail_pointer(trailer);
<span class="p_del">-	esph = ip_esp_hdr(skb);</span>
<span class="p_add">+	esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);</span>
 
 skip_cow:
 	esp_output_fill_trailer(tail, tfclen, plen, proto);
<span class="p_header">diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c</span>
<span class="p_header">index fc310db2708b..760311fd7c5b 100644</span>
<span class="p_header">--- a/net/ipv4/icmp.c</span>
<span class="p_header">+++ b/net/ipv4/icmp.c</span>
<span class="p_chunk">@@ -674,8 +674,12 @@</span> <span class="p_context"> void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)</span>
 	/* Needed by both icmp_global_allow and icmp_xmit_lock */
 	local_bh_disable();
 
<span class="p_del">-	/* Check global sysctl_icmp_msgs_per_sec ratelimit */</span>
<span class="p_del">-	if (!icmpv4_global_allow(net, type, code))</span>
<span class="p_add">+	/* Check global sysctl_icmp_msgs_per_sec ratelimit, unless</span>
<span class="p_add">+	 * incoming dev is loopback.  If outgoing dev change to not be</span>
<span class="p_add">+	 * loopback, then peer ratelimit still work (in icmpv4_xrlim_allow)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(skb_in-&gt;dev &amp;&amp; (skb_in-&gt;dev-&gt;flags&amp;IFF_LOOPBACK)) &amp;&amp;</span>
<span class="p_add">+	      !icmpv4_global_allow(net, type, code))</span>
 		goto out_bh_enable;
 
 	sk = icmp_xmit_lock(net);
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 44fd86de2823..ec9a396fa466 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -1112,6 +1112,7 @@</span> <span class="p_context"> static void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im)</span>
 	pmc = kzalloc(sizeof(*pmc), GFP_KERNEL);
 	if (!pmc)
 		return;
<span class="p_add">+	spin_lock_init(&amp;pmc-&gt;lock);</span>
 	spin_lock_bh(&amp;im-&gt;lock);
 	pmc-&gt;interface = im-&gt;interface;
 	in_dev_hold(in_dev);
<span class="p_chunk">@@ -2071,21 +2072,26 @@</span> <span class="p_context"> static int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,</span>
 
 static void ip_mc_clear_src(struct ip_mc_list *pmc)
 {
<span class="p_del">-	struct ip_sf_list *psf, *nextpsf;</span>
<span class="p_add">+	struct ip_sf_list *psf, *nextpsf, *tomb, *sources;</span>
 
<span class="p_del">-	for (psf = pmc-&gt;tomb; psf; psf = nextpsf) {</span>
<span class="p_add">+	spin_lock_bh(&amp;pmc-&gt;lock);</span>
<span class="p_add">+	tomb = pmc-&gt;tomb;</span>
<span class="p_add">+	pmc-&gt;tomb = NULL;</span>
<span class="p_add">+	sources = pmc-&gt;sources;</span>
<span class="p_add">+	pmc-&gt;sources = NULL;</span>
<span class="p_add">+	pmc-&gt;sfmode = MCAST_EXCLUDE;</span>
<span class="p_add">+	pmc-&gt;sfcount[MCAST_INCLUDE] = 0;</span>
<span class="p_add">+	pmc-&gt;sfcount[MCAST_EXCLUDE] = 1;</span>
<span class="p_add">+	spin_unlock_bh(&amp;pmc-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (psf = tomb; psf; psf = nextpsf) {</span>
 		nextpsf = psf-&gt;sf_next;
 		kfree(psf);
 	}
<span class="p_del">-	pmc-&gt;tomb = NULL;</span>
<span class="p_del">-	for (psf = pmc-&gt;sources; psf; psf = nextpsf) {</span>
<span class="p_add">+	for (psf = sources; psf; psf = nextpsf) {</span>
 		nextpsf = psf-&gt;sf_next;
 		kfree(psf);
 	}
<span class="p_del">-	pmc-&gt;sources = NULL;</span>
<span class="p_del">-	pmc-&gt;sfmode = MCAST_EXCLUDE;</span>
<span class="p_del">-	pmc-&gt;sfcount[MCAST_INCLUDE] = 0;</span>
<span class="p_del">-	pmc-&gt;sfcount[MCAST_EXCLUDE] = 1;</span>
 }
 
 /* Join a multicast group
<span class="p_header">diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c</span>
<span class="p_header">index 823abaef006b..b2d1be55ca94 100644</span>
<span class="p_header">--- a/net/ipv4/ip_tunnel.c</span>
<span class="p_header">+++ b/net/ipv4/ip_tunnel.c</span>
<span class="p_chunk">@@ -961,7 +961,6 @@</span> <span class="p_context"> static void ip_tunnel_dev_free(struct net_device *dev)</span>
 	gro_cells_destroy(&amp;tunnel-&gt;gro_cells);
 	dst_cache_destroy(&amp;tunnel-&gt;dst_cache);
 	free_percpu(dev-&gt;tstats);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 void ip_tunnel_dellink(struct net_device *dev, struct list_head *head)
<span class="p_chunk">@@ -1148,7 +1147,8 @@</span> <span class="p_context"> int ip_tunnel_init(struct net_device *dev)</span>
 	struct iphdr *iph = &amp;tunnel-&gt;parms.iph;
 	int err;
 
<span class="p_del">-	dev-&gt;destructor	= ip_tunnel_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = ip_tunnel_dev_free;</span>
 	dev-&gt;tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
 	if (!dev-&gt;tstats)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c</span>
<span class="p_header">index b036e85e093b..96c5681abb05 100644</span>
<span class="p_header">--- a/net/ipv4/ipmr.c</span>
<span class="p_header">+++ b/net/ipv4/ipmr.c</span>
<span class="p_chunk">@@ -501,7 +501,7 @@</span> <span class="p_context"> static void reg_vif_setup(struct net_device *dev)</span>
 	dev-&gt;mtu		= ETH_DATA_LEN - sizeof(struct iphdr) - 8;
 	dev-&gt;flags		= IFF_NOARP;
 	dev-&gt;netdev_ops		= &amp;reg_vif_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 	dev-&gt;features		|= NETIF_F_NETNS_LOCAL;
 }
 
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 311f45641673..9725e8faf56d 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -328,9 +328,9 @@</span> <span class="p_context"> static void addrconf_mod_rs_timer(struct inet6_dev *idev,</span>
 static void addrconf_mod_dad_work(struct inet6_ifaddr *ifp,
 				   unsigned long delay)
 {
<span class="p_del">-	if (!delayed_work_pending(&amp;ifp-&gt;dad_work))</span>
<span class="p_del">-		in6_ifa_hold(ifp);</span>
<span class="p_del">-	mod_delayed_work(addrconf_wq, &amp;ifp-&gt;dad_work, delay);</span>
<span class="p_add">+	in6_ifa_hold(ifp);</span>
<span class="p_add">+	if (mod_delayed_work(addrconf_wq, &amp;ifp-&gt;dad_work, delay))</span>
<span class="p_add">+		in6_ifa_put(ifp);</span>
 }
 
 static int snmp6_alloc_dev(struct inet6_dev *idev)
<span class="p_header">diff --git a/net/ipv6/fib6_rules.c b/net/ipv6/fib6_rules.c</span>
<span class="p_header">index eea23b57c6a5..ec849d88a662 100644</span>
<span class="p_header">--- a/net/ipv6/fib6_rules.c</span>
<span class="p_header">+++ b/net/ipv6/fib6_rules.c</span>
<span class="p_chunk">@@ -32,7 +32,6 @@</span> <span class="p_context"> struct fib6_rule {</span>
 struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
 				   int flags, pol_lookup_t lookup)
 {
<span class="p_del">-	struct rt6_info *rt;</span>
 	struct fib_lookup_arg arg = {
 		.lookup_ptr = lookup,
 		.flags = FIB_LOOKUP_NOREF,
<span class="p_chunk">@@ -44,21 +43,11 @@</span> <span class="p_context"> struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,</span>
 	fib_rules_lookup(net-&gt;ipv6.fib6_rules_ops,
 			 flowi6_to_flowi(fl6), flags, &amp;arg);
 
<span class="p_del">-	rt = arg.result;</span>
<span class="p_add">+	if (arg.result)</span>
<span class="p_add">+		return arg.result;</span>
 
<span class="p_del">-	if (!rt) {</span>
<span class="p_del">-		dst_hold(&amp;net-&gt;ipv6.ip6_null_entry-&gt;dst);</span>
<span class="p_del">-		return &amp;net-&gt;ipv6.ip6_null_entry-&gt;dst;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (rt-&gt;rt6i_flags &amp; RTF_REJECT &amp;&amp;</span>
<span class="p_del">-	    rt-&gt;dst.error == -EAGAIN) {</span>
<span class="p_del">-		ip6_rt_put(rt);</span>
<span class="p_del">-		rt = net-&gt;ipv6.ip6_null_entry;</span>
<span class="p_del">-		dst_hold(&amp;rt-&gt;dst);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return &amp;rt-&gt;dst;</span>
<span class="p_add">+	dst_hold(&amp;net-&gt;ipv6.ip6_null_entry-&gt;dst);</span>
<span class="p_add">+	return &amp;net-&gt;ipv6.ip6_null_entry-&gt;dst;</span>
 }
 
 static int fib6_rule_action(struct fib_rule *rule, struct flowi *flp,
<span class="p_chunk">@@ -121,7 +110,8 @@</span> <span class="p_context"> static int fib6_rule_action(struct fib_rule *rule, struct flowi *flp,</span>
 			flp6-&gt;saddr = saddr;
 		}
 		err = rt-&gt;dst.error;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		if (err != -EAGAIN)</span>
<span class="p_add">+			goto out;</span>
 	}
 again:
 	ip6_rt_put(rt);
<span class="p_header">diff --git a/net/ipv6/icmp.c b/net/ipv6/icmp.c</span>
<span class="p_header">index 230b5aac9f03..8d7b113958b1 100644</span>
<span class="p_header">--- a/net/ipv6/icmp.c</span>
<span class="p_header">+++ b/net/ipv6/icmp.c</span>
<span class="p_chunk">@@ -491,7 +491,7 @@</span> <span class="p_context"> static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,</span>
 	local_bh_disable();
 
 	/* Check global sysctl_icmp_msgs_per_sec ratelimit */
<span class="p_del">-	if (!icmpv6_global_allow(type))</span>
<span class="p_add">+	if (!(skb-&gt;dev-&gt;flags&amp;IFF_LOOPBACK) &amp;&amp; !icmpv6_global_allow(type))</span>
 		goto out_bh_enable;
 
 	mip6_addr_swap(skb);
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index d4bf2c68a545..e6b78ba0e636 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -289,8 +289,7 @@</span> <span class="p_context"> struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,</span>
 	struct rt6_info *rt;
 
 	rt = lookup(net, net-&gt;ipv6.fib6_main_tbl, fl6, flags);
<span class="p_del">-	if (rt-&gt;rt6i_flags &amp; RTF_REJECT &amp;&amp;</span>
<span class="p_del">-	    rt-&gt;dst.error == -EAGAIN) {</span>
<span class="p_add">+	if (rt-&gt;dst.error == -EAGAIN) {</span>
 		ip6_rt_put(rt);
 		rt = net-&gt;ipv6.ip6_null_entry;
 		dst_hold(&amp;rt-&gt;dst);
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index 4d60164c17e2..0f1c24935b7a 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -986,13 +986,13 @@</span> <span class="p_context"> static void ip6gre_dev_free(struct net_device *dev)</span>
 
 	dst_cache_destroy(&amp;t-&gt;dst_cache);
 	free_percpu(dev-&gt;tstats);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static void ip6gre_tunnel_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops = &amp;ip6gre_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = ip6gre_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = ip6gre_dev_free;</span>
 
 	dev-&gt;type = ARPHRD_IP6GRE;
 
<span class="p_chunk">@@ -1143,7 +1143,7 @@</span> <span class="p_context"> static int __net_init ip6gre_init_net(struct net *net)</span>
 	return 0;
 
 err_reg_dev:
<span class="p_del">-	ip6gre_dev_free(ign-&gt;fb_tunnel_dev);</span>
<span class="p_add">+	free_netdev(ign-&gt;fb_tunnel_dev);</span>
 err_alloc_dev:
 	return err;
 }
<span class="p_chunk">@@ -1292,7 +1292,8 @@</span> <span class="p_context"> static void ip6gre_tap_setup(struct net_device *dev)</span>
 	ether_setup(dev);
 
 	dev-&gt;netdev_ops = &amp;ip6gre_tap_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = ip6gre_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = ip6gre_dev_free;</span>
 
 	dev-&gt;features |= NETIF_F_NETNS_LOCAL;
 	dev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index e2d7867f3112..292f24c48c94 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -254,7 +254,6 @@</span> <span class="p_context"> static void ip6_dev_free(struct net_device *dev)</span>
 	gro_cells_destroy(&amp;t-&gt;gro_cells);
 	dst_cache_destroy(&amp;t-&gt;dst_cache);
 	free_percpu(dev-&gt;tstats);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static int ip6_tnl_create2(struct net_device *dev)
<span class="p_chunk">@@ -322,7 +321,7 @@</span> <span class="p_context"> static struct ip6_tnl *ip6_tnl_create(struct net *net, struct __ip6_tnl_parm *p)</span>
 	return t;
 
 failed_free:
<span class="p_del">-	ip6_dev_free(dev);</span>
<span class="p_add">+	free_netdev(dev);</span>
 failed:
 	return ERR_PTR(err);
 }
<span class="p_chunk">@@ -1772,7 +1771,8 @@</span> <span class="p_context"> static const struct net_device_ops ip6_tnl_netdev_ops = {</span>
 static void ip6_tnl_dev_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops = &amp;ip6_tnl_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = ip6_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = ip6_dev_free;</span>
 
 	dev-&gt;type = ARPHRD_TUNNEL6;
 	dev-&gt;flags |= IFF_NOARP;
<span class="p_chunk">@@ -2211,7 +2211,7 @@</span> <span class="p_context"> static int __net_init ip6_tnl_init_net(struct net *net)</span>
 	return 0;
 
 err_register:
<span class="p_del">-	ip6_dev_free(ip6n-&gt;fb_tnl_dev);</span>
<span class="p_add">+	free_netdev(ip6n-&gt;fb_tnl_dev);</span>
 err_alloc_dev:
 	return err;
 }
<span class="p_header">diff --git a/net/ipv6/ip6_vti.c b/net/ipv6/ip6_vti.c</span>
<span class="p_header">index 3d8a3b63b4fd..5659f4a40f38 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_vti.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_vti.c</span>
<span class="p_chunk">@@ -180,7 +180,6 @@</span> <span class="p_context"> vti6_tnl_unlink(struct vti6_net *ip6n, struct ip6_tnl *t)</span>
 static void vti6_dev_free(struct net_device *dev)
 {
 	free_percpu(dev-&gt;tstats);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static int vti6_tnl_create2(struct net_device *dev)
<span class="p_chunk">@@ -235,7 +234,7 @@</span> <span class="p_context"> static struct ip6_tnl *vti6_tnl_create(struct net *net, struct __ip6_tnl_parm *p</span>
 	return t;
 
 failed_free:
<span class="p_del">-	vti6_dev_free(dev);</span>
<span class="p_add">+	free_netdev(dev);</span>
 failed:
 	return NULL;
 }
<span class="p_chunk">@@ -841,7 +840,8 @@</span> <span class="p_context"> static const struct net_device_ops vti6_netdev_ops = {</span>
 static void vti6_dev_setup(struct net_device *dev)
 {
 	dev-&gt;netdev_ops = &amp;vti6_netdev_ops;
<span class="p_del">-	dev-&gt;destructor = vti6_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = vti6_dev_free;</span>
 
 	dev-&gt;type = ARPHRD_TUNNEL6;
 	dev-&gt;hard_header_len = LL_MAX_HEADER + sizeof(struct ipv6hdr);
<span class="p_chunk">@@ -1092,7 +1092,7 @@</span> <span class="p_context"> static int __net_init vti6_init_net(struct net *net)</span>
 	return 0;
 
 err_register:
<span class="p_del">-	vti6_dev_free(ip6n-&gt;fb_tnl_dev);</span>
<span class="p_add">+	free_netdev(ip6n-&gt;fb_tnl_dev);</span>
 err_alloc_dev:
 	return err;
 }
<span class="p_header">diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c</span>
<span class="p_header">index bf34d0950752..576fd9332235 100644</span>
<span class="p_header">--- a/net/ipv6/ip6mr.c</span>
<span class="p_header">+++ b/net/ipv6/ip6mr.c</span>
<span class="p_chunk">@@ -733,7 +733,7 @@</span> <span class="p_context"> static void reg_vif_setup(struct net_device *dev)</span>
 	dev-&gt;mtu		= 1500 - sizeof(struct ipv6hdr) - 8;
 	dev-&gt;flags		= IFF_NOARP;
 	dev-&gt;netdev_ops		= &amp;reg_vif_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 	dev-&gt;features		|= NETIF_F_NETNS_LOCAL;
 }
 
<span class="p_header">diff --git a/net/ipv6/proc.c b/net/ipv6/proc.c</span>
<span class="p_header">index cc8e3ae9ca73..e88bcb8ff0fd 100644</span>
<span class="p_header">--- a/net/ipv6/proc.c</span>
<span class="p_header">+++ b/net/ipv6/proc.c</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> static void snmp6_seq_show_item64(struct seq_file *seq, void __percpu *mib,</span>
 	u64 buff64[SNMP_MIB_MAX];
 	int i;
 
<span class="p_del">-	memset(buff64, 0, sizeof(unsigned long) * SNMP_MIB_MAX);</span>
<span class="p_add">+	memset(buff64, 0, sizeof(u64) * SNMP_MIB_MAX);</span>
 
 	snmp_get_cpu_field64_batch(buff64, itemlist, mib, syncpoff);
 	for (i = 0; itemlist[i].name; i++)
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index d316d00e11ab..1072fc189708 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -2804,6 +2804,7 @@</span> <span class="p_context"> static int fib6_ifdown(struct rt6_info *rt, void *arg)</span>
 	if ((rt-&gt;dst.dev == dev || !dev) &amp;&amp;
 	    rt != adn-&gt;net-&gt;ipv6.ip6_null_entry &amp;&amp;
 	    (rt-&gt;rt6i_nsiblings == 0 ||
<span class="p_add">+	     (dev &amp;&amp; netdev_unregistering(dev)) ||</span>
 	     !rt-&gt;rt6i_idev-&gt;cnf.ignore_routes_with_linkdown))
 		return -1;
 
<span class="p_header">diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c</span>
<span class="p_header">index 99853c6e33a8..4f07a211ac2a 100644</span>
<span class="p_header">--- a/net/ipv6/sit.c</span>
<span class="p_header">+++ b/net/ipv6/sit.c</span>
<span class="p_chunk">@@ -265,7 +265,7 @@</span> <span class="p_context"> static struct ip_tunnel *ipip6_tunnel_locate(struct net *net,</span>
 	return nt;
 
 failed_free:
<span class="p_del">-	ipip6_dev_free(dev);</span>
<span class="p_add">+	free_netdev(dev);</span>
 failed:
 	return NULL;
 }
<span class="p_chunk">@@ -1333,7 +1333,6 @@</span> <span class="p_context"> static void ipip6_dev_free(struct net_device *dev)</span>
 
 	dst_cache_destroy(&amp;tunnel-&gt;dst_cache);
 	free_percpu(dev-&gt;tstats);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 #define SIT_FEATURES (NETIF_F_SG	   | \
<span class="p_chunk">@@ -1348,7 +1347,8 @@</span> <span class="p_context"> static void ipip6_tunnel_setup(struct net_device *dev)</span>
 	int t_hlen = tunnel-&gt;hlen + sizeof(struct iphdr);
 
 	dev-&gt;netdev_ops		= &amp;ipip6_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= ipip6_dev_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
<span class="p_add">+	dev-&gt;priv_destructor	= ipip6_dev_free;</span>
 
 	dev-&gt;type		= ARPHRD_SIT;
 	dev-&gt;hard_header_len	= LL_MAX_HEADER + t_hlen;
<span class="p_header">diff --git a/net/ipv6/xfrm6_input.c b/net/ipv6/xfrm6_input.c</span>
<span class="p_header">index 08a807b29298..3ef5d913e7a3 100644</span>
<span class="p_header">--- a/net/ipv6/xfrm6_input.c</span>
<span class="p_header">+++ b/net/ipv6/xfrm6_input.c</span>
<span class="p_chunk">@@ -43,8 +43,8 @@</span> <span class="p_context"> int xfrm6_transport_finish(struct sk_buff *skb, int async)</span>
 		return 1;
 #endif
 
<span class="p_del">-	ipv6_hdr(skb)-&gt;payload_len = htons(skb-&gt;len);</span>
 	__skb_push(skb, skb-&gt;data - skb_network_header(skb));
<span class="p_add">+	ipv6_hdr(skb)-&gt;payload_len = htons(skb-&gt;len - sizeof(struct ipv6hdr));</span>
 
 	if (xo &amp;&amp; (xo-&gt;flags &amp; XFRM_GRO)) {
 		skb_mac_header_rebuild(skb);
<span class="p_header">diff --git a/net/irda/irlan/irlan_eth.c b/net/irda/irlan/irlan_eth.c</span>
<span class="p_header">index 74d09f91709e..3be852808a9d 100644</span>
<span class="p_header">--- a/net/irda/irlan/irlan_eth.c</span>
<span class="p_header">+++ b/net/irda/irlan/irlan_eth.c</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> static void irlan_eth_setup(struct net_device *dev)</span>
 	ether_setup(dev);
 
 	dev-&gt;netdev_ops		= &amp;irlan_eth_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 	dev-&gt;min_mtu		= 0;
 	dev-&gt;max_mtu		= ETH_MAX_MTU;
 
<span class="p_header">diff --git a/net/key/af_key.c b/net/key/af_key.c</span>
<span class="p_header">index be8cecc65002..358175c83180 100644</span>
<span class="p_header">--- a/net/key/af_key.c</span>
<span class="p_header">+++ b/net/key/af_key.c</span>
<span class="p_chunk">@@ -1157,6 +1157,7 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 			goto out;
 	}
 
<span class="p_add">+	err = -ENOBUFS;</span>
 	key = ext_hdrs[SADB_EXT_KEY_AUTH - 1];
 	if (sa-&gt;sadb_sa_auth) {
 		int keysize = 0;
<span class="p_chunk">@@ -1168,8 +1169,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 		if (key)
 			keysize = (key-&gt;sadb_key_bits + 7) / 8;
 		x-&gt;aalg = kmalloc(sizeof(*x-&gt;aalg) + keysize, GFP_KERNEL);
<span class="p_del">-		if (!x-&gt;aalg)</span>
<span class="p_add">+		if (!x-&gt;aalg) {</span>
<span class="p_add">+			err = -ENOMEM;</span>
 			goto out;
<span class="p_add">+		}</span>
 		strcpy(x-&gt;aalg-&gt;alg_name, a-&gt;name);
 		x-&gt;aalg-&gt;alg_key_len = 0;
 		if (key) {
<span class="p_chunk">@@ -1188,8 +1191,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 				goto out;
 			}
 			x-&gt;calg = kmalloc(sizeof(*x-&gt;calg), GFP_KERNEL);
<span class="p_del">-			if (!x-&gt;calg)</span>
<span class="p_add">+			if (!x-&gt;calg) {</span>
<span class="p_add">+				err = -ENOMEM;</span>
 				goto out;
<span class="p_add">+			}</span>
 			strcpy(x-&gt;calg-&gt;alg_name, a-&gt;name);
 			x-&gt;props.calgo = sa-&gt;sadb_sa_encrypt;
 		} else {
<span class="p_chunk">@@ -1203,8 +1208,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 			if (key)
 				keysize = (key-&gt;sadb_key_bits + 7) / 8;
 			x-&gt;ealg = kmalloc(sizeof(*x-&gt;ealg) + keysize, GFP_KERNEL);
<span class="p_del">-			if (!x-&gt;ealg)</span>
<span class="p_add">+			if (!x-&gt;ealg) {</span>
<span class="p_add">+				err = -ENOMEM;</span>
 				goto out;
<span class="p_add">+			}</span>
 			strcpy(x-&gt;ealg-&gt;alg_name, a-&gt;name);
 			x-&gt;ealg-&gt;alg_key_len = 0;
 			if (key) {
<span class="p_chunk">@@ -1249,8 +1256,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 		struct xfrm_encap_tmpl *natt;
 
 		x-&gt;encap = kmalloc(sizeof(*x-&gt;encap), GFP_KERNEL);
<span class="p_del">-		if (!x-&gt;encap)</span>
<span class="p_add">+		if (!x-&gt;encap) {</span>
<span class="p_add">+			err = -ENOMEM;</span>
 			goto out;
<span class="p_add">+		}</span>
 
 		natt = x-&gt;encap;
 		n_type = ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1];
<span class="p_chunk">@@ -2755,6 +2764,8 @@</span> <span class="p_context"> static int pfkey_spdflush(struct sock *sk, struct sk_buff *skb, const struct sad</span>
 	int err, err2;
 
 	err = xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, true);
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		xfrm_garbage_collect(net);</span>
 	err2 = unicast_flush_resp(sk, hdr);
 	if (err || err2) {
 		if (err == -ESRCH) /* empty table - old silent behavior */
<span class="p_header">diff --git a/net/l2tp/l2tp_eth.c b/net/l2tp/l2tp_eth.c</span>
<span class="p_header">index 6fd41d7afe1e..cafb667b3c85 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_eth.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_eth.c</span>
<span class="p_chunk">@@ -133,7 +133,7 @@</span> <span class="p_context"> static void l2tp_eth_dev_setup(struct net_device *dev)</span>
 	dev-&gt;priv_flags		&amp;= ~IFF_TX_SKB_SHARING;
 	dev-&gt;features		|= NETIF_F_LLTX;
 	dev-&gt;netdev_ops		= &amp;l2tp_eth_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 }
 
 static void l2tp_eth_dev_recv(struct l2tp_session *session, struct sk_buff *skb, int data_len)
<span class="p_header">diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c</span>
<span class="p_header">index 5bb0c5012819..8f783d527f29 100644</span>
<span class="p_header">--- a/net/mac80211/iface.c</span>
<span class="p_header">+++ b/net/mac80211/iface.c</span>
<span class="p_chunk">@@ -1198,7 +1198,6 @@</span> <span class="p_context"> static const struct net_device_ops ieee80211_monitorif_ops = {</span>
 static void ieee80211_if_free(struct net_device *dev)
 {
 	free_percpu(dev-&gt;tstats);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static void ieee80211_if_setup(struct net_device *dev)
<span class="p_chunk">@@ -1206,7 +1205,8 @@</span> <span class="p_context"> static void ieee80211_if_setup(struct net_device *dev)</span>
 	ether_setup(dev);
 	dev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;
 	dev-&gt;netdev_ops = &amp;ieee80211_dataif_ops;
<span class="p_del">-	dev-&gt;destructor = ieee80211_if_free;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	dev-&gt;priv_destructor = ieee80211_if_free;</span>
 }
 
 static void ieee80211_if_setup_no_queue(struct net_device *dev)
<span class="p_chunk">@@ -1810,6 +1810,7 @@</span> <span class="p_context"> int ieee80211_if_add(struct ieee80211_local *local, const char *name,</span>
 		ret = dev_alloc_name(ndev, ndev-&gt;name);
 		if (ret &lt; 0) {
 			ieee80211_if_free(ndev);
<span class="p_add">+			free_netdev(ndev);</span>
 			return ret;
 		}
 
<span class="p_chunk">@@ -1899,7 +1900,7 @@</span> <span class="p_context"> int ieee80211_if_add(struct ieee80211_local *local, const char *name,</span>
 
 		ret = register_netdevice(ndev);
 		if (ret) {
<span class="p_del">-			ieee80211_if_free(ndev);</span>
<span class="p_add">+			free_netdev(ndev);</span>
 			return ret;
 		}
 	}
<span class="p_header">diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c</span>
<span class="p_header">index 06019dba4b10..bd88a9b80773 100644</span>
<span class="p_header">--- a/net/mac802154/iface.c</span>
<span class="p_header">+++ b/net/mac802154/iface.c</span>
<span class="p_chunk">@@ -526,8 +526,6 @@</span> <span class="p_context"> static void mac802154_wpan_free(struct net_device *dev)</span>
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	mac802154_llsec_destroy(&amp;sdata-&gt;sec);
<span class="p_del">-</span>
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static void ieee802154_if_setup(struct net_device *dev)
<span class="p_chunk">@@ -593,7 +591,8 @@</span> <span class="p_context"> ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,</span>
 					sdata-&gt;dev-&gt;dev_addr);
 
 		sdata-&gt;dev-&gt;header_ops = &amp;mac802154_header_ops;
<span class="p_del">-		sdata-&gt;dev-&gt;destructor = mac802154_wpan_free;</span>
<span class="p_add">+		sdata-&gt;dev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+		sdata-&gt;dev-&gt;priv_destructor = mac802154_wpan_free;</span>
 		sdata-&gt;dev-&gt;netdev_ops = &amp;mac802154_wpan_ops;
 		sdata-&gt;dev-&gt;ml_priv = &amp;mac802154_mlme_wpan;
 		wpan_dev-&gt;promiscuous_mode = false;
<span class="p_chunk">@@ -608,7 +607,7 @@</span> <span class="p_context"> ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,</span>
 
 		break;
 	case NL802154_IFTYPE_MONITOR:
<span class="p_del">-		sdata-&gt;dev-&gt;destructor = free_netdev;</span>
<span class="p_add">+		sdata-&gt;dev-&gt;needs_free_netdev = true;</span>
 		sdata-&gt;dev-&gt;netdev_ops = &amp;mac802154_monitor_ops;
 		wpan_dev-&gt;promiscuous_mode = true;
 		break;
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">index dc7dfd68fafe..8555659d2e07 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_chunk">@@ -45,6 +45,8 @@</span> <span class="p_context"></span>
 #include &lt;net/netfilter/nf_conntrack_zones.h&gt;
 #include &lt;net/netfilter/nf_conntrack_timestamp.h&gt;
 #include &lt;net/netfilter/nf_conntrack_labels.h&gt;
<span class="p_add">+#include &lt;net/netfilter/nf_conntrack_seqadj.h&gt;</span>
<span class="p_add">+#include &lt;net/netfilter/nf_conntrack_synproxy.h&gt;</span>
 #ifdef CONFIG_NF_NAT_NEEDED
 #include &lt;net/netfilter/nf_nat_core.h&gt;
 #include &lt;net/netfilter/nf_nat_l4proto.h&gt;
<span class="p_chunk">@@ -1814,6 +1816,8 @@</span> <span class="p_context"> ctnetlink_create_conntrack(struct net *net,</span>
 	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
 	nf_ct_ecache_ext_add(ct, 0, 0, GFP_ATOMIC);
 	nf_ct_labels_ext_add(ct);
<span class="p_add">+	nfct_seqadj_ext_add(ct);</span>
<span class="p_add">+	nfct_synproxy_ext_add(ct);</span>
 
 	/* we must add conntrack extensions before confirmation. */
 	ct-&gt;status |= IPS_CONFIRMED;
<span class="p_header">diff --git a/net/openvswitch/vport-internal_dev.c b/net/openvswitch/vport-internal_dev.c</span>
<span class="p_header">index 89193a634da4..04a3128adcf0 100644</span>
<span class="p_header">--- a/net/openvswitch/vport-internal_dev.c</span>
<span class="p_header">+++ b/net/openvswitch/vport-internal_dev.c</span>
<span class="p_chunk">@@ -94,7 +94,6 @@</span> <span class="p_context"> static void internal_dev_destructor(struct net_device *dev)</span>
 	struct vport *vport = ovs_internal_dev_get_vport(dev);
 
 	ovs_vport_free(vport);
<span class="p_del">-	free_netdev(dev);</span>
 }
 
 static void
<span class="p_chunk">@@ -156,7 +155,8 @@</span> <span class="p_context"> static void do_setup(struct net_device *netdev)</span>
 	netdev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;
 	netdev-&gt;priv_flags |= IFF_LIVE_ADDR_CHANGE | IFF_OPENVSWITCH |
 			      IFF_PHONY_HEADROOM | IFF_NO_QUEUE;
<span class="p_del">-	netdev-&gt;destructor = internal_dev_destructor;</span>
<span class="p_add">+	netdev-&gt;needs_free_netdev = true;</span>
<span class="p_add">+	netdev-&gt;priv_destructor = internal_dev_destructor;</span>
 	netdev-&gt;ethtool_ops = &amp;internal_dev_ethtool_ops;
 	netdev-&gt;rtnl_link_ops = &amp;internal_dev_link_ops;
 
<span class="p_header">diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c</span>
<span class="p_header">index 21c28b51be94..2c9337946e30 100644</span>
<span class="p_header">--- a/net/phonet/pep-gprs.c</span>
<span class="p_header">+++ b/net/phonet/pep-gprs.c</span>
<span class="p_chunk">@@ -236,7 +236,7 @@</span> <span class="p_context"> static void gprs_setup(struct net_device *dev)</span>
 	dev-&gt;tx_queue_len	= 10;
 
 	dev-&gt;netdev_ops		= &amp;gprs_netdev_ops;
<span class="p_del">-	dev-&gt;destructor		= free_netdev;</span>
<span class="p_add">+	dev-&gt;needs_free_netdev	= true;</span>
 }
 
 /*
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index d9d4c92e06b3..74f761022450 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -4586,13 +4586,13 @@</span> <span class="p_context"> int sctp_for_each_endpoint(int (*cb)(struct sctp_endpoint *, void *),</span>
 
 	for (head = sctp_ep_hashtable; hash &lt; sctp_ep_hashsize;
 	     hash++, head++) {
<span class="p_del">-		read_lock(&amp;head-&gt;lock);</span>
<span class="p_add">+		read_lock_bh(&amp;head-&gt;lock);</span>
 		sctp_for_each_hentry(epb, &amp;head-&gt;chain) {
 			err = cb(sctp_ep(epb), p);
 			if (err)
 				break;
 		}
<span class="p_del">-		read_unlock(&amp;head-&gt;lock);</span>
<span class="p_add">+		read_unlock_bh(&amp;head-&gt;lock);</span>
 	}
 
 	return err;
<span class="p_chunk">@@ -4630,9 +4630,8 @@</span> <span class="p_context"> int sctp_for_each_transport(int (*cb)(struct sctp_transport *, void *),</span>
 	if (err)
 		return err;
 
<span class="p_del">-	sctp_transport_get_idx(net, &amp;hti, pos);</span>
<span class="p_del">-	obj = sctp_transport_get_next(net, &amp;hti);</span>
<span class="p_del">-	for (; obj &amp;&amp; !IS_ERR(obj); obj = sctp_transport_get_next(net, &amp;hti)) {</span>
<span class="p_add">+	obj = sctp_transport_get_idx(net, &amp;hti, pos + 1);</span>
<span class="p_add">+	for (; !IS_ERR_OR_NULL(obj); obj = sctp_transport_get_next(net, &amp;hti)) {</span>
 		struct sctp_transport *transport = obj;
 
 		if (!sctp_transport_hold(transport))
<span class="p_header">diff --git a/net/tipc/msg.c b/net/tipc/msg.c</span>
<span class="p_header">index 312ef7de57d7..ab3087687a32 100644</span>
<span class="p_header">--- a/net/tipc/msg.c</span>
<span class="p_header">+++ b/net/tipc/msg.c</span>
<span class="p_chunk">@@ -508,7 +508,7 @@</span> <span class="p_context"> bool tipc_msg_reverse(u32 own_node,  struct sk_buff **skb, int err)</span>
 	}
 
 	if (skb_cloned(_skb) &amp;&amp;
<span class="p_del">-	    pskb_expand_head(_skb, BUF_HEADROOM, BUF_TAILROOM, GFP_KERNEL))</span>
<span class="p_add">+	    pskb_expand_head(_skb, BUF_HEADROOM, BUF_TAILROOM, GFP_ATOMIC))</span>
 		goto exit;
 
 	/* Now reverse the concerned fields */
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 928691c43408..475e1170597c 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -999,7 +999,8 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	struct path path = { NULL, NULL };
 
 	err = -EINVAL;
<span class="p_del">-	if (sunaddr-&gt;sun_family != AF_UNIX)</span>
<span class="p_add">+	if (addr_len &lt; offsetofend(struct sockaddr_un, sun_family) ||</span>
<span class="p_add">+	    sunaddr-&gt;sun_family != AF_UNIX)</span>
 		goto out;
 
 	if (addr_len == sizeof(short)) {
<span class="p_chunk">@@ -1110,6 +1111,10 @@</span> <span class="p_context"> static int unix_dgram_connect(struct socket *sock, struct sockaddr *addr,</span>
 	unsigned int hash;
 	int err;
 
<span class="p_add">+	err = -EINVAL;</span>
<span class="p_add">+	if (alen &lt; offsetofend(struct sockaddr, sa_family))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (addr-&gt;sa_family != AF_UNSPEC) {
 		err = unix_mkname(sunaddr, alen, &amp;hash);
 		if (err &lt; 0)
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index dfc77b9c5e5a..56fba8f073f5 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -1006,10 +1006,6 @@</span> <span class="p_context"> int xfrm_policy_flush(struct net *net, u8 type, bool task_valid)</span>
 		err = -ESRCH;
 out:
 	spin_unlock_bh(&amp;net-&gt;xfrm.xfrm_policy_lock);
<span class="p_del">-</span>
<span class="p_del">-	if (cnt)</span>
<span class="p_del">-		xfrm_garbage_collect(net);</span>
<span class="p_del">-</span>
 	return err;
 }
 EXPORT_SYMBOL(xfrm_policy_flush);
<span class="p_chunk">@@ -1797,43 +1793,6 @@</span> <span class="p_context"> static struct dst_entry *xfrm_bundle_create(struct xfrm_policy *policy,</span>
 	goto out;
 }
 
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-static int xfrm_dst_alloc_copy(void **target, const void *src, int size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!*target) {</span>
<span class="p_del">-		*target = kmalloc(size, GFP_ATOMIC);</span>
<span class="p_del">-		if (!*target)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy(*target, src, size);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static int xfrm_dst_update_parent(struct dst_entry *dst,</span>
<span class="p_del">-				  const struct xfrm_selector *sel)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	struct xfrm_dst *xdst = (struct xfrm_dst *)dst;</span>
<span class="p_del">-	return xfrm_dst_alloc_copy((void **)&amp;(xdst-&gt;partner),</span>
<span class="p_del">-				   sel, sizeof(*sel));</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int xfrm_dst_update_origin(struct dst_entry *dst,</span>
<span class="p_del">-				  const struct flowi *fl)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	struct xfrm_dst *xdst = (struct xfrm_dst *)dst;</span>
<span class="p_del">-	return xfrm_dst_alloc_copy((void **)&amp;(xdst-&gt;origin), fl, sizeof(*fl));</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int xfrm_expand_policies(const struct flowi *fl, u16 family,
 				struct xfrm_policy **pols,
 				int *num_pols, int *num_xfrms)
<span class="p_chunk">@@ -1905,16 +1864,6 @@</span> <span class="p_context"> xfrm_resolve_and_create_bundle(struct xfrm_policy **pols, int num_pols,</span>
 
 	xdst = (struct xfrm_dst *)dst;
 	xdst-&gt;num_xfrms = err;
<span class="p_del">-	if (num_pols &gt; 1)</span>
<span class="p_del">-		err = xfrm_dst_update_parent(dst, &amp;pols[1]-&gt;selector);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		err = xfrm_dst_update_origin(dst, fl);</span>
<span class="p_del">-	if (unlikely(err)) {</span>
<span class="p_del">-		dst_free(dst);</span>
<span class="p_del">-		XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTBUNDLECHECKERROR);</span>
<span class="p_del">-		return ERR_PTR(err);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	xdst-&gt;num_pols = num_pols;
 	memcpy(xdst-&gt;pols, pols, sizeof(struct xfrm_policy *) * num_pols);
 	xdst-&gt;policy_genid = atomic_read(&amp;pols[0]-&gt;genid);
<span class="p_header">diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c</span>
<span class="p_header">index 40a8aa39220d..66698552fbd6 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_user.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_user.c</span>
<span class="p_chunk">@@ -1999,6 +1999,7 @@</span> <span class="p_context"> static int xfrm_flush_policy(struct sk_buff *skb, struct nlmsghdr *nlh,</span>
 			return 0;
 		return err;
 	}
<span class="p_add">+	xfrm_garbage_collect(net);</span>
 
 	c.data.type = type;
 	c.event = nlh-&gt;nlmsg_type;
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h</span>
<span class="p_header">index f17f25245e52..a206320b8eea 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.h</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.h</span>
<span class="p_chunk">@@ -294,6 +294,8 @@</span> <span class="p_context"> struct hda_codec {</span>
 
 #define list_for_each_codec(c, bus) \
 	list_for_each_entry(c, &amp;(bus)-&gt;core.codec_list, core.list)
<span class="p_add">+#define list_for_each_codec_safe(c, n, bus)				\</span>
<span class="p_add">+	list_for_each_entry_safe(c, n, &amp;(bus)-&gt;core.codec_list, core.list)</span>
 
 /* snd_hda_codec_read/write optional flags */
 #define HDA_RW_NO_RESPONSE_FALLBACK	(1 &lt;&lt; 0)
<span class="p_header">diff --git a/sound/pci/hda/hda_controller.c b/sound/pci/hda/hda_controller.c</span>
<span class="p_header">index 3715a5725613..1c60beb5b70a 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_controller.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_controller.c</span>
<span class="p_chunk">@@ -1337,8 +1337,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(azx_probe_codecs);</span>
 /* configure each codec instance */
 int azx_codec_configure(struct azx *chip)
 {
<span class="p_del">-	struct hda_codec *codec;</span>
<span class="p_del">-	list_for_each_codec(codec, &amp;chip-&gt;bus) {</span>
<span class="p_add">+	struct hda_codec *codec, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* use _safe version here since snd_hda_codec_configure() deregisters</span>
<span class="p_add">+	 * the device upon error and deletes itself from the bus list.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	list_for_each_codec_safe(codec, next, &amp;chip-&gt;bus) {</span>
 		snd_hda_codec_configure(codec);
 	}
 	return 0;
<span class="p_header">diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c</span>
<span class="p_header">index e7c8f4f076d5..b0bd29003b5d 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_generic.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_generic.c</span>
<span class="p_chunk">@@ -3169,6 +3169,7 @@</span> <span class="p_context"> static int check_dyn_adc_switch(struct hda_codec *codec)</span>
 						spec-&gt;input_paths[i][nums]);
 					spec-&gt;input_paths[i][nums] =
 						spec-&gt;input_paths[i][n];
<span class="p_add">+					spec-&gt;input_paths[i][n] = 0;</span>
 				}
 			}
 			nums++;
<span class="p_header">diff --git a/tools/arch/x86/lib/memcpy_64.S b/tools/arch/x86/lib/memcpy_64.S</span>
<span class="p_header">index 49e6ebac7e73..98dcc112b363 100644</span>
<span class="p_header">--- a/tools/arch/x86/lib/memcpy_64.S</span>
<span class="p_header">+++ b/tools/arch/x86/lib/memcpy_64.S</span>
<span class="p_chunk">@@ -286,7 +286,7 @@</span> <span class="p_context"> ENDPROC(memcpy_mcsafe_unrolled)</span>
 	_ASM_EXTABLE_FAULT(.L_copy_leading_bytes, .L_memcpy_mcsafe_fail)
 	_ASM_EXTABLE_FAULT(.L_cache_w0, .L_memcpy_mcsafe_fail)
 	_ASM_EXTABLE_FAULT(.L_cache_w1, .L_memcpy_mcsafe_fail)
<span class="p_del">-	_ASM_EXTABLE_FAULT(.L_cache_w3, .L_memcpy_mcsafe_fail)</span>
<span class="p_add">+	_ASM_EXTABLE_FAULT(.L_cache_w2, .L_memcpy_mcsafe_fail)</span>
 	_ASM_EXTABLE_FAULT(.L_cache_w3, .L_memcpy_mcsafe_fail)
 	_ASM_EXTABLE_FAULT(.L_cache_w4, .L_memcpy_mcsafe_fail)
 	_ASM_EXTABLE_FAULT(.L_cache_w5, .L_memcpy_mcsafe_fail)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



