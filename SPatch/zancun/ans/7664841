
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4,16/16] mm: add knob to tune lazyfreeing - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4,16/16] mm: add knob to tune lazyfreeing</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=36811">Minchan Kim</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 20, 2015, 8:02 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1448006568-16031-17-git-send-email-minchan@kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7664841/mbox/"
   >mbox</a>
|
   <a href="/patch/7664841/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7664841/">/patch/7664841/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 2A42EBF90C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 Nov 2015 08:03:25 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 4262D20498
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 Nov 2015 08:03:23 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 17FBE2046F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 Nov 2015 08:03:21 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1162075AbbKTIDJ (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 20 Nov 2015 03:03:09 -0500
Received: from LGEAMRELO11.lge.com ([156.147.23.51]:45374 &quot;EHLO
	lgeamrelo11.lge.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1161725AbbKTIDA (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 20 Nov 2015 03:03:00 -0500
Received: from unknown (HELO lgemrelse6q.lge.com) (156.147.1.121)
	by 156.147.23.51 with ESMTP; 20 Nov 2015 17:02:58 +0900
X-Original-SENDERIP: 156.147.1.121
X-Original-MAILFROM: minchan@kernel.org
Received: from unknown (HELO localhost.localdomain) (10.177.223.161)
	by 156.147.1.121 with ESMTP; 20 Nov 2015 17:02:58 +0900
X-Original-SENDERIP: 10.177.223.161
X-Original-MAILFROM: minchan@kernel.org
From: Minchan Kim &lt;minchan@kernel.org&gt;
To: Andrew Morton &lt;akpm@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, linux-mm@kvack.org,
	Michael Kerrisk &lt;mtk.manpages@gmail.com&gt;,
	linux-api@vger.kernel.org, Hugh Dickins &lt;hughd@google.com&gt;,
	Johannes Weiner &lt;hannes@cmpxchg.org&gt;,
	Rik van Riel &lt;riel@redhat.com&gt;, Mel Gorman &lt;mgorman@suse.de&gt;,
	KOSAKI Motohiro &lt;kosaki.motohiro@jp.fujitsu.com&gt;,
	Jason Evans &lt;je@fb.com&gt;, Daniel Micay &lt;danielmicay@gmail.com&gt;,
	&quot;Kirill A. Shutemov&quot; &lt;kirill@shutemov.name&gt;,
	Shaohua Li &lt;shli@kernel.org&gt;, Michal Hocko &lt;mhocko@suse.cz&gt;,
	yalin.wang2010@gmail.com, Andy Lutomirski &lt;luto@amacapital.net&gt;,
	Minchan Kim &lt;minchan@kernel.org&gt;
Subject: [PATCH v4 16/16] mm: add knob to tune lazyfreeing
Date: Fri, 20 Nov 2015 17:02:48 +0900
Message-Id: &lt;1448006568-16031-17-git-send-email-minchan@kernel.org&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1448006568-16031-1-git-send-email-minchan@kernel.org&gt;
References: &lt;1448006568-16031-1-git-send-email-minchan@kernel.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.5 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=36811">Minchan Kim</a> - Nov. 20, 2015, 8:02 a.m.</div>
<pre class="content">
MADV_FREEed page&#39;s hotness is very arguble.
Someone think it&#39;s hot while others are it&#39;s cold.

Quote from Shaohua
&quot;
My main concern is the policy how we should treat the FREE pages. Moving it to
inactive lru is definitionly a good start, I&#39;m wondering if it&#39;s enough. The
MADV_FREE increases memory pressure and cause unnecessary reclaim because of
the lazy memory free. While MADV_FREE is intended to be a better replacement of
MADV_DONTNEED, MADV_DONTNEED doesn&#39;t have the memory pressure issue as it free
memory immediately. So I hope the MADV_FREE doesn&#39;t have impact on memory
pressure too. I&#39;m thinking of adding an extra lru list and wartermark for this
to make sure FREE pages can be freed before system wide page reclaim. As you
said, this is arguable, but I hope we can discuss about this issue more.
&quot;

Quote from me
&quot;
It seems the divergence comes from MADV_FREE is *replacement* of MADV_DONTNEED.
But I don&#39;t think so. If we could discard MADV_FREEed page *anytime*, I agree
but it&#39;s not true because the page would be dirty state when VM want to reclaim.

I&#39;m also against with your&#39;s suggestion which let&#39;s discard FREEed page before
system wide page reclaim because system would have lots of clean cold page
caches or anonymous pages. In such case, reclaiming of them would be better.
Yeb, it&#39;s really workload-dependent so we might need some heuristic which is
normally what we want to avoid.

Having said that, I agree with you we could do better than the deactivation
and frankly speaking, I&#39;m thinking of another LRU list(e.g. tentatively named
&quot;ezreclaim LRU list&quot;). What I have in mind is to age (anon|file|ez)
fairly. IOW, I want to percolate ez-LRU list reclaiming into get_scan_count.
When the MADV_FREE is called, we could move hinted pages from anon-LRU to
ez-LRU and then If VM find to not be able to discard a page in ez-LRU,
it could promote it to acive-anon-LRU which would be very natural aging
concept because it mean someone touches the page recenlty.
With that, I don&#39;t want to bias one side and don&#39;t want to add some knob for
tuning the heuristic but let&#39;s rely on common fair aging scheme of VM.
&quot;

Quote from Johannes
&quot;
thread 1:
Even if we&#39;re wrong about the aging of those MADV_FREE pages, their
contents are invalidated; they can be discarded freely, and restoring
them is a mere GFP_ZERO allocation. All other anonymous pages have to
be written to disk, and potentially be read back.

[ Arguably, MADV_FREE pages should even be reclaimed before inactive
  page cache. It&#39;s the same cost to discard both types of pages, but
  restoring page cache involves IO. ]

It probably makes sense to stop thinking about them as anonymous pages
entirely at this point when it comes to aging. They&#39;re really not. The
LRU lists are split to differentiate access patterns and cost of page
stealing (and restoring). From that angle, MADV_FREE pages really have
nothing in common with in-use anonymous pages, and so they shouldn&#39;t
be on the same LRU list.

thread:2
What about them is hot? They contain garbage, you have to write to
them before you can use them. Granted, you might have to refetch
cachelines if you don&#39;t do cacheline-aligned populating writes, but
you can do a lot of them before it&#39;s more expensive than doing IO.

&quot;

Quote from Daniel
&quot;
thread:1
Keep in mind that this is memory the kernel wouldn&#39;t be getting back at
all if the allocator wasn&#39;t going out of the way to purge it, and they
aren&#39;t going to go out of their way to purge it if it means the kernel
is going to steal the pages when there isn&#39;t actually memory pressure.

An allocator would be using MADV_DONTNEED if it didn&#39;t expect that the
pages were going to be used against shortly. MADV_FREE indicates that it
has time to inform the kernel that they&#39;re unused but they could still
be very hot.

thread:2
It&#39;s hot because applications churn through memory via the allocator.

Drop the pages and the application is now churning through page faults
and zeroing rather than simply reusing memory. It&#39;s not something that
may happen, it *will* happen. A page in the page cache *may* be reused,
but often won&#39;t be, especially when the I/O patterns don&#39;t line up well
with the way it works.

The whole point of the feature is not requiring the allocator to have
elaborate mechanisms for aging pages and throttling purging. That ends
up resulting in lots of memory held by userspace where the kernel can&#39;t
reclaim it under memory pressure. If it&#39;s dropped before page cache, it
isn&#39;t going to be able to replace any of that logic in allocators.

The page cache is speculative. Page caching by allocators is not really
speculative. Using MADV_FREE on the pages at all is speculative. The
memory is probably going to be reused fairly soon (unless the process
exits, and then it doesn&#39;t matter), but purging will end up reducing
memory usage for the portions that aren&#39;t.

It would be a different story for a full unpinning/pinning feature since
that would have other use cases (speculative caches), but this is really
only useful in allocators.
&quot;
You could read all thread from https://lkml.org/lkml/2015/11/4/51

Yeah, with arguble issue and there is no one decision, I think it
means we should provide the knob &quot;lazyfreeness&quot;(I hope someone
give better naming).

It&#39;s similar to swapppiness so higher values will discard MADV_FREE
pages agreessively.
In this implementation, lazyfreeness starts from 100 which is max
of swappiness(ie, if you see 40 of /proc/sys/vm/lazyfreeness,
it means 100 + 40). Therefore, lazyfree LRU list always has more
reclaiming pressure than anonymous LRU but same with filecache
pressure when we consider default values(ie, 60 swappiness,
40 lazyfreeness). If user want to reclaim lazyfree LRU first to
prevent other LRU reclaiming, he could set lazyfreeness to above 80
which is double of default lazyfreeness.

There is one exception case. If system has low free memory and
file cache, it start to discard MADV_FREEed pages unconditionally
even though user set lazyfreeness to 0. It&#39;s same logic with
swappiness to prevent thrashing.

Cc: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
Cc: Rik van Riel &lt;riel@redhat.com&gt;
Cc: Mel Gorman &lt;mgorman@suse.de&gt;
<span class="signed-off-by">Signed-off-by: Minchan Kim &lt;minchan@kernel.org&gt;</span>
---
 Documentation/sysctl/vm.txt |  13 +++++
 drivers/base/node.c         |   4 +-
 fs/proc/meminfo.c           |   4 +-
 include/linux/memcontrol.h  |   1 +
 include/linux/mmzone.h      |  19 +++++--
 include/linux/swap.h        |  15 +++++
 kernel/sysctl.c             |   9 +++
 mm/memcontrol.c             |  32 ++++++++++-
 mm/vmscan.c                 | 131 +++++++++++++++++++++++++-------------------
 mm/vmstat.c                 |   2 +-
 10 files changed, 162 insertions(+), 68 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/sysctl/vm.txt b/Documentation/sysctl/vm.txt</span>
<span class="p_header">index a4482fceacec..e3bcf115cf03 100644</span>
<span class="p_header">--- a/Documentation/sysctl/vm.txt</span>
<span class="p_header">+++ b/Documentation/sysctl/vm.txt</span>
<span class="p_chunk">@@ -56,6 +56,7 @@</span> <span class="p_context"> files can be found in mm/swap.c.</span>
 - percpu_pagelist_fraction
 - stat_interval
 - swappiness
<span class="p_add">+- lazyfreeness</span>
 - user_reserve_kbytes
 - vfs_cache_pressure
 - zone_reclaim_mode
<span class="p_chunk">@@ -737,6 +738,18 @@</span> <span class="p_context"> The default value is 60.</span>
 
 ==============================================================
 
<span class="p_add">+lazyfreeness</span>
<span class="p_add">+</span>
<span class="p_add">+This control is used to define how aggressive the kernel will discard</span>
<span class="p_add">+MADV_FREE hinted pages.  Higher values will increase agressiveness,</span>
<span class="p_add">+lower values decrease the amount of discarding.  A value of 0 instructs</span>
<span class="p_add">+the kernel not to initiate discarding until the amount of free and</span>
<span class="p_add">+file-backed pages is less than the high water mark in a zone.</span>
<span class="p_add">+</span>
<span class="p_add">+The default value is 40.</span>
<span class="p_add">+</span>
<span class="p_add">+==============================================================</span>
<span class="p_add">+</span>
 - user_reserve_kbytes
 
 When overcommit_memory is set to 2, &quot;never overcommit&quot; mode, reserve
<span class="p_header">diff --git a/drivers/base/node.c b/drivers/base/node.c</span>
<span class="p_header">index f7a1f2107b43..3b0bf1b78b2e 100644</span>
<span class="p_header">--- a/drivers/base/node.c</span>
<span class="p_header">+++ b/drivers/base/node.c</span>
<span class="p_chunk">@@ -69,8 +69,8 @@</span> <span class="p_context"> static ssize_t node_read_meminfo(struct device *dev,</span>
 		       &quot;Node %d Inactive(anon): %8lu kB\n&quot;
 		       &quot;Node %d Active(file):   %8lu kB\n&quot;
 		       &quot;Node %d Inactive(file): %8lu kB\n&quot;
<span class="p_del">-		       &quot;Node %d Unevictable:    %8lu kB\n&quot;</span>
 		       &quot;Node %d LazyFree:	%8lu kB\n&quot;
<span class="p_add">+		       &quot;Node %d Unevictable:    %8lu kB\n&quot;</span>
 		       &quot;Node %d Mlocked:        %8lu kB\n&quot;,
 		       nid, K(i.totalram),
 		       nid, K(i.freeram),
<span class="p_chunk">@@ -83,8 +83,8 @@</span> <span class="p_context"> static ssize_t node_read_meminfo(struct device *dev,</span>
 		       nid, K(node_page_state(nid, NR_INACTIVE_ANON)),
 		       nid, K(node_page_state(nid, NR_ACTIVE_FILE)),
 		       nid, K(node_page_state(nid, NR_INACTIVE_FILE)),
<span class="p_del">-		       nid, K(node_page_state(nid, NR_UNEVICTABLE)),</span>
 		       nid, K(node_page_state(nid, NR_LZFREE)),
<span class="p_add">+		       nid, K(node_page_state(nid, NR_UNEVICTABLE)),</span>
 		       nid, K(node_page_state(nid, NR_MLOCK)));
 
 #ifdef CONFIG_HIGHMEM
<span class="p_header">diff --git a/fs/proc/meminfo.c b/fs/proc/meminfo.c</span>
<span class="p_header">index 3444f7c4e0b6..f47e6a5aa2e5 100644</span>
<span class="p_header">--- a/fs/proc/meminfo.c</span>
<span class="p_header">+++ b/fs/proc/meminfo.c</span>
<span class="p_chunk">@@ -101,8 +101,8 @@</span> <span class="p_context"> static int meminfo_proc_show(struct seq_file *m, void *v)</span>
 		&quot;Inactive(anon): %8lu kB\n&quot;
 		&quot;Active(file):   %8lu kB\n&quot;
 		&quot;Inactive(file): %8lu kB\n&quot;
<span class="p_del">-		&quot;Unevictable:    %8lu kB\n&quot;</span>
 		&quot;LazyFree:	 %8lu kB\n&quot;
<span class="p_add">+		&quot;Unevictable:    %8lu kB\n&quot;</span>
 		&quot;Mlocked:        %8lu kB\n&quot;
 #ifdef CONFIG_HIGHMEM
 		&quot;HighTotal:      %8lu kB\n&quot;
<span class="p_chunk">@@ -159,8 +159,8 @@</span> <span class="p_context"> static int meminfo_proc_show(struct seq_file *m, void *v)</span>
 		K(pages[LRU_INACTIVE_ANON]),
 		K(pages[LRU_ACTIVE_FILE]),
 		K(pages[LRU_INACTIVE_FILE]),
<span class="p_del">-		K(pages[LRU_UNEVICTABLE]),</span>
 		K(pages[LRU_LZFREE]),
<span class="p_add">+		K(pages[LRU_UNEVICTABLE]),</span>
 		K(global_page_state(NR_MLOCK)),
 #ifdef CONFIG_HIGHMEM
 		K(i.totalhigh),
<span class="p_header">diff --git a/include/linux/memcontrol.h b/include/linux/memcontrol.h</span>
<span class="p_header">index 3e3318ddfc0e..5522ff733506 100644</span>
<span class="p_header">--- a/include/linux/memcontrol.h</span>
<span class="p_header">+++ b/include/linux/memcontrol.h</span>
<span class="p_chunk">@@ -210,6 +210,7 @@</span> <span class="p_context"> struct mem_cgroup {</span>
 	int		under_oom;
 
 	int	swappiness;
<span class="p_add">+	int	lzfreeness;</span>
 	/* OOM-Killer disable */
 	int		oom_kill_disable;
 
<span class="p_header">diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h</span>
<span class="p_header">index 1aaa436da0d5..210184b2dd18 100644</span>
<span class="p_header">--- a/include/linux/mmzone.h</span>
<span class="p_header">+++ b/include/linux/mmzone.h</span>
<span class="p_chunk">@@ -120,8 +120,8 @@</span> <span class="p_context"> enum zone_stat_item {</span>
 	NR_ACTIVE_ANON,		/*  &quot;     &quot;     &quot;   &quot;       &quot;         */
 	NR_INACTIVE_FILE,	/*  &quot;     &quot;     &quot;   &quot;       &quot;         */
 	NR_ACTIVE_FILE,		/*  &quot;     &quot;     &quot;   &quot;       &quot;         */
<span class="p_del">-	NR_UNEVICTABLE,		/*  &quot;     &quot;     &quot;   &quot;       &quot;         */</span>
 	NR_LZFREE,		/*  &quot;     &quot;     &quot;   &quot;       &quot;         */
<span class="p_add">+	NR_UNEVICTABLE,		/*  &quot;     &quot;     &quot;   &quot;       &quot;         */</span>
 	NR_MLOCK,		/* mlock()ed pages found and moved off LRU */
 	NR_ANON_PAGES,	/* Mapped anonymous pages */
 	NR_FILE_MAPPED,	/* pagecache pages mapped into pagetables.
<span class="p_chunk">@@ -179,20 +179,29 @@</span> <span class="p_context"> enum lru_list {</span>
 	LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,
 	LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,
 	LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,
<span class="p_del">-	LRU_UNEVICTABLE,</span>
 	LRU_LZFREE,
<span class="p_add">+	LRU_UNEVICTABLE,</span>
 	NR_LRU_LISTS
 };
 
 #define for_each_lru(lru) for (lru = 0; lru &lt; NR_LRU_LISTS; lru++)
<span class="p_add">+#define for_each_evictable_lru(lru) for (lru = 0; lru &lt;= LRU_LZFREE; lru++)</span>
 
<span class="p_del">-#define for_each_evictable_lru(lru) for (lru = 0; lru &lt;= LRU_ACTIVE_FILE; lru++)</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int is_file_lru(enum lru_list lru)</span>
<span class="p_add">+static inline bool is_file_lru(enum lru_list lru)</span>
 {
 	return (lru == LRU_INACTIVE_FILE || lru == LRU_ACTIVE_FILE);
 }
 
<span class="p_add">+static inline bool is_anon_lru(enum lru_list lru)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (lru == LRU_INACTIVE_ANON || lru == LRU_ACTIVE_ANON);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool is_lazyfree_lru(enum lru_list lru)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (lru == LRU_LZFREE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int is_active_lru(enum lru_list lru)
 {
 	return (lru == LRU_ACTIVE_ANON || lru == LRU_ACTIVE_FILE);
<span class="p_header">diff --git a/include/linux/swap.h b/include/linux/swap.h</span>
<span class="p_header">index c484339b46b6..252b478a2579 100644</span>
<span class="p_header">--- a/include/linux/swap.h</span>
<span class="p_header">+++ b/include/linux/swap.h</span>
<span class="p_chunk">@@ -331,6 +331,7 @@</span> <span class="p_context"> extern unsigned long mem_cgroup_shrink_node_zone(struct mem_cgroup *mem,</span>
 						unsigned long *nr_scanned);
 extern unsigned long shrink_all_memory(unsigned long nr_pages);
 extern int vm_swappiness;
<span class="p_add">+extern int vm_lazyfreeness;</span>
 extern int remove_mapping(struct address_space *mapping, struct page *page);
 extern unsigned long vm_total_pages;
 
<span class="p_chunk">@@ -362,11 +363,25 @@</span> <span class="p_context"> static inline int mem_cgroup_swappiness(struct mem_cgroup *memcg)</span>
 	return memcg-&gt;swappiness;
 }
 
<span class="p_add">+static inline int mem_cgroup_lzfreeness(struct mem_cgroup *memcg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* root ? */</span>
<span class="p_add">+	if (mem_cgroup_disabled() || !memcg-&gt;css.parent)</span>
<span class="p_add">+		return vm_lazyfreeness;</span>
<span class="p_add">+</span>
<span class="p_add">+	return memcg-&gt;lzfreeness;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #else
 static inline int mem_cgroup_swappiness(struct mem_cgroup *mem)
 {
 	return vm_swappiness;
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int mem_cgroup_lzfreeness(struct mem_cgroup *mem)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return vm_lazyfreeness;</span>
<span class="p_add">+}</span>
 #endif
 #ifdef CONFIG_MEMCG_SWAP
 extern void mem_cgroup_swapout(struct page *page, swp_entry_t entry);
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index e69201d8094e..2496b10c08e9 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -1268,6 +1268,15 @@</span> <span class="p_context"> static struct ctl_table vm_table[] = {</span>
 		.extra1		= &amp;zero,
 		.extra2		= &amp;one_hundred,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.procname	= &quot;lazyfreeness&quot;,</span>
<span class="p_add">+		.data		= &amp;vm_lazyfreeness,</span>
<span class="p_add">+		.maxlen		= sizeof(vm_lazyfreeness),</span>
<span class="p_add">+		.mode		= 0644,</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;zero,</span>
<span class="p_add">+		.extra2		= &amp;one_hundred,</span>
<span class="p_add">+	},</span>
 #ifdef CONFIG_HUGETLB_PAGE
 	{
 		.procname	= &quot;nr_hugepages&quot;,
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 1dc599ce1bcb..5bdbe2a20dc0 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -108,8 +108,8 @@</span> <span class="p_context"> static const char * const mem_cgroup_lru_names[] = {</span>
 	&quot;active_anon&quot;,
 	&quot;inactive_file&quot;,
 	&quot;active_file&quot;,
<span class="p_del">-	&quot;unevictable&quot;,</span>
 	&quot;lazyfree&quot;,
<span class="p_add">+	&quot;unevictable&quot;,</span>
 };
 
 #define THRESHOLDS_EVENTS_TARGET 128
<span class="p_chunk">@@ -3288,6 +3288,30 @@</span> <span class="p_context"> static int mem_cgroup_swappiness_write(struct cgroup_subsys_state *css,</span>
 	return 0;
 }
 
<span class="p_add">+static u64 mem_cgroup_lzfreeness_read(struct cgroup_subsys_state *css,</span>
<span class="p_add">+				      struct cftype *cft)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mem_cgroup *memcg = mem_cgroup_from_css(css);</span>
<span class="p_add">+</span>
<span class="p_add">+	return mem_cgroup_lzfreeness(memcg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mem_cgroup_lzfreeness_write(struct cgroup_subsys_state *css,</span>
<span class="p_add">+				       struct cftype *cft, u64 val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mem_cgroup *memcg = mem_cgroup_from_css(css);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (val &gt; 100)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (css-&gt;parent)</span>
<span class="p_add">+		memcg-&gt;lzfreeness = val;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		vm_lazyfreeness = val;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __mem_cgroup_threshold(struct mem_cgroup *memcg, bool swap)
 {
 	struct mem_cgroup_threshold_ary *t;
<span class="p_chunk">@@ -4085,6 +4109,11 @@</span> <span class="p_context"> static struct cftype mem_cgroup_legacy_files[] = {</span>
 		.write_u64 = mem_cgroup_swappiness_write,
 	},
 	{
<span class="p_add">+		.name = &quot;lazyfreeness&quot;,</span>
<span class="p_add">+		.read_u64 = mem_cgroup_lzfreeness_read,</span>
<span class="p_add">+		.write_u64 = mem_cgroup_lzfreeness_write,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		.name = &quot;move_charge_at_immigrate&quot;,
 		.read_u64 = mem_cgroup_move_charge_read,
 		.write_u64 = mem_cgroup_move_charge_write,
<span class="p_chunk">@@ -4305,6 +4334,7 @@</span> <span class="p_context"> mem_cgroup_css_online(struct cgroup_subsys_state *css)</span>
 	memcg-&gt;use_hierarchy = parent-&gt;use_hierarchy;
 	memcg-&gt;oom_kill_disable = parent-&gt;oom_kill_disable;
 	memcg-&gt;swappiness = mem_cgroup_swappiness(parent);
<span class="p_add">+	memcg-&gt;lzfreeness = mem_cgroup_lzfreeness(parent);</span>
 
 	if (parent-&gt;use_hierarchy) {
 		page_counter_init(&amp;memcg-&gt;memory, &amp;parent-&gt;memory);
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index d9dfd034b963..325b49cedee8 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -141,6 +141,10 @@</span> <span class="p_context"> struct scan_control {</span>
  */
 int vm_swappiness = 60;
 /*
<span class="p_add">+ * From 0 .. 100.  Higher means more lazy freeing.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int vm_lazyfreeness = 40;</span>
<span class="p_add">+/*</span>
  * The total number of pages which are beyond the high watermark within all
  * zones.
  */
<span class="p_chunk">@@ -1989,10 +1993,11 @@</span> <span class="p_context"> static unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,</span>
 }
 
 enum scan_balance {
<span class="p_del">-	SCAN_EQUAL,</span>
<span class="p_del">-	SCAN_FRACT,</span>
<span class="p_del">-	SCAN_ANON,</span>
<span class="p_del">-	SCAN_FILE,</span>
<span class="p_add">+	SCAN_EQUAL = (1 &lt;&lt; 0),</span>
<span class="p_add">+	SCAN_FRACT = (1 &lt;&lt; 1),</span>
<span class="p_add">+	SCAN_ANON = (1 &lt;&lt; 2),</span>
<span class="p_add">+	SCAN_FILE = (1 &lt;&lt; 3),</span>
<span class="p_add">+	SCAN_LZFREE = (1 &lt;&lt; 4),</span>
 };
 
 /*
<span class="p_chunk">@@ -2003,20 +2008,21 @@</span> <span class="p_context"> enum scan_balance {</span>
  *
  * nr[0] = anon inactive pages to scan; nr[1] = anon active pages to scan
  * nr[2] = file inactive pages to scan; nr[3] = file active pages to scan
<span class="p_add">+ * nr[4] = lazy free pages to scan;</span>
  */
 static void get_scan_count(struct lruvec *lruvec, int swappiness,
<span class="p_del">-			   struct scan_control *sc, unsigned long *nr,</span>
<span class="p_del">-			   unsigned long *lru_pages)</span>
<span class="p_add">+			int lzfreeness, struct scan_control *sc,</span>
<span class="p_add">+			unsigned long *nr, unsigned long *lru_pages)</span>
 {
 	struct zone_reclaim_stat *reclaim_stat = &amp;lruvec-&gt;reclaim_stat;
<span class="p_del">-	u64 fraction[2];</span>
<span class="p_add">+	u64 fraction[3];</span>
 	u64 denominator = 0;	/* gcc */
 	struct zone *zone = lruvec_zone(lruvec);
<span class="p_del">-	unsigned long anon_prio, file_prio;</span>
<span class="p_del">-	enum scan_balance scan_balance;</span>
<span class="p_del">-	unsigned long anon, file;</span>
<span class="p_add">+	unsigned long anon_prio, file_prio, lzfree_prio;</span>
<span class="p_add">+	enum scan_balance scan_balance = 0;</span>
<span class="p_add">+	unsigned long anon, file, lzfree;</span>
 	bool force_scan = false;
<span class="p_del">-	unsigned long ap, fp;</span>
<span class="p_add">+	unsigned long ap, fp, lp;</span>
 	enum lru_list lru;
 	bool some_scanned;
 	int pass;
<span class="p_chunk">@@ -2040,9 +2046,19 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, int swappiness,</span>
 	if (!global_reclaim(sc))
 		force_scan = true;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we have lazyfree pages and lzfreeness is enough high,</span>
<span class="p_add">+	 * scan only lazyfree LRU to prevent to reclaim other pages</span>
<span class="p_add">+	 * until lazyfree LRU list is empty.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (get_lru_size(lruvec, LRU_LZFREE) &amp;&amp; lzfreeness &gt;= 80) {</span>
<span class="p_add">+		scan_balance = SCAN_LZFREE;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* If we have no swap space, do not bother scanning anon pages. */
 	if (!sc-&gt;may_swap || (get_nr_swap_pages() &lt;= 0)) {
<span class="p_del">-		scan_balance = SCAN_FILE;</span>
<span class="p_add">+		scan_balance = SCAN_FILE|SCAN_LZFREE;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -2054,7 +2070,7 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, int swappiness,</span>
 	 * too expensive.
 	 */
 	if (!global_reclaim(sc) &amp;&amp; !swappiness) {
<span class="p_del">-		scan_balance = SCAN_FILE;</span>
<span class="p_add">+		scan_balance = SCAN_FILE|SCAN_LZFREE;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -2086,7 +2102,7 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, int swappiness,</span>
 			   zone_page_state(zone, NR_INACTIVE_FILE);
 
 		if (unlikely(zonefile + zonefree &lt;= high_wmark_pages(zone))) {
<span class="p_del">-			scan_balance = SCAN_ANON;</span>
<span class="p_add">+			scan_balance = SCAN_ANON|SCAN_LZFREE;</span>
 			goto out;
 		}
 	}
<span class="p_chunk">@@ -2096,7 +2112,7 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, int swappiness,</span>
 	 * anything from the anonymous working set right now.
 	 */
 	if (!inactive_file_is_low(lruvec)) {
<span class="p_del">-		scan_balance = SCAN_FILE;</span>
<span class="p_add">+		scan_balance = SCAN_FILE|SCAN_LZFREE;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -2108,6 +2124,7 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, int swappiness,</span>
 	 */
 	anon_prio = swappiness;
 	file_prio = 200 - anon_prio;
<span class="p_add">+	lzfree_prio = 100 + lzfreeness;</span>
 
 	/*
 	 * OK, so we have swap space and a fair amount of page cache
<span class="p_chunk">@@ -2125,6 +2142,7 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, int swappiness,</span>
 		get_lru_size(lruvec, LRU_INACTIVE_ANON);
 	file  = get_lru_size(lruvec, LRU_ACTIVE_FILE) +
 		get_lru_size(lruvec, LRU_INACTIVE_FILE);
<span class="p_add">+	lzfree = get_lru_size(lruvec, LRU_LZFREE);</span>
 
 	spin_lock_irq(&amp;zone-&gt;lru_lock);
 	if (unlikely(reclaim_stat-&gt;recent_scanned[0] &gt; anon / 4)) {
<span class="p_chunk">@@ -2137,6 +2155,11 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, int swappiness,</span>
 		reclaim_stat-&gt;recent_rotated[1] /= 2;
 	}
 
<span class="p_add">+	if (unlikely(reclaim_stat-&gt;recent_scanned[2] &gt; lzfree / 4)) {</span>
<span class="p_add">+		reclaim_stat-&gt;recent_scanned[2] /= 2;</span>
<span class="p_add">+		reclaim_stat-&gt;recent_rotated[2] /= 2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * The amount of pressure on anon vs file pages is inversely
 	 * proportional to the fraction of recently scanned pages on
<span class="p_chunk">@@ -2147,13 +2170,18 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, int swappiness,</span>
 
 	fp = file_prio * (reclaim_stat-&gt;recent_scanned[1] + 1);
 	fp /= reclaim_stat-&gt;recent_rotated[1] + 1;
<span class="p_add">+</span>
<span class="p_add">+	lp = lzfree_prio * (reclaim_stat-&gt;recent_scanned[2] + 1);</span>
<span class="p_add">+	lp /= reclaim_stat-&gt;recent_rotated[2] + 1;</span>
 	spin_unlock_irq(&amp;zone-&gt;lru_lock);
 
 	fraction[0] = ap;
 	fraction[1] = fp;
<span class="p_del">-	denominator = ap + fp + 1;</span>
<span class="p_add">+	fraction[2] = lp;</span>
<span class="p_add">+	denominator = ap + fp + lp + 1;</span>
 out:
 	some_scanned = false;
<span class="p_add">+</span>
 	/* Only use force_scan on second pass. */
 	for (pass = 0; !some_scanned &amp;&amp; pass &lt; 2; pass++) {
 		*lru_pages = 0;
<span class="p_chunk">@@ -2168,34 +2196,34 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, int swappiness,</span>
 			if (!scan &amp;&amp; pass &amp;&amp; force_scan)
 				scan = min(size, SWAP_CLUSTER_MAX);
 
<span class="p_del">-			switch (scan_balance) {</span>
<span class="p_del">-			case SCAN_EQUAL:</span>
<span class="p_del">-				/* Scan lists relative to size */</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case SCAN_FRACT:</span>
<span class="p_add">+			if (scan_balance &amp; SCAN_FRACT) {</span>
 				/*
 				 * Scan types proportional to swappiness and
 				 * their relative recent reclaim efficiency.
 				 */
 				scan = div64_u64(scan * fraction[file],
 							denominator);
<span class="p_del">-				break;</span>
<span class="p_del">-			case SCAN_FILE:</span>
<span class="p_del">-			case SCAN_ANON:</span>
<span class="p_del">-				/* Scan one type exclusively */</span>
<span class="p_del">-				if ((scan_balance == SCAN_FILE) != file) {</span>
<span class="p_del">-					size = 0;</span>
<span class="p_del">-					scan = 0;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			default:</span>
<span class="p_del">-				/* Look ma, no brain */</span>
<span class="p_del">-				BUG();</span>
<span class="p_add">+				goto scan;</span>
 			}
 
<span class="p_add">+			/* Scan lists relative to size */</span>
<span class="p_add">+			if (scan_balance &amp; SCAN_EQUAL)</span>
<span class="p_add">+				goto scan;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (scan_balance &amp; SCAN_FILE &amp;&amp; is_file_lru(lru))</span>
<span class="p_add">+				goto scan;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (scan_balance &amp; SCAN_ANON &amp;&amp; is_anon_lru(lru))</span>
<span class="p_add">+				goto scan;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (scan_balance &amp; SCAN_LZFREE &amp;&amp;</span>
<span class="p_add">+						is_lazyfree_lru(lru))</span>
<span class="p_add">+				goto scan;</span>
<span class="p_add">+</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+scan:</span>
 			*lru_pages += size;
 			nr[lru] = scan;
<span class="p_del">-</span>
 			/*
 			 * Skip the second pass and don&#39;t force_scan,
 			 * if we found something to scan.
<span class="p_chunk">@@ -2226,23 +2254,22 @@</span> <span class="p_context"> static inline void init_tlb_ubc(void)</span>
  * This is a basic per-zone page freer.  Used by both kswapd and direct reclaim.
  */
 static void shrink_lruvec(struct lruvec *lruvec, int swappiness,
<span class="p_del">-			  struct scan_control *sc, unsigned long *lru_pages)</span>
<span class="p_add">+			int lzfreeness, struct scan_control *sc,</span>
<span class="p_add">+			unsigned long *lru_pages)</span>
 {
<span class="p_del">-	unsigned long nr[NR_LRU_LISTS];</span>
<span class="p_del">-	unsigned long targets[NR_LRU_LISTS];</span>
<span class="p_add">+	unsigned long nr[NR_LRU_LISTS] = {0,};</span>
<span class="p_add">+	unsigned long targets[NR_LRU_LISTS] = {0,};</span>
 	unsigned long nr_to_scan;
<span class="p_del">-	unsigned long nr_to_scan_lzfree;</span>
 	enum lru_list lru;
 	unsigned long nr_reclaimed = 0;
 	unsigned long nr_to_reclaim = sc-&gt;nr_to_reclaim;
 	struct blk_plug plug;
 	bool scan_adjusted;
 
<span class="p_del">-	get_scan_count(lruvec, swappiness, sc, nr, lru_pages);</span>
<span class="p_add">+	get_scan_count(lruvec, swappiness, lzfreeness, sc, nr, lru_pages);</span>
 
 	/* Record the original scan target for proportional adjustments later */
 	memcpy(targets, nr, sizeof(nr));
<span class="p_del">-	nr_to_scan_lzfree = get_lru_size(lruvec, LRU_LZFREE);</span>
 
 	/*
 	 * Global reclaiming within direct reclaim at DEF_PRIORITY is a normal
<span class="p_chunk">@@ -2260,22 +2287,9 @@</span> <span class="p_context"> static void shrink_lruvec(struct lruvec *lruvec, int swappiness,</span>
 
 	init_tlb_ubc();
 
<span class="p_del">-	while (nr_to_scan_lzfree) {</span>
<span class="p_del">-		nr_to_scan = min(nr_to_scan_lzfree, SWAP_CLUSTER_MAX);</span>
<span class="p_del">-		nr_to_scan_lzfree -= nr_to_scan;</span>
<span class="p_del">-</span>
<span class="p_del">-		nr_reclaimed += shrink_inactive_list(nr_to_scan, lruvec,</span>
<span class="p_del">-						sc, LRU_LZFREE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (nr_reclaimed &gt;= nr_to_reclaim) {</span>
<span class="p_del">-		sc-&gt;nr_reclaimed += nr_reclaimed;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	blk_start_plug(&amp;plug);
 	while (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||
<span class="p_del">-					nr[LRU_INACTIVE_FILE]) {</span>
<span class="p_add">+		nr[LRU_INACTIVE_FILE] || nr[LRU_LZFREE]) {</span>
 		unsigned long nr_anon, nr_file, percentage;
 		unsigned long nr_scanned;
 
<span class="p_chunk">@@ -2457,7 +2471,7 @@</span> <span class="p_context"> static bool shrink_zone(struct zone *zone, struct scan_control *sc,</span>
 			unsigned long lru_pages;
 			unsigned long scanned;
 			struct lruvec *lruvec;
<span class="p_del">-			int swappiness;</span>
<span class="p_add">+			int swappiness, lzfreeness;</span>
 
 			if (mem_cgroup_low(root, memcg)) {
 				if (!sc-&gt;may_thrash)
<span class="p_chunk">@@ -2467,9 +2481,11 @@</span> <span class="p_context"> static bool shrink_zone(struct zone *zone, struct scan_control *sc,</span>
 
 			lruvec = mem_cgroup_zone_lruvec(zone, memcg);
 			swappiness = mem_cgroup_swappiness(memcg);
<span class="p_add">+			lzfreeness = mem_cgroup_lzfreeness(memcg);</span>
 			scanned = sc-&gt;nr_scanned;
 
<span class="p_del">-			shrink_lruvec(lruvec, swappiness, sc, &amp;lru_pages);</span>
<span class="p_add">+			shrink_lruvec(lruvec, swappiness, lzfreeness,</span>
<span class="p_add">+					sc, &amp;lru_pages);</span>
 			zone_lru_pages += lru_pages;
 
 			if (memcg &amp;&amp; is_classzone)
<span class="p_chunk">@@ -2935,6 +2951,7 @@</span> <span class="p_context"> unsigned long mem_cgroup_shrink_node_zone(struct mem_cgroup *memcg,</span>
 	};
 	struct lruvec *lruvec = mem_cgroup_zone_lruvec(zone, memcg);
 	int swappiness = mem_cgroup_swappiness(memcg);
<span class="p_add">+	int lzfreeness = mem_cgroup_lzfreeness(memcg);</span>
 	unsigned long lru_pages;
 
 	sc.gfp_mask = (gfp_mask &amp; GFP_RECLAIM_MASK) |
<span class="p_chunk">@@ -2951,7 +2968,7 @@</span> <span class="p_context"> unsigned long mem_cgroup_shrink_node_zone(struct mem_cgroup *memcg,</span>
 	 * will pick up pages from other mem cgroup&#39;s as well. We hack
 	 * the priority and make it zero.
 	 */
<span class="p_del">-	shrink_lruvec(lruvec, swappiness, &amp;sc, &amp;lru_pages);</span>
<span class="p_add">+	shrink_lruvec(lruvec, swappiness, lzfreeness, &amp;sc, &amp;lru_pages);</span>
 
 	trace_mm_vmscan_memcg_softlimit_reclaim_end(sc.nr_reclaimed);
 
<span class="p_header">diff --git a/mm/vmstat.c b/mm/vmstat.c</span>
<span class="p_header">index df95d9473bba..43effd0374d9 100644</span>
<span class="p_header">--- a/mm/vmstat.c</span>
<span class="p_header">+++ b/mm/vmstat.c</span>
<span class="p_chunk">@@ -703,8 +703,8 @@</span> <span class="p_context"> const char * const vmstat_text[] = {</span>
 	&quot;nr_active_anon&quot;,
 	&quot;nr_inactive_file&quot;,
 	&quot;nr_active_file&quot;,
<span class="p_del">-	&quot;nr_unevictable&quot;,</span>
 	&quot;nr_lazyfree&quot;,
<span class="p_add">+	&quot;nr_unevictable&quot;,</span>
 	&quot;nr_mlock&quot;,
 	&quot;nr_anon_pages&quot;,
 	&quot;nr_mapped&quot;,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



