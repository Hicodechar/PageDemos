
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.5 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.5</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 20, 2017, 10:19 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170120101925.GB5406@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9527933/mbox/"
   >mbox</a>
|
   <a href="/patch/9527933/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9527933/">/patch/9527933/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	EB32060459 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 Jan 2017 10:21:27 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CDDFF28354
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 Jan 2017 10:21:27 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id BCD7428562; Fri, 20 Jan 2017 10:21:27 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C53D328354
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 Jan 2017 10:21:19 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752043AbdATKTh (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 20 Jan 2017 05:19:37 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:50550 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751835AbdATKTY (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 20 Jan 2017 05:19:24 -0500
Received: from localhost (unknown [78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 24883901;
	Fri, 20 Jan 2017 10:19:11 +0000 (UTC)
Date: Fri, 20 Jan 2017 11:19:25 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.5
Message-ID: &lt;20170120101925.GB5406@kroah.com&gt;
References: &lt;20170120101913.GA5406@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: &lt;20170120101913.GA5406@kroah.com&gt;
User-Agent: Mutt/1.7.2 (2016-11-26)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 20, 2017, 10:19 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/mfd/tps65086.txt b/Documentation/devicetree/bindings/mfd/tps65086.txt</span>
<span class="p_header">index d3705612a846..9cfa886fe99f 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/mfd/tps65086.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/mfd/tps65086.txt</span>
<span class="p_chunk">@@ -23,7 +23,7 @@</span> <span class="p_context"> Required properties:</span>
                             defined below.
 
 Optional regulator properties:
<span class="p_del">- - ti,regulator-step-size-25mv	: This is applicable for buck[1,2,6], set this</span>
<span class="p_add">+ - ti,regulator-step-size-25mv	: This is applicable for buck[1-6], set this</span>
 				    if the regulator is factory set with a 25mv
 				    step voltage mapping.
  - ti,regulator-decay		: This is applicable for buck[1-6], set this if
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 9175706bfe7f..2a8af8af7b27 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 4</span>
<span class="p_add">+SUBLEVEL = 5</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm64/mm/hugetlbpage.c b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">index 2e49bd252fe7..45bec627bae3 100644</span>
<span class="p_header">--- a/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -51,20 +51,8 @@</span> <span class="p_context"> static int find_num_contig(struct mm_struct *mm, unsigned long addr,</span>
 	*pgsize = PAGE_SIZE;
 	if (!pte_cont(pte))
 		return 1;
<span class="p_del">-	if (!pgd_present(*pgd)) {</span>
<span class="p_del">-		VM_BUG_ON(!pgd_present(*pgd));</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	}</span>
 	pud = pud_offset(pgd, addr);
<span class="p_del">-	if (!pud_present(*pud)) {</span>
<span class="p_del">-		VM_BUG_ON(!pud_present(*pud));</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	}</span>
 	pmd = pmd_offset(pud, addr);
<span class="p_del">-	if (!pmd_present(*pmd)) {</span>
<span class="p_del">-		VM_BUG_ON(!pmd_present(*pmd));</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	}</span>
 	if ((pte_t *)pmd == ptep) {
 		*pgsize = PMD_SIZE;
 		return CONT_PMDS;
<span class="p_chunk">@@ -212,7 +200,7 @@</span> <span class="p_context"> pte_t huge_ptep_get_and_clear(struct mm_struct *mm,</span>
 		ncontig = find_num_contig(mm, addr, cpte, *cpte, &amp;pgsize);
 		/* save the 1st pte to return */
 		pte = ptep_get_and_clear(mm, addr, cpte);
<span class="p_del">-		for (i = 1; i &lt; ncontig; ++i) {</span>
<span class="p_add">+		for (i = 1, addr += pgsize; i &lt; ncontig; ++i, addr += pgsize) {</span>
 			/*
 			 * If HW_AFDBM is enabled, then the HW could
 			 * turn on the dirty bit for any of the page
<span class="p_chunk">@@ -250,8 +238,8 @@</span> <span class="p_context"> int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
 		pfn = pte_pfn(*cpte);
 		ncontig = find_num_contig(vma-&gt;vm_mm, addr, cpte,
 					  *cpte, &amp;pgsize);
<span class="p_del">-		for (i = 0; i &lt; ncontig; ++i, ++cpte) {</span>
<span class="p_del">-			changed = ptep_set_access_flags(vma, addr, cpte,</span>
<span class="p_add">+		for (i = 0; i &lt; ncontig; ++i, ++cpte, addr += pgsize) {</span>
<span class="p_add">+			changed |= ptep_set_access_flags(vma, addr, cpte,</span>
 							pfn_pte(pfn,
 								hugeprot),
 							dirty);
<span class="p_chunk">@@ -273,7 +261,7 @@</span> <span class="p_context"> void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
 
 		cpte = huge_pte_offset(mm, addr);
 		ncontig = find_num_contig(mm, addr, cpte, *cpte, &amp;pgsize);
<span class="p_del">-		for (i = 0; i &lt; ncontig; ++i, ++cpte)</span>
<span class="p_add">+		for (i = 0; i &lt; ncontig; ++i, ++cpte, addr += pgsize)</span>
 			ptep_set_wrprotect(mm, addr, cpte);
 	} else {
 		ptep_set_wrprotect(mm, addr, ptep);
<span class="p_chunk">@@ -291,7 +279,7 @@</span> <span class="p_context"> void huge_ptep_clear_flush(struct vm_area_struct *vma,</span>
 		cpte = huge_pte_offset(vma-&gt;vm_mm, addr);
 		ncontig = find_num_contig(vma-&gt;vm_mm, addr, cpte,
 					  *cpte, &amp;pgsize);
<span class="p_del">-		for (i = 0; i &lt; ncontig; ++i, ++cpte)</span>
<span class="p_add">+		for (i = 0; i &lt; ncontig; ++i, ++cpte, addr += pgsize)</span>
 			ptep_clear_flush(vma, addr, cpte);
 	} else {
 		ptep_clear_flush(vma, addr, ptep);
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/64/mmu-hash.h b/arch/powerpc/include/asm/book3s/64/mmu-hash.h</span>
<span class="p_header">index e407af2b7333..2e6a823fa502 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/64/mmu-hash.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/64/mmu-hash.h</span>
<span class="p_chunk">@@ -70,7 +70,9 @@</span> <span class="p_context"></span>
 
 #define HPTE_V_SSIZE_SHIFT	62
 #define HPTE_V_AVPN_SHIFT	7
<span class="p_add">+#define HPTE_V_COMMON_BITS	ASM_CONST(0x000fffffffffffff)</span>
 #define HPTE_V_AVPN		ASM_CONST(0x3fffffffffffff80)
<span class="p_add">+#define HPTE_V_AVPN_3_0		ASM_CONST(0x000fffffffffff80)</span>
 #define HPTE_V_AVPN_VAL(x)	(((x) &amp; HPTE_V_AVPN) &gt;&gt; HPTE_V_AVPN_SHIFT)
 #define HPTE_V_COMPARE(x,y)	(!(((x) ^ (y)) &amp; 0xffffffffffffff80UL))
 #define HPTE_V_BOLTED		ASM_CONST(0x0000000000000010)
<span class="p_chunk">@@ -80,14 +82,16 @@</span> <span class="p_context"></span>
 #define HPTE_V_VALID		ASM_CONST(0x0000000000000001)
 
 /*
<span class="p_del">- * ISA 3.0 have a different HPTE format.</span>
<span class="p_add">+ * ISA 3.0 has a different HPTE format.</span>
  */
 #define HPTE_R_3_0_SSIZE_SHIFT	58
<span class="p_add">+#define HPTE_R_3_0_SSIZE_MASK	(3ull &lt;&lt; HPTE_R_3_0_SSIZE_SHIFT)</span>
 #define HPTE_R_PP0		ASM_CONST(0x8000000000000000)
 #define HPTE_R_TS		ASM_CONST(0x4000000000000000)
 #define HPTE_R_KEY_HI		ASM_CONST(0x3000000000000000)
 #define HPTE_R_RPN_SHIFT	12
 #define HPTE_R_RPN		ASM_CONST(0x0ffffffffffff000)
<span class="p_add">+#define HPTE_R_RPN_3_0		ASM_CONST(0x01fffffffffff000)</span>
 #define HPTE_R_PP		ASM_CONST(0x0000000000000003)
 #define HPTE_R_PPP		ASM_CONST(0x8000000000000003)
 #define HPTE_R_N		ASM_CONST(0x0000000000000004)
<span class="p_chunk">@@ -316,12 +320,43 @@</span> <span class="p_context"> static inline unsigned long hpte_encode_avpn(unsigned long vpn, int psize,</span>
 	 */
 	v = (vpn &gt;&gt; (23 - VPN_SHIFT)) &amp; ~(mmu_psize_defs[psize].avpnm);
 	v &lt;&lt;= HPTE_V_AVPN_SHIFT;
<span class="p_del">-	if (!cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_del">-		v |= ((unsigned long) ssize) &lt;&lt; HPTE_V_SSIZE_SHIFT;</span>
<span class="p_add">+	v |= ((unsigned long) ssize) &lt;&lt; HPTE_V_SSIZE_SHIFT;</span>
 	return v;
 }
 
 /*
<span class="p_add">+ * ISA v3.0 defines a new HPTE format, which differs from the old</span>
<span class="p_add">+ * format in having smaller AVPN and ARPN fields, and the B field</span>
<span class="p_add">+ * in the second dword instead of the first.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline unsigned long hpte_old_to_new_v(unsigned long v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* trim AVPN, drop B */</span>
<span class="p_add">+	return v &amp; HPTE_V_COMMON_BITS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long hpte_old_to_new_r(unsigned long v, unsigned long r)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* move B field from 1st to 2nd dword, trim ARPN */</span>
<span class="p_add">+	return (r &amp; ~HPTE_R_3_0_SSIZE_MASK) |</span>
<span class="p_add">+		(((v) &gt;&gt; HPTE_V_SSIZE_SHIFT) &lt;&lt; HPTE_R_3_0_SSIZE_SHIFT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long hpte_new_to_old_v(unsigned long v, unsigned long r)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* insert B field */</span>
<span class="p_add">+	return (v &amp; HPTE_V_COMMON_BITS) |</span>
<span class="p_add">+		((r &amp; HPTE_R_3_0_SSIZE_MASK) &lt;&lt;</span>
<span class="p_add">+		 (HPTE_V_SSIZE_SHIFT - HPTE_R_3_0_SSIZE_SHIFT));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long hpte_new_to_old_r(unsigned long r)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* clear out B field */</span>
<span class="p_add">+	return r &amp; ~HPTE_R_3_0_SSIZE_MASK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * This function sets the AVPN and L fields of the HPTE  appropriately
  * using the base page size and actual page size.
  */
<span class="p_chunk">@@ -341,12 +376,8 @@</span> <span class="p_context"> static inline unsigned long hpte_encode_v(unsigned long vpn, int base_psize,</span>
  * aligned for the requested page size
  */
 static inline unsigned long hpte_encode_r(unsigned long pa, int base_psize,
<span class="p_del">-					  int actual_psize, int ssize)</span>
<span class="p_add">+					  int actual_psize)</span>
 {
<span class="p_del">-</span>
<span class="p_del">-	if (cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_del">-		pa |= ((unsigned long) ssize) &lt;&lt; HPTE_R_3_0_SSIZE_SHIFT;</span>
<span class="p_del">-</span>
 	/* A 4K page needs no special encoding */
 	if (actual_psize == MMU_PAGE_4K)
 		return pa &amp; HPTE_R_RPN;
<span class="p_header">diff --git a/arch/powerpc/kernel/ibmebus.c b/arch/powerpc/kernel/ibmebus.c</span>
<span class="p_header">index 6ca9a2ffaac7..35f5244782d9 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/ibmebus.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/ibmebus.c</span>
<span class="p_chunk">@@ -180,6 +180,7 @@</span> <span class="p_context"> static int ibmebus_create_device(struct device_node *dn)</span>
 static int ibmebus_create_devices(const struct of_device_id *matches)
 {
 	struct device_node *root, *child;
<span class="p_add">+	struct device *dev;</span>
 	int ret = 0;
 
 	root = of_find_node_by_path(&quot;/&quot;);
<span class="p_chunk">@@ -188,9 +189,12 @@</span> <span class="p_context"> static int ibmebus_create_devices(const struct of_device_id *matches)</span>
 		if (!of_match_node(matches, child))
 			continue;
 
<span class="p_del">-		if (bus_find_device(&amp;ibmebus_bus_type, NULL, child,</span>
<span class="p_del">-				    ibmebus_match_node))</span>
<span class="p_add">+		dev = bus_find_device(&amp;ibmebus_bus_type, NULL, child,</span>
<span class="p_add">+				      ibmebus_match_node);</span>
<span class="p_add">+		if (dev) {</span>
<span class="p_add">+			put_device(dev);</span>
 			continue;
<span class="p_add">+		}</span>
 
 		ret = ibmebus_create_device(child);
 		if (ret) {
<span class="p_chunk">@@ -262,6 +266,7 @@</span> <span class="p_context"> static ssize_t ibmebus_store_probe(struct bus_type *bus,</span>
 				   const char *buf, size_t count)
 {
 	struct device_node *dn = NULL;
<span class="p_add">+	struct device *dev;</span>
 	char *path;
 	ssize_t rc = 0;
 
<span class="p_chunk">@@ -269,8 +274,10 @@</span> <span class="p_context"> static ssize_t ibmebus_store_probe(struct bus_type *bus,</span>
 	if (!path)
 		return -ENOMEM;
 
<span class="p_del">-	if (bus_find_device(&amp;ibmebus_bus_type, NULL, path,</span>
<span class="p_del">-			    ibmebus_match_path)) {</span>
<span class="p_add">+	dev = bus_find_device(&amp;ibmebus_bus_type, NULL, path,</span>
<span class="p_add">+			      ibmebus_match_path);</span>
<span class="p_add">+	if (dev) {</span>
<span class="p_add">+		put_device(dev);</span>
 		printk(KERN_WARNING &quot;%s: %s has already been probed\n&quot;,
 		       __func__, path);
 		rc = -EEXIST;
<span class="p_chunk">@@ -307,6 +314,7 @@</span> <span class="p_context"> static ssize_t ibmebus_store_remove(struct bus_type *bus,</span>
 	if ((dev = bus_find_device(&amp;ibmebus_bus_type, NULL, path,
 				   ibmebus_match_path))) {
 		of_device_unregister(to_platform_device(dev));
<span class="p_add">+		put_device(dev);</span>
 
 		kfree(path);
 		return count;
<span class="p_header">diff --git a/arch/powerpc/mm/hash_native_64.c b/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_header">index 83ddc0e171b0..ad9fd5245be2 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_chunk">@@ -221,13 +221,18 @@</span> <span class="p_context"> static long native_hpte_insert(unsigned long hpte_group, unsigned long vpn,</span>
 		return -1;
 
 	hpte_v = hpte_encode_v(vpn, psize, apsize, ssize) | vflags | HPTE_V_VALID;
<span class="p_del">-	hpte_r = hpte_encode_r(pa, psize, apsize, ssize) | rflags;</span>
<span class="p_add">+	hpte_r = hpte_encode_r(pa, psize, apsize) | rflags;</span>
 
 	if (!(vflags &amp; HPTE_V_BOLTED)) {
 		DBG_LOW(&quot; i=%x hpte_v=%016lx, hpte_r=%016lx\n&quot;,
 			i, hpte_v, hpte_r);
 	}
 
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_ARCH_300)) {</span>
<span class="p_add">+		hpte_r = hpte_old_to_new_r(hpte_v, hpte_r);</span>
<span class="p_add">+		hpte_v = hpte_old_to_new_v(hpte_v);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	hptep-&gt;r = cpu_to_be64(hpte_r);
 	/* Guarantee the second dword is visible before the valid bit */
 	eieio();
<span class="p_chunk">@@ -295,6 +300,8 @@</span> <span class="p_context"> static long native_hpte_updatepp(unsigned long slot, unsigned long newpp,</span>
 		vpn, want_v &amp; HPTE_V_AVPN, slot, newpp);
 
 	hpte_v = be64_to_cpu(hptep-&gt;v);
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_add">+		hpte_v = hpte_new_to_old_v(hpte_v, be64_to_cpu(hptep-&gt;r));</span>
 	/*
 	 * We need to invalidate the TLB always because hpte_remove doesn&#39;t do
 	 * a tlb invalidate. If a hash bucket gets full, we &quot;evict&quot; a more/less
<span class="p_chunk">@@ -309,6 +316,8 @@</span> <span class="p_context"> static long native_hpte_updatepp(unsigned long slot, unsigned long newpp,</span>
 		native_lock_hpte(hptep);
 		/* recheck with locks held */
 		hpte_v = be64_to_cpu(hptep-&gt;v);
<span class="p_add">+		if (cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_add">+			hpte_v = hpte_new_to_old_v(hpte_v, be64_to_cpu(hptep-&gt;r));</span>
 		if (unlikely(!HPTE_V_COMPARE(hpte_v, want_v) ||
 			     !(hpte_v &amp; HPTE_V_VALID))) {
 			ret = -1;
<span class="p_chunk">@@ -350,6 +359,8 @@</span> <span class="p_context"> static long native_hpte_find(unsigned long vpn, int psize, int ssize)</span>
 	for (i = 0; i &lt; HPTES_PER_GROUP; i++) {
 		hptep = htab_address + slot;
 		hpte_v = be64_to_cpu(hptep-&gt;v);
<span class="p_add">+		if (cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_add">+			hpte_v = hpte_new_to_old_v(hpte_v, be64_to_cpu(hptep-&gt;r));</span>
 
 		if (HPTE_V_COMPARE(hpte_v, want_v) &amp;&amp; (hpte_v &amp; HPTE_V_VALID))
 			/* HPTE matches */
<span class="p_chunk">@@ -409,6 +420,8 @@</span> <span class="p_context"> static void native_hpte_invalidate(unsigned long slot, unsigned long vpn,</span>
 	want_v = hpte_encode_avpn(vpn, bpsize, ssize);
 	native_lock_hpte(hptep);
 	hpte_v = be64_to_cpu(hptep-&gt;v);
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_add">+		hpte_v = hpte_new_to_old_v(hpte_v, be64_to_cpu(hptep-&gt;r));</span>
 
 	/*
 	 * We need to invalidate the TLB always because hpte_remove doesn&#39;t do
<span class="p_chunk">@@ -467,6 +480,8 @@</span> <span class="p_context"> static void native_hugepage_invalidate(unsigned long vsid,</span>
 		want_v = hpte_encode_avpn(vpn, psize, ssize);
 		native_lock_hpte(hptep);
 		hpte_v = be64_to_cpu(hptep-&gt;v);
<span class="p_add">+		if (cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_add">+			hpte_v = hpte_new_to_old_v(hpte_v, be64_to_cpu(hptep-&gt;r));</span>
 
 		/* Even if we miss, we need to invalidate the TLB */
 		if (!HPTE_V_COMPARE(hpte_v, want_v) || !(hpte_v &amp; HPTE_V_VALID))
<span class="p_chunk">@@ -504,6 +519,10 @@</span> <span class="p_context"> static void hpte_decode(struct hash_pte *hpte, unsigned long slot,</span>
 	/* Look at the 8 bit LP value */
 	unsigned int lp = (hpte_r &gt;&gt; LP_SHIFT) &amp; ((1 &lt;&lt; LP_BITS) - 1);
 
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_ARCH_300)) {</span>
<span class="p_add">+		hpte_v = hpte_new_to_old_v(hpte_v, hpte_r);</span>
<span class="p_add">+		hpte_r = hpte_new_to_old_r(hpte_r);</span>
<span class="p_add">+	}</span>
 	if (!(hpte_v &amp; HPTE_V_LARGE)) {
 		size   = MMU_PAGE_4K;
 		a_size = MMU_PAGE_4K;
<span class="p_chunk">@@ -512,11 +531,7 @@</span> <span class="p_context"> static void hpte_decode(struct hash_pte *hpte, unsigned long slot,</span>
 		a_size = hpte_page_sizes[lp] &gt;&gt; 4;
 	}
 	/* This works for all page sizes, and for 256M and 1T segments */
<span class="p_del">-	if (cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_del">-		*ssize = hpte_r &gt;&gt; HPTE_R_3_0_SSIZE_SHIFT;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		*ssize = hpte_v &gt;&gt; HPTE_V_SSIZE_SHIFT;</span>
<span class="p_del">-</span>
<span class="p_add">+	*ssize = hpte_v &gt;&gt; HPTE_V_SSIZE_SHIFT;</span>
 	shift = mmu_psize_defs[size].shift;
 
 	avpn = (HPTE_V_AVPN_VAL(hpte_v) &amp; ~mmu_psize_defs[size].avpnm);
<span class="p_chunk">@@ -639,6 +654,9 @@</span> <span class="p_context"> static void native_flush_hash_range(unsigned long number, int local)</span>
 			want_v = hpte_encode_avpn(vpn, psize, ssize);
 			native_lock_hpte(hptep);
 			hpte_v = be64_to_cpu(hptep-&gt;v);
<span class="p_add">+			if (cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_add">+				hpte_v = hpte_new_to_old_v(hpte_v,</span>
<span class="p_add">+						be64_to_cpu(hptep-&gt;r));</span>
 			if (!HPTE_V_COMPARE(hpte_v, want_v) ||
 			    !(hpte_v &amp; HPTE_V_VALID))
 				native_unlock_hpte(hptep);
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable-radix.c b/arch/powerpc/mm/pgtable-radix.c</span>
<span class="p_header">index 688b54517655..ebb7f46f0532 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable-radix.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable-radix.c</span>
<span class="p_chunk">@@ -159,7 +159,7 @@</span> <span class="p_context"> static void __init radix_init_pgtable(void)</span>
 	 * Allocate Partition table and process table for the
 	 * host.
 	 */
<span class="p_del">-	BUILD_BUG_ON_MSG((PRTB_SIZE_SHIFT &gt; 23), &quot;Process table size too large.&quot;);</span>
<span class="p_add">+	BUILD_BUG_ON_MSG((PRTB_SIZE_SHIFT &gt; 36), &quot;Process table size too large.&quot;);</span>
 	process_tb = early_alloc_pgtable(1UL &lt;&lt; PRTB_SIZE_SHIFT);
 	/*
 	 * Fill in the process table.
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"> static void __init radix_init_partition_table(void)</span>
 
 	rts_field = radix__get_tree_size();
 
<span class="p_del">-	BUILD_BUG_ON_MSG((PATB_SIZE_SHIFT &gt; 24), &quot;Partition table size too large.&quot;);</span>
<span class="p_add">+	BUILD_BUG_ON_MSG((PATB_SIZE_SHIFT &gt; 36), &quot;Partition table size too large.&quot;);</span>
 	partition_tb = early_alloc_pgtable(1UL &lt;&lt; PATB_SIZE_SHIFT);
 	partition_tb-&gt;patb0 = cpu_to_be64(rts_field | __pa(init_mm.pgd) |
 					  RADIX_PGD_INDEX_SIZE | PATB_HR);
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">index d4b33dd2d9e7..dcdfee0cd4f2 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> static struct pnv_ioda_pe *pnv_ioda_init_pe(struct pnv_phb *phb, int pe_no)</span>
 	 */
 	rc = opal_pci_eeh_freeze_clear(phb-&gt;opal_id, pe_no,
 				       OPAL_EEH_ACTION_CLEAR_FREEZE_ALL);
<span class="p_del">-	if (rc != OPAL_SUCCESS)</span>
<span class="p_add">+	if (rc != OPAL_SUCCESS &amp;&amp; rc != OPAL_UNSUPPORTED)</span>
 		pr_warn(&quot;%s: Error %lld unfreezing PHB#%d-PE#%d\n&quot;,
 			__func__, rc, phb-&gt;hose-&gt;global_number, pe_no);
 
<span class="p_header">diff --git a/arch/powerpc/platforms/ps3/htab.c b/arch/powerpc/platforms/ps3/htab.c</span>
<span class="p_header">index cb3c50328de8..cc2b281a3766 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/ps3/htab.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/ps3/htab.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static long ps3_hpte_insert(unsigned long hpte_group, unsigned long vpn,</span>
 	vflags &amp;= ~HPTE_V_SECONDARY;
 
 	hpte_v = hpte_encode_v(vpn, psize, apsize, ssize) | vflags | HPTE_V_VALID;
<span class="p_del">-	hpte_r = hpte_encode_r(ps3_mm_phys_to_lpar(pa), psize, apsize, ssize) | rflags;</span>
<span class="p_add">+	hpte_r = hpte_encode_r(ps3_mm_phys_to_lpar(pa), psize, apsize) | rflags;</span>
 
 	spin_lock_irqsave(&amp;ps3_htab_lock, flags);
 
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/lpar.c b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">index aa35245d8d6d..f2c98f6c1c9c 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> static long pSeries_lpar_hpte_insert(unsigned long hpte_group,</span>
 			 hpte_group, vpn,  pa, rflags, vflags, psize);
 
 	hpte_v = hpte_encode_v(vpn, psize, apsize, ssize) | vflags | HPTE_V_VALID;
<span class="p_del">-	hpte_r = hpte_encode_r(pa, psize, apsize, ssize) | rflags;</span>
<span class="p_add">+	hpte_r = hpte_encode_r(pa, psize, apsize) | rflags;</span>
 
 	if (!(vflags &amp; HPTE_V_BOLTED))
 		pr_devel(&quot; hpte_v=%016lx, hpte_r=%016lx\n&quot;, hpte_v, hpte_r);
<span class="p_header">diff --git a/arch/x86/include/asm/cpufeatures.h b/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_header">index a39629206864..ed10b5bf9b93 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_chunk">@@ -311,4 +311,6 @@</span> <span class="p_context"></span>
 #define X86_BUG_NULL_SEG	X86_BUG(10) /* Nulling a selector preserves the base */
 #define X86_BUG_SWAPGS_FENCE	X86_BUG(11) /* SWAPGS without input dep on GS */
 #define X86_BUG_MONITOR		X86_BUG(12) /* IPI required to wake up remote CPU */
<span class="p_add">+#define X86_BUG_AMD_E400	X86_BUG(13) /* CPU is among the affected by Erratum 400 */</span>
<span class="p_add">+</span>
 #endif /* _ASM_X86_CPUFEATURES_H */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">index 1e81a37c034e..1d3167269a67 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_chunk">@@ -20,6 +20,10 @@</span> <span class="p_context"></span>
 
 #include &quot;cpu.h&quot;
 
<span class="p_add">+static const int amd_erratum_383[];</span>
<span class="p_add">+static const int amd_erratum_400[];</span>
<span class="p_add">+static bool cpu_has_amd_erratum(struct cpuinfo_x86 *cpu, const int *erratum);</span>
<span class="p_add">+</span>
 /*
  * nodes_per_socket: Stores the number of nodes per socket.
  * Refer to Fam15h Models 00-0fh BKDG - CPUID Fn8000_001E_ECX
<span class="p_chunk">@@ -305,20 +309,32 @@</span> <span class="p_context"> static void amd_get_topology(struct cpuinfo_x86 *c)</span>
 
 	/* get information required for multi-node processors */
 	if (boot_cpu_has(X86_FEATURE_TOPOEXT)) {
<span class="p_del">-		u32 eax, ebx, ecx, edx;</span>
 
<span class="p_del">-		cpuid(0x8000001e, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-		node_id = ecx &amp; 7;</span>
<span class="p_add">+		node_id = cpuid_ecx(0x8000001e) &amp; 7;</span>
 
<span class="p_del">-		/* get compute unit information */</span>
<span class="p_del">-		smp_num_siblings = ((ebx &gt;&gt; 8) &amp; 3) + 1;</span>
<span class="p_del">-		c-&gt;x86_max_cores /= smp_num_siblings;</span>
<span class="p_del">-		c-&gt;cpu_core_id = ebx &amp; 0xff;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We may have multiple LLCs if L3 caches exist, so check if we</span>
<span class="p_add">+		 * have an L3 cache by looking at the L3 cache CPUID leaf.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (cpuid_edx(0x80000006)) {</span>
<span class="p_add">+			if (c-&gt;x86 == 0x17) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * LLC is at the core complex level.</span>
<span class="p_add">+				 * Core complex id is ApicId[3].</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				per_cpu(cpu_llc_id, cpu) = c-&gt;apicid &gt;&gt; 3;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/* LLC is at the node level. */</span>
<span class="p_add">+				per_cpu(cpu_llc_id, cpu) = node_id;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	} else if (cpu_has(c, X86_FEATURE_NODEID_MSR)) {
 		u64 value;
 
 		rdmsrl(MSR_FAM10H_NODE_ID, value);
 		node_id = value &amp; 7;
<span class="p_add">+</span>
<span class="p_add">+		per_cpu(cpu_llc_id, cpu) = node_id;</span>
 	} else
 		return;
 
<span class="p_chunk">@@ -329,9 +345,6 @@</span> <span class="p_context"> static void amd_get_topology(struct cpuinfo_x86 *c)</span>
 		set_cpu_cap(c, X86_FEATURE_AMD_DCM);
 		cus_per_node = c-&gt;x86_max_cores / nodes_per_socket;
 
<span class="p_del">-		/* store NodeID, use llc_shared_map to store sibling info */</span>
<span class="p_del">-		per_cpu(cpu_llc_id, cpu) = node_id;</span>
<span class="p_del">-</span>
 		/* core id has to be in the [0 .. cores_per_node - 1] range */
 		c-&gt;cpu_core_id %= cus_per_node;
 	}
<span class="p_chunk">@@ -356,15 +369,6 @@</span> <span class="p_context"> static void amd_detect_cmp(struct cpuinfo_x86 *c)</span>
 	/* use socket ID also for last level cache */
 	per_cpu(cpu_llc_id, cpu) = c-&gt;phys_proc_id;
 	amd_get_topology(c);
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Fix percpu cpu_llc_id here as LLC topology is different</span>
<span class="p_del">-	 * for Fam17h systems.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	 if (c-&gt;x86 != 0x17 || !cpuid_edx(0x80000006))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	per_cpu(cpu_llc_id, cpu) = c-&gt;apicid &gt;&gt; 3;</span>
 #endif
 }
 
<span class="p_chunk">@@ -585,11 +589,16 @@</span> <span class="p_context"> static void early_init_amd(struct cpuinfo_x86 *c)</span>
 	/* F16h erratum 793, CVE-2013-6885 */
 	if (c-&gt;x86 == 0x16 &amp;&amp; c-&gt;x86_model &lt;= 0xf)
 		msr_set_bit(MSR_AMD64_LS_CFG, 15);
<span class="p_del">-}</span>
 
<span class="p_del">-static const int amd_erratum_383[];</span>
<span class="p_del">-static const int amd_erratum_400[];</span>
<span class="p_del">-static bool cpu_has_amd_erratum(struct cpuinfo_x86 *cpu, const int *erratum);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check whether the machine is affected by erratum 400. This is</span>
<span class="p_add">+	 * used to select the proper idle routine and to enable the check</span>
<span class="p_add">+	 * whether the machine is affected in arch_post_acpi_init(), which</span>
<span class="p_add">+	 * sets the X86_BUG_AMD_APIC_C1E bug depending on the MSR check.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpu_has_amd_erratum(c, amd_erratum_400))</span>
<span class="p_add">+		set_cpu_bug(c, X86_BUG_AMD_E400);</span>
<span class="p_add">+}</span>
 
 static void init_amd_k8(struct cpuinfo_x86 *c)
 {
<span class="p_chunk">@@ -770,9 +779,6 @@</span> <span class="p_context"> static void init_amd(struct cpuinfo_x86 *c)</span>
 	if (c-&gt;x86 &gt; 0x11)
 		set_cpu_cap(c, X86_FEATURE_ARAT);
 
<span class="p_del">-	if (cpu_has_amd_erratum(c, amd_erratum_400))</span>
<span class="p_del">-		set_cpu_bug(c, X86_BUG_AMD_APIC_C1E);</span>
<span class="p_del">-</span>
 	rdmsr_safe(MSR_AMD64_PATCH_LEVEL, &amp;c-&gt;microcode, &amp;dummy);
 
 	/* 3DNow or LM implies PREFETCHW */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index dd62708c6a67..023c7bfa24df 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -1275,7 +1275,7 @@</span> <span class="p_context"> static __init int setup_disablecpuid(char *arg)</span>
 {
 	int bit;
 
<span class="p_del">-	if (get_option(&amp;arg, &amp;bit) &amp;&amp; bit &lt; NCAPINTS*32)</span>
<span class="p_add">+	if (get_option(&amp;arg, &amp;bit) &amp;&amp; bit &gt;= 0 &amp;&amp; bit &lt; NCAPINTS * 32)</span>
 		setup_clear_cpu_cap(bit);
 	else
 		return 0;
<span class="p_header">diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c</span>
<span class="p_header">index 0888a879120f..8e10e72bf6ee 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process.c</span>
<span class="p_chunk">@@ -448,8 +448,7 @@</span> <span class="p_context"> void select_idle_routine(const struct cpuinfo_x86 *c)</span>
 	if (x86_idle || boot_option_idle_override == IDLE_POLL)
 		return;
 
<span class="p_del">-	if (cpu_has_bug(c, X86_BUG_AMD_APIC_C1E)) {</span>
<span class="p_del">-		/* E400: APIC timer interrupt does not wake up CPU from C1e */</span>
<span class="p_add">+	if (boot_cpu_has_bug(X86_BUG_AMD_E400)) {</span>
 		pr_info(&quot;using AMD E400 aware idle routine\n&quot;);
 		x86_idle = amd_e400_idle;
 	} else if (prefer_mwait_c1_over_halt(c)) {
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index a3ce9d260d68..9f676adcdfc2 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -171,6 +171,7 @@</span> <span class="p_context"></span>
 #define NearBranch  ((u64)1 &lt;&lt; 52)  /* Near branches */
 #define No16	    ((u64)1 &lt;&lt; 53)  /* No 16 bit operand */
 #define IncSP       ((u64)1 &lt;&lt; 54)  /* SP is incremented before ModRM calc */
<span class="p_add">+#define Aligned16   ((u64)1 &lt;&lt; 55)  /* Aligned to 16 byte boundary (e.g. FXSAVE) */</span>
 
 #define DstXacc     (DstAccLo | SrcAccHi | SrcWrite)
 
<span class="p_chunk">@@ -446,6 +447,26 @@</span> <span class="p_context"> FOP_END;</span>
 FOP_START(salc) &quot;pushf; sbb %al, %al; popf \n\t&quot; FOP_RET
 FOP_END;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * XXX: inoutclob user must know where the argument is being expanded.</span>
<span class="p_add">+ *      Relying on CC_HAVE_ASM_GOTO would allow us to remove _fault.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define asm_safe(insn, inoutclob...) \</span>
<span class="p_add">+({ \</span>
<span class="p_add">+	int _fault = 0; \</span>
<span class="p_add">+ \</span>
<span class="p_add">+	asm volatile(&quot;1:&quot; insn &quot;\n&quot; \</span>
<span class="p_add">+	             &quot;2:\n&quot; \</span>
<span class="p_add">+	             &quot;.pushsection .fixup, \&quot;ax\&quot;\n&quot; \</span>
<span class="p_add">+	             &quot;3: movl $1, %[_fault]\n&quot; \</span>
<span class="p_add">+	             &quot;   jmp  2b\n&quot; \</span>
<span class="p_add">+	             &quot;.popsection\n&quot; \</span>
<span class="p_add">+	             _ASM_EXTABLE(1b, 3b) \</span>
<span class="p_add">+	             : [_fault] &quot;+qm&quot;(_fault) inoutclob ); \</span>
<span class="p_add">+ \</span>
<span class="p_add">+	_fault ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE; \</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 static int emulator_check_intercept(struct x86_emulate_ctxt *ctxt,
 				    enum x86_intercept intercept,
 				    enum x86_intercept_stage stage)
<span class="p_chunk">@@ -632,21 +653,24 @@</span> <span class="p_context"> static void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,</span>
  * depending on whether they&#39;re AVX encoded or not.
  *
  * Also included is CMPXCHG16B which is not a vector instruction, yet it is
<span class="p_del">- * subject to the same check.</span>
<span class="p_add">+ * subject to the same check.  FXSAVE and FXRSTOR are checked here too as their</span>
<span class="p_add">+ * 512 bytes of data must be aligned to a 16 byte boundary.</span>
  */
<span class="p_del">-static bool insn_aligned(struct x86_emulate_ctxt *ctxt, unsigned size)</span>
<span class="p_add">+static unsigned insn_alignment(struct x86_emulate_ctxt *ctxt, unsigned size)</span>
 {
 	if (likely(size &lt; 16))
<span class="p_del">-		return false;</span>
<span class="p_add">+		return 1;</span>
 
 	if (ctxt-&gt;d &amp; Aligned)
<span class="p_del">-		return true;</span>
<span class="p_add">+		return size;</span>
 	else if (ctxt-&gt;d &amp; Unaligned)
<span class="p_del">-		return false;</span>
<span class="p_add">+		return 1;</span>
 	else if (ctxt-&gt;d &amp; Avx)
<span class="p_del">-		return false;</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	else if (ctxt-&gt;d &amp; Aligned16)</span>
<span class="p_add">+		return 16;</span>
 	else
<span class="p_del">-		return true;</span>
<span class="p_add">+		return size;</span>
 }
 
 static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,
<span class="p_chunk">@@ -704,7 +728,7 @@</span> <span class="p_context"> static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,</span>
 		}
 		break;
 	}
<span class="p_del">-	if (insn_aligned(ctxt, size) &amp;&amp; ((la &amp; (size - 1)) != 0))</span>
<span class="p_add">+	if (la &amp; (insn_alignment(ctxt, size) - 1))</span>
 		return emulate_gp(ctxt, 0);
 	return X86EMUL_CONTINUE;
 bad:
<span class="p_chunk">@@ -791,6 +815,20 @@</span> <span class="p_context"> static int segmented_read_std(struct x86_emulate_ctxt *ctxt,</span>
 	return ctxt-&gt;ops-&gt;read_std(ctxt, linear, data, size, &amp;ctxt-&gt;exception);
 }
 
<span class="p_add">+static int segmented_write_std(struct x86_emulate_ctxt *ctxt,</span>
<span class="p_add">+			       struct segmented_address addr,</span>
<span class="p_add">+			       void *data,</span>
<span class="p_add">+			       unsigned int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+	ulong linear;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = linearize(ctxt, addr, size, true, &amp;linear);</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	return ctxt-&gt;ops-&gt;write_std(ctxt, linear, data, size, &amp;ctxt-&gt;exception);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Prefetch the remaining bytes of the instruction without crossing page
  * boundary if they are not in fetch_cache yet.
<span class="p_chunk">@@ -1544,7 +1582,6 @@</span> <span class="p_context"> static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,</span>
 				    &amp;ctxt-&gt;exception);
 }
 
<span class="p_del">-/* Does not support long mode */</span>
 static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 				     u16 selector, int seg, u8 cpl,
 				     enum x86_transfer_type transfer,
<span class="p_chunk">@@ -1581,20 +1618,34 @@</span> <span class="p_context"> static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,</span>
 
 	rpl = selector &amp; 3;
 
<span class="p_del">-	/* NULL selector is not valid for TR, CS and SS (except for long mode) */</span>
<span class="p_del">-	if ((seg == VCPU_SREG_CS</span>
<span class="p_del">-	     || (seg == VCPU_SREG_SS</span>
<span class="p_del">-		 &amp;&amp; (ctxt-&gt;mode != X86EMUL_MODE_PROT64 || rpl != cpl))</span>
<span class="p_del">-	     || seg == VCPU_SREG_TR)</span>
<span class="p_del">-	    &amp;&amp; null_selector)</span>
<span class="p_del">-		goto exception;</span>
<span class="p_del">-</span>
 	/* TR should be in GDT only */
 	if (seg == VCPU_SREG_TR &amp;&amp; (selector &amp; (1 &lt;&lt; 2)))
 		goto exception;
 
<span class="p_del">-	if (null_selector) /* for NULL selector skip all following checks */</span>
<span class="p_add">+	/* NULL selector is not valid for TR, CS and (except for long mode) SS */</span>
<span class="p_add">+	if (null_selector) {</span>
<span class="p_add">+		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)</span>
<span class="p_add">+			goto exception;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (seg == VCPU_SREG_SS) {</span>
<span class="p_add">+			if (ctxt-&gt;mode != X86EMUL_MODE_PROT64 || rpl != cpl)</span>
<span class="p_add">+				goto exception;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * ctxt-&gt;ops-&gt;set_segment expects the CPL to be in</span>
<span class="p_add">+			 * SS.DPL, so fake an expand-up 32-bit data segment.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			seg_desc.type = 3;</span>
<span class="p_add">+			seg_desc.p = 1;</span>
<span class="p_add">+			seg_desc.s = 1;</span>
<span class="p_add">+			seg_desc.dpl = cpl;</span>
<span class="p_add">+			seg_desc.d = 1;</span>
<span class="p_add">+			seg_desc.g = 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Skip all following checks */</span>
 		goto load;
<span class="p_add">+	}</span>
 
 	ret = read_segment_descriptor(ctxt, selector, &amp;seg_desc, &amp;desc_addr);
 	if (ret != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -1710,6 +1761,21 @@</span> <span class="p_context"> static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,</span>
 				   u16 selector, int seg)
 {
 	u8 cpl = ctxt-&gt;ops-&gt;cpl(ctxt);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * None of MOV, POP and LSS can load a NULL selector in CPL=3, but</span>
<span class="p_add">+	 * they can load it at CPL&lt;3 (Intel&#39;s manual says only LSS can,</span>
<span class="p_add">+	 * but it&#39;s wrong).</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However, the Intel manual says that putting IST=1/DPL=3 in</span>
<span class="p_add">+	 * an interrupt gate will result in SS=3 (the AMD manual instead</span>
<span class="p_add">+	 * says it doesn&#39;t), so allow SS=3 in __load_segment_descriptor</span>
<span class="p_add">+	 * and only forbid it here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (seg == VCPU_SREG_SS &amp;&amp; selector == 3 &amp;&amp;</span>
<span class="p_add">+	    ctxt-&gt;mode == X86EMUL_MODE_PROT64)</span>
<span class="p_add">+		return emulate_exception(ctxt, GP_VECTOR, 0, true);</span>
<span class="p_add">+</span>
 	return __load_segment_descriptor(ctxt, selector, seg, cpl,
 					 X86_TRANSFER_NONE, NULL);
 }
<span class="p_chunk">@@ -3658,8 +3724,8 @@</span> <span class="p_context"> static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,</span>
 	}
 	/* Disable writeback. */
 	ctxt-&gt;dst.type = OP_NONE;
<span class="p_del">-	return segmented_write(ctxt, ctxt-&gt;dst.addr.mem,</span>
<span class="p_del">-			       &amp;desc_ptr, 2 + ctxt-&gt;op_bytes);</span>
<span class="p_add">+	return segmented_write_std(ctxt, ctxt-&gt;dst.addr.mem,</span>
<span class="p_add">+				   &amp;desc_ptr, 2 + ctxt-&gt;op_bytes);</span>
 }
 
 static int em_sgdt(struct x86_emulate_ctxt *ctxt)
<span class="p_chunk">@@ -3842,6 +3908,131 @@</span> <span class="p_context"> static int em_movsxd(struct x86_emulate_ctxt *ctxt)</span>
 	return X86EMUL_CONTINUE;
 }
 
<span class="p_add">+static int check_fxsr(struct x86_emulate_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 eax = 1, ebx, ecx = 0, edx;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;get_cpuid(ctxt, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	if (!(edx &amp; FFL(FXSR)))</span>
<span class="p_add">+		return emulate_ud(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ctxt-&gt;ops-&gt;get_cr(ctxt, 0) &amp; (X86_CR0_TS | X86_CR0_EM))</span>
<span class="p_add">+		return emulate_nm(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t emulate a case that should never be hit, instead of working</span>
<span class="p_add">+	 * around a lack of fxsave64/fxrstor64 on old compilers.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ctxt-&gt;mode &gt;= X86EMUL_MODE_PROT64)</span>
<span class="p_add">+		return X86EMUL_UNHANDLEABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+	return X86EMUL_CONTINUE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * FXSAVE and FXRSTOR have 4 different formats depending on execution mode,</span>
<span class="p_add">+ *  1) 16 bit mode</span>
<span class="p_add">+ *  2) 32 bit mode</span>
<span class="p_add">+ *     - like (1), but FIP and FDP (foo) are only 16 bit.  At least Intel CPUs</span>
<span class="p_add">+ *       preserve whole 32 bit values, though, so (1) and (2) are the same wrt.</span>
<span class="p_add">+ *       save and restore</span>
<span class="p_add">+ *  3) 64-bit mode with REX.W prefix</span>
<span class="p_add">+ *     - like (2), but XMM 8-15 are being saved and restored</span>
<span class="p_add">+ *  4) 64-bit mode without REX.W prefix</span>
<span class="p_add">+ *     - like (3), but FIP and FDP are 64 bit</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Emulation uses (3) for (1) and (2) and preserves XMM 8-15 to reach the</span>
<span class="p_add">+ * desired result.  (4) is not emulated.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note: Guest and host CPUID.(EAX=07H,ECX=0H):EBX[bit 13] (deprecate FPU CS</span>
<span class="p_add">+ * and FPU DS) should match.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int em_fxsave(struct x86_emulate_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fxregs_state fx_state;</span>
<span class="p_add">+	size_t size;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = check_fxsr(ctxt);</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;get_fpu(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = asm_safe(&quot;fxsave %[fx]&quot;, , [fx] &quot;+m&quot;(fx_state));</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;put_fpu(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ctxt-&gt;ops-&gt;get_cr(ctxt, 4) &amp; X86_CR4_OSFXSR)</span>
<span class="p_add">+		size = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		size = offsetof(struct fxregs_state, xmm_space[0]);</span>
<span class="p_add">+</span>
<span class="p_add">+	return segmented_write_std(ctxt, ctxt-&gt;memop.addr.mem, &amp;fx_state, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int fxrstor_fixup(struct x86_emulate_ctxt *ctxt,</span>
<span class="p_add">+		struct fxregs_state *new)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc = X86EMUL_CONTINUE;</span>
<span class="p_add">+	struct fxregs_state old;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = asm_safe(&quot;fxsave %[fx]&quot;, , [fx] &quot;+m&quot;(old));</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 64 bit host will restore XMM 8-15, which is not correct on non-64</span>
<span class="p_add">+	 * bit guests.  Load the current values in order to preserve 64 bit</span>
<span class="p_add">+	 * XMMs after fxrstor.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	/* XXX: accessing XMM 8-15 very awkwardly */</span>
<span class="p_add">+	memcpy(&amp;new-&gt;xmm_space[8 * 16/4], &amp;old.xmm_space[8 * 16/4], 8 * 16);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Hardware doesn&#39;t save and restore XMM 0-7 without CR4.OSFXSR, but</span>
<span class="p_add">+	 * does save and restore MXCSR.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(ctxt-&gt;ops-&gt;get_cr(ctxt, 4) &amp; X86_CR4_OSFXSR))</span>
<span class="p_add">+		memcpy(new-&gt;xmm_space, old.xmm_space, 8 * 16);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int em_fxrstor(struct x86_emulate_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fxregs_state fx_state;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = check_fxsr(ctxt);</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = segmented_read_std(ctxt, ctxt-&gt;memop.addr.mem, &amp;fx_state, 512);</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fx_state.mxcsr &gt;&gt; 16)</span>
<span class="p_add">+		return emulate_gp(ctxt, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;get_fpu(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ctxt-&gt;mode &lt; X86EMUL_MODE_PROT64)</span>
<span class="p_add">+		rc = fxrstor_fixup(ctxt, &amp;fx_state);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rc == X86EMUL_CONTINUE)</span>
<span class="p_add">+		rc = asm_safe(&quot;fxrstor %[fx]&quot;, : [fx] &quot;m&quot;(fx_state));</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;put_fpu(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool valid_cr(int nr)
 {
 	switch (nr) {
<span class="p_chunk">@@ -4194,7 +4385,9 @@</span> <span class="p_context"> static const struct gprefix pfx_0f_ae_7 = {</span>
 };
 
 static const struct group_dual group15 = { {
<span class="p_del">-	N, N, N, N, N, N, N, GP(0, &amp;pfx_0f_ae_7),</span>
<span class="p_add">+	I(ModRM | Aligned16, em_fxsave),</span>
<span class="p_add">+	I(ModRM | Aligned16, em_fxrstor),</span>
<span class="p_add">+	N, N, N, N, N, GP(0, &amp;pfx_0f_ae_7),</span>
 }, {
 	N, N, N, N, N, N, N, N,
 } };
<span class="p_chunk">@@ -5066,21 +5259,13 @@</span> <span class="p_context"> static bool string_insn_completed(struct x86_emulate_ctxt *ctxt)</span>
 
 static int flush_pending_x87_faults(struct x86_emulate_ctxt *ctxt)
 {
<span class="p_del">-	bool fault = false;</span>
<span class="p_add">+	int rc;</span>
 
 	ctxt-&gt;ops-&gt;get_fpu(ctxt);
<span class="p_del">-	asm volatile(&quot;1: fwait \n\t&quot;</span>
<span class="p_del">-		     &quot;2: \n\t&quot;</span>
<span class="p_del">-		     &quot;.pushsection .fixup,\&quot;ax\&quot; \n\t&quot;</span>
<span class="p_del">-		     &quot;3: \n\t&quot;</span>
<span class="p_del">-		     &quot;movb $1, %[fault] \n\t&quot;</span>
<span class="p_del">-		     &quot;jmp 2b \n\t&quot;</span>
<span class="p_del">-		     &quot;.popsection \n\t&quot;</span>
<span class="p_del">-		     _ASM_EXTABLE(1b, 3b)</span>
<span class="p_del">-		     : [fault]&quot;+qm&quot;(fault));</span>
<span class="p_add">+	rc = asm_safe(&quot;fwait&quot;);</span>
 	ctxt-&gt;ops-&gt;put_fpu(ctxt);
 
<span class="p_del">-	if (unlikely(fault))</span>
<span class="p_add">+	if (unlikely(rc != X86EMUL_CONTINUE))</span>
 		return emulate_exception(ctxt, MF_VECTOR, 0, false);
 
 	return X86EMUL_CONTINUE;
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 6f69340f9fa3..3f05c044720b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -2360,3 +2360,9 @@</span> <span class="p_context"> void kvm_lapic_init(void)</span>
 	jump_label_rate_limit(&amp;apic_hw_disabled, HZ);
 	jump_label_rate_limit(&amp;apic_sw_disabled, HZ);
 }
<span class="p_add">+</span>
<span class="p_add">+void kvm_lapic_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static_key_deferred_flush(&amp;apic_hw_disabled);</span>
<span class="p_add">+	static_key_deferred_flush(&amp;apic_sw_disabled);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h</span>
<span class="p_header">index f60d01c29d51..4dfe4d6cb338 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.h</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.h</span>
<span class="p_chunk">@@ -108,6 +108,7 @@</span> <span class="p_context"> static inline bool kvm_hv_vapic_assist_page_enabled(struct kvm_vcpu *vcpu)</span>
 
 int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data);
 void kvm_lapic_init(void);
<span class="p_add">+void kvm_lapic_exit(void);</span>
 
 #define VEC_POS(v) ((v) &amp; (32 - 1))
 #define REG_POS(v) (((v) &gt;&gt; 5) &lt;&lt; 4)
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index f3648c978d2f..487b957e7802 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -3308,6 +3308,8 @@</span> <span class="p_context"> static int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,</span>
 
 	switch (cap-&gt;cap) {
 	case KVM_CAP_HYPERV_SYNIC:
<span class="p_add">+		if (!irqchip_in_kernel(vcpu-&gt;kvm))</span>
<span class="p_add">+			return -EINVAL;</span>
 		return kvm_hv_activate_synic(vcpu);
 	default:
 		return -EINVAL;
<span class="p_chunk">@@ -5963,6 +5965,7 @@</span> <span class="p_context"> int kvm_arch_init(void *opaque)</span>
 
 void kvm_arch_exit(void)
 {
<span class="p_add">+	kvm_lapic_exit();</span>
 	perf_unregister_guest_info_callbacks(&amp;kvm_guest_cbs);
 
 	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index 936a488d6cf6..274dfc481849 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -210,6 +210,70 @@</span> <span class="p_context"> int __init efi_memblock_x86_reserve_range(void)</span>
 	return 0;
 }
 
<span class="p_add">+#define OVERFLOW_ADDR_SHIFT	(64 - EFI_PAGE_SHIFT)</span>
<span class="p_add">+#define OVERFLOW_ADDR_MASK	(U64_MAX &lt;&lt; OVERFLOW_ADDR_SHIFT)</span>
<span class="p_add">+#define U64_HIGH_BIT		(~(U64_MAX &gt;&gt; 1))</span>
<span class="p_add">+</span>
<span class="p_add">+static bool __init efi_memmap_entry_valid(const efi_memory_desc_t *md, int i)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 end = (md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT) + md-&gt;phys_addr - 1;</span>
<span class="p_add">+	u64 end_hi = 0;</span>
<span class="p_add">+	char buf[64];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (md-&gt;num_pages == 0) {</span>
<span class="p_add">+		end = 0;</span>
<span class="p_add">+	} else if (md-&gt;num_pages &gt; EFI_PAGES_MAX ||</span>
<span class="p_add">+		   EFI_PAGES_MAX - md-&gt;num_pages &lt;</span>
<span class="p_add">+		   (md-&gt;phys_addr &gt;&gt; EFI_PAGE_SHIFT)) {</span>
<span class="p_add">+		end_hi = (md-&gt;num_pages &amp; OVERFLOW_ADDR_MASK)</span>
<span class="p_add">+			&gt;&gt; OVERFLOW_ADDR_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((md-&gt;phys_addr &amp; U64_HIGH_BIT) &amp;&amp; !(end &amp; U64_HIGH_BIT))</span>
<span class="p_add">+			end_hi += 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_warn_once(FW_BUG &quot;Invalid EFI memory map entries:\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (end_hi) {</span>
<span class="p_add">+		pr_warn(&quot;mem%02u: %s range=[0x%016llx-0x%llx%016llx] (invalid)\n&quot;,</span>
<span class="p_add">+			i, efi_md_typeattr_format(buf, sizeof(buf), md),</span>
<span class="p_add">+			md-&gt;phys_addr, end_hi, end);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pr_warn(&quot;mem%02u: %s range=[0x%016llx-0x%016llx] (invalid)\n&quot;,</span>
<span class="p_add">+			i, efi_md_typeattr_format(buf, sizeof(buf), md),</span>
<span class="p_add">+			md-&gt;phys_addr, end);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init efi_clean_memmap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_memory_desc_t *out = efi.memmap.map;</span>
<span class="p_add">+	const efi_memory_desc_t *in = out;</span>
<span class="p_add">+	const efi_memory_desc_t *end = efi.memmap.map_end;</span>
<span class="p_add">+	int i, n_removal;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = n_removal = 0; in &lt; end; i++) {</span>
<span class="p_add">+		if (efi_memmap_entry_valid(in, i)) {</span>
<span class="p_add">+			if (out != in)</span>
<span class="p_add">+				memcpy(out, in, efi.memmap.desc_size);</span>
<span class="p_add">+			out = (void *)out + efi.memmap.desc_size;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			n_removal++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		in = (void *)in + efi.memmap.desc_size;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (n_removal &gt; 0) {</span>
<span class="p_add">+		u64 size = efi.memmap.nr_map - n_removal;</span>
<span class="p_add">+</span>
<span class="p_add">+		pr_warn(&quot;Removing %d invalid memory map entries.\n&quot;, n_removal);</span>
<span class="p_add">+		efi_memmap_install(efi.memmap.phys_map, size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init efi_print_memmap(void)
 {
 	efi_memory_desc_t *md;
<span class="p_chunk">@@ -472,6 +536,8 @@</span> <span class="p_context"> void __init efi_init(void)</span>
 		}
 	}
 
<span class="p_add">+	efi_clean_memmap();</span>
<span class="p_add">+</span>
 	if (efi_enabled(EFI_DBG))
 		efi_print_memmap();
 }
<span class="p_header">diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c</span>
<span class="p_header">index 10aca63a50d7..30031d5293c4 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/quirks.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/quirks.c</span>
<span class="p_chunk">@@ -214,7 +214,7 @@</span> <span class="p_context"> void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size)</span>
 
 	new_size = efi.memmap.desc_size * num_entries;
 
<span class="p_del">-	new_phys = memblock_alloc(new_size, 0);</span>
<span class="p_add">+	new_phys = efi_memmap_alloc(num_entries);</span>
 	if (!new_phys) {
 		pr_err(&quot;Could not allocate boot services memmap\n&quot;);
 		return;
<span class="p_chunk">@@ -355,7 +355,7 @@</span> <span class="p_context"> void __init efi_free_boot_services(void)</span>
 	}
 
 	new_size = efi.memmap.desc_size * num_entries;
<span class="p_del">-	new_phys = memblock_alloc(new_size, 0);</span>
<span class="p_add">+	new_phys = efi_memmap_alloc(num_entries);</span>
 	if (!new_phys) {
 		pr_err(&quot;Failed to allocate new EFI memmap\n&quot;);
 		return;
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index ad459e4e8071..81caceb96c3c 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -895,7 +895,7 @@</span> <span class="p_context"> static int blk_mq_hctx_next_cpu(struct blk_mq_hw_ctx *hctx)</span>
 		return WORK_CPU_UNBOUND;
 
 	if (--hctx-&gt;next_cpu_batch &lt;= 0) {
<span class="p_del">-		int cpu = hctx-&gt;next_cpu, next_cpu;</span>
<span class="p_add">+		int next_cpu;</span>
 
 		next_cpu = cpumask_next(hctx-&gt;next_cpu, hctx-&gt;cpumask);
 		if (next_cpu &gt;= nr_cpu_ids)
<span class="p_chunk">@@ -903,8 +903,6 @@</span> <span class="p_context"> static int blk_mq_hctx_next_cpu(struct blk_mq_hw_ctx *hctx)</span>
 
 		hctx-&gt;next_cpu = next_cpu;
 		hctx-&gt;next_cpu_batch = BLK_MQ_CPU_WORK_BATCH;
<span class="p_del">-</span>
<span class="p_del">-		return cpu;</span>
 	}
 
 	return hctx-&gt;next_cpu;
<span class="p_header">diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c</span>
<span class="p_header">index 5e24d880306c..3ab6807773ee 100644</span>
<span class="p_header">--- a/block/cfq-iosched.c</span>
<span class="p_header">+++ b/block/cfq-iosched.c</span>
<span class="p_chunk">@@ -1596,7 +1596,7 @@</span> <span class="p_context"> static struct blkcg_policy_data *cfq_cpd_alloc(gfp_t gfp)</span>
 {
 	struct cfq_group_data *cgd;
 
<span class="p_del">-	cgd = kzalloc(sizeof(*cgd), GFP_KERNEL);</span>
<span class="p_add">+	cgd = kzalloc(sizeof(*cgd), gfp);</span>
 	if (!cgd)
 		return NULL;
 	return &amp;cgd-&gt;cpd;
<span class="p_header">diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c</span>
<span class="p_header">index 0d099a24f776..e53bef6cf53c 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/ghes.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/ghes.c</span>
<span class="p_chunk">@@ -852,6 +852,8 @@</span> <span class="p_context"> static int ghes_notify_nmi(unsigned int cmd, struct pt_regs *regs)</span>
 		if (ghes_read_estatus(ghes, 1)) {
 			ghes_clear_estatus(ghes);
 			continue;
<span class="p_add">+		} else {</span>
<span class="p_add">+			ret = NMI_HANDLED;</span>
 		}
 
 		sev = ghes_severity(ghes-&gt;estatus-&gt;error_severity);
<span class="p_chunk">@@ -863,12 +865,11 @@</span> <span class="p_context"> static int ghes_notify_nmi(unsigned int cmd, struct pt_regs *regs)</span>
 
 		__process_error(ghes);
 		ghes_clear_estatus(ghes);
<span class="p_del">-</span>
<span class="p_del">-		ret = NMI_HANDLED;</span>
 	}
 
 #ifdef CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG
<span class="p_del">-	irq_work_queue(&amp;ghes_proc_irq_work);</span>
<span class="p_add">+	if (ret == NMI_HANDLED)</span>
<span class="p_add">+		irq_work_queue(&amp;ghes_proc_irq_work);</span>
 #endif
 	atomic_dec(&amp;ghes_in_nmi);
 	return ret;
<span class="p_header">diff --git a/drivers/acpi/cppc_acpi.c b/drivers/acpi/cppc_acpi.c</span>
<span class="p_header">index d0d0504b7c89..e0ea8f56d2bf 100644</span>
<span class="p_header">--- a/drivers/acpi/cppc_acpi.c</span>
<span class="p_header">+++ b/drivers/acpi/cppc_acpi.c</span>
<span class="p_chunk">@@ -784,8 +784,10 @@</span> <span class="p_context"> int acpi_cppc_processor_probe(struct acpi_processor *pr)</span>
 
 	/* Add per logical CPU nodes for reading its feedback counters. */
 	cpu_dev = get_cpu_device(pr-&gt;id);
<span class="p_del">-	if (!cpu_dev)</span>
<span class="p_add">+	if (!cpu_dev) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
 		goto out_free;
<span class="p_add">+	}</span>
 
 	ret = kobject_init_and_add(&amp;cpc_ptr-&gt;kobj, &amp;cppc_ktype, &amp;cpu_dev-&gt;kobj,
 			&quot;acpi_cppc&quot;);
<span class="p_header">diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c</span>
<span class="p_header">index 5545a679abd8..3c3b8f601469 100644</span>
<span class="p_header">--- a/drivers/block/virtio_blk.c</span>
<span class="p_header">+++ b/drivers/block/virtio_blk.c</span>
<span class="p_chunk">@@ -56,6 +56,7 @@</span> <span class="p_context"> struct virtblk_req {</span>
 	struct virtio_blk_outhdr out_hdr;
 	struct virtio_scsi_inhdr in_hdr;
 	u8 status;
<span class="p_add">+	u8 sense[SCSI_SENSE_BUFFERSIZE];</span>
 	struct scatterlist sg[];
 };
 
<span class="p_chunk">@@ -102,7 +103,8 @@</span> <span class="p_context"> static int __virtblk_add_req(struct virtqueue *vq,</span>
 	}
 
 	if (type == cpu_to_virtio32(vq-&gt;vdev, VIRTIO_BLK_T_SCSI_CMD)) {
<span class="p_del">-		sg_init_one(&amp;sense, vbr-&gt;req-&gt;sense, SCSI_SENSE_BUFFERSIZE);</span>
<span class="p_add">+		memcpy(vbr-&gt;sense, vbr-&gt;req-&gt;sense, SCSI_SENSE_BUFFERSIZE);</span>
<span class="p_add">+		sg_init_one(&amp;sense, vbr-&gt;sense, SCSI_SENSE_BUFFERSIZE);</span>
 		sgs[num_out + num_in++] = &amp;sense;
 		sg_init_one(&amp;inhdr, &amp;vbr-&gt;in_hdr, sizeof(vbr-&gt;in_hdr));
 		sgs[num_out + num_in++] = &amp;inhdr;
<span class="p_header">diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c</span>
<span class="p_header">index 5497f7fc44d0..d2ef51ca9cf4 100644</span>
<span class="p_header">--- a/drivers/block/zram/zram_drv.c</span>
<span class="p_header">+++ b/drivers/block/zram/zram_drv.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/genhd.h&gt;
 #include &lt;linux/highmem.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/backing-dev.h&gt;</span>
 #include &lt;linux/string.h&gt;
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/err.h&gt;
<span class="p_chunk">@@ -111,6 +112,14 @@</span> <span class="p_context"> static inline bool is_partial_io(struct bio_vec *bvec)</span>
 	return bvec-&gt;bv_len != PAGE_SIZE;
 }
 
<span class="p_add">+static void zram_revalidate_disk(struct zram *zram)</span>
<span class="p_add">+{</span>
<span class="p_add">+	revalidate_disk(zram-&gt;disk);</span>
<span class="p_add">+	/* revalidate_disk reset the BDI_CAP_STABLE_WRITES so set again */</span>
<span class="p_add">+	zram-&gt;disk-&gt;queue-&gt;backing_dev_info.capabilities |=</span>
<span class="p_add">+		BDI_CAP_STABLE_WRITES;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Check if request is within bounds and aligned on zram logical blocks.
  */
<span class="p_chunk">@@ -1094,15 +1103,9 @@</span> <span class="p_context"> static ssize_t disksize_store(struct device *dev,</span>
 	zram-&gt;comp = comp;
 	zram-&gt;disksize = disksize;
 	set_capacity(zram-&gt;disk, zram-&gt;disksize &gt;&gt; SECTOR_SHIFT);
<span class="p_add">+	zram_revalidate_disk(zram);</span>
 	up_write(&amp;zram-&gt;init_lock);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Revalidate disk out of the init_lock to avoid lockdep splat.</span>
<span class="p_del">-	 * It&#39;s okay because disk&#39;s capacity is protected by init_lock</span>
<span class="p_del">-	 * so that revalidate_disk always sees up-to-date capacity.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	revalidate_disk(zram-&gt;disk);</span>
<span class="p_del">-</span>
 	return len;
 
 out_destroy_comp:
<span class="p_chunk">@@ -1148,7 +1151,7 @@</span> <span class="p_context"> static ssize_t reset_store(struct device *dev,</span>
 	/* Make sure all the pending I/O are finished */
 	fsync_bdev(bdev);
 	zram_reset_device(zram);
<span class="p_del">-	revalidate_disk(zram-&gt;disk);</span>
<span class="p_add">+	zram_revalidate_disk(zram);</span>
 	bdput(bdev);
 
 	mutex_lock(&amp;bdev-&gt;bd_mutex);
<span class="p_header">diff --git a/drivers/bus/vexpress-config.c b/drivers/bus/vexpress-config.c</span>
<span class="p_header">index 9efdf1de4035..493e7b9fc813 100644</span>
<span class="p_header">--- a/drivers/bus/vexpress-config.c</span>
<span class="p_header">+++ b/drivers/bus/vexpress-config.c</span>
<span class="p_chunk">@@ -171,6 +171,7 @@</span> <span class="p_context"> static int vexpress_config_populate(struct device_node *node)</span>
 {
 	struct device_node *bridge;
 	struct device *parent;
<span class="p_add">+	int ret;</span>
 
 	bridge = of_parse_phandle(node, &quot;arm,vexpress,config-bridge&quot;, 0);
 	if (!bridge)
<span class="p_chunk">@@ -182,7 +183,11 @@</span> <span class="p_context"> static int vexpress_config_populate(struct device_node *node)</span>
 	if (WARN_ON(!parent))
 		return -ENODEV;
 
<span class="p_del">-	return of_platform_populate(node, NULL, NULL, parent);</span>
<span class="p_add">+	ret = of_platform_populate(node, NULL, NULL, parent);</span>
<span class="p_add">+</span>
<span class="p_add">+	put_device(parent);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int __init vexpress_config_init(void)
<span class="p_header">diff --git a/drivers/char/mem.c b/drivers/char/mem.c</span>
<span class="p_header">index 5bb1985ec484..6d9cc2d39d22 100644</span>
<span class="p_header">--- a/drivers/char/mem.c</span>
<span class="p_header">+++ b/drivers/char/mem.c</span>
<span class="p_chunk">@@ -381,9 +381,6 @@</span> <span class="p_context"> static ssize_t read_kmem(struct file *file, char __user *buf,</span>
 	char *kbuf; /* k-addr because vread() takes vmlist_lock rwlock */
 	int err = 0;
 
<span class="p_del">-	if (!pfn_valid(PFN_DOWN(p)))</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
 	read = 0;
 	if (p &lt; (unsigned long) high_memory) {
 		low_count = count;
<span class="p_chunk">@@ -412,6 +409,8 @@</span> <span class="p_context"> static ssize_t read_kmem(struct file *file, char __user *buf,</span>
 			 * by the kernel or data corruption may occur
 			 */
 			kbuf = xlate_dev_kmem_ptr((void *)p);
<span class="p_add">+			if (!virt_addr_valid(kbuf))</span>
<span class="p_add">+				return -ENXIO;</span>
 
 			if (copy_to_user(buf, kbuf, sz))
 				return -EFAULT;
<span class="p_chunk">@@ -482,6 +481,8 @@</span> <span class="p_context"> static ssize_t do_write_kmem(unsigned long p, const char __user *buf,</span>
 		 * corruption may occur.
 		 */
 		ptr = xlate_dev_kmem_ptr((void *)p);
<span class="p_add">+		if (!virt_addr_valid(ptr))</span>
<span class="p_add">+			return -ENXIO;</span>
 
 		copied = copy_from_user(ptr, buf, sz);
 		if (copied) {
<span class="p_chunk">@@ -512,9 +513,6 @@</span> <span class="p_context"> static ssize_t write_kmem(struct file *file, const char __user *buf,</span>
 	char *kbuf; /* k-addr because vwrite() takes vmlist_lock rwlock */
 	int err = 0;
 
<span class="p_del">-	if (!pfn_valid(PFN_DOWN(p)))</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
 	if (p &lt; (unsigned long) high_memory) {
 		unsigned long to_write = min_t(unsigned long, count,
 					       (unsigned long)high_memory - p);
<span class="p_header">diff --git a/drivers/cpufreq/powernv-cpufreq.c b/drivers/cpufreq/powernv-cpufreq.c</span>
<span class="p_header">index d3ffde806629..a84724eabfb8 100644</span>
<span class="p_header">--- a/drivers/cpufreq/powernv-cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/powernv-cpufreq.c</span>
<span class="p_chunk">@@ -647,8 +647,14 @@</span> <span class="p_context"> static int powernv_cpufreq_target_index(struct cpufreq_policy *policy,</span>
 	if (unlikely(rebooting) &amp;&amp; new_index != get_nominal_index())
 		return 0;
 
<span class="p_del">-	if (!throttled)</span>
<span class="p_add">+	if (!throttled) {</span>
<span class="p_add">+		/* we don&#39;t want to be preempted while</span>
<span class="p_add">+		 * checking if the CPU frequency has been throttled</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		preempt_disable();</span>
 		powernv_cpufreq_throttle_check(NULL);
<span class="p_add">+		preempt_enable();</span>
<span class="p_add">+	}</span>
 
 	cur_msec = jiffies_to_msecs(get_jiffies_64());
 
<span class="p_header">diff --git a/drivers/dma/omap-dma.c b/drivers/dma/omap-dma.c</span>
<span class="p_header">index 7ca27d4b1c54..6b16ce390dce 100644</span>
<span class="p_header">--- a/drivers/dma/omap-dma.c</span>
<span class="p_header">+++ b/drivers/dma/omap-dma.c</span>
<span class="p_chunk">@@ -1339,6 +1339,7 @@</span> <span class="p_context"> static int omap_dma_probe(struct platform_device *pdev)</span>
 	struct omap_dmadev *od;
 	struct resource *res;
 	int rc, i, irq;
<span class="p_add">+	u32 lch_count;</span>
 
 	od = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*od), GFP_KERNEL);
 	if (!od)
<span class="p_chunk">@@ -1381,20 +1382,31 @@</span> <span class="p_context"> static int omap_dma_probe(struct platform_device *pdev)</span>
 	spin_lock_init(&amp;od-&gt;lock);
 	spin_lock_init(&amp;od-&gt;irq_lock);
 
<span class="p_del">-	if (!pdev-&gt;dev.of_node) {</span>
<span class="p_del">-		od-&gt;dma_requests = od-&gt;plat-&gt;dma_attr-&gt;lch_count;</span>
<span class="p_del">-		if (unlikely(!od-&gt;dma_requests))</span>
<span class="p_del">-			od-&gt;dma_requests = OMAP_SDMA_REQUESTS;</span>
<span class="p_del">-	} else if (of_property_read_u32(pdev-&gt;dev.of_node, &quot;dma-requests&quot;,</span>
<span class="p_del">-					&amp;od-&gt;dma_requests)) {</span>
<span class="p_add">+	/* Number of DMA requests */</span>
<span class="p_add">+	od-&gt;dma_requests = OMAP_SDMA_REQUESTS;</span>
<span class="p_add">+	if (pdev-&gt;dev.of_node &amp;&amp; of_property_read_u32(pdev-&gt;dev.of_node,</span>
<span class="p_add">+						      &quot;dma-requests&quot;,</span>
<span class="p_add">+						      &amp;od-&gt;dma_requests)) {</span>
 		dev_info(&amp;pdev-&gt;dev,
 			 &quot;Missing dma-requests property, using %u.\n&quot;,
 			 OMAP_SDMA_REQUESTS);
<span class="p_del">-		od-&gt;dma_requests = OMAP_SDMA_REQUESTS;</span>
 	}
 
<span class="p_del">-	od-&gt;lch_map = devm_kcalloc(&amp;pdev-&gt;dev, od-&gt;dma_requests,</span>
<span class="p_del">-				   sizeof(*od-&gt;lch_map), GFP_KERNEL);</span>
<span class="p_add">+	/* Number of available logical channels */</span>
<span class="p_add">+	if (!pdev-&gt;dev.of_node) {</span>
<span class="p_add">+		lch_count = od-&gt;plat-&gt;dma_attr-&gt;lch_count;</span>
<span class="p_add">+		if (unlikely(!lch_count))</span>
<span class="p_add">+			lch_count = OMAP_SDMA_CHANNELS;</span>
<span class="p_add">+	} else if (of_property_read_u32(pdev-&gt;dev.of_node, &quot;dma-channels&quot;,</span>
<span class="p_add">+					&amp;lch_count)) {</span>
<span class="p_add">+		dev_info(&amp;pdev-&gt;dev,</span>
<span class="p_add">+			 &quot;Missing dma-channels property, using %u.\n&quot;,</span>
<span class="p_add">+			 OMAP_SDMA_CHANNELS);</span>
<span class="p_add">+		lch_count = OMAP_SDMA_CHANNELS;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	od-&gt;lch_map = devm_kcalloc(&amp;pdev-&gt;dev, lch_count, sizeof(*od-&gt;lch_map),</span>
<span class="p_add">+				   GFP_KERNEL);</span>
 	if (!od-&gt;lch_map)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/extcon/extcon.c b/drivers/extcon/extcon.c</span>
<span class="p_header">index 78298460d168..7c1e3a7b14e0 100644</span>
<span class="p_header">--- a/drivers/extcon/extcon.c</span>
<span class="p_header">+++ b/drivers/extcon/extcon.c</span>
<span class="p_chunk">@@ -453,7 +453,7 @@</span> <span class="p_context"> int extcon_sync(struct extcon_dev *edev, unsigned int id)</span>
 		dev_err(&amp;edev-&gt;dev, &quot;out of memory in extcon_set_state\n&quot;);
 		kobject_uevent(&amp;edev-&gt;dev.kobj, KOBJ_CHANGE);
 
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return -ENOMEM;</span>
 	}
 
 	length = name_show(&amp;edev-&gt;dev, NULL, prop_buf);
<span class="p_header">diff --git a/drivers/firmware/efi/fake_mem.c b/drivers/firmware/efi/fake_mem.c</span>
<span class="p_header">index 520a40e5e0e4..6c7d60c239b5 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/fake_mem.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/fake_mem.c</span>
<span class="p_chunk">@@ -71,8 +71,7 @@</span> <span class="p_context"> void __init efi_fake_memmap(void)</span>
 	}
 
 	/* allocate memory for new EFI memmap */
<span class="p_del">-	new_memmap_phy = memblock_alloc(efi.memmap.desc_size * new_nr_map,</span>
<span class="p_del">-					PAGE_SIZE);</span>
<span class="p_add">+	new_memmap_phy = efi_memmap_alloc(new_nr_map);</span>
 	if (!new_memmap_phy)
 		return;
 
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h</span>
<span class="p_header">index ee49cd23ee63..fac67992bede 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/efistub.h</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/efistub.h</span>
<span class="p_chunk">@@ -30,14 +30,6 @@</span> <span class="p_context"> efi_status_t efi_file_close(void *handle);</span>
 
 unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
 
<span class="p_del">-efi_status_t update_fdt(efi_system_table_t *sys_table, void *orig_fdt,</span>
<span class="p_del">-			unsigned long orig_fdt_size,</span>
<span class="p_del">-			void *fdt, int new_fdt_size, char *cmdline_ptr,</span>
<span class="p_del">-			u64 initrd_addr, u64 initrd_size,</span>
<span class="p_del">-			efi_memory_desc_t *memory_map,</span>
<span class="p_del">-			unsigned long map_size, unsigned long desc_size,</span>
<span class="p_del">-			u32 desc_ver);</span>
<span class="p_del">-</span>
 efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
 					    void *handle,
 					    unsigned long *new_fdt_addr,
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/fdt.c b/drivers/firmware/efi/libstub/fdt.c</span>
<span class="p_header">index a6a93116a8f0..921dfa047202 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/fdt.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/fdt.c</span>
<span class="p_chunk">@@ -16,13 +16,10 @@</span> <span class="p_context"></span>
 
 #include &quot;efistub.h&quot;
 
<span class="p_del">-efi_status_t update_fdt(efi_system_table_t *sys_table, void *orig_fdt,</span>
<span class="p_del">-			unsigned long orig_fdt_size,</span>
<span class="p_del">-			void *fdt, int new_fdt_size, char *cmdline_ptr,</span>
<span class="p_del">-			u64 initrd_addr, u64 initrd_size,</span>
<span class="p_del">-			efi_memory_desc_t *memory_map,</span>
<span class="p_del">-			unsigned long map_size, unsigned long desc_size,</span>
<span class="p_del">-			u32 desc_ver)</span>
<span class="p_add">+static efi_status_t update_fdt(efi_system_table_t *sys_table, void *orig_fdt,</span>
<span class="p_add">+			       unsigned long orig_fdt_size,</span>
<span class="p_add">+			       void *fdt, int new_fdt_size, char *cmdline_ptr,</span>
<span class="p_add">+			       u64 initrd_addr, u64 initrd_size)</span>
 {
 	int node, num_rsv;
 	int status;
<span class="p_chunk">@@ -101,25 +98,23 @@</span> <span class="p_context"> efi_status_t update_fdt(efi_system_table_t *sys_table, void *orig_fdt,</span>
 	if (status)
 		goto fdt_set_fail;
 
<span class="p_del">-	fdt_val64 = cpu_to_fdt64((u64)(unsigned long)memory_map);</span>
<span class="p_add">+	fdt_val64 = U64_MAX; /* placeholder */</span>
 	status = fdt_setprop(fdt, node, &quot;linux,uefi-mmap-start&quot;,
 			     &amp;fdt_val64,  sizeof(fdt_val64));
 	if (status)
 		goto fdt_set_fail;
 
<span class="p_del">-	fdt_val32 = cpu_to_fdt32(map_size);</span>
<span class="p_add">+	fdt_val32 = U32_MAX; /* placeholder */</span>
 	status = fdt_setprop(fdt, node, &quot;linux,uefi-mmap-size&quot;,
 			     &amp;fdt_val32,  sizeof(fdt_val32));
 	if (status)
 		goto fdt_set_fail;
 
<span class="p_del">-	fdt_val32 = cpu_to_fdt32(desc_size);</span>
 	status = fdt_setprop(fdt, node, &quot;linux,uefi-mmap-desc-size&quot;,
 			     &amp;fdt_val32, sizeof(fdt_val32));
 	if (status)
 		goto fdt_set_fail;
 
<span class="p_del">-	fdt_val32 = cpu_to_fdt32(desc_ver);</span>
 	status = fdt_setprop(fdt, node, &quot;linux,uefi-mmap-desc-ver&quot;,
 			     &amp;fdt_val32, sizeof(fdt_val32));
 	if (status)
<span class="p_chunk">@@ -148,6 +143,43 @@</span> <span class="p_context"> efi_status_t update_fdt(efi_system_table_t *sys_table, void *orig_fdt,</span>
 	return EFI_LOAD_ERROR;
 }
 
<span class="p_add">+static efi_status_t update_fdt_memmap(void *fdt, struct efi_boot_memmap *map)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int node = fdt_path_offset(fdt, &quot;/chosen&quot;);</span>
<span class="p_add">+	u64 fdt_val64;</span>
<span class="p_add">+	u32 fdt_val32;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (node &lt; 0)</span>
<span class="p_add">+		return EFI_LOAD_ERROR;</span>
<span class="p_add">+</span>
<span class="p_add">+	fdt_val64 = cpu_to_fdt64((unsigned long)*map-&gt;map);</span>
<span class="p_add">+	err = fdt_setprop_inplace(fdt, node, &quot;linux,uefi-mmap-start&quot;,</span>
<span class="p_add">+				  &amp;fdt_val64, sizeof(fdt_val64));</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return EFI_LOAD_ERROR;</span>
<span class="p_add">+</span>
<span class="p_add">+	fdt_val32 = cpu_to_fdt32(*map-&gt;map_size);</span>
<span class="p_add">+	err = fdt_setprop_inplace(fdt, node, &quot;linux,uefi-mmap-size&quot;,</span>
<span class="p_add">+				  &amp;fdt_val32, sizeof(fdt_val32));</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return EFI_LOAD_ERROR;</span>
<span class="p_add">+</span>
<span class="p_add">+	fdt_val32 = cpu_to_fdt32(*map-&gt;desc_size);</span>
<span class="p_add">+	err = fdt_setprop_inplace(fdt, node, &quot;linux,uefi-mmap-desc-size&quot;,</span>
<span class="p_add">+				  &amp;fdt_val32, sizeof(fdt_val32));</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return EFI_LOAD_ERROR;</span>
<span class="p_add">+</span>
<span class="p_add">+	fdt_val32 = cpu_to_fdt32(*map-&gt;desc_ver);</span>
<span class="p_add">+	err = fdt_setprop_inplace(fdt, node, &quot;linux,uefi-mmap-desc-ver&quot;,</span>
<span class="p_add">+				  &amp;fdt_val32, sizeof(fdt_val32));</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return EFI_LOAD_ERROR;</span>
<span class="p_add">+</span>
<span class="p_add">+	return EFI_SUCCESS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifndef EFI_FDT_ALIGN
 #define EFI_FDT_ALIGN EFI_PAGE_SIZE
 #endif
<span class="p_chunk">@@ -243,20 +275,10 @@</span> <span class="p_context"> efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,</span>
 			goto fail;
 		}
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Now that we have done our final memory allocation (and free)</span>
<span class="p_del">-		 * we can get the memory map key  needed for</span>
<span class="p_del">-		 * exit_boot_services().</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		status = efi_get_memory_map(sys_table, &amp;map);</span>
<span class="p_del">-		if (status != EFI_SUCCESS)</span>
<span class="p_del">-			goto fail_free_new_fdt;</span>
<span class="p_del">-</span>
 		status = update_fdt(sys_table,
 				    (void *)fdt_addr, fdt_size,
 				    (void *)*new_fdt_addr, new_fdt_size,
<span class="p_del">-				    cmdline_ptr, initrd_addr, initrd_size,</span>
<span class="p_del">-				    memory_map, map_size, desc_size, desc_ver);</span>
<span class="p_add">+				    cmdline_ptr, initrd_addr, initrd_size);</span>
 
 		/* Succeeding the first time is the expected case. */
 		if (status == EFI_SUCCESS)
<span class="p_chunk">@@ -266,20 +288,16 @@</span> <span class="p_context"> efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,</span>
 			/*
 			 * We need to allocate more space for the new
 			 * device tree, so free existing buffer that is
<span class="p_del">-			 * too small.  Also free memory map, as we will need</span>
<span class="p_del">-			 * to get new one that reflects the free/alloc we do</span>
<span class="p_del">-			 * on the device tree buffer.</span>
<span class="p_add">+			 * too small.</span>
 			 */
 			efi_free(sys_table, new_fdt_size, *new_fdt_addr);
<span class="p_del">-			sys_table-&gt;boottime-&gt;free_pool(memory_map);</span>
 			new_fdt_size += EFI_PAGE_SIZE;
 		} else {
 			pr_efi_err(sys_table, &quot;Unable to construct new device tree.\n&quot;);
<span class="p_del">-			goto fail_free_mmap;</span>
<span class="p_add">+			goto fail_free_new_fdt;</span>
 		}
 	}
 
<span class="p_del">-	sys_table-&gt;boottime-&gt;free_pool(memory_map);</span>
 	priv.runtime_map = runtime_map;
 	priv.runtime_entry_count = &amp;runtime_entry_count;
 	status = efi_exit_boot_services(sys_table, handle, &amp;map, &amp;priv,
<span class="p_chunk">@@ -288,6 +306,16 @@</span> <span class="p_context"> efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,</span>
 	if (status == EFI_SUCCESS) {
 		efi_set_virtual_address_map_t *svam;
 
<span class="p_add">+		status = update_fdt_memmap((void *)*new_fdt_addr, &amp;map);</span>
<span class="p_add">+		if (status != EFI_SUCCESS) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The kernel won&#39;t get far without the memory map, but</span>
<span class="p_add">+			 * may still be able to print something meaningful so</span>
<span class="p_add">+			 * return success here.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			return EFI_SUCCESS;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* Install the new virtual address map */
 		svam = sys_table-&gt;runtime-&gt;set_virtual_address_map;
 		status = svam(runtime_entry_count * desc_size, desc_size,
<span class="p_chunk">@@ -319,9 +347,6 @@</span> <span class="p_context"> efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,</span>
 
 	pr_efi_err(sys_table, &quot;Exit boot services failed.\n&quot;);
 
<span class="p_del">-fail_free_mmap:</span>
<span class="p_del">-	sys_table-&gt;boottime-&gt;free_pool(memory_map);</span>
<span class="p_del">-</span>
 fail_free_new_fdt:
 	efi_free(sys_table, new_fdt_size, *new_fdt_addr);
 
<span class="p_header">diff --git a/drivers/firmware/efi/memmap.c b/drivers/firmware/efi/memmap.c</span>
<span class="p_header">index f03ddecd232b..78686443cb37 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/memmap.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/memmap.c</span>
<span class="p_chunk">@@ -9,6 +9,44 @@</span> <span class="p_context"></span>
 #include &lt;linux/efi.h&gt;
 #include &lt;linux/io.h&gt;
 #include &lt;asm/early_ioremap.h&gt;
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t __init __efi_memmap_alloc_early(unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return memblock_alloc(size, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t __init __efi_memmap_alloc_late(unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int order = get_order(size);</span>
<span class="p_add">+	struct page *p = alloc_pages(GFP_KERNEL, order);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!p)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return PFN_PHYS(page_to_pfn(p));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_memmap_alloc - Allocate memory for the EFI memory map</span>
<span class="p_add">+ * @num_entries: Number of entries in the allocated map.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Depending on whether mm_init() has already been invoked or not,</span>
<span class="p_add">+ * either memblock or &quot;normal&quot; page allocation is used.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns the physical address of the allocated memory map on</span>
<span class="p_add">+ * success, zero on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+phys_addr_t __init efi_memmap_alloc(unsigned int num_entries)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long size = num_entries * efi.memmap.desc_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (slab_is_available())</span>
<span class="p_add">+		return __efi_memmap_alloc_late(size);</span>
<span class="p_add">+</span>
<span class="p_add">+	return __efi_memmap_alloc_early(size);</span>
<span class="p_add">+}</span>
 
 /**
  * __efi_memmap_init - Common code for mapping the EFI memory map
<span class="p_header">diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c</span>
<span class="p_header">index 90621fb93941..92159313361b 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib.c</span>
<span class="p_chunk">@@ -1317,12 +1317,12 @@</span> <span class="p_context"> void gpiochip_remove(struct gpio_chip *chip)</span>
 
 	/* FIXME: should the legacy sysfs handling be moved to gpio_device? */
 	gpiochip_sysfs_unregister(gdev);
<span class="p_add">+	gpiochip_free_hogs(chip);</span>
 	/* Numb the device, cancelling all outstanding operations */
 	gdev-&gt;chip = NULL;
 	gpiochip_irqchip_remove(chip);
 	acpi_gpiochip_remove(chip);
 	gpiochip_remove_pin_ranges(chip);
<span class="p_del">-	gpiochip_free_hogs(chip);</span>
 	of_gpiochip_remove(chip);
 	/*
 	 * We accept no more calls into the driver from this point, so
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/si_dpm.c b/drivers/gpu/drm/amd/amdgpu/si_dpm.c</span>
<span class="p_header">index 6d2ea76f4eb6..b447a01ab21a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/si_dpm.c</span>
<span class="p_chunk">@@ -56,7 +56,6 @@</span> <span class="p_context"></span>
 #define BIOS_SCRATCH_4                                    0x5cd
 
 MODULE_FIRMWARE(&quot;radeon/tahiti_smc.bin&quot;);
<span class="p_del">-MODULE_FIRMWARE(&quot;radeon/tahiti_k_smc.bin&quot;);</span>
 MODULE_FIRMWARE(&quot;radeon/pitcairn_smc.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/pitcairn_k_smc.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/verde_smc.bin&quot;);
<span class="p_chunk">@@ -3486,19 +3485,6 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct amdgpu_device *adev,</span>
 		    (adev-&gt;pdev-&gt;device == 0x6817) ||
 		    (adev-&gt;pdev-&gt;device == 0x6806))
 			max_mclk = 120000;
<span class="p_del">-	} else if (adev-&gt;asic_type == CHIP_VERDE) {</span>
<span class="p_del">-		if ((adev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6820) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6821) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6822) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x682A) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x682B)) {</span>
<span class="p_del">-			max_sclk = 75000;</span>
<span class="p_del">-			max_mclk = 80000;</span>
<span class="p_del">-		}</span>
 	} else if (adev-&gt;asic_type == CHIP_OLAND) {
 		if ((adev-&gt;pdev-&gt;revision == 0xC7) ||
 		    (adev-&gt;pdev-&gt;revision == 0x80) ||
<span class="p_chunk">@@ -7685,49 +7671,49 @@</span> <span class="p_context"> static int si_dpm_init_microcode(struct amdgpu_device *adev)</span>
 		chip_name = &quot;tahiti&quot;;
 		break;
 	case CHIP_PITCAIRN:
<span class="p_del">-		if ((adev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6810) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6811) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6816) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6817) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6806))</span>
<span class="p_add">+		if ((adev-&gt;pdev-&gt;revision == 0x81) &amp;&amp;</span>
<span class="p_add">+		    ((adev-&gt;pdev-&gt;device == 0x6810) ||</span>
<span class="p_add">+		    (adev-&gt;pdev-&gt;device == 0x6811)))</span>
 			chip_name = &quot;pitcairn_k&quot;;
 		else
 			chip_name = &quot;pitcairn&quot;;
 		break;
 	case CHIP_VERDE:
<span class="p_del">-		if ((adev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6820) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6821) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6822) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x682A) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x682B))</span>
<span class="p_add">+		if (((adev-&gt;pdev-&gt;device == 0x6820) &amp;&amp;</span>
<span class="p_add">+			((adev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;revision == 0x83))) ||</span>
<span class="p_add">+		    ((adev-&gt;pdev-&gt;device == 0x6821) &amp;&amp;</span>
<span class="p_add">+			((adev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;revision == 0x87))) ||</span>
<span class="p_add">+		    ((adev-&gt;pdev-&gt;revision == 0x87) &amp;&amp;</span>
<span class="p_add">+			((adev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x682b))))</span>
 			chip_name = &quot;verde_k&quot;;
 		else
 			chip_name = &quot;verde&quot;;
 		break;
 	case CHIP_OLAND:
<span class="p_del">-		if ((adev-&gt;pdev-&gt;revision == 0xC7) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0x80) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6604) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6605))</span>
<span class="p_add">+		if (((adev-&gt;pdev-&gt;revision == 0x81) &amp;&amp;</span>
<span class="p_add">+			((adev-&gt;pdev-&gt;device == 0x6600) ||</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x6604) ||</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x6605) ||</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x6610))) ||</span>
<span class="p_add">+		    ((adev-&gt;pdev-&gt;revision == 0x83) &amp;&amp;</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x6610)))</span>
 			chip_name = &quot;oland_k&quot;;
 		else
 			chip_name = &quot;oland&quot;;
 		break;
 	case CHIP_HAINAN:
<span class="p_del">-		if ((adev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;revision == 0xC3) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6664) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6665) ||</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;device == 0x6667))</span>
<span class="p_add">+		if (((adev-&gt;pdev-&gt;revision == 0x81) &amp;&amp;</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x6660)) ||</span>
<span class="p_add">+		    ((adev-&gt;pdev-&gt;revision == 0x83) &amp;&amp;</span>
<span class="p_add">+			((adev-&gt;pdev-&gt;device == 0x6660) ||</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x6663) ||</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x6665) ||</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x6667))) ||</span>
<span class="p_add">+		    ((adev-&gt;pdev-&gt;revision == 0xc3) &amp;&amp;</span>
<span class="p_add">+			(adev-&gt;pdev-&gt;device == 0x6665)))</span>
 			chip_name = &quot;hainan_k&quot;;
 		else
 			chip_name = &quot;hainan&quot;;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_atomic_helper.c b/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_header">index 21f992605541..338766c64c99 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_chunk">@@ -1253,8 +1253,10 @@</span> <span class="p_context"> int drm_atomic_helper_commit(struct drm_device *dev,</span>
 
 	if (!nonblock) {
 		ret = drm_atomic_helper_wait_for_fences(dev, state, true);
<span class="p_del">-		if (ret)</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			drm_atomic_helper_cleanup_planes(dev, state);</span>
 			return ret;
<span class="p_add">+		}</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/gpu/drm/drm_irq.c b/drivers/gpu/drm/drm_irq.c</span>
<span class="p_header">index b969a64a1514..48a6167f5e7b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_irq.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_irq.c</span>
<span class="p_chunk">@@ -952,8 +952,10 @@</span> <span class="p_context"> static u32 drm_vblank_count_and_time(struct drm_device *dev, unsigned int pipe,</span>
 	u32 vblank_count;
 	unsigned int seq;
 
<span class="p_del">-	if (WARN_ON(pipe &gt;= dev-&gt;num_crtcs))</span>
<span class="p_add">+	if (WARN_ON(pipe &gt;= dev-&gt;num_crtcs)) {</span>
<span class="p_add">+		*vblanktime = (struct timeval) { 0 };</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	do {
 		seq = read_seqbegin(&amp;vblank-&gt;seqlock);
<span class="p_header">diff --git a/drivers/gpu/drm/drm_mm.c b/drivers/gpu/drm/drm_mm.c</span>
<span class="p_header">index 11d44a1e0ab3..ee07bb4a57b7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_mm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_mm.c</span>
<span class="p_chunk">@@ -839,6 +839,7 @@</span> <span class="p_context"> void drm_mm_init(struct drm_mm * mm, u64 start, u64 size)</span>
 
 	/* Clever trick to avoid a special case in the free hole tracking. */
 	INIT_LIST_HEAD(&amp;mm-&gt;head_node.node_list);
<span class="p_add">+	mm-&gt;head_node.allocated = 0;</span>
 	mm-&gt;head_node.hole_follows = 1;
 	mm-&gt;head_node.scanned_block = 0;
 	mm-&gt;head_node.scanned_prev_free = 0;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index c9e83f39ec0a..869b29fe9ec4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -16749,7 +16749,6 @@</span> <span class="p_context"> static void intel_modeset_readout_hw_state(struct drm_device *dev)</span>
 
 	for_each_intel_crtc(dev, crtc) {
 		struct intel_crtc_state *crtc_state = crtc-&gt;config;
<span class="p_del">-		int pixclk = 0;</span>
 
 		__drm_atomic_helper_crtc_destroy_state(&amp;crtc_state-&gt;base);
 		memset(crtc_state, 0, sizeof(*crtc_state));
<span class="p_chunk">@@ -16761,23 +16760,9 @@</span> <span class="p_context"> static void intel_modeset_readout_hw_state(struct drm_device *dev)</span>
 		crtc-&gt;base.enabled = crtc_state-&gt;base.enable;
 		crtc-&gt;active = crtc_state-&gt;base.active;
 
<span class="p_del">-		if (crtc_state-&gt;base.active) {</span>
<span class="p_add">+		if (crtc_state-&gt;base.active)</span>
 			dev_priv-&gt;active_crtcs |= 1 &lt;&lt; crtc-&gt;pipe;
 
<span class="p_del">-			if (INTEL_GEN(dev_priv) &gt;= 9 || IS_BROADWELL(dev_priv))</span>
<span class="p_del">-				pixclk = ilk_pipe_pixel_rate(crtc_state);</span>
<span class="p_del">-			else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))</span>
<span class="p_del">-				pixclk = crtc_state-&gt;base.adjusted_mode.crtc_clock;</span>
<span class="p_del">-			else</span>
<span class="p_del">-				WARN_ON(dev_priv-&gt;display.modeset_calc_cdclk);</span>
<span class="p_del">-</span>
<span class="p_del">-			/* pixel rate mustn&#39;t exceed 95% of cdclk with IPS on BDW */</span>
<span class="p_del">-			if (IS_BROADWELL(dev_priv) &amp;&amp; crtc_state-&gt;ips_enabled)</span>
<span class="p_del">-				pixclk = DIV_ROUND_UP(pixclk * 100, 95);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		dev_priv-&gt;min_pixclk[crtc-&gt;pipe] = pixclk;</span>
<span class="p_del">-</span>
 		readout_plane_state(crtc);
 
 		DRM_DEBUG_KMS(&quot;[CRTC:%d:%s] hw state readout: %s\n&quot;,
<span class="p_chunk">@@ -16851,6 +16836,8 @@</span> <span class="p_context"> static void intel_modeset_readout_hw_state(struct drm_device *dev)</span>
 	}
 
 	for_each_intel_crtc(dev, crtc) {
<span class="p_add">+		int pixclk = 0;</span>
<span class="p_add">+</span>
 		crtc-&gt;base.hwmode = crtc-&gt;config-&gt;base.adjusted_mode;
 
 		memset(&amp;crtc-&gt;base.mode, 0, sizeof(crtc-&gt;base.mode));
<span class="p_chunk">@@ -16878,10 +16865,23 @@</span> <span class="p_context"> static void intel_modeset_readout_hw_state(struct drm_device *dev)</span>
 			 */
 			crtc-&gt;base.state-&gt;mode.private_flags = I915_MODE_FLAG_INHERITED;
 
<span class="p_add">+			if (INTEL_GEN(dev_priv) &gt;= 9 || IS_BROADWELL(dev_priv))</span>
<span class="p_add">+				pixclk = ilk_pipe_pixel_rate(crtc-&gt;config);</span>
<span class="p_add">+			else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))</span>
<span class="p_add">+				pixclk = crtc-&gt;config-&gt;base.adjusted_mode.crtc_clock;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				WARN_ON(dev_priv-&gt;display.modeset_calc_cdclk);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* pixel rate mustn&#39;t exceed 95% of cdclk with IPS on BDW */</span>
<span class="p_add">+			if (IS_BROADWELL(dev_priv) &amp;&amp; crtc-&gt;config-&gt;ips_enabled)</span>
<span class="p_add">+				pixclk = DIV_ROUND_UP(pixclk * 100, 95);</span>
<span class="p_add">+</span>
 			drm_calc_timestamping_constants(&amp;crtc-&gt;base, &amp;crtc-&gt;base.hwmode);
 			update_scanline_offset(crtc);
 		}
 
<span class="p_add">+		dev_priv-&gt;min_pixclk[crtc-&gt;pipe] = pixclk;</span>
<span class="p_add">+</span>
 		intel_pipe_config_sanity_check(dev_priv, crtc-&gt;config);
 	}
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index 985cb31f4b44..e559a45ff1f7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -2955,24 +2955,10 @@</span> <span class="p_context"> intel_enable_sagv(struct drm_i915_private *dev_priv)</span>
 	return 0;
 }
 
<span class="p_del">-static int</span>
<span class="p_del">-intel_do_sagv_disable(struct drm_i915_private *dev_priv)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	uint32_t temp = GEN9_SAGV_DISABLE;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = sandybridge_pcode_read(dev_priv, GEN9_PCODE_SAGV_CONTROL,</span>
<span class="p_del">-				     &amp;temp);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return temp &amp; GEN9_SAGV_IS_DISABLED;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int
 intel_disable_sagv(struct drm_i915_private *dev_priv)
 {
<span class="p_del">-	int ret, result;</span>
<span class="p_add">+	int ret;</span>
 
 	if (!intel_has_sagv(dev_priv))
 		return 0;
<span class="p_chunk">@@ -2984,25 +2970,23 @@</span> <span class="p_context"> intel_disable_sagv(struct drm_i915_private *dev_priv)</span>
 	mutex_lock(&amp;dev_priv-&gt;rps.hw_lock);
 
 	/* bspec says to keep retrying for at least 1 ms */
<span class="p_del">-	ret = wait_for(result = intel_do_sagv_disable(dev_priv), 1);</span>
<span class="p_add">+	ret = skl_pcode_request(dev_priv, GEN9_PCODE_SAGV_CONTROL,</span>
<span class="p_add">+				GEN9_SAGV_DISABLE,</span>
<span class="p_add">+				GEN9_SAGV_IS_DISABLED, GEN9_SAGV_IS_DISABLED,</span>
<span class="p_add">+				1);</span>
 	mutex_unlock(&amp;dev_priv-&gt;rps.hw_lock);
 
<span class="p_del">-	if (ret == -ETIMEDOUT) {</span>
<span class="p_del">-		DRM_ERROR(&quot;Request to disable SAGV timed out\n&quot;);</span>
<span class="p_del">-		return -ETIMEDOUT;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/*
 	 * Some skl systems, pre-release machines in particular,
 	 * don&#39;t actually have an SAGV.
 	 */
<span class="p_del">-	if (IS_SKYLAKE(dev_priv) &amp;&amp; result == -ENXIO) {</span>
<span class="p_add">+	if (IS_SKYLAKE(dev_priv) &amp;&amp; ret == -ENXIO) {</span>
 		DRM_DEBUG_DRIVER(&quot;No SAGV found on system, ignoring\n&quot;);
 		dev_priv-&gt;sagv_status = I915_SAGV_NOT_CONTROLLED;
 		return 0;
<span class="p_del">-	} else if (result &lt; 0) {</span>
<span class="p_del">-		DRM_ERROR(&quot;Failed to disable the SAGV\n&quot;);</span>
<span class="p_del">-		return result;</span>
<span class="p_add">+	} else if (ret &lt; 0) {</span>
<span class="p_add">+		DRM_ERROR(&quot;Failed to disable the SAGV (%d)\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
 	}
 
 	dev_priv-&gt;sagv_status = I915_SAGV_DISABLED;
<span class="p_chunk">@@ -8015,14 +7999,14 @@</span> <span class="p_context"> int skl_pcode_request(struct drm_i915_private *dev_priv, u32 mbox, u32 request,</span>
 	 * worst case) _and_ PCODE was busy for some reason even after a
 	 * (queued) request and @timeout_base_ms delay. As a workaround retry
 	 * the poll with preemption disabled to maximize the number of
<span class="p_del">-	 * requests. Increase the timeout from @timeout_base_ms to 50ms to</span>
<span class="p_add">+	 * requests. Increase the timeout from @timeout_base_ms to 10ms to</span>
 	 * account for interrupts that could reduce the number of these
 	 * requests.
 	 */
 	DRM_DEBUG_KMS(&quot;PCODE timeout, retrying with preemption disabled\n&quot;);
 	WARN_ON_ONCE(timeout_base_ms &gt; 3);
 	preempt_disable();
<span class="p_del">-	ret = wait_for_atomic(COND, 50);</span>
<span class="p_add">+	ret = wait_for_atomic(COND, 10);</span>
 	preempt_enable();
 
 out:
<span class="p_header">diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_header">index 113db3c4a633..27cb42467b20 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> static int panel_simple_get_fixed_modes(struct panel_simple *panel)</span>
 
 		mode-&gt;type |= DRM_MODE_TYPE_DRIVER;
 
<span class="p_del">-		if (panel-&gt;desc-&gt;num_modes == 1)</span>
<span class="p_add">+		if (panel-&gt;desc-&gt;num_timings == 1)</span>
 			mode-&gt;type |= DRM_MODE_TYPE_PREFERRED;
 
 		drm_mode_probed_add(connector, mode);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">index 125c7e82c3d1..877af4a5ef68 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_chunk">@@ -50,7 +50,6 @@</span> <span class="p_context"> MODULE_FIRMWARE(&quot;radeon/tahiti_ce.bin&quot;);</span>
 MODULE_FIRMWARE(&quot;radeon/tahiti_mc.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/tahiti_rlc.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/tahiti_smc.bin&quot;);
<span class="p_del">-MODULE_FIRMWARE(&quot;radeon/tahiti_k_smc.bin&quot;);</span>
 
 MODULE_FIRMWARE(&quot;radeon/PITCAIRN_pfp.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/PITCAIRN_me.bin&quot;);
<span class="p_chunk">@@ -1657,9 +1656,6 @@</span> <span class="p_context"> static int si_init_microcode(struct radeon_device *rdev)</span>
 	switch (rdev-&gt;family) {
 	case CHIP_TAHITI:
 		chip_name = &quot;TAHITI&quot;;
<span class="p_del">-		/* XXX: figure out which Tahitis need the new ucode */</span>
<span class="p_del">-		if (0)</span>
<span class="p_del">-			new_smc = true;</span>
 		new_chip_name = &quot;tahiti&quot;;
 		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
 		me_req_size = SI_PM4_UCODE_SIZE * 4;
<span class="p_chunk">@@ -1671,12 +1667,9 @@</span> <span class="p_context"> static int si_init_microcode(struct radeon_device *rdev)</span>
 		break;
 	case CHIP_PITCAIRN:
 		chip_name = &quot;PITCAIRN&quot;;
<span class="p_del">-		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6810) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6811) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6816) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6817) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6806))</span>
<span class="p_add">+		if ((rdev-&gt;pdev-&gt;revision == 0x81) &amp;&amp;</span>
<span class="p_add">+		    ((rdev-&gt;pdev-&gt;device == 0x6810) ||</span>
<span class="p_add">+		     (rdev-&gt;pdev-&gt;device == 0x6811)))</span>
 			new_smc = true;
 		new_chip_name = &quot;pitcairn&quot;;
 		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
<span class="p_chunk">@@ -1689,15 +1682,15 @@</span> <span class="p_context"> static int si_init_microcode(struct radeon_device *rdev)</span>
 		break;
 	case CHIP_VERDE:
 		chip_name = &quot;VERDE&quot;;
<span class="p_del">-		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6820) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6821) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6822) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x682A) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x682B))</span>
<span class="p_add">+		if (((rdev-&gt;pdev-&gt;device == 0x6820) &amp;&amp;</span>
<span class="p_add">+		     ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		      (rdev-&gt;pdev-&gt;revision == 0x83))) ||</span>
<span class="p_add">+		    ((rdev-&gt;pdev-&gt;device == 0x6821) &amp;&amp;</span>
<span class="p_add">+		     ((rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_add">+		      (rdev-&gt;pdev-&gt;revision == 0x87))) ||</span>
<span class="p_add">+		    ((rdev-&gt;pdev-&gt;revision == 0x87) &amp;&amp;</span>
<span class="p_add">+		     ((rdev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_add">+		      (rdev-&gt;pdev-&gt;device == 0x682b))))</span>
 			new_smc = true;
 		new_chip_name = &quot;verde&quot;;
 		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
<span class="p_chunk">@@ -1710,13 +1703,13 @@</span> <span class="p_context"> static int si_init_microcode(struct radeon_device *rdev)</span>
 		break;
 	case CHIP_OLAND:
 		chip_name = &quot;OLAND&quot;;
<span class="p_del">-		if ((rdev-&gt;pdev-&gt;revision == 0xC7) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x80) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6604) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6605))</span>
<span class="p_add">+		if (((rdev-&gt;pdev-&gt;revision == 0x81) &amp;&amp;</span>
<span class="p_add">+		     ((rdev-&gt;pdev-&gt;device == 0x6600) ||</span>
<span class="p_add">+		      (rdev-&gt;pdev-&gt;device == 0x6604) ||</span>
<span class="p_add">+		      (rdev-&gt;pdev-&gt;device == 0x6605) ||</span>
<span class="p_add">+		      (rdev-&gt;pdev-&gt;device == 0x6610))) ||</span>
<span class="p_add">+		    ((rdev-&gt;pdev-&gt;revision == 0x83) &amp;&amp;</span>
<span class="p_add">+		     (rdev-&gt;pdev-&gt;device == 0x6610)))</span>
 			new_smc = true;
 		new_chip_name = &quot;oland&quot;;
 		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
<span class="p_chunk">@@ -1728,12 +1721,15 @@</span> <span class="p_context"> static int si_init_microcode(struct radeon_device *rdev)</span>
 		break;
 	case CHIP_HAINAN:
 		chip_name = &quot;HAINAN&quot;;
<span class="p_del">-		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0xC3) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6664) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6665) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6667))</span>
<span class="p_add">+		if (((rdev-&gt;pdev-&gt;revision == 0x81) &amp;&amp;</span>
<span class="p_add">+		     (rdev-&gt;pdev-&gt;device == 0x6660)) ||</span>
<span class="p_add">+		    ((rdev-&gt;pdev-&gt;revision == 0x83) &amp;&amp;</span>
<span class="p_add">+		     ((rdev-&gt;pdev-&gt;device == 0x6660) ||</span>
<span class="p_add">+		      (rdev-&gt;pdev-&gt;device == 0x6663) ||</span>
<span class="p_add">+		      (rdev-&gt;pdev-&gt;device == 0x6665) ||</span>
<span class="p_add">+		      (rdev-&gt;pdev-&gt;device == 0x6667))) ||</span>
<span class="p_add">+		    ((rdev-&gt;pdev-&gt;revision == 0xc3) &amp;&amp;</span>
<span class="p_add">+		     (rdev-&gt;pdev-&gt;device == 0x6665)))</span>
 			new_smc = true;
 		new_chip_name = &quot;hainan&quot;;
 		pfp_req_size = SI_PFP_UCODE_SIZE * 4;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 8b5e697f2549..13ba73fd9b68 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -3008,19 +3008,6 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 		    (rdev-&gt;pdev-&gt;device == 0x6817) ||
 		    (rdev-&gt;pdev-&gt;device == 0x6806))
 			max_mclk = 120000;
<span class="p_del">-	} else if (rdev-&gt;family == CHIP_VERDE) {</span>
<span class="p_del">-		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6820) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6821) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6822) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x682A) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x682B)) {</span>
<span class="p_del">-			max_sclk = 75000;</span>
<span class="p_del">-			max_mclk = 80000;</span>
<span class="p_del">-		}</span>
 	} else if (rdev-&gt;family == CHIP_OLAND) {
 		if ((rdev-&gt;pdev-&gt;revision == 0xC7) ||
 		    (rdev-&gt;pdev-&gt;revision == 0x80) ||
<span class="p_header">diff --git a/drivers/gpu/drm/savage/savage_state.c b/drivers/gpu/drm/savage/savage_state.c</span>
<span class="p_header">index 3dc0d8ff95ec..2db89bed52e8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/savage/savage_state.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/savage/savage_state.c</span>
<span class="p_chunk">@@ -1004,6 +1004,7 @@</span> <span class="p_context"> int savage_bci_cmdbuf(struct drm_device *dev, void *data, struct drm_file *file_</span>
 		kvb_addr = memdup_user(cmdbuf-&gt;vb_addr, cmdbuf-&gt;vb_size);
 		if (IS_ERR(kvb_addr)) {
 			ret = PTR_ERR(kvb_addr);
<span class="p_add">+			kvb_addr = NULL;</span>
 			goto done;
 		}
 		cmdbuf-&gt;vb_addr = kvb_addr;
<span class="p_header">diff --git a/drivers/gpu/drm/tegra/dpaux.c b/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_header">index 059f409556d5..2fde44c3a1b3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_chunk">@@ -539,9 +539,9 @@</span> <span class="p_context"> static int tegra_dpaux_probe(struct platform_device *pdev)</span>
 	dpaux-&gt;desc.owner = THIS_MODULE;
 
 	dpaux-&gt;pinctrl = devm_pinctrl_register(&amp;pdev-&gt;dev, &amp;dpaux-&gt;desc, dpaux);
<span class="p_del">-	if (!dpaux-&gt;pinctrl) {</span>
<span class="p_add">+	if (IS_ERR(dpaux-&gt;pinctrl)) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to register pincontrol\n&quot;);
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		return PTR_ERR(dpaux-&gt;pinctrl);</span>
 	}
 #endif
 	/* enable and clear all interrupts */
<span class="p_header">diff --git a/drivers/gpu/drm/vc4/vc4_gem.c b/drivers/gpu/drm/vc4/vc4_gem.c</span>
<span class="p_header">index 47a095f392f8..303f23c96220 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vc4/vc4_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vc4/vc4_gem.c</span>
<span class="p_chunk">@@ -544,14 +544,15 @@</span> <span class="p_context"> vc4_cl_lookup_bos(struct drm_device *dev,</span>
 
 	handles = drm_malloc_ab(exec-&gt;bo_count, sizeof(uint32_t));
 	if (!handles) {
<span class="p_add">+		ret = -ENOMEM;</span>
 		DRM_ERROR(&quot;Failed to allocate incoming GEM handles\n&quot;);
 		goto fail;
 	}
 
<span class="p_del">-	ret = copy_from_user(handles,</span>
<span class="p_del">-			     (void __user *)(uintptr_t)args-&gt;bo_handles,</span>
<span class="p_del">-			     exec-&gt;bo_count * sizeof(uint32_t));</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (copy_from_user(handles,</span>
<span class="p_add">+			   (void __user *)(uintptr_t)args-&gt;bo_handles,</span>
<span class="p_add">+			   exec-&gt;bo_count * sizeof(uint32_t))) {</span>
<span class="p_add">+		ret = -EFAULT;</span>
 		DRM_ERROR(&quot;Failed to copy in GEM handles\n&quot;);
 		goto fail;
 	}
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-piix4.c b/drivers/i2c/busses/i2c-piix4.c</span>
<span class="p_header">index c2268cdf38e8..e34d82e79b98 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-piix4.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-piix4.c</span>
<span class="p_chunk">@@ -585,10 +585,29 @@</span> <span class="p_context"> static s32 piix4_access_sb800(struct i2c_adapter *adap, u16 addr,</span>
 		 u8 command, int size, union i2c_smbus_data *data)
 {
 	struct i2c_piix4_adapdata *adapdata = i2c_get_adapdata(adap);
<span class="p_add">+	unsigned short piix4_smba = adapdata-&gt;smba;</span>
<span class="p_add">+	int retries = MAX_TIMEOUT;</span>
<span class="p_add">+	int smbslvcnt;</span>
 	u8 smba_en_lo;
 	u8 port;
 	int retval;
 
<span class="p_add">+	/* Request the SMBUS semaphore, avoid conflicts with the IMC */</span>
<span class="p_add">+	smbslvcnt  = inb_p(SMBSLVCNT);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		outb_p(smbslvcnt | 0x10, SMBSLVCNT);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Check the semaphore status */</span>
<span class="p_add">+		smbslvcnt  = inb_p(SMBSLVCNT);</span>
<span class="p_add">+		if (smbslvcnt &amp; 0x10)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		usleep_range(1000, 2000);</span>
<span class="p_add">+	} while (--retries);</span>
<span class="p_add">+	/* SMBus is still owned by the IMC, we give up */</span>
<span class="p_add">+	if (!retries)</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;piix4_mutex_sb800);
 
 	outb_p(piix4_port_sel_sb800, SB800_PIIX4_SMB_IDX);
<span class="p_chunk">@@ -606,6 +625,9 @@</span> <span class="p_context"> static s32 piix4_access_sb800(struct i2c_adapter *adap, u16 addr,</span>
 
 	mutex_unlock(&amp;piix4_mutex_sb800);
 
<span class="p_add">+	/* Release the semaphore */</span>
<span class="p_add">+	outb_p(smbslvcnt | 0x20, SMBSLVCNT);</span>
<span class="p_add">+</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index b432b64e307a..7484aac1e14d 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -1657,7 +1657,7 @@</span> <span class="p_context"> static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,</span>
 
 	if (i2c_check_addr_validity(addr, info.flags)) {
 		dev_err(&amp;adap-&gt;dev, &quot;of_i2c: invalid addr=%x on %s\n&quot;,
<span class="p_del">-			info.addr, node-&gt;full_name);</span>
<span class="p_add">+			addr, node-&gt;full_name);</span>
 		return ERR_PTR(-EINVAL);
 	}
 
<span class="p_header">diff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c</span>
<span class="p_header">index 66f323fd3982..6f638bbc922d 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-dev.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-dev.c</span>
<span class="p_chunk">@@ -331,7 +331,7 @@</span> <span class="p_context"> static noinline int i2cdev_ioctl_smbus(struct i2c_client *client,</span>
 		unsigned long arg)
 {
 	struct i2c_smbus_ioctl_data data_arg;
<span class="p_del">-	union i2c_smbus_data temp;</span>
<span class="p_add">+	union i2c_smbus_data temp = {};</span>
 	int datasize, res;
 
 	if (copy_from_user(&amp;data_arg,
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">index 8bc3d36d2837..9c4ac26c014e 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_chunk">@@ -151,6 +151,9 @@</span> <span class="p_context"> static int pca954x_reg_write(struct i2c_adapter *adap,</span>
 		buf[0] = val;
 		msg.buf = buf;
 		ret = __i2c_transfer(adap, &amp;msg, 1);
<span class="p_add">+</span>
<span class="p_add">+		if (ret &gt;= 0 &amp;&amp; ret != 1)</span>
<span class="p_add">+			ret = -EREMOTEIO;</span>
 	} else {
 		union i2c_smbus_data data;
 		ret = adap-&gt;algo-&gt;smbus_xfer(adap, client-&gt;addr,
<span class="p_chunk">@@ -179,7 +182,7 @@</span> <span class="p_context"> static int pca954x_select_chan(struct i2c_mux_core *muxc, u32 chan)</span>
 	/* Only select the channel if its different from the last channel */
 	if (data-&gt;last_chan != regval) {
 		ret = pca954x_reg_write(muxc-&gt;parent, client, regval);
<span class="p_del">-		data-&gt;last_chan = ret ? 0 : regval;</span>
<span class="p_add">+		data-&gt;last_chan = ret &lt; 0 ? 0 : regval;</span>
 	}
 
 	return ret;
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb4/device.c b/drivers/infiniband/hw/cxgb4/device.c</span>
<span class="p_header">index 93e3d270a98a..b99dc9e0ffb2 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb4/device.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb4/device.c</span>
<span class="p_chunk">@@ -828,8 +828,10 @@</span> <span class="p_context"> static int c4iw_rdev_open(struct c4iw_rdev *rdev)</span>
 	}
 	rdev-&gt;status_page = (struct t4_dev_status_page *)
 			    __get_free_page(GFP_KERNEL);
<span class="p_del">-	if (!rdev-&gt;status_page)</span>
<span class="p_add">+	if (!rdev-&gt;status_page) {</span>
<span class="p_add">+		err = -ENOMEM;</span>
 		goto destroy_ocqp_pool;
<span class="p_add">+	}</span>
 	rdev-&gt;status_page-&gt;qp_start = rdev-&gt;lldi.vr-&gt;qp.start;
 	rdev-&gt;status_page-&gt;qp_size = rdev-&gt;lldi.vr-&gt;qp.size;
 	rdev-&gt;status_page-&gt;cq_start = rdev-&gt;lldi.vr-&gt;cq.start;
<span class="p_header">diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c</span>
<span class="p_header">index 83af17ad0f1f..bbe15243b8e7 100644</span>
<span class="p_header">--- a/drivers/input/joystick/xpad.c</span>
<span class="p_header">+++ b/drivers/input/joystick/xpad.c</span>
<span class="p_chunk">@@ -1376,6 +1376,12 @@</span> <span class="p_context"> static int xpad_init_input(struct usb_xpad *xpad)</span>
 	input_dev-&gt;name = xpad-&gt;name;
 	input_dev-&gt;phys = xpad-&gt;phys;
 	usb_to_input_id(xpad-&gt;udev, &amp;input_dev-&gt;id);
<span class="p_add">+</span>
<span class="p_add">+	if (xpad-&gt;xtype == XTYPE_XBOX360W) {</span>
<span class="p_add">+		/* x360w controllers and the receiver have different ids */</span>
<span class="p_add">+		input_dev-&gt;id.product = 0x02a1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	input_dev-&gt;dev.parent = &amp;xpad-&gt;intf-&gt;dev;
 
 	input_set_drvdata(input_dev, xpad);
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index 073246c7d163..0cdd95801a25 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -211,6 +211,12 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_noloop_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Rev 1&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;PEGATRON CORPORATION&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;C15B&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/input/touchscreen/elants_i2c.c b/drivers/input/touchscreen/elants_i2c.c</span>
<span class="p_header">index 02aec284deca..3e6003d32e56 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/elants_i2c.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/elants_i2c.c</span>
<span class="p_chunk">@@ -914,9 +914,9 @@</span> <span class="p_context"> static irqreturn_t elants_i2c_irq(int irq, void *_dev)</span>
 
 		case QUEUE_HEADER_NORMAL:
 			report_count = ts-&gt;buf[FW_HDR_COUNT];
<span class="p_del">-			if (report_count &gt; 3) {</span>
<span class="p_add">+			if (report_count == 0 || report_count &gt; 3) {</span>
 				dev_err(&amp;client-&gt;dev,
<span class="p_del">-					&quot;too large report count: %*ph\n&quot;,</span>
<span class="p_add">+					&quot;bad report count: %*ph\n&quot;,</span>
 					HEADER_SIZE, ts-&gt;buf);
 				break;
 			}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">index 92bd13ddc39d..0c9ef8729ca7 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_chunk">@@ -1158,7 +1158,8 @@</span> <span class="p_context"> static int mlx5_unload_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv,</span>
 {
 	int err = 0;
 
<span class="p_del">-	mlx5_drain_health_wq(dev);</span>
<span class="p_add">+	if (cleanup)</span>
<span class="p_add">+		mlx5_drain_health_wq(dev);</span>
 
 	mutex_lock(&amp;dev-&gt;intf_state_mutex);
 	if (test_bit(MLX5_INTERFACE_STATE_DOWN, &amp;dev-&gt;intf_state)) {
<span class="p_chunk">@@ -1320,9 +1321,10 @@</span> <span class="p_context"> static pci_ers_result_t mlx5_pci_err_detected(struct pci_dev *pdev,</span>
 
 	mlx5_enter_error_state(dev);
 	mlx5_unload_one(dev, priv, false);
<span class="p_del">-	/* In case of kernel call save the pci state */</span>
<span class="p_add">+	/* In case of kernel call save the pci state and drain the health wq */</span>
 	if (state) {
 		pci_save_state(pdev);
<span class="p_add">+		mlx5_drain_health_wq(dev);</span>
 		mlx5_pci_disable_device(dev);
 	}
 
<span class="p_header">diff --git a/drivers/net/wireless/intersil/orinoco/mic.c b/drivers/net/wireless/intersil/orinoco/mic.c</span>
<span class="p_header">index bc7397d709d3..08bc7822f820 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intersil/orinoco/mic.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intersil/orinoco/mic.c</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"></span>
 /********************************************************************/
 int orinoco_mic_init(struct orinoco_private *priv)
 {
<span class="p_del">-	priv-&gt;tx_tfm_mic = crypto_alloc_ahash(&quot;michael_mic&quot;, 0,</span>
<span class="p_add">+	priv-&gt;tx_tfm_mic = crypto_alloc_shash(&quot;michael_mic&quot;, 0,</span>
 					      CRYPTO_ALG_ASYNC);
 	if (IS_ERR(priv-&gt;tx_tfm_mic)) {
 		printk(KERN_DEBUG &quot;orinoco_mic_init: could not allocate &quot;
<span class="p_chunk">@@ -25,7 +25,7 @@</span> <span class="p_context"> int orinoco_mic_init(struct orinoco_private *priv)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	priv-&gt;rx_tfm_mic = crypto_alloc_ahash(&quot;michael_mic&quot;, 0,</span>
<span class="p_add">+	priv-&gt;rx_tfm_mic = crypto_alloc_shash(&quot;michael_mic&quot;, 0,</span>
 					      CRYPTO_ALG_ASYNC);
 	if (IS_ERR(priv-&gt;rx_tfm_mic)) {
 		printk(KERN_DEBUG &quot;orinoco_mic_init: could not allocate &quot;
<span class="p_chunk">@@ -40,17 +40,16 @@</span> <span class="p_context"> int orinoco_mic_init(struct orinoco_private *priv)</span>
 void orinoco_mic_free(struct orinoco_private *priv)
 {
 	if (priv-&gt;tx_tfm_mic)
<span class="p_del">-		crypto_free_ahash(priv-&gt;tx_tfm_mic);</span>
<span class="p_add">+		crypto_free_shash(priv-&gt;tx_tfm_mic);</span>
 	if (priv-&gt;rx_tfm_mic)
<span class="p_del">-		crypto_free_ahash(priv-&gt;rx_tfm_mic);</span>
<span class="p_add">+		crypto_free_shash(priv-&gt;rx_tfm_mic);</span>
 }
 
<span class="p_del">-int orinoco_mic(struct crypto_ahash *tfm_michael, u8 *key,</span>
<span class="p_add">+int orinoco_mic(struct crypto_shash *tfm_michael, u8 *key,</span>
 		u8 *da, u8 *sa, u8 priority,
 		u8 *data, size_t data_len, u8 *mic)
 {
<span class="p_del">-	AHASH_REQUEST_ON_STACK(req, tfm_michael);</span>
<span class="p_del">-	struct scatterlist sg[2];</span>
<span class="p_add">+	SHASH_DESC_ON_STACK(desc, tfm_michael);</span>
 	u8 hdr[ETH_HLEN + 2]; /* size of header + padding */
 	int err;
 
<span class="p_chunk">@@ -67,18 +66,27 @@</span> <span class="p_context"> int orinoco_mic(struct crypto_ahash *tfm_michael, u8 *key,</span>
 	hdr[ETH_ALEN * 2 + 2] = 0;
 	hdr[ETH_ALEN * 2 + 3] = 0;
 
<span class="p_del">-	/* Use scatter gather to MIC header and data in one go */</span>
<span class="p_del">-	sg_init_table(sg, 2);</span>
<span class="p_del">-	sg_set_buf(&amp;sg[0], hdr, sizeof(hdr));</span>
<span class="p_del">-	sg_set_buf(&amp;sg[1], data, data_len);</span>
<span class="p_add">+	desc-&gt;tfm = tfm_michael;</span>
<span class="p_add">+	desc-&gt;flags = 0;</span>
 
<span class="p_del">-	if (crypto_ahash_setkey(tfm_michael, key, MIC_KEYLEN))</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+	err = crypto_shash_setkey(tfm_michael, key, MIC_KEYLEN);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_shash_init(desc);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_shash_update(desc, hdr, sizeof(hdr));</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_shash_update(desc, data, data_len);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_shash_final(desc, mic);</span>
<span class="p_add">+	shash_desc_zero(desc);</span>
 
<span class="p_del">-	ahash_request_set_tfm(req, tfm_michael);</span>
<span class="p_del">-	ahash_request_set_callback(req, 0, NULL, NULL);</span>
<span class="p_del">-	ahash_request_set_crypt(req, sg, mic, data_len + sizeof(hdr));</span>
<span class="p_del">-	err = crypto_ahash_digest(req);</span>
<span class="p_del">-	ahash_request_zero(req);</span>
 	return err;
 }
<span class="p_header">diff --git a/drivers/net/wireless/intersil/orinoco/mic.h b/drivers/net/wireless/intersil/orinoco/mic.h</span>
<span class="p_header">index ce731d05cc98..e8724e889219 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intersil/orinoco/mic.h</span>
<span class="p_header">+++ b/drivers/net/wireless/intersil/orinoco/mic.h</span>
<span class="p_chunk">@@ -6,6 +6,7 @@</span> <span class="p_context"></span>
 #define _ORINOCO_MIC_H_
 
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;crypto/hash.h&gt;</span>
 
 #define MICHAEL_MIC_LEN 8
 
<span class="p_chunk">@@ -15,7 +16,7 @@</span> <span class="p_context"> struct crypto_ahash;</span>
 
 int orinoco_mic_init(struct orinoco_private *priv);
 void orinoco_mic_free(struct orinoco_private *priv);
<span class="p_del">-int orinoco_mic(struct crypto_ahash *tfm_michael, u8 *key,</span>
<span class="p_add">+int orinoco_mic(struct crypto_shash *tfm_michael, u8 *key,</span>
 		u8 *da, u8 *sa, u8 priority,
 		u8 *data, size_t data_len, u8 *mic);
 
<span class="p_header">diff --git a/drivers/net/wireless/intersil/orinoco/orinoco.h b/drivers/net/wireless/intersil/orinoco/orinoco.h</span>
<span class="p_header">index 2f0c84b1c440..5fa1c3e3713f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intersil/orinoco/orinoco.h</span>
<span class="p_header">+++ b/drivers/net/wireless/intersil/orinoco/orinoco.h</span>
<span class="p_chunk">@@ -152,8 +152,8 @@</span> <span class="p_context"> struct orinoco_private {</span>
 	u8 *wpa_ie;
 	int wpa_ie_len;
 
<span class="p_del">-	struct crypto_ahash *rx_tfm_mic;</span>
<span class="p_del">-	struct crypto_ahash *tx_tfm_mic;</span>
<span class="p_add">+	struct crypto_shash *rx_tfm_mic;</span>
<span class="p_add">+	struct crypto_shash *tx_tfm_mic;</span>
 
 	unsigned int wpa_enabled:1;
 	unsigned int tkip_cm_active:1;
<span class="p_header">diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c</span>
<span class="p_header">index 79e679d12f3b..da10b484bd25 100644</span>
<span class="p_header">--- a/drivers/nvme/host/core.c</span>
<span class="p_header">+++ b/drivers/nvme/host/core.c</span>
<span class="p_chunk">@@ -1122,12 +1122,7 @@</span> <span class="p_context"> int nvme_disable_ctrl(struct nvme_ctrl *ctrl, u64 cap)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	/* Checking for ctrl-&gt;tagset is a trick to avoid sleeping on module</span>
<span class="p_del">-	 * load, since we only need the quirk on reset_controller. Notice</span>
<span class="p_del">-	 * that the HGST device needs this delay only in firmware activation</span>
<span class="p_del">-	 * procedure; unfortunately we have no (easy) way to verify this.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((ctrl-&gt;quirks &amp; NVME_QUIRK_DELAY_BEFORE_CHK_RDY) &amp;&amp; ctrl-&gt;tagset)</span>
<span class="p_add">+	if (ctrl-&gt;quirks &amp; NVME_QUIRK_DELAY_BEFORE_CHK_RDY)</span>
 		msleep(NVME_QUIRK_DELAY_AMOUNT);
 
 	return nvme_wait_ready(ctrl, cap, false);
<span class="p_header">diff --git a/drivers/pinctrl/freescale/pinctrl-imx.c b/drivers/pinctrl/freescale/pinctrl-imx.c</span>
<span class="p_header">index 79c4e14a5a75..5ef7e875b50e 100644</span>
<span class="p_header">--- a/drivers/pinctrl/freescale/pinctrl-imx.c</span>
<span class="p_header">+++ b/drivers/pinctrl/freescale/pinctrl-imx.c</span>
<span class="p_chunk">@@ -778,10 +778,10 @@</span> <span class="p_context"> int imx_pinctrl_probe(struct platform_device *pdev,</span>
 	imx_pinctrl_desc-&gt;name = dev_name(&amp;pdev-&gt;dev);
 	imx_pinctrl_desc-&gt;pins = info-&gt;pins;
 	imx_pinctrl_desc-&gt;npins = info-&gt;npins;
<span class="p_del">-	imx_pinctrl_desc-&gt;pctlops = &amp;imx_pctrl_ops,</span>
<span class="p_del">-	imx_pinctrl_desc-&gt;pmxops = &amp;imx_pmx_ops,</span>
<span class="p_del">-	imx_pinctrl_desc-&gt;confops = &amp;imx_pinconf_ops,</span>
<span class="p_del">-	imx_pinctrl_desc-&gt;owner = THIS_MODULE,</span>
<span class="p_add">+	imx_pinctrl_desc-&gt;pctlops = &amp;imx_pctrl_ops;</span>
<span class="p_add">+	imx_pinctrl_desc-&gt;pmxops = &amp;imx_pmx_ops;</span>
<span class="p_add">+	imx_pinctrl_desc-&gt;confops = &amp;imx_pinconf_ops;</span>
<span class="p_add">+	imx_pinctrl_desc-&gt;owner = THIS_MODULE;</span>
 
 	ret = imx_pinctrl_probe_dt(pdev, info);
 	if (ret) {
<span class="p_header">diff --git a/drivers/pinctrl/meson/pinctrl-meson.c b/drivers/pinctrl/meson/pinctrl-meson.c</span>
<span class="p_header">index 57122eda155a..9443c9d408c6 100644</span>
<span class="p_header">--- a/drivers/pinctrl/meson/pinctrl-meson.c</span>
<span class="p_header">+++ b/drivers/pinctrl/meson/pinctrl-meson.c</span>
<span class="p_chunk">@@ -212,7 +212,7 @@</span> <span class="p_context"> static int meson_pmx_request_gpio(struct pinctrl_dev *pcdev,</span>
 {
 	struct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);
 
<span class="p_del">-	meson_pmx_disable_other_groups(pc, range-&gt;pin_base + offset, -1);</span>
<span class="p_add">+	meson_pmx_disable_other_groups(pc, offset, -1);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c</span>
<span class="p_header">index f3a8897d4e8f..cf80ce1dd7ce 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sh-pfc/core.c</span>
<span class="p_header">+++ b/drivers/pinctrl/sh-pfc/core.c</span>
<span class="p_chunk">@@ -389,6 +389,21 @@</span> <span class="p_context"> int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)</span>
 	return 0;
 }
 
<span class="p_add">+const struct sh_pfc_bias_info *</span>
<span class="p_add">+sh_pfc_pin_to_bias_info(const struct sh_pfc_bias_info *info,</span>
<span class="p_add">+			unsigned int num, unsigned int pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num; i++)</span>
<span class="p_add">+		if (info[i].pin == pin)</span>
<span class="p_add">+			return &amp;info[i];</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ONCE(1, &quot;Pin %u is not in bias info list\n&quot;, pin);</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int sh_pfc_init_ranges(struct sh_pfc *pfc)
 {
 	struct sh_pfc_pin_range *range;
<span class="p_header">diff --git a/drivers/pinctrl/sh-pfc/core.h b/drivers/pinctrl/sh-pfc/core.h</span>
<span class="p_header">index 0bbdea5849f4..6d598dd63720 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sh-pfc/core.h</span>
<span class="p_header">+++ b/drivers/pinctrl/sh-pfc/core.h</span>
<span class="p_chunk">@@ -33,4 +33,8 @@</span> <span class="p_context"> void sh_pfc_write_reg(struct sh_pfc *pfc, u32 reg, unsigned int width,</span>
 int sh_pfc_get_pin_index(struct sh_pfc *pfc, unsigned int pin);
 int sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type);
 
<span class="p_add">+const struct sh_pfc_bias_info *</span>
<span class="p_add">+sh_pfc_pin_to_bias_info(const struct sh_pfc_bias_info *info,</span>
<span class="p_add">+			unsigned int num, unsigned int pin);</span>
<span class="p_add">+</span>
 #endif /* __SH_PFC_CORE_H__ */
<span class="p_header">diff --git a/drivers/pinctrl/sh-pfc/pfc-r8a7795.c b/drivers/pinctrl/sh-pfc/pfc-r8a7795.c</span>
<span class="p_header">index 2e8cc2adbed7..84cee66b1e08 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sh-pfc/pfc-r8a7795.c</span>
<span class="p_header">+++ b/drivers/pinctrl/sh-pfc/pfc-r8a7795.c</span>
<span class="p_chunk">@@ -5188,184 +5188,183 @@</span> <span class="p_context"> static int r8a7795_pin_to_pocctrl(struct sh_pfc *pfc, unsigned int pin, u32 *poc</span>
 #define PU5	0x14
 #define PU6	0x18
 
<span class="p_del">-static const struct {</span>
<span class="p_del">-	u16 reg : 11;</span>
<span class="p_del">-	u16 bit : 5;</span>
<span class="p_del">-} pullups[] = {</span>
<span class="p_del">-	[RCAR_GP_PIN(2, 11)] = { PU0, 31 },	/* AVB_PHY_INT */</span>
<span class="p_del">-	[RCAR_GP_PIN(2, 10)] = { PU0, 30 },	/* AVB_MAGIC */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  9)] = { PU0, 29 },	/* AVB_MDC */</span>
<span class="p_del">-</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 19)] = { PU1, 31 },	/* A19 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 18)] = { PU1, 30 },	/* A18 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 17)] = { PU1, 29 },	/* A17 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 16)] = { PU1, 28 },	/* A16 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 15)] = { PU1, 27 },	/* A15 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 14)] = { PU1, 26 },	/* A14 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 13)] = { PU1, 25 },	/* A13 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 12)] = { PU1, 24 },	/* A12 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 11)] = { PU1, 23 },	/* A11 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 10)] = { PU1, 22 },	/* A10 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  9)] = { PU1, 21 },	/* A9 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  8)] = { PU1, 20 },	/* A8 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  7)] = { PU1, 19 },	/* A7 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  6)] = { PU1, 18 },	/* A6 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  5)] = { PU1, 17 },	/* A5 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  4)] = { PU1, 16 },	/* A4 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  3)] = { PU1, 15 },	/* A3 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  2)] = { PU1, 14 },	/* A2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  1)] = { PU1, 13 },	/* A1 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1,  0)] = { PU1, 12 },	/* A0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  8)] = { PU1, 11 },	/* PWM2_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  7)] = { PU1, 10 },	/* PWM1_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  6)] = { PU1,  9 },	/* PWM0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  5)] = { PU1,  8 },	/* IRQ5 */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  4)] = { PU1,  7 },	/* IRQ4 */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  3)] = { PU1,  6 },	/* IRQ3 */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  2)] = { PU1,  5 },	/* IRQ2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  1)] = { PU1,  4 },	/* IRQ1 */</span>
<span class="p_del">-	[RCAR_GP_PIN(2,  0)] = { PU1,  3 },	/* IRQ0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(2, 14)] = { PU1,  2 },	/* AVB_AVTP_CAPTURE_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(2, 13)] = { PU1,  1 },	/* AVB_AVTP_MATCH_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(2, 12)] = { PU1,  0 },	/* AVB_LINK */</span>
<span class="p_del">-</span>
<span class="p_del">-	[RCAR_GP_PIN(7,  3)] = { PU2, 29 },	/* HDMI1_CEC */</span>
<span class="p_del">-	[RCAR_GP_PIN(7,  2)] = { PU2, 28 },	/* HDMI0_CEC */</span>
<span class="p_del">-	[RCAR_GP_PIN(7,  1)] = { PU2, 27 },	/* AVS2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(7,  0)] = { PU2, 26 },	/* AVS1 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0, 15)] = { PU2, 25 },	/* D15 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0, 14)] = { PU2, 24 },	/* D14 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0, 13)] = { PU2, 23 },	/* D13 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0, 12)] = { PU2, 22 },	/* D12 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0, 11)] = { PU2, 21 },	/* D11 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0, 10)] = { PU2, 20 },	/* D10 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  9)] = { PU2, 19 },	/* D9 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  8)] = { PU2, 18 },	/* D8 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  7)] = { PU2, 17 },	/* D7 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  6)] = { PU2, 16 },	/* D6 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  5)] = { PU2, 15 },	/* D5 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  4)] = { PU2, 14 },	/* D4 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  3)] = { PU2, 13 },	/* D3 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  2)] = { PU2, 12 },	/* D2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  1)] = { PU2, 11 },	/* D1 */</span>
<span class="p_del">-	[RCAR_GP_PIN(0,  0)] = { PU2, 10 },	/* D0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 27)] = { PU2,  8 },	/* EX_WAIT0_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 26)] = { PU2,  7 },	/* WE1_N */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 25)] = { PU2,  6 },	/* WE0_N */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 24)] = { PU2,  5 },	/* RD_WR_N */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 23)] = { PU2,  4 },	/* RD_N */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 22)] = { PU2,  3 },	/* BS_N */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 21)] = { PU2,  2 },	/* CS1_N_A26 */</span>
<span class="p_del">-	[RCAR_GP_PIN(1, 20)] = { PU2,  1 },	/* CS0_N */</span>
<span class="p_del">-</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  9)] = { PU3, 31 },	/* SD3_DAT0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  8)] = { PU3, 30 },	/* SD3_CMD */</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  7)] = { PU3, 29 },	/* SD3_CLK */</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  6)] = { PU3, 28 },	/* SD2_DS */</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  5)] = { PU3, 27 },	/* SD2_DAT3 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  4)] = { PU3, 26 },	/* SD2_DAT2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  3)] = { PU3, 25 },	/* SD2_DAT1 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  2)] = { PU3, 24 },	/* SD2_DAT0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  1)] = { PU3, 23 },	/* SD2_CMD */</span>
<span class="p_del">-	[RCAR_GP_PIN(4,  0)] = { PU3, 22 },	/* SD2_CLK */</span>
<span class="p_del">-	[RCAR_GP_PIN(3, 11)] = { PU3, 21 },	/* SD1_DAT3 */</span>
<span class="p_del">-	[RCAR_GP_PIN(3, 10)] = { PU3, 20 },	/* SD1_DAT2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  9)] = { PU3, 19 },	/* SD1_DAT1 */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  8)] = { PU3, 18 },	/* SD1_DAT0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  7)] = { PU3, 17 },	/* SD1_CMD */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  6)] = { PU3, 16 },	/* SD1_CLK */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  5)] = { PU3, 15 },	/* SD0_DAT3 */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  4)] = { PU3, 14 },	/* SD0_DAT2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  3)] = { PU3, 13 },	/* SD0_DAT1 */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  2)] = { PU3, 12 },	/* SD0_DAT0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  1)] = { PU3, 11 },	/* SD0_CMD */</span>
<span class="p_del">-	[RCAR_GP_PIN(3,  0)] = { PU3, 10 },	/* SD0_CLK */</span>
<span class="p_del">-</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 19)] = { PU4, 31 },	/* MSIOF0_SS1 */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 18)] = { PU4, 30 },	/* MSIOF0_SYNC */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 17)] = { PU4, 29 },	/* MSIOF0_SCK */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 16)] = { PU4, 28 },	/* HRTS0_N */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 15)] = { PU4, 27 },	/* HCTS0_N */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 14)] = { PU4, 26 },	/* HTX0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 13)] = { PU4, 25 },	/* HRX0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 12)] = { PU4, 24 },	/* HSCK0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 11)] = { PU4, 23 },	/* RX2_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 10)] = { PU4, 22 },	/* TX2_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  9)] = { PU4, 21 },	/* SCK2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  8)] = { PU4, 20 },	/* RTS1_N_TANS */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  7)] = { PU4, 19 },	/* CTS1_N */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  6)] = { PU4, 18 },	/* TX1_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  5)] = { PU4, 17 },	/* RX1_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  4)] = { PU4, 16 },	/* RTS0_N_TANS */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  3)] = { PU4, 15 },	/* CTS0_N */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  2)] = { PU4, 14 },	/* TX0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  1)] = { PU4, 13 },	/* RX0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(5,  0)] = { PU4, 12 },	/* SCK0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(3, 15)] = { PU4, 11 },	/* SD1_WP */</span>
<span class="p_del">-	[RCAR_GP_PIN(3, 14)] = { PU4, 10 },	/* SD1_CD */</span>
<span class="p_del">-	[RCAR_GP_PIN(3, 13)] = { PU4,  9 },	/* SD0_WP */</span>
<span class="p_del">-	[RCAR_GP_PIN(3, 12)] = { PU4,  8 },	/* SD0_CD */</span>
<span class="p_del">-	[RCAR_GP_PIN(4, 17)] = { PU4,  7 },	/* SD3_DS */</span>
<span class="p_del">-	[RCAR_GP_PIN(4, 16)] = { PU4,  6 },	/* SD3_DAT7 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4, 15)] = { PU4,  5 },	/* SD3_DAT6 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4, 14)] = { PU4,  4 },	/* SD3_DAT5 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4, 13)] = { PU4,  3 },	/* SD3_DAT4 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4, 12)] = { PU4,  2 },	/* SD3_DAT3 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4, 11)] = { PU4,  1 },	/* SD3_DAT2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(4, 10)] = { PU4,  0 },	/* SD3_DAT1 */</span>
<span class="p_del">-</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 24)] = { PU5, 31 },	/* USB0_PWEN */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 23)] = { PU5, 30 },	/* AUDIO_CLKB_B */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 22)] = { PU5, 29 },	/* AUDIO_CLKA_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 21)] = { PU5, 28 },	/* SSI_SDATA9_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 20)] = { PU5, 27 },	/* SSI_SDATA8 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 19)] = { PU5, 26 },	/* SSI_SDATA7 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 18)] = { PU5, 25 },	/* SSI_WS78 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 17)] = { PU5, 24 },	/* SSI_SCK78 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 16)] = { PU5, 23 },	/* SSI_SDATA6 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 15)] = { PU5, 22 },	/* SSI_WS6 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 14)] = { PU5, 21 },	/* SSI_SCK6 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 13)] = { PU5, 20 },	/* SSI_SDATA5 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 12)] = { PU5, 19 },	/* SSI_WS5 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 11)] = { PU5, 18 },	/* SSI_SCK5 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 10)] = { PU5, 17 },	/* SSI_SDATA4 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  9)] = { PU5, 16 },	/* SSI_WS4 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  8)] = { PU5, 15 },	/* SSI_SCK4 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  7)] = { PU5, 14 },	/* SSI_SDATA3 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  6)] = { PU5, 13 },	/* SSI_WS34 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  5)] = { PU5, 12 },	/* SSI_SCK34 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  4)] = { PU5, 11 },	/* SSI_SDATA2_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  3)] = { PU5, 10 },	/* SSI_SDATA1_A */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  2)] = { PU5,  9 },	/* SSI_SDATA0 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  1)] = { PU5,  8 },	/* SSI_WS01239 */</span>
<span class="p_del">-	[RCAR_GP_PIN(6,  0)] = { PU5,  7 },	/* SSI_SCK01239 */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 25)] = { PU5,  5 },	/* MLB_DAT */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 24)] = { PU5,  4 },	/* MLB_SIG */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 23)] = { PU5,  3 },	/* MLB_CLK */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 22)] = { PU5,  2 },	/* MSIOF0_RXD */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 21)] = { PU5,  1 },	/* MSIOF0_SS2 */</span>
<span class="p_del">-	[RCAR_GP_PIN(5, 20)] = { PU5,  0 },	/* MSIOF0_TXD */</span>
<span class="p_del">-</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 31)] = { PU6,  6 },	/* USB31_OVC */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 30)] = { PU6,  5 },	/* USB31_PWEN */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 29)] = { PU6,  4 },	/* USB30_OVC */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 28)] = { PU6,  3 },	/* USB30_PWEN */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 27)] = { PU6,  2 },	/* USB1_OVC */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 26)] = { PU6,  1 },	/* USB1_PWEN */</span>
<span class="p_del">-	[RCAR_GP_PIN(6, 25)] = { PU6,  0 },	/* USB0_OVC */</span>
<span class="p_add">+static const struct sh_pfc_bias_info bias_info[] = {</span>
<span class="p_add">+	{ RCAR_GP_PIN(2, 11), PU0, 31 },	/* AVB_PHY_INT */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2, 10), PU0, 30 },	/* AVB_MAGIC */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  9), PU0, 29 },	/* AVB_MDC */</span>
<span class="p_add">+</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 19), PU1, 31 },	/* A19 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 18), PU1, 30 },	/* A18 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 17), PU1, 29 },	/* A17 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 16), PU1, 28 },	/* A16 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 15), PU1, 27 },	/* A15 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 14), PU1, 26 },	/* A14 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 13), PU1, 25 },	/* A13 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 12), PU1, 24 },	/* A12 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 11), PU1, 23 },	/* A11 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 10), PU1, 22 },	/* A10 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  9), PU1, 21 },	/* A9 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  8), PU1, 20 },	/* A8 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  7), PU1, 19 },	/* A7 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  6), PU1, 18 },	/* A6 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  5), PU1, 17 },	/* A5 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  4), PU1, 16 },	/* A4 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  3), PU1, 15 },	/* A3 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  2), PU1, 14 },	/* A2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  1), PU1, 13 },	/* A1 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1,  0), PU1, 12 },	/* A0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  8), PU1, 11 },	/* PWM2_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  7), PU1, 10 },	/* PWM1_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  6), PU1,  9 },	/* PWM0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  5), PU1,  8 },	/* IRQ5 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  4), PU1,  7 },	/* IRQ4 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  3), PU1,  6 },	/* IRQ3 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  2), PU1,  5 },	/* IRQ2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  1), PU1,  4 },	/* IRQ1 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2,  0), PU1,  3 },	/* IRQ0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2, 14), PU1,  2 },	/* AVB_AVTP_CAPTURE_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2, 13), PU1,  1 },	/* AVB_AVTP_MATCH_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(2, 12), PU1,  0 },	/* AVB_LINK */</span>
<span class="p_add">+</span>
<span class="p_add">+	{ RCAR_GP_PIN(7,  3), PU2, 29 },	/* HDMI1_CEC */</span>
<span class="p_add">+	{ RCAR_GP_PIN(7,  2), PU2, 28 },	/* HDMI0_CEC */</span>
<span class="p_add">+	{ RCAR_GP_PIN(7,  1), PU2, 27 },	/* AVS2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(7,  0), PU2, 26 },	/* AVS1 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0, 15), PU2, 25 },	/* D15 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0, 14), PU2, 24 },	/* D14 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0, 13), PU2, 23 },	/* D13 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0, 12), PU2, 22 },	/* D12 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0, 11), PU2, 21 },	/* D11 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0, 10), PU2, 20 },	/* D10 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  9), PU2, 19 },	/* D9 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  8), PU2, 18 },	/* D8 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  7), PU2, 17 },	/* D7 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  6), PU2, 16 },	/* D6 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  5), PU2, 15 },	/* D5 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  4), PU2, 14 },	/* D4 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  3), PU2, 13 },	/* D3 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  2), PU2, 12 },	/* D2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  1), PU2, 11 },	/* D1 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(0,  0), PU2, 10 },	/* D0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 27), PU2,  8 },	/* EX_WAIT0_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 26), PU2,  7 },	/* WE1_N */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 25), PU2,  6 },	/* WE0_N */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 24), PU2,  5 },	/* RD_WR_N */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 23), PU2,  4 },	/* RD_N */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 22), PU2,  3 },	/* BS_N */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 21), PU2,  2 },	/* CS1_N_A26 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(1, 20), PU2,  1 },	/* CS0_N */</span>
<span class="p_add">+</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  9), PU3, 31 },	/* SD3_DAT0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  8), PU3, 30 },	/* SD3_CMD */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  7), PU3, 29 },	/* SD3_CLK */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  6), PU3, 28 },	/* SD2_DS */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  5), PU3, 27 },	/* SD2_DAT3 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  4), PU3, 26 },	/* SD2_DAT2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  3), PU3, 25 },	/* SD2_DAT1 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  2), PU3, 24 },	/* SD2_DAT0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  1), PU3, 23 },	/* SD2_CMD */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4,  0), PU3, 22 },	/* SD2_CLK */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3, 11), PU3, 21 },	/* SD1_DAT3 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3, 10), PU3, 20 },	/* SD1_DAT2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  9), PU3, 19 },	/* SD1_DAT1 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  8), PU3, 18 },	/* SD1_DAT0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  7), PU3, 17 },	/* SD1_CMD */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  6), PU3, 16 },	/* SD1_CLK */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  5), PU3, 15 },	/* SD0_DAT3 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  4), PU3, 14 },	/* SD0_DAT2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  3), PU3, 13 },	/* SD0_DAT1 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  2), PU3, 12 },	/* SD0_DAT0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  1), PU3, 11 },	/* SD0_CMD */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3,  0), PU3, 10 },	/* SD0_CLK */</span>
<span class="p_add">+</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 19), PU4, 31 },	/* MSIOF0_SS1 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 18), PU4, 30 },	/* MSIOF0_SYNC */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 17), PU4, 29 },	/* MSIOF0_SCK */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 16), PU4, 28 },	/* HRTS0_N */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 15), PU4, 27 },	/* HCTS0_N */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 14), PU4, 26 },	/* HTX0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 13), PU4, 25 },	/* HRX0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 12), PU4, 24 },	/* HSCK0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 11), PU4, 23 },	/* RX2_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 10), PU4, 22 },	/* TX2_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  9), PU4, 21 },	/* SCK2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  8), PU4, 20 },	/* RTS1_N_TANS */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  7), PU4, 19 },	/* CTS1_N */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  6), PU4, 18 },	/* TX1_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  5), PU4, 17 },	/* RX1_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  4), PU4, 16 },	/* RTS0_N_TANS */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  3), PU4, 15 },	/* CTS0_N */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  2), PU4, 14 },	/* TX0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  1), PU4, 13 },	/* RX0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5,  0), PU4, 12 },	/* SCK0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3, 15), PU4, 11 },	/* SD1_WP */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3, 14), PU4, 10 },	/* SD1_CD */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3, 13), PU4,  9 },	/* SD0_WP */</span>
<span class="p_add">+	{ RCAR_GP_PIN(3, 12), PU4,  8 },	/* SD0_CD */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4, 17), PU4,  7 },	/* SD3_DS */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4, 16), PU4,  6 },	/* SD3_DAT7 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4, 15), PU4,  5 },	/* SD3_DAT6 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4, 14), PU4,  4 },	/* SD3_DAT5 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4, 13), PU4,  3 },	/* SD3_DAT4 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4, 12), PU4,  2 },	/* SD3_DAT3 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4, 11), PU4,  1 },	/* SD3_DAT2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(4, 10), PU4,  0 },	/* SD3_DAT1 */</span>
<span class="p_add">+</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 24), PU5, 31 },	/* USB0_PWEN */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 23), PU5, 30 },	/* AUDIO_CLKB_B */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 22), PU5, 29 },	/* AUDIO_CLKA_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 21), PU5, 28 },	/* SSI_SDATA9_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 20), PU5, 27 },	/* SSI_SDATA8 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 19), PU5, 26 },	/* SSI_SDATA7 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 18), PU5, 25 },	/* SSI_WS78 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 17), PU5, 24 },	/* SSI_SCK78 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 16), PU5, 23 },	/* SSI_SDATA6 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 15), PU5, 22 },	/* SSI_WS6 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 14), PU5, 21 },	/* SSI_SCK6 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 13), PU5, 20 },	/* SSI_SDATA5 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 12), PU5, 19 },	/* SSI_WS5 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 11), PU5, 18 },	/* SSI_SCK5 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 10), PU5, 17 },	/* SSI_SDATA4 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  9), PU5, 16 },	/* SSI_WS4 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  8), PU5, 15 },	/* SSI_SCK4 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  7), PU5, 14 },	/* SSI_SDATA3 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  6), PU5, 13 },	/* SSI_WS34 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  5), PU5, 12 },	/* SSI_SCK34 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  4), PU5, 11 },	/* SSI_SDATA2_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  3), PU5, 10 },	/* SSI_SDATA1_A */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  2), PU5,  9 },	/* SSI_SDATA0 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  1), PU5,  8 },	/* SSI_WS01239 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6,  0), PU5,  7 },	/* SSI_SCK01239 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 25), PU5,  5 },	/* MLB_DAT */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 24), PU5,  4 },	/* MLB_SIG */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 23), PU5,  3 },	/* MLB_CLK */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 22), PU5,  2 },	/* MSIOF0_RXD */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 21), PU5,  1 },	/* MSIOF0_SS2 */</span>
<span class="p_add">+	{ RCAR_GP_PIN(5, 20), PU5,  0 },	/* MSIOF0_TXD */</span>
<span class="p_add">+</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 31), PU6,  6 },	/* USB31_OVC */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 30), PU6,  5 },	/* USB31_PWEN */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 29), PU6,  4 },	/* USB30_OVC */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 28), PU6,  3 },	/* USB30_PWEN */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 27), PU6,  2 },	/* USB1_OVC */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 26), PU6,  1 },	/* USB1_PWEN */</span>
<span class="p_add">+	{ RCAR_GP_PIN(6, 25), PU6,  0 },	/* USB0_OVC */</span>
 };
 
 static unsigned int r8a7795_pinmux_get_bias(struct sh_pfc *pfc,
 					    unsigned int pin)
 {
<span class="p_add">+	const struct sh_pfc_bias_info *info;</span>
 	u32 reg;
 	u32 bit;
 
<span class="p_del">-	if (WARN_ON_ONCE(!pullups[pin].reg))</span>
<span class="p_add">+	info = sh_pfc_pin_to_bias_info(bias_info, ARRAY_SIZE(bias_info), pin);</span>
<span class="p_add">+	if (!info)</span>
 		return PIN_CONFIG_BIAS_DISABLE;
 
<span class="p_del">-	reg = pullups[pin].reg;</span>
<span class="p_del">-	bit = BIT(pullups[pin].bit);</span>
<span class="p_add">+	reg = info-&gt;reg;</span>
<span class="p_add">+	bit = BIT(info-&gt;bit);</span>
 
 	if (sh_pfc_read_reg(pfc, PUEN + reg, 32) &amp; bit) {
 		if (sh_pfc_read_reg(pfc, PUD + reg, 32) &amp; bit)
<span class="p_chunk">@@ -5379,15 +5378,17 @@</span> <span class="p_context"> static unsigned int r8a7795_pinmux_get_bias(struct sh_pfc *pfc,</span>
 static void r8a7795_pinmux_set_bias(struct sh_pfc *pfc, unsigned int pin,
 				   unsigned int bias)
 {
<span class="p_add">+	const struct sh_pfc_bias_info *info;</span>
 	u32 enable, updown;
 	u32 reg;
 	u32 bit;
 
<span class="p_del">-	if (WARN_ON_ONCE(!pullups[pin].reg))</span>
<span class="p_add">+	info = sh_pfc_pin_to_bias_info(bias_info, ARRAY_SIZE(bias_info), pin);</span>
<span class="p_add">+	if (!info)</span>
 		return;
 
<span class="p_del">-	reg = pullups[pin].reg;</span>
<span class="p_del">-	bit = BIT(pullups[pin].bit);</span>
<span class="p_add">+	reg = info-&gt;reg;</span>
<span class="p_add">+	bit = BIT(info-&gt;bit);</span>
 
 	enable = sh_pfc_read_reg(pfc, PUEN + reg, 32) &amp; ~bit;
 	if (bias != PIN_CONFIG_BIAS_DISABLE)
<span class="p_header">diff --git a/drivers/pinctrl/sh-pfc/pinctrl.c b/drivers/pinctrl/sh-pfc/pinctrl.c</span>
<span class="p_header">index c5772584594c..fcacfa73ef6e 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sh-pfc/pinctrl.c</span>
<span class="p_header">+++ b/drivers/pinctrl/sh-pfc/pinctrl.c</span>
<span class="p_chunk">@@ -570,7 +570,8 @@</span> <span class="p_context"> static bool sh_pfc_pinconf_validate(struct sh_pfc *pfc, unsigned int _pin,</span>
 
 	switch (param) {
 	case PIN_CONFIG_BIAS_DISABLE:
<span class="p_del">-		return true;</span>
<span class="p_add">+		return pin-&gt;configs &amp;</span>
<span class="p_add">+			(SH_PFC_PIN_CFG_PULL_UP | SH_PFC_PIN_CFG_PULL_DOWN);</span>
 
 	case PIN_CONFIG_BIAS_PULL_UP:
 		return pin-&gt;configs &amp; SH_PFC_PIN_CFG_PULL_UP;
<span class="p_header">diff --git a/drivers/pinctrl/sh-pfc/sh_pfc.h b/drivers/pinctrl/sh-pfc/sh_pfc.h</span>
<span class="p_header">index 2345421103db..9556c172e3d2 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sh-pfc/sh_pfc.h</span>
<span class="p_header">+++ b/drivers/pinctrl/sh-pfc/sh_pfc.h</span>
<span class="p_chunk">@@ -189,6 +189,12 @@</span> <span class="p_context"> struct sh_pfc_window {</span>
 	unsigned long size;
 };
 
<span class="p_add">+struct sh_pfc_bias_info {</span>
<span class="p_add">+	u16 pin;</span>
<span class="p_add">+	u16 reg : 11;</span>
<span class="p_add">+	u16 bit : 5;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct sh_pfc_pin_range;
 
 struct sh_pfc {
<span class="p_header">diff --git a/drivers/power/supply/bq24190_charger.c b/drivers/power/supply/bq24190_charger.c</span>
<span class="p_header">index f5746b9f4e83..e9584330aeed 100644</span>
<span class="p_header">--- a/drivers/power/supply/bq24190_charger.c</span>
<span class="p_header">+++ b/drivers/power/supply/bq24190_charger.c</span>
<span class="p_chunk">@@ -1141,7 +1141,7 @@</span> <span class="p_context"> static int bq24190_battery_set_property(struct power_supply *psy,</span>
 
 	dev_dbg(bdi-&gt;dev, &quot;prop: %d\n&quot;, psp);
 
<span class="p_del">-	pm_runtime_put_sync(bdi-&gt;dev);</span>
<span class="p_add">+	pm_runtime_get_sync(bdi-&gt;dev);</span>
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_ONLINE:
<span class="p_header">diff --git a/drivers/power/supply/bq27xxx_battery.c b/drivers/power/supply/bq27xxx_battery.c</span>
<span class="p_header">index 3b0dbc689d72..bccb3f595ff3 100644</span>
<span class="p_header">--- a/drivers/power/supply/bq27xxx_battery.c</span>
<span class="p_header">+++ b/drivers/power/supply/bq27xxx_battery.c</span>
<span class="p_chunk">@@ -164,6 +164,25 @@</span> <span class="p_context"> static u8 bq27xxx_regs[][BQ27XXX_REG_MAX] = {</span>
 		[BQ27XXX_REG_DCAP] = 0x3c,
 		[BQ27XXX_REG_AP] = INVALID_REG_ADDR,
 	},
<span class="p_add">+	[BQ27510] = {</span>
<span class="p_add">+		[BQ27XXX_REG_CTRL] = 0x00,</span>
<span class="p_add">+		[BQ27XXX_REG_TEMP] = 0x06,</span>
<span class="p_add">+		[BQ27XXX_REG_INT_TEMP] = 0x28,</span>
<span class="p_add">+		[BQ27XXX_REG_VOLT] = 0x08,</span>
<span class="p_add">+		[BQ27XXX_REG_AI] = 0x14,</span>
<span class="p_add">+		[BQ27XXX_REG_FLAGS] = 0x0a,</span>
<span class="p_add">+		[BQ27XXX_REG_TTE] = 0x16,</span>
<span class="p_add">+		[BQ27XXX_REG_TTF] = INVALID_REG_ADDR,</span>
<span class="p_add">+		[BQ27XXX_REG_TTES] = 0x1a,</span>
<span class="p_add">+		[BQ27XXX_REG_TTECP] = INVALID_REG_ADDR,</span>
<span class="p_add">+		[BQ27XXX_REG_NAC] = 0x0c,</span>
<span class="p_add">+		[BQ27XXX_REG_FCC] = 0x12,</span>
<span class="p_add">+		[BQ27XXX_REG_CYCT] = 0x1e,</span>
<span class="p_add">+		[BQ27XXX_REG_AE] = INVALID_REG_ADDR,</span>
<span class="p_add">+		[BQ27XXX_REG_SOC] = 0x20,</span>
<span class="p_add">+		[BQ27XXX_REG_DCAP] = 0x2e,</span>
<span class="p_add">+		[BQ27XXX_REG_AP] = INVALID_REG_ADDR,</span>
<span class="p_add">+	},</span>
 	[BQ27530] = {
 		[BQ27XXX_REG_CTRL] = 0x00,
 		[BQ27XXX_REG_TEMP] = 0x06,
<span class="p_chunk">@@ -302,6 +321,24 @@</span> <span class="p_context"> static enum power_supply_property bq27500_battery_props[] = {</span>
 	POWER_SUPPLY_PROP_MANUFACTURER,
 };
 
<span class="p_add">+static enum power_supply_property bq27510_battery_props[] = {</span>
<span class="p_add">+	POWER_SUPPLY_PROP_STATUS,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_PRESENT,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_VOLTAGE_NOW,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_CURRENT_NOW,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_CAPACITY,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_TEMP,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_TECHNOLOGY,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_CHARGE_FULL,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_CHARGE_NOW,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_CYCLE_COUNT,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_HEALTH,</span>
<span class="p_add">+	POWER_SUPPLY_PROP_MANUFACTURER,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static enum power_supply_property bq27530_battery_props[] = {
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_PRESENT,
<span class="p_chunk">@@ -385,6 +422,7 @@</span> <span class="p_context"> static struct {</span>
 	BQ27XXX_PROP(BQ27000, bq27000_battery_props),
 	BQ27XXX_PROP(BQ27010, bq27010_battery_props),
 	BQ27XXX_PROP(BQ27500, bq27500_battery_props),
<span class="p_add">+	BQ27XXX_PROP(BQ27510, bq27510_battery_props),</span>
 	BQ27XXX_PROP(BQ27530, bq27530_battery_props),
 	BQ27XXX_PROP(BQ27541, bq27541_battery_props),
 	BQ27XXX_PROP(BQ27545, bq27545_battery_props),
<span class="p_chunk">@@ -635,7 +673,8 @@</span> <span class="p_context"> static int bq27xxx_battery_read_pwr_avg(struct bq27xxx_device_info *di)</span>
  */
 static bool bq27xxx_battery_overtemp(struct bq27xxx_device_info *di, u16 flags)
 {
<span class="p_del">-	if (di-&gt;chip == BQ27500 || di-&gt;chip == BQ27541 || di-&gt;chip == BQ27545)</span>
<span class="p_add">+	if (di-&gt;chip == BQ27500 || di-&gt;chip == BQ27510 ||</span>
<span class="p_add">+	    di-&gt;chip == BQ27541 || di-&gt;chip == BQ27545)</span>
 		return flags &amp; (BQ27XXX_FLAG_OTC | BQ27XXX_FLAG_OTD);
 	if (di-&gt;chip == BQ27530 || di-&gt;chip == BQ27421)
 		return flags &amp; BQ27XXX_FLAG_OT;
<span class="p_header">diff --git a/drivers/power/supply/bq27xxx_battery_i2c.c b/drivers/power/supply/bq27xxx_battery_i2c.c</span>
<span class="p_header">index 85d4ea2a9c20..5c5c3a6f9923 100644</span>
<span class="p_header">--- a/drivers/power/supply/bq27xxx_battery_i2c.c</span>
<span class="p_header">+++ b/drivers/power/supply/bq27xxx_battery_i2c.c</span>
<span class="p_chunk">@@ -149,8 +149,8 @@</span> <span class="p_context"> static const struct i2c_device_id bq27xxx_i2c_id_table[] = {</span>
 	{ &quot;bq27200&quot;, BQ27000 },
 	{ &quot;bq27210&quot;, BQ27010 },
 	{ &quot;bq27500&quot;, BQ27500 },
<span class="p_del">-	{ &quot;bq27510&quot;, BQ27500 },</span>
<span class="p_del">-	{ &quot;bq27520&quot;, BQ27500 },</span>
<span class="p_add">+	{ &quot;bq27510&quot;, BQ27510 },</span>
<span class="p_add">+	{ &quot;bq27520&quot;, BQ27510 },</span>
 	{ &quot;bq27530&quot;, BQ27530 },
 	{ &quot;bq27531&quot;, BQ27530 },
 	{ &quot;bq27541&quot;, BQ27541 },
<span class="p_header">diff --git a/drivers/powercap/intel_rapl.c b/drivers/powercap/intel_rapl.c</span>
<span class="p_header">index 243b233ff31b..3c71f608b444 100644</span>
<span class="p_header">--- a/drivers/powercap/intel_rapl.c</span>
<span class="p_header">+++ b/drivers/powercap/intel_rapl.c</span>
<span class="p_chunk">@@ -442,6 +442,7 @@</span> <span class="p_context"> static int contraint_to_pl(struct rapl_domain *rd, int cid)</span>
 			return i;
 		}
 	}
<span class="p_add">+	pr_err(&quot;Cannot find matching power limit for constraint %d\n&quot;, cid);</span>
 
 	return -EINVAL;
 }
<span class="p_chunk">@@ -457,6 +458,10 @@</span> <span class="p_context"> static int set_power_limit(struct powercap_zone *power_zone, int cid,</span>
 	get_online_cpus();
 	rd = power_zone_to_rapl_domain(power_zone);
 	id = contraint_to_pl(rd, cid);
<span class="p_add">+	if (id &lt; 0) {</span>
<span class="p_add">+		ret = id;</span>
<span class="p_add">+		goto set_exit;</span>
<span class="p_add">+	}</span>
 
 	rp = rd-&gt;rp;
 
<span class="p_chunk">@@ -496,6 +501,11 @@</span> <span class="p_context"> static int get_current_power_limit(struct powercap_zone *power_zone, int cid,</span>
 	get_online_cpus();
 	rd = power_zone_to_rapl_domain(power_zone);
 	id = contraint_to_pl(rd, cid);
<span class="p_add">+	if (id &lt; 0) {</span>
<span class="p_add">+		ret = id;</span>
<span class="p_add">+		goto get_exit;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	switch (rd-&gt;rpl[id].prim_id) {
 	case PL1_ENABLE:
 		prim = POWER_LIMIT1;
<span class="p_chunk">@@ -512,6 +522,7 @@</span> <span class="p_context"> static int get_current_power_limit(struct powercap_zone *power_zone, int cid,</span>
 	else
 		*data = val;
 
<span class="p_add">+get_exit:</span>
 	put_online_cpus();
 
 	return ret;
<span class="p_chunk">@@ -527,6 +538,10 @@</span> <span class="p_context"> static int set_time_window(struct powercap_zone *power_zone, int cid,</span>
 	get_online_cpus();
 	rd = power_zone_to_rapl_domain(power_zone);
 	id = contraint_to_pl(rd, cid);
<span class="p_add">+	if (id &lt; 0) {</span>
<span class="p_add">+		ret = id;</span>
<span class="p_add">+		goto set_time_exit;</span>
<span class="p_add">+	}</span>
 
 	switch (rd-&gt;rpl[id].prim_id) {
 	case PL1_ENABLE:
<span class="p_chunk">@@ -538,6 +553,8 @@</span> <span class="p_context"> static int set_time_window(struct powercap_zone *power_zone, int cid,</span>
 	default:
 		ret = -EINVAL;
 	}
<span class="p_add">+</span>
<span class="p_add">+set_time_exit:</span>
 	put_online_cpus();
 	return ret;
 }
<span class="p_chunk">@@ -552,6 +569,10 @@</span> <span class="p_context"> static int get_time_window(struct powercap_zone *power_zone, int cid, u64 *data)</span>
 	get_online_cpus();
 	rd = power_zone_to_rapl_domain(power_zone);
 	id = contraint_to_pl(rd, cid);
<span class="p_add">+	if (id &lt; 0) {</span>
<span class="p_add">+		ret = id;</span>
<span class="p_add">+		goto get_time_exit;</span>
<span class="p_add">+	}</span>
 
 	switch (rd-&gt;rpl[id].prim_id) {
 	case PL1_ENABLE:
<span class="p_chunk">@@ -566,6 +587,8 @@</span> <span class="p_context"> static int get_time_window(struct powercap_zone *power_zone, int cid, u64 *data)</span>
 	}
 	if (!ret)
 		*data = val;
<span class="p_add">+</span>
<span class="p_add">+get_time_exit:</span>
 	put_online_cpus();
 
 	return ret;
<span class="p_chunk">@@ -707,7 +730,7 @@</span> <span class="p_context"> static u64 rapl_unit_xlate(struct rapl_domain *rd, enum unit_type type,</span>
 	case ENERGY_UNIT:
 		scale = ENERGY_UNIT_SCALE;
 		/* per domain unit takes precedence */
<span class="p_del">-		if (rd &amp;&amp; rd-&gt;domain_energy_unit)</span>
<span class="p_add">+		if (rd-&gt;domain_energy_unit)</span>
 			units = rd-&gt;domain_energy_unit;
 		else
 			units = rp-&gt;energy_unit;
<span class="p_header">diff --git a/drivers/regulator/axp20x-regulator.c b/drivers/regulator/axp20x-regulator.c</span>
<span class="p_header">index 54382ef902c6..e6a512ebeae2 100644</span>
<span class="p_header">--- a/drivers/regulator/axp20x-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/axp20x-regulator.c</span>
<span class="p_chunk">@@ -337,10 +337,18 @@</span> <span class="p_context"> static const struct regulator_desc axp809_regulators[] = {</span>
 		 AXP22X_ELDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(1)),
 	AXP_DESC(AXP809, ELDO3, &quot;eldo3&quot;, &quot;eldoin&quot;, 700, 3300, 100,
 		 AXP22X_ELDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(2)),
<span class="p_del">-	AXP_DESC_IO(AXP809, LDO_IO0, &quot;ldo_io0&quot;, &quot;ips&quot;, 700, 3300, 100,</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note the datasheet only guarantees reliable operation up to</span>
<span class="p_add">+	 * 3.3V, this needs to be enforced via dts provided constraints</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	AXP_DESC_IO(AXP809, LDO_IO0, &quot;ldo_io0&quot;, &quot;ips&quot;, 700, 3800, 100,</span>
 		    AXP22X_LDO_IO0_V_OUT, 0x1f, AXP20X_GPIO0_CTRL, 0x07,
 		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
<span class="p_del">-	AXP_DESC_IO(AXP809, LDO_IO1, &quot;ldo_io1&quot;, &quot;ips&quot;, 700, 3300, 100,</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note the datasheet only guarantees reliable operation up to</span>
<span class="p_add">+	 * 3.3V, this needs to be enforced via dts provided constraints</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	AXP_DESC_IO(AXP809, LDO_IO1, &quot;ldo_io1&quot;, &quot;ips&quot;, 700, 3800, 100,</span>
 		    AXP22X_LDO_IO1_V_OUT, 0x1f, AXP20X_GPIO1_CTRL, 0x07,
 		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
 	AXP_DESC_FIXED(AXP809, RTC_LDO, &quot;rtc_ldo&quot;, &quot;ips&quot;, 1800),
<span class="p_header">diff --git a/drivers/regulator/helpers.c b/drivers/regulator/helpers.c</span>
<span class="p_header">index bcf38fd5106a..379cdacc05d8 100644</span>
<span class="p_header">--- a/drivers/regulator/helpers.c</span>
<span class="p_header">+++ b/drivers/regulator/helpers.c</span>
<span class="p_chunk">@@ -454,13 +454,17 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(regulator_set_bypass_regmap);</span>
 int regulator_get_bypass_regmap(struct regulator_dev *rdev, bool *enable)
 {
 	unsigned int val;
<span class="p_add">+	unsigned int val_on = rdev-&gt;desc-&gt;bypass_val_on;</span>
 	int ret;
 
 	ret = regmap_read(rdev-&gt;regmap, rdev-&gt;desc-&gt;bypass_reg, &amp;val);
 	if (ret != 0)
 		return ret;
 
<span class="p_del">-	*enable = (val &amp; rdev-&gt;desc-&gt;bypass_mask) == rdev-&gt;desc-&gt;bypass_val_on;</span>
<span class="p_add">+	if (!val_on)</span>
<span class="p_add">+		val_on = rdev-&gt;desc-&gt;bypass_mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	*enable = (val &amp; rdev-&gt;desc-&gt;bypass_mask) == val_on;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/regulator/tps65086-regulator.c b/drivers/regulator/tps65086-regulator.c</span>
<span class="p_header">index 33f389d583ef..caf174ffa316 100644</span>
<span class="p_header">--- a/drivers/regulator/tps65086-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/tps65086-regulator.c</span>
<span class="p_chunk">@@ -71,18 +71,17 @@</span> <span class="p_context"> struct tps65086_regulator {</span>
 	unsigned int decay_mask;
 };
 
<span class="p_del">-static const struct regulator_linear_range tps65086_buck126_10mv_ranges[] = {</span>
<span class="p_add">+static const struct regulator_linear_range tps65086_10mv_ranges[] = {</span>
 	REGULATOR_LINEAR_RANGE(0, 0x0, 0x0, 0),
 	REGULATOR_LINEAR_RANGE(410000, 0x1, 0x7F, 10000),
 };
 
 static const struct regulator_linear_range tps65086_buck126_25mv_ranges[] = {
<span class="p_del">-	REGULATOR_LINEAR_RANGE(0, 0x0, 0x0, 0),</span>
<span class="p_del">-	REGULATOR_LINEAR_RANGE(1000000, 0x1, 0x18, 0),</span>
<span class="p_add">+	REGULATOR_LINEAR_RANGE(1000000, 0x0, 0x18, 0),</span>
 	REGULATOR_LINEAR_RANGE(1025000, 0x19, 0x7F, 25000),
 };
 
<span class="p_del">-static const struct regulator_linear_range tps65086_buck345_ranges[] = {</span>
<span class="p_add">+static const struct regulator_linear_range tps65086_buck345_25mv_ranges[] = {</span>
 	REGULATOR_LINEAR_RANGE(0, 0x0, 0x0, 0),
 	REGULATOR_LINEAR_RANGE(425000, 0x1, 0x7F, 25000),
 };
<span class="p_chunk">@@ -125,27 +124,27 @@</span> <span class="p_context"> static int tps65086_of_parse_cb(struct device_node *dev,</span>
 static struct tps65086_regulator regulators[] = {
 	TPS65086_REGULATOR(&quot;BUCK1&quot;, &quot;buck1&quot;, BUCK1, 0x80, TPS65086_BUCK1CTRL,
 			   BUCK_VID_MASK, TPS65086_BUCK123CTRL, BIT(0),
<span class="p_del">-			   tps65086_buck126_10mv_ranges, TPS65086_BUCK1CTRL,</span>
<span class="p_add">+			   tps65086_10mv_ranges, TPS65086_BUCK1CTRL,</span>
 			   BIT(0)),
 	TPS65086_REGULATOR(&quot;BUCK2&quot;, &quot;buck2&quot;, BUCK2, 0x80, TPS65086_BUCK2CTRL,
 			   BUCK_VID_MASK, TPS65086_BUCK123CTRL, BIT(1),
<span class="p_del">-			   tps65086_buck126_10mv_ranges, TPS65086_BUCK2CTRL,</span>
<span class="p_add">+			   tps65086_10mv_ranges, TPS65086_BUCK2CTRL,</span>
 			   BIT(0)),
 	TPS65086_REGULATOR(&quot;BUCK3&quot;, &quot;buck3&quot;, BUCK3, 0x80, TPS65086_BUCK3VID,
 			   BUCK_VID_MASK, TPS65086_BUCK123CTRL, BIT(2),
<span class="p_del">-			   tps65086_buck345_ranges, TPS65086_BUCK3DECAY,</span>
<span class="p_add">+			   tps65086_10mv_ranges, TPS65086_BUCK3DECAY,</span>
 			   BIT(0)),
 	TPS65086_REGULATOR(&quot;BUCK4&quot;, &quot;buck4&quot;, BUCK4, 0x80, TPS65086_BUCK4VID,
 			   BUCK_VID_MASK, TPS65086_BUCK4CTRL, BIT(0),
<span class="p_del">-			   tps65086_buck345_ranges, TPS65086_BUCK4VID,</span>
<span class="p_add">+			   tps65086_10mv_ranges, TPS65086_BUCK4VID,</span>
 			   BIT(0)),
 	TPS65086_REGULATOR(&quot;BUCK5&quot;, &quot;buck5&quot;, BUCK5, 0x80, TPS65086_BUCK5VID,
 			   BUCK_VID_MASK, TPS65086_BUCK5CTRL, BIT(0),
<span class="p_del">-			   tps65086_buck345_ranges, TPS65086_BUCK5CTRL,</span>
<span class="p_add">+			   tps65086_10mv_ranges, TPS65086_BUCK5CTRL,</span>
 			   BIT(0)),
 	TPS65086_REGULATOR(&quot;BUCK6&quot;, &quot;buck6&quot;, BUCK6, 0x80, TPS65086_BUCK6VID,
 			   BUCK_VID_MASK, TPS65086_BUCK6CTRL, BIT(0),
<span class="p_del">-			   tps65086_buck126_10mv_ranges, TPS65086_BUCK6CTRL,</span>
<span class="p_add">+			   tps65086_10mv_ranges, TPS65086_BUCK6CTRL,</span>
 			   BIT(0)),
 	TPS65086_REGULATOR(&quot;LDOA1&quot;, &quot;ldoa1&quot;, LDOA1, 0xF, TPS65086_LDOA1CTRL,
 			   VDOA1_VID_MASK, TPS65086_LDOA1CTRL, BIT(0),
<span class="p_chunk">@@ -162,18 +161,6 @@</span> <span class="p_context"> static struct tps65086_regulator regulators[] = {</span>
 	TPS65086_SWITCH(&quot;VTT&quot;, &quot;vtt&quot;, VTT, TPS65086_SWVTT_EN, BIT(4)),
 };
 
<span class="p_del">-static inline bool has_25mv_mode(int id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (id) {</span>
<span class="p_del">-	case BUCK1:</span>
<span class="p_del">-	case BUCK2:</span>
<span class="p_del">-	case BUCK6:</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int tps65086_of_parse_cb(struct device_node *dev,
 				const struct regulator_desc *desc,
 				struct regulator_config *config)
<span class="p_chunk">@@ -181,12 +168,27 @@</span> <span class="p_context"> static int tps65086_of_parse_cb(struct device_node *dev,</span>
 	int ret;
 
 	/* Check for 25mV step mode */
<span class="p_del">-	if (has_25mv_mode(desc-&gt;id) &amp;&amp;</span>
<span class="p_del">-			of_property_read_bool(config-&gt;of_node, &quot;ti,regulator-step-size-25mv&quot;)) {</span>
<span class="p_del">-		regulators[desc-&gt;id].desc.linear_ranges =</span>
<span class="p_add">+	if (of_property_read_bool(config-&gt;of_node, &quot;ti,regulator-step-size-25mv&quot;)) {</span>
<span class="p_add">+		switch (desc-&gt;id) {</span>
<span class="p_add">+		case BUCK1:</span>
<span class="p_add">+		case BUCK2:</span>
<span class="p_add">+		case BUCK6:</span>
<span class="p_add">+			regulators[desc-&gt;id].desc.linear_ranges =</span>
 				tps65086_buck126_25mv_ranges;
<span class="p_del">-		regulators[desc-&gt;id].desc.n_linear_ranges =</span>
<span class="p_add">+			regulators[desc-&gt;id].desc.n_linear_ranges =</span>
 				ARRAY_SIZE(tps65086_buck126_25mv_ranges);
<span class="p_add">+			break;</span>
<span class="p_add">+		case BUCK3:</span>
<span class="p_add">+		case BUCK4:</span>
<span class="p_add">+		case BUCK5:</span>
<span class="p_add">+			regulators[desc-&gt;id].desc.linear_ranges =</span>
<span class="p_add">+				tps65086_buck345_25mv_ranges;</span>
<span class="p_add">+			regulators[desc-&gt;id].desc.n_linear_ranges =</span>
<span class="p_add">+				ARRAY_SIZE(tps65086_buck345_25mv_ranges);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			dev_warn(config-&gt;dev, &quot;25mV step mode only valid for BUCK regulators\n&quot;);</span>
<span class="p_add">+		}</span>
 	}
 
 	/* Check for decay mode */
<span class="p_header">diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig</span>
<span class="p_header">index f396bfef5d42..5fcbefcb8636 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Kconfig</span>
<span class="p_header">+++ b/drivers/remoteproc/Kconfig</span>
<span class="p_chunk">@@ -91,17 +91,12 @@</span> <span class="p_context"> config QCOM_Q6V5_PIL</span>
 	  Say y here to support the Qualcomm Peripherial Image Loader for the
 	  Hexagon V5 based remote processors.
 
<span class="p_del">-config QCOM_WCNSS_IRIS</span>
<span class="p_del">-	tristate</span>
<span class="p_del">-	depends on OF &amp;&amp; ARCH_QCOM</span>
<span class="p_del">-</span>
 config QCOM_WCNSS_PIL
 	tristate &quot;Qualcomm WCNSS Peripheral Image Loader&quot;
 	depends on OF &amp;&amp; ARCH_QCOM
 	depends on QCOM_SMEM
 	select QCOM_MDT_LOADER
 	select QCOM_SCM
<span class="p_del">-	select QCOM_WCNSS_IRIS</span>
 	select REMOTEPROC
 	help
 	  Say y here to support the Peripheral Image Loader for the Qualcomm
<span class="p_header">diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile</span>
<span class="p_header">index 6dfb62ed643f..034b6f3563a7 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Makefile</span>
<span class="p_header">+++ b/drivers/remoteproc/Makefile</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"> obj-$(CONFIG_WKUP_M3_RPROC)		+= wkup_m3_rproc.o</span>
 obj-$(CONFIG_DA8XX_REMOTEPROC)		+= da8xx_remoteproc.o
 obj-$(CONFIG_QCOM_MDT_LOADER)		+= qcom_mdt_loader.o
 obj-$(CONFIG_QCOM_Q6V5_PIL)		+= qcom_q6v5_pil.o
<span class="p_del">-obj-$(CONFIG_QCOM_WCNSS_IRIS)		+= qcom_wcnss_iris.o</span>
<span class="p_del">-obj-$(CONFIG_QCOM_WCNSS_PIL)		+= qcom_wcnss.o</span>
<span class="p_add">+obj-$(CONFIG_QCOM_WCNSS_PIL)		+= qcom_wcnss_pil.o</span>
<span class="p_add">+qcom_wcnss_pil-y			+= qcom_wcnss.o</span>
<span class="p_add">+qcom_wcnss_pil-y			+= qcom_wcnss_iris.o</span>
 obj-$(CONFIG_ST_REMOTEPROC)		+= st_remoteproc.o
<span class="p_header">diff --git a/drivers/remoteproc/qcom_wcnss.c b/drivers/remoteproc/qcom_wcnss.c</span>
<span class="p_header">index f5cedeaafba1..323b629474a6 100644</span>
<span class="p_header">--- a/drivers/remoteproc/qcom_wcnss.c</span>
<span class="p_header">+++ b/drivers/remoteproc/qcom_wcnss.c</span>
<span class="p_chunk">@@ -143,7 +143,6 @@</span> <span class="p_context"> void qcom_wcnss_assign_iris(struct qcom_wcnss *wcnss,</span>
 
 	mutex_unlock(&amp;wcnss-&gt;iris_lock);
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(qcom_wcnss_assign_iris);</span>
 
 static int wcnss_load(struct rproc *rproc, const struct firmware *fw)
 {
<span class="p_chunk">@@ -619,6 +618,28 @@</span> <span class="p_context"> static struct platform_driver wcnss_driver = {</span>
 	},
 };
 
<span class="p_del">-module_platform_driver(wcnss_driver);</span>
<span class="p_add">+static int __init wcnss_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = platform_driver_register(&amp;wcnss_driver);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = platform_driver_register(&amp;qcom_iris_driver);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		platform_driver_unregister(&amp;wcnss_driver);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+module_init(wcnss_init);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit wcnss_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	platform_driver_unregister(&amp;qcom_iris_driver);</span>
<span class="p_add">+	platform_driver_unregister(&amp;wcnss_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+module_exit(wcnss_exit);</span>
<span class="p_add">+</span>
 MODULE_DESCRIPTION(&quot;Qualcomm Peripherial Image Loader for Wireless Subsystem&quot;);
 MODULE_LICENSE(&quot;GPL v2&quot;);
<span class="p_header">diff --git a/drivers/remoteproc/qcom_wcnss.h b/drivers/remoteproc/qcom_wcnss.h</span>
<span class="p_header">index 9dc4a9fe41e1..25fb7f62a457 100644</span>
<span class="p_header">--- a/drivers/remoteproc/qcom_wcnss.h</span>
<span class="p_header">+++ b/drivers/remoteproc/qcom_wcnss.h</span>
<span class="p_chunk">@@ -4,6 +4,8 @@</span> <span class="p_context"></span>
 struct qcom_iris;
 struct qcom_wcnss;
 
<span class="p_add">+extern struct platform_driver qcom_iris_driver;</span>
<span class="p_add">+</span>
 struct wcnss_vreg_info {
 	const char * const name;
 	int min_voltage;
<span class="p_header">diff --git a/drivers/remoteproc/qcom_wcnss_iris.c b/drivers/remoteproc/qcom_wcnss_iris.c</span>
<span class="p_header">index f0ca24a8dd0b..05d6e175411a 100644</span>
<span class="p_header">--- a/drivers/remoteproc/qcom_wcnss_iris.c</span>
<span class="p_header">+++ b/drivers/remoteproc/qcom_wcnss_iris.c</span>
<span class="p_chunk">@@ -94,14 +94,12 @@</span> <span class="p_context"> int qcom_iris_enable(struct qcom_iris *iris)</span>
 
 	return ret;
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(qcom_iris_enable);</span>
 
 void qcom_iris_disable(struct qcom_iris *iris)
 {
 	clk_disable_unprepare(iris-&gt;xo_clk);
 	regulator_bulk_disable(iris-&gt;num_vregs, iris-&gt;vregs);
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(qcom_iris_disable);</span>
 
 static int qcom_iris_probe(struct platform_device *pdev)
 {
<span class="p_chunk">@@ -174,7 +172,7 @@</span> <span class="p_context"> static const struct of_device_id iris_of_match[] = {</span>
 	{}
 };
 
<span class="p_del">-static struct platform_driver wcnss_driver = {</span>
<span class="p_add">+struct platform_driver qcom_iris_driver = {</span>
 	.probe = qcom_iris_probe,
 	.remove = qcom_iris_remove,
 	.driver = {
<span class="p_chunk">@@ -182,7 +180,3 @@</span> <span class="p_context"> static struct platform_driver wcnss_driver = {</span>
 		.of_match_table = iris_of_match,
 	},
 };
<span class="p_del">-</span>
<span class="p_del">-module_platform_driver(wcnss_driver);</span>
<span class="p_del">-MODULE_DESCRIPTION(&quot;Qualcomm Wireless Subsystem Iris driver&quot;);</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="p_header">diff --git a/drivers/remoteproc/st_remoteproc.c b/drivers/remoteproc/st_remoteproc.c</span>
<span class="p_header">index ae8963fcc8c8..da4e152e9733 100644</span>
<span class="p_header">--- a/drivers/remoteproc/st_remoteproc.c</span>
<span class="p_header">+++ b/drivers/remoteproc/st_remoteproc.c</span>
<span class="p_chunk">@@ -245,8 +245,10 @@</span> <span class="p_context"> static int st_rproc_probe(struct platform_device *pdev)</span>
 		goto free_rproc;
 
 	enabled = st_rproc_state(pdev);
<span class="p_del">-	if (enabled &lt; 0)</span>
<span class="p_add">+	if (enabled &lt; 0) {</span>
<span class="p_add">+		ret = enabled;</span>
 		goto free_rproc;
<span class="p_add">+	}</span>
 
 	if (enabled) {
 		atomic_inc(&amp;rproc-&gt;power);
<span class="p_header">diff --git a/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c b/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c</span>
<span class="p_header">index 642b739ad0da..608140f16d98 100644</span>
<span class="p_header">--- a/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c</span>
<span class="p_header">+++ b/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c</span>
<span class="p_chunk">@@ -3702,7 +3702,7 @@</span> <span class="p_context"> static int ibmvscsis_write_pending(struct se_cmd *se_cmd)</span>
 			       1, 1);
 	if (rc) {
 		pr_err(&quot;srp_transfer_data() failed: %d\n&quot;, rc);
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_add">+		return -EIO;</span>
 	}
 	/*
 	 * We now tell TCM to add this WRITE CDB directly into the TCM storage
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c</span>
<span class="p_header">index 240a361b674f..e8819aa20415 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_core.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_core.c</span>
<span class="p_chunk">@@ -675,7 +675,7 @@</span> <span class="p_context"> static struct console univ8250_console = {</span>
 	.device		= uart_console_device,
 	.setup		= univ8250_console_setup,
 	.match		= univ8250_console_match,
<span class="p_del">-	.flags		= CON_PRINTBUFFER | CON_ANYTIME | CON_CONSDEV,</span>
<span class="p_add">+	.flags		= CON_PRINTBUFFER | CON_ANYTIME,</span>
 	.index		= -1,
 	.data		= &amp;serial8250_reg,
 };
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">index 1731b98d2471..080d5a59d0a7 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_chunk">@@ -1411,7 +1411,7 @@</span> <span class="p_context"> static void __do_stop_tx_rs485(struct uart_8250_port *p)</span>
 	 * Enable previously disabled RX interrupts.
 	 */
 	if (!(p-&gt;port.rs485.flags &amp; SER_RS485_RX_DURING_TX)) {
<span class="p_del">-		serial8250_clear_fifos(p);</span>
<span class="p_add">+		serial8250_clear_and_reinit_fifos(p);</span>
 
 		p-&gt;ier |= UART_IER_RLSI | UART_IER_RDI;
 		serial_port_out(&amp;p-&gt;port, UART_IER, p-&gt;ier);
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 168b10cad47b..fabbe76203bb 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -481,6 +481,14 @@</span> <span class="p_context"> static void atmel_stop_tx(struct uart_port *port)</span>
 		/* disable PDC transmit */
 		atmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS);
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Disable the transmitter.</span>
<span class="p_add">+	 * This is mandatory when DMA is used, otherwise the DMA buffer</span>
<span class="p_add">+	 * is fully transmitted.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	atmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXDIS);</span>
<span class="p_add">+</span>
 	/* Disable interrupts */
 	atmel_uart_writel(port, ATMEL_US_IDR, atmel_port-&gt;tx_done_mask);
 
<span class="p_chunk">@@ -513,6 +521,9 @@</span> <span class="p_context"> static void atmel_start_tx(struct uart_port *port)</span>
 
 	/* Enable interrupts */
 	atmel_uart_writel(port, ATMEL_US_IER, atmel_port-&gt;tx_done_mask);
<span class="p_add">+</span>
<span class="p_add">+	/* re-enable the transmitter */</span>
<span class="p_add">+	atmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN);</span>
 }
 
 /*
<span class="p_chunk">@@ -798,6 +809,11 @@</span> <span class="p_context"> static void atmel_complete_tx_dma(void *arg)</span>
 	 */
 	if (!uart_circ_empty(xmit))
 		atmel_tasklet_schedule(atmel_port, &amp;atmel_port-&gt;tasklet_tx);
<span class="p_add">+	else if ((port-&gt;rs485.flags &amp; SER_RS485_ENABLED) &amp;&amp;</span>
<span class="p_add">+		 !(port-&gt;rs485.flags &amp; SER_RS485_RX_DURING_TX)) {</span>
<span class="p_add">+		/* DMA done, stop TX, start RX for RS485 */</span>
<span class="p_add">+		atmel_start_rx(port);</span>
<span class="p_add">+	}</span>
 
 	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);
 }
<span class="p_chunk">@@ -900,12 +916,6 @@</span> <span class="p_context"> static void atmel_tx_dma(struct uart_port *port)</span>
 		desc-&gt;callback = atmel_complete_tx_dma;
 		desc-&gt;callback_param = atmel_port;
 		atmel_port-&gt;cookie_tx = dmaengine_submit(desc);
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (port-&gt;rs485.flags &amp; SER_RS485_ENABLED) {</span>
<span class="p_del">-			/* DMA done, stop TX, start RX for RS485 */</span>
<span class="p_del">-			atmel_start_rx(port);</span>
<span class="p_del">-		}</span>
 	}
 
 	if (uart_circ_chars_pending(xmit) &lt; WAKEUP_CHARS)
<span class="p_header">diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c</span>
<span class="p_header">index 52bbd27e93ae..701c085bb19b 100644</span>
<span class="p_header">--- a/drivers/tty/sysrq.c</span>
<span class="p_header">+++ b/drivers/tty/sysrq.c</span>
<span class="p_chunk">@@ -946,8 +946,8 @@</span> <span class="p_context"> static const struct input_device_id sysrq_ids[] = {</span>
 	{
 		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
 				INPUT_DEVICE_ID_MATCH_KEYBIT,
<span class="p_del">-		.evbit = { BIT_MASK(EV_KEY) },</span>
<span class="p_del">-		.keybit = { BIT_MASK(KEY_LEFTALT) },</span>
<span class="p_add">+		.evbit = { [BIT_WORD(EV_KEY)] = BIT_MASK(EV_KEY) },</span>
<span class="p_add">+		.keybit = { [BIT_WORD(KEY_LEFTALT)] = BIT_MASK(KEY_LEFTALT) },</span>
 	},
 	{ },
 };
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 771a6da9caea..521c1816a26a 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -917,17 +917,6 @@</span> <span class="p_context"> void xhci_stop_endpoint_command_watchdog(unsigned long arg)</span>
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 
 	ep-&gt;stop_cmds_pending--;
<span class="p_del">-	if (xhci-&gt;xhc_state &amp; XHCI_STATE_REMOVING) {</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) {</span>
<span class="p_del">-		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,</span>
<span class="p_del">-				&quot;Stop EP timer ran, but another timer marked &quot;</span>
<span class="p_del">-				&quot;xHCI as DYING, exiting.&quot;);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
 	if (!(ep-&gt;stop_cmds_pending == 0 &amp;&amp; (ep-&gt;ep_state &amp; EP_HALT_PENDING))) {
 		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
 				&quot;Stop EP timer ran, but no command pending, &quot;
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index ad0624386950..34e23c7d7797 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -1529,19 +1529,6 @@</span> <span class="p_context"> int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 		xhci_urb_free_priv(urb_priv);
 		return ret;
 	}
<span class="p_del">-	if ((xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) ||</span>
<span class="p_del">-			(xhci-&gt;xhc_state &amp; XHCI_STATE_HALTED)) {</span>
<span class="p_del">-		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,</span>
<span class="p_del">-				&quot;Ep 0x%x: URB %p to be canceled on &quot;</span>
<span class="p_del">-				&quot;non-responsive xHCI host.&quot;,</span>
<span class="p_del">-				urb-&gt;ep-&gt;desc.bEndpointAddress, urb);</span>
<span class="p_del">-		/* Let the stop endpoint command watchdog timer (which set this</span>
<span class="p_del">-		 * state) finish cleaning up the endpoint TD lists.  We must</span>
<span class="p_del">-		 * have caught it in the middle of dropping a lock and giving</span>
<span class="p_del">-		 * back an URB.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		goto done;</span>
<span class="p_del">-	}</span>
 
 	ep_index = xhci_get_endpoint_index(&amp;urb-&gt;ep-&gt;desc);
 	ep = &amp;xhci-&gt;devs[urb-&gt;dev-&gt;slot_id]-&gt;eps[ep_index];
<span class="p_header">diff --git a/drivers/usb/musb/musb_debugfs.c b/drivers/usb/musb/musb_debugfs.c</span>
<span class="p_header">index 9b22d946c089..534a3f6fa89c 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_debugfs.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_debugfs.c</span>
<span class="p_chunk">@@ -114,6 +114,7 @@</span> <span class="p_context"> static int musb_regdump_show(struct seq_file *s, void *unused)</span>
 	unsigned		i;
 
 	seq_printf(s, &quot;MUSB (M)HDRC Register Dump\n&quot;);
<span class="p_add">+	pm_runtime_get_sync(musb-&gt;controller);</span>
 
 	for (i = 0; i &lt; ARRAY_SIZE(musb_regmap); i++) {
 		switch (musb_regmap[i].size) {
<span class="p_chunk">@@ -132,6 +133,8 @@</span> <span class="p_context"> static int musb_regdump_show(struct seq_file *s, void *unused)</span>
 		}
 	}
 
<span class="p_add">+	pm_runtime_mark_last_busy(musb-&gt;controller);</span>
<span class="p_add">+	pm_runtime_put_autosuspend(musb-&gt;controller);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -145,7 +148,10 @@</span> <span class="p_context"> static int musb_test_mode_show(struct seq_file *s, void *unused)</span>
 	struct musb		*musb = s-&gt;private;
 	unsigned		test;
 
<span class="p_add">+	pm_runtime_get_sync(musb-&gt;controller);</span>
 	test = musb_readb(musb-&gt;mregs, MUSB_TESTMODE);
<span class="p_add">+	pm_runtime_mark_last_busy(musb-&gt;controller);</span>
<span class="p_add">+	pm_runtime_put_autosuspend(musb-&gt;controller);</span>
 
 	if (test &amp; MUSB_TEST_FORCE_HOST)
 		seq_printf(s, &quot;force host\n&quot;);
<span class="p_chunk">@@ -194,11 +200,12 @@</span> <span class="p_context"> static ssize_t musb_test_mode_write(struct file *file,</span>
 	u8			test;
 	char			buf[18];
 
<span class="p_add">+	pm_runtime_get_sync(musb-&gt;controller);</span>
 	test = musb_readb(musb-&gt;mregs, MUSB_TESTMODE);
 	if (test) {
 		dev_err(musb-&gt;controller, &quot;Error: test mode is already set. &quot;
 			&quot;Please do USB Bus Reset to start a new test.\n&quot;);
<span class="p_del">-		return count;</span>
<span class="p_add">+		goto ret;</span>
 	}
 
 	memset(buf, 0x00, sizeof(buf));
<span class="p_chunk">@@ -234,6 +241,9 @@</span> <span class="p_context"> static ssize_t musb_test_mode_write(struct file *file,</span>
 
 	musb_writeb(musb-&gt;mregs, MUSB_TESTMODE, test);
 
<span class="p_add">+ret:</span>
<span class="p_add">+	pm_runtime_mark_last_busy(musb-&gt;controller);</span>
<span class="p_add">+	pm_runtime_put_autosuspend(musb-&gt;controller);</span>
 	return count;
 }
 
<span class="p_chunk">@@ -254,8 +264,13 @@</span> <span class="p_context"> static int musb_softconnect_show(struct seq_file *s, void *unused)</span>
 	switch (musb-&gt;xceiv-&gt;otg-&gt;state) {
 	case OTG_STATE_A_HOST:
 	case OTG_STATE_A_WAIT_BCON:
<span class="p_add">+		pm_runtime_get_sync(musb-&gt;controller);</span>
<span class="p_add">+</span>
 		reg = musb_readb(musb-&gt;mregs, MUSB_DEVCTL);
 		connect = reg &amp; MUSB_DEVCTL_SESSION ? 1 : 0;
<span class="p_add">+</span>
<span class="p_add">+		pm_runtime_mark_last_busy(musb-&gt;controller);</span>
<span class="p_add">+		pm_runtime_put_autosuspend(musb-&gt;controller);</span>
 		break;
 	default:
 		connect = -1;
<span class="p_chunk">@@ -284,6 +299,7 @@</span> <span class="p_context"> static ssize_t musb_softconnect_write(struct file *file,</span>
 	if (copy_from_user(&amp;buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
 		return -EFAULT;
 
<span class="p_add">+	pm_runtime_get_sync(musb-&gt;controller);</span>
 	if (!strncmp(buf, &quot;0&quot;, 1)) {
 		switch (musb-&gt;xceiv-&gt;otg-&gt;state) {
 		case OTG_STATE_A_HOST:
<span class="p_chunk">@@ -314,6 +330,8 @@</span> <span class="p_context"> static ssize_t musb_softconnect_write(struct file *file,</span>
 		}
 	}
 
<span class="p_add">+	pm_runtime_mark_last_busy(musb-&gt;controller);</span>
<span class="p_add">+	pm_runtime_put_autosuspend(musb-&gt;controller);</span>
 	return count;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/ch341.c b/drivers/usb/serial/ch341.c</span>
<span class="p_header">index f139488d0816..e98590aab633 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ch341.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ch341.c</span>
<span class="p_chunk">@@ -99,6 +99,8 @@</span> <span class="p_context"> static int ch341_control_out(struct usb_device *dev, u8 request,</span>
 	r = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), request,
 			    USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,
 			    value, index, NULL, 0, DEFAULT_TIMEOUT);
<span class="p_add">+	if (r &lt; 0)</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;failed to send control message: %d\n&quot;, r);</span>
 
 	return r;
 }
<span class="p_chunk">@@ -116,7 +118,20 @@</span> <span class="p_context"> static int ch341_control_in(struct usb_device *dev,</span>
 	r = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
 			    USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
 			    value, index, buf, bufsize, DEFAULT_TIMEOUT);
<span class="p_del">-	return r;</span>
<span class="p_add">+	if (r &lt; bufsize) {</span>
<span class="p_add">+		if (r &gt;= 0) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev,</span>
<span class="p_add">+				&quot;short control message received (%d &lt; %u)\n&quot;,</span>
<span class="p_add">+				r, bufsize);</span>
<span class="p_add">+			r = -EIO;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;failed to receive control message: %d\n&quot;,</span>
<span class="p_add">+			r);</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int ch341_set_baudrate(struct usb_device *dev,
<span class="p_chunk">@@ -158,9 +173,9 @@</span> <span class="p_context"> static int ch341_set_handshake(struct usb_device *dev, u8 control)</span>
 
 static int ch341_get_status(struct usb_device *dev, struct ch341_private *priv)
 {
<span class="p_add">+	const unsigned int size = 2;</span>
 	char *buffer;
 	int r;
<span class="p_del">-	const unsigned size = 8;</span>
 	unsigned long flags;
 
 	buffer = kmalloc(size, GFP_KERNEL);
<span class="p_chunk">@@ -171,14 +186,9 @@</span> <span class="p_context"> static int ch341_get_status(struct usb_device *dev, struct ch341_private *priv)</span>
 	if (r &lt; 0)
 		goto out;
 
<span class="p_del">-	/* setup the private status if available */</span>
<span class="p_del">-	if (r == 2) {</span>
<span class="p_del">-		r = 0;</span>
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_status = (~(*buffer)) &amp; CH341_BITS_MODEM_STAT;</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		r = -EPROTO;</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	priv-&gt;line_status = (~(*buffer)) &amp; CH341_BITS_MODEM_STAT;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
 
 out:	kfree(buffer);
 	return r;
<span class="p_chunk">@@ -188,9 +198,9 @@</span> <span class="p_context"> out:	kfree(buffer);</span>
 
 static int ch341_configure(struct usb_device *dev, struct ch341_private *priv)
 {
<span class="p_add">+	const unsigned int size = 2;</span>
 	char *buffer;
 	int r;
<span class="p_del">-	const unsigned size = 8;</span>
 
 	buffer = kmalloc(size, GFP_KERNEL);
 	if (!buffer)
<span class="p_chunk">@@ -253,7 +263,6 @@</span> <span class="p_context"> static int ch341_port_probe(struct usb_serial_port *port)</span>
 
 	spin_lock_init(&amp;priv-&gt;lock);
 	priv-&gt;baud_rate = DEFAULT_BAUD_RATE;
<span class="p_del">-	priv-&gt;line_control = CH341_BIT_RTS | CH341_BIT_DTR;</span>
 
 	r = ch341_configure(port-&gt;serial-&gt;dev, priv);
 	if (r &lt; 0)
<span class="p_chunk">@@ -315,7 +324,7 @@</span> <span class="p_context"> static int ch341_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 
 	r = ch341_configure(serial-&gt;dev, priv);
 	if (r)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return r;</span>
 
 	if (tty)
 		ch341_set_termios(tty, port, NULL);
<span class="p_chunk">@@ -325,12 +334,19 @@</span> <span class="p_context"> static int ch341_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 	if (r) {
 		dev_err(&amp;port-&gt;dev, &quot;%s - failed to submit interrupt urb: %d\n&quot;,
 			__func__, r);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return r;</span>
 	}
 
 	r = usb_serial_generic_open(tty, port);
<span class="p_add">+	if (r)</span>
<span class="p_add">+		goto err_kill_interrupt_urb;</span>
 
<span class="p_del">-out:	return r;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_kill_interrupt_urb:</span>
<span class="p_add">+	usb_kill_urb(port-&gt;interrupt_in_urb);</span>
<span class="p_add">+</span>
<span class="p_add">+	return r;</span>
 }
 
 /* Old_termios contains the original termios settings and
<span class="p_chunk">@@ -345,26 +361,25 @@</span> <span class="p_context"> static void ch341_set_termios(struct tty_struct *tty,</span>
 
 	baud_rate = tty_get_baud_rate(tty);
 
<span class="p_del">-	priv-&gt;baud_rate = baud_rate;</span>
<span class="p_del">-</span>
 	if (baud_rate) {
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_control |= (CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+		priv-&gt;baud_rate = baud_rate;</span>
 		ch341_set_baudrate(port-&gt;serial-&gt;dev, priv);
<span class="p_del">-	} else {</span>
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_control &amp;= ~(CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
 	}
 
<span class="p_del">-	ch341_set_handshake(port-&gt;serial-&gt;dev, priv-&gt;line_control);</span>
<span class="p_del">-</span>
 	/* Unimplemented:
 	 * (cflag &amp; CSIZE) : data bits [5, 8]
 	 * (cflag &amp; PARENB) : parity {NONE, EVEN, ODD}
 	 * (cflag &amp; CSTOPB) : stop bits [1, 2]
 	 */
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	if (C_BAUD(tty) == B0)</span>
<span class="p_add">+		priv-&gt;line_control &amp;= ~(CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_add">+	else if (old_termios &amp;&amp; (old_termios-&gt;c_cflag &amp; CBAUD) == B0)</span>
<span class="p_add">+		priv-&gt;line_control |= (CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	ch341_set_handshake(port-&gt;serial-&gt;dev, priv-&gt;line_control);</span>
 }
 
 static void ch341_break_ctl(struct tty_struct *tty, int break_state)
<span class="p_chunk">@@ -539,14 +554,23 @@</span> <span class="p_context"> static int ch341_tiocmget(struct tty_struct *tty)</span>
 
 static int ch341_reset_resume(struct usb_serial *serial)
 {
<span class="p_del">-	struct ch341_private *priv;</span>
<span class="p_del">-</span>
<span class="p_del">-	priv = usb_get_serial_port_data(serial-&gt;port[0]);</span>
<span class="p_add">+	struct usb_serial_port *port = serial-&gt;port[0];</span>
<span class="p_add">+	struct ch341_private *priv = usb_get_serial_port_data(port);</span>
<span class="p_add">+	int ret;</span>
 
 	/* reconfigure ch341 serial port after bus-reset */
 	ch341_configure(serial-&gt;dev, priv);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (tty_port_initialized(&amp;port-&gt;port)) {</span>
<span class="p_add">+		ret = usb_submit_urb(port-&gt;interrupt_in_urb, GFP_NOIO);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(&amp;port-&gt;dev, &quot;failed to submit interrupt urb: %d\n&quot;,</span>
<span class="p_add">+				ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return usb_serial_generic_resume(serial);</span>
 }
 
 static struct usb_serial_driver ch341_device = {
<span class="p_header">diff --git a/drivers/usb/serial/kl5kusb105.c b/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_header">index 0ee190fc1bf8..6cb45757818f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_header">+++ b/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_chunk">@@ -192,10 +192,11 @@</span> <span class="p_context"> static int klsi_105_get_line_state(struct usb_serial_port *port,</span>
 			     status_buf, KLSI_STATUSBUF_LEN,
 			     10000
 			     );
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		dev_err(&amp;port-&gt;dev, &quot;Reading line status failed (error = %d)\n&quot;,</span>
<span class="p_del">-			rc);</span>
<span class="p_del">-	else {</span>
<span class="p_add">+	if (rc != KLSI_STATUSBUF_LEN) {</span>
<span class="p_add">+		dev_err(&amp;port-&gt;dev, &quot;reading line status failed: %d\n&quot;, rc);</span>
<span class="p_add">+		if (rc &gt;= 0)</span>
<span class="p_add">+			rc = -EIO;</span>
<span class="p_add">+	} else {</span>
 		status = get_unaligned_le16(status_buf);
 
 		dev_info(&amp;port-&gt;serial-&gt;dev-&gt;dev, &quot;read status %x %x\n&quot;,
<span class="p_header">diff --git a/drivers/usb/wusbcore/crypto.c b/drivers/usb/wusbcore/crypto.c</span>
<span class="p_header">index 79451f7ef1b7..062c205f0046 100644</span>
<span class="p_header">--- a/drivers/usb/wusbcore/crypto.c</span>
<span class="p_header">+++ b/drivers/usb/wusbcore/crypto.c</span>
<span class="p_chunk">@@ -216,7 +216,6 @@</span> <span class="p_context"> static int wusb_ccm_mac(struct crypto_skcipher *tfm_cbc,</span>
 	struct scatterlist sg[4], sg_dst;
 	void *dst_buf;
 	size_t dst_size;
<span class="p_del">-	const u8 bzero[16] = { 0 };</span>
 	u8 iv[crypto_skcipher_ivsize(tfm_cbc)];
 	size_t zero_padding;
 
<span class="p_chunk">@@ -261,7 +260,7 @@</span> <span class="p_context"> static int wusb_ccm_mac(struct crypto_skcipher *tfm_cbc,</span>
 	sg_set_buf(&amp;sg[1], &amp;scratch-&gt;b1, sizeof(scratch-&gt;b1));
 	sg_set_buf(&amp;sg[2], b, blen);
 	/* 0 if well behaved :) */
<span class="p_del">-	sg_set_buf(&amp;sg[3], bzero, zero_padding);</span>
<span class="p_add">+	sg_set_page(&amp;sg[3], ZERO_PAGE(0), zero_padding, 0);</span>
 	sg_init_one(&amp;sg_dst, dst_buf, dst_size);
 
 	skcipher_request_set_tfm(req, tfm_cbc);
<span class="p_header">diff --git a/drivers/vme/bridges/vme_ca91cx42.c b/drivers/vme/bridges/vme_ca91cx42.c</span>
<span class="p_header">index 6b5ee896af63..7cc51223db1c 100644</span>
<span class="p_header">--- a/drivers/vme/bridges/vme_ca91cx42.c</span>
<span class="p_header">+++ b/drivers/vme/bridges/vme_ca91cx42.c</span>
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> static int ca91cx42_slave_get(struct vme_slave_resource *image, int *enabled,</span>
 	vme_bound = ioread32(bridge-&gt;base + CA91CX42_VSI_BD[i]);
 	pci_offset = ioread32(bridge-&gt;base + CA91CX42_VSI_TO[i]);
 
<span class="p_del">-	*pci_base = (dma_addr_t)vme_base + pci_offset;</span>
<span class="p_add">+	*pci_base = (dma_addr_t)*vme_base + pci_offset;</span>
 	*size = (unsigned long long)((vme_bound - *vme_base) + granularity);
 
 	*enabled = 0;
<span class="p_header">diff --git a/fs/btrfs/async-thread.c b/fs/btrfs/async-thread.c</span>
<span class="p_header">index 63d197724519..ff0b0be92d61 100644</span>
<span class="p_header">--- a/fs/btrfs/async-thread.c</span>
<span class="p_header">+++ b/fs/btrfs/async-thread.c</span>
<span class="p_chunk">@@ -273,6 +273,8 @@</span> <span class="p_context"> static void run_ordered_work(struct __btrfs_workqueue *wq)</span>
 	unsigned long flags;
 
 	while (1) {
<span class="p_add">+		void *wtag;</span>
<span class="p_add">+</span>
 		spin_lock_irqsave(lock, flags);
 		if (list_empty(list))
 			break;
<span class="p_chunk">@@ -299,11 +301,13 @@</span> <span class="p_context"> static void run_ordered_work(struct __btrfs_workqueue *wq)</span>
 		spin_unlock_irqrestore(lock, flags);
 
 		/*
<span class="p_del">-		 * we don&#39;t want to call the ordered free functions</span>
<span class="p_del">-		 * with the lock held though</span>
<span class="p_add">+		 * We don&#39;t want to call the ordered free functions with the</span>
<span class="p_add">+		 * lock held though. Save the work as tag for the trace event,</span>
<span class="p_add">+		 * because the callback could free the structure.</span>
 		 */
<span class="p_add">+		wtag = work;</span>
 		work-&gt;ordered_free(work);
<span class="p_del">-		trace_btrfs_all_work_done(work);</span>
<span class="p_add">+		trace_btrfs_all_work_done(wq-&gt;fs_info, wtag);</span>
 	}
 	spin_unlock_irqrestore(lock, flags);
 }
<span class="p_chunk">@@ -311,6 +315,7 @@</span> <span class="p_context"> static void run_ordered_work(struct __btrfs_workqueue *wq)</span>
 static void normal_work_helper(struct btrfs_work *work)
 {
 	struct __btrfs_workqueue *wq;
<span class="p_add">+	void *wtag;</span>
 	int need_order = 0;
 
 	/*
<span class="p_chunk">@@ -324,6 +329,8 @@</span> <span class="p_context"> static void normal_work_helper(struct btrfs_work *work)</span>
 	if (work-&gt;ordered_func)
 		need_order = 1;
 	wq = work-&gt;wq;
<span class="p_add">+	/* Safe for tracepoints in case work gets freed by the callback */</span>
<span class="p_add">+	wtag = work;</span>
 
 	trace_btrfs_work_sched(work);
 	thresh_exec_hook(wq);
<span class="p_chunk">@@ -333,7 +340,7 @@</span> <span class="p_context"> static void normal_work_helper(struct btrfs_work *work)</span>
 		run_ordered_work(wq);
 	}
 	if (!need_order)
<span class="p_del">-		trace_btrfs_all_work_done(work);</span>
<span class="p_add">+		trace_btrfs_all_work_done(wq-&gt;fs_info, wtag);</span>
 }
 
 void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 4607af38c72e..5909ae8c6731 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -2537,11 +2537,11 @@</span> <span class="p_context"> static noinline int __btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,</span>
 		if (ref &amp;&amp; ref-&gt;seq &amp;&amp;
 		    btrfs_check_delayed_seq(fs_info, delayed_refs, ref-&gt;seq)) {
 			spin_unlock(&amp;locked_ref-&gt;lock);
<span class="p_del">-			btrfs_delayed_ref_unlock(locked_ref);</span>
 			spin_lock(&amp;delayed_refs-&gt;lock);
 			locked_ref-&gt;processing = 0;
 			delayed_refs-&gt;num_heads_ready++;
 			spin_unlock(&amp;delayed_refs-&gt;lock);
<span class="p_add">+			btrfs_delayed_ref_unlock(locked_ref);</span>
 			locked_ref = NULL;
 			cond_resched();
 			count++;
<span class="p_chunk">@@ -2587,7 +2587,10 @@</span> <span class="p_context"> static noinline int __btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,</span>
 					 */
 					if (must_insert_reserved)
 						locked_ref-&gt;must_insert_reserved = 1;
<span class="p_add">+					spin_lock(&amp;delayed_refs-&gt;lock);</span>
 					locked_ref-&gt;processing = 0;
<span class="p_add">+					delayed_refs-&gt;num_heads_ready++;</span>
<span class="p_add">+					spin_unlock(&amp;delayed_refs-&gt;lock);</span>
 					btrfs_debug(fs_info,
 						    &quot;run_delayed_extent_op returned %d&quot;,
 						    ret);
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 5c7cc953ac81..4485a48f4091 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -1330,8 +1330,11 @@</span> <span class="p_context"> int d_set_mounted(struct dentry *dentry)</span>
 	}
 	spin_lock(&amp;dentry-&gt;d_lock);
 	if (!d_unlinked(dentry)) {
<span class="p_del">-		dentry-&gt;d_flags |= DCACHE_MOUNTED;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_add">+		ret = -EBUSY;</span>
<span class="p_add">+		if (!d_mountpoint(dentry)) {</span>
<span class="p_add">+			dentry-&gt;d_flags |= DCACHE_MOUNTED;</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+		}</span>
 	}
  	spin_unlock(&amp;dentry-&gt;d_lock);
 out:
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index e6c234b1a645..7cea503ae06d 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -746,26 +746,50 @@</span> <span class="p_context"> static struct mountpoint *lookup_mountpoint(struct dentry *dentry)</span>
 	return NULL;
 }
 
<span class="p_del">-static struct mountpoint *new_mountpoint(struct dentry *dentry)</span>
<span class="p_add">+static struct mountpoint *get_mountpoint(struct dentry *dentry)</span>
 {
<span class="p_del">-	struct hlist_head *chain = mp_hash(dentry);</span>
<span class="p_del">-	struct mountpoint *mp;</span>
<span class="p_add">+	struct mountpoint *mp, *new = NULL;</span>
 	int ret;
 
<span class="p_del">-	mp = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);</span>
<span class="p_del">-	if (!mp)</span>
<span class="p_add">+	if (d_mountpoint(dentry)) {</span>
<span class="p_add">+mountpoint:</span>
<span class="p_add">+		read_seqlock_excl(&amp;mount_lock);</span>
<span class="p_add">+		mp = lookup_mountpoint(dentry);</span>
<span class="p_add">+		read_sequnlock_excl(&amp;mount_lock);</span>
<span class="p_add">+		if (mp)</span>
<span class="p_add">+			goto done;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!new)</span>
<span class="p_add">+		new = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);</span>
<span class="p_add">+	if (!new)</span>
 		return ERR_PTR(-ENOMEM);
 
<span class="p_add">+</span>
<span class="p_add">+	/* Exactly one processes may set d_mounted */</span>
 	ret = d_set_mounted(dentry);
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		kfree(mp);</span>
<span class="p_del">-		return ERR_PTR(ret);</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	mp-&gt;m_dentry = dentry;</span>
<span class="p_del">-	mp-&gt;m_count = 1;</span>
<span class="p_del">-	hlist_add_head(&amp;mp-&gt;m_hash, chain);</span>
<span class="p_del">-	INIT_HLIST_HEAD(&amp;mp-&gt;m_list);</span>
<span class="p_add">+	/* Someone else set d_mounted? */</span>
<span class="p_add">+	if (ret == -EBUSY)</span>
<span class="p_add">+		goto mountpoint;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The dentry is not available as a mountpoint? */</span>
<span class="p_add">+	mp = ERR_PTR(ret);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add the new mountpoint to the hash table */</span>
<span class="p_add">+	read_seqlock_excl(&amp;mount_lock);</span>
<span class="p_add">+	new-&gt;m_dentry = dentry;</span>
<span class="p_add">+	new-&gt;m_count = 1;</span>
<span class="p_add">+	hlist_add_head(&amp;new-&gt;m_hash, mp_hash(dentry));</span>
<span class="p_add">+	INIT_HLIST_HEAD(&amp;new-&gt;m_list);</span>
<span class="p_add">+	read_sequnlock_excl(&amp;mount_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	mp = new;</span>
<span class="p_add">+	new = NULL;</span>
<span class="p_add">+done:</span>
<span class="p_add">+	kfree(new);</span>
 	return mp;
 }
 
<span class="p_chunk">@@ -1568,11 +1592,11 @@</span> <span class="p_context"> void __detach_mounts(struct dentry *dentry)</span>
 	struct mount *mnt;
 
 	namespace_lock();
<span class="p_add">+	lock_mount_hash();</span>
 	mp = lookup_mountpoint(dentry);
 	if (IS_ERR_OR_NULL(mp))
 		goto out_unlock;
 
<span class="p_del">-	lock_mount_hash();</span>
 	event++;
 	while (!hlist_empty(&amp;mp-&gt;m_list)) {
 		mnt = hlist_entry(mp-&gt;m_list.first, struct mount, mnt_mp_list);
<span class="p_chunk">@@ -1582,9 +1606,9 @@</span> <span class="p_context"> void __detach_mounts(struct dentry *dentry)</span>
 		}
 		else umount_tree(mnt, UMOUNT_CONNECTED);
 	}
<span class="p_del">-	unlock_mount_hash();</span>
 	put_mountpoint(mp);
 out_unlock:
<span class="p_add">+	unlock_mount_hash();</span>
 	namespace_unlock();
 }
 
<span class="p_chunk">@@ -2013,9 +2037,7 @@</span> <span class="p_context"> static struct mountpoint *lock_mount(struct path *path)</span>
 	namespace_lock();
 	mnt = lookup_mnt(path);
 	if (likely(!mnt)) {
<span class="p_del">-		struct mountpoint *mp = lookup_mountpoint(dentry);</span>
<span class="p_del">-		if (!mp)</span>
<span class="p_del">-			mp = new_mountpoint(dentry);</span>
<span class="p_add">+		struct mountpoint *mp = get_mountpoint(dentry);</span>
 		if (IS_ERR(mp)) {
 			namespace_unlock();
 			inode_unlock(dentry-&gt;d_inode);
<span class="p_chunk">@@ -2034,7 +2056,11 @@</span> <span class="p_context"> static struct mountpoint *lock_mount(struct path *path)</span>
 static void unlock_mount(struct mountpoint *where)
 {
 	struct dentry *dentry = where-&gt;m_dentry;
<span class="p_add">+</span>
<span class="p_add">+	read_seqlock_excl(&amp;mount_lock);</span>
 	put_mountpoint(where);
<span class="p_add">+	read_sequnlock_excl(&amp;mount_lock);</span>
<span class="p_add">+</span>
 	namespace_unlock();
 	inode_unlock(dentry-&gt;d_inode);
 }
<span class="p_chunk">@@ -3110,9 +3136,9 @@</span> <span class="p_context"> SYSCALL_DEFINE2(pivot_root, const char __user *, new_root,</span>
 	touch_mnt_namespace(current-&gt;nsproxy-&gt;mnt_ns);
 	/* A moved mount should not expire automatically */
 	list_del_init(&amp;new_mnt-&gt;mnt_expire);
<span class="p_add">+	put_mountpoint(root_mp);</span>
 	unlock_mount_hash();
 	chroot_fs_refs(&amp;root, &amp;new);
<span class="p_del">-	put_mountpoint(root_mp);</span>
 	error = 0;
 out4:
 	unlock_mount(old_mp);
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index 5f1af4cd1a33..53e02b8bd9bd 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -477,7 +477,7 @@</span> <span class="p_context"> void nfs_force_use_readdirplus(struct inode *dir)</span>
 {
 	if (!list_empty(&amp;NFS_I(dir)-&gt;open_files)) {
 		nfs_advise_use_readdirplus(dir);
<span class="p_del">-		nfs_zap_mapping(dir, dir-&gt;i_mapping);</span>
<span class="p_add">+		invalidate_mapping_pages(dir-&gt;i_mapping, 0, -1);</span>
 	}
 }
 
<span class="p_chunk">@@ -886,17 +886,6 @@</span> <span class="p_context"> int uncached_readdir(nfs_readdir_descriptor_t *desc)</span>
 	goto out;
 }
 
<span class="p_del">-static bool nfs_dir_mapping_need_revalidate(struct inode *dir)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct nfs_inode *nfsi = NFS_I(dir);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (nfs_attribute_cache_expired(dir))</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	if (nfsi-&gt;cache_validity &amp; NFS_INO_INVALID_DATA)</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* The file offset position represents the dirent entry number.  A
    last cookie cache takes care of the common case of reading the
    whole directory.
<span class="p_chunk">@@ -928,7 +917,7 @@</span> <span class="p_context"> static int nfs_readdir(struct file *file, struct dir_context *ctx)</span>
 	desc-&gt;decode = NFS_PROTO(inode)-&gt;decode_dirent;
 	desc-&gt;plus = nfs_use_readdirplus(inode, ctx) ? 1 : 0;
 
<span class="p_del">-	if (ctx-&gt;pos == 0 || nfs_dir_mapping_need_revalidate(inode))</span>
<span class="p_add">+	if (ctx-&gt;pos == 0 || nfs_attribute_cache_expired(inode))</span>
 		res = nfs_revalidate_mapping(inode, file-&gt;f_mapping);
 	if (res &lt; 0)
 		goto out;
<span class="p_header">diff --git a/fs/nfs/filelayout/filelayoutdev.c b/fs/nfs/filelayout/filelayoutdev.c</span>
<span class="p_header">index 4946ef40ba87..85ef38f9765f 100644</span>
<span class="p_header">--- a/fs/nfs/filelayout/filelayoutdev.c</span>
<span class="p_header">+++ b/fs/nfs/filelayout/filelayoutdev.c</span>
<span class="p_chunk">@@ -283,7 +283,8 @@</span> <span class="p_context"> nfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)</span>
 			     s-&gt;nfs_client-&gt;cl_rpcclient-&gt;cl_auth-&gt;au_flavor);
 
 out_test_devid:
<span class="p_del">-	if (filelayout_test_devid_unavailable(devid))</span>
<span class="p_add">+	if (ret-&gt;ds_clp == NULL ||</span>
<span class="p_add">+	    filelayout_test_devid_unavailable(devid))</span>
 		ret = NULL;
 out:
 	return ret;
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index 31b107e196fd..415d7e69bc5e 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -1257,13 +1257,11 @@</span> <span class="p_context"> bool pnfs_wait_on_layoutreturn(struct inode *ino, struct rpc_task *task)</span>
 	 * i_lock */
         spin_lock(&amp;ino-&gt;i_lock);
         lo = nfsi-&gt;layout;
<span class="p_del">-        if (lo &amp;&amp; test_bit(NFS_LAYOUT_RETURN, &amp;lo-&gt;plh_flags))</span>
<span class="p_add">+        if (lo &amp;&amp; test_bit(NFS_LAYOUT_RETURN, &amp;lo-&gt;plh_flags)) {</span>
<span class="p_add">+                rpc_sleep_on(&amp;NFS_SERVER(ino)-&gt;roc_rpcwaitq, task, NULL);</span>
                 sleep = true;
<span class="p_add">+	}</span>
         spin_unlock(&amp;ino-&gt;i_lock);
<span class="p_del">-</span>
<span class="p_del">-        if (sleep)</span>
<span class="p_del">-                rpc_sleep_on(&amp;NFS_SERVER(ino)-&gt;roc_rpcwaitq, task, NULL);</span>
<span class="p_del">-</span>
         return sleep;
 }
 
<span class="p_header">diff --git a/fs/nfs/super.c b/fs/nfs/super.c</span>
<span class="p_header">index 001796bcd6c8..ddce94ce8142 100644</span>
<span class="p_header">--- a/fs/nfs/super.c</span>
<span class="p_header">+++ b/fs/nfs/super.c</span>
<span class="p_chunk">@@ -2904,7 +2904,7 @@</span> <span class="p_context"> module_param(max_session_slots, ushort, 0644);</span>
 MODULE_PARM_DESC(max_session_slots, &quot;Maximum number of outstanding NFSv4.1 &quot;
 		&quot;requests the client will negotiate&quot;);
 module_param(max_session_cb_slots, ushort, 0644);
<span class="p_del">-MODULE_PARM_DESC(max_session_slots, &quot;Maximum number of parallel NFSv4.1 &quot;</span>
<span class="p_add">+MODULE_PARM_DESC(max_session_cb_slots, &quot;Maximum number of parallel NFSv4.1 &quot;</span>
 		&quot;callbacks the client will process for a given server&quot;);
 module_param(send_implementation_id, ushort, 0644);
 MODULE_PARM_DESC(send_implementation_id,
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index 83d576f6a287..77d1632e905d 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -3303,6 +3303,16 @@</span> <span class="p_context"> static int ocfs2_downconvert_lock(struct ocfs2_super *osb,</span>
 	mlog(ML_BASTS, &quot;lockres %s, level %d =&gt; %d\n&quot;, lockres-&gt;l_name,
 	     lockres-&gt;l_level, new_level);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On DLM_LKF_VALBLK, fsdlm behaves differently with o2cb. It always</span>
<span class="p_add">+	 * expects DLM_LKF_VALBLK being set if the LKB has LVB, so that</span>
<span class="p_add">+	 * we can recover correctly from node failure. Otherwise, we may get</span>
<span class="p_add">+	 * invalid LVB in LKB, but without DLM_SBF_VALNOTVALID being set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ocfs2_is_o2cb_active() &amp;&amp;</span>
<span class="p_add">+	    lockres-&gt;l_ops-&gt;flags &amp; LOCK_TYPE_USES_LVB)</span>
<span class="p_add">+		lvb = 1;</span>
<span class="p_add">+</span>
 	if (lvb)
 		dlm_flags |= DLM_LKF_VALBLK;
 
<span class="p_header">diff --git a/fs/ocfs2/stackglue.c b/fs/ocfs2/stackglue.c</span>
<span class="p_header">index 52c07346bea3..820359096c7a 100644</span>
<span class="p_header">--- a/fs/ocfs2/stackglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/stackglue.c</span>
<span class="p_chunk">@@ -48,6 +48,12 @@</span> <span class="p_context"> static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = &quot;/sbin/ocfs2_hb_ctl&quot;;</span>
  */
 static struct ocfs2_stack_plugin *active_stack;
 
<span class="p_add">+inline int ocfs2_is_o2cb_active(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !strcmp(active_stack-&gt;sp_name, OCFS2_STACK_PLUGIN_O2CB);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(ocfs2_is_o2cb_active);</span>
<span class="p_add">+</span>
 static struct ocfs2_stack_plugin *ocfs2_stack_lookup(const char *name)
 {
 	struct ocfs2_stack_plugin *p;
<span class="p_header">diff --git a/fs/ocfs2/stackglue.h b/fs/ocfs2/stackglue.h</span>
<span class="p_header">index f2dce10fae54..e3036e1790e8 100644</span>
<span class="p_header">--- a/fs/ocfs2/stackglue.h</span>
<span class="p_header">+++ b/fs/ocfs2/stackglue.h</span>
<span class="p_chunk">@@ -298,6 +298,9 @@</span> <span class="p_context"> void ocfs2_stack_glue_set_max_proto_version(struct ocfs2_protocol_version *max_p</span>
 int ocfs2_stack_glue_register(struct ocfs2_stack_plugin *plugin);
 void ocfs2_stack_glue_unregister(struct ocfs2_stack_plugin *plugin);
 
<span class="p_add">+/* In ocfs2_downconvert_lock(), we need to know which stack we are using */</span>
<span class="p_add">+int ocfs2_is_o2cb_active(void);</span>
<span class="p_add">+</span>
 extern struct kset *ocfs2_kset;
 
 #endif  /* STACKGLUE_H */
<span class="p_header">diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c</span>
<span class="p_header">index 55313d994895..d4e37acd4821 100644</span>
<span class="p_header">--- a/fs/proc/proc_sysctl.c</span>
<span class="p_header">+++ b/fs/proc/proc_sysctl.c</span>
<span class="p_chunk">@@ -709,7 +709,7 @@</span> <span class="p_context"> static int proc_sys_readdir(struct file *file, struct dir_context *ctx)</span>
 	ctl_dir = container_of(head, struct ctl_dir, header);
 
 	if (!dir_emit_dots(file, ctx))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto out;</span>
 
 	pos = 2;
 
<span class="p_chunk">@@ -719,6 +719,7 @@</span> <span class="p_context"> static int proc_sys_readdir(struct file *file, struct dir_context *ctx)</span>
 			break;
 		}
 	}
<span class="p_add">+out:</span>
 	sysctl_head_finish(head);
 	return 0;
 }
<span class="p_header">diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c</span>
<span class="p_header">index 2693ba84ec25..06763f5cc701 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_aops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_aops.c</span>
<span class="p_chunk">@@ -1158,19 +1158,22 @@</span> <span class="p_context"> xfs_vm_releasepage(</span>
 	 * block_invalidatepage() can send pages that are still marked dirty
 	 * but otherwise have invalidated buffers.
 	 *
<span class="p_del">-	 * We&#39;ve historically freed buffers on the latter. Instead, quietly</span>
<span class="p_del">-	 * filter out all dirty pages to avoid spurious buffer state warnings.</span>
<span class="p_del">-	 * This can likely be removed once shrink_active_list() is fixed.</span>
<span class="p_add">+	 * We want to release the latter to avoid unnecessary buildup of the</span>
<span class="p_add">+	 * LRU, skip the former and warn if we&#39;ve left any lingering</span>
<span class="p_add">+	 * delalloc/unwritten buffers on clean pages. Skip pages with delalloc</span>
<span class="p_add">+	 * or unwritten buffers and warn if the page is not dirty. Otherwise</span>
<span class="p_add">+	 * try to release the buffers.</span>
 	 */
<span class="p_del">-	if (PageDirty(page))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	xfs_count_page_state(page, &amp;delalloc, &amp;unwritten);
 
<span class="p_del">-	if (WARN_ON_ONCE(delalloc))</span>
<span class="p_add">+	if (delalloc) {</span>
<span class="p_add">+		WARN_ON_ONCE(!PageDirty(page));</span>
 		return 0;
<span class="p_del">-	if (WARN_ON_ONCE(unwritten))</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (unwritten) {</span>
<span class="p_add">+		WARN_ON_ONCE(!PageDirty(page));</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	return try_to_free_buffers(page);
 }
<span class="p_header">diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h</span>
<span class="p_header">index c47c358ba052..f6a816129856 100644</span>
<span class="p_header">--- a/include/linux/blkdev.h</span>
<span class="p_header">+++ b/include/linux/blkdev.h</span>
<span class="p_chunk">@@ -1057,7 +1057,7 @@</span> <span class="p_context"> static inline int blk_pre_runtime_suspend(struct request_queue *q)</span>
 static inline void blk_post_runtime_suspend(struct request_queue *q, int err) {}
 static inline void blk_pre_runtime_resume(struct request_queue *q) {}
 static inline void blk_post_runtime_resume(struct request_queue *q, int err) {}
<span class="p_del">-extern inline void blk_set_runtime_active(struct request_queue *q) {}</span>
<span class="p_add">+static inline void blk_set_runtime_active(struct request_queue *q) {}</span>
 #endif
 
 /*
<span class="p_header">diff --git a/include/linux/efi.h b/include/linux/efi.h</span>
<span class="p_header">index 2d089487d2da..cba7177cbec7 100644</span>
<span class="p_header">--- a/include/linux/efi.h</span>
<span class="p_header">+++ b/include/linux/efi.h</span>
<span class="p_chunk">@@ -103,6 +103,7 @@</span> <span class="p_context"> typedef	struct {</span>
 
 #define EFI_PAGE_SHIFT		12
 #define EFI_PAGE_SIZE		(1UL &lt;&lt; EFI_PAGE_SHIFT)
<span class="p_add">+#define EFI_PAGES_MAX		(U64_MAX &gt;&gt; EFI_PAGE_SHIFT)</span>
 
 typedef struct {
 	u32 type;
<span class="p_chunk">@@ -930,6 +931,7 @@</span> <span class="p_context"> static inline efi_status_t efi_query_variable_store(u32 attributes,</span>
 #endif
 extern void __iomem *efi_lookup_mapped_addr(u64 phys_addr);
 
<span class="p_add">+extern phys_addr_t __init efi_memmap_alloc(unsigned int num_entries);</span>
 extern int __init efi_memmap_init_early(struct efi_memory_map_data *data);
 extern int __init efi_memmap_init_late(phys_addr_t addr, unsigned long size);
 extern void __init efi_memmap_unmap(void);
<span class="p_header">diff --git a/include/linux/jump_label_ratelimit.h b/include/linux/jump_label_ratelimit.h</span>
<span class="p_header">index 089f70f83e97..23da3af459fe 100644</span>
<span class="p_header">--- a/include/linux/jump_label_ratelimit.h</span>
<span class="p_header">+++ b/include/linux/jump_label_ratelimit.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"> struct static_key_deferred {</span>
 
 #ifdef HAVE_JUMP_LABEL
 extern void static_key_slow_dec_deferred(struct static_key_deferred *key);
<span class="p_add">+extern void static_key_deferred_flush(struct static_key_deferred *key);</span>
 extern void
 jump_label_rate_limit(struct static_key_deferred *key, unsigned long rl);
 
<span class="p_chunk">@@ -26,6 +27,10 @@</span> <span class="p_context"> static inline void static_key_slow_dec_deferred(struct static_key_deferred *key)</span>
 	STATIC_KEY_CHECK_USE();
 	static_key_slow_dec(&amp;key-&gt;key);
 }
<span class="p_add">+static inline void static_key_deferred_flush(struct static_key_deferred *key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	STATIC_KEY_CHECK_USE();</span>
<span class="p_add">+}</span>
 static inline void
 jump_label_rate_limit(struct static_key_deferred *key,
 		unsigned long rl)
<span class="p_header">diff --git a/include/linux/memcontrol.h b/include/linux/memcontrol.h</span>
<span class="p_header">index 61d20c17f3b7..254698856b8f 100644</span>
<span class="p_header">--- a/include/linux/memcontrol.h</span>
<span class="p_header">+++ b/include/linux/memcontrol.h</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> struct mem_cgroup_reclaim_iter {</span>
  */
 struct mem_cgroup_per_node {
 	struct lruvec		lruvec;
<span class="p_del">-	unsigned long		lru_size[NR_LRU_LISTS];</span>
<span class="p_add">+	unsigned long		lru_zone_size[MAX_NR_ZONES][NR_LRU_LISTS];</span>
 
 	struct mem_cgroup_reclaim_iter	iter[DEF_PRIORITY + 1];
 
<span class="p_chunk">@@ -432,7 +432,7 @@</span> <span class="p_context"> static inline bool mem_cgroup_online(struct mem_cgroup *memcg)</span>
 int mem_cgroup_select_victim_node(struct mem_cgroup *memcg);
 
 void mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,
<span class="p_del">-		int nr_pages);</span>
<span class="p_add">+		int zid, int nr_pages);</span>
 
 unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,
 					   int nid, unsigned int lru_mask);
<span class="p_chunk">@@ -441,9 +441,23 @@</span> <span class="p_context"> static inline</span>
 unsigned long mem_cgroup_get_lru_size(struct lruvec *lruvec, enum lru_list lru)
 {
 	struct mem_cgroup_per_node *mz;
<span class="p_add">+	unsigned long nr_pages = 0;</span>
<span class="p_add">+	int zid;</span>
 
 	mz = container_of(lruvec, struct mem_cgroup_per_node, lruvec);
<span class="p_del">-	return mz-&gt;lru_size[lru];</span>
<span class="p_add">+	for (zid = 0; zid &lt; MAX_NR_ZONES; zid++)</span>
<span class="p_add">+		nr_pages += mz-&gt;lru_zone_size[zid][lru];</span>
<span class="p_add">+	return nr_pages;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline</span>
<span class="p_add">+unsigned long mem_cgroup_get_zone_lru_size(struct lruvec *lruvec,</span>
<span class="p_add">+		enum lru_list lru, int zone_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mem_cgroup_per_node *mz;</span>
<span class="p_add">+</span>
<span class="p_add">+	mz = container_of(lruvec, struct mem_cgroup_per_node, lruvec);</span>
<span class="p_add">+	return mz-&gt;lru_zone_size[zone_idx][lru];</span>
 }
 
 void mem_cgroup_handle_over_high(void);
<span class="p_chunk">@@ -671,6 +685,12 @@</span> <span class="p_context"> mem_cgroup_get_lru_size(struct lruvec *lruvec, enum lru_list lru)</span>
 {
 	return 0;
 }
<span class="p_add">+static inline</span>
<span class="p_add">+unsigned long mem_cgroup_get_zone_lru_size(struct lruvec *lruvec,</span>
<span class="p_add">+		enum lru_list lru, int zone_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
 static inline unsigned long
 mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,
<span class="p_header">diff --git a/include/linux/mm_inline.h b/include/linux/mm_inline.h</span>
<span class="p_header">index 71613e8a720f..41d376e7116d 100644</span>
<span class="p_header">--- a/include/linux/mm_inline.h</span>
<span class="p_header">+++ b/include/linux/mm_inline.h</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"> static __always_inline void update_lru_size(struct lruvec *lruvec,</span>
 {
 	__update_lru_size(lruvec, lru, zid, nr_pages);
 #ifdef CONFIG_MEMCG
<span class="p_del">-	mem_cgroup_update_lru_size(lruvec, lru, nr_pages);</span>
<span class="p_add">+	mem_cgroup_update_lru_size(lruvec, lru, zid, nr_pages);</span>
 #endif
 }
 
<span class="p_header">diff --git a/include/linux/power/bq27xxx_battery.h b/include/linux/power/bq27xxx_battery.h</span>
<span class="p_header">index e30deb046156..bed9557b69e7 100644</span>
<span class="p_header">--- a/include/linux/power/bq27xxx_battery.h</span>
<span class="p_header">+++ b/include/linux/power/bq27xxx_battery.h</span>
<span class="p_chunk">@@ -4,7 +4,8 @@</span> <span class="p_context"></span>
 enum bq27xxx_chip {
 	BQ27000 = 1, /* bq27000, bq27200 */
 	BQ27010, /* bq27010, bq27210 */
<span class="p_del">-	BQ27500, /* bq27500, bq27510, bq27520 */</span>
<span class="p_add">+	BQ27500, /* bq27500 */</span>
<span class="p_add">+	BQ27510, /* bq27510, bq27520 */</span>
 	BQ27530, /* bq27530, bq27531 */
 	BQ27541, /* bq27541, bq27542, bq27546, bq27742 */
 	BQ27545, /* bq27545 */
<span class="p_header">diff --git a/include/linux/swap.h b/include/linux/swap.h</span>
<span class="p_header">index a56523cefb9b..55ff5593c193 100644</span>
<span class="p_header">--- a/include/linux/swap.h</span>
<span class="p_header">+++ b/include/linux/swap.h</span>
<span class="p_chunk">@@ -150,8 +150,9 @@</span> <span class="p_context"> enum {</span>
 	SWP_FILE	= (1 &lt;&lt; 7),	/* set after swap_activate success */
 	SWP_AREA_DISCARD = (1 &lt;&lt; 8),	/* single-time swap area discards */
 	SWP_PAGE_DISCARD = (1 &lt;&lt; 9),	/* freed swap page-cluster discards */
<span class="p_add">+	SWP_STABLE_WRITES = (1 &lt;&lt; 10),	/* no overwrite PG_writeback pages */</span>
 					/* add others here before... */
<span class="p_del">-	SWP_SCANNING	= (1 &lt;&lt; 10),	/* refcount in scan_swap_map */</span>
<span class="p_add">+	SWP_SCANNING	= (1 &lt;&lt; 11),	/* refcount in scan_swap_map */</span>
 };
 
 #define SWAP_CLUSTER_MAX 32UL
<span class="p_header">diff --git a/include/sound/hdmi-codec.h b/include/sound/hdmi-codec.h</span>
<span class="p_header">index 530c57bdefa0..915c4357945c 100644</span>
<span class="p_header">--- a/include/sound/hdmi-codec.h</span>
<span class="p_header">+++ b/include/sound/hdmi-codec.h</span>
<span class="p_chunk">@@ -36,10 +36,10 @@</span> <span class="p_context"> struct hdmi_codec_daifmt {</span>
 		HDMI_AC97,
 		HDMI_SPDIF,
 	} fmt;
<span class="p_del">-	int bit_clk_inv:1;</span>
<span class="p_del">-	int frame_clk_inv:1;</span>
<span class="p_del">-	int bit_clk_master:1;</span>
<span class="p_del">-	int frame_clk_master:1;</span>
<span class="p_add">+	unsigned int bit_clk_inv:1;</span>
<span class="p_add">+	unsigned int frame_clk_inv:1;</span>
<span class="p_add">+	unsigned int bit_clk_master:1;</span>
<span class="p_add">+	unsigned int frame_clk_master:1;</span>
 };
 
 /*
<span class="p_header">diff --git a/include/trace/events/btrfs.h b/include/trace/events/btrfs.h</span>
<span class="p_header">index e030d6f6c19a..6d7fe1169956 100644</span>
<span class="p_header">--- a/include/trace/events/btrfs.h</span>
<span class="p_header">+++ b/include/trace/events/btrfs.h</span>
<span class="p_chunk">@@ -1162,22 +1162,26 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(btrfs__work,</span>
 		   __entry-&gt;func, __entry-&gt;ordered_func, __entry-&gt;ordered_free)
 );
 
<span class="p_del">-/* For situiations that the work is freed */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * For situiations when the work is freed, we pass fs_info and a tag that that</span>
<span class="p_add">+ * matches address of the work structure so it can be paired with the</span>
<span class="p_add">+ * scheduling event.</span>
<span class="p_add">+ */</span>
 DECLARE_EVENT_CLASS(btrfs__work__done,
 
<span class="p_del">-	TP_PROTO(struct btrfs_work *work),</span>
<span class="p_add">+	TP_PROTO(struct btrfs_fs_info *fs_info, void *wtag),</span>
 
<span class="p_del">-	TP_ARGS(work),</span>
<span class="p_add">+	TP_ARGS(fs_info, wtag),</span>
 
 	TP_STRUCT__entry_btrfs(
<span class="p_del">-		__field(	void *,	work			)</span>
<span class="p_add">+		__field(	void *,	wtag			)</span>
 	),
 
<span class="p_del">-	TP_fast_assign_btrfs(btrfs_work_owner(work),</span>
<span class="p_del">-		__entry-&gt;work		= work;</span>
<span class="p_add">+	TP_fast_assign_btrfs(fs_info,</span>
<span class="p_add">+		__entry-&gt;wtag		= wtag;</span>
 	),
 
<span class="p_del">-	TP_printk_btrfs(&quot;work-&gt;%p&quot;, __entry-&gt;work)</span>
<span class="p_add">+	TP_printk_btrfs(&quot;work-&gt;%p&quot;, __entry-&gt;wtag)</span>
 );
 
 DEFINE_EVENT(btrfs__work, btrfs_work_queued,
<span class="p_chunk">@@ -1196,9 +1200,9 @@</span> <span class="p_context"> DEFINE_EVENT(btrfs__work, btrfs_work_sched,</span>
 
 DEFINE_EVENT(btrfs__work__done, btrfs_all_work_done,
 
<span class="p_del">-	TP_PROTO(struct btrfs_work *work),</span>
<span class="p_add">+	TP_PROTO(struct btrfs_fs_info *fs_info, void *wtag),</span>
 
<span class="p_del">-	TP_ARGS(work)</span>
<span class="p_add">+	TP_ARGS(fs_info, wtag)</span>
 );
 
 DEFINE_EVENT(btrfs__work, btrfs_ordered_sched,
<span class="p_header">diff --git a/kernel/jump_label.c b/kernel/jump_label.c</span>
<span class="p_header">index 93ad6c1fb9b6..a9b8cf500591 100644</span>
<span class="p_header">--- a/kernel/jump_label.c</span>
<span class="p_header">+++ b/kernel/jump_label.c</span>
<span class="p_chunk">@@ -182,6 +182,13 @@</span> <span class="p_context"> void static_key_slow_dec_deferred(struct static_key_deferred *key)</span>
 }
 EXPORT_SYMBOL_GPL(static_key_slow_dec_deferred);
 
<span class="p_add">+void static_key_deferred_flush(struct static_key_deferred *key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	STATIC_KEY_CHECK_USE();</span>
<span class="p_add">+	flush_delayed_work(&amp;key-&gt;work);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(static_key_deferred_flush);</span>
<span class="p_add">+</span>
 void jump_label_rate_limit(struct static_key_deferred *key,
 		unsigned long rl)
 {
<span class="p_header">diff --git a/kernel/memremap.c b/kernel/memremap.c</span>
<span class="p_header">index b501e390bb34..9ecedc28b928 100644</span>
<span class="p_header">--- a/kernel/memremap.c</span>
<span class="p_header">+++ b/kernel/memremap.c</span>
<span class="p_chunk">@@ -246,7 +246,9 @@</span> <span class="p_context"> static void devm_memremap_pages_release(struct device *dev, void *data)</span>
 	/* pages are dead and unused, undo the arch mapping */
 	align_start = res-&gt;start &amp; ~(SECTION_SIZE - 1);
 	align_size = ALIGN(resource_size(res), SECTION_SIZE);
<span class="p_add">+	mem_hotplug_begin();</span>
 	arch_remove_memory(align_start, align_size);
<span class="p_add">+	mem_hotplug_done();</span>
 	untrack_pfn(NULL, PHYS_PFN(align_start), align_size);
 	pgmap_radix_release(res);
 	dev_WARN_ONCE(dev, pgmap-&gt;altmap &amp;&amp; pgmap-&gt;altmap-&gt;alloc,
<span class="p_chunk">@@ -358,7 +360,9 @@</span> <span class="p_context"> void *devm_memremap_pages(struct device *dev, struct resource *res,</span>
 	if (error)
 		goto err_pfn_remap;
 
<span class="p_add">+	mem_hotplug_begin();</span>
 	error = arch_add_memory(nid, align_start, align_size, true);
<span class="p_add">+	mem_hotplug_done();</span>
 	if (error)
 		goto err_add_memory;
 
<span class="p_header">diff --git a/kernel/pid_namespace.c b/kernel/pid_namespace.c</span>
<span class="p_header">index df9e8e9e0be7..eef2ce968636 100644</span>
<span class="p_header">--- a/kernel/pid_namespace.c</span>
<span class="p_header">+++ b/kernel/pid_namespace.c</span>
<span class="p_chunk">@@ -151,8 +151,12 @@</span> <span class="p_context"> static struct pid_namespace *create_pid_namespace(struct user_namespace *user_ns</span>
 
 static void delayed_free_pidns(struct rcu_head *p)
 {
<span class="p_del">-	kmem_cache_free(pid_ns_cachep,</span>
<span class="p_del">-			container_of(p, struct pid_namespace, rcu));</span>
<span class="p_add">+	struct pid_namespace *ns = container_of(p, struct pid_namespace, rcu);</span>
<span class="p_add">+</span>
<span class="p_add">+	dec_pid_namespaces(ns-&gt;ucounts);</span>
<span class="p_add">+	put_user_ns(ns-&gt;user_ns);</span>
<span class="p_add">+</span>
<span class="p_add">+	kmem_cache_free(pid_ns_cachep, ns);</span>
 }
 
 static void destroy_pid_namespace(struct pid_namespace *ns)
<span class="p_chunk">@@ -162,8 +166,6 @@</span> <span class="p_context"> static void destroy_pid_namespace(struct pid_namespace *ns)</span>
 	ns_free_inum(&amp;ns-&gt;ns);
 	for (i = 0; i &lt; PIDMAP_ENTRIES; i++)
 		kfree(ns-&gt;pidmap[i].page);
<span class="p_del">-	dec_pid_namespaces(ns-&gt;ucounts);</span>
<span class="p_del">-	put_user_ns(ns-&gt;user_ns);</span>
 	call_rcu(&amp;ns-&gt;rcu, delayed_free_pidns);
 }
 
<span class="p_header">diff --git a/lib/iov_iter.c b/lib/iov_iter.c</span>
<span class="p_header">index f2bd21b93dfc..efb0b4d267a1 100644</span>
<span class="p_header">--- a/lib/iov_iter.c</span>
<span class="p_header">+++ b/lib/iov_iter.c</span>
<span class="p_chunk">@@ -678,43 +678,50 @@</span> <span class="p_context"> size_t iov_iter_copy_from_user_atomic(struct page *page,</span>
 }
 EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);
 
<span class="p_add">+static inline void pipe_truncate(struct iov_iter *i)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pipe_inode_info *pipe = i-&gt;pipe;</span>
<span class="p_add">+	if (pipe-&gt;nrbufs) {</span>
<span class="p_add">+		size_t off = i-&gt;iov_offset;</span>
<span class="p_add">+		int idx = i-&gt;idx;</span>
<span class="p_add">+		int nrbufs = (idx - pipe-&gt;curbuf) &amp; (pipe-&gt;buffers - 1);</span>
<span class="p_add">+		if (off) {</span>
<span class="p_add">+			pipe-&gt;bufs[idx].len = off - pipe-&gt;bufs[idx].offset;</span>
<span class="p_add">+			idx = next_idx(idx, pipe);</span>
<span class="p_add">+			nrbufs++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		while (pipe-&gt;nrbufs &gt; nrbufs) {</span>
<span class="p_add">+			pipe_buf_release(pipe, &amp;pipe-&gt;bufs[idx]);</span>
<span class="p_add">+			idx = next_idx(idx, pipe);</span>
<span class="p_add">+			pipe-&gt;nrbufs--;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void pipe_advance(struct iov_iter *i, size_t size)
 {
 	struct pipe_inode_info *pipe = i-&gt;pipe;
<span class="p_del">-	struct pipe_buffer *buf;</span>
<span class="p_del">-	int idx = i-&gt;idx;</span>
<span class="p_del">-	size_t off = i-&gt;iov_offset, orig_sz;</span>
<span class="p_del">-	</span>
 	if (unlikely(i-&gt;count &lt; size))
 		size = i-&gt;count;
<span class="p_del">-	orig_sz = size;</span>
<span class="p_del">-</span>
 	if (size) {
<span class="p_add">+		struct pipe_buffer *buf;</span>
<span class="p_add">+		size_t off = i-&gt;iov_offset, left = size;</span>
<span class="p_add">+		int idx = i-&gt;idx;</span>
 		if (off) /* make it relative to the beginning of buffer */
<span class="p_del">-			size += off - pipe-&gt;bufs[idx].offset;</span>
<span class="p_add">+			left += off - pipe-&gt;bufs[idx].offset;</span>
 		while (1) {
 			buf = &amp;pipe-&gt;bufs[idx];
<span class="p_del">-			if (size &lt;= buf-&gt;len)</span>
<span class="p_add">+			if (left &lt;= buf-&gt;len)</span>
 				break;
<span class="p_del">-			size -= buf-&gt;len;</span>
<span class="p_add">+			left -= buf-&gt;len;</span>
 			idx = next_idx(idx, pipe);
 		}
<span class="p_del">-		buf-&gt;len = size;</span>
 		i-&gt;idx = idx;
<span class="p_del">-		off = i-&gt;iov_offset = buf-&gt;offset + size;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (off)</span>
<span class="p_del">-		idx = next_idx(idx, pipe);</span>
<span class="p_del">-	if (pipe-&gt;nrbufs) {</span>
<span class="p_del">-		int unused = (pipe-&gt;curbuf + pipe-&gt;nrbufs) &amp; (pipe-&gt;buffers - 1);</span>
<span class="p_del">-		/* [curbuf,unused) is in use.  Free [idx,unused) */</span>
<span class="p_del">-		while (idx != unused) {</span>
<span class="p_del">-			pipe_buf_release(pipe, &amp;pipe-&gt;bufs[idx]);</span>
<span class="p_del">-			idx = next_idx(idx, pipe);</span>
<span class="p_del">-			pipe-&gt;nrbufs--;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		i-&gt;iov_offset = buf-&gt;offset + left;</span>
 	}
<span class="p_del">-	i-&gt;count -= orig_sz;</span>
<span class="p_add">+	i-&gt;count -= size;</span>
<span class="p_add">+	/* ... and discard everything past that point */</span>
<span class="p_add">+	pipe_truncate(i);</span>
 }
 
 void iov_iter_advance(struct iov_iter *i, size_t size)
<span class="p_chunk">@@ -774,6 +781,7 @@</span> <span class="p_context"> void iov_iter_pipe(struct iov_iter *i, int direction,</span>
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
<span class="p_add">+	WARN_ON(pipe-&gt;nrbufs == pipe-&gt;buffers);</span>
 	i-&gt;type = direction;
 	i-&gt;pipe = pipe;
 	i-&gt;idx = (pipe-&gt;curbuf + pipe-&gt;nrbufs) &amp; (pipe-&gt;buffers - 1);
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index 9a50acecc473..779801092ef1 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static int page_cache_tree_insert(struct address_space *mapping,</span>
 				workingset_node_pages_dec(node);
 			/* Wakeup waiters for exceptional entry lock */
 			dax_wake_mapping_entry_waiter(mapping, page-&gt;index,
<span class="p_del">-						      false);</span>
<span class="p_add">+						      true);</span>
 		}
 	}
 	radix_tree_replace_slot(slot, page);
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index d4a6e4001512..8ca40b70beae 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -872,15 +872,17 @@</span> <span class="p_context"> void huge_pmd_set_accessed(struct fault_env *fe, pmd_t orig_pmd)</span>
 {
 	pmd_t entry;
 	unsigned long haddr;
<span class="p_add">+	bool write = fe-&gt;flags &amp; FAULT_FLAG_WRITE;</span>
 
 	fe-&gt;ptl = pmd_lock(fe-&gt;vma-&gt;vm_mm, fe-&gt;pmd);
 	if (unlikely(!pmd_same(*fe-&gt;pmd, orig_pmd)))
 		goto unlock;
 
 	entry = pmd_mkyoung(orig_pmd);
<span class="p_add">+	if (write)</span>
<span class="p_add">+		entry = pmd_mkdirty(entry);</span>
 	haddr = fe-&gt;address &amp; HPAGE_PMD_MASK;
<span class="p_del">-	if (pmdp_set_access_flags(fe-&gt;vma, haddr, fe-&gt;pmd, entry,</span>
<span class="p_del">-				fe-&gt;flags &amp; FAULT_FLAG_WRITE))</span>
<span class="p_add">+	if (pmdp_set_access_flags(fe-&gt;vma, haddr, fe-&gt;pmd, entry, write))</span>
 		update_mmu_cache_pmd(fe-&gt;vma, fe-&gt;address, fe-&gt;pmd);
 
 unlock:
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 23aec01836aa..b6adedbafaf5 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1773,23 +1773,32 @@</span> <span class="p_context"> static int gather_surplus_pages(struct hstate *h, int delta)</span>
 }
 
 /*
<span class="p_del">- * When releasing a hugetlb pool reservation, any surplus pages that were</span>
<span class="p_del">- * allocated to satisfy the reservation must be explicitly freed if they were</span>
<span class="p_del">- * never used.</span>
<span class="p_del">- * Called with hugetlb_lock held.</span>
<span class="p_add">+ * This routine has two main purposes:</span>
<span class="p_add">+ * 1) Decrement the reservation count (resv_huge_pages) by the value passed</span>
<span class="p_add">+ *    in unused_resv_pages.  This corresponds to the prior adjustments made</span>
<span class="p_add">+ *    to the associated reservation map.</span>
<span class="p_add">+ * 2) Free any unused surplus pages that may have been allocated to satisfy</span>
<span class="p_add">+ *    the reservation.  As many as unused_resv_pages may be freed.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called with hugetlb_lock held.  However, the lock could be dropped (and</span>
<span class="p_add">+ * reacquired) during calls to cond_resched_lock.  Whenever dropping the lock,</span>
<span class="p_add">+ * we must make sure nobody else can claim pages we are in the process of</span>
<span class="p_add">+ * freeing.  Do this by ensuring resv_huge_page always is greater than the</span>
<span class="p_add">+ * number of huge pages we plan to free when dropping the lock.</span>
  */
 static void return_unused_surplus_pages(struct hstate *h,
 					unsigned long unused_resv_pages)
 {
 	unsigned long nr_pages;
 
<span class="p_del">-	/* Uncommit the reservation */</span>
<span class="p_del">-	h-&gt;resv_huge_pages -= unused_resv_pages;</span>
<span class="p_del">-</span>
 	/* Cannot return gigantic pages currently */
 	if (hstate_is_gigantic(h))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Part (or even all) of the reservation could have been backed</span>
<span class="p_add">+	 * by pre-allocated pages. Only free surplus pages.</span>
<span class="p_add">+	 */</span>
 	nr_pages = min(unused_resv_pages, h-&gt;surplus_huge_pages);
 
 	/*
<span class="p_chunk">@@ -1799,12 +1808,22 @@</span> <span class="p_context"> static void return_unused_surplus_pages(struct hstate *h,</span>
 	 * when the nodes with surplus pages have no free pages.
 	 * free_pool_huge_page() will balance the the freed pages across the
 	 * on-line nodes with memory and will handle the hstate accounting.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we decrement resv_huge_pages as we free the pages.  If</span>
<span class="p_add">+	 * we drop the lock, resv_huge_pages will still be sufficiently large</span>
<span class="p_add">+	 * to cover subsequent pages we may free.</span>
 	 */
 	while (nr_pages--) {
<span class="p_add">+		h-&gt;resv_huge_pages--;</span>
<span class="p_add">+		unused_resv_pages--;</span>
 		if (!free_pool_huge_page(h, &amp;node_states[N_MEMORY], 1))
<span class="p_del">-			break;</span>
<span class="p_add">+			goto out;</span>
 		cond_resched_lock(&amp;hugetlb_lock);
 	}
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	/* Fully uncommit the reservation */</span>
<span class="p_add">+	h-&gt;resv_huge_pages -= unused_resv_pages;</span>
 }
 
 
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 0f870ba43942..d536a9daa511 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -625,8 +625,8 @@</span> <span class="p_context"> static void mem_cgroup_charge_statistics(struct mem_cgroup *memcg,</span>
 unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,
 					   int nid, unsigned int lru_mask)
 {
<span class="p_add">+	struct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);</span>
 	unsigned long nr = 0;
<span class="p_del">-	struct mem_cgroup_per_node *mz;</span>
 	enum lru_list lru;
 
 	VM_BUG_ON((unsigned)nid &gt;= nr_node_ids);
<span class="p_chunk">@@ -634,8 +634,7 @@</span> <span class="p_context"> unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,</span>
 	for_each_lru(lru) {
 		if (!(BIT(lru) &amp; lru_mask))
 			continue;
<span class="p_del">-		mz = mem_cgroup_nodeinfo(memcg, nid);</span>
<span class="p_del">-		nr += mz-&gt;lru_size[lru];</span>
<span class="p_add">+		nr += mem_cgroup_get_lru_size(lruvec, lru);</span>
 	}
 	return nr;
 }
<span class="p_chunk">@@ -1002,6 +1001,7 @@</span> <span class="p_context"> struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgd</span>
  * mem_cgroup_update_lru_size - account for adding or removing an lru page
  * @lruvec: mem_cgroup per zone lru vector
  * @lru: index of lru list the page is sitting on
<span class="p_add">+ * @zid: zone id of the accounted pages</span>
  * @nr_pages: positive when adding or negative when removing
  *
  * This function must be called under lru_lock, just before a page is added
<span class="p_chunk">@@ -1009,27 +1009,25 @@</span> <span class="p_context"> struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgd</span>
  * so as to allow it to check that lru_size 0 is consistent with list_empty).
  */
 void mem_cgroup_update_lru_size(struct lruvec *lruvec, enum lru_list lru,
<span class="p_del">-				int nr_pages)</span>
<span class="p_add">+				int zid, int nr_pages)</span>
 {
 	struct mem_cgroup_per_node *mz;
 	unsigned long *lru_size;
 	long size;
<span class="p_del">-	bool empty;</span>
 
 	if (mem_cgroup_disabled())
 		return;
 
 	mz = container_of(lruvec, struct mem_cgroup_per_node, lruvec);
<span class="p_del">-	lru_size = mz-&gt;lru_size + lru;</span>
<span class="p_del">-	empty = list_empty(lruvec-&gt;lists + lru);</span>
<span class="p_add">+	lru_size = &amp;mz-&gt;lru_zone_size[zid][lru];</span>
 
 	if (nr_pages &lt; 0)
 		*lru_size += nr_pages;
 
 	size = *lru_size;
<span class="p_del">-	if (WARN_ONCE(size &lt; 0 || empty != !size,</span>
<span class="p_del">-		&quot;%s(%p, %d, %d): lru_size %ld but %sempty\n&quot;,</span>
<span class="p_del">-		__func__, lruvec, lru, nr_pages, size, empty ? &quot;&quot; : &quot;not &quot;)) {</span>
<span class="p_add">+	if (WARN_ONCE(size &lt; 0,</span>
<span class="p_add">+		&quot;%s(%p, %d, %d): lru_size %ld\n&quot;,</span>
<span class="p_add">+		__func__, lruvec, lru, nr_pages, size)) {</span>
 		VM_BUG_ON(1);
 		*lru_size = 0;
 	}
<span class="p_header">diff --git a/mm/slab.c b/mm/slab.c</span>
<span class="p_header">index 0b0550ca85b4..bd878f051a3b 100644</span>
<span class="p_header">--- a/mm/slab.c</span>
<span class="p_header">+++ b/mm/slab.c</span>
<span class="p_chunk">@@ -2475,7 +2475,6 @@</span> <span class="p_context"> union freelist_init_state {</span>
 		unsigned int pos;
 		unsigned int *list;
 		unsigned int count;
<span class="p_del">-		unsigned int rand;</span>
 	};
 	struct rnd_state rnd_state;
 };
<span class="p_chunk">@@ -2501,8 +2500,7 @@</span> <span class="p_context"> static bool freelist_state_initialize(union freelist_init_state *state,</span>
 	} else {
 		state-&gt;list = cachep-&gt;random_seq;
 		state-&gt;count = count;
<span class="p_del">-		state-&gt;pos = 0;</span>
<span class="p_del">-		state-&gt;rand = rand;</span>
<span class="p_add">+		state-&gt;pos = rand % count;</span>
 		ret = true;
 	}
 	return ret;
<span class="p_chunk">@@ -2511,7 +2509,9 @@</span> <span class="p_context"> static bool freelist_state_initialize(union freelist_init_state *state,</span>
 /* Get the next entry on the list and randomize it using a random shift */
 static freelist_idx_t next_random_slot(union freelist_init_state *state)
 {
<span class="p_del">-	return (state-&gt;list[state-&gt;pos++] + state-&gt;rand) % state-&gt;count;</span>
<span class="p_add">+	if (state-&gt;pos &gt;= state-&gt;count)</span>
<span class="p_add">+		state-&gt;pos = 0;</span>
<span class="p_add">+	return state-&gt;list[state-&gt;pos++];</span>
 }
 
 /* Swap two freelist entries */
<span class="p_header">diff --git a/mm/swapfile.c b/mm/swapfile.c</span>
<span class="p_header">index f30438970cd1..d76b2a18f044 100644</span>
<span class="p_header">--- a/mm/swapfile.c</span>
<span class="p_header">+++ b/mm/swapfile.c</span>
<span class="p_chunk">@@ -943,11 +943,25 @@</span> <span class="p_context"> bool reuse_swap_page(struct page *page, int *total_mapcount)</span>
 	count = page_trans_huge_mapcount(page, total_mapcount);
 	if (count &lt;= 1 &amp;&amp; PageSwapCache(page)) {
 		count += page_swapcount(page);
<span class="p_del">-		if (count == 1 &amp;&amp; !PageWriteback(page)) {</span>
<span class="p_add">+		if (count != 1)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		if (!PageWriteback(page)) {</span>
 			delete_from_swap_cache(page);
 			SetPageDirty(page);
<span class="p_add">+		} else {</span>
<span class="p_add">+			swp_entry_t entry;</span>
<span class="p_add">+			struct swap_info_struct *p;</span>
<span class="p_add">+</span>
<span class="p_add">+			entry.val = page_private(page);</span>
<span class="p_add">+			p = swap_info_get(entry);</span>
<span class="p_add">+			if (p-&gt;flags &amp; SWP_STABLE_WRITES) {</span>
<span class="p_add">+				spin_unlock(&amp;p-&gt;lock);</span>
<span class="p_add">+				return false;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			spin_unlock(&amp;p-&gt;lock);</span>
 		}
 	}
<span class="p_add">+out:</span>
 	return count &lt;= 1;
 }
 
<span class="p_chunk">@@ -2449,6 +2463,10 @@</span> <span class="p_context"> SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)</span>
 		error = -ENOMEM;
 		goto bad_swap;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (bdi_cap_stable_pages_required(inode_to_bdi(inode)))</span>
<span class="p_add">+		p-&gt;flags |= SWP_STABLE_WRITES;</span>
<span class="p_add">+</span>
 	if (p-&gt;bdev &amp;&amp; blk_queue_nonrot(bdev_get_queue(p-&gt;bdev))) {
 		int cpu;
 
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index c4abf08861d2..fa30010a5277 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -242,6 +242,16 @@</span> <span class="p_context"> unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru)</span>
 	return node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);
 }
 
<span class="p_add">+unsigned long lruvec_zone_lru_size(struct lruvec *lruvec, enum lru_list lru,</span>
<span class="p_add">+				   int zone_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!mem_cgroup_disabled())</span>
<span class="p_add">+		return mem_cgroup_get_zone_lru_size(lruvec, lru, zone_idx);</span>
<span class="p_add">+</span>
<span class="p_add">+	return zone_page_state(&amp;lruvec_pgdat(lruvec)-&gt;node_zones[zone_idx],</span>
<span class="p_add">+			       NR_ZONE_LRU_BASE + lru);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Add a shrinker callback to be called from the vm.
  */
<span class="p_chunk">@@ -1382,8 +1392,7 @@</span> <span class="p_context"> int __isolate_lru_page(struct page *page, isolate_mode_t mode)</span>
  * be complete before mem_cgroup_update_lru_size due to a santity check.
  */
 static __always_inline void update_lru_sizes(struct lruvec *lruvec,
<span class="p_del">-			enum lru_list lru, unsigned long *nr_zone_taken,</span>
<span class="p_del">-			unsigned long nr_taken)</span>
<span class="p_add">+			enum lru_list lru, unsigned long *nr_zone_taken)</span>
 {
 	int zid;
 
<span class="p_chunk">@@ -1392,11 +1401,11 @@</span> <span class="p_context"> static __always_inline void update_lru_sizes(struct lruvec *lruvec,</span>
 			continue;
 
 		__update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_MEMCG
<span class="p_del">-	mem_cgroup_update_lru_size(lruvec, lru, -nr_taken);</span>
<span class="p_add">+		mem_cgroup_update_lru_size(lruvec, lru, zid, -nr_zone_taken[zid]);</span>
 #endif
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 }
 
 /*
<span class="p_chunk">@@ -1501,7 +1510,7 @@</span> <span class="p_context"> static unsigned long isolate_lru_pages(unsigned long nr_to_scan,</span>
 	*nr_scanned = scan;
 	trace_mm_vmscan_lru_isolate(sc-&gt;reclaim_idx, sc-&gt;order, nr_to_scan, scan,
 				    nr_taken, mode, is_file_lru(lru));
<span class="p_del">-	update_lru_sizes(lruvec, lru, nr_zone_taken, nr_taken);</span>
<span class="p_add">+	update_lru_sizes(lruvec, lru, nr_zone_taken);</span>
 	return nr_taken;
 }
 
<span class="p_chunk">@@ -2047,10 +2056,8 @@</span> <span class="p_context"> static bool inactive_list_is_low(struct lruvec *lruvec, bool file,</span>
 		if (!managed_zone(zone))
 			continue;
 
<span class="p_del">-		inactive_zone = zone_page_state(zone,</span>
<span class="p_del">-				NR_ZONE_LRU_BASE + (file * LRU_FILE));</span>
<span class="p_del">-		active_zone = zone_page_state(zone,</span>
<span class="p_del">-				NR_ZONE_LRU_BASE + (file * LRU_FILE) + LRU_ACTIVE);</span>
<span class="p_add">+		inactive_zone = lruvec_zone_lru_size(lruvec, file * LRU_FILE, zid);</span>
<span class="p_add">+		active_zone = lruvec_zone_lru_size(lruvec, (file * LRU_FILE) + LRU_ACTIVE, zid);</span>
 
 		inactive -= min(inactive, inactive_zone);
 		active -= min(active, active_zone);
<span class="p_header">diff --git a/net/bridge/br_netfilter_hooks.c b/net/bridge/br_netfilter_hooks.c</span>
<span class="p_header">index 2fe9345c1407..7fbdbae58e65 100644</span>
<span class="p_header">--- a/net/bridge/br_netfilter_hooks.c</span>
<span class="p_header">+++ b/net/bridge/br_netfilter_hooks.c</span>
<span class="p_chunk">@@ -399,7 +399,7 @@</span> <span class="p_context"> static int br_nf_pre_routing_finish(struct net *net, struct sock *sk, struct sk_</span>
 				br_nf_hook_thresh(NF_BR_PRE_ROUTING,
 						  net, sk, skb, skb-&gt;dev,
 						  NULL,
<span class="p_del">-						  br_nf_pre_routing_finish);</span>
<span class="p_add">+						  br_nf_pre_routing_finish_bridge);</span>
 				return 0;
 			}
 			ether_addr_copy(eth_hdr(skb)-&gt;h_dest, dev-&gt;dev_addr);
<span class="p_header">diff --git a/net/iucv/af_iucv.c b/net/iucv/af_iucv.c</span>
<span class="p_header">index 02b45a8e8b35..91cbbf1c3f82 100644</span>
<span class="p_header">--- a/net/iucv/af_iucv.c</span>
<span class="p_header">+++ b/net/iucv/af_iucv.c</span>
<span class="p_chunk">@@ -1036,7 +1036,8 @@</span> <span class="p_context"> static int iucv_sock_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	struct iucv_sock *iucv = iucv_sk(sk);
<span class="p_del">-	size_t headroom, linear;</span>
<span class="p_add">+	size_t headroom = 0;</span>
<span class="p_add">+	size_t linear;</span>
 	struct sk_buff *skb;
 	struct iucv_message txmsg = {0};
 	struct cmsghdr *cmsg;
<span class="p_chunk">@@ -1114,18 +1115,20 @@</span> <span class="p_context"> static int iucv_sock_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 	 * this is fine for SOCK_SEQPACKET (unless we want to support
 	 * segmented records using the MSG_EOR flag), but
 	 * for SOCK_STREAM we might want to improve it in future */
<span class="p_del">-	headroom = (iucv-&gt;transport == AF_IUCV_TRANS_HIPER)</span>
<span class="p_del">-		   ? sizeof(struct af_iucv_trans_hdr) + ETH_HLEN : 0;</span>
<span class="p_del">-	if (headroom + len &lt; PAGE_SIZE) {</span>
<span class="p_add">+	if (iucv-&gt;transport == AF_IUCV_TRANS_HIPER) {</span>
<span class="p_add">+		headroom = sizeof(struct af_iucv_trans_hdr) + ETH_HLEN;</span>
 		linear = len;
 	} else {
<span class="p_del">-		/* In nonlinear &quot;classic&quot; iucv skb,</span>
<span class="p_del">-		 * reserve space for iucv_array</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (iucv-&gt;transport != AF_IUCV_TRANS_HIPER)</span>
<span class="p_del">-			headroom += sizeof(struct iucv_array) *</span>
<span class="p_del">-				    (MAX_SKB_FRAGS + 1);</span>
<span class="p_del">-		linear = PAGE_SIZE - headroom;</span>
<span class="p_add">+		if (len &lt; PAGE_SIZE) {</span>
<span class="p_add">+			linear = len;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* In nonlinear &quot;classic&quot; iucv skb,</span>
<span class="p_add">+			 * reserve space for iucv_array</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			headroom = sizeof(struct iucv_array) *</span>
<span class="p_add">+				   (MAX_SKB_FRAGS + 1);</span>
<span class="p_add">+			linear = PAGE_SIZE - headroom;</span>
<span class="p_add">+		}</span>
 	}
 	skb = sock_alloc_send_pskb(sk, headroom + linear, len - linear,
 				   noblock, &amp;err, 0);
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index a2dd6edaae37..1b3c18c2c1ec 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -14402,13 +14402,17 @@</span> <span class="p_context"> static int nl80211_netlink_notify(struct notifier_block * nb,</span>
 
 	list_for_each_entry_rcu(rdev, &amp;cfg80211_rdev_list, list) {
 		bool schedule_destroy_work = false;
<span class="p_del">-		bool schedule_scan_stop = false;</span>
 		struct cfg80211_sched_scan_request *sched_scan_req =
 			rcu_dereference(rdev-&gt;sched_scan_req);
 
 		if (sched_scan_req &amp;&amp; notify-&gt;portid &amp;&amp;
<span class="p_del">-		    sched_scan_req-&gt;owner_nlportid == notify-&gt;portid)</span>
<span class="p_del">-			schedule_scan_stop = true;</span>
<span class="p_add">+		    sched_scan_req-&gt;owner_nlportid == notify-&gt;portid) {</span>
<span class="p_add">+			sched_scan_req-&gt;owner_nlportid = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (rdev-&gt;ops-&gt;sched_scan_stop &amp;&amp;</span>
<span class="p_add">+			    rdev-&gt;wiphy.flags &amp; WIPHY_FLAG_SUPPORTS_SCHED_SCAN)</span>
<span class="p_add">+				schedule_work(&amp;rdev-&gt;sched_scan_stop_wk);</span>
<span class="p_add">+		}</span>
 
 		list_for_each_entry_rcu(wdev, &amp;rdev-&gt;wiphy.wdev_list, list) {
 			cfg80211_mlme_unregister_socket(wdev, notify-&gt;portid);
<span class="p_chunk">@@ -14439,12 +14443,6 @@</span> <span class="p_context"> static int nl80211_netlink_notify(struct notifier_block * nb,</span>
 				spin_unlock(&amp;rdev-&gt;destroy_list_lock);
 				schedule_work(&amp;rdev-&gt;destroy_work);
 			}
<span class="p_del">-		} else if (schedule_scan_stop) {</span>
<span class="p_del">-			sched_scan_req-&gt;owner_nlportid = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (rdev-&gt;ops-&gt;sched_scan_stop &amp;&amp;</span>
<span class="p_del">-			    rdev-&gt;wiphy.flags &amp; WIPHY_FLAG_SUPPORTS_SCHED_SCAN)</span>
<span class="p_del">-				schedule_work(&amp;rdev-&gt;sched_scan_stop_wk);</span>
 		}
 	}
 
<span class="p_header">diff --git a/tools/testing/selftests/Makefile b/tools/testing/selftests/Makefile</span>
<span class="p_header">index f770dba2a6f6..a899ef81c705 100644</span>
<span class="p_header">--- a/tools/testing/selftests/Makefile</span>
<span class="p_header">+++ b/tools/testing/selftests/Makefile</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> ifdef INSTALL_PATH</span>
 	done;
 
 	@# Ask all targets to emit their test scripts
<span class="p_del">-	echo &quot;#!/bin/bash&quot; &gt; $(ALL_SCRIPT)</span>
<span class="p_add">+	echo &quot;#!/bin/sh&quot; &gt; $(ALL_SCRIPT)</span>
 	echo &quot;cd \$$(dirname \$$0)&quot; &gt;&gt; $(ALL_SCRIPT)
 	echo &quot;ROOT=\$$PWD&quot; &gt;&gt; $(ALL_SCRIPT)
 
<span class="p_header">diff --git a/tools/testing/selftests/net/run_netsocktests b/tools/testing/selftests/net/run_netsocktests</span>
<span class="p_header">index c09a682df56a..16058bbea7a8 100755</span>
<span class="p_header">--- a/tools/testing/selftests/net/run_netsocktests</span>
<span class="p_header">+++ b/tools/testing/selftests/net/run_netsocktests</span>
<span class="p_chunk">@@ -1,4 +1,4 @@</span> <span class="p_context"></span>
<span class="p_del">-#!/bin/bash</span>
<span class="p_add">+#!/bin/sh</span>
 
 echo &quot;--------------------&quot;
 echo &quot;running socket test&quot;
<span class="p_header">diff --git a/virt/lib/irqbypass.c b/virt/lib/irqbypass.c</span>
<span class="p_header">index 52abac4bb6a2..6d2fcd6fcb25 100644</span>
<span class="p_header">--- a/virt/lib/irqbypass.c</span>
<span class="p_header">+++ b/virt/lib/irqbypass.c</span>
<span class="p_chunk">@@ -195,7 +195,7 @@</span> <span class="p_context"> int irq_bypass_register_consumer(struct irq_bypass_consumer *consumer)</span>
 	mutex_lock(&amp;lock);
 
 	list_for_each_entry(tmp, &amp;consumers, node) {
<span class="p_del">-		if (tmp-&gt;token == consumer-&gt;token) {</span>
<span class="p_add">+		if (tmp-&gt;token == consumer-&gt;token || tmp == consumer) {</span>
 			mutex_unlock(&amp;lock);
 			module_put(THIS_MODULE);
 			return -EBUSY;
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> void irq_bypass_unregister_consumer(struct irq_bypass_consumer *consumer)</span>
 	mutex_lock(&amp;lock);
 
 	list_for_each_entry(tmp, &amp;consumers, node) {
<span class="p_del">-		if (tmp-&gt;token != consumer-&gt;token)</span>
<span class="p_add">+		if (tmp != consumer)</span>
 			continue;
 
 		list_for_each_entry(producer, &amp;producers, node) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



