
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.39 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.39</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 20, 2016, 10:57 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161120105745.GH2697@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9438471/mbox/"
   >mbox</a>
|
   <a href="/patch/9438471/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9438471/">/patch/9438471/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	5A28B6047D for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 20 Nov 2016 10:59:09 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2334128ABA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 20 Nov 2016 10:59:09 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1124228ABE; Sun, 20 Nov 2016 10:59:09 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 42D5E28ABA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 20 Nov 2016 10:59:08 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753887AbcKTK6z (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 20 Nov 2016 05:58:55 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:37289 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1753582AbcKTK6T (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 20 Nov 2016 05:58:19 -0500
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1c8Pof-0005cx-HU; Sun, 20 Nov 2016 10:58:07 +0000
Date: Sun, 20 Nov 2016 10:57:45 +0000
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20161120105745.GH2697@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;L/Qt9NZ8t00Dhfad&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	shadbolt.decadent.org.uk
X-Spam-Level: **
X-Spam-Status: No, score=2.2 required=5.0 tests=FILL_THIS_FORM,
	FILL_THIS_FORM_LOAN,NO_RELAYS autolearn=disabled version=3.4.0
Subject: Linux 3.16.39
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Nov. 20, 2016, 10:57 a.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.39 kernel.

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.38 is attached to this message.

Ben.

------------

 Documentation/filesystems/porting                  |   4 +-
 Documentation/module-signing.txt                   |   6 +
 Makefile                                           |   2 +-
 arch/alpha/include/asm/uaccess.h                   |  19 ++-
 arch/arc/include/asm/irqflags.h                    |   2 +-
 arch/arc/include/asm/uaccess.h                     |  11 +-
 arch/arc/mm/tlbex.S                                |   6 +-
 arch/arm/boot/compressed/head.S                    |   2 +-
 arch/arm/boot/dts/kirkwood-ib62x0.dts              |   2 +-
 arch/arm/common/sa1111.c                           |  22 +--
 arch/arm/include/asm/dma-mapping.h                 |   2 +-
 arch/arm/kernel/sys_oabi-compat.c                  |   8 +-
 arch/arm/kvm/arm.c                                 |   2 -
 arch/arm/kvm/mmu.c                                 |   1 +
 arch/arm/mach-mvebu/coherency.c                    |  22 ++-
 .../mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c |   1 +
 arch/arm/mach-omap2/omap_hwmod_3xxx_data.c         |  12 ++
 arch/arm/mach-omap2/prcm43xx.h                     |   1 +
 arch/arm/mach-sa1100/generic.c                     |   3 +
 arch/arm/mm/dma-mapping.c                          |  59 +++++---
 arch/arm64/crypto/aes-glue.c                       |   2 +-
 arch/arm64/include/asm/elf.h                       |   1 +
 arch/arm64/include/asm/spinlock.h                  |  10 ++
 arch/arm64/include/uapi/asm/auxvec.h               |   2 +
 arch/arm64/kernel/debug-monitors.c                 |   1 -
 arch/arm64/kernel/perf_event.c                     |  21 ++-
 arch/arm64/kernel/smp.c                            |   1 -
 arch/arm64/mm/proc.S                               |   2 +
 arch/avr32/include/asm/uaccess.h                   |  11 +-
 arch/avr32/kernel/avr32_ksyms.c                    |   2 +-
 arch/avr32/lib/copy_user.S                         |   8 +-
 arch/avr32/mach-at32ap/pio.c                       |   2 +-
 arch/blackfin/include/asm/uaccess.h                |   9 +-
 arch/cris/include/asm/uaccess.h                    |  71 +++++-----
 arch/frv/include/asm/uaccess.h                     |  12 +-
 arch/hexagon/include/asm/uaccess.h                 |   3 +-
 arch/ia64/include/asm/uaccess.h                    |  20 ++-
 arch/m32r/include/asm/uaccess.h                    |   2 +-
 arch/metag/include/asm/cmpxchg_lnkget.h            |   2 +-
 arch/metag/include/asm/uaccess.h                   |   3 +-
 arch/microblaze/include/asm/uaccess.h              |  11 +-
 .../include/asm/mach-paravirt/kernel-entry-init.h  |   2 +
 arch/mips/include/asm/pgtable.h                    |   6 +-
 arch/mips/include/asm/r4kcache.h                   |   4 +
 arch/mips/include/asm/uaccess.h                    |   3 +
 arch/mips/kernel/scall64-n32.S                     |   2 +-
 arch/mips/kernel/scall64-o32.S                     |   2 +-
 arch/mips/kvm/kvm_mips.c                           |   2 +-
 arch/mips/kvm/kvm_mips_emul.c                      |  98 ++++++++++---
 arch/mips/kvm/kvm_tlb.c                            |  64 ++++++---
 arch/mips/mm/sc-rm7k.c                             |   2 +-
 arch/mips/mti-malta/malta-setup.c                  |   8 +-
 arch/mips/net/bpf_jit.c                            |   2 +-
 arch/mn10300/include/asm/uaccess.h                 |   1 +
 arch/mn10300/lib/usercopy.c                        |   4 +-
 arch/openrisc/include/asm/uaccess.h                |  35 ++---
 arch/parisc/include/asm/uaccess.h                  |   7 +-
 arch/parisc/include/uapi/asm/errno.h               |   4 +-
 arch/powerpc/include/asm/pci-bridge.h              |   1 +
 arch/powerpc/include/asm/uaccess.h                 |  21 +--
 arch/powerpc/kernel/exceptions-64s.S               |  39 ++----
 arch/powerpc/kernel/mce.c                          |   3 +-
 arch/powerpc/kernel/pci-common.c                   |  36 +++++
 arch/powerpc/kernel/prom_init.c                    |   9 +-
 arch/powerpc/kernel/tm.S                           |   3 +-
 arch/powerpc/platforms/powernv/opal-dump.c         |   7 +-
 arch/powerpc/platforms/powernv/opal-elog.c         |   7 +-
 arch/powerpc/platforms/powernv/opal.c              |   1 +
 arch/powerpc/platforms/pseries/pci.c               |   4 +
 arch/powerpc/platforms/pseries/pci_dlpar.c         |   7 +-
 arch/s390/include/asm/elf.h                        |   1 +
 arch/s390/include/asm/tlbflush.h                   |   3 +-
 arch/s390/include/asm/uaccess.h                    |   8 +-
 arch/s390/include/uapi/asm/auxvec.h                |   2 +
 arch/s390/mm/pgtable.c                             |   4 +-
 arch/score/include/asm/uaccess.h                   |  46 +++---
 arch/sh/include/asm/uaccess.h                      |   5 +-
 arch/sh/include/asm/uaccess_64.h                   |   1 +
 arch/sparc/include/asm/uaccess_32.h                |   4 +-
 arch/tile/include/asm/elf.h                        |   1 +
 arch/tile/include/uapi/asm/auxvec.h                |   2 +
 arch/x86/boot/compressed/eboot.c                   |  20 ++-
 arch/x86/include/asm/tlbflush.h                    |   7 +
 arch/x86/kernel/apic/apic.c                        |   3 +
 arch/x86/kernel/cpu/amd.c                          |  14 ++
 arch/x86/kernel/cpu/perf_event_amd.c               |   4 +-
 arch/x86/kernel/early-quirks.c                     | 105 ++++++++++++--
 arch/x86/kernel/paravirt.c                         |   4 +-
 arch/x86/kvm/vmx.c                                 |  77 +++++++---
 arch/x86/syscalls/syscall_32.tbl                   |   2 +-
 block/genhd.c                                      |   3 +-
 crypto/blkcipher.c                                 |   3 +-
 crypto/cryptd.c                                    |   9 +-
 crypto/gcm.c                                       |   4 +-
 crypto/scatterwalk.c                               |   3 +-
 drivers/bcma/bcma_private.h                        |   2 -
 drivers/bluetooth/ath3k.c                          |   4 +
 drivers/bluetooth/btusb.c                          |   2 +
 drivers/char/hw_random/omap-rng.c                  |  16 ++-
 drivers/char/random.c                              |  13 +-
 drivers/char/tpm/tpm_tis.c                         |   9 +-
 drivers/clocksource/sun4i_timer.c                  |   9 +-
 drivers/crypto/caam/caamhash.c                     |   1 +
 drivers/crypto/nx/nx.c                             |   2 +-
 drivers/devfreq/devfreq.c                          |   2 +-
 drivers/firewire/net.c                             |  51 ++++---
 drivers/firmware/efi/efi-stub-helper.c             |  96 +++++++++----
 drivers/firmware/efi/fdt.c                         |  13 +-
 drivers/gpio/Kconfig                               |   1 +
 drivers/gpio/gpio-intel-mid.c                      |  19 ---
 drivers/gpio/gpio-pca953x.c                        |   2 +-
 drivers/gpu/drm/drm_crtc.c                         |   3 +
 drivers/gpu/drm/drm_edid.c                         |   8 ++
 drivers/gpu/drm/i915/intel_display.c               |  20 +--
 drivers/gpu/drm/msm/msm_drv.h                      |   6 +
 drivers/gpu/drm/msm/msm_gem.c                      |   9 ++
 drivers/gpu/drm/msm/msm_gem_submit.c               |  37 ++++-
 drivers/gpu/drm/nouveau/nouveau_acpi.c             |  76 +++++-----
 drivers/gpu/drm/nouveau/nouveau_drm.c              |   5 +-
 drivers/gpu/drm/nouveau/nv04_fbcon.c               |   4 +-
 drivers/gpu/drm/nouveau/nv50_fbcon.c               |   2 +-
 drivers/gpu/drm/nouveau/nvc0_fbcon.c               |   2 +-
 drivers/gpu/drm/qxl/qxl_draw.c                     |   2 +
 drivers/gpu/drm/radeon/atombios_encoders.c         |   1 +
 drivers/gpu/drm/radeon/radeon_atombios.c           |   4 +-
 drivers/gpu/drm/radeon/radeon_atpx_handler.c       |   5 +
 drivers/gpu/drm/radeon/radeon_connectors.c         |  15 +-
 drivers/gpu/drm/radeon/radeon_device.c             |   4 +
 drivers/gpu/drm/radeon/radeon_kms.c                |   4 +-
 drivers/gpu/drm/radeon/radeon_ttm.c                |   4 +-
 drivers/gpu/drm/radeon/si_dpm.c                    |   6 +
 drivers/hid/uhid.c                                 |  33 +++--
 drivers/hv/vmbus_drv.c                             |   3 +
 drivers/hwmon/adt7411.c                            |   5 +-
 drivers/i2c/busses/i2c-efm32.c                     |   2 +-
 drivers/i2c/busses/i2c-eg20t.c                     |  18 ++-
 drivers/i2c/busses/i2c-qup.c                       |   3 +-
 drivers/i2c/muxes/i2c-mux-pca954x.c                |   2 +-
 drivers/iio/accel/kxsd9.c                          |   2 +
 drivers/iio/adc/at91_adc.c                         |   4 +-
 drivers/iio/adc/ti_am335x_adc.c                    |  14 +-
 .../iio/common/hid-sensors/hid-sensor-attributes.c |   4 +-
 drivers/iio/industrialio-core.c                    |   5 +-
 drivers/iio/proximity/as3935.c                     |   2 +-
 drivers/infiniband/core/multicast.c                |  13 +-
 drivers/infiniband/hw/mlx4/mad.c                   |  23 +++
 drivers/infiniband/hw/mlx4/mcg.c                   |  14 +-
 drivers/infiniband/hw/mlx4/mlx4_ib.h               |   2 +-
 drivers/infiniband/hw/mlx4/qp.c                    |  37 ++---
 drivers/infiniband/ulp/ipoib/ipoib.h               |   1 +
 drivers/infiniband/ulp/ipoib/ipoib_cm.c            |  16 +++
 drivers/infiniband/ulp/ipoib/ipoib_ib.c            |   9 ++
 drivers/infiniband/ulp/ipoib/ipoib_main.c          |   2 +-
 drivers/input/joystick/xpad.c                      |   3 +
 drivers/input/keyboard/tegra-kbc.c                 |   2 +-
 drivers/input/serio/i8042.c                        |  17 +--
 drivers/input/serio/libps2.c                       |  10 +-
 drivers/md/bcache/super.c                          |  11 +-
 drivers/md/dm-crypt.c                              |   2 +-
 drivers/md/dm-flakey.c                             |  23 +--
 drivers/media/dvb-core/dvb_ringbuffer.c            |  96 +++++++++++--
 drivers/media/dvb-core/dvb_ringbuffer.h            |   2 +
 drivers/media/pci/ngene/ngene-dvb.c                |   2 +-
 drivers/media/platform/s5p-mfc/s5p_mfc.c           |  11 ++
 drivers/media/usb/em28xx/em28xx-i2c.c              |   5 +-
 drivers/media/usb/usbvision/usbvision-video.c      |   7 -
 drivers/mmc/card/block.c                           |  12 +-
 drivers/mtd/maps/pmcmsp-flash.c                    |   6 +-
 drivers/mtd/nand/davinci_nand.c                    |   3 +
 drivers/mtd/nand/nand_base.c                       |   2 +-
 drivers/mtd/ubi/attach.c                           |  27 +++-
 drivers/mtd/ubi/build.c                            |   5 +-
 drivers/mtd/ubi/ubi.h                              |   3 +
 drivers/mtd/ubi/vmt.c                              |  25 +++-
 drivers/net/can/dev.c                              |  27 ++--
 drivers/net/can/flexcan.c                          |  13 +-
 drivers/net/ethernet/ethoc.c                       |  10 +-
 drivers/net/ethernet/marvell/mvneta.c              |   2 +-
 drivers/net/ethernet/mellanox/mlx5/core/cmd.c      |  85 +++++++----
 drivers/net/macvlan.c                              |  10 +-
 drivers/net/ppp/ppp_generic.c                      |   5 +-
 drivers/net/tun.c                                  |   5 +-
 drivers/net/wireless/ath/ath9k/ar9003_eeprom.c     |   2 +-
 drivers/net/wireless/brcm80211/brcmfmac/bcmsdh.c   |   4 +-
 .../net/wireless/brcm80211/brcmfmac/wl_cfg80211.c  |   2 +-
 drivers/net/wireless/brcm80211/brcmsmac/dma.c      |   4 +-
 drivers/net/wireless/brcm80211/brcmsmac/stf.c      |   2 +-
 drivers/net/wireless/iwlwifi/pcie/tx.c             |   4 +-
 drivers/pci/quirks.c                               |  10 +-
 drivers/platform/x86/hp-wmi.c                      |   7 +-
 drivers/power/max17042_battery.c                   |  15 +-
 drivers/pps/clients/pps_parport.c                  |   2 +-
 drivers/rtc/rtc-ds1307.c                           |  28 +++-
 drivers/s390/block/dasd.c                          |  10 +-
 drivers/scsi/aacraid/commctrl.c                    |  13 +-
 drivers/scsi/arcmsr/arcmsr_hba.c                   |   8 +-
 drivers/scsi/constants.c                           |   5 +-
 drivers/scsi/megaraid/megaraid_sas_base.c          |   6 +-
 drivers/scsi/megaraid/megaraid_sas_fusion.c        |   2 +-
 drivers/staging/comedi/drivers/daqboard2000.c      |   2 +-
 drivers/staging/comedi/drivers/ni_mio_common.c     |  12 +-
 drivers/staging/lustre/lustre/llite/llite_lib.c    |   2 +-
 drivers/target/iscsi/iscsi_target.c                |  22 ++-
 drivers/target/iscsi/iscsi_target_login.c          |   5 +-
 drivers/target/target_core_device.c                |   8 +-
 drivers/target/target_core_file.c                  |   3 +-
 drivers/target/target_core_iblock.c                |   3 +-
 drivers/target/target_core_transport.c             |   9 +-
 drivers/tty/serial/8250/8250_pci.c                 | 139 ++++++++++++++++++
 drivers/tty/serial/atmel_serial.c                  |  14 +-
 drivers/tty/serial/samsung.c                       |  16 ++-
 drivers/tty/serial/sunhv.c                         |   6 -
 drivers/tty/vt/keyboard.c                          |  30 ++--
 drivers/usb/class/cdc-acm.c                        |   5 +-
 drivers/usb/class/cdc-acm.h                        |   1 -
 drivers/usb/core/config.c                          |  93 ++++++++++--
 drivers/usb/core/devio.c                           |  16 ++-
 drivers/usb/core/quirks.c                          |   6 +
 drivers/usb/dwc3/gadget.c                          |  23 +--
 drivers/usb/gadget/fsl_qe_udc.c                    |   9 +-
 drivers/usb/gadget/udc-core.c                      |   2 +-
 drivers/usb/host/xhci-hub.c                        |   3 +
 drivers/usb/host/xhci-pci.c                        |   3 +-
 drivers/usb/host/xhci-ring.c                       |  13 +-
 drivers/usb/misc/usbtest.c                         |   7 +-
 drivers/usb/renesas_usbhs/fifo.c                   |  22 ++-
 drivers/usb/renesas_usbhs/mod.c                    |  11 +-
 drivers/usb/renesas_usbhs/mod_gadget.c             |   9 +-
 drivers/usb/serial/ftdi_sio.c                      |   3 +
 drivers/usb/serial/ftdi_sio_ids.h                  |  12 ++
 drivers/usb/serial/mos7720.c                       |   2 +-
 drivers/usb/serial/mos7840.c                       |   4 +-
 drivers/usb/serial/option.c                        |  34 +++++
 drivers/usb/serial/usb-serial-simple.c             |   3 +-
 drivers/usb/serial/usb-serial.c                    |   4 +-
 drivers/vfio/pci/vfio_pci.c                        |  33 +++--
 drivers/vfio/pci/vfio_pci_intrs.c                  |  69 +++++----
 drivers/virtio/virtio_balloon.c                    |   2 +
 drivers/xen/xenbus/xenbus_dev_frontend.c           |  14 +-
 fs/9p/acl.c                                        |  40 +++---
 fs/9p/vfs_inode.c                                  |   2 +-
 fs/9p/vfs_inode_dotl.c                             |   2 +-
 fs/adfs/inode.c                                    |   2 +-
 fs/affs/inode.c                                    |   2 +-
 fs/attr.c                                          |  35 +++--
 fs/btrfs/acl.c                                     |   6 +-
 fs/btrfs/inode.c                                   |   2 +-
 fs/btrfs/ioctl.c                                   |  12 ++
 fs/btrfs/tree-log.c                                |   2 +
 fs/ceph/acl.c                                      |   6 +-
 fs/ceph/file.c                                     |  12 +-
 fs/ceph/inode.c                                    |   2 +-
 fs/cifs/cifsencrypt.c                              |  16 ++-
 fs/cifs/dir.c                                      |  24 +++-
 fs/cifs/inode.c                                    |   4 +-
 fs/cifs/smb2ops.c                                  |  30 +++-
 fs/ecryptfs/inode.c                                |   2 +-
 fs/exofs/inode.c                                   |   2 +-
 fs/ext2/acl.c                                      |  12 +-
 fs/ext2/inode.c                                    |   2 +-
 fs/ext3/acl.c                                      |  12 +-
 fs/ext3/inode.c                                    |   2 +-
 fs/ext4/acl.c                                      |  12 +-
 fs/ext4/balloc.c                                   |   3 +
 fs/ext4/extents.c                                  |   8 +-
 fs/ext4/inode.c                                    |  37 ++++-
 fs/ext4/mballoc.c                                  |  17 +--
 fs/ext4/super.c                                    |  35 ++++-
 fs/f2fs/acl.c                                      |   6 +-
 fs/f2fs/file.c                                     |   2 +-
 fs/fat/file.c                                      |   2 +-
 fs/fuse/dir.c                                      |   9 +-
 fs/fuse/file.c                                     |  24 ++++
 fs/fuse/fuse_i.h                                   |   2 +-
 fs/fuse/inode.c                                    |   2 +-
 fs/gfs2/acl.c                                      |  12 +-
 fs/gfs2/inode.c                                    |   2 +-
 fs/hfs/inode.c                                     |   2 +-
 fs/hfsplus/inode.c                                 |   2 +-
 fs/hfsplus/posix_acl.c                             |   4 +-
 fs/hostfs/hostfs_kern.c                            |   9 +-
 fs/hpfs/inode.c                                    |   2 +-
 fs/hugetlbfs/inode.c                               |   2 +-
 fs/jffs2/acl.c                                     |   9 +-
 fs/jffs2/fs.c                                      |   2 +-
 fs/jfs/acl.c                                       |   6 +-
 fs/jfs/file.c                                      |   2 +-
 fs/kernfs/file.c                                   |  28 +++-
 fs/kernfs/inode.c                                  |   2 +-
 fs/libfs.c                                         |   2 +-
 fs/logfs/file.c                                    |   2 +-
 fs/minix/file.c                                    |   2 +-
 fs/ncpfs/inode.c                                   |   2 +-
 fs/nfs/callback.c                                  |   1 +
 fs/nfs/callback_xdr.c                              |   6 +-
 fs/nfs/nfs4proc.c                                  |  13 +-
 fs/nfs/write.c                                     |   5 +-
 fs/nfsd/vfs.c                                      |  12 +-
 fs/nilfs2/inode.c                                  |   2 +-
 fs/notify/fanotify/fanotify.c                      |  13 +-
 fs/notify/fanotify/fanotify_user.c                 |  36 +++--
 fs/notify/group.c                                  |  19 +++
 fs/notify/notification.c                           |  23 +--
 fs/ntfs/inode.c                                    |   2 +-
 fs/ocfs2/acl.c                                     |   9 +-
 fs/ocfs2/dlm/dlmconvert.c                          |  12 +-
 fs/ocfs2/dlmfs/dlmfs.c                             |   2 +-
 fs/ocfs2/file.c                                    |  36 +++--
 fs/omfs/file.c                                     |   2 +-
 fs/posix_acl.c                                     |  31 ++++
 fs/proc/base.c                                     |   2 +-
 fs/proc/generic.c                                  |   2 +-
 fs/proc/proc_sysctl.c                              |   2 +-
 fs/ramfs/file-nommu.c                              |   2 +-
 fs/reiserfs/inode.c                                |   2 +-
 fs/reiserfs/xattr_acl.c                            |   8 +-
 fs/seq_file.c                                      |   4 +-
 fs/sysv/file.c                                     |   2 +-
 fs/ubifs/file.c                                    |   2 +-
 fs/ubifs/tnc_commit.c                              |   2 +-
 fs/udf/file.c                                      |   2 +-
 fs/ufs/truncate.c                                  |   2 +-
 fs/utimes.c                                        |   4 +-
 fs/xfs/xfs_acl.c                                   |  16 +--
 fs/xfs/xfs_file.c                                  |   2 +-
 fs/xfs/xfs_ioctl.c                                 |   2 +-
 fs/xfs/xfs_iops.c                                  |  16 ++-
 fs/xfs/xfs_iops.h                                  |   6 +-
 include/asm-generic/uaccess.h                      |  20 ++-
 include/linux/backing-dev.h                        |   2 +
 include/linux/bcma/bcma.h                          |   1 +
 include/linux/can/dev.h                            |   3 +-
 include/linux/compiler-gcc.h                       |   2 +-
 include/linux/efi.h                                |   9 ++
 include/linux/fs.h                                 |   2 +-
 include/linux/fsnotify_backend.h                   |   6 +-
 include/linux/i8042.h                              |   6 -
 include/linux/mlx5/qp.h                            |   4 +-
 include/linux/mroute.h                             |   2 +-
 include/linux/mroute6.h                            |   2 +-
 include/linux/netfilter/x_tables.h                 |   4 +
 include/linux/pagemap.h                            |  38 ++---
 include/linux/posix_acl.h                          |   1 +
 include/linux/radix-tree.h                         |   1 +
 include/linux/serio.h                              |  24 +++-
 include/linux/swap.h                               |   2 +
 include/net/inet_ecn.h                             |   3 +-
 include/net/tcp.h                                  |   2 +
 include/target/target_core_backend.h               |   2 +-
 ipc/msg.c                                          |   2 +-
 ipc/sem.c                                          |  12 +-
 kernel/cpuset.c                                    |  15 ++
 kernel/fork.c                                      |  10 +-
 kernel/module.c                                    |  13 +-
 kernel/posix-cpu-timers.c                          |   1 +
 kernel/power/hibernate.c                           |   4 +-
 kernel/printk/braille.c                            |   4 +-
 kernel/sched/core.c                                |  23 ++-
 kernel/sched/sched.h                               |  13 --
 kernel/time/timekeeping_debug.c                    |   9 +-
 kernel/trace/trace.c                               |  15 +-
 lib/mpi/mpicoder.c                                 |   2 +-
 mm/backing-dev.c                                   |  19 +++
 mm/filemap.c                                       |  93 ++++++------
 mm/hugetlb.c                                       |   4 +
 mm/ksm.c                                           |   3 +-
 mm/shmem.c                                         |   2 +-
 mm/workingset.c                                    |  10 +-
 net/batman-adv/bridge_loop_avoidance.c             | 137 +++++++++++++++---
 net/batman-adv/distributed-arp-table.c             |  10 +-
 net/batman-adv/originator.c                        |  15 ++
 net/batman-adv/routing.c                           |  80 +++++++++--
 net/batman-adv/send.c                              |   4 +-
 net/batman-adv/types.h                             |  20 ++-
 net/bluetooth/l2cap_sock.c                         |   2 +-
 net/bluetooth/rfcomm/sock.c                        |  20 +--
 net/ceph/osdmap.c                                  | 156 +++++++++++++++------
 net/ipv4/ipmr.c                                    |   3 +-
 net/ipv4/netfilter/arp_tables.c                    |  36 +++--
 net/ipv4/netfilter/ip_tables.c                     |  33 ++++-
 net/ipv4/route.c                                   |   3 +-
 net/ipv4/tcp_fastopen.c                            |   1 +
 net/ipv4/tcp_input.c                               |   3 +-
 net/ipv4/tcp_output.c                              |   3 +-
 net/ipv6/addrconf.c                                |   9 ++
 net/ipv6/ip6_gre.c                                 |   2 +-
 net/ipv6/ip6mr.c                                   |   5 +-
 net/ipv6/netfilter/ip6_tables.c                    |  33 ++++-
 net/ipv6/route.c                                   |   4 +-
 net/irda/af_irda.c                                 |  12 +-
 net/l2tp/l2tp_core.c                               |   3 +
 net/l2tp/l2tp_ppp.c                                |   7 +-
 net/mac80211/cfg.c                                 |   2 +-
 net/mac80211/tx.c                                  |   6 +-
 net/netfilter/nf_conntrack_expect.c                |   2 +-
 net/netfilter/nfnetlink_queue_core.c               |   6 +-
 net/netfilter/x_tables.c                           |  50 +++++++
 net/netlabel/netlabel_kapi.c                       |  12 +-
 net/sched/sch_generic.c                            |   9 +-
 net/sunrpc/auth_gss/auth_gss.c                     |   8 +-
 net/sunrpc/svc.c                                   |   7 +-
 net/wireless/nl80211.c                             |   2 +-
 net/xfrm/xfrm_state.c                              |   1 +
 net/xfrm/xfrm_user.c                               |  15 +-
 scripts/recordmcount.c                             |   9 +-
 security/keys/proc.c                               |   2 +-
 sound/core/control.c                               |   2 +
 sound/core/pcm.c                                   |  14 +-
 sound/core/rawmidi.c                               |   4 +-
 sound/core/timer.c                                 |  34 ++++-
 sound/firewire/fireworks/fireworks.h               |   1 -
 sound/firewire/fireworks/fireworks_hwdep.c         |  71 +++++++---
 sound/firewire/fireworks/fireworks_proc.c          |   4 +-
 sound/firewire/fireworks/fireworks_transaction.c   |   5 +-
 sound/pci/hda/hda_codec.c                          |   4 +-
 sound/pci/hda/hda_intel.c                          |   4 +-
 sound/pci/hda/patch_realtek.c                      |   9 ++
 sound/soc/omap/omap-mcpdm.c                        |   5 +-
 tools/vm/slabinfo.c                                |   3 +-
 virt/kvm/kvm_main.c                                |   2 +
 420 files changed, 3506 insertions(+), 1566 deletions(-)

Adrien Vergé (1):
      USB: quirks: Fix another ELAN touchscreen

Al Viro (26):
      alpha: fix copy_from_user()
      asm-generic: make copy_from_user() zero the destination properly
      asm-generic: make get_user() clear the destination on errors
      cris: buggered copy_from_user/copy_to_user/clear_user
      frv: fix clear_user()
      hexagon: fix strncpy_from_user() error return
      ia64: copy_from_user() should zero the destination on access_ok() failure
      metag: copy_from_user() should zero the destination on access_ok() failure
      mips: copy_from_user() must zero the destination on access_ok() failure
      mn10300: failing __get_user() and get_user() should zero
      mn10300: copy_from_user() should zero on access_ok() failure...
      openrisc: fix copy_from_user()
      parisc: fix copy_from_user()
      ppc32: fix copy_from_user()
      s390: get_user() should zero on failure
      score: fix __get_user/get_user
      score: fix copy_from_user() and friends
      sh64: failing __get_user() should zero
      sh: fix copy_from_user()
      sparc32: fix copy_from_user()
      blackfin: fix copy_from_user()
      m32r: fix __get_user()
      microblaze: fix copy_from_user()
      microblaze: fix __get_user()
      avr32: fix copy_from_user()
      fix fault_in_multipages_...() on architectures with no-op access_ok()

Alan Stern (4):
      USB: validate wMaxPacketValue entries in endpoint descriptors
      USB: fix typo in wMaxPacketSize validation
      USB: avoid left shift by -1
      USB: change bInterval default to 10 ms

Aleksandr Makarov (2):
      USB: serial: option: add WeTelecom WM-D200
      USB: serial: option: add WeTelecom 0x6802 and 0x6803 products

Alex Deucher (4):
      drm/radeon: add a delay after ATPX dGPU power off
      drm/radeon: support backlight control for UNIPHY3
      drm/radeon: fix firmware info version checks
      drm/radeon/si/dpm: add workaround for for Jet parts

Alex Hung (1):
      hp-wmi: Fix wifi cannot be hard-unblocked

Alex Vesker (2):
      IB/ipoib: Don&#39;t allow MC joins during light MC flush
      IB/mlx4: Fix incorrect MC join state bit-masking on SR-IOV

Alex Williamson (1):
      vfio/pci: Fix NULL pointer oops in error interrupt setup handling

Alexandre Belloni (1):
      tty/serial: atmel: fix RS485 half duplex with DMA

Alexey Dobriyan (1):
      posix_cpu_timer: Exit early when process has been reaped

Alexey Khoroshilov (3):
      i2c: efm32: fix a failure path in efm32_i2c_probe()
      USB: serial: mos7720: fix non-atomic allocation in write path
      USB: serial: mos7840: fix non-atomic allocation in write path

Alexey Klimov (1):
      USB: serial: fix memleak in driver-registration error path

Alexey Kuznetsov (1):
      fuse: fsync() did not return IO errors

Alison Schofield (1):
      iio: proximity: as3935: set up buffer timestamps for non-zero values

Amadeusz Sławiński (1):
      Bluetooth: Fix l2cap_sock_setsockopt() with optname BT_RCVMTU

Anders Darander (1):
      iio: adc: at91: unbreak channel adc channel 3

Andrey Pronin (1):
      tpm: read burstcount from TPM_STS in one 32-bit transaction

Andrey Ryabinin (1):
      radix-tree: fix radix_tree_iter_retry() for tagged iterators.

Andy Shevchenko (1):
      gpio: intel-mid: Remove potentially harmful code

Ard Biesheuvel (2):
      crypto: cryptd - initialize child shash_desc on import
      crypto: arm64/aes-ctr - fix NULL dereference in tail processing

Arend Van Spriel (1):
      brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()

Artemy Kovalyov (1):
      IB/mlx5: Fix MODIFY_QP command input structure

Ashish Samant (1):
      ocfs2: fix start offset to ocfs2_zero_range_for_truncate()

Balbir Singh (1):
      sched/core: Fix a race between try_to_wake_up() and a woken up task

Ben Hutchings (3):
      module: Invalidate signatures on force-loaded modules
      Documentation/module-signing.txt: Note need for version info if reusing a key
      Linux 3.16.39

Benjamin Coddington (1):
      nfs: don&#39;t create zero-length requests

Cameron Gutman (1):
      Input: xpad - validate USB endpoint count during probe

Chen-Yu Tsai (1):
      clocksource/drivers/sun4i: Clear interrupts after stopping timer in probe function

Chris Blake (1):
      PCI: Mark Atheros AR9485 and QCA9882 to avoid bus reset

Chris Mason (1):
      Btrfs: remove root_log_ctx from ctx list before btrfs_sync_log returns

Christian König (1):
      drm/radeon: fix radeon_move_blit on 32bit systems

Chuck Lever (2):
      svc: Avoid garbage replies when pc_func() returns rpc_drop_reply
      NFS: Don&#39;t drop CB requests with invalid principals

Dan Carpenter (12):
      em28xx-i2c: rt_mutex_trylock() returns zero on failure
      qxl: check for kmap failures
      mtd: pmcmsp-flash: Allocating too much in init_msp_flash()
      crypto: nx - off by one bug in nx_of_update_msc()
      MIPS: RM7000: Double locking bug in rm7k_tc_disable()
      tools/vm/slabinfo: fix an unintentional printf
      sparc: serial: sunhv: fix a double lock bug
      avr32: off by one in at32_init_pio()
      hostfs: Freeing an ERR_PTR in hostfs_fill_sb_common()
      usb: gadget: fsl_qe_udc: off by one in setup_received_handle()
      usb: gadget: fsl_qe_udc: signedness bug in qe_get_frame()
      scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()

Dan Williams (1):
      block: fix bdi vs gendisk lifetime mismatch

Daniel Borkmann (1):
      bpf, mips: fix off-by-one in ctx offset allocation

Daniel Mentz (1):
      ARC: Call trace_hardirqs_on() before enabling irqs

Daniel Vetter (1):
      drm: Reject page_flip for !DRIVER_MODESET

Daniele Palmas (3):
      USB: serial: option: add support for Telit LE910 PID 0x1206
      USB: serial: option: add support for Telit LE920A4
      USB: serial: simple: add support for another Infineon flashloader

Dave Carroll (1):
      aacraid: Check size values after double-fetch from user

Dave Weinstein (1):
      arm: oabi compat: add missing access checks

David Daney (1):
      MIPS: Fix page table corruption on THP permission changes.

David Hildenbrand (1):
      s390/mm: fix gmap tlb flush issues

David Howells (3):
      KEYS: 64-bit MIPS needs to use compat_sys_keyctl for 32-bit userspace
      x86/syscalls/64: Add compat_sys_keyctl for 32-bit userspace
      KEYS: Fix short sprintf buffer in /proc/keys show function

Dmitri Epshtein (1):
      net: mvneta: set real interrupt per packet for tx_done

Dmitry Torokhov (3):
      tty/vt/keyboard: fix OOB access in do_compute_shiftstate()
      Input: i8042 - break load dependency between atkbd/psmouse and i8042
      Input: i8042 - set up shared ps2_cmd_mutex for AUX ports

Dmitry Tunin (1):
      Bluetooth: Add support of 13d3:3490 AR3012 device

Emanuel Czirai (1):
      x86/AMD: Apply erratum 665 on machines without a BIOS fix

Erez Shitrit (2):
      IB/core: Fix use after free in send_leave function
      IB/ipoib: Fix memory corruption in ipoib cm mode connect flow

Eric Biggers (1):
      dm crypt: fix free of bad values after tfm allocation failure

Eric Dumazet (3):
      tcp: fix use after free in tcp_xmit_retransmit_queue()
      qdisc: fix a module refcount leak in qdisc_create_dflt()
      tcp: fix a compile error in DBGUNDO()

Eric Wheeler (1):
      bcache: register_bcache(): call blkdev_put() when cache_alloc() fails

Fabian Frederick (1):
      sysv, ipc: fix security-layer leaking

Fabio Estevam (1):
      can: flexcan: fix resume function

Felipe Balbi (2):
      usb: dwc3: gadget: increment request-&gt;actual once
      usb: gadget: udc: core: don&#39;t starve DMA resources

Felix Fietkau (1):
      mac80211: fix purging multicast PS buffer queue

Feng Li (1):
      iscsi-target: Fix panic when adding second TCP connection to iSCSI session

Florian Fainelli (4):
      net: ethoc: Fix early error paths
      brcmfmac: Fix glob_skb leak in brcmf_sdiod_recv_chain
      brcmsmac: Free packet if dma_mapping_error() fails in dma_rxfill
      brcmsmac: Initialize power in brcms_c_stf_ss_algo_channel_get()

Florian Westphal (2):
      netfilter: x_tables: validate targets of jumps
      netfilter: x_tables: speed up jump target validation

Forrest Liu (1):
      Btrfs: add missing blk_finish_plug in btrfs_sync_log()

Gavin Li (1):
      cdc-acm: fix wrong pipe type on rx interrupt xfers

Gregor Boirie (1):
      iio:core: fix IIO_VAL_FRACTIONAL sign handling

Gregory CLEMENT (1):
      ARM: 8561/3: dma-mapping: Don&#39;t use outer_flush_range when the L2C is coherent

Guenter Roeck (2):
      avr32: fix &#39;undefined reference to `___copy_from_user&#39;
      openrisc: fix the fix of copy_from_user()

Haishuang Yan (1):
      ip6_gre: Set flowi6_proto as IPPROTO_GRE in xmit path.

Hector Palacios (1):
      mtd: nand: fix bug writing 1 byte less than page size

Helge Deller (1):
      parisc: Fix order of EREFUSED define in errno.h

Herbert Xu (4):
      macvlan: Fix potential use-after free for broadcasts
      crypto: gcm - Filter out async ghash if necessary
      crypto: scatterwalk - Fix test in scatterwalk_done
      crypto: skcipher - Fix blkcipher walk OOM crash

Ian Abbott (3):
      staging: comedi: daqboard2000: bug fix board type matching code
      staging: comedi: ni_mio_common: fix AO inttrig backwards compatibility
      staging: comedi: ni_mio_common: fix wrong insn_write handler

Ilan Tayari (1):
      xfrm: Fix memory leak of aead algorithm name

Ilya Dryomov (1):
      libceph: apply new_state before new_up_client on incrementals

Iosif Harutyunov (1):
      ubi: Fix race condition between ubi device creation and udev

Jack Morgenstein (2):
      IB/mlx4: Fix code indentation in QP1 MAD flow
      IB/mlx4: Use correct subnet-prefix in QP1 mads under SR-IOV

Jaganath Kanakkassery (1):
      Bluetooth: Fix potential NULL dereference in RFCOMM bind callback

James Hogan (11):
      tile: Define AT_VECTOR_SIZE_ARCH for ARCH_DLINFO
      MIPS: c-r4k: Fix protected_writeback_scache_line for EVA
      arm64: Define AT_VECTOR_SIZE_ARCH for ARCH_DLINFO
      s390: Define AT_VECTOR_SIZE_ARCH for ARCH_DLINFO
      metag: Fix __cmpxchg_u32 asm constraint for CMP
      MIPS: KVM: Fix mapped fault broken commpage handling
      MIPS: KVM: Add missing gfn range check
      MIPS: KVM: Fix gfn range check in kseg0 tlb faults
      MIPS: KVM: Propagate kseg0/mapped tlb fault errors
      MIPS: KVM: Check for pfn noslot case
      KVM: MIPS: Drop other CPU ASIDs on guest MMU changes

Jan Beulich (2):
      xenbus: don&#39;t BUG() on user mode induced condition
      xenbus: don&#39;t look up transaction IDs for ordinary writes

Jan Kara (6):
      ext4: fix deadlock during page writeback
      fsnotify: add a way to stop queueing events on group shutdown
      fanotify: fix list corruption in fanotify_get_response()
      fs: Give dentry to inode_change_ok() instead of inode
      fs: Avoid premature clearing of capabilities
      posix_acl: Clear SGID bit when setting file permissions

Javier Martinez Canillas (2):
      s5p-mfc: Set device name for reserved memory region devs
      s5p-mfc: Add release callback for memory region devs

Jeff Mahoney (1):
      btrfs: ensure that file descriptor used with subvol ioctls is a dir

Jeffrey Hugo (1):
      efi/libstub: Allocate headspace in efi_get_memory_map()

Jia He (1):
      mm/hugetlb: avoid soft lockup in set_max_huge_pages()

Jim Lin (1):
      usb: xhci: Fix panic if disconnect

Jim Mattson (1):
      KVM: nVMX: Fix memory corruption when using VMCS shadowing

Jimi Damon (1):
      serial: 8250: added acces i/o products quad and octal serial cards

Jiri Slaby (1):
      pps: do not crash when failed to register

Johannes Berg (2):
      ipv6: suppress sparse warnings in IP6_ECN_set_ce()
      nl80211: validate number of probe response CSA counters

Johannes Weiner (2):
      mm: workingset: fix crash in shadow node shrinker caused by replace_page_cache_page()
      mm: filemap: don&#39;t plant shadow entries without radix tree node

John Stultz (1):
      timekeeping: Cap array access in timekeeping_debug

Joseph Qi (1):
      ocfs2/dlm: fix race between convert and migration

Joseph Salisbury (1):
      usb: quirks: Add no-lpm quirk for Elan

Karl Beldan (1):
      mtd: nand: davinci: Reinitialize the HW ECC engine in 4bit hwctl

Keerthy (2):
      ARM: AM43XX: hwmod: Fix RSTST register offset for pruss
      rtc: ds1307: Fix relying on reset value for weekday

Kent Overstreet (1):
      bcache: RESERVE_PRIO is too small by one when prio_buckets() is a power of two.

Konrad Leszczynski (1):
      usb: dwc3: fix for the isoc transfer EP_BUSY flag

Konstantin Neumoin (1):
      balloon: check the number of available pages in leak balloon

Krzysztof Kozlowski (2):
      serial: samsung: Fix ERR pointer dereference on deferred probe
      serial: samsung: Fix possible out of bounds access on non-DT platform

Kweh, Hock Leong (1):
      iio: fix pressure data output unit in hid-sensor-attributes

Lance Richardson (1):
      ip6_gre: fix flowi6_proto value in ip6gre_xmit_other()

Laura Abbott (1):
      ftrace/recordmcount: Work around for addition of metag magic but not relocations

Lauro Costa (1):
      Bluetooth: Add USB ID 13D3:3487 to ath3k

Linus Torvalds (1):
      Using BUG_ON() as an assert() is _never_ acceptable

Linus Walleij (3):
      gpio: Fix OF build problem on UM
      iio: accel: kxsd9: Fix raw read return
      iio: accel: kxsd9: Fix scaling bug

Liping Zhang (2):
      netfilter: nf_ct_expect: remove the redundant slash when policy name is empty
      netfilter: nfnetlink_queue: reject verdict request from different portid

Lu Baolu (1):
      usb: misc: usbtest: add fix for driver hang

Lubomir Rintel (1):
      USB: serial: option: add D-Link DWM-156/A3

Lukas Wunner (6):
      drm/nouveau: Don&#39;t leak runtime pm ref on driver unload
      drm/radeon: Don&#39;t leak runtime pm ref on driver unload
      drm/radeon: Don&#39;t leak runtime pm ref on driver load
      x86/quirks: Apply nvidia_bugs quirk only on root bus
      x86/quirks: Reintroduce scanning of secondary buses
      x86/quirks: Add early quirk to reset Apple AirPort card

Lyude (1):
      drm/radeon: Poll for both connect/disconnect on analog connectors

Mahesh Salgaonkar (2):
      powerpc/powernv: Fix MCE handler to avoid trashing CR0/CR1 registers.
      powerpc/book3s: Fix MCE console messages for unrecoverable MCE.

Mario Kleiner (2):
      drm/edid: Add 6 bpc quirk for display AEO model 0.
      drm/i915/dp: Revert &quot;drm/i915/dp: fall back to 18 bpp when sink capability is unknown&quot;

Masahiro Yamada (1):
      Input: tegra-kbc - fix inverted reset logic

Mathias Krause (1):
      xfrm_user: propagate sec ctx allocation errors

Mathias Nyman (2):
      xhci: always handle &quot;Command Ring Stopped&quot; events
      xhci: don&#39;t dereference a xhci member after removing xhci

Matt Fleming (1):
      perf/x86/amd: Make HW_CACHE_REFERENCES and HW_CACHE_MISSES measure L2

Matt Redfearn (1):
      MIPS: paravirt: Fix undefined reference to smp_bootstrap

Mauricio Faria de Oliveira (1):
      powerpc/pseries: use pci_host_bridge.release_fn() to kfree(phb)

Mauro Carvalho Chehab (1):
      ngene: properly handle __user ptr

Maxim Patlasov (1):
      fuse: fuse_flush must check mapping-&gt;flags for errors

Michael Ellerman (1):
      powerpc/prom: Fix sub-processor option passed to ibm, client-architecture-support

Michael Neuling (1):
      powerpc/tm: Fix stack pointer corruption in __tm_recheckpoint()

Michael Walle (1):
      hwmon: (adt7411) set bit 3 in CFG1 register

Michal Hocko (1):
      kernel/fork: fix CLONE_CHILD_CLEARTID regression in nscd

Mike Christie (1):
      target: Fix max_unmap_lba_count calc overflow

Mike Snitzer (1):
      dm flakey: error READ bios during the down_interval

Mikulas Patocka (1):
      drm/nouveau/fbcon: fix font width not divisible by 8

Mukesh Ojha (1):
      powerpc/powernv : Drop reference added by kset_find_obj()

Neal Cardwell (1):
      tcp: fastopen: fix rcv_wup initialization for TFO server on SYN/data

Nicholas Bellinger (2):
      target: Fix missing complete during ABORT_TASK + CMD_T_FABRIC_STOP
      target: Fix race between iscsi-target connection shutdown + ABORT_TASK

Nicolai Stange (1):
      lib/mpi: mpi_read_raw_data(): fix nbits calculation

Nicolas Dichtel (1):
      ipv6: add missing netconf notif when &#39;all&#39; is updated

Nicolas Iooss (1):
      printk: fix parsing of &quot;brl=&quot; option

Nikolay Aleksandrov (1):
      ipmr, ip6mr: fix scheduling while atomic and a deadlock with ipmr_get_route

Nishanth Menon (1):
      hwrng: omap - Fix assumption that runtime_get_sync will always succeed

Olga Kornievskaia (1):
      SUNRPC: allow for upcalls for same uid but different gss service

Paolo Bonzini (2):
      KVM: nVMX: fix lifetime issues for vmcs02
      compiler-gcc: disable -ftracer for __noclone functions

Paul Blakey (1):
      net/mlx5: Added missing check of msg length in verifying its signature

Paul Burton (1):
      MIPS: Malta: Fix IOCU disable switch read for MIPS64

Paul Moore (1):
      netlabel: add address family checks to netlbl_{sock,req}_delattr()

Pavel Shilovsky (1):
      CIFS: Fix a possible invalid memory access in smb2_query_symlink()

Peter Rosin (1):
      i2c: mux: pca954x: retry updating the mux selection on failure

Peter Ujfalusi (1):
      ASoC: omap-mcpdm: Fix irq resource handling

Peter Wu (4):
      ALSA: hda - fix use-after-free after module unload
      drm/nouveau/acpi: ensure matching ACPI handle and supported functions
      drm/nouveau/acpi: return supported DSM functions
      drm/nouveau/acpi: check for function 0x1B before using it

Phil Turnbull (1):
      ceph: Correctly return NXIO errors from ceph_llseek

Rabin Vincent (1):
      cifs: fix crash due to race in hmac(md5) handling

Radim Krčmář (1):
      KVM: nVMX: postpone VMCS changes on MSR_IA32_APICBASE write

Richard Weinberger (2):
      ubi: Make volume resize power cut aware
      ubi: Be more paranoid while seaching for the most recent Fastmap

Rob Clark (3):
      drm/msm: use mutex_lock_interruptible for submit ioctl
      drm/msm: fix use of copy_from_user() while holding spinlock
      drm/msm: protect against faults from copy_from_user() in submit ioctl

Robert Deliën (1):
      USB: serial: ftdi_sio: add PIDs for Ivium Technologies devices

Roderick Colenbrander (1):
      HID: uhid: fix timeout when probe races with IO

Roger Quadros (1):
      ARM: 8617/1: dma: fix dma_max_pfn()

Russell King (3):
      crypto: caam - fix non-hmac hashes
      ARM: sa1100: clear reset status prior to reboot
      ARM: sa1111: fix pcmcia suspend/resume

Sabrina Dubroca (1):
      l2tp: fix use-after-free during module unload

Sachin Prabhu (1):
      cifs: Check for existing directory when opening file with O_CREAT

Sara Sharon (1):
      iwlwifi: pcie: fix access to scratch buffer

Sebastian Andrzej Siewior (1):
      x86/mm: Disable preemption during CR3 read+write

Sebastian Reichel (1):
      ARM: OMAP3: hwmod data: Add sysc information for DSI

Sergei Miroshnichenko (1):
      can: dev: fix deadlock reported after bus-off

Sheng-Hui J. Chu (1):
      USB: serial: ftdi_sio: add device ID for WICED USB UART dev board

Shrirang Bagul (1):
      ALSA: hda - On-board speaker fixup on ACER Veriton

Simon Baatz (1):
      ARM: kirkwood: ib62x0: fix size of u-boot environment partition

Simon Wunderlich (1):
      batman-adv: lock crc access in bridge loop avoidance

Soeren Moch (1):
      media: dvb_ringbuffer: Add memory barriers

Soheil Hassas Yeganeh (2):
      tcp: consider recv buf for the initial window scale
      tun: fix transmit timestamp support

Srinivas Ramana (1):
      ARM: 8618/1: decompressor: reset ttbcr fields to use TTBR0 on ARMv7

Stefan Haberland (1):
      s390/dasd: fix hanging device after clear subchannel

Stefan Richter (1):
      firewire: net: guard against rx buffer overflows

Stephan Mueller (1):
      random: add interrupt callback to VMBus IRQ handler

Steven Rostedt (1):
      x86/paravirt: Do not trace _paravirt_ident_*() functions

Steven Rostedt (Red Hat) (1):
      tracing: Move mutex to protect against resetting of seq data

Sudeep Holla (1):
      i2c: qup: skip qup_i2c_suspend if the device is already runtime suspended

Suzuki K Poulose (1):
      kvm-arm: Unmap shadow pagetables properly

Suzuki K. Poulose (1):
      arm64: perf: reject groups spanning multiple HW PMUs

Sven Eckelmann (10):
      ath9k: Fix programming of minCCA power threshold
      batman-adv: Avoid nullptr dereference in bla after vlan_insert_tag
      batman-adv: Avoid nullptr dereference in dat after vlan_insert_tag
      batman-adv: Fix orig_node_vlan leak on orig_node_release
      batman-adv: Fix kerneldoc member names in for main structs
      batman-adv: Fix non-atomic bla_claim::backbone_gw access
      batman-adv: Fix reference leak in batadv_find_router
      batman-adv: Free last_bonding_candidate on release of orig_node
      batman-adv: Fix speedy join in gateway client mode
      batman-adv: Add missing refcnt for last_candidate

Sven Van Asbroeck (1):
      power: supply: max17042_battery: fix model download bug.

Takashi Iwai (5):
      ALSA: ctl: Stop notification after disconnection
      ALSA: pcm: Free chmap at PCM free callback, too
      ALSA: hda: Fix krealloc() with __GFP_ZERO usage
      ALSA: timer: Fix zero-division by continue of uninitialized instance
      ALSA: rawmidi: Fix possible deadlock with virmidi registration

Takashi Sakamoto (1):
      ALSA: fireworks: accessing to user space outside spinlock

Taras Kondratiuk (1):
      mmc: block: fix packed command header endianness

Tejun Heo (1):
      kernfs: don&#39;t depend on d_find_any_alias() when generating notifications

Theodore Ts&#39;o (3):
      random: print a warning for the first ten uninitialized random users
      ext4: validate s_reserved_gdt_blocks on mount
      ext4: validate that metadata blocks do not overlap superblock

Thomas Garnier (1):
      PM / hibernate: Restore processor state before using per-CPU variables

Thomas Petazzoni (1):
      ARM: mvebu: fix HW I/O coherency related deadlocks

Trond Myklebust (2):
      NFSv4.x: Fix a refcount leak in nfs_callback_up_net
      NFSv4.1: Fix the CREATE_SESSION slot number accounting

Tyrel Datwyler (1):
      scsi: fix upper bounds check of sense key in scsi_sense_key_string()

Vegard Nossum (11):
      ext4: check for extents that wrap around
      ext4: don&#39;t call ext4_should_journal_data() on the journal inode
      ext4: fix reference counting bug on block allocation error
      ext4: short-cut orphan cleanup on error
      xfrm: fix crash in XFRM_MSG_GETSA netlink handler
      net/irda: fix NULL pointer dereference on memory allocation failure
      block: fix use-after-free in seq file
      fs/seq_file: fix out-of-bounds read
      ALSA: timer: fix division by zero after SNDRV_TIMER_IOCTL_CONTINUE
      ALSA: timer: fix NULL pointer dereference on memory allocation failure
      ALSA: timer: fix NULL pointer dereference in read()/ioctl() race

Vignesh R (2):
      gpio: pca953x: Fix NBANK calculation for PCA9536
      iio: adc: ti_am335x_adc: Protect FIFO1 from concurrent access

Vincent Stehlé (1):
      ubifs: Fix assertion in layout_in_gaps()

Vineet Gupta (2):
      ARC: uaccess: get_user to zero out dest in cause of fault
      ARC: use ASL assembler mnemonic

Vlad Tsyrklevich (1):
      vfio/pci: Fix integer overflows, bitmask check

Vladis Dronov (1):
      usbvision: revert commit 588afcc1

WANG Cong (1):
      ppp: defer netns reference release for ppp channel

Wanpeng Li (2):
      sched/cputime: Fix prev steal time accouting during CPU hotplug
      x86/apic: Do not init irq remapping if ioapic is disabled

Wei Fang (1):
      fuse: fix wrong assignment of -&gt;flags in fuse_send_init()

Wei Yongjun (1):
      ipv6: addrconf: fix dev refcont leak when DAD failed

Will Deacon (2):
      arm64: debug: unmask PSTATE.D earlier
      arm64: spinlocks: implement smp_mb__before_spinlock() as smp_mb()

Xiaolong Ye (1):
      PM / devfreq: Fix incorrect type issue.

Yadi.hu (1):
      i2c-eg20t: fix race between i2c init and interrupt enable

Yan, Zheng (1):
      libceph: set &#39;exists&#39; flag for newly up osd

Yinghai Lu (1):
      megaraid_sas: Fix probing cards without io port

Yoshihiro Shimoda (4):
      usb: renesas_usbhs: fix the sequence in xfer_work()
      usb: renesas_usbhs: fix NULL pointer dereference in xfer_work()
      usb: renesas_usbhs: protect the CFIFOSEL setting in usbhsg_ep_enable()
      usb: renesas_usbhs: fix clearing the {BRDY,BEMP}STS condition

Zefan Li (1):
      cpuset: make sure new tasks conform to the current config of the cpuset

phil.turnbull@oracle.com (2):
      l2tp: Correctly return -EBADF from pppol2tp_getname.
      irda: Free skb on irda_accept error path.

zhong jiang (1):
      mm,ksm: fix endless looping in allocating memory when ksm enable
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/filesystems/porting b/Documentation/filesystems/porting</span>
<span class="p_header">index 0f3a1390bf00..4f65ae209a65 100644</span>
<span class="p_header">--- a/Documentation/filesystems/porting</span>
<span class="p_header">+++ b/Documentation/filesystems/porting</span>
<span class="p_chunk">@@ -287,8 +287,8 @@</span> <span class="p_context"> implementing on-disk size changes.  Start with a copy of the old inode_setattr</span>
 and vmtruncate, and the reorder the vmtruncate + foofs_vmtruncate sequence to
 be in order of zeroing blocks using block_truncate_page or similar helpers,
 size update and on finally on-disk truncation which should not fail.
<span class="p_del">-inode_change_ok now includes the size checks for ATTR_SIZE and must be called</span>
<span class="p_del">-in the beginning of -&gt;setattr unconditionally.</span>
<span class="p_add">+setattr_prepare (which used to be inode_change_ok) now includes the size checks</span>
<span class="p_add">+for ATTR_SIZE and must be called in the beginning of -&gt;setattr unconditionally.</span>
 
 [mandatory]
 
<span class="p_header">diff --git a/Documentation/module-signing.txt b/Documentation/module-signing.txt</span>
<span class="p_header">index 09c2382ad055..e3af8c27eef2 100644</span>
<span class="p_header">--- a/Documentation/module-signing.txt</span>
<span class="p_header">+++ b/Documentation/module-signing.txt</span>
<span class="p_chunk">@@ -239,3 +239,9 @@</span> <span class="p_context"> Since the private key is used to sign modules, viruses and malware could use</span>
 the private key to sign modules and compromise the operating system.  The
 private key must be either destroyed or moved to a secure location and not kept
 in the root node of the kernel source tree.
<span class="p_add">+</span>
<span class="p_add">+If you use the same private key to sign modules for multiple kernel</span>
<span class="p_add">+configurations, you must ensure that the module version information is</span>
<span class="p_add">+sufficient to prevent loading a module into a different kernel.  Either</span>
<span class="p_add">+set CONFIG_MODVERSIONS=y or ensure that each configuration has a different</span>
<span class="p_add">+kernel release string by changing EXTRAVERSION or CONFIG_LOCALVERSION.</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 37083fbc8784..444ddb666ef8 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 38</span>
<span class="p_add">+SUBLEVEL = 39</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_header">diff --git a/arch/alpha/include/asm/uaccess.h b/arch/alpha/include/asm/uaccess.h</span>
<span class="p_header">index 766fdfde2b7a..6e9d27ad5103 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -371,14 +371,6 @@</span> <span class="p_context"> __copy_tofrom_user_nocheck(void *to, const void *from, long len)</span>
 	return __cu_len;
 }
 
<span class="p_del">-extern inline long</span>
<span class="p_del">-__copy_tofrom_user(void *to, const void *from, long len, const void __user *validate)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (__access_ok((unsigned long)validate, len, get_fs()))</span>
<span class="p_del">-		len = __copy_tofrom_user_nocheck(to, from, len);</span>
<span class="p_del">-	return len;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #define __copy_to_user(to,from,n)					\
 ({									\
 	__chk_user_ptr(to);						\
<span class="p_chunk">@@ -393,17 +385,22 @@</span> <span class="p_context"> __copy_tofrom_user(void *to, const void *from, long len, const void __user *vali</span>
 #define __copy_to_user_inatomic __copy_to_user
 #define __copy_from_user_inatomic __copy_from_user
 
<span class="p_del">-</span>
 extern inline long
 copy_to_user(void __user *to, const void *from, long n)
 {
<span class="p_del">-	return __copy_tofrom_user((__force void *)to, from, n, to);</span>
<span class="p_add">+	if (likely(__access_ok((unsigned long)to, n, get_fs())))</span>
<span class="p_add">+		n = __copy_tofrom_user_nocheck((__force void *)to, from, n);</span>
<span class="p_add">+	return n;</span>
 }
 
 extern inline long
 copy_from_user(void *to, const void __user *from, long n)
 {
<span class="p_del">-	return __copy_tofrom_user(to, (__force void *)from, n, from);</span>
<span class="p_add">+	if (likely(__access_ok((unsigned long)from, n, get_fs())))</span>
<span class="p_add">+		n = __copy_tofrom_user_nocheck(to, (__force void *)from, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		memset(to, 0, n);</span>
<span class="p_add">+	return n;</span>
 }
 
 extern void __do_clear_user(void);
<span class="p_header">diff --git a/arch/arc/include/asm/irqflags.h b/arch/arc/include/asm/irqflags.h</span>
<span class="p_header">index cb7efc29f16f..d98d3bd5ecf6 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/irqflags.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/irqflags.h</span>
<span class="p_chunk">@@ -179,10 +179,10 @@</span> <span class="p_context"> static inline void arch_unmask_irq(unsigned int irq)</span>
 .endm
 
 .macro IRQ_ENABLE  scratch
<span class="p_add">+	TRACE_ASM_IRQ_ENABLE</span>
 	lr	\scratch, [status32]
 	or	\scratch, \scratch, (STATUS_E1_MASK | STATUS_E2_MASK)
 	flag	\scratch
<span class="p_del">-	TRACE_ASM_IRQ_ENABLE</span>
 .endm
 
 #endif	/* __ASSEMBLY__ */
<span class="p_header">diff --git a/arch/arc/include/asm/uaccess.h b/arch/arc/include/asm/uaccess.h</span>
<span class="p_header">index 30c9baffa96f..08770c750696 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -83,7 +83,10 @@</span> <span class="p_context"></span>
 	&quot;2:	;nop\n&quot;				\
 	&quot;	.section .fixup, \&quot;ax\&quot;\n&quot;	\
 	&quot;	.align 4\n&quot;			\
<span class="p_del">-	&quot;3:	mov %0, %3\n&quot;			\</span>
<span class="p_add">+	&quot;3:	# return -EFAULT\n&quot;		\</span>
<span class="p_add">+	&quot;	mov %0, %3\n&quot;			\</span>
<span class="p_add">+	&quot;	# zero out dst ptr\n&quot;		\</span>
<span class="p_add">+	&quot;	mov %1,  0\n&quot;			\</span>
 	&quot;	j   2b\n&quot;			\
 	&quot;	.previous\n&quot;			\
 	&quot;	.section __ex_table, \&quot;a\&quot;\n&quot;	\
<span class="p_chunk">@@ -101,7 +104,11 @@</span> <span class="p_context"></span>
 	&quot;2:	;nop\n&quot;				\
 	&quot;	.section .fixup, \&quot;ax\&quot;\n&quot;	\
 	&quot;	.align 4\n&quot;			\
<span class="p_del">-	&quot;3:	mov %0, %3\n&quot;			\</span>
<span class="p_add">+	&quot;3:	# return -EFAULT\n&quot;		\</span>
<span class="p_add">+	&quot;	mov %0, %3\n&quot;			\</span>
<span class="p_add">+	&quot;	# zero out dst ptr\n&quot;		\</span>
<span class="p_add">+	&quot;	mov %1,  0\n&quot;			\</span>
<span class="p_add">+	&quot;	mov %R1, 0\n&quot;			\</span>
 	&quot;	j   2b\n&quot;			\
 	&quot;	.previous\n&quot;			\
 	&quot;	.section __ex_table, \&quot;a\&quot;\n&quot;	\
<span class="p_header">diff --git a/arch/arc/mm/tlbex.S b/arch/arc/mm/tlbex.S</span>
<span class="p_header">index 79bfc81358c9..41043f204fa4 100644</span>
<span class="p_header">--- a/arch/arc/mm/tlbex.S</span>
<span class="p_header">+++ b/arch/arc/mm/tlbex.S</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> ex_saved_reg1:</span>
 #ifdef CONFIG_SMP
 	sr  r0, [ARC_REG_SCRATCH_DATA0]	; freeup r0 to code with
 	GET_CPU_ID  r0			; get to per cpu scratch mem,
<span class="p_del">-	lsl r0, r0, L1_CACHE_SHIFT	; cache line wide per cpu</span>
<span class="p_add">+	asl r0, r0, L1_CACHE_SHIFT	; cache line wide per cpu</span>
 	add r0, @ex_saved_reg1, r0
 #else
 	st    r0, [@ex_saved_reg1]
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> ex_saved_reg1:</span>
 .macro TLBMISS_RESTORE_REGS
 #ifdef CONFIG_SMP
 	GET_CPU_ID  r0			; get to per cpu scratch mem
<span class="p_del">-	lsl r0, r0, L1_CACHE_SHIFT	; each is cache line wide</span>
<span class="p_add">+	asl r0, r0, L1_CACHE_SHIFT	; each is cache line wide</span>
 	add r0, @ex_saved_reg1, r0
 	ld_s  r3, [r0,12]
 	ld_s  r2, [r0, 8]
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> ex_saved_reg1:</span>
 
 .macro CONV_PTE_TO_TLB
 	and    r3, r0, PTE_BITS_RWX	;       r w x
<span class="p_del">-	lsl    r2, r3, 3		; r w x 0 0 0</span>
<span class="p_add">+	asl    r2, r3, 3		; r w x 0 0 0</span>
 	and.f  0,  r0, _PAGE_GLOBAL
 	or.z   r2, r2, r3		; r w x r w x
 
<span class="p_header">diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S</span>
<span class="p_header">index d35692b63cfd..624bd3ea0adf 100644</span>
<span class="p_header">--- a/arch/arm/boot/compressed/head.S</span>
<span class="p_header">+++ b/arch/arm/boot/compressed/head.S</span>
<span class="p_chunk">@@ -726,7 +726,7 @@</span> <span class="p_context"> __armv7_mmu_cache_on:</span>
 		orrne	r0, r0, #1		@ MMU enabled
 		movne	r1, #0xfffffffd		@ domain 0 = client
 		bic     r6, r6, #1 &lt;&lt; 31        @ 32-bit translation system
<span class="p_del">-		bic     r6, r6, #3 &lt;&lt; 0         @ use only ttbr0</span>
<span class="p_add">+		bic     r6, r6, #(7 &lt;&lt; 0) | (1 &lt;&lt; 4)	@ use only ttbr0</span>
 		mcrne	p15, 0, r3, c2, c0, 0	@ load page table pointer
 		mcrne	p15, 0, r1, c3, c0, 0	@ load domain access control
 		mcrne   p15, 0, r6, c2, c0, 2   @ load ttb control
<span class="p_header">diff --git a/arch/arm/boot/dts/kirkwood-ib62x0.dts b/arch/arm/boot/dts/kirkwood-ib62x0.dts</span>
<span class="p_header">index bfa5edde179c..2c1e7f09205f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/kirkwood-ib62x0.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/kirkwood-ib62x0.dts</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"></span>
 
 	partition@e0000 {
 		label = &quot;u-boot environment&quot;;
<span class="p_del">-		reg = &lt;0xe0000 0x100000&gt;;</span>
<span class="p_add">+		reg = &lt;0xe0000 0x20000&gt;;</span>
 	};
 
 	partition@100000 {
<span class="p_header">diff --git a/arch/arm/common/sa1111.c b/arch/arm/common/sa1111.c</span>
<span class="p_header">index e57d7e5bf96a..932125a20877 100644</span>
<span class="p_header">--- a/arch/arm/common/sa1111.c</span>
<span class="p_header">+++ b/arch/arm/common/sa1111.c</span>
<span class="p_chunk">@@ -872,9 +872,9 @@</span> <span class="p_context"> struct sa1111_save_data {</span>
 
 #ifdef CONFIG_PM
 
<span class="p_del">-static int sa1111_suspend(struct platform_device *dev, pm_message_t state)</span>
<span class="p_add">+static int sa1111_suspend_noirq(struct device *dev)</span>
 {
<span class="p_del">-	struct sa1111 *sachip = platform_get_drvdata(dev);</span>
<span class="p_add">+	struct sa1111 *sachip = dev_get_drvdata(dev);</span>
 	struct sa1111_save_data *save;
 	unsigned long flags;
 	unsigned int val;
<span class="p_chunk">@@ -937,9 +937,9 @@</span> <span class="p_context"> static int sa1111_suspend(struct platform_device *dev, pm_message_t state)</span>
  *	restored by their respective drivers, and must be called
  *	via LDM after this function.
  */
<span class="p_del">-static int sa1111_resume(struct platform_device *dev)</span>
<span class="p_add">+static int sa1111_resume_noirq(struct device *dev)</span>
 {
<span class="p_del">-	struct sa1111 *sachip = platform_get_drvdata(dev);</span>
<span class="p_add">+	struct sa1111 *sachip = dev_get_drvdata(dev);</span>
 	struct sa1111_save_data *save;
 	unsigned long flags, id;
 	void __iomem *base;
<span class="p_chunk">@@ -955,7 +955,7 @@</span> <span class="p_context"> static int sa1111_resume(struct platform_device *dev)</span>
 	id = sa1111_readl(sachip-&gt;base + SA1111_SKID);
 	if ((id &amp; SKID_ID_MASK) != SKID_SA1111_ID) {
 		__sa1111_remove(sachip);
<span class="p_del">-		platform_set_drvdata(dev, NULL);</span>
<span class="p_add">+		dev_set_drvdata(dev, NULL);</span>
 		kfree(save);
 		return 0;
 	}
<span class="p_chunk">@@ -1006,8 +1006,8 @@</span> <span class="p_context"> static int sa1111_resume(struct platform_device *dev)</span>
 }
 
 #else
<span class="p_del">-#define sa1111_suspend NULL</span>
<span class="p_del">-#define sa1111_resume  NULL</span>
<span class="p_add">+#define sa1111_suspend_noirq NULL</span>
<span class="p_add">+#define sa1111_resume_noirq  NULL</span>
 #endif
 
 static int sa1111_probe(struct platform_device *pdev)
<span class="p_chunk">@@ -1041,6 +1041,11 @@</span> <span class="p_context"> static int sa1111_remove(struct platform_device *pdev)</span>
 	return 0;
 }
 
<span class="p_add">+static struct dev_pm_ops sa1111_pm_ops = {</span>
<span class="p_add">+	.suspend_noirq = sa1111_suspend_noirq,</span>
<span class="p_add">+	.resume_noirq = sa1111_resume_noirq,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  *	Not sure if this should be on the system bus or not yet.
  *	We really want some way to register a system device at
<span class="p_chunk">@@ -1053,11 +1058,10 @@</span> <span class="p_context"> static int sa1111_remove(struct platform_device *pdev)</span>
 static struct platform_driver sa1111_device_driver = {
 	.probe		= sa1111_probe,
 	.remove		= sa1111_remove,
<span class="p_del">-	.suspend	= sa1111_suspend,</span>
<span class="p_del">-	.resume		= sa1111_resume,</span>
 	.driver		= {
 		.name	= &quot;sa1111&quot;,
 		.owner	= THIS_MODULE,
<span class="p_add">+		.pm	= &amp;sa1111_pm_ops,</span>
 	},
 };
 
<span class="p_header">diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_header">index c45b61a4b4a5..911dcd456123 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static inline dma_addr_t virt_to_dma(struct device *dev, void *addr)</span>
 /* The ARM override for dma_max_pfn() */
 static inline unsigned long dma_max_pfn(struct device *dev)
 {
<span class="p_del">-	return PHYS_PFN_OFFSET + dma_to_pfn(dev, *dev-&gt;dma_mask);</span>
<span class="p_add">+	return dma_to_pfn(dev, *dev-&gt;dma_mask);</span>
 }
 #define dma_max_pfn(dev) dma_max_pfn(dev)
 
<span class="p_header">diff --git a/arch/arm/kernel/sys_oabi-compat.c b/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_header">index eb821e7b80f9..8a1c2c8a1a64 100644</span>
<span class="p_header">--- a/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_header">+++ b/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_chunk">@@ -279,8 +279,12 @@</span> <span class="p_context"> asmlinkage long sys_oabi_epoll_wait(int epfd,</span>
 	mm_segment_t fs;
 	long ret, err, i;
 
<span class="p_del">-	if (maxevents &lt;= 0 || maxevents &gt; (INT_MAX/sizeof(struct epoll_event)))</span>
<span class="p_add">+	if (maxevents &lt;= 0 ||</span>
<span class="p_add">+			maxevents &gt; (INT_MAX/sizeof(*kbuf)) ||</span>
<span class="p_add">+			maxevents &gt; (INT_MAX/sizeof(*events)))</span>
 		return -EINVAL;
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, events, sizeof(*events) * maxevents))</span>
<span class="p_add">+		return -EFAULT;</span>
 	kbuf = kmalloc(sizeof(*kbuf) * maxevents, GFP_KERNEL);
 	if (!kbuf)
 		return -ENOMEM;
<span class="p_chunk">@@ -317,6 +321,8 @@</span> <span class="p_context"> asmlinkage long sys_oabi_semtimedop(int semid,</span>
 
 	if (nsops &lt; 1 || nsops &gt; SEMOPM)
 		return -EINVAL;
<span class="p_add">+	if (!access_ok(VERIFY_READ, tsops, sizeof(*tsops) * nsops))</span>
<span class="p_add">+		return -EFAULT;</span>
 	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
 	if (!sops)
 		return -ENOMEM;
<span class="p_header">diff --git a/arch/arm/kvm/arm.c b/arch/arm/kvm/arm.c</span>
<span class="p_header">index 499b236873d2..d75c6e3ed78c 100644</span>
<span class="p_header">--- a/arch/arm/kvm/arm.c</span>
<span class="p_header">+++ b/arch/arm/kvm/arm.c</span>
<span class="p_chunk">@@ -164,8 +164,6 @@</span> <span class="p_context"> void kvm_arch_destroy_vm(struct kvm *kvm)</span>
 {
 	int i;
 
<span class="p_del">-	kvm_free_stage2_pgd(kvm);</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; KVM_MAX_VCPUS; ++i) {
 		if (kvm-&gt;vcpus[i]) {
 			kvm_arch_vcpu_free(kvm-&gt;vcpus[i]);
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index c61da3e6a629..1c89e49a2467 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -1257,6 +1257,7 @@</span> <span class="p_context"> void kvm_arch_memslots_updated(struct kvm *kvm)</span>
 
 void kvm_arch_flush_shadow_all(struct kvm *kvm)
 {
<span class="p_add">+	kvm_free_stage2_pgd(kvm);</span>
 }
 
 void kvm_arch_flush_shadow_memslot(struct kvm *kvm,
<span class="p_header">diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c</span>
<span class="p_header">index 01efe130912e..9e5c29df91f5 100644</span>
<span class="p_header">--- a/arch/arm/mach-mvebu/coherency.c</span>
<span class="p_header">+++ b/arch/arm/mach-mvebu/coherency.c</span>
<span class="p_chunk">@@ -315,22 +315,16 @@</span> <span class="p_context"> static void __init armada_370_coherency_init(struct device_node *np)</span>
 }
 
 /*
<span class="p_del">- * This ioremap hook is used on Armada 375/38x to ensure that PCIe</span>
<span class="p_del">- * memory areas are mapped as MT_UNCACHED instead of MT_DEVICE. This</span>
<span class="p_del">- * is needed as a workaround for a deadlock issue between the PCIe</span>
<span class="p_del">- * interface and the cache controller.</span>
<span class="p_add">+ * This ioremap hook is used on Armada 375/38x to ensure that all MMIO</span>
<span class="p_add">+ * areas are mapped as MT_UNCACHED instead of MT_DEVICE. This is</span>
<span class="p_add">+ * needed for the HW I/O coherency mechanism to work properly without</span>
<span class="p_add">+ * deadlock.</span>
  */
 static void __iomem *
<span class="p_del">-armada_pcie_wa_ioremap_caller(phys_addr_t phys_addr, size_t size,</span>
<span class="p_del">-			      unsigned int mtype, void *caller)</span>
<span class="p_add">+armada_wa_ioremap_caller(phys_addr_t phys_addr, size_t size,</span>
<span class="p_add">+			 unsigned int mtype, void *caller)</span>
 {
<span class="p_del">-	struct resource pcie_mem;</span>
<span class="p_del">-</span>
<span class="p_del">-	mvebu_mbus_get_pcie_mem_aperture(&amp;pcie_mem);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pcie_mem.start &lt;= phys_addr &amp;&amp; (phys_addr + size) &lt;= pcie_mem.end)</span>
<span class="p_del">-		mtype = MT_UNCACHED;</span>
<span class="p_del">-</span>
<span class="p_add">+	mtype = MT_UNCACHED;</span>
 	return __arm_ioremap_caller(phys_addr, size, mtype, caller);
 }
 
<span class="p_chunk">@@ -339,7 +333,7 @@</span> <span class="p_context"> static void __init armada_375_380_coherency_init(struct device_node *np)</span>
 	struct device_node *cache_dn;
 
 	coherency_cpu_base = of_iomap(np, 0);
<span class="p_del">-	arch_ioremap_caller = armada_pcie_wa_ioremap_caller;</span>
<span class="p_add">+	arch_ioremap_caller = armada_wa_ioremap_caller;</span>
 
 	/*
 	 * We should switch the PL310 to I/O coherency mode only if
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c</span>
<span class="p_header">index a579b89ce9b7..b08605cc93ff 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c</span>
<span class="p_chunk">@@ -1460,6 +1460,7 @@</span> <span class="p_context"> static void omap_hwmod_am43xx_rst(void)</span>
 {
 	RSTCTRL(am33xx_pruss_hwmod, AM43XX_RM_PER_RSTCTRL_OFFSET);
 	RSTCTRL(am33xx_gfx_hwmod, AM43XX_RM_GFX_RSTCTRL_OFFSET);
<span class="p_add">+	RSTST(am33xx_pruss_hwmod, AM43XX_RM_PER_RSTST_OFFSET);</span>
 	RSTST(am33xx_gfx_hwmod, AM43XX_RM_GFX_RSTST_OFFSET);
 }
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c b/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_header">index 1cd0cfdc03e0..3ec3ed945221 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_chunk">@@ -724,8 +724,20 @@</span> <span class="p_context"> static struct omap_hwmod omap3xxx_dss_dispc_hwmod = {</span>
  * display serial interface controller
  */
 
<span class="p_add">+static struct omap_hwmod_class_sysconfig omap3xxx_dsi_sysc = {</span>
<span class="p_add">+	.rev_offs	= 0x0000,</span>
<span class="p_add">+	.sysc_offs	= 0x0010,</span>
<span class="p_add">+	.syss_offs	= 0x0014,</span>
<span class="p_add">+	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_CLOCKACTIVITY |</span>
<span class="p_add">+			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |</span>
<span class="p_add">+			   SYSC_HAS_SOFTRESET | SYSS_HAS_RESET_STATUS),</span>
<span class="p_add">+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),</span>
<span class="p_add">+	.sysc_fields	= &amp;omap_hwmod_sysc_type1,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static struct omap_hwmod_class omap3xxx_dsi_hwmod_class = {
 	.name = &quot;dsi&quot;,
<span class="p_add">+	.sysc	= &amp;omap3xxx_dsi_sysc,</span>
 };
 
 static struct omap_hwmod_irq_info omap3xxx_dsi1_irqs[] = {
<span class="p_header">diff --git a/arch/arm/mach-omap2/prcm43xx.h b/arch/arm/mach-omap2/prcm43xx.h</span>
<span class="p_header">index 7785be984edd..4c60d3464a87 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/prcm43xx.h</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/prcm43xx.h</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"></span>
 
 /* RM RSTST offsets */
 #define AM43XX_RM_GFX_RSTST_OFFSET			0x0014
<span class="p_add">+#define AM43XX_RM_PER_RSTST_OFFSET			0x0014</span>
 #define AM43XX_RM_WKUP_RSTST_OFFSET			0x0014
 
 /* CM instances */
<span class="p_header">diff --git a/arch/arm/mach-sa1100/generic.c b/arch/arm/mach-sa1100/generic.c</span>
<span class="p_header">index d4ea142c4edd..186e3f8729ef 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/generic.c</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/generic.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 
 #include &lt;mach/hardware.h&gt;
 #include &lt;mach/irqs.h&gt;
<span class="p_add">+#include &lt;mach/reset.h&gt;</span>
 
 #include &quot;generic.h&quot;
 
<span class="p_chunk">@@ -91,6 +92,8 @@</span> <span class="p_context"> static void sa1100_power_off(void)</span>
 
 void sa11x0_restart(enum reboot_mode mode, const char *cmd)
 {
<span class="p_add">+	clear_reset_status(RESET_STATUS_ALL);</span>
<span class="p_add">+</span>
 	if (mode == REBOOT_SOFT) {
 		/* Jump into ROM at address 0 */
 		soft_restart(0);
<span class="p_header">diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">index 832b295eb4a5..f0fbd97fdfba 100644</span>
<span class="p_header">--- a/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -39,6 +39,9 @@</span> <span class="p_context"></span>
 
 #include &quot;mm.h&quot;
 
<span class="p_add">+#define NORMAL	    0</span>
<span class="p_add">+#define COHERENT    1</span>
<span class="p_add">+</span>
 /*
  * The DMA API is built upon the notion of &quot;buffer ownership&quot;.  A buffer
  * is either exclusively owned by the CPU (and therefore may be accessed
<span class="p_chunk">@@ -219,7 +222,7 @@</span> <span class="p_context"> static u64 get_coherent_dma_mask(struct device *dev)</span>
 	return mask;
 }
 
<span class="p_del">-static void __dma_clear_buffer(struct page *page, size_t size)</span>
<span class="p_add">+static void __dma_clear_buffer(struct page *page, size_t size, int coherent_flag)</span>
 {
 	/*
 	 * Ensure that the allocated pages are zeroed, and that any data
<span class="p_chunk">@@ -231,17 +234,21 @@</span> <span class="p_context"> static void __dma_clear_buffer(struct page *page, size_t size)</span>
 		while (size &gt; 0) {
 			void *ptr = kmap_atomic(page);
 			memset(ptr, 0, PAGE_SIZE);
<span class="p_del">-			dmac_flush_range(ptr, ptr + PAGE_SIZE);</span>
<span class="p_add">+			if (coherent_flag != COHERENT)</span>
<span class="p_add">+				dmac_flush_range(ptr, ptr + PAGE_SIZE);</span>
 			kunmap_atomic(ptr);
 			page++;
 			size -= PAGE_SIZE;
 		}
<span class="p_del">-		outer_flush_range(base, end);</span>
<span class="p_add">+		if (coherent_flag != COHERENT)</span>
<span class="p_add">+			outer_flush_range(base, end);</span>
 	} else {
 		void *ptr = page_address(page);
 		memset(ptr, 0, size);
<span class="p_del">-		dmac_flush_range(ptr, ptr + size);</span>
<span class="p_del">-		outer_flush_range(__pa(ptr), __pa(ptr) + size);</span>
<span class="p_add">+		if (coherent_flag != COHERENT) {</span>
<span class="p_add">+			dmac_flush_range(ptr, ptr + size);</span>
<span class="p_add">+			outer_flush_range(__pa(ptr), __pa(ptr) + size);</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -249,7 +256,8 @@</span> <span class="p_context"> static void __dma_clear_buffer(struct page *page, size_t size)</span>
  * Allocate a DMA buffer for &#39;dev&#39; of size &#39;size&#39; using the
  * specified gfp mask.  Note that &#39;size&#39; must be page aligned.
  */
<span class="p_del">-static struct page *__dma_alloc_buffer(struct device *dev, size_t size, gfp_t gfp)</span>
<span class="p_add">+static struct page *__dma_alloc_buffer(struct device *dev, size_t size,</span>
<span class="p_add">+				       gfp_t gfp, int coherent_flag)</span>
 {
 	unsigned long order = get_order(size);
 	struct page *page, *p, *e;
<span class="p_chunk">@@ -265,7 +273,7 @@</span> <span class="p_context"> static struct page *__dma_alloc_buffer(struct device *dev, size_t size, gfp_t gf</span>
 	for (p = page + (size &gt;&gt; PAGE_SHIFT), e = page + (1 &lt;&lt; order); p &lt; e; p++)
 		__free_page(p);
 
<span class="p_del">-	__dma_clear_buffer(page, size);</span>
<span class="p_add">+	__dma_clear_buffer(page, size, coherent_flag);</span>
 
 	return page;
 }
<span class="p_chunk">@@ -287,7 +295,7 @@</span> <span class="p_context"> static void __dma_free_buffer(struct page *page, size_t size)</span>
 
 static void *__alloc_from_contiguous(struct device *dev, size_t size,
 				     pgprot_t prot, struct page **ret_page,
<span class="p_del">-				     const void *caller);</span>
<span class="p_add">+				     const void *caller, int coherent_flag);</span>
 
 static void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,
 				 pgprot_t prot, struct page **ret_page,
<span class="p_chunk">@@ -389,10 +397,13 @@</span> <span class="p_context"> static int __init atomic_pool_init(void)</span>
 	pages = kzalloc(nr_pages * sizeof(struct page *), GFP_KERNEL);
 	if (!pages)
 		goto no_pages;
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The atomic pool is only used for non-coherent allocations</span>
<span class="p_add">+	 * so we must pass NORMAL for coherent_flag.</span>
<span class="p_add">+	 */</span>
 	if (dev_get_cma_area(NULL))
 		ptr = __alloc_from_contiguous(NULL, pool-&gt;size, prot, &amp;page,
<span class="p_del">-					      atomic_pool_init);</span>
<span class="p_add">+					      atomic_pool_init, NORMAL);</span>
 	else
 		ptr = __alloc_remap_buffer(NULL, pool-&gt;size, gfp, prot, &amp;page,
 					   atomic_pool_init);
<span class="p_chunk">@@ -505,7 +516,11 @@</span> <span class="p_context"> static void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,</span>
 {
 	struct page *page;
 	void *ptr;
<span class="p_del">-	page = __dma_alloc_buffer(dev, size, gfp);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * __alloc_remap_buffer is only called when the device is</span>
<span class="p_add">+	 * non-coherent</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	page = __dma_alloc_buffer(dev, size, gfp, NORMAL);</span>
 	if (!page)
 		return NULL;
 
<span class="p_chunk">@@ -597,7 +612,7 @@</span> <span class="p_context"> static int __free_from_pool(void *start, size_t size)</span>
 
 static void *__alloc_from_contiguous(struct device *dev, size_t size,
 				     pgprot_t prot, struct page **ret_page,
<span class="p_del">-				     const void *caller)</span>
<span class="p_add">+				     const void *caller, int coherent_flag)</span>
 {
 	unsigned long order = get_order(size);
 	size_t count = size &gt;&gt; PAGE_SHIFT;
<span class="p_chunk">@@ -608,7 +623,7 @@</span> <span class="p_context"> static void *__alloc_from_contiguous(struct device *dev, size_t size,</span>
 	if (!page)
 		return NULL;
 
<span class="p_del">-	__dma_clear_buffer(page, size);</span>
<span class="p_add">+	__dma_clear_buffer(page, size, coherent_flag);</span>
 
 	if (PageHighMem(page)) {
 		ptr = __dma_alloc_remap(page, size, GFP_KERNEL, prot, caller);
<span class="p_chunk">@@ -651,7 +666,7 @@</span> <span class="p_context"> static inline pgprot_t __get_dma_pgprot(struct dma_attrs *attrs, pgprot_t prot)</span>
 #define __get_dma_pgprot(attrs, prot)	__pgprot(0)
 #define __alloc_remap_buffer(dev, size, gfp, prot, ret, c)	NULL
 #define __alloc_from_pool(size, ret_page)			NULL
<span class="p_del">-#define __alloc_from_contiguous(dev, size, prot, ret, c)	NULL</span>
<span class="p_add">+#define __alloc_from_contiguous(dev, size, prot, ret, c, coherent_flag)	NULL</span>
 #define __free_from_pool(cpu_addr, size)			0
 #define __free_from_contiguous(dev, page, cpu_addr, size)	do { } while (0)
 #define __dma_free_remap(cpu_addr, size)			do { } while (0)
<span class="p_chunk">@@ -662,7 +677,8 @@</span> <span class="p_context"> static void *__alloc_simple_buffer(struct device *dev, size_t size, gfp_t gfp,</span>
 				   struct page **ret_page)
 {
 	struct page *page;
<span class="p_del">-	page = __dma_alloc_buffer(dev, size, gfp);</span>
<span class="p_add">+	/* __alloc_simple_buffer is only called when the device is coherent */</span>
<span class="p_add">+	page = __dma_alloc_buffer(dev, size, gfp, COHERENT);</span>
 	if (!page)
 		return NULL;
 
<span class="p_chunk">@@ -713,7 +729,8 @@</span> <span class="p_context"> static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,</span>
 	else if (!dev_get_cma_area(dev))
 		addr = __alloc_remap_buffer(dev, size, gfp, prot, &amp;page, caller);
 	else
<span class="p_del">-		addr = __alloc_from_contiguous(dev, size, prot, &amp;page, caller);</span>
<span class="p_add">+		addr = __alloc_from_contiguous(dev, size, prot, &amp;page, caller,</span>
<span class="p_add">+					       NORMAL);</span>
 
 	if (addr)
 		*handle = pfn_to_dma(dev, page_to_pfn(page));
<span class="p_chunk">@@ -1172,7 +1189,8 @@</span> <span class="p_context"> static inline void __free_iova(struct dma_iommu_mapping *mapping,</span>
 }
 
 static struct page **__iommu_alloc_buffer(struct device *dev, size_t size,
<span class="p_del">-					  gfp_t gfp, struct dma_attrs *attrs)</span>
<span class="p_add">+					  gfp_t gfp, struct dma_attrs *attrs,</span>
<span class="p_add">+					  int coherent_flag)</span>
 {
 	struct page **pages;
 	int count = size &gt;&gt; PAGE_SHIFT;
<span class="p_chunk">@@ -1195,7 +1213,7 @@</span> <span class="p_context"> static struct page **__iommu_alloc_buffer(struct device *dev, size_t size,</span>
 		if (!page)
 			goto error;
 
<span class="p_del">-		__dma_clear_buffer(page, size);</span>
<span class="p_add">+		__dma_clear_buffer(page, size, coherent_flag);</span>
 
 		for (i = 0; i &lt; count; i++)
 			pages[i] = page + i;
<span class="p_chunk">@@ -1224,7 +1242,7 @@</span> <span class="p_context"> static struct page **__iommu_alloc_buffer(struct device *dev, size_t size,</span>
 				pages[i + j] = pages[i] + j;
 		}
 
<span class="p_del">-		__dma_clear_buffer(pages[i], PAGE_SIZE &lt;&lt; order);</span>
<span class="p_add">+		__dma_clear_buffer(pages[i], PAGE_SIZE &lt;&lt; order, coherent_flag);</span>
 		i += 1 &lt;&lt; order;
 		count -= 1 &lt;&lt; order;
 	}
<span class="p_chunk">@@ -1427,7 +1445,8 @@</span> <span class="p_context"> static void *arm_iommu_alloc_attrs(struct device *dev, size_t size,</span>
 	 */
 	gfp &amp;= ~(__GFP_COMP);
 
<span class="p_del">-	pages = __iommu_alloc_buffer(dev, size, gfp, attrs);</span>
<span class="p_add">+	/* For now always consider we are in a non-coherent case */</span>
<span class="p_add">+	pages = __iommu_alloc_buffer(dev, size, gfp, attrs, NORMAL);</span>
 	if (!pages)
 		return NULL;
 
<span class="p_header">diff --git a/arch/arm64/crypto/aes-glue.c b/arch/arm64/crypto/aes-glue.c</span>
<span class="p_header">index 5f63a791b2fb..31d014f01574 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-glue.c</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-glue.c</span>
<span class="p_chunk">@@ -205,7 +205,7 @@</span> <span class="p_context"> static int ctr_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,</span>
 		err = blkcipher_walk_done(desc, &amp;walk,
 					  walk.nbytes % AES_BLOCK_SIZE);
 	}
<span class="p_del">-	if (nbytes) {</span>
<span class="p_add">+	if (walk.nbytes % AES_BLOCK_SIZE) {</span>
 		u8 *tdst = walk.dst.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 *tsrc = walk.src.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 __aligned(8) tail[AES_BLOCK_SIZE];
<span class="p_header">diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h</span>
<span class="p_header">index 2009daf52bf1..922ff638669e 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/elf.h</span>
<span class="p_chunk">@@ -137,6 +137,7 @@</span> <span class="p_context"> extern unsigned long randomize_et_dyn(unsigned long base);</span>
 
 #define SET_PERSONALITY(ex)		clear_thread_flag(TIF_32BIT);
 
<span class="p_add">+/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
 #define ARCH_DLINFO							\
 do {									\
 	NEW_AUX_ENT(AT_SYSINFO_EHDR,					\
<span class="p_header">diff --git a/arch/arm64/include/asm/spinlock.h b/arch/arm64/include/asm/spinlock.h</span>
<span class="p_header">index c45b7b1b7197..3c0bb9b303e8 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/spinlock.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/spinlock.h</span>
<span class="p_chunk">@@ -231,4 +231,14 @@</span> <span class="p_context"> static inline int arch_read_trylock(arch_rwlock_t *rw)</span>
 #define arch_read_relax(lock)	cpu_relax()
 #define arch_write_relax(lock)	cpu_relax()
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Accesses appearing in program order before a spin_lock() operation</span>
<span class="p_add">+ * can be reordered with accesses inside the critical section, by virtue</span>
<span class="p_add">+ * of arch_spin_lock being constructed using acquire semantics.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In cases where this is problematic (e.g. try_to_wake_up), an</span>
<span class="p_add">+ * smp_mb__before_spinlock() can restore the required ordering.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define smp_mb__before_spinlock()	smp_mb()</span>
<span class="p_add">+</span>
 #endif /* __ASM_SPINLOCK_H */
<span class="p_header">diff --git a/arch/arm64/include/uapi/asm/auxvec.h b/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_header">index 22d6d8885854..4cf0c17787a8 100644</span>
<span class="p_header">--- a/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -19,4 +19,6 @@</span> <span class="p_context"></span>
 /* vDSO location */
 #define AT_SYSINFO_EHDR	33
 
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH 1 /* entries in ARCH_DLINFO */</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/arm64/kernel/debug-monitors.c b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">index fe5b94078d82..a2db6f219bbe 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_chunk">@@ -159,7 +159,6 @@</span> <span class="p_context"> static int debug_monitors_init(void)</span>
 	/* Clear the OS lock. */
 	on_each_cpu(clear_os_lock, NULL, 1);
 	isb();
<span class="p_del">-	local_dbg_enable();</span>
 
 	/* Register hotplug handler. */
 	__register_cpu_notifier(&amp;os_lock_nb);
<span class="p_header">diff --git a/arch/arm64/kernel/perf_event.c b/arch/arm64/kernel/perf_event.c</span>
<span class="p_header">index 6166745ecb93..be0ff66e4894 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/perf_event.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/perf_event.c</span>
<span class="p_chunk">@@ -316,22 +316,31 @@</span> <span class="p_context"> out:</span>
 }
 
 static int
<span class="p_del">-validate_event(struct pmu_hw_events *hw_events,</span>
<span class="p_del">-	       struct perf_event *event)</span>
<span class="p_add">+validate_event(struct pmu *pmu, struct pmu_hw_events *hw_events,</span>
<span class="p_add">+				struct perf_event *event)</span>
 {
<span class="p_del">-	struct arm_pmu *armpmu = to_arm_pmu(event-&gt;pmu);</span>
<span class="p_add">+	struct arm_pmu *armpmu;</span>
 	struct hw_perf_event fake_event = event-&gt;hw;
 	struct pmu *leader_pmu = event-&gt;group_leader-&gt;pmu;
 
 	if (is_software_event(event))
 		return 1;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Reject groups spanning multiple HW PMUs (e.g. CPU + CCI). The</span>
<span class="p_add">+	 * core perf code won&#39;t check that the pmu-&gt;ctx == leader-&gt;ctx</span>
<span class="p_add">+	 * until after pmu-&gt;event_init(event).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (event-&gt;pmu != pmu)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (event-&gt;pmu != leader_pmu || event-&gt;state &lt; PERF_EVENT_STATE_OFF)
 		return 1;
 
 	if (event-&gt;state == PERF_EVENT_STATE_OFF &amp;&amp; !event-&gt;attr.enable_on_exec)
 		return 1;
 
<span class="p_add">+	armpmu = to_arm_pmu(event-&gt;pmu);</span>
 	return armpmu-&gt;get_event_idx(hw_events, &amp;fake_event) &gt;= 0;
 }
 
<span class="p_chunk">@@ -349,15 +358,15 @@</span> <span class="p_context"> validate_group(struct perf_event *event)</span>
 	memset(fake_used_mask, 0, sizeof(fake_used_mask));
 	fake_pmu.used_mask = fake_used_mask;
 
<span class="p_del">-	if (!validate_event(&amp;fake_pmu, leader))</span>
<span class="p_add">+	if (!validate_event(event-&gt;pmu, &amp;fake_pmu, leader))</span>
 		return -EINVAL;
 
 	list_for_each_entry(sibling, &amp;leader-&gt;sibling_list, group_entry) {
<span class="p_del">-		if (!validate_event(&amp;fake_pmu, sibling))</span>
<span class="p_add">+		if (!validate_event(event-&gt;pmu, &amp;fake_pmu, sibling))</span>
 			return -EINVAL;
 	}
 
<span class="p_del">-	if (!validate_event(&amp;fake_pmu, event))</span>
<span class="p_add">+	if (!validate_event(event-&gt;pmu, &amp;fake_pmu, event))</span>
 		return -EINVAL;
 
 	return 0;
<span class="p_header">diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c</span>
<span class="p_header">index 9df272c0d240..c684be1e9942 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/smp.c</span>
<span class="p_chunk">@@ -174,7 +174,6 @@</span> <span class="p_context"> asmlinkage void secondary_start_kernel(void)</span>
 	set_cpu_online(cpu, true);
 	complete(&amp;cpu_running);
 
<span class="p_del">-	local_dbg_enable();</span>
 	local_irq_enable();
 	local_async_enable();
 
<span class="p_header">diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S</span>
<span class="p_header">index dc34442ff728..10e94cbc3192 100644</span>
<span class="p_header">--- a/arch/arm64/mm/proc.S</span>
<span class="p_header">+++ b/arch/arm64/mm/proc.S</span>
<span class="p_chunk">@@ -189,6 +189,8 @@</span> <span class="p_context"> ENTRY(__cpu_setup)</span>
 	msr	cpacr_el1, x0			// Enable FP/ASIMD
 	mov	x0, #1 &lt;&lt; 12			// Reset mdscr_el1 and disable
 	msr	mdscr_el1, x0			// access to the DCC from EL0
<span class="p_add">+	isb					// Unmask debug exceptions now,</span>
<span class="p_add">+	enable_dbg				// since this is per-cpu</span>
 	reset_pmuserenr_el0 x0			// Disable PMU access from EL0
 	/*
 	 * Memory region attributes for LPAE:
<span class="p_header">diff --git a/arch/avr32/include/asm/uaccess.h b/arch/avr32/include/asm/uaccess.h</span>
<span class="p_header">index 245b2ee213c9..a0a9b8c31041 100644</span>
<span class="p_header">--- a/arch/avr32/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/avr32/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> extern __kernel_size_t __copy_user(void *to, const void *from,</span>
 
 extern __kernel_size_t copy_to_user(void __user *to, const void *from,
 				    __kernel_size_t n);
<span class="p_del">-extern __kernel_size_t copy_from_user(void *to, const void __user *from,</span>
<span class="p_add">+extern __kernel_size_t ___copy_from_user(void *to, const void __user *from,</span>
 				      __kernel_size_t n);
 
 static inline __kernel_size_t __copy_to_user(void __user *to, const void *from,
<span class="p_chunk">@@ -88,6 +88,15 @@</span> <span class="p_context"> static inline __kernel_size_t __copy_from_user(void *to,</span>
 {
 	return __copy_user(to, (const void __force *)from, n);
 }
<span class="p_add">+static inline __kernel_size_t copy_from_user(void *to,</span>
<span class="p_add">+					       const void __user *from,</span>
<span class="p_add">+					       __kernel_size_t n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	size_t res = ___copy_from_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
<span class="p_add">+}</span>
 
 #define __copy_to_user_inatomic __copy_to_user
 #define __copy_from_user_inatomic __copy_from_user
<span class="p_header">diff --git a/arch/avr32/kernel/avr32_ksyms.c b/arch/avr32/kernel/avr32_ksyms.c</span>
<span class="p_header">index d93ead02daed..7c6cf14f0985 100644</span>
<span class="p_header">--- a/arch/avr32/kernel/avr32_ksyms.c</span>
<span class="p_header">+++ b/arch/avr32/kernel/avr32_ksyms.c</span>
<span class="p_chunk">@@ -36,7 +36,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(copy_page);</span>
 /*
  * Userspace access stuff.
  */
<span class="p_del">-EXPORT_SYMBOL(copy_from_user);</span>
<span class="p_add">+EXPORT_SYMBOL(___copy_from_user);</span>
 EXPORT_SYMBOL(copy_to_user);
 EXPORT_SYMBOL(__copy_user);
 EXPORT_SYMBOL(strncpy_from_user);
<span class="p_header">diff --git a/arch/avr32/lib/copy_user.S b/arch/avr32/lib/copy_user.S</span>
<span class="p_header">index ea59c04b07de..075373471da1 100644</span>
<span class="p_header">--- a/arch/avr32/lib/copy_user.S</span>
<span class="p_header">+++ b/arch/avr32/lib/copy_user.S</span>
<span class="p_chunk">@@ -23,13 +23,13 @@</span> <span class="p_context"></span>
 	 */
 	.text
 	.align	1
<span class="p_del">-	.global	copy_from_user</span>
<span class="p_del">-	.type	copy_from_user, @function</span>
<span class="p_del">-copy_from_user:</span>
<span class="p_add">+	.global	___copy_from_user</span>
<span class="p_add">+	.type	___copy_from_user, @function</span>
<span class="p_add">+___copy_from_user:</span>
 	branch_if_kernel r8, __copy_user
 	ret_if_privileged r8, r11, r10, r10
 	rjmp	__copy_user
<span class="p_del">-	.size	copy_from_user, . - copy_from_user</span>
<span class="p_add">+	.size	___copy_from_user, . - ___copy_from_user</span>
 
 	.global	copy_to_user
 	.type	copy_to_user, @function
<span class="p_header">diff --git a/arch/avr32/mach-at32ap/pio.c b/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_header">index 903c7d81d0d5..a8e208eaf2a4 100644</span>
<span class="p_header">--- a/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_header">+++ b/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_chunk">@@ -435,7 +435,7 @@</span> <span class="p_context"> void __init at32_init_pio(struct platform_device *pdev)</span>
 	struct resource *regs;
 	struct pio_device *pio;
 
<span class="p_del">-	if (pdev-&gt;id &gt; MAX_NR_PIO_DEVICES) {</span>
<span class="p_add">+	if (pdev-&gt;id &gt;= MAX_NR_PIO_DEVICES) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;only %d PIO devices supported\n&quot;,
 			MAX_NR_PIO_DEVICES);
 		return;
<span class="p_header">diff --git a/arch/blackfin/include/asm/uaccess.h b/arch/blackfin/include/asm/uaccess.h</span>
<span class="p_header">index 57701c3b8a59..a992a788409c 100644</span>
<span class="p_header">--- a/arch/blackfin/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/blackfin/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -177,11 +177,12 @@</span> <span class="p_context"> static inline int bad_user_access_length(void)</span>
 static inline unsigned long __must_check
 copy_from_user(void *to, const void __user *from, unsigned long n)
 {
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n))) {</span>
 		memcpy(to, (const void __force *)from, n);
<span class="p_del">-	else</span>
<span class="p_del">-		return n;</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memset(to, 0, n);</span>
<span class="p_add">+	return n;</span>
 }
 
 static inline unsigned long __must_check
<span class="p_header">diff --git a/arch/cris/include/asm/uaccess.h b/arch/cris/include/asm/uaccess.h</span>
<span class="p_header">index 914540801c5e..93bfa8acc38b 100644</span>
<span class="p_header">--- a/arch/cris/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/cris/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -176,30 +176,6 @@</span> <span class="p_context"> extern unsigned long __copy_user(void __user *to, const void *from, unsigned lon</span>
 extern unsigned long __copy_user_zeroing(void *to, const void __user *from, unsigned long n);
 extern unsigned long __do_clear_user(void __user *to, unsigned long n);
 
<span class="p_del">-static inline unsigned long</span>
<span class="p_del">-__generic_copy_to_user(void __user *to, const void *from, unsigned long n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, to, n))</span>
<span class="p_del">-		return __copy_user(to,from,n);</span>
<span class="p_del">-	return n;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline unsigned long</span>
<span class="p_del">-__generic_copy_from_user(void *to, const void __user *from, unsigned long n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_del">-		return __copy_user_zeroing(to,from,n);</span>
<span class="p_del">-	return n;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline unsigned long</span>
<span class="p_del">-__generic_clear_user(void __user *to, unsigned long n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, to, n))</span>
<span class="p_del">-		return __do_clear_user(to,n);</span>
<span class="p_del">-	return n;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline long
 __strncpy_from_user(char *dst, const char __user *src, long count)
 {
<span class="p_chunk">@@ -262,7 +238,7 @@</span> <span class="p_context"> __constant_copy_from_user(void *to, const void __user *from, unsigned long n)</span>
 	else if (n == 24)
 		__asm_copy_from_user_24(to, from, ret);
 	else
<span class="p_del">-		ret = __generic_copy_from_user(to, from, n);</span>
<span class="p_add">+		ret = __copy_user_zeroing(to, from, n);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -312,7 +288,7 @@</span> <span class="p_context"> __constant_copy_to_user(void __user *to, const void *from, unsigned long n)</span>
 	else if (n == 24)
 		__asm_copy_to_user_24(to, from, ret);
 	else
<span class="p_del">-		ret = __generic_copy_to_user(to, from, n);</span>
<span class="p_add">+		ret = __copy_user(to, from, n);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -344,26 +320,43 @@</span> <span class="p_context"> __constant_clear_user(void __user *to, unsigned long n)</span>
 	else if (n == 24)
 		__asm_clear_24(to, ret);
 	else
<span class="p_del">-		ret = __generic_clear_user(to, n);</span>
<span class="p_add">+		ret = __do_clear_user(to, n);</span>
 
 	return ret;
 }
 
 
<span class="p_del">-#define clear_user(to, n)			\</span>
<span class="p_del">-(__builtin_constant_p(n) ?			\</span>
<span class="p_del">- __constant_clear_user(to, n) :			\</span>
<span class="p_del">- __generic_clear_user(to, n))</span>
<span class="p_add">+static inline size_t clear_user(void __user *to, size_t n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))</span>
<span class="p_add">+		return n;</span>
<span class="p_add">+	if (__builtin_constant_p(n))</span>
<span class="p_add">+		return __constant_clear_user(to, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return __do_clear_user(to, n);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#define copy_from_user(to, from, n)		\</span>
<span class="p_del">-(__builtin_constant_p(n) ?			\</span>
<span class="p_del">- __constant_copy_from_user(to, from, n) :	\</span>
<span class="p_del">- __generic_copy_from_user(to, from, n))</span>
<span class="p_add">+static inline size_t copy_from_user(void *to, const void __user *from, size_t n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(!access_ok(VERIFY_READ, from, n))) {</span>
<span class="p_add">+		memset(to, 0, n);</span>
<span class="p_add">+		return n;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (__builtin_constant_p(n))</span>
<span class="p_add">+		return __constant_copy_from_user(to, from, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return __copy_user_zeroing(to, from, n);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#define copy_to_user(to, from, n)		\</span>
<span class="p_del">-(__builtin_constant_p(n) ?			\</span>
<span class="p_del">- __constant_copy_to_user(to, from, n) :		\</span>
<span class="p_del">- __generic_copy_to_user(to, from, n))</span>
<span class="p_add">+static inline size_t copy_to_user(void __user *to, const void *from, size_t n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))</span>
<span class="p_add">+		return n;</span>
<span class="p_add">+	if (__builtin_constant_p(n))</span>
<span class="p_add">+		return __constant_copy_to_user(to, from, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return __copy_user(to, from, n);</span>
<span class="p_add">+}</span>
 
 /* We let the __ versions of copy_from/to_user inline, because they&#39;re often
  * used in fast paths and have only a small space overhead.
<span class="p_header">diff --git a/arch/frv/include/asm/uaccess.h b/arch/frv/include/asm/uaccess.h</span>
<span class="p_header">index 3ac9a59d65d4..87d9e34c5df8 100644</span>
<span class="p_header">--- a/arch/frv/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/frv/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -263,19 +263,25 @@</span> <span class="p_context"> do {							\</span>
 extern long __memset_user(void *dst, unsigned long count);
 extern long __memcpy_user(void *dst, const void *src, unsigned long count);
 
<span class="p_del">-#define clear_user(dst,count)			__memset_user(____force(dst), (count))</span>
<span class="p_add">+#define __clear_user(dst,count)			__memset_user(____force(dst), (count))</span>
 #define __copy_from_user_inatomic(to, from, n)	__memcpy_user((to), ____force(from), (n))
 #define __copy_to_user_inatomic(to, from, n)	__memcpy_user(____force(to), (from), (n))
 
 #else
 
<span class="p_del">-#define clear_user(dst,count)			(memset(____force(dst), 0, (count)), 0)</span>
<span class="p_add">+#define __clear_user(dst,count)			(memset(____force(dst), 0, (count)), 0)</span>
 #define __copy_from_user_inatomic(to, from, n)	(memcpy((to), ____force(from), (n)), 0)
 #define __copy_to_user_inatomic(to, from, n)	(memcpy(____force(to), (from), (n)), 0)
 
 #endif
 
<span class="p_del">-#define __clear_user clear_user</span>
<span class="p_add">+static inline unsigned long __must_check</span>
<span class="p_add">+clear_user(void __user *to, unsigned long n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (likely(__access_ok(to, n)))</span>
<span class="p_add">+		n = __clear_user(to, n);</span>
<span class="p_add">+	return n;</span>
<span class="p_add">+}</span>
 
 static inline unsigned long __must_check
 __copy_to_user(void __user *to, const void *from, unsigned long n)
<span class="p_header">diff --git a/arch/hexagon/include/asm/uaccess.h b/arch/hexagon/include/asm/uaccess.h</span>
<span class="p_header">index e4127e4d6a5b..25fc9049db8a 100644</span>
<span class="p_header">--- a/arch/hexagon/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/hexagon/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -102,7 +102,8 @@</span> <span class="p_context"> static inline long hexagon_strncpy_from_user(char *dst, const char __user *src,</span>
 {
 	long res = __strnlen_user(src, n);
 
<span class="p_del">-	/* return from strnlen can&#39;t be zero -- that would be rubbish. */</span>
<span class="p_add">+	if (unlikely(!res))</span>
<span class="p_add">+		return -EFAULT;</span>
 
 	if (res &gt; n) {
 		copy_from_user(dst, src, n);
<span class="p_header">diff --git a/arch/ia64/include/asm/uaccess.h b/arch/ia64/include/asm/uaccess.h</span>
<span class="p_header">index 449c8c0fa2bd..810926c56e31 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -262,17 +262,15 @@</span> <span class="p_context"> __copy_from_user (void *to, const void __user *from, unsigned long count)</span>
 	__cu_len;									\
 })
 
<span class="p_del">-#define copy_from_user(to, from, n)							\</span>
<span class="p_del">-({											\</span>
<span class="p_del">-	void *__cu_to = (to);								\</span>
<span class="p_del">-	const void __user *__cu_from = (from);						\</span>
<span class="p_del">-	long __cu_len = (n);								\</span>
<span class="p_del">-											\</span>
<span class="p_del">-	__chk_user_ptr(__cu_from);							\</span>
<span class="p_del">-	if (__access_ok(__cu_from, __cu_len, get_fs()))					\</span>
<span class="p_del">-		__cu_len = __copy_user((__force void __user *) __cu_to, __cu_from, __cu_len);	\</span>
<span class="p_del">-	__cu_len;									\</span>
<span class="p_del">-})</span>
<span class="p_add">+static inline unsigned long</span>
<span class="p_add">+copy_from_user(void *to, const void __user *from, unsigned long n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (likely(__access_ok(from, n, get_fs())))</span>
<span class="p_add">+		n = __copy_user((__force void __user *) to, from, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		memset(to, 0, n);</span>
<span class="p_add">+	return n;</span>
<span class="p_add">+}</span>
 
 #define __copy_in_user(to, from, size)	__copy_user((to), (from), (size))
 
<span class="p_header">diff --git a/arch/m32r/include/asm/uaccess.h b/arch/m32r/include/asm/uaccess.h</span>
<span class="p_header">index 84fe7ba53035..c393e8f57cf7 100644</span>
<span class="p_header">--- a/arch/m32r/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/m32r/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -215,7 +215,7 @@</span> <span class="p_context"> extern int fixup_exception(struct pt_regs *regs);</span>
 #define __get_user_nocheck(x,ptr,size)					\
 ({									\
 	long __gu_err = 0;						\
<span class="p_del">-	unsigned long __gu_val;						\</span>
<span class="p_add">+	unsigned long __gu_val = 0;					\</span>
 	might_fault();							\
 	__get_user_size(__gu_val,(ptr),(size),__gu_err);		\
 	(x) = (__typeof__(*(ptr)))__gu_val;				\
<span class="p_header">diff --git a/arch/metag/include/asm/cmpxchg_lnkget.h b/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_header">index 0154e2807ebb..2369ad394876 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> static inline unsigned long __cmpxchg_u32(volatile int *m, unsigned long old,</span>
 		      &quot;	DCACHE	[%2], %0\n&quot;
 #endif
 		      &quot;2:\n&quot;
<span class="p_del">-		      : &quot;=&amp;d&quot; (temp), &quot;=&amp;da&quot; (retval)</span>
<span class="p_add">+		      : &quot;=&amp;d&quot; (temp), &quot;=&amp;d&quot; (retval)</span>
 		      : &quot;da&quot; (m), &quot;bd&quot; (old), &quot;da&quot; (new)
 		      : &quot;cc&quot;
 		      );
<span class="p_header">diff --git a/arch/metag/include/asm/uaccess.h b/arch/metag/include/asm/uaccess.h</span>
<span class="p_header">index 0748b0a97986..7841f2290385 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -199,8 +199,9 @@</span> <span class="p_context"> extern unsigned long __must_check __copy_user_zeroing(void *to,</span>
 static inline unsigned long
 copy_from_user(void *to, const void __user *from, unsigned long n)
 {
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n)))</span>
 		return __copy_user_zeroing(to, from, n);
<span class="p_add">+	memset(to, 0, n);</span>
 	return n;
 }
 
<span class="p_header">diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h</span>
<span class="p_header">index 0aa005703a0b..1858887105ba 100644</span>
<span class="p_header">--- a/arch/microblaze/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/microblaze/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -226,7 +226,7 @@</span> <span class="p_context"> extern long __user_bad(void);</span>
 
 #define __get_user(x, ptr)						\
 ({									\
<span class="p_del">-	unsigned long __gu_val;						\</span>
<span class="p_add">+	unsigned long __gu_val = 0;					\</span>
 	/*unsigned long __gu_ptr = (unsigned long)(ptr);*/		\
 	long __gu_err;							\
 	switch (sizeof(*(ptr))) {					\
<span class="p_chunk">@@ -371,10 +371,13 @@</span> <span class="p_context"> extern long __user_bad(void);</span>
 static inline long copy_from_user(void *to,
 		const void __user *from, unsigned long n)
 {
<span class="p_add">+	unsigned long res = n;</span>
 	might_fault();
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_del">-		return __copy_from_user(to, from, n);</span>
<span class="p_del">-	return n;</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n)))</span>
<span class="p_add">+		res = __copy_from_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
 }
 
 #define __copy_to_user(to, from, n)	\
<span class="p_header">diff --git a/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h b/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h</span>
<span class="p_header">index 2f82bfa3a773..c9f5769dfc8f 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h</span>
<span class="p_chunk">@@ -11,11 +11,13 @@</span> <span class="p_context"></span>
 #define CP0_EBASE $15, 1
 
 	.macro  kernel_entry_setup
<span class="p_add">+#ifdef CONFIG_SMP</span>
 	mfc0	t0, CP0_EBASE
 	andi	t0, t0, 0x3ff		# CPUNum
 	beqz	t0, 1f
 	# CPUs other than zero goto smp_bootstrap
 	j	smp_bootstrap
<span class="p_add">+#endif /* CONFIG_SMP */</span>
 
 1:
 	.endm
<span class="p_header">diff --git a/arch/mips/include/asm/pgtable.h b/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">index 148a4766bf4d..f94d39f9e21d 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -572,7 +572,11 @@</span> <span class="p_context"> static inline struct page *pmd_page(pmd_t pmd)</span>
 
 static inline pmd_t pmd_modify(pmd_t pmd, pgprot_t newprot)
 {
<span class="p_del">-	pmd_val(pmd) = (pmd_val(pmd) &amp; _PAGE_CHG_MASK) | pgprot_val(newprot);</span>
<span class="p_add">+	pmd_val(pmd) = (pmd_val(pmd) &amp; (_PAGE_CHG_MASK</span>
<span class="p_add">+#ifdef _PAGE_HUGE</span>
<span class="p_add">+					| _PAGE_HUGE</span>
<span class="p_add">+#endif</span>
<span class="p_add">+				)) | pgprot_val(newprot);</span>
 	return pmd;
 }
 
<span class="p_header">diff --git a/arch/mips/include/asm/r4kcache.h b/arch/mips/include/asm/r4kcache.h</span>
<span class="p_header">index ed038d7c3410..7b74668d3e20 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/r4kcache.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/r4kcache.h</span>
<span class="p_chunk">@@ -263,7 +263,11 @@</span> <span class="p_context"> static inline void protected_writeback_dcache_line(unsigned long addr)</span>
 
 static inline void protected_writeback_scache_line(unsigned long addr)
 {
<span class="p_add">+#ifdef CONFIG_EVA</span>
<span class="p_add">+	protected_cachee_op(Hit_Writeback_Inv_SD, addr);</span>
<span class="p_add">+#else</span>
 	protected_cache_op(Hit_Writeback_Inv_SD, addr);
<span class="p_add">+#endif</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/mips/include/asm/uaccess.h b/arch/mips/include/asm/uaccess.h</span>
<span class="p_header">index 16e0ea6b99d8..cb4a3ee31983 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/thread_info.h&gt;
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
 #include &lt;asm/asm-eva.h&gt;
 
 /*
<span class="p_chunk">@@ -1139,6 +1140,8 @@</span> <span class="p_context"> extern size_t __copy_in_user_eva(void *__to, const void *__from, size_t __n);</span>
 			__cu_len = __invoke_copy_from_user(__cu_to,	\
 							   __cu_from,	\
 							   __cu_len);   \
<span class="p_add">+		} else {						\</span>
<span class="p_add">+			memset(__cu_to, 0, __cu_len);			\</span>
 		}							\
 	}								\
 	__cu_len;							\
<span class="p_header">diff --git a/arch/mips/kernel/scall64-n32.S b/arch/mips/kernel/scall64-n32.S</span>
<span class="p_header">index 47dd5f9016c1..28a2cb2c6c9b 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall64-n32.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall64-n32.S</span>
<span class="p_chunk">@@ -353,7 +353,7 @@</span> <span class="p_context"> EXPORT(sysn32_call_table)</span>
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key
 	PTR	sys_request_key
<span class="p_del">-	PTR	sys_keyctl			/* 6245 */</span>
<span class="p_add">+	PTR	compat_sys_keyctl		/* 6245 */</span>
 	PTR	sys_set_thread_area
 	PTR	sys_inotify_init
 	PTR	sys_inotify_add_watch
<span class="p_header">diff --git a/arch/mips/kernel/scall64-o32.S b/arch/mips/kernel/scall64-o32.S</span>
<span class="p_header">index 7f5feb25ae04..3b726b9229b4 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall64-o32.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall64-o32.S</span>
<span class="p_chunk">@@ -491,7 +491,7 @@</span> <span class="p_context"> EXPORT(sys32_call_table)</span>
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key			/* 4280 */
 	PTR	sys_request_key
<span class="p_del">-	PTR	sys_keyctl</span>
<span class="p_add">+	PTR	compat_sys_keyctl</span>
 	PTR	sys_set_thread_area
 	PTR	sys_inotify_init
 	PTR	sys_inotify_add_watch		/* 4285 */
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">index 2c81c2c9e8dc..72aad2a9a6b4 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_chunk">@@ -1211,7 +1211,7 @@</span> <span class="p_context"> int __init kvm_mips_init(void)</span>
 	 */
 	kvm_mips_gfn_to_pfn = gfn_to_pfn;
 	kvm_mips_release_pfn_clean = kvm_release_pfn_clean;
<span class="p_del">-	kvm_mips_is_error_pfn = is_error_pfn;</span>
<span class="p_add">+	kvm_mips_is_error_pfn = is_error_noslot_pfn;</span>
 
 	pr_info(&quot;KVM/MIPS Initialized\n&quot;);
 	return 0;
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">index 1983678883c9..bac2bba41f38 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_chunk">@@ -817,6 +817,47 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbr(struct kvm_vcpu *vcpu)</span>
 	return er;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * kvm_mips_invalidate_guest_tlb() - Indicates a change in guest MMU map.</span>
<span class="p_add">+ * @vcpu:	VCPU with changed mappings.</span>
<span class="p_add">+ * @tlb:	TLB entry being removed.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is called to indicate a single change in guest MMU mappings, so that we</span>
<span class="p_add">+ * can arrange TLB flushes on this and other CPUs.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void kvm_mips_invalidate_guest_tlb(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+					  struct kvm_mips_tlb *tlb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu, i;</span>
<span class="p_add">+	bool user;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* No need to flush for entries which are already invalid */</span>
<span class="p_add">+	if (!((tlb-&gt;tlb_lo0 | tlb-&gt;tlb_lo1) &amp; MIPS3_PG_V))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	/* User address space doesn&#39;t need flushing for KSeg2/3 changes */</span>
<span class="p_add">+	user = tlb-&gt;tlb_hi &lt; KVM_GUEST_KSEG0;</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_add">+	 * matches, invalidate it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Invalidate the whole ASID on other CPUs */</span>
<span class="p_add">+	cpu = smp_processor_id();</span>
<span class="p_add">+	for_each_possible_cpu(i) {</span>
<span class="p_add">+		if (i == cpu)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (user)</span>
<span class="p_add">+			vcpu-&gt;arch.guest_user_asid[i] = 0;</span>
<span class="p_add">+		vcpu-&gt;arch.guest_kernel_asid[i] = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Write Guest TLB Entry @ Index */
 enum emulation_result kvm_mips_emul_tlbwi(struct kvm_vcpu *vcpu)
 {
<span class="p_chunk">@@ -838,10 +879,8 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbwi(struct kvm_vcpu *vcpu)</span>
 	}
 
 	tlb = &amp;vcpu-&gt;arch.guest_tlb[index];
<span class="p_del">-#if 1</span>
<span class="p_del">-	/* Probe the shadow host TLB for the entry being overwritten, if one matches, invalidate it */</span>
<span class="p_del">-	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_del">-#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_mips_invalidate_guest_tlb(vcpu, tlb);</span>
 
 	tlb-&gt;tlb_mask = kvm_read_c0_guest_pagemask(cop0);
 	tlb-&gt;tlb_hi = kvm_read_c0_guest_entryhi(cop0);
<span class="p_chunk">@@ -880,10 +919,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbwr(struct kvm_vcpu *vcpu)</span>
 
 	tlb = &amp;vcpu-&gt;arch.guest_tlb[index];
 
<span class="p_del">-#if 1</span>
<span class="p_del">-	/* Probe the shadow host TLB for the entry being overwritten, if one matches, invalidate it */</span>
<span class="p_del">-	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	kvm_mips_invalidate_guest_tlb(vcpu, tlb);</span>
 
 	tlb-&gt;tlb_mask = kvm_read_c0_guest_pagemask(cop0);
 	tlb-&gt;tlb_hi = kvm_read_c0_guest_entryhi(cop0);
<span class="p_chunk">@@ -926,6 +962,7 @@</span> <span class="p_context"> kvm_mips_emulate_CP0(uint32_t inst, uint32_t *opc, uint32_t cause,</span>
 	int32_t rt, rd, copz, sel, co_bit, op;
 	uint32_t pc = vcpu-&gt;arch.pc;
 	unsigned long curr_pc;
<span class="p_add">+	int cpu, i;</span>
 
 	/*
 	 * Update PC and hold onto current PC in case there is
<span class="p_chunk">@@ -1037,8 +1074,16 @@</span> <span class="p_context"> kvm_mips_emulate_CP0(uint32_t inst, uint32_t *opc, uint32_t cause,</span>
 					     ASID_MASK,
 					     vcpu-&gt;arch.gprs[rt] &amp; ASID_MASK);
 
<span class="p_add">+					preempt_disable();</span>
 					/* Blow away the shadow host TLBs */
 					kvm_mips_flush_host_tlb(1);
<span class="p_add">+					cpu = smp_processor_id();</span>
<span class="p_add">+					for_each_possible_cpu(i)</span>
<span class="p_add">+						if (i != cpu) {</span>
<span class="p_add">+							vcpu-&gt;arch.guest_user_asid[i] = 0;</span>
<span class="p_add">+							vcpu-&gt;arch.guest_kernel_asid[i] = 0;</span>
<span class="p_add">+						}</span>
<span class="p_add">+					preempt_enable();</span>
 				}
 				kvm_write_c0_guest_entryhi(cop0,
 							   vcpu-&gt;arch.gprs[rt]);
<span class="p_chunk">@@ -1481,9 +1526,13 @@</span> <span class="p_context"> kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc, uint32_t cause,</span>
 
 	preempt_disable();
 	if (KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG0) {
<span class="p_del">-</span>
<span class="p_del">-		if (kvm_mips_host_tlb_lookup(vcpu, va) &lt; 0) {</span>
<span class="p_del">-			kvm_mips_handle_kseg0_tlb_fault(va, vcpu);</span>
<span class="p_add">+		if (kvm_mips_host_tlb_lookup(vcpu, va) &lt; 0 &amp;&amp;</span>
<span class="p_add">+		    kvm_mips_handle_kseg0_tlb_fault(va, vcpu)) {</span>
<span class="p_add">+			kvm_err(&quot;%s: handling mapped kseg0 tlb fault for %lx, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+				__func__, va, vcpu, read_c0_entryhi());</span>
<span class="p_add">+			er = EMULATE_FAIL;</span>
<span class="p_add">+			preempt_enable();</span>
<span class="p_add">+			goto done;</span>
 		}
 	} else if ((KVM_GUEST_KSEGX(va) &lt; KVM_GUEST_KSEG0) ||
 		   KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG23) {
<span class="p_chunk">@@ -1516,11 +1565,19 @@</span> <span class="p_context"> kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc, uint32_t cause,</span>
 								run, vcpu);
 				preempt_enable();
 				goto dont_update_pc;
<span class="p_del">-			} else {</span>
<span class="p_del">-				/* We fault an entry from the guest tlb to the shadow host TLB */</span>
<span class="p_del">-				kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_del">-								     NULL,</span>
<span class="p_del">-								     NULL);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We fault an entry from the guest tlb to the</span>
<span class="p_add">+			 * shadow host TLB</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_add">+								 NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, va, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				er = EMULATE_FAIL;</span>
<span class="p_add">+				preempt_enable();</span>
<span class="p_add">+				goto done;</span>
 			}
 		}
 	} else {
<span class="p_chunk">@@ -2335,8 +2392,13 @@</span> <span class="p_context"> kvm_mips_handle_tlbmiss(unsigned long cause, uint32_t *opc,</span>
 			    (&quot;Injecting hi: %#lx, lo0: %#lx, lo1: %#lx into shadow host TLB\n&quot;,
 			     tlb-&gt;tlb_hi, tlb-&gt;tlb_lo0, tlb-&gt;tlb_lo1);
 			/* OK we have a Guest TLB entry, now inject it into the shadow host TLB */
<span class="p_del">-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb, NULL,</span>
<span class="p_del">-							     NULL);</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_add">+								 NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, va, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				er = EMULATE_FAIL;</span>
<span class="p_add">+			}</span>
 		}
 	}
 
<span class="p_header">diff --git a/arch/mips/kvm/kvm_tlb.c b/arch/mips/kvm/kvm_tlb.c</span>
<span class="p_header">index 8a5a700ad8de..1fde7236382d 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_tlb.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_tlb.c</span>
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"> static int kvm_mips_map_page(struct kvm *kvm, gfn_t gfn)</span>
         srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);
 	pfn = kvm_mips_gfn_to_pfn(kvm, gfn);
 
<span class="p_del">-	if (kvm_mips_is_error_pfn(pfn)) {</span>
<span class="p_add">+	if (is_error_noslot_pfn(pfn)) {</span>
 		kvm_err(&quot;Couldn&#39;t get pfn for gfn %#&quot; PRIx64 &quot;!\n&quot;, gfn);
 		err = -EFAULT;
 		goto out;
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> int kvm_mips_handle_kseg0_tlb_fault(unsigned long badvaddr,</span>
 	}
 
 	gfn = (KVM_GUEST_CPHYSADDR(badvaddr) &gt;&gt; PAGE_SHIFT);
<span class="p_del">-	if (gfn &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
<span class="p_add">+	if ((gfn | 1) &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
 		kvm_err(&quot;%s: Invalid gfn: %#llx, BadVaddr: %#lx\n&quot;, __func__,
 			gfn, badvaddr);
 		kvm_mips_dump_host_tlbs();
<span class="p_chunk">@@ -361,21 +361,39 @@</span> <span class="p_context"> kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,</span>
 	unsigned long entryhi = 0, entrylo0 = 0, entrylo1 = 0;
 	struct kvm *kvm = vcpu-&gt;kvm;
 	pfn_t pfn0, pfn1;
<span class="p_add">+	gfn_t gfn0, gfn1;</span>
<span class="p_add">+	long tlb_lo[2];</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	tlb_lo[0] = tlb-&gt;tlb_lo0;</span>
<span class="p_add">+	tlb_lo[1] = tlb-&gt;tlb_lo1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The commpage address must not be mapped to anything else if the guest</span>
<span class="p_add">+	 * TLB contains entries nearby, or commpage accesses will break.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!((tlb-&gt;tlb_hi ^ KVM_GUEST_COMMPAGE_ADDR) &amp;</span>
<span class="p_add">+			VPN2_MASK &amp; (PAGE_MASK &lt;&lt; 1)))</span>
<span class="p_add">+		tlb_lo[(KVM_GUEST_COMMPAGE_ADDR &gt;&gt; PAGE_SHIFT) &amp; 1] = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	gfn0 = mips3_tlbpfn_to_paddr(tlb_lo[0]) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	gfn1 = mips3_tlbpfn_to_paddr(tlb_lo[1]) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (gfn0 &gt;= kvm-&gt;arch.guest_pmap_npages ||</span>
<span class="p_add">+	    gfn1 &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
<span class="p_add">+		kvm_err(&quot;%s: Invalid gfn: [%#llx, %#llx], EHi: %#lx\n&quot;,</span>
<span class="p_add">+			__func__, gfn0, gfn1, tlb-&gt;tlb_hi);</span>
<span class="p_add">+		kvm_mips_dump_guest_tlbs(vcpu);</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	if (kvm_mips_map_page(kvm, gfn0) &lt; 0)</span>
<span class="p_add">+		return -1;</span>
 
<span class="p_del">-	if ((tlb-&gt;tlb_hi &amp; VPN2_MASK) == 0) {</span>
<span class="p_del">-		pfn0 = 0;</span>
<span class="p_del">-		pfn1 = 0;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo0) &gt;&gt; PAGE_SHIFT) &lt; 0)</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo1) &gt;&gt; PAGE_SHIFT) &lt; 0)</span>
<span class="p_del">-			return -1;</span>
<span class="p_add">+	if (kvm_mips_map_page(kvm, gfn1) &lt; 0)</span>
<span class="p_add">+		return -1;</span>
 
<span class="p_del">-		pfn0 = kvm-&gt;arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo0) &gt;&gt; PAGE_SHIFT];</span>
<span class="p_del">-		pfn1 = kvm-&gt;arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo1) &gt;&gt; PAGE_SHIFT];</span>
<span class="p_del">-	}</span>
<span class="p_add">+	pfn0 = kvm-&gt;arch.guest_pmap[gfn0];</span>
<span class="p_add">+	pfn1 = kvm-&gt;arch.guest_pmap[gfn1];</span>
 
 	if (hpa0)
 		*hpa0 = pfn0 &lt;&lt; PAGE_SHIFT;
<span class="p_chunk">@@ -387,9 +405,9 @@</span> <span class="p_context"> kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,</span>
 	entryhi = (tlb-&gt;tlb_hi &amp; VPN2_MASK) | (KVM_GUEST_KERNEL_MODE(vcpu) ?
 			kvm_mips_get_kernel_asid(vcpu) : kvm_mips_get_user_asid(vcpu));
 	entrylo0 = mips3_paddr_to_tlbpfn(pfn0 &lt;&lt; PAGE_SHIFT) | (0x3 &lt;&lt; 3) |
<span class="p_del">-			(tlb-&gt;tlb_lo0 &amp; MIPS3_PG_D) | (tlb-&gt;tlb_lo0 &amp; MIPS3_PG_V);</span>
<span class="p_add">+		(tlb_lo[0] &amp; MIPS3_PG_D) | (tlb_lo[0] &amp; MIPS3_PG_V);</span>
 	entrylo1 = mips3_paddr_to_tlbpfn(pfn1 &lt;&lt; PAGE_SHIFT) | (0x3 &lt;&lt; 3) |
<span class="p_del">-			(tlb-&gt;tlb_lo1 &amp; MIPS3_PG_D) | (tlb-&gt;tlb_lo1 &amp; MIPS3_PG_V);</span>
<span class="p_add">+		(tlb_lo[1] &amp; MIPS3_PG_D) | (tlb_lo[1] &amp; MIPS3_PG_V);</span>
 
 	kvm_debug(&quot;@ %#lx tlb_lo0: 0x%08lx tlb_lo1: 0x%08lx\n&quot;, vcpu-&gt;arch.pc,
 		  tlb-&gt;tlb_lo0, tlb-&gt;tlb_lo1);
<span class="p_chunk">@@ -783,10 +801,16 @@</span> <span class="p_context"> uint32_t kvm_get_inst(uint32_t *opc, struct kvm_vcpu *vcpu)</span>
 				local_irq_restore(flags);
 				return KVM_INVALID_INST;
 			}
<span class="p_del">-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu,</span>
<span class="p_del">-							     &amp;vcpu-&gt;arch.</span>
<span class="p_del">-							     guest_tlb[index],</span>
<span class="p_del">-							     NULL, NULL);</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu,</span>
<span class="p_add">+						&amp;vcpu-&gt;arch.guest_tlb[index],</span>
<span class="p_add">+						NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault failed for %p, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, opc, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				kvm_mips_dump_guest_tlbs(vcpu);</span>
<span class="p_add">+				local_irq_restore(flags);</span>
<span class="p_add">+				return KVM_INVALID_INST;</span>
<span class="p_add">+			}</span>
 			inst = *(opc);
 		}
 		local_irq_restore(flags);
<span class="p_header">diff --git a/arch/mips/mm/sc-rm7k.c b/arch/mips/mm/sc-rm7k.c</span>
<span class="p_header">index 9ac1efcfbcc7..78f900c59276 100644</span>
<span class="p_header">--- a/arch/mips/mm/sc-rm7k.c</span>
<span class="p_header">+++ b/arch/mips/mm/sc-rm7k.c</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> static void rm7k_tc_disable(void)</span>
 	local_irq_save(flags);
 	blast_rm7k_tcache();
 	clear_c0_config(RM7K_CONF_TE);
<span class="p_del">-	local_irq_save(flags);</span>
<span class="p_add">+	local_irq_restore(flags);</span>
 }
 
 static void rm7k_sc_disable(void)
<span class="p_header">diff --git a/arch/mips/mti-malta/malta-setup.c b/arch/mips/mti-malta/malta-setup.c</span>
<span class="p_header">index db7c9e5826a6..89251e595d8a 100644</span>
<span class="p_header">--- a/arch/mips/mti-malta/malta-setup.c</span>
<span class="p_header">+++ b/arch/mips/mti-malta/malta-setup.c</span>
<span class="p_chunk">@@ -36,6 +36,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/console.h&gt;
 #endif
 
<span class="p_add">+#define ROCIT_CONFIG_GEN0		0x1f403000</span>
<span class="p_add">+#define  ROCIT_CONFIG_GEN0_PCI_IOCU	BIT(7)</span>
<span class="p_add">+</span>
 extern void malta_be_init(void);
 extern int malta_be_handler(struct pt_regs *regs, int is_fixup);
 
<span class="p_chunk">@@ -104,6 +107,8 @@</span> <span class="p_context"> static void __init fd_activate(void)</span>
 static int __init plat_enable_iocoherency(void)
 {
 	int supported = 0;
<span class="p_add">+	u32 cfg;</span>
<span class="p_add">+</span>
 	if (mips_revision_sconid == MIPS_REVISION_SCON_BONITO) {
 		if (BONITO_PCICACHECTRL &amp; BONITO_PCICACHECTRL_CPUCOH_PRES) {
 			BONITO_PCICACHECTRL |= BONITO_PCICACHECTRL_CPUCOH_EN;
<span class="p_chunk">@@ -126,7 +131,8 @@</span> <span class="p_context"> static int __init plat_enable_iocoherency(void)</span>
 	} else if (mips_cm_numiocu() != 0) {
 		/* Nothing special needs to be done to enable coherency */
 		pr_info(&quot;CMP IOCU detected\n&quot;);
<span class="p_del">-		if ((*(unsigned int *)0xbf403000 &amp; 0x81) != 0x81) {</span>
<span class="p_add">+		cfg = __raw_readl((u32 *)CKSEG1ADDR(ROCIT_CONFIG_GEN0));</span>
<span class="p_add">+		if (!(cfg &amp; ROCIT_CONFIG_GEN0_PCI_IOCU)) {</span>
 			pr_crit(&quot;IOCU OPERATION DISABLED BY SWITCH - DEFAULTING TO SW IO COHERENCY\n&quot;);
 			return 0;
 		}
<span class="p_header">diff --git a/arch/mips/net/bpf_jit.c b/arch/mips/net/bpf_jit.c</span>
<span class="p_header">index 32751a0bba58..0de0bf0a638c 100644</span>
<span class="p_header">--- a/arch/mips/net/bpf_jit.c</span>
<span class="p_header">+++ b/arch/mips/net/bpf_jit.c</span>
<span class="p_chunk">@@ -1365,7 +1365,7 @@</span> <span class="p_context"> void bpf_jit_compile(struct sk_filter *fp)</span>
 
 	memset(&amp;ctx, 0, sizeof(ctx));
 
<span class="p_del">-	ctx.offsets = kcalloc(fp-&gt;len, sizeof(*ctx.offsets), GFP_KERNEL);</span>
<span class="p_add">+	ctx.offsets = kcalloc(fp-&gt;len + 1, sizeof(*ctx.offsets), GFP_KERNEL);</span>
 	if (ctx.offsets == NULL)
 		return;
 
<span class="p_header">diff --git a/arch/mn10300/include/asm/uaccess.h b/arch/mn10300/include/asm/uaccess.h</span>
<span class="p_header">index 537278746a15..4af43d9ba495 100644</span>
<span class="p_header">--- a/arch/mn10300/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/mn10300/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -181,6 +181,7 @@</span> <span class="p_context"> struct __large_struct { unsigned long buf[100]; };</span>
 		&quot;2:\n&quot;						\
 		&quot;	.section	.fixup,\&quot;ax\&quot;\n&quot;	\
 		&quot;3:\n\t&quot;					\
<span class="p_add">+		&quot;	mov		0,%1\n&quot;			\</span>
 		&quot;	mov		%3,%0\n&quot;		\
 		&quot;	jmp		2b\n&quot;			\
 		&quot;	.previous\n&quot;				\
<span class="p_header">diff --git a/arch/mn10300/lib/usercopy.c b/arch/mn10300/lib/usercopy.c</span>
<span class="p_header">index 7826e6c364e7..ce8899e5e171 100644</span>
<span class="p_header">--- a/arch/mn10300/lib/usercopy.c</span>
<span class="p_header">+++ b/arch/mn10300/lib/usercopy.c</span>
<span class="p_chunk">@@ -9,7 +9,7 @@</span> <span class="p_context"></span>
  * as published by the Free Software Foundation; either version
  * 2 of the Licence, or (at your option) any later version.
  */
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 unsigned long
 __generic_copy_to_user(void *to, const void *from, unsigned long n)
<span class="p_chunk">@@ -24,6 +24,8 @@</span> <span class="p_context"> __generic_copy_from_user(void *to, const void *from, unsigned long n)</span>
 {
 	if (access_ok(VERIFY_READ, from, n))
 		__copy_user_zeroing(to, from, n);
<span class="p_add">+	else</span>
<span class="p_add">+		memset(to, 0, n);</span>
 	return n;
 }
 
<span class="p_header">diff --git a/arch/openrisc/include/asm/uaccess.h b/arch/openrisc/include/asm/uaccess.h</span>
<span class="p_header">index ab2e7a198a4c..d441480a4af4 100644</span>
<span class="p_header">--- a/arch/openrisc/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -273,28 +273,20 @@</span> <span class="p_context"> __copy_tofrom_user(void *to, const void *from, unsigned long size);</span>
 static inline unsigned long
 copy_from_user(void *to, const void *from, unsigned long n)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, n);</span>
<span class="p_del">-	if ((unsigned long)from &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)from + n - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, n - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return n;</span>
<span class="p_add">+	unsigned long res = n;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n)))</span>
<span class="p_add">+		res = __copy_tofrom_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
 }
 
 static inline unsigned long
 copy_to_user(void *to, const void *from, unsigned long n)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, to, n))</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, n);</span>
<span class="p_del">-	if ((unsigned long)to &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)to + n - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, n - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_WRITE, to, n)))</span>
<span class="p_add">+		n = __copy_tofrom_user(to, from, n);</span>
 	return n;
 }
 
<span class="p_chunk">@@ -303,13 +295,8 @@</span> <span class="p_context"> extern unsigned long __clear_user(void *addr, unsigned long size);</span>
 static inline __must_check unsigned long
 clear_user(void *addr, unsigned long size)
 {
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, addr, size))</span>
<span class="p_del">-		return __clear_user(addr, size);</span>
<span class="p_del">-	if ((unsigned long)addr &lt; TASK_SIZE) {</span>
<span class="p_del">-		unsigned long over = (unsigned long)addr + size - TASK_SIZE;</span>
<span class="p_del">-		return __clear_user(addr, size - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_WRITE, addr, size)))</span>
<span class="p_add">+		size = __clear_user(addr, size);</span>
 	return size;
 }
 
<span class="p_header">diff --git a/arch/parisc/include/asm/uaccess.h b/arch/parisc/include/asm/uaccess.h</span>
<span class="p_header">index de2db1910755..9392458b6e86 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -9,6 +9,8 @@</span> <span class="p_context"></span>
 #include &lt;asm/errno.h&gt;
 #include &lt;asm-generic/uaccess-unaligned.h&gt;
 
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
<span class="p_add">+</span>
 #define VERIFY_READ 0
 #define VERIFY_WRITE 1
 
<span class="p_chunk">@@ -248,13 +250,14 @@</span> <span class="p_context"> static inline unsigned long __must_check copy_from_user(void *to,</span>
                                           unsigned long n)
 {
         int sz = __compiletime_object_size(to);
<span class="p_del">-        int ret = -EFAULT;</span>
<span class="p_add">+        unsigned long ret = n;</span>
 
         if (likely(sz == -1 || !__builtin_constant_p(n) || sz &gt;= n))
                 ret = __copy_from_user(to, from, n);
         else
                 copy_from_user_overflow();
<span class="p_del">-</span>
<span class="p_add">+	if (unlikely(ret))</span>
<span class="p_add">+		memset(to + (n - ret), 0, ret);</span>
         return ret;
 }
 
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_header">index c0ae62520d15..274d5bc6ecce 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_chunk">@@ -97,10 +97,10 @@</span> <span class="p_context"></span>
 #define	ENOTCONN	235	/* Transport endpoint is not connected */
 #define	ESHUTDOWN	236	/* Cannot send after transport endpoint shutdown */
 #define	ETOOMANYREFS	237	/* Too many references: cannot splice */
<span class="p_del">-#define EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
 #define	ETIMEDOUT	238	/* Connection timed out */
 #define	ECONNREFUSED	239	/* Connection refused */
<span class="p_del">-#define EREMOTERELEASE	240	/* Remote peer released connection */</span>
<span class="p_add">+#define	EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
<span class="p_add">+#define	EREMOTERELEASE	240	/* Remote peer released connection */</span>
 #define	EHOSTDOWN	241	/* Host is down */
 #define	EHOSTUNREACH	242	/* No route to host */
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/pci-bridge.h b/arch/powerpc/include/asm/pci-bridge.h</span>
<span class="p_header">index 4ca90a39d6d0..1c92606ca792 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/pci-bridge.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/pci-bridge.h</span>
<span class="p_chunk">@@ -246,6 +246,7 @@</span> <span class="p_context"> extern void pci_process_bridge_OF_ranges(struct pci_controller *hose,</span>
 /* Allocate &amp; free a PCI host bridge structure */
 extern struct pci_controller *pcibios_alloc_controller(struct device_node *dev);
 extern void pcibios_free_controller(struct pci_controller *phb);
<span class="p_add">+extern void pcibios_free_controller_deferred(struct pci_host_bridge *bridge);</span>
 
 #ifdef CONFIG_PCI
 extern int pcibios_vaddr_is_ioport(void __iomem *address);
<span class="p_header">diff --git a/arch/powerpc/include/asm/uaccess.h b/arch/powerpc/include/asm/uaccess.h</span>
<span class="p_header">index 9485b43a7c00..46c486599645 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -323,30 +323,17 @@</span> <span class="p_context"> extern unsigned long __copy_tofrom_user(void __user *to,</span>
 static inline unsigned long copy_from_user(void *to,
 		const void __user *from, unsigned long n)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n)))</span>
 		return __copy_tofrom_user((__force void __user *)to, from, n);
<span class="p_del">-	if ((unsigned long)from &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)from + n - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user((__force void __user *)to, from,</span>
<span class="p_del">-				n - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	memset(to, 0, n);</span>
 	return n;
 }
 
 static inline unsigned long copy_to_user(void __user *to,
 		const void *from, unsigned long n)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
 	if (access_ok(VERIFY_WRITE, to, n))
 		return __copy_tofrom_user(to, (__force void __user *)from, n);
<span class="p_del">-	if ((unsigned long)to &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)to + n - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, (__force void __user *)from,</span>
<span class="p_del">-				n - over) + over;</span>
<span class="p_del">-	}</span>
 	return n;
 }
 
<span class="p_chunk">@@ -437,10 +424,6 @@</span> <span class="p_context"> static inline unsigned long clear_user(void __user *addr, unsigned long size)</span>
 	might_fault();
 	if (likely(access_ok(VERIFY_WRITE, addr, size)))
 		return __clear_user(addr, size);
<span class="p_del">-	if ((unsigned long)addr &lt; TASK_SIZE) {</span>
<span class="p_del">-		unsigned long over = (unsigned long)addr + size - TASK_SIZE;</span>
<span class="p_del">-		return __clear_user(addr, size - over) + over;</span>
<span class="p_del">-	}</span>
 	return size;
 }
 
<span class="p_header">diff --git a/arch/powerpc/kernel/exceptions-64s.S b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">index 9ff25dcbfb87..7d8a755f5558 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_chunk">@@ -153,29 +153,14 @@</span> <span class="p_context"> machine_check_pSeries_1:</span>
 	 */
 	HMT_MEDIUM_PPR_DISCARD
 	SET_SCRATCH0(r13)		/* save r13 */
<span class="p_del">-#ifdef CONFIG_PPC_P7_NAP</span>
<span class="p_del">-BEGIN_FTR_SECTION</span>
<span class="p_del">-	/* Running native on arch 2.06 or later, check if we are</span>
<span class="p_del">-	 * waking up from nap. We only handle no state loss and</span>
<span class="p_del">-	 * supervisor state loss. We do -not- handle hypervisor</span>
<span class="p_del">-	 * state loss at this time.</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Running native on arch 2.06 or later, we may wakeup from winkle</span>
<span class="p_add">+	 * inside machine check. If yes, then last bit of HSPGR0 would be set</span>
<span class="p_add">+	 * to 1. Hence clear it unconditionally.</span>
 	 */
<span class="p_del">-	mfspr	r13,SPRN_SRR1</span>
<span class="p_del">-	rlwinm.	r13,r13,47-31,30,31</span>
<span class="p_del">-	OPT_GET_SPR(r13, SPRN_CFAR, CPU_FTR_CFAR)</span>
<span class="p_del">-	beq	9f</span>
<span class="p_del">-</span>
<span class="p_del">-	mfspr	r13,SPRN_SRR1</span>
<span class="p_del">-	rlwinm.	r13,r13,47-31,30,31</span>
<span class="p_del">-	/* waking up from powersave (nap) state */</span>
<span class="p_del">-	cmpwi	cr1,r13,2</span>
<span class="p_del">-	/* Total loss of HV state is fatal. let&#39;s just stay stuck here */</span>
<span class="p_del">-	OPT_GET_SPR(r13, SPRN_CFAR, CPU_FTR_CFAR)</span>
<span class="p_del">-	bgt	cr1,.</span>
<span class="p_del">-9:</span>
<span class="p_del">-	OPT_SET_SPR(r13, SPRN_CFAR, CPU_FTR_CFAR)</span>
<span class="p_del">-END_FTR_SECTION_IFSET(CPU_FTR_HVMODE | CPU_FTR_ARCH_206)</span>
<span class="p_del">-#endif /* CONFIG_PPC_P7_NAP */</span>
<span class="p_add">+	GET_PACA(r13)</span>
<span class="p_add">+	clrrdi	r13,r13,1</span>
<span class="p_add">+	SET_PACA(r13)</span>
 	EXCEPTION_PROLOG_0(PACA_EXMC)
 BEGIN_FTR_SECTION
 	b	machine_check_pSeries_early
<span class="p_chunk">@@ -1418,17 +1403,17 @@</span> <span class="p_context"> machine_check_handle_early:</span>
 	 * Check if thread was in power saving mode. We come here when any
 	 * of the following is true:
 	 * a. thread wasn&#39;t in power saving mode
<span class="p_del">-	 * b. thread was in power saving mode with no state loss or</span>
<span class="p_del">-	 *    supervisor state loss</span>
<span class="p_add">+	 * b. thread was in power saving mode with no state loss,</span>
<span class="p_add">+	 *    supervisor state loss or hypervisor state loss.</span>
 	 *
<span class="p_del">-	 * Go back to nap again if (b) is true.</span>
<span class="p_add">+	 * Go back to nap/sleep/winkle mode again if (b) is true.</span>
 	 */
 	rlwinm.	r11,r12,47-31,30,31	/* Was it in power saving mode? */
 	beq	4f			/* No, it wasn;t */
 	/* Thread was in power saving mode. Go back to nap again. */
 	cmpwi	r11,2
<span class="p_del">-	bne	3f</span>
<span class="p_del">-	/* Supervisor state loss */</span>
<span class="p_add">+	blt	3f</span>
<span class="p_add">+	/* Supervisor/Hypervisor state loss */</span>
 	li	r0,1
 	stb	r0,PACA_NAPSTATELOST(r13)
 3:	bl	machine_check_queue_event
<span class="p_header">diff --git a/arch/powerpc/kernel/mce.c b/arch/powerpc/kernel/mce.c</span>
<span class="p_header">index a7fd4cb78b78..1c75f9777ce3 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/mce.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/mce.c</span>
<span class="p_chunk">@@ -92,7 +92,8 @@</span> <span class="p_context"> void save_mce_event(struct pt_regs *regs, long handled,</span>
 	mce-&gt;in_use = 1;
 
 	mce-&gt;initiator = MCE_INITIATOR_CPU;
<span class="p_del">-	if (handled)</span>
<span class="p_add">+	/* Mark it recovered if we have handled it and MSR(RI=1). */</span>
<span class="p_add">+	if (handled &amp;&amp; (regs-&gt;msr &amp; MSR_RI))</span>
 		mce-&gt;disposition = MCE_DISPOSITION_RECOVERED;
 	else
 		mce-&gt;disposition = MCE_DISPOSITION_NOT_RECOVERED;
<span class="p_header">diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c</span>
<span class="p_header">index b49c72fd7f16..d4f779654f1d 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/pci-common.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/pci-common.c</span>
<span class="p_chunk">@@ -102,6 +102,42 @@</span> <span class="p_context"> void pcibios_free_controller(struct pci_controller *phb)</span>
 }
 
 /*
<span class="p_add">+ * This function is used to call pcibios_free_controller()</span>
<span class="p_add">+ * in a deferred manner: a callback from the PCI subsystem.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * _*DO NOT*_ call pcibios_free_controller() explicitly if</span>
<span class="p_add">+ * this is used (or it may access an invalid *phb pointer).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The callback occurs when all references to the root bus</span>
<span class="p_add">+ * are dropped (e.g., child buses/devices and their users).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It&#39;s called as .release_fn() of &#39;struct pci_host_bridge&#39;</span>
<span class="p_add">+ * which is associated with the &#39;struct pci_controller.bus&#39;</span>
<span class="p_add">+ * (root bus) - it expects .release_data to hold a pointer</span>
<span class="p_add">+ * to &#39;struct pci_controller&#39;.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to use it, register .release_fn()/release_data</span>
<span class="p_add">+ * like this:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * pci_set_host_bridge_release(bridge,</span>
<span class="p_add">+ *                             pcibios_free_controller_deferred</span>
<span class="p_add">+ *                             (void *) phb);</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * e.g. in the pcibios_root_bridge_prepare() callback from</span>
<span class="p_add">+ * pci_create_root_bus().</span>
<span class="p_add">+ */</span>
<span class="p_add">+void pcibios_free_controller_deferred(struct pci_host_bridge *bridge)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_controller *phb = (struct pci_controller *)</span>
<span class="p_add">+					 bridge-&gt;release_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;domain %d, dynamic %d\n&quot;, phb-&gt;global_number, phb-&gt;is_dynamic);</span>
<span class="p_add">+</span>
<span class="p_add">+	pcibios_free_controller(phb);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(pcibios_free_controller_deferred);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * The function is used to return the minimal alignment
  * for memory or I/O windows of the associated P2P bridge.
  * By default, 4KiB alignment for I/O windows and 1MiB for
<span class="p_header">diff --git a/arch/powerpc/kernel/prom_init.c b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">index 1a85d8f96739..69be680f7184 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_chunk">@@ -685,7 +685,7 @@</span> <span class="p_context"> unsigned char ibm_architecture_vec[] = {</span>
 	OV4_MIN_ENT_CAP,		/* minimum VP entitled capacity */
 
 	/* option vector 5: PAPR/OF options */
<span class="p_del">-	19 - 2,				/* length */</span>
<span class="p_add">+	22 - 2,				/* length */</span>
 	0,				/* don&#39;t ignore, don&#39;t halt */
 	OV5_FEAT(OV5_LPAR) | OV5_FEAT(OV5_SPLPAR) | OV5_FEAT(OV5_LARGE_PAGES) |
 	OV5_FEAT(OV5_DRCONF_MEMORY) | OV5_FEAT(OV5_DONATE_DEDICATE_CPU) |
<span class="p_chunk">@@ -716,8 +716,11 @@</span> <span class="p_context"> unsigned char ibm_architecture_vec[] = {</span>
 	0,
 	0,
 	OV5_FEAT(OV5_PFO_HW_RNG) | OV5_FEAT(OV5_PFO_HW_ENCR) |
<span class="p_del">-	OV5_FEAT(OV5_PFO_HW_842),</span>
<span class="p_del">-	OV5_FEAT(OV5_SUB_PROCESSORS),</span>
<span class="p_add">+	OV5_FEAT(OV5_PFO_HW_842),				/* Byte 17 */</span>
<span class="p_add">+	0,							/* Byte 18 */</span>
<span class="p_add">+	0,							/* Byte 19 */</span>
<span class="p_add">+	0,							/* Byte 20 */</span>
<span class="p_add">+	OV5_FEAT(OV5_SUB_PROCESSORS),				/* Byte 21 */</span>
 	/* option vector 6: IBM PAPR hints */
 	4 - 2,				/* length */
 	0,
<span class="p_header">diff --git a/arch/powerpc/kernel/tm.S b/arch/powerpc/kernel/tm.S</span>
<span class="p_header">index f81d900a562a..08225a352477 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/tm.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/tm.S</span>
<span class="p_chunk">@@ -338,8 +338,6 @@</span> <span class="p_context"> _GLOBAL(__tm_recheckpoint)</span>
 	 */
 	subi	r7, r7, STACK_FRAME_OVERHEAD
 
<span class="p_del">-	SET_SCRATCH0(r1)</span>
<span class="p_del">-</span>
 	mfmsr	r6
 	/* R4 = original MSR to indicate whether thread used FP/Vector etc. */
 
<span class="p_chunk">@@ -468,6 +466,7 @@</span> <span class="p_context"> restore_gprs:</span>
 	 * until we turn MSR RI back on.
 	 */
 
<span class="p_add">+	SET_SCRATCH0(r1)</span>
 	ld	r5, -8(r1)
 	ld	r1, -16(r1)
 
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal-dump.c b/arch/powerpc/platforms/powernv/opal-dump.c</span>
<span class="p_header">index 788a1977b9a5..2f420f9e4c54 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal-dump.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal-dump.c</span>
<span class="p_chunk">@@ -365,6 +365,7 @@</span> <span class="p_context"> static int process_dump(void)</span>
 	uint32_t dump_id, dump_size, dump_type;
 	struct dump_obj *dump;
 	char name[22];
<span class="p_add">+	struct kobject *kobj;</span>
 
 	rc = dump_read_info(&amp;dump_id, &amp;dump_size, &amp;dump_type);
 	if (rc != OPAL_SUCCESS)
<span class="p_chunk">@@ -376,8 +377,12 @@</span> <span class="p_context"> static int process_dump(void)</span>
 	 * that gracefully and not create two conflicting
 	 * entries.
 	 */
<span class="p_del">-	if (kset_find_obj(dump_kset, name))</span>
<span class="p_add">+	kobj = kset_find_obj(dump_kset, name);</span>
<span class="p_add">+	if (kobj) {</span>
<span class="p_add">+		/* Drop reference added by kset_find_obj() */</span>
<span class="p_add">+		kobject_put(kobj);</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	dump = create_dump_obj(dump_id, dump_size, dump_type);
 	if (!dump)
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal-elog.c b/arch/powerpc/platforms/powernv/opal-elog.c</span>
<span class="p_header">index 0ad533b617f7..c4ae2958de9c 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal-elog.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal-elog.c</span>
<span class="p_chunk">@@ -246,6 +246,7 @@</span> <span class="p_context"> static void elog_work_fn(struct work_struct *work)</span>
 	uint64_t elog_type;
 	int rc;
 	char name[2+16+1];
<span class="p_add">+	struct kobject *kobj;</span>
 
 	rc = opal_get_elog_size(&amp;id, &amp;size, &amp;type);
 	if (rc != OPAL_SUCCESS) {
<span class="p_chunk">@@ -268,8 +269,12 @@</span> <span class="p_context"> static void elog_work_fn(struct work_struct *work)</span>
 	 * that gracefully and not create two conflicting
 	 * entries.
 	 */
<span class="p_del">-	if (kset_find_obj(elog_kset, name))</span>
<span class="p_add">+	kobj = kset_find_obj(elog_kset, name);</span>
<span class="p_add">+	if (kobj) {</span>
<span class="p_add">+		/* Drop reference added by kset_find_obj() */</span>
<span class="p_add">+		kobject_put(kobj);</span>
 		return;
<span class="p_add">+	}</span>
 
 	create_elog_obj(log_id, elog_size, elog_type);
 }
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal.c b/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_header">index 0fa7178d36dc..12833e486d9b 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_chunk">@@ -459,6 +459,7 @@</span> <span class="p_context"> static int opal_recover_mce(struct pt_regs *regs,</span>
 
 	if (!(regs-&gt;msr &amp; MSR_RI)) {
 		/* If MSR_RI isn&#39;t set, we cannot recover */
<span class="p_add">+		pr_err(&quot;Machine check interrupt unrecoverable: MSR(RI=0)\n&quot;);</span>
 		recovered = 0;
 	} else if (evt-&gt;disposition == MCE_DISPOSITION_RECOVERED) {
 		/* Platform corrected itself */
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/pci.c b/arch/powerpc/platforms/pseries/pci.c</span>
<span class="p_header">index c413ec158ff5..1017734bdc78 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/pci.c</span>
<span class="p_chunk">@@ -118,6 +118,10 @@</span> <span class="p_context"> int pseries_root_bridge_prepare(struct pci_host_bridge *bridge)</span>
 
 	bus = bridge-&gt;bus;
 
<span class="p_add">+	/* Rely on the pcibios_free_controller_deferred() callback. */</span>
<span class="p_add">+	pci_set_host_bridge_release(bridge, pcibios_free_controller_deferred,</span>
<span class="p_add">+					(void *) pci_bus_to_host(bus));</span>
<span class="p_add">+</span>
 	dn = pcibios_get_phb_of_node(bus);
 	if (!dn)
 		return 0;
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/pci_dlpar.c b/arch/powerpc/platforms/pseries/pci_dlpar.c</span>
<span class="p_header">index 89e23811199c..e161a25bc64b 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/pci_dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/pci_dlpar.c</span>
<span class="p_chunk">@@ -135,8 +135,11 @@</span> <span class="p_context"> int remove_phb_dynamic(struct pci_controller *phb)</span>
 		release_resource(res);
 	}
 
<span class="p_del">-	/* Free pci_controller data structure */</span>
<span class="p_del">-	pcibios_free_controller(phb);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The pci_controller data structure is freed by</span>
<span class="p_add">+	 * the pcibios_free_controller_deferred() callback;</span>
<span class="p_add">+	 * see pseries_root_bridge_prepare().</span>
<span class="p_add">+	 */</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/s390/include/asm/elf.h b/arch/s390/include/asm/elf.h</span>
<span class="p_header">index 78f4f8711d58..977afc2674e2 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/elf.h</span>
<span class="p_chunk">@@ -210,6 +210,7 @@</span> <span class="p_context"> do {								\</span>
 
 #define STACK_RND_MASK	0x7ffUL
 
<span class="p_add">+/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
 #define ARCH_DLINFO							    \
 do {									    \
 	if (vdso_enabled)						    \
<span class="p_header">diff --git a/arch/s390/include/asm/tlbflush.h b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">index 16c9c88658c8..1f2fa85091ce 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -88,7 +88,8 @@</span> <span class="p_context"> static inline void __tlb_flush_full(struct mm_struct *mm)</span>
 }
 
 /*
<span class="p_del">- * Flush TLB entries for a specific ASCE on all CPUs.</span>
<span class="p_add">+ * Flush TLB entries for a specific ASCE on all CPUs. Should never be used</span>
<span class="p_add">+ * when more than one asce (e.g. gmap) ran on this mm.</span>
  */
 static inline void __tlb_flush_asce(struct mm_struct *mm, unsigned long asce)
 {
<span class="p_header">diff --git a/arch/s390/include/asm/uaccess.h b/arch/s390/include/asm/uaccess.h</span>
<span class="p_header">index cd4c68e0398d..528f08c1d584 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -213,28 +213,28 @@</span> <span class="p_context"> int __put_user_bad(void) __attribute__((noreturn));</span>
 	__chk_user_ptr(ptr);					\
 	switch (sizeof(*(ptr))) {				\
 	case 1: {						\
<span class="p_del">-		unsigned char __x;				\</span>
<span class="p_add">+		unsigned char __x = 0;				\</span>
 		__gu_err = __get_user_fn(&amp;__x, ptr,		\
 					 sizeof(*(ptr)));	\
 		(x) = *(__force __typeof__(*(ptr)) *) &amp;__x;	\
 		break;						\
 	};							\
 	case 2: {						\
<span class="p_del">-		unsigned short __x;				\</span>
<span class="p_add">+		unsigned short __x = 0;				\</span>
 		__gu_err = __get_user_fn(&amp;__x, ptr,		\
 					 sizeof(*(ptr)));	\
 		(x) = *(__force __typeof__(*(ptr)) *) &amp;__x;	\
 		break;						\
 	};							\
 	case 4: {						\
<span class="p_del">-		unsigned int __x;				\</span>
<span class="p_add">+		unsigned int __x = 0;				\</span>
 		__gu_err = __get_user_fn(&amp;__x, ptr,		\
 					 sizeof(*(ptr)));	\
 		(x) = *(__force __typeof__(*(ptr)) *) &amp;__x;	\
 		break;						\
 	};							\
 	case 8: {						\
<span class="p_del">-		unsigned long long __x;				\</span>
<span class="p_add">+		unsigned long long __x = 0;			\</span>
 		__gu_err = __get_user_fn(&amp;__x, ptr,		\
 					 sizeof(*(ptr)));	\
 		(x) = *(__force __typeof__(*(ptr)) *) &amp;__x;	\
<span class="p_header">diff --git a/arch/s390/include/uapi/asm/auxvec.h b/arch/s390/include/uapi/asm/auxvec.h</span>
<span class="p_header">index a1f153e89133..c53e08442255 100644</span>
<span class="p_header">--- a/arch/s390/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/s390/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -3,4 +3,6 @@</span> <span class="p_context"></span>
 
 #define AT_SYSINFO_EHDR		33
 
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH 1 /* entries in ARCH_DLINFO */</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/s390/mm/pgtable.c b/arch/s390/mm/pgtable.c</span>
<span class="p_header">index 98eeb823342c..80fcdfb8a810 100644</span>
<span class="p_header">--- a/arch/s390/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/s390/mm/pgtable.c</span>
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> static int gmap_unlink_segment(struct gmap *gmap, unsigned long *table)</span>
 static void gmap_flush_tlb(struct gmap *gmap)
 {
 	if (MACHINE_HAS_IDTE)
<span class="p_del">-		__tlb_flush_asce(gmap-&gt;mm, (unsigned long) gmap-&gt;table |</span>
<span class="p_add">+		__tlb_flush_idte((unsigned long) gmap-&gt;table |</span>
 				 _ASCE_TYPE_REGION1);
 	else
 		__tlb_flush_global();
<span class="p_chunk">@@ -221,7 +221,7 @@</span> <span class="p_context"> void gmap_free(struct gmap *gmap)</span>
 
 	/* Flush tlb. */
 	if (MACHINE_HAS_IDTE)
<span class="p_del">-		__tlb_flush_asce(gmap-&gt;mm, (unsigned long) gmap-&gt;table |</span>
<span class="p_add">+		__tlb_flush_idte((unsigned long) gmap-&gt;table |</span>
 				 _ASCE_TYPE_REGION1);
 	else
 		__tlb_flush_global();
<span class="p_header">diff --git a/arch/score/include/asm/uaccess.h b/arch/score/include/asm/uaccess.h</span>
<span class="p_header">index ab66ddde777b..69326dfb894d 100644</span>
<span class="p_header">--- a/arch/score/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/score/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> do {									\</span>
 		__get_user_asm(val, &quot;lw&quot;, ptr);				\
 		 break;							\
 	case 8: 							\
<span class="p_del">-		if ((copy_from_user((void *)&amp;val, ptr, 8)) == 0)	\</span>
<span class="p_add">+		if (__copy_from_user((void *)&amp;val, ptr, 8) == 0)	\</span>
 			__gu_err = 0;					\
 		else							\
 			__gu_err = -EFAULT;				\
<span class="p_chunk">@@ -183,6 +183,8 @@</span> <span class="p_context"> do {									\</span>
 									\
 	if (likely(access_ok(VERIFY_READ, __gu_ptr, size)))		\
 		__get_user_common((x), size, __gu_ptr);			\
<span class="p_add">+	else								\</span>
<span class="p_add">+		(x) = 0;						\</span>
 									\
 	__gu_err;							\
 })
<span class="p_chunk">@@ -196,6 +198,7 @@</span> <span class="p_context"> do {									\</span>
 		&quot;2:\n&quot;							\
 		&quot;.section .fixup,\&quot;ax\&quot;\n&quot;				\
 		&quot;3:li	%0, %4\n&quot;					\
<span class="p_add">+		&quot;li	%1, 0\n&quot;					\</span>
 		&quot;j	2b\n&quot;						\
 		&quot;.previous\n&quot;						\
 		&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\
<span class="p_chunk">@@ -293,35 +296,34 @@</span> <span class="p_context"> extern int __copy_tofrom_user(void *to, const void *from, unsigned long len);</span>
 static inline unsigned long
 copy_from_user(void *to, const void *from, unsigned long len)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_add">+	unsigned long res = len;</span>
 
<span class="p_del">-	if (access_ok(VERIFY_READ, from, len))</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, len);</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, len)))</span>
<span class="p_add">+		res = __copy_tofrom_user(to, from, len);</span>
 
<span class="p_del">-	if ((unsigned long)from &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)from + len - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, len - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return len;</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (len - res), 0, res);</span>
<span class="p_add">+</span>
<span class="p_add">+	return res;</span>
 }
 
 static inline unsigned long
 copy_to_user(void *to, const void *from, unsigned long len)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, to, len))</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, len);</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_WRITE, to, len)))</span>
<span class="p_add">+		len = __copy_tofrom_user(to, from, len);</span>
 
<span class="p_del">-	if ((unsigned long)to &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)to + len - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, len - over) + over;</span>
<span class="p_del">-	}</span>
 	return len;
 }
 
<span class="p_del">-#define __copy_from_user(to, from, len)	\</span>
<span class="p_del">-		__copy_tofrom_user((to), (from), (len))</span>
<span class="p_add">+static inline unsigned long</span>
<span class="p_add">+__copy_from_user(void *to, const void *from, unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long left = __copy_tofrom_user(to, from, len);</span>
<span class="p_add">+	if (unlikely(left))</span>
<span class="p_add">+		memset(to + (len - left), 0, left);</span>
<span class="p_add">+	return left;</span>
<span class="p_add">+}</span>
 
 #define __copy_to_user(to, from, len)		\
 		__copy_tofrom_user((to), (from), (len))
<span class="p_chunk">@@ -335,17 +337,17 @@</span> <span class="p_context"> __copy_to_user_inatomic(void *to, const void *from, unsigned long len)</span>
 static inline unsigned long
 __copy_from_user_inatomic(void *to, const void *from, unsigned long len)
 {
<span class="p_del">-	return __copy_from_user(to, from, len);</span>
<span class="p_add">+	return __copy_tofrom_user(to, from, len);</span>
 }
 
<span class="p_del">-#define __copy_in_user(to, from, len)	__copy_from_user(to, from, len)</span>
<span class="p_add">+#define __copy_in_user(to, from, len)	__copy_tofrom_user(to, from, len)</span>
 
 static inline unsigned long
 copy_in_user(void *to, const void *from, unsigned long len)
 {
 	if (access_ok(VERIFY_READ, from, len) &amp;&amp;
 		      access_ok(VERFITY_WRITE, to, len))
<span class="p_del">-		return copy_from_user(to, from, len);</span>
<span class="p_add">+		return __copy_tofrom_user(to, from, len);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/sh/include/asm/uaccess.h b/arch/sh/include/asm/uaccess.h</span>
<span class="p_header">index 9486376605f4..c04cc18ae9cd 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -151,7 +151,10 @@</span> <span class="p_context"> copy_from_user(void *to, const void __user *from, unsigned long n)</span>
 	__kernel_size_t __copy_size = (__kernel_size_t) n;
 
 	if (__copy_size &amp;&amp; __access_ok(__copy_from, __copy_size))
<span class="p_del">-		return __copy_user(to, from, __copy_size);</span>
<span class="p_add">+		__copy_size = __copy_user(to, from, __copy_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(__copy_size))</span>
<span class="p_add">+		memset(to + (n - __copy_size), 0, __copy_size);</span>
 
 	return __copy_size;
 }
<span class="p_header">diff --git a/arch/sh/include/asm/uaccess_64.h b/arch/sh/include/asm/uaccess_64.h</span>
<span class="p_header">index 2e07e0f40c6a..a2f9d0531328 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/uaccess_64.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/uaccess_64.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #define __get_user_size(x,ptr,size,retval)			\
 do {								\
 	retval = 0;						\
<span class="p_add">+	x = 0;							\</span>
 	switch (size) {						\
 	case 1:							\
 		retval = __get_user_asm_b((void *)&amp;x,		\
<span class="p_header">diff --git a/arch/sparc/include/asm/uaccess_32.h b/arch/sparc/include/asm/uaccess_32.h</span>
<span class="p_header">index 9634d086fc56..79b03872e165 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/uaccess_32.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/uaccess_32.h</span>
<span class="p_chunk">@@ -265,8 +265,10 @@</span> <span class="p_context"> static inline unsigned long copy_from_user(void *to, const void __user *from, un</span>
 {
 	if (n &amp;&amp; __access_ok((unsigned long) from, n))
 		return __copy_user((__force void __user *) to, from, n);
<span class="p_del">-	else</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		memset(to, 0, n);</span>
 		return n;
<span class="p_add">+	}</span>
 }
 
 static inline unsigned long __copy_from_user(void *to, const void __user *from, unsigned long n)
<span class="p_header">diff --git a/arch/tile/include/asm/elf.h b/arch/tile/include/asm/elf.h</span>
<span class="p_header">index 41d9878a9686..581f1414b6ca 100644</span>
<span class="p_header">--- a/arch/tile/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/tile/include/asm/elf.h</span>
<span class="p_chunk">@@ -131,6 +131,7 @@</span> <span class="p_context"> extern int dump_task_regs(struct task_struct *, elf_gregset_t *);</span>
 struct linux_binprm;
 extern int arch_setup_additional_pages(struct linux_binprm *bprm,
 				       int executable_stack);
<span class="p_add">+/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
 #define ARCH_DLINFO \
 do { \
 	NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_BASE); \
<span class="p_header">diff --git a/arch/tile/include/uapi/asm/auxvec.h b/arch/tile/include/uapi/asm/auxvec.h</span>
<span class="p_header">index c93e92709f14..f497123ed980 100644</span>
<span class="p_header">--- a/arch/tile/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/tile/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -18,4 +18,6 @@</span> <span class="p_context"></span>
 /* The vDSO location. */
 #define AT_SYSINFO_EHDR         33
 
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH 1 /* entries in ARCH_DLINFO */</span>
<span class="p_add">+</span>
 #endif /* _ASM_TILE_AUXVEC_H */
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">index b77310833b03..cec4d620843e 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_chunk">@@ -1266,7 +1266,7 @@</span> <span class="p_context"> static efi_status_t exit_boot(struct boot_params *boot_params,</span>
 			      void *handle, bool is64)
 {
 	struct efi_info *efi = &amp;boot_params-&gt;efi_info;
<span class="p_del">-	unsigned long map_sz, key, desc_size;</span>
<span class="p_add">+	unsigned long map_sz, key, desc_size, buff_size;</span>
 	efi_memory_desc_t *mem_map;
 	struct setup_data *e820ext;
 	const char *signature;
<span class="p_chunk">@@ -1277,14 +1277,20 @@</span> <span class="p_context"> static efi_status_t exit_boot(struct boot_params *boot_params,</span>
 	bool called_exit = false;
 	u8 nr_entries;
 	int i;
<span class="p_del">-</span>
<span class="p_del">-	nr_desc = 0;</span>
<span class="p_del">-	e820ext = NULL;</span>
<span class="p_del">-	e820ext_size = 0;</span>
<span class="p_add">+	struct efi_boot_memmap map;</span>
<span class="p_add">+</span>
<span class="p_add">+	nr_desc =	0;</span>
<span class="p_add">+	e820ext =	NULL;</span>
<span class="p_add">+	e820ext_size =	0;</span>
<span class="p_add">+	map.map =	&amp;mem_map;</span>
<span class="p_add">+	map.map_size =	&amp;map_sz;</span>
<span class="p_add">+	map.desc_size =	&amp;desc_size;</span>
<span class="p_add">+	map.desc_ver =	&amp;desc_version;</span>
<span class="p_add">+	map.key_ptr =	&amp;key;</span>
<span class="p_add">+	map.buff_size =	&amp;buff_size;</span>
 
 get_map:
<span class="p_del">-	status = efi_get_memory_map(sys_table, &amp;mem_map, &amp;map_sz, &amp;desc_size,</span>
<span class="p_del">-				    &amp;desc_version, &amp;key);</span>
<span class="p_add">+	status = efi_get_memory_map(sys_table, &amp;map);</span>
 
 	if (status != EFI_SUCCESS)
 		return status;
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 04905bfc508b..5e4b0cc54e43 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -17,7 +17,14 @@</span> <span class="p_context"></span>
 
 static inline void __native_flush_tlb(void)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If current-&gt;mm == NULL then we borrow a mm which may change during a</span>
<span class="p_add">+	 * task switch and therefore we must not be preempted while we write CR3</span>
<span class="p_add">+	 * back:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	preempt_disable();</span>
 	native_write_cr3(native_read_cr3());
<span class="p_add">+	preempt_enable();</span>
 }
 
 static inline void __native_flush_tlb_global_irq_disabled(void)
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">index c385d14dadc3..42937ccb8573 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic.c</span>
<span class="p_chunk">@@ -1615,6 +1615,9 @@</span> <span class="p_context"> void __init enable_IR_x2apic(void)</span>
 	int ret, x2apic_enabled = 0;
 	int hardware_init_ret;
 
<span class="p_add">+	if (skip_ioapic_setup)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* Make sure irq_remap_ops are initialized */
 	setup_irq_remapping_ops();
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">index edefacacc2cc..80e35e8522e4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_chunk">@@ -522,6 +522,17 @@</span> <span class="p_context"> static const int amd_erratum_383[];</span>
 static const int amd_erratum_400[];
 static bool cpu_has_amd_erratum(struct cpuinfo_x86 *cpu, const int *erratum);
 
<span class="p_add">+#define MSR_AMD64_DE_CFG	0xC0011029</span>
<span class="p_add">+</span>
<span class="p_add">+static void init_amd_ln(struct cpuinfo_x86 *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Apply erratum 665 fix unconditionally so machines without a BIOS</span>
<span class="p_add">+	 * fix work.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	msr_set_bit(MSR_AMD64_DE_CFG, 31);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void init_amd(struct cpuinfo_x86 *c)
 {
 	u32 dummy;
<span class="p_chunk">@@ -614,6 +625,9 @@</span> <span class="p_context"> static void init_amd(struct cpuinfo_x86 *c)</span>
 		}
 	}
 
<span class="p_add">+	if (c-&gt;x86 == 0x12)</span>
<span class="p_add">+		init_amd_ln(c);</span>
<span class="p_add">+</span>
 	/* re-enable TopologyExtensions if switched off by BIOS */
 	if ((c-&gt;x86 == 0x15) &amp;&amp;
 	    (c-&gt;x86_model &gt;= 0x10) &amp;&amp; (c-&gt;x86_model &lt;= 0x1f) &amp;&amp;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_amd.c b/arch/x86/kernel/cpu/perf_event_amd.c</span>
<span class="p_header">index beeb7cc07044..dc4c3b89c3f5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_amd.c</span>
<span class="p_chunk">@@ -119,8 +119,8 @@</span> <span class="p_context"> static const u64 amd_perfmon_event_map[] =</span>
 {
   [PERF_COUNT_HW_CPU_CYCLES]			= 0x0076,
   [PERF_COUNT_HW_INSTRUCTIONS]			= 0x00c0,
<span class="p_del">-  [PERF_COUNT_HW_CACHE_REFERENCES]		= 0x0080,</span>
<span class="p_del">-  [PERF_COUNT_HW_CACHE_MISSES]			= 0x0081,</span>
<span class="p_add">+  [PERF_COUNT_HW_CACHE_REFERENCES]		= 0x077d,</span>
<span class="p_add">+  [PERF_COUNT_HW_CACHE_MISSES]			= 0x077e,</span>
   [PERF_COUNT_HW_BRANCH_INSTRUCTIONS]		= 0x00c2,
   [PERF_COUNT_HW_BRANCH_MISSES]			= 0x00c3,
   [PERF_COUNT_HW_STALLED_CYCLES_FRONTEND]	= 0x00d0, /* &quot;Decoder empty&quot; event */
<span class="p_header">diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">index 2e1a6853e00c..2fa494f59828 100644</span>
<span class="p_header">--- a/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/early-quirks.c</span>
<span class="p_chunk">@@ -11,7 +11,11 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/pci.h&gt;
 #include &lt;linux/acpi.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/dmi.h&gt;</span>
 #include &lt;linux/pci_ids.h&gt;
<span class="p_add">+#include &lt;linux/bcma/bcma.h&gt;</span>
<span class="p_add">+#include &lt;linux/bcma/bcma_regs.h&gt;</span>
 #include &lt;drm/i915_drm.h&gt;
 #include &lt;asm/pci-direct.h&gt;
 #include &lt;asm/dma.h&gt;
<span class="p_chunk">@@ -21,6 +25,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/iommu.h&gt;
 #include &lt;asm/gart.h&gt;
 #include &lt;asm/irq_remapping.h&gt;
<span class="p_add">+#include &lt;asm/early_ioremap.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define dev_err(msg)  pr_err(&quot;pci 0000:%02x:%02x.%d: %s&quot;, bus, slot, func, msg)</span>
 
 static void __init fix_hypertransport_config(int num, int slot, int func)
 {
<span class="p_chunk">@@ -76,6 +83,13 @@</span> <span class="p_context"> static void __init nvidia_bugs(int num, int slot, int func)</span>
 #ifdef CONFIG_ACPI
 #ifdef CONFIG_X86_IO_APIC
 	/*
<span class="p_add">+	 * Only applies to Nvidia root ports (bus 0) and not to</span>
<span class="p_add">+	 * Nvidia graphics cards with PCI ports on secondary buses.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (num)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * All timer overrides on Nvidia are
 	 * wrong unless HPET is enabled.
 	 * Unfortunately that&#39;s not true on many Asus boards.
<span class="p_chunk">@@ -565,6 +579,61 @@</span> <span class="p_context"> static void __init force_disable_hpet(int num, int slot, int func)</span>
 #endif
 }
 
<span class="p_add">+#define BCM4331_MMIO_SIZE	16384</span>
<span class="p_add">+#define BCM4331_PM_CAP		0x40</span>
<span class="p_add">+#define bcma_aread32(reg)	ioread32(mmio + 1 * BCMA_CORE_SIZE + reg)</span>
<span class="p_add">+#define bcma_awrite32(reg, val)	iowrite32(val, mmio + 1 * BCMA_CORE_SIZE + reg)</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init apple_airport_reset(int bus, int slot, int func)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void __iomem *mmio;</span>
<span class="p_add">+	u16 pmcsr;</span>
<span class="p_add">+	u64 addr;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dmi_match(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Card may have been put into PCI_D3hot by grub quirk */</span>
<span class="p_add">+	pmcsr = read_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pmcsr &amp; PCI_PM_CTRL_STATE_MASK) != PCI_D0) {</span>
<span class="p_add">+		pmcsr &amp;= ~PCI_PM_CTRL_STATE_MASK;</span>
<span class="p_add">+		write_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL, pmcsr);</span>
<span class="p_add">+		mdelay(10);</span>
<span class="p_add">+</span>
<span class="p_add">+		pmcsr = read_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL);</span>
<span class="p_add">+		if ((pmcsr &amp; PCI_PM_CTRL_STATE_MASK) != PCI_D0) {</span>
<span class="p_add">+			dev_err(&quot;Cannot power up Apple AirPort card\n&quot;);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	addr  =      read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_0);</span>
<span class="p_add">+	addr |= (u64)read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_1) &lt;&lt; 32;</span>
<span class="p_add">+	addr &amp;= PCI_BASE_ADDRESS_MEM_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+	mmio = early_ioremap(addr, BCM4331_MMIO_SIZE);</span>
<span class="p_add">+	if (!mmio) {</span>
<span class="p_add">+		dev_err(&quot;Cannot iomap Apple AirPort card\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;Resetting Apple AirPort card (left enabled by EFI)\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; bcma_aread32(BCMA_RESET_ST) &amp;&amp; i &lt; 30; i++)</span>
<span class="p_add">+		udelay(10);</span>
<span class="p_add">+</span>
<span class="p_add">+	bcma_awrite32(BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);</span>
<span class="p_add">+	bcma_aread32(BCMA_RESET_CTL);</span>
<span class="p_add">+	udelay(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	bcma_awrite32(BCMA_RESET_CTL, 0);</span>
<span class="p_add">+	bcma_aread32(BCMA_RESET_CTL);</span>
<span class="p_add">+	udelay(10);</span>
<span class="p_add">+</span>
<span class="p_add">+	early_iounmap(mmio, BCM4331_MMIO_SIZE);</span>
<span class="p_add">+}</span>
 
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
<span class="p_chunk">@@ -578,12 +647,6 @@</span> <span class="p_context"> struct chipset {</span>
 	void (*f)(int num, int slot, int func);
 };
 
<span class="p_del">-/*</span>
<span class="p_del">- * Only works for devices on the root bus. If you add any devices</span>
<span class="p_del">- * not on bus 0 readd another loop level in early_quirks(). But</span>
<span class="p_del">- * be careful because at least the Nvidia quirk here relies on</span>
<span class="p_del">- * only matching on bus 0.</span>
<span class="p_del">- */</span>
 static struct chipset early_qrk[] __initdata = {
 	{ PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,
 	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, nvidia_bugs },
<span class="p_chunk">@@ -609,9 +672,13 @@</span> <span class="p_context"> static struct chipset early_qrk[] __initdata = {</span>
 	 */
 	{ PCI_VENDOR_ID_INTEL, 0x0f00,
 		PCI_CLASS_BRIDGE_HOST, PCI_ANY_ID, 0, force_disable_hpet},
<span class="p_add">+	{ PCI_VENDOR_ID_BROADCOM, 0x4331,</span>
<span class="p_add">+	  PCI_CLASS_NETWORK_OTHER, PCI_ANY_ID, 0, apple_airport_reset},</span>
 	{}
 };
 
<span class="p_add">+static void __init early_pci_scan_bus(int bus);</span>
<span class="p_add">+</span>
 /**
  * check_dev_quirk - apply early quirks to a given PCI device
  * @num: bus number
<span class="p_chunk">@@ -620,7 +687,7 @@</span> <span class="p_context"> static struct chipset early_qrk[] __initdata = {</span>
  *
  * Check the vendor &amp; device ID against the early quirks table.
  *
<span class="p_del">- * If the device is single function, let early_quirks() know so we don&#39;t</span>
<span class="p_add">+ * If the device is single function, let early_pci_scan_bus() know so we don&#39;t</span>
  * poke at this device again.
  */
 static int __init check_dev_quirk(int num, int slot, int func)
<span class="p_chunk">@@ -629,6 +696,7 @@</span> <span class="p_context"> static int __init check_dev_quirk(int num, int slot, int func)</span>
 	u16 vendor;
 	u16 device;
 	u8 type;
<span class="p_add">+	u8 sec;</span>
 	int i;
 
 	class = read_pci_config_16(num, slot, func, PCI_CLASS_DEVICE);
<span class="p_chunk">@@ -656,25 +724,36 @@</span> <span class="p_context"> static int __init check_dev_quirk(int num, int slot, int func)</span>
 
 	type = read_pci_config_byte(num, slot, func,
 				    PCI_HEADER_TYPE);
<span class="p_add">+</span>
<span class="p_add">+	if ((type &amp; 0x7f) == PCI_HEADER_TYPE_BRIDGE) {</span>
<span class="p_add">+		sec = read_pci_config_byte(num, slot, func, PCI_SECONDARY_BUS);</span>
<span class="p_add">+		if (sec &gt; num)</span>
<span class="p_add">+			early_pci_scan_bus(sec);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!(type &amp; 0x80))
 		return -1;
 
 	return 0;
 }
 
<span class="p_del">-void __init early_quirks(void)</span>
<span class="p_add">+static void __init early_pci_scan_bus(int bus)</span>
 {
 	int slot, func;
 
<span class="p_del">-	if (!early_pci_allowed())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	/* Poor man&#39;s PCI discovery */
<span class="p_del">-	/* Only scan the root bus */</span>
 	for (slot = 0; slot &lt; 32; slot++)
 		for (func = 0; func &lt; 8; func++) {
 			/* Only probe function 0 on single fn devices */
<span class="p_del">-			if (check_dev_quirk(0, slot, func))</span>
<span class="p_add">+			if (check_dev_quirk(bus, slot, func))</span>
 				break;
 		}
 }
<span class="p_add">+</span>
<span class="p_add">+void __init early_quirks(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!early_pci_allowed())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	early_pci_scan_bus(0);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c</span>
<span class="p_header">index 8d12f0546dfc..8819ec730be4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/paravirt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/paravirt.c</span>
<span class="p_chunk">@@ -55,12 +55,12 @@</span> <span class="p_context"> asm (&quot;.pushsection .entry.text, \&quot;ax\&quot;\n&quot;</span>
      &quot;.popsection&quot;);
 
 /* identity function, which can be inlined */
<span class="p_del">-u32 _paravirt_ident_32(u32 x)</span>
<span class="p_add">+u32 notrace _paravirt_ident_32(u32 x)</span>
 {
 	return x;
 }
 
<span class="p_del">-u64 _paravirt_ident_64(u64 x)</span>
<span class="p_add">+u64 notrace _paravirt_ident_64(u64 x)</span>
 {
 	return x;
 }
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index e890c0398d62..413fbb087718 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -372,6 +372,7 @@</span> <span class="p_context"> struct nested_vmx {</span>
 	struct list_head vmcs02_pool;
 	int vmcs02_num;
 	u64 vmcs01_tsc_offset;
<span class="p_add">+	bool change_vmcs01_virtual_x2apic_mode;</span>
 	/* L2 must run next, and mustn&#39;t decide to exit to L1. */
 	bool nested_run_pending;
 	/*
<span class="p_chunk">@@ -5777,22 +5778,27 @@</span> <span class="p_context"> static void nested_free_vmcs02(struct vcpu_vmx *vmx, gpa_t vmptr)</span>
 
 /*
  * Free all VMCSs saved for this vcpu, except the one pointed by
<span class="p_del">- * vmx-&gt;loaded_vmcs. These include the VMCSs in vmcs02_pool (except the one</span>
<span class="p_del">- * currently used, if running L2), and vmcs01 when running L2.</span>
<span class="p_add">+ * vmx-&gt;loaded_vmcs. We must be running L1, so vmx-&gt;loaded_vmcs</span>
<span class="p_add">+ * must be &amp;vmx-&gt;vmcs01.</span>
  */
 static void nested_free_all_saved_vmcss(struct vcpu_vmx *vmx)
 {
 	struct vmcs02_list *item, *n;
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(vmx-&gt;loaded_vmcs != &amp;vmx-&gt;vmcs01);</span>
 	list_for_each_entry_safe(item, n, &amp;vmx-&gt;nested.vmcs02_pool, list) {
<span class="p_del">-		if (vmx-&gt;loaded_vmcs != &amp;item-&gt;vmcs02)</span>
<span class="p_del">-			free_loaded_vmcs(&amp;item-&gt;vmcs02);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Something will leak if the above WARN triggers.  Better than</span>
<span class="p_add">+		 * a use-after-free.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (vmx-&gt;loaded_vmcs == &amp;item-&gt;vmcs02)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		free_loaded_vmcs(&amp;item-&gt;vmcs02);</span>
 		list_del(&amp;item-&gt;list);
 		kfree(item);
<span class="p_add">+		vmx-&gt;nested.vmcs02_num--;</span>
 	}
<span class="p_del">-	vmx-&gt;nested.vmcs02_num = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (vmx-&gt;loaded_vmcs != &amp;vmx-&gt;vmcs01)</span>
<span class="p_del">-		free_loaded_vmcs(&amp;vmx-&gt;vmcs01);</span>
 }
 
 /*
<span class="p_chunk">@@ -7079,6 +7085,12 @@</span> <span class="p_context"> static void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)</span>
 {
 	u32 sec_exec_control;
 
<span class="p_add">+	/* Postpone execution until vmcs01 is the current VMCS. */</span>
<span class="p_add">+	if (is_guest_mode(vcpu)) {</span>
<span class="p_add">+		to_vmx(vcpu)-&gt;nested.change_vmcs01_virtual_x2apic_mode = true;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * There is not point to enable virtualize x2apic without enable
 	 * apicv
<span class="p_chunk">@@ -7557,13 +7569,46 @@</span> <span class="p_context"> static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)</span>
 	vmx_complete_interrupts(vmx);
 }
 
<span class="p_add">+static void vmx_load_vmcs01(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vcpu_vmx *vmx = to_vmx(vcpu);</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vmx-&gt;loaded_vmcs == &amp;vmx-&gt;vmcs01)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	cpu = get_cpu();</span>
<span class="p_add">+	vmx-&gt;loaded_vmcs = &amp;vmx-&gt;vmcs01;</span>
<span class="p_add">+	vmx_vcpu_put(vcpu);</span>
<span class="p_add">+	vmx_vcpu_load(vcpu, cpu);</span>
<span class="p_add">+	vcpu-&gt;cpu = cpu;</span>
<span class="p_add">+	put_cpu();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Ensure that the current vmcs of the logical processor is the</span>
<span class="p_add">+ * vmcs01 of the vcpu before calling free_nested().</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void vmx_free_vcpu_nested(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+       struct vcpu_vmx *vmx = to_vmx(vcpu);</span>
<span class="p_add">+       int r;</span>
<span class="p_add">+</span>
<span class="p_add">+       r = vcpu_load(vcpu);</span>
<span class="p_add">+       BUG_ON(r);</span>
<span class="p_add">+       vmx_load_vmcs01(vcpu);</span>
<span class="p_add">+       free_nested(vmx);</span>
<span class="p_add">+       vcpu_put(vcpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void vmx_free_vcpu(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 
 	free_vpid(vmx);
<span class="p_add">+	leave_guest_mode(vcpu);</span>
<span class="p_add">+	vmx_free_vcpu_nested(vcpu);</span>
 	free_loaded_vmcs(vmx-&gt;loaded_vmcs);
<span class="p_del">-	free_nested(vmx);</span>
 	kfree(vmx-&gt;guest_msrs);
 	kvm_vcpu_uninit(vcpu);
 	kmem_cache_free(kvm_vcpu_cache, vmx);
<span class="p_chunk">@@ -8707,7 +8752,6 @@</span> <span class="p_context"> static void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,</span>
 			      unsigned long exit_qualification)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
<span class="p_del">-	int cpu;</span>
 	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
 
 	/* trying to cancel vmlaunch/vmresume is a bug */
<span class="p_chunk">@@ -8732,12 +8776,7 @@</span> <span class="p_context"> static void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,</span>
 				       vmcs12-&gt;vm_exit_intr_error_code,
 				       KVM_ISA_VMX);
 
<span class="p_del">-	cpu = get_cpu();</span>
<span class="p_del">-	vmx-&gt;loaded_vmcs = &amp;vmx-&gt;vmcs01;</span>
<span class="p_del">-	vmx_vcpu_put(vcpu);</span>
<span class="p_del">-	vmx_vcpu_load(vcpu, cpu);</span>
<span class="p_del">-	vcpu-&gt;cpu = cpu;</span>
<span class="p_del">-	put_cpu();</span>
<span class="p_add">+	vmx_load_vmcs01(vcpu);</span>
 
 	vm_entry_controls_init(vmx, vmcs_read32(VM_ENTRY_CONTROLS));
 	vm_exit_controls_init(vmx, vmcs_read32(VM_EXIT_CONTROLS));
<span class="p_chunk">@@ -8752,6 +8791,12 @@</span> <span class="p_context"> static void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,</span>
 	/* Update TSC_OFFSET if TSC was changed while L2 ran */
 	vmcs_write64(TSC_OFFSET, vmx-&gt;nested.vmcs01_tsc_offset);
 
<span class="p_add">+	if (vmx-&gt;nested.change_vmcs01_virtual_x2apic_mode) {</span>
<span class="p_add">+		vmx-&gt;nested.change_vmcs01_virtual_x2apic_mode = false;</span>
<span class="p_add">+		vmx_set_virtual_x2apic_mode(vcpu,</span>
<span class="p_add">+				vcpu-&gt;arch.apic_base &amp; X2APIC_ENABLE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* This is needed for same reason as it was needed in prepare_vmcs02 */
 	vmx-&gt;host_rsp = 0;
 
<span class="p_header">diff --git a/arch/x86/syscalls/syscall_32.tbl b/arch/x86/syscalls/syscall_32.tbl</span>
<span class="p_header">index d6b867921612..50aa58be7933 100644</span>
<span class="p_header">--- a/arch/x86/syscalls/syscall_32.tbl</span>
<span class="p_header">+++ b/arch/x86/syscalls/syscall_32.tbl</span>
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"></span>
 # 285 sys_setaltroot
 286	i386	add_key			sys_add_key
 287	i386	request_key		sys_request_key
<span class="p_del">-288	i386	keyctl			sys_keyctl</span>
<span class="p_add">+288	i386	keyctl			sys_keyctl			compat_sys_keyctl</span>
 289	i386	ioprio_set		sys_ioprio_set
 290	i386	ioprio_get		sys_ioprio_get
 291	i386	inotify_init		sys_inotify_init
<span class="p_header">diff --git a/block/genhd.c b/block/genhd.c</span>
<span class="p_header">index 9316f5fd416f..548e9e698610 100644</span>
<span class="p_header">--- a/block/genhd.c</span>
<span class="p_header">+++ b/block/genhd.c</span>
<span class="p_chunk">@@ -611,7 +611,7 @@</span> <span class="p_context"> void add_disk(struct gendisk *disk)</span>
 
 	/* Register BDI before referencing it from bdev */
 	bdi = &amp;disk-&gt;queue-&gt;backing_dev_info;
<span class="p_del">-	bdi_register_dev(bdi, disk_devt(disk));</span>
<span class="p_add">+	bdi_register_owner(bdi, disk_to_dev(disk));</span>
 
 	blk_register_region(disk_devt(disk), disk-&gt;minors, NULL,
 			    exact_match, exact_lock, disk);
<span class="p_chunk">@@ -829,6 +829,7 @@</span> <span class="p_context"> static void disk_seqf_stop(struct seq_file *seqf, void *v)</span>
 	if (iter) {
 		class_dev_iter_exit(iter);
 		kfree(iter);
<span class="p_add">+		seqf-&gt;private = NULL;</span>
 	}
 }
 
<span class="p_header">diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c</span>
<span class="p_header">index 3c551d46aa3b..37130b81d0d4 100644</span>
<span class="p_header">--- a/crypto/blkcipher.c</span>
<span class="p_header">+++ b/crypto/blkcipher.c</span>
<span class="p_chunk">@@ -233,6 +233,8 @@</span> <span class="p_context"> static int blkcipher_walk_next(struct blkcipher_desc *desc,</span>
 		return blkcipher_walk_done(desc, walk, -EINVAL);
 	}
 
<span class="p_add">+	bsize = min(walk-&gt;walk_blocksize, n);</span>
<span class="p_add">+</span>
 	walk-&gt;flags &amp;= ~(BLKCIPHER_WALK_SLOW | BLKCIPHER_WALK_COPY |
 			 BLKCIPHER_WALK_DIFF);
 	if (!scatterwalk_aligned(&amp;walk-&gt;in, walk-&gt;alignmask) ||
<span class="p_chunk">@@ -245,7 +247,6 @@</span> <span class="p_context"> static int blkcipher_walk_next(struct blkcipher_desc *desc,</span>
 		}
 	}
 
<span class="p_del">-	bsize = min(walk-&gt;walk_blocksize, n);</span>
 	n = scatterwalk_clamp(&amp;walk-&gt;in, n);
 	n = scatterwalk_clamp(&amp;walk-&gt;out, n);
 
<span class="p_header">diff --git a/crypto/cryptd.c b/crypto/cryptd.c</span>
<span class="p_header">index 75c415d37086..d85fab975514 100644</span>
<span class="p_header">--- a/crypto/cryptd.c</span>
<span class="p_header">+++ b/crypto/cryptd.c</span>
<span class="p_chunk">@@ -565,9 +565,14 @@</span> <span class="p_context"> static int cryptd_hash_export(struct ahash_request *req, void *out)</span>
 
 static int cryptd_hash_import(struct ahash_request *req, const void *in)
 {
<span class="p_del">-	struct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);</span>
<span class="p_add">+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);</span>
<span class="p_add">+	struct cryptd_hash_ctx *ctx = crypto_ahash_ctx(tfm);</span>
<span class="p_add">+	struct shash_desc *desc = cryptd_shash_desc(req);</span>
<span class="p_add">+</span>
<span class="p_add">+	desc-&gt;tfm = ctx-&gt;child;</span>
<span class="p_add">+	desc-&gt;flags = req-&gt;base.flags;</span>
 
<span class="p_del">-	return crypto_shash_import(&amp;rctx-&gt;desc, in);</span>
<span class="p_add">+	return crypto_shash_import(desc, in);</span>
 }
 
 static int cryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,
<span class="p_header">diff --git a/crypto/gcm.c b/crypto/gcm.c</span>
<span class="p_header">index f0bd00b15f26..d2a0f7371cf0 100644</span>
<span class="p_header">--- a/crypto/gcm.c</span>
<span class="p_header">+++ b/crypto/gcm.c</span>
<span class="p_chunk">@@ -716,7 +716,9 @@</span> <span class="p_context"> static struct crypto_instance *crypto_gcm_alloc_common(struct rtattr **tb,</span>
 
 	ghash_alg = crypto_find_alg(ghash_name, &amp;crypto_ahash_type,
 				    CRYPTO_ALG_TYPE_HASH,
<span class="p_del">-				    CRYPTO_ALG_TYPE_AHASH_MASK);</span>
<span class="p_add">+				    CRYPTO_ALG_TYPE_AHASH_MASK |</span>
<span class="p_add">+				    crypto_requires_sync(algt-&gt;type,</span>
<span class="p_add">+							 algt-&gt;mask));</span>
 	if (IS_ERR(ghash_alg))
 		return ERR_CAST(ghash_alg);
 
<span class="p_header">diff --git a/crypto/scatterwalk.c b/crypto/scatterwalk.c</span>
<span class="p_header">index 79ca2278c2a3..0ec7a6fa3d4d 100644</span>
<span class="p_header">--- a/crypto/scatterwalk.c</span>
<span class="p_header">+++ b/crypto/scatterwalk.c</span>
<span class="p_chunk">@@ -68,7 +68,8 @@</span> <span class="p_context"> static void scatterwalk_pagedone(struct scatter_walk *walk, int out,</span>
 
 void scatterwalk_done(struct scatter_walk *walk, int out, int more)
 {
<span class="p_del">-	if (!(scatterwalk_pagelen(walk) &amp; (PAGE_SIZE - 1)) || !more)</span>
<span class="p_add">+	if (!more || walk-&gt;offset &gt;= walk-&gt;sg-&gt;offset + walk-&gt;sg-&gt;length ||</span>
<span class="p_add">+	    !(walk-&gt;offset &amp; (PAGE_SIZE - 1)))</span>
 		scatterwalk_pagedone(walk, out, more);
 }
 EXPORT_SYMBOL_GPL(scatterwalk_done);
<span class="p_header">diff --git a/drivers/bcma/bcma_private.h b/drivers/bcma/bcma_private.h</span>
<span class="p_header">index 09b632ad0fe2..7ded994c6dd0 100644</span>
<span class="p_header">--- a/drivers/bcma/bcma_private.h</span>
<span class="p_header">+++ b/drivers/bcma/bcma_private.h</span>
<span class="p_chunk">@@ -8,8 +8,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/bcma/bcma.h&gt;
 #include &lt;linux/delay.h&gt;
 
<span class="p_del">-#define BCMA_CORE_SIZE		0x1000</span>
<span class="p_del">-</span>
 #define bcma_err(bus, fmt, ...) \
 	pr_err(&quot;bus%d: &quot; fmt, (bus)-&gt;num, ##__VA_ARGS__)
 #define bcma_warn(bus, fmt, ...) \
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 8e51b6c8ccac..1af9fd3202c1 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -122,6 +122,8 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3432) },
 	{ USB_DEVICE(0x13d3, 0x3472) },
 	{ USB_DEVICE(0x13d3, 0x3474) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3487) },</span>
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3490) },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE02C) },
<span class="p_chunk">@@ -188,6 +190,8 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3487), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3490), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU22 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE036), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index a9ccee35973e..876654772092 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -216,6 +216,8 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3487), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3490), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/char/hw_random/omap-rng.c b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">index f66ea258382f..710aec7820a4 100644</span>
<span class="p_header">--- a/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">+++ b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_chunk">@@ -384,7 +384,12 @@</span> <span class="p_context"> static int omap_rng_probe(struct platform_device *pdev)</span>
 	}
 
 	pm_runtime_enable(&amp;pdev-&gt;dev);
<span class="p_del">-	pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	ret = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);</span>
<span class="p_add">+		pm_runtime_put_noidle(&amp;pdev-&gt;dev);</span>
<span class="p_add">+		goto err_ioremap;</span>
<span class="p_add">+	}</span>
 
 	ret = (dev-&gt;of_node) ? of_get_omap_rng_device_details(priv, pdev) :
 				get_omap_rng_device_details(priv);
<span class="p_chunk">@@ -437,8 +442,15 @@</span> <span class="p_context"> static int omap_rng_suspend(struct device *dev)</span>
 static int omap_rng_resume(struct device *dev)
 {
 	struct omap_rng_dev *priv = dev_get_drvdata(dev);
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pm_runtime_get_sync(dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);</span>
<span class="p_add">+		pm_runtime_put_noidle(dev);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	pm_runtime_get_sync(dev);</span>
 	priv-&gt;pdata-&gt;init(priv);
 
 	return 0;
<span class="p_header">diff --git a/drivers/char/random.c b/drivers/char/random.c</span>
<span class="p_header">index dde8da31dcae..692482b7c2fb 100644</span>
<span class="p_header">--- a/drivers/char/random.c</span>
<span class="p_header">+++ b/drivers/char/random.c</span>
<span class="p_chunk">@@ -956,6 +956,7 @@</span> <span class="p_context"> static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)</span>
 	mix_pool_bytes(r, tmp, bytes, NULL);
 	credit_entropy_bits(r, bytes*8);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(add_interrupt_randomness);</span>
 
 /*
  * Used as a workqueue function so that when the input pool is getting
<span class="p_chunk">@@ -1379,12 +1380,16 @@</span> <span class="p_context"> random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)</span>
 static ssize_t
 urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
<span class="p_add">+	static int maxwarn = 10;</span>
 	int ret;
 
<span class="p_del">-	if (unlikely(nonblocking_pool.initialized == 0))</span>
<span class="p_del">-		printk_once(KERN_NOTICE &quot;random: %s urandom read &quot;</span>
<span class="p_del">-			    &quot;with %d bits of entropy available\n&quot;,</span>
<span class="p_del">-			    current-&gt;comm, nonblocking_pool.entropy_total);</span>
<span class="p_add">+	if (unlikely(nonblocking_pool.initialized == 0) &amp;&amp;</span>
<span class="p_add">+	    maxwarn &gt; 0) {</span>
<span class="p_add">+		maxwarn--;</span>
<span class="p_add">+		printk(KERN_NOTICE &quot;random: %s: uninitialized urandom read &quot;</span>
<span class="p_add">+		       &quot;(%zd bytes read, %d bits of entropy available)\n&quot;,</span>
<span class="p_add">+		       current-&gt;comm, nbytes, nonblocking_pool.entropy_total);</span>
<span class="p_add">+	}</span>
 
 	nbytes = min_t(size_t, nbytes, INT_MAX &gt;&gt; (ENTROPY_SHIFT + 3));
 	ret = extract_entropy_user(&amp;nonblocking_pool, buf, nbytes);
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis.c b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">index 51350cd0847e..415e47d79a46 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_chunk">@@ -197,16 +197,15 @@</span> <span class="p_context"> static int get_burstcount(struct tpm_chip *chip)</span>
 {
 	unsigned long stop;
 	int burstcnt;
<span class="p_add">+	u32 value;</span>
 
 	/* wait for burstcount */
 	/* which timeout value, spec has 2 answers (c &amp; d) */
 	stop = jiffies + chip-&gt;vendor.timeout_d;
 	do {
<span class="p_del">-		burstcnt = ioread8(chip-&gt;vendor.iobase +</span>
<span class="p_del">-				   TPM_STS(chip-&gt;vendor.locality) + 1);</span>
<span class="p_del">-		burstcnt += ioread8(chip-&gt;vendor.iobase +</span>
<span class="p_del">-				    TPM_STS(chip-&gt;vendor.locality) +</span>
<span class="p_del">-				    2) &lt;&lt; 8;</span>
<span class="p_add">+		value = ioread32(chip-&gt;vendor.iobase +</span>
<span class="p_add">+				 TPM_STS(chip-&gt;vendor.locality));</span>
<span class="p_add">+		burstcnt = (value &gt;&gt; 8) &amp; 0xFFFF;</span>
 		if (burstcnt)
 			return burstcnt;
 		msleep(TPM_TIMEOUT);
<span class="p_header">diff --git a/drivers/clocksource/sun4i_timer.c b/drivers/clocksource/sun4i_timer.c</span>
<span class="p_header">index f4a9c0058b4d..501c95941882 100644</span>
<span class="p_header">--- a/drivers/clocksource/sun4i_timer.c</span>
<span class="p_header">+++ b/drivers/clocksource/sun4i_timer.c</span>
<span class="p_chunk">@@ -120,12 +120,16 @@</span> <span class="p_context"> static struct clock_event_device sun4i_clockevent = {</span>
 	.set_next_event = sun4i_clkevt_next_event,
 };
 
<span class="p_add">+static void sun4i_timer_clear_interrupt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	writel(TIMER_IRQ_EN(0), timer_base + TIMER_IRQ_ST_REG);</span>
<span class="p_add">+}</span>
 
 static irqreturn_t sun4i_timer_interrupt(int irq, void *dev_id)
 {
 	struct clock_event_device *evt = (struct clock_event_device *)dev_id;
 
<span class="p_del">-	writel(0x1, timer_base + TIMER_IRQ_ST_REG);</span>
<span class="p_add">+	sun4i_timer_clear_interrupt();</span>
 	evt-&gt;event_handler(evt);
 
 	return IRQ_HANDLED;
<span class="p_chunk">@@ -182,6 +186,9 @@</span> <span class="p_context"> static void __init sun4i_timer_init(struct device_node *node)</span>
 	/* Make sure timer is stopped before playing with interrupts */
 	sun4i_clkevt_time_stop(0);
 
<span class="p_add">+	/* clear timer0 interrupt */</span>
<span class="p_add">+	sun4i_timer_clear_interrupt();</span>
<span class="p_add">+</span>
 	sun4i_clockevent.cpumask = cpu_possible_mask;
 	sun4i_clockevent.irq = irq;
 
<span class="p_header">diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">index a22f9b473c22..4f03b1a14d62 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamhash.c</span>
<span class="p_chunk">@@ -1778,6 +1778,7 @@</span> <span class="p_context"> caam_hash_alloc(struct caam_hash_template *template,</span>
 			 template-&gt;name);
 		snprintf(alg-&gt;cra_driver_name, CRYPTO_MAX_ALG_NAME, &quot;%s&quot;,
 			 template-&gt;driver_name);
<span class="p_add">+		t_alg-&gt;ahash_alg.setkey = NULL;</span>
 	}
 	alg-&gt;cra_module = THIS_MODULE;
 	alg-&gt;cra_init = caam_hash_cra_init;
<span class="p_header">diff --git a/drivers/crypto/nx/nx.c b/drivers/crypto/nx/nx.c</span>
<span class="p_header">index 5533fe31c90d..433a7696bf0f 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx.c</span>
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> static void nx_of_update_msc(struct device   *dev,</span>
 		     ((bytes_so_far + sizeof(struct msc_triplet)) &lt;= lenp) &amp;&amp;
 		     i &lt; msc-&gt;triplets;
 		     i++) {
<span class="p_del">-			if (msc-&gt;fc &gt; NX_MAX_FC || msc-&gt;mode &gt; NX_MAX_MODE) {</span>
<span class="p_add">+			if (msc-&gt;fc &gt;= NX_MAX_FC || msc-&gt;mode &gt;= NX_MAX_MODE) {</span>
 				dev_err(dev, &quot;unknown function code/mode &quot;
 					&quot;combo: %d/%d (ignored)\n&quot;, msc-&gt;fc,
 					msc-&gt;mode);
<span class="p_header">diff --git a/drivers/devfreq/devfreq.c b/drivers/devfreq/devfreq.c</span>
<span class="p_header">index 9f90369dd6bd..ba850eb2d275 100644</span>
<span class="p_header">--- a/drivers/devfreq/devfreq.c</span>
<span class="p_header">+++ b/drivers/devfreq/devfreq.c</span>
<span class="p_chunk">@@ -483,7 +483,7 @@</span> <span class="p_context"> struct devfreq *devfreq_add_device(struct device *dev,</span>
 						devfreq-&gt;profile-&gt;max_state *
 						devfreq-&gt;profile-&gt;max_state,
 						GFP_KERNEL);
<span class="p_del">-	devfreq-&gt;time_in_state = devm_kzalloc(dev, sizeof(unsigned int) *</span>
<span class="p_add">+	devfreq-&gt;time_in_state = devm_kzalloc(dev, sizeof(unsigned long) *</span>
 						devfreq-&gt;profile-&gt;max_state,
 						GFP_KERNEL);
 	devfreq-&gt;last_stat_updated = jiffies;
<span class="p_header">diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c</span>
<span class="p_header">index c3986452194d..3e8fcbf511e2 100644</span>
<span class="p_header">--- a/drivers/firewire/net.c</span>
<span class="p_header">+++ b/drivers/firewire/net.c</span>
<span class="p_chunk">@@ -591,6 +591,9 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 	int retval;
 	u16 ether_type;
 
<span class="p_add">+	if (len &lt;= RFC2374_UNFRAG_HDR_SIZE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	hdr.w0 = be32_to_cpu(buf[0]);
 	lf = fwnet_get_hdr_lf(&amp;hdr);
 	if (lf == RFC2374_HDR_UNFRAG) {
<span class="p_chunk">@@ -615,7 +618,12 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 		return fwnet_finish_incoming_packet(net, skb, source_node_id,
 						    is_broadcast, ether_type);
 	}
<span class="p_add">+</span>
 	/* A datagram fragment has been received, now the fun begins. */
<span class="p_add">+</span>
<span class="p_add">+	if (len &lt;= RFC2374_FRAG_HDR_SIZE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	hdr.w1 = ntohl(buf[1]);
 	buf += 2;
 	len -= RFC2374_FRAG_HDR_SIZE;
<span class="p_chunk">@@ -629,6 +637,9 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 	datagram_label = fwnet_get_hdr_dgl(&amp;hdr);
 	dg_size = fwnet_get_hdr_dg_size(&amp;hdr); /* ??? + 1 */
 
<span class="p_add">+	if (fg_off + len &gt; dg_size)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 
 	peer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);
<span class="p_chunk">@@ -735,6 +746,22 @@</span> <span class="p_context"> static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,</span>
 	fw_send_response(card, r, rcode);
 }
 
<span class="p_add">+static int gasp_source_id(__be32 *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return be32_to_cpu(p[0]) &gt;&gt; 16;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u32 gasp_specifier_id(__be32 *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (be32_to_cpu(p[0]) &amp; 0xffff) &lt;&lt; 8 |</span>
<span class="p_add">+	       (be32_to_cpu(p[1]) &amp; 0xff000000) &gt;&gt; 24;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u32 gasp_version(__be32 *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return be32_to_cpu(p[1]) &amp; 0xffffff;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void fwnet_receive_broadcast(struct fw_iso_context *context,
 		u32 cycle, size_t header_length, void *header, void *data)
 {
<span class="p_chunk">@@ -744,9 +771,6 @@</span> <span class="p_context"> static void fwnet_receive_broadcast(struct fw_iso_context *context,</span>
 	__be32 *buf_ptr;
 	int retval;
 	u32 length;
<span class="p_del">-	u16 source_node_id;</span>
<span class="p_del">-	u32 specifier_id;</span>
<span class="p_del">-	u32 ver;</span>
 	unsigned long offset;
 	unsigned long flags;
 
<span class="p_chunk">@@ -763,22 +787,17 @@</span> <span class="p_context"> static void fwnet_receive_broadcast(struct fw_iso_context *context,</span>
 
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 
<span class="p_del">-	specifier_id =    (be32_to_cpu(buf_ptr[0]) &amp; 0xffff) &lt;&lt; 8</span>
<span class="p_del">-			| (be32_to_cpu(buf_ptr[1]) &amp; 0xff000000) &gt;&gt; 24;</span>
<span class="p_del">-	ver = be32_to_cpu(buf_ptr[1]) &amp; 0xffffff;</span>
<span class="p_del">-	source_node_id = be32_to_cpu(buf_ptr[0]) &gt;&gt; 16;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (specifier_id == IANA_SPECIFIER_ID &amp;&amp;</span>
<span class="p_del">-	    (ver == RFC2734_SW_VERSION</span>
<span class="p_add">+	if (length &gt; IEEE1394_GASP_HDR_SIZE &amp;&amp;</span>
<span class="p_add">+	    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &amp;&amp;</span>
<span class="p_add">+	    (gasp_version(buf_ptr) == RFC2734_SW_VERSION</span>
 #if IS_ENABLED(CONFIG_IPV6)
<span class="p_del">-	     || ver == RFC3146_SW_VERSION</span>
<span class="p_add">+	     || gasp_version(buf_ptr) == RFC3146_SW_VERSION</span>
 #endif
<span class="p_del">-	    )) {</span>
<span class="p_del">-		buf_ptr += 2;</span>
<span class="p_del">-		length -= IEEE1394_GASP_HDR_SIZE;</span>
<span class="p_del">-		fwnet_incoming_packet(dev, buf_ptr, length, source_node_id,</span>
<span class="p_add">+	    ))</span>
<span class="p_add">+		fwnet_incoming_packet(dev, buf_ptr + 2,</span>
<span class="p_add">+				      length - IEEE1394_GASP_HDR_SIZE,</span>
<span class="p_add">+				      gasp_source_id(buf_ptr),</span>
 				      context-&gt;card-&gt;generation, true);
<span class="p_del">-	}</span>
 
 	packet.payload_length = dev-&gt;rcv_buffer_size;
 	packet.interrupt = 1;
<span class="p_header">diff --git a/drivers/firmware/efi/efi-stub-helper.c b/drivers/firmware/efi/efi-stub-helper.c</span>
<span class="p_header">index 2fb3a0aab56c..8eae9c9d7863 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi-stub-helper.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi-stub-helper.c</span>
<span class="p_chunk">@@ -15,6 +15,8 @@</span> <span class="p_context"></span>
 #define EFI_ERROR	(~0UL)
 
 
<span class="p_add">+#define EFI_MMAP_NR_SLACK_SLOTS	8</span>
<span class="p_add">+</span>
 struct file_info {
 	efi_file_handle_t *handle;
 	u64 size;
<span class="p_chunk">@@ -41,49 +43,62 @@</span> <span class="p_context"> static void efi_printk(efi_system_table_t *sys_table_arg, char *str)</span>
 #define pr_efi_err(sys_table, msg) efi_printk(sys_table, &quot;EFI stub: ERROR: &quot;msg)
 
 
<span class="p_add">+static inline bool mmap_has_headroom(unsigned long buff_size,</span>
<span class="p_add">+				     unsigned long map_size,</span>
<span class="p_add">+				     unsigned long desc_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long slack = buff_size - map_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	return slack / desc_size &gt;= EFI_MMAP_NR_SLACK_SLOTS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static efi_status_t efi_get_memory_map(efi_system_table_t *sys_table_arg,
<span class="p_del">-				       efi_memory_desc_t **map,</span>
<span class="p_del">-				       unsigned long *map_size,</span>
<span class="p_del">-				       unsigned long *desc_size,</span>
<span class="p_del">-				       u32 *desc_ver,</span>
<span class="p_del">-				       unsigned long *key_ptr)</span>
<span class="p_add">+				       struct efi_boot_memmap *map)</span>
 {
 	efi_memory_desc_t *m = NULL;
 	efi_status_t status;
 	unsigned long key;
 	u32 desc_version;
 
<span class="p_del">-	*map_size = sizeof(*m) * 32;</span>
<span class="p_add">+	*map-&gt;desc_size =	sizeof(*m);</span>
<span class="p_add">+	*map-&gt;map_size =	*map-&gt;desc_size * 32;</span>
<span class="p_add">+	*map-&gt;buff_size =	*map-&gt;map_size;</span>
 again:
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Add an additional efi_memory_desc_t because we&#39;re doing an</span>
<span class="p_del">-	 * allocation which may be in a new descriptor region.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	*map_size += sizeof(*m);</span>
 	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
<span class="p_del">-				*map_size, (void **)&amp;m);</span>
<span class="p_add">+				*map-&gt;map_size, (void **)&amp;m);</span>
 	if (status != EFI_SUCCESS)
 		goto fail;
 
<span class="p_del">-	*desc_size = 0;</span>
<span class="p_add">+	*map-&gt;desc_size = 0;</span>
 	key = 0;
<span class="p_del">-	status = efi_call_early(get_memory_map, map_size, m,</span>
<span class="p_del">-				&amp;key, desc_size, &amp;desc_version);</span>
<span class="p_del">-	if (status == EFI_BUFFER_TOO_SMALL) {</span>
<span class="p_add">+	status = efi_call_early(get_memory_map, map-&gt;map_size, m,</span>
<span class="p_add">+				&amp;key, map-&gt;desc_size, &amp;desc_version);</span>
<span class="p_add">+	if (status == EFI_BUFFER_TOO_SMALL ||</span>
<span class="p_add">+	    !mmap_has_headroom(*map-&gt;buff_size, *map-&gt;map_size,</span>
<span class="p_add">+			       *map-&gt;desc_size)) {</span>
 		efi_call_early(free_pool, m);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Make sure there is some entries of headroom so that the</span>
<span class="p_add">+		 * buffer can be reused for a new map after allocations are</span>
<span class="p_add">+		 * no longer permitted.  Its unlikely that the map will grow to</span>
<span class="p_add">+		 * exceed this headroom once we are ready to trigger</span>
<span class="p_add">+		 * ExitBootServices()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		*map-&gt;map_size += *map-&gt;desc_size * EFI_MMAP_NR_SLACK_SLOTS;</span>
<span class="p_add">+		*map-&gt;buff_size = *map-&gt;map_size;</span>
 		goto again;
 	}
 
 	if (status != EFI_SUCCESS)
 		efi_call_early(free_pool, m);
 
<span class="p_del">-	if (key_ptr &amp;&amp; status == EFI_SUCCESS)</span>
<span class="p_del">-		*key_ptr = key;</span>
<span class="p_del">-	if (desc_ver &amp;&amp; status == EFI_SUCCESS)</span>
<span class="p_del">-		*desc_ver = desc_version;</span>
<span class="p_add">+	if (map-&gt;key_ptr &amp;&amp; status == EFI_SUCCESS)</span>
<span class="p_add">+		*map-&gt;key_ptr = key;</span>
<span class="p_add">+	if (map-&gt;desc_ver &amp;&amp; status == EFI_SUCCESS)</span>
<span class="p_add">+		*map-&gt;desc_ver = desc_version;</span>
 
 fail:
<span class="p_del">-	*map = m;</span>
<span class="p_add">+	*map-&gt;map = m;</span>
 	return status;
 }
 
<span class="p_chunk">@@ -91,13 +106,20 @@</span> <span class="p_context"> fail:</span>
 static unsigned long __init get_dram_base(efi_system_table_t *sys_table_arg)
 {
 	efi_status_t status;
<span class="p_del">-	unsigned long map_size;</span>
<span class="p_add">+	unsigned long map_size, buff_size;</span>
 	unsigned long membase  = EFI_ERROR;
 	struct efi_memory_map map;
 	efi_memory_desc_t *md;
<span class="p_add">+	struct efi_boot_memmap boot_map;</span>
 
<span class="p_del">-	status = efi_get_memory_map(sys_table_arg, (efi_memory_desc_t **)&amp;map.map,</span>
<span class="p_del">-				    &amp;map_size, &amp;map.desc_size, NULL, NULL);</span>
<span class="p_add">+	boot_map.map =		(efi_memory_desc_t **)&amp;map.map;</span>
<span class="p_add">+	boot_map.map_size =	&amp;map_size;</span>
<span class="p_add">+	boot_map.desc_size =	&amp;map.desc_size;</span>
<span class="p_add">+	boot_map.desc_ver =	NULL;</span>
<span class="p_add">+	boot_map.key_ptr =	NULL;</span>
<span class="p_add">+	boot_map.buff_size =	&amp;buff_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = efi_get_memory_map(sys_table_arg, &amp;boot_map);</span>
 	if (status != EFI_SUCCESS)
 		return membase;
 
<span class="p_chunk">@@ -120,15 +142,22 @@</span> <span class="p_context"> static efi_status_t efi_high_alloc(efi_system_table_t *sys_table_arg,</span>
 			       unsigned long size, unsigned long align,
 			       unsigned long *addr, unsigned long max)
 {
<span class="p_del">-	unsigned long map_size, desc_size;</span>
<span class="p_add">+	unsigned long map_size, desc_size, buff_size;</span>
 	efi_memory_desc_t *map;
 	efi_status_t status;
 	unsigned long nr_pages;
 	u64 max_addr = 0;
 	int i;
<span class="p_add">+	struct efi_boot_memmap boot_map;</span>
<span class="p_add">+</span>
<span class="p_add">+	boot_map.map =		&amp;map;</span>
<span class="p_add">+	boot_map.map_size =	&amp;map_size;</span>
<span class="p_add">+	boot_map.desc_size =	&amp;desc_size;</span>
<span class="p_add">+	boot_map.desc_ver =	NULL;</span>
<span class="p_add">+	boot_map.key_ptr =	NULL;</span>
<span class="p_add">+	boot_map.buff_size =	&amp;buff_size;</span>
 
<span class="p_del">-	status = efi_get_memory_map(sys_table_arg, &amp;map, &amp;map_size, &amp;desc_size,</span>
<span class="p_del">-				    NULL, NULL);</span>
<span class="p_add">+	status = efi_get_memory_map(sys_table_arg, &amp;boot_map);</span>
 	if (status != EFI_SUCCESS)
 		goto fail;
 
<span class="p_chunk">@@ -206,14 +235,21 @@</span> <span class="p_context"> static efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,</span>
 			      unsigned long size, unsigned long align,
 			      unsigned long *addr)
 {
<span class="p_del">-	unsigned long map_size, desc_size;</span>
<span class="p_add">+	unsigned long map_size, desc_size, buff_size;</span>
 	efi_memory_desc_t *map;
 	efi_status_t status;
 	unsigned long nr_pages;
 	int i;
<span class="p_add">+	struct efi_boot_memmap boot_map;</span>
<span class="p_add">+</span>
<span class="p_add">+	boot_map.map =		&amp;map;</span>
<span class="p_add">+	boot_map.map_size =	&amp;map_size;</span>
<span class="p_add">+	boot_map.desc_size =	&amp;desc_size;</span>
<span class="p_add">+	boot_map.desc_ver =	NULL;</span>
<span class="p_add">+	boot_map.key_ptr =	NULL;</span>
<span class="p_add">+	boot_map.buff_size =	&amp;buff_size;</span>
 
<span class="p_del">-	status = efi_get_memory_map(sys_table_arg, &amp;map, &amp;map_size, &amp;desc_size,</span>
<span class="p_del">-				    NULL, NULL);</span>
<span class="p_add">+	status = efi_get_memory_map(sys_table_arg, &amp;boot_map);</span>
 	if (status != EFI_SUCCESS)
 		goto fail;
 
<span class="p_header">diff --git a/drivers/firmware/efi/fdt.c b/drivers/firmware/efi/fdt.c</span>
<span class="p_header">index 507a3df46a5d..519448aeaffd 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/fdt.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/fdt.c</span>
<span class="p_chunk">@@ -178,12 +178,20 @@</span> <span class="p_context"> efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,</span>
 					    unsigned long fdt_addr,
 					    unsigned long fdt_size)
 {
<span class="p_del">-	unsigned long map_size, desc_size;</span>
<span class="p_add">+	unsigned long map_size, desc_size, buff_size;</span>
 	u32 desc_ver;
 	unsigned long mmap_key;
 	efi_memory_desc_t *memory_map;
 	unsigned long new_fdt_size;
 	efi_status_t status;
<span class="p_add">+	struct efi_boot_memmap map;</span>
<span class="p_add">+</span>
<span class="p_add">+	map.map =	&amp;memory_map;</span>
<span class="p_add">+	map.map_size =	&amp;map_size;</span>
<span class="p_add">+	map.desc_size =	&amp;desc_size;</span>
<span class="p_add">+	map.desc_ver =	&amp;desc_ver;</span>
<span class="p_add">+	map.key_ptr =	&amp;mmap_key;</span>
<span class="p_add">+	map.buff_size =	&amp;buff_size;</span>
 
 	/*
 	 * Estimate size of new FDT, and allocate memory for it. We
<span class="p_chunk">@@ -204,8 +212,7 @@</span> <span class="p_context"> efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,</span>
 		 * we can get the memory map key  needed for
 		 * exit_boot_services().
 		 */
<span class="p_del">-		status = efi_get_memory_map(sys_table, &amp;memory_map, &amp;map_size,</span>
<span class="p_del">-					    &amp;desc_size, &amp;desc_ver, &amp;mmap_key);</span>
<span class="p_add">+		status = efi_get_memory_map(sys_table, &amp;map);</span>
 		if (status != EFI_SUCCESS)
 			goto fail_free_new_fdt;
 
<span class="p_header">diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig</span>
<span class="p_header">index 4a1b5113e527..53a2f65fb166 100644</span>
<span class="p_header">--- a/drivers/gpio/Kconfig</span>
<span class="p_header">+++ b/drivers/gpio/Kconfig</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> config GPIO_DEVRES</span>
 config OF_GPIO
 	def_bool y
 	depends on OF
<span class="p_add">+	depends on HAS_IOMEM</span>
 
 config GPIO_ACPI
 	def_bool y
<span class="p_header">diff --git a/drivers/gpio/gpio-intel-mid.c b/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_header">index 118a6bf455d9..39d0bc81657e 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_chunk">@@ -17,7 +17,6 @@</span> <span class="p_context"></span>
  * Moorestown platform Langwell chip.
  * Medfield platform Penwell chip.
  * Clovertrail platform Cloverview chip.
<span class="p_del">- * Merrifield platform Tangier chip.</span>
  */
 
 #include &lt;linux/module.h&gt;
<span class="p_chunk">@@ -66,10 +65,6 @@</span> <span class="p_context"> enum GPIO_REG {</span>
 /* intel_mid gpio driver data */
 struct intel_mid_gpio_ddata {
 	u16 ngpio;		/* number of gpio pins */
<span class="p_del">-	u32 gplr_offset;	/* offset of first GPLR register from base */</span>
<span class="p_del">-	u32 flis_base;		/* base address of FLIS registers */</span>
<span class="p_del">-	u32 flis_len;		/* length of FLIS registers */</span>
<span class="p_del">-	u32 (*get_flis_offset)(int gpio);</span>
 	u32 chip_irq_type;	/* chip interrupt type */
 };
 
<span class="p_chunk">@@ -284,15 +279,6 @@</span> <span class="p_context"> static const struct intel_mid_gpio_ddata gpio_cloverview_core = {</span>
 	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE,
 };
 
<span class="p_del">-static const struct intel_mid_gpio_ddata gpio_tangier = {</span>
<span class="p_del">-	.ngpio = 192,</span>
<span class="p_del">-	.gplr_offset = 4,</span>
<span class="p_del">-	.flis_base = 0xff0c0000,</span>
<span class="p_del">-	.flis_len = 0x8000,</span>
<span class="p_del">-	.get_flis_offset = NULL,</span>
<span class="p_del">-	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static const struct pci_device_id intel_gpio_ids[] = {
 	{
 		/* Lincroft */
<span class="p_chunk">@@ -319,11 +305,6 @@</span> <span class="p_context"> static const struct pci_device_id intel_gpio_ids[] = {</span>
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08f7),
 		.driver_data = (kernel_ulong_t)&amp;gpio_cloverview_core,
 	},
<span class="p_del">-	{</span>
<span class="p_del">-		/* Tangier */</span>
<span class="p_del">-		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1199),</span>
<span class="p_del">-		.driver_data = (kernel_ulong_t)&amp;gpio_tangier,</span>
<span class="p_del">-	},</span>
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, intel_gpio_ids);
<span class="p_header">diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c</span>
<span class="p_header">index 103de0f01934..7a92eb0dad6b 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-pca953x.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-pca953x.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(i2c, pca953x_id);</span>
 #define MAX_BANK 5
 #define BANK_SZ 8
 
<span class="p_del">-#define NBANK(chip) (chip-&gt;gpio_chip.ngpio / BANK_SZ)</span>
<span class="p_add">+#define NBANK(chip) DIV_ROUND_UP(chip-&gt;gpio_chip.ngpio, BANK_SZ)</span>
 
 struct pca953x_chip {
 	unsigned gpio_start;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index 0dd2c26c55ab..8cbc8ea28e0e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -4236,6 +4236,9 @@</span> <span class="p_context"> int drm_mode_page_flip_ioctl(struct drm_device *dev,</span>
 	unsigned long flags;
 	int ret = -EINVAL;
 
<span class="p_add">+	if (!drm_core_check_feature(dev, DRIVER_MODESET))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (page_flip-&gt;flags &amp; ~DRM_MODE_PAGE_FLIP_FLAGS ||
 	    page_flip-&gt;reserved != 0)
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">index dfa9769b26b5..0149b1e6dd5b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_chunk">@@ -72,6 +72,8 @@</span> <span class="p_context"></span>
 #define EDID_QUIRK_FORCE_8BPC			(1 &lt;&lt; 8)
 /* Force 12bpc */
 #define EDID_QUIRK_FORCE_12BPC			(1 &lt;&lt; 9)
<span class="p_add">+/* Force 6bpc */</span>
<span class="p_add">+#define EDID_QUIRK_FORCE_6BPC			(1 &lt;&lt; 10)</span>
 
 struct detailed_mode_closure {
 	struct drm_connector *connector;
<span class="p_chunk">@@ -98,6 +100,9 @@</span> <span class="p_context"> static struct edid_quirk {</span>
 	/* Unknown Acer */
 	{ &quot;ACR&quot;, 2423, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
 
<span class="p_add">+	/* AEO model 0 reports 8 bpc, but is a 6 bpc panel */</span>
<span class="p_add">+	{ &quot;AEO&quot;, 0, EDID_QUIRK_FORCE_6BPC },</span>
<span class="p_add">+</span>
 	/* Belinea 10 15 55 */
 	{ &quot;MAX&quot;, 1516, EDID_QUIRK_PREFER_LARGE_60 },
 	{ &quot;MAX&quot;, 0x77e, EDID_QUIRK_PREFER_LARGE_60 },
<span class="p_chunk">@@ -3667,6 +3672,9 @@</span> <span class="p_context"> int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid)</span>
 
 	drm_add_display_info(edid, &amp;connector-&gt;display_info, connector);
 
<span class="p_add">+	if (quirks &amp; EDID_QUIRK_FORCE_6BPC)</span>
<span class="p_add">+		connector-&gt;display_info.bpc = 6;</span>
<span class="p_add">+</span>
 	if (quirks &amp; EDID_QUIRK_FORCE_8BPC)
 		connector-&gt;display_info.bpc = 8;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index a62393650307..2041c5bbb929 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -9475,21 +9475,11 @@</span> <span class="p_context"> connected_sink_compute_bpp(struct intel_connector *connector,</span>
 		pipe_config-&gt;pipe_bpp = connector-&gt;base.display_info.bpc*3;
 	}
 
<span class="p_del">-	/* Clamp bpp to default limit on screens without EDID 1.4 */</span>
<span class="p_del">-	if (connector-&gt;base.display_info.bpc == 0) {</span>
<span class="p_del">-		int type = connector-&gt;base.connector_type;</span>
<span class="p_del">-		int clamp_bpp = 24;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Fall back to 18 bpp when DP sink capability is unknown. */</span>
<span class="p_del">-		if (type == DRM_MODE_CONNECTOR_DisplayPort ||</span>
<span class="p_del">-		    type == DRM_MODE_CONNECTOR_eDP)</span>
<span class="p_del">-			clamp_bpp = 18;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (bpp &gt; clamp_bpp) {</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of %d\n&quot;,</span>
<span class="p_del">-				      bpp, clamp_bpp);</span>
<span class="p_del">-			pipe_config-&gt;pipe_bpp = clamp_bpp;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	/* Clamp bpp to 8 on screens without EDID 1.4 */</span>
<span class="p_add">+	if (connector-&gt;base.display_info.bpc == 0 &amp;&amp; bpp &gt; 24) {</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of 24\n&quot;,</span>
<span class="p_add">+			      bpp);</span>
<span class="p_add">+		pipe_config-&gt;pipe_bpp = 24;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/msm/msm_drv.h b/drivers/gpu/drm/msm/msm_drv.h</span>
<span class="p_header">index 8a2c5fd0893e..cb4a95b75dd7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/msm_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/msm_drv.h</span>
<span class="p_chunk">@@ -124,6 +124,12 @@</span> <span class="p_context"> struct msm_drm_private {</span>
 		 */
 		struct drm_mm mm;
 	} vram;
<span class="p_add">+</span>
<span class="p_add">+	/* task holding struct_mutex.. currently only used in submit path</span>
<span class="p_add">+	 * to detect and reject faults from copy_from_user() for submit</span>
<span class="p_add">+	 * ioctl.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct task_struct *struct_mutex_task;</span>
 };
 
 struct msm_format {
<span class="p_header">diff --git a/drivers/gpu/drm/msm/msm_gem.c b/drivers/gpu/drm/msm/msm_gem.c</span>
<span class="p_header">index 690d7e7b6d1e..f611b079a360 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/msm_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/msm_gem.c</span>
<span class="p_chunk">@@ -188,11 +188,20 @@</span> <span class="p_context"> int msm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)</span>
 {
 	struct drm_gem_object *obj = vma-&gt;vm_private_data;
 	struct drm_device *dev = obj-&gt;dev;
<span class="p_add">+	struct msm_drm_private *priv = dev-&gt;dev_private;</span>
 	struct page **pages;
 	unsigned long pfn;
 	pgoff_t pgoff;
 	int ret;
 
<span class="p_add">+	/* This should only happen if userspace tries to pass a mmap&#39;d</span>
<span class="p_add">+	 * but unfaulted gem bo vaddr into submit ioctl, triggering</span>
<span class="p_add">+	 * a page fault while struct_mutex is already held.  This is</span>
<span class="p_add">+	 * not a valid use-case so just bail.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (priv-&gt;struct_mutex_task == current)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
<span class="p_add">+</span>
 	/* Make sure we don&#39;t parallel update on a fault, nor move or remove
 	 * something from beneath our feet
 	 */
<span class="p_header">diff --git a/drivers/gpu/drm/msm/msm_gem_submit.c b/drivers/gpu/drm/msm/msm_gem_submit.c</span>
<span class="p_header">index cd0554f68316..057951163126 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/msm_gem_submit.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/msm_gem_submit.c</span>
<span class="p_chunk">@@ -55,6 +55,14 @@</span> <span class="p_context"> static struct msm_gem_submit *submit_create(struct drm_device *dev,</span>
 	return submit;
 }
 
<span class="p_add">+static inline unsigned long __must_check</span>
<span class="p_add">+copy_from_user_inatomic(void *to, const void __user *from, unsigned long n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_add">+		return __copy_from_user_inatomic(to, from, n);</span>
<span class="p_add">+	return -EFAULT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int submit_lookup_objects(struct msm_gem_submit *submit,
 		struct drm_msm_gem_submit *args, struct drm_file *file)
 {
<span class="p_chunk">@@ -62,6 +70,7 @@</span> <span class="p_context"> static int submit_lookup_objects(struct msm_gem_submit *submit,</span>
 	int ret = 0;
 
 	spin_lock(&amp;file-&gt;table_lock);
<span class="p_add">+	pagefault_disable();</span>
 
 	for (i = 0; i &lt; args-&gt;nr_bos; i++) {
 		struct drm_msm_gem_submit_bo submit_bo;
<span class="p_chunk">@@ -70,10 +79,15 @@</span> <span class="p_context"> static int submit_lookup_objects(struct msm_gem_submit *submit,</span>
 		void __user *userptr =
 			to_user_ptr(args-&gt;bos + (i * sizeof(submit_bo)));
 
<span class="p_del">-		ret = copy_from_user(&amp;submit_bo, userptr, sizeof(submit_bo));</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			ret = -EFAULT;</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_add">+		ret = copy_from_user_inatomic(&amp;submit_bo, userptr, sizeof(submit_bo));</span>
<span class="p_add">+		if (unlikely(ret)) {</span>
<span class="p_add">+			pagefault_enable();</span>
<span class="p_add">+			spin_unlock(&amp;file-&gt;table_lock);</span>
<span class="p_add">+			ret = copy_from_user(&amp;submit_bo, userptr, sizeof(submit_bo));</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			spin_lock(&amp;file-&gt;table_lock);</span>
<span class="p_add">+			pagefault_disable();</span>
 		}
 
 		if (submit_bo.flags &amp; ~MSM_SUBMIT_BO_FLAGS) {
<span class="p_chunk">@@ -113,9 +127,12 @@</span> <span class="p_context"> static int submit_lookup_objects(struct msm_gem_submit *submit,</span>
 	}
 
 out_unlock:
<span class="p_del">-	submit-&gt;nr_bos = i;</span>
<span class="p_add">+	pagefault_enable();</span>
 	spin_unlock(&amp;file-&gt;table_lock);
 
<span class="p_add">+out:</span>
<span class="p_add">+	submit-&gt;nr_bos = i;</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -339,12 +356,16 @@</span> <span class="p_context"> int msm_ioctl_gem_submit(struct drm_device *dev, void *data,</span>
 	if (args-&gt;nr_cmds &gt; MAX_CMDS)
 		return -EINVAL;
 
<span class="p_del">-	mutex_lock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_add">+	ret = mutex_lock_interruptible(&amp;dev-&gt;struct_mutex);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;struct_mutex_task = current;</span>
 
 	submit = submit_create(dev, gpu, args-&gt;nr_bos);
 	if (!submit) {
 		ret = -ENOMEM;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_unlock;</span>
 	}
 
 	ret = submit_lookup_objects(submit, args, file);
<span class="p_chunk">@@ -422,6 +443,8 @@</span> <span class="p_context"> int msm_ioctl_gem_submit(struct drm_device *dev, void *data,</span>
 out:
 	if (submit)
 		submit_cleanup(submit, !!ret);
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	priv-&gt;struct_mutex_task = NULL;</span>
 	mutex_unlock(&amp;dev-&gt;struct_mutex);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_acpi.c b/drivers/gpu/drm/nouveau/nouveau_acpi.c</span>
<span class="p_header">index 279206997e5c..8f057ab38e27 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_acpi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_acpi.c</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"></span>
 static struct nouveau_dsm_priv {
 	bool dsm_detected;
 	bool optimus_detected;
<span class="p_add">+	bool optimus_flags_detected;</span>
 	acpi_handle dhandle;
 	acpi_handle other_handle;
 	acpi_handle rom_handle;
<span class="p_chunk">@@ -58,9 +59,6 @@</span> <span class="p_context"> bool nouveau_is_v1_dsm(void) {</span>
 	return nouveau_dsm_priv.dsm_detected;
 }
 
<span class="p_del">-#define NOUVEAU_DSM_HAS_MUX 0x1</span>
<span class="p_del">-#define NOUVEAU_DSM_HAS_OPT 0x2</span>
<span class="p_del">-</span>
 #ifdef CONFIG_VGA_SWITCHEROO
 static const char nouveau_dsm_muid[] = {
 	0xA0, 0xA0, 0x95, 0x9D, 0x60, 0x00, 0x48, 0x4D,
<span class="p_chunk">@@ -111,7 +109,7 @@</span> <span class="p_context"> static int nouveau_optimus_dsm(acpi_handle handle, int func, int arg, uint32_t *</span>
  * requirements on the fourth parameter, so a private implementation
  * instead of using acpi_check_dsm().
  */
<span class="p_del">-static int nouveau_check_optimus_dsm(acpi_handle handle)</span>
<span class="p_add">+static int nouveau_dsm_get_optimus_functions(acpi_handle handle)</span>
 {
 	int result;
 
<span class="p_chunk">@@ -126,7 +124,9 @@</span> <span class="p_context"> static int nouveau_check_optimus_dsm(acpi_handle handle)</span>
 	 * ACPI Spec v4 9.14.1: if bit 0 is zero, no function is supported.
 	 * If the n-th bit is enabled, function n is supported
 	 */
<span class="p_del">-	return result &amp; 1 &amp;&amp; result &amp; (1 &lt;&lt; NOUVEAU_DSM_OPTIMUS_CAPS);</span>
<span class="p_add">+	if (result &amp; 1 &amp;&amp; result &amp; (1 &lt;&lt; NOUVEAU_DSM_OPTIMUS_CAPS))</span>
<span class="p_add">+		return result;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int nouveau_dsm(acpi_handle handle, int func, int arg)
<span class="p_chunk">@@ -213,27 +213,36 @@</span> <span class="p_context"> static struct vga_switcheroo_handler nouveau_dsm_handler = {</span>
 	.get_client_id = nouveau_dsm_get_client_id,
 };
 
<span class="p_del">-static int nouveau_dsm_pci_probe(struct pci_dev *pdev)</span>
<span class="p_add">+static void nouveau_dsm_pci_probe(struct pci_dev *pdev, acpi_handle *dhandle_out,</span>
<span class="p_add">+				  bool *has_mux, bool *has_opt,</span>
<span class="p_add">+				  bool *has_opt_flags)</span>
 {
 	acpi_handle dhandle;
<span class="p_del">-	int retval = 0;</span>
<span class="p_add">+	bool supports_mux;</span>
<span class="p_add">+	int optimus_funcs;</span>
 
 	dhandle = ACPI_HANDLE(&amp;pdev-&gt;dev);
 	if (!dhandle)
<span class="p_del">-		return false;</span>
<span class="p_add">+		return;</span>
 
 	if (!acpi_has_method(dhandle, &quot;_DSM&quot;)) {
 		nouveau_dsm_priv.other_handle = dhandle;
<span class="p_del">-		return false;</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_del">-	if (acpi_check_dsm(dhandle, nouveau_dsm_muid, 0x00000102,</span>
<span class="p_del">-			   1 &lt;&lt; NOUVEAU_DSM_POWER))</span>
<span class="p_del">-		retval |= NOUVEAU_DSM_HAS_MUX;</span>
<span class="p_add">+	supports_mux = acpi_check_dsm(dhandle, nouveau_dsm_muid, 0x00000102,</span>
<span class="p_add">+				      1 &lt;&lt; NOUVEAU_DSM_POWER);</span>
<span class="p_add">+	optimus_funcs = nouveau_dsm_get_optimus_functions(dhandle);</span>
 
<span class="p_del">-	if (nouveau_check_optimus_dsm(dhandle))</span>
<span class="p_del">-		retval |= NOUVEAU_DSM_HAS_OPT;</span>
<span class="p_add">+	/* Does not look like a Nvidia device. */</span>
<span class="p_add">+	if (!supports_mux &amp;&amp; !optimus_funcs)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	*dhandle_out = dhandle;</span>
<span class="p_add">+	*has_mux = supports_mux;</span>
<span class="p_add">+	*has_opt = !!optimus_funcs;</span>
<span class="p_add">+	*has_opt_flags = optimus_funcs &amp; (1 &lt;&lt; NOUVEAU_DSM_OPTIMUS_FLAGS);</span>
 
<span class="p_del">-	if (retval &amp; NOUVEAU_DSM_HAS_OPT) {</span>
<span class="p_add">+	if (optimus_funcs) {</span>
 		uint32_t result;
 		nouveau_optimus_dsm(dhandle, NOUVEAU_DSM_OPTIMUS_CAPS, 0,
 				    &amp;result);
<span class="p_chunk">@@ -242,10 +251,6 @@</span> <span class="p_context"> static int nouveau_dsm_pci_probe(struct pci_dev *pdev)</span>
 			 (result &amp; OPTIMUS_DYNAMIC_PWR_CAP) ? &quot;dynamic power, &quot; : &quot;&quot;,
 			 (result &amp; OPTIMUS_HDA_CODEC_MASK) ? &quot;hda bios codec supported&quot; : &quot;&quot;);
 	}
<span class="p_del">-	if (retval)</span>
<span class="p_del">-		nouveau_dsm_priv.dhandle = dhandle;</span>
<span class="p_del">-</span>
<span class="p_del">-	return retval;</span>
 }
 
 static bool nouveau_dsm_detect(void)
<span class="p_chunk">@@ -253,11 +258,12 @@</span> <span class="p_context"> static bool nouveau_dsm_detect(void)</span>
 	char acpi_method_name[255] = { 0 };
 	struct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};
 	struct pci_dev *pdev = NULL;
<span class="p_del">-	int has_dsm = 0;</span>
<span class="p_del">-	int has_optimus = 0;</span>
<span class="p_add">+	acpi_handle dhandle = NULL;</span>
<span class="p_add">+	bool has_mux = false;</span>
<span class="p_add">+	bool has_optimus = false;</span>
<span class="p_add">+	bool has_optimus_flags = false;</span>
 	int vga_count = 0;
 	bool guid_valid;
<span class="p_del">-	int retval;</span>
 	bool ret = false;
 
 	/* lookup the MXM GUID */
<span class="p_chunk">@@ -270,32 +276,29 @@</span> <span class="p_context"> static bool nouveau_dsm_detect(void)</span>
 	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA &lt;&lt; 8, pdev)) != NULL) {
 		vga_count++;
 
<span class="p_del">-		retval = nouveau_dsm_pci_probe(pdev);</span>
<span class="p_del">-		if (retval &amp; NOUVEAU_DSM_HAS_MUX)</span>
<span class="p_del">-			has_dsm |= 1;</span>
<span class="p_del">-		if (retval &amp; NOUVEAU_DSM_HAS_OPT)</span>
<span class="p_del">-			has_optimus = 1;</span>
<span class="p_add">+		nouveau_dsm_pci_probe(pdev, &amp;dhandle, &amp;has_mux, &amp;has_optimus,</span>
<span class="p_add">+				      &amp;has_optimus_flags);</span>
 	}
 
 	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_3D &lt;&lt; 8, pdev)) != NULL) {
 		vga_count++;
 
<span class="p_del">-		retval = nouveau_dsm_pci_probe(pdev);</span>
<span class="p_del">-		if (retval &amp; NOUVEAU_DSM_HAS_MUX)</span>
<span class="p_del">-			has_dsm |= 1;</span>
<span class="p_del">-		if (retval &amp; NOUVEAU_DSM_HAS_OPT)</span>
<span class="p_del">-			has_optimus = 1;</span>
<span class="p_add">+		nouveau_dsm_pci_probe(pdev, &amp;dhandle, &amp;has_mux, &amp;has_optimus,</span>
<span class="p_add">+				      &amp;has_optimus_flags);</span>
 	}
 
 	/* find the optimus DSM or the old v1 DSM */
<span class="p_del">-	if (has_optimus == 1) {</span>
<span class="p_add">+	if (has_optimus) {</span>
<span class="p_add">+		nouveau_dsm_priv.dhandle = dhandle;</span>
 		acpi_get_name(nouveau_dsm_priv.dhandle, ACPI_FULL_PATHNAME,
 			&amp;buffer);
 		printk(KERN_INFO &quot;VGA switcheroo: detected Optimus DSM method %s handle\n&quot;,
 			acpi_method_name);
 		nouveau_dsm_priv.optimus_detected = true;
<span class="p_add">+		nouveau_dsm_priv.optimus_flags_detected = has_optimus_flags;</span>
 		ret = true;
<span class="p_del">-	} else if (vga_count == 2 &amp;&amp; has_dsm &amp;&amp; guid_valid) {</span>
<span class="p_add">+	} else if (vga_count == 2 &amp;&amp; has_mux &amp;&amp; guid_valid) {</span>
<span class="p_add">+		nouveau_dsm_priv.dhandle = dhandle;</span>
 		acpi_get_name(nouveau_dsm_priv.dhandle, ACPI_FULL_PATHNAME,
 			&amp;buffer);
 		printk(KERN_INFO &quot;VGA switcheroo: detected DSM switching method %s handle\n&quot;,
<span class="p_chunk">@@ -336,8 +339,9 @@</span> <span class="p_context"> void nouveau_switcheroo_optimus_dsm(void)</span>
 	if (!nouveau_dsm_priv.optimus_detected)
 		return;
 
<span class="p_del">-	nouveau_optimus_dsm(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_OPTIMUS_FLAGS,</span>
<span class="p_del">-			    0x3, &amp;result);</span>
<span class="p_add">+	if (nouveau_dsm_priv.optimus_flags_detected)</span>
<span class="p_add">+		nouveau_optimus_dsm(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_OPTIMUS_FLAGS,</span>
<span class="p_add">+				    0x3, &amp;result);</span>
 
 	nouveau_optimus_dsm(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_OPTIMUS_CAPS,
 		NOUVEAU_DSM_OPTIMUS_SET_POWERDOWN, &amp;result);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_drm.c b/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_header">index 84a8b9fb20c8..9604d14e2094 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_chunk">@@ -472,7 +472,10 @@</span> <span class="p_context"> nouveau_drm_unload(struct drm_device *dev)</span>
 {
 	struct nouveau_drm *drm = nouveau_drm(dev);
 
<span class="p_del">-	pm_runtime_get_sync(dev-&gt;dev);</span>
<span class="p_add">+	if (nouveau_runtime_pm != 0) {</span>
<span class="p_add">+		pm_runtime_get_sync(dev-&gt;dev);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	nouveau_fbcon_fini(dev);
 	nouveau_accel_fini(drm);
 	nouveau_hwmon_fini(dev);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv04_fbcon.c b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">index cf4ad5142f21..fba084558969 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_chunk">@@ -109,11 +109,11 @@</span> <span class="p_context"> nv04_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 			 ((image-&gt;dx + image-&gt;width) &amp; 0xffff));
 	OUT_RING(chan, bg);
 	OUT_RING(chan, fg);
<span class="p_del">-	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | image-&gt;width);</span>
<span class="p_add">+	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | ALIGN(image-&gt;width, 8));</span>
 	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | image-&gt;width);
 	OUT_RING(chan, (image-&gt;dy &lt;&lt; 16) | (image-&gt;dx &amp; 0xffff));
 
<span class="p_del">-	dsize = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_add">+	dsize = ALIGN(ALIGN(image-&gt;width, 8) * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dsize) {
 		int iter_len = dsize &gt; 128 ? 128 : dsize;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv50_fbcon.c b/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_header">index 3860b7443e90..e9f65ac0fb78 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> nv50_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	OUT_RING(chan, 0);
 	OUT_RING(chan, image-&gt;dy);
 
<span class="p_del">-	dwords = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_add">+	dwords = ALIGN(ALIGN(image-&gt;width, 8) * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dwords) {
 		int push = dwords &gt; 2047 ? 2047 : dwords;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvc0_fbcon.c b/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_header">index fff0a1a33df0..4327d8e85dfc 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> nvc0_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	OUT_RING  (chan, 0);
 	OUT_RING  (chan, image-&gt;dy);
 
<span class="p_del">-	dwords = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_add">+	dwords = ALIGN(ALIGN(image-&gt;width, 8) * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dwords) {
 		int push = dwords &gt; 2047 ? 2047 : dwords;
 
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_draw.c b/drivers/gpu/drm/qxl/qxl_draw.c</span>
<span class="p_header">index 56e1d633875e..6e6c76080d6a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_draw.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_draw.c</span>
<span class="p_chunk">@@ -136,6 +136,8 @@</span> <span class="p_context"> static int qxl_palette_create_1bit(struct qxl_bo *palette_bo,</span>
 				 * correctly globaly, since that would require
 				 * tracking all of our palettes. */
 	ret = qxl_bo_kmap(palette_bo, (void **)&amp;pal);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	pal-&gt;num_ents = 2;
 	pal-&gt;unique = unique++;
 	if (visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR) {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index 6af1728c5c2b..d38799899ca9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -119,6 +119,7 @@</span> <span class="p_context"> atombios_set_backlight_level(struct radeon_encoder *radeon_encoder, u8 level)</span>
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
<span class="p_add">+		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:</span>
 			if (dig-&gt;backlight_level == 0)
 				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);
 			else {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">index 0bf38157dfc3..dc86c87e01a0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_chunk">@@ -1128,7 +1128,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		    le16_to_cpu(firmware_info-&gt;info.usReferenceClock);
 		p1pll-&gt;reference_div = 0;
 
<span class="p_del">-		if (crev &lt; 2)</span>
<span class="p_add">+		if ((frev &lt; 2) &amp;&amp; (crev &lt; 2))</span>
 			p1pll-&gt;pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info.usMinPixelClockPLL_Output);
 		else
<span class="p_chunk">@@ -1137,7 +1137,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		p1pll-&gt;pll_out_max =
 		    le32_to_cpu(firmware_info-&gt;info.ulMaxPixelClockPLL_Output);
 
<span class="p_del">-		if (crev &gt;= 4) {</span>
<span class="p_add">+		if (((frev &lt; 2) &amp;&amp; (crev &gt;= 4)) || (frev &gt;= 2)) {</span>
 			p1pll-&gt;lcd_pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info_14.usLcdMinPixelClockPLL_Output) * 100;
 			if (p1pll-&gt;lcd_pll_out_min == 0)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">index a9fb0d016d38..ba95c4934c8d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/acpi.h&gt;
 #include &lt;linux/pci.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 
 #include &quot;radeon_acpi.h&quot;
 
<span class="p_chunk">@@ -256,6 +257,10 @@</span> <span class="p_context"> static int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)</span>
 		if (!info)
 			return -EIO;
 		kfree(info);
<span class="p_add">+</span>
<span class="p_add">+		/* 200ms delay is required after off */</span>
<span class="p_add">+		if (state == 0)</span>
<span class="p_add">+			msleep(200);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 508eed9f8071..e77ddbcc9d56 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -1835,7 +1835,6 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 						      1);
 			/* no HPD on analog connectors */
 			radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 			connector-&gt;interlace_allowed = true;
 			connector-&gt;doublescan_allowed = true;
 			break;
<span class="p_chunk">@@ -2060,8 +2059,10 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
 
<span class="p_chunk">@@ -2137,7 +2138,6 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 					      1);
 		/* no HPD on analog connectors */
 		radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-		connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 		connector-&gt;interlace_allowed = true;
 		connector-&gt;doublescan_allowed = true;
 		break;
<span class="p_chunk">@@ -2222,10 +2222,13 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
<span class="p_add">+</span>
 	connector-&gt;display_info.subpixel_order = subpixel_order;
 	drm_sysfs_connector_add(connector);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index 821c86bc70c2..7a7a4af75630 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 #include &lt;drm/drmP.h&gt;
 #include &lt;drm/drm_crtc_helper.h&gt;
 #include &lt;drm/radeon_drm.h&gt;
<span class="p_add">+#include &lt;linux/pm_runtime.h&gt;</span>
 #include &lt;linux/vgaarb.h&gt;
 #include &lt;linux/vga_switcheroo.h&gt;
 #include &lt;linux/efi.h&gt;
<span class="p_chunk">@@ -1465,6 +1466,9 @@</span> <span class="p_context"> int radeon_device_init(struct radeon_device *rdev,</span>
 	return 0;
 
 failed:
<span class="p_add">+	/* balance pm_runtime_get_sync() in radeon_driver_unload_kms() */</span>
<span class="p_add">+	if (radeon_is_px(ddev))</span>
<span class="p_add">+		pm_runtime_put_noidle(ddev-&gt;dev);</span>
 	if (runtime)
 		vga_switcheroo_fini_domain_pm_ops(rdev-&gt;dev);
 	return r;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_kms.c b/drivers/gpu/drm/radeon/radeon_kms.c</span>
<span class="p_header">index b63094746b50..907ad15a8485 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_kms.c</span>
<span class="p_chunk">@@ -61,7 +61,9 @@</span> <span class="p_context"> int radeon_driver_unload_kms(struct drm_device *dev)</span>
 	if (rdev-&gt;rmmio == NULL)
 		goto done_free;
 
<span class="p_del">-	pm_runtime_get_sync(dev-&gt;dev);</span>
<span class="p_add">+	if (radeon_is_px(dev)) {</span>
<span class="p_add">+		pm_runtime_get_sync(dev-&gt;dev);</span>
<span class="p_add">+	}</span>
 
 	radeon_acpi_fini(rdev);
 	
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">index c4675b9729c9..56ff46e68c54 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_chunk">@@ -232,8 +232,8 @@</span> <span class="p_context"> static int radeon_move_blit(struct ttm_buffer_object *bo,</span>
 
 	rdev = radeon_get_rdev(bo-&gt;bdev);
 	ridx = radeon_copy_ring_index(rdev);
<span class="p_del">-	old_start = old_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-	new_start = new_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	old_start = (u64)old_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	new_start = (u64)new_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
 
 	switch (old_mem-&gt;mem_type) {
 	case TTM_PL_VRAM:
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 92d849e68f14..12527d69877c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -3022,6 +3022,12 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 	if (rdev-&gt;pdev-&gt;device == 0x6811 &amp;&amp;
 	    rdev-&gt;pdev-&gt;revision == 0x81)
 		max_mclk = 120000;
<span class="p_add">+	/* limit sclk/mclk on Jet parts for stability */</span>
<span class="p_add">+	if (rdev-&gt;pdev-&gt;device == 0x6665 &amp;&amp;</span>
<span class="p_add">+	    rdev-&gt;pdev-&gt;revision == 0xc3) {</span>
<span class="p_add">+		max_sclk = 75000;</span>
<span class="p_add">+		max_mclk = 80000;</span>
<span class="p_add">+	}</span>
 
 	/* XXX validate the min clocks required for display */
 
<span class="p_header">diff --git a/drivers/hid/uhid.c b/drivers/hid/uhid.c</span>
<span class="p_header">index 0cb92e347258..e0453b6a21a8 100644</span>
<span class="p_header">--- a/drivers/hid/uhid.c</span>
<span class="p_header">+++ b/drivers/hid/uhid.c</span>
<span class="p_chunk">@@ -49,10 +49,26 @@</span> <span class="p_context"> struct uhid_device {</span>
 	atomic_t report_done;
 	atomic_t report_id;
 	struct uhid_event report_buf;
<span class="p_add">+	struct work_struct worker;</span>
 };
 
 static struct miscdevice uhid_misc;
 
<span class="p_add">+static void uhid_device_add_worker(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct uhid_device *uhid = container_of(work, struct uhid_device, worker);</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hid_add_device(uhid-&gt;hid);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		hid_err(uhid-&gt;hid, &quot;Cannot register HID device: error %d\n&quot;, ret);</span>
<span class="p_add">+</span>
<span class="p_add">+		hid_destroy_device(uhid-&gt;hid);</span>
<span class="p_add">+		uhid-&gt;hid = NULL;</span>
<span class="p_add">+		uhid-&gt;running = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void uhid_queue(struct uhid_device *uhid, struct uhid_event *ev)
 {
 	__u8 newhead;
<span class="p_chunk">@@ -471,18 +487,14 @@</span> <span class="p_context"> static int uhid_dev_create2(struct uhid_device *uhid,</span>
 	uhid-&gt;hid = hid;
 	uhid-&gt;running = true;
 
<span class="p_del">-	ret = hid_add_device(hid);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		hid_err(hid, &quot;Cannot register HID device\n&quot;);</span>
<span class="p_del">-		goto err_hid;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Adding of a HID device is done through a worker, to allow HID drivers</span>
<span class="p_add">+	 * which use feature requests during .probe to work, without they would</span>
<span class="p_add">+	 * be blocked on devlock, which is held by uhid_char_write.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	schedule_work(&amp;uhid-&gt;worker);</span>
 
 	return 0;
 
<span class="p_del">-err_hid:</span>
<span class="p_del">-	hid_destroy_device(hid);</span>
<span class="p_del">-	uhid-&gt;hid = NULL;</span>
<span class="p_del">-	uhid-&gt;running = false;</span>
 err_free:
 	kfree(uhid-&gt;rd_data);
 	return ret;
<span class="p_chunk">@@ -499,6 +511,8 @@</span> <span class="p_context"> static int uhid_dev_destroy(struct uhid_device *uhid)</span>
 	atomic_set(&amp;uhid-&gt;report_done, 1);
 	wake_up_interruptible(&amp;uhid-&gt;report_wait);
 
<span class="p_add">+	cancel_work_sync(&amp;uhid-&gt;worker);</span>
<span class="p_add">+</span>
 	hid_destroy_device(uhid-&gt;hid);
 	kfree(uhid-&gt;rd_data);
 
<span class="p_chunk">@@ -567,6 +581,7 @@</span> <span class="p_context"> static int uhid_char_open(struct inode *inode, struct file *file)</span>
 	init_waitqueue_head(&amp;uhid-&gt;report_wait);
 	uhid-&gt;running = false;
 	atomic_set(&amp;uhid-&gt;report_done, 1);
<span class="p_add">+	INIT_WORK(&amp;uhid-&gt;worker, uhid_device_add_worker);</span>
 
 	file-&gt;private_data = uhid;
 	nonseekable_open(inode, file);
<span class="p_header">diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c</span>
<span class="p_header">index 233da0b9f4b9..1f2fff71dbe3 100644</span>
<span class="p_header">--- a/drivers/hv/vmbus_drv.c</span>
<span class="p_header">+++ b/drivers/hv/vmbus_drv.c</span>
<span class="p_chunk">@@ -33,6 +33,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/hyperv.h&gt;
 #include &lt;linux/kernel_stat.h&gt;
 #include &lt;linux/cpu.h&gt;
<span class="p_add">+#include &lt;linux/random.h&gt;</span>
 #include &lt;asm/hyperv.h&gt;
 #include &lt;asm/hypervisor.h&gt;
 #include &lt;asm/mshyperv.h&gt;
<span class="p_chunk">@@ -795,6 +796,8 @@</span> <span class="p_context"> int __vmbus_driver_register(struct hv_driver *hv_driver, struct module *owner, c</span>
 EXPORT_SYMBOL_GPL(__vmbus_driver_register);
 
 /**
<span class="p_add">+</span>
<span class="p_add">+	add_interrupt_randomness(HYPERVISOR_CALLBACK_VECTOR, 0);</span>
  * vmbus_driver_unregister() - Unregister a vmbus&#39;s driver
  * @drv: Pointer to driver structure you want to un-register
  *
<span class="p_header">diff --git a/drivers/hwmon/adt7411.c b/drivers/hwmon/adt7411.c</span>
<span class="p_header">index d9299dee37d1..dddaa161aadb 100644</span>
<span class="p_header">--- a/drivers/hwmon/adt7411.c</span>
<span class="p_header">+++ b/drivers/hwmon/adt7411.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 
 #define ADT7411_REG_CFG1			0x18
 #define ADT7411_CFG1_START_MONITOR		(1 &lt;&lt; 0)
<span class="p_add">+#define ADT7411_CFG1_RESERVED_BIT3		(1 &lt;&lt; 3)</span>
 
 #define ADT7411_REG_CFG2			0x19
 #define ADT7411_CFG2_DISABLE_AVG		(1 &lt;&lt; 5)
<span class="p_chunk">@@ -292,8 +293,10 @@</span> <span class="p_context"> static int adt7411_probe(struct i2c_client *client,</span>
 	mutex_init(&amp;data-&gt;device_lock);
 	mutex_init(&amp;data-&gt;update_lock);
 
<span class="p_add">+	/* According to the datasheet, we must only write 1 to bit 3 */</span>
 	ret = adt7411_modify_bit(client, ADT7411_REG_CFG1,
<span class="p_del">-				 ADT7411_CFG1_START_MONITOR, 1);</span>
<span class="p_add">+				 ADT7411_CFG1_RESERVED_BIT3</span>
<span class="p_add">+				 | ADT7411_CFG1_START_MONITOR, 1);</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-efm32.c b/drivers/i2c/busses/i2c-efm32.c</span>
<span class="p_header">index f7eccd682de9..599e620fd8da 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-efm32.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-efm32.c</span>
<span class="p_chunk">@@ -427,7 +427,7 @@</span> <span class="p_context"> static int efm32_i2c_probe(struct platform_device *pdev)</span>
 	ret = request_irq(ddata-&gt;irq, efm32_i2c_irq, 0, DRIVER_NAME, ddata);
 	if (ret &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request irq (%d)\n&quot;, ret);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err_disable_clk;</span>
 	}
 
 	ret = i2c_add_adapter(&amp;ddata-&gt;adapter);
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-eg20t.c b/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_header">index a44ea13d1434..85f33003c38b 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_chunk">@@ -777,13 +777,6 @@</span> <span class="p_context"> static int pch_i2c_probe(struct pci_dev *pdev,</span>
 	/* Set the number of I2C channel instance */
 	adap_info-&gt;ch_num = id-&gt;driver_data;
 
<span class="p_del">-	ret = request_irq(pdev-&gt;irq, pch_i2c_handler, IRQF_SHARED,</span>
<span class="p_del">-		  KBUILD_MODNAME, adap_info);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		pch_pci_err(pdev, &quot;request_irq FAILED\n&quot;);</span>
<span class="p_del">-		goto err_request_irq;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; adap_info-&gt;ch_num; i++) {
 		pch_adap = &amp;adap_info-&gt;pch_data[i].pch_adapter;
 		adap_info-&gt;pch_i2c_suspended = false;
<span class="p_chunk">@@ -800,6 +793,17 @@</span> <span class="p_context"> static int pch_i2c_probe(struct pci_dev *pdev,</span>
 		adap_info-&gt;pch_data[i].pch_base_address = base_addr + 0x100 * i;
 
 		pch_adap-&gt;dev.parent = &amp;pdev-&gt;dev;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = request_irq(pdev-&gt;irq, pch_i2c_handler, IRQF_SHARED,</span>
<span class="p_add">+		  KBUILD_MODNAME, adap_info);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pch_pci_err(pdev, &quot;request_irq FAILED\n&quot;);</span>
<span class="p_add">+		goto err_request_irq;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; adap_info-&gt;ch_num; i++) {</span>
<span class="p_add">+		pch_adap = &amp;adap_info-&gt;pch_data[i].pch_adapter;</span>
 
 		pch_i2c_init(&amp;adap_info-&gt;pch_data[i]);
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-qup.c b/drivers/i2c/busses/i2c-qup.c</span>
<span class="p_header">index eb47c98131ec..d9e6738db72c 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-qup.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-qup.c</span>
<span class="p_chunk">@@ -724,7 +724,8 @@</span> <span class="p_context"> static int qup_i2c_pm_resume_runtime(struct device *device)</span>
 #ifdef CONFIG_PM_SLEEP
 static int qup_i2c_suspend(struct device *device)
 {
<span class="p_del">-	qup_i2c_pm_suspend_runtime(device);</span>
<span class="p_add">+	if (!pm_runtime_suspended(device))</span>
<span class="p_add">+		return qup_i2c_pm_suspend_runtime(device);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">index 9bd4212782ab..f1b945509477 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> static int pca954x_select_chan(struct i2c_adapter *adap,</span>
 	/* Only select the channel if its different from the last channel */
 	if (data-&gt;last_chan != regval) {
 		ret = pca954x_reg_write(adap, client, regval);
<span class="p_del">-		data-&gt;last_chan = regval;</span>
<span class="p_add">+		data-&gt;last_chan = ret ? 0 : regval;</span>
 	}
 
 	return ret;
<span class="p_header">diff --git a/drivers/iio/accel/kxsd9.c b/drivers/iio/accel/kxsd9.c</span>
<span class="p_header">index d8738d4f8df3..6bf81d95a3f4 100644</span>
<span class="p_header">--- a/drivers/iio/accel/kxsd9.c</span>
<span class="p_header">+++ b/drivers/iio/accel/kxsd9.c</span>
<span class="p_chunk">@@ -160,11 +160,13 @@</span> <span class="p_context"> static int kxsd9_read_raw(struct iio_dev *indio_dev,</span>
 		if (ret &lt; 0)
 			goto error_ret;
 		*val = ret;
<span class="p_add">+		ret = IIO_VAL_INT;</span>
 		break;
 	case IIO_CHAN_INFO_SCALE:
 		ret = spi_w8r8(st-&gt;us, KXSD9_READ(KXSD9_REG_CTRL_C));
 		if (ret &lt; 0)
 			goto error_ret;
<span class="p_add">+		*val = 0;</span>
 		*val2 = kxsd9_micro_scales[ret &amp; KXSD9_FS_MASK];
 		ret = IIO_VAL_INT_PLUS_MICRO;
 		break;
<span class="p_header">diff --git a/drivers/iio/adc/at91_adc.c b/drivers/iio/adc/at91_adc.c</span>
<span class="p_header">index fa5d299d9222..e98515fc469f 100644</span>
<span class="p_header">--- a/drivers/iio/adc/at91_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/at91_adc.c</span>
<span class="p_chunk">@@ -381,8 +381,8 @@</span> <span class="p_context"> static irqreturn_t at91_adc_rl_interrupt(int irq, void *private)</span>
 		st-&gt;ts_bufferedmeasure = false;
 		input_report_key(st-&gt;ts_input, BTN_TOUCH, 0);
 		input_sync(st-&gt;ts_input);
<span class="p_del">-	} else if (status &amp; AT91_ADC_EOC(3)) {</span>
<span class="p_del">-		/* Conversion finished */</span>
<span class="p_add">+	} else if (status &amp; AT91_ADC_EOC(3) &amp;&amp; st-&gt;ts_input) {</span>
<span class="p_add">+		/* Conversion finished and we&#39;ve a touchscreen */</span>
 		if (st-&gt;ts_bufferedmeasure) {
 			/*
 			 * Last measurement is always discarded, since it can
<span class="p_header">diff --git a/drivers/iio/adc/ti_am335x_adc.c b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">index 9d2957696b23..222cdb1caad9 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"></span>
 
 struct tiadc_device {
 	struct ti_tscadc_dev *mfd_tscadc;
<span class="p_add">+	struct mutex fifo1_lock; /* to protect fifo access */</span>
 	int channels;
 	u8 channel_line[8];
 	u8 channel_step[8];
<span class="p_chunk">@@ -341,6 +342,7 @@</span> <span class="p_context"> static int tiadc_read_raw(struct iio_dev *indio_dev,</span>
 		int *val, int *val2, long mask)
 {
 	struct tiadc_device *adc_dev = iio_priv(indio_dev);
<span class="p_add">+	int ret = IIO_VAL_INT;</span>
 	int i, map_val;
 	unsigned int fifo1count, read, stepid;
 	bool found = false;
<span class="p_chunk">@@ -354,6 +356,7 @@</span> <span class="p_context"> static int tiadc_read_raw(struct iio_dev *indio_dev,</span>
 	if (!step_en)
 		return -EINVAL;
 
<span class="p_add">+	mutex_lock(&amp;adc_dev-&gt;fifo1_lock);</span>
 	fifo1count = tiadc_readl(adc_dev, REG_FIFO1CNT);
 	while (fifo1count--)
 		tiadc_readl(adc_dev, REG_FIFO1);
<span class="p_chunk">@@ -370,7 +373,8 @@</span> <span class="p_context"> static int tiadc_read_raw(struct iio_dev *indio_dev,</span>
 
 		if (time_after(jiffies, timeout)) {
 			am335x_tsc_se_adc_done(adc_dev-&gt;mfd_tscadc);
<span class="p_del">-			return -EAGAIN;</span>
<span class="p_add">+			ret = -EAGAIN;</span>
<span class="p_add">+			goto err_unlock;</span>
 		}
 	}
 	map_val = adc_dev-&gt;channel_step[chan-&gt;scan_index];
<span class="p_chunk">@@ -396,8 +400,11 @@</span> <span class="p_context"> static int tiadc_read_raw(struct iio_dev *indio_dev,</span>
 	am335x_tsc_se_adc_done(adc_dev-&gt;mfd_tscadc);
 
 	if (found == false)
<span class="p_del">-		return -EBUSY;</span>
<span class="p_del">-	return IIO_VAL_INT;</span>
<span class="p_add">+		ret =  -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+err_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;adc_dev-&gt;fifo1_lock);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static const struct iio_info tiadc_info = {
<span class="p_chunk">@@ -444,6 +451,7 @@</span> <span class="p_context"> static int tiadc_probe(struct platform_device *pdev)</span>
 
 	tiadc_step_config(indio_dev);
 	tiadc_writel(adc_dev, REG_FIFO1THR, FIFO1_THRESHOLD);
<span class="p_add">+	mutex_init(&amp;adc_dev-&gt;fifo1_lock);</span>
 
 	err = tiadc_channel_init(indio_dev, adc_dev-&gt;channels);
 	if (err &lt; 0)
<span class="p_header">diff --git a/drivers/iio/common/hid-sensors/hid-sensor-attributes.c b/drivers/iio/common/hid-sensors/hid-sensor-attributes.c</span>
<span class="p_header">index 403dd3d8986e..b321a253eba8 100644</span>
<span class="p_header">--- a/drivers/iio/common/hid-sensors/hid-sensor-attributes.c</span>
<span class="p_header">+++ b/drivers/iio/common/hid-sensors/hid-sensor-attributes.c</span>
<span class="p_chunk">@@ -56,8 +56,8 @@</span> <span class="p_context"> struct {</span>
 	{HID_USAGE_SENSOR_ALS, 0, 1, 0},
 	{HID_USAGE_SENSOR_ALS, HID_USAGE_SENSOR_UNITS_LUX, 1, 0},
 
<span class="p_del">-	{HID_USAGE_SENSOR_PRESSURE, 0, 100000, 0},</span>
<span class="p_del">-	{HID_USAGE_SENSOR_PRESSURE, HID_USAGE_SENSOR_UNITS_PASCAL, 1, 0},</span>
<span class="p_add">+	{HID_USAGE_SENSOR_PRESSURE, 0, 100, 0},</span>
<span class="p_add">+	{HID_USAGE_SENSOR_PRESSURE, HID_USAGE_SENSOR_UNITS_PASCAL, 0, 1000},</span>
 };
 
 static int pow_10(unsigned power)
<span class="p_header">diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c</span>
<span class="p_header">index 7995c68c2a34..230cbdda6ce1 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-core.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-core.c</span>
<span class="p_chunk">@@ -404,9 +404,8 @@</span> <span class="p_context"> ssize_t iio_format_value(char *buf, unsigned int type, int size, int *vals)</span>
 			return sprintf(buf, &quot;%d.%09u\n&quot;, vals[0], vals[1]);
 	case IIO_VAL_FRACTIONAL:
 		tmp = div_s64((s64)vals[0] * 1000000000LL, vals[1]);
<span class="p_del">-		vals[1] = do_div(tmp, 1000000000LL);</span>
<span class="p_del">-		vals[0] = tmp;</span>
<span class="p_del">-		return sprintf(buf, &quot;%d.%09u\n&quot;, vals[0], vals[1]);</span>
<span class="p_add">+		vals[0] = (int)div_s64_rem(tmp, 1000000000, &amp;vals[1]);</span>
<span class="p_add">+		return sprintf(buf, &quot;%d.%09u\n&quot;, vals[0], abs(vals[1]));</span>
 	case IIO_VAL_FRACTIONAL_LOG2:
 		tmp = (s64)vals[0] * 1000000000LL &gt;&gt; vals[1];
 		vals[1] = do_div(tmp, 1000000000LL);
<span class="p_header">diff --git a/drivers/iio/proximity/as3935.c b/drivers/iio/proximity/as3935.c</span>
<span class="p_header">index 37c1bb2afd08..758c14703ad8 100644</span>
<span class="p_header">--- a/drivers/iio/proximity/as3935.c</span>
<span class="p_header">+++ b/drivers/iio/proximity/as3935.c</span>
<span class="p_chunk">@@ -389,7 +389,7 @@</span> <span class="p_context"> static int as3935_probe(struct spi_device *spi)</span>
 		return ret;
 	}
 
<span class="p_del">-	ret = iio_triggered_buffer_setup(indio_dev, NULL,</span>
<span class="p_add">+	ret = iio_triggered_buffer_setup(indio_dev, iio_pollfunc_store_time,</span>
 		&amp;as3935_trigger_handler, NULL);
 
 	if (ret) {
<span class="p_header">diff --git a/drivers/infiniband/core/multicast.c b/drivers/infiniband/core/multicast.c</span>
<span class="p_header">index d2360a8ef0b2..180d7f436ed5 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/multicast.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/multicast.c</span>
<span class="p_chunk">@@ -106,7 +106,6 @@</span> <span class="p_context"> struct mcast_group {</span>
 	atomic_t		refcount;
 	enum mcast_group_state	state;
 	struct ib_sa_query	*query;
<span class="p_del">-	int			query_id;</span>
 	u16			pkey_index;
 	u8			leave_state;
 	int			retries;
<span class="p_chunk">@@ -339,11 +338,7 @@</span> <span class="p_context"> static int send_join(struct mcast_group *group, struct mcast_member *member)</span>
 				       member-&gt;multicast.comp_mask,
 				       3000, GFP_KERNEL, join_handler, group,
 				       &amp;group-&gt;query);
<span class="p_del">-	if (ret &gt;= 0) {</span>
<span class="p_del">-		group-&gt;query_id = ret;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return (ret &gt; 0) ? 0 : ret;</span>
 }
 
 static int send_leave(struct mcast_group *group, u8 leave_state)
<span class="p_chunk">@@ -363,11 +358,7 @@</span> <span class="p_context"> static int send_leave(struct mcast_group *group, u8 leave_state)</span>
 				       IB_SA_MCMEMBER_REC_JOIN_STATE,
 				       3000, GFP_KERNEL, leave_handler,
 				       group, &amp;group-&gt;query);
<span class="p_del">-	if (ret &gt;= 0) {</span>
<span class="p_del">-		group-&gt;query_id = ret;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return (ret &gt; 0) ? 0 : ret;</span>
 }
 
 static void join_group(struct mcast_group *group, struct mcast_member *member,
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index 1cc83abb9b44..841cdc1554f5 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -1062,6 +1062,27 @@</span> <span class="p_context"> void handle_port_mgmt_change_event(struct work_struct *work)</span>
 
 		/* Generate GUID changed event */
 		if (changed_attr &amp; MLX4_EQ_PORT_INFO_GID_PFX_CHANGE_MASK) {
<span class="p_add">+			if (mlx4_is_master(dev-&gt;dev)) {</span>
<span class="p_add">+				union ib_gid gid;</span>
<span class="p_add">+				int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (!eqe-&gt;event.port_mgmt_change.params.port_info.gid_prefix)</span>
<span class="p_add">+					err = __mlx4_ib_query_gid(&amp;dev-&gt;ib_dev, port, 0, &amp;gid, 1);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					gid.global.subnet_prefix =</span>
<span class="p_add">+						eqe-&gt;event.port_mgmt_change.params.port_info.gid_prefix;</span>
<span class="p_add">+				if (err) {</span>
<span class="p_add">+					pr_warn(&quot;Could not change QP1 subnet prefix for port %d: query_gid error (%d)\n&quot;,</span>
<span class="p_add">+						port, err);</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					pr_debug(&quot;Changing QP1 subnet prefix for port %d. old=0x%llx. new=0x%llx\n&quot;,</span>
<span class="p_add">+						 port,</span>
<span class="p_add">+						 (u64)atomic64_read(&amp;dev-&gt;sriov.demux[port - 1].subnet_prefix),</span>
<span class="p_add">+						 be64_to_cpu(gid.global.subnet_prefix));</span>
<span class="p_add">+					atomic64_set(&amp;dev-&gt;sriov.demux[port - 1].subnet_prefix,</span>
<span class="p_add">+						     be64_to_cpu(gid.global.subnet_prefix));</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
 			mlx4_ib_dispatch_event(dev, port, IB_EVENT_GID_CHANGE);
 			/*if master, notify all slaves*/
 			if (mlx4_is_master(dev-&gt;dev))
<span class="p_chunk">@@ -2134,6 +2155,8 @@</span> <span class="p_context"> int mlx4_ib_init_sriov(struct mlx4_ib_dev *dev)</span>
 		if (err)
 			goto demux_err;
 		dev-&gt;sriov.demux[i].guid_cache[0] = gid.global.interface_id;
<span class="p_add">+		atomic64_set(&amp;dev-&gt;sriov.demux[i].subnet_prefix,</span>
<span class="p_add">+			     be64_to_cpu(gid.global.subnet_prefix));</span>
 		err = alloc_pv_object(dev, mlx4_master_func_num(dev-&gt;dev), i + 1,
 				      &amp;dev-&gt;sriov.sqps[i]);
 		if (err)
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mcg.c b/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_header">index a0559a8af4f4..0948963a7493 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_chunk">@@ -485,7 +485,7 @@</span> <span class="p_context"> static u8 get_leave_state(struct mcast_group *group)</span>
 		if (!group-&gt;members[i])
 			leave_state |= (1 &lt;&lt; i);
 
<span class="p_del">-	return leave_state &amp; (group-&gt;rec.scope_join_state &amp; 7);</span>
<span class="p_add">+	return leave_state &amp; (group-&gt;rec.scope_join_state &amp; 0xf);</span>
 }
 
 static int join_group(struct mcast_group *group, int slave, u8 join_mask)
<span class="p_chunk">@@ -560,8 +560,8 @@</span> <span class="p_context"> static void mlx4_ib_mcg_timeout_handler(struct work_struct *work)</span>
 		} else
 			mcg_warn_group(group, &quot;DRIVER BUG\n&quot;);
 	} else if (group-&gt;state == MCAST_LEAVE_SENT) {
<span class="p_del">-		if (group-&gt;rec.scope_join_state &amp; 7)</span>
<span class="p_del">-			group-&gt;rec.scope_join_state &amp;= 0xf8;</span>
<span class="p_add">+		if (group-&gt;rec.scope_join_state &amp; 0xf)</span>
<span class="p_add">+			group-&gt;rec.scope_join_state &amp;= 0xf0;</span>
 		group-&gt;state = MCAST_IDLE;
 		mutex_unlock(&amp;group-&gt;lock);
 		if (release_group(group, 1))
<span class="p_chunk">@@ -601,7 +601,7 @@</span> <span class="p_context"> static int handle_leave_req(struct mcast_group *group, u8 leave_mask,</span>
 static int handle_join_req(struct mcast_group *group, u8 join_mask,
 			   struct mcast_req *req)
 {
<span class="p_del">-	u8 group_join_state = group-&gt;rec.scope_join_state &amp; 7;</span>
<span class="p_add">+	u8 group_join_state = group-&gt;rec.scope_join_state &amp; 0xf;</span>
 	int ref = 0;
 	u16 status;
 	struct ib_sa_mcmember_data *sa_data = (struct ib_sa_mcmember_data *)req-&gt;sa_mad.data;
<span class="p_chunk">@@ -686,8 +686,8 @@</span> <span class="p_context"> static void mlx4_ib_mcg_work_handler(struct work_struct *work)</span>
 			u8 cur_join_state;
 
 			resp_join_state = ((struct ib_sa_mcmember_data *)
<span class="p_del">-						group-&gt;response_sa_mad.data)-&gt;scope_join_state &amp; 7;</span>
<span class="p_del">-			cur_join_state = group-&gt;rec.scope_join_state &amp; 7;</span>
<span class="p_add">+						group-&gt;response_sa_mad.data)-&gt;scope_join_state &amp; 0xf;</span>
<span class="p_add">+			cur_join_state = group-&gt;rec.scope_join_state &amp; 0xf;</span>
 
 			if (method == IB_MGMT_METHOD_GET_RESP) {
 				/* successfull join */
<span class="p_chunk">@@ -706,7 +706,7 @@</span> <span class="p_context"> process_requests:</span>
 		req = list_first_entry(&amp;group-&gt;pending_list, struct mcast_req,
 				       group_list);
 		sa_data = (struct ib_sa_mcmember_data *)req-&gt;sa_mad.data;
<span class="p_del">-		req_join_state = sa_data-&gt;scope_join_state &amp; 0x7;</span>
<span class="p_add">+		req_join_state = sa_data-&gt;scope_join_state &amp; 0xf;</span>
 
 		/* For a leave request, we will immediately answer the VF, and
 		 * update our internal counters. The actual leave will be sent
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mlx4_ib.h b/drivers/infiniband/hw/mlx4/mlx4_ib.h</span>
<span class="p_header">index 369da3ca5d64..5b6b3a3cf9a9 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mlx4_ib.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mlx4_ib.h</span>
<span class="p_chunk">@@ -417,7 +417,7 @@</span> <span class="p_context"> struct mlx4_ib_demux_ctx {</span>
 	struct workqueue_struct *wq;
 	struct workqueue_struct *ud_wq;
 	spinlock_t ud_lock;
<span class="p_del">-	__be64 subnet_prefix;</span>
<span class="p_add">+	atomic64_t subnet_prefix;</span>
 	__be64 guid_cache[128];
 	struct mlx4_ib_dev *dev;
 	/* the following lock protects both mcg_table and mcg_mgid0_list */
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 5fe3646b248f..6f50a21331ed 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -2149,24 +2149,27 @@</span> <span class="p_context"> static int build_mlx_header(struct mlx4_ib_sqp *sqp, struct ib_send_wr *wr,</span>
 		sqp-&gt;ud_header.grh.flow_label    =
 			ah-&gt;av.ib.sl_tclass_flowlabel &amp; cpu_to_be32(0xfffff);
 		sqp-&gt;ud_header.grh.hop_limit     = ah-&gt;av.ib.hop_limit;
<span class="p_del">-		if (is_eth)</span>
<span class="p_add">+		if (is_eth) {</span>
 			memcpy(sqp-&gt;ud_header.grh.source_gid.raw, sgid.raw, 16);
<span class="p_del">-		else {</span>
<span class="p_del">-		if (mlx4_is_mfunc(to_mdev(ib_dev)-&gt;dev)) {</span>
<span class="p_del">-			/* When multi-function is enabled, the ib_core gid</span>
<span class="p_del">-			 * indexes don&#39;t necessarily match the hw ones, so</span>
<span class="p_del">-			 * we must use our own cache */</span>
<span class="p_del">-			sqp-&gt;ud_header.grh.source_gid.global.subnet_prefix =</span>
<span class="p_del">-				to_mdev(ib_dev)-&gt;sriov.demux[sqp-&gt;qp.port - 1].</span>
<span class="p_del">-						       subnet_prefix;</span>
<span class="p_del">-			sqp-&gt;ud_header.grh.source_gid.global.interface_id =</span>
<span class="p_del">-				to_mdev(ib_dev)-&gt;sriov.demux[sqp-&gt;qp.port - 1].</span>
<span class="p_del">-					       guid_cache[ah-&gt;av.ib.gid_index];</span>
<span class="p_del">-		} else</span>
<span class="p_del">-			ib_get_cached_gid(ib_dev,</span>
<span class="p_del">-					  be32_to_cpu(ah-&gt;av.ib.port_pd) &gt;&gt; 24,</span>
<span class="p_del">-					  ah-&gt;av.ib.gid_index,</span>
<span class="p_del">-					  &amp;sqp-&gt;ud_header.grh.source_gid);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (mlx4_is_mfunc(to_mdev(ib_dev)-&gt;dev)) {</span>
<span class="p_add">+				/* When multi-function is enabled, the ib_core gid</span>
<span class="p_add">+				 * indexes don&#39;t necessarily match the hw ones, so</span>
<span class="p_add">+				 * we must use our own cache</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				sqp-&gt;ud_header.grh.source_gid.global.subnet_prefix =</span>
<span class="p_add">+					cpu_to_be64(atomic64_read(&amp;(to_mdev(ib_dev)-&gt;sriov.</span>
<span class="p_add">+								    demux[sqp-&gt;qp.port - 1].</span>
<span class="p_add">+								    subnet_prefix)));</span>
<span class="p_add">+				sqp-&gt;ud_header.grh.source_gid.global.interface_id =</span>
<span class="p_add">+					to_mdev(ib_dev)-&gt;sriov.demux[sqp-&gt;qp.port - 1].</span>
<span class="p_add">+						       guid_cache[ah-&gt;av.ib.gid_index];</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				ib_get_cached_gid(ib_dev,</span>
<span class="p_add">+						  be32_to_cpu(ah-&gt;av.ib.port_pd) &gt;&gt; 24,</span>
<span class="p_add">+						  ah-&gt;av.ib.gid_index,</span>
<span class="p_add">+						  &amp;sqp-&gt;ud_header.grh.source_gid);</span>
<span class="p_add">+			}</span>
 		}
 		memcpy(sqp-&gt;ud_header.grh.destination_gid.raw,
 		       ah-&gt;av.ib.dgid, 16);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib.h b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">index 2a7c7dc28726..51f5edc9eaf6 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_chunk">@@ -463,6 +463,7 @@</span> <span class="p_context"> void ipoib_send(struct net_device *dev, struct sk_buff *skb,</span>
 		struct ipoib_ah *address, u32 qpn);
 void ipoib_reap_ah(struct work_struct *work);
 
<span class="p_add">+struct ipoib_path *__path_find(struct net_device *dev, void *gid);</span>
 void ipoib_mark_paths_invalid(struct net_device *dev);
 void ipoib_flush_paths(struct net_device *dev);
 struct ipoib_dev_priv *ipoib_intf_alloc(const char *format);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 105eebd77ad4..9bf0c8f59d54 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -1303,6 +1303,8 @@</span> <span class="p_context"> void ipoib_cm_destroy_tx(struct ipoib_cm_tx *tx)</span>
 	}
 }
 
<span class="p_add">+#define QPN_AND_OPTIONS_OFFSET	4</span>
<span class="p_add">+</span>
 static void ipoib_cm_tx_start(struct work_struct *work)
 {
 	struct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,
<span class="p_chunk">@@ -1311,6 +1313,7 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 	struct ipoib_neigh *neigh;
 	struct ipoib_cm_tx *p;
 	unsigned long flags;
<span class="p_add">+	struct ipoib_path *path;</span>
 	int ret;
 
 	struct ib_sa_path_rec pathrec;
<span class="p_chunk">@@ -1323,7 +1326,19 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 		p = list_entry(priv-&gt;cm.start_list.next, typeof(*p), list);
 		list_del_init(&amp;p-&gt;list);
 		neigh = p-&gt;neigh;
<span class="p_add">+</span>
 		qpn = IPOIB_QPN(neigh-&gt;daddr);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * As long as the search is with these 2 locks,</span>
<span class="p_add">+		 * path existence indicates its validity.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		path = __path_find(dev, neigh-&gt;daddr + QPN_AND_OPTIONS_OFFSET);</span>
<span class="p_add">+		if (!path) {</span>
<span class="p_add">+			pr_info(&quot;%s ignore not valid path %pI6\n&quot;,</span>
<span class="p_add">+				__func__,</span>
<span class="p_add">+				neigh-&gt;daddr + QPN_AND_OPTIONS_OFFSET);</span>
<span class="p_add">+			goto free_neigh;</span>
<span class="p_add">+		}</span>
 		memcpy(&amp;pathrec, &amp;p-&gt;path-&gt;pathrec, sizeof pathrec);
 
 		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
<span class="p_chunk">@@ -1335,6 +1350,7 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 		spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 
 		if (ret) {
<span class="p_add">+free_neigh:</span>
 			neigh = p-&gt;neigh;
 			if (neigh) {
 				neigh-&gt;cm = NULL;
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ib.c b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">index 6a7003ddb0be..fcbfdda0e585 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_chunk">@@ -1030,8 +1030,17 @@</span> <span class="p_context"> static void __ipoib_ib_dev_flush(struct ipoib_dev_priv *priv,</span>
 	}
 
 	if (level == IPOIB_FLUSH_LIGHT) {
<span class="p_add">+		int oper_up;</span>
 		ipoib_mark_paths_invalid(dev);
<span class="p_add">+		/* Set IPoIB operation as down to prevent races between:</span>
<span class="p_add">+		 * the flush flow which leaves MCG and on the fly joins</span>
<span class="p_add">+		 * which can happen during that time. mcast restart task</span>
<span class="p_add">+		 * should deal with join requests we missed.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		oper_up = test_and_clear_bit(IPOIB_FLAG_OPER_UP, &amp;priv-&gt;flags);</span>
 		ipoib_mcast_dev_flush(dev);
<span class="p_add">+		if (oper_up)</span>
<span class="p_add">+			set_bit(IPOIB_FLAG_OPER_UP, &amp;priv-&gt;flags);</span>
 	}
 
 	if (level &gt;= IPOIB_FLUSH_NORMAL)
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 7e4a6efbf2ce..dbfe8f1e6d7e 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -253,7 +253,7 @@</span> <span class="p_context"> int ipoib_set_mode(struct net_device *dev, const char *buf)</span>
 	return -EINVAL;
 }
 
<span class="p_del">-static struct ipoib_path *__path_find(struct net_device *dev, void *gid)</span>
<span class="p_add">+struct ipoib_path *__path_find(struct net_device *dev, void *gid)</span>
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct rb_node *n = priv-&gt;path_tree.rb_node;
<span class="p_header">diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c</span>
<span class="p_header">index e2c655964711..a137a3738128 100644</span>
<span class="p_header">--- a/drivers/input/joystick/xpad.c</span>
<span class="p_header">+++ b/drivers/input/joystick/xpad.c</span>
<span class="p_chunk">@@ -883,6 +883,9 @@</span> <span class="p_context"> static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	struct usb_endpoint_descriptor *ep_irq_in;
 	int i, error;
 
<span class="p_add">+	if (intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints != 2)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	for (i = 0; xpad_device[i].idVendor; i++) {
 		if ((le16_to_cpu(udev-&gt;descriptor.idVendor) == xpad_device[i].idVendor) &amp;&amp;
 		    (le16_to_cpu(udev-&gt;descriptor.idProduct) == xpad_device[i].idProduct))
<span class="p_header">diff --git a/drivers/input/keyboard/tegra-kbc.c b/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_header">index 9757a58bc897..5d39b966dd28 100644</span>
<span class="p_header">--- a/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_header">+++ b/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_chunk">@@ -376,7 +376,7 @@</span> <span class="p_context"> static int tegra_kbc_start(struct tegra_kbc *kbc)</span>
 	/* Reset the KBC controller to clear all previous status.*/
 	reset_control_assert(kbc-&gt;rst);
 	udelay(100);
<span class="p_del">-	reset_control_assert(kbc-&gt;rst);</span>
<span class="p_add">+	reset_control_deassert(kbc-&gt;rst);</span>
 	udelay(100);
 
 	tegra_kbc_config_pins(kbc);
<span class="p_header">diff --git a/drivers/input/serio/i8042.c b/drivers/input/serio/i8042.c</span>
<span class="p_header">index eb796fff9e62..9a0cc5b5561a 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042.c</span>
<span class="p_header">+++ b/drivers/input/serio/i8042.c</span>
<span class="p_chunk">@@ -1230,6 +1230,7 @@</span> <span class="p_context"> static int __init i8042_create_kbd_port(void)</span>
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
 	serio-&gt;close		= i8042_port_close;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	strlcpy(serio-&gt;name, &quot;i8042 KBD port&quot;, sizeof(serio-&gt;name));
<span class="p_chunk">@@ -1257,6 +1258,7 @@</span> <span class="p_context"> static int __init i8042_create_aux_port(int idx)</span>
 	serio-&gt;write		= i8042_aux_write;
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	if (idx &lt; 0) {
<span class="p_chunk">@@ -1321,21 +1323,6 @@</span> <span class="p_context"> static void i8042_unregister_ports(void)</span>
 	}
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Checks whether port belongs to i8042 controller.</span>
<span class="p_del">- */</span>
<span class="p_del">-bool i8042_check_port_owner(const struct serio *port)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; I8042_NUM_PORTS; i++)</span>
<span class="p_del">-		if (i8042_ports[i].serio == port)</span>
<span class="p_del">-			return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(i8042_check_port_owner);</span>
<span class="p_del">-</span>
 static void i8042_free_irqs(void)
 {
 	if (i8042_aux_irq_registered)
<span class="p_header">diff --git a/drivers/input/serio/libps2.c b/drivers/input/serio/libps2.c</span>
<span class="p_header">index 75516996db20..ded0c6f65c9f 100644</span>
<span class="p_header">--- a/drivers/input/serio/libps2.c</span>
<span class="p_header">+++ b/drivers/input/serio/libps2.c</span>
<span class="p_chunk">@@ -56,19 +56,17 @@</span> <span class="p_context"> EXPORT_SYMBOL(ps2_sendbyte);</span>
 
 void ps2_begin_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	mutex_lock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_lock_chip();</span>
<span class="p_add">+	mutex_lock(m);</span>
 }
 EXPORT_SYMBOL(ps2_begin_command);
 
 void ps2_end_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_unlock_chip();</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	mutex_unlock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	mutex_unlock(m);</span>
 }
 EXPORT_SYMBOL(ps2_end_command);
 
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index 3b260c67db75..af7bae7b4daf 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -1829,7 +1829,7 @@</span> <span class="p_context"> static int cache_alloc(struct cache_sb *sb, struct cache *ca)</span>
 	free = roundup_pow_of_two(ca-&gt;sb.nbuckets) &gt;&gt; 10;
 
 	if (!init_fifo(&amp;ca-&gt;free[RESERVE_BTREE], 8, GFP_KERNEL) ||
<span class="p_del">-	    !init_fifo(&amp;ca-&gt;free[RESERVE_PRIO], prio_buckets(ca), GFP_KERNEL) ||</span>
<span class="p_add">+	    !init_fifo_exact(&amp;ca-&gt;free[RESERVE_PRIO], prio_buckets(ca), GFP_KERNEL) ||</span>
 	    !init_fifo(&amp;ca-&gt;free[RESERVE_MOVINGGC], free, GFP_KERNEL) ||
 	    !init_fifo(&amp;ca-&gt;free[RESERVE_NONE], free, GFP_KERNEL) ||
 	    !init_fifo(&amp;ca-&gt;free_inc,	free &lt;&lt; 2, GFP_KERNEL) ||
<span class="p_chunk">@@ -1854,7 +1854,7 @@</span> <span class="p_context"> static int register_cache(struct cache_sb *sb, struct page *sb_page,</span>
 				  struct block_device *bdev, struct cache *ca)
 {
 	char name[BDEVNAME_SIZE];
<span class="p_del">-	const char *err = NULL;</span>
<span class="p_add">+	const char *err = NULL; /* must be set for any error case */</span>
 	int ret = 0;
 
 	memcpy(&amp;ca-&gt;sb, sb, sizeof(struct cache_sb));
<span class="p_chunk">@@ -1871,8 +1871,13 @@</span> <span class="p_context"> static int register_cache(struct cache_sb *sb, struct page *sb_page,</span>
 		ca-&gt;discard = CACHE_DISCARD(&amp;ca-&gt;sb);
 
 	ret = cache_alloc(sb, ca);
<span class="p_del">-	if (ret != 0)</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		if (ret == -ENOMEM)</span>
<span class="p_add">+			err = &quot;cache_alloc(): -ENOMEM&quot;;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			err = &quot;cache_alloc(): unknown error&quot;;</span>
 		goto err;
<span class="p_add">+	}</span>
 
 	if (kobject_add(&amp;ca-&gt;kobj, &amp;part_to_dev(bdev-&gt;bd_part)-&gt;kobj, &quot;bcache&quot;)) {
 		err = &quot;error calling kobject_add&quot;;
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index f87223056696..34e7db1e7304 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -1400,7 +1400,7 @@</span> <span class="p_context"> static int crypt_alloc_tfms(struct crypt_config *cc, char *ciphermode)</span>
 	unsigned i;
 	int err;
 
<span class="p_del">-	cc-&gt;tfms = kmalloc(cc-&gt;tfms_count * sizeof(struct crypto_ablkcipher *),</span>
<span class="p_add">+	cc-&gt;tfms = kzalloc(cc-&gt;tfms_count * sizeof(struct crypto_ablkcipher *),</span>
 			   GFP_KERNEL);
 	if (!cc-&gt;tfms)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/md/dm-flakey.c b/drivers/md/dm-flakey.c</span>
<span class="p_header">index b257e46876d3..0f5e1820c92d 100644</span>
<span class="p_header">--- a/drivers/md/dm-flakey.c</span>
<span class="p_header">+++ b/drivers/md/dm-flakey.c</span>
<span class="p_chunk">@@ -287,10 +287,16 @@</span> <span class="p_context"> static int flakey_map(struct dm_target *ti, struct bio *bio)</span>
 		pb-&gt;bio_submitted = true;
 
 		/*
<span class="p_del">-		 * Map reads as normal.</span>
<span class="p_add">+		 * Map reads as normal only if corrupt_bio_byte set.</span>
 		 */
<span class="p_del">-		if (bio_data_dir(bio) == READ)</span>
<span class="p_del">-			goto map_bio;</span>
<span class="p_add">+		if (bio_data_dir(bio) == READ) {</span>
<span class="p_add">+			/* If flags were specified, only corrupt those that match. */</span>
<span class="p_add">+			if (fc-&gt;corrupt_bio_byte &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_add">+			    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_add">+				goto map_bio;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				return -EIO;</span>
<span class="p_add">+		}</span>
 
 		/*
 		 * Drop writes?
<span class="p_chunk">@@ -328,12 +334,13 @@</span> <span class="p_context"> static int flakey_end_io(struct dm_target *ti, struct bio *bio, int error)</span>
 
 	/*
 	 * Corrupt successful READs while in down state.
<span class="p_del">-	 * If flags were specified, only corrupt those that match.</span>
 	 */
<span class="p_del">-	if (fc-&gt;corrupt_bio_byte &amp;&amp; !error &amp;&amp; pb-&gt;bio_submitted &amp;&amp;</span>
<span class="p_del">-	    (bio_data_dir(bio) == READ) &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_del">-	    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_del">-		corrupt_bio_data(bio, fc);</span>
<span class="p_add">+	if (!error &amp;&amp; pb-&gt;bio_submitted &amp;&amp; (bio_data_dir(bio) == READ)) {</span>
<span class="p_add">+		if (fc-&gt;corrupt_bio_byte)</span>
<span class="p_add">+			corrupt_bio_data(bio, fc);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+	}</span>
 
 	return error;
 }
<span class="p_header">diff --git a/drivers/media/dvb-core/dvb_ringbuffer.c b/drivers/media/dvb-core/dvb_ringbuffer.c</span>
<span class="p_header">index a5712cd7c65f..7df7fb3738a0 100644</span>
<span class="p_header">--- a/drivers/media/dvb-core/dvb_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/media/dvb-core/dvb_ringbuffer.c</span>
<span class="p_chunk">@@ -55,7 +55,13 @@</span> <span class="p_context"> void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data, size_t len)</span>
 
 int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf)
 {
<span class="p_del">-	return (rbuf-&gt;pread==rbuf-&gt;pwrite);</span>
<span class="p_add">+	/* smp_load_acquire() to load write pointer on reader side</span>
<span class="p_add">+	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),</span>
<span class="p_add">+	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * for memory barriers also see Documentation/circular-buffers.txt</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return (rbuf-&gt;pread == smp_load_acquire(&amp;rbuf-&gt;pwrite));</span>
 }
 
 
<span class="p_chunk">@@ -64,7 +70,12 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)</span>
 {
 	ssize_t free;
 
<span class="p_del">-	free = rbuf-&gt;pread - rbuf-&gt;pwrite;</span>
<span class="p_add">+	/* ACCESS_ONCE() to load read pointer on writer side</span>
<span class="p_add">+	 * this pairs with smp_store_release() in dvb_ringbuffer_read(),</span>
<span class="p_add">+	 * dvb_ringbuffer_read_user(), dvb_ringbuffer_flush(),</span>
<span class="p_add">+	 * or dvb_ringbuffer_reset()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	free = ACCESS_ONCE(rbuf-&gt;pread) - rbuf-&gt;pwrite;</span>
 	if (free &lt;= 0)
 		free += rbuf-&gt;size;
 	return free-1;
<span class="p_chunk">@@ -76,7 +87,11 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)</span>
 {
 	ssize_t avail;
 
<span class="p_del">-	avail = rbuf-&gt;pwrite - rbuf-&gt;pread;</span>
<span class="p_add">+	/* smp_load_acquire() to load write pointer on reader side</span>
<span class="p_add">+	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),</span>
<span class="p_add">+	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	avail = smp_load_acquire(&amp;rbuf-&gt;pwrite) - rbuf-&gt;pread;</span>
 	if (avail &lt; 0)
 		avail += rbuf-&gt;size;
 	return avail;
<span class="p_chunk">@@ -86,14 +101,25 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)</span>
 
 void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf)
 {
<span class="p_del">-	rbuf-&gt;pread = rbuf-&gt;pwrite;</span>
<span class="p_add">+	/* dvb_ringbuffer_flush() counts as read operation</span>
<span class="p_add">+	 * smp_load_acquire() to load write pointer</span>
<span class="p_add">+	 * smp_store_release() to update read pointer, this ensures that the</span>
<span class="p_add">+	 * correct pointer is visible for subsequent dvb_ringbuffer_free()</span>
<span class="p_add">+	 * calls on other cpu cores</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, smp_load_acquire(&amp;rbuf-&gt;pwrite));</span>
 	rbuf-&gt;error = 0;
 }
 EXPORT_SYMBOL(dvb_ringbuffer_flush);
 
 void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf)
 {
<span class="p_del">-	rbuf-&gt;pread = rbuf-&gt;pwrite = 0;</span>
<span class="p_add">+	/* dvb_ringbuffer_reset() counts as read and write operation</span>
<span class="p_add">+	 * smp_store_release() to update read pointer</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, 0);</span>
<span class="p_add">+	/* smp_store_release() to update write pointer */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pwrite, 0);</span>
 	rbuf-&gt;error = 0;
 }
 
<span class="p_chunk">@@ -119,12 +145,17 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf, u8 __user *buf, si</span>
 			return -EFAULT;
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pread = 0;</span>
<span class="p_add">+		/* smp_store_release() for read pointer update to ensure</span>
<span class="p_add">+		 * that buf is not overwritten until read is complete,</span>
<span class="p_add">+		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pread, 0);</span>
 	}
 	if (copy_to_user(buf, rbuf-&gt;data+rbuf-&gt;pread, todo))
 		return -EFAULT;
 
<span class="p_del">-	rbuf-&gt;pread = (rbuf-&gt;pread + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() to update read pointer, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, (rbuf-&gt;pread + todo) % rbuf-&gt;size);</span>
 
 	return len;
 }
<span class="p_chunk">@@ -139,11 +170,16 @@</span> <span class="p_context"> void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len)</span>
 		memcpy(buf, rbuf-&gt;data+rbuf-&gt;pread, split);
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pread = 0;</span>
<span class="p_add">+		/* smp_store_release() for read pointer update to ensure</span>
<span class="p_add">+		 * that buf is not overwritten until read is complete,</span>
<span class="p_add">+		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pread, 0);</span>
 	}
 	memcpy(buf, rbuf-&gt;data+rbuf-&gt;pread, todo);
 
<span class="p_del">-	rbuf-&gt;pread = (rbuf-&gt;pread + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() to update read pointer, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, (rbuf-&gt;pread + todo) % rbuf-&gt;size);</span>
 }
 
 
<span class="p_chunk">@@ -158,10 +194,47 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t</span>
 		memcpy(rbuf-&gt;data+rbuf-&gt;pwrite, buf, split);
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pwrite = 0;</span>
<span class="p_add">+		/* smp_store_release() for write pointer update to ensure that</span>
<span class="p_add">+		 * written data is visible on other cpu cores before the pointer</span>
<span class="p_add">+		 * update, this pairs with smp_load_acquire() in</span>
<span class="p_add">+		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pwrite, 0);</span>
 	}
 	memcpy(rbuf-&gt;data+rbuf-&gt;pwrite, buf, todo);
<span class="p_del">-	rbuf-&gt;pwrite = (rbuf-&gt;pwrite + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() for write pointer update, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pwrite, (rbuf-&gt;pwrite + todo) % rbuf-&gt;size);</span>
<span class="p_add">+</span>
<span class="p_add">+	return len;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+ssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,</span>
<span class="p_add">+				  const u8 __user *buf, size_t len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+	size_t todo = len;</span>
<span class="p_add">+	size_t split;</span>
<span class="p_add">+</span>
<span class="p_add">+	split = (rbuf-&gt;pwrite + len &gt; rbuf-&gt;size) ? rbuf-&gt;size - rbuf-&gt;pwrite : 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (split &gt; 0) {</span>
<span class="p_add">+		status = copy_from_user(rbuf-&gt;data+rbuf-&gt;pwrite, buf, split);</span>
<span class="p_add">+		if (status)</span>
<span class="p_add">+			return len - todo;</span>
<span class="p_add">+		buf += split;</span>
<span class="p_add">+		todo -= split;</span>
<span class="p_add">+		/* smp_store_release() for write pointer update to ensure that</span>
<span class="p_add">+		 * written data is visible on other cpu cores before the pointer</span>
<span class="p_add">+		 * update, this pairs with smp_load_acquire() in</span>
<span class="p_add">+		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pwrite, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	status = copy_from_user(rbuf-&gt;data+rbuf-&gt;pwrite, buf, todo);</span>
<span class="p_add">+	if (status)</span>
<span class="p_add">+		return len - todo;</span>
<span class="p_add">+	/* smp_store_release() for write pointer update, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pwrite, (rbuf-&gt;pwrite + todo) % rbuf-&gt;size);</span>
 
 	return len;
 }
<span class="p_chunk">@@ -297,3 +370,4 @@</span> <span class="p_context"> EXPORT_SYMBOL(dvb_ringbuffer_flush_spinlock_wakeup);</span>
 EXPORT_SYMBOL(dvb_ringbuffer_read_user);
 EXPORT_SYMBOL(dvb_ringbuffer_read);
 EXPORT_SYMBOL(dvb_ringbuffer_write);
<span class="p_add">+EXPORT_SYMBOL(dvb_ringbuffer_write_user);</span>
<span class="p_header">diff --git a/drivers/media/dvb-core/dvb_ringbuffer.h b/drivers/media/dvb-core/dvb_ringbuffer.h</span>
<span class="p_header">index 41f04dae69b6..9e1e11b7c39c 100644</span>
<span class="p_header">--- a/drivers/media/dvb-core/dvb_ringbuffer.h</span>
<span class="p_header">+++ b/drivers/media/dvb-core/dvb_ringbuffer.h</span>
<span class="p_chunk">@@ -133,6 +133,8 @@</span> <span class="p_context"> extern void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf,</span>
 */
 extern ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf,
 				    size_t len);
<span class="p_add">+extern ssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,</span>
<span class="p_add">+				         const u8 __user *buf, size_t len);</span>
 
 
 /**
<span class="p_header">diff --git a/drivers/media/pci/ngene/ngene-dvb.c b/drivers/media/pci/ngene/ngene-dvb.c</span>
<span class="p_header">index fcb16a615aab..3263d71b4808 100644</span>
<span class="p_header">--- a/drivers/media/pci/ngene/ngene-dvb.c</span>
<span class="p_header">+++ b/drivers/media/pci/ngene/ngene-dvb.c</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> static ssize_t ts_write(struct file *file, const char *buf,</span>
 				     (&amp;dev-&gt;tsout_rbuf) &gt;= count) &lt; 0)
 		return 0;
 
<span class="p_del">-	dvb_ringbuffer_write(&amp;dev-&gt;tsout_rbuf, buf, count);</span>
<span class="p_add">+	dvb_ringbuffer_write_user(&amp;dev-&gt;tsout_rbuf, buf, count);</span>
 
 	return count;
 }
<span class="p_header">diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">index 41723180d10c..19c25e0245d1 100644</span>
<span class="p_header">--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_chunk">@@ -1003,6 +1003,11 @@</span> <span class="p_context"> static int match_child(struct device *dev, void *data)</span>
 	return !strcmp(dev_name(dev), (char *)data);
 }
 
<span class="p_add">+static void s5p_mfc_memdev_release(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dma_release_declared_memory(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void *mfc_get_drv_data(struct platform_device *pdev);
 
 static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)
<span class="p_chunk">@@ -1015,6 +1020,9 @@</span> <span class="p_context"> static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)</span>
 		mfc_err(&quot;Not enough memory\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+</span>
<span class="p_add">+	dev_set_name(dev-&gt;mem_dev_l, &quot;%s&quot;, &quot;s5p-mfc-l&quot;);</span>
<span class="p_add">+	dev-&gt;mem_dev_l-&gt;release = s5p_mfc_memdev_release;</span>
 	device_initialize(dev-&gt;mem_dev_l);
 	of_property_read_u32_array(dev-&gt;plat_dev-&gt;dev.of_node,
 			&quot;samsung,mfc-l&quot;, mem_info, 2);
<span class="p_chunk">@@ -1032,6 +1040,9 @@</span> <span class="p_context"> static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)</span>
 		mfc_err(&quot;Not enough memory\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+</span>
<span class="p_add">+	dev_set_name(dev-&gt;mem_dev_r, &quot;%s&quot;, &quot;s5p-mfc-r&quot;);</span>
<span class="p_add">+	dev-&gt;mem_dev_r-&gt;release = s5p_mfc_memdev_release;</span>
 	device_initialize(dev-&gt;mem_dev_r);
 	of_property_read_u32_array(dev-&gt;plat_dev-&gt;dev.of_node,
 			&quot;samsung,mfc-r&quot;, mem_info, 2);
<span class="p_header">diff --git a/drivers/media/usb/em28xx/em28xx-i2c.c b/drivers/media/usb/em28xx/em28xx-i2c.c</span>
<span class="p_header">index b58d4ebf6419..6c1737828d5f 100644</span>
<span class="p_header">--- a/drivers/media/usb/em28xx/em28xx-i2c.c</span>
<span class="p_header">+++ b/drivers/media/usb/em28xx/em28xx-i2c.c</span>
<span class="p_chunk">@@ -501,9 +501,8 @@</span> <span class="p_context"> static int em28xx_i2c_xfer(struct i2c_adapter *i2c_adap,</span>
 	int addr, rc, i;
 	u8 reg;
 
<span class="p_del">-	rc = rt_mutex_trylock(&amp;dev-&gt;i2c_bus_lock);</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		return rc;</span>
<span class="p_add">+	if (!rt_mutex_trylock(&amp;dev-&gt;i2c_bus_lock))</span>
<span class="p_add">+		return -EAGAIN;</span>
 
 	/* Switch I2C bus if needed */
 	if (bus != dev-&gt;cur_i2c_bus &amp;&amp;
<span class="p_header">diff --git a/drivers/media/usb/usbvision/usbvision-video.c b/drivers/media/usb/usbvision/usbvision-video.c</span>
<span class="p_header">index 0dd73a9caf32..354f5a7ae887 100644</span>
<span class="p_header">--- a/drivers/media/usb/usbvision/usbvision-video.c</span>
<span class="p_header">+++ b/drivers/media/usb/usbvision/usbvision-video.c</span>
<span class="p_chunk">@@ -1537,13 +1537,6 @@</span> <span class="p_context"> static int usbvision_probe(struct usb_interface *intf,</span>
 	printk(KERN_INFO &quot;%s: %s found\n&quot;, __func__,
 				usbvision_device_data[model].model_string);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * this is a security check.</span>
<span class="p_del">-	 * an exploit using an incorrect bInterfaceNumber is known</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (ifnum &gt;= USB_MAXINTERFACES || !dev-&gt;actconfig-&gt;interface[ifnum])</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
 	if (usbvision_device_data[model].interface &gt;= 0)
 		interface = &amp;dev-&gt;actconfig-&gt;interface[usbvision_device_data[model].interface]-&gt;altsetting[0];
 	else if (ifnum &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces)
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index c51e164dfae0..619c67b71ecb 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1659,8 +1659,8 @@</span> <span class="p_context"> static void mmc_blk_packed_hdr_wrq_prep(struct mmc_queue_req *mqrq,</span>
 
 	packed_cmd_hdr = packed-&gt;cmd_hdr;
 	memset(packed_cmd_hdr, 0, sizeof(packed-&gt;cmd_hdr));
<span class="p_del">-	packed_cmd_hdr[0] = (packed-&gt;nr_entries &lt;&lt; 16) |</span>
<span class="p_del">-		(PACKED_CMD_WR &lt;&lt; 8) | PACKED_CMD_VER;</span>
<span class="p_add">+	packed_cmd_hdr[0] = cpu_to_le32((packed-&gt;nr_entries &lt;&lt; 16) |</span>
<span class="p_add">+		(PACKED_CMD_WR &lt;&lt; 8) | PACKED_CMD_VER);</span>
 	hdr_blocks = mmc_large_sector(card) ? 8 : 1;
 
 	/*
<span class="p_chunk">@@ -1674,14 +1674,14 @@</span> <span class="p_context"> static void mmc_blk_packed_hdr_wrq_prep(struct mmc_queue_req *mqrq,</span>
 			((brq-&gt;data.blocks * brq-&gt;data.blksz) &gt;=
 			 card-&gt;ext_csd.data_tag_unit_size);
 		/* Argument of CMD23 */
<span class="p_del">-		packed_cmd_hdr[(i * 2)] =</span>
<span class="p_add">+		packed_cmd_hdr[(i * 2)] = cpu_to_le32(</span>
 			(do_rel_wr ? MMC_CMD23_ARG_REL_WR : 0) |
 			(do_data_tag ? MMC_CMD23_ARG_TAG_REQ : 0) |
<span class="p_del">-			blk_rq_sectors(prq);</span>
<span class="p_add">+			blk_rq_sectors(prq));</span>
 		/* Argument of CMD18 or CMD25 */
<span class="p_del">-		packed_cmd_hdr[((i * 2)) + 1] =</span>
<span class="p_add">+		packed_cmd_hdr[((i * 2)) + 1] = cpu_to_le32(</span>
 			mmc_card_blockaddr(card) ?
<span class="p_del">-			blk_rq_pos(prq) : blk_rq_pos(prq) &lt;&lt; 9;</span>
<span class="p_add">+			blk_rq_pos(prq) : blk_rq_pos(prq) &lt;&lt; 9);</span>
 		packed-&gt;blocks += blk_rq_sectors(prq);
 		i++;
 	}
<span class="p_header">diff --git a/drivers/mtd/maps/pmcmsp-flash.c b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">index 744ca5cacc9b..f9fa3fad728e 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_chunk">@@ -75,15 +75,15 @@</span> <span class="p_context"> static int __init init_msp_flash(void)</span>
 
 	printk(KERN_NOTICE &quot;Found %d PMC flash devices\n&quot;, fcnt);
 
<span class="p_del">-	msp_flash = kmalloc(fcnt * sizeof(struct map_info *), GFP_KERNEL);</span>
<span class="p_add">+	msp_flash = kcalloc(fcnt, sizeof(*msp_flash), GFP_KERNEL);</span>
 	if (!msp_flash)
 		return -ENOMEM;
 
<span class="p_del">-	msp_parts = kmalloc(fcnt * sizeof(struct mtd_partition *), GFP_KERNEL);</span>
<span class="p_add">+	msp_parts = kcalloc(fcnt, sizeof(*msp_parts), GFP_KERNEL);</span>
 	if (!msp_parts)
 		goto free_msp_flash;
 
<span class="p_del">-	msp_maps = kcalloc(fcnt, sizeof(struct mtd_info), GFP_KERNEL);</span>
<span class="p_add">+	msp_maps = kcalloc(fcnt, sizeof(*msp_maps), GFP_KERNEL);</span>
 	if (!msp_maps)
 		goto free_msp_parts;
 
<span class="p_header">diff --git a/drivers/mtd/nand/davinci_nand.c b/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_header">index b922c8efcf40..0ba96f9e1aa5 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_chunk">@@ -241,6 +241,9 @@</span> <span class="p_context"> static void nand_davinci_hwctl_4bit(struct mtd_info *mtd, int mode)</span>
 	unsigned long flags;
 	u32 val;
 
<span class="p_add">+	/* Reset ECC hardware */</span>
<span class="p_add">+	davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET);</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;davinci_nand_lock, flags);
 
 	/* Start 4-bit ECC calculation for read/write */
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 4f3e80c68a26..529f42a8d7f8 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2389,7 +2389,7 @@</span> <span class="p_context"> static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,</span>
 		int cached = writelen &gt; bytes &amp;&amp; page != blockmask;
 		uint8_t *wbuf = buf;
 		int use_bufpoi;
<span class="p_del">-		int part_pagewr = (column || writelen &lt; (mtd-&gt;writesize - 1));</span>
<span class="p_add">+		int part_pagewr = (column || writelen &lt; mtd-&gt;writesize);</span>
 
 		if (part_pagewr)
 			use_bufpoi = 1;
<span class="p_header">diff --git a/drivers/mtd/ubi/attach.c b/drivers/mtd/ubi/attach.c</span>
<span class="p_header">index 21841fe25ad3..d86742a0fefd 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/attach.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/attach.c</span>
<span class="p_chunk">@@ -807,6 +807,7 @@</span> <span class="p_context"> out_unlock:</span>
  * @pnum: the physical eraseblock number
  * @vid: The volume ID of the found volume will be stored in this pointer
  * @sqnum: The sqnum of the found volume will be stored in this pointer
<span class="p_add">+ * @fast: true if we&#39;re scanning for a Fastmap</span>
  *
  * This function reads UBI headers of PEB @pnum, checks them, and adds
  * information about this PEB to the corresponding list or RB-tree in the
<span class="p_chunk">@@ -814,7 +815,7 @@</span> <span class="p_context"> out_unlock:</span>
  * successfully handled and a negative error code in case of failure.
  */
 static int scan_peb(struct ubi_device *ubi, struct ubi_attach_info *ai,
<span class="p_del">-		    int pnum, int *vid, unsigned long long *sqnum)</span>
<span class="p_add">+		    int pnum, int *vid, unsigned long long *sqnum, bool fast)</span>
 {
 	long long uninitialized_var(ec);
 	int err, bitflips = 0, vol_id = -1, ec_err = 0;
<span class="p_chunk">@@ -931,6 +932,20 @@</span> <span class="p_context"> static int scan_peb(struct ubi_device *ubi, struct ubi_attach_info *ai,</span>
 			 */
 			ai-&gt;maybe_bad_peb_count += 1;
 	case UBI_IO_BAD_HDR:
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If we&#39;re facing a bad VID header we have to drop *all*</span>
<span class="p_add">+			 * Fastmap data structures we find. The most recent Fastmap</span>
<span class="p_add">+			 * could be bad and therefore there is a chance that we attach</span>
<span class="p_add">+			 * from an old one. On a fine MTD stack a PEB must not render</span>
<span class="p_add">+			 * bad all of a sudden, but the reality is different.</span>
<span class="p_add">+			 * So, let&#39;s be paranoid and help finding the root cause by</span>
<span class="p_add">+			 * falling back to scanning mode instead of attaching with a</span>
<span class="p_add">+			 * bad EBA table and cause data corruption which is hard to</span>
<span class="p_add">+			 * analyze.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (fast)</span>
<span class="p_add">+				ai-&gt;force_full_scan = 1;</span>
<span class="p_add">+</span>
 		if (ec_err)
 			/*
 			 * Both headers are corrupted. There is a possibility
<span class="p_chunk">@@ -1243,7 +1258,7 @@</span> <span class="p_context"> static int scan_all(struct ubi_device *ubi, struct ubi_attach_info *ai,</span>
 		cond_resched();
 
 		dbg_gen(&quot;process PEB %d&quot;, pnum);
<span class="p_del">-		err = scan_peb(ubi, ai, pnum, NULL, NULL);</span>
<span class="p_add">+		err = scan_peb(ubi, ai, pnum, NULL, NULL, false);</span>
 		if (err &lt; 0)
 			goto out_vidh;
 	}
<span class="p_chunk">@@ -1330,7 +1345,7 @@</span> <span class="p_context"> static int scan_fast(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 		cond_resched();
 
 		dbg_gen(&quot;process PEB %d&quot;, pnum);
<span class="p_del">-		err = scan_peb(ubi, ai, pnum, &amp;vol_id, &amp;sqnum);</span>
<span class="p_add">+		err = scan_peb(ubi, ai, pnum, &amp;vol_id, &amp;sqnum, true);</span>
 		if (err &lt; 0)
 			goto out_vidh;
 
<span class="p_chunk">@@ -1346,7 +1361,11 @@</span> <span class="p_context"> static int scan_fast(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 	if (fm_anchor &lt; 0)
 		return UBI_NO_FASTMAP;
 
<span class="p_del">-	return ubi_scan_fastmap(ubi, ai, fm_anchor);</span>
<span class="p_add">+	if (ai-&gt;force_full_scan)</span>
<span class="p_add">+		return UBI_NO_FASTMAP;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return ubi_scan_fastmap(ubi, ai, fm_anchor);</span>
<span class="p_add">+</span>
 
 out_vidh:
 	ubi_free_vid_hdr(ubi, vidh);
<span class="p_header">diff --git a/drivers/mtd/ubi/build.c b/drivers/mtd/ubi/build.c</span>
<span class="p_header">index 6e30a3c280d0..c3db383a9000 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/build.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/build.c</span>
<span class="p_chunk">@@ -999,6 +999,9 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 			goto out_detach;
 	}
 
<span class="p_add">+	/* Make device &quot;available&quot; before it becomes accessible via sysfs */</span>
<span class="p_add">+	ubi_devices[ubi_num] = ubi;</span>
<span class="p_add">+</span>
 	err = uif_init(ubi, &amp;ref);
 	if (err)
 		goto out_detach;
<span class="p_chunk">@@ -1043,7 +1046,6 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 	wake_up_process(ubi-&gt;bgt_thread);
 	spin_unlock(&amp;ubi-&gt;wl_lock);
 
<span class="p_del">-	ubi_devices[ubi_num] = ubi;</span>
 	ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL);
 	return ubi_num;
 
<span class="p_chunk">@@ -1054,6 +1056,7 @@</span> <span class="p_context"> out_uif:</span>
 	ubi_assert(ref);
 	uif_close(ubi);
 out_detach:
<span class="p_add">+	ubi_devices[ubi_num] = NULL;</span>
 	ubi_wl_close(ubi);
 	ubi_free_internal_volumes(ubi);
 	vfree(ubi-&gt;vtbl);
<span class="p_header">diff --git a/drivers/mtd/ubi/ubi.h b/drivers/mtd/ubi/ubi.h</span>
<span class="p_header">index c1f1087b6939..92774b7c6230 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/ubi.h</span>
<span class="p_header">+++ b/drivers/mtd/ubi/ubi.h</span>
<span class="p_chunk">@@ -670,6 +670,8 @@</span> <span class="p_context"> struct ubi_ainf_volume {</span>
  * @vols_found: number of volumes found
  * @highest_vol_id: highest volume ID
  * @is_empty: flag indicating whether the MTD device is empty or not
<span class="p_add">+ * @force_full_scan: flag indicating whether we need to do a full scan and drop</span>
<span class="p_add">+		     all existing Fastmap data structures</span>
  * @min_ec: lowest erase counter value
  * @max_ec: highest erase counter value
  * @max_sqnum: highest sequence number value
<span class="p_chunk">@@ -696,6 +698,7 @@</span> <span class="p_context"> struct ubi_attach_info {</span>
 	int vols_found;
 	int highest_vol_id;
 	int is_empty;
<span class="p_add">+	int force_full_scan;</span>
 	int min_ec;
 	int max_ec;
 	unsigned long long max_sqnum;
<span class="p_header">diff --git a/drivers/mtd/ubi/vmt.c b/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">index 8330703c098f..96131eb34c9f 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/vmt.c</span>
<span class="p_chunk">@@ -534,13 +534,6 @@</span> <span class="p_context"> int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)</span>
 		spin_unlock(&amp;ubi-&gt;volumes_lock);
 	}
 
<span class="p_del">-	/* Change volume table record */</span>
<span class="p_del">-	vtbl_rec = ubi-&gt;vtbl[vol_id];</span>
<span class="p_del">-	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);</span>
<span class="p_del">-	err = ubi_change_vtbl_record(ubi, vol_id, &amp;vtbl_rec);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_acc;</span>
<span class="p_del">-</span>
 	if (pebs &lt; 0) {
 		for (i = 0; i &lt; -pebs; i++) {
 			err = ubi_eba_unmap_leb(ubi, vol, reserved_pebs + i);
<span class="p_chunk">@@ -558,6 +551,24 @@</span> <span class="p_context"> int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)</span>
 		spin_unlock(&amp;ubi-&gt;volumes_lock);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When we shrink a volume we have to flush all pending (erase) work.</span>
<span class="p_add">+	 * Otherwise it can happen that upon next attach UBI finds a LEB with</span>
<span class="p_add">+	 * lnum &gt; highest_lnum and refuses to attach.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pebs &lt; 0) {</span>
<span class="p_add">+		err = ubi_wl_flush(ubi, vol_id, UBI_ALL);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_acc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Change volume table record */</span>
<span class="p_add">+	vtbl_rec = ubi-&gt;vtbl[vol_id];</span>
<span class="p_add">+	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);</span>
<span class="p_add">+	err = ubi_change_vtbl_record(ubi, vol_id, &amp;vtbl_rec);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out_acc;</span>
<span class="p_add">+</span>
 	vol-&gt;reserved_pebs = reserved_pebs;
 	if (vol-&gt;vol_type == UBI_DYNAMIC_VOLUME) {
 		vol-&gt;used_ebs = reserved_pebs;
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index edb3b86eb118..e47ad8a789ca 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/netdevice.h&gt;
 #include &lt;linux/if_arp.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 #include &lt;linux/can.h&gt;
 #include &lt;linux/can/dev.h&gt;
 #include &lt;linux/can/skb.h&gt;
<span class="p_chunk">@@ -392,9 +393,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(can_free_echo_skb);</span>
 /*
  * CAN device restart for bus-off recovery
  */
<span class="p_del">-static void can_restart(unsigned long data)</span>
<span class="p_add">+static void can_restart(struct net_device *dev)</span>
 {
<span class="p_del">-	struct net_device *dev = (struct net_device *)data;</span>
 	struct can_priv *priv = netdev_priv(dev);
 	struct net_device_stats *stats = &amp;dev-&gt;stats;
 	struct sk_buff *skb;
<span class="p_chunk">@@ -434,6 +434,14 @@</span> <span class="p_context"> restart:</span>
 		netdev_err(dev, &quot;Error %d during restart&quot;, err);
 }
 
<span class="p_add">+static void can_restart_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct delayed_work *dwork = to_delayed_work(work);</span>
<span class="p_add">+	struct can_priv *priv = container_of(dwork, struct can_priv, restart_work);</span>
<span class="p_add">+</span>
<span class="p_add">+	can_restart(priv-&gt;dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int can_restart_now(struct net_device *dev)
 {
 	struct can_priv *priv = netdev_priv(dev);
<span class="p_chunk">@@ -447,8 +455,8 @@</span> <span class="p_context"> int can_restart_now(struct net_device *dev)</span>
 	if (priv-&gt;state != CAN_STATE_BUS_OFF)
 		return -EBUSY;
 
<span class="p_del">-	/* Runs as soon as possible in the timer context */</span>
<span class="p_del">-	mod_timer(&amp;priv-&gt;restart_timer, jiffies);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;priv-&gt;restart_work);</span>
<span class="p_add">+	can_restart(dev);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -470,8 +478,8 @@</span> <span class="p_context"> void can_bus_off(struct net_device *dev)</span>
 	priv-&gt;can_stats.bus_off++;
 
 	if (priv-&gt;restart_ms)
<span class="p_del">-		mod_timer(&amp;priv-&gt;restart_timer,</span>
<span class="p_del">-			  jiffies + (priv-&gt;restart_ms * HZ) / 1000);</span>
<span class="p_add">+		schedule_delayed_work(&amp;priv-&gt;restart_work,</span>
<span class="p_add">+				      msecs_to_jiffies(priv-&gt;restart_ms));</span>
 }
 EXPORT_SYMBOL_GPL(can_bus_off);
 
<span class="p_chunk">@@ -578,6 +586,7 @@</span> <span class="p_context"> struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)</span>
 		return NULL;
 
 	priv = netdev_priv(dev);
<span class="p_add">+	priv-&gt;dev = dev;</span>
 
 	if (echo_skb_max) {
 		priv-&gt;echo_skb_max = echo_skb_max;
<span class="p_chunk">@@ -587,7 +596,7 @@</span> <span class="p_context"> struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)</span>
 
 	priv-&gt;state = CAN_STATE_STOPPED;
 
<span class="p_del">-	init_timer(&amp;priv-&gt;restart_timer);</span>
<span class="p_add">+	INIT_DELAYED_WORK(&amp;priv-&gt;restart_work, can_restart_work);</span>
 
 	return dev;
 }
<span class="p_chunk">@@ -662,8 +671,6 @@</span> <span class="p_context"> int open_candev(struct net_device *dev)</span>
 	if (!netif_carrier_ok(dev))
 		netif_carrier_on(dev);
 
<span class="p_del">-	setup_timer(&amp;priv-&gt;restart_timer, can_restart, (unsigned long)dev);</span>
<span class="p_del">-</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(open_candev);
<span class="p_chunk">@@ -678,7 +685,7 @@</span> <span class="p_context"> void close_candev(struct net_device *dev)</span>
 {
 	struct can_priv *priv = netdev_priv(dev);
 
<span class="p_del">-	del_timer_sync(&amp;priv-&gt;restart_timer);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;priv-&gt;restart_work);</span>
 	can_flush_echo_skb(dev);
 }
 EXPORT_SYMBOL_GPL(close_candev);
<span class="p_header">diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c</span>
<span class="p_header">index bf83639888a9..7c06df557e37 100644</span>
<span class="p_header">--- a/drivers/net/can/flexcan.c</span>
<span class="p_header">+++ b/drivers/net/can/flexcan.c</span>
<span class="p_chunk">@@ -1248,11 +1248,10 @@</span> <span class="p_context"> static int __maybe_unused flexcan_suspend(struct device *device)</span>
 	struct flexcan_priv *priv = netdev_priv(dev);
 	int err;
 
<span class="p_del">-	err = flexcan_chip_disable(priv);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
 	if (netif_running(dev)) {
<span class="p_add">+		err = flexcan_chip_disable(priv);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
 		netif_stop_queue(dev);
 		netif_device_detach(dev);
 	}
<span class="p_chunk">@@ -1265,13 +1264,17 @@</span> <span class="p_context"> static int __maybe_unused flexcan_resume(struct device *device)</span>
 {
 	struct net_device *dev = dev_get_drvdata(device);
 	struct flexcan_priv *priv = netdev_priv(dev);
<span class="p_add">+	int err;</span>
 
 	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
 	if (netif_running(dev)) {
 		netif_device_attach(dev);
 		netif_start_queue(dev);
<span class="p_add">+		err = flexcan_chip_enable(priv);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
 	}
<span class="p_del">-	return flexcan_chip_enable(priv);</span>
<span class="p_add">+	return 0;</span>
 }
 
 static SIMPLE_DEV_PM_OPS(flexcan_pm_ops, flexcan_suspend, flexcan_resume);
<span class="p_header">diff --git a/drivers/net/ethernet/ethoc.c b/drivers/net/ethernet/ethoc.c</span>
<span class="p_header">index f3658bdb64cc..00d0a05b9d7f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ethoc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ethoc.c</span>
<span class="p_chunk">@@ -1080,7 +1080,7 @@</span> <span class="p_context"> static int ethoc_probe(struct platform_device *pdev)</span>
 	if (!priv-&gt;iobase) {
 		dev_err(&amp;pdev-&gt;dev, &quot;cannot remap I/O memory space\n&quot;);
 		ret = -ENXIO;
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto free;</span>
 	}
 
 	if (netdev-&gt;mem_end) {
<span class="p_chunk">@@ -1089,7 +1089,7 @@</span> <span class="p_context"> static int ethoc_probe(struct platform_device *pdev)</span>
 		if (!priv-&gt;membase) {
 			dev_err(&amp;pdev-&gt;dev, &quot;cannot remap memory space\n&quot;);
 			ret = -ENXIO;
<span class="p_del">-			goto error;</span>
<span class="p_add">+			goto free;</span>
 		}
 	} else {
 		/* Allocate buffer memory */
<span class="p_chunk">@@ -1100,7 +1100,7 @@</span> <span class="p_context"> static int ethoc_probe(struct platform_device *pdev)</span>
 			dev_err(&amp;pdev-&gt;dev, &quot;cannot allocate %dB buffer\n&quot;,
 				buffer_size);
 			ret = -ENOMEM;
<span class="p_del">-			goto error;</span>
<span class="p_add">+			goto free;</span>
 		}
 		netdev-&gt;mem_end = netdev-&gt;mem_start + buffer_size;
 		priv-&gt;dma_alloc = buffer_size;
<span class="p_chunk">@@ -1111,7 +1111,7 @@</span> <span class="p_context"> static int ethoc_probe(struct platform_device *pdev)</span>
 		128, (netdev-&gt;mem_end - netdev-&gt;mem_start + 1) / ETHOC_BUFSIZ);
 	if (num_bd &lt; 4) {
 		ret = -ENODEV;
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto free;</span>
 	}
 	priv-&gt;num_bd = num_bd;
 	/* num_tx must be a power of two */
<span class="p_chunk">@@ -1124,7 +1124,7 @@</span> <span class="p_context"> static int ethoc_probe(struct platform_device *pdev)</span>
 	priv-&gt;vma = devm_kzalloc(&amp;pdev-&gt;dev, num_bd*sizeof(void *), GFP_KERNEL);
 	if (!priv-&gt;vma) {
 		ret = -ENOMEM;
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto free;</span>
 	}
 
 	/* Allow the platform setup code to pass in a MAC address. */
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 99a69490f39b..4d468707a866 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"></span>
 /* Various constants */
 
 /* Coalescing */
<span class="p_del">-#define MVNETA_TXDONE_COAL_PKTS		1</span>
<span class="p_add">+#define MVNETA_TXDONE_COAL_PKTS		0	/* interrupt per packet */</span>
 #define MVNETA_RX_COAL_PKTS		32
 #define MVNETA_RX_COAL_USEC		100
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">index cea4098b1d80..3ee3dcedf74a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_chunk">@@ -159,13 +159,14 @@</span> <span class="p_context"> static struct mlx5_cmd_layout *get_inst(struct mlx5_cmd *cmd, int idx)</span>
 	return cmd-&gt;cmd_buf + (idx &lt;&lt; cmd-&gt;log_stride);
 }
 
<span class="p_del">-static u8 xor8_buf(void *buf, int len)</span>
<span class="p_add">+static u8 xor8_buf(void *buf, size_t offset, int len)</span>
 {
 	u8 *ptr = buf;
 	u8 sum = 0;
 	int i;
<span class="p_add">+	int end = len + offset;</span>
 
<span class="p_del">-	for (i = 0; i &lt; len; i++)</span>
<span class="p_add">+	for (i = offset; i &lt; end; i++)</span>
 		sum ^= ptr[i];
 
 	return sum;
<span class="p_chunk">@@ -173,41 +174,49 @@</span> <span class="p_context"> static u8 xor8_buf(void *buf, int len)</span>
 
 static int verify_block_sig(struct mlx5_cmd_prot_block *block)
 {
<span class="p_del">-	if (xor8_buf(block-&gt;rsvd0, sizeof(*block) - sizeof(block-&gt;data) - 1) != 0xff)</span>
<span class="p_add">+	size_t rsvd0_off = offsetof(struct mlx5_cmd_prot_block, rsvd0);</span>
<span class="p_add">+	int xor_len = sizeof(*block) - sizeof(block-&gt;data) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xor8_buf(block, rsvd0_off, xor_len) != 0xff)</span>
 		return -EINVAL;
 
<span class="p_del">-	if (xor8_buf(block, sizeof(*block)) != 0xff)</span>
<span class="p_add">+	if (xor8_buf(block, 0, sizeof(*block)) != 0xff)</span>
 		return -EINVAL;
 
 	return 0;
 }
 
<span class="p_del">-static void calc_block_sig(struct mlx5_cmd_prot_block *block, u8 token,</span>
<span class="p_del">-			   int csum)</span>
<span class="p_add">+static void calc_block_sig(struct mlx5_cmd_prot_block *block)</span>
 {
<span class="p_del">-	block-&gt;token = token;</span>
<span class="p_del">-	if (csum) {</span>
<span class="p_del">-		block-&gt;ctrl_sig = ~xor8_buf(block-&gt;rsvd0, sizeof(*block) -</span>
<span class="p_del">-					    sizeof(block-&gt;data) - 2);</span>
<span class="p_del">-		block-&gt;sig = ~xor8_buf(block, sizeof(*block) - 1);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	int ctrl_xor_len = sizeof(*block) - sizeof(block-&gt;data) - 2;</span>
<span class="p_add">+	size_t rsvd0_off = offsetof(struct mlx5_cmd_prot_block, rsvd0);</span>
<span class="p_add">+</span>
<span class="p_add">+	block-&gt;ctrl_sig = ~xor8_buf(block, rsvd0_off, ctrl_xor_len);</span>
<span class="p_add">+	block-&gt;sig = ~xor8_buf(block, 0, sizeof(*block) - 1);</span>
 }
 
<span class="p_del">-static void calc_chain_sig(struct mlx5_cmd_msg *msg, u8 token, int csum)</span>
<span class="p_add">+static void calc_chain_sig(struct mlx5_cmd_msg *msg)</span>
 {
 	struct mlx5_cmd_mailbox *next = msg-&gt;next;
<span class="p_del">-</span>
<span class="p_del">-	while (next) {</span>
<span class="p_del">-		calc_block_sig(next-&gt;buf, token, csum);</span>
<span class="p_add">+	int size = msg-&gt;len;</span>
<span class="p_add">+	int blen = size - min_t(int, sizeof(msg-&gt;first.data), size);</span>
<span class="p_add">+	int n = (blen + MLX5_CMD_DATA_BLOCK_SIZE - 1)</span>
<span class="p_add">+		/ MLX5_CMD_DATA_BLOCK_SIZE;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; n &amp;&amp; next; i++)  {</span>
<span class="p_add">+		calc_block_sig(next-&gt;buf);</span>
 		next = next-&gt;next;
 	}
 }
 
 static void set_signature(struct mlx5_cmd_work_ent *ent, int csum)
 {
<span class="p_del">-	ent-&gt;lay-&gt;sig = ~xor8_buf(ent-&gt;lay, sizeof(*ent-&gt;lay));</span>
<span class="p_del">-	calc_chain_sig(ent-&gt;in, ent-&gt;token, csum);</span>
<span class="p_del">-	calc_chain_sig(ent-&gt;out, ent-&gt;token, csum);</span>
<span class="p_add">+	ent-&gt;lay-&gt;sig = ~xor8_buf(ent-&gt;lay, 0,  sizeof(*ent-&gt;lay));</span>
<span class="p_add">+	if (csum) {</span>
<span class="p_add">+		calc_chain_sig(ent-&gt;in);</span>
<span class="p_add">+		calc_chain_sig(ent-&gt;out);</span>
<span class="p_add">+	}</span>
 }
 
 static void poll_timeout(struct mlx5_cmd_work_ent *ent)
<span class="p_chunk">@@ -238,12 +247,17 @@</span> <span class="p_context"> static int verify_signature(struct mlx5_cmd_work_ent *ent)</span>
 	struct mlx5_cmd_mailbox *next = ent-&gt;out-&gt;next;
 	int err;
 	u8 sig;
<span class="p_add">+	int size = ent-&gt;out-&gt;len;</span>
<span class="p_add">+	int blen = size - min_t(int, sizeof(ent-&gt;out-&gt;first.data), size);</span>
<span class="p_add">+	int n = (blen + MLX5_CMD_DATA_BLOCK_SIZE - 1)</span>
<span class="p_add">+		/ MLX5_CMD_DATA_BLOCK_SIZE;</span>
<span class="p_add">+	int i = 0;</span>
 
<span class="p_del">-	sig = xor8_buf(ent-&gt;lay, sizeof(*ent-&gt;lay));</span>
<span class="p_add">+	sig = xor8_buf(ent-&gt;lay, 0, sizeof(*ent-&gt;lay));</span>
 	if (sig != 0xff)
 		return -EINVAL;
 
<span class="p_del">-	while (next) {</span>
<span class="p_add">+	for (i = 0; i &lt; n &amp;&amp; next; i++) {</span>
 		err = verify_block_sig(next-&gt;buf);
 		if (err)
 			return err;
<span class="p_chunk">@@ -555,7 +569,6 @@</span> <span class="p_context"> static void cmd_work_handler(struct work_struct *work)</span>
 		ent-&gt;idx = cmd-&gt;max_reg_cmds;
 	}
 
<span class="p_del">-	ent-&gt;token = alloc_token(cmd);</span>
 	cmd-&gt;ent_arr[ent-&gt;idx] = ent;
 	lay = get_inst(cmd, ent-&gt;idx);
 	ent-&gt;lay = lay;
<span class="p_chunk">@@ -654,7 +667,8 @@</span> <span class="p_context"> static int wait_func(struct mlx5_core_dev *dev, struct mlx5_cmd_work_ent *ent)</span>
 static int mlx5_cmd_invoke(struct mlx5_core_dev *dev, struct mlx5_cmd_msg *in,
 			   struct mlx5_cmd_msg *out, void *uout, int uout_size,
 			   mlx5_cmd_cbk_t callback,
<span class="p_del">-			   void *context, int page_queue, u8 *status)</span>
<span class="p_add">+			   void *context, int page_queue, u8 *status,</span>
<span class="p_add">+			   u8 token)</span>
 {
 	struct mlx5_cmd *cmd = &amp;dev-&gt;cmd;
 	struct mlx5_cmd_work_ent *ent;
<span class="p_chunk">@@ -672,6 +686,8 @@</span> <span class="p_context"> static int mlx5_cmd_invoke(struct mlx5_core_dev *dev, struct mlx5_cmd_msg *in,</span>
 	if (IS_ERR(ent))
 		return PTR_ERR(ent);
 
<span class="p_add">+	ent-&gt;token = token;</span>
<span class="p_add">+</span>
 	if (!callback)
 		init_completion(&amp;ent-&gt;done);
 
<span class="p_chunk">@@ -746,7 +762,8 @@</span> <span class="p_context"> static const struct file_operations fops = {</span>
 	.write	= dbg_write,
 };
 
<span class="p_del">-static int mlx5_copy_to_msg(struct mlx5_cmd_msg *to, void *from, int size)</span>
<span class="p_add">+static int mlx5_copy_to_msg(struct mlx5_cmd_msg *to, void *from, int size,</span>
<span class="p_add">+			    u8 token)</span>
 {
 	struct mlx5_cmd_prot_block *block;
 	struct mlx5_cmd_mailbox *next;
<span class="p_chunk">@@ -772,6 +789,7 @@</span> <span class="p_context"> static int mlx5_copy_to_msg(struct mlx5_cmd_msg *to, void *from, int size)</span>
 		memcpy(block-&gt;data, from, copy);
 		from += copy;
 		size -= copy;
<span class="p_add">+		block-&gt;token = token;</span>
 		next = next-&gt;next;
 	}
 
<span class="p_chunk">@@ -841,7 +859,8 @@</span> <span class="p_context"> static void free_cmd_box(struct mlx5_core_dev *dev,</span>
 }
 
 static struct mlx5_cmd_msg *mlx5_alloc_cmd_msg(struct mlx5_core_dev *dev,
<span class="p_del">-					       gfp_t flags, int size)</span>
<span class="p_add">+					       gfp_t flags, int size,</span>
<span class="p_add">+					       u8 token)</span>
 {
 	struct mlx5_cmd_mailbox *tmp, *head = NULL;
 	struct mlx5_cmd_prot_block *block;
<span class="p_chunk">@@ -870,6 +889,7 @@</span> <span class="p_context"> static struct mlx5_cmd_msg *mlx5_alloc_cmd_msg(struct mlx5_core_dev *dev,</span>
 		tmp-&gt;next = head;
 		block-&gt;next = cpu_to_be64(tmp-&gt;next ? tmp-&gt;next-&gt;dma : 0);
 		block-&gt;block_num = cpu_to_be32(n - i - 1);
<span class="p_add">+		block-&gt;token = token;</span>
 		head = tmp;
 	}
 	msg-&gt;next = head;
<span class="p_chunk">@@ -1239,7 +1259,7 @@</span> <span class="p_context"> static struct mlx5_cmd_msg *alloc_msg(struct mlx5_core_dev *dev, int in_size,</span>
 	}
 
 	if (IS_ERR(msg))
<span class="p_del">-		msg = mlx5_alloc_cmd_msg(dev, gfp, in_size);</span>
<span class="p_add">+		msg = mlx5_alloc_cmd_msg(dev, gfp, in_size, 0);</span>
 
 	return msg;
 }
<span class="p_chunk">@@ -1258,6 +1278,7 @@</span> <span class="p_context"> static int cmd_exec(struct mlx5_core_dev *dev, void *in, int in_size, void *out,</span>
 	gfp_t gfp;
 	int err;
 	u8 status = 0;
<span class="p_add">+	u8 token;</span>
 
 	pages_queue = is_manage_pages(in);
 	gfp = callback ? GFP_ATOMIC : GFP_KERNEL;
<span class="p_chunk">@@ -1268,20 +1289,22 @@</span> <span class="p_context"> static int cmd_exec(struct mlx5_core_dev *dev, void *in, int in_size, void *out,</span>
 		return err;
 	}
 
<span class="p_del">-	err = mlx5_copy_to_msg(inb, in, in_size);</span>
<span class="p_add">+	token = alloc_token(&amp;dev-&gt;cmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = mlx5_copy_to_msg(inb, in, in_size, token);</span>
 	if (err) {
 		mlx5_core_warn(dev, &quot;err %d\n&quot;, err);
 		goto out_in;
 	}
 
<span class="p_del">-	outb = mlx5_alloc_cmd_msg(dev, gfp, out_size);</span>
<span class="p_add">+	outb = mlx5_alloc_cmd_msg(dev, gfp, out_size, token);</span>
 	if (IS_ERR(outb)) {
 		err = PTR_ERR(outb);
 		goto out_in;
 	}
 
 	err = mlx5_cmd_invoke(dev, inb, outb, out, out_size, callback, context,
<span class="p_del">-			      pages_queue, &amp;status);</span>
<span class="p_add">+			      pages_queue, &amp;status, token);</span>
 	if (err)
 		goto out_out;
 
<span class="p_chunk">@@ -1348,7 +1371,7 @@</span> <span class="p_context"> static int create_msg_cache(struct mlx5_core_dev *dev)</span>
 	INIT_LIST_HEAD(&amp;cmd-&gt;cache.med.head);
 
 	for (i = 0; i &lt; NUM_LONG_LISTS; i++) {
<span class="p_del">-		msg = mlx5_alloc_cmd_msg(dev, GFP_KERNEL, LONG_LIST_SIZE);</span>
<span class="p_add">+		msg = mlx5_alloc_cmd_msg(dev, GFP_KERNEL, LONG_LIST_SIZE, 0);</span>
 		if (IS_ERR(msg)) {
 			err = PTR_ERR(msg);
 			goto ex_err;
<span class="p_chunk">@@ -1358,7 +1381,7 @@</span> <span class="p_context"> static int create_msg_cache(struct mlx5_core_dev *dev)</span>
 	}
 
 	for (i = 0; i &lt; NUM_MED_LISTS; i++) {
<span class="p_del">-		msg = mlx5_alloc_cmd_msg(dev, GFP_KERNEL, MED_LIST_SIZE);</span>
<span class="p_add">+		msg = mlx5_alloc_cmd_msg(dev, GFP_KERNEL, MED_LIST_SIZE, 0);</span>
 		if (IS_ERR(msg)) {
 			err = PTR_ERR(msg);
 			goto ex_err;
<span class="p_header">diff --git a/drivers/net/macvlan.c b/drivers/net/macvlan.c</span>
<span class="p_header">index bb33b0410a22..8432521408a7 100644</span>
<span class="p_header">--- a/drivers/net/macvlan.c</span>
<span class="p_header">+++ b/drivers/net/macvlan.c</span>
<span class="p_chunk">@@ -234,11 +234,14 @@</span> <span class="p_context"> static void macvlan_process_broadcast(struct work_struct *w)</span>
 
 		rcu_read_unlock();
 
<span class="p_add">+		if (src)</span>
<span class="p_add">+			dev_put(src-&gt;dev);</span>
 		kfree_skb(skb);
 	}
 }
 
 static void macvlan_broadcast_enqueue(struct macvlan_port *port,
<span class="p_add">+				      const struct macvlan_dev *src,</span>
 				      struct sk_buff *skb)
 {
 	struct sk_buff *nskb;
<span class="p_chunk">@@ -248,8 +251,12 @@</span> <span class="p_context"> static void macvlan_broadcast_enqueue(struct macvlan_port *port,</span>
 	if (!nskb)
 		goto err;
 
<span class="p_add">+	MACVLAN_SKB_CB(nskb)-&gt;src = src;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;port-&gt;bc_queue.lock);
 	if (skb_queue_len(&amp;port-&gt;bc_queue) &lt; MACVLAN_BC_QUEUE_LEN) {
<span class="p_add">+		if (src)</span>
<span class="p_add">+			dev_hold(src-&gt;dev);</span>
 		__skb_queue_tail(&amp;port-&gt;bc_queue, nskb);
 		err = 0;
 	}
<span class="p_chunk">@@ -296,8 +303,7 @@</span> <span class="p_context"> static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)</span>
 			goto out;
 		}
 
<span class="p_del">-		MACVLAN_SKB_CB(skb)-&gt;src = src;</span>
<span class="p_del">-		macvlan_broadcast_enqueue(port, skb);</span>
<span class="p_add">+		macvlan_broadcast_enqueue(port, src, skb);</span>
 
 		return RX_HANDLER_PASS;
 	}
<span class="p_header">diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">index 2b5ac1818797..03054f55073c 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_chunk">@@ -2338,8 +2338,6 @@</span> <span class="p_context"> ppp_unregister_channel(struct ppp_channel *chan)</span>
 	spin_lock_bh(&amp;pn-&gt;all_channels_lock);
 	list_del(&amp;pch-&gt;list);
 	spin_unlock_bh(&amp;pn-&gt;all_channels_lock);
<span class="p_del">-	put_net(pch-&gt;chan_net);</span>
<span class="p_del">-	pch-&gt;chan_net = NULL;</span>
 
 	pch-&gt;file.dead = 1;
 	wake_up_interruptible(&amp;pch-&gt;file.rwait);
<span class="p_chunk">@@ -2955,6 +2953,9 @@</span> <span class="p_context"> ppp_disconnect_channel(struct channel *pch)</span>
  */
 static void ppp_destroy_channel(struct channel *pch)
 {
<span class="p_add">+	put_net(pch-&gt;chan_net);</span>
<span class="p_add">+	pch-&gt;chan_net = NULL;</span>
<span class="p_add">+</span>
 	atomic_dec(&amp;channel_count);
 
 	if (!pch-&gt;file.dead) {
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 4d4527c13f52..343a71ad865b 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -794,10 +794,7 @@</span> <span class="p_context"> static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	if (unlikely(skb_orphan_frags(skb, GFP_ATOMIC)))
 		goto drop;
 
<span class="p_del">-	if (skb-&gt;sk) {</span>
<span class="p_del">-		sock_tx_timestamp(skb-&gt;sk, &amp;skb_shinfo(skb)-&gt;tx_flags);</span>
<span class="p_del">-		sw_tx_timestamp(skb);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	skb_tx_timestamp(skb);</span>
 
 	/* Orphan the skb - required as we might hang on to it
 	 * for indefinite time.
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c</span>
<span class="p_header">index 235053ba7737..d429dcbcb055 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c</span>
<span class="p_chunk">@@ -4169,7 +4169,7 @@</span> <span class="p_context"> static void ath9k_hw_ar9300_set_board_values(struct ath_hw *ah,</span>
 	if (!AR_SREV_9330(ah) &amp;&amp; !AR_SREV_9340(ah) &amp;&amp; !AR_SREV_9531(ah))
 		ar9003_hw_internal_regulator_apply(ah);
 	ar9003_hw_apply_tuning_caps(ah);
<span class="p_del">-	ar9003_hw_apply_minccapwr_thresh(ah, chan);</span>
<span class="p_add">+	ar9003_hw_apply_minccapwr_thresh(ah, is2ghz);</span>
 	ar9003_hw_txend_to_xpa_off_apply(ah, is2ghz);
 	ar9003_hw_thermometer_apply(ah);
 	ar9003_hw_thermo_cal_apply(ah);
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/bcmsdh.c b/drivers/net/wireless/brcm80211/brcmfmac/bcmsdh.c</span>
<span class="p_header">index a16e644e7c08..8367ad77ca43 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/bcmsdh.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/bcmsdh.c</span>
<span class="p_chunk">@@ -708,8 +708,10 @@</span> <span class="p_context"> int brcmf_sdiod_recv_chain(struct brcmf_sdio_dev *sdiodev,</span>
 			return -ENOMEM;
 		err = brcmf_sdiod_buffrw(sdiodev, SDIO_FUNC_2, false, addr,
 					 glom_skb);
<span class="p_del">-		if (err)</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			brcmu_pkt_buf_free_skb(glom_skb);</span>
 			goto done;
<span class="p_add">+		}</span>
 
 		skb_queue_walk(pktq, skb) {
 			memcpy(skb-&gt;data, glom_skb-&gt;data, skb-&gt;len);
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c b/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c</span>
<span class="p_header">index d8fa276e368b..9e6502a9648c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c</span>
<span class="p_chunk">@@ -3822,7 +3822,7 @@</span> <span class="p_context"> brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,</span>
 				(u8 *)&amp;settings-&gt;beacon.head[ie_offset],
 				settings-&gt;beacon.head_len - ie_offset,
 				WLAN_EID_SSID);
<span class="p_del">-		if (!ssid_ie)</span>
<span class="p_add">+		if (!ssid_ie || ssid_ie-&gt;len &gt; IEEE80211_MAX_SSID_LEN)</span>
 			return -EINVAL;
 
 		memcpy(ssid_le.SSID, ssid_ie-&gt;data, ssid_ie-&gt;len);
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmsmac/dma.c b/drivers/net/wireless/brcm80211/brcmsmac/dma.c</span>
<span class="p_header">index 4fb9635d3919..7660b523dcf1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmsmac/dma.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmsmac/dma.c</span>
<span class="p_chunk">@@ -1079,8 +1079,10 @@</span> <span class="p_context"> bool dma_rxfill(struct dma_pub *pub)</span>
 
 		pa = dma_map_single(di-&gt;dmadev, p-&gt;data, di-&gt;rxbufsize,
 				    DMA_FROM_DEVICE);
<span class="p_del">-		if (dma_mapping_error(di-&gt;dmadev, pa))</span>
<span class="p_add">+		if (dma_mapping_error(di-&gt;dmadev, pa)) {</span>
<span class="p_add">+			brcmu_pkt_buf_free_skb(p);</span>
 			return false;
<span class="p_add">+		}</span>
 
 		/* save the free packet pointer */
 		di-&gt;rxp[rxout] = p;
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmsmac/stf.c b/drivers/net/wireless/brcm80211/brcmsmac/stf.c</span>
<span class="p_header">index dd9162722495..0ab865de1491 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmsmac/stf.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmsmac/stf.c</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> void</span>
 brcms_c_stf_ss_algo_channel_get(struct brcms_c_info *wlc, u16 *ss_algo_channel,
 			    u16 chanspec)
 {
<span class="p_del">-	struct tx_power power;</span>
<span class="p_add">+	struct tx_power power = { };</span>
 	u8 siso_mcs_id, cdd_mcs_id, stbc_mcs_id;
 
 	/* Clear previous settings */
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/tx.c b/drivers/net/wireless/iwlwifi/pcie/tx.c</span>
<span class="p_header">index 452bb1b0c791..5d2ff0e149f0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/tx.c</span>
<span class="p_chunk">@@ -1364,9 +1364,9 @@</span> <span class="p_context"> static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,</span>
 
 	/* start the TFD with the scratchbuf */
 	scratch_size = min_t(int, copy_size, IWL_HCMD_SCRATCHBUF_SIZE);
<span class="p_del">-	memcpy(&amp;txq-&gt;scratchbufs[q-&gt;write_ptr], &amp;out_cmd-&gt;hdr, scratch_size);</span>
<span class="p_add">+	memcpy(&amp;txq-&gt;scratchbufs[idx], &amp;out_cmd-&gt;hdr, scratch_size);</span>
 	iwl_pcie_txq_build_tfd(trans, txq,
<span class="p_del">-			       iwl_pcie_get_scratchbuf_dma(txq, q-&gt;write_ptr),</span>
<span class="p_add">+			       iwl_pcie_get_scratchbuf_dma(txq, idx),</span>
 			       scratch_size, true);
 
 	/* map first command fragment, if any remains */
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 1f5ea2403d94..89ee38869334 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -3074,13 +3074,15 @@</span> <span class="p_context"> static void quirk_no_bus_reset(struct pci_dev *dev)</span>
 }
 
 /*
<span class="p_del">- * Atheros AR93xx chips do not behave after a bus reset.  The device will</span>
<span class="p_del">- * throw a Link Down error on AER-capable systems and regardless of AER,</span>
<span class="p_del">- * config space of the device is never accessible again and typically</span>
<span class="p_del">- * causes the system to hang or reset when access is attempted.</span>
<span class="p_add">+ * Some Atheros AR9xxx and QCA988x chips do not behave after a bus reset.</span>
<span class="p_add">+ * The device will throw a Link Down error on AER-capable systems and</span>
<span class="p_add">+ * regardless of AER, config space of the device is never accessible again</span>
<span class="p_add">+ * and typically causes the system to hang or reset when access is attempted.</span>
  * http://www.spinics.net/lists/linux-pci/msg34797.html
  */
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0030, quirk_no_bus_reset);
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0032, quirk_no_bus_reset);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x003c, quirk_no_bus_reset);</span>
 
 static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
 			  struct pci_fixup *end)
<span class="p_header">diff --git a/drivers/platform/x86/hp-wmi.c b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">index 301386c4d85b..450d790c8bbf 100644</span>
<span class="p_header">--- a/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_chunk">@@ -723,6 +723,11 @@</span> <span class="p_context"> static int __init hp_wmi_rfkill_setup(struct platform_device *device)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	err = hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, &amp;wireless,</span>
<span class="p_add">+				   sizeof(wireless), 0);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	if (wireless &amp; 0x1) {
 		wifi_rfkill = rfkill_alloc(&quot;hp-wifi&quot;, &amp;device-&gt;dev,
 					   RFKILL_TYPE_WLAN,
<span class="p_chunk">@@ -910,7 +915,7 @@</span> <span class="p_context"> static int __init hp_wmi_bios_setup(struct platform_device *device)</span>
 	gps_rfkill = NULL;
 	rfkill2_count = 0;
 
<span class="p_del">-	if (hp_wmi_bios_2009_later() || hp_wmi_rfkill_setup(device))</span>
<span class="p_add">+	if (hp_wmi_rfkill_setup(device))</span>
 		hp_wmi_rfkill2_setup(device);
 
 	err = device_create_file(&amp;device-&gt;dev, &amp;dev_attr_display);
<span class="p_header">diff --git a/drivers/power/max17042_battery.c b/drivers/power/max17042_battery.c</span>
<span class="p_header">index 66da691c41cf..2ca452743609 100644</span>
<span class="p_header">--- a/drivers/power/max17042_battery.c</span>
<span class="p_header">+++ b/drivers/power/max17042_battery.c</span>
<span class="p_chunk">@@ -295,13 +295,16 @@</span> <span class="p_context"> static inline void max17042_write_model_data(struct max17042_chip *chip,</span>
 }
 
 static inline void max17042_read_model_data(struct max17042_chip *chip,
<span class="p_del">-					u8 addr, u32 *data, int size)</span>
<span class="p_add">+					u8 addr, u16 *data, int size)</span>
 {
 	struct regmap *map = chip-&gt;regmap;
 	int i;
<span class="p_add">+	u32 tmp;</span>
 
<span class="p_del">-	for (i = 0; i &lt; size; i++)</span>
<span class="p_del">-		regmap_read(map, addr + i, &amp;data[i]);</span>
<span class="p_add">+	for (i = 0; i &lt; size; i++) {</span>
<span class="p_add">+		regmap_read(map, addr + i, &amp;tmp);</span>
<span class="p_add">+		data[i] = (u16)tmp;</span>
<span class="p_add">+	}</span>
 }
 
 static inline int max17042_model_data_compare(struct max17042_chip *chip,
<span class="p_chunk">@@ -324,7 +327,7 @@</span> <span class="p_context"> static int max17042_init_model(struct max17042_chip *chip)</span>
 {
 	int ret;
 	int table_size = ARRAY_SIZE(chip-&gt;pdata-&gt;config_data-&gt;cell_char_tbl);
<span class="p_del">-	u32 *temp_data;</span>
<span class="p_add">+	u16 *temp_data;</span>
 
 	temp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);
 	if (!temp_data)
<span class="p_chunk">@@ -339,7 +342,7 @@</span> <span class="p_context"> static int max17042_init_model(struct max17042_chip *chip)</span>
 	ret = max17042_model_data_compare(
 		chip,
 		chip-&gt;pdata-&gt;config_data-&gt;cell_char_tbl,
<span class="p_del">-		(u16 *)temp_data,</span>
<span class="p_add">+		temp_data,</span>
 		table_size);
 
 	max10742_lock_model(chip);
<span class="p_chunk">@@ -352,7 +355,7 @@</span> <span class="p_context"> static int max17042_verify_model_lock(struct max17042_chip *chip)</span>
 {
 	int i;
 	int table_size = ARRAY_SIZE(chip-&gt;pdata-&gt;config_data-&gt;cell_char_tbl);
<span class="p_del">-	u32 *temp_data;</span>
<span class="p_add">+	u16 *temp_data;</span>
 	int ret = 0;
 
 	temp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);
<span class="p_header">diff --git a/drivers/pps/clients/pps_parport.c b/drivers/pps/clients/pps_parport.c</span>
<span class="p_header">index 38a8bbe74810..83797d89c30f 100644</span>
<span class="p_header">--- a/drivers/pps/clients/pps_parport.c</span>
<span class="p_header">+++ b/drivers/pps/clients/pps_parport.c</span>
<span class="p_chunk">@@ -195,7 +195,7 @@</span> <span class="p_context"> static void parport_detach(struct parport *port)</span>
 	struct pps_client_pp *device;
 
 	/* FIXME: oooh, this is ugly! */
<span class="p_del">-	if (strcmp(pardev-&gt;name, KBUILD_MODNAME))</span>
<span class="p_add">+	if (!pardev || strcmp(pardev-&gt;name, KBUILD_MODNAME))</span>
 		/* not our port */
 		return;
 
<span class="p_header">diff --git a/drivers/rtc/rtc-ds1307.c b/drivers/rtc/rtc-ds1307.c</span>
<span class="p_header">index f182dae3a4b7..5236842d28aa 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-ds1307.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-ds1307.c</span>
<span class="p_chunk">@@ -611,6 +611,8 @@</span> <span class="p_context"> static const struct rtc_class_ops ds13xx_rtc_ops = {</span>
  * Alarm support for mcp7941x devices.
  */
 
<span class="p_add">+#define MCP794XX_REG_WEEKDAY		0x3</span>
<span class="p_add">+#define MCP794XX_REG_WEEKDAY_WDAY_MASK	0x7</span>
 #define MCP7941X_REG_CONTROL		0x07
 #	define MCP7941X_BIT_ALM0_EN	0x10
 #	define MCP7941X_BIT_ALM1_EN	0x20
<span class="p_chunk">@@ -840,12 +842,15 @@</span> <span class="p_context"> static int ds1307_probe(struct i2c_client *client,</span>
 {
 	struct ds1307		*ds1307;
 	int			err = -ENODEV;
<span class="p_del">-	int			tmp;</span>
<span class="p_add">+	int			tmp, wday;</span>
 	const struct chip_desc	*chip = &amp;chips[id-&gt;driver_data];
 	struct i2c_adapter	*adapter = to_i2c_adapter(client-&gt;dev.parent);
 	bool			want_irq = false;
 	unsigned char		*buf;
 	struct ds1307_platform_data *pdata = dev_get_platdata(&amp;client-&gt;dev);
<span class="p_add">+	struct rtc_time		tm;</span>
<span class="p_add">+	unsigned long		timestamp;</span>
<span class="p_add">+</span>
 	static const int	bbsqi_bitpos[] = {
 		[ds_1337] = 0,
 		[ds_1339] = DS1339_BIT_BBSQI,
<span class="p_chunk">@@ -1115,6 +1120,27 @@</span> <span class="p_context"> read_rtc:</span>
 		return PTR_ERR(ds1307-&gt;rtc);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some IPs have weekday reset value = 0x1 which might not correct</span>
<span class="p_add">+	 * hence compute the wday using the current date/month/year values</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ds1307_get_time(&amp;client-&gt;dev, &amp;tm);</span>
<span class="p_add">+	wday = tm.tm_wday;</span>
<span class="p_add">+	rtc_tm_to_time(&amp;tm, &amp;timestamp);</span>
<span class="p_add">+	rtc_time_to_tm(timestamp, &amp;tm);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check if reset wday is different from the computed wday</span>
<span class="p_add">+	 * If different then set the wday which we computed using</span>
<span class="p_add">+	 * timestamp</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (wday != tm.tm_wday) {</span>
<span class="p_add">+		wday = i2c_smbus_read_byte_data(client, MCP794XX_REG_WEEKDAY);</span>
<span class="p_add">+		wday = wday &amp; ~MCP794XX_REG_WEEKDAY_WDAY_MASK;</span>
<span class="p_add">+		wday = wday | (tm.tm_wday + 1);</span>
<span class="p_add">+		i2c_smbus_write_byte_data(client, MCP794XX_REG_WEEKDAY, wday);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (want_irq) {
 		err = request_irq(client-&gt;irq, ds1307_irq, IRQF_SHARED,
 			  ds1307-&gt;rtc-&gt;name, client);
<span class="p_header">diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c</span>
<span class="p_header">index 1eef0f586950..cf0214005fca 100644</span>
<span class="p_header">--- a/drivers/s390/block/dasd.c</span>
<span class="p_header">+++ b/drivers/s390/block/dasd.c</span>
<span class="p_chunk">@@ -1613,9 +1613,18 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	unsigned long long now;
 	int expires;
 
<span class="p_add">+	cqr = (struct dasd_ccw_req *) intparm;</span>
 	if (IS_ERR(irb)) {
 		switch (PTR_ERR(irb)) {
 		case -EIO:
<span class="p_add">+			if (cqr &amp;&amp; cqr-&gt;status == DASD_CQR_CLEAR_PENDING) {</span>
<span class="p_add">+				device = (struct dasd_device *) cqr-&gt;startdev;</span>
<span class="p_add">+				cqr-&gt;status = DASD_CQR_CLEARED;</span>
<span class="p_add">+				dasd_device_clear_timer(device);</span>
<span class="p_add">+				wake_up(&amp;dasd_flush_wq);</span>
<span class="p_add">+				dasd_schedule_device_bh(device);</span>
<span class="p_add">+				return;</span>
<span class="p_add">+			}</span>
 			break;
 		case -ETIMEDOUT:
 			DBF_EVENT_DEVID(DBF_WARNING, cdev, &quot;%s: &quot;
<span class="p_chunk">@@ -1631,7 +1640,6 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	}
 
 	now = get_tod_clock();
<span class="p_del">-	cqr = (struct dasd_ccw_req *) intparm;</span>
 	/* check for conditions that should be handled immediately */
 	if (!cqr ||
 	    !(scsw_dstat(&amp;irb-&gt;scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &amp;&amp;
<span class="p_header">diff --git a/drivers/scsi/aacraid/commctrl.c b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">index fbcd48d0bfc3..16b2db3cd9f1 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	struct fib *fibptr;
 	struct hw_fib * hw_fib = (struct hw_fib *)0;
 	dma_addr_t hw_fib_pa = (dma_addr_t)0LL;
<span class="p_del">-	unsigned size;</span>
<span class="p_add">+	unsigned int size, osize;</span>
 	int retval;
 
 	if (dev-&gt;in_reset) {
<span class="p_chunk">@@ -87,7 +87,8 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	 *	will not overrun the buffer when we copy the memory. Return
 	 *	an error if we would.
 	 */
<span class="p_del">-	size = le16_to_cpu(kfib-&gt;header.Size) + sizeof(struct aac_fibhdr);</span>
<span class="p_add">+	osize = size = le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr);</span>
 	if (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))
 		size = le16_to_cpu(kfib-&gt;header.SenderSize);
 	if (size &gt; dev-&gt;max_fib_size) {
<span class="p_chunk">@@ -118,6 +119,14 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	/* Sanity check the second copy */</span>
<span class="p_add">+	if ((osize != le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr))</span>
<span class="p_add">+		|| (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))) {</span>
<span class="p_add">+		retval = -EINVAL;</span>
<span class="p_add">+		goto cleanup;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (kfib-&gt;header.Command == cpu_to_le16(TakeABreakPt)) {
 		aac_adapter_interrupt(dev);
 		/*
<span class="p_header">diff --git a/drivers/scsi/arcmsr/arcmsr_hba.c b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">index 652b41b4ddbd..4494529c4a60 100644</span>
<span class="p_header">--- a/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">+++ b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_chunk">@@ -1802,7 +1802,8 @@</span> <span class="p_context"> static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,</span>
 
 	case ARCMSR_MESSAGE_WRITE_WQBUFFER: {
 		unsigned char *ver_addr;
<span class="p_del">-		int32_t my_empty_len, user_len, wqbuf_firstindex, wqbuf_lastindex;</span>
<span class="p_add">+		uint32_t user_len;</span>
<span class="p_add">+		int32_t my_empty_len, wqbuf_firstindex, wqbuf_lastindex;</span>
 		uint8_t *pQbuffer, *ptmpuserbuffer;
 
 		ver_addr = kmalloc(1032, GFP_ATOMIC);
<span class="p_chunk">@@ -1819,6 +1820,11 @@</span> <span class="p_context"> static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,</span>
 		}
 		ptmpuserbuffer = ver_addr;
 		user_len = pcmdmessagefld-&gt;cmdmessage.Length;
<span class="p_add">+		if (user_len &gt; 1032) {</span>
<span class="p_add">+			retvalue = ARCMSR_MESSAGE_FAIL;</span>
<span class="p_add">+			kfree(ver_addr);</span>
<span class="p_add">+			goto message_out;</span>
<span class="p_add">+		}</span>
 		memcpy(ptmpuserbuffer, pcmdmessagefld-&gt;messagedatabuffer, user_len);
 		wqbuf_lastindex = acb-&gt;wqbuf_lastindex;
 		wqbuf_firstindex = acb-&gt;wqbuf_firstindex;
<span class="p_header">diff --git a/drivers/scsi/constants.c b/drivers/scsi/constants.c</span>
<span class="p_header">index d35a5d6c8d7c..2cde21be80c1 100644</span>
<span class="p_header">--- a/drivers/scsi/constants.c</span>
<span class="p_header">+++ b/drivers/scsi/constants.c</span>
<span class="p_chunk">@@ -1335,9 +1335,10 @@</span> <span class="p_context"> static const char * const snstext[] = {</span>
 
 /* Get sense key string or NULL if not available */
 const char *
<span class="p_del">-scsi_sense_key_string(unsigned char key) {</span>
<span class="p_add">+scsi_sense_key_string(unsigned char key)</span>
<span class="p_add">+{</span>
 #ifdef CONFIG_SCSI_CONSTANTS
<span class="p_del">-	if (key &lt;= 0xE)</span>
<span class="p_add">+	if (key &lt; ARRAY_SIZE(snstext))</span>
 		return snstext[key];
 #endif
 	return NULL;
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index acecd7de4ea1..0f6f296eaff9 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -3996,7 +3996,7 @@</span> <span class="p_context"> static int megasas_init_fw(struct megasas_instance *instance)</span>
 	/* Find first memory bar */
 	bar_list = pci_select_bars(instance-&gt;pdev, IORESOURCE_MEM);
 	instance-&gt;bar = find_first_bit(&amp;bar_list, sizeof(unsigned long));
<span class="p_del">-	if (pci_request_selected_regions(instance-&gt;pdev, instance-&gt;bar,</span>
<span class="p_add">+	if (pci_request_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar,</span>
 					 &quot;megasas: LSI&quot;)) {
 		printk(KERN_DEBUG &quot;megasas: IO memory region busy!\n&quot;);
 		return -EBUSY;
<span class="p_chunk">@@ -4261,7 +4261,7 @@</span> <span class="p_context"> fail_ready_state:</span>
 	iounmap(instance-&gt;reg_set);
 
       fail_ioremap:
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 
 	return -EINVAL;
 }
<span class="p_chunk">@@ -4282,7 +4282,7 @@</span> <span class="p_context"> static void megasas_release_mfi(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index f16764bf9964..560bbbd03788 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -2190,7 +2190,7 @@</span> <span class="p_context"> megasas_release_fusion(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/daqboard2000.c b/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_header">index a8f6036ad82b..746d7360cfed 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_chunk">@@ -684,7 +684,7 @@</span> <span class="p_context"> static const void *daqboard2000_find_boardinfo(struct comedi_device *dev,</span>
 	const struct daq200_boardtype *board;
 	int i;
 
<span class="p_del">-	if (pcidev-&gt;subsystem_device != PCI_VENDOR_ID_IOTECH)</span>
<span class="p_add">+	if (pcidev-&gt;subsystem_vendor != PCI_VENDOR_ID_IOTECH)</span>
 		return NULL;
 
 	for (i = 0; i &lt; ARRAY_SIZE(boardtypes); i++) {
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_header">index 7ffdcc07ef92..83a96bcb21b6 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_chunk">@@ -2959,7 +2959,15 @@</span> <span class="p_context"> static int ni_ao_inttrig(struct comedi_device *dev,</span>
 	int i;
 	static const int timeout = 1000;
 
<span class="p_del">-	if (trig_num != cmd-&gt;start_arg)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Require trig_num == cmd-&gt;start_arg when cmd-&gt;start_src == TRIG_INT.</span>
<span class="p_add">+	 * For backwards compatibility, also allow trig_num == 0 when</span>
<span class="p_add">+	 * cmd-&gt;start_src != TRIG_INT (i.e. when cmd-&gt;start_src == TRIG_EXT);</span>
<span class="p_add">+	 * in that case, the internal trigger is being used as a pre-trigger</span>
<span class="p_add">+	 * before the external trigger.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(trig_num == cmd-&gt;start_arg ||</span>
<span class="p_add">+	      (trig_num == 0 &amp;&amp; cmd-&gt;start_src != TRIG_INT)))</span>
 		return -EINVAL;
 
 	/* Null trig at beginning prevent ao start trigger from executing more than
<span class="p_chunk">@@ -4407,7 +4415,7 @@</span> <span class="p_context"> static int ni_E_init(struct comedi_device *dev)</span>
 		else
 			s-&gt;maxdata = 0xffffff;
 		s-&gt;insn_read = ni_tio_insn_read;
<span class="p_del">-		s-&gt;insn_write = ni_tio_insn_read;</span>
<span class="p_add">+		s-&gt;insn_write = ni_tio_insn_write;</span>
 		s-&gt;insn_config = ni_tio_insn_config;
 #ifdef PCIDMA
 		s-&gt;subdev_flags |= SDF_CMD_READ /* | SDF_CMD_WRITE */;
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/llite/llite_lib.c b/drivers/staging/lustre/lustre/llite/llite_lib.c</span>
<span class="p_header">index 0e507f53fd9b..17cfa99b4fc0 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/llite/llite_lib.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/llite/llite_lib.c</span>
<span class="p_chunk">@@ -1386,7 +1386,7 @@</span> <span class="p_context"> int ll_setattr_raw(struct dentry *dentry, struct iattr *attr, bool hsm_import)</span>
 		attr-&gt;ia_valid |= ATTR_MTIME | ATTR_CTIME;
 	}
 
<span class="p_del">-	/* POSIX: check before ATTR_*TIME_SET set (from inode_change_ok) */</span>
<span class="p_add">+	/* POSIX: check before ATTR_*TIME_SET set (from setattr_prepare) */</span>
 	if (attr-&gt;ia_valid &amp; TIMES_SET_FLAGS) {
 		if ((!uid_eq(current_fsuid(), inode-&gt;i_uid)) &amp;&amp;
 		    !capable(CFS_CAP_FOWNER))
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 00b801df7322..ef9c33fe2617 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -505,7 +505,8 @@</span> <span class="p_context"> static void iscsit_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)</span>
 	bool scsi_cmd = (cmd-&gt;iscsi_opcode == ISCSI_OP_SCSI_CMD);
 
 	spin_lock_bh(&amp;conn-&gt;cmd_lock);
<span class="p_del">-	if (!list_empty(&amp;cmd-&gt;i_conn_node))</span>
<span class="p_add">+	if (!list_empty(&amp;cmd-&gt;i_conn_node) &amp;&amp;</span>
<span class="p_add">+	    !(cmd-&gt;se_cmd.transport_state &amp; CMD_T_FABRIC_STOP))</span>
 		list_del_init(&amp;cmd-&gt;i_conn_node);
 	spin_unlock_bh(&amp;conn-&gt;cmd_lock);
 
<span class="p_chunk">@@ -4174,6 +4175,7 @@</span> <span class="p_context"> transport_err:</span>
 
 static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)
 {
<span class="p_add">+	LIST_HEAD(tmp_list);</span>
 	struct iscsi_cmd *cmd = NULL, *cmd_tmp = NULL;
 	struct iscsi_session *sess = conn-&gt;sess;
 	/*
<span class="p_chunk">@@ -4182,18 +4184,26 @@</span> <span class="p_context"> static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)</span>
 	 * has been reset -&gt; returned sleeping pre-handler state.
 	 */
 	spin_lock_bh(&amp;conn-&gt;cmd_lock);
<span class="p_del">-	list_for_each_entry_safe(cmd, cmd_tmp, &amp;conn-&gt;conn_cmd_list, i_conn_node) {</span>
<span class="p_add">+	list_splice_init(&amp;conn-&gt;conn_cmd_list, &amp;tmp_list);</span>
 
<span class="p_add">+	list_for_each_entry(cmd, &amp;tmp_list, i_conn_node) {</span>
<span class="p_add">+		struct se_cmd *se_cmd = &amp;cmd-&gt;se_cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (se_cmd-&gt;se_tfo != NULL) {</span>
<span class="p_add">+			spin_lock(&amp;se_cmd-&gt;t_state_lock);</span>
<span class="p_add">+			se_cmd-&gt;transport_state |= CMD_T_FABRIC_STOP;</span>
<span class="p_add">+			spin_unlock(&amp;se_cmd-&gt;t_state_lock);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(cmd, cmd_tmp, &amp;tmp_list, i_conn_node) {</span>
 		list_del_init(&amp;cmd-&gt;i_conn_node);
<span class="p_del">-		spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
 
 		iscsit_increment_maxcmdsn(cmd, sess);
<span class="p_del">-</span>
 		iscsit_free_cmd(cmd, true);
 
<span class="p_del">-		spin_lock_bh(&amp;conn-&gt;cmd_lock);</span>
 	}
<span class="p_del">-	spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
 }
 
 static void iscsit_stop_timers_for_cmds(
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index 09dac9ac305e..d534738ff3c7 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -1418,8 +1418,9 @@</span> <span class="p_context"> static int __iscsi_target_login_thread(struct iscsi_np *np)</span>
 	}
 	login-&gt;zero_tsih = zero_tsih;
 
<span class="p_del">-	conn-&gt;sess-&gt;se_sess-&gt;sup_prot_ops =</span>
<span class="p_del">-		conn-&gt;conn_transport-&gt;iscsit_get_sup_prot_ops(conn);</span>
<span class="p_add">+	if (conn-&gt;sess)</span>
<span class="p_add">+		conn-&gt;sess-&gt;se_sess-&gt;sup_prot_ops =</span>
<span class="p_add">+			conn-&gt;conn_transport-&gt;iscsit_get_sup_prot_ops(conn);</span>
 
 	tpg = conn-&gt;tpg;
 	if (!tpg) {
<span class="p_header">diff --git a/drivers/target/target_core_device.c b/drivers/target/target_core_device.c</span>
<span class="p_header">index 07425b8d606e..5638b60b4192 100644</span>
<span class="p_header">--- a/drivers/target/target_core_device.c</span>
<span class="p_header">+++ b/drivers/target/target_core_device.c</span>
<span class="p_chunk">@@ -1583,13 +1583,15 @@</span> <span class="p_context"> struct se_device *target_alloc_device(struct se_hba *hba, const char *name)</span>
  * in ATA and we need to set TPE=1
  */
 bool target_configure_unmap_from_queue(struct se_dev_attrib *attrib,
<span class="p_del">-				       struct request_queue *q, int block_size)</span>
<span class="p_add">+				       struct request_queue *q)</span>
 {
<span class="p_add">+	int block_size = queue_logical_block_size(q);</span>
<span class="p_add">+</span>
 	if (!blk_queue_discard(q))
 		return false;
 
<span class="p_del">-	attrib-&gt;max_unmap_lba_count = (q-&gt;limits.max_discard_sectors &lt;&lt; 9) /</span>
<span class="p_del">-								block_size;</span>
<span class="p_add">+	attrib-&gt;max_unmap_lba_count =</span>
<span class="p_add">+		q-&gt;limits.max_discard_sectors &gt;&gt; (ilog2(block_size) - 9);</span>
 	/*
 	 * Currently hardcoded to 1 in Linux/SCSI code..
 	 */
<span class="p_header">diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c</span>
<span class="p_header">index 703f885deac1..03bfa49b5590 100644</span>
<span class="p_header">--- a/drivers/target/target_core_file.c</span>
<span class="p_header">+++ b/drivers/target/target_core_file.c</span>
<span class="p_chunk">@@ -165,8 +165,7 @@</span> <span class="p_context"> static int fd_configure_device(struct se_device *dev)</span>
 			dev_size, div_u64(dev_size, fd_dev-&gt;fd_block_size),
 			fd_dev-&gt;fd_block_size);
 
<span class="p_del">-		if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q,</span>
<span class="p_del">-						      fd_dev-&gt;fd_block_size))</span>
<span class="p_add">+		if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q))</span>
 			pr_debug(&quot;IFILE: BLOCK Discard support available,&quot;
 				 &quot; disabled by default\n&quot;);
 		/*
<span class="p_header">diff --git a/drivers/target/target_core_iblock.c b/drivers/target/target_core_iblock.c</span>
<span class="p_header">index 91c625ac40d1..7ee927d9c3ac 100644</span>
<span class="p_header">--- a/drivers/target/target_core_iblock.c</span>
<span class="p_header">+++ b/drivers/target/target_core_iblock.c</span>
<span class="p_chunk">@@ -126,8 +126,7 @@</span> <span class="p_context"> static int iblock_configure_device(struct se_device *dev)</span>
 	dev-&gt;dev_attrib.hw_max_sectors = queue_max_hw_sectors(q);
 	dev-&gt;dev_attrib.hw_queue_depth = q-&gt;nr_requests;
 
<span class="p_del">-	if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q,</span>
<span class="p_del">-					      dev-&gt;dev_attrib.hw_block_size))</span>
<span class="p_add">+	if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q))</span>
 		pr_debug(&quot;IBLOCK: BLOCK Discard support available,&quot;
 			 &quot; disabled by default\n&quot;);
 
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 33fc58d514d3..7769af94aee2 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -2455,15 +2455,10 @@</span> <span class="p_context"> static void target_release_cmd_kref(struct kref *kref)</span>
 	struct se_session *se_sess = se_cmd-&gt;se_sess;
 	bool fabric_stop;
 
<span class="p_del">-	if (list_empty(&amp;se_cmd-&gt;se_cmd_list)) {</span>
<span class="p_del">-		spin_unlock(&amp;se_sess-&gt;sess_cmd_lock);</span>
<span class="p_del">-		target_free_cmd_mem(se_cmd);</span>
<span class="p_del">-		se_cmd-&gt;se_tfo-&gt;release_cmd(se_cmd);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
 
 	spin_lock(&amp;se_cmd-&gt;t_state_lock);
<span class="p_del">-	fabric_stop = (se_cmd-&gt;transport_state &amp; CMD_T_FABRIC_STOP);</span>
<span class="p_add">+	fabric_stop = (se_cmd-&gt;transport_state &amp; CMD_T_FABRIC_STOP) &amp;&amp;</span>
<span class="p_add">+		      (se_cmd-&gt;transport_state &amp; CMD_T_ABORTED);</span>
 	spin_unlock(&amp;se_cmd-&gt;t_state_lock);
 
 	if (se_cmd-&gt;cmd_wait_set || fabric_stop) {
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index b4df88da5b40..e90ea3da5cda 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -1821,6 +1821,43 @@</span> <span class="p_context"> pci_wch_ch353_setup(struct serial_private *priv,</span>
 #define PCI_DEVICE_ID_PERICOM_PI7C9X7954	0x7954
 #define PCI_DEVICE_ID_PERICOM_PI7C9X7958	0x7958
 
<span class="p_add">+#define PCI_VENDOR_ID_ACCESIO			0x494f</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM_2SDB	0x1051</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_COM_2S	0x1053</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM_4SDB	0x105C</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_COM_4S	0x105E</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM232_2DB	0x1091</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_COM232_2	0x1093</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM232_4DB	0x1099</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_COM232_4	0x109B</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM_2SMDB	0x10D1</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_COM_2SM	0x10D3</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM_4SMDB	0x10DA</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_COM_4SM	0x10DC</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_ICM485_1	0x1108</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_ICM422_2	0x1110</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_ICM485_2	0x1111</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_ICM422_4	0x1118</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_ICM485_4	0x1119</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_ICM_2S	0x1152</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_ICM_4S	0x115A</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_ICM232_2	0x1190</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_ICM232_2	0x1191</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_ICM232_4	0x1198</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_MPCIE_ICM232_4	0x1199</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_ICM_2SM	0x11D0</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM422_4	0x105A</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM485_4	0x105B</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM422_8	0x106A</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM485_8	0x106B</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM232_4	0x1098</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM232_8	0x10A9</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM_4SM	0x10D9</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_COM_8SM	0x10E9</span>
<span class="p_add">+#define PCI_DEVICE_ID_ACCESIO_PCIE_ICM_4SM	0x11D8</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 /* Unknown vendors/cards - this should not be in linux/pci_ids.h */
 #define PCI_SUBDEVICE_ID_UNKNOWN_0x1584	0x1584
 #define PCI_SUBDEVICE_ID_UNKNOWN_0x1588	0x1588
<span class="p_chunk">@@ -4890,6 +4927,108 @@</span> <span class="p_context"> static struct pci_device_id serial_pci_tbl[] = {</span>
 		0,
 		0, pbn_pericom_PI7C9X7958 },
 	/*
<span class="p_add">+	 * ACCES I/O Products quad</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM_2SDB,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_COM_2S,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM_4SDB,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_COM_4S,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM232_2DB,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_COM232_2,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM232_4DB,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_COM232_4,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM_2SMDB,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_COM_2SM,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM_4SMDB,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_COM_4SM,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_ICM485_1,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_ICM422_2,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_ICM485_2,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_ICM422_4,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_ICM485_4,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_ICM_2S,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_ICM_4S,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_ICM232_2,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_ICM232_2,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_ICM232_4,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_MPCIE_ICM232_4,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_ICM_2SM,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM422_4,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM485_4,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM422_8,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM485_8,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM232_4,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM232_8,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM_4SM,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_COM_8SM,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_ACCESIO, PCI_DEVICE_ID_ACCESIO_PCIE_ICM_4SM,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,</span>
<span class="p_add">+		pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	/*</span>
 	 * Topic TP560 Data/Fax/Voice 56k modem (reported by Evan Clarke)
 	 */
 	{	PCI_VENDOR_ID_TOPIC, PCI_DEVICE_ID_TOPIC_TP560,
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 0d39ae4ff533..d806657ca53e 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -434,19 +434,21 @@</span> <span class="p_context"> static void atmel_start_tx(struct uart_port *port)</span>
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
<span class="p_del">-	if (atmel_use_pdc_tx(port)) {</span>
<span class="p_del">-		if (UART_GET_PTSR(port) &amp; ATMEL_PDC_TXTEN)</span>
<span class="p_del">-			/* The transmitter is already running.  Yes, we</span>
<span class="p_del">-			   really need this.*/</span>
<span class="p_del">-			return;</span>
<span class="p_add">+	if (atmel_use_pdc_tx(port) &amp;&amp; (UART_GET_PTSR(port)</span>
<span class="p_add">+				       &amp; ATMEL_PDC_TXTEN))</span>
<span class="p_add">+		/* The transmitter is already running.  Yes, we</span>
<span class="p_add">+		   really need this.*/</span>
<span class="p_add">+		return;</span>
 
<span class="p_add">+	if (atmel_use_pdc_tx(port) || atmel_use_dma_tx(port))</span>
 		if ((atmel_port-&gt;rs485.flags &amp; SER_RS485_ENABLED) &amp;&amp;
 		    !(atmel_port-&gt;rs485.flags &amp; SER_RS485_RX_DURING_TX))
 			atmel_stop_rx(port);
 
<span class="p_add">+	if (atmel_use_pdc_tx(port))</span>
 		/* re-enable PDC transmit */
 		UART_PUT_PTCR(port, ATMEL_PDC_TXTEN);
<span class="p_del">-	}</span>
<span class="p_add">+</span>
 	/* Enable interrupts */
 	UART_PUT_IER(port, atmel_port-&gt;tx_done_mask);
 }
<span class="p_header">diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c</span>
<span class="p_header">index 7268409dfc68..2a2a54db86ff 100644</span>
<span class="p_header">--- a/drivers/tty/serial/samsung.c</span>
<span class="p_header">+++ b/drivers/tty/serial/samsung.c</span>
<span class="p_chunk">@@ -1163,7 +1163,7 @@</span> <span class="p_context"> static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,</span>
 		return -ENODEV;
 
 	if (port-&gt;mapbase != 0)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	/* setup info for port */
 	port-&gt;dev	= &amp;platdev-&gt;dev;
<span class="p_chunk">@@ -1213,14 +1213,15 @@</span> <span class="p_context"> static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,</span>
 	if (IS_ERR(ourport-&gt;clk)) {
 		pr_err(&quot;%s: Controller clock not found\n&quot;,
 				dev_name(&amp;platdev-&gt;dev));
<span class="p_del">-		return PTR_ERR(ourport-&gt;clk);</span>
<span class="p_add">+		ret = PTR_ERR(ourport-&gt;clk);</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	ret = clk_prepare_enable(ourport-&gt;clk);
 	if (ret) {
 		pr_err(&quot;uart: clock failed to prepare+enable: %d\n&quot;, ret);
 		clk_put(ourport-&gt;clk);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	/* Keep all interrupts masked and cleared */
<span class="p_chunk">@@ -1236,7 +1237,12 @@</span> <span class="p_context"> static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,</span>
 
 	/* reset the fifos (and setup the uart) */
 	s3c24xx_serial_resetport(port, cfg);
<span class="p_add">+</span>
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	port-&gt;mapbase = 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 #ifdef CONFIG_SAMSUNG_CLOCK
<span class="p_chunk">@@ -1301,8 +1307,6 @@</span> <span class="p_context"> static int s3c24xx_serial_probe(struct platform_device *pdev)</span>
 		ourport-&gt;info-&gt;fifosize :
 		ourport-&gt;drv_data-&gt;fifosize[probe_index];
 
<span class="p_del">-	probe_index++;</span>
<span class="p_del">-</span>
 	dbg(&quot;%s: initialising port %p...\n&quot;, __func__, ourport);
 
 	ret = s3c24xx_serial_init_port(ourport, pdev);
<span class="p_chunk">@@ -1338,6 +1342,8 @@</span> <span class="p_context"> static int s3c24xx_serial_probe(struct platform_device *pdev)</span>
 	if (ret &lt; 0)
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to add cpufreq notifier\n&quot;);
 
<span class="p_add">+	probe_index++;</span>
<span class="p_add">+</span>
 	return 0;
 
  probe_err:
<span class="p_header">diff --git a/drivers/tty/serial/sunhv.c b/drivers/tty/serial/sunhv.c</span>
<span class="p_header">index dc697cee248a..233103adad2d 100644</span>
<span class="p_header">--- a/drivers/tty/serial/sunhv.c</span>
<span class="p_header">+++ b/drivers/tty/serial/sunhv.c</span>
<span class="p_chunk">@@ -492,12 +492,6 @@</span> <span class="p_context"> static void sunhv_console_write_bychar(struct console *con, const char *s, unsig</span>
 		locked = spin_trylock_irqsave(&amp;port-&gt;lock, flags);
 	else
 		spin_lock_irqsave(&amp;port-&gt;lock, flags);
<span class="p_del">-	if (port-&gt;sysrq) {</span>
<span class="p_del">-		locked = 0;</span>
<span class="p_del">-	} else if (oops_in_progress) {</span>
<span class="p_del">-		locked = spin_trylock(&amp;port-&gt;lock);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		spin_lock(&amp;port-&gt;lock);</span>
 
 	for (i = 0; i &lt; n; i++) {
 		if (*s == &#39;\n&#39;)
<span class="p_header">diff --git a/drivers/tty/vt/keyboard.c b/drivers/tty/vt/keyboard.c</span>
<span class="p_header">index d0e3a4497707..adf4d3124cc6 100644</span>
<span class="p_header">--- a/drivers/tty/vt/keyboard.c</span>
<span class="p_header">+++ b/drivers/tty/vt/keyboard.c</span>
<span class="p_chunk">@@ -365,34 +365,22 @@</span> <span class="p_context"> static void to_utf8(struct vc_data *vc, uint c)</span>
 
 static void do_compute_shiftstate(void)
 {
<span class="p_del">-	unsigned int i, j, k, sym, val;</span>
<span class="p_add">+	unsigned int k, sym, val;</span>
 
 	shift_state = 0;
 	memset(shift_down, 0, sizeof(shift_down));
 
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(key_down); i++) {</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!key_down[i])</span>
<span class="p_add">+	for_each_set_bit(k, key_down, min(NR_KEYS, KEY_CNT)) {</span>
<span class="p_add">+		sym = U(key_maps[0][k]);</span>
<span class="p_add">+		if (KTYP(sym) != KT_SHIFT &amp;&amp; KTYP(sym) != KT_SLOCK)</span>
 			continue;
 
<span class="p_del">-		k = i * BITS_PER_LONG;</span>
<span class="p_del">-</span>
<span class="p_del">-		for (j = 0; j &lt; BITS_PER_LONG; j++, k++) {</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!test_bit(k, key_down))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		val = KVAL(sym);</span>
<span class="p_add">+		if (val == KVAL(K_CAPSSHIFT))</span>
<span class="p_add">+			val = KVAL(K_SHIFT);</span>
 
<span class="p_del">-			sym = U(key_maps[0][k]);</span>
<span class="p_del">-			if (KTYP(sym) != KT_SHIFT &amp;&amp; KTYP(sym) != KT_SLOCK)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-</span>
<span class="p_del">-			val = KVAL(sym);</span>
<span class="p_del">-			if (val == KVAL(K_CAPSSHIFT))</span>
<span class="p_del">-				val = KVAL(K_SHIFT);</span>
<span class="p_del">-</span>
<span class="p_del">-			shift_down[val]++;</span>
<span class="p_del">-			shift_state |= (1 &lt;&lt; val);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		shift_down[val]++;</span>
<span class="p_add">+		shift_state |= BIT(val);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 54061a3bc5e9..73b3b054771f 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1336,7 +1336,6 @@</span> <span class="p_context"> made_compressed_probe:</span>
 	spin_lock_init(&amp;acm-&gt;write_lock);
 	spin_lock_init(&amp;acm-&gt;read_lock);
 	mutex_init(&amp;acm-&gt;mutex);
<span class="p_del">-	acm-&gt;rx_endpoint = usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress);</span>
 	acm-&gt;is_int_ep = usb_endpoint_xfer_int(epread);
 	if (acm-&gt;is_int_ep)
 		acm-&gt;bInterval = epread-&gt;bInterval;
<span class="p_chunk">@@ -1386,14 +1385,14 @@</span> <span class="p_context"> made_compressed_probe:</span>
 		urb-&gt;transfer_dma = rb-&gt;dma;
 		if (acm-&gt;is_int_ep) {
 			usb_fill_int_urb(urb, acm-&gt;dev,
<span class="p_del">-					 acm-&gt;rx_endpoint,</span>
<span class="p_add">+					 usb_rcvintpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					 rb-&gt;base,
 					 acm-&gt;readsize,
 					 acm_read_bulk_callback, rb,
 					 acm-&gt;bInterval);
 		} else {
 			usb_fill_bulk_urb(urb, acm-&gt;dev,
<span class="p_del">-					  acm-&gt;rx_endpoint,</span>
<span class="p_add">+					  usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					  rb-&gt;base,
 					  acm-&gt;readsize,
 					  acm_read_bulk_callback, rb);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index 70d24d7e9dc5..6050d8e92c5e 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -95,7 +95,6 @@</span> <span class="p_context"> struct acm {</span>
 	struct urb *read_urbs[ACM_NR];
 	struct acm_rb read_buffers[ACM_NR];
 	int rx_buflimit;
<span class="p_del">-	int rx_endpoint;</span>
 	spinlock_t read_lock;
 	int write_used;					/* number of non-empty write buffers */
 	int transmitting;
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 894894f2ff93..8de16f982f55 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -142,6 +142,31 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 	}
 }
 
<span class="p_add">+static const unsigned short low_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 8,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 8,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short full_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1023,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 64,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short high_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short super_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
     int asnum, struct usb_host_interface *ifp, int num_ep,
     unsigned char *buffer, int size)
<span class="p_chunk">@@ -150,6 +175,8 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	struct usb_endpoint_descriptor *d;
 	struct usb_host_endpoint *endpoint;
 	int n, i, j, retval;
<span class="p_add">+	unsigned int maxp;</span>
<span class="p_add">+	const unsigned short *maxpacket_maxes;</span>
 
 	d = (struct usb_endpoint_descriptor *) buffer;
 	buffer += d-&gt;bLength;
<span class="p_chunk">@@ -184,8 +211,10 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	memcpy(&amp;endpoint-&gt;desc, d, n);
 	INIT_LIST_HEAD(&amp;endpoint-&gt;urb_list);
 
<span class="p_del">-	/* Fix up bInterval values outside the legal range. Use 32 ms if no</span>
<span class="p_del">-	 * proper value can be guessed. */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fix up bInterval values outside the legal range.</span>
<span class="p_add">+	 * Use 10 or 8 ms if no proper value can be guessed.</span>
<span class="p_add">+	 */</span>
 	i = 0;		/* i = min, j = max, n = default */
 	j = 255;
 	if (usb_endpoint_xfer_int(d)) {
<span class="p_chunk">@@ -193,13 +222,15 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 		switch (to_usb_device(ddev)-&gt;speed) {
 		case USB_SPEED_SUPER:
 		case USB_SPEED_HIGH:
<span class="p_del">-			/* Many device manufacturers are using full-speed</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Many device manufacturers are using full-speed</span>
 			 * bInterval values in high-speed interrupt endpoint
<span class="p_del">-			 * descriptors. Try to fix those and fall back to a</span>
<span class="p_del">-			 * 32 ms default value otherwise. */</span>
<span class="p_add">+			 * descriptors. Try to fix those and fall back to an</span>
<span class="p_add">+			 * 8-ms default value otherwise.</span>
<span class="p_add">+			 */</span>
 			n = fls(d-&gt;bInterval*8);
 			if (n == 0)
<span class="p_del">-				n = 9;	/* 32 ms = 2^(9-1) uframes */</span>
<span class="p_add">+				n = 7;	/* 8 ms = 2^(7-1) uframes */</span>
 			j = 16;
 
 			/*
<span class="p_chunk">@@ -214,10 +245,12 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 			}
 			break;
 		default:		/* USB_SPEED_FULL or _LOW */
<span class="p_del">-			/* For low-speed, 10 ms is the official minimum.</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * For low-speed, 10 ms is the official minimum.</span>
 			 * But some &quot;overclocked&quot; devices might want faster
<span class="p_del">-			 * polling so we&#39;ll allow it. */</span>
<span class="p_del">-			n = 32;</span>
<span class="p_add">+			 * polling so we&#39;ll allow it.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			n = 10;</span>
 			break;
 		}
 	} else if (usb_endpoint_xfer_isoc(d)) {
<span class="p_chunk">@@ -225,10 +258,10 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 		j = 16;
 		switch (to_usb_device(ddev)-&gt;speed) {
 		case USB_SPEED_HIGH:
<span class="p_del">-			n = 9;		/* 32 ms = 2^(9-1) uframes */</span>
<span class="p_add">+			n = 7;		/* 8 ms = 2^(7-1) uframes */</span>
 			break;
 		default:		/* USB_SPEED_FULL */
<span class="p_del">-			n = 6;		/* 32 ms = 2^(6-1) frames */</span>
<span class="p_add">+			n = 4;		/* 8 ms = 2^(4-1) frames */</span>
 			break;
 		}
 	}
<span class="p_chunk">@@ -256,6 +289,41 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 			endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
 	}
 
<span class="p_add">+	/* Validate the wMaxPacketSize field */</span>
<span class="p_add">+	maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the highest legal maxpacket size for this endpoint */</span>
<span class="p_add">+	i = 0;		/* additional transactions per microframe */</span>
<span class="p_add">+	switch (to_usb_device(ddev)-&gt;speed) {</span>
<span class="p_add">+	case USB_SPEED_LOW:</span>
<span class="p_add">+		maxpacket_maxes = low_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_FULL:</span>
<span class="p_add">+		maxpacket_maxes = full_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_HIGH:</span>
<span class="p_add">+		/* Bits 12..11 are allowed only for HS periodic endpoints */</span>
<span class="p_add">+		if (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {</span>
<span class="p_add">+			i = maxp &amp; (BIT(12) | BIT(11));</span>
<span class="p_add">+			maxp &amp;= ~i;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* fallthrough */</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		maxpacket_maxes = high_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_SUPER:</span>
<span class="p_add">+		maxpacket_maxes = super_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	j = maxpacket_maxes[usb_endpoint_type(&amp;endpoint-&gt;desc)];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (maxp &gt; j) {</span>
<span class="p_add">+		dev_warn(ddev, &quot;config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n&quot;,</span>
<span class="p_add">+		    cfgno, inum, asnum, d-&gt;bEndpointAddress, maxp, j);</span>
<span class="p_add">+		maxp = j;</span>
<span class="p_add">+		endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(i | maxp);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Some buggy high speed devices have bulk endpoints using
 	 * maxpacket sizes other than 512.  High speed HCDs may not
<span class="p_chunk">@@ -263,9 +331,6 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	 */
 	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_HIGH
 			&amp;&amp; usb_endpoint_xfer_bulk(d)) {
<span class="p_del">-		unsigned maxp;</span>
<span class="p_del">-</span>
<span class="p_del">-		maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc) &amp; 0x07ff;</span>
 		if (maxp != 512)
 			dev_warn(ddev, &quot;config %d interface %d altsetting %d &quot;
 				&quot;bulk endpoint 0x%X has invalid maxpacket %d\n&quot;,
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index dfcb5f8b8f18..39a8bb8f8820 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -1527,11 +1527,17 @@</span> <span class="p_context"> static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb</span>
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
 	as-&gt;urb-&gt;number_of_packets = number_of_packets;
 	as-&gt;urb-&gt;stream_id = stream_id;
<span class="p_del">-	if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||</span>
<span class="p_del">-			ps-&gt;dev-&gt;speed == USB_SPEED_HIGH)</span>
<span class="p_del">-		as-&gt;urb-&gt;interval = 1 &lt;&lt; min(15, ep-&gt;desc.bInterval - 1);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ep-&gt;desc.bInterval) {</span>
<span class="p_add">+		if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||</span>
<span class="p_add">+				ps-&gt;dev-&gt;speed == USB_SPEED_HIGH ||</span>
<span class="p_add">+				ps-&gt;dev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
<span class="p_add">+			as-&gt;urb-&gt;interval = 1 &lt;&lt;</span>
<span class="p_add">+					min(15, ep-&gt;desc.bInterval - 1);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	as-&gt;urb-&gt;context = as;
 	as-&gt;urb-&gt;complete = async_completed;
 	for (totlen = u = 0; u &lt; number_of_packets; u++) {
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 0673a5abc21d..6c7e47f67dd4 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -125,6 +125,12 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	{ USB_DEVICE(0x04f3, 0x016f), .driver_info =
 			USB_QUIRK_DEVICE_QUALIFIER },
 
<span class="p_add">+	{ USB_DEVICE(0x04f3, 0x0381), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_NO_LPM },</span>
<span class="p_add">+</span>
<span class="p_add">+	{ USB_DEVICE(0x04f3, 0x21b8), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_DEVICE_QUALIFIER },</span>
<span class="p_add">+</span>
 	/* Roland SC-8820 */
 	{ USB_DEVICE(0x0582, 0x0007), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 4a279bb9092a..ede2814702c4 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -1943,14 +1943,6 @@</span> <span class="p_context"> static int __dwc3_cleanup_done_trbs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 			s_pkt = 1;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We assume here we will always receive the entire data block</span>
<span class="p_del">-	 * which we should receive. Meaning, if we program RX to</span>
<span class="p_del">-	 * receive 4K but we receive only 2K, we assume that&#39;s all we</span>
<span class="p_del">-	 * should receive and we simply bounce the request back to the</span>
<span class="p_del">-	 * gadget driver for further processing.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	req-&gt;request.actual += req-&gt;request.length - count;</span>
 	if (s_pkt)
 		return 1;
 	if ((event-&gt;status &amp; DEPEVT_STATUS_LST) &amp;&amp;
<span class="p_chunk">@@ -1970,6 +1962,7 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 	struct dwc3_trb		*trb;
 	unsigned int		slot;
 	unsigned int		i;
<span class="p_add">+	int			count = 0;</span>
 	int			ret;
 
 	do {
<span class="p_chunk">@@ -1986,6 +1979,8 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 				slot++;
 			slot %= DWC3_TRB_NUM;
 			trb = &amp;dep-&gt;trb_pool[slot];
<span class="p_add">+			count += trb-&gt;size &amp; DWC3_TRB_SIZE_MASK;</span>
<span class="p_add">+</span>
 
 			ret = __dwc3_cleanup_done_trbs(dwc, dep, req, trb,
 					event, status);
<span class="p_chunk">@@ -1993,6 +1988,14 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 				break;
 		}while (++i &lt; req-&gt;request.num_mapped_sgs);
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We assume here we will always receive the entire data block</span>
<span class="p_add">+		 * which we should receive. Meaning, if we program RX to</span>
<span class="p_add">+		 * receive 4K but we receive only 2K, we assume that&#39;s all we</span>
<span class="p_add">+		 * should receive and we simply bounce the request back to the</span>
<span class="p_add">+		 * gadget driver for further processing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		req-&gt;request.actual += req-&gt;request.length - count;</span>
 		dwc3_gadget_giveback(dep, req, status);
 
 		if (ret)
<span class="p_chunk">@@ -2016,6 +2019,10 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 		return 1;
 	}
 
<span class="p_add">+	if (usb_endpoint_xfer_isoc(dep-&gt;endpoint.desc))</span>
<span class="p_add">+		if ((event-&gt;status &amp; DEPEVT_STATUS_IOC) &amp;&amp;</span>
<span class="p_add">+				(trb-&gt;ctrl &amp; DWC3_TRB_CTRL_IOC))</span>
<span class="p_add">+			return 0;</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/drivers/usb/gadget/fsl_qe_udc.c b/drivers/usb/gadget/fsl_qe_udc.c</span>
<span class="p_header">index ad5483335167..8214773321ef 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/fsl_qe_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/fsl_qe_udc.c</span>
<span class="p_chunk">@@ -1881,11 +1881,8 @@</span> <span class="p_context"> static int qe_get_frame(struct usb_gadget *gadget)</span>
 
 	tmp = in_be16(&amp;udc-&gt;usb_param-&gt;frame_n);
 	if (tmp &amp; 0x8000)
<span class="p_del">-		tmp = tmp &amp; 0x07ff;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		tmp = -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return (int)tmp;</span>
<span class="p_add">+		return tmp &amp; 0x07ff;</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int fsl_qe_start(struct usb_gadget *gadget,
<span class="p_chunk">@@ -2057,7 +2054,7 @@</span> <span class="p_context"> static void setup_received_handle(struct qe_udc *udc,</span>
 			struct qe_ep *ep;
 
 			if (wValue != 0 || wLength != 0
<span class="p_del">-				|| pipe &gt; USB_MAX_ENDPOINTS)</span>
<span class="p_add">+				|| pipe &gt;= USB_MAX_ENDPOINTS)</span>
 				break;
 			ep = &amp;udc-&gt;eps[pipe];
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc-core.c b/drivers/usb/gadget/udc-core.c</span>
<span class="p_header">index 38913eac6e7c..d7ef85f38847 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc-core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc-core.c</span>
<span class="p_chunk">@@ -91,7 +91,7 @@</span> <span class="p_context"> void usb_gadget_unmap_request(struct usb_gadget *gadget,</span>
 		return;
 
 	if (req-&gt;num_mapped_sgs) {
<span class="p_del">-		dma_unmap_sg(&amp;gadget-&gt;dev, req-&gt;sg, req-&gt;num_mapped_sgs,</span>
<span class="p_add">+		dma_unmap_sg(&amp;gadget-&gt;dev, req-&gt;sg, req-&gt;num_sgs,</span>
 				is_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 
 		req-&gt;num_mapped_sgs = 0;
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 69a70f880429..8ae80088d348 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -276,6 +276,9 @@</span> <span class="p_context"> static int xhci_stop_device(struct xhci_hcd *xhci, int slot_id, int suspend)</span>
 
 	ret = 0;
 	virt_dev = xhci-&gt;devs[slot_id];
<span class="p_add">+	if (!virt_dev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	cmd = xhci_alloc_command(xhci, false, true, GFP_NOIO);
 	if (!cmd) {
 		xhci_dbg(xhci, &quot;Couldn&#39;t allocate command structure.\n&quot;);
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 4b36d8562eef..015d4c08a3cb 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -293,12 +293,13 @@</span> <span class="p_context"> static void xhci_pci_remove(struct pci_dev *dev)</span>
 		usb_remove_hcd(xhci-&gt;shared_hcd);
 		usb_put_hcd(xhci-&gt;shared_hcd);
 	}
<span class="p_del">-	usb_hcd_pci_remove(dev);</span>
 
 	/* Workaround for spurious wakeups at shutdown with HSW */
 	if (xhci-&gt;quirks &amp; XHCI_SPURIOUS_WAKEUP)
 		pci_set_power_state(dev, PCI_D3hot);
 
<span class="p_add">+	usb_hcd_pci_remove(dev);</span>
<span class="p_add">+</span>
 	kfree(xhci);
 }
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index f15e2df4448c..58edc5478d6e 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1351,12 +1351,6 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 
 	cmd = list_entry(xhci-&gt;cmd_list.next, struct xhci_command, cmd_list);
 
<span class="p_del">-	if (cmd-&gt;command_trb != xhci-&gt;cmd_ring-&gt;dequeue) {</span>
<span class="p_del">-		xhci_err(xhci,</span>
<span class="p_del">-			 &quot;Command completion event does not match command\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	del_timer(&amp;xhci-&gt;cmd_timer);
 
 	trace_xhci_cmd_completion(cmd_trb, (struct xhci_generic_trb *) event);
<span class="p_chunk">@@ -1368,6 +1362,13 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 		xhci_handle_stopped_cmd_ring(xhci, cmd);
 		return;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (cmd-&gt;command_trb != xhci-&gt;cmd_ring-&gt;dequeue) {</span>
<span class="p_add">+		xhci_err(xhci,</span>
<span class="p_add">+			 &quot;Command completion event does not match command\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Host aborted the command ring, check if the current command was
 	 * supposed to be aborted, otherwise continue normally.
<span class="p_header">diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c</span>
<span class="p_header">index 829f446064ea..419a5b3cb924 100644</span>
<span class="p_header">--- a/drivers/usb/misc/usbtest.c</span>
<span class="p_header">+++ b/drivers/usb/misc/usbtest.c</span>
<span class="p_chunk">@@ -488,7 +488,6 @@</span> <span class="p_context"> static void sg_timeout(unsigned long _req)</span>
 {
 	struct usb_sg_request	*req = (struct usb_sg_request *) _req;
 
<span class="p_del">-	req-&gt;status = -ETIMEDOUT;</span>
 	usb_sg_cancel(req);
 }
 
<span class="p_chunk">@@ -519,8 +518,10 @@</span> <span class="p_context"> static int perform_sglist(</span>
 		mod_timer(&amp;sg_timer, jiffies +
 				msecs_to_jiffies(SIMPLE_IO_TIMEOUT));
 		usb_sg_wait(req);
<span class="p_del">-		del_timer_sync(&amp;sg_timer);</span>
<span class="p_del">-		retval = req-&gt;status;</span>
<span class="p_add">+		if (!del_timer_sync(&amp;sg_timer))</span>
<span class="p_add">+			retval = -ETIMEDOUT;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			retval = req-&gt;status;</span>
 
 		/* FIXME check resulting data pattern */
 
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index 50763ebff015..2a540e4b5c61 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -780,36 +780,46 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 {
 	struct usbhs_pkt *pkt = container_of(work, struct usbhs_pkt, work);
 	struct usbhs_pipe *pipe = pkt-&gt;pipe;
<span class="p_del">-	struct usbhs_fifo *fifo = usbhs_pipe_to_fifo(pipe);</span>
<span class="p_add">+	struct usbhs_fifo *fifo;</span>
 	struct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);
 	struct dma_async_tx_descriptor *desc;
<span class="p_del">-	struct dma_chan *chan = usbhsf_dma_chan_get(fifo, pkt);</span>
<span class="p_add">+	struct dma_chan *chan;</span>
 	struct device *dev = usbhs_priv_to_dev(priv);
 	enum dma_transfer_direction dir;
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_add">+	usbhs_lock(priv, flags);</span>
<span class="p_add">+	fifo = usbhs_pipe_to_fifo(pipe);</span>
<span class="p_add">+	if (!fifo)</span>
<span class="p_add">+		goto xfer_work_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	chan = usbhsf_dma_chan_get(fifo, pkt);</span>
 	dir = usbhs_pipe_is_dir_in(pipe) ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;
 
 	desc = dmaengine_prep_slave_single(chan, pkt-&gt;dma + pkt-&gt;actual,
 					pkt-&gt;trans, dir,
 					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 	if (!desc)
<span class="p_del">-		return;</span>
<span class="p_add">+		goto xfer_work_end;</span>
 
 	desc-&gt;callback		= usbhsf_dma_complete;
 	desc-&gt;callback_param	= pipe;
 
 	if (dmaengine_submit(desc) &lt; 0) {
 		dev_err(dev, &quot;Failed to submit dma descriptor\n&quot;);
<span class="p_del">-		return;</span>
<span class="p_add">+		goto xfer_work_end;</span>
 	}
 
 	dev_dbg(dev, &quot;  %s %d (%d/ %d)\n&quot;,
 		fifo-&gt;name, usbhs_pipe_number(pipe), pkt-&gt;length, pkt-&gt;zero);
 
<span class="p_del">-	usbhs_pipe_set_trans_count_if_bulk(pipe, pkt-&gt;trans);</span>
<span class="p_del">-	usbhs_pipe_enable(pipe);</span>
 	usbhsf_dma_start(pipe, fifo);
<span class="p_add">+	usbhs_pipe_set_trans_count_if_bulk(pipe, pkt-&gt;trans);</span>
 	dma_async_issue_pending(chan);
<span class="p_add">+	usbhs_pipe_enable(pipe);</span>
<span class="p_add">+</span>
<span class="p_add">+xfer_work_end:</span>
<span class="p_add">+	usbhs_unlock(priv, flags);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/mod.c b/drivers/usb/renesas_usbhs/mod.c</span>
<span class="p_header">index 6a030b931a3b..254194d61915 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/mod.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/mod.c</span>
<span class="p_chunk">@@ -272,9 +272,16 @@</span> <span class="p_context"> static irqreturn_t usbhs_interrupt(int irq, void *data)</span>
 	usbhs_write(priv, INTSTS0, ~irq_state.intsts0 &amp; INTSTS0_MAGIC);
 	usbhs_write(priv, INTSTS1, ~irq_state.intsts1 &amp; INTSTS1_MAGIC);
 
<span class="p_del">-	usbhs_write(priv, BRDYSTS, ~irq_state.brdysts);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The driver should not clear the xxxSTS after the line of</span>
<span class="p_add">+	 * &quot;call irq callback functions&quot; because each &quot;if&quot; statement is</span>
<span class="p_add">+	 * possible to call the callback function for avoiding any side effects.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (irq_state.intsts0 &amp; BRDY)</span>
<span class="p_add">+		usbhs_write(priv, BRDYSTS, ~irq_state.brdysts);</span>
 	usbhs_write(priv, NRDYSTS, ~irq_state.nrdysts);
<span class="p_del">-	usbhs_write(priv, BEMPSTS, ~irq_state.bempsts);</span>
<span class="p_add">+	if (irq_state.intsts0 &amp; BEMP)</span>
<span class="p_add">+		usbhs_write(priv, BEMPSTS, ~irq_state.bempsts);</span>
 
 	/*
 	 * call irq callback functions
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">index e344d50f4697..6583c04cc35e 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_chunk">@@ -558,6 +558,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct usbhs_pipe *pipe;
 	int ret = -EIO;
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	usbhs_lock(priv, flags);</span>
 
 	/*
 	 * if it already have pipe,
<span class="p_chunk">@@ -566,7 +569,8 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	if (uep-&gt;pipe) {
 		usbhs_pipe_clear(uep-&gt;pipe);
 		usbhs_pipe_sequence_data0(uep-&gt;pipe);
<span class="p_del">-		return 0;</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto usbhsg_ep_enable_end;</span>
 	}
 
 	pipe = usbhs_pipe_malloc(priv,
<span class="p_chunk">@@ -594,6 +598,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 		ret = 0;
 	}
 
<span class="p_add">+usbhsg_ep_enable_end:</span>
<span class="p_add">+	usbhs_unlock(priv, flags);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index fb3a832d86e3..6103727cd060 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -661,6 +661,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_TFD128_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_FM3RX_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS777_PID) },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_PALMSENS_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_IVIUM_XSTAT_PID) },</span>
 	{ USB_DEVICE(FTDI_VID, LINX_SDMUSBQSS_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_MASTERDEVEL2_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_FUTURE_0_PID) },
<span class="p_chunk">@@ -1021,6 +1023,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7560U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7561U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7563U_PID) },
<span class="p_add">+	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 334bc600282d..48db84f25cc9 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -406,6 +406,12 @@</span> <span class="p_context"></span>
 #define FTDI_4N_GALAXY_DE_3_PID	0xF3C2
 
 /*
<span class="p_add">+ * Ivium Technologies product IDs</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FTDI_PALMSENS_PID	0xf440</span>
<span class="p_add">+#define FTDI_IVIUM_XSTAT_PID	0xf441</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Linx Technologies product ids
  */
 #define LINX_SDMUSBQSS_PID	0xF448	/* Linx SDM-USB-QS-S */
<span class="p_chunk">@@ -673,6 +679,12 @@</span> <span class="p_context"></span>
 #define INTREPID_NEOVI_PID	0x0701
 
 /*
<span class="p_add">+ * WICED USB UART</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define WICED_VID		0x0A5C</span>
<span class="p_add">+#define WICED_USB20706V2_PID	0x6422</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Definitions for ID TECH (www.idt-net.com) devices
  */
 #define IDTECH_VID		0x0ACD	/* ID TECH Vendor ID */
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index dfd728a263d2..c3b8ae360424 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -1239,7 +1239,7 @@</span> <span class="p_context"> static int mos7720_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 
 	if (urb-&gt;transfer_buffer == NULL) {
 		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,
<span class="p_del">-					       GFP_KERNEL);</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 		if (!urb-&gt;transfer_buffer)
 			goto exit;
 	}
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index 393be562d875..f5f3b49ff9d5 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -1372,8 +1372,8 @@</span> <span class="p_context"> static int mos7840_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 	}
 
 	if (urb-&gt;transfer_buffer == NULL) {
<span class="p_del">-		urb-&gt;transfer_buffer =</span>
<span class="p_del">-		    kmalloc(URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);</span>
<span class="p_add">+		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 		if (!urb-&gt;transfer_buffer)
 			goto exit;
 	}
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 9d8fe3d2feca..f243c734eb05 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -276,6 +276,13 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE922_USBCFG5		0x1045
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
<span class="p_add">+#define TELIT_PRODUCT_LE910_USBCFG4		0x1206</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1207		0x1207</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1208		0x1208</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1211		0x1211</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1212		0x1212</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1213		0x1213</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1214		0x1214</span>
 
 /* ZTE PRODUCTS */
 #define ZTE_VENDOR_ID				0x19d2
<span class="p_chunk">@@ -520,6 +527,12 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define VIATELECOM_VENDOR_ID			0x15eb
 #define VIATELECOM_PRODUCT_CDS7			0x0001
 
<span class="p_add">+/* WeTelecom products */</span>
<span class="p_add">+#define WETELECOM_VENDOR_ID			0x22de</span>
<span class="p_add">+#define WETELECOM_PRODUCT_WMD200		0x6801</span>
<span class="p_add">+#define WETELECOM_PRODUCT_6802			0x6802</span>
<span class="p_add">+#define WETELECOM_PRODUCT_WMD300		0x6803</span>
<span class="p_add">+</span>
 /* some devices interfaces need special handling due to a number of reasons */
 enum option_blacklist_reason {
 		OPTION_BLACKLIST_NONE = 0,
<span class="p_chunk">@@ -642,6 +655,11 @@</span> <span class="p_context"> static const struct option_blacklist_info sierra_mc73xx_blacklist = {</span>
 	.reserved = BIT(8) | BIT(10) | BIT(11),
 };
 
<span class="p_add">+static const struct option_blacklist_info telit_le920a4_blacklist_1 = {</span>
<span class="p_add">+	.sendsetup = BIT(0),</span>
<span class="p_add">+	.reserved = BIT(1),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info telit_le922_blacklist_usbcfg0 = {
 	.sendsetup = BIT(2),
 	.reserved = BIT(0) | BIT(1) | BIT(3),
<span class="p_chunk">@@ -1217,8 +1235,20 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg0 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910_USBCFG4),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
 		.driver_info = (kernel_ulong_t)&amp;telit_le920_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1207) },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1208),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le920a4_blacklist_1 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1211),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1212),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le920a4_blacklist_1 },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1213, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1214),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff),
 		.driver_info = (kernel_ulong_t)&amp;net_intf1_blacklist },
<span class="p_chunk">@@ -1974,9 +2004,13 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x7e11, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/A3 */</span>
 	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD200, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_6802, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD300, 0xff, 0xff, 0xff) },</span>
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial-simple.c b/drivers/usb/serial/usb-serial-simple.c</span>
<span class="p_header">index 5c19d3e7b4b8..790452c7a9e4 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial-simple.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial-simple.c</span>
<span class="p_chunk">@@ -48,7 +48,8 @@</span> <span class="p_context"> DEVICE(funsoft, FUNSOFT_IDS);</span>
 /* Infineon Flashloader driver */
 #define FLASHLOADER_IDS()		\
 	{ USB_DEVICE_INTERFACE_CLASS(0x058b, 0x0041, USB_CLASS_CDC_DATA) }, \
<span class="p_del">-	{ USB_DEVICE(0x8087, 0x0716) }</span>
<span class="p_add">+	{ USB_DEVICE(0x8087, 0x0716) }, \</span>
<span class="p_add">+	{ USB_DEVICE(0x8087, 0x0801) }</span>
 DEVICE(flashloader, FLASHLOADER_IDS);
 
 /* Google Serial USB SubClass */
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">index 6fbfc8fc2f5d..d3bf8348e638 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial.c</span>
<span class="p_chunk">@@ -1416,7 +1416,7 @@</span> <span class="p_context"> int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[]</span>
 
 	rc = usb_register(udriver);
 	if (rc)
<span class="p_del">-		return rc;</span>
<span class="p_add">+		goto failed_usb_register;</span>
 
 	for (sd = serial_drivers; *sd; ++sd) {
 		(*sd)-&gt;usb_driver = udriver;
<span class="p_chunk">@@ -1434,6 +1434,8 @@</span> <span class="p_context"> int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[]</span>
 	while (sd-- &gt; serial_drivers)
 		usb_serial_deregister(*sd);
 	usb_deregister(udriver);
<span class="p_add">+failed_usb_register:</span>
<span class="p_add">+	kfree(udriver);</span>
 	return rc;
 }
 EXPORT_SYMBOL_GPL(usb_serial_register_drivers);
<span class="p_header">diff --git a/drivers/vfio/pci/vfio_pci.c b/drivers/vfio/pci/vfio_pci.c</span>
<span class="p_header">index a1e77f570b19..431fb1e25830 100644</span>
<span class="p_header">--- a/drivers/vfio/pci/vfio_pci.c</span>
<span class="p_header">+++ b/drivers/vfio/pci/vfio_pci.c</span>
<span class="p_chunk">@@ -460,8 +460,9 @@</span> <span class="p_context"> static long vfio_pci_ioctl(void *device_data,</span>
 
 	} else if (cmd == VFIO_DEVICE_SET_IRQS) {
 		struct vfio_irq_set hdr;
<span class="p_add">+		size_t size;</span>
 		u8 *data = NULL;
<span class="p_del">-		int ret = 0;</span>
<span class="p_add">+		int max, ret = 0;</span>
 
 		minsz = offsetofend(struct vfio_irq_set, count);
 
<span class="p_chunk">@@ -469,23 +470,31 @@</span> <span class="p_context"> static long vfio_pci_ioctl(void *device_data,</span>
 			return -EFAULT;
 
 		if (hdr.argsz &lt; minsz || hdr.index &gt;= VFIO_PCI_NUM_IRQS ||
<span class="p_add">+		    hdr.count &gt;= (U32_MAX - hdr.start) ||</span>
 		    hdr.flags &amp; ~(VFIO_IRQ_SET_DATA_TYPE_MASK |
 				  VFIO_IRQ_SET_ACTION_TYPE_MASK))
 			return -EINVAL;
 
<span class="p_del">-		if (!(hdr.flags &amp; VFIO_IRQ_SET_DATA_NONE)) {</span>
<span class="p_del">-			size_t size;</span>
<span class="p_del">-			int max = vfio_pci_get_irq_count(vdev, hdr.index);</span>
<span class="p_add">+		max = vfio_pci_get_irq_count(vdev, hdr.index);</span>
<span class="p_add">+		if (hdr.start &gt;= max || hdr.start + hdr.count &gt; max)</span>
<span class="p_add">+			return -EINVAL;</span>
 
<span class="p_del">-			if (hdr.flags &amp; VFIO_IRQ_SET_DATA_BOOL)</span>
<span class="p_del">-				size = sizeof(uint8_t);</span>
<span class="p_del">-			else if (hdr.flags &amp; VFIO_IRQ_SET_DATA_EVENTFD)</span>
<span class="p_del">-				size = sizeof(int32_t);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				return -EINVAL;</span>
<span class="p_add">+		switch (hdr.flags &amp; VFIO_IRQ_SET_DATA_TYPE_MASK) {</span>
<span class="p_add">+		case VFIO_IRQ_SET_DATA_NONE:</span>
<span class="p_add">+			size = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case VFIO_IRQ_SET_DATA_BOOL:</span>
<span class="p_add">+			size = sizeof(uint8_t);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case VFIO_IRQ_SET_DATA_EVENTFD:</span>
<span class="p_add">+			size = sizeof(int32_t);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-			if (hdr.argsz - minsz &lt; hdr.count * size ||</span>
<span class="p_del">-			    hdr.start &gt;= max || hdr.start + hdr.count &gt; max)</span>
<span class="p_add">+		if (size) {</span>
<span class="p_add">+			if (hdr.argsz - minsz &lt; hdr.count * size)</span>
 				return -EINVAL;
 
 			data = memdup_user((void __user *)(arg + minsz),
<span class="p_header">diff --git a/drivers/vfio/pci/vfio_pci_intrs.c b/drivers/vfio/pci/vfio_pci_intrs.c</span>
<span class="p_header">index 9dd49c9839ac..36cb198b7290 100644</span>
<span class="p_header">--- a/drivers/vfio/pci/vfio_pci_intrs.c</span>
<span class="p_header">+++ b/drivers/vfio/pci/vfio_pci_intrs.c</span>
<span class="p_chunk">@@ -465,7 +465,7 @@</span> <span class="p_context"> static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)</span>
 	if (!is_irq_none(vdev))
 		return -EINVAL;
 
<span class="p_del">-	vdev-&gt;ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);</span>
<span class="p_add">+	vdev-&gt;ctx = kcalloc(nvec, sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);</span>
 	if (!vdev-&gt;ctx)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -752,41 +752,58 @@</span> <span class="p_context"> static int vfio_pci_set_err_trigger(struct vfio_pci_device *vdev,</span>
 				    unsigned index, unsigned start,
 				    unsigned count, uint32_t flags, void *data)
 {
<span class="p_del">-	int32_t fd = *(int32_t *)data;</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((index != VFIO_PCI_ERR_IRQ_INDEX) ||</span>
<span class="p_del">-	    !(flags &amp; VFIO_IRQ_SET_DATA_TYPE_MASK))</span>
<span class="p_add">+	if (index != VFIO_PCI_ERR_IRQ_INDEX || start != 0 || count &gt; 1)</span>
 		return -EINVAL;
 
 	/* DATA_NONE/DATA_BOOL enables loopback testing */
 	if (flags &amp; VFIO_IRQ_SET_DATA_NONE) {
<span class="p_del">-		if (vdev-&gt;err_trigger)</span>
<span class="p_del">-			eventfd_signal(vdev-&gt;err_trigger, 1);</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+		if (vdev-&gt;err_trigger) {</span>
<span class="p_add">+			if (count) {</span>
<span class="p_add">+				eventfd_signal(vdev-&gt;err_trigger, 1);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				eventfd_ctx_put(vdev-&gt;err_trigger);</span>
<span class="p_add">+				vdev-&gt;err_trigger = NULL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	} else if (flags &amp; VFIO_IRQ_SET_DATA_BOOL) {
<span class="p_del">-		uint8_t trigger = *(uint8_t *)data;</span>
<span class="p_add">+		uint8_t trigger;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!count)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		trigger = *(uint8_t *)data;</span>
 		if (trigger &amp;&amp; vdev-&gt;err_trigger)
 			eventfd_signal(vdev-&gt;err_trigger, 1);
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	/* Handle SET_DATA_EVENTFD */</span>
<span class="p_del">-	if (fd == -1) {</span>
<span class="p_del">-		if (vdev-&gt;err_trigger)</span>
<span class="p_del">-			eventfd_ctx_put(vdev-&gt;err_trigger);</span>
<span class="p_del">-		vdev-&gt;err_trigger = NULL;</span>
 		return 0;
<span class="p_del">-	} else if (fd &gt;= 0) {</span>
<span class="p_del">-		struct eventfd_ctx *efdctx;</span>
<span class="p_del">-		efdctx = eventfd_ctx_fdget(fd);</span>
<span class="p_del">-		if (IS_ERR(efdctx))</span>
<span class="p_del">-			return PTR_ERR(efdctx);</span>
<span class="p_del">-		if (vdev-&gt;err_trigger)</span>
<span class="p_del">-			eventfd_ctx_put(vdev-&gt;err_trigger);</span>
<span class="p_del">-		vdev-&gt;err_trigger = efdctx;</span>
<span class="p_add">+	} else if (flags &amp; VFIO_IRQ_SET_DATA_EVENTFD) {</span>
<span class="p_add">+		int32_t fd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!count)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		fd = *(int32_t *)data;</span>
<span class="p_add">+		if (fd == -1) {</span>
<span class="p_add">+			if (vdev-&gt;err_trigger)</span>
<span class="p_add">+				eventfd_ctx_put(vdev-&gt;err_trigger);</span>
<span class="p_add">+			vdev-&gt;err_trigger = NULL;</span>
<span class="p_add">+		} else if (fd &gt;= 0) {</span>
<span class="p_add">+			struct eventfd_ctx *efdctx;</span>
<span class="p_add">+</span>
<span class="p_add">+			efdctx = eventfd_ctx_fdget(fd);</span>
<span class="p_add">+			if (IS_ERR(efdctx))</span>
<span class="p_add">+				return PTR_ERR(efdctx);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (vdev-&gt;err_trigger)</span>
<span class="p_add">+				eventfd_ctx_put(vdev-&gt;err_trigger);</span>
<span class="p_add">+</span>
<span class="p_add">+			vdev-&gt;err_trigger = efdctx;</span>
<span class="p_add">+		}</span>
 		return 0;
<span class="p_del">-	} else</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 int vfio_pci_set_irqs_ioctl(struct vfio_pci_device *vdev, uint32_t flags,
 			    unsigned index, unsigned start, unsigned count,
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 7490e92c03d5..447571d19ecb 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -177,6 +177,8 @@</span> <span class="p_context"> static void leak_balloon(struct virtio_balloon *vb, size_t num)</span>
 	num = min(num, ARRAY_SIZE(vb-&gt;pfns));
 
 	mutex_lock(&amp;vb-&gt;balloon_lock);
<span class="p_add">+	/* We can&#39;t release more pages than taken */</span>
<span class="p_add">+	num = min(num, (size_t)vb-&gt;num_pages);</span>
 	for (vb-&gt;num_pfns = 0; vb-&gt;num_pfns &lt; num;
 	     vb-&gt;num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {
 		page = balloon_page_dequeue(vb_dev_info);
<span class="p_header">diff --git a/drivers/xen/xenbus/xenbus_dev_frontend.c b/drivers/xen/xenbus/xenbus_dev_frontend.c</span>
<span class="p_header">index 85534ea63555..6bd06f9d737d 100644</span>
<span class="p_header">--- a/drivers/xen/xenbus/xenbus_dev_frontend.c</span>
<span class="p_header">+++ b/drivers/xen/xenbus/xenbus_dev_frontend.c</span>
<span class="p_chunk">@@ -316,11 +316,18 @@</span> <span class="p_context"> static int xenbus_write_transaction(unsigned msg_type,</span>
 			rc = -ENOMEM;
 			goto out;
 		}
<span class="p_add">+	} else if (msg_type == XS_TRANSACTION_END) {</span>
<span class="p_add">+		list_for_each_entry(trans, &amp;u-&gt;transactions, list)</span>
<span class="p_add">+			if (trans-&gt;handle.id == u-&gt;u.msg.tx_id)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		if (&amp;trans-&gt;list == &amp;u-&gt;transactions)</span>
<span class="p_add">+			return -ESRCH;</span>
 	}
 
 	reply = xenbus_dev_request_and_reply(&amp;u-&gt;u.msg);
 	if (IS_ERR(reply)) {
<span class="p_del">-		kfree(trans);</span>
<span class="p_add">+		if (msg_type == XS_TRANSACTION_START)</span>
<span class="p_add">+			kfree(trans);</span>
 		rc = PTR_ERR(reply);
 		goto out;
 	}
<span class="p_chunk">@@ -330,12 +337,7 @@</span> <span class="p_context"> static int xenbus_write_transaction(unsigned msg_type,</span>
 
 		list_add(&amp;trans-&gt;list, &amp;u-&gt;transactions);
 	} else if (msg_type == XS_TRANSACTION_END) {
<span class="p_del">-		list_for_each_entry(trans, &amp;u-&gt;transactions, list)</span>
<span class="p_del">-			if (trans-&gt;handle.id == u-&gt;u.msg.tx_id)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		BUG_ON(&amp;trans-&gt;list == &amp;u-&gt;transactions);</span>
 		list_del(&amp;trans-&gt;list);
<span class="p_del">-</span>
 		kfree(trans);
 	}
 
<span class="p_header">diff --git a/fs/9p/acl.c b/fs/9p/acl.c</span>
<span class="p_header">index 8482f2d11606..d3f5d487ae46 100644</span>
<span class="p_header">--- a/fs/9p/acl.c</span>
<span class="p_header">+++ b/fs/9p/acl.c</span>
<span class="p_chunk">@@ -320,32 +320,26 @@</span> <span class="p_context"> static int v9fs_xattr_set_acl(struct dentry *dentry, const char *name,</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			retval = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (retval &lt; 0)</span>
<span class="p_add">+			struct iattr iattr;</span>
<span class="p_add">+</span>
<span class="p_add">+			retval = posix_acl_update_mode(inode, &amp;iattr.ia_mode, &amp;acl);</span>
<span class="p_add">+			if (retval)</span>
 				goto err_out;
<span class="p_del">-			else {</span>
<span class="p_del">-				struct iattr iattr;</span>
<span class="p_del">-				if (retval == 0) {</span>
<span class="p_del">-					/*</span>
<span class="p_del">-					 * ACL can be represented</span>
<span class="p_del">-					 * by the mode bits. So don&#39;t</span>
<span class="p_del">-					 * update ACL.</span>
<span class="p_del">-					 */</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-					value = NULL;</span>
<span class="p_del">-					size = 0;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				/* Updte the mode bits */</span>
<span class="p_del">-				iattr.ia_mode = ((mode &amp; S_IALLUGO) |</span>
<span class="p_del">-						 (inode-&gt;i_mode &amp; ~S_IALLUGO));</span>
<span class="p_del">-				iattr.ia_valid = ATTR_MODE;</span>
<span class="p_del">-				/* FIXME should we update ctime ?</span>
<span class="p_del">-				 * What is the following setxattr update the</span>
<span class="p_del">-				 * mode ?</span>
<span class="p_add">+			if (!acl) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * ACL can be represented</span>
<span class="p_add">+				 * by the mode bits. So don&#39;t</span>
<span class="p_add">+				 * update ACL.</span>
 				 */
<span class="p_del">-				v9fs_vfs_setattr_dotl(dentry, &amp;iattr);</span>
<span class="p_add">+				value = NULL;</span>
<span class="p_add">+				size = 0;</span>
 			}
<span class="p_add">+			iattr.ia_valid = ATTR_MODE;</span>
<span class="p_add">+			/* FIXME should we update ctime ?</span>
<span class="p_add">+			 * What is the following setxattr update the</span>
<span class="p_add">+			 * mode ?</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			v9fs_vfs_setattr_dotl(dentry, &amp;iattr);</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index bdfcea010c9f..d0b7320b17c4 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -1094,7 +1094,7 @@</span> <span class="p_context"> static int v9fs_vfs_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct p9_wstat wstat;
 
 	p9_debug(P9_DEBUG_VFS, &quot;\n&quot;);
<span class="p_del">-	retval = inode_change_ok(dentry-&gt;d_inode, iattr);</span>
<span class="p_add">+	retval = setattr_prepare(dentry, iattr);</span>
 	if (retval)
 		return retval;
 
<span class="p_header">diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">index d3fb85871921..f03024e5bcbe 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_chunk">@@ -560,7 +560,7 @@</span> <span class="p_context"> int v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)</span>
 
 	p9_debug(P9_DEBUG_VFS, &quot;\n&quot;);
 
<span class="p_del">-	retval = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	retval = setattr_prepare(dentry, iattr);</span>
 	if (retval)
 		return retval;
 
<span class="p_header">diff --git a/fs/adfs/inode.c b/fs/adfs/inode.c</span>
<span class="p_header">index b9acadafa4a1..247b351f3005 100644</span>
<span class="p_header">--- a/fs/adfs/inode.c</span>
<span class="p_header">+++ b/fs/adfs/inode.c</span>
<span class="p_chunk">@@ -303,7 +303,7 @@</span> <span class="p_context"> adfs_notify_change(struct dentry *dentry, struct iattr *attr)</span>
 	unsigned int ia_valid = attr-&gt;ia_valid;
 	int error;
 	
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 
 	/*
 	 * we can&#39;t change the UID or GID of any file -
<span class="p_header">diff --git a/fs/affs/inode.c b/fs/affs/inode.c</span>
<span class="p_header">index bec2d1a0c91c..55a931da9917 100644</span>
<span class="p_header">--- a/fs/affs/inode.c</span>
<span class="p_header">+++ b/fs/affs/inode.c</span>
<span class="p_chunk">@@ -222,7 +222,7 @@</span> <span class="p_context"> affs_notify_change(struct dentry *dentry, struct iattr *attr)</span>
 
 	pr_debug(&quot;notify_change(%lu,0x%x)\n&quot;, inode-&gt;i_ino, attr-&gt;ia_valid);
 
<span class="p_del">-	error = inode_change_ok(inode,attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		goto out;
 
<span class="p_header">diff --git a/fs/attr.c b/fs/attr.c</span>
<span class="p_header">index 6530ced19697..ee697ddc6c2e 100644</span>
<span class="p_header">--- a/fs/attr.c</span>
<span class="p_header">+++ b/fs/attr.c</span>
<span class="p_chunk">@@ -17,19 +17,22 @@</span> <span class="p_context"></span>
 #include &lt;linux/ima.h&gt;
 
 /**
<span class="p_del">- * inode_change_ok - check if attribute changes to an inode are allowed</span>
<span class="p_del">- * @inode:	inode to check</span>
<span class="p_add">+ * setattr_prepare - check if attribute changes to a dentry are allowed</span>
<span class="p_add">+ * @dentry:	dentry to check</span>
  * @attr:	attributes to change
  *
  * Check if we are allowed to change the attributes contained in @attr
<span class="p_del">- * in the given inode.  This includes the normal unix access permission</span>
<span class="p_del">- * checks, as well as checks for rlimits and others.</span>
<span class="p_add">+ * in the given dentry.  This includes the normal unix access permission</span>
<span class="p_add">+ * checks, as well as checks for rlimits and others. The function also clears</span>
<span class="p_add">+ * SGID bit from mode if user is not allowed to set it. Also file capabilities</span>
<span class="p_add">+ * and IMA extended attributes are cleared if ATTR_KILL_PRIV is set.</span>
  *
  * Should be called as the first thing in -&gt;setattr implementations,
  * possibly after taking additional locks.
  */
<span class="p_del">-int inode_change_ok(const struct inode *inode, struct iattr *attr)</span>
<span class="p_add">+int setattr_prepare(struct dentry *dentry, struct iattr *attr)</span>
 {
<span class="p_add">+	struct inode *inode = d_inode(dentry);</span>
 	unsigned int ia_valid = attr-&gt;ia_valid;
 
 	/*
<span class="p_chunk">@@ -44,7 +47,7 @@</span> <span class="p_context"> int inode_change_ok(const struct inode *inode, struct iattr *attr)</span>
 
 	/* If force is set do it anyway. */
 	if (ia_valid &amp; ATTR_FORCE)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto kill_priv;</span>
 
 	/* Make sure a caller can chown. */
 	if ((ia_valid &amp; ATTR_UID) &amp;&amp;
<span class="p_chunk">@@ -77,9 +80,19 @@</span> <span class="p_context"> int inode_change_ok(const struct inode *inode, struct iattr *attr)</span>
 			return -EPERM;
 	}
 
<span class="p_add">+kill_priv:</span>
<span class="p_add">+	/* User has permission for the change */</span>
<span class="p_add">+	if (ia_valid &amp; ATTR_KILL_PRIV) {</span>
<span class="p_add">+		int error;</span>
<span class="p_add">+</span>
<span class="p_add">+		error = security_inode_killpriv(dentry);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
<span class="p_del">-EXPORT_SYMBOL(inode_change_ok);</span>
<span class="p_add">+EXPORT_SYMBOL(setattr_prepare);</span>
 
 /**
  * inode_newsize_ok - may this inode be truncated to a given size
<span class="p_chunk">@@ -217,13 +230,11 @@</span> <span class="p_context"> int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **de</span>
 	if (!(ia_valid &amp; ATTR_MTIME_SET))
 		attr-&gt;ia_mtime = now;
 	if (ia_valid &amp; ATTR_KILL_PRIV) {
<span class="p_del">-		attr-&gt;ia_valid &amp;= ~ATTR_KILL_PRIV;</span>
<span class="p_del">-		ia_valid &amp;= ~ATTR_KILL_PRIV;</span>
 		error = security_inode_need_killpriv(dentry);
<span class="p_del">-		if (error &gt; 0)</span>
<span class="p_del">-			error = security_inode_killpriv(dentry);</span>
<span class="p_del">-		if (error)</span>
<span class="p_add">+		if (error &lt; 0)</span>
 			return error;
<span class="p_add">+		if (error == 0)</span>
<span class="p_add">+			ia_valid = attr-&gt;ia_valid &amp;= ~ATTR_KILL_PRIV;</span>
 	}
 
 	/*
<span class="p_header">diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c</span>
<span class="p_header">index 9a0124a95851..fb3e64d37cb4 100644</span>
<span class="p_header">--- a/fs/btrfs/acl.c</span>
<span class="p_header">+++ b/fs/btrfs/acl.c</span>
<span class="p_chunk">@@ -83,11 +83,9 @@</span> <span class="p_context"> static int __btrfs_set_acl(struct btrfs_trans_handle *trans,</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
 				return ret;
<span class="p_del">-			if (ret == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		ret = 0;
 		break;
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index a09ec5e7f3e2..4292500ef241 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -4690,7 +4690,7 @@</span> <span class="p_context"> static int btrfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (btrfs_root_readonly(root))
 		return -EROFS;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index b69285f0593b..eb4348781a97 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -1649,6 +1649,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_transid(struct file *file,</span>
 	int namelen;
 	int ret = 0;
 
<span class="p_add">+	if (!S_ISDIR(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	ret = mnt_want_write_file(file);
 	if (ret)
 		goto out;
<span class="p_chunk">@@ -1706,6 +1709,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create(struct file *file,</span>
 	struct btrfs_ioctl_vol_args *vol_args;
 	int ret;
 
<span class="p_add">+	if (!S_ISDIR(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_chunk">@@ -1729,6 +1735,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_v2(struct file *file,</span>
 	bool readonly = false;
 	struct btrfs_qgroup_inherit *inherit = NULL;
 
<span class="p_add">+	if (!S_ISDIR(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_chunk">@@ -2355,6 +2364,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_destroy(struct file *file,</span>
 	int ret;
 	int err = 0;
 
<span class="p_add">+	if (!S_ISDIR(dir-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_header">diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c</span>
<span class="p_header">index 2c3fcb38068f..830952d045c9 100644</span>
<span class="p_header">--- a/fs/btrfs/tree-log.c</span>
<span class="p_header">+++ b/fs/btrfs/tree-log.c</span>
<span class="p_chunk">@@ -2600,6 +2600,8 @@</span> <span class="p_context"> int btrfs_sync_log(struct btrfs_trans_handle *trans,</span>
 	}
 
 	if (log_root_tree-&gt;log_transid_committed &gt;= root_log_ctx.log_transid) {
<span class="p_add">+		blk_finish_plug(&amp;plug);</span>
<span class="p_add">+		list_del_init(&amp;root_log_ctx.list);</span>
 		mutex_unlock(&amp;log_root_tree-&gt;log_mutex);
 		ret = root_log_ctx.log_ret;
 		goto out;
<span class="p_header">diff --git a/fs/ceph/acl.c b/fs/ceph/acl.c</span>
<span class="p_header">index 469f2e8657e8..a02b900c1ed6 100644</span>
<span class="p_header">--- a/fs/ceph/acl.c</span>
<span class="p_header">+++ b/fs/ceph/acl.c</span>
<span class="p_chunk">@@ -108,11 +108,9 @@</span> <span class="p_context"> int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;new_mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;new_mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
 				goto out;
<span class="p_del">-			if (ret == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/ceph/file.c b/fs/ceph/file.c</span>
<span class="p_header">index 302085100c28..293d1cdf3645 100644</span>
<span class="p_header">--- a/fs/ceph/file.c</span>
<span class="p_header">+++ b/fs/ceph/file.c</span>
<span class="p_chunk">@@ -985,16 +985,14 @@</span> <span class="p_context"> out_unlocked:</span>
 static loff_t ceph_llseek(struct file *file, loff_t offset, int whence)
 {
 	struct inode *inode = file-&gt;f_mapping-&gt;host;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	loff_t ret;</span>
 
 	mutex_lock(&amp;inode-&gt;i_mutex);
 
 	if (whence == SEEK_END || whence == SEEK_DATA || whence == SEEK_HOLE) {
 		ret = ceph_do_getattr(inode, CEPH_STAT_CAP_SIZE);
<span class="p_del">-		if (ret &lt; 0) {</span>
<span class="p_del">-			offset = ret;</span>
<span class="p_add">+		if (ret &lt; 0)</span>
 			goto out;
<span class="p_del">-		}</span>
 	}
 
 	switch (whence) {
<span class="p_chunk">@@ -1009,7 +1007,7 @@</span> <span class="p_context"> static loff_t ceph_llseek(struct file *file, loff_t offset, int whence)</span>
 		 * write() or lseek() might have altered it
 		 */
 		if (offset == 0) {
<span class="p_del">-			offset = file-&gt;f_pos;</span>
<span class="p_add">+			ret = file-&gt;f_pos;</span>
 			goto out;
 		}
 		offset += file-&gt;f_pos;
<span class="p_chunk">@@ -1029,11 +1027,11 @@</span> <span class="p_context"> static loff_t ceph_llseek(struct file *file, loff_t offset, int whence)</span>
 		break;
 	}
 
<span class="p_del">-	offset = vfs_setpos(file, offset, inode-&gt;i_sb-&gt;s_maxbytes);</span>
<span class="p_add">+	ret = vfs_setpos(file, offset, inode-&gt;i_sb-&gt;s_maxbytes);</span>
 
 out:
 	mutex_unlock(&amp;inode-&gt;i_mutex);
<span class="p_del">-	return offset;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static inline void ceph_zero_partial_page(
<span class="p_header">diff --git a/fs/ceph/inode.c b/fs/ceph/inode.c</span>
<span class="p_header">index c3e103ff18bd..122d60506ab9 100644</span>
<span class="p_header">--- a/fs/ceph/inode.c</span>
<span class="p_header">+++ b/fs/ceph/inode.c</span>
<span class="p_chunk">@@ -1708,7 +1708,7 @@</span> <span class="p_context"> int ceph_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (ceph_snap(inode) != CEPH_NOSNAP)
 		return -EROFS;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err != 0)
 		return err;
 
<span class="p_header">diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c</span>
<span class="p_header">index 0bd335a393f8..f1aa100758df 100644</span>
<span class="p_header">--- a/fs/cifs/cifsencrypt.c</span>
<span class="p_header">+++ b/fs/cifs/cifsencrypt.c</span>
<span class="p_chunk">@@ -727,24 +727,26 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 
 	memcpy(ses-&gt;auth_key.response + baselen, tiblob, tilen);
 
<span class="p_add">+	mutex_lock(&amp;ses-&gt;server-&gt;srv_mutex);</span>
<span class="p_add">+</span>
 	rc = crypto_hmacmd5_alloc(ses-&gt;server);
 	if (rc) {
 		cifs_dbg(VFS, &quot;could not crypto alloc hmacmd5 rc %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* calculate ntlmv2_hash */
 	rc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);
 	if (rc) {
 		cifs_dbg(VFS, &quot;could not get v2 hash rc %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* calculate first part of the client response (CR1) */
 	rc = CalcNTLMv2_response(ses, ntlmv2_hash);
 	if (rc) {
 		cifs_dbg(VFS, &quot;Could not calculate CR1 rc: %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* now calculate the session key for NTLMv2 */
<span class="p_chunk">@@ -753,13 +755,13 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not set NTLMV2 Hash as a key\n&quot;,
 			 __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_init(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash);
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not init hmacmd5\n&quot;, __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_update(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash,
<span class="p_chunk">@@ -767,7 +769,7 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 		CIFS_HMAC_MD5_HASH_SIZE);
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not update with response\n&quot;, __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_final(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash,
<span class="p_chunk">@@ -775,6 +777,8 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	if (rc)
 		cifs_dbg(VFS, &quot;%s: Could not generate md5 hash\n&quot;, __func__);
 
<span class="p_add">+unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;ses-&gt;server-&gt;srv_mutex);</span>
 setup_ntlmv2_rsp_ret:
 	kfree(tiblob);
 
<span class="p_header">diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c</span>
<span class="p_header">index 3db0c5fd9a11..3f2dd87b899a 100644</span>
<span class="p_header">--- a/fs/cifs/dir.c</span>
<span class="p_header">+++ b/fs/cifs/dir.c</span>
<span class="p_chunk">@@ -229,6 +229,13 @@</span> <span class="p_context"> cifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,</span>
 				goto cifs_create_get_file_info;
 			}
 
<span class="p_add">+			if (S_ISDIR(newinode-&gt;i_mode)) {</span>
<span class="p_add">+				CIFSSMBClose(xid, tcon, fid-&gt;netfid);</span>
<span class="p_add">+				iput(newinode);</span>
<span class="p_add">+				rc = -EISDIR;</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (!S_ISREG(newinode-&gt;i_mode)) {
 				/*
 				 * The server may allow us to open things like
<span class="p_chunk">@@ -399,10 +406,14 @@</span> <span class="p_context"> cifs_create_set_dentry:</span>
 	if (rc != 0) {
 		cifs_dbg(FYI, &quot;Create worked, get_inode_info failed rc = %d\n&quot;,
 			 rc);
<span class="p_del">-		if (server-&gt;ops-&gt;close)</span>
<span class="p_del">-			server-&gt;ops-&gt;close(xid, tcon, fid);</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_err;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (S_ISDIR(newinode-&gt;i_mode)) {</span>
<span class="p_add">+		rc = -EISDIR;</span>
<span class="p_add">+		goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	d_drop(direntry);
 	d_add(direntry, newinode);
 
<span class="p_chunk">@@ -410,6 +421,13 @@</span> <span class="p_context"> out:</span>
 	kfree(buf);
 	kfree(full_path);
 	return rc;
<span class="p_add">+</span>
<span class="p_add">+out_err:</span>
<span class="p_add">+	if (server-&gt;ops-&gt;close)</span>
<span class="p_add">+		server-&gt;ops-&gt;close(xid, tcon, fid);</span>
<span class="p_add">+	if (newinode)</span>
<span class="p_add">+		iput(newinode);</span>
<span class="p_add">+	goto out;</span>
 }
 
 int
<span class="p_header">diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c</span>
<span class="p_header">index 8dc1cfcb534f..6a5ca969c301 100644</span>
<span class="p_header">--- a/fs/cifs/inode.c</span>
<span class="p_header">+++ b/fs/cifs/inode.c</span>
<span class="p_chunk">@@ -2074,7 +2074,7 @@</span> <span class="p_context"> cifs_setattr_unix(struct dentry *direntry, struct iattr *attrs)</span>
 	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_NO_PERM)
 		attrs-&gt;ia_valid |= ATTR_FORCE;
 
<span class="p_del">-	rc = inode_change_ok(inode, attrs);</span>
<span class="p_add">+	rc = setattr_prepare(direntry, attrs);</span>
 	if (rc &lt; 0)
 		goto out;
 
<span class="p_chunk">@@ -2215,7 +2215,7 @@</span> <span class="p_context"> cifs_setattr_nounix(struct dentry *direntry, struct iattr *attrs)</span>
 	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_NO_PERM)
 		attrs-&gt;ia_valid |= ATTR_FORCE;
 
<span class="p_del">-	rc = inode_change_ok(inode, attrs);</span>
<span class="p_add">+	rc = setattr_prepare(direntry, attrs);</span>
 	if (rc &lt; 0) {
 		free_xid(xid);
 		return rc;
<span class="p_header">diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c</span>
<span class="p_header">index b241a2a7683b..1059ba829774 100644</span>
<span class="p_header">--- a/fs/cifs/smb2ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb2ops.c</span>
<span class="p_chunk">@@ -858,6 +858,9 @@</span> <span class="p_context"> smb2_new_lease_key(struct cifs_fid *fid)</span>
 	get_random_bytes(fid-&gt;lease_key, SMB2_LEASE_KEY_SIZE);
 }
 
<span class="p_add">+#define SMB2_SYMLINK_STRUCT_SIZE \</span>
<span class="p_add">+	(sizeof(struct smb2_err_rsp) - 1 + sizeof(struct smb2_symlink_err_rsp))</span>
<span class="p_add">+</span>
 static int
 smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,
 		   const char *full_path, char **target_path,
<span class="p_chunk">@@ -870,7 +873,10 @@</span> <span class="p_context"> smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,</span>
 	struct cifs_fid fid;
 	struct smb2_err_rsp *err_buf = NULL;
 	struct smb2_symlink_err_rsp *symlink;
<span class="p_del">-	unsigned int sub_len, sub_offset;</span>
<span class="p_add">+	unsigned int sub_len;</span>
<span class="p_add">+	unsigned int sub_offset;</span>
<span class="p_add">+	unsigned int print_len;</span>
<span class="p_add">+	unsigned int print_offset;</span>
 
 	cifs_dbg(FYI, &quot;%s: path: %s\n&quot;, __func__, full_path);
 
<span class="p_chunk">@@ -891,11 +897,33 @@</span> <span class="p_context"> smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		kfree(utf16_path);
 		return -ENOENT;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (le32_to_cpu(err_buf-&gt;ByteCount) &lt; sizeof(struct smb2_symlink_err_rsp) ||</span>
<span class="p_add">+	    get_rfc1002_length(err_buf) + 4 &lt; SMB2_SYMLINK_STRUCT_SIZE) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* open must fail on symlink - reset rc */
 	rc = 0;
 	symlink = (struct smb2_symlink_err_rsp *)err_buf-&gt;ErrorData;
 	sub_len = le16_to_cpu(symlink-&gt;SubstituteNameLength);
 	sub_offset = le16_to_cpu(symlink-&gt;SubstituteNameOffset);
<span class="p_add">+	print_len = le16_to_cpu(symlink-&gt;PrintNameLength);</span>
<span class="p_add">+	print_offset = le16_to_cpu(symlink-&gt;PrintNameOffset);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_rfc1002_length(err_buf) + 4 &lt;</span>
<span class="p_add">+			SMB2_SYMLINK_STRUCT_SIZE + sub_offset + sub_len) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_rfc1002_length(err_buf) + 4 &lt;</span>
<span class="p_add">+			SMB2_SYMLINK_STRUCT_SIZE + print_offset + print_len) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	*target_path = cifs_strndup_from_utf16(
 				(char *)symlink-&gt;PathBuffer + sub_offset,
 				sub_len, true, cifs_sb-&gt;local_nls);
<span class="p_header">diff --git a/fs/ecryptfs/inode.c b/fs/ecryptfs/inode.c</span>
<span class="p_header">index 57ee4c53b4f8..8bc9ec714467 100644</span>
<span class="p_header">--- a/fs/ecryptfs/inode.c</span>
<span class="p_header">+++ b/fs/ecryptfs/inode.c</span>
<span class="p_chunk">@@ -952,7 +952,7 @@</span> <span class="p_context"> static int ecryptfs_setattr(struct dentry *dentry, struct iattr *ia)</span>
 	}
 	mutex_unlock(&amp;crypt_stat-&gt;cs_mutex);
 
<span class="p_del">-	rc = inode_change_ok(inode, ia);</span>
<span class="p_add">+	rc = setattr_prepare(dentry, ia);</span>
 	if (rc)
 		goto out;
 	if (ia-&gt;ia_valid &amp; ATTR_SIZE) {
<span class="p_header">diff --git a/fs/exofs/inode.c b/fs/exofs/inode.c</span>
<span class="p_header">index 3f9cafd73931..799e7d4562fe 100644</span>
<span class="p_header">--- a/fs/exofs/inode.c</span>
<span class="p_header">+++ b/fs/exofs/inode.c</span>
<span class="p_chunk">@@ -1039,7 +1039,7 @@</span> <span class="p_context"> int exofs_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	if (unlikely(error))
 		return error;
 
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (unlikely(error))
 		return error;
 
<span class="p_header">diff --git a/fs/ext2/acl.c b/fs/ext2/acl.c</span>
<span class="p_header">index 27695e6f4e46..d6aeb84e90b6 100644</span>
<span class="p_header">--- a/fs/ext2/acl.c</span>
<span class="p_header">+++ b/fs/ext2/acl.c</span>
<span class="p_chunk">@@ -193,15 +193,11 @@</span> <span class="p_context"> ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
<span class="p_del">-				error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-				if (error &lt; 0)</span>
<span class="p_add">+				error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+				if (error)</span>
 					return error;
<span class="p_del">-				else {</span>
<span class="p_del">-					inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_del">-					mark_inode_dirty(inode);</span>
<span class="p_del">-					if (error == 0)</span>
<span class="p_del">-						acl = NULL;</span>
<span class="p_del">-				}</span>
<span class="p_add">+				inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_add">+				mark_inode_dirty(inode);</span>
 			}
 			break;
 
<span class="p_header">diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c</span>
<span class="p_header">index 36d35c36311d..b822e4a447d6 100644</span>
<span class="p_header">--- a/fs/ext2/inode.c</span>
<span class="p_header">+++ b/fs/ext2/inode.c</span>
<span class="p_chunk">@@ -1547,7 +1547,7 @@</span> <span class="p_context"> int ext2_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ext3/acl.c b/fs/ext3/acl.c</span>
<span class="p_header">index 8bbaf5bcf982..c4509495a104 100644</span>
<span class="p_header">--- a/fs/ext3/acl.c</span>
<span class="p_header">+++ b/fs/ext3/acl.c</span>
<span class="p_chunk">@@ -195,15 +195,11 @@</span> <span class="p_context"> __ext3_set_acl(handle_t *handle, struct inode *inode, int type,</span>
 		case ACL_TYPE_ACCESS:
 			name_index = EXT3_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
<span class="p_del">-				error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-				if (error &lt; 0)</span>
<span class="p_add">+				error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+				if (error)</span>
 					return error;
<span class="p_del">-				else {</span>
<span class="p_del">-					inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_del">-					ext3_mark_inode_dirty(handle, inode);</span>
<span class="p_del">-					if (error == 0)</span>
<span class="p_del">-						acl = NULL;</span>
<span class="p_del">-				}</span>
<span class="p_add">+				inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_add">+				ext3_mark_inode_dirty(handle, inode);</span>
 			}
 			break;
 
<span class="p_header">diff --git a/fs/ext3/inode.c b/fs/ext3/inode.c</span>
<span class="p_header">index 2c6ccc49ba27..215972e94e17 100644</span>
<span class="p_header">--- a/fs/ext3/inode.c</span>
<span class="p_header">+++ b/fs/ext3/inode.c</span>
<span class="p_chunk">@@ -3244,7 +3244,7 @@</span> <span class="p_context"> int ext3_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	int error, rc = 0;
 	const unsigned int ia_valid = attr-&gt;ia_valid;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ext4/acl.c b/fs/ext4/acl.c</span>
<span class="p_header">index d40c8dbbb0d6..87d9bbf6a53f 100644</span>
<span class="p_header">--- a/fs/ext4/acl.c</span>
<span class="p_header">+++ b/fs/ext4/acl.c</span>
<span class="p_chunk">@@ -201,15 +201,11 @@</span> <span class="p_context"> __ext4_set_acl(handle_t *handle, struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
<span class="p_del">-			else {</span>
<span class="p_del">-				inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_del">-				ext4_mark_inode_dirty(handle, inode);</span>
<span class="p_del">-				if (error == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_add">+			ext4_mark_inode_dirty(handle, inode);</span>
 		}
 		break;
 
<span class="p_header">diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c</span>
<span class="p_header">index 06b65be20d48..5fb1195f602f 100644</span>
<span class="p_header">--- a/fs/ext4/balloc.c</span>
<span class="p_header">+++ b/fs/ext4/balloc.c</span>
<span class="p_chunk">@@ -209,6 +209,9 @@</span> <span class="p_context"> static int ext4_init_block_bitmap(struct super_block *sb,</span>
 	memset(bh-&gt;b_data, 0, sb-&gt;s_blocksize);
 
 	bit_max = ext4_num_base_meta_clusters(sb, block_group);
<span class="p_add">+	if ((bit_max &gt;&gt; 3) &gt;= bh-&gt;b_size)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
 	for (bit = 0; bit &lt; bit_max; bit++)
 		ext4_set_bit(bit, bh-&gt;b_data);
 
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index e41ec5034bad..d24d6fc1df4f 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -359,9 +359,13 @@</span> <span class="p_context"> static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)</span>
 	ext4_fsblk_t block = ext4_ext_pblock(ext);
 	int len = ext4_ext_get_actual_len(ext);
 	ext4_lblk_t lblock = le32_to_cpu(ext-&gt;ee_block);
<span class="p_del">-	ext4_lblk_t last = lblock + len - 1;</span>
 
<span class="p_del">-	if (len == 0 || lblock &gt; last)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We allow neither:</span>
<span class="p_add">+	 *  - zero length</span>
<span class="p_add">+	 *  - overflow/wrap-around</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (lblock + len &lt;= lblock)</span>
 		return 0;
 	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, len);
 }
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index a2c4495d40e9..ae4271d5c6ca 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -207,9 +207,9 @@</span> <span class="p_context"> void ext4_evict_inode(struct inode *inode)</span>
 		 * Note that directories do not have this problem because they
 		 * don&#39;t use page cache.
 		 */
<span class="p_del">-		if (ext4_should_journal_data(inode) &amp;&amp;</span>
<span class="p_del">-		    (S_ISLNK(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &amp;&amp;</span>
<span class="p_del">-		    inode-&gt;i_ino != EXT4_JOURNAL_INO) {</span>
<span class="p_add">+		if (inode-&gt;i_ino != EXT4_JOURNAL_INO &amp;&amp;</span>
<span class="p_add">+		    ext4_should_journal_data(inode) &amp;&amp;</span>
<span class="p_add">+		    (S_ISLNK(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode))) {</span>
 			journal_t *journal = EXT4_SB(inode-&gt;i_sb)-&gt;s_journal;
 			tid_t commit_tid = EXT4_I(inode)-&gt;i_datasync_tid;
 
<span class="p_chunk">@@ -2610,13 +2610,36 @@</span> <span class="p_context"> retry:</span>
 				done = true;
 			}
 		}
<span class="p_del">-		ext4_journal_stop(handle);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Caution: If the handle is synchronous,</span>
<span class="p_add">+		 * ext4_journal_stop() can wait for transaction commit</span>
<span class="p_add">+		 * to finish which may depend on writeback of pages to</span>
<span class="p_add">+		 * complete or on page lock to be released.  In that</span>
<span class="p_add">+		 * case, we have to wait until after after we have</span>
<span class="p_add">+		 * submitted all the IO, released page locks we hold,</span>
<span class="p_add">+		 * and dropped io_end reference (for extent conversion</span>
<span class="p_add">+		 * to be able to complete) before stopping the handle.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!ext4_handle_valid(handle) || handle-&gt;h_sync == 0) {</span>
<span class="p_add">+			ext4_journal_stop(handle);</span>
<span class="p_add">+			handle = NULL;</span>
<span class="p_add">+		}</span>
 		/* Submit prepared bio */
 		ext4_io_submit(&amp;mpd.io_submit);
 		/* Unlock pages we didn&#39;t use */
 		mpage_release_unused_pages(&amp;mpd, give_up_on_write);
<span class="p_del">-		/* Drop our io_end reference we got from init */</span>
<span class="p_del">-		ext4_put_io_end(mpd.io_submit.io_end);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Drop our io_end reference we got from init. We have</span>
<span class="p_add">+		 * to be careful and use deferred io_end finishing if</span>
<span class="p_add">+		 * we are still holding the transaction as we can</span>
<span class="p_add">+		 * release the last reference to io_end which may end</span>
<span class="p_add">+		 * up doing unwritten extent conversion.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (handle) {</span>
<span class="p_add">+			ext4_put_io_end_defer(mpd.io_submit.io_end);</span>
<span class="p_add">+			ext4_journal_stop(handle);</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			ext4_put_io_end(mpd.io_submit.io_end);</span>
 
 		if (ret == -ENOSPC &amp;&amp; sbi-&gt;s_journal) {
 			/*
<span class="p_chunk">@@ -4649,7 +4672,7 @@</span> <span class="p_context"> int ext4_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	int orphan = 0;
 	const unsigned int ia_valid = attr-&gt;ia_valid;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index 47f7af78675a..62d0c5cbcad6 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -2911,7 +2911,7 @@</span> <span class="p_context"> ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,</span>
 		ext4_error(sb, &quot;Allocating blocks %llu-%llu which overlap &quot;
 			   &quot;fs metadata&quot;, block, block+len);
 		/* File system mounted not to panic on error
<span class="p_del">-		 * Fix the bitmap and repeat the block allocation</span>
<span class="p_add">+		 * Fix the bitmap and return EFSCORRUPTED</span>
 		 * We leak some of the blocks here.
 		 */
 		ext4_lock_group(sb, ac-&gt;ac_b_ex.fe_group);
<span class="p_chunk">@@ -2920,7 +2920,7 @@</span> <span class="p_context"> ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,</span>
 		ext4_unlock_group(sb, ac-&gt;ac_b_ex.fe_group);
 		err = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);
 		if (!err)
<span class="p_del">-			err = -EAGAIN;</span>
<span class="p_add">+			err = -EIO;</span>
 		goto out_err;
 	}
 
<span class="p_chunk">@@ -4489,18 +4489,7 @@</span> <span class="p_context"> repeat:</span>
 	}
 	if (likely(ac-&gt;ac_status == AC_STATUS_FOUND)) {
 		*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);
<span class="p_del">-		if (*errp == -EAGAIN) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * drop the reference that we took</span>
<span class="p_del">-			 * in ext4_mb_use_best_found</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			ext4_mb_release_context(ac);</span>
<span class="p_del">-			ac-&gt;ac_b_ex.fe_group = 0;</span>
<span class="p_del">-			ac-&gt;ac_b_ex.fe_start = 0;</span>
<span class="p_del">-			ac-&gt;ac_b_ex.fe_len = 0;</span>
<span class="p_del">-			ac-&gt;ac_status = AC_STATUS_CONTINUE;</span>
<span class="p_del">-			goto repeat;</span>
<span class="p_del">-		} else if (*errp) {</span>
<span class="p_add">+		if (*errp) {</span>
 			ext4_discard_allocated_blocks(ac);
 			goto errout;
 		} else {
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 83026f40d9cd..1c239bba4344 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -2077,6 +2077,7 @@</span> <span class="p_context"> void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,</span>
 
 /* Called at mount-time, super-block is locked */
 static int ext4_check_descriptors(struct super_block *sb,
<span class="p_add">+				  ext4_fsblk_t sb_block,</span>
 				  ext4_group_t *first_not_zeroed)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
<span class="p_chunk">@@ -2107,6 +2108,11 @@</span> <span class="p_context"> static int ext4_check_descriptors(struct super_block *sb,</span>
 			grp = i;
 
 		block_bitmap = ext4_block_bitmap(sb, gdp);
<span class="p_add">+		if (block_bitmap == sb_block) {</span>
<span class="p_add">+			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;</span>
<span class="p_add">+				 &quot;Block bitmap for group %u overlaps &quot;</span>
<span class="p_add">+				 &quot;superblock&quot;, i);</span>
<span class="p_add">+		}</span>
 		if (block_bitmap &lt; first_block || block_bitmap &gt; last_block) {
 			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;
 			       &quot;Block bitmap for group %u not in group &quot;
<span class="p_chunk">@@ -2114,6 +2120,11 @@</span> <span class="p_context"> static int ext4_check_descriptors(struct super_block *sb,</span>
 			return 0;
 		}
 		inode_bitmap = ext4_inode_bitmap(sb, gdp);
<span class="p_add">+		if (inode_bitmap == sb_block) {</span>
<span class="p_add">+			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;</span>
<span class="p_add">+				 &quot;Inode bitmap for group %u overlaps &quot;</span>
<span class="p_add">+				 &quot;superblock&quot;, i);</span>
<span class="p_add">+		}</span>
 		if (inode_bitmap &lt; first_block || inode_bitmap &gt; last_block) {
 			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;
 			       &quot;Inode bitmap for group %u not in group &quot;
<span class="p_chunk">@@ -2121,6 +2132,11 @@</span> <span class="p_context"> static int ext4_check_descriptors(struct super_block *sb,</span>
 			return 0;
 		}
 		inode_table = ext4_inode_table(sb, gdp);
<span class="p_add">+		if (inode_table == sb_block) {</span>
<span class="p_add">+			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;</span>
<span class="p_add">+				 &quot;Inode table for group %u overlaps &quot;</span>
<span class="p_add">+				 &quot;superblock&quot;, i);</span>
<span class="p_add">+		}</span>
 		if (inode_table &lt; first_block ||
 		    inode_table + sbi-&gt;s_itb_per_group - 1 &gt; last_block) {
 			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;
<span class="p_chunk">@@ -2228,6 +2244,16 @@</span> <span class="p_context"> static void ext4_orphan_cleanup(struct super_block *sb,</span>
 	while (es-&gt;s_last_orphan) {
 		struct inode *inode;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We may have encountered an error during cleanup; if</span>
<span class="p_add">+		 * so, skip the rest.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (EXT4_SB(sb)-&gt;s_mount_state &amp; EXT4_ERROR_FS) {</span>
<span class="p_add">+			jbd_debug(1, &quot;Skipping orphan recovery on fs with errors.\n&quot;);</span>
<span class="p_add">+			es-&gt;s_last_orphan = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		inode = ext4_orphan_get(sb, le32_to_cpu(es-&gt;s_last_orphan));
 		if (IS_ERR(inode)) {
 			es-&gt;s_last_orphan = 0;
<span class="p_chunk">@@ -3644,6 +3670,13 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 		goto failed_mount;
 	}
 
<span class="p_add">+	if (le16_to_cpu(sbi-&gt;s_es-&gt;s_reserved_gdt_blocks) &gt; (blocksize / 4)) {</span>
<span class="p_add">+		ext4_msg(sb, KERN_ERR,</span>
<span class="p_add">+			 &quot;Number of reserved GDT blocks insanely large: %d&quot;,</span>
<span class="p_add">+			 le16_to_cpu(sbi-&gt;s_es-&gt;s_reserved_gdt_blocks));</span>
<span class="p_add">+		goto failed_mount;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (sb-&gt;s_blocksize != blocksize) {
 		/* Validate the filesystem blocksize */
 		if (!sb_set_blocksize(sb, blocksize)) {
<span class="p_chunk">@@ -3885,7 +3918,7 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 			goto failed_mount2;
 		}
 	}
<span class="p_del">-	if (!ext4_check_descriptors(sb, &amp;first_not_zeroed)) {</span>
<span class="p_add">+	if (!ext4_check_descriptors(sb, logical_sb_block, &amp;first_not_zeroed)) {</span>
 		ext4_msg(sb, KERN_ERR, &quot;group descriptors corrupted!&quot;);
 		goto failed_mount2;
 	}
<span class="p_header">diff --git a/fs/f2fs/acl.c b/fs/f2fs/acl.c</span>
<span class="p_header">index dbe2141d10ad..ff4737033823 100644</span>
<span class="p_header">--- a/fs/f2fs/acl.c</span>
<span class="p_header">+++ b/fs/f2fs/acl.c</span>
<span class="p_chunk">@@ -213,12 +213,10 @@</span> <span class="p_context"> static int __f2fs_set_acl(struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
 			set_acl_inode(fi, inode-&gt;i_mode);
<span class="p_del">-			if (error == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 
<span class="p_header">diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="p_header">index 7d8b96275092..010c2af33858 100644</span>
<span class="p_header">--- a/fs/f2fs/file.c</span>
<span class="p_header">+++ b/fs/f2fs/file.c</span>
<span class="p_chunk">@@ -500,7 +500,7 @@</span> <span class="p_context"> int f2fs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct f2fs_inode_info *fi = F2FS_I(inode);
 	int err;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/fat/file.c b/fs/fat/file.c</span>
<span class="p_header">index 85f79a89e747..17982aac0ef3 100644</span>
<span class="p_header">--- a/fs/fat/file.c</span>
<span class="p_header">+++ b/fs/fat/file.c</span>
<span class="p_chunk">@@ -394,7 +394,7 @@</span> <span class="p_context"> int fat_setattr(struct dentry *dentry, struct iattr *attr)</span>
 			attr-&gt;ia_valid &amp;= ~TIMES_SET_FLAGS;
 	}
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	attr-&gt;ia_valid = ia_valid;
 	if (error) {
 		if (sbi-&gt;options.quiet)
<span class="p_header">diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c</span>
<span class="p_header">index 0c6048247a34..31ad5fc879b8 100644</span>
<span class="p_header">--- a/fs/fuse/dir.c</span>
<span class="p_header">+++ b/fs/fuse/dir.c</span>
<span class="p_chunk">@@ -1704,9 +1704,10 @@</span> <span class="p_context"> int fuse_flush_times(struct inode *inode, struct fuse_file *ff)</span>
  * vmtruncate() doesn&#39;t allow for this case, so do the rlimit checking
  * and the actual truncation by hand.
  */
<span class="p_del">-int fuse_do_setattr(struct inode *inode, struct iattr *attr,</span>
<span class="p_add">+int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,</span>
 		    struct file *file)
 {
<span class="p_add">+	struct inode *inode = dentry-&gt;d_inode;</span>
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_inode *fi = get_fuse_inode(inode);
 	struct fuse_req *req;
<span class="p_chunk">@@ -1721,7 +1722,7 @@</span> <span class="p_context"> int fuse_do_setattr(struct inode *inode, struct iattr *attr,</span>
 	if (!(fc-&gt;flags &amp; FUSE_DEFAULT_PERMISSIONS))
 		attr-&gt;ia_valid |= ATTR_FORCE;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -1826,9 +1827,9 @@</span> <span class="p_context"> static int fuse_setattr(struct dentry *entry, struct iattr *attr)</span>
 		return -EACCES;
 
 	if (attr-&gt;ia_valid &amp; ATTR_FILE)
<span class="p_del">-		return fuse_do_setattr(inode, attr, attr-&gt;ia_file);</span>
<span class="p_add">+		return fuse_do_setattr(entry, attr, attr-&gt;ia_file);</span>
 	else
<span class="p_del">-		return fuse_do_setattr(inode, attr, NULL);</span>
<span class="p_add">+		return fuse_do_setattr(entry, attr, NULL);</span>
 }
 
 static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index a6442041ab64..5f747cf3a412 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -454,6 +454,15 @@</span> <span class="p_context"> static int fuse_flush(struct file *file, fl_owner_t id)</span>
 	fuse_sync_writes(inode);
 	mutex_unlock(&amp;inode-&gt;i_mutex);
 
<span class="p_add">+	if (test_bit(AS_ENOSPC, &amp;file-&gt;f_mapping-&gt;flags) &amp;&amp;</span>
<span class="p_add">+	    test_and_clear_bit(AS_ENOSPC, &amp;file-&gt;f_mapping-&gt;flags))</span>
<span class="p_add">+		err = -ENOSPC;</span>
<span class="p_add">+	if (test_bit(AS_EIO, &amp;file-&gt;f_mapping-&gt;flags) &amp;&amp;</span>
<span class="p_add">+	    test_and_clear_bit(AS_EIO, &amp;file-&gt;f_mapping-&gt;flags))</span>
<span class="p_add">+		err = -EIO;</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	req = fuse_get_req_nofail_nopages(fc, file);
 	memset(&amp;inarg, 0, sizeof(inarg));
 	inarg.fh = ff-&gt;fh;
<span class="p_chunk">@@ -499,6 +508,21 @@</span> <span class="p_context"> int fuse_fsync_common(struct file *file, loff_t start, loff_t end,</span>
 		goto out;
 
 	fuse_sync_writes(inode);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Due to implementation of fuse writeback</span>
<span class="p_add">+	 * filemap_write_and_wait_range() does not catch errors.</span>
<span class="p_add">+	 * We have to do this directly after fuse_sync_writes()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (test_bit(AS_ENOSPC, &amp;file-&gt;f_mapping-&gt;flags) &amp;&amp;</span>
<span class="p_add">+	    test_and_clear_bit(AS_ENOSPC, &amp;file-&gt;f_mapping-&gt;flags))</span>
<span class="p_add">+		err = -ENOSPC;</span>
<span class="p_add">+	if (test_bit(AS_EIO, &amp;file-&gt;f_mapping-&gt;flags) &amp;&amp;</span>
<span class="p_add">+	    test_and_clear_bit(AS_EIO, &amp;file-&gt;f_mapping-&gt;flags))</span>
<span class="p_add">+		err = -EIO;</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	err = sync_inode_metadata(inode, 1);
 	if (err)
 		goto out;
<span class="p_header">diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h</span>
<span class="p_header">index e8e47a6ab518..300619ba8591 100644</span>
<span class="p_header">--- a/fs/fuse/fuse_i.h</span>
<span class="p_header">+++ b/fs/fuse/fuse_i.h</span>
<span class="p_chunk">@@ -894,7 +894,7 @@</span> <span class="p_context"> bool fuse_write_update_size(struct inode *inode, loff_t pos);</span>
 int fuse_flush_times(struct inode *inode, struct fuse_file *ff);
 int fuse_write_inode(struct inode *inode, struct writeback_control *wbc);
 
<span class="p_del">-int fuse_do_setattr(struct inode *inode, struct iattr *attr,</span>
<span class="p_add">+int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,</span>
 		    struct file *file);
 
 #endif /* _FS_FUSE_I_H */
<span class="p_header">diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c</span>
<span class="p_header">index 6abafb11f214..fdf7b33306be 100644</span>
<span class="p_header">--- a/fs/fuse/inode.c</span>
<span class="p_header">+++ b/fs/fuse/inode.c</span>
<span class="p_chunk">@@ -933,7 +933,7 @@</span> <span class="p_context"> static void fuse_send_init(struct fuse_conn *fc, struct fuse_req *req)</span>
 	arg-&gt;flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC |
 		FUSE_EXPORT_SUPPORT | FUSE_BIG_WRITES | FUSE_DONT_MASK |
 		FUSE_SPLICE_WRITE | FUSE_SPLICE_MOVE | FUSE_SPLICE_READ |
<span class="p_del">-		FUSE_FLOCK_LOCKS | FUSE_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |</span>
<span class="p_add">+		FUSE_FLOCK_LOCKS | FUSE_HAS_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |</span>
 		FUSE_DO_READDIRPLUS | FUSE_READDIRPLUS_AUTO | FUSE_ASYNC_DIO |
 		FUSE_WRITEBACK_CACHE | FUSE_NO_OPEN_SUPPORT;
 	req-&gt;in.h.opcode = FUSE_INIT;
<span class="p_header">diff --git a/fs/gfs2/acl.c b/fs/gfs2/acl.c</span>
<span class="p_header">index 7b3143064af1..88e66aa516c4 100644</span>
<span class="p_header">--- a/fs/gfs2/acl.c</span>
<span class="p_header">+++ b/fs/gfs2/acl.c</span>
<span class="p_chunk">@@ -79,17 +79,11 @@</span> <span class="p_context"> int gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode-&gt;i_mode;
 
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-		if (error &lt; 0)</span>
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
 			return error;
<span class="p_del">-</span>
<span class="p_del">-		if (error == 0)</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mode != inode-&gt;i_mode) {</span>
<span class="p_del">-			inode-&gt;i_mode = mode;</span>
<span class="p_add">+		if (mode != inode-&gt;i_mode)</span>
 			mark_inode_dirty(inode);
<span class="p_del">-		}</span>
 	}
 
 	if (acl) {
<span class="p_header">diff --git a/fs/gfs2/inode.c b/fs/gfs2/inode.c</span>
<span class="p_header">index ba4b2e5377db..b6657ddd1de5 100644</span>
<span class="p_header">--- a/fs/gfs2/inode.c</span>
<span class="p_header">+++ b/fs/gfs2/inode.c</span>
<span class="p_chunk">@@ -1774,7 +1774,7 @@</span> <span class="p_context"> static int gfs2_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		goto out;
 
<span class="p_header">diff --git a/fs/hfs/inode.c b/fs/hfs/inode.c</span>
<span class="p_header">index d0929bc81782..a4a3f8a674b9 100644</span>
<span class="p_header">--- a/fs/hfs/inode.c</span>
<span class="p_header">+++ b/fs/hfs/inode.c</span>
<span class="p_chunk">@@ -604,7 +604,7 @@</span> <span class="p_context"> int hfs_inode_setattr(struct dentry *dentry, struct iattr * attr)</span>
 	struct hfs_sb_info *hsb = HFS_SB(inode-&gt;i_sb);
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr); /* basic permission checks */</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr); /* basic permission checks */</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/hfsplus/inode.c b/fs/hfsplus/inode.c</span>
<span class="p_header">index 0cf786f2d046..9cd897cc2384 100644</span>
<span class="p_header">--- a/fs/hfsplus/inode.c</span>
<span class="p_header">+++ b/fs/hfsplus/inode.c</span>
<span class="p_chunk">@@ -247,7 +247,7 @@</span> <span class="p_context"> static int hfsplus_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/hfsplus/posix_acl.c b/fs/hfsplus/posix_acl.c</span>
<span class="p_header">index df0c9af68d05..71b3087b7e32 100644</span>
<span class="p_header">--- a/fs/hfsplus/posix_acl.c</span>
<span class="p_header">+++ b/fs/hfsplus/posix_acl.c</span>
<span class="p_chunk">@@ -68,8 +68,8 @@</span> <span class="p_context"> int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,</span>
 	case ACL_TYPE_ACCESS:
 		xattr_name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			err = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (err &lt; 0)</span>
<span class="p_add">+			err = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (err)</span>
 				return err;
 		}
 		err = 0;
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index 070e249f7d0f..50f0b4f0480e 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -792,7 +792,7 @@</span> <span class="p_context"> static int hostfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 
 	int fd = HOSTFS_I(inode)-&gt;fd;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -942,10 +942,11 @@</span> <span class="p_context"> static int hostfs_fill_sb_common(struct super_block *sb, void *d, int silent)</span>
 
 	if (S_ISLNK(root_inode-&gt;i_mode)) {
 		char *name = follow_link(host_root_path);
<span class="p_del">-		if (IS_ERR(name))</span>
<span class="p_add">+		if (IS_ERR(name)) {</span>
 			err = PTR_ERR(name);
<span class="p_del">-		else</span>
<span class="p_del">-			err = read_name(root_inode, name);</span>
<span class="p_add">+			goto out_put;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = read_name(root_inode, name);</span>
 		kfree(name);
 		if (err)
 			goto out_put;
<span class="p_header">diff --git a/fs/hpfs/inode.c b/fs/hpfs/inode.c</span>
<span class="p_header">index 7ce4b74234a1..5ada7b73b5d9 100644</span>
<span class="p_header">--- a/fs/hpfs/inode.c</span>
<span class="p_header">+++ b/fs/hpfs/inode.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> int hpfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if ((attr-&gt;ia_valid &amp; ATTR_SIZE) &amp;&amp; attr-&gt;ia_size &gt; inode-&gt;i_size)
 		goto out_unlock;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		goto out_unlock;
 
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index 1e2872b25343..e3ac491424fc 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -429,7 +429,7 @@</span> <span class="p_context"> static int hugetlbfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 
 	BUG_ON(!inode);
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/jffs2/acl.c b/fs/jffs2/acl.c</span>
<span class="p_header">index 009ec0b5993d..4f43deb09a5a 100644</span>
<span class="p_header">--- a/fs/jffs2/acl.c</span>
<span class="p_header">+++ b/fs/jffs2/acl.c</span>
<span class="p_chunk">@@ -236,9 +236,10 @@</span> <span class="p_context"> int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			rc = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (rc &lt; 0)</span>
<span class="p_add">+			umode_t mode;</span>
<span class="p_add">+</span>
<span class="p_add">+			rc = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (rc)</span>
 				return rc;
 			if (inode-&gt;i_mode != mode) {
 				struct iattr attr;
<span class="p_chunk">@@ -250,8 +251,6 @@</span> <span class="p_context"> int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 				if (rc &lt; 0)
 					return rc;
 			}
<span class="p_del">-			if (rc == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/jffs2/fs.c b/fs/jffs2/fs.c</span>
<span class="p_header">index 601afd1afddf..bb9460ea36e8 100644</span>
<span class="p_header">--- a/fs/jffs2/fs.c</span>
<span class="p_header">+++ b/fs/jffs2/fs.c</span>
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> int jffs2_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int rc;
 
<span class="p_del">-	rc = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	rc = setattr_prepare(dentry, iattr);</span>
 	if (rc)
 		return rc;
 
<span class="p_header">diff --git a/fs/jfs/acl.c b/fs/jfs/acl.c</span>
<span class="p_header">index 0c8ca830b113..9fad9f4fe883 100644</span>
<span class="p_header">--- a/fs/jfs/acl.c</span>
<span class="p_header">+++ b/fs/jfs/acl.c</span>
<span class="p_chunk">@@ -84,13 +84,11 @@</span> <span class="p_context"> static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		ea_name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			rc = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (rc &lt; 0)</span>
<span class="p_add">+			rc = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (rc)</span>
 				return rc;
 			inode-&gt;i_ctime = CURRENT_TIME;
 			mark_inode_dirty(inode);
<span class="p_del">-			if (rc == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/jfs/file.c b/fs/jfs/file.c</span>
<span class="p_header">index 33aa0cc1f8b8..b43cc9a6dba1 100644</span>
<span class="p_header">--- a/fs/jfs/file.c</span>
<span class="p_header">+++ b/fs/jfs/file.c</span>
<span class="p_chunk">@@ -103,7 +103,7 @@</span> <span class="p_context"> int jfs_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int rc;
 
<span class="p_del">-	rc = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	rc = setattr_prepare(dentry, iattr);</span>
 	if (rc)
 		return rc;
 
<span class="p_header">diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c</span>
<span class="p_header">index d895b4b7b661..b120e85aa7b9 100644</span>
<span class="p_header">--- a/fs/kernfs/file.c</span>
<span class="p_header">+++ b/fs/kernfs/file.c</span>
<span class="p_chunk">@@ -828,21 +828,35 @@</span> <span class="p_context"> repeat:</span>
 	mutex_lock(&amp;kernfs_mutex);
 
 	list_for_each_entry(info, &amp;kernfs_root(kn)-&gt;supers, node) {
<span class="p_add">+		struct kernfs_node *parent;</span>
 		struct inode *inode;
<span class="p_del">-		struct dentry *dentry;</span>
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We want fsnotify_modify() on @kn but as the</span>
<span class="p_add">+		 * modifications aren&#39;t originating from userland don&#39;t</span>
<span class="p_add">+		 * have the matching @file available.  Look up the inodes</span>
<span class="p_add">+		 * and generate the events manually.</span>
<span class="p_add">+		 */</span>
 		inode = ilookup(info-&gt;sb, kn-&gt;ino);
 		if (!inode)
 			continue;
 
<span class="p_del">-		dentry = d_find_any_alias(inode);</span>
<span class="p_del">-		if (dentry) {</span>
<span class="p_del">-			fsnotify_parent(NULL, dentry, FS_MODIFY);</span>
<span class="p_del">-			fsnotify(inode, FS_MODIFY, inode, FSNOTIFY_EVENT_INODE,</span>
<span class="p_del">-				 NULL, 0);</span>
<span class="p_del">-			dput(dentry);</span>
<span class="p_add">+		parent = kernfs_get_parent(kn);</span>
<span class="p_add">+		if (parent) {</span>
<span class="p_add">+			struct inode *p_inode;</span>
<span class="p_add">+</span>
<span class="p_add">+			p_inode = ilookup(info-&gt;sb, parent-&gt;ino);</span>
<span class="p_add">+			if (p_inode) {</span>
<span class="p_add">+				fsnotify(p_inode, FS_MODIFY | FS_EVENT_ON_CHILD,</span>
<span class="p_add">+					 inode, FSNOTIFY_EVENT_INODE, kn-&gt;name, 0);</span>
<span class="p_add">+				iput(p_inode);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			kernfs_put(parent);</span>
 		}
 
<span class="p_add">+		fsnotify(inode, FS_MODIFY, inode, FSNOTIFY_EVENT_INODE,</span>
<span class="p_add">+			 kn-&gt;name, 0);</span>
 		iput(inode);
 	}
 
<span class="p_header">diff --git a/fs/kernfs/inode.c b/fs/kernfs/inode.c</span>
<span class="p_header">index 5b8ab29494b7..8b6cb8cbf887 100644</span>
<span class="p_header">--- a/fs/kernfs/inode.c</span>
<span class="p_header">+++ b/fs/kernfs/inode.c</span>
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> int kernfs_iop_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 		return -EINVAL;
 
 	mutex_lock(&amp;kernfs_mutex);
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (error)
 		goto out;
 
<span class="p_header">diff --git a/fs/libfs.c b/fs/libfs.c</span>
<span class="p_header">index 5ba7e10d6b23..51994a562aca 100644</span>
<span class="p_header">--- a/fs/libfs.c</span>
<span class="p_header">+++ b/fs/libfs.c</span>
<span class="p_chunk">@@ -371,7 +371,7 @@</span> <span class="p_context"> int simple_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/logfs/file.c b/fs/logfs/file.c</span>
<span class="p_header">index 8538752df2f6..34f4d33b6ee9 100644</span>
<span class="p_header">--- a/fs/logfs/file.c</span>
<span class="p_header">+++ b/fs/logfs/file.c</span>
<span class="p_chunk">@@ -244,7 +244,7 @@</span> <span class="p_context"> static int logfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int err = 0;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/minix/file.c b/fs/minix/file.c</span>
<span class="p_header">index a967de085ac0..6b569161325e 100644</span>
<span class="p_header">--- a/fs/minix/file.c</span>
<span class="p_header">+++ b/fs/minix/file.c</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"> static int minix_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ncpfs/inode.c b/fs/ncpfs/inode.c</span>
<span class="p_header">index e31e589369a4..f8d3f461a01f 100644</span>
<span class="p_header">--- a/fs/ncpfs/inode.c</span>
<span class="p_header">+++ b/fs/ncpfs/inode.c</span>
<span class="p_chunk">@@ -885,7 +885,7 @@</span> <span class="p_context"> int ncp_notify_change(struct dentry *dentry, struct iattr *attr)</span>
 	/* ageing the dentry to force validation */
 	ncp_age_dentry(server, dentry);
 
<span class="p_del">-	result = inode_change_ok(inode, attr);</span>
<span class="p_add">+	result = setattr_prepare(dentry, attr);</span>
 	if (result &lt; 0)
 		goto out;
 
<span class="p_header">diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c</span>
<span class="p_header">index 8c849947d34f..c1f955e2d809 100644</span>
<span class="p_header">--- a/fs/nfs/callback.c</span>
<span class="p_header">+++ b/fs/nfs/callback.c</span>
<span class="p_chunk">@@ -301,6 +301,7 @@</span> <span class="p_context"> static int nfs_callback_up_net(int minorversion, struct svc_serv *serv, struct n</span>
 err_socks:
 	svc_rpcb_cleanup(serv, net);
 err_bind:
<span class="p_add">+	nn-&gt;cb_users[minorversion]--;</span>
 	dprintk(&quot;NFS: Couldn&#39;t create callback socket: err = %d; &quot;
 			&quot;net = %p\n&quot;, ret, net);
 	return ret;
<span class="p_header">diff --git a/fs/nfs/callback_xdr.c b/fs/nfs/callback_xdr.c</span>
<span class="p_header">index 02f8d09e119f..b06c6ba9765d 100644</span>
<span class="p_header">--- a/fs/nfs/callback_xdr.c</span>
<span class="p_header">+++ b/fs/nfs/callback_xdr.c</span>
<span class="p_chunk">@@ -915,7 +915,7 @@</span> <span class="p_context"> static __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *r</span>
 	if (hdr_arg.minorversion == 0) {
 		cps.clp = nfs4_find_client_ident(SVC_NET(rqstp), hdr_arg.cb_ident);
 		if (!cps.clp || !check_gss_callback_principal(cps.clp, rqstp))
<span class="p_del">-			return rpc_drop_reply;</span>
<span class="p_add">+			goto out_invalidcred;</span>
 	}
 
 	cps.minorversion = hdr_arg.minorversion;
<span class="p_chunk">@@ -943,6 +943,10 @@</span> <span class="p_context"> static __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *r</span>
 	nfs_put_client(cps.clp);
 	dprintk(&quot;%s: done, status = %u\n&quot;, __func__, ntohl(status));
 	return rpc_success;
<span class="p_add">+</span>
<span class="p_add">+out_invalidcred:</span>
<span class="p_add">+	pr_warn_ratelimited(&quot;NFS: NFSv4 callback contains invalid cred\n&quot;);</span>
<span class="p_add">+	return rpc_autherr_badcred;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 7dc0bf73e76a..1522ec81c26f 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -7063,13 +7063,22 @@</span> <span class="p_context"> static int _nfs4_proc_create_session(struct nfs_client *clp,</span>
 	status = rpc_call_sync(session-&gt;clp-&gt;cl_rpcclient, &amp;msg, RPC_TASK_TIMEOUT);
 	trace_nfs4_create_session(clp, status);
 
<span class="p_add">+	switch (status) {</span>
<span class="p_add">+	case -NFS4ERR_STALE_CLIENTID:</span>
<span class="p_add">+	case -NFS4ERR_DELAY:</span>
<span class="p_add">+	case -ETIMEDOUT:</span>
<span class="p_add">+	case -EACCES:</span>
<span class="p_add">+	case -EAGAIN:</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	clp-&gt;cl_seqid++;</span>
 	if (!status) {
 		/* Verify the session&#39;s negotiated channel_attrs values */
 		status = nfs4_verify_channel_attrs(&amp;args, session);
<span class="p_del">-		/* Increment the clientid slot sequence id */</span>
<span class="p_del">-		clp-&gt;cl_seqid++;</span>
 	}
 
<span class="p_add">+out:</span>
 	return status;
 }
 
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index ecb0f9fd5632..34f18294817a 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -1222,6 +1222,9 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 	dprintk(&quot;NFS:       nfs_updatepage(%pD2 %d@%lld)\n&quot;,
 		file, count, (long long)(page_file_offset(page) + offset));
 
<span class="p_add">+	if (!count)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (nfs_can_extend_write(file, page, inode)) {
 		count = max(count + offset, nfs_page_length(page));
 		offset = 0;
<span class="p_chunk">@@ -1232,7 +1235,7 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 		nfs_set_pageerror(page);
 	else
 		__set_page_dirty_nobuffers(page);
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	dprintk(&quot;NFS:       nfs_updatepage returns %d (isize %lld)\n&quot;,
 			status, (long long)i_size_read(inode));
 	return status;
<span class="p_header">diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c</span>
<span class="p_header">index 140c496f612c..521f717b4a99 100644</span>
<span class="p_header">--- a/fs/nfsd/vfs.c</span>
<span class="p_header">+++ b/fs/nfsd/vfs.c</span>
<span class="p_chunk">@@ -300,17 +300,19 @@</span> <span class="p_context"> commit_metadata(struct svc_fh *fhp)</span>
  * NFS semantics and what Linux expects.
  */
 static void
<span class="p_del">-nfsd_sanitize_attrs(struct inode *inode, struct iattr *iap)</span>
<span class="p_add">+nfsd_sanitize_attrs(struct dentry *dentry, struct iattr *iap)</span>
 {
<span class="p_add">+	struct inode *inode = dentry-&gt;d_inode;</span>
<span class="p_add">+</span>
 	/*
 	 * NFSv2 does not differentiate between &quot;set-[ac]time-to-now&quot;
 	 * which only requires access, and &quot;set-[ac]time-to-X&quot; which
 	 * requires ownership.
 	 * So if it looks like it might be &quot;set both to the same time which
<span class="p_del">-	 * is close to now&quot;, and if inode_change_ok fails, then we</span>
<span class="p_add">+	 * is close to now&quot;, and if setattr_prepare fails, then we</span>
 	 * convert to &quot;set to now&quot; instead of &quot;set to explicit time&quot;
 	 *
<span class="p_del">-	 * We only call inode_change_ok as the last test as technically</span>
<span class="p_add">+	 * We only call setattr_prepare as the last test as technically</span>
 	 * it is not an interface that we should be using.
 	 */
 #define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)
<span class="p_chunk">@@ -328,7 +330,7 @@</span> <span class="p_context"> nfsd_sanitize_attrs(struct inode *inode, struct iattr *iap)</span>
 		if (delta &lt; 0)
 			delta = -delta;
 		if (delta &lt; MAX_TOUCH_TIME_ERROR &amp;&amp;
<span class="p_del">-		    inode_change_ok(inode, iap) != 0) {</span>
<span class="p_add">+		    setattr_prepare(dentry, iap) != 0) {</span>
 			/*
 			 * Turn off ATTR_[AM]TIME_SET but leave ATTR_[AM]TIME.
 			 * This will cause notify_change to set these times
<span class="p_chunk">@@ -435,7 +437,7 @@</span> <span class="p_context"> nfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,</span>
 	if (!iap-&gt;ia_valid)
 		goto out;
 
<span class="p_del">-	nfsd_sanitize_attrs(inode, iap);</span>
<span class="p_add">+	nfsd_sanitize_attrs(dentry, iap);</span>
 
 	/*
 	 * The size case is special, it changes the file in addition to the
<span class="p_header">diff --git a/fs/nilfs2/inode.c b/fs/nilfs2/inode.c</span>
<span class="p_header">index 31b6b2953c59..80e61bad215d 100644</span>
<span class="p_header">--- a/fs/nilfs2/inode.c</span>
<span class="p_header">+++ b/fs/nilfs2/inode.c</span>
<span class="p_chunk">@@ -839,7 +839,7 @@</span> <span class="p_context"> int nilfs_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct super_block *sb = inode-&gt;i_sb;
 	int err;
 
<span class="p_del">-	err = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, iattr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/notify/fanotify/fanotify.c b/fs/notify/fanotify/fanotify.c</span>
<span class="p_header">index 7e948ffba461..0439f6cdb931 100644</span>
<span class="p_header">--- a/fs/notify/fanotify/fanotify.c</span>
<span class="p_header">+++ b/fs/notify/fanotify/fanotify.c</span>
<span class="p_chunk">@@ -67,18 +67,7 @@</span> <span class="p_context"> static int fanotify_get_response(struct fsnotify_group *group,</span>
 
 	pr_debug(&quot;%s: group=%p event=%p\n&quot;, __func__, group, event);
 
<span class="p_del">-	wait_event(group-&gt;fanotify_data.access_waitq, event-&gt;response ||</span>
<span class="p_del">-				atomic_read(&amp;group-&gt;fanotify_data.bypass_perm));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!event-&gt;response) {	/* bypass_perm set */</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Event was canceled because group is being destroyed. Remove</span>
<span class="p_del">-		 * it from group&#39;s event list because we are responsible for</span>
<span class="p_del">-		 * freeing the permission event.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		fsnotify_remove_event(group, &amp;event-&gt;fae.fse);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	wait_event(group-&gt;fanotify_data.access_waitq, event-&gt;response);</span>
 
 	/* userspace responded, convert to something usable */
 	switch (event-&gt;response) {
<span class="p_header">diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_header">index ec50a8385b13..394da4dc45e1 100644</span>
<span class="p_header">--- a/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_header">+++ b/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_chunk">@@ -358,16 +358,20 @@</span> <span class="p_context"> static int fanotify_release(struct inode *ignored, struct file *file)</span>
 
 #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 	struct fanotify_perm_event_info *event, *next;
<span class="p_add">+	struct fsnotify_event *fsn_event;</span>
 
 	/*
<span class="p_del">-	 * There may be still new events arriving in the notification queue</span>
<span class="p_del">-	 * but since userspace cannot use fanotify fd anymore, no event can</span>
<span class="p_del">-	 * enter or leave access_list by now.</span>
<span class="p_add">+	 * Stop new events from arriving in the notification queue. since</span>
<span class="p_add">+	 * userspace cannot use fanotify fd anymore, no event can enter or</span>
<span class="p_add">+	 * leave access_list by now either.</span>
 	 */
<span class="p_del">-	spin_lock(&amp;group-&gt;fanotify_data.access_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	atomic_inc(&amp;group-&gt;fanotify_data.bypass_perm);</span>
<span class="p_add">+	fsnotify_group_stop_queueing(group);</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Process all permission events on access_list and notification queue</span>
<span class="p_add">+	 * and simulate reply from userspace.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock(&amp;group-&gt;fanotify_data.access_lock);</span>
 	list_for_each_entry_safe(event, next, &amp;group-&gt;fanotify_data.access_list,
 				 fae.fse.list) {
 		pr_debug(&quot;%s: found group=%p event=%p\n&quot;, __func__, group,
<span class="p_chunk">@@ -379,12 +383,21 @@</span> <span class="p_context"> static int fanotify_release(struct inode *ignored, struct file *file)</span>
 	spin_unlock(&amp;group-&gt;fanotify_data.access_lock);
 
 	/*
<span class="p_del">-	 * Since bypass_perm is set, newly queued events will not wait for</span>
<span class="p_del">-	 * access response. Wake up the already sleeping ones now.</span>
<span class="p_del">-	 * synchronize_srcu() in fsnotify_destroy_group() will wait for all</span>
<span class="p_del">-	 * processes sleeping in fanotify_handle_event() waiting for access</span>
<span class="p_del">-	 * response and thus also for all permission events to be freed.</span>
<span class="p_add">+	 * Destroy all non-permission events. For permission events just</span>
<span class="p_add">+	 * dequeue them and set the response. They will be freed once the</span>
<span class="p_add">+	 * response is consumed and fanotify_get_response() returns.</span>
 	 */
<span class="p_add">+	mutex_lock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+	while (!fsnotify_notify_queue_is_empty(group)) {</span>
<span class="p_add">+		fsn_event = fsnotify_remove_notify_event(group);</span>
<span class="p_add">+		if (!(fsn_event-&gt;mask &amp; FAN_ALL_PERM_EVENTS))</span>
<span class="p_add">+			fsnotify_destroy_event(group, fsn_event);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			FANOTIFY_PE(fsn_event)-&gt;response = FAN_ALLOW;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Response for all permission events it set, wakeup waiters */</span>
 	wake_up(&amp;group-&gt;fanotify_data.access_waitq);
 #endif
 
<span class="p_chunk">@@ -742,7 +755,6 @@</span> <span class="p_context"> SYSCALL_DEFINE2(fanotify_init, unsigned int, flags, unsigned int, event_f_flags)</span>
 	spin_lock_init(&amp;group-&gt;fanotify_data.access_lock);
 	init_waitqueue_head(&amp;group-&gt;fanotify_data.access_waitq);
 	INIT_LIST_HEAD(&amp;group-&gt;fanotify_data.access_list);
<span class="p_del">-	atomic_set(&amp;group-&gt;fanotify_data.bypass_perm, 0);</span>
 #endif
 	switch (flags &amp; FAN_ALL_CLASS_BITS) {
 	case FAN_CLASS_NOTIF:
<span class="p_header">diff --git a/fs/notify/group.c b/fs/notify/group.c</span>
<span class="p_header">index ad1995980456..f3e3188f3568 100644</span>
<span class="p_header">--- a/fs/notify/group.c</span>
<span class="p_header">+++ b/fs/notify/group.c</span>
<span class="p_chunk">@@ -40,6 +40,17 @@</span> <span class="p_context"> void fsnotify_final_destroy_group(struct fsnotify_group *group)</span>
 }
 
 /*
<span class="p_add">+ * Stop queueing new events for this group. Once this function returns</span>
<span class="p_add">+ * fsnotify_add_event() will not add any new events to the group&#39;s queue.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void fsnotify_group_stop_queueing(struct fsnotify_group *group)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+	group-&gt;shutdown = true;</span>
<span class="p_add">+	mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Trying to get rid of a group. Remove all marks, flush all events and release
  * the group reference.
  * Note that another thread calling fsnotify_clear_marks_by_group() may still
<span class="p_chunk">@@ -47,6 +58,14 @@</span> <span class="p_context"> void fsnotify_final_destroy_group(struct fsnotify_group *group)</span>
  */
 void fsnotify_destroy_group(struct fsnotify_group *group)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Stop queueing new events. The code below is careful enough to not</span>
<span class="p_add">+	 * require this but fanotify needs to stop queuing events even before</span>
<span class="p_add">+	 * fsnotify_destroy_group() is called and this makes the other callers</span>
<span class="p_add">+	 * of fsnotify_destroy_group() to see the same behavior.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fsnotify_group_stop_queueing(group);</span>
<span class="p_add">+</span>
 	/* clear all inode marks for this group */
 	fsnotify_clear_marks_by_group(group);
 
<span class="p_header">diff --git a/fs/notify/notification.c b/fs/notify/notification.c</span>
<span class="p_header">index 25a07c70f1c9..1646ff5dca5c 100644</span>
<span class="p_header">--- a/fs/notify/notification.c</span>
<span class="p_header">+++ b/fs/notify/notification.c</span>
<span class="p_chunk">@@ -82,7 +82,8 @@</span> <span class="p_context"> void fsnotify_destroy_event(struct fsnotify_group *group,</span>
  * Add an event to the group notification queue.  The group can later pull this
  * event off the queue to deal with.  The function returns 0 if the event was
  * added to the queue, 1 if the event was merged with some other queued event,
<span class="p_del">- * 2 if the queue of events has overflown.</span>
<span class="p_add">+ * 2 if the event was not queued - either the queue of events has overflown</span>
<span class="p_add">+ * or the group is shutting down.</span>
  */
 int fsnotify_add_notify_event(struct fsnotify_group *group,
 			      struct fsnotify_event *event,
<span class="p_chunk">@@ -96,6 +97,11 @@</span> <span class="p_context"> int fsnotify_add_notify_event(struct fsnotify_group *group,</span>
 
 	mutex_lock(&amp;group-&gt;notification_mutex);
 
<span class="p_add">+	if (group-&gt;shutdown) {</span>
<span class="p_add">+		mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+		return 2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (group-&gt;q_len &gt;= group-&gt;max_events) {
 		ret = 2;
 		/* Queue overflow event only if it isn&#39;t already queued */
<span class="p_chunk">@@ -126,21 +132,6 @@</span> <span class="p_context"> queue:</span>
 }
 
 /*
<span class="p_del">- * Remove @event from group&#39;s notification queue. It is the responsibility of</span>
<span class="p_del">- * the caller to destroy the event.</span>
<span class="p_del">- */</span>
<span class="p_del">-void fsnotify_remove_event(struct fsnotify_group *group,</span>
<span class="p_del">-			   struct fsnotify_event *event)</span>
<span class="p_del">-{</span>
<span class="p_del">-	mutex_lock(&amp;group-&gt;notification_mutex);</span>
<span class="p_del">-	if (!list_empty(&amp;event-&gt;list)) {</span>
<span class="p_del">-		list_del_init(&amp;event-&gt;list);</span>
<span class="p_del">-		group-&gt;q_len--;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * Remove and return the first event from the notification list.  It is the
  * responsibility of the caller to destroy the obtained event
  */
<span class="p_header">diff --git a/fs/ntfs/inode.c b/fs/ntfs/inode.c</span>
<span class="p_header">index f47af5e6e230..a5589470373f 100644</span>
<span class="p_header">--- a/fs/ntfs/inode.c</span>
<span class="p_header">+++ b/fs/ntfs/inode.c</span>
<span class="p_chunk">@@ -2891,7 +2891,7 @@</span> <span class="p_context"> int ntfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	int err;
 	unsigned int ia_valid = attr-&gt;ia_valid;
 
<span class="p_del">-	err = inode_change_ok(vi, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		goto out;
 	/* We do not support NTFS ACLs yet. */
<span class="p_header">diff --git a/fs/ocfs2/acl.c b/fs/ocfs2/acl.c</span>
<span class="p_header">index 7f9e4484c6f6..293ab80f3fe2 100644</span>
<span class="p_header">--- a/fs/ocfs2/acl.c</span>
<span class="p_header">+++ b/fs/ocfs2/acl.c</span>
<span class="p_chunk">@@ -241,14 +241,11 @@</span> <span class="p_context"> int ocfs2_set_acl(handle_t *handle,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+			umode_t mode;</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
 				return ret;
 			else {
<span class="p_del">-				if (ret == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-</span>
 				ret = ocfs2_acl_set_mode(inode, di_bh,
 							 handle, mode);
 				if (ret)
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmconvert.c b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">index f90931335c6b..2e11658676eb 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_chunk">@@ -262,7 +262,6 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 				  struct dlm_lock *lock, int flags, int type)
 {
 	enum dlm_status status;
<span class="p_del">-	u8 old_owner = res-&gt;owner;</span>
 
 	mlog(0, &quot;type=%d, convert_type=%d, busy=%d\n&quot;, lock-&gt;ml.type,
 	     lock-&gt;ml.convert_type, res-&gt;state &amp; DLM_LOCK_RES_IN_PROGRESS);
<span class="p_chunk">@@ -329,7 +328,6 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 
 	spin_lock(&amp;res-&gt;spinlock);
 	res-&gt;state &amp;= ~DLM_LOCK_RES_IN_PROGRESS;
<span class="p_del">-	lock-&gt;convert_pending = 0;</span>
 	/* if it failed, move it back to granted queue.
 	 * if master returns DLM_NORMAL and then down before sending ast,
 	 * it may have already been moved to granted queue, reset to
<span class="p_chunk">@@ -338,12 +336,14 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 		if (status != DLM_NOTQUEUED)
 			dlm_error(status);
 		dlm_revert_pending_convert(res, lock);
<span class="p_del">-	} else if ((res-&gt;state &amp; DLM_LOCK_RES_RECOVERING) ||</span>
<span class="p_del">-			(old_owner != res-&gt;owner)) {</span>
<span class="p_del">-		mlog(0, &quot;res %.*s is in recovering or has been recovered.\n&quot;,</span>
<span class="p_del">-				res-&gt;lockname.len, res-&gt;lockname.name);</span>
<span class="p_add">+	} else if (!lock-&gt;convert_pending) {</span>
<span class="p_add">+		mlog(0, &quot;%s: res %.*s, owner died and lock has been moved back &quot;</span>
<span class="p_add">+				&quot;to granted list, retry convert.\n&quot;,</span>
<span class="p_add">+				dlm-&gt;name, res-&gt;lockname.len, res-&gt;lockname.name);</span>
 		status = DLM_RECOVERING;
 	}
<span class="p_add">+</span>
<span class="p_add">+	lock-&gt;convert_pending = 0;</span>
 bail:
 	spin_unlock(&amp;res-&gt;spinlock);
 
<span class="p_header">diff --git a/fs/ocfs2/dlmfs/dlmfs.c b/fs/ocfs2/dlmfs/dlmfs.c</span>
<span class="p_header">index 09b7d9dac71d..4d129dfcc1c7 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmfs/dlmfs.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmfs/dlmfs.c</span>
<span class="p_chunk">@@ -211,7 +211,7 @@</span> <span class="p_context"> static int dlmfs_file_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 
 	attr-&gt;ia_valid &amp;= ~ATTR_SIZE;
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c</span>
<span class="p_header">index fd106d136983..cd3b06f600a2 100644</span>
<span class="p_header">--- a/fs/ocfs2/file.c</span>
<span class="p_header">+++ b/fs/ocfs2/file.c</span>
<span class="p_chunk">@@ -1144,7 +1144,7 @@</span> <span class="p_context"> int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (!(attr-&gt;ia_valid &amp; OCFS2_VALID_ATTRS))
 		return 0;
 
<span class="p_del">-	status = inode_change_ok(inode, attr);</span>
<span class="p_add">+	status = setattr_prepare(dentry, attr);</span>
 	if (status)
 		return status;
 
<span class="p_chunk">@@ -1516,7 +1516,8 @@</span> <span class="p_context"> static int ocfs2_zero_partial_clusters(struct inode *inode,</span>
 				       u64 start, u64 len)
 {
 	int ret = 0;
<span class="p_del">-	u64 tmpend, end = start + len;</span>
<span class="p_add">+	u64 tmpend = 0;</span>
<span class="p_add">+	u64 end = start + len;</span>
 	struct ocfs2_super *osb = OCFS2_SB(inode-&gt;i_sb);
 	unsigned int csize = osb-&gt;s_clustersize;
 	handle_t *handle;
<span class="p_chunk">@@ -1548,18 +1549,31 @@</span> <span class="p_context"> static int ocfs2_zero_partial_clusters(struct inode *inode,</span>
 	}
 
 	/*
<span class="p_del">-	 * We want to get the byte offset of the end of the 1st cluster.</span>
<span class="p_add">+	 * If start is on a cluster boundary and end is somewhere in another</span>
<span class="p_add">+	 * cluster, we have not COWed the cluster starting at start, unless</span>
<span class="p_add">+	 * end is also within the same cluster. So, in this case, we skip this</span>
<span class="p_add">+	 * first call to ocfs2_zero_range_for_truncate() truncate and move on</span>
<span class="p_add">+	 * to the next one.</span>
 	 */
<span class="p_del">-	tmpend = (u64)osb-&gt;s_clustersize + (start &amp; ~(osb-&gt;s_clustersize - 1));</span>
<span class="p_del">-	if (tmpend &gt; end)</span>
<span class="p_del">-		tmpend = end;</span>
<span class="p_add">+	if ((start &amp; (csize - 1)) != 0) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We want to get the byte offset of the end of the 1st</span>
<span class="p_add">+		 * cluster.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tmpend = (u64)osb-&gt;s_clustersize +</span>
<span class="p_add">+			(start &amp; ~(osb-&gt;s_clustersize - 1));</span>
<span class="p_add">+		if (tmpend &gt; end)</span>
<span class="p_add">+			tmpend = end;</span>
 
<span class="p_del">-	trace_ocfs2_zero_partial_clusters_range1((unsigned long long)start,</span>
<span class="p_del">-						 (unsigned long long)tmpend);</span>
<span class="p_add">+		trace_ocfs2_zero_partial_clusters_range1(</span>
<span class="p_add">+			(unsigned long long)start,</span>
<span class="p_add">+			(unsigned long long)tmpend);</span>
 
<span class="p_del">-	ret = ocfs2_zero_range_for_truncate(inode, handle, start, tmpend);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		mlog_errno(ret);</span>
<span class="p_add">+		ret = ocfs2_zero_range_for_truncate(inode, handle, start,</span>
<span class="p_add">+						    tmpend);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			mlog_errno(ret);</span>
<span class="p_add">+	}</span>
 
 	if (tmpend &lt; end) {
 		/*
<span class="p_header">diff --git a/fs/omfs/file.c b/fs/omfs/file.c</span>
<span class="p_header">index 902e88527fce..b53f0602cc03 100644</span>
<span class="p_header">--- a/fs/omfs/file.c</span>
<span class="p_header">+++ b/fs/omfs/file.c</span>
<span class="p_chunk">@@ -351,7 +351,7 @@</span> <span class="p_context"> static int omfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/posix_acl.c b/fs/posix_acl.c</span>
<span class="p_header">index b1c249115aaa..a767c594f17a 100644</span>
<span class="p_header">--- a/fs/posix_acl.c</span>
<span class="p_header">+++ b/fs/posix_acl.c</span>
<span class="p_chunk">@@ -594,6 +594,37 @@</span> <span class="p_context"> no_acl:</span>
 }
 EXPORT_SYMBOL_GPL(posix_acl_create);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * posix_acl_update_mode  -  update mode in set_acl</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Update the file mode when setting an ACL: compute the new file permission</span>
<span class="p_add">+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new</span>
<span class="p_add">+ * file mode, set *acl to NULL to indicate that no ACL should be set.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * As with chmod, clear the setgit bit if the caller is not in the owning group</span>
<span class="p_add">+ * or capable of CAP_FSETID (see inode_change_ok).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called from set_acl inode operations.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,</span>
<span class="p_add">+			  struct posix_acl **acl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = posix_acl_equiv_mode(*acl, &amp;mode);</span>
<span class="p_add">+	if (error &lt; 0)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	if (error == 0)</span>
<span class="p_add">+		*acl = NULL;</span>
<span class="p_add">+	if (!in_group_p(inode-&gt;i_gid) &amp;&amp;</span>
<span class="p_add">+	    !capable_wrt_inode_uidgid(inode, CAP_FSETID))</span>
<span class="p_add">+		mode &amp;= ~S_ISGID;</span>
<span class="p_add">+	*mode_p = mode;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(posix_acl_update_mode);</span>
<span class="p_add">+</span>
 /*
  * Fix up the uids and gids in posix acl extended attributes in place.
  */
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index 0897f5cb4957..944c6be58199 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -536,7 +536,7 @@</span> <span class="p_context"> int proc_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (attr-&gt;ia_valid &amp; ATTR_MODE)
 		return -EPERM;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/proc/generic.c b/fs/proc/generic.c</span>
<span class="p_header">index c18d9b05cea9..d95c6868b5f5 100644</span>
<span class="p_header">--- a/fs/proc/generic.c</span>
<span class="p_header">+++ b/fs/proc/generic.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> static int proc_notify_change(struct dentry *dentry, struct iattr *iattr)</span>
 	struct proc_dir_entry *de = PDE(inode);
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c</span>
<span class="p_header">index b45db1ddb8e0..728c4657188f 100644</span>
<span class="p_header">--- a/fs/proc/proc_sysctl.c</span>
<span class="p_header">+++ b/fs/proc/proc_sysctl.c</span>
<span class="p_chunk">@@ -753,7 +753,7 @@</span> <span class="p_context"> static int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (attr-&gt;ia_valid &amp; (ATTR_MODE | ATTR_UID | ATTR_GID))
 		return -EPERM;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ramfs/file-nommu.c b/fs/ramfs/file-nommu.c</span>
<span class="p_header">index dda012ad4208..a6b6083176d3 100644</span>
<span class="p_header">--- a/fs/ramfs/file-nommu.c</span>
<span class="p_header">+++ b/fs/ramfs/file-nommu.c</span>
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> static int ramfs_nommu_setattr(struct dentry *dentry, struct iattr *ia)</span>
 	int ret = 0;
 
 	/* POSIX UID/GID verification for setting inode attributes */
<span class="p_del">-	ret = inode_change_ok(inode, ia);</span>
<span class="p_add">+	ret = setattr_prepare(dentry, ia);</span>
 	if (ret)
 		return ret;
 
<span class="p_header">diff --git a/fs/reiserfs/inode.c b/fs/reiserfs/inode.c</span>
<span class="p_header">index 63b2b0ec49e6..27b402e05aa2 100644</span>
<span class="p_header">--- a/fs/reiserfs/inode.c</span>
<span class="p_header">+++ b/fs/reiserfs/inode.c</span>
<span class="p_chunk">@@ -3312,7 +3312,7 @@</span> <span class="p_context"> int reiserfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	unsigned int ia_valid;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/reiserfs/xattr_acl.c b/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">index 44503e293790..7071c2230a92 100644</span>
<span class="p_header">--- a/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">+++ b/fs/reiserfs/xattr_acl.c</span>
<span class="p_chunk">@@ -246,13 +246,9 @@</span> <span class="p_context"> __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
<span class="p_del">-			else {</span>
<span class="p_del">-				if (error == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-			}</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/seq_file.c b/fs/seq_file.c</span>
<span class="p_header">index 3857b720cb1b..fbb1688bff87 100644</span>
<span class="p_header">--- a/fs/seq_file.c</span>
<span class="p_header">+++ b/fs/seq_file.c</span>
<span class="p_chunk">@@ -219,8 +219,10 @@</span> <span class="p_context"> ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)</span>
 		size -= n;
 		buf += n;
 		copied += n;
<span class="p_del">-		if (!m-&gt;count)</span>
<span class="p_add">+		if (!m-&gt;count) {</span>
<span class="p_add">+			m-&gt;from = 0;</span>
 			m-&gt;index++;
<span class="p_add">+		}</span>
 		if (!size)
 			goto Done;
 	}
<span class="p_header">diff --git a/fs/sysv/file.c b/fs/sysv/file.c</span>
<span class="p_header">index b00811c75b24..3bb4ccd69731 100644</span>
<span class="p_header">--- a/fs/sysv/file.c</span>
<span class="p_header">+++ b/fs/sysv/file.c</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> static int sysv_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ubifs/file.c b/fs/ubifs/file.c</span>
<span class="p_header">index d37140e5b722..68d7fe857ba9 100644</span>
<span class="p_header">--- a/fs/ubifs/file.c</span>
<span class="p_header">+++ b/fs/ubifs/file.c</span>
<span class="p_chunk">@@ -1262,7 +1262,7 @@</span> <span class="p_context"> int ubifs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 
 	dbg_gen(&quot;ino %lu, mode %#x, ia_valid %#x&quot;,
 		inode-&gt;i_ino, inode-&gt;i_mode, attr-&gt;ia_valid);
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/ubifs/tnc_commit.c b/fs/ubifs/tnc_commit.c</span>
<span class="p_header">index 3600994f8411..1512f3490848 100644</span>
<span class="p_header">--- a/fs/ubifs/tnc_commit.c</span>
<span class="p_header">+++ b/fs/ubifs/tnc_commit.c</span>
<span class="p_chunk">@@ -370,7 +370,7 @@</span> <span class="p_context"> static int layout_in_gaps(struct ubifs_info *c, int cnt)</span>
 
 	p = c-&gt;gap_lebs;
 	do {
<span class="p_del">-		ubifs_assert(p &lt; c-&gt;gap_lebs + sizeof(int) * c-&gt;lst.idx_lebs);</span>
<span class="p_add">+		ubifs_assert(p &lt; c-&gt;gap_lebs + c-&gt;lst.idx_lebs);</span>
 		written = layout_leb_in_gaps(c, p);
 		if (written &lt; 0) {
 			err = written;
<span class="p_header">diff --git a/fs/udf/file.c b/fs/udf/file.c</span>
<span class="p_header">index d80738fdf424..1aaf63a5f32f 100644</span>
<span class="p_header">--- a/fs/udf/file.c</span>
<span class="p_header">+++ b/fs/udf/file.c</span>
<span class="p_chunk">@@ -269,7 +269,7 @@</span> <span class="p_context"> static int udf_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ufs/truncate.c b/fs/ufs/truncate.c</span>
<span class="p_header">index f04f89fbd4d9..92cde998aead 100644</span>
<span class="p_header">--- a/fs/ufs/truncate.c</span>
<span class="p_header">+++ b/fs/ufs/truncate.c</span>
<span class="p_chunk">@@ -496,7 +496,7 @@</span> <span class="p_context"> int ufs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	unsigned int ia_valid = attr-&gt;ia_valid;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/utimes.c b/fs/utimes.c</span>
<span class="p_header">index aa138d64560a..61abc3051377 100644</span>
<span class="p_header">--- a/fs/utimes.c</span>
<span class="p_header">+++ b/fs/utimes.c</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> static int utimes_common(struct path *path, struct timespec *times)</span>
 			newattrs.ia_valid |= ATTR_MTIME_SET;
 		}
 		/*
<span class="p_del">-		 * Tell inode_change_ok(), that this is an explicit time</span>
<span class="p_add">+		 * Tell setattr_prepare(), that this is an explicit time</span>
 		 * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET
 		 * were used.
 		 */
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static int utimes_common(struct path *path, struct timespec *times)</span>
 		/*
 		 * If times is NULL (or both times are UTIME_NOW),
 		 * then we need to check permissions, because
<span class="p_del">-		 * inode_change_ok() won&#39;t do it.</span>
<span class="p_add">+		 * setattr_prepare() won&#39;t do it.</span>
 		 */
 		error = -EACCES;
                 if (IS_IMMUTABLE(inode))
<span class="p_header">diff --git a/fs/xfs/xfs_acl.c b/fs/xfs/xfs_acl.c</span>
<span class="p_header">index 6888ad886ff6..d1229033a22f 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_acl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_acl.c</span>
<span class="p_chunk">@@ -244,7 +244,8 @@</span> <span class="p_context"> xfs_set_mode(struct inode *inode, umode_t mode)</span>
 		iattr.ia_mode = mode;
 		iattr.ia_ctime = current_fs_time(inode-&gt;i_sb);
 
<span class="p_del">-		error = -xfs_setattr_nonsize(XFS_I(inode), &amp;iattr, XFS_ATTR_NOACL);</span>
<span class="p_add">+		error = -xfs_setattr_nonsize(NULL, XFS_I(inode), &amp;iattr,</span>
<span class="p_add">+					     XFS_ATTR_NOACL);</span>
 	}
 
 	return error;
<span class="p_chunk">@@ -286,16 +287,11 @@</span> <span class="p_context"> xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 		return error;
 
 	if (type == ACL_TYPE_ACCESS) {
<span class="p_del">-		umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (error &lt;= 0) {</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_del">-				return error;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		umode_t mode;</span>
 
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
 		error = xfs_set_mode(inode, mode);
 		if (error)
 			return error;
<span class="p_header">diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c</span>
<span class="p_header">index d2f4cb598b46..eb04981b03b4 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_file.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_file.c</span>
<span class="p_chunk">@@ -862,7 +862,7 @@</span> <span class="p_context"> xfs_file_fallocate(</span>
 
 		iattr.ia_valid = ATTR_SIZE;
 		iattr.ia_size = new_size;
<span class="p_del">-		error = xfs_setattr_size(ip, &amp;iattr);</span>
<span class="p_add">+		error = xfs_setattr_size(file-&gt;f_dentry, &amp;iattr);</span>
 	}
 
 out_unlock:
<span class="p_header">diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c</span>
<span class="p_header">index afc859f44d01..cee62a5afbee 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_ioctl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_ioctl.c</span>
<span class="p_chunk">@@ -717,7 +717,7 @@</span> <span class="p_context"> xfs_ioc_space(</span>
 		iattr.ia_valid = ATTR_SIZE;
 		iattr.ia_size = bf-&gt;l_start;
 
<span class="p_del">-		error = xfs_setattr_size(ip, &amp;iattr);</span>
<span class="p_add">+		error = xfs_setattr_size(filp-&gt;f_dentry, &amp;iattr);</span>
 		if (!error)
 			clrprealloc = true;
 		break;
<span class="p_header">diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c</span>
<span class="p_header">index 125da8969c72..cfc5c260ecbe 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_iops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_iops.c</span>
<span class="p_chunk">@@ -527,6 +527,7 @@</span> <span class="p_context"> xfs_setattr_time(</span>
 
 int
 xfs_setattr_nonsize(
<span class="p_add">+	struct dentry		*dentry,</span>
 	struct xfs_inode	*ip,
 	struct iattr		*iattr,
 	int			flags)
<span class="p_chunk">@@ -551,7 +552,7 @@</span> <span class="p_context"> xfs_setattr_nonsize(</span>
 		if (XFS_FORCED_SHUTDOWN(mp))
 			return XFS_ERROR(EIO);
 
<span class="p_del">-		error = -inode_change_ok(inode, iattr);</span>
<span class="p_add">+		error = -setattr_prepare(dentry, iattr);</span>
 		if (error)
 			return XFS_ERROR(error);
 	}
<span class="p_chunk">@@ -734,11 +735,12 @@</span> <span class="p_context"> out_dqrele:</span>
  */
 int
 xfs_setattr_size(
<span class="p_del">-	struct xfs_inode	*ip,</span>
<span class="p_add">+	struct dentry		*dentry,</span>
 	struct iattr		*iattr)
 {
<span class="p_add">+	struct inode		*inode = dentry-&gt;d_inode;</span>
<span class="p_add">+	struct xfs_inode	*ip = XFS_I(inode);</span>
 	struct xfs_mount	*mp = ip-&gt;i_mount;
<span class="p_del">-	struct inode		*inode = VFS_I(ip);</span>
 	xfs_off_t		oldsize, newsize;
 	struct xfs_trans	*tp;
 	int			error;
<span class="p_chunk">@@ -754,7 +756,7 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 	if (XFS_FORCED_SHUTDOWN(mp))
 		return XFS_ERROR(EIO);
 
<span class="p_del">-	error = -inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = -setattr_prepare(dentry, iattr);</span>
 	if (error)
 		return XFS_ERROR(error);
 
<span class="p_chunk">@@ -778,7 +780,7 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 		 * Use the regular setattr path to update the timestamps.
 		 */
 		iattr-&gt;ia_valid &amp;= ~ATTR_SIZE;
<span class="p_del">-		return xfs_setattr_nonsize(ip, iattr, 0);</span>
<span class="p_add">+		return xfs_setattr_nonsize(dentry, ip, iattr, 0);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -939,10 +941,10 @@</span> <span class="p_context"> xfs_vn_setattr(</span>
 
 	if (iattr-&gt;ia_valid &amp; ATTR_SIZE) {
 		xfs_ilock(ip, XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL);
<span class="p_del">-		error = xfs_setattr_size(ip, iattr);</span>
<span class="p_add">+		error = xfs_setattr_size(dentry, iattr);</span>
 		xfs_iunlock(ip, XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL);
 	} else {
<span class="p_del">-		error = xfs_setattr_nonsize(ip, iattr, 0);</span>
<span class="p_add">+		error = xfs_setattr_nonsize(dentry, ip, iattr, 0);</span>
 	}
 
 	return -error;
<span class="p_header">diff --git a/fs/xfs/xfs_iops.h b/fs/xfs/xfs_iops.h</span>
<span class="p_header">index 1c34e4335920..f66a37c0a88a 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_iops.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_iops.h</span>
<span class="p_chunk">@@ -32,8 +32,8 @@</span> <span class="p_context"> extern void xfs_setup_inode(struct xfs_inode *);</span>
  */
 #define XFS_ATTR_NOACL		0x01	/* Don&#39;t call posix_acl_chmod */
 
<span class="p_del">-extern int xfs_setattr_nonsize(struct xfs_inode *ip, struct iattr *vap,</span>
<span class="p_del">-			       int flags);</span>
<span class="p_del">-extern int xfs_setattr_size(struct xfs_inode *ip, struct iattr *vap);</span>
<span class="p_add">+extern int xfs_setattr_nonsize(struct dentry *dentry, struct xfs_inode *ip,</span>
<span class="p_add">+			       struct iattr *vap, int flags);</span>
<span class="p_add">+extern int xfs_setattr_size(struct dentry *dentry, struct iattr *vap);</span>
 
 #endif /* __XFS_IOPS_H__ */
<span class="p_header">diff --git a/include/asm-generic/uaccess.h b/include/asm-generic/uaccess.h</span>
<span class="p_header">index 72d8803832ff..ae88865a3d67 100644</span>
<span class="p_header">--- a/include/asm-generic/uaccess.h</span>
<span class="p_header">+++ b/include/asm-generic/uaccess.h</span>
<span class="p_chunk">@@ -228,14 +228,18 @@</span> <span class="p_context"> extern int __put_user_bad(void) __attribute__((noreturn));</span>
 	might_fault();						\
 	access_ok(VERIFY_READ, ptr, sizeof(*ptr)) ?		\
 		__get_user(x, ptr) :				\
<span class="p_del">-		-EFAULT;					\</span>
<span class="p_add">+		((x) = (__typeof__(*(ptr)))0,-EFAULT);		\</span>
 })
 
 #ifndef __get_user_fn
 static inline int __get_user_fn(size_t size, const void __user *ptr, void *x)
 {
<span class="p_del">-	size = __copy_from_user(x, ptr, size);</span>
<span class="p_del">-	return size ? -EFAULT : size;</span>
<span class="p_add">+	size_t n = __copy_from_user(x, ptr, size);</span>
<span class="p_add">+	if (unlikely(n)) {</span>
<span class="p_add">+		memset(x + (size - n), 0, n);</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
 }
 
 #define __get_user_fn(sz, u, k)	__get_user_fn(sz, u, k)
<span class="p_chunk">@@ -255,11 +259,13 @@</span> <span class="p_context"> extern int __get_user_bad(void) __attribute__((noreturn));</span>
 static inline long copy_from_user(void *to,
 		const void __user * from, unsigned long n)
 {
<span class="p_add">+	unsigned long res = n;</span>
 	might_fault();
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_del">-		return __copy_from_user(to, from, n);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return n;</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n)))</span>
<span class="p_add">+		res = __copy_from_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
 }
 
 static inline long copy_to_user(void __user *to,
<span class="p_header">diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h</span>
<span class="p_header">index e488e9459a93..f0069a94d9cc 100644</span>
<span class="p_header">--- a/include/linux/backing-dev.h</span>
<span class="p_header">+++ b/include/linux/backing-dev.h</span>
<span class="p_chunk">@@ -100,6 +100,7 @@</span> <span class="p_context"> struct backing_dev_info {</span>
 	struct list_head work_list;
 
 	struct device *dev;
<span class="p_add">+	struct device *owner;</span>
 
 	struct timer_list laptop_mode_wb_timer;
 
<span class="p_chunk">@@ -116,6 +117,7 @@</span> <span class="p_context"> __printf(3, 4)</span>
 int bdi_register(struct backing_dev_info *bdi, struct device *parent,
 		const char *fmt, ...);
 int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev);
<span class="p_add">+int bdi_register_owner(struct backing_dev_info *bdi, struct device *owner);</span>
 void bdi_unregister(struct backing_dev_info *bdi);
 int __must_check bdi_setup_and_register(struct backing_dev_info *, char *, unsigned int);
 void bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,
<span class="p_header">diff --git a/include/linux/bcma/bcma.h b/include/linux/bcma/bcma.h</span>
<span class="p_header">index 0b3bb16c705a..b19c7ed88cff 100644</span>
<span class="p_header">--- a/include/linux/bcma/bcma.h</span>
<span class="p_header">+++ b/include/linux/bcma/bcma.h</span>
<span class="p_chunk">@@ -153,6 +153,7 @@</span> <span class="p_context"> struct bcma_host_ops {</span>
 #define BCMA_CORE_DEFAULT		0xFFF
 
 #define BCMA_MAX_NR_CORES		16
<span class="p_add">+#define BCMA_CORE_SIZE			0x1000</span>
 
 /* Chip IDs of PCIe devices */
 #define BCMA_CHIP_ID_BCM4313	0x4313
<span class="p_header">diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h</span>
<span class="p_header">index 6992afc6ba7f..e90bdfc4d0b7 100644</span>
<span class="p_header">--- a/include/linux/can/dev.h</span>
<span class="p_header">+++ b/include/linux/can/dev.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"> enum can_mode {</span>
  * CAN common private data
  */
 struct can_priv {
<span class="p_add">+	struct net_device *dev;</span>
 	struct can_device_stats can_stats;
 
 	struct can_bittiming bittiming, data_bittiming;
<span class="p_chunk">@@ -43,7 +44,7 @@</span> <span class="p_context"> struct can_priv {</span>
 	u32 ctrlmode_supported;
 
 	int restart_ms;
<span class="p_del">-	struct timer_list restart_timer;</span>
<span class="p_add">+	struct delayed_work restart_work;</span>
 
 	int (*do_set_bittiming)(struct net_device *dev);
 	int (*do_set_data_bittiming)(struct net_device *dev);
<span class="p_header">diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h</span>
<span class="p_header">index bb2cdcd929c6..633716ef19b0 100644</span>
<span class="p_header">--- a/include/linux/compiler-gcc.h</span>
<span class="p_header">+++ b/include/linux/compiler-gcc.h</span>
<span class="p_chunk">@@ -177,7 +177,7 @@</span> <span class="p_context"></span>
 #define unreachable() __builtin_unreachable()
 
 /* Mark a function definition as prohibited from being cloned. */
<span class="p_del">-#define __noclone	__attribute__((__noclone__))</span>
<span class="p_add">+#define __noclone	__attribute__((__noclone__, __optimize__(&quot;no-tracer&quot;)))</span>
 
 #endif /* GCC_VERSION &gt;= 40500 */
 
<span class="p_header">diff --git a/include/linux/efi.h b/include/linux/efi.h</span>
<span class="p_header">index 8cb09c9d81ef..1431089c54dc 100644</span>
<span class="p_header">--- a/include/linux/efi.h</span>
<span class="p_header">+++ b/include/linux/efi.h</span>
<span class="p_chunk">@@ -117,6 +117,15 @@</span> <span class="p_context"> typedef struct {</span>
 	u32 imagesize;
 } efi_capsule_header_t;
 
<span class="p_add">+struct efi_boot_memmap {</span>
<span class="p_add">+	efi_memory_desc_t	**map;</span>
<span class="p_add">+	unsigned long		*map_size;</span>
<span class="p_add">+	unsigned long		*desc_size;</span>
<span class="p_add">+	u32			*desc_ver;</span>
<span class="p_add">+	unsigned long		*key_ptr;</span>
<span class="p_add">+	unsigned long		*buff_size;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Allocation types for calls to boottime-&gt;allocate_pages.
  */
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index 545837db9468..3b69a82bbdd9 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -2627,7 +2627,7 @@</span> <span class="p_context"> extern int buffer_migrate_page(struct address_space *,</span>
 #define buffer_migrate_page NULL
 #endif
 
<span class="p_del">-extern int inode_change_ok(const struct inode *, struct iattr *);</span>
<span class="p_add">+extern int setattr_prepare(struct dentry *, struct iattr *);</span>
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
 extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
<span class="p_header">diff --git a/include/linux/fsnotify_backend.h b/include/linux/fsnotify_backend.h</span>
<span class="p_header">index d2be2526ec48..e36f4e76ba94 100644</span>
<span class="p_header">--- a/include/linux/fsnotify_backend.h</span>
<span class="p_header">+++ b/include/linux/fsnotify_backend.h</span>
<span class="p_chunk">@@ -150,6 +150,7 @@</span> <span class="p_context"> struct fsnotify_group {</span>
 	#define FS_PRIO_1	1 /* fanotify content based access control */
 	#define FS_PRIO_2	2 /* fanotify pre-content access */
 	unsigned int priority;
<span class="p_add">+	bool shutdown;		/* group is being shut down, don&#39;t queue more events */</span>
 
 	/* stores all fastpath marks assoc with this group so they can be cleaned on unregister */
 	struct mutex mark_mutex;	/* protect marks_list */
<span class="p_chunk">@@ -181,7 +182,6 @@</span> <span class="p_context"> struct fsnotify_group {</span>
 			spinlock_t access_lock;
 			struct list_head access_list;
 			wait_queue_head_t access_waitq;
<span class="p_del">-			atomic_t bypass_perm;</span>
 #endif /* CONFIG_FANOTIFY_ACCESS_PERMISSIONS */
 			int f_flags;
 			unsigned int max_marks;
<span class="p_chunk">@@ -314,6 +314,8 @@</span> <span class="p_context"> extern struct fsnotify_group *fsnotify_alloc_group(const struct fsnotify_ops *op</span>
 extern void fsnotify_get_group(struct fsnotify_group *group);
 /* drop reference on a group from fsnotify_alloc_group */
 extern void fsnotify_put_group(struct fsnotify_group *group);
<span class="p_add">+/* group destruction begins, stop queuing new events */</span>
<span class="p_add">+extern void fsnotify_group_stop_queueing(struct fsnotify_group *group);</span>
 /* destroy group */
 extern void fsnotify_destroy_group(struct fsnotify_group *group);
 /* fasync handler function */
<span class="p_chunk">@@ -326,8 +328,6 @@</span> <span class="p_context"> extern int fsnotify_add_notify_event(struct fsnotify_group *group,</span>
 				     struct fsnotify_event *event,
 				     int (*merge)(struct list_head *,
 						  struct fsnotify_event *));
<span class="p_del">-/* Remove passed event from groups notification queue */</span>
<span class="p_del">-extern void fsnotify_remove_event(struct fsnotify_group *group, struct fsnotify_event *event);</span>
 /* true if the group notification queue is empty */
 extern bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group);
 /* return, but do not dequeue the first event on the notification queue */
<span class="p_header">diff --git a/include/linux/i8042.h b/include/linux/i8042.h</span>
<span class="p_header">index 0f9bafa17a02..d98780ca9604 100644</span>
<span class="p_header">--- a/include/linux/i8042.h</span>
<span class="p_header">+++ b/include/linux/i8042.h</span>
<span class="p_chunk">@@ -62,7 +62,6 @@</span> <span class="p_context"> struct serio;</span>
 void i8042_lock_chip(void);
 void i8042_unlock_chip(void);
 int i8042_command(unsigned char *param, int command);
<span class="p_del">-bool i8042_check_port_owner(const struct serio *);</span>
 int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio));
 int i8042_remove_filter(bool (*filter)(unsigned char data, unsigned char str,
<span class="p_chunk">@@ -83,11 +82,6 @@</span> <span class="p_context"> static inline int i8042_command(unsigned char *param, int command)</span>
 	return -ENODEV;
 }
 
<span class="p_del">-static inline bool i8042_check_port_owner(const struct serio *serio)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio))
 {
<span class="p_header">diff --git a/include/linux/mlx5/qp.h b/include/linux/mlx5/qp.h</span>
<span class="p_header">index ab1c14a56e6d..0efa883e6508 100644</span>
<span class="p_header">--- a/include/linux/mlx5/qp.h</span>
<span class="p_header">+++ b/include/linux/mlx5/qp.h</span>
<span class="p_chunk">@@ -442,9 +442,9 @@</span> <span class="p_context"> struct mlx5_destroy_qp_mbox_out {</span>
 struct mlx5_modify_qp_mbox_in {
 	struct mlx5_inbox_hdr	hdr;
 	__be32			qpn;
<span class="p_del">-	u8			rsvd1[4];</span>
<span class="p_del">-	__be32			optparam;</span>
 	u8			rsvd0[4];
<span class="p_add">+	__be32			optparam;</span>
<span class="p_add">+	u8			rsvd1[4];</span>
 	struct mlx5_qp_context	ctx;
 	u8			rsvd2[16];
 };
<span class="p_header">diff --git a/include/linux/mroute.h b/include/linux/mroute.h</span>
<span class="p_header">index 79aaa9fc1a15..d5277fc3ce2e 100644</span>
<span class="p_header">--- a/include/linux/mroute.h</span>
<span class="p_header">+++ b/include/linux/mroute.h</span>
<span class="p_chunk">@@ -103,5 +103,5 @@</span> <span class="p_context"> struct mfc_cache {</span>
 struct rtmsg;
 extern int ipmr_get_route(struct net *net, struct sk_buff *skb,
 			  __be32 saddr, __be32 daddr,
<span class="p_del">-			  struct rtmsg *rtm, int nowait);</span>
<span class="p_add">+			  struct rtmsg *rtm, int nowait, u32 portid);</span>
 #endif
<span class="p_header">diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h</span>
<span class="p_header">index 66982e764051..f831155dc7d1 100644</span>
<span class="p_header">--- a/include/linux/mroute6.h</span>
<span class="p_header">+++ b/include/linux/mroute6.h</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> struct mfc6_cache {</span>
 
 struct rtmsg;
 extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
<span class="p_del">-			   struct rtmsg *rtm, int nowait);</span>
<span class="p_add">+			   struct rtmsg *rtm, int nowait, u32 portid);</span>
 
 #ifdef CONFIG_IPV6_MROUTE
 extern struct sock *mroute6_socket(struct net *net, struct sk_buff *skb);
<span class="p_header">diff --git a/include/linux/netfilter/x_tables.h b/include/linux/netfilter/x_tables.h</span>
<span class="p_header">index 7741efa43b35..cc615e273f80 100644</span>
<span class="p_header">--- a/include/linux/netfilter/x_tables.h</span>
<span class="p_header">+++ b/include/linux/netfilter/x_tables.h</span>
<span class="p_chunk">@@ -243,6 +243,10 @@</span> <span class="p_context"> int xt_check_entry_offsets(const void *base, const char *elems,</span>
 			   unsigned int target_offset,
 			   unsigned int next_offset);
 
<span class="p_add">+unsigned int *xt_alloc_entry_offsets(unsigned int size);</span>
<span class="p_add">+bool xt_find_jump_offset(const unsigned int *offsets,</span>
<span class="p_add">+			 unsigned int target, unsigned int size);</span>
<span class="p_add">+</span>
 int xt_check_match(struct xt_mtchk_param *, unsigned int size, u_int8_t proto,
 		   bool inv_proto);
 int xt_check_target(struct xt_tgchk_param *, unsigned int size, u_int8_t proto,
<span class="p_header">diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h</span>
<span class="p_header">index 25f106b0375b..10b57940dc62 100644</span>
<span class="p_header">--- a/include/linux/pagemap.h</span>
<span class="p_header">+++ b/include/linux/pagemap.h</span>
<span class="p_chunk">@@ -599,56 +599,56 @@</span> <span class="p_context"> static inline int fault_in_pages_readable(const char __user *uaddr, int size)</span>
  */
 static inline int fault_in_multipages_writeable(char __user *uaddr, int size)
 {
<span class="p_del">-	int ret = 0;</span>
 	char __user *end = uaddr + size - 1;
 
 	if (unlikely(size == 0))
<span class="p_del">-		return ret;</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_add">+	if (unlikely(uaddr &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
 	/*
 	 * Writing zeroes into userspace here is OK, because we know that if
 	 * the zero gets there, we&#39;ll be overwriting it.
 	 */
<span class="p_del">-	while (uaddr &lt;= end) {</span>
<span class="p_del">-		ret = __put_user(0, uaddr);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (unlikely(__put_user(0, uaddr) != 0))</span>
<span class="p_add">+			return -EFAULT;</span>
 		uaddr += PAGE_SIZE;
<span class="p_del">-	}</span>
<span class="p_add">+	} while (uaddr &lt;= end);</span>
 
 	/* Check whether the range spilled into the next page. */
 	if (((unsigned long)uaddr &amp; PAGE_MASK) ==
 			((unsigned long)end &amp; PAGE_MASK))
<span class="p_del">-		ret = __put_user(0, end);</span>
<span class="p_add">+		return __put_user(0, end);</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static inline int fault_in_multipages_readable(const char __user *uaddr,
 					       int size)
 {
 	volatile char c;
<span class="p_del">-	int ret = 0;</span>
 	const char __user *end = uaddr + size - 1;
 
 	if (unlikely(size == 0))
<span class="p_del">-		return ret;</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-	while (uaddr &lt;= end) {</span>
<span class="p_del">-		ret = __get_user(c, uaddr);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_add">+	if (unlikely(uaddr &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (unlikely(__get_user(c, uaddr) != 0))</span>
<span class="p_add">+			return -EFAULT;</span>
 		uaddr += PAGE_SIZE;
<span class="p_del">-	}</span>
<span class="p_add">+	} while (uaddr &lt;= end);</span>
 
 	/* Check whether the range spilled into the next page. */
 	if (((unsigned long)uaddr &amp; PAGE_MASK) ==
 			((unsigned long)end &amp; PAGE_MASK)) {
<span class="p_del">-		ret = __get_user(c, end);</span>
<span class="p_del">-		(void)c;</span>
<span class="p_add">+		return __get_user(c, end);</span>
 	}
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
<span class="p_header">diff --git a/include/linux/posix_acl.h b/include/linux/posix_acl.h</span>
<span class="p_header">index 3e96a6a76103..d1a8ad7e5ae4 100644</span>
<span class="p_header">--- a/include/linux/posix_acl.h</span>
<span class="p_header">+++ b/include/linux/posix_acl.h</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> extern int set_posix_acl(struct inode *, int, struct posix_acl *);</span>
 extern int posix_acl_chmod(struct inode *, umode_t);
 extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,
 		struct posix_acl **);
<span class="p_add">+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);</span>
 
 extern int simple_set_acl(struct inode *, struct posix_acl *, int);
 extern int simple_acl_create(struct inode *, struct inode *);
<span class="p_header">diff --git a/include/linux/radix-tree.h b/include/linux/radix-tree.h</span>
<span class="p_header">index 5d5174b59802..673dee29a9b9 100644</span>
<span class="p_header">--- a/include/linux/radix-tree.h</span>
<span class="p_header">+++ b/include/linux/radix-tree.h</span>
<span class="p_chunk">@@ -382,6 +382,7 @@</span> <span class="p_context"> static inline __must_check</span>
 void **radix_tree_iter_retry(struct radix_tree_iter *iter)
 {
 	iter-&gt;next_index = iter-&gt;index;
<span class="p_add">+	iter-&gt;tags = 0;</span>
 	return NULL;
 }
 
<span class="p_header">diff --git a/include/linux/serio.h b/include/linux/serio.h</span>
<span class="p_header">index 9f779c7a2da4..27ae809edd70 100644</span>
<span class="p_header">--- a/include/linux/serio.h</span>
<span class="p_header">+++ b/include/linux/serio.h</span>
<span class="p_chunk">@@ -29,7 +29,8 @@</span> <span class="p_context"> struct serio {</span>
 
 	struct serio_device_id id;
 
<span class="p_del">-	spinlock_t lock;		/* protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	/* Protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	spinlock_t lock;</span>
 
 	int (*write)(struct serio *, unsigned char);
 	int (*open)(struct serio *);
<span class="p_chunk">@@ -38,16 +39,29 @@</span> <span class="p_context"> struct serio {</span>
 	void (*stop)(struct serio *);
 
 	struct serio *parent;
<span class="p_del">-	struct list_head child_node;	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	struct list_head child_node;</span>
 	struct list_head children;
<span class="p_del">-	unsigned int depth;		/* level of nesting in serio hierarchy */</span>
<span class="p_add">+	/* Level of nesting in serio hierarchy */</span>
<span class="p_add">+	unsigned int depth;</span>
 
<span class="p_del">-	struct serio_driver *drv;	/* accessed from interrupt, must be protected by serio-&gt;lock and serio-&gt;sem */</span>
<span class="p_del">-	struct mutex drv_mutex;		/* protects serio-&gt;drv so attributes can pin driver */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * serio-&gt;drv is accessed from interrupt handlers; when modifying</span>
<span class="p_add">+	 * caller should acquire serio-&gt;drv_mutex and serio-&gt;lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct serio_driver *drv;</span>
<span class="p_add">+	/* Protects serio-&gt;drv so attributes can pin current driver */</span>
<span class="p_add">+	struct mutex drv_mutex;</span>
 
 	struct device dev;
 
 	struct list_head node;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For use by PS/2 layer when several ports share hardware and</span>
<span class="p_add">+	 * may get indigestion when exposed to concurrent access (i8042).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct mutex *ps2_cmd_mutex;</span>
 };
 #define to_serio_port(d)	container_of(d, struct serio, dev)
 
<span class="p_header">diff --git a/include/linux/swap.h b/include/linux/swap.h</span>
<span class="p_header">index 4bdbee80eede..c28e936c8116 100644</span>
<span class="p_header">--- a/include/linux/swap.h</span>
<span class="p_header">+++ b/include/linux/swap.h</span>
<span class="p_chunk">@@ -274,6 +274,7 @@</span> <span class="p_context"> static inline void workingset_node_pages_inc(struct radix_tree_node *node)</span>
 
 static inline void workingset_node_pages_dec(struct radix_tree_node *node)
 {
<span class="p_add">+	VM_WARN_ON_ONCE(!workingset_node_pages(node));</span>
 	node-&gt;count--;
 }
 
<span class="p_chunk">@@ -289,6 +290,7 @@</span> <span class="p_context"> static inline void workingset_node_shadows_inc(struct radix_tree_node *node)</span>
 
 static inline void workingset_node_shadows_dec(struct radix_tree_node *node)
 {
<span class="p_add">+	VM_WARN_ON_ONCE(!workingset_node_shadows(node));</span>
 	node-&gt;count -= 1U &lt;&lt; RADIX_TREE_COUNT_SHIFT;
 }
 
<span class="p_header">diff --git a/include/net/inet_ecn.h b/include/net/inet_ecn.h</span>
<span class="p_header">index 0dc0a51da38f..dce2d586d9ce 100644</span>
<span class="p_header">--- a/include/net/inet_ecn.h</span>
<span class="p_header">+++ b/include/net/inet_ecn.h</span>
<span class="p_chunk">@@ -128,7 +128,8 @@</span> <span class="p_context"> static inline int IP6_ECN_set_ce(struct sk_buff *skb, struct ipv6hdr *iph)</span>
 	to = from | htonl(INET_ECN_CE &lt;&lt; 20);
 	*(__be32 *)iph = to;
 	if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)
<span class="p_del">-		skb-&gt;csum = csum_add(csum_sub(skb-&gt;csum, from), to);</span>
<span class="p_add">+		skb-&gt;csum = csum_add(csum_sub(skb-&gt;csum, (__force __wsum)from),</span>
<span class="p_add">+				     (__force __wsum)to);</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/include/net/tcp.h b/include/net/tcp.h</span>
<span class="p_header">index d587ff0f8828..60e2dc5cef26 100644</span>
<span class="p_header">--- a/include/net/tcp.h</span>
<span class="p_header">+++ b/include/net/tcp.h</span>
<span class="p_chunk">@@ -1413,6 +1413,8 @@</span> <span class="p_context"> static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unli</span>
 {
 	if (sk-&gt;sk_send_head == skb_unlinked)
 		sk-&gt;sk_send_head = NULL;
<span class="p_add">+	if (tcp_sk(sk)-&gt;highest_sack == skb_unlinked)</span>
<span class="p_add">+		tcp_sk(sk)-&gt;highest_sack = NULL;</span>
 }
 
 static inline void tcp_init_send_head(struct sock *sk)
<span class="p_header">diff --git a/include/target/target_core_backend.h b/include/target/target_core_backend.h</span>
<span class="p_header">index e006e10e08a9..a09a83603c52 100644</span>
<span class="p_header">--- a/include/target/target_core_backend.h</span>
<span class="p_header">+++ b/include/target/target_core_backend.h</span>
<span class="p_chunk">@@ -97,6 +97,6 @@</span> <span class="p_context"> sense_reason_t	transport_generic_map_mem_to_cmd(struct se_cmd *,</span>
 void	array_free(void *array, int n);
 sector_t target_to_linux_sector(struct se_device *dev, sector_t lb);
 bool target_configure_unmap_from_queue(struct se_dev_attrib *attrib,
<span class="p_del">-				       struct request_queue *q, int block_size);</span>
<span class="p_add">+				       struct request_queue *q);</span>
 
 #endif /* TARGET_CORE_BACKEND_H */
<span class="p_header">diff --git a/ipc/msg.c b/ipc/msg.c</span>
<span class="p_header">index cfc8b388332d..02e72d3db498 100644</span>
<span class="p_header">--- a/ipc/msg.c</span>
<span class="p_header">+++ b/ipc/msg.c</span>
<span class="p_chunk">@@ -678,7 +678,7 @@</span> <span class="p_context"> long do_msgsnd(int msqid, long mtype, void __user *mtext,</span>
 		rcu_read_lock();
 		ipc_lock_object(&amp;msq-&gt;q_perm);
 
<span class="p_del">-		ipc_rcu_putref(msq, ipc_rcu_free);</span>
<span class="p_add">+		ipc_rcu_putref(msq, msg_rcu_free);</span>
 		/* raced with RMID? */
 		if (!ipc_valid_object(&amp;msq-&gt;q_perm)) {
 			err = -EIDRM;
<span class="p_header">diff --git a/ipc/sem.c b/ipc/sem.c</span>
<span class="p_header">index 541cb0ff9bd6..fb0c4c96e50a 100644</span>
<span class="p_header">--- a/ipc/sem.c</span>
<span class="p_header">+++ b/ipc/sem.c</span>
<span class="p_chunk">@@ -442,7 +442,7 @@</span> <span class="p_context"> static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns</span>
 static inline void sem_lock_and_putref(struct sem_array *sma)
 {
 	sem_lock(sma, NULL, -1);
<span class="p_del">-	ipc_rcu_putref(sma, ipc_rcu_free);</span>
<span class="p_add">+	ipc_rcu_putref(sma, sem_rcu_free);</span>
 }
 
 static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)
<span class="p_chunk">@@ -1385,7 +1385,7 @@</span> <span class="p_context"> static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,</span>
 			rcu_read_unlock();
 			sem_io = ipc_alloc(sizeof(ushort)*nsems);
 			if (sem_io == NULL) {
<span class="p_del">-				ipc_rcu_putref(sma, ipc_rcu_free);</span>
<span class="p_add">+				ipc_rcu_putref(sma, sem_rcu_free);</span>
 				return -ENOMEM;
 			}
 
<span class="p_chunk">@@ -1419,20 +1419,20 @@</span> <span class="p_context"> static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,</span>
 		if (nsems &gt; SEMMSL_FAST) {
 			sem_io = ipc_alloc(sizeof(ushort)*nsems);
 			if (sem_io == NULL) {
<span class="p_del">-				ipc_rcu_putref(sma, ipc_rcu_free);</span>
<span class="p_add">+				ipc_rcu_putref(sma, sem_rcu_free);</span>
 				return -ENOMEM;
 			}
 		}
 
 		if (copy_from_user(sem_io, p, nsems*sizeof(ushort))) {
<span class="p_del">-			ipc_rcu_putref(sma, ipc_rcu_free);</span>
<span class="p_add">+			ipc_rcu_putref(sma, sem_rcu_free);</span>
 			err = -EFAULT;
 			goto out_free;
 		}
 
 		for (i = 0; i &lt; nsems; i++) {
 			if (sem_io[i] &gt; SEMVMX) {
<span class="p_del">-				ipc_rcu_putref(sma, ipc_rcu_free);</span>
<span class="p_add">+				ipc_rcu_putref(sma, sem_rcu_free);</span>
 				err = -ERANGE;
 				goto out_free;
 			}
<span class="p_chunk">@@ -1722,7 +1722,7 @@</span> <span class="p_context"> static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)</span>
 	/* step 2: allocate new undo structure */
 	new = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);
 	if (!new) {
<span class="p_del">-		ipc_rcu_putref(sma, ipc_rcu_free);</span>
<span class="p_add">+		ipc_rcu_putref(sma, sem_rcu_free);</span>
 		return ERR_PTR(-ENOMEM);
 	}
 
<span class="p_header">diff --git a/kernel/cpuset.c b/kernel/cpuset.c</span>
<span class="p_header">index 524a8eef2965..533494236c12 100644</span>
<span class="p_header">--- a/kernel/cpuset.c</span>
<span class="p_header">+++ b/kernel/cpuset.c</span>
<span class="p_chunk">@@ -1963,6 +1963,20 @@</span> <span class="p_context"> static void cpuset_css_free(struct cgroup_subsys_state *css)</span>
 	kfree(cs);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Make sure the new task conform to the current state of its parent,</span>
<span class="p_add">+ * which could have been changed by cpuset just after it inherits the</span>
<span class="p_add">+ * state from the parent and before it sits on the cgroup&#39;s task list.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void cpuset_fork(struct task_struct *task)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (task_css_is_root(task, cpuset_cgrp_id))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_cpus_allowed_ptr(task, &amp;current-&gt;cpus_allowed);</span>
<span class="p_add">+	task-&gt;mems_allowed = current-&gt;mems_allowed;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct cgroup_subsys cpuset_cgrp_subsys = {
 	.css_alloc = cpuset_css_alloc,
 	.css_online = cpuset_css_online,
<span class="p_chunk">@@ -1971,6 +1985,7 @@</span> <span class="p_context"> struct cgroup_subsys cpuset_cgrp_subsys = {</span>
 	.can_attach = cpuset_can_attach,
 	.cancel_attach = cpuset_cancel_attach,
 	.attach = cpuset_attach,
<span class="p_add">+	.fork		= cpuset_fork,</span>
 	.base_cftypes = files,
 	.early_init = 1,
 };
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index a4ca06e80972..602dbac0b201 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -777,14 +777,12 @@</span> <span class="p_context"> void mm_release(struct task_struct *tsk, struct mm_struct *mm)</span>
 	deactivate_mm(tsk, mm);
 
 	/*
<span class="p_del">-	 * If we&#39;re exiting normally, clear a user-space tid field if</span>
<span class="p_del">-	 * requested.  We leave this alone when dying by signal, to leave</span>
<span class="p_del">-	 * the value intact in a core dump, and to save the unnecessary</span>
<span class="p_del">-	 * trouble, say, a killed vfork parent shouldn&#39;t touch this mm.</span>
<span class="p_del">-	 * Userland only wants this done for a sys_exit.</span>
<span class="p_add">+	 * Signal userspace if we&#39;re not exiting with a core dump</span>
<span class="p_add">+	 * because we want to leave the value intact for debugging</span>
<span class="p_add">+	 * purposes.</span>
 	 */
 	if (tsk-&gt;clear_child_tid) {
<span class="p_del">-		if (!(tsk-&gt;flags &amp; PF_SIGNALED) &amp;&amp;</span>
<span class="p_add">+		if (!(tsk-&gt;signal-&gt;flags &amp; SIGNAL_GROUP_COREDUMP) &amp;&amp;</span>
 		    atomic_read(&amp;mm-&gt;mm_users) &gt; 1) {
 			/*
 			 * We don&#39;t check the error code - if userspace has
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index c3ca760edaf0..8c3baf05f7bd 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -2435,13 +2435,18 @@</span> <span class="p_context"> static inline void kmemleak_load_module(const struct module *mod,</span>
 #endif
 
 #ifdef CONFIG_MODULE_SIG
<span class="p_del">-static int module_sig_check(struct load_info *info)</span>
<span class="p_add">+static int module_sig_check(struct load_info *info, int flags)</span>
 {
 	int err = -ENOKEY;
 	const unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;
 	const void *mod = info-&gt;hdr;
 
<span class="p_del">-	if (info-&gt;len &gt; markerlen &amp;&amp;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Require flags == 0, as a module with version information</span>
<span class="p_add">+	 * removed is no longer the module that was signed</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (flags == 0 &amp;&amp;</span>
<span class="p_add">+	    info-&gt;len &gt; markerlen &amp;&amp;</span>
 	    memcmp(mod + info-&gt;len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {
 		/* We truncate the module to discard the signature */
 		info-&gt;len -= markerlen;
<span class="p_chunk">@@ -2463,7 +2468,7 @@</span> <span class="p_context"> static int module_sig_check(struct load_info *info)</span>
 	return err;
 }
 #else /* !CONFIG_MODULE_SIG */
<span class="p_del">-static int module_sig_check(struct load_info *info)</span>
<span class="p_add">+static int module_sig_check(struct load_info *info, int flags)</span>
 {
 	return 0;
 }
<span class="p_chunk">@@ -3200,7 +3205,7 @@</span> <span class="p_context"> static int load_module(struct load_info *info, const char __user *uargs,</span>
 	long err;
 	char *after_dashes;
 
<span class="p_del">-	err = module_sig_check(info);</span>
<span class="p_add">+	err = module_sig_check(info, flags);</span>
 	if (err)
 		goto free_copy;
 
<span class="p_header">diff --git a/kernel/posix-cpu-timers.c b/kernel/posix-cpu-timers.c</span>
<span class="p_header">index 3b8946416a5f..4bd1dd7db1a1 100644</span>
<span class="p_header">--- a/kernel/posix-cpu-timers.c</span>
<span class="p_header">+++ b/kernel/posix-cpu-timers.c</span>
<span class="p_chunk">@@ -798,6 +798,7 @@</span> <span class="p_context"> static void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec *itp)</span>
 			timer-&gt;it.cpu.expires = 0;
 			sample_to_timespec(timer-&gt;it_clock, timer-&gt;it.cpu.expires,
 					   &amp;itp-&gt;it_value);
<span class="p_add">+			return;</span>
 		} else {
 			cpu_timer_sample_group(timer-&gt;it_clock, p, &amp;now);
 			unlock_task_sighand(p, &amp;flags);
<span class="p_header">diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c</span>
<span class="p_header">index 286ef6072714..2daeb2ec1979 100644</span>
<span class="p_header">--- a/kernel/power/hibernate.c</span>
<span class="p_header">+++ b/kernel/power/hibernate.c</span>
<span class="p_chunk">@@ -301,12 +301,12 @@</span> <span class="p_context"> static int create_image(int platform_mode)</span>
 	save_processor_state();
 	trace_suspend_resume(TPS(&quot;machine_suspend&quot;), PM_EVENT_HIBERNATE, true);
 	error = swsusp_arch_suspend();
<span class="p_add">+	/* Restore control flow magically appears here */</span>
<span class="p_add">+	restore_processor_state();</span>
 	trace_suspend_resume(TPS(&quot;machine_suspend&quot;), PM_EVENT_HIBERNATE, false);
 	if (error)
 		printk(KERN_ERR &quot;PM: Error %d creating hibernation image\n&quot;,
 			error);
<span class="p_del">-	/* Restore control flow magically appears here */</span>
<span class="p_del">-	restore_processor_state();</span>
 	if (!in_suspend)
 		events_check_enabled = false;
 
<span class="p_header">diff --git a/kernel/printk/braille.c b/kernel/printk/braille.c</span>
<span class="p_header">index 276762f3a460..d5760c42f042 100644</span>
<span class="p_header">--- a/kernel/printk/braille.c</span>
<span class="p_header">+++ b/kernel/printk/braille.c</span>
<span class="p_chunk">@@ -9,10 +9,10 @@</span> <span class="p_context"></span>
 
 char *_braille_console_setup(char **str, char **brl_options)
 {
<span class="p_del">-	if (!memcmp(*str, &quot;brl,&quot;, 4)) {</span>
<span class="p_add">+	if (!strncmp(*str, &quot;brl,&quot;, 4)) {</span>
 		*brl_options = &quot;&quot;;
 		*str += 4;
<span class="p_del">-	} else if (!memcmp(str, &quot;brl=&quot;, 4)) {</span>
<span class="p_add">+	} else if (!strncmp(*str, &quot;brl=&quot;, 4)) {</span>
 		*brl_options = *str + 4;
 		*str = strchr(*brl_options, &#39;,&#39;);
 		if (!*str)
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 7c90f805e457..f2c0bcc4ba6c 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -1696,6 +1696,28 @@</span> <span class="p_context"> try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)</span>
 	success = 1; /* we&#39;re going to change -&gt;state */
 	cpu = task_cpu(p);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ensure we load p-&gt;on_rq _after_ p-&gt;state, otherwise it would</span>
<span class="p_add">+	 * be possible to, falsely, observe p-&gt;on_rq == 0 and get stuck</span>
<span class="p_add">+	 * in smp_cond_load_acquire() below.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * sched_ttwu_pending()                 try_to_wake_up()</span>
<span class="p_add">+	 *   [S] p-&gt;on_rq = 1;                  [L] P-&gt;state</span>
<span class="p_add">+	 *       UNLOCK rq-&gt;lock  -----.</span>
<span class="p_add">+	 *                              \</span>
<span class="p_add">+	 *				 +---   RMB</span>
<span class="p_add">+	 * schedule()                   /</span>
<span class="p_add">+	 *       LOCK rq-&gt;lock    -----&#39;</span>
<span class="p_add">+	 *       UNLOCK rq-&gt;lock</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * [task p]</span>
<span class="p_add">+	 *   [S] p-&gt;state = UNINTERRUPTIBLE     [L] p-&gt;on_rq</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Pairs with the UNLOCK+LOCK on rq-&gt;lock from the</span>
<span class="p_add">+	 * last wakeup of our task and the schedule that got our task</span>
<span class="p_add">+	 * current.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_rmb();</span>
 	if (p-&gt;on_rq &amp;&amp; ttwu_remote(p, wake_flags))
 		goto stat;
 
<span class="p_chunk">@@ -5147,7 +5169,6 @@</span> <span class="p_context"> migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu)</span>
 
 	case CPU_UP_PREPARE:
 		rq-&gt;calc_load_update = calc_load_update;
<span class="p_del">-		account_reset_rq(rq);</span>
 		break;
 
 	case CPU_ONLINE:
<span class="p_header">diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h</span>
<span class="p_header">index 3b45ba18f7f4..88379724fc5b 100644</span>
<span class="p_header">--- a/kernel/sched/sched.h</span>
<span class="p_header">+++ b/kernel/sched/sched.h</span>
<span class="p_chunk">@@ -1563,16 +1563,3 @@</span> <span class="p_context"> static inline u64 irq_time_read(int cpu)</span>
 }
 #endif /* CONFIG_64BIT */
 #endif /* CONFIG_IRQ_TIME_ACCOUNTING */
<span class="p_del">-</span>
<span class="p_del">-static inline void account_reset_rq(struct rq *rq)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_IRQ_TIME_ACCOUNTING</span>
<span class="p_del">-	rq-&gt;prev_irq_time = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_PARAVIRT</span>
<span class="p_del">-	rq-&gt;prev_steal_time = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING</span>
<span class="p_del">-	rq-&gt;prev_steal_time_rq = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/kernel/time/timekeeping_debug.c b/kernel/time/timekeeping_debug.c</span>
<span class="p_header">index 4d54f97558df..bbda623aafa7 100644</span>
<span class="p_header">--- a/kernel/time/timekeeping_debug.c</span>
<span class="p_header">+++ b/kernel/time/timekeeping_debug.c</span>
<span class="p_chunk">@@ -23,7 +23,9 @@</span> <span class="p_context"></span>
 
 #include &quot;timekeeping_internal.h&quot;
 
<span class="p_del">-static unsigned int sleep_time_bin[32] = {0};</span>
<span class="p_add">+#define NUM_BINS 32</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int sleep_time_bin[NUM_BINS] = {0};</span>
 
 static int tk_debug_show_sleep_time(struct seq_file *s, void *data)
 {
<span class="p_chunk">@@ -69,6 +71,9 @@</span> <span class="p_context"> late_initcall(tk_debug_sleep_time_init);</span>
 
 void tk_debug_account_sleep_time(struct timespec *t)
 {
<span class="p_del">-	sleep_time_bin[fls(t-&gt;tv_sec)]++;</span>
<span class="p_add">+	/* Cap bin index so we don&#39;t overflow the array */</span>
<span class="p_add">+	int bin = min(fls(t-&gt;tv_sec), NUM_BINS-1);</span>
<span class="p_add">+</span>
<span class="p_add">+	sleep_time_bin[bin]++;</span>
 }
 
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 6d3c38966eda..8df0ed9af291 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -4435,13 +4435,6 @@</span> <span class="p_context"> tracing_read_pipe(struct file *filp, char __user *ubuf,</span>
 	struct trace_array *tr = iter-&gt;tr;
 	ssize_t sret;
 
<span class="p_del">-	/* return any leftover data */</span>
<span class="p_del">-	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span>
<span class="p_del">-	if (sret != -EBUSY)</span>
<span class="p_del">-		return sret;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_seq_init(&amp;iter-&gt;seq);</span>
<span class="p_del">-</span>
 	/* copy the tracer to avoid using a global lock all around */
 	mutex_lock(&amp;trace_types_lock);
 	if (unlikely(iter-&gt;trace-&gt;name != tr-&gt;current_trace-&gt;name))
<span class="p_chunk">@@ -4454,6 +4447,14 @@</span> <span class="p_context"> tracing_read_pipe(struct file *filp, char __user *ubuf,</span>
 	 * is protected.
 	 */
 	mutex_lock(&amp;iter-&gt;mutex);
<span class="p_add">+</span>
<span class="p_add">+	/* return any leftover data */</span>
<span class="p_add">+	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span>
<span class="p_add">+	if (sret != -EBUSY)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_seq_init(&amp;iter-&gt;seq);</span>
<span class="p_add">+</span>
 	if (iter-&gt;trace-&gt;read) {
 		sret = iter-&gt;trace-&gt;read(iter, filp, ubuf, cnt, ppos);
 		if (sret)
<span class="p_header">diff --git a/lib/mpi/mpicoder.c b/lib/mpi/mpicoder.c</span>
<span class="p_header">index 4cc6442733f4..fe8b9ffbbb50 100644</span>
<span class="p_header">--- a/lib/mpi/mpicoder.c</span>
<span class="p_header">+++ b/lib/mpi/mpicoder.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> MPI mpi_read_raw_data(const void *xbuffer, size_t nbytes)</span>
 		return NULL;
 	}
 	if (nbytes &gt; 0)
<span class="p_del">-		nbits -= count_leading_zeros(buffer[0]);</span>
<span class="p_add">+		nbits -= count_leading_zeros(buffer[0]) - (BITS_PER_LONG - 8);</span>
 	else
 		nbits = 0;
 
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index afc8593327d6..5df7b79513ea 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -350,6 +350,20 @@</span> <span class="p_context"> int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev)</span>
 }
 EXPORT_SYMBOL(bdi_register_dev);
 
<span class="p_add">+int bdi_register_owner(struct backing_dev_info *bdi, struct device *owner)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = bdi_register(bdi, NULL, &quot;%u:%u&quot;, MAJOR(owner-&gt;devt),</span>
<span class="p_add">+			MINOR(owner-&gt;devt));</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	bdi-&gt;owner = owner;</span>
<span class="p_add">+	get_device(owner);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(bdi_register_owner);</span>
<span class="p_add">+</span>
 /*
  * Remove bdi from the global list and shutdown any threads we have running
  */
<span class="p_chunk">@@ -418,6 +432,11 @@</span> <span class="p_context"> void bdi_unregister(struct backing_dev_info *bdi)</span>
 
 		device_unregister(dev);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (bdi-&gt;owner) {</span>
<span class="p_add">+		put_device(bdi-&gt;owner);</span>
<span class="p_add">+		bdi-&gt;owner = NULL;</span>
<span class="p_add">+	}</span>
 }
 EXPORT_SYMBOL(bdi_unregister);
 
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index 322462d27b99..076282561870 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -108,6 +108,48 @@</span> <span class="p_context"></span>
  *   -&gt;tasklist_lock            (memory_failure, collect_procs_ao)
  */
 
<span class="p_add">+static int page_cache_tree_insert(struct address_space *mapping,</span>
<span class="p_add">+				  struct page *page, void **shadowp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct radix_tree_node *node;</span>
<span class="p_add">+	void **slot;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = __radix_tree_create(&amp;mapping-&gt;page_tree, page-&gt;index,</span>
<span class="p_add">+				    &amp;node, &amp;slot);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	if (*slot) {</span>
<span class="p_add">+		void *p;</span>
<span class="p_add">+</span>
<span class="p_add">+		p = radix_tree_deref_slot_protected(slot, &amp;mapping-&gt;tree_lock);</span>
<span class="p_add">+		if (!radix_tree_exceptional_entry(p))</span>
<span class="p_add">+			return -EEXIST;</span>
<span class="p_add">+		if (shadowp)</span>
<span class="p_add">+			*shadowp = p;</span>
<span class="p_add">+		mapping-&gt;nrshadows--;</span>
<span class="p_add">+		if (node)</span>
<span class="p_add">+			workingset_node_shadows_dec(node);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	radix_tree_replace_slot(slot, page);</span>
<span class="p_add">+	mapping-&gt;nrpages++;</span>
<span class="p_add">+	if (node) {</span>
<span class="p_add">+		workingset_node_pages_inc(node);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Don&#39;t track node that contains actual pages.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Avoid acquiring the list_lru lock if already</span>
<span class="p_add">+		 * untracked.  The list_empty() test is safe as</span>
<span class="p_add">+		 * node-&gt;private_list is protected by</span>
<span class="p_add">+		 * mapping-&gt;tree_lock.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!list_empty(&amp;node-&gt;private_list))</span>
<span class="p_add">+			list_lru_del(&amp;workingset_shadow_nodes,</span>
<span class="p_add">+				     &amp;node-&gt;private_list);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void page_cache_tree_delete(struct address_space *mapping,
 				   struct page *page, void *shadow)
 {
<span class="p_chunk">@@ -121,6 +163,13 @@</span> <span class="p_context"> static void page_cache_tree_delete(struct address_space *mapping,</span>
 
 	__radix_tree_lookup(&amp;mapping-&gt;page_tree, page-&gt;index, &amp;node, &amp;slot);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need a node to properly account shadow</span>
<span class="p_add">+	 * entries. Don&#39;t plant any without. XXX</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!node)</span>
<span class="p_add">+		shadow = NULL;</span>
<span class="p_add">+</span>
 	if (shadow) {
 		mapping-&gt;nrshadows++;
 		/*
<span class="p_chunk">@@ -494,7 +543,7 @@</span> <span class="p_context"> int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask)</span>
 
 		spin_lock_irq(&amp;mapping-&gt;tree_lock);
 		__delete_from_page_cache(old, NULL);
<span class="p_del">-		error = radix_tree_insert(&amp;mapping-&gt;page_tree, offset, new);</span>
<span class="p_add">+		error = page_cache_tree_insert(mapping, new, NULL);</span>
 		BUG_ON(error);
 		mapping-&gt;nrpages++;
 		__inc_zone_page_state(new, NR_FILE_PAGES);
<span class="p_chunk">@@ -513,48 +562,6 @@</span> <span class="p_context"> int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask)</span>
 }
 EXPORT_SYMBOL_GPL(replace_page_cache_page);
 
<span class="p_del">-static int page_cache_tree_insert(struct address_space *mapping,</span>
<span class="p_del">-				  struct page *page, void **shadowp)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct radix_tree_node *node;</span>
<span class="p_del">-	void **slot;</span>
<span class="p_del">-	int error;</span>
<span class="p_del">-</span>
<span class="p_del">-	error = __radix_tree_create(&amp;mapping-&gt;page_tree, page-&gt;index,</span>
<span class="p_del">-				    &amp;node, &amp;slot);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-	if (*slot) {</span>
<span class="p_del">-		void *p;</span>
<span class="p_del">-</span>
<span class="p_del">-		p = radix_tree_deref_slot_protected(slot, &amp;mapping-&gt;tree_lock);</span>
<span class="p_del">-		if (!radix_tree_exceptional_entry(p))</span>
<span class="p_del">-			return -EEXIST;</span>
<span class="p_del">-		if (shadowp)</span>
<span class="p_del">-			*shadowp = p;</span>
<span class="p_del">-		mapping-&gt;nrshadows--;</span>
<span class="p_del">-		if (node)</span>
<span class="p_del">-			workingset_node_shadows_dec(node);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	radix_tree_replace_slot(slot, page);</span>
<span class="p_del">-	mapping-&gt;nrpages++;</span>
<span class="p_del">-	if (node) {</span>
<span class="p_del">-		workingset_node_pages_inc(node);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Don&#39;t track node that contains actual pages.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Avoid acquiring the list_lru lock if already</span>
<span class="p_del">-		 * untracked.  The list_empty() test is safe as</span>
<span class="p_del">-		 * node-&gt;private_list is protected by</span>
<span class="p_del">-		 * mapping-&gt;tree_lock.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!list_empty(&amp;node-&gt;private_list))</span>
<span class="p_del">-			list_lru_del(&amp;workingset_shadow_nodes,</span>
<span class="p_del">-				     &amp;node-&gt;private_list);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int __add_to_page_cache_locked(struct page *page,
 				      struct address_space *mapping,
 				      pgoff_t offset, gfp_t gfp_mask,
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index c83332d80152..0225f1c6263a 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1655,6 +1655,10 @@</span> <span class="p_context"> static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,</span>
 		 * and reducing the surplus.
 		 */
 		spin_unlock(&amp;hugetlb_lock);
<span class="p_add">+</span>
<span class="p_add">+		/* yield cpu to avoid soft lockup */</span>
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+</span>
 		if (hstate_is_gigantic(h))
 			ret = alloc_fresh_gigantic_page(h, nodes_allowed);
 		else
<span class="p_header">diff --git a/mm/ksm.c b/mm/ksm.c</span>
<span class="p_header">index 691f1bf55858..d8c9c689862c 100644</span>
<span class="p_header">--- a/mm/ksm.c</span>
<span class="p_header">+++ b/mm/ksm.c</span>
<span class="p_chunk">@@ -283,7 +283,8 @@</span> <span class="p_context"> static inline struct rmap_item *alloc_rmap_item(void)</span>
 {
 	struct rmap_item *rmap_item;
 
<span class="p_del">-	rmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL);</span>
<span class="p_add">+	rmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL |</span>
<span class="p_add">+						__GFP_NORETRY | __GFP_NOWARN);</span>
 	if (rmap_item)
 		ksm_rmap_items++;
 	return rmap_item;
<span class="p_header">diff --git a/mm/shmem.c b/mm/shmem.c</span>
<span class="p_header">index a2b87affdc23..efab7a79b05f 100644</span>
<span class="p_header">--- a/mm/shmem.c</span>
<span class="p_header">+++ b/mm/shmem.c</span>
<span class="p_chunk">@@ -540,7 +540,7 @@</span> <span class="p_context"> static int shmem_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/mm/workingset.c b/mm/workingset.c</span>
<span class="p_header">index f7216fa7da27..c068f8c84f07 100644</span>
<span class="p_header">--- a/mm/workingset.c</span>
<span class="p_header">+++ b/mm/workingset.c</span>
<span class="p_chunk">@@ -340,21 +340,19 @@</span> <span class="p_context"> static enum lru_status shadow_lru_isolate(struct list_head *item,</span>
 	 * no pages, so we expect to be able to remove them all and
 	 * delete and free the empty node afterwards.
 	 */
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(!node-&gt;count);</span>
<span class="p_del">-	BUG_ON(node-&gt;count &amp; RADIX_TREE_COUNT_MASK);</span>
<span class="p_add">+	BUG_ON(!workingset_node_shadows(node));</span>
<span class="p_add">+	BUG_ON(workingset_node_pages(node));</span>
 
 	for (i = 0; i &lt; RADIX_TREE_MAP_SIZE; i++) {
 		if (node-&gt;slots[i]) {
 			BUG_ON(!radix_tree_exceptional_entry(node-&gt;slots[i]));
 			node-&gt;slots[i] = NULL;
<span class="p_del">-			BUG_ON(node-&gt;count &lt; (1U &lt;&lt; RADIX_TREE_COUNT_SHIFT));</span>
<span class="p_del">-			node-&gt;count -= 1U &lt;&lt; RADIX_TREE_COUNT_SHIFT;</span>
<span class="p_add">+			workingset_node_shadows_dec(node);</span>
 			BUG_ON(!mapping-&gt;nrshadows);
 			mapping-&gt;nrshadows--;
 		}
 	}
<span class="p_del">-	BUG_ON(node-&gt;count);</span>
<span class="p_add">+	BUG_ON(workingset_node_shadows(node));</span>
 	inc_zone_state(page_zone(virt_to_page(node)), WORKINGSET_NODERECLAIM);
 	if (!__radix_tree_delete_node(&amp;mapping-&gt;page_tree, node))
 		BUG();
<span class="p_header">diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_header">index 90673ff8b87b..335401d6351c 100644</span>
<span class="p_header">--- a/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_header">+++ b/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_chunk">@@ -115,7 +115,18 @@</span> <span class="p_context"> batadv_backbone_gw_free_ref(struct batadv_bla_backbone_gw *backbone_gw)</span>
 /* finally deinitialize the claim */
 static void batadv_claim_release(struct batadv_bla_claim *claim)
 {
<span class="p_del">-	batadv_backbone_gw_free_ref(claim-&gt;backbone_gw);</span>
<span class="p_add">+	struct batadv_bla_backbone_gw *old_backbone_gw;</span>
<span class="p_add">+	spin_lock_bh(&amp;claim-&gt;backbone_lock);</span>
<span class="p_add">+	old_backbone_gw = claim-&gt;backbone_gw;</span>
<span class="p_add">+	claim-&gt;backbone_gw = NULL;</span>
<span class="p_add">+	spin_unlock_bh(&amp;claim-&gt;backbone_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;old_backbone_gw-&gt;crc_lock);</span>
<span class="p_add">+	old_backbone_gw-&gt;crc ^= crc16(0, claim-&gt;addr, ETH_ALEN);</span>
<span class="p_add">+	spin_unlock_bh(&amp;old_backbone_gw-&gt;crc_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	batadv_backbone_gw_free_ref(old_backbone_gw);</span>
<span class="p_add">+</span>
 	kfree_rcu(claim, rcu);
 }
 
<span class="p_chunk">@@ -242,7 +253,9 @@</span> <span class="p_context"> batadv_bla_del_backbone_claims(struct batadv_bla_backbone_gw *backbone_gw)</span>
 	}
 
 	/* all claims gone, intialize CRC */
<span class="p_add">+	spin_lock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
 	backbone_gw-&gt;crc = BATADV_BLA_CRC_INIT;
<span class="p_add">+	spin_unlock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
 }
 
 /**
<span class="p_chunk">@@ -338,9 +351,12 @@</span> <span class="p_context"> static void batadv_bla_send_claim(struct batadv_priv *bat_priv, uint8_t *mac,</span>
 		break;
 	}
 
<span class="p_del">-	if (vid &amp; BATADV_VLAN_HAS_TAG)</span>
<span class="p_add">+	if (vid &amp; BATADV_VLAN_HAS_TAG) {</span>
 		skb = vlan_insert_tag(skb, htons(ETH_P_8021Q),
 				      vid &amp; VLAN_VID_MASK);
<span class="p_add">+		if (!skb)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+	}</span>
 
 	skb_reset_mac_header(skb);
 	skb-&gt;protocol = eth_type_trans(skb, soft_iface);
<span class="p_chunk">@@ -389,6 +405,7 @@</span> <span class="p_context"> batadv_bla_get_backbone_gw(struct batadv_priv *bat_priv, uint8_t *orig,</span>
 	entry-&gt;lasttime = jiffies;
 	entry-&gt;crc = BATADV_BLA_CRC_INIT;
 	entry-&gt;bat_priv = bat_priv;
<span class="p_add">+	spin_lock_init(&amp;entry-&gt;crc_lock);</span>
 	atomic_set(&amp;entry-&gt;request_sent, 0);
 	atomic_set(&amp;entry-&gt;wait_periods, 0);
 	ether_addr_copy(entry-&gt;orig, orig);
<span class="p_chunk">@@ -537,7 +554,9 @@</span> <span class="p_context"> static void batadv_bla_send_announce(struct batadv_priv *bat_priv,</span>
 	__be16 crc;
 
 	memcpy(mac, batadv_announce_mac, 4);
<span class="p_add">+	spin_lock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
 	crc = htons(backbone_gw-&gt;crc);
<span class="p_add">+	spin_unlock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
 	memcpy(&amp;mac[4], &amp;crc, 2);
 
 	batadv_bla_send_claim(bat_priv, mac, backbone_gw-&gt;vid,
<span class="p_chunk">@@ -555,8 +574,10 @@</span> <span class="p_context"> static void batadv_bla_add_claim(struct batadv_priv *bat_priv,</span>
 				 const uint8_t *mac, const unsigned short vid,
 				 struct batadv_bla_backbone_gw *backbone_gw)
 {
<span class="p_add">+	struct batadv_bla_backbone_gw *old_backbone_gw;</span>
 	struct batadv_bla_claim *claim;
 	struct batadv_bla_claim search_claim;
<span class="p_add">+	bool remove_crc = false;</span>
 	int hash_added;
 
 	ether_addr_copy(search_claim.addr, mac);
<span class="p_chunk">@@ -570,8 +591,10 @@</span> <span class="p_context"> static void batadv_bla_add_claim(struct batadv_priv *bat_priv,</span>
 			return;
 
 		ether_addr_copy(claim-&gt;addr, mac);
<span class="p_add">+		spin_lock_init(&amp;claim-&gt;backbone_lock);</span>
 		claim-&gt;vid = vid;
 		claim-&gt;lasttime = jiffies;
<span class="p_add">+		atomic_inc(&amp;backbone_gw-&gt;refcount);</span>
 		claim-&gt;backbone_gw = backbone_gw;
 
 		atomic_set(&amp;claim-&gt;refcount, 2);
<span class="p_chunk">@@ -598,20 +621,55 @@</span> <span class="p_context"> static void batadv_bla_add_claim(struct batadv_priv *bat_priv,</span>
 			   &quot;bla_add_claim(): changing ownership for %pM, vid %d\n&quot;,
 			   mac, BATADV_PRINT_VID(vid));
 
<span class="p_del">-		claim-&gt;backbone_gw-&gt;crc ^= crc16(0, claim-&gt;addr, ETH_ALEN);</span>
<span class="p_del">-		batadv_backbone_gw_free_ref(claim-&gt;backbone_gw);</span>
<span class="p_add">+		remove_crc = true;</span>
 	}
<span class="p_del">-	/* set (new) backbone gw */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* replace backbone_gw atomically and adjust reference counters */</span>
<span class="p_add">+	spin_lock_bh(&amp;claim-&gt;backbone_lock);</span>
<span class="p_add">+	old_backbone_gw = claim-&gt;backbone_gw;</span>
 	atomic_inc(&amp;backbone_gw-&gt;refcount);
 	claim-&gt;backbone_gw = backbone_gw;
<span class="p_add">+	spin_unlock_bh(&amp;claim-&gt;backbone_lock);</span>
 
<span class="p_add">+	if (remove_crc) {</span>
<span class="p_add">+		/* remove claim address from old backbone_gw */</span>
<span class="p_add">+		spin_lock_bh(&amp;old_backbone_gw-&gt;crc_lock);</span>
<span class="p_add">+		old_backbone_gw-&gt;crc ^= crc16(0, claim-&gt;addr, ETH_ALEN);</span>
<span class="p_add">+		spin_unlock_bh(&amp;old_backbone_gw-&gt;crc_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	batadv_backbone_gw_free_ref(old_backbone_gw);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* add claim address to new backbone_gw */</span>
<span class="p_add">+	spin_lock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
 	backbone_gw-&gt;crc ^= crc16(0, claim-&gt;addr, ETH_ALEN);
<span class="p_add">+	spin_unlock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
 	backbone_gw-&gt;lasttime = jiffies;
 
 claim_free_ref:
 	batadv_claim_free_ref(claim);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_bla_claim_get_backbone_gw - Get valid reference for backbone_gw of</span>
<span class="p_add">+ *  claim</span>
<span class="p_add">+ * @claim: claim whose backbone_gw should be returned</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: valid reference to claim::backbone_gw</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct batadv_bla_backbone_gw *</span>
<span class="p_add">+batadv_bla_claim_get_backbone_gw(struct batadv_bla_claim *claim)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct batadv_bla_backbone_gw *backbone_gw;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;claim-&gt;backbone_lock);</span>
<span class="p_add">+	backbone_gw = claim-&gt;backbone_gw;</span>
<span class="p_add">+	atomic_inc(&amp;backbone_gw-&gt;refcount);</span>
<span class="p_add">+	spin_unlock_bh(&amp;claim-&gt;backbone_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return backbone_gw;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Delete a claim from the claim hash which has the
  * given mac address and vid.
  */
<span class="p_chunk">@@ -633,8 +691,6 @@</span> <span class="p_context"> static void batadv_bla_del_claim(struct batadv_priv *bat_priv,</span>
 			   batadv_choose_claim, claim);
 	batadv_claim_free_ref(claim); /* reference from the hash is gone */
 
<span class="p_del">-	claim-&gt;backbone_gw-&gt;crc ^= crc16(0, claim-&gt;addr, ETH_ALEN);</span>
<span class="p_del">-</span>
 	/* don&#39;t need the reference from hash_find() anymore */
 	batadv_claim_free_ref(claim);
 }
<span class="p_chunk">@@ -645,7 +701,7 @@</span> <span class="p_context"> static int batadv_handle_announce(struct batadv_priv *bat_priv,</span>
 				  unsigned short vid)
 {
 	struct batadv_bla_backbone_gw *backbone_gw;
<span class="p_del">-	uint16_t crc;</span>
<span class="p_add">+	uint16_t backbone_crc, crc;</span>
 
 	if (memcmp(an_addr, batadv_announce_mac, 4) != 0)
 		return 0;
<span class="p_chunk">@@ -665,12 +721,16 @@</span> <span class="p_context"> static int batadv_handle_announce(struct batadv_priv *bat_priv,</span>
 		   &quot;handle_announce(): ANNOUNCE vid %d (sent by %pM)... CRC = %#.4x\n&quot;,
 		   BATADV_PRINT_VID(vid), backbone_gw-&gt;orig, crc);
 
<span class="p_del">-	if (backbone_gw-&gt;crc != crc) {</span>
<span class="p_add">+	spin_lock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
<span class="p_add">+	backbone_crc = backbone_gw-&gt;crc;</span>
<span class="p_add">+	spin_unlock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (backbone_crc != crc) {</span>
 		batadv_dbg(BATADV_DBG_BLA, backbone_gw-&gt;bat_priv,
 			   &quot;handle_announce(): CRC FAILED for %pM/%d (my = %#.4x, sent = %#.4x)\n&quot;,
 			   backbone_gw-&gt;orig,
 			   BATADV_PRINT_VID(backbone_gw-&gt;vid),
<span class="p_del">-			   backbone_gw-&gt;crc, crc);</span>
<span class="p_add">+			   backbone_crc, crc);</span>
 
 		batadv_bla_send_request(backbone_gw);
 	} else {
<span class="p_chunk">@@ -1041,6 +1101,7 @@</span> <span class="p_context"> static void batadv_bla_purge_claims(struct batadv_priv *bat_priv,</span>
 				    struct batadv_hard_iface *primary_if,
 				    int now)
 {
<span class="p_add">+	struct batadv_bla_backbone_gw *backbone_gw;</span>
 	struct batadv_bla_claim *claim;
 	struct hlist_head *head;
 	struct batadv_hashtable *hash;
<span class="p_chunk">@@ -1055,14 +1116,17 @@</span> <span class="p_context"> static void batadv_bla_purge_claims(struct batadv_priv *bat_priv,</span>
 
 		rcu_read_lock();
 		hlist_for_each_entry_rcu(claim, head, hash_entry) {
<span class="p_add">+			backbone_gw = batadv_bla_claim_get_backbone_gw(claim);</span>
 			if (now)
 				goto purge_now;
<span class="p_del">-			if (!batadv_compare_eth(claim-&gt;backbone_gw-&gt;orig,</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!batadv_compare_eth(backbone_gw-&gt;orig,</span>
 						primary_if-&gt;net_dev-&gt;dev_addr))
<span class="p_del">-				continue;</span>
<span class="p_add">+				goto skip;</span>
<span class="p_add">+</span>
 			if (!batadv_has_timed_out(claim-&gt;lasttime,
 						  BATADV_BLA_CLAIM_TIMEOUT))
<span class="p_del">-				continue;</span>
<span class="p_add">+				goto skip;</span>
 
 			batadv_dbg(BATADV_DBG_BLA, bat_priv,
 				   &quot;bla_purge_claims(): %pM, vid %d, time out\n&quot;,
<span class="p_chunk">@@ -1070,8 +1134,10 @@</span> <span class="p_context"> static void batadv_bla_purge_claims(struct batadv_priv *bat_priv,</span>
 
 purge_now:
 			batadv_handle_unclaim(bat_priv, primary_if,
<span class="p_del">-					      claim-&gt;backbone_gw-&gt;orig,</span>
<span class="p_add">+					      backbone_gw-&gt;orig,</span>
 					      claim-&gt;addr, claim-&gt;vid);
<span class="p_add">+skip:</span>
<span class="p_add">+			batadv_backbone_gw_free_ref(backbone_gw);</span>
 		}
 		rcu_read_unlock();
 	}
<span class="p_chunk">@@ -1458,9 +1524,11 @@</span> <span class="p_context"> void batadv_bla_free(struct batadv_priv *bat_priv)</span>
 int batadv_bla_rx(struct batadv_priv *bat_priv, struct sk_buff *skb,
 		  unsigned short vid, bool is_bcast)
 {
<span class="p_add">+	struct batadv_bla_backbone_gw *backbone_gw;</span>
 	struct ethhdr *ethhdr;
 	struct batadv_bla_claim search_claim, *claim = NULL;
 	struct batadv_hard_iface *primary_if;
<span class="p_add">+	bool own_claim;</span>
 	int ret;
 
 	ethhdr = eth_hdr(skb);
<span class="p_chunk">@@ -1493,8 +1561,12 @@</span> <span class="p_context"> int batadv_bla_rx(struct batadv_priv *bat_priv, struct sk_buff *skb,</span>
 	}
 
 	/* if it is our own claim ... */
<span class="p_del">-	if (batadv_compare_eth(claim-&gt;backbone_gw-&gt;orig,</span>
<span class="p_del">-			       primary_if-&gt;net_dev-&gt;dev_addr)) {</span>
<span class="p_add">+	backbone_gw = batadv_bla_claim_get_backbone_gw(claim);</span>
<span class="p_add">+	own_claim = batadv_compare_eth(backbone_gw-&gt;orig,</span>
<span class="p_add">+				       primary_if-&gt;net_dev-&gt;dev_addr);</span>
<span class="p_add">+	batadv_backbone_gw_free_ref(backbone_gw);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (own_claim) {</span>
 		/* ... allow it in any case */
 		claim-&gt;lasttime = jiffies;
 		goto allow;
<span class="p_chunk">@@ -1557,7 +1629,9 @@</span> <span class="p_context"> int batadv_bla_tx(struct batadv_priv *bat_priv, struct sk_buff *skb,</span>
 {
 	struct ethhdr *ethhdr;
 	struct batadv_bla_claim search_claim, *claim = NULL;
<span class="p_add">+	struct batadv_bla_backbone_gw *backbone_gw;</span>
 	struct batadv_hard_iface *primary_if;
<span class="p_add">+	bool client_roamed;</span>
 	int ret = 0;
 
 	primary_if = batadv_primary_if_get_selected(bat_priv);
<span class="p_chunk">@@ -1587,8 +1661,12 @@</span> <span class="p_context"> int batadv_bla_tx(struct batadv_priv *bat_priv, struct sk_buff *skb,</span>
 		goto allow;
 
 	/* check if we are responsible. */
<span class="p_del">-	if (batadv_compare_eth(claim-&gt;backbone_gw-&gt;orig,</span>
<span class="p_del">-			       primary_if-&gt;net_dev-&gt;dev_addr)) {</span>
<span class="p_add">+	backbone_gw = batadv_bla_claim_get_backbone_gw(claim);</span>
<span class="p_add">+	client_roamed = batadv_compare_eth(backbone_gw-&gt;orig,</span>
<span class="p_add">+					   primary_if-&gt;net_dev-&gt;dev_addr);</span>
<span class="p_add">+	batadv_backbone_gw_free_ref(backbone_gw);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (client_roamed) {</span>
 		/* if yes, the client has roamed and we have
 		 * to unclaim it.
 		 */
<span class="p_chunk">@@ -1629,9 +1707,11 @@</span> <span class="p_context"> int batadv_bla_claim_table_seq_print_text(struct seq_file *seq, void *offset)</span>
 	struct net_device *net_dev = (struct net_device *)seq-&gt;private;
 	struct batadv_priv *bat_priv = netdev_priv(net_dev);
 	struct batadv_hashtable *hash = bat_priv-&gt;bla.claim_hash;
<span class="p_add">+	struct batadv_bla_backbone_gw *backbone_gw;</span>
 	struct batadv_bla_claim *claim;
 	struct batadv_hard_iface *primary_if;
 	struct hlist_head *head;
<span class="p_add">+	u16 backbone_crc;</span>
 	uint32_t i;
 	bool is_own;
 	uint8_t *primary_addr;
<span class="p_chunk">@@ -1652,13 +1732,21 @@</span> <span class="p_context"> int batadv_bla_claim_table_seq_print_text(struct seq_file *seq, void *offset)</span>
 
 		rcu_read_lock();
 		hlist_for_each_entry_rcu(claim, head, hash_entry) {
<span class="p_del">-			is_own = batadv_compare_eth(claim-&gt;backbone_gw-&gt;orig,</span>
<span class="p_add">+			backbone_gw = batadv_bla_claim_get_backbone_gw(claim);</span>
<span class="p_add">+</span>
<span class="p_add">+			is_own = batadv_compare_eth(backbone_gw-&gt;orig,</span>
 						    primary_addr);
<span class="p_add">+</span>
<span class="p_add">+			spin_lock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
<span class="p_add">+			backbone_crc = backbone_gw-&gt;crc;</span>
<span class="p_add">+			spin_unlock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
 			seq_printf(seq, &quot; * %pM on %5d by %pM [%c] (%#.4x)\n&quot;,
 				   claim-&gt;addr, BATADV_PRINT_VID(claim-&gt;vid),
<span class="p_del">-				   claim-&gt;backbone_gw-&gt;orig,</span>
<span class="p_add">+				   backbone_gw-&gt;orig,</span>
 				   (is_own ? &#39;x&#39; : &#39; &#39;),
<span class="p_del">-				   claim-&gt;backbone_gw-&gt;crc);</span>
<span class="p_add">+				   backbone_crc);</span>
<span class="p_add">+</span>
<span class="p_add">+			batadv_backbone_gw_free_ref(backbone_gw);</span>
 		}
 		rcu_read_unlock();
 	}
<span class="p_chunk">@@ -1677,6 +1765,7 @@</span> <span class="p_context"> int batadv_bla_backbone_table_seq_print_text(struct seq_file *seq, void *offset)</span>
 	struct batadv_hard_iface *primary_if;
 	struct hlist_head *head;
 	int secs, msecs;
<span class="p_add">+	u16 backbone_crc;</span>
 	uint32_t i;
 	bool is_own;
 	uint8_t *primary_addr;
<span class="p_chunk">@@ -1707,10 +1796,14 @@</span> <span class="p_context"> int batadv_bla_backbone_table_seq_print_text(struct seq_file *seq, void *offset)</span>
 			if (is_own)
 				continue;
 
<span class="p_add">+			spin_lock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
<span class="p_add">+			backbone_crc = backbone_gw-&gt;crc;</span>
<span class="p_add">+			spin_unlock_bh(&amp;backbone_gw-&gt;crc_lock);</span>
<span class="p_add">+</span>
 			seq_printf(seq, &quot; * %pM on %5d %4i.%03is (%#.4x)\n&quot;,
 				   backbone_gw-&gt;orig,
 				   BATADV_PRINT_VID(backbone_gw-&gt;vid), secs,
<span class="p_del">-				   msecs, backbone_gw-&gt;crc);</span>
<span class="p_add">+				   msecs, backbone_crc);</span>
 		}
 		rcu_read_unlock();
 	}
<span class="p_header">diff --git a/net/batman-adv/distributed-arp-table.c b/net/batman-adv/distributed-arp-table.c</span>
<span class="p_header">index f49badcfd8a1..dc240a8d99d4 100644</span>
<span class="p_header">--- a/net/batman-adv/distributed-arp-table.c</span>
<span class="p_header">+++ b/net/batman-adv/distributed-arp-table.c</span>
<span class="p_chunk">@@ -959,9 +959,12 @@</span> <span class="p_context"> bool batadv_dat_snoop_outgoing_arp_request(struct batadv_priv *bat_priv,</span>
 		if (!skb_new)
 			goto out;
 
<span class="p_del">-		if (vid &amp; BATADV_VLAN_HAS_TAG)</span>
<span class="p_add">+		if (vid &amp; BATADV_VLAN_HAS_TAG) {</span>
 			skb_new = vlan_insert_tag(skb_new, htons(ETH_P_8021Q),
 						  vid &amp; VLAN_VID_MASK);
<span class="p_add">+			if (!skb_new)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+		}</span>
 
 		skb_reset_mac_header(skb_new);
 		skb_new-&gt;protocol = eth_type_trans(skb_new,
<span class="p_chunk">@@ -1039,9 +1042,12 @@</span> <span class="p_context"> bool batadv_dat_snoop_incoming_arp_request(struct batadv_priv *bat_priv,</span>
 	 */
 	skb_reset_mac_header(skb_new);
 
<span class="p_del">-	if (vid &amp; BATADV_VLAN_HAS_TAG)</span>
<span class="p_add">+	if (vid &amp; BATADV_VLAN_HAS_TAG) {</span>
 		skb_new = vlan_insert_tag(skb_new, htons(ETH_P_8021Q),
 					  vid &amp; VLAN_VID_MASK);
<span class="p_add">+		if (!skb_new)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+	}</span>
 
 	/* To preserve backwards compatibility, the node has choose the outgoing
 	 * format based on the incoming request packet type. The assumption is
<span class="p_header">diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c</span>
<span class="p_header">index 6b4adf1810d3..9e6967a1f23e 100644</span>
<span class="p_header">--- a/net/batman-adv/originator.c</span>
<span class="p_header">+++ b/net/batman-adv/originator.c</span>
<span class="p_chunk">@@ -529,6 +529,8 @@</span> <span class="p_context"> static void batadv_orig_node_release(struct batadv_orig_node *orig_node)</span>
 	struct hlist_node *node_tmp;
 	struct batadv_neigh_node *neigh_node;
 	struct batadv_orig_ifinfo *orig_ifinfo;
<span class="p_add">+	struct batadv_orig_node_vlan *vlan, *vlan_tmp;</span>
<span class="p_add">+	struct batadv_orig_ifinfo *last_candidate;</span>
 
 	spin_lock_bh(&amp;orig_node-&gt;neigh_list_lock);
 
<span class="p_chunk">@@ -544,8 +546,21 @@</span> <span class="p_context"> static void batadv_orig_node_release(struct batadv_orig_node *orig_node)</span>
 		hlist_del_rcu(&amp;orig_ifinfo-&gt;list);
 		batadv_orig_ifinfo_free_ref(orig_ifinfo);
 	}
<span class="p_add">+</span>
<span class="p_add">+	last_candidate = orig_node-&gt;last_bonding_candidate;</span>
<span class="p_add">+	orig_node-&gt;last_bonding_candidate = NULL;</span>
 	spin_unlock_bh(&amp;orig_node-&gt;neigh_list_lock);
 
<span class="p_add">+	if (last_candidate)</span>
<span class="p_add">+		batadv_orig_ifinfo_free_ref(last_candidate);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;orig_node-&gt;vlan_list_lock);</span>
<span class="p_add">+	list_for_each_entry_safe(vlan, vlan_tmp, &amp;orig_node-&gt;vlan_list, list) {</span>
<span class="p_add">+		list_del_rcu(&amp;vlan-&gt;list);</span>
<span class="p_add">+		batadv_orig_node_vlan_free_ref(vlan);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;orig_node-&gt;vlan_list_lock);</span>
<span class="p_add">+</span>
 	/* Free nc_nodes */
 	batadv_nc_purge_orig(orig_node-&gt;bat_priv, orig_node, NULL);
 
<span class="p_header">diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c</span>
<span class="p_header">index 22bbdd082546..34c20cc0670c 100644</span>
<span class="p_header">--- a/net/batman-adv/routing.c</span>
<span class="p_header">+++ b/net/batman-adv/routing.c</span>
<span class="p_chunk">@@ -425,6 +425,52 @@</span> <span class="p_context"> static int batadv_check_unicast_packet(struct batadv_priv *bat_priv,</span>
 }
 
 /**
<span class="p_add">+ * batadv_last_bonding_get - Get last_bonding_candidate of orig_node</span>
<span class="p_add">+ * @orig_node: originator node whose last bonding candidate should be retrieved</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: last bonding candidate of router or NULL if not found</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The object is returned with refcounter increased by 1.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct batadv_orig_ifinfo *</span>
<span class="p_add">+batadv_last_bonding_get(struct batadv_orig_node *orig_node)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct batadv_orig_ifinfo *last_bonding_candidate;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;orig_node-&gt;neigh_list_lock);</span>
<span class="p_add">+	last_bonding_candidate = orig_node-&gt;last_bonding_candidate;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (last_bonding_candidate)</span>
<span class="p_add">+		atomic_inc(&amp;last_bonding_candidate-&gt;refcount);</span>
<span class="p_add">+	spin_unlock_bh(&amp;orig_node-&gt;neigh_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return last_bonding_candidate;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_last_bonding_replace - Replace last_bonding_candidate of orig_node</span>
<span class="p_add">+ * @orig_node: originator node whose bonding candidates should be replaced</span>
<span class="p_add">+ * @new_candidate: new bonding candidate or NULL</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void</span>
<span class="p_add">+batadv_last_bonding_replace(struct batadv_orig_node *orig_node,</span>
<span class="p_add">+			    struct batadv_orig_ifinfo *new_candidate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct batadv_orig_ifinfo *old_candidate;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;orig_node-&gt;neigh_list_lock);</span>
<span class="p_add">+	old_candidate = orig_node-&gt;last_bonding_candidate;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (new_candidate)</span>
<span class="p_add">+		atomic_inc(&amp;new_candidate-&gt;refcount);</span>
<span class="p_add">+	orig_node-&gt;last_bonding_candidate = new_candidate;</span>
<span class="p_add">+	spin_unlock_bh(&amp;orig_node-&gt;neigh_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (old_candidate)</span>
<span class="p_add">+		batadv_orig_ifinfo_free_ref(old_candidate);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * batadv_find_router - find a suitable router for this originator
  * @bat_priv: the bat priv with all the soft interface information
  * @orig_node: the destination node
<span class="p_chunk">@@ -469,7 +515,7 @@</span> <span class="p_context"> batadv_find_router(struct batadv_priv *bat_priv,</span>
 	 * router - obviously there are no other candidates.
 	 */
 	rcu_read_lock();
<span class="p_del">-	last_candidate = orig_node-&gt;last_bonding_candidate;</span>
<span class="p_add">+	last_candidate = batadv_last_bonding_get(orig_node);</span>
 	if (last_candidate)
 		last_cand_router = rcu_dereference(last_candidate-&gt;router);
 
<span class="p_chunk">@@ -529,10 +575,6 @@</span> <span class="p_context"> next:</span>
 	}
 	rcu_read_unlock();
 
<span class="p_del">-	/* last_bonding_candidate is reset below, remove the old reference. */</span>
<span class="p_del">-	if (orig_node-&gt;last_bonding_candidate)</span>
<span class="p_del">-		batadv_orig_ifinfo_free_ref(orig_node-&gt;last_bonding_candidate);</span>
<span class="p_del">-</span>
 	/* After finding candidates, handle the three cases:
 	 * 1) there is a next candidate, use that
 	 * 2) there is no next candidate, use the first of the list
<span class="p_chunk">@@ -541,23 +583,33 @@</span> <span class="p_context"> next:</span>
 	if (next_candidate) {
 		batadv_neigh_node_free_ref(router);
 
<span class="p_del">-		/* remove references to first candidate, we don&#39;t need it. */</span>
<span class="p_del">-		if (first_candidate) {</span>
<span class="p_del">-			batadv_neigh_node_free_ref(first_candidate_router);</span>
<span class="p_del">-			batadv_orig_ifinfo_free_ref(first_candidate);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		atomic_inc(&amp;next_candidate_router-&gt;refcount);</span>
 		router = next_candidate_router;
<span class="p_del">-		orig_node-&gt;last_bonding_candidate = next_candidate;</span>
<span class="p_add">+		batadv_last_bonding_replace(orig_node, next_candidate);</span>
 	} else if (first_candidate) {
 		batadv_neigh_node_free_ref(router);
 
<span class="p_del">-		/* refcounting has already been done in the loop above. */</span>
<span class="p_add">+		atomic_inc(&amp;first_candidate_router-&gt;refcount);</span>
 		router = first_candidate_router;
<span class="p_del">-		orig_node-&gt;last_bonding_candidate = first_candidate;</span>
<span class="p_add">+		batadv_last_bonding_replace(orig_node, first_candidate);</span>
 	} else {
<span class="p_del">-		orig_node-&gt;last_bonding_candidate = NULL;</span>
<span class="p_add">+		batadv_last_bonding_replace(orig_node, NULL);</span>
 	}
 
<span class="p_add">+	/* cleanup of candidates */</span>
<span class="p_add">+	if (first_candidate) {</span>
<span class="p_add">+		batadv_neigh_node_free_ref(first_candidate_router);</span>
<span class="p_add">+		batadv_orig_ifinfo_free_ref(first_candidate);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (next_candidate) {</span>
<span class="p_add">+		batadv_neigh_node_free_ref(next_candidate_router);</span>
<span class="p_add">+		batadv_orig_ifinfo_free_ref(next_candidate);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (last_candidate)</span>
<span class="p_add">+		batadv_orig_ifinfo_free_ref(last_candidate);</span>
<span class="p_add">+</span>
 	return router;
 }
 
<span class="p_header">diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c</span>
<span class="p_header">index 6004c2de7b2a..2cfd5ddbb404 100644</span>
<span class="p_header">--- a/net/batman-adv/send.c</span>
<span class="p_header">+++ b/net/batman-adv/send.c</span>
<span class="p_chunk">@@ -363,8 +363,8 @@</span> <span class="p_context"> int batadv_send_skb_via_gw(struct batadv_priv *bat_priv, struct sk_buff *skb,</span>
 	struct batadv_orig_node *orig_node;
 
 	orig_node = batadv_gw_get_selected_orig(bat_priv);
<span class="p_del">-	return batadv_send_skb_unicast(bat_priv, skb, BATADV_UNICAST, 0,</span>
<span class="p_del">-				       orig_node, vid);</span>
<span class="p_add">+	return batadv_send_skb_unicast(bat_priv, skb, BATADV_UNICAST_4ADDR,</span>
<span class="p_add">+				       BATADV_P_DATA, orig_node, vid);</span>
 }
 
 void batadv_schedule_bat_ogm(struct batadv_hard_iface *hard_iface)
<span class="p_header">diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h</span>
<span class="p_header">index 0cc890bab7a4..61f34f889555 100644</span>
<span class="p_header">--- a/net/batman-adv/types.h</span>
<span class="p_header">+++ b/net/batman-adv/types.h</span>
<span class="p_chunk">@@ -202,12 +202,12 @@</span> <span class="p_context"> struct batadv_orig_bat_iv {</span>
  * @primary_addr: hosts primary interface address
  * @ifinfo_list: list for routers per outgoing interface
  * @last_bonding_candidate: pointer to last ifinfo of last used router
<span class="p_del">- * @batadv_dat_addr_t:  address of the orig node in the distributed hash</span>
<span class="p_add">+ * @dat_addr: address of the orig node in the distributed hash</span>
  * @last_seen: time when last packet from this node was received
  * @bcast_seqno_reset: time when the broadcast seqno window was reset
  * @mcast_handler_lock: synchronizes mcast-capability and -flag changes
  * @mcast_flags: multicast flags announced by the orig node
<span class="p_del">- * @mcast_want_all_unsnoop_node: a list node for the</span>
<span class="p_add">+ * @mcast_want_all_unsnoopables_node: a list node for the</span>
  *  mcast.want_all_unsnoopables list
  * @mcast_want_all_ipv4_node: a list node for the mcast.want_all_ipv4 list
  * @mcast_want_all_ipv6_node: a list node for the mcast.want_all_ipv6 list
<span class="p_chunk">@@ -272,7 +272,9 @@</span> <span class="p_context"> struct batadv_orig_node {</span>
 	DECLARE_BITMAP(bcast_bits, BATADV_TQ_LOCAL_WINDOW_SIZE);
 	uint32_t last_bcast_seqno;
 	struct hlist_head neigh_list;
<span class="p_del">-	/* neigh_list_lock protects: neigh_list and router */</span>
<span class="p_add">+	/* neigh_list_lock protects: neigh_list, ifinfo_list,</span>
<span class="p_add">+	 * last_bonding_candidate and router</span>
<span class="p_add">+	 */</span>
 	spinlock_t neigh_list_lock;
 	struct hlist_node hash_entry;
 	struct batadv_priv *bat_priv;
<span class="p_chunk">@@ -390,7 +392,7 @@</span> <span class="p_context"> struct batadv_neigh_ifinfo {</span>
 
 /**
  * struct batadv_bcast_duplist_entry - structure for LAN broadcast suppression
<span class="p_del">- * @orig[ETH_ALEN]: mac address of orig node orginating the broadcast</span>
<span class="p_add">+ * @orig: mac address of orig node orginating the broadcast</span>
  * @crc: crc32 checksum of broadcast payload
  * @entrytime: time when the broadcast packet was received
  */
<span class="p_chunk">@@ -538,7 +540,7 @@</span> <span class="p_context"> struct batadv_priv_tt {</span>
 
 /**
  * struct batadv_priv_bla - per mesh interface bridge loope avoidance data
<span class="p_del">- * @num_requests; number of bla requests in flight</span>
<span class="p_add">+ * @num_requests: number of bla requests in flight</span>
  * @claim_hash: hash table containing mesh nodes this host has claimed
  * @backbone_hash: hash table containing all detected backbone gateways
  * @bcast_duplist: recently received broadcast packets array (for broadcast
<span class="p_chunk">@@ -760,7 +762,7 @@</span> <span class="p_context"> struct batadv_softif_vlan {</span>
  * @dat: distributed arp table data
  * @mcast: multicast data
  * @network_coding: bool indicating whether network coding is enabled
<span class="p_del">- * @batadv_priv_nc: network coding data</span>
<span class="p_add">+ * @nc: network coding data</span>
  */
 struct batadv_priv {
 	atomic_t mesh_state;
<span class="p_chunk">@@ -871,6 +873,7 @@</span> <span class="p_context"> struct batadv_socket_packet {</span>
  *  backbone gateway - no bcast traffic is formwared until the situation was
  *  resolved
  * @crc: crc16 checksum over all claims
<span class="p_add">+ * @crc_lock: lock protecting crc</span>
  * @refcount: number of contexts the object is used
  * @rcu: struct used for freeing in an RCU-safe manner
  */
<span class="p_chunk">@@ -884,6 +887,7 @@</span> <span class="p_context"> struct batadv_bla_backbone_gw {</span>
 	atomic_t wait_periods;
 	atomic_t request_sent;
 	uint16_t crc;
<span class="p_add">+	spinlock_t crc_lock; /* protects crc */</span>
 	atomic_t refcount;
 	struct rcu_head rcu;
 };
<span class="p_chunk">@@ -892,7 +896,8 @@</span> <span class="p_context"> struct batadv_bla_backbone_gw {</span>
  * struct batadv_bla_claim - claimed non-mesh client structure
  * @addr: mac address of claimed non-mesh client
  * @vid: vlan id this client was detected on
<span class="p_del">- * @batadv_bla_backbone_gw: pointer to backbone gw claiming this client</span>
<span class="p_add">+ * @backbone_gw: pointer to backbone gw claiming this client</span>
<span class="p_add">+ * @backbone_lock: lock protecting backbone_gw pointer</span>
  * @lasttime: last time we heard of claim (locals only)
  * @hash_entry: hlist node for batadv_priv_bla::claim_hash
  * @refcount: number of contexts the object is used
<span class="p_chunk">@@ -902,6 +907,7 @@</span> <span class="p_context"> struct batadv_bla_claim {</span>
 	uint8_t addr[ETH_ALEN];
 	unsigned short vid;
 	struct batadv_bla_backbone_gw *backbone_gw;
<span class="p_add">+	spinlock_t backbone_lock; /* protects backbone_gw */</span>
 	unsigned long lasttime;
 	struct hlist_node hash_entry;
 	struct rcu_head rcu;
<span class="p_header">diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">index d0fd8b04f2e6..071d35c9f3b4 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_sock.c</span>
<span class="p_chunk">@@ -921,7 +921,7 @@</span> <span class="p_context"> static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,</span>
 			break;
 		}
 
<span class="p_del">-		if (get_user(opt, (u32 __user *) optval)) {</span>
<span class="p_add">+		if (get_user(opt, (u16 __user *) optval)) {</span>
 			err = -EFAULT;
 			break;
 		}
<span class="p_header">diff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c</span>
<span class="p_header">index 8bbbb5ec468c..bcb3160fefb4 100644</span>
<span class="p_header">--- a/net/bluetooth/rfcomm/sock.c</span>
<span class="p_header">+++ b/net/bluetooth/rfcomm/sock.c</span>
<span class="p_chunk">@@ -334,16 +334,19 @@</span> <span class="p_context"> static int rfcomm_sock_create(struct net *net, struct socket *sock,</span>
 
 static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
<span class="p_del">-	struct sockaddr_rc *sa = (struct sockaddr_rc *) addr;</span>
<span class="p_add">+	struct sockaddr_rc sa;</span>
 	struct sock *sk = sock-&gt;sk;
<span class="p_del">-	int chan = sa-&gt;rc_channel;</span>
<span class="p_del">-	int err = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	BT_DBG(&quot;sk %p %pMR&quot;, sk, &amp;sa-&gt;rc_bdaddr);</span>
<span class="p_add">+	int len, err = 0;</span>
 
 	if (!addr || addr-&gt;sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
<span class="p_add">+	memset(&amp;sa, 0, sizeof(sa));</span>
<span class="p_add">+	len = min_t(unsigned int, sizeof(sa), addr_len);</span>
<span class="p_add">+	memcpy(&amp;sa, addr, len);</span>
<span class="p_add">+</span>
<span class="p_add">+	BT_DBG(&quot;sk %p %pMR&quot;, sk, &amp;sa.rc_bdaddr);</span>
<span class="p_add">+</span>
 	lock_sock(sk);
 
 	if (sk-&gt;sk_state != BT_OPEN) {
<span class="p_chunk">@@ -358,12 +361,13 @@</span> <span class="p_context"> static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr</span>
 
 	write_lock(&amp;rfcomm_sk_list.lock);
 
<span class="p_del">-	if (chan &amp;&amp; __rfcomm_get_listen_sock_by_addr(chan, &amp;sa-&gt;rc_bdaddr)) {</span>
<span class="p_add">+	if (sa.rc_channel &amp;&amp;</span>
<span class="p_add">+	    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &amp;sa.rc_bdaddr)) {</span>
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
<span class="p_del">-		bacpy(&amp;rfcomm_pi(sk)-&gt;src, &amp;sa-&gt;rc_bdaddr);</span>
<span class="p_del">-		rfcomm_pi(sk)-&gt;channel = chan;</span>
<span class="p_add">+		bacpy(&amp;rfcomm_pi(sk)-&gt;src, &amp;sa.rc_bdaddr);</span>
<span class="p_add">+		rfcomm_pi(sk)-&gt;channel = sa.rc_channel;</span>
 		sk-&gt;sk_state = BT_BOUND;
 	}
 
<span class="p_header">diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c</span>
<span class="p_header">index 5740f71b609d..98c579243d87 100644</span>
<span class="p_header">--- a/net/ceph/osdmap.c</span>
<span class="p_header">+++ b/net/ceph/osdmap.c</span>
<span class="p_chunk">@@ -1167,6 +1167,115 @@</span> <span class="p_context"> struct ceph_osdmap *ceph_osdmap_decode(void **p, void *end)</span>
 }
 
 /*
<span class="p_add">+ * Encoding order is (new_up_client, new_state, new_weight).  Need to</span>
<span class="p_add">+ * apply in the (new_weight, new_state, new_up_client) order, because</span>
<span class="p_add">+ * an incremental map may look like e.g.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *     new_up_client: { osd=6, addr=... } # set osd_state and addr</span>
<span class="p_add">+ *     new_state: { osd=6, xorstate=EXISTS } # clear osd_state</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int decode_new_up_state_weight(void **p, void *end,</span>
<span class="p_add">+				      struct ceph_osdmap *map)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *new_up_client;</span>
<span class="p_add">+	void *new_state;</span>
<span class="p_add">+	void *new_weight_end;</span>
<span class="p_add">+	u32 len;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_up_client = *p;</span>
<span class="p_add">+	ceph_decode_32_safe(p, end, len, e_inval);</span>
<span class="p_add">+	len *= sizeof(u32) + sizeof(struct ceph_entity_addr);</span>
<span class="p_add">+	ceph_decode_need(p, end, len, e_inval);</span>
<span class="p_add">+	*p += len;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_state = *p;</span>
<span class="p_add">+	ceph_decode_32_safe(p, end, len, e_inval);</span>
<span class="p_add">+	len *= sizeof(u32) + sizeof(u8);</span>
<span class="p_add">+	ceph_decode_need(p, end, len, e_inval);</span>
<span class="p_add">+	*p += len;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* new_weight */</span>
<span class="p_add">+	ceph_decode_32_safe(p, end, len, e_inval);</span>
<span class="p_add">+	while (len--) {</span>
<span class="p_add">+		s32 osd;</span>
<span class="p_add">+		u32 w;</span>
<span class="p_add">+</span>
<span class="p_add">+		ceph_decode_need(p, end, 2*sizeof(u32), e_inval);</span>
<span class="p_add">+		osd = ceph_decode_32(p);</span>
<span class="p_add">+		w = ceph_decode_32(p);</span>
<span class="p_add">+		BUG_ON(osd &gt;= map-&gt;max_osd);</span>
<span class="p_add">+		pr_info(&quot;osd%d weight 0x%x %s\n&quot;, osd, w,</span>
<span class="p_add">+		     w == CEPH_OSD_IN ? &quot;(in)&quot; :</span>
<span class="p_add">+		     (w == CEPH_OSD_OUT ? &quot;(out)&quot; : &quot;&quot;));</span>
<span class="p_add">+		map-&gt;osd_weight[osd] = w;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If we are marking in, set the EXISTS, and clear the</span>
<span class="p_add">+		 * AUTOOUT and NEW bits.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (w) {</span>
<span class="p_add">+			map-&gt;osd_state[osd] |= CEPH_OSD_EXISTS;</span>
<span class="p_add">+			map-&gt;osd_state[osd] &amp;= ~(CEPH_OSD_AUTOOUT |</span>
<span class="p_add">+						 CEPH_OSD_NEW);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	new_weight_end = *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* new_state (up/down) */</span>
<span class="p_add">+	*p = new_state;</span>
<span class="p_add">+	len = ceph_decode_32(p);</span>
<span class="p_add">+	while (len--) {</span>
<span class="p_add">+		s32 osd;</span>
<span class="p_add">+		u8 xorstate;</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		osd = ceph_decode_32(p);</span>
<span class="p_add">+		xorstate = ceph_decode_8(p);</span>
<span class="p_add">+		if (xorstate == 0)</span>
<span class="p_add">+			xorstate = CEPH_OSD_UP;</span>
<span class="p_add">+		BUG_ON(osd &gt;= map-&gt;max_osd);</span>
<span class="p_add">+		if ((map-&gt;osd_state[osd] &amp; CEPH_OSD_UP) &amp;&amp;</span>
<span class="p_add">+		    (xorstate &amp; CEPH_OSD_UP))</span>
<span class="p_add">+			pr_info(&quot;osd%d down\n&quot;, osd);</span>
<span class="p_add">+		if ((map-&gt;osd_state[osd] &amp; CEPH_OSD_EXISTS) &amp;&amp;</span>
<span class="p_add">+		    (xorstate &amp; CEPH_OSD_EXISTS)) {</span>
<span class="p_add">+			pr_info(&quot;osd%d does not exist\n&quot;, osd);</span>
<span class="p_add">+			map-&gt;osd_weight[osd] = CEPH_OSD_IN;</span>
<span class="p_add">+			ret = set_primary_affinity(map, osd,</span>
<span class="p_add">+						   CEPH_OSD_DEFAULT_PRIMARY_AFFINITY);</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+			memset(map-&gt;osd_addr + osd, 0, sizeof(*map-&gt;osd_addr));</span>
<span class="p_add">+			map-&gt;osd_state[osd] = 0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			map-&gt;osd_state[osd] ^= xorstate;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* new_up_client */</span>
<span class="p_add">+	*p = new_up_client;</span>
<span class="p_add">+	len = ceph_decode_32(p);</span>
<span class="p_add">+	while (len--) {</span>
<span class="p_add">+		s32 osd;</span>
<span class="p_add">+		struct ceph_entity_addr addr;</span>
<span class="p_add">+</span>
<span class="p_add">+		osd = ceph_decode_32(p);</span>
<span class="p_add">+		ceph_decode_copy(p, &amp;addr, sizeof(addr));</span>
<span class="p_add">+		ceph_decode_addr(&amp;addr);</span>
<span class="p_add">+		BUG_ON(osd &gt;= map-&gt;max_osd);</span>
<span class="p_add">+		pr_info(&quot;osd%d up\n&quot;, osd);</span>
<span class="p_add">+		map-&gt;osd_state[osd] |= CEPH_OSD_EXISTS | CEPH_OSD_UP;</span>
<span class="p_add">+		map-&gt;osd_addr[osd] = addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	*p = new_weight_end;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+e_inval:</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * decode and apply an incremental map update.
  */
 struct ceph_osdmap *osdmap_apply_incremental(void **p, void *end,
<span class="p_chunk">@@ -1265,49 +1374,10 @@</span> <span class="p_context"> struct ceph_osdmap *osdmap_apply_incremental(void **p, void *end,</span>
 			__remove_pg_pool(&amp;map-&gt;pg_pools, pi);
 	}
 
<span class="p_del">-	/* new_up */</span>
<span class="p_del">-	ceph_decode_32_safe(p, end, len, e_inval);</span>
<span class="p_del">-	while (len--) {</span>
<span class="p_del">-		u32 osd;</span>
<span class="p_del">-		struct ceph_entity_addr addr;</span>
<span class="p_del">-		ceph_decode_32_safe(p, end, osd, e_inval);</span>
<span class="p_del">-		ceph_decode_copy_safe(p, end, &amp;addr, sizeof(addr), e_inval);</span>
<span class="p_del">-		ceph_decode_addr(&amp;addr);</span>
<span class="p_del">-		pr_info(&quot;osd%d up\n&quot;, osd);</span>
<span class="p_del">-		BUG_ON(osd &gt;= map-&gt;max_osd);</span>
<span class="p_del">-		map-&gt;osd_state[osd] |= CEPH_OSD_UP;</span>
<span class="p_del">-		map-&gt;osd_addr[osd] = addr;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* new_state */</span>
<span class="p_del">-	ceph_decode_32_safe(p, end, len, e_inval);</span>
<span class="p_del">-	while (len--) {</span>
<span class="p_del">-		u32 osd;</span>
<span class="p_del">-		u8 xorstate;</span>
<span class="p_del">-		ceph_decode_32_safe(p, end, osd, e_inval);</span>
<span class="p_del">-		xorstate = **(u8 **)p;</span>
<span class="p_del">-		(*p)++;  /* clean flag */</span>
<span class="p_del">-		if (xorstate == 0)</span>
<span class="p_del">-			xorstate = CEPH_OSD_UP;</span>
<span class="p_del">-		if (xorstate &amp; CEPH_OSD_UP)</span>
<span class="p_del">-			pr_info(&quot;osd%d down\n&quot;, osd);</span>
<span class="p_del">-		if (osd &lt; map-&gt;max_osd)</span>
<span class="p_del">-			map-&gt;osd_state[osd] ^= xorstate;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* new_weight */</span>
<span class="p_del">-	ceph_decode_32_safe(p, end, len, e_inval);</span>
<span class="p_del">-	while (len--) {</span>
<span class="p_del">-		u32 osd, off;</span>
<span class="p_del">-		ceph_decode_need(p, end, sizeof(u32)*2, e_inval);</span>
<span class="p_del">-		osd = ceph_decode_32(p);</span>
<span class="p_del">-		off = ceph_decode_32(p);</span>
<span class="p_del">-		pr_info(&quot;osd%d weight 0x%x %s\n&quot;, osd, off,</span>
<span class="p_del">-		     off == CEPH_OSD_IN ? &quot;(in)&quot; :</span>
<span class="p_del">-		     (off == CEPH_OSD_OUT ? &quot;(out)&quot; : &quot;&quot;));</span>
<span class="p_del">-		if (osd &lt; map-&gt;max_osd)</span>
<span class="p_del">-			map-&gt;osd_weight[osd] = off;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* new_up_client, new_state, new_weight */</span>
<span class="p_add">+	err = decode_new_up_state_weight(p, end, map);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto bad;</span>
 
 	/* new_pg_temp */
 	err = decode_new_pg_temp(p, end, map);
<span class="p_header">diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c</span>
<span class="p_header">index da9f18156ba9..65a28620006c 100644</span>
<span class="p_header">--- a/net/ipv4/ipmr.c</span>
<span class="p_header">+++ b/net/ipv4/ipmr.c</span>
<span class="p_chunk">@@ -2188,7 +2188,7 @@</span> <span class="p_context"> static int __ipmr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,</span>
 
 int ipmr_get_route(struct net *net, struct sk_buff *skb,
 		   __be32 saddr, __be32 daddr,
<span class="p_del">-		   struct rtmsg *rtm, int nowait)</span>
<span class="p_add">+		   struct rtmsg *rtm, int nowait, u32 portid)</span>
 {
 	struct mfc_cache *cache;
 	struct mr_table *mrt;
<span class="p_chunk">@@ -2233,6 +2233,7 @@</span> <span class="p_context"> int ipmr_get_route(struct net *net, struct sk_buff *skb,</span>
 			return -ENOMEM;
 		}
 
<span class="p_add">+		NETLINK_CB(skb2).portid = portid;</span>
 		skb_push(skb2, sizeof(struct iphdr));
 		skb_reset_network_header(skb2);
 		iph = ip_hdr(skb2);
<span class="p_header">diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_header">index 3bdb46b325ab..106db177a91c 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_chunk">@@ -367,7 +367,8 @@</span> <span class="p_context"> static inline bool unconditional(const struct arpt_entry *e)</span>
  * there are loops.  Puts hook bitmask in comefrom.
  */
 static int mark_source_chains(const struct xt_table_info *newinfo,
<span class="p_del">-			      unsigned int valid_hooks, void *entry0)</span>
<span class="p_add">+			      unsigned int valid_hooks, void *entry0,</span>
<span class="p_add">+			      unsigned int *offsets)</span>
 {
 	unsigned int hook;
 
<span class="p_chunk">@@ -456,6 +457,11 @@</span> <span class="p_context"> static int mark_source_chains(const struct xt_table_info *newinfo,</span>
 					/* This a jump; chase it. */
 					duprintf(&quot;Jump rule %u -&gt; %u\n&quot;,
 						 pos, newpos);
<span class="p_add">+					if (!xt_find_jump_offset(offsets, newpos,</span>
<span class="p_add">+								 newinfo-&gt;number))</span>
<span class="p_add">+						return 0;</span>
<span class="p_add">+					e = (struct arpt_entry *)</span>
<span class="p_add">+						(entry0 + newpos);</span>
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e-&gt;next_offset;
<span class="p_chunk">@@ -615,6 +621,7 @@</span> <span class="p_context"> static int translate_table(struct xt_table_info *newinfo, void *entry0,</span>
                            const struct arpt_replace *repl)
 {
 	struct arpt_entry *iter;
<span class="p_add">+	unsigned int *offsets;</span>
 	unsigned int i;
 	int ret = 0;
 
<span class="p_chunk">@@ -628,8 +635,10 @@</span> <span class="p_context"> static int translate_table(struct xt_table_info *newinfo, void *entry0,</span>
 	}
 
 	duprintf(&quot;translate_table: size %u\n&quot;, newinfo-&gt;size);
<span class="p_add">+	offsets = xt_alloc_entry_offsets(newinfo-&gt;number);</span>
<span class="p_add">+	if (!offsets)</span>
<span class="p_add">+		return -ENOMEM;</span>
 	i = 0;
<span class="p_del">-</span>
 	/* Walk through entries, checking offsets. */
 	xt_entry_foreach(iter, entry0, newinfo-&gt;size) {
 		ret = check_entry_size_and_hooks(iter, newinfo, entry0,
<span class="p_chunk">@@ -638,7 +647,9 @@</span> <span class="p_context"> static int translate_table(struct xt_table_info *newinfo, void *entry0,</span>
 						 repl-&gt;underflow,
 						 repl-&gt;valid_hooks);
 		if (ret != 0)
<span class="p_del">-			break;</span>
<span class="p_add">+			goto out_free;</span>
<span class="p_add">+		if (i &lt; repl-&gt;num_entries)</span>
<span class="p_add">+			offsets[i] = (void *)iter - entry0;</span>
 		++i;
 		if (strcmp(arpt_get_target(iter)-&gt;u.user.name,
 		    XT_ERROR_TARGET) == 0)
<span class="p_chunk">@@ -646,12 +657,13 @@</span> <span class="p_context"> static int translate_table(struct xt_table_info *newinfo, void *entry0,</span>
 	}
 	duprintf(&quot;translate_table: ARPT_ENTRY_ITERATE gives %d\n&quot;, ret);
 	if (ret != 0)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto out_free;</span>
 
<span class="p_add">+	ret = -EINVAL;</span>
 	if (i != repl-&gt;num_entries) {
 		duprintf(&quot;translate_table: %u not %u entries\n&quot;,
 			 i, repl-&gt;num_entries);
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		goto out_free;</span>
 	}
 
 	/* Check hooks all assigned */
<span class="p_chunk">@@ -662,17 +674,20 @@</span> <span class="p_context"> static int translate_table(struct xt_table_info *newinfo, void *entry0,</span>
 		if (newinfo-&gt;hook_entry[i] == 0xFFFFFFFF) {
 			duprintf(&quot;Invalid hook entry %u %u\n&quot;,
 				 i, repl-&gt;hook_entry[i]);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			goto out_free;</span>
 		}
 		if (newinfo-&gt;underflow[i] == 0xFFFFFFFF) {
 			duprintf(&quot;Invalid underflow %u %u\n&quot;,
 				 i, repl-&gt;underflow[i]);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			goto out_free;</span>
 		}
 	}
 
<span class="p_del">-	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0))</span>
<span class="p_del">-		return -ELOOP;</span>
<span class="p_add">+	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0, offsets)) {</span>
<span class="p_add">+		ret = -ELOOP;</span>
<span class="p_add">+		goto out_free;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kvfree(offsets);</span>
 
 	/* Finally, each sanity check must pass */
 	i = 0;
<span class="p_chunk">@@ -699,6 +714,9 @@</span> <span class="p_context"> static int translate_table(struct xt_table_info *newinfo, void *entry0,</span>
 	}
 
 	return ret;
<span class="p_add">+ out_free:</span>
<span class="p_add">+	kvfree(offsets);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void get_counters(const struct xt_table_info *t,
<span class="p_header">diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c</span>
<span class="p_header">index baa1f65e5142..9e20b99bf325 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/ip_tables.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/ip_tables.c</span>
<span class="p_chunk">@@ -443,7 +443,8 @@</span> <span class="p_context"> ipt_do_table(struct sk_buff *skb,</span>
    there are loops.  Puts hook bitmask in comefrom. */
 static int
 mark_source_chains(const struct xt_table_info *newinfo,
<span class="p_del">-		   unsigned int valid_hooks, void *entry0)</span>
<span class="p_add">+		   unsigned int valid_hooks, void *entry0,</span>
<span class="p_add">+		   unsigned int *offsets)</span>
 {
 	unsigned int hook;
 
<span class="p_chunk">@@ -536,6 +537,11 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 					/* This a jump; chase it. */
 					duprintf(&quot;Jump rule %u -&gt; %u\n&quot;,
 						 pos, newpos);
<span class="p_add">+					if (!xt_find_jump_offset(offsets, newpos,</span>
<span class="p_add">+								 newinfo-&gt;number))</span>
<span class="p_add">+						return 0;</span>
<span class="p_add">+					e = (struct ipt_entry *)</span>
<span class="p_add">+						(entry0 + newpos);</span>
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e-&gt;next_offset;
<span class="p_chunk">@@ -782,6 +788,7 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
                 const struct ipt_replace *repl)
 {
 	struct ipt_entry *iter;
<span class="p_add">+	unsigned int *offsets;</span>
 	unsigned int i;
 	int ret = 0;
 
<span class="p_chunk">@@ -795,6 +802,9 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
 	}
 
 	duprintf(&quot;translate_table: size %u\n&quot;, newinfo-&gt;size);
<span class="p_add">+	offsets = xt_alloc_entry_offsets(newinfo-&gt;number);</span>
<span class="p_add">+	if (!offsets)</span>
<span class="p_add">+		return -ENOMEM;</span>
 	i = 0;
 	/* Walk through entries, checking offsets. */
 	xt_entry_foreach(iter, entry0, newinfo-&gt;size) {
<span class="p_chunk">@@ -804,17 +814,20 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
 						 repl-&gt;underflow,
 						 repl-&gt;valid_hooks);
 		if (ret != 0)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out_free;</span>
<span class="p_add">+		if (i &lt; repl-&gt;num_entries)</span>
<span class="p_add">+			offsets[i] = (void *)iter - entry0;</span>
 		++i;
 		if (strcmp(ipt_get_target(iter)-&gt;u.user.name,
 		    XT_ERROR_TARGET) == 0)
 			++newinfo-&gt;stacksize;
 	}
 
<span class="p_add">+	ret = -EINVAL;</span>
 	if (i != repl-&gt;num_entries) {
 		duprintf(&quot;translate_table: %u not %u entries\n&quot;,
 			 i, repl-&gt;num_entries);
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		goto out_free;</span>
 	}
 
 	/* Check hooks all assigned */
<span class="p_chunk">@@ -825,17 +838,20 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
 		if (newinfo-&gt;hook_entry[i] == 0xFFFFFFFF) {
 			duprintf(&quot;Invalid hook entry %u %u\n&quot;,
 				 i, repl-&gt;hook_entry[i]);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			goto out_free;</span>
 		}
 		if (newinfo-&gt;underflow[i] == 0xFFFFFFFF) {
 			duprintf(&quot;Invalid underflow %u %u\n&quot;,
 				 i, repl-&gt;underflow[i]);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			goto out_free;</span>
 		}
 	}
 
<span class="p_del">-	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0))</span>
<span class="p_del">-		return -ELOOP;</span>
<span class="p_add">+	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0, offsets)) {</span>
<span class="p_add">+		ret = -ELOOP;</span>
<span class="p_add">+		goto out_free;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kvfree(offsets);</span>
 
 	/* Finally, each sanity check must pass */
 	i = 0;
<span class="p_chunk">@@ -862,6 +878,9 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
 	}
 
 	return ret;
<span class="p_add">+ out_free:</span>
<span class="p_add">+	kvfree(offsets);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 5df7ed8c62d9..2548c2274cb8 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -2413,7 +2413,8 @@</span> <span class="p_context"> static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,</span>
 		    IPV4_DEVCONF_ALL(net, MC_FORWARDING)) {
 			int err = ipmr_get_route(net, skb,
 						 fl4-&gt;saddr, fl4-&gt;daddr,
<span class="p_del">-						 r, nowait);</span>
<span class="p_add">+						 r, nowait, portid);</span>
<span class="p_add">+</span>
 			if (err &lt;= 0) {
 				if (!nowait) {
 					if (err == 0)
<span class="p_header">diff --git a/net/ipv4/tcp_fastopen.c b/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">index 6088c58bc54c..2b986576e5ad 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_fastopen.c</span>
<span class="p_chunk">@@ -213,6 +213,7 @@</span> <span class="p_context"> static bool tcp_fastopen_create_child(struct sock *sk,</span>
 		}
 	}
 	tcp_rsk(req)-&gt;rcv_nxt = tp-&gt;rcv_nxt = end_seq;
<span class="p_add">+	tp-&gt;rcv_wup = tp-&gt;rcv_nxt;</span>
 	sk-&gt;sk_data_ready(sk);
 	bh_unlock_sock(child);
 	sock_put(child);
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index d3b64bfedd18..50023e8af668 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -2316,10 +2316,9 @@</span> <span class="p_context"> static void DBGUNDO(struct sock *sk, const char *msg)</span>
 	}
 #if IS_ENABLED(CONFIG_IPV6)
 	else if (sk-&gt;sk_family == AF_INET6) {
<span class="p_del">-		struct ipv6_pinfo *np = inet6_sk(sk);</span>
 		pr_debug(&quot;Undo %s %pI6/%u c%u l%u ss%u/%u p%u\n&quot;,
 			 msg,
<span class="p_del">-			 &amp;np-&gt;daddr, ntohs(inet-&gt;inet_dport),</span>
<span class="p_add">+			 &amp;sk-&gt;sk_v6_daddr, ntohs(inet-&gt;inet_dport),</span>
 			 tp-&gt;snd_cwnd, tcp_left_out(tp),
 			 tp-&gt;snd_ssthresh, tp-&gt;prior_ssthresh,
 			 tp-&gt;packets_out);
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 9d26f4569a2e..8b5c457b40cd 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -245,7 +245,8 @@</span> <span class="p_context"> void tcp_select_initial_window(int __space, __u32 mss,</span>
 		/* Set window scaling on max possible window
 		 * See RFC1323 for an explanation of the limit to 14
 		 */
<span class="p_del">-		space = max_t(u32, sysctl_tcp_rmem[2], sysctl_rmem_max);</span>
<span class="p_add">+		space = max_t(u32, space, sysctl_tcp_rmem[2]);</span>
<span class="p_add">+		space = max_t(u32, space, sysctl_rmem_max);</span>
 		space = min_t(u32, space, *window_clamp);
 		while (space &gt; 65535 &amp;&amp; (*rcv_wscale) &lt; 14) {
 			space &gt;&gt;= 1;
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 0002aa9ca91a..213fc4f9b265 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -723,7 +723,14 @@</span> <span class="p_context"> static int addrconf_fixup_forwarding(struct ctl_table *table, int *p, int newf)</span>
 	}
 
 	if (p == &amp;net-&gt;ipv6.devconf_all-&gt;forwarding) {
<span class="p_add">+		int old_dflt = net-&gt;ipv6.devconf_dflt-&gt;forwarding;</span>
<span class="p_add">+</span>
 		net-&gt;ipv6.devconf_dflt-&gt;forwarding = newf;
<span class="p_add">+		if ((!newf) ^ (!old_dflt))</span>
<span class="p_add">+			inet6_netconf_notify_devconf(net, NETCONFA_FORWARDING,</span>
<span class="p_add">+						     NETCONFA_IFINDEX_DEFAULT,</span>
<span class="p_add">+						     net-&gt;ipv6.devconf_dflt);</span>
<span class="p_add">+</span>
 		addrconf_forward_change(net, newf);
 		if ((!newf) ^ (!old))
 			inet6_netconf_notify_devconf(net, NETCONFA_FORWARDING,
<span class="p_chunk">@@ -1679,6 +1686,7 @@</span> <span class="p_context"> void addrconf_dad_failure(struct inet6_ifaddr *ifp)</span>
 	spin_unlock_bh(&amp;ifp-&gt;state_lock);
 
 	addrconf_mod_dad_work(ifp, 0);
<span class="p_add">+	in6_ifa_put(ifp);</span>
 }
 
 /* Join to solicited addr multicast group.
<span class="p_chunk">@@ -3255,6 +3263,7 @@</span> <span class="p_context"> static void addrconf_dad_work(struct work_struct *w)</span>
 		addrconf_dad_begin(ifp);
 		goto out;
 	} else if (action == DAD_ABORT) {
<span class="p_add">+		in6_ifa_hold(ifp);</span>
 		addrconf_dad_stop(ifp, 1);
 		goto out;
 	}
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index 1ee013644bb2..473bb5031af2 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -881,7 +881,6 @@</span> <span class="p_context"> static int ip6gre_xmit_other(struct sk_buff *skb, struct net_device *dev)</span>
 		encap_limit = t-&gt;parms.encap_limit;
 
 	memcpy(&amp;fl6, &amp;t-&gt;fl.u.ip6, sizeof(fl6));
<span class="p_del">-	fl6.flowi6_proto = skb-&gt;protocol;</span>
 
 	err = ip6gre_xmit2(skb, dev, 0, &amp;fl6, encap_limit, &amp;mtu);
 
<span class="p_chunk">@@ -939,6 +938,7 @@</span> <span class="p_context"> static void ip6gre_tnl_link_config(struct ip6_tnl *t, int set_mtu)</span>
 	fl6-&gt;daddr = p-&gt;raddr;
 	fl6-&gt;flowi6_oif = p-&gt;link;
 	fl6-&gt;flowlabel = 0;
<span class="p_add">+	fl6-&gt;flowi6_proto = IPPROTO_GRE;</span>
 
 	if (!(p-&gt;flags&amp;IP6_TNL_F_USE_ORIG_TCLASS))
 		fl6-&gt;flowlabel |= IPV6_TCLASS_MASK &amp; p-&gt;flowinfo;
<span class="p_header">diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c</span>
<span class="p_header">index 5e739bb6ae90..17049f81c750 100644</span>
<span class="p_header">--- a/net/ipv6/ip6mr.c</span>
<span class="p_header">+++ b/net/ipv6/ip6mr.c</span>
<span class="p_chunk">@@ -2272,8 +2272,8 @@</span> <span class="p_context"> static int __ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,</span>
 	return 1;
 }
 
<span class="p_del">-int ip6mr_get_route(struct net *net,</span>
<span class="p_del">-		    struct sk_buff *skb, struct rtmsg *rtm, int nowait)</span>
<span class="p_add">+int ip6mr_get_route(struct net *net, struct sk_buff *skb, struct rtmsg *rtm,</span>
<span class="p_add">+		    int nowait, u32 portid)</span>
 {
 	int err;
 	struct mr6_table *mrt;
<span class="p_chunk">@@ -2318,6 +2318,7 @@</span> <span class="p_context"> int ip6mr_get_route(struct net *net,</span>
 			return -ENOMEM;
 		}
 
<span class="p_add">+		NETLINK_CB(skb2).portid = portid;</span>
 		skb_reset_transport_header(skb2);
 
 		skb_put(skb2, sizeof(struct ipv6hdr));
<span class="p_header">diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c</span>
<span class="p_header">index 9802b2469662..d0fe5a92b2f1 100644</span>
<span class="p_header">--- a/net/ipv6/netfilter/ip6_tables.c</span>
<span class="p_header">+++ b/net/ipv6/netfilter/ip6_tables.c</span>
<span class="p_chunk">@@ -453,7 +453,8 @@</span> <span class="p_context"> ip6t_do_table(struct sk_buff *skb,</span>
    there are loops.  Puts hook bitmask in comefrom. */
 static int
 mark_source_chains(const struct xt_table_info *newinfo,
<span class="p_del">-		   unsigned int valid_hooks, void *entry0)</span>
<span class="p_add">+		   unsigned int valid_hooks, void *entry0,</span>
<span class="p_add">+		   unsigned int *offsets)</span>
 {
 	unsigned int hook;
 
<span class="p_chunk">@@ -546,6 +547,11 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 					/* This a jump; chase it. */
 					duprintf(&quot;Jump rule %u -&gt; %u\n&quot;,
 						 pos, newpos);
<span class="p_add">+					if (!xt_find_jump_offset(offsets, newpos,</span>
<span class="p_add">+								 newinfo-&gt;number))</span>
<span class="p_add">+						return 0;</span>
<span class="p_add">+					e = (struct ip6t_entry *)</span>
<span class="p_add">+						(entry0 + newpos);</span>
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e-&gt;next_offset;
<span class="p_chunk">@@ -792,6 +798,7 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
                 const struct ip6t_replace *repl)
 {
 	struct ip6t_entry *iter;
<span class="p_add">+	unsigned int *offsets;</span>
 	unsigned int i;
 	int ret = 0;
 
<span class="p_chunk">@@ -805,6 +812,9 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
 	}
 
 	duprintf(&quot;translate_table: size %u\n&quot;, newinfo-&gt;size);
<span class="p_add">+	offsets = xt_alloc_entry_offsets(newinfo-&gt;number);</span>
<span class="p_add">+	if (!offsets)</span>
<span class="p_add">+		return -ENOMEM;</span>
 	i = 0;
 	/* Walk through entries, checking offsets. */
 	xt_entry_foreach(iter, entry0, newinfo-&gt;size) {
<span class="p_chunk">@@ -814,17 +824,20 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
 						 repl-&gt;underflow,
 						 repl-&gt;valid_hooks);
 		if (ret != 0)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out_free;</span>
<span class="p_add">+		if (i &lt; repl-&gt;num_entries)</span>
<span class="p_add">+			offsets[i] = (void *)iter - entry0;</span>
 		++i;
 		if (strcmp(ip6t_get_target(iter)-&gt;u.user.name,
 		    XT_ERROR_TARGET) == 0)
 			++newinfo-&gt;stacksize;
 	}
 
<span class="p_add">+	ret = -EINVAL;</span>
 	if (i != repl-&gt;num_entries) {
 		duprintf(&quot;translate_table: %u not %u entries\n&quot;,
 			 i, repl-&gt;num_entries);
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		goto out_free;</span>
 	}
 
 	/* Check hooks all assigned */
<span class="p_chunk">@@ -835,17 +848,20 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
 		if (newinfo-&gt;hook_entry[i] == 0xFFFFFFFF) {
 			duprintf(&quot;Invalid hook entry %u %u\n&quot;,
 				 i, repl-&gt;hook_entry[i]);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			goto out_free;</span>
 		}
 		if (newinfo-&gt;underflow[i] == 0xFFFFFFFF) {
 			duprintf(&quot;Invalid underflow %u %u\n&quot;,
 				 i, repl-&gt;underflow[i]);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			goto out_free;</span>
 		}
 	}
 
<span class="p_del">-	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0))</span>
<span class="p_del">-		return -ELOOP;</span>
<span class="p_add">+	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0, offsets)) {</span>
<span class="p_add">+		ret = -ELOOP;</span>
<span class="p_add">+		goto out_free;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kvfree(offsets);</span>
 
 	/* Finally, each sanity check must pass */
 	i = 0;
<span class="p_chunk">@@ -872,6 +888,9 @@</span> <span class="p_context"> translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,</span>
 	}
 
 	return ret;
<span class="p_add">+ out_free:</span>
<span class="p_add">+	kvfree(offsets);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 4967b50cdf52..889e06626c26 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -2618,7 +2618,9 @@</span> <span class="p_context"> static int rt6_fill_node(struct net *net,</span>
 	if (iif) {
 #ifdef CONFIG_IPV6_MROUTE
 		if (ipv6_addr_is_multicast(&amp;rt-&gt;rt6i_dst.addr)) {
<span class="p_del">-			int err = ip6mr_get_route(net, skb, rtm, nowait);</span>
<span class="p_add">+			int err = ip6mr_get_route(net, skb, rtm, nowait,</span>
<span class="p_add">+						  portid);</span>
<span class="p_add">+</span>
 			if (err &lt;= 0) {
 				if (!nowait) {
 					if (err == 0)
<span class="p_header">diff --git a/net/irda/af_irda.c b/net/irda/af_irda.c</span>
<span class="p_header">index f945293c17f0..a34379892d85 100644</span>
<span class="p_header">--- a/net/irda/af_irda.c</span>
<span class="p_header">+++ b/net/irda/af_irda.c</span>
<span class="p_chunk">@@ -843,7 +843,7 @@</span> <span class="p_context"> static int irda_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	struct sock *sk = sock-&gt;sk;
 	struct irda_sock *new, *self = irda_sk(sk);
 	struct sock *newsk;
<span class="p_del">-	struct sk_buff *skb;</span>
<span class="p_add">+	struct sk_buff *skb = NULL;</span>
 	int err;
 
 	IRDA_DEBUG(2, &quot;%s()\n&quot;, __func__);
<span class="p_chunk">@@ -913,7 +913,6 @@</span> <span class="p_context"> static int irda_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	err = -EPERM; /* value does not seem to make sense. -arnd */
 	if (!new-&gt;tsap) {
 		IRDA_DEBUG(0, &quot;%s(), dup failed!\n&quot;, __func__);
<span class="p_del">-		kfree_skb(skb);</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -932,7 +931,6 @@</span> <span class="p_context"> static int irda_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	/* Clean up the original one to keep it in listen state */
 	irttp_listen(self-&gt;tsap);
 
<span class="p_del">-	kfree_skb(skb);</span>
 	sk-&gt;sk_ack_backlog--;
 
 	newsock-&gt;state = SS_CONNECTED;
<span class="p_chunk">@@ -940,6 +938,7 @@</span> <span class="p_context"> static int irda_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	irda_connect_response(new);
 	err = 0;
 out:
<span class="p_add">+	kfree_skb(skb);</span>
 	release_sock(sk);
 	return err;
 }
<span class="p_chunk">@@ -1037,8 +1036,11 @@</span> <span class="p_context"> static int irda_connect(struct socket *sock, struct sockaddr *uaddr,</span>
 	}
 
 	/* Check if we have opened a local TSAP */
<span class="p_del">-	if (!self-&gt;tsap)</span>
<span class="p_del">-		irda_open_tsap(self, LSAP_ANY, addr-&gt;sir_name);</span>
<span class="p_add">+	if (!self-&gt;tsap) {</span>
<span class="p_add">+		err = irda_open_tsap(self, LSAP_ANY, addr-&gt;sir_name);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+	}</span>
 
 	/* Move to connecting socket, start sending Connect Requests */
 	sock-&gt;state = SS_CONNECTING;
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index 0c6a8f18b0fc..76f4c5c9a466 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -1892,6 +1892,9 @@</span> <span class="p_context"> static __net_exit void l2tp_exit_net(struct net *net)</span>
 		(void)l2tp_tunnel_delete(tunnel);
 	}
 	rcu_read_unlock_bh();
<span class="p_add">+</span>
<span class="p_add">+	flush_workqueue(l2tp_wq);</span>
<span class="p_add">+	rcu_barrier();</span>
 }
 
 static struct pernet_operations l2tp_net_ops = {
<span class="p_header">diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">index b704a9356208..1ae69a4695de 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ppp.c</span>
<span class="p_chunk">@@ -883,10 +883,8 @@</span> <span class="p_context"> static int pppol2tp_getname(struct socket *sock, struct sockaddr *uaddr,</span>
 
 	pls = l2tp_session_priv(session);
 	tunnel = l2tp_sock_to_tunnel(pls-&gt;tunnel_sock);
<span class="p_del">-	if (tunnel == NULL) {</span>
<span class="p_del">-		error = -EBADF;</span>
<span class="p_add">+	if (tunnel == NULL)</span>
 		goto end_put_sess;
<span class="p_del">-	}</span>
 
 	inet = inet_sk(tunnel-&gt;sock);
 	if ((tunnel-&gt;version == 2) &amp;&amp; (tunnel-&gt;sock-&gt;sk_family == AF_INET)) {
<span class="p_chunk">@@ -964,12 +962,11 @@</span> <span class="p_context"> static int pppol2tp_getname(struct socket *sock, struct sockaddr *uaddr,</span>
 	}
 
 	*usockaddr_len = len;
<span class="p_add">+	error = 0;</span>
 
 	sock_put(pls-&gt;tunnel_sock);
 end_put_sess:
 	sock_put(sk);
<span class="p_del">-	error = 0;</span>
<span class="p_del">-</span>
 end:
 	return error;
 }
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index 592f4b152ba8..708bc2074d90 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -1186,7 +1186,7 @@</span> <span class="p_context"> static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)</span>
 
 	/* free all potentially still buffered bcast frames */
 	local-&gt;total_ps_buffered -= skb_queue_len(&amp;sdata-&gt;u.ap.ps.bc_buf);
<span class="p_del">-	skb_queue_purge(&amp;sdata-&gt;u.ap.ps.bc_buf);</span>
<span class="p_add">+	ieee80211_purge_tx_queue(&amp;local-&gt;hw, &amp;sdata-&gt;u.ap.ps.bc_buf);</span>
 
 	mutex_lock(&amp;local-&gt;mtx);
 	ieee80211_vif_copy_chanctx_to_vlans(sdata, true);
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index c344e0bc00b7..ca6131c452b5 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -351,7 +351,7 @@</span> <span class="p_context"> static void purge_old_ps_buffers(struct ieee80211_local *local)</span>
 		skb = skb_dequeue(&amp;ps-&gt;bc_buf);
 		if (skb) {
 			purged++;
<span class="p_del">-			dev_kfree_skb(skb);</span>
<span class="p_add">+			ieee80211_free_txskb(&amp;local-&gt;hw, skb);</span>
 		}
 		total += skb_queue_len(&amp;ps-&gt;bc_buf);
 	}
<span class="p_chunk">@@ -434,7 +434,7 @@</span> <span class="p_context"> ieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)</span>
 	if (skb_queue_len(&amp;ps-&gt;bc_buf) &gt;= AP_MAX_BC_BUFFER) {
 		ps_dbg(tx-&gt;sdata,
 		       &quot;BC TX buffer full - dropping the oldest frame\n&quot;);
<span class="p_del">-		dev_kfree_skb(skb_dequeue(&amp;ps-&gt;bc_buf));</span>
<span class="p_add">+		ieee80211_free_txskb(&amp;tx-&gt;local-&gt;hw, skb_dequeue(&amp;ps-&gt;bc_buf));</span>
 	} else
 		tx-&gt;local-&gt;total_ps_buffered++;
 
<span class="p_chunk">@@ -2989,7 +2989,7 @@</span> <span class="p_context"> ieee80211_get_buffered_bc(struct ieee80211_hw *hw,</span>
 			sdata = IEEE80211_DEV_TO_SUB_IF(skb-&gt;dev);
 		if (!ieee80211_tx_prepare(sdata, &amp;tx, skb))
 			break;
<span class="p_del">-		dev_kfree_skb_any(skb);</span>
<span class="p_add">+		ieee80211_free_txskb(hw, skb);</span>
 	}
 
 	info = IEEE80211_SKB_CB(skb);
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_expect.c b/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_header">index c45186f91cc8..16120a636bd4 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_chunk">@@ -556,7 +556,7 @@</span> <span class="p_context"> static int exp_seq_show(struct seq_file *s, void *v)</span>
 	helper = rcu_dereference(nfct_help(expect-&gt;master)-&gt;helper);
 	if (helper) {
 		seq_printf(s, &quot;%s%s&quot;, expect-&gt;flags ? &quot; &quot; : &quot;&quot;, helper-&gt;name);
<span class="p_del">-		if (helper-&gt;expect_policy[expect-&gt;class].name)</span>
<span class="p_add">+		if (helper-&gt;expect_policy[expect-&gt;class].name[0])</span>
 			seq_printf(s, &quot;/%s&quot;,
 				   helper-&gt;expect_policy[expect-&gt;class].name);
 	}
<span class="p_header">diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">index 7a83e57ad3f1..bd55f0c31795 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_chunk">@@ -985,10 +985,8 @@</span> <span class="p_context"> nfqnl_recv_verdict(struct sock *ctnl, struct sk_buff *skb,</span>
 	struct net *net = sock_net(ctnl);
 	struct nfnl_queue_net *q = nfnl_queue_pernet(net);
 
<span class="p_del">-	queue = instance_lookup(q, queue_num);</span>
<span class="p_del">-	if (!queue)</span>
<span class="p_del">-		queue = verdict_instance_lookup(q, queue_num,</span>
<span class="p_del">-						NETLINK_CB(skb).portid);</span>
<span class="p_add">+	queue = verdict_instance_lookup(q, queue_num,</span>
<span class="p_add">+					NETLINK_CB(skb).portid);</span>
 	if (IS_ERR(queue))
 		return PTR_ERR(queue);
 
<span class="p_header">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span>
<span class="p_header">index 1393af786e15..3ca6db13af92 100644</span>
<span class="p_header">--- a/net/netfilter/x_tables.c</span>
<span class="p_header">+++ b/net/netfilter/x_tables.c</span>
<span class="p_chunk">@@ -721,6 +721,56 @@</span> <span class="p_context"> int xt_check_entry_offsets(const void *base,</span>
 }
 EXPORT_SYMBOL(xt_check_entry_offsets);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * xt_alloc_entry_offsets - allocate array to store rule head offsets</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @size: number of entries</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: NULL or kmalloc&#39;d or vmalloc&#39;d array</span>
<span class="p_add">+ */</span>
<span class="p_add">+unsigned int *xt_alloc_entry_offsets(unsigned int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int *off;</span>
<span class="p_add">+</span>
<span class="p_add">+	off = kcalloc(size, sizeof(unsigned int), GFP_KERNEL | __GFP_NOWARN);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (off)</span>
<span class="p_add">+		return off;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &lt; (SIZE_MAX / sizeof(unsigned int)))</span>
<span class="p_add">+		off = vmalloc(size * sizeof(unsigned int));</span>
<span class="p_add">+</span>
<span class="p_add">+	return off;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(xt_alloc_entry_offsets);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * xt_find_jump_offset - check if target is a valid jump offset</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @offsets: array containing all valid rule start offsets of a rule blob</span>
<span class="p_add">+ * @target: the jump target to search for</span>
<span class="p_add">+ * @size: entries in @offset</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool xt_find_jump_offset(const unsigned int *offsets,</span>
<span class="p_add">+			 unsigned int target, unsigned int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int m, low = 0, hi = size;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (hi &gt; low) {</span>
<span class="p_add">+		m = (low + hi) / 2u;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (offsets[m] &gt; target)</span>
<span class="p_add">+			hi = m;</span>
<span class="p_add">+		else if (offsets[m] &lt; target)</span>
<span class="p_add">+			low = m + 1;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(xt_find_jump_offset);</span>
<span class="p_add">+</span>
 int xt_check_target(struct xt_tgchk_param *par,
 		    unsigned int size, u_int8_t proto, bool inv_proto)
 {
<span class="p_header">diff --git a/net/netlabel/netlabel_kapi.c b/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">index 3045a964f39c..8473d34f2e3a 100644</span>
<span class="p_header">--- a/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">+++ b/net/netlabel/netlabel_kapi.c</span>
<span class="p_chunk">@@ -699,7 +699,11 @@</span> <span class="p_context"> socket_setattr_return:</span>
  */
 void netlbl_sock_delattr(struct sock *sk)
 {
<span class="p_del">-	cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+	switch (sk-&gt;sk_family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -862,7 +866,11 @@</span> <span class="p_context"> req_setattr_return:</span>
 */
 void netlbl_req_delattr(struct request_sock *req)
 {
<span class="p_del">-	cipso_v4_req_delattr(req);</span>
<span class="p_add">+	switch (req-&gt;rsk_ops-&gt;family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_req_delattr(req);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_header">diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c</span>
<span class="p_header">index e1543b03e39d..c0bdd3bce189 100644</span>
<span class="p_header">--- a/net/sched/sch_generic.c</span>
<span class="p_header">+++ b/net/sched/sch_generic.c</span>
<span class="p_chunk">@@ -590,18 +590,19 @@</span> <span class="p_context"> struct Qdisc *qdisc_create_dflt(struct netdev_queue *dev_queue,</span>
 	struct Qdisc *sch;
 
 	if (!try_module_get(ops-&gt;owner))
<span class="p_del">-		goto errout;</span>
<span class="p_add">+		return NULL;</span>
 
 	sch = qdisc_alloc(dev_queue, ops);
<span class="p_del">-	if (IS_ERR(sch))</span>
<span class="p_del">-		goto errout;</span>
<span class="p_add">+	if (IS_ERR(sch)) {</span>
<span class="p_add">+		module_put(ops-&gt;owner);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
 	sch-&gt;parent = parentid;
 
 	if (!ops-&gt;init || ops-&gt;init(sch, NULL) == 0)
 		return sch;
 
 	qdisc_destroy(sch);
<span class="p_del">-errout:</span>
 	return NULL;
 }
 EXPORT_SYMBOL(qdisc_create_dflt);
<span class="p_header">diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c</span>
<span class="p_header">index b6e440baccc3..265be00a4ac5 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/auth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/auth_gss.c</span>
<span class="p_chunk">@@ -326,12 +326,14 @@</span> <span class="p_context"> gss_release_msg(struct gss_upcall_msg *gss_msg)</span>
 }
 
 static struct gss_upcall_msg *
<span class="p_del">-__gss_find_upcall(struct rpc_pipe *pipe, kuid_t uid)</span>
<span class="p_add">+__gss_find_upcall(struct rpc_pipe *pipe, kuid_t uid, const struct gss_auth *auth)</span>
 {
 	struct gss_upcall_msg *pos;
 	list_for_each_entry(pos, &amp;pipe-&gt;in_downcall, list) {
 		if (!uid_eq(pos-&gt;uid, uid))
 			continue;
<span class="p_add">+		if (auth &amp;&amp; pos-&gt;auth-&gt;service != auth-&gt;service)</span>
<span class="p_add">+			continue;</span>
 		atomic_inc(&amp;pos-&gt;count);
 		dprintk(&quot;RPC:       %s found msg %p\n&quot;, __func__, pos);
 		return pos;
<span class="p_chunk">@@ -351,7 +353,7 @@</span> <span class="p_context"> gss_add_msg(struct gss_upcall_msg *gss_msg)</span>
 	struct gss_upcall_msg *old;
 
 	spin_lock(&amp;pipe-&gt;lock);
<span class="p_del">-	old = __gss_find_upcall(pipe, gss_msg-&gt;uid);</span>
<span class="p_add">+	old = __gss_find_upcall(pipe, gss_msg-&gt;uid, gss_msg-&gt;auth);</span>
 	if (old == NULL) {
 		atomic_inc(&amp;gss_msg-&gt;count);
 		list_add(&amp;gss_msg-&gt;list, &amp;pipe-&gt;in_downcall);
<span class="p_chunk">@@ -700,7 +702,7 @@</span> <span class="p_context"> gss_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)</span>
 	err = -ENOENT;
 	/* Find a matching upcall */
 	spin_lock(&amp;pipe-&gt;lock);
<span class="p_del">-	gss_msg = __gss_find_upcall(pipe, uid);</span>
<span class="p_add">+	gss_msg = __gss_find_upcall(pipe, uid, NULL);</span>
 	if (gss_msg == NULL) {
 		spin_unlock(&amp;pipe-&gt;lock);
 		goto err_put_ctx;
<span class="p_header">diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c</span>
<span class="p_header">index 78c809c1f819..a7e5624a1cf2 100644</span>
<span class="p_header">--- a/net/sunrpc/svc.c</span>
<span class="p_header">+++ b/net/sunrpc/svc.c</span>
<span class="p_chunk">@@ -1189,11 +1189,16 @@</span> <span class="p_context"> svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)</span>
 		*statp = procp-&gt;pc_func(rqstp, rqstp-&gt;rq_argp, rqstp-&gt;rq_resp);
 
 		/* Encode reply */
<span class="p_del">-		if (rqstp-&gt;rq_dropme) {</span>
<span class="p_add">+		if (*statp == rpc_drop_reply || rqstp-&gt;rq_dropme) {</span>
 			if (procp-&gt;pc_release)
 				procp-&gt;pc_release(rqstp, NULL, rqstp-&gt;rq_resp);
 			goto dropit;
 		}
<span class="p_add">+		if (*statp == rpc_autherr_badcred) {</span>
<span class="p_add">+			if (procp-&gt;pc_release)</span>
<span class="p_add">+				procp-&gt;pc_release(rqstp, NULL, rqstp-&gt;rq_resp);</span>
<span class="p_add">+			goto err_bad_auth;</span>
<span class="p_add">+		}</span>
 		if (*statp == rpc_success &amp;&amp;
 		    (xdr = procp-&gt;pc_encode) &amp;&amp;
 		    !xdr(rqstp, resv-&gt;iov_base+resv-&gt;iov_len, rqstp-&gt;rq_resp)) {
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 56918f89a1d6..d4fb275c4c20 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -5980,7 +5980,7 @@</span> <span class="p_context"> static int nl80211_channel_switch(struct sk_buff *skb, struct genl_info *info)</span>
 
 		params.n_counter_offsets_presp = len / sizeof(u16);
 		if (rdev-&gt;wiphy.max_num_csa_counters &amp;&amp;
<span class="p_del">-		    (params.n_counter_offsets_beacon &gt;</span>
<span class="p_add">+		    (params.n_counter_offsets_presp &gt;</span>
 		     rdev-&gt;wiphy.max_num_csa_counters))
 			return -EINVAL;
 
<span class="p_header">diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c</span>
<span class="p_header">index 86f381b09d8d..725cf243860c 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_state.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_state.c</span>
<span class="p_chunk">@@ -339,6 +339,7 @@</span> <span class="p_context"> static void xfrm_state_gc_destroy(struct xfrm_state *x)</span>
 {
 	tasklet_hrtimer_cancel(&amp;x-&gt;mtimer);
 	del_timer_sync(&amp;x-&gt;rtimer);
<span class="p_add">+	kfree(x-&gt;aead);</span>
 	kfree(x-&gt;aalg);
 	kfree(x-&gt;ealg);
 	kfree(x-&gt;calg);
<span class="p_header">diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c</span>
<span class="p_header">index d4db6ebb089d..8059e412c9f3 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_user.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_user.c</span>
<span class="p_chunk">@@ -559,9 +559,12 @@</span> <span class="p_context"> static struct xfrm_state *xfrm_state_construct(struct net *net,</span>
 	if (err)
 		goto error;
 
<span class="p_del">-	if (attrs[XFRMA_SEC_CTX] &amp;&amp;</span>
<span class="p_del">-	    security_xfrm_state_alloc(x, nla_data(attrs[XFRMA_SEC_CTX])))</span>
<span class="p_del">-		goto error;</span>
<span class="p_add">+	if (attrs[XFRMA_SEC_CTX]) {</span>
<span class="p_add">+		err = security_xfrm_state_alloc(x,</span>
<span class="p_add">+						nla_data(attrs[XFRMA_SEC_CTX]));</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+	}</span>
 
 	if ((err = xfrm_alloc_replay_state_esn(&amp;x-&gt;replay_esn, &amp;x-&gt;preplay_esn,
 					       attrs[XFRMA_REPLAY_ESN_VAL])))
<span class="p_chunk">@@ -869,7 +872,8 @@</span> <span class="p_context"> static int xfrm_dump_sa_done(struct netlink_callback *cb)</span>
 	struct sock *sk = cb-&gt;skb-&gt;sk;
 	struct net *net = sock_net(sk);
 
<span class="p_del">-	xfrm_state_walk_done(walk, net);</span>
<span class="p_add">+	if (cb-&gt;args[0])</span>
<span class="p_add">+		xfrm_state_walk_done(walk, net);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -894,8 +898,6 @@</span> <span class="p_context"> static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)</span>
 		u8 proto = 0;
 		int err;
 
<span class="p_del">-		cb-&gt;args[0] = 1;</span>
<span class="p_del">-</span>
 		err = nlmsg_parse(cb-&gt;nlh, 0, attrs, XFRMA_MAX,
 				  xfrma_policy);
 		if (err &lt; 0)
<span class="p_chunk">@@ -914,6 +916,7 @@</span> <span class="p_context"> static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)</span>
 			proto = nla_get_u8(attrs[XFRMA_PROTO]);
 
 		xfrm_state_walk_init(walk, proto, filter);
<span class="p_add">+		cb-&gt;args[0] = 1;</span>
 	}
 
 	(void) xfrm_state_walk(net, walk, dump_one_state, &amp;info);
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index 56f497b27c49..a97ae04f5d2a 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -33,10 +33,17 @@</span> <span class="p_context"></span>
 #include &lt;string.h&gt;
 #include &lt;unistd.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * glibc synced up and added the metag number but didn&#39;t add the relocations.</span>
<span class="p_add">+ * Work around this in a crude manner for now.</span>
<span class="p_add">+ */</span>
 #ifndef EM_METAG
<span class="p_del">-/* Remove this when these make it to the standard system elf.h. */</span>
 #define EM_METAG      174
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef R_METAG_ADDR32</span>
 #define R_METAG_ADDR32                   2
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef R_METAG_NONE</span>
 #define R_METAG_NONE                     3
 #endif
 
<span class="p_header">diff --git a/security/keys/proc.c b/security/keys/proc.c</span>
<span class="p_header">index d3f6f2fd21db..62a86e8cb907 100644</span>
<span class="p_header">--- a/security/keys/proc.c</span>
<span class="p_header">+++ b/security/keys/proc.c</span>
<span class="p_chunk">@@ -187,7 +187,7 @@</span> <span class="p_context"> static int proc_keys_show(struct seq_file *m, void *v)</span>
 	struct timespec now;
 	unsigned long timo;
 	key_ref_t key_ref, skey_ref;
<span class="p_del">-	char xbuf[12];</span>
<span class="p_add">+	char xbuf[16];</span>
 	int rc;
 
 	struct keyring_search_context ctx = {
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 1d395d865f1b..665020b7c82e 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -150,6 +150,8 @@</span> <span class="p_context"> void snd_ctl_notify(struct snd_card *card, unsigned int mask,</span>
 	
 	if (snd_BUG_ON(!card || !id))
 		return;
<span class="p_add">+	if (card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
 	read_lock(&amp;card-&gt;ctl_files_rwlock);
 #if IS_ENABLED(CONFIG_SND_MIXER_OSS)
 	card-&gt;mixer_oss_change_count++;
<span class="p_header">diff --git a/sound/core/pcm.c b/sound/core/pcm.c</span>
<span class="p_header">index 43932e8dce66..2c9dc3106340 100644</span>
<span class="p_header">--- a/sound/core/pcm.c</span>
<span class="p_header">+++ b/sound/core/pcm.c</span>
<span class="p_chunk">@@ -806,6 +806,14 @@</span> <span class="p_context"> int snd_pcm_new_internal(struct snd_card *card, const char *id, int device,</span>
 }
 EXPORT_SYMBOL(snd_pcm_new_internal);
 
<span class="p_add">+static void free_chmap(struct snd_pcm_str *pstr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pstr-&gt;chmap_kctl) {</span>
<span class="p_add">+		snd_ctl_remove(pstr-&gt;pcm-&gt;card, pstr-&gt;chmap_kctl);</span>
<span class="p_add">+		pstr-&gt;chmap_kctl = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 {
 	struct snd_pcm_substream *substream, *substream_next;
<span class="p_chunk">@@ -828,6 +836,7 @@</span> <span class="p_context"> static void snd_pcm_free_stream(struct snd_pcm_str * pstr)</span>
 		kfree(setup);
 	}
 #endif
<span class="p_add">+	free_chmap(pstr);</span>
 }
 
 static int snd_pcm_free(struct snd_pcm *pcm)
<span class="p_chunk">@@ -1142,10 +1151,7 @@</span> <span class="p_context"> static int snd_pcm_dev_disconnect(struct snd_device *device)</span>
 			break;
 		}
 		snd_unregister_device(devtype, pcm-&gt;card, pcm-&gt;device);
<span class="p_del">-		if (pcm-&gt;streams[cidx].chmap_kctl) {</span>
<span class="p_del">-			snd_ctl_remove(pcm-&gt;card, pcm-&gt;streams[cidx].chmap_kctl);</span>
<span class="p_del">-			pcm-&gt;streams[cidx].chmap_kctl = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		free_chmap(&amp;pcm-&gt;streams[cidx]);</span>
 	}
 	mutex_unlock(&amp;pcm-&gt;open_mutex);
  unlock:
<span class="p_header">diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c</span>
<span class="p_header">index 857741431fc6..b5c88e08f3fe 100644</span>
<span class="p_header">--- a/sound/core/rawmidi.c</span>
<span class="p_header">+++ b/sound/core/rawmidi.c</span>
<span class="p_chunk">@@ -1637,12 +1637,14 @@</span> <span class="p_context"> static int snd_rawmidi_dev_register(struct snd_device *device)</span>
 		return -EBUSY;
 	}
 	list_add_tail(&amp;rmidi-&gt;list, &amp;snd_rawmidi_devices);
<span class="p_add">+	mutex_unlock(&amp;register_mutex);</span>
 	sprintf(name, &quot;midiC%iD%i&quot;, rmidi-&gt;card-&gt;number, rmidi-&gt;device);
 	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_RAWMIDI,
 				       rmidi-&gt;card, rmidi-&gt;device,
 				       &amp;snd_rawmidi_f_ops, rmidi, name)) &lt; 0) {
 		rmidi_err(rmidi, &quot;unable to register rawmidi device %i:%i\n&quot;,
 			  rmidi-&gt;card-&gt;number, rmidi-&gt;device);
<span class="p_add">+		mutex_lock(&amp;register_mutex);</span>
 		list_del(&amp;rmidi-&gt;list);
 		mutex_unlock(&amp;register_mutex);
 		return err;
<span class="p_chunk">@@ -1650,6 +1652,7 @@</span> <span class="p_context"> static int snd_rawmidi_dev_register(struct snd_device *device)</span>
 	if (rmidi-&gt;ops &amp;&amp; rmidi-&gt;ops-&gt;dev_register &amp;&amp;
 	    (err = rmidi-&gt;ops-&gt;dev_register(rmidi)) &lt; 0) {
 		snd_unregister_device(SNDRV_DEVICE_TYPE_RAWMIDI, rmidi-&gt;card, rmidi-&gt;device);
<span class="p_add">+		mutex_lock(&amp;register_mutex);</span>
 		list_del(&amp;rmidi-&gt;list);
 		mutex_unlock(&amp;register_mutex);
 		return err;
<span class="p_chunk">@@ -1682,7 +1685,6 @@</span> <span class="p_context"> static int snd_rawmidi_dev_register(struct snd_device *device)</span>
 		}
 	}
 #endif /* CONFIG_SND_OSSEMUL */
<span class="p_del">-	mutex_unlock(&amp;register_mutex);</span>
 	sprintf(name, &quot;midi%d&quot;, rmidi-&gt;device);
 	entry = snd_info_create_card_entry(rmidi-&gt;card, name, rmidi-&gt;card-&gt;proc_root);
 	if (entry) {
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index cdc22503fdb8..d32c631cca6b 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -35,6 +35,9 @@</span> <span class="p_context"></span>
 #include &lt;sound/initval.h&gt;
 #include &lt;linux/kmod.h&gt;
 
<span class="p_add">+/* internal flags */</span>
<span class="p_add">+#define SNDRV_TIMER_IFLG_PAUSED		0x00010000</span>
<span class="p_add">+</span>
 #if IS_ENABLED(CONFIG_SND_HRTIMER)
 #define DEFAULT_TIMER_LIMIT 4
 #elif IS_ENABLED(CONFIG_SND_RTCTIMER)
<span class="p_chunk">@@ -296,8 +299,21 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 		get_device(&amp;timer-&gt;card-&gt;card_dev);
 	timeri-&gt;slave_class = tid-&gt;dev_sclass;
 	timeri-&gt;slave_id = slave_id;
<span class="p_del">-	if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp; timer-&gt;hw.open)</span>
<span class="p_del">-		timer-&gt;hw.open(timer);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp; timer-&gt;hw.open) {</span>
<span class="p_add">+		int err = timer-&gt;hw.open(timer);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			kfree(timeri-&gt;owner);</span>
<span class="p_add">+			kfree(timeri);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (timer-&gt;card)</span>
<span class="p_add">+				put_device(&amp;timer-&gt;card-&gt;card_dev);</span>
<span class="p_add">+			module_put(timer-&gt;module);</span>
<span class="p_add">+			mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	list_add_tail(&amp;timeri-&gt;open_list, &amp;timer-&gt;open_list_head);
 	snd_timer_check_master(timeri);
 	mutex_unlock(&amp;register_mutex);
<span class="p_chunk">@@ -556,6 +572,10 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)</span>
 		}
 	}
 	timeri-&gt;flags &amp;= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);
<span class="p_add">+	if (event == SNDRV_TIMER_EVENT_STOP)</span>
<span class="p_add">+		timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_PAUSED;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		timeri-&gt;flags |= SNDRV_TIMER_IFLG_PAUSED;</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
       __end:
 	if (event != SNDRV_TIMER_EVENT_RESOLUTION)
<span class="p_chunk">@@ -598,6 +618,10 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
 
 	if (timeri == NULL)
 		return result;
<span class="p_add">+	/* timer can continue only after pause */</span>
<span class="p_add">+	if (!(timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_PAUSED))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE)
 		return snd_timer_start_slave(timeri);
 	timer = timeri-&gt;timer;
<span class="p_chunk">@@ -839,6 +863,7 @@</span> <span class="p_context"> int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,</span>
 	timer-&gt;tmr_subdevice = tid-&gt;subdevice;
 	if (id)
 		strlcpy(timer-&gt;id, id, sizeof(timer-&gt;id));
<span class="p_add">+	timer-&gt;sticks = 1;</span>
 	INIT_LIST_HEAD(&amp;timer-&gt;device_list);
 	INIT_LIST_HEAD(&amp;timer-&gt;open_list_head);
 	INIT_LIST_HEAD(&amp;timer-&gt;active_list_head);
<span class="p_chunk">@@ -1830,6 +1855,9 @@</span> <span class="p_context"> static int snd_timer_user_continue(struct file *file)</span>
 	tu = file-&gt;private_data;
 	if (!tu-&gt;timeri)
 		return -EBADFD;
<span class="p_add">+	/* start timer instead of continue if it&#39;s not used before */</span>
<span class="p_add">+	if (!(tu-&gt;timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_PAUSED))</span>
<span class="p_add">+		return snd_timer_user_start(file);</span>
 	tu-&gt;timeri-&gt;lost = 0;
 	return (err = snd_timer_continue(tu-&gt;timeri)) &lt; 0 ? err : 0;
 }
<span class="p_chunk">@@ -1971,6 +1999,7 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 		tu-&gt;qused--;
 		spin_unlock_irq(&amp;tu-&gt;qlock);
 
<span class="p_add">+		mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
 		if (tu-&gt;tread) {
 			if (copy_to_user(buffer, &amp;tu-&gt;tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
<span class="p_chunk">@@ -1980,6 +2009,7 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
 		}
<span class="p_add">+		mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
 
 		spin_lock_irq(&amp;tu-&gt;qlock);
 		if (err &lt; 0)
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks.h b/sound/firewire/fireworks/fireworks.h</span>
<span class="p_header">index 084d414b228c..b431c34b2d74 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks.h</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks.h</span>
<span class="p_chunk">@@ -106,7 +106,6 @@</span> <span class="p_context"> struct snd_efw {</span>
 	u8 *resp_buf;
 	u8 *pull_ptr;
 	u8 *push_ptr;
<span class="p_del">-	unsigned int resp_queues;</span>
 };
 
 int snd_efw_transaction_cmd(struct fw_unit *unit,
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks_hwdep.c b/sound/firewire/fireworks/fireworks_hwdep.c</span>
<span class="p_header">index 33df8655fe81..2e1d9a23920c 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks_hwdep.c</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks_hwdep.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"> hwdep_read_resp_buf(struct snd_efw *efw, char __user *buf, long remained,</span>
 {
 	unsigned int length, till_end, type;
 	struct snd_efw_transaction *t;
<span class="p_add">+	u8 *pull_ptr;</span>
 	long count = 0;
 
 	if (remained &lt; sizeof(type) + sizeof(struct snd_efw_transaction))
<span class="p_chunk">@@ -38,8 +39,17 @@</span> <span class="p_context"> hwdep_read_resp_buf(struct snd_efw *efw, char __user *buf, long remained,</span>
 	buf += sizeof(type);
 
 	/* write into buffer as many responses as possible */
<span class="p_del">-	while (efw-&gt;resp_queues &gt; 0) {</span>
<span class="p_del">-		t = (struct snd_efw_transaction *)(efw-&gt;pull_ptr);</span>
<span class="p_add">+	spin_lock_irq(&amp;efw-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When another task reaches here during this task&#39;s access to user</span>
<span class="p_add">+	 * space, it picks up current position in buffer and can read the same</span>
<span class="p_add">+	 * series of responses.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pull_ptr = efw-&gt;pull_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (efw-&gt;push_ptr != pull_ptr) {</span>
<span class="p_add">+		t = (struct snd_efw_transaction *)(pull_ptr);</span>
 		length = be32_to_cpu(t-&gt;length) * sizeof(__be32);
 
 		/* confirm enough space for this response */
<span class="p_chunk">@@ -49,26 +59,39 @@</span> <span class="p_context"> hwdep_read_resp_buf(struct snd_efw *efw, char __user *buf, long remained,</span>
 		/* copy from ring buffer to user buffer */
 		while (length &gt; 0) {
 			till_end = snd_efw_resp_buf_size -
<span class="p_del">-				(unsigned int)(efw-&gt;pull_ptr - efw-&gt;resp_buf);</span>
<span class="p_add">+				(unsigned int)(pull_ptr - efw-&gt;resp_buf);</span>
 			till_end = min_t(unsigned int, length, till_end);
 
<span class="p_del">-			if (copy_to_user(buf, efw-&gt;pull_ptr, till_end))</span>
<span class="p_add">+			spin_unlock_irq(&amp;efw-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (copy_to_user(buf, pull_ptr, till_end))</span>
 				return -EFAULT;
 
<span class="p_del">-			efw-&gt;pull_ptr += till_end;</span>
<span class="p_del">-			if (efw-&gt;pull_ptr &gt;= efw-&gt;resp_buf +</span>
<span class="p_del">-					     snd_efw_resp_buf_size)</span>
<span class="p_del">-				efw-&gt;pull_ptr -= snd_efw_resp_buf_size;</span>
<span class="p_add">+			spin_lock_irq(&amp;efw-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+			pull_ptr += till_end;</span>
<span class="p_add">+			if (pull_ptr &gt;= efw-&gt;resp_buf + snd_efw_resp_buf_size)</span>
<span class="p_add">+				pull_ptr -= snd_efw_resp_buf_size;</span>
 
 			length -= till_end;
 			buf += till_end;
 			count += till_end;
 			remained -= till_end;
 		}
<span class="p_del">-</span>
<span class="p_del">-		efw-&gt;resp_queues--;</span>
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * All of tasks can read from the buffer nearly simultaneously, but the</span>
<span class="p_add">+	 * last position for each task is different depending on the length of</span>
<span class="p_add">+	 * given buffer. Here, for simplicity, a position of buffer is set by</span>
<span class="p_add">+	 * the latest task. It&#39;s better for a listening application to allow one</span>
<span class="p_add">+	 * thread to read from the buffer. Unless, each task can read different</span>
<span class="p_add">+	 * sequence of responses depending on variation of buffer length.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	efw-&gt;pull_ptr = pull_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irq(&amp;efw-&gt;lock);</span>
<span class="p_add">+</span>
 	return count;
 }
 
<span class="p_chunk">@@ -76,14 +99,17 @@</span> <span class="p_context"> static long</span>
 hwdep_read_locked(struct snd_efw *efw, char __user *buf, long count,
 		  loff_t *offset)
 {
<span class="p_del">-	union snd_firewire_event event;</span>
<span class="p_add">+	union snd_firewire_event event = {</span>
<span class="p_add">+		.lock_status.type = SNDRV_FIREWIRE_EVENT_LOCK_STATUS,</span>
<span class="p_add">+	};</span>
 
<span class="p_del">-	memset(&amp;event, 0, sizeof(event));</span>
<span class="p_add">+	spin_lock_irq(&amp;efw-&gt;lock);</span>
 
<span class="p_del">-	event.lock_status.type = SNDRV_FIREWIRE_EVENT_LOCK_STATUS;</span>
 	event.lock_status.status = (efw-&gt;dev_lock_count &gt; 0);
 	efw-&gt;dev_lock_changed = false;
 
<span class="p_add">+	spin_unlock_irq(&amp;efw-&gt;lock);</span>
<span class="p_add">+</span>
 	count = min_t(long, count, sizeof(event.lock_status));
 
 	if (copy_to_user(buf, &amp;event, count))
<span class="p_chunk">@@ -98,10 +124,15 @@</span> <span class="p_context"> hwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,</span>
 {
 	struct snd_efw *efw = hwdep-&gt;private_data;
 	DEFINE_WAIT(wait);
<span class="p_add">+	bool dev_lock_changed;</span>
<span class="p_add">+	bool queued;</span>
 
 	spin_lock_irq(&amp;efw-&gt;lock);
 
<span class="p_del">-	while ((!efw-&gt;dev_lock_changed) &amp;&amp; (efw-&gt;resp_queues == 0)) {</span>
<span class="p_add">+	dev_lock_changed = efw-&gt;dev_lock_changed;</span>
<span class="p_add">+	queued = efw-&gt;push_ptr != efw-&gt;pull_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!dev_lock_changed &amp;&amp; !queued) {</span>
 		prepare_to_wait(&amp;efw-&gt;hwdep_wait, &amp;wait, TASK_INTERRUPTIBLE);
 		spin_unlock_irq(&amp;efw-&gt;lock);
 		schedule();
<span class="p_chunk">@@ -109,15 +140,17 @@</span> <span class="p_context"> hwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,</span>
 		if (signal_pending(current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&amp;efw-&gt;lock);
<span class="p_add">+		dev_lock_changed = efw-&gt;dev_lock_changed;</span>
<span class="p_add">+		queued = efw-&gt;push_ptr != efw-&gt;pull_ptr;</span>
 	}
 
<span class="p_del">-	if (efw-&gt;dev_lock_changed)</span>
<span class="p_add">+	spin_unlock_irq(&amp;efw-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev_lock_changed)</span>
 		count = hwdep_read_locked(efw, buf, count, offset);
<span class="p_del">-	else if (efw-&gt;resp_queues &gt; 0)</span>
<span class="p_add">+	else if (queued)</span>
 		count = hwdep_read_resp_buf(efw, buf, count, offset);
 
<span class="p_del">-	spin_unlock_irq(&amp;efw-&gt;lock);</span>
<span class="p_del">-</span>
 	return count;
 }
 
<span class="p_chunk">@@ -160,7 +193,7 @@</span> <span class="p_context"> hwdep_poll(struct snd_hwdep *hwdep, struct file *file, poll_table *wait)</span>
 	poll_wait(file, &amp;efw-&gt;hwdep_wait, wait);
 
 	spin_lock_irq(&amp;efw-&gt;lock);
<span class="p_del">-	if (efw-&gt;dev_lock_changed || (efw-&gt;resp_queues &gt; 0))</span>
<span class="p_add">+	if (efw-&gt;dev_lock_changed || efw-&gt;pull_ptr != efw-&gt;push_ptr)</span>
 		events = POLLIN | POLLRDNORM;
 	else
 		events = 0;
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c</span>
<span class="p_header">index f29d4aaf56a1..5b3753b05006 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks_proc.c</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks_proc.c</span>
<span class="p_chunk">@@ -188,8 +188,8 @@</span> <span class="p_context"> proc_read_queues_state(struct snd_info_entry *entry,</span>
 	else
 		consumed = (unsigned int)(efw-&gt;push_ptr - efw-&gt;pull_ptr);
 
<span class="p_del">-	snd_iprintf(buffer, &quot;%d %d/%d\n&quot;,</span>
<span class="p_del">-		    efw-&gt;resp_queues, consumed, snd_efw_resp_buf_size);</span>
<span class="p_add">+	snd_iprintf(buffer, &quot;%d/%d\n&quot;,</span>
<span class="p_add">+		    consumed, snd_efw_resp_buf_size);</span>
 }
 
 static void
<span class="p_header">diff --git a/sound/firewire/fireworks/fireworks_transaction.c b/sound/firewire/fireworks/fireworks_transaction.c</span>
<span class="p_header">index 2a85e4209f0b..8e9abbb6b68c 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/fireworks_transaction.c</span>
<span class="p_header">+++ b/sound/firewire/fireworks/fireworks_transaction.c</span>
<span class="p_chunk">@@ -121,11 +121,11 @@</span> <span class="p_context"> copy_resp_to_buf(struct snd_efw *efw, void *data, size_t length, int *rcode)</span>
 	size_t capacity, till_end;
 	struct snd_efw_transaction *t;
 
<span class="p_del">-	spin_lock_irq(&amp;efw-&gt;lock);</span>
<span class="p_del">-</span>
 	t = (struct snd_efw_transaction *)data;
 	length = min_t(size_t, be32_to_cpu(t-&gt;length) * sizeof(u32), length);
 
<span class="p_add">+	spin_lock_irq(&amp;efw-&gt;lock);</span>
<span class="p_add">+</span>
 	if (efw-&gt;push_ptr &lt; efw-&gt;pull_ptr)
 		capacity = (unsigned int)(efw-&gt;pull_ptr - efw-&gt;push_ptr);
 	else
<span class="p_chunk">@@ -155,7 +155,6 @@</span> <span class="p_context"> copy_resp_to_buf(struct snd_efw *efw, void *data, size_t length, int *rcode)</span>
 	}
 
 	/* for hwdep */
<span class="p_del">-	efw-&gt;resp_queues++;</span>
 	wake_up(&amp;efw-&gt;hwdep_wait);
 
 	*rcode = RCODE_COMPLETE;
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c</span>
<span class="p_header">index 68bea67c3ca3..22b7038cff0d 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.c</span>
<span class="p_chunk">@@ -5793,13 +5793,15 @@</span> <span class="p_context"> void *snd_array_new(struct snd_array *array)</span>
 		return NULL;
 	if (array-&gt;used &gt;= array-&gt;alloced) {
 		int num = array-&gt;alloced + array-&gt;alloc_align;
<span class="p_add">+		int oldsize = array-&gt;alloced * array-&gt;elem_size;</span>
 		int size = (num + 1) * array-&gt;elem_size;
 		void *nlist;
 		if (snd_BUG_ON(num &gt;= 4096))
 			return NULL;
<span class="p_del">-		nlist = krealloc(array-&gt;list, size, GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_add">+		nlist = krealloc(array-&gt;list, size, GFP_KERNEL);</span>
 		if (!nlist)
 			return NULL;
<span class="p_add">+		memset(nlist + oldsize, 0, size - oldsize);</span>
 		array-&gt;list = nlist;
 		array-&gt;alloced = num;
 	}
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 2f523b08f576..8ff15d834ace 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -950,8 +950,10 @@</span> <span class="p_context"> static int azx_free(struct azx *chip)</span>
 	if (use_vga_switcheroo(chip)) {
 		if (chip-&gt;disabled &amp;&amp; chip-&gt;bus)
 			snd_hda_unlock_devices(chip-&gt;bus);
<span class="p_del">-		if (chip-&gt;vga_switcheroo_registered)</span>
<span class="p_add">+		if (chip-&gt;vga_switcheroo_registered) {</span>
 			vga_switcheroo_unregister_client(chip-&gt;pci);
<span class="p_add">+			vga_switcheroo_fini_domain_pm_ops(chip-&gt;card-&gt;dev);</span>
<span class="p_add">+		}</span>
 	}
 
 	if (chip-&gt;initialized) {
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 4dd1538c1257..187d33729b50 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5837,6 +5837,7 @@</span> <span class="p_context"> enum {</span>
 	ALC668_FIXUP_DELL_XPS13,
 	ALC662_FIXUP_ASUS_Nx50,
 	ALC668_FIXUP_ASUS_Nx51,
<span class="p_add">+	ALC662_FIXUP_ACER_VERITON,</span>
 };
 
 static const struct hda_fixup alc662_fixups[] = {
<span class="p_chunk">@@ -6078,6 +6079,13 @@</span> <span class="p_context"> static const struct hda_fixup alc662_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC662_FIXUP_BASS_CHMAP,
 	},
<span class="p_add">+	[ALC662_FIXUP_ACER_VERITON] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x15, 0x50170120 }, /* no internal speaker */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		}</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc662_fixup_tbl[] = {
<span class="p_chunk">@@ -6113,6 +6121,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x38af, &quot;Lenovo Ideapad Y550P&quot;, ALC662_FIXUP_IDEAPAD),
 	SND_PCI_QUIRK(0x17aa, 0x3a0d, &quot;Lenovo Ideapad Y550&quot;, ALC662_FIXUP_IDEAPAD),
 	SND_PCI_QUIRK(0x19da, 0xa130, &quot;Zotac Z68&quot;, ALC662_FIXUP_ZOTAC_Z68),
<span class="p_add">+	SND_PCI_QUIRK(0x1b0a, 0x01b8, &quot;ACER Veriton&quot;, ALC662_FIXUP_ACER_VERITON),</span>
 	SND_PCI_QUIRK(0x1b35, 0x2206, &quot;CZC P10T&quot;, ALC662_FIXUP_CZC_P10T),
 
 #if 0
<span class="p_header">diff --git a/sound/soc/omap/omap-mcpdm.c b/sound/soc/omap/omap-mcpdm.c</span>
<span class="p_header">index f0e2ebeab02b..301acfe5aab7 100644</span>
<span class="p_header">--- a/sound/soc/omap/omap-mcpdm.c</span>
<span class="p_header">+++ b/sound/soc/omap/omap-mcpdm.c</span>
<span class="p_chunk">@@ -390,8 +390,8 @@</span> <span class="p_context"> static int omap_mcpdm_probe(struct snd_soc_dai *dai)</span>
 	pm_runtime_get_sync(mcpdm-&gt;dev);
 	omap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, 0x00);
 
<span class="p_del">-	ret = devm_request_irq(mcpdm-&gt;dev, mcpdm-&gt;irq, omap_mcpdm_irq_handler,</span>
<span class="p_del">-				0, &quot;McPDM&quot;, (void *)mcpdm);</span>
<span class="p_add">+	ret = request_irq(mcpdm-&gt;irq, omap_mcpdm_irq_handler, 0, &quot;McPDM&quot;,</span>
<span class="p_add">+			  (void *)mcpdm);</span>
 
 	pm_runtime_put_sync(mcpdm-&gt;dev);
 
<span class="p_chunk">@@ -416,6 +416,7 @@</span> <span class="p_context"> static int omap_mcpdm_remove(struct snd_soc_dai *dai)</span>
 {
 	struct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);
 
<span class="p_add">+	free_irq(mcpdm-&gt;irq, (void *)mcpdm);</span>
 	pm_runtime_disable(mcpdm-&gt;dev);
 
 	return 0;
<span class="p_header">diff --git a/tools/vm/slabinfo.c b/tools/vm/slabinfo.c</span>
<span class="p_header">index 808d5a9d5dcf..bcc6125657e5 100644</span>
<span class="p_header">--- a/tools/vm/slabinfo.c</span>
<span class="p_header">+++ b/tools/vm/slabinfo.c</span>
<span class="p_chunk">@@ -493,10 +493,11 @@</span> <span class="p_context"> static void slab_stats(struct slabinfo *s)</span>
 			s-&gt;alloc_node_mismatch, (s-&gt;alloc_node_mismatch * 100) / total);
 	}
 
<span class="p_del">-	if (s-&gt;cmpxchg_double_fail || s-&gt;cmpxchg_double_cpu_fail)</span>
<span class="p_add">+	if (s-&gt;cmpxchg_double_fail || s-&gt;cmpxchg_double_cpu_fail) {</span>
 		printf(&quot;\nCmpxchg_double Looping\n------------------------\n&quot;);
 		printf(&quot;Locked Cmpxchg Double redos   %lu\nUnlocked Cmpxchg Double redos %lu\n&quot;,
 			s-&gt;cmpxchg_double_fail, s-&gt;cmpxchg_double_cpu_fail);
<span class="p_add">+	}</span>
 }
 
 static void report(struct slabinfo *s)
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index a63127acc67d..6103f9238774 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -137,6 +137,7 @@</span> <span class="p_context"> int vcpu_load(struct kvm_vcpu *vcpu)</span>
 	put_cpu();
 	return 0;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(vcpu_load);</span>
 
 void vcpu_put(struct kvm_vcpu *vcpu)
 {
<span class="p_chunk">@@ -146,6 +147,7 @@</span> <span class="p_context"> void vcpu_put(struct kvm_vcpu *vcpu)</span>
 	preempt_enable();
 	mutex_unlock(&amp;vcpu-&gt;mutex);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(vcpu_put);</span>
 
 static void ack_flush(void *_completed)
 {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



