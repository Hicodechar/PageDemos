
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.13.4 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.13.4</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 28, 2017, 8:33 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170928083310.GB11022@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9975509/mbox/"
   >mbox</a>
|
   <a href="/patch/9975509/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9975509/">/patch/9975509/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	3BB796037E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 Sep 2017 08:33:32 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 076EB29503
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 Sep 2017 08:33:32 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id EF3D42950A; Thu, 28 Sep 2017 08:33:31 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-4.5 required=2.0 tests=BAD_CREDIT,BAYES_00,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7971E29503
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 Sep 2017 08:33:24 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752653AbdI1IdV (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 28 Sep 2017 04:33:21 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:56244 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751776AbdI1IdO (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 28 Sep 2017 04:33:14 -0400
Received: from localhost (unknown [195.81.232.10])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 86C358FF;
	Thu, 28 Sep 2017 08:33:12 +0000 (UTC)
Date: Thu, 28 Sep 2017 10:33:10 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.13.4
Message-ID: &lt;20170928083310.GB11022@kroah.com&gt;
References: &lt;20170928083302.GA11022@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170928083302.GA11022@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 28, 2017, 8:33 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/dev-tools/gdb-kernel-debugging.rst b/Documentation/dev-tools/gdb-kernel-debugging.rst</span>
<span class="p_header">index 5e93c9bc6619..19df79286f00 100644</span>
<span class="p_header">--- a/Documentation/dev-tools/gdb-kernel-debugging.rst</span>
<span class="p_header">+++ b/Documentation/dev-tools/gdb-kernel-debugging.rst</span>
<span class="p_chunk">@@ -31,11 +31,13 @@</span> <span class="p_context"> Setup</span>
   CONFIG_DEBUG_INFO_REDUCED off. If your architecture supports
   CONFIG_FRAME_POINTER, keep it enabled.
 
<span class="p_del">-- Install that kernel on the guest.</span>
<span class="p_add">+- Install that kernel on the guest, turn off KASLR if necessary by adding</span>
<span class="p_add">+  &quot;nokaslr&quot; to the kernel command line.</span>
   Alternatively, QEMU allows to boot the kernel directly using -kernel,
   -append, -initrd command line switches. This is generally only useful if
   you do not depend on modules. See QEMU documentation for more details on
<span class="p_del">-  this mode.</span>
<span class="p_add">+  this mode. In this case, you should build the kernel with</span>
<span class="p_add">+  CONFIG_RANDOMIZE_BASE disabled if the architecture supports KASLR.</span>
 
 - Enable the gdb stub of QEMU/KVM, either
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 0f31ef4aea7b..159901979dec 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 13
<span class="p_del">-SUBLEVEL = 3</span>
<span class="p_add">+SUBLEVEL = 4</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/arc/kernel/entry.S b/arch/arc/kernel/entry.S</span>
<span class="p_header">index 1eea99beecc3..85d9ea4a0acc 100644</span>
<span class="p_header">--- a/arch/arc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arc/kernel/entry.S</span>
<span class="p_chunk">@@ -92,6 +92,12 @@</span> <span class="p_context"> ENTRY(EV_MachineCheck)</span>
 	lr  r0, [efa]
 	mov r1, sp
 
<span class="p_add">+	; hardware auto-disables MMU, re-enable it to allow kernel vaddr</span>
<span class="p_add">+	; access for say stack unwinding of modules for crash dumps</span>
<span class="p_add">+	lr	r3, [ARC_REG_PID]</span>
<span class="p_add">+	or	r3, r3, MMU_ENABLE</span>
<span class="p_add">+	sr	r3, [ARC_REG_PID]</span>
<span class="p_add">+</span>
 	lsr  	r3, r2, 8
 	bmsk 	r3, r3, 7
 	brne    r3, ECR_C_MCHK_DUP_TLB, 1f
<span class="p_header">diff --git a/arch/arc/mm/tlb.c b/arch/arc/mm/tlb.c</span>
<span class="p_header">index b181f3ee38aa..ac81502055f8 100644</span>
<span class="p_header">--- a/arch/arc/mm/tlb.c</span>
<span class="p_header">+++ b/arch/arc/mm/tlb.c</span>
<span class="p_chunk">@@ -908,9 +908,6 @@</span> <span class="p_context"> void do_tlb_overlap_fault(unsigned long cause, unsigned long address,</span>
 
 	local_irq_save(flags);
 
<span class="p_del">-	/* re-enable the MMU */</span>
<span class="p_del">-	write_aux_reg(ARC_REG_PID, MMU_ENABLE | read_aux_reg(ARC_REG_PID));</span>
<span class="p_del">-</span>
 	/* loop thru all sets of TLB */
 	for (set = 0; set &lt; mmu-&gt;sets; set++) {
 
<span class="p_header">diff --git a/arch/mips/math-emu/dp_fmax.c b/arch/mips/math-emu/dp_fmax.c</span>
<span class="p_header">index fd71b8daaaf2..5bec64f2884e 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/dp_fmax.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/dp_fmax.c</span>
<span class="p_chunk">@@ -47,14 +47,26 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmax(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754dp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -80,9 +92,7 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmax(union ieee754dp x, union ieee754dp y)</span>
 		return ys ? x : y;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754dp_zero(1);</span>
<span class="p_add">+		return ieee754dp_zero(xs &amp; ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		DPDNORMX;
<span class="p_chunk">@@ -106,16 +116,32 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmax(union ieee754dp x, union ieee754dp y)</span>
 	else if (xs &lt; ys)
 		return x;
 
<span class="p_del">-	/* Compare exponent */</span>
<span class="p_del">-	if (xe &gt; ye)</span>
<span class="p_del">-		return x;</span>
<span class="p_del">-	else if (xe &lt; ye)</span>
<span class="p_del">-		return y;</span>
<span class="p_add">+	/* Signs of inputs are equal, let&#39;s compare exponents */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Inputs are both negative */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* Compare mantissa */</span>
<span class="p_add">+	/* Signs and exponents of inputs are equal, let&#39;s compare mantissas */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive, with equal signs and exponents */</span>
<span class="p_add">+		if (xm &lt;= ym)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Inputs are both negative, with equal signs and exponents */</span>
 	if (xm &lt;= ym)
<span class="p_del">-		return y;</span>
<span class="p_del">-	return x;</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	return y;</span>
 }
 
 union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)
<span class="p_chunk">@@ -147,14 +173,26 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754dp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -164,6 +202,9 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 	/*
 	 * Infinity and zero handling
 	 */
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
<span class="p_add">+		return ieee754dp_inf(xs &amp; ys);</span>
<span class="p_add">+</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -171,7 +212,6 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
<span class="p_chunk">@@ -180,9 +220,7 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 		return y;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754dp_zero(1);</span>
<span class="p_add">+		return ieee754dp_zero(xs &amp; ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		DPDNORMX;
<span class="p_chunk">@@ -207,7 +245,11 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 		return y;
 
 	/* Compare mantissa */
<span class="p_del">-	if (xm &lt;= ym)</span>
<span class="p_add">+	if (xm &lt; ym)</span>
 		return y;
<span class="p_del">-	return x;</span>
<span class="p_add">+	else if (xm &gt; ym)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	else if (xs == 0)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	return y;</span>
 }
<span class="p_header">diff --git a/arch/mips/math-emu/dp_fmin.c b/arch/mips/math-emu/dp_fmin.c</span>
<span class="p_header">index c1072b0dfb95..a287b23818d8 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/dp_fmin.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/dp_fmin.c</span>
<span class="p_chunk">@@ -47,14 +47,26 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmin(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754dp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -80,9 +92,7 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmin(union ieee754dp x, union ieee754dp y)</span>
 		return ys ? y : x;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754dp_zero(1);</span>
<span class="p_add">+		return ieee754dp_zero(xs | ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		DPDNORMX;
<span class="p_chunk">@@ -106,16 +116,32 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmin(union ieee754dp x, union ieee754dp y)</span>
 	else if (xs &lt; ys)
 		return y;
 
<span class="p_del">-	/* Compare exponent */</span>
<span class="p_del">-	if (xe &gt; ye)</span>
<span class="p_del">-		return y;</span>
<span class="p_del">-	else if (xe &lt; ye)</span>
<span class="p_del">-		return x;</span>
<span class="p_add">+	/* Signs of inputs are the same, let&#39;s compare exponents */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Inputs are both negative */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* Compare mantissa */</span>
<span class="p_add">+	/* Signs and exponents of inputs are equal, let&#39;s compare mantissas */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive, with equal signs and exponents */</span>
<span class="p_add">+		if (xm &lt;= ym)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Inputs are both negative, with equal signs and exponents */</span>
 	if (xm &lt;= ym)
<span class="p_del">-		return x;</span>
<span class="p_del">-	return y;</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	return x;</span>
 }
 
 union ieee754dp ieee754dp_fmina(union ieee754dp x, union ieee754dp y)
<span class="p_chunk">@@ -147,14 +173,26 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmina(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754dp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -164,25 +202,25 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmina(union ieee754dp x, union ieee754dp y)</span>
 	/*
 	 * Infinity and zero handling
 	 */
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
<span class="p_add">+		return ieee754dp_inf(xs | ys);</span>
<span class="p_add">+</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
<span class="p_del">-		return x;</span>
<span class="p_add">+		return y;</span>
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_DNORM):
<span class="p_del">-		return y;</span>
<span class="p_add">+		return x;</span>
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754dp_zero(1);</span>
<span class="p_add">+		return ieee754dp_zero(xs | ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		DPDNORMX;
<span class="p_chunk">@@ -207,7 +245,11 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmina(union ieee754dp x, union ieee754dp y)</span>
 		return x;
 
 	/* Compare mantissa */
<span class="p_del">-	if (xm &lt;= ym)</span>
<span class="p_add">+	if (xm &lt; ym)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	else if (xm &gt; ym)</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	else if (xs == 1)</span>
 		return x;
 	return y;
 }
<span class="p_header">diff --git a/arch/mips/math-emu/dp_maddf.c b/arch/mips/math-emu/dp_maddf.c</span>
<span class="p_header">index caa62f20a888..e0d9be5fbf4c 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/dp_maddf.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/dp_maddf.c</span>
<span class="p_chunk">@@ -14,22 +14,45 @@</span> <span class="p_context"></span>
 
 #include &quot;ieee754dp.h&quot;
 
<span class="p_del">-enum maddf_flags {</span>
<span class="p_del">-	maddf_negate_product	= 1 &lt;&lt; 0,</span>
<span class="p_del">-};</span>
<span class="p_add">+</span>
<span class="p_add">+/* 128 bits shift right logical with rounding. */</span>
<span class="p_add">+void srl128(u64 *hptr, u64 *lptr, int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 low;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (count &gt;= 128) {</span>
<span class="p_add">+		*lptr = *hptr != 0 || *lptr != 0;</span>
<span class="p_add">+		*hptr = 0;</span>
<span class="p_add">+	} else if (count &gt;= 64) {</span>
<span class="p_add">+		if (count == 64) {</span>
<span class="p_add">+			*lptr = *hptr | (*lptr != 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			low = *lptr;</span>
<span class="p_add">+			*lptr = *hptr &gt;&gt; (count - 64);</span>
<span class="p_add">+			*lptr |= (*hptr &lt;&lt; (128 - count)) != 0 || low != 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		*hptr = 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		low = *lptr;</span>
<span class="p_add">+		*lptr = low &gt;&gt; count | *hptr &lt;&lt; (64 - count);</span>
<span class="p_add">+		*lptr |= (low &lt;&lt; (64 - count)) != 0;</span>
<span class="p_add">+		*hptr = *hptr &gt;&gt; count;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 
 static union ieee754dp _dp_maddf(union ieee754dp z, union ieee754dp x,
 				 union ieee754dp y, enum maddf_flags flags)
 {
 	int re;
 	int rs;
<span class="p_del">-	u64 rm;</span>
 	unsigned lxm;
 	unsigned hxm;
 	unsigned lym;
 	unsigned hym;
 	u64 lrm;
 	u64 hrm;
<span class="p_add">+	u64 lzm;</span>
<span class="p_add">+	u64 hzm;</span>
 	u64 t;
 	u64 at;
 	int s;
<span class="p_chunk">@@ -48,52 +71,34 @@</span> <span class="p_context"> static union ieee754dp _dp_maddf(union ieee754dp z, union ieee754dp x,</span>
 
 	ieee754_clearcx();
 
<span class="p_del">-	switch (zc) {</span>
<span class="p_del">-	case IEEE754_CLASS_SNAN:</span>
<span class="p_del">-		ieee754_setcx(IEEE754_INVALID_OPERATION);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Handle the cases when at least one of x, y or z is a NaN.</span>
<span class="p_add">+	 * Order of precedence is sNaN, qNaN and z, x, y.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (zc == IEEE754_CLASS_SNAN)</span>
 		return ieee754dp_nanxcpt(z);
<span class="p_del">-	case IEEE754_CLASS_DNORM:</span>
<span class="p_del">-		DPDNORMZ;</span>
<span class="p_del">-	/* QNAN and ZERO cases are handled separately below */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (CLPAIR(xc, yc)) {</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-		return ieee754dp_nanxcpt(y);</span>
<span class="p_del">-</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_ZERO):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_NORM):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_DNORM):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):</span>
<span class="p_add">+	if (xc == IEEE754_CLASS_SNAN)</span>
 		return ieee754dp_nanxcpt(x);
<span class="p_del">-</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+	if (yc == IEEE754_CLASS_SNAN)</span>
<span class="p_add">+		return ieee754dp_nanxcpt(y);</span>
<span class="p_add">+	if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_add">+		return z;</span>
<span class="p_add">+	if (xc == IEEE754_CLASS_QNAN)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	if (yc == IEEE754_CLASS_QNAN)</span>
 		return y;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_INF):</span>
<span class="p_del">-		return x;</span>
<span class="p_add">+	if (zc == IEEE754_CLASS_DNORM)</span>
<span class="p_add">+		DPDNORMZ;</span>
<span class="p_add">+	/* ZERO z cases are handled separately below */</span>
 
<span class="p_add">+	switch (CLPAIR(xc, yc)) {</span>
 
 	/*
 	 * Infinity handling
 	 */
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
 		ieee754_setcx(IEEE754_INVALID_OPERATION);
 		return ieee754dp_indef();
 
<span class="p_chunk">@@ -102,9 +107,27 @@</span> <span class="p_context"> static union ieee754dp _dp_maddf(union ieee754dp z, union ieee754dp x,</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
<span class="p_del">-		return ieee754dp_inf(xs ^ ys);</span>
<span class="p_add">+		if ((zc == IEEE754_CLASS_INF) &amp;&amp;</span>
<span class="p_add">+		    ((!(flags &amp; MADDF_NEGATE_PRODUCT) &amp;&amp; (zs != (xs ^ ys))) ||</span>
<span class="p_add">+		     ((flags &amp; MADDF_NEGATE_PRODUCT) &amp;&amp; (zs == (xs ^ ys))))) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Cases of addition of infinities with opposite signs</span>
<span class="p_add">+			 * or subtraction of infinities with same signs.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ieee754_setcx(IEEE754_INVALID_OPERATION);</span>
<span class="p_add">+			return ieee754dp_indef();</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * z is here either not an infinity, or an infinity having the</span>
<span class="p_add">+		 * same sign as product (x*y) (in case of MADDF.D instruction)</span>
<span class="p_add">+		 * or product -(x*y) (in MSUBF.D case). The result must be an</span>
<span class="p_add">+		 * infinity, and its sign is determined only by the value of</span>
<span class="p_add">+		 * (flags &amp; MADDF_NEGATE_PRODUCT) and the signs of x and y.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (flags &amp; MADDF_NEGATE_PRODUCT)</span>
<span class="p_add">+			return ieee754dp_inf(1 ^ (xs ^ ys));</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return ieee754dp_inf(xs ^ ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_NORM):
<span class="p_chunk">@@ -113,32 +136,42 @@</span> <span class="p_context"> static union ieee754dp _dp_maddf(union ieee754dp z, union ieee754dp x,</span>
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
 		if (zc == IEEE754_CLASS_INF)
 			return ieee754dp_inf(zs);
<span class="p_del">-		/* Multiplication is 0 so just return z */</span>
<span class="p_add">+		if (zc == IEEE754_CLASS_ZERO) {</span>
<span class="p_add">+			/* Handle cases +0 + (-0) and similar ones. */</span>
<span class="p_add">+			if ((!(flags &amp; MADDF_NEGATE_PRODUCT)</span>
<span class="p_add">+					&amp;&amp; (zs == (xs ^ ys))) ||</span>
<span class="p_add">+			    ((flags &amp; MADDF_NEGATE_PRODUCT)</span>
<span class="p_add">+					&amp;&amp; (zs != (xs ^ ys))))</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Cases of addition of zeros of equal signs</span>
<span class="p_add">+				 * or subtraction of zeroes of opposite signs.</span>
<span class="p_add">+				 * The sign of the resulting zero is in any</span>
<span class="p_add">+				 * such case determined only by the sign of z.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				return z;</span>
<span class="p_add">+</span>
<span class="p_add">+			return ieee754dp_zero(ieee754_csr.rm == FPU_CSR_RD);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* x*y is here 0, and z is not 0, so just return z */</span>
 		return z;
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		DPDNORMX;
 
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_DNORM):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
<span class="p_del">-		else if (zc == IEEE754_CLASS_INF)</span>
<span class="p_add">+		if (zc == IEEE754_CLASS_INF)</span>
 			return ieee754dp_inf(zs);
 		DPDNORMY;
 		break;
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_NORM):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
<span class="p_del">-		else if (zc == IEEE754_CLASS_INF)</span>
<span class="p_add">+		if (zc == IEEE754_CLASS_INF)</span>
 			return ieee754dp_inf(zs);
 		DPDNORMX;
 		break;
 
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_NORM):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
<span class="p_del">-		else if (zc == IEEE754_CLASS_INF)</span>
<span class="p_add">+		if (zc == IEEE754_CLASS_INF)</span>
 			return ieee754dp_inf(zs);
 		/* fall through to real computations */
 	}
<span class="p_chunk">@@ -157,7 +190,7 @@</span> <span class="p_context"> static union ieee754dp _dp_maddf(union ieee754dp z, union ieee754dp x,</span>
 
 	re = xe + ye;
 	rs = xs ^ ys;
<span class="p_del">-	if (flags &amp; maddf_negate_product)</span>
<span class="p_add">+	if (flags &amp; MADDF_NEGATE_PRODUCT)</span>
 		rs ^= 1;
 
 	/* shunt to top of word */
<span class="p_chunk">@@ -165,7 +198,7 @@</span> <span class="p_context"> static union ieee754dp _dp_maddf(union ieee754dp z, union ieee754dp x,</span>
 	ym &lt;&lt;= 64 - (DP_FBITS + 1);
 
 	/*
<span class="p_del">-	 * Multiply 64 bits xm, ym to give high 64 bits rm with stickness.</span>
<span class="p_add">+	 * Multiply 64 bits xm and ym to give 128 bits result in hrm:lrm.</span>
 	 */
 
 	/* 32 * 32 =&gt; 64 */
<span class="p_chunk">@@ -195,81 +228,110 @@</span> <span class="p_context"> static union ieee754dp _dp_maddf(union ieee754dp z, union ieee754dp x,</span>
 
 	hrm = hrm + (t &gt;&gt; 32);
 
<span class="p_del">-	rm = hrm | (lrm != 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Sticky shift down to normal rounding precision.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((s64) rm &lt; 0) {</span>
<span class="p_del">-		rm = (rm &gt;&gt; (64 - (DP_FBITS + 1 + 3))) |</span>
<span class="p_del">-		     ((rm &lt;&lt; (DP_FBITS + 1 + 3)) != 0);</span>
<span class="p_add">+	/* Put explicit bit at bit 126 if necessary */</span>
<span class="p_add">+	if ((int64_t)hrm &lt; 0) {</span>
<span class="p_add">+		lrm = (hrm &lt;&lt; 63) | (lrm &gt;&gt; 1);</span>
<span class="p_add">+		hrm = hrm &gt;&gt; 1;</span>
 		re++;
<span class="p_del">-	} else {</span>
<span class="p_del">-		rm = (rm &gt;&gt; (64 - (DP_FBITS + 1 + 3 + 1))) |</span>
<span class="p_del">-		     ((rm &lt;&lt; (DP_FBITS + 1 + 3 + 1)) != 0);</span>
 	}
<span class="p_del">-	assert(rm &amp; (DP_HIDDEN_BIT &lt;&lt; 3));</span>
 
<span class="p_del">-	if (zc == IEEE754_CLASS_ZERO)</span>
<span class="p_del">-		return ieee754dp_format(rs, re, rm);</span>
<span class="p_add">+	assert(hrm &amp; (1 &lt;&lt; 62));</span>
 
<span class="p_del">-	/* And now the addition */</span>
<span class="p_del">-	assert(zm &amp; DP_HIDDEN_BIT);</span>
<span class="p_add">+	if (zc == IEEE754_CLASS_ZERO) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Move explicit bit from bit 126 to bit 55 since the</span>
<span class="p_add">+		 * ieee754dp_format code expects the mantissa to be</span>
<span class="p_add">+		 * 56 bits wide (53 + 3 rounding bits).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		srl128(&amp;hrm, &amp;lrm, (126 - 55));</span>
<span class="p_add">+		return ieee754dp_format(rs, re, lrm);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Provide guard,round and stick bit space.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	zm &lt;&lt;= 3;</span>
<span class="p_add">+	/* Move explicit bit from bit 52 to bit 126 */</span>
<span class="p_add">+	lzm = 0;</span>
<span class="p_add">+	hzm = zm &lt;&lt; 10;</span>
<span class="p_add">+	assert(hzm &amp; (1 &lt;&lt; 62));</span>
 
<span class="p_add">+	/* Make the exponents the same */</span>
 	if (ze &gt; re) {
 		/*
 		 * Have to shift y fraction right to align.
 		 */
 		s = ze - re;
<span class="p_del">-		rm = XDPSRS(rm, s);</span>
<span class="p_add">+		srl128(&amp;hrm, &amp;lrm, s);</span>
 		re += s;
 	} else if (re &gt; ze) {
 		/*
 		 * Have to shift x fraction right to align.
 		 */
 		s = re - ze;
<span class="p_del">-		zm = XDPSRS(zm, s);</span>
<span class="p_add">+		srl128(&amp;hzm, &amp;lzm, s);</span>
 		ze += s;
 	}
 	assert(ze == re);
 	assert(ze &lt;= DP_EMAX);
 
<span class="p_add">+	/* Do the addition */</span>
 	if (zs == rs) {
 		/*
<span class="p_del">-		 * Generate 28 bit result of adding two 27 bit numbers</span>
<span class="p_del">-		 * leaving result in xm, xs and xe.</span>
<span class="p_add">+		 * Generate 128 bit result by adding two 127 bit numbers</span>
<span class="p_add">+		 * leaving result in hzm:lzm, zs and ze.</span>
 		 */
<span class="p_del">-		zm = zm + rm;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (zm &gt;&gt; (DP_FBITS + 1 + 3)) { /* carry out */</span>
<span class="p_del">-			zm = XDPSRS1(zm);</span>
<span class="p_add">+		hzm = hzm + hrm + (lzm &gt; (lzm + lrm));</span>
<span class="p_add">+		lzm = lzm + lrm;</span>
<span class="p_add">+		if ((int64_t)hzm &lt; 0) {        /* carry out */</span>
<span class="p_add">+			srl128(&amp;hzm, &amp;lzm, 1);</span>
 			ze++;
 		}
 	} else {
<span class="p_del">-		if (zm &gt;= rm) {</span>
<span class="p_del">-			zm = zm - rm;</span>
<span class="p_add">+		if (hzm &gt; hrm || (hzm == hrm &amp;&amp; lzm &gt;= lrm)) {</span>
<span class="p_add">+			hzm = hzm - hrm - (lzm &lt; lrm);</span>
<span class="p_add">+			lzm = lzm - lrm;</span>
 		} else {
<span class="p_del">-			zm = rm - zm;</span>
<span class="p_add">+			hzm = hrm - hzm - (lrm &lt; lzm);</span>
<span class="p_add">+			lzm = lrm - lzm;</span>
 			zs = rs;
 		}
<span class="p_del">-		if (zm == 0)</span>
<span class="p_add">+		if (lzm == 0 &amp;&amp; hzm == 0)</span>
 			return ieee754dp_zero(ieee754_csr.rm == FPU_CSR_RD);
 
 		/*
<span class="p_del">-		 * Normalize to rounding precision.</span>
<span class="p_add">+		 * Put explicit bit at bit 126 if necessary.</span>
 		 */
<span class="p_del">-		while ((zm &gt;&gt; (DP_FBITS + 3)) == 0) {</span>
<span class="p_del">-			zm &lt;&lt;= 1;</span>
<span class="p_del">-			ze--;</span>
<span class="p_add">+		if (hzm == 0) {</span>
<span class="p_add">+			/* left shift by 63 or 64 bits */</span>
<span class="p_add">+			if ((int64_t)lzm &lt; 0) {</span>
<span class="p_add">+				/* MSB of lzm is the explicit bit */</span>
<span class="p_add">+				hzm = lzm &gt;&gt; 1;</span>
<span class="p_add">+				lzm = lzm &lt;&lt; 63;</span>
<span class="p_add">+				ze -= 63;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				hzm = lzm;</span>
<span class="p_add">+				lzm = 0;</span>
<span class="p_add">+				ze -= 64;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		t = 0;</span>
<span class="p_add">+		while ((hzm &gt;&gt; (62 - t)) == 0)</span>
<span class="p_add">+			t++;</span>
<span class="p_add">+</span>
<span class="p_add">+		assert(t &lt;= 62);</span>
<span class="p_add">+		if (t) {</span>
<span class="p_add">+			hzm = hzm &lt;&lt; t | lzm &gt;&gt; (64 - t);</span>
<span class="p_add">+			lzm = lzm &lt;&lt; t;</span>
<span class="p_add">+			ze -= t;</span>
 		}
 	}
 
<span class="p_del">-	return ieee754dp_format(zs, ze, zm);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Move explicit bit from bit 126 to bit 55 since the</span>
<span class="p_add">+	 * ieee754dp_format code expects the mantissa to be</span>
<span class="p_add">+	 * 56 bits wide (53 + 3 rounding bits).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	srl128(&amp;hzm, &amp;lzm, (126 - 55));</span>
<span class="p_add">+</span>
<span class="p_add">+	return ieee754dp_format(zs, ze, lzm);</span>
 }
 
 union ieee754dp ieee754dp_maddf(union ieee754dp z, union ieee754dp x,
<span class="p_chunk">@@ -281,5 +343,5 @@</span> <span class="p_context"> union ieee754dp ieee754dp_maddf(union ieee754dp z, union ieee754dp x,</span>
 union ieee754dp ieee754dp_msubf(union ieee754dp z, union ieee754dp x,
 				union ieee754dp y)
 {
<span class="p_del">-	return _dp_maddf(z, x, y, maddf_negate_product);</span>
<span class="p_add">+	return _dp_maddf(z, x, y, MADDF_NEGATE_PRODUCT);</span>
 }
<span class="p_header">diff --git a/arch/mips/math-emu/ieee754int.h b/arch/mips/math-emu/ieee754int.h</span>
<span class="p_header">index 8bc2f6963324..dd2071f430e0 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/ieee754int.h</span>
<span class="p_header">+++ b/arch/mips/math-emu/ieee754int.h</span>
<span class="p_chunk">@@ -26,6 +26,10 @@</span> <span class="p_context"></span>
 
 #define CLPAIR(x, y)	((x)*6+(y))
 
<span class="p_add">+enum maddf_flags {</span>
<span class="p_add">+	MADDF_NEGATE_PRODUCT	= 1 &lt;&lt; 0,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static inline void ieee754_clearcx(void)
 {
 	ieee754_csr.cx = 0;
<span class="p_header">diff --git a/arch/mips/math-emu/ieee754sp.h b/arch/mips/math-emu/ieee754sp.h</span>
<span class="p_header">index 8476067075fe..0f63e4202cff 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/ieee754sp.h</span>
<span class="p_header">+++ b/arch/mips/math-emu/ieee754sp.h</span>
<span class="p_chunk">@@ -45,6 +45,10 @@</span> <span class="p_context"> static inline int ieee754sp_finite(union ieee754sp x)</span>
 	return SPBEXP(x) != SP_EMAX + 1 + SP_EBIAS;
 }
 
<span class="p_add">+/* 64 bit right shift with rounding */</span>
<span class="p_add">+#define XSPSRS64(v, rs)						\</span>
<span class="p_add">+	(((rs) &gt;= 64) ? ((v) != 0) : ((v) &gt;&gt; (rs)) | ((v) &lt;&lt; (64-(rs)) != 0))</span>
<span class="p_add">+</span>
 /* 3bit extended single precision sticky right shift */
 #define XSPSRS(v, rs)						\
 	((rs &gt; (SP_FBITS+3))?1:((v) &gt;&gt; (rs)) | ((v) &lt;&lt; (32-(rs)) != 0))
<span class="p_header">diff --git a/arch/mips/math-emu/sp_fmax.c b/arch/mips/math-emu/sp_fmax.c</span>
<span class="p_header">index 4d000844e48e..74a5a00d2f22 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/sp_fmax.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/sp_fmax.c</span>
<span class="p_chunk">@@ -47,14 +47,26 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmax(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754sp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -80,9 +92,7 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmax(union ieee754sp x, union ieee754sp y)</span>
 		return ys ? x : y;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754sp_zero(1);</span>
<span class="p_add">+		return ieee754sp_zero(xs &amp; ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		SPDNORMX;
<span class="p_chunk">@@ -106,16 +116,32 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmax(union ieee754sp x, union ieee754sp y)</span>
 	else if (xs &lt; ys)
 		return x;
 
<span class="p_del">-	/* Compare exponent */</span>
<span class="p_del">-	if (xe &gt; ye)</span>
<span class="p_del">-		return x;</span>
<span class="p_del">-	else if (xe &lt; ye)</span>
<span class="p_del">-		return y;</span>
<span class="p_add">+	/* Signs of inputs are equal, let&#39;s compare exponents */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Inputs are both negative */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* Compare mantissa */</span>
<span class="p_add">+	/* Signs and exponents of inputs are equal, let&#39;s compare mantissas */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive, with equal signs and exponents */</span>
<span class="p_add">+		if (xm &lt;= ym)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Inputs are both negative, with equal signs and exponents */</span>
 	if (xm &lt;= ym)
<span class="p_del">-		return y;</span>
<span class="p_del">-	return x;</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	return y;</span>
 }
 
 union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)
<span class="p_chunk">@@ -147,14 +173,26 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754sp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -164,6 +202,9 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 	/*
 	 * Infinity and zero handling
 	 */
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
<span class="p_add">+		return ieee754sp_inf(xs &amp; ys);</span>
<span class="p_add">+</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -171,7 +212,6 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
<span class="p_chunk">@@ -180,9 +220,7 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 		return y;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754sp_zero(1);</span>
<span class="p_add">+		return ieee754sp_zero(xs &amp; ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		SPDNORMX;
<span class="p_chunk">@@ -207,7 +245,11 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 		return y;
 
 	/* Compare mantissa */
<span class="p_del">-	if (xm &lt;= ym)</span>
<span class="p_add">+	if (xm &lt; ym)</span>
 		return y;
<span class="p_del">-	return x;</span>
<span class="p_add">+	else if (xm &gt; ym)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	else if (xs == 0)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	return y;</span>
 }
<span class="p_header">diff --git a/arch/mips/math-emu/sp_fmin.c b/arch/mips/math-emu/sp_fmin.c</span>
<span class="p_header">index 4eb1bb9e9dec..c51385f46b09 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/sp_fmin.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/sp_fmin.c</span>
<span class="p_chunk">@@ -47,14 +47,26 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmin(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754sp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -80,9 +92,7 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmin(union ieee754sp x, union ieee754sp y)</span>
 		return ys ? y : x;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754sp_zero(1);</span>
<span class="p_add">+		return ieee754sp_zero(xs | ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		SPDNORMX;
<span class="p_chunk">@@ -106,16 +116,32 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmin(union ieee754sp x, union ieee754sp y)</span>
 	else if (xs &lt; ys)
 		return y;
 
<span class="p_del">-	/* Compare exponent */</span>
<span class="p_del">-	if (xe &gt; ye)</span>
<span class="p_del">-		return y;</span>
<span class="p_del">-	else if (xe &lt; ye)</span>
<span class="p_del">-		return x;</span>
<span class="p_add">+	/* Signs of inputs are the same, let&#39;s compare exponents */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Inputs are both negative */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* Compare mantissa */</span>
<span class="p_add">+	/* Signs and exponents of inputs are equal, let&#39;s compare mantissas */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive, with equal signs and exponents */</span>
<span class="p_add">+		if (xm &lt;= ym)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Inputs are both negative, with equal signs and exponents */</span>
 	if (xm &lt;= ym)
<span class="p_del">-		return x;</span>
<span class="p_del">-	return y;</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	return x;</span>
 }
 
 union ieee754sp ieee754sp_fmina(union ieee754sp x, union ieee754sp y)
<span class="p_chunk">@@ -147,14 +173,26 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmina(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754sp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -164,25 +202,25 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmina(union ieee754sp x, union ieee754sp y)</span>
 	/*
 	 * Infinity and zero handling
 	 */
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
<span class="p_add">+		return ieee754sp_inf(xs | ys);</span>
<span class="p_add">+</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
<span class="p_del">-		return x;</span>
<span class="p_add">+		return y;</span>
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_DNORM):
<span class="p_del">-		return y;</span>
<span class="p_add">+		return x;</span>
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754sp_zero(1);</span>
<span class="p_add">+		return ieee754sp_zero(xs | ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		SPDNORMX;
<span class="p_chunk">@@ -207,7 +245,11 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmina(union ieee754sp x, union ieee754sp y)</span>
 		return x;
 
 	/* Compare mantissa */
<span class="p_del">-	if (xm &lt;= ym)</span>
<span class="p_add">+	if (xm &lt; ym)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	else if (xm &gt; ym)</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	else if (xs == 1)</span>
 		return x;
 	return y;
 }
<span class="p_header">diff --git a/arch/mips/math-emu/sp_maddf.c b/arch/mips/math-emu/sp_maddf.c</span>
<span class="p_header">index c91d5e5d9b5f..7195fe785d81 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/sp_maddf.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/sp_maddf.c</span>
<span class="p_chunk">@@ -14,9 +14,6 @@</span> <span class="p_context"></span>
 
 #include &quot;ieee754sp.h&quot;
 
<span class="p_del">-enum maddf_flags {</span>
<span class="p_del">-	maddf_negate_product	= 1 &lt;&lt; 0,</span>
<span class="p_del">-};</span>
 
 static union ieee754sp _sp_maddf(union ieee754sp z, union ieee754sp x,
 				 union ieee754sp y, enum maddf_flags flags)
<span class="p_chunk">@@ -24,14 +21,8 @@</span> <span class="p_context"> static union ieee754sp _sp_maddf(union ieee754sp z, union ieee754sp x,</span>
 	int re;
 	int rs;
 	unsigned rm;
<span class="p_del">-	unsigned short lxm;</span>
<span class="p_del">-	unsigned short hxm;</span>
<span class="p_del">-	unsigned short lym;</span>
<span class="p_del">-	unsigned short hym;</span>
<span class="p_del">-	unsigned lrm;</span>
<span class="p_del">-	unsigned hrm;</span>
<span class="p_del">-	unsigned t;</span>
<span class="p_del">-	unsigned at;</span>
<span class="p_add">+	uint64_t rm64;</span>
<span class="p_add">+	uint64_t zm64;</span>
 	int s;
 
 	COMPXSP;
<span class="p_chunk">@@ -48,51 +39,35 @@</span> <span class="p_context"> static union ieee754sp _sp_maddf(union ieee754sp z, union ieee754sp x,</span>
 
 	ieee754_clearcx();
 
<span class="p_del">-	switch (zc) {</span>
<span class="p_del">-	case IEEE754_CLASS_SNAN:</span>
<span class="p_del">-		ieee754_setcx(IEEE754_INVALID_OPERATION);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Handle the cases when at least one of x, y or z is a NaN.</span>
<span class="p_add">+	 * Order of precedence is sNaN, qNaN and z, x, y.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (zc == IEEE754_CLASS_SNAN)</span>
 		return ieee754sp_nanxcpt(z);
<span class="p_del">-	case IEEE754_CLASS_DNORM:</span>
<span class="p_del">-		SPDNORMZ;</span>
<span class="p_del">-	/* QNAN and ZERO cases are handled separately below */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (CLPAIR(xc, yc)) {</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_SNAN):</span>
<span class="p_add">+	if (xc == IEEE754_CLASS_SNAN)</span>
<span class="p_add">+		return ieee754sp_nanxcpt(x);</span>
<span class="p_add">+	if (yc == IEEE754_CLASS_SNAN)</span>
 		return ieee754sp_nanxcpt(y);
<span class="p_add">+	if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_add">+		return z;</span>
<span class="p_add">+	if (xc == IEEE754_CLASS_QNAN)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	if (yc == IEEE754_CLASS_QNAN)</span>
<span class="p_add">+		return y;</span>
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_SNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_ZERO):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_NORM):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_DNORM):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):</span>
<span class="p_del">-		return ieee754sp_nanxcpt(x);</span>
<span class="p_add">+	if (zc == IEEE754_CLASS_DNORM)</span>
<span class="p_add">+		SPDNORMZ;</span>
<span class="p_add">+	/* ZERO z cases are handled separately below */</span>
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-		return y;</span>
<span class="p_add">+	switch (CLPAIR(xc, yc)) {</span>
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):</span>
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_INF):</span>
<span class="p_del">-		return x;</span>
 
 	/*
 	 * Infinity handling
 	 */
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
 		ieee754_setcx(IEEE754_INVALID_OPERATION);
 		return ieee754sp_indef();
 
<span class="p_chunk">@@ -101,9 +76,27 @@</span> <span class="p_context"> static union ieee754sp _sp_maddf(union ieee754sp z, union ieee754sp x,</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
<span class="p_del">-		return ieee754sp_inf(xs ^ ys);</span>
<span class="p_add">+		if ((zc == IEEE754_CLASS_INF) &amp;&amp;</span>
<span class="p_add">+		    ((!(flags &amp; MADDF_NEGATE_PRODUCT) &amp;&amp; (zs != (xs ^ ys))) ||</span>
<span class="p_add">+		     ((flags &amp; MADDF_NEGATE_PRODUCT) &amp;&amp; (zs == (xs ^ ys))))) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Cases of addition of infinities with opposite signs</span>
<span class="p_add">+			 * or subtraction of infinities with same signs.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ieee754_setcx(IEEE754_INVALID_OPERATION);</span>
<span class="p_add">+			return ieee754sp_indef();</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * z is here either not an infinity, or an infinity having the</span>
<span class="p_add">+		 * same sign as product (x*y) (in case of MADDF.D instruction)</span>
<span class="p_add">+		 * or product -(x*y) (in MSUBF.D case). The result must be an</span>
<span class="p_add">+		 * infinity, and its sign is determined only by the value of</span>
<span class="p_add">+		 * (flags &amp; MADDF_NEGATE_PRODUCT) and the signs of x and y.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (flags &amp; MADDF_NEGATE_PRODUCT)</span>
<span class="p_add">+			return ieee754sp_inf(1 ^ (xs ^ ys));</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return ieee754sp_inf(xs ^ ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_NORM):
<span class="p_chunk">@@ -112,32 +105,42 @@</span> <span class="p_context"> static union ieee754sp _sp_maddf(union ieee754sp z, union ieee754sp x,</span>
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
 		if (zc == IEEE754_CLASS_INF)
 			return ieee754sp_inf(zs);
<span class="p_del">-		/* Multiplication is 0 so just return z */</span>
<span class="p_add">+		if (zc == IEEE754_CLASS_ZERO) {</span>
<span class="p_add">+			/* Handle cases +0 + (-0) and similar ones. */</span>
<span class="p_add">+			if ((!(flags &amp; MADDF_NEGATE_PRODUCT)</span>
<span class="p_add">+					&amp;&amp; (zs == (xs ^ ys))) ||</span>
<span class="p_add">+			    ((flags &amp; MADDF_NEGATE_PRODUCT)</span>
<span class="p_add">+					&amp;&amp; (zs != (xs ^ ys))))</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Cases of addition of zeros of equal signs</span>
<span class="p_add">+				 * or subtraction of zeroes of opposite signs.</span>
<span class="p_add">+				 * The sign of the resulting zero is in any</span>
<span class="p_add">+				 * such case determined only by the sign of z.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				return z;</span>
<span class="p_add">+</span>
<span class="p_add">+			return ieee754sp_zero(ieee754_csr.rm == FPU_CSR_RD);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* x*y is here 0, and z is not 0, so just return z */</span>
 		return z;
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		SPDNORMX;
 
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_DNORM):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
<span class="p_del">-		else if (zc == IEEE754_CLASS_INF)</span>
<span class="p_add">+		if (zc == IEEE754_CLASS_INF)</span>
 			return ieee754sp_inf(zs);
 		SPDNORMY;
 		break;
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_NORM):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
<span class="p_del">-		else if (zc == IEEE754_CLASS_INF)</span>
<span class="p_add">+		if (zc == IEEE754_CLASS_INF)</span>
 			return ieee754sp_inf(zs);
 		SPDNORMX;
 		break;
 
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_NORM):
<span class="p_del">-		if (zc == IEEE754_CLASS_QNAN)</span>
<span class="p_del">-			return z;</span>
<span class="p_del">-		else if (zc == IEEE754_CLASS_INF)</span>
<span class="p_add">+		if (zc == IEEE754_CLASS_INF)</span>
 			return ieee754sp_inf(zs);
 		/* fall through to real computations */
 	}
<span class="p_chunk">@@ -158,111 +161,93 @@</span> <span class="p_context"> static union ieee754sp _sp_maddf(union ieee754sp z, union ieee754sp x,</span>
 
 	re = xe + ye;
 	rs = xs ^ ys;
<span class="p_del">-	if (flags &amp; maddf_negate_product)</span>
<span class="p_add">+	if (flags &amp; MADDF_NEGATE_PRODUCT)</span>
 		rs ^= 1;
 
<span class="p_del">-	/* shunt to top of word */</span>
<span class="p_del">-	xm &lt;&lt;= 32 - (SP_FBITS + 1);</span>
<span class="p_del">-	ym &lt;&lt;= 32 - (SP_FBITS + 1);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Multiply 32 bits xm, ym to give high 32 bits rm with stickness.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	lxm = xm &amp; 0xffff;</span>
<span class="p_del">-	hxm = xm &gt;&gt; 16;</span>
<span class="p_del">-	lym = ym &amp; 0xffff;</span>
<span class="p_del">-	hym = ym &gt;&gt; 16;</span>
<span class="p_del">-</span>
<span class="p_del">-	lrm = lxm * lym;	/* 16 * 16 =&gt; 32 */</span>
<span class="p_del">-	hrm = hxm * hym;	/* 16 * 16 =&gt; 32 */</span>
<span class="p_del">-</span>
<span class="p_del">-	t = lxm * hym; /* 16 * 16 =&gt; 32 */</span>
<span class="p_del">-	at = lrm + (t &lt;&lt; 16);</span>
<span class="p_del">-	hrm += at &lt; lrm;</span>
<span class="p_del">-	lrm = at;</span>
<span class="p_del">-	hrm = hrm + (t &gt;&gt; 16);</span>
<span class="p_add">+	/* Multiple 24 bit xm and ym to give 48 bit results */</span>
<span class="p_add">+	rm64 = (uint64_t)xm * ym;</span>
 
<span class="p_del">-	t = hxm * lym; /* 16 * 16 =&gt; 32 */</span>
<span class="p_del">-	at = lrm + (t &lt;&lt; 16);</span>
<span class="p_del">-	hrm += at &lt; lrm;</span>
<span class="p_del">-	lrm = at;</span>
<span class="p_del">-	hrm = hrm + (t &gt;&gt; 16);</span>
<span class="p_add">+	/* Shunt to top of word */</span>
<span class="p_add">+	rm64 = rm64 &lt;&lt; 16;</span>
 
<span class="p_del">-	rm = hrm | (lrm != 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Sticky shift down to normal rounding precision.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((int) rm &lt; 0) {</span>
<span class="p_del">-		rm = (rm &gt;&gt; (32 - (SP_FBITS + 1 + 3))) |</span>
<span class="p_del">-		    ((rm &lt;&lt; (SP_FBITS + 1 + 3)) != 0);</span>
<span class="p_add">+	/* Put explicit bit at bit 62 if necessary */</span>
<span class="p_add">+	if ((int64_t) rm64 &lt; 0) {</span>
<span class="p_add">+		rm64 = rm64 &gt;&gt; 1;</span>
 		re++;
<span class="p_del">-	} else {</span>
<span class="p_del">-		rm = (rm &gt;&gt; (32 - (SP_FBITS + 1 + 3 + 1))) |</span>
<span class="p_del">-		     ((rm &lt;&lt; (SP_FBITS + 1 + 3 + 1)) != 0);</span>
 	}
<span class="p_del">-	assert(rm &amp; (SP_HIDDEN_BIT &lt;&lt; 3));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (zc == IEEE754_CLASS_ZERO)</span>
<span class="p_del">-		return ieee754sp_format(rs, re, rm);</span>
 
<span class="p_del">-	/* And now the addition */</span>
<span class="p_add">+	assert(rm64 &amp; (1 &lt;&lt; 62));</span>
 
<span class="p_del">-	assert(zm &amp; SP_HIDDEN_BIT);</span>
<span class="p_add">+	if (zc == IEEE754_CLASS_ZERO) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Move explicit bit from bit 62 to bit 26 since the</span>
<span class="p_add">+		 * ieee754sp_format code expects the mantissa to be</span>
<span class="p_add">+		 * 27 bits wide (24 + 3 rounding bits).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		rm = XSPSRS64(rm64, (62 - 26));</span>
<span class="p_add">+		return ieee754sp_format(rs, re, rm);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Provide guard,round and stick bit space.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	zm &lt;&lt;= 3;</span>
<span class="p_add">+	/* Move explicit bit from bit 23 to bit 62 */</span>
<span class="p_add">+	zm64 = (uint64_t)zm &lt;&lt; (62 - 23);</span>
<span class="p_add">+	assert(zm64 &amp; (1 &lt;&lt; 62));</span>
 
<span class="p_add">+	/* Make the exponents the same */</span>
 	if (ze &gt; re) {
 		/*
 		 * Have to shift r fraction right to align.
 		 */
 		s = ze - re;
<span class="p_del">-		rm = XSPSRS(rm, s);</span>
<span class="p_add">+		rm64 = XSPSRS64(rm64, s);</span>
 		re += s;
 	} else if (re &gt; ze) {
 		/*
 		 * Have to shift z fraction right to align.
 		 */
 		s = re - ze;
<span class="p_del">-		zm = XSPSRS(zm, s);</span>
<span class="p_add">+		zm64 = XSPSRS64(zm64, s);</span>
 		ze += s;
 	}
 	assert(ze == re);
 	assert(ze &lt;= SP_EMAX);
 
<span class="p_add">+	/* Do the addition */</span>
 	if (zs == rs) {
 		/*
<span class="p_del">-		 * Generate 28 bit result of adding two 27 bit numbers</span>
<span class="p_del">-		 * leaving result in zm, zs and ze.</span>
<span class="p_add">+		 * Generate 64 bit result by adding two 63 bit numbers</span>
<span class="p_add">+		 * leaving result in zm64, zs and ze.</span>
 		 */
<span class="p_del">-		zm = zm + rm;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (zm &gt;&gt; (SP_FBITS + 1 + 3)) { /* carry out */</span>
<span class="p_del">-			zm = XSPSRS1(zm);</span>
<span class="p_add">+		zm64 = zm64 + rm64;</span>
<span class="p_add">+		if ((int64_t)zm64 &lt; 0) {	/* carry out */</span>
<span class="p_add">+			zm64 = XSPSRS1(zm64);</span>
 			ze++;
 		}
 	} else {
<span class="p_del">-		if (zm &gt;= rm) {</span>
<span class="p_del">-			zm = zm - rm;</span>
<span class="p_add">+		if (zm64 &gt;= rm64) {</span>
<span class="p_add">+			zm64 = zm64 - rm64;</span>
 		} else {
<span class="p_del">-			zm = rm - zm;</span>
<span class="p_add">+			zm64 = rm64 - zm64;</span>
 			zs = rs;
 		}
<span class="p_del">-		if (zm == 0)</span>
<span class="p_add">+		if (zm64 == 0)</span>
 			return ieee754sp_zero(ieee754_csr.rm == FPU_CSR_RD);
 
 		/*
<span class="p_del">-		 * Normalize in extended single precision</span>
<span class="p_add">+		 * Put explicit bit at bit 62 if necessary.</span>
 		 */
<span class="p_del">-		while ((zm &gt;&gt; (SP_MBITS + 3)) == 0) {</span>
<span class="p_del">-			zm &lt;&lt;= 1;</span>
<span class="p_add">+		while ((zm64 &gt;&gt; 62) == 0) {</span>
<span class="p_add">+			zm64 &lt;&lt;= 1;</span>
 			ze--;
 		}
<span class="p_del">-</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Move explicit bit from bit 62 to bit 26 since the</span>
<span class="p_add">+	 * ieee754sp_format code expects the mantissa to be</span>
<span class="p_add">+	 * 27 bits wide (24 + 3 rounding bits).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	zm = XSPSRS64(zm64, (62 - 26));</span>
<span class="p_add">+</span>
 	return ieee754sp_format(zs, ze, zm);
 }
 
<span class="p_chunk">@@ -275,5 +260,5 @@</span> <span class="p_context"> union ieee754sp ieee754sp_maddf(union ieee754sp z, union ieee754sp x,</span>
 union ieee754sp ieee754sp_msubf(union ieee754sp z, union ieee754sp x,
 				union ieee754sp y)
 {
<span class="p_del">-	return _sp_maddf(z, x, y, maddf_negate_product);</span>
<span class="p_add">+	return _sp_maddf(z, x, y, MADDF_NEGATE_PRODUCT);</span>
 }
<span class="p_header">diff --git a/arch/powerpc/kernel/align.c b/arch/powerpc/kernel/align.c</span>
<span class="p_header">index ec7a8b099dd9..fd3c1fcc73eb 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/align.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/align.c</span>
<span class="p_chunk">@@ -235,6 +235,28 @@</span> <span class="p_context"> static int emulate_dcbz(struct pt_regs *regs, unsigned char __user *addr)</span>
 
 #define SWIZ_PTR(p)		((unsigned char __user *)((p) ^ swiz))
 
<span class="p_add">+#define __get_user_or_set_dar(_regs, _dest, _addr)		\</span>
<span class="p_add">+	({							\</span>
<span class="p_add">+		int rc = 0;					\</span>
<span class="p_add">+		typeof(_addr) __addr = (_addr);			\</span>
<span class="p_add">+		if (__get_user_inatomic(_dest, __addr)) {	\</span>
<span class="p_add">+			_regs-&gt;dar = (unsigned long)__addr;	\</span>
<span class="p_add">+			rc = -EFAULT;				\</span>
<span class="p_add">+		}						\</span>
<span class="p_add">+		rc;						\</span>
<span class="p_add">+	})</span>
<span class="p_add">+</span>
<span class="p_add">+#define __put_user_or_set_dar(_regs, _src, _addr)		\</span>
<span class="p_add">+	({							\</span>
<span class="p_add">+		int rc = 0;					\</span>
<span class="p_add">+		typeof(_addr) __addr = (_addr);			\</span>
<span class="p_add">+		if (__put_user_inatomic(_src, __addr)) {	\</span>
<span class="p_add">+			_regs-&gt;dar = (unsigned long)__addr;	\</span>
<span class="p_add">+			rc = -EFAULT;				\</span>
<span class="p_add">+		}						\</span>
<span class="p_add">+		rc;						\</span>
<span class="p_add">+	})</span>
<span class="p_add">+</span>
 static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,
 			    unsigned int reg, unsigned int nb,
 			    unsigned int flags, unsigned int instr,
<span class="p_chunk">@@ -263,9 +285,10 @@</span> <span class="p_context"> static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,</span>
 		} else {
 			unsigned long pc = regs-&gt;nip ^ (swiz &amp; 4);
 
<span class="p_del">-			if (__get_user_inatomic(instr,</span>
<span class="p_del">-						(unsigned int __user *)pc))</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, instr,</span>
<span class="p_add">+						  (unsigned int __user *)pc))</span>
 				return -EFAULT;
<span class="p_add">+</span>
 			if (swiz == 0 &amp;&amp; (flags &amp; SW))
 				instr = cpu_to_le32(instr);
 			nb = (instr &gt;&gt; 11) &amp; 0x1f;
<span class="p_chunk">@@ -309,31 +332,31 @@</span> <span class="p_context"> static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,</span>
 			       ((nb0 + 3) / 4) * sizeof(unsigned long));
 
 		for (i = 0; i &lt; nb; ++i, ++p)
<span class="p_del">-			if (__get_user_inatomic(REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_del">-						SWIZ_PTR(p)))</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+						  SWIZ_PTR(p)))</span>
 				return -EFAULT;
 		if (nb0 &gt; 0) {
 			rptr = &amp;regs-&gt;gpr[0];
 			addr += nb;
 			for (i = 0; i &lt; nb0; ++i, ++p)
<span class="p_del">-				if (__get_user_inatomic(REG_BYTE(rptr,</span>
<span class="p_del">-								 i ^ bswiz),</span>
<span class="p_del">-							SWIZ_PTR(p)))</span>
<span class="p_add">+				if (__get_user_or_set_dar(regs,</span>
<span class="p_add">+							  REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+							  SWIZ_PTR(p)))</span>
 					return -EFAULT;
 		}
 
 	} else {
 		for (i = 0; i &lt; nb; ++i, ++p)
<span class="p_del">-			if (__put_user_inatomic(REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_del">-						SWIZ_PTR(p)))</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+						  SWIZ_PTR(p)))</span>
 				return -EFAULT;
 		if (nb0 &gt; 0) {
 			rptr = &amp;regs-&gt;gpr[0];
 			addr += nb;
 			for (i = 0; i &lt; nb0; ++i, ++p)
<span class="p_del">-				if (__put_user_inatomic(REG_BYTE(rptr,</span>
<span class="p_del">-								 i ^ bswiz),</span>
<span class="p_del">-							SWIZ_PTR(p)))</span>
<span class="p_add">+				if (__put_user_or_set_dar(regs,</span>
<span class="p_add">+							  REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+							  SWIZ_PTR(p)))</span>
 					return -EFAULT;
 		}
 	}
<span class="p_chunk">@@ -345,29 +368,32 @@</span> <span class="p_context"> static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,</span>
  * Only POWER6 has these instructions, and it does true little-endian,
  * so we don&#39;t need the address swizzling.
  */
<span class="p_del">-static int emulate_fp_pair(unsigned char __user *addr, unsigned int reg,</span>
<span class="p_del">-			   unsigned int flags)</span>
<span class="p_add">+static int emulate_fp_pair(struct pt_regs *regs, unsigned char __user *addr,</span>
<span class="p_add">+			   unsigned int reg, unsigned int flags)</span>
 {
 	char *ptr0 = (char *) &amp;current-&gt;thread.TS_FPR(reg);
 	char *ptr1 = (char *) &amp;current-&gt;thread.TS_FPR(reg+1);
<span class="p_del">-	int i, ret, sw = 0;</span>
<span class="p_add">+	int i, sw = 0;</span>
 
 	if (reg &amp; 1)
 		return 0;	/* invalid form: FRS/FRT must be even */
 	if (flags &amp; SW)
 		sw = 7;
<span class="p_del">-	ret = 0;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; 8; ++i) {
 		if (!(flags &amp; ST)) {
<span class="p_del">-			ret |= __get_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __get_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		} else {
<span class="p_del">-			ret |= __put_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __put_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		}
 	}
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+</span>
 	return 1;	/* exception handled and fixed up */
 }
 
<span class="p_chunk">@@ -377,24 +403,27 @@</span> <span class="p_context"> static int emulate_lq_stq(struct pt_regs *regs, unsigned char __user *addr,</span>
 {
 	char *ptr0 = (char *)&amp;regs-&gt;gpr[reg];
 	char *ptr1 = (char *)&amp;regs-&gt;gpr[reg+1];
<span class="p_del">-	int i, ret, sw = 0;</span>
<span class="p_add">+	int i, sw = 0;</span>
 
 	if (reg &amp; 1)
 		return 0;	/* invalid form: GPR must be even */
 	if (flags &amp; SW)
 		sw = 7;
<span class="p_del">-	ret = 0;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; 8; ++i) {
 		if (!(flags &amp; ST)) {
<span class="p_del">-			ret |= __get_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __get_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		} else {
<span class="p_del">-			ret |= __put_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __put_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		}
 	}
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+</span>
 	return 1;	/* exception handled and fixed up */
 }
 #endif /* CONFIG_PPC64 */
<span class="p_chunk">@@ -687,9 +716,14 @@</span> <span class="p_context"> static int emulate_vsx(unsigned char __user *addr, unsigned int reg,</span>
 	for (j = 0; j &lt; length; j += elsize) {
 		for (i = 0; i &lt; elsize; ++i) {
 			if (flags &amp; ST)
<span class="p_del">-				ret |= __put_user(ptr[i^sw], addr + i);</span>
<span class="p_add">+				ret = __put_user_or_set_dar(regs, ptr[i^sw],</span>
<span class="p_add">+							    addr + i);</span>
 			else
<span class="p_del">-				ret |= __get_user(ptr[i^sw], addr + i);</span>
<span class="p_add">+				ret = __get_user_or_set_dar(regs, ptr[i^sw],</span>
<span class="p_add">+							    addr + i);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
 		}
 		ptr  += elsize;
 #ifdef __LITTLE_ENDIAN__
<span class="p_chunk">@@ -739,7 +773,7 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 	unsigned int dsisr;
 	unsigned char __user *addr;
 	unsigned long p, swiz;
<span class="p_del">-	int ret, i;</span>
<span class="p_add">+	int i;</span>
 	union data {
 		u64 ll;
 		double dd;
<span class="p_chunk">@@ -936,7 +970,7 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 		if (flags &amp; F) {
 			/* Special case for 16-byte FP loads and stores */
 			PPC_WARN_ALIGNMENT(fp_pair, regs);
<span class="p_del">-			return emulate_fp_pair(addr, reg, flags);</span>
<span class="p_add">+			return emulate_fp_pair(regs, addr, reg, flags);</span>
 		} else {
 #ifdef CONFIG_PPC64
 			/* Special case for 16-byte loads and stores */
<span class="p_chunk">@@ -966,15 +1000,12 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 		}
 
 		data.ll = 0;
<span class="p_del">-		ret = 0;</span>
 		p = (unsigned long)addr;
 
 		for (i = 0; i &lt; nb; i++)
<span class="p_del">-			ret |= __get_user_inatomic(data.v[start + i],</span>
<span class="p_del">-						   SWIZ_PTR(p++));</span>
<span class="p_del">-</span>
<span class="p_del">-		if (unlikely(ret))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, data.v[start + i],</span>
<span class="p_add">+						  SWIZ_PTR(p++)))</span>
<span class="p_add">+				return -EFAULT;</span>
 
 	} else if (flags &amp; F) {
 		data.ll = current-&gt;thread.TS_FPR(reg);
<span class="p_chunk">@@ -1046,15 +1077,13 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 			break;
 		}
 
<span class="p_del">-		ret = 0;</span>
 		p = (unsigned long)addr;
 
 		for (i = 0; i &lt; nb; i++)
<span class="p_del">-			ret |= __put_user_inatomic(data.v[start + i],</span>
<span class="p_del">-						   SWIZ_PTR(p++));</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, data.v[start + i],</span>
<span class="p_add">+						  SWIZ_PTR(p++)))</span>
<span class="p_add">+				return -EFAULT;</span>
 
<span class="p_del">-		if (unlikely(ret))</span>
<span class="p_del">-			return -EFAULT;</span>
 	} else if (flags &amp; F)
 		current-&gt;thread.TS_FPR(reg) = data.ll;
 	else
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/npu-dma.c b/arch/powerpc/platforms/powernv/npu-dma.c</span>
<span class="p_header">index 4c7b8591f737..2cb6cbea4b3b 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/npu-dma.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/npu-dma.c</span>
<span class="p_chunk">@@ -545,6 +545,12 @@</span> <span class="p_context"> static void mmio_invalidate(struct npu_context *npu_context, int va,</span>
 	struct mmio_atsd_reg mmio_atsd_reg[NV_MAX_NPUS];
 	unsigned long pid = npu_context-&gt;mm-&gt;context.id;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Unfortunately the nest mmu does not support flushing specific</span>
<span class="p_add">+	 * addresses so we have to flush the whole mm.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	flush_tlb_mm(npu_context-&gt;mm);</span>
<span class="p_add">+</span>
 	/*
 	 * Loop over all the NPUs this process is active on and launch
 	 * an invalidate.
<span class="p_chunk">@@ -576,12 +582,6 @@</span> <span class="p_context"> static void mmio_invalidate(struct npu_context *npu_context, int va,</span>
 		}
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Unfortunately the nest mmu does not support flushing specific</span>
<span class="p_del">-	 * addresses so we have to flush the whole mm.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	flush_tlb_mm(npu_context-&gt;mm);</span>
<span class="p_del">-</span>
 	mmio_invalidate_wait(mmio_atsd_reg, flush);
 	if (flush)
 		/* Wait for the flush to complete */
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/hotplug-memory.c b/arch/powerpc/platforms/pseries/hotplug-memory.c</span>
<span class="p_header">index ca9b2f4aaa22..bf2f43f7ac6a 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/hotplug-memory.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/hotplug-memory.c</span>
<span class="p_chunk">@@ -817,6 +817,9 @@</span> <span class="p_context"> static int dlpar_memory_add_by_count(u32 lmbs_to_add, struct property *prop)</span>
 		return -EINVAL;
 
 	for (i = 0; i &lt; num_lmbs &amp;&amp; lmbs_to_add != lmbs_added; i++) {
<span class="p_add">+		if (lmbs[i].flags &amp; DRCONF_MEM_ASSIGNED)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		rc = dlpar_acquire_drc(lmbs[i].drc_index);
 		if (rc)
 			continue;
<span class="p_chunk">@@ -859,6 +862,7 @@</span> <span class="p_context"> static int dlpar_memory_add_by_count(u32 lmbs_to_add, struct property *prop)</span>
 				lmbs[i].base_addr, lmbs[i].drc_index);
 			lmbs[i].reserved = 0;
 		}
<span class="p_add">+		rc = 0;</span>
 	}
 
 	return rc;
<span class="p_header">diff --git a/arch/s390/include/asm/mmu.h b/arch/s390/include/asm/mmu.h</span>
<span class="p_header">index bd6f30304518..3525fe6e7e4c 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/mmu.h</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/errno.h&gt;
 
 typedef struct {
<span class="p_add">+	spinlock_t lock;</span>
 	cpumask_t cpu_attach_mask;
 	atomic_t flush_count;
 	unsigned int flush_mm;
<span class="p_chunk">@@ -27,6 +28,7 @@</span> <span class="p_context"> typedef struct {</span>
 } mm_context_t;
 
 #define INIT_MM_CONTEXT(name)						   \
<span class="p_add">+	.context.lock =	__SPIN_LOCK_UNLOCKED(name.context.lock),	   \</span>
 	.context.pgtable_lock =						   \
 			__SPIN_LOCK_UNLOCKED(name.context.pgtable_lock),   \
 	.context.pgtable_list = LIST_HEAD_INIT(name.context.pgtable_list), \
<span class="p_header">diff --git a/arch/s390/include/asm/mmu_context.h b/arch/s390/include/asm/mmu_context.h</span>
<span class="p_header">index 24bc41622a98..ebfb2f248ae9 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
 static inline int init_new_context(struct task_struct *tsk,
 				   struct mm_struct *mm)
 {
<span class="p_add">+	spin_lock_init(&amp;mm-&gt;context.lock);</span>
 	spin_lock_init(&amp;mm-&gt;context.pgtable_lock);
 	INIT_LIST_HEAD(&amp;mm-&gt;context.pgtable_list);
 	spin_lock_init(&amp;mm-&gt;context.gmap_lock);
<span class="p_chunk">@@ -102,7 +103,6 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 	if (prev == next)
 		return;
 	cpumask_set_cpu(cpu, &amp;next-&gt;context.cpu_attach_mask);
<span class="p_del">-	cpumask_set_cpu(cpu, mm_cpumask(next));</span>
 	/* Clear old ASCE by loading the kernel ASCE. */
 	__ctl_load(S390_lowcore.kernel_asce, 1, 1);
 	__ctl_load(S390_lowcore.kernel_asce, 7, 7);
<span class="p_chunk">@@ -120,9 +120,8 @@</span> <span class="p_context"> static inline void finish_arch_post_lock_switch(void)</span>
 		preempt_disable();
 		while (atomic_read(&amp;mm-&gt;context.flush_count))
 			cpu_relax();
<span class="p_del">-</span>
<span class="p_del">-		if (mm-&gt;context.flush_mm)</span>
<span class="p_del">-			__tlb_flush_mm(mm);</span>
<span class="p_add">+		cpumask_set_cpu(smp_processor_id(), mm_cpumask(mm));</span>
<span class="p_add">+		__tlb_flush_mm_lazy(mm);</span>
 		preempt_enable();
 	}
 	set_fs(current-&gt;thread.mm_segment);
<span class="p_chunk">@@ -135,6 +134,7 @@</span> <span class="p_context"> static inline void activate_mm(struct mm_struct *prev,</span>
                                struct mm_struct *next)
 {
 	switch_mm(prev, next, current);
<span class="p_add">+	cpumask_set_cpu(smp_processor_id(), mm_cpumask(next));</span>
 	set_user_asce(next);
 }
 
<span class="p_header">diff --git a/arch/s390/include/asm/tlbflush.h b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">index 39846100682a..eed927aeb08f 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -43,23 +43,6 @@</span> <span class="p_context"> static inline void __tlb_flush_global(void)</span>
  * Flush TLB entries for a specific mm on all CPUs (in case gmap is used
  * this implicates multiple ASCEs!).
  */
<span class="p_del">-static inline void __tlb_flush_full(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-	atomic_inc(&amp;mm-&gt;context.flush_count);</span>
<span class="p_del">-	if (cpumask_equal(mm_cpumask(mm), cpumask_of(smp_processor_id()))) {</span>
<span class="p_del">-		/* Local TLB flush */</span>
<span class="p_del">-		__tlb_flush_local();</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* Global TLB flush */</span>
<span class="p_del">-		__tlb_flush_global();</span>
<span class="p_del">-		/* Reset TLB flush mask */</span>
<span class="p_del">-		cpumask_copy(mm_cpumask(mm), &amp;mm-&gt;context.cpu_attach_mask);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	atomic_dec(&amp;mm-&gt;context.flush_count);</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void __tlb_flush_mm(struct mm_struct *mm)
 {
 	unsigned long gmap_asce;
<span class="p_chunk">@@ -71,16 +54,18 @@</span> <span class="p_context"> static inline void __tlb_flush_mm(struct mm_struct *mm)</span>
 	 */
 	preempt_disable();
 	atomic_inc(&amp;mm-&gt;context.flush_count);
<span class="p_add">+	/* Reset TLB flush mask */</span>
<span class="p_add">+	cpumask_copy(mm_cpumask(mm), &amp;mm-&gt;context.cpu_attach_mask);</span>
<span class="p_add">+	barrier();</span>
 	gmap_asce = READ_ONCE(mm-&gt;context.gmap_asce);
 	if (MACHINE_HAS_IDTE &amp;&amp; gmap_asce != -1UL) {
 		if (gmap_asce)
 			__tlb_flush_idte(gmap_asce);
 		__tlb_flush_idte(mm-&gt;context.asce);
 	} else {
<span class="p_del">-		__tlb_flush_full(mm);</span>
<span class="p_add">+		/* Global TLB flush */</span>
<span class="p_add">+		__tlb_flush_global();</span>
 	}
<span class="p_del">-	/* Reset TLB flush mask */</span>
<span class="p_del">-	cpumask_copy(mm_cpumask(mm), &amp;mm-&gt;context.cpu_attach_mask);</span>
 	atomic_dec(&amp;mm-&gt;context.flush_count);
 	preempt_enable();
 }
<span class="p_chunk">@@ -94,7 +79,6 @@</span> <span class="p_context"> static inline void __tlb_flush_kernel(void)</span>
 }
 #else
 #define __tlb_flush_global()	__tlb_flush_local()
<span class="p_del">-#define __tlb_flush_full(mm)	__tlb_flush_local()</span>
 
 /*
  * Flush TLB entries for a specific ASCE on all CPUs.
<span class="p_chunk">@@ -112,10 +96,12 @@</span> <span class="p_context"> static inline void __tlb_flush_kernel(void)</span>
 
 static inline void __tlb_flush_mm_lazy(struct mm_struct * mm)
 {
<span class="p_add">+	spin_lock(&amp;mm-&gt;context.lock);</span>
 	if (mm-&gt;context.flush_mm) {
<span class="p_del">-		__tlb_flush_mm(mm);</span>
 		mm-&gt;context.flush_mm = 0;
<span class="p_add">+		__tlb_flush_mm(mm);</span>
 	}
<span class="p_add">+	spin_unlock(&amp;mm-&gt;context.lock);</span>
 }
 
 /*
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index dbecbf4a64e0..658f67309602 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -280,7 +280,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_start_queue_async);</span>
 void blk_start_queue(struct request_queue *q)
 {
 	lockdep_assert_held(q-&gt;queue_lock);
<span class="p_del">-	WARN_ON(!irqs_disabled());</span>
<span class="p_add">+	WARN_ON(!in_interrupt() &amp;&amp; !irqs_disabled());</span>
 	WARN_ON_ONCE(q-&gt;mq_ops);
 
 	queue_flag_clear(QUEUE_FLAG_STOPPED, q);
<span class="p_chunk">@@ -2330,7 +2330,12 @@</span> <span class="p_context"> blk_status_t blk_insert_cloned_request(struct request_queue *q, struct request *</span>
 	if (q-&gt;mq_ops) {
 		if (blk_queue_io_stat(q))
 			blk_account_io_start(rq, true);
<span class="p_del">-		blk_mq_sched_insert_request(rq, false, true, false, false);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Since we have a scheduler attached on the top device,</span>
<span class="p_add">+		 * bypass a potential scheduler on the bottom device for</span>
<span class="p_add">+		 * insert.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		blk_mq_request_bypass_insert(rq);</span>
 		return BLK_STS_OK;
 	}
 
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 4603b115e234..e0523eb8eee1 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -1357,6 +1357,22 @@</span> <span class="p_context"> void __blk_mq_insert_request(struct blk_mq_hw_ctx *hctx, struct request *rq,</span>
 	blk_mq_hctx_mark_pending(hctx, ctx);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Should only be used carefully, when the caller knows we want to</span>
<span class="p_add">+ * bypass a potential IO scheduler on the target device.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void blk_mq_request_bypass_insert(struct request *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct blk_mq_ctx *ctx = rq-&gt;mq_ctx;</span>
<span class="p_add">+	struct blk_mq_hw_ctx *hctx = blk_mq_map_queue(rq-&gt;q, ctx-&gt;cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;hctx-&gt;lock);</span>
<span class="p_add">+	list_add_tail(&amp;rq-&gt;queuelist, &amp;hctx-&gt;dispatch);</span>
<span class="p_add">+	spin_unlock(&amp;hctx-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	blk_mq_run_hw_queue(hctx, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void blk_mq_insert_requests(struct blk_mq_hw_ctx *hctx, struct blk_mq_ctx *ctx,
 			    struct list_head *list)
 
<span class="p_header">diff --git a/block/blk-mq.h b/block/blk-mq.h</span>
<span class="p_header">index 60b01c0309bc..f64747914560 100644</span>
<span class="p_header">--- a/block/blk-mq.h</span>
<span class="p_header">+++ b/block/blk-mq.h</span>
<span class="p_chunk">@@ -54,6 +54,7 @@</span> <span class="p_context"> int blk_mq_alloc_rqs(struct blk_mq_tag_set *set, struct blk_mq_tags *tags,</span>
  */
 void __blk_mq_insert_request(struct blk_mq_hw_ctx *hctx, struct request *rq,
 				bool at_head);
<span class="p_add">+void blk_mq_request_bypass_insert(struct request *rq);</span>
 void blk_mq_insert_requests(struct blk_mq_hw_ctx *hctx, struct blk_mq_ctx *ctx,
 				struct list_head *list);
 
<span class="p_header">diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c</span>
<span class="p_header">index 903605dbc1a5..76b875c69a95 100644</span>
<span class="p_header">--- a/crypto/algif_skcipher.c</span>
<span class="p_header">+++ b/crypto/algif_skcipher.c</span>
<span class="p_chunk">@@ -144,8 +144,10 @@</span> <span class="p_context"> static int skcipher_alloc_sgl(struct sock *sk)</span>
 		sg_init_table(sgl-&gt;sg, MAX_SGL_ENTS + 1);
 		sgl-&gt;cur = 0;
 
<span class="p_del">-		if (sg)</span>
<span class="p_add">+		if (sg) {</span>
 			sg_chain(sg, MAX_SGL_ENTS + 1, sgl-&gt;sg);
<span class="p_add">+			sg_unmark_end(sg + (MAX_SGL_ENTS - 1));</span>
<span class="p_add">+		}</span>
 
 		list_add_tail(&amp;sgl-&gt;list, &amp;ctx-&gt;tsgl);
 	}
<span class="p_header">diff --git a/crypto/scompress.c b/crypto/scompress.c</span>
<span class="p_header">index ae1d3cf209e4..0b40d991d65f 100644</span>
<span class="p_header">--- a/crypto/scompress.c</span>
<span class="p_header">+++ b/crypto/scompress.c</span>
<span class="p_chunk">@@ -211,9 +211,7 @@</span> <span class="p_context"> static int scomp_acomp_comp_decomp(struct acomp_req *req, int dir)</span>
 					      scratch_dst, &amp;req-&gt;dlen, *ctx);
 	if (!ret) {
 		if (!req-&gt;dst) {
<span class="p_del">-			req-&gt;dst = crypto_scomp_sg_alloc(req-&gt;dlen,</span>
<span class="p_del">-				   req-&gt;base.flags &amp; CRYPTO_TFM_REQ_MAY_SLEEP ?</span>
<span class="p_del">-				   GFP_KERNEL : GFP_ATOMIC);</span>
<span class="p_add">+			req-&gt;dst = crypto_scomp_sg_alloc(req-&gt;dlen, GFP_ATOMIC);</span>
 			if (!req-&gt;dst)
 				goto out;
 		}
<span class="p_header">diff --git a/drivers/block/skd_main.c b/drivers/block/skd_main.c</span>
<span class="p_header">index d0368682bd43..153f20ce318b 100644</span>
<span class="p_header">--- a/drivers/block/skd_main.c</span>
<span class="p_header">+++ b/drivers/block/skd_main.c</span>
<span class="p_chunk">@@ -2160,6 +2160,9 @@</span> <span class="p_context"> static void skd_send_fitmsg(struct skd_device *skdev,</span>
 		 */
 		qcmd |= FIT_QCMD_MSGSIZE_64;
 
<span class="p_add">+	/* Make sure skd_msg_buf is written before the doorbell is triggered. */</span>
<span class="p_add">+	smp_wmb();</span>
<span class="p_add">+</span>
 	SKD_WRITEQ(skdev, qcmd, FIT_Q_COMMAND);
 }
 
<span class="p_chunk">@@ -2202,6 +2205,9 @@</span> <span class="p_context"> static void skd_send_special_fitmsg(struct skd_device *skdev,</span>
 	qcmd = skspcl-&gt;mb_dma_address;
 	qcmd |= FIT_QCMD_QID_NORMAL + FIT_QCMD_MSGSIZE_128;
 
<span class="p_add">+	/* Make sure skd_msg_buf is written before the doorbell is triggered. */</span>
<span class="p_add">+	smp_wmb();</span>
<span class="p_add">+</span>
 	SKD_WRITEQ(skdev, qcmd, FIT_Q_COMMAND);
 }
 
<span class="p_chunk">@@ -4539,15 +4545,16 @@</span> <span class="p_context"> static void skd_free_disk(struct skd_device *skdev)</span>
 {
 	struct gendisk *disk = skdev-&gt;disk;
 
<span class="p_del">-	if (disk != NULL) {</span>
<span class="p_del">-		struct request_queue *q = disk-&gt;queue;</span>
<span class="p_add">+	if (disk &amp;&amp; (disk-&gt;flags &amp; GENHD_FL_UP))</span>
<span class="p_add">+		del_gendisk(disk);</span>
 
<span class="p_del">-		if (disk-&gt;flags &amp; GENHD_FL_UP)</span>
<span class="p_del">-			del_gendisk(disk);</span>
<span class="p_del">-		if (q)</span>
<span class="p_del">-			blk_cleanup_queue(q);</span>
<span class="p_del">-		put_disk(disk);</span>
<span class="p_add">+	if (skdev-&gt;queue) {</span>
<span class="p_add">+		blk_cleanup_queue(skdev-&gt;queue);</span>
<span class="p_add">+		skdev-&gt;queue = NULL;</span>
<span class="p_add">+		disk-&gt;queue = NULL;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	put_disk(disk);</span>
 	skdev-&gt;disk = NULL;
 }
 
<span class="p_header">diff --git a/drivers/crypto/caam/caamalg_qi.c b/drivers/crypto/caam/caamalg_qi.c</span>
<span class="p_header">index 3425f2d9a2a1..fe0185ceac16 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamalg_qi.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamalg_qi.c</span>
<span class="p_chunk">@@ -776,9 +776,9 @@</span> <span class="p_context"> static void ablkcipher_done(struct caam_drv_req *drv_req, u32 status)</span>
 	struct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);
 	struct caam_ctx *caam_ctx = crypto_ablkcipher_ctx(ablkcipher);
 	struct device *qidev = caam_ctx-&gt;qidev;
<span class="p_del">-#ifdef DEBUG</span>
 	int ivsize = crypto_ablkcipher_ivsize(ablkcipher);
 
<span class="p_add">+#ifdef DEBUG</span>
 	dev_err(qidev, &quot;%s %d: status 0x%x\n&quot;, __func__, __LINE__, status);
 #endif
 
<span class="p_chunk">@@ -799,6 +799,13 @@</span> <span class="p_context"> static void ablkcipher_done(struct caam_drv_req *drv_req, u32 status)</span>
 	ablkcipher_unmap(qidev, edesc, req);
 	qi_cache_free(edesc);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The crypto API expects us to set the IV (req-&gt;info) to the last</span>
<span class="p_add">+	 * ciphertext block. This is used e.g. by the CTS mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	scatterwalk_map_and_copy(req-&gt;info, req-&gt;dst, req-&gt;nbytes - ivsize,</span>
<span class="p_add">+				 ivsize, 0);</span>
<span class="p_add">+</span>
 	ablkcipher_request_complete(req, status);
 }
 
<span class="p_chunk">@@ -1968,7 +1975,7 @@</span> <span class="p_context"> static struct caam_aead_alg driver_aeads[] = {</span>
 				.cra_name = &quot;echainiv(authenc(hmac(sha256),&quot;
 					    &quot;cbc(des)))&quot;,
 				.cra_driver_name = &quot;echainiv-authenc-&quot;
<span class="p_del">-						   &quot;hmac-sha256-cbc-desi-&quot;</span>
<span class="p_add">+						   &quot;hmac-sha256-cbc-des-&quot;</span>
 						   &quot;caam-qi&quot;,
 				.cra_blocksize = DES_BLOCK_SIZE,
 			},
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto-aes-xts.c b/drivers/crypto/ccp/ccp-crypto-aes-xts.c</span>
<span class="p_header">index 58a4244b4752..3f26a415ef44 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto-aes-xts.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto-aes-xts.c</span>
<span class="p_chunk">@@ -1,8 +1,9 @@</span> <span class="p_context"></span>
 /*
  * AMD Cryptographic Coprocessor (CCP) AES XTS crypto API support
  *
<span class="p_del">- * Copyright (C) 2013 Advanced Micro Devices, Inc.</span>
<span class="p_add">+ * Copyright (C) 2013,2017 Advanced Micro Devices, Inc.</span>
  *
<span class="p_add">+ * Author: Gary R Hook &lt;gary.hook@amd.com&gt;</span>
  * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
  *
  * This program is free software; you can redistribute it and/or modify
<span class="p_chunk">@@ -164,6 +165,7 @@</span> <span class="p_context"> static int ccp_aes_xts_crypt(struct ablkcipher_request *req,</span>
 	memset(&amp;rctx-&gt;cmd, 0, sizeof(rctx-&gt;cmd));
 	INIT_LIST_HEAD(&amp;rctx-&gt;cmd.entry);
 	rctx-&gt;cmd.engine = CCP_ENGINE_XTS_AES_128;
<span class="p_add">+	rctx-&gt;cmd.u.xts.type = CCP_AES_TYPE_128;</span>
 	rctx-&gt;cmd.u.xts.action = (encrypt) ? CCP_AES_ACTION_ENCRYPT
 					   : CCP_AES_ACTION_DECRYPT;
 	rctx-&gt;cmd.u.xts.unit_size = unit_size;
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-dev-v5.c b/drivers/crypto/ccp/ccp-dev-v5.c</span>
<span class="p_header">index b10d2d2075cb..9bc134a4ebf0 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-dev-v5.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-dev-v5.c</span>
<span class="p_chunk">@@ -145,6 +145,7 @@</span> <span class="p_context"> union ccp_function {</span>
 #define	CCP_AES_MODE(p)		((p)-&gt;aes.mode)
 #define	CCP_AES_TYPE(p)		((p)-&gt;aes.type)
 #define	CCP_XTS_SIZE(p)		((p)-&gt;aes_xts.size)
<span class="p_add">+#define	CCP_XTS_TYPE(p)		((p)-&gt;aes_xts.type)</span>
 #define	CCP_XTS_ENCRYPT(p)	((p)-&gt;aes_xts.encrypt)
 #define	CCP_DES3_SIZE(p)	((p)-&gt;des3.size)
 #define	CCP_DES3_ENCRYPT(p)	((p)-&gt;des3.encrypt)
<span class="p_chunk">@@ -344,6 +345,7 @@</span> <span class="p_context"> static int ccp5_perform_xts_aes(struct ccp_op *op)</span>
 	CCP5_CMD_PROT(&amp;desc) = 0;
 
 	function.raw = 0;
<span class="p_add">+	CCP_XTS_TYPE(&amp;function) = op-&gt;u.xts.type;</span>
 	CCP_XTS_ENCRYPT(&amp;function) = op-&gt;u.xts.action;
 	CCP_XTS_SIZE(&amp;function) = op-&gt;u.xts.unit_size;
 	CCP5_CMD_FUNCTION(&amp;desc) = function.raw;
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-dev.h b/drivers/crypto/ccp/ccp-dev.h</span>
<span class="p_header">index a70154ac7405..7b8370e9c42e 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-dev.h</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-dev.h</span>
<span class="p_chunk">@@ -192,6 +192,7 @@</span> <span class="p_context"></span>
 #define CCP_AES_CTX_SB_COUNT		1
 
 #define CCP_XTS_AES_KEY_SB_COUNT	1
<span class="p_add">+#define CCP5_XTS_AES_KEY_SB_COUNT	2</span>
 #define CCP_XTS_AES_CTX_SB_COUNT	1
 
 #define CCP_DES3_KEY_SB_COUNT		1
<span class="p_chunk">@@ -497,6 +498,7 @@</span> <span class="p_context"> struct ccp_aes_op {</span>
 };
 
 struct ccp_xts_aes_op {
<span class="p_add">+	enum ccp_aes_type type;</span>
 	enum ccp_aes_action action;
 	enum ccp_xts_aes_unit_size unit_size;
 };
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-ops.c b/drivers/crypto/ccp/ccp-ops.c</span>
<span class="p_header">index c0dfdacbdff5..f3542aede519 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-ops.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-ops.c</span>
<span class="p_chunk">@@ -1038,6 +1038,8 @@</span> <span class="p_context"> static int ccp_run_xts_aes_cmd(struct ccp_cmd_queue *cmd_q,</span>
 	struct ccp_op op;
 	unsigned int unit_size, dm_offset;
 	bool in_place = false;
<span class="p_add">+	unsigned int sb_count;</span>
<span class="p_add">+	enum ccp_aes_type aestype;</span>
 	int ret;
 
 	switch (xts-&gt;unit_size) {
<span class="p_chunk">@@ -1061,7 +1063,9 @@</span> <span class="p_context"> static int ccp_run_xts_aes_cmd(struct ccp_cmd_queue *cmd_q,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (xts-&gt;key_len != AES_KEYSIZE_128)</span>
<span class="p_add">+	if (xts-&gt;key_len == AES_KEYSIZE_128)</span>
<span class="p_add">+		aestype = CCP_AES_TYPE_128;</span>
<span class="p_add">+	else</span>
 		return -EINVAL;
 
 	if (!xts-&gt;final &amp;&amp; (xts-&gt;src_len &amp; (AES_BLOCK_SIZE - 1)))
<span class="p_chunk">@@ -1083,23 +1087,44 @@</span> <span class="p_context"> static int ccp_run_xts_aes_cmd(struct ccp_cmd_queue *cmd_q,</span>
 	op.sb_key = cmd_q-&gt;sb_key;
 	op.sb_ctx = cmd_q-&gt;sb_ctx;
 	op.init = 1;
<span class="p_add">+	op.u.xts.type = aestype;</span>
 	op.u.xts.action = xts-&gt;action;
 	op.u.xts.unit_size = xts-&gt;unit_size;
 
<span class="p_del">-	/* All supported key sizes fit in a single (32-byte) SB entry</span>
<span class="p_del">-	 * and must be in little endian format. Use the 256-bit byte</span>
<span class="p_del">-	 * swap passthru option to convert from big endian to little</span>
<span class="p_del">-	 * endian.</span>
<span class="p_add">+	/* A version 3 device only supports 128-bit keys, which fits into a</span>
<span class="p_add">+	 * single SB entry. A version 5 device uses a 512-bit vector, so two</span>
<span class="p_add">+	 * SB entries.</span>
 	 */
<span class="p_add">+	if (cmd_q-&gt;ccp-&gt;vdata-&gt;version == CCP_VERSION(3, 0))</span>
<span class="p_add">+		sb_count = CCP_XTS_AES_KEY_SB_COUNT;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sb_count = CCP5_XTS_AES_KEY_SB_COUNT;</span>
 	ret = ccp_init_dm_workarea(&amp;key, cmd_q,
<span class="p_del">-				   CCP_XTS_AES_KEY_SB_COUNT * CCP_SB_BYTES,</span>
<span class="p_add">+				   sb_count * CCP_SB_BYTES,</span>
 				   DMA_TO_DEVICE);
 	if (ret)
 		return ret;
 
<span class="p_del">-	dm_offset = CCP_SB_BYTES - AES_KEYSIZE_128;</span>
<span class="p_del">-	ccp_set_dm_area(&amp;key, dm_offset, xts-&gt;key, 0, xts-&gt;key_len);</span>
<span class="p_del">-	ccp_set_dm_area(&amp;key, 0, xts-&gt;key, dm_offset, xts-&gt;key_len);</span>
<span class="p_add">+	if (cmd_q-&gt;ccp-&gt;vdata-&gt;version == CCP_VERSION(3, 0)) {</span>
<span class="p_add">+		/* All supported key sizes must be in little endian format.</span>
<span class="p_add">+		 * Use the 256-bit byte swap passthru option to convert from</span>
<span class="p_add">+		 * big endian to little endian.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		dm_offset = CCP_SB_BYTES - AES_KEYSIZE_128;</span>
<span class="p_add">+		ccp_set_dm_area(&amp;key, dm_offset, xts-&gt;key, 0, xts-&gt;key_len);</span>
<span class="p_add">+		ccp_set_dm_area(&amp;key, 0, xts-&gt;key, xts-&gt;key_len, xts-&gt;key_len);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Version 5 CCPs use a 512-bit space for the key: each portion</span>
<span class="p_add">+		 * occupies 256 bits, or one entire slot, and is zero-padded.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		unsigned int pad;</span>
<span class="p_add">+</span>
<span class="p_add">+		dm_offset = CCP_SB_BYTES;</span>
<span class="p_add">+		pad = dm_offset - xts-&gt;key_len;</span>
<span class="p_add">+		ccp_set_dm_area(&amp;key, pad, xts-&gt;key, 0, xts-&gt;key_len);</span>
<span class="p_add">+		ccp_set_dm_area(&amp;key, dm_offset + pad, xts-&gt;key, xts-&gt;key_len,</span>
<span class="p_add">+				xts-&gt;key_len);</span>
<span class="p_add">+	}</span>
 	ret = ccp_copy_to_sb(cmd_q, &amp;key, op.jobid, op.sb_key,
 			     CCP_PASSTHRU_BYTESWAP_256BIT);
 	if (ret) {
<span class="p_header">diff --git a/drivers/devfreq/devfreq.c b/drivers/devfreq/devfreq.c</span>
<span class="p_header">index dea04871b50d..a1c4ee818614 100644</span>
<span class="p_header">--- a/drivers/devfreq/devfreq.c</span>
<span class="p_header">+++ b/drivers/devfreq/devfreq.c</span>
<span class="p_chunk">@@ -564,7 +564,7 @@</span> <span class="p_context"> struct devfreq *devfreq_add_device(struct device *dev,</span>
 	err = device_register(&amp;devfreq-&gt;dev);
 	if (err) {
 		mutex_unlock(&amp;devfreq-&gt;lock);
<span class="p_del">-		goto err_out;</span>
<span class="p_add">+		goto err_dev;</span>
 	}
 
 	devfreq-&gt;trans_table =	devm_kzalloc(&amp;devfreq-&gt;dev,
<span class="p_chunk">@@ -610,6 +610,9 @@</span> <span class="p_context"> struct devfreq *devfreq_add_device(struct device *dev,</span>
 	mutex_unlock(&amp;devfreq_list_lock);
 
 	device_unregister(&amp;devfreq-&gt;dev);
<span class="p_add">+err_dev:</span>
<span class="p_add">+	if (devfreq)</span>
<span class="p_add">+		kfree(devfreq);</span>
 err_out:
 	return ERR_PTR(err);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c</span>
<span class="p_header">index 4083be61b328..6417febe18b9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c</span>
<span class="p_chunk">@@ -95,9 +95,8 @@</span> <span class="p_context"> int psp_wait_for(struct psp_context *psp, uint32_t reg_index,</span>
 	int i;
 	struct amdgpu_device *adev = psp-&gt;adev;
 
<span class="p_del">-	val = RREG32(reg_index);</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; adev-&gt;usec_timeout; i++) {
<span class="p_add">+		val = RREG32(reg_index);</span>
 		if (check_changed) {
 			if (val != reg_val)
 				return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/psp_v3_1.c b/drivers/gpu/drm/amd/amdgpu/psp_v3_1.c</span>
<span class="p_header">index c98d77d0c8f8..6f80ad8f588b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/psp_v3_1.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/psp_v3_1.c</span>
<span class="p_chunk">@@ -237,11 +237,9 @@</span> <span class="p_context"> int psp_v3_1_bootloader_load_sos(struct psp_context *psp)</span>
 
 	/* there might be handshake issue with hardware which needs delay */
 	mdelay(20);
<span class="p_del">-#if 0</span>
 	ret = psp_wait_for(psp, SOC15_REG_OFFSET(MP0, 0, mmMP0_SMN_C2PMSG_81),
 			   RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81),
 			   0, true);
<span class="p_del">-#endif</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/init.c b/drivers/infiniband/hw/hfi1/init.c</span>
<span class="p_header">index 4a11d4da4c92..ff30b34c8984 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/init.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/init.c</span>
<span class="p_chunk">@@ -483,7 +483,6 @@</span> <span class="p_context"> void hfi1_init_pportdata(struct pci_dev *pdev, struct hfi1_pportdata *ppd,</span>
 
 	ppd-&gt;pkeys[default_pkey_idx] = DEFAULT_P_KEY;
 	ppd-&gt;part_enforce |= HFI1_PART_ENFORCE_IN;
<span class="p_del">-	ppd-&gt;part_enforce |= HFI1_PART_ENFORCE_OUT;</span>
 
 	if (loopback) {
 		hfi1_early_err(&amp;pdev-&gt;dev,
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/rc.c b/drivers/infiniband/hw/hfi1/rc.c</span>
<span class="p_header">index 1080778a1f7c..0c73fb0c2c1b 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/rc.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/rc.c</span>
<span class="p_chunk">@@ -425,7 +425,7 @@</span> <span class="p_context"> int hfi1_make_rc_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)</span>
 		case IB_WR_RDMA_WRITE:
 			if (newreq &amp;&amp; !(qp-&gt;s_flags &amp; RVT_S_UNLIMITED_CREDIT))
 				qp-&gt;s_lsn++;
<span class="p_del">-			/* FALLTHROUGH */</span>
<span class="p_add">+			goto no_flow_control;</span>
 		case IB_WR_RDMA_WRITE_WITH_IMM:
 			/* If no credit, return. */
 			if (!(qp-&gt;s_flags &amp; RVT_S_UNLIMITED_CREDIT) &amp;&amp;
<span class="p_chunk">@@ -433,6 +433,7 @@</span> <span class="p_context"> int hfi1_make_rc_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)</span>
 				qp-&gt;s_flags |= RVT_S_WAIT_SSN_CREDIT;
 				goto bail;
 			}
<span class="p_add">+no_flow_control:</span>
 			put_ib_reth_vaddr(
 				wqe-&gt;rdma_wr.remote_addr,
 				&amp;ohdr-&gt;u.rc.reth);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">index 2c40a2e989d2..a0eb2f96179a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_chunk">@@ -48,6 +48,7 @@</span> <span class="p_context"> enum {</span>
 #define MLX5_UMR_ALIGN 2048
 
 static int clean_mr(struct mlx5_ib_mr *mr);
<span class="p_add">+static int max_umr_order(struct mlx5_ib_dev *dev);</span>
 static int use_umr(struct mlx5_ib_dev *dev, int order);
 static int unreg_umr(struct mlx5_ib_dev *dev, struct mlx5_ib_mr *mr);
 
<span class="p_chunk">@@ -491,16 +492,18 @@</span> <span class="p_context"> static struct mlx5_ib_mr *alloc_cached_mr(struct mlx5_ib_dev *dev, int order)</span>
 	struct mlx5_mr_cache *cache = &amp;dev-&gt;cache;
 	struct mlx5_ib_mr *mr = NULL;
 	struct mlx5_cache_ent *ent;
<span class="p_add">+	int last_umr_cache_entry;</span>
 	int c;
 	int i;
 
 	c = order2idx(dev, order);
<span class="p_del">-	if (c &lt; 0 || c &gt; MAX_UMR_CACHE_ENTRY) {</span>
<span class="p_add">+	last_umr_cache_entry = order2idx(dev, max_umr_order(dev));</span>
<span class="p_add">+	if (c &lt; 0 || c &gt; last_umr_cache_entry) {</span>
 		mlx5_ib_warn(dev, &quot;order %d, cache index %d\n&quot;, order, c);
 		return NULL;
 	}
 
<span class="p_del">-	for (i = c; i &lt; MAX_UMR_CACHE_ENTRY; i++) {</span>
<span class="p_add">+	for (i = c; i &lt;= last_umr_cache_entry; i++) {</span>
 		ent = &amp;cache-&gt;ent[i];
 
 		mlx5_ib_dbg(dev, &quot;order %d, cache index %d\n&quot;, ent-&gt;order, i);
<span class="p_chunk">@@ -816,11 +819,16 @@</span> <span class="p_context"> static int get_octo_len(u64 addr, u64 len, int page_size)</span>
 	return (npages + 1) / 2;
 }
 
<span class="p_del">-static int use_umr(struct mlx5_ib_dev *dev, int order)</span>
<span class="p_add">+static int max_umr_order(struct mlx5_ib_dev *dev)</span>
 {
 	if (MLX5_CAP_GEN(dev-&gt;mdev, umr_extended_translation_offset))
<span class="p_del">-		return order &lt;= MAX_UMR_CACHE_ENTRY + 2;</span>
<span class="p_del">-	return order &lt;= MLX5_MAX_UMR_SHIFT;</span>
<span class="p_add">+		return MAX_UMR_CACHE_ENTRY + 2;</span>
<span class="p_add">+	return MLX5_MAX_UMR_SHIFT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int use_umr(struct mlx5_ib_dev *dev, int order)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return order &lt;= max_umr_order(dev);</span>
 }
 
 static int mr_umem_get(struct ib_pd *pd, u64 start, u64 length,
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_rc.c b/drivers/infiniband/hw/qib/qib_rc.c</span>
<span class="p_header">index 4ddbcac5eabe..e9a91736b12d 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_rc.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_rc.c</span>
<span class="p_chunk">@@ -348,7 +348,7 @@</span> <span class="p_context"> int qib_make_rc_req(struct rvt_qp *qp, unsigned long *flags)</span>
 		case IB_WR_RDMA_WRITE:
 			if (newreq &amp;&amp; !(qp-&gt;s_flags &amp; RVT_S_UNLIMITED_CREDIT))
 				qp-&gt;s_lsn++;
<span class="p_del">-			/* FALLTHROUGH */</span>
<span class="p_add">+			goto no_flow_control;</span>
 		case IB_WR_RDMA_WRITE_WITH_IMM:
 			/* If no credit, return. */
 			if (!(qp-&gt;s_flags &amp; RVT_S_UNLIMITED_CREDIT) &amp;&amp;
<span class="p_chunk">@@ -356,7 +356,7 @@</span> <span class="p_context"> int qib_make_rc_req(struct rvt_qp *qp, unsigned long *flags)</span>
 				qp-&gt;s_flags |= RVT_S_WAIT_SSN_CREDIT;
 				goto bail;
 			}
<span class="p_del">-</span>
<span class="p_add">+no_flow_control:</span>
 			ohdr-&gt;u.rc.reth.vaddr =
 				cpu_to_be64(wqe-&gt;rdma_wr.remote_addr);
 			ohdr-&gt;u.rc.reth.rkey =
<span class="p_header">diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c</span>
<span class="p_header">index ca0e19ae7a90..f6d0c8f51613 100644</span>
<span class="p_header">--- a/drivers/input/joystick/xpad.c</span>
<span class="p_header">+++ b/drivers/input/joystick/xpad.c</span>
<span class="p_chunk">@@ -1764,10 +1764,12 @@</span> <span class="p_context"> static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 		struct usb_endpoint_descriptor *ep =
 				&amp;intf-&gt;cur_altsetting-&gt;endpoint[i].desc;
 
<span class="p_del">-		if (usb_endpoint_dir_in(ep))</span>
<span class="p_del">-			ep_irq_in = ep;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ep_irq_out = ep;</span>
<span class="p_add">+		if (usb_endpoint_xfer_int(ep)) {</span>
<span class="p_add">+			if (usb_endpoint_dir_in(ep))</span>
<span class="p_add">+				ep_irq_in = ep;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				ep_irq_out = ep;</span>
<span class="p_add">+		}</span>
 	}
 
 	if (!ep_irq_in || !ep_irq_out) {
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index f932a83b4990..9125ad017eda 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -839,6 +839,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_kbdreset_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;P34&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Gigabyte P57 - Elantech touchpad */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;GIGABYTE&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;P57&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{
 		/* Schenker XMG C504 - Elantech touchpad */
 		.matches = {
<span class="p_header">diff --git a/drivers/mailbox/bcm-flexrm-mailbox.c b/drivers/mailbox/bcm-flexrm-mailbox.c</span>
<span class="p_header">index da67882caa7b..0e298ed42ae0 100644</span>
<span class="p_header">--- a/drivers/mailbox/bcm-flexrm-mailbox.c</span>
<span class="p_header">+++ b/drivers/mailbox/bcm-flexrm-mailbox.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"></span>
 
 /* Register RING_CMPL_START_ADDR fields */
 #define CMPL_START_ADDR_VALUE(pa)			\
<span class="p_del">-	((u32)((((u64)(pa)) &gt;&gt; RING_CMPL_ALIGN_ORDER) &amp; 0x03ffffff))</span>
<span class="p_add">+	((u32)((((u64)(pa)) &gt;&gt; RING_CMPL_ALIGN_ORDER) &amp; 0x07ffffff))</span>
 
 /* Register RING_CONTROL fields */
 #define CONTROL_MASK_DISABLE_CONTROL			12
<span class="p_header">diff --git a/drivers/md/bcache/bcache.h b/drivers/md/bcache/bcache.h</span>
<span class="p_header">index dee542fff68e..2ed9bd231d84 100644</span>
<span class="p_header">--- a/drivers/md/bcache/bcache.h</span>
<span class="p_header">+++ b/drivers/md/bcache/bcache.h</span>
<span class="p_chunk">@@ -333,6 +333,7 @@</span> <span class="p_context"> struct cached_dev {</span>
 	/* Limit number of writeback bios in flight */
 	struct semaphore	in_flight;
 	struct task_struct	*writeback_thread;
<span class="p_add">+	struct workqueue_struct	*writeback_write_wq;</span>
 
 	struct keybuf		writeback_keys;
 
<span class="p_header">diff --git a/drivers/md/bcache/request.c b/drivers/md/bcache/request.c</span>
<span class="p_header">index 019b3df9f1c6..4b413db99276 100644</span>
<span class="p_header">--- a/drivers/md/bcache/request.c</span>
<span class="p_header">+++ b/drivers/md/bcache/request.c</span>
<span class="p_chunk">@@ -196,12 +196,12 @@</span> <span class="p_context"> static void bch_data_insert_start(struct closure *cl)</span>
 	struct data_insert_op *op = container_of(cl, struct data_insert_op, cl);
 	struct bio *bio = op-&gt;bio, *n;
 
<span class="p_del">-	if (atomic_sub_return(bio_sectors(bio), &amp;op-&gt;c-&gt;sectors_to_gc) &lt; 0)</span>
<span class="p_del">-		wake_up_gc(op-&gt;c);</span>
<span class="p_del">-</span>
 	if (op-&gt;bypass)
 		return bch_data_invalidate(cl);
 
<span class="p_add">+	if (atomic_sub_return(bio_sectors(bio), &amp;op-&gt;c-&gt;sectors_to_gc) &lt; 0)</span>
<span class="p_add">+		wake_up_gc(op-&gt;c);</span>
<span class="p_add">+</span>
 	/*
 	 * Journal writes are marked REQ_PREFLUSH; if the original write was a
 	 * flush, it&#39;ll wait on the journal write.
<span class="p_chunk">@@ -400,12 +400,6 @@</span> <span class="p_context"> static bool check_should_bypass(struct cached_dev *dc, struct bio *bio)</span>
 	if (!congested &amp;&amp; !dc-&gt;sequential_cutoff)
 		goto rescale;
 
<span class="p_del">-	if (!congested &amp;&amp;</span>
<span class="p_del">-	    mode == CACHE_MODE_WRITEBACK &amp;&amp;</span>
<span class="p_del">-	    op_is_write(bio-&gt;bi_opf) &amp;&amp;</span>
<span class="p_del">-	    op_is_sync(bio-&gt;bi_opf))</span>
<span class="p_del">-		goto rescale;</span>
<span class="p_del">-</span>
 	spin_lock(&amp;dc-&gt;io_lock);
 
 	hlist_for_each_entry(i, iohash(dc, bio-&gt;bi_iter.bi_sector), hash)
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index 8352fad765f6..046fc5bddf54 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -1026,7 +1026,7 @@</span> <span class="p_context"> int bch_cached_dev_attach(struct cached_dev *dc, struct cache_set *c)</span>
 	}
 
 	if (BDEV_STATE(&amp;dc-&gt;sb) == BDEV_STATE_DIRTY) {
<span class="p_del">-		bch_sectors_dirty_init(dc);</span>
<span class="p_add">+		bch_sectors_dirty_init(&amp;dc-&gt;disk);</span>
 		atomic_set(&amp;dc-&gt;has_dirty, 1);
 		atomic_inc(&amp;dc-&gt;count);
 		bch_writeback_queue(dc);
<span class="p_chunk">@@ -1059,6 +1059,8 @@</span> <span class="p_context"> static void cached_dev_free(struct closure *cl)</span>
 	cancel_delayed_work_sync(&amp;dc-&gt;writeback_rate_update);
 	if (!IS_ERR_OR_NULL(dc-&gt;writeback_thread))
 		kthread_stop(dc-&gt;writeback_thread);
<span class="p_add">+	if (dc-&gt;writeback_write_wq)</span>
<span class="p_add">+		destroy_workqueue(dc-&gt;writeback_write_wq);</span>
 
 	mutex_lock(&amp;bch_register_lock);
 
<span class="p_chunk">@@ -1228,6 +1230,7 @@</span> <span class="p_context"> static int flash_dev_run(struct cache_set *c, struct uuid_entry *u)</span>
 		goto err;
 
 	bcache_device_attach(d, c, u - c-&gt;uuids);
<span class="p_add">+	bch_sectors_dirty_init(d);</span>
 	bch_flash_dev_request_init(d);
 	add_disk(d-&gt;disk);
 
<span class="p_chunk">@@ -1964,6 +1967,8 @@</span> <span class="p_context"> static ssize_t register_bcache(struct kobject *k, struct kobj_attribute *attr,</span>
 			else
 				err = &quot;device busy&quot;;
 			mutex_unlock(&amp;bch_register_lock);
<span class="p_add">+			if (!IS_ERR(bdev))</span>
<span class="p_add">+				bdput(bdev);</span>
 			if (attr == &amp;ksysfs_register_quiet)
 				goto out;
 		}
<span class="p_header">diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.c</span>
<span class="p_header">index f90f13616980..ab2f8ce1e3bc 100644</span>
<span class="p_header">--- a/drivers/md/bcache/sysfs.c</span>
<span class="p_header">+++ b/drivers/md/bcache/sysfs.c</span>
<span class="p_chunk">@@ -192,7 +192,7 @@</span> <span class="p_context"> STORE(__cached_dev)</span>
 {
 	struct cached_dev *dc = container_of(kobj, struct cached_dev,
 					     disk.kobj);
<span class="p_del">-	unsigned v = size;</span>
<span class="p_add">+	ssize_t v = size;</span>
 	struct cache_set *c;
 	struct kobj_uevent_env *env;
 
<span class="p_chunk">@@ -227,7 +227,7 @@</span> <span class="p_context"> STORE(__cached_dev)</span>
 		bch_cached_dev_run(dc);
 
 	if (attr == &amp;sysfs_cache_mode) {
<span class="p_del">-		ssize_t v = bch_read_string_list(buf, bch_cache_modes + 1);</span>
<span class="p_add">+		v = bch_read_string_list(buf, bch_cache_modes + 1);</span>
 
 		if (v &lt; 0)
 			return v;
<span class="p_header">diff --git a/drivers/md/bcache/util.c b/drivers/md/bcache/util.c</span>
<span class="p_header">index 8c3a938f4bf0..176d3c2ef5f5 100644</span>
<span class="p_header">--- a/drivers/md/bcache/util.c</span>
<span class="p_header">+++ b/drivers/md/bcache/util.c</span>
<span class="p_chunk">@@ -74,24 +74,44 @@</span> <span class="p_context"> STRTO_H(strtouint, unsigned int)</span>
 STRTO_H(strtoll, long long)
 STRTO_H(strtoull, unsigned long long)
 
<span class="p_add">+/**</span>
<span class="p_add">+ * bch_hprint() - formats @v to human readable string for sysfs.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @v - signed 64 bit integer</span>
<span class="p_add">+ * @buf - the (at least 8 byte) buffer to format the result into.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns the number of bytes used by format.</span>
<span class="p_add">+ */</span>
 ssize_t bch_hprint(char *buf, int64_t v)
 {
 	static const char units[] = &quot;?kMGTPEZY&quot;;
<span class="p_del">-	char dec[4] = &quot;&quot;;</span>
<span class="p_del">-	int u, t = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (u = 0; v &gt;= 1024 || v &lt;= -1024; u++) {</span>
<span class="p_del">-		t = v &amp; ~(~0 &lt;&lt; 10);</span>
<span class="p_del">-		v &gt;&gt;= 10;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!u)</span>
<span class="p_del">-		return sprintf(buf, &quot;%llu&quot;, v);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (v &lt; 100 &amp;&amp; v &gt; -100)</span>
<span class="p_del">-		snprintf(dec, sizeof(dec), &quot;.%i&quot;, t / 100);</span>
<span class="p_del">-</span>
<span class="p_del">-	return sprintf(buf, &quot;%lli%s%c&quot;, v, dec, units[u]);</span>
<span class="p_add">+	int u = 0, t;</span>
<span class="p_add">+</span>
<span class="p_add">+	uint64_t q;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (v &lt; 0)</span>
<span class="p_add">+		q = -v;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		q = v;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* For as long as the number is more than 3 digits, but at least</span>
<span class="p_add">+	 * once, shift right / divide by 1024.  Keep the remainder for</span>
<span class="p_add">+	 * a digit after the decimal point.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		u++;</span>
<span class="p_add">+</span>
<span class="p_add">+		t = q &amp; ~(~0 &lt;&lt; 10);</span>
<span class="p_add">+		q &gt;&gt;= 10;</span>
<span class="p_add">+	} while (q &gt;= 1000);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (v &lt; 0)</span>
<span class="p_add">+		/* &#39;-&#39;, up to 3 digits, &#39;.&#39;, 1 digit, 1 character, null;</span>
<span class="p_add">+		 * yields 8 bytes.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return sprintf(buf, &quot;-%llu.%i%c&quot;, q, t * 10 / 1024, units[u]);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return sprintf(buf, &quot;%llu.%i%c&quot;, q, t * 10 / 1024, units[u]);</span>
 }
 
 ssize_t bch_snprint_string_list(char *buf, size_t size, const char * const list[],
<span class="p_header">diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.c</span>
<span class="p_header">index 42c66e76f05e..a635d6ac7fde 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.c</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.c</span>
<span class="p_chunk">@@ -21,7 +21,8 @@</span> <span class="p_context"></span>
 static void __update_writeback_rate(struct cached_dev *dc)
 {
 	struct cache_set *c = dc-&gt;disk.c;
<span class="p_del">-	uint64_t cache_sectors = c-&gt;nbuckets * c-&gt;sb.bucket_size;</span>
<span class="p_add">+	uint64_t cache_sectors = c-&gt;nbuckets * c-&gt;sb.bucket_size -</span>
<span class="p_add">+				bcache_flash_devs_sectors_dirty(c);</span>
 	uint64_t cache_dirty_target =
 		div_u64(cache_sectors * dc-&gt;writeback_percent, 100);
 
<span class="p_chunk">@@ -186,7 +187,7 @@</span> <span class="p_context"> static void write_dirty(struct closure *cl)</span>
 
 	closure_bio_submit(&amp;io-&gt;bio, cl);
 
<span class="p_del">-	continue_at(cl, write_dirty_finish, system_wq);</span>
<span class="p_add">+	continue_at(cl, write_dirty_finish, io-&gt;dc-&gt;writeback_write_wq);</span>
 }
 
 static void read_dirty_endio(struct bio *bio)
<span class="p_chunk">@@ -206,7 +207,7 @@</span> <span class="p_context"> static void read_dirty_submit(struct closure *cl)</span>
 
 	closure_bio_submit(&amp;io-&gt;bio, cl);
 
<span class="p_del">-	continue_at(cl, write_dirty, system_wq);</span>
<span class="p_add">+	continue_at(cl, write_dirty, io-&gt;dc-&gt;writeback_write_wq);</span>
 }
 
 static void read_dirty(struct cached_dev *dc)
<span class="p_chunk">@@ -482,17 +483,17 @@</span> <span class="p_context"> static int sectors_dirty_init_fn(struct btree_op *_op, struct btree *b,</span>
 	return MAP_CONTINUE;
 }
 
<span class="p_del">-void bch_sectors_dirty_init(struct cached_dev *dc)</span>
<span class="p_add">+void bch_sectors_dirty_init(struct bcache_device *d)</span>
 {
 	struct sectors_dirty_init op;
 
 	bch_btree_op_init(&amp;op.op, -1);
<span class="p_del">-	op.inode = dc-&gt;disk.id;</span>
<span class="p_add">+	op.inode = d-&gt;id;</span>
 
<span class="p_del">-	bch_btree_map_keys(&amp;op.op, dc-&gt;disk.c, &amp;KEY(op.inode, 0, 0),</span>
<span class="p_add">+	bch_btree_map_keys(&amp;op.op, d-&gt;c, &amp;KEY(op.inode, 0, 0),</span>
 			   sectors_dirty_init_fn, 0);
 
<span class="p_del">-	dc-&gt;disk.sectors_dirty_last = bcache_dev_sectors_dirty(&amp;dc-&gt;disk);</span>
<span class="p_add">+	d-&gt;sectors_dirty_last = bcache_dev_sectors_dirty(d);</span>
 }
 
 void bch_cached_dev_writeback_init(struct cached_dev *dc)
<span class="p_chunk">@@ -516,6 +517,11 @@</span> <span class="p_context"> void bch_cached_dev_writeback_init(struct cached_dev *dc)</span>
 
 int bch_cached_dev_writeback_start(struct cached_dev *dc)
 {
<span class="p_add">+	dc-&gt;writeback_write_wq = alloc_workqueue(&quot;bcache_writeback_wq&quot;,</span>
<span class="p_add">+						WQ_MEM_RECLAIM, 0);</span>
<span class="p_add">+	if (!dc-&gt;writeback_write_wq)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	dc-&gt;writeback_thread = kthread_create(bch_writeback_thread, dc,
 					      &quot;bcache_writeback&quot;);
 	if (IS_ERR(dc-&gt;writeback_thread))
<span class="p_header">diff --git a/drivers/md/bcache/writeback.h b/drivers/md/bcache/writeback.h</span>
<span class="p_header">index 629bd1a502fd..e35421d20d2e 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.h</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.h</span>
<span class="p_chunk">@@ -14,6 +14,25 @@</span> <span class="p_context"> static inline uint64_t bcache_dev_sectors_dirty(struct bcache_device *d)</span>
 	return ret;
 }
 
<span class="p_add">+static inline uint64_t  bcache_flash_devs_sectors_dirty(struct cache_set *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint64_t i, ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;bch_register_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; c-&gt;nr_uuids; i++) {</span>
<span class="p_add">+		struct bcache_device *d = c-&gt;devices[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!d || !UUID_FLASH_ONLY(&amp;c-&gt;uuids[i]))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+	   ret += bcache_dev_sectors_dirty(d);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;bch_register_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned offset_to_stripe(struct bcache_device *d,
 					uint64_t offset)
 {
<span class="p_chunk">@@ -84,7 +103,7 @@</span> <span class="p_context"> static inline void bch_writeback_add(struct cached_dev *dc)</span>
 
 void bcache_dev_sectors_dirty_add(struct cache_set *, unsigned, uint64_t, int);
 
<span class="p_del">-void bch_sectors_dirty_init(struct cached_dev *dc);</span>
<span class="p_add">+void bch_sectors_dirty_init(struct bcache_device *);</span>
 void bch_cached_dev_writeback_init(struct cached_dev *);
 int bch_cached_dev_writeback_start(struct cached_dev *);
 
<span class="p_header">diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c</span>
<span class="p_header">index 40f3cd7eab0f..d2121637b4ab 100644</span>
<span class="p_header">--- a/drivers/md/bitmap.c</span>
<span class="p_header">+++ b/drivers/md/bitmap.c</span>
<span class="p_chunk">@@ -625,7 +625,7 @@</span> <span class="p_context"> static int bitmap_read_sb(struct bitmap *bitmap)</span>
 		err = read_sb_page(bitmap-&gt;mddev,
 				   offset,
 				   sb_page,
<span class="p_del">-				   0, sizeof(bitmap_super_t));</span>
<span class="p_add">+				   0, PAGE_SIZE);</span>
 	}
 	if (err)
 		return err;
<span class="p_chunk">@@ -2058,6 +2058,11 @@</span> <span class="p_context"> int bitmap_resize(struct bitmap *bitmap, sector_t blocks,</span>
 	long pages;
 	struct bitmap_page *new_bp;
 
<span class="p_add">+	if (bitmap-&gt;storage.file &amp;&amp; !init) {</span>
<span class="p_add">+		pr_info(&quot;md: cannot resize file-based bitmap\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (chunksize == 0) {
 		/* If there is enough space, leave the chunk size unchanged,
 		 * else increase by factor of two until there is enough space.
<span class="p_chunk">@@ -2118,7 +2123,7 @@</span> <span class="p_context"> int bitmap_resize(struct bitmap *bitmap, sector_t blocks,</span>
 	if (store.sb_page &amp;&amp; bitmap-&gt;storage.sb_page)
 		memcpy(page_address(store.sb_page),
 		       page_address(bitmap-&gt;storage.sb_page),
<span class="p_del">-		       sizeof(bitmap_super_t));</span>
<span class="p_add">+		       PAGE_SIZE);</span>
 	bitmap_file_unmap(&amp;bitmap-&gt;storage);
 	bitmap-&gt;storage = store;
 
<span class="p_header">diff --git a/drivers/media/i2c/adv7180.c b/drivers/media/i2c/adv7180.c</span>
<span class="p_header">index 78de7ddf5081..3df28f2f9b38 100644</span>
<span class="p_header">--- a/drivers/media/i2c/adv7180.c</span>
<span class="p_header">+++ b/drivers/media/i2c/adv7180.c</span>
<span class="p_chunk">@@ -1402,6 +1402,8 @@</span> <span class="p_context"> static int adv7180_remove(struct i2c_client *client)</span>
 
 static const struct i2c_device_id adv7180_id[] = {
 	{ &quot;adv7180&quot;, (kernel_ulong_t)&amp;adv7180_info },
<span class="p_add">+	{ &quot;adv7180cp&quot;, (kernel_ulong_t)&amp;adv7180_info },</span>
<span class="p_add">+	{ &quot;adv7180st&quot;, (kernel_ulong_t)&amp;adv7180_info },</span>
 	{ &quot;adv7182&quot;, (kernel_ulong_t)&amp;adv7182_info },
 	{ &quot;adv7280&quot;, (kernel_ulong_t)&amp;adv7280_info },
 	{ &quot;adv7280-m&quot;, (kernel_ulong_t)&amp;adv7280_m_info },
<span class="p_header">diff --git a/drivers/media/platform/qcom/venus/helpers.c b/drivers/media/platform/qcom/venus/helpers.c</span>
<span class="p_header">index 5f4434c0a8f1..2d6187904552 100644</span>
<span class="p_header">--- a/drivers/media/platform/qcom/venus/helpers.c</span>
<span class="p_header">+++ b/drivers/media/platform/qcom/venus/helpers.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static void return_buf_error(struct venus_inst *inst,</span>
 	if (vbuf-&gt;vb2_buf.type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
 		v4l2_m2m_src_buf_remove_by_buf(m2m_ctx, vbuf);
 	else
<span class="p_del">-		v4l2_m2m_src_buf_remove_by_buf(m2m_ctx, vbuf);</span>
<span class="p_add">+		v4l2_m2m_dst_buf_remove_by_buf(m2m_ctx, vbuf);</span>
 
 	v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);
 }
<span class="p_header">diff --git a/drivers/media/rc/lirc_dev.c b/drivers/media/rc/lirc_dev.c</span>
<span class="p_header">index db1e7b70c998..9080e39ea391 100644</span>
<span class="p_header">--- a/drivers/media/rc/lirc_dev.c</span>
<span class="p_header">+++ b/drivers/media/rc/lirc_dev.c</span>
<span class="p_chunk">@@ -59,6 +59,8 @@</span> <span class="p_context"> static void lirc_release(struct device *ld)</span>
 {
 	struct irctl *ir = container_of(ld, struct irctl, dev);
 
<span class="p_add">+	put_device(ir-&gt;dev.parent);</span>
<span class="p_add">+</span>
 	if (ir-&gt;buf_internal) {
 		lirc_buffer_free(ir-&gt;buf);
 		kfree(ir-&gt;buf);
<span class="p_chunk">@@ -218,6 +220,8 @@</span> <span class="p_context"> int lirc_register_driver(struct lirc_driver *d)</span>
 
 	mutex_unlock(&amp;lirc_dev_lock);
 
<span class="p_add">+	get_device(ir-&gt;dev.parent);</span>
<span class="p_add">+</span>
 	dev_info(ir-&gt;d.dev, &quot;lirc_dev: driver %s registered at minor = %d\n&quot;,
 		 ir-&gt;d.name, ir-&gt;d.minor);
 
<span class="p_header">diff --git a/drivers/media/usb/uvc/uvc_ctrl.c b/drivers/media/usb/uvc/uvc_ctrl.c</span>
<span class="p_header">index c2ee6e39fd0c..20397aba6849 100644</span>
<span class="p_header">--- a/drivers/media/usb/uvc/uvc_ctrl.c</span>
<span class="p_header">+++ b/drivers/media/usb/uvc/uvc_ctrl.c</span>
<span class="p_chunk">@@ -2002,6 +2002,13 @@</span> <span class="p_context"> int uvc_ctrl_add_mapping(struct uvc_video_chain *chain,</span>
 		goto done;
 	}
 
<span class="p_add">+	/* Validate the user-provided bit-size and offset */</span>
<span class="p_add">+	if (mapping-&gt;size &gt; 32 ||</span>
<span class="p_add">+	    mapping-&gt;offset + mapping-&gt;size &gt; ctrl-&gt;info.size * 8) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	list_for_each_entry(map, &amp;ctrl-&gt;info.mappings, list) {
 		if (mapping-&gt;id == map-&gt;id) {
 			uvc_trace(UVC_TRACE_CONTROL, &quot;Can&#39;t add mapping &#39;%s&#39;, &quot;
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">index 6f52970f8b54..0c14e995667c 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_chunk">@@ -796,7 +796,8 @@</span> <span class="p_context"> static int put_v4l2_event32(struct v4l2_event *kp, struct v4l2_event32 __user *u</span>
 		copy_to_user(&amp;up-&gt;u, &amp;kp-&gt;u, sizeof(kp-&gt;u)) ||
 		put_user(kp-&gt;pending, &amp;up-&gt;pending) ||
 		put_user(kp-&gt;sequence, &amp;up-&gt;sequence) ||
<span class="p_del">-		compat_put_timespec(&amp;kp-&gt;timestamp, &amp;up-&gt;timestamp) ||</span>
<span class="p_add">+		put_user(kp-&gt;timestamp.tv_sec, &amp;up-&gt;timestamp.tv_sec) ||</span>
<span class="p_add">+		put_user(kp-&gt;timestamp.tv_nsec, &amp;up-&gt;timestamp.tv_nsec) ||</span>
 		put_user(kp-&gt;id, &amp;up-&gt;id) ||
 		copy_to_user(up-&gt;reserved, kp-&gt;reserved, 8 * sizeof(__u32)))
 			return -EFAULT;
<span class="p_header">diff --git a/drivers/misc/cxl/api.c b/drivers/misc/cxl/api.c</span>
<span class="p_header">index 1a138c83f877..a0c44d16bf30 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/api.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/api.c</span>
<span class="p_chunk">@@ -336,6 +336,10 @@</span> <span class="p_context"> int cxl_start_context(struct cxl_context *ctx, u64 wed,</span>
 			mmput(ctx-&gt;mm);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Increment driver use count. Enables global TLBIs for hash</span>
<span class="p_add">+	 * and callbacks to handle the segment table</span>
<span class="p_add">+	 */</span>
 	cxl_ctx_get();
 
 	if ((rc = cxl_ops-&gt;attach_process(ctx, kernel, wed, 0))) {
<span class="p_header">diff --git a/drivers/misc/cxl/file.c b/drivers/misc/cxl/file.c</span>
<span class="p_header">index 0761271d68c5..4bfad9f6dc9f 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/file.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/file.c</span>
<span class="p_chunk">@@ -95,7 +95,6 @@</span> <span class="p_context"> static int __afu_open(struct inode *inode, struct file *file, bool master)</span>
 
 	pr_devel(&quot;afu_open pe: %i\n&quot;, ctx-&gt;pe);
 	file-&gt;private_data = ctx;
<span class="p_del">-	cxl_ctx_get();</span>
 
 	/* indicate success */
 	rc = 0;
<span class="p_chunk">@@ -225,6 +224,12 @@</span> <span class="p_context"> static long afu_ioctl_start_work(struct cxl_context *ctx,</span>
 	if (ctx-&gt;mm)
 		mmput(ctx-&gt;mm);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Increment driver use count. Enables global TLBIs for hash</span>
<span class="p_add">+	 * and callbacks to handle the segment table</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cxl_ctx_get();</span>
<span class="p_add">+</span>
 	trace_cxl_attach(ctx, work.work_element_descriptor, work.num_interrupts, amr);
 
 	if ((rc = cxl_ops-&gt;attach_process(ctx, false, work.work_element_descriptor,
<span class="p_chunk">@@ -233,6 +238,7 @@</span> <span class="p_context"> static long afu_ioctl_start_work(struct cxl_context *ctx,</span>
 		cxl_adapter_context_put(ctx-&gt;afu-&gt;adapter);
 		put_pid(ctx-&gt;pid);
 		ctx-&gt;pid = NULL;
<span class="p_add">+		cxl_ctx_put();</span>
 		cxl_context_mm_count_put(ctx);
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/net/wireless/ath/wcn36xx/main.c b/drivers/net/wireless/ath/wcn36xx/main.c</span>
<span class="p_header">index 517a315e259b..35bd50bcbbd5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/wcn36xx/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/wcn36xx/main.c</span>
<span class="p_chunk">@@ -372,6 +372,8 @@</span> <span class="p_context"> static int wcn36xx_config(struct ieee80211_hw *hw, u32 changed)</span>
 
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac config changed 0x%08x\n&quot;, changed);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	if (changed &amp; IEEE80211_CONF_CHANGE_CHANNEL) {
 		int ch = WCN36XX_HW_CHANNEL(wcn);
 		wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;wcn36xx_config channel switch=%d\n&quot;,
<span class="p_chunk">@@ -382,6 +384,8 @@</span> <span class="p_context"> static int wcn36xx_config(struct ieee80211_hw *hw, u32 changed)</span>
 		}
 	}
 
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -396,6 +400,8 @@</span> <span class="p_context"> static void wcn36xx_configure_filter(struct ieee80211_hw *hw,</span>
 
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac configure filter\n&quot;);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	*total &amp;= FIF_ALLMULTI;
 
 	fp = (void *)(unsigned long)multicast;
<span class="p_chunk">@@ -408,6 +414,8 @@</span> <span class="p_context"> static void wcn36xx_configure_filter(struct ieee80211_hw *hw,</span>
 		else if (NL80211_IFTYPE_STATION == vif-&gt;type &amp;&amp; tmp-&gt;sta_assoc)
 			wcn36xx_smd_set_mc_list(wcn, vif, fp);
 	}
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
 	kfree(fp);
 }
 
<span class="p_chunk">@@ -471,6 +479,8 @@</span> <span class="p_context"> static int wcn36xx_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,</span>
 			 key_conf-&gt;key,
 			 key_conf-&gt;keylen);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	switch (key_conf-&gt;cipher) {
 	case WLAN_CIPHER_SUITE_WEP40:
 		vif_priv-&gt;encrypt_type = WCN36XX_HAL_ED_WEP40;
<span class="p_chunk">@@ -565,6 +575,8 @@</span> <span class="p_context"> static int wcn36xx_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,</span>
 	}
 
 out:
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -725,6 +737,8 @@</span> <span class="p_context"> static void wcn36xx_bss_info_changed(struct ieee80211_hw *hw,</span>
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac bss info changed vif %p changed 0x%08x\n&quot;,
 		    vif, changed);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	if (changed &amp; BSS_CHANGED_BEACON_INFO) {
 		wcn36xx_dbg(WCN36XX_DBG_MAC,
 			    &quot;mac bss changed dtim period %d\n&quot;,
<span class="p_chunk">@@ -787,7 +801,13 @@</span> <span class="p_context"> static void wcn36xx_bss_info_changed(struct ieee80211_hw *hw,</span>
 				     bss_conf-&gt;aid);
 
 			vif_priv-&gt;sta_assoc = true;
<span class="p_del">-			rcu_read_lock();</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Holding conf_mutex ensures mutal exclusion with</span>
<span class="p_add">+			 * wcn36xx_sta_remove() and as such ensures that sta</span>
<span class="p_add">+			 * won&#39;t be freed while we&#39;re operating on it. As such</span>
<span class="p_add">+			 * we do not need to hold the rcu_read_lock().</span>
<span class="p_add">+			 */</span>
 			sta = ieee80211_find_sta(vif, bss_conf-&gt;bssid);
 			if (!sta) {
 				wcn36xx_err(&quot;sta %pM is not found\n&quot;,
<span class="p_chunk">@@ -811,7 +831,6 @@</span> <span class="p_context"> static void wcn36xx_bss_info_changed(struct ieee80211_hw *hw,</span>
 			 * place where AID is available.
 			 */
 			wcn36xx_smd_config_sta(wcn, vif, sta);
<span class="p_del">-			rcu_read_unlock();</span>
 		} else {
 			wcn36xx_dbg(WCN36XX_DBG_MAC,
 				    &quot;disassociated bss %pM vif %pM AID=%d\n&quot;,
<span class="p_chunk">@@ -873,6 +892,9 @@</span> <span class="p_context"> static void wcn36xx_bss_info_changed(struct ieee80211_hw *hw,</span>
 		}
 	}
 out:
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return;
 }
 
<span class="p_chunk">@@ -882,7 +904,10 @@</span> <span class="p_context"> static int wcn36xx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)</span>
 	struct wcn36xx *wcn = hw-&gt;priv;
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac set RTS threshold %d\n&quot;, value);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
 	wcn36xx_smd_update_cfg(wcn, WCN36XX_HAL_CFG_RTS_THRESHOLD, value);
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -893,8 +918,12 @@</span> <span class="p_context"> static void wcn36xx_remove_interface(struct ieee80211_hw *hw,</span>
 	struct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac remove interface vif %p\n&quot;, vif);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	list_del(&amp;vif_priv-&gt;list);
 	wcn36xx_smd_delete_sta_self(wcn, vif-&gt;addr);
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
 }
 
 static int wcn36xx_add_interface(struct ieee80211_hw *hw,
<span class="p_chunk">@@ -915,9 +944,13 @@</span> <span class="p_context"> static int wcn36xx_add_interface(struct ieee80211_hw *hw,</span>
 		return -EOPNOTSUPP;
 	}
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	list_add(&amp;vif_priv-&gt;list, &amp;wcn-&gt;vif_list);
 	wcn36xx_smd_add_sta_self(wcn, vif);
 
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -930,6 +963,8 @@</span> <span class="p_context"> static int wcn36xx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,</span>
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac sta add vif %p sta %pM\n&quot;,
 		    vif, sta-&gt;addr);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	spin_lock_init(&amp;sta_priv-&gt;ampdu_lock);
 	sta_priv-&gt;vif = vif_priv;
 	/*
<span class="p_chunk">@@ -941,6 +976,9 @@</span> <span class="p_context"> static int wcn36xx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,</span>
 		sta_priv-&gt;aid = sta-&gt;aid;
 		wcn36xx_smd_config_sta(wcn, vif, sta);
 	}
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -954,8 +992,13 @@</span> <span class="p_context"> static int wcn36xx_sta_remove(struct ieee80211_hw *hw,</span>
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac sta remove vif %p sta %pM index %d\n&quot;,
 		    vif, sta-&gt;addr, sta_priv-&gt;sta_index);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	wcn36xx_smd_delete_sta(wcn, sta_priv-&gt;sta_index);
 	sta_priv-&gt;vif = NULL;
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -999,6 +1042,8 @@</span> <span class="p_context"> static int wcn36xx_ampdu_action(struct ieee80211_hw *hw,</span>
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac ampdu action action %d tid %d\n&quot;,
 		    action, tid);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	switch (action) {
 	case IEEE80211_AMPDU_RX_START:
 		sta_priv-&gt;tid = tid;
<span class="p_chunk">@@ -1038,6 +1083,8 @@</span> <span class="p_context"> static int wcn36xx_ampdu_action(struct ieee80211_hw *hw,</span>
 		wcn36xx_err(&quot;Unknown AMPDU action\n&quot;);
 	}
 
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1216,6 +1263,7 @@</span> <span class="p_context"> static int wcn36xx_probe(struct platform_device *pdev)</span>
 	wcn = hw-&gt;priv;
 	wcn-&gt;hw = hw;
 	wcn-&gt;dev = &amp;pdev-&gt;dev;
<span class="p_add">+	mutex_init(&amp;wcn-&gt;conf_mutex);</span>
 	mutex_init(&amp;wcn-&gt;hal_mutex);
 	mutex_init(&amp;wcn-&gt;scan_lock);
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/wcn36xx/wcn36xx.h b/drivers/net/wireless/ath/wcn36xx/wcn36xx.h</span>
<span class="p_header">index b52b4da9a967..6aefba4c0cda 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/wcn36xx/wcn36xx.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/wcn36xx/wcn36xx.h</span>
<span class="p_chunk">@@ -202,6 +202,9 @@</span> <span class="p_context"> struct wcn36xx {</span>
 	struct qcom_smem_state	*tx_rings_empty_state;
 	unsigned		tx_rings_empty_state_bit;
 
<span class="p_add">+	/* prevents concurrent FW reconfiguration */</span>
<span class="p_add">+	struct mutex		conf_mutex;</span>
<span class="p_add">+</span>
 	/*
 	 * smd_buf must be protected with smd_mutex to garantee
 	 * that all messages are sent one after another
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c</span>
<span class="p_header">index 3ee6767392b6..d25bad052d78 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c</span>
<span class="p_chunk">@@ -79,6 +79,7 @@</span> <span class="p_context"></span>
 /* NVM offsets (in words) definitions */
 enum wkp_nvm_offsets {
 	/* NVM HW-Section offset (in words) definitions */
<span class="p_add">+	SUBSYSTEM_ID = 0x0A,</span>
 	HW_ADDR = 0x15,
 
 	/* NVM SW-Section offset (in words) definitions */
<span class="p_chunk">@@ -254,13 +255,12 @@</span> <span class="p_context"> static u32 iwl_get_channel_flags(u8 ch_num, int ch_idx, bool is_5ghz,</span>
 static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,
 				struct iwl_nvm_data *data,
 				const __le16 * const nvm_ch_flags,
<span class="p_del">-				bool lar_supported)</span>
<span class="p_add">+				bool lar_supported, bool no_wide_in_5ghz)</span>
 {
 	int ch_idx;
 	int n_channels = 0;
 	struct ieee80211_channel *channel;
 	u16 ch_flags;
<span class="p_del">-	bool is_5ghz;</span>
 	int num_of_ch, num_2ghz_channels;
 	const u8 *nvm_chan;
 
<span class="p_chunk">@@ -275,12 +275,20 @@</span> <span class="p_context"> static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,</span>
 	}
 
 	for (ch_idx = 0; ch_idx &lt; num_of_ch; ch_idx++) {
<span class="p_add">+		bool is_5ghz = (ch_idx &gt;= num_2ghz_channels);</span>
<span class="p_add">+</span>
 		ch_flags = __le16_to_cpup(nvm_ch_flags + ch_idx);
 
<span class="p_del">-		if (ch_idx &gt;= num_2ghz_channels &amp;&amp;</span>
<span class="p_del">-		    !data-&gt;sku_cap_band_52GHz_enable)</span>
<span class="p_add">+		if (is_5ghz &amp;&amp; !data-&gt;sku_cap_band_52GHz_enable)</span>
 			continue;
 
<span class="p_add">+		/* workaround to disable wide channels in 5GHz */</span>
<span class="p_add">+		if (no_wide_in_5ghz &amp;&amp; is_5ghz) {</span>
<span class="p_add">+			ch_flags &amp;= ~(NVM_CHANNEL_40MHZ |</span>
<span class="p_add">+				     NVM_CHANNEL_80MHZ |</span>
<span class="p_add">+				     NVM_CHANNEL_160MHZ);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (ch_flags &amp; NVM_CHANNEL_160MHZ)
 			data-&gt;vht160_supported = true;
 
<span class="p_chunk">@@ -303,8 +311,8 @@</span> <span class="p_context"> static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,</span>
 		n_channels++;
 
 		channel-&gt;hw_value = nvm_chan[ch_idx];
<span class="p_del">-		channel-&gt;band = (ch_idx &lt; num_2ghz_channels) ?</span>
<span class="p_del">-				NL80211_BAND_2GHZ : NL80211_BAND_5GHZ;</span>
<span class="p_add">+		channel-&gt;band = is_5ghz ?</span>
<span class="p_add">+				NL80211_BAND_5GHZ : NL80211_BAND_2GHZ;</span>
 		channel-&gt;center_freq =
 			ieee80211_channel_to_frequency(
 				channel-&gt;hw_value, channel-&gt;band);
<span class="p_chunk">@@ -316,7 +324,6 @@</span> <span class="p_context"> static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,</span>
 		 * is not used in mvm, and is used for backwards compatibility
 		 */
 		channel-&gt;max_power = IWL_DEFAULT_MAX_TX_POWER;
<span class="p_del">-		is_5ghz = channel-&gt;band == NL80211_BAND_5GHZ;</span>
 
 		/* don&#39;t put limitations in case we&#39;re using LAR */
 		if (!lar_supported)
<span class="p_chunk">@@ -432,14 +439,15 @@</span> <span class="p_context"> static void iwl_init_vht_hw_capab(const struct iwl_cfg *cfg,</span>
 
 void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,
 		     struct iwl_nvm_data *data, const __le16 *nvm_ch_flags,
<span class="p_del">-		     u8 tx_chains, u8 rx_chains, bool lar_supported)</span>
<span class="p_add">+		     u8 tx_chains, u8 rx_chains, bool lar_supported,</span>
<span class="p_add">+		     bool no_wide_in_5ghz)</span>
 {
 	int n_channels;
 	int n_used = 0;
 	struct ieee80211_supported_band *sband;
 
 	n_channels = iwl_init_channel_map(dev, cfg, data, nvm_ch_flags,
<span class="p_del">-					  lar_supported);</span>
<span class="p_add">+					  lar_supported, no_wide_in_5ghz);</span>
 	sband = &amp;data-&gt;bands[NL80211_BAND_2GHZ];
 	sband-&gt;band = NL80211_BAND_2GHZ;
 	sband-&gt;bitrates = &amp;iwl_cfg80211_rates[RATES_24_OFFS];
<span class="p_chunk">@@ -645,6 +653,39 @@</span> <span class="p_context"> static int iwl_set_hw_address(struct iwl_trans *trans,</span>
 	return 0;
 }
 
<span class="p_add">+static bool</span>
<span class="p_add">+iwl_nvm_no_wide_in_5ghz(struct device *dev, const struct iwl_cfg *cfg,</span>
<span class="p_add">+			const __le16 *nvm_hw)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Workaround a bug in Indonesia SKUs where the regulatory in</span>
<span class="p_add">+	 * some 7000-family OTPs erroneously allow wide channels in</span>
<span class="p_add">+	 * 5GHz.  To check for Indonesia, we take the SKU value from</span>
<span class="p_add">+	 * bits 1-4 in the subsystem ID and check if it is either 5 or</span>
<span class="p_add">+	 * 9.  In those cases, we need to force-disable wide channels</span>
<span class="p_add">+	 * in 5GHz otherwise the FW will throw a sysassert when we try</span>
<span class="p_add">+	 * to use them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cfg-&gt;device_family == IWL_DEVICE_FAMILY_7000) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Unlike the other sections in the NVM, the hw</span>
<span class="p_add">+		 * section uses big-endian.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u16 subsystem_id = be16_to_cpup((const __be16 *)nvm_hw</span>
<span class="p_add">+						+ SUBSYSTEM_ID);</span>
<span class="p_add">+		u8 sku = (subsystem_id &amp; 0x1e) &gt;&gt; 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sku == 5 || sku == 9) {</span>
<span class="p_add">+			IWL_DEBUG_EEPROM(dev,</span>
<span class="p_add">+					 &quot;disabling wide channels in 5GHz (0x%0x %d)\n&quot;,</span>
<span class="p_add">+					 subsystem_id, sku);</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct iwl_nvm_data *
 iwl_parse_nvm_data(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 		   const __le16 *nvm_hw, const __le16 *nvm_sw,
<span class="p_chunk">@@ -655,6 +696,7 @@</span> <span class="p_context"> iwl_parse_nvm_data(struct iwl_trans *trans, const struct iwl_cfg *cfg,</span>
 	struct device *dev = trans-&gt;dev;
 	struct iwl_nvm_data *data;
 	bool lar_enabled;
<span class="p_add">+	bool no_wide_in_5ghz = iwl_nvm_no_wide_in_5ghz(dev, cfg, nvm_hw);</span>
 	u32 sku, radio_cfg;
 	u16 lar_config;
 	const __le16 *ch_section;
<span class="p_chunk">@@ -725,7 +767,7 @@</span> <span class="p_context"> iwl_parse_nvm_data(struct iwl_trans *trans, const struct iwl_cfg *cfg,</span>
 	}
 
 	iwl_init_sbands(dev, cfg, data, ch_section, tx_chains, rx_chains,
<span class="p_del">-			lar_fw_supported &amp;&amp; lar_enabled);</span>
<span class="p_add">+			lar_fw_supported &amp;&amp; lar_enabled, no_wide_in_5ghz);</span>
 	data-&gt;calib_version = 255;
 
 	return data;
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.h b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.h</span>
<span class="p_header">index 3fd6506a02ab..50d9b3eaa4f8 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.h</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.h</span>
<span class="p_chunk">@@ -93,7 +93,8 @@</span> <span class="p_context"> void iwl_set_hw_address_from_csr(struct iwl_trans *trans,</span>
  */
 void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,
 		     struct iwl_nvm_data *data, const __le16 *nvm_ch_flags,
<span class="p_del">-		     u8 tx_chains, u8 rx_chains, bool lar_supported);</span>
<span class="p_add">+		     u8 tx_chains, u8 rx_chains, bool lar_supported,</span>
<span class="p_add">+		     bool no_wide_in_5ghz);</span>
 
 /**
  * iwl_parse_mcc_info - parse MCC (mobile country code) info coming from FW
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c b/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c</span>
<span class="p_header">index dac7e542a190..4de565cec747 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c</span>
<span class="p_chunk">@@ -628,7 +628,8 @@</span> <span class="p_context"> int iwl_mvm_nvm_get_from_fw(struct iwl_mvm *mvm)</span>
 			rsp-&gt;regulatory.channel_profile,
 			mvm-&gt;nvm_data-&gt;valid_tx_ant &amp; mvm-&gt;fw-&gt;valid_tx_ant,
 			mvm-&gt;nvm_data-&gt;valid_rx_ant &amp; mvm-&gt;fw-&gt;valid_rx_ant,
<span class="p_del">-			rsp-&gt;regulatory.lar_enabled &amp;&amp; lar_fw_supported);</span>
<span class="p_add">+			rsp-&gt;regulatory.lar_enabled &amp;&amp; lar_fw_supported,</span>
<span class="p_add">+			false);</span>
 
 	iwl_free_resp(&amp;hcmd);
 	return 0;
<span class="p_header">diff --git a/drivers/pci/hotplug/pciehp_hpc.c b/drivers/pci/hotplug/pciehp_hpc.c</span>
<span class="p_header">index 026830a138ae..e5d5ce9e3010 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/pciehp_hpc.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/pciehp_hpc.c</span>
<span class="p_chunk">@@ -586,6 +586,14 @@</span> <span class="p_context"> static irqreturn_t pciehp_isr(int irq, void *dev_id)</span>
 	events = status &amp; (PCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |
 			   PCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_CC |
 			   PCI_EXP_SLTSTA_DLLSC);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we&#39;ve already reported a power fault, don&#39;t report it again</span>
<span class="p_add">+	 * until we&#39;ve done something to handle it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ctrl-&gt;power_fault_detected)</span>
<span class="p_add">+		events &amp;= ~PCI_EXP_SLTSTA_PFD;</span>
<span class="p_add">+</span>
 	if (!events)
 		return IRQ_NONE;
 
<span class="p_header">diff --git a/drivers/pci/hotplug/shpchp_hpc.c b/drivers/pci/hotplug/shpchp_hpc.c</span>
<span class="p_header">index de0ea474fb73..e5824c7b7b6b 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/shpchp_hpc.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/shpchp_hpc.c</span>
<span class="p_chunk">@@ -1062,6 +1062,8 @@</span> <span class="p_context"> int shpc_init(struct controller *ctrl, struct pci_dev *pdev)</span>
 		if (rc) {
 			ctrl_info(ctrl, &quot;Can&#39;t get msi for the hotplug controller\n&quot;);
 			ctrl_info(ctrl, &quot;Use INTx for the hotplug controller\n&quot;);
<span class="p_add">+		} else {</span>
<span class="p_add">+			pci_set_master(pdev);</span>
 		}
 
 		rc = request_irq(ctrl-&gt;pci_dev-&gt;irq, shpc_isr, IRQF_SHARED,
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-amd.c b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">index e6779d4352a2..7c30fd986560 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/pinctrl/pinconf.h&gt;
 #include &lt;linux/pinctrl/pinconf-generic.h&gt;
 
<span class="p_add">+#include &quot;core.h&quot;</span>
 #include &quot;pinctrl-utils.h&quot;
 #include &quot;pinctrl-amd.h&quot;
 
<span class="p_chunk">@@ -725,6 +726,69 @@</span> <span class="p_context"> static const struct pinconf_ops amd_pinconf_ops = {</span>
 	.pin_config_group_set = amd_pinconf_group_set,
 };
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+static bool amd_gpio_should_save(struct amd_gpio *gpio_dev, unsigned int pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct pin_desc *pd = pin_desc_get(gpio_dev-&gt;pctrl, pin);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pd)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Only restore the pin if it is actually in use by the kernel (or</span>
<span class="p_add">+	 * by userspace).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pd-&gt;mux_owner || pd-&gt;gpio_owner ||</span>
<span class="p_add">+	    gpiochip_line_is_irq(&amp;gpio_dev-&gt;gc, pin))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int amd_gpio_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct platform_device *pdev = to_platform_device(dev);</span>
<span class="p_add">+	struct amd_gpio *gpio_dev = platform_get_drvdata(pdev);</span>
<span class="p_add">+	struct pinctrl_desc *desc = gpio_dev-&gt;pctrl-&gt;desc;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; desc-&gt;npins; i++) {</span>
<span class="p_add">+		int pin = desc-&gt;pins[i].number;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!amd_gpio_should_save(gpio_dev, pin))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		gpio_dev-&gt;saved_regs[i] = readl(gpio_dev-&gt;base + pin*4);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int amd_gpio_resume(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct platform_device *pdev = to_platform_device(dev);</span>
<span class="p_add">+	struct amd_gpio *gpio_dev = platform_get_drvdata(pdev);</span>
<span class="p_add">+	struct pinctrl_desc *desc = gpio_dev-&gt;pctrl-&gt;desc;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; desc-&gt;npins; i++) {</span>
<span class="p_add">+		int pin = desc-&gt;pins[i].number;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!amd_gpio_should_save(gpio_dev, pin))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		writel(gpio_dev-&gt;saved_regs[i], gpio_dev-&gt;base + pin*4);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct dev_pm_ops amd_gpio_pm_ops = {</span>
<span class="p_add">+	SET_LATE_SYSTEM_SLEEP_PM_OPS(amd_gpio_suspend,</span>
<span class="p_add">+				     amd_gpio_resume)</span>
<span class="p_add">+};</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static struct pinctrl_desc amd_pinctrl_desc = {
 	.pins	= kerncz_pins,
 	.npins = ARRAY_SIZE(kerncz_pins),
<span class="p_chunk">@@ -764,6 +828,14 @@</span> <span class="p_context"> static int amd_gpio_probe(struct platform_device *pdev)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+	gpio_dev-&gt;saved_regs = devm_kcalloc(&amp;pdev-&gt;dev, amd_pinctrl_desc.npins,</span>
<span class="p_add">+					    sizeof(*gpio_dev-&gt;saved_regs),</span>
<span class="p_add">+					    GFP_KERNEL);</span>
<span class="p_add">+	if (!gpio_dev-&gt;saved_regs)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	gpio_dev-&gt;pdev = pdev;
 	gpio_dev-&gt;gc.direction_input	= amd_gpio_direction_input;
 	gpio_dev-&gt;gc.direction_output	= amd_gpio_direction_output;
<span class="p_chunk">@@ -853,6 +925,9 @@</span> <span class="p_context"> static struct platform_driver amd_gpio_driver = {</span>
 	.driver		= {
 		.name	= &quot;amd_gpio&quot;,
 		.acpi_match_table = ACPI_PTR(amd_gpio_acpi_match),
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+		.pm	= &amp;amd_gpio_pm_ops,</span>
<span class="p_add">+#endif</span>
 	},
 	.probe		= amd_gpio_probe,
 	.remove		= amd_gpio_remove,
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-amd.h b/drivers/pinctrl/pinctrl-amd.h</span>
<span class="p_header">index 5b1cb965c767..8fa453a59da5 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-amd.h</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-amd.h</span>
<span class="p_chunk">@@ -97,6 +97,7 @@</span> <span class="p_context"> struct amd_gpio {</span>
 	unsigned int            hwbank_num;
 	struct resource         *res;
 	struct platform_device  *pdev;
<span class="p_add">+	u32			*saved_regs;</span>
 };
 
 /*  KERNCZ configuration*/
<span class="p_header">diff --git a/drivers/pinctrl/samsung/pinctrl-exynos.c b/drivers/pinctrl/samsung/pinctrl-exynos.c</span>
<span class="p_header">index 731530a9ce38..9ab8faf528a6 100644</span>
<span class="p_header">--- a/drivers/pinctrl/samsung/pinctrl-exynos.c</span>
<span class="p_header">+++ b/drivers/pinctrl/samsung/pinctrl-exynos.c</span>
<span class="p_chunk">@@ -174,10 +174,10 @@</span> <span class="p_context"> static int exynos_irq_request_resources(struct irq_data *irqd)</span>
 
 	spin_lock_irqsave(&amp;bank-&gt;slock, flags);
 
<span class="p_del">-	con = readl(bank-&gt;eint_base + reg_con);</span>
<span class="p_add">+	con = readl(bank-&gt;pctl_base + reg_con);</span>
 	con &amp;= ~(mask &lt;&lt; shift);
 	con |= EXYNOS_EINT_FUNC &lt;&lt; shift;
<span class="p_del">-	writel(con, bank-&gt;eint_base + reg_con);</span>
<span class="p_add">+	writel(con, bank-&gt;pctl_base + reg_con);</span>
 
 	spin_unlock_irqrestore(&amp;bank-&gt;slock, flags);
 
<span class="p_chunk">@@ -202,10 +202,10 @@</span> <span class="p_context"> static void exynos_irq_release_resources(struct irq_data *irqd)</span>
 
 	spin_lock_irqsave(&amp;bank-&gt;slock, flags);
 
<span class="p_del">-	con = readl(bank-&gt;eint_base + reg_con);</span>
<span class="p_add">+	con = readl(bank-&gt;pctl_base + reg_con);</span>
 	con &amp;= ~(mask &lt;&lt; shift);
 	con |= FUNC_INPUT &lt;&lt; shift;
<span class="p_del">-	writel(con, bank-&gt;eint_base + reg_con);</span>
<span class="p_add">+	writel(con, bank-&gt;pctl_base + reg_con);</span>
 
 	spin_unlock_irqrestore(&amp;bank-&gt;slock, flags);
 
<span class="p_header">diff --git a/drivers/pinctrl/samsung/pinctrl-s3c24xx.c b/drivers/pinctrl/samsung/pinctrl-s3c24xx.c</span>
<span class="p_header">index 49774851e84a..edf27264b603 100644</span>
<span class="p_header">--- a/drivers/pinctrl/samsung/pinctrl-s3c24xx.c</span>
<span class="p_header">+++ b/drivers/pinctrl/samsung/pinctrl-s3c24xx.c</span>
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> static void s3c24xx_eint_set_function(struct samsung_pinctrl_drv_data *d,</span>
 	u32 val;
 
 	/* Make sure that pin is configured as interrupt */
<span class="p_del">-	reg = bank-&gt;pctl_base + bank-&gt;pctl_offset;</span>
<span class="p_add">+	reg = d-&gt;virt_base + bank-&gt;pctl_offset;</span>
 	shift = pin * bank_type-&gt;fld_width[PINCFG_TYPE_FUNC];
 	mask = (1 &lt;&lt; bank_type-&gt;fld_width[PINCFG_TYPE_FUNC]) - 1;
 
<span class="p_chunk">@@ -184,7 +184,7 @@</span> <span class="p_context"> static int s3c24xx_eint_type(struct irq_data *data, unsigned int type)</span>
 	s3c24xx_eint_set_handler(data, type);
 
 	/* Set up interrupt trigger */
<span class="p_del">-	reg = bank-&gt;eint_base + EINT_REG(index);</span>
<span class="p_add">+	reg = d-&gt;virt_base + EINT_REG(index);</span>
 	shift = EINT_OFFS(index);
 
 	val = readl(reg);
<span class="p_chunk">@@ -259,29 +259,32 @@</span> <span class="p_context"> static void s3c2410_demux_eint0_3(struct irq_desc *desc)</span>
 static void s3c2412_eint0_3_ack(struct irq_data *data)
 {
 	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(data);
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = bank-&gt;drvdata;</span>
 
 	unsigned long bitval = 1UL &lt;&lt; data-&gt;hwirq;
<span class="p_del">-	writel(bitval, bank-&gt;eint_base + EINTPEND_REG);</span>
<span class="p_add">+	writel(bitval, d-&gt;virt_base + EINTPEND_REG);</span>
 }
 
 static void s3c2412_eint0_3_mask(struct irq_data *data)
 {
 	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(data);
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = bank-&gt;drvdata;</span>
 	unsigned long mask;
 
<span class="p_del">-	mask = readl(bank-&gt;eint_base + EINTMASK_REG);</span>
<span class="p_add">+	mask = readl(d-&gt;virt_base + EINTMASK_REG);</span>
 	mask |= (1UL &lt;&lt; data-&gt;hwirq);
<span class="p_del">-	writel(mask, bank-&gt;eint_base + EINTMASK_REG);</span>
<span class="p_add">+	writel(mask, d-&gt;virt_base + EINTMASK_REG);</span>
 }
 
 static void s3c2412_eint0_3_unmask(struct irq_data *data)
 {
 	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(data);
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = bank-&gt;drvdata;</span>
 	unsigned long mask;
 
<span class="p_del">-	mask = readl(bank-&gt;eint_base + EINTMASK_REG);</span>
<span class="p_add">+	mask = readl(d-&gt;virt_base + EINTMASK_REG);</span>
 	mask &amp;= ~(1UL &lt;&lt; data-&gt;hwirq);
<span class="p_del">-	writel(mask, bank-&gt;eint_base + EINTMASK_REG);</span>
<span class="p_add">+	writel(mask, d-&gt;virt_base + EINTMASK_REG);</span>
 }
 
 static struct irq_chip s3c2412_eint0_3_chip = {
<span class="p_chunk">@@ -316,31 +319,34 @@</span> <span class="p_context"> static void s3c2412_demux_eint0_3(struct irq_desc *desc)</span>
 static void s3c24xx_eint_ack(struct irq_data *data)
 {
 	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(data);
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = bank-&gt;drvdata;</span>
 	unsigned char index = bank-&gt;eint_offset + data-&gt;hwirq;
 
<span class="p_del">-	writel(1UL &lt;&lt; index, bank-&gt;eint_base + EINTPEND_REG);</span>
<span class="p_add">+	writel(1UL &lt;&lt; index, d-&gt;virt_base + EINTPEND_REG);</span>
 }
 
 static void s3c24xx_eint_mask(struct irq_data *data)
 {
 	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(data);
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = bank-&gt;drvdata;</span>
 	unsigned char index = bank-&gt;eint_offset + data-&gt;hwirq;
 	unsigned long mask;
 
<span class="p_del">-	mask = readl(bank-&gt;eint_base + EINTMASK_REG);</span>
<span class="p_add">+	mask = readl(d-&gt;virt_base + EINTMASK_REG);</span>
 	mask |= (1UL &lt;&lt; index);
<span class="p_del">-	writel(mask, bank-&gt;eint_base + EINTMASK_REG);</span>
<span class="p_add">+	writel(mask, d-&gt;virt_base + EINTMASK_REG);</span>
 }
 
 static void s3c24xx_eint_unmask(struct irq_data *data)
 {
 	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(data);
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = bank-&gt;drvdata;</span>
 	unsigned char index = bank-&gt;eint_offset + data-&gt;hwirq;
 	unsigned long mask;
 
<span class="p_del">-	mask = readl(bank-&gt;eint_base + EINTMASK_REG);</span>
<span class="p_add">+	mask = readl(d-&gt;virt_base + EINTMASK_REG);</span>
 	mask &amp;= ~(1UL &lt;&lt; index);
<span class="p_del">-	writel(mask, bank-&gt;eint_base + EINTMASK_REG);</span>
<span class="p_add">+	writel(mask, d-&gt;virt_base + EINTMASK_REG);</span>
 }
 
 static struct irq_chip s3c24xx_eint_chip = {
<span class="p_chunk">@@ -356,14 +362,13 @@</span> <span class="p_context"> static inline void s3c24xx_demux_eint(struct irq_desc *desc,</span>
 {
 	struct s3c24xx_eint_data *data = irq_desc_get_handler_data(desc);
 	struct irq_chip *chip = irq_desc_get_chip(desc);
<span class="p_del">-	struct irq_data *irqd = irq_desc_get_irq_data(desc);</span>
<span class="p_del">-	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);</span>
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = data-&gt;drvdata;</span>
 	unsigned int pend, mask;
 
 	chained_irq_enter(chip, desc);
 
<span class="p_del">-	pend = readl(bank-&gt;eint_base + EINTPEND_REG);</span>
<span class="p_del">-	mask = readl(bank-&gt;eint_base + EINTMASK_REG);</span>
<span class="p_add">+	pend = readl(d-&gt;virt_base + EINTPEND_REG);</span>
<span class="p_add">+	mask = readl(d-&gt;virt_base + EINTMASK_REG);</span>
 
 	pend &amp;= ~mask;
 	pend &amp;= range;
<span class="p_header">diff --git a/drivers/pinctrl/samsung/pinctrl-s3c64xx.c b/drivers/pinctrl/samsung/pinctrl-s3c64xx.c</span>
<span class="p_header">index 4a88d7446e87..e63663b32907 100644</span>
<span class="p_header">--- a/drivers/pinctrl/samsung/pinctrl-s3c64xx.c</span>
<span class="p_header">+++ b/drivers/pinctrl/samsung/pinctrl-s3c64xx.c</span>
<span class="p_chunk">@@ -280,7 +280,7 @@</span> <span class="p_context"> static void s3c64xx_irq_set_function(struct samsung_pinctrl_drv_data *d,</span>
 	u32 val;
 
 	/* Make sure that pin is configured as interrupt */
<span class="p_del">-	reg = bank-&gt;pctl_base + bank-&gt;pctl_offset;</span>
<span class="p_add">+	reg = d-&gt;virt_base + bank-&gt;pctl_offset;</span>
 	shift = pin;
 	if (bank_type-&gt;fld_width[PINCFG_TYPE_FUNC] * shift &gt;= 32) {
 		/* 4-bit bank type with 2 con regs */
<span class="p_chunk">@@ -308,8 +308,9 @@</span> <span class="p_context"> static void s3c64xx_irq_set_function(struct samsung_pinctrl_drv_data *d,</span>
 static inline void s3c64xx_gpio_irq_set_mask(struct irq_data *irqd, bool mask)
 {
 	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = bank-&gt;drvdata;</span>
 	unsigned char index = EINT_OFFS(bank-&gt;eint_offset) + irqd-&gt;hwirq;
<span class="p_del">-	void __iomem *reg = bank-&gt;eint_base + EINTMASK_REG(bank-&gt;eint_offset);</span>
<span class="p_add">+	void __iomem *reg = d-&gt;virt_base + EINTMASK_REG(bank-&gt;eint_offset);</span>
 	u32 val;
 
 	val = readl(reg);
<span class="p_chunk">@@ -333,8 +334,9 @@</span> <span class="p_context"> static void s3c64xx_gpio_irq_mask(struct irq_data *irqd)</span>
 static void s3c64xx_gpio_irq_ack(struct irq_data *irqd)
 {
 	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = bank-&gt;drvdata;</span>
 	unsigned char index = EINT_OFFS(bank-&gt;eint_offset) + irqd-&gt;hwirq;
<span class="p_del">-	void __iomem *reg = bank-&gt;eint_base + EINTPEND_REG(bank-&gt;eint_offset);</span>
<span class="p_add">+	void __iomem *reg = d-&gt;virt_base + EINTPEND_REG(bank-&gt;eint_offset);</span>
 
 	writel(1 &lt;&lt; index, reg);
 }
<span class="p_chunk">@@ -357,7 +359,7 @@</span> <span class="p_context"> static int s3c64xx_gpio_irq_set_type(struct irq_data *irqd, unsigned int type)</span>
 	s3c64xx_irq_set_handler(irqd, type);
 
 	/* Set up interrupt trigger */
<span class="p_del">-	reg = bank-&gt;eint_base + EINTCON_REG(bank-&gt;eint_offset);</span>
<span class="p_add">+	reg = d-&gt;virt_base + EINTCON_REG(bank-&gt;eint_offset);</span>
 	shift = EINT_OFFS(bank-&gt;eint_offset) + irqd-&gt;hwirq;
 	shift = 4 * (shift / 4); /* 4 EINTs per trigger selector */
 
<span class="p_chunk">@@ -409,8 +411,7 @@</span> <span class="p_context"> static void s3c64xx_eint_gpio_irq(struct irq_desc *desc)</span>
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 	struct s3c64xx_eint_gpio_data *data = irq_desc_get_handler_data(desc);
<span class="p_del">-	struct irq_data *irqd = irq_desc_get_irq_data(desc);</span>
<span class="p_del">-	struct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);</span>
<span class="p_add">+	struct samsung_pinctrl_drv_data *drvdata = data-&gt;drvdata;</span>
 
 	chained_irq_enter(chip, desc);
 
<span class="p_chunk">@@ -420,7 +421,7 @@</span> <span class="p_context"> static void s3c64xx_eint_gpio_irq(struct irq_desc *desc)</span>
 		unsigned int pin;
 		unsigned int virq;
 
<span class="p_del">-		svc = readl(bank-&gt;eint_base + SERVICE_REG);</span>
<span class="p_add">+		svc = readl(drvdata-&gt;virt_base + SERVICE_REG);</span>
 		group = SVC_GROUP(svc);
 		pin = svc &amp; SVC_NUM_MASK;
 
<span class="p_chunk">@@ -515,15 +516,15 @@</span> <span class="p_context"> static inline void s3c64xx_eint0_irq_set_mask(struct irq_data *irqd, bool mask)</span>
 {
 	struct s3c64xx_eint0_domain_data *ddata =
 					irq_data_get_irq_chip_data(irqd);
<span class="p_del">-	struct samsung_pin_bank *bank = ddata-&gt;bank;</span>
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = ddata-&gt;bank-&gt;drvdata;</span>
 	u32 val;
 
<span class="p_del">-	val = readl(bank-&gt;eint_base + EINT0MASK_REG);</span>
<span class="p_add">+	val = readl(d-&gt;virt_base + EINT0MASK_REG);</span>
 	if (mask)
 		val |= 1 &lt;&lt; ddata-&gt;eints[irqd-&gt;hwirq];
 	else
 		val &amp;= ~(1 &lt;&lt; ddata-&gt;eints[irqd-&gt;hwirq]);
<span class="p_del">-	writel(val, bank-&gt;eint_base + EINT0MASK_REG);</span>
<span class="p_add">+	writel(val, d-&gt;virt_base + EINT0MASK_REG);</span>
 }
 
 static void s3c64xx_eint0_irq_unmask(struct irq_data *irqd)
<span class="p_chunk">@@ -540,10 +541,10 @@</span> <span class="p_context"> static void s3c64xx_eint0_irq_ack(struct irq_data *irqd)</span>
 {
 	struct s3c64xx_eint0_domain_data *ddata =
 					irq_data_get_irq_chip_data(irqd);
<span class="p_del">-	struct samsung_pin_bank *bank = ddata-&gt;bank;</span>
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = ddata-&gt;bank-&gt;drvdata;</span>
 
 	writel(1 &lt;&lt; ddata-&gt;eints[irqd-&gt;hwirq],
<span class="p_del">-					bank-&gt;eint_base + EINT0PEND_REG);</span>
<span class="p_add">+					d-&gt;virt_base + EINT0PEND_REG);</span>
 }
 
 static int s3c64xx_eint0_irq_set_type(struct irq_data *irqd, unsigned int type)
<span class="p_chunk">@@ -551,7 +552,7 @@</span> <span class="p_context"> static int s3c64xx_eint0_irq_set_type(struct irq_data *irqd, unsigned int type)</span>
 	struct s3c64xx_eint0_domain_data *ddata =
 					irq_data_get_irq_chip_data(irqd);
 	struct samsung_pin_bank *bank = ddata-&gt;bank;
<span class="p_del">-	struct samsung_pinctrl_drv_data *d = ddata-&gt;bank-&gt;drvdata;</span>
<span class="p_add">+	struct samsung_pinctrl_drv_data *d = bank-&gt;drvdata;</span>
 	void __iomem *reg;
 	int trigger;
 	u8 shift;
<span class="p_chunk">@@ -566,7 +567,7 @@</span> <span class="p_context"> static int s3c64xx_eint0_irq_set_type(struct irq_data *irqd, unsigned int type)</span>
 	s3c64xx_irq_set_handler(irqd, type);
 
 	/* Set up interrupt trigger */
<span class="p_del">-	reg = bank-&gt;eint_base + EINT0CON0_REG;</span>
<span class="p_add">+	reg = d-&gt;virt_base + EINT0CON0_REG;</span>
 	shift = ddata-&gt;eints[irqd-&gt;hwirq];
 	if (shift &gt;= EINT_MAX_PER_REG) {
 		reg += 4;
<span class="p_chunk">@@ -598,19 +599,14 @@</span> <span class="p_context"> static struct irq_chip s3c64xx_eint0_irq_chip = {</span>
 static inline void s3c64xx_irq_demux_eint(struct irq_desc *desc, u32 range)
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
<span class="p_del">-	struct irq_data *irqd = irq_desc_get_irq_data(desc);</span>
<span class="p_del">-	struct s3c64xx_eint0_domain_data *ddata =</span>
<span class="p_del">-					irq_data_get_irq_chip_data(irqd);</span>
<span class="p_del">-	struct samsung_pin_bank *bank = ddata-&gt;bank;</span>
<span class="p_del">-</span>
 	struct s3c64xx_eint0_data *data = irq_desc_get_handler_data(desc);
<span class="p_del">-</span>
<span class="p_add">+	struct samsung_pinctrl_drv_data *drvdata = data-&gt;drvdata;</span>
 	unsigned int pend, mask;
 
 	chained_irq_enter(chip, desc);
 
<span class="p_del">-	pend = readl(bank-&gt;eint_base + EINT0PEND_REG);</span>
<span class="p_del">-	mask = readl(bank-&gt;eint_base + EINT0MASK_REG);</span>
<span class="p_add">+	pend = readl(drvdata-&gt;virt_base + EINT0PEND_REG);</span>
<span class="p_add">+	mask = readl(drvdata-&gt;virt_base + EINT0MASK_REG);</span>
 
 	pend = pend &amp; range &amp; ~mask;
 	pend &amp;= range;
<span class="p_header">diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.c b/drivers/pinctrl/samsung/pinctrl-samsung.c</span>
<span class="p_header">index f542642eed8d..61bbd54e35ba 100644</span>
<span class="p_header">--- a/drivers/pinctrl/samsung/pinctrl-samsung.c</span>
<span class="p_header">+++ b/drivers/pinctrl/samsung/pinctrl-samsung.c</span>
<span class="p_chunk">@@ -1013,6 +1013,12 @@</span> <span class="p_context"> samsung_pinctrl_get_soc_data(struct samsung_pinctrl_drv_data *d,</span>
 		bank-&gt;eint_base = virt_base[0];
 		bank-&gt;pctl_base = virt_base[bdata-&gt;pctl_res_idx];
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Legacy platforms should provide only one resource with IO memory.</span>
<span class="p_add">+	 * Store it as virt_base because legacy driver needs to access it</span>
<span class="p_add">+	 * through samsung_pinctrl_drv_data.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	d-&gt;virt_base = virt_base[0];</span>
 
 	for_each_child_of_node(node, np) {
 		if (!of_find_property(np, &quot;gpio-controller&quot;, NULL))
<span class="p_header">diff --git a/drivers/pinctrl/samsung/pinctrl-samsung.h b/drivers/pinctrl/samsung/pinctrl-samsung.h</span>
<span class="p_header">index 515a61035e54..61c4cab0ad24 100644</span>
<span class="p_header">--- a/drivers/pinctrl/samsung/pinctrl-samsung.h</span>
<span class="p_header">+++ b/drivers/pinctrl/samsung/pinctrl-samsung.h</span>
<span class="p_chunk">@@ -247,6 +247,10 @@</span> <span class="p_context"> struct samsung_pin_ctrl {</span>
 /**
  * struct samsung_pinctrl_drv_data: wrapper for holding driver data together.
  * @node: global list node
<span class="p_add">+ * @virt_base: register base address of the controller; this will be equal</span>
<span class="p_add">+ *             to each bank samsung_pin_bank-&gt;pctl_base and used on legacy</span>
<span class="p_add">+ *             platforms (like S3C24XX or S3C64XX) which has to access the base</span>
<span class="p_add">+ *             through samsung_pinctrl_drv_data, not samsung_pin_bank).</span>
  * @dev: device instance representing the controller.
  * @irq: interrpt number used by the controller to notify gpio interrupts.
  * @ctrl: pin controller instance managed by the driver.
<span class="p_chunk">@@ -262,6 +266,7 @@</span> <span class="p_context"> struct samsung_pin_ctrl {</span>
  */
 struct samsung_pinctrl_drv_data {
 	struct list_head		node;
<span class="p_add">+	void __iomem			*virt_base;</span>
 	struct device			*dev;
 	int				irq;
 
<span class="p_header">diff --git a/drivers/regulator/cpcap-regulator.c b/drivers/regulator/cpcap-regulator.c</span>
<span class="p_header">index cc98aceed1c1..ce1cab320f6f 100644</span>
<span class="p_header">--- a/drivers/regulator/cpcap-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/cpcap-regulator.c</span>
<span class="p_chunk">@@ -77,6 +77,8 @@</span> <span class="p_context"></span>
 #define CPCAP_BIT_VAUDIO_MODE0		BIT(1)
 #define CPCAP_BIT_V_AUDIO_EN		BIT(0)
 
<span class="p_add">+#define CPCAP_BIT_AUDIO_NORMAL_MODE	0x00</span>
<span class="p_add">+</span>
 /*
  * Off mode configuration bit. Used currently only by SW5 on omap4. There&#39;s
  * the following comment in Motorola Linux kernel tree for it:
<span class="p_chunk">@@ -217,7 +219,7 @@</span> <span class="p_context"> static unsigned int cpcap_regulator_get_mode(struct regulator_dev *rdev)</span>
 
 	regmap_read(rdev-&gt;regmap, rdev-&gt;desc-&gt;enable_reg, &amp;value);
 
<span class="p_del">-	if (!(value &amp; CPCAP_BIT_AUDIO_LOW_PWR))</span>
<span class="p_add">+	if (value &amp; CPCAP_BIT_AUDIO_LOW_PWR)</span>
 		return REGULATOR_MODE_STANDBY;
 
 	return REGULATOR_MODE_NORMAL;
<span class="p_chunk">@@ -230,10 +232,10 @@</span> <span class="p_context"> static int cpcap_regulator_set_mode(struct regulator_dev *rdev,</span>
 
 	switch (mode) {
 	case REGULATOR_MODE_NORMAL:
<span class="p_del">-		value = CPCAP_BIT_AUDIO_LOW_PWR;</span>
<span class="p_add">+		value = CPCAP_BIT_AUDIO_NORMAL_MODE;</span>
 		break;
 	case REGULATOR_MODE_STANDBY:
<span class="p_del">-		value = 0;</span>
<span class="p_add">+		value = CPCAP_BIT_AUDIO_LOW_PWR;</span>
 		break;
 	default:
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.c b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">index d5bf36ec8a75..34367d172961 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Debug traces for zfcp.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2016</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2017</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -447,6 +447,7 @@</span> <span class="p_context"> static u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,</span>
 	struct fc_ct_hdr *reqh = sg_virt(ct_els-&gt;req);
 	struct fc_ns_gid_ft *reqn = (struct fc_ns_gid_ft *)(reqh + 1);
 	struct scatterlist *resp_entry = ct_els-&gt;resp;
<span class="p_add">+	struct fc_ct_hdr *resph;</span>
 	struct fc_gpn_ft_resp *acc;
 	int max_entries, x, last = 0;
 
<span class="p_chunk">@@ -473,6 +474,13 @@</span> <span class="p_context"> static u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,</span>
 		return len; /* not GPN_FT response so do not cap */
 
 	acc = sg_virt(resp_entry);
<span class="p_add">+</span>
<span class="p_add">+	/* cap all but accept CT responses to at least the CT header */</span>
<span class="p_add">+	resph = (struct fc_ct_hdr *)acc;</span>
<span class="p_add">+	if ((ct_els-&gt;status) ||</span>
<span class="p_add">+	    (resph-&gt;ct_cmd != cpu_to_be16(FC_FS_ACC)))</span>
<span class="p_add">+		return max(FC_CT_HDR_LEN, ZFCP_DBF_SAN_MAX_PAYLOAD);</span>
<span class="p_add">+</span>
 	max_entries = (reqh-&gt;ct_mr_size * 4 / sizeof(struct fc_gpn_ft_resp))
 		+ 1 /* zfcp_fc_scan_ports: bytes correct, entries off-by-one
 		     * to account for header as 1st pseudo &quot;entry&quot; */;
<span class="p_chunk">@@ -555,8 +563,8 @@</span> <span class="p_context"> void zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *sc,</span>
 	rec-&gt;scsi_retries = sc-&gt;retries;
 	rec-&gt;scsi_allowed = sc-&gt;allowed;
 	rec-&gt;scsi_id = sc-&gt;device-&gt;id;
<span class="p_del">-	/* struct zfcp_dbf_scsi needs to be updated to handle 64bit LUNs */</span>
 	rec-&gt;scsi_lun = (u32)sc-&gt;device-&gt;lun;
<span class="p_add">+	rec-&gt;scsi_lun_64_hi = (u32)(sc-&gt;device-&gt;lun &gt;&gt; 32);</span>
 	rec-&gt;host_scribble = (unsigned long)sc-&gt;host_scribble;
 
 	memcpy(rec-&gt;scsi_opcode, sc-&gt;cmnd,
<span class="p_chunk">@@ -564,19 +572,32 @@</span> <span class="p_context"> void zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *sc,</span>
 
 	if (fsf) {
 		rec-&gt;fsf_req_id = fsf-&gt;req_id;
<span class="p_add">+		rec-&gt;pl_len = FCP_RESP_WITH_EXT;</span>
 		fcp_rsp = (struct fcp_resp_with_ext *)
 				&amp;(fsf-&gt;qtcb-&gt;bottom.io.fcp_rsp);
<span class="p_add">+		/* mandatory parts of FCP_RSP IU in this SCSI record */</span>
 		memcpy(&amp;rec-&gt;fcp_rsp, fcp_rsp, FCP_RESP_WITH_EXT);
 		if (fcp_rsp-&gt;resp.fr_flags &amp; FCP_RSP_LEN_VAL) {
 			fcp_rsp_info = (struct fcp_resp_rsp_info *) &amp;fcp_rsp[1];
 			rec-&gt;fcp_rsp_info = fcp_rsp_info-&gt;rsp_code;
<span class="p_add">+			rec-&gt;pl_len += be32_to_cpu(fcp_rsp-&gt;ext.fr_rsp_len);</span>
 		}
 		if (fcp_rsp-&gt;resp.fr_flags &amp; FCP_SNS_LEN_VAL) {
<span class="p_del">-			rec-&gt;pl_len = min((u16)SCSI_SENSE_BUFFERSIZE,</span>
<span class="p_del">-					  (u16)ZFCP_DBF_PAY_MAX_REC);</span>
<span class="p_del">-			zfcp_dbf_pl_write(dbf, sc-&gt;sense_buffer, rec-&gt;pl_len,</span>
<span class="p_del">-					  &quot;fcp_sns&quot;, fsf-&gt;req_id);</span>
<span class="p_add">+			rec-&gt;pl_len += be32_to_cpu(fcp_rsp-&gt;ext.fr_sns_len);</span>
 		}
<span class="p_add">+		/* complete FCP_RSP IU in associated PAYload record</span>
<span class="p_add">+		 * but only if there are optional parts</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (fcp_rsp-&gt;resp.fr_flags != 0)</span>
<span class="p_add">+			zfcp_dbf_pl_write(</span>
<span class="p_add">+				dbf, fcp_rsp,</span>
<span class="p_add">+				/* at least one full PAY record</span>
<span class="p_add">+				 * but not beyond hardware response field</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				min_t(u16, max_t(u16, rec-&gt;pl_len,</span>
<span class="p_add">+						 ZFCP_DBF_PAY_MAX_REC),</span>
<span class="p_add">+				      FSF_FCP_RSP_SIZE),</span>
<span class="p_add">+				&quot;fcp_riu&quot;, fsf-&gt;req_id);</span>
 	}
 
 	debug_event(dbf-&gt;scsi, level, rec, sizeof(*rec));
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">index db186d44cfaf..b60667c145fd 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
  * zfcp device driver
  * debug feature declarations
  *
<span class="p_del">- * Copyright IBM Corp. 2008, 2016</span>
<span class="p_add">+ * Copyright IBM Corp. 2008, 2017</span>
  */
 
 #ifndef ZFCP_DBF_H
<span class="p_chunk">@@ -204,7 +204,7 @@</span> <span class="p_context"> enum zfcp_dbf_scsi_id {</span>
  * @id: unique number of recovery record type
  * @tag: identifier string specifying the location of initiation
  * @scsi_id: scsi device id
<span class="p_del">- * @scsi_lun: scsi device logical unit number</span>
<span class="p_add">+ * @scsi_lun: scsi device logical unit number, low part of 64 bit, old 32 bit</span>
  * @scsi_result: scsi result
  * @scsi_retries: current retry number of scsi request
  * @scsi_allowed: allowed retries
<span class="p_chunk">@@ -214,6 +214,7 @@</span> <span class="p_context"> enum zfcp_dbf_scsi_id {</span>
  * @host_scribble: LLD specific data attached to SCSI request
  * @pl_len: length of paload stored as zfcp_dbf_pay
  * @fsf_rsp: response for fsf request
<span class="p_add">+ * @scsi_lun_64_hi: scsi device logical unit number, high part of 64 bit</span>
  */
 struct zfcp_dbf_scsi {
 	u8 id;
<span class="p_chunk">@@ -230,6 +231,7 @@</span> <span class="p_context"> struct zfcp_dbf_scsi {</span>
 	u64 host_scribble;
 	u16 pl_len;
 	struct fcp_resp_with_ext fcp_rsp;
<span class="p_add">+	u32 scsi_lun_64_hi;</span>
 } __packed;
 
 /**
<span class="p_chunk">@@ -323,7 +325,11 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)</span>
 {
 	struct fsf_qtcb *qtcb = req-&gt;qtcb;
 
<span class="p_del">-	if ((qtcb-&gt;prefix.prot_status != FSF_PROT_GOOD) &amp;&amp;</span>
<span class="p_add">+	if (unlikely(req-&gt;status &amp; (ZFCP_STATUS_FSFREQ_DISMISSED |</span>
<span class="p_add">+				    ZFCP_STATUS_FSFREQ_ERROR))) {</span>
<span class="p_add">+		zfcp_dbf_hba_fsf_resp(&quot;fs_rerr&quot;, 3, req);</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if ((qtcb-&gt;prefix.prot_status != FSF_PROT_GOOD) &amp;&amp;</span>
 	    (qtcb-&gt;prefix.prot_status != FSF_PROT_FSF_STATUS_PRESENTED)) {
 		zfcp_dbf_hba_fsf_resp(&quot;fs_perr&quot;, 1, req);
 
<span class="p_chunk">@@ -401,7 +407,8 @@</span> <span class="p_context"> void zfcp_dbf_scsi_abort(char *tag, struct scsi_cmnd *scmd,</span>
  * @flag: indicates type of reset (Target Reset, Logical Unit Reset)
  */
 static inline
<span class="p_del">-void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)</span>
<span class="p_add">+void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag,</span>
<span class="p_add">+			    struct zfcp_fsf_req *fsf_req)</span>
 {
 	char tmp_tag[ZFCP_DBF_TAG_LEN];
 
<span class="p_chunk">@@ -411,7 +418,7 @@</span> <span class="p_context"> void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)</span>
 		memcpy(tmp_tag, &quot;lr_&quot;, 3);
 
 	memcpy(&amp;tmp_tag[3], tag, 4);
<span class="p_del">-	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, NULL);</span>
<span class="p_add">+	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, fsf_req);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fc.h b/drivers/s390/scsi/zfcp_fc.h</span>
<span class="p_header">index df2b541c8287..a2275825186f 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fc.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fc.h</span>
<span class="p_chunk">@@ -4,7 +4,7 @@</span> <span class="p_context"></span>
  * Fibre Channel related definitions and inline functions for the zfcp
  * device driver
  *
<span class="p_del">- * Copyright IBM Corp. 2009</span>
<span class="p_add">+ * Copyright IBM Corp. 2009, 2017</span>
  */
 
 #ifndef ZFCP_FC_H
<span class="p_chunk">@@ -279,6 +279,10 @@</span> <span class="p_context"> void zfcp_fc_eval_fcp_rsp(struct fcp_resp_with_ext *fcp_rsp,</span>
 		     !(rsp_flags &amp; FCP_SNS_LEN_VAL) &amp;&amp;
 		     fcp_rsp-&gt;resp.fr_status == SAM_STAT_GOOD)
 			set_host_byte(scsi, DID_ERROR);
<span class="p_add">+	} else if (unlikely(rsp_flags &amp; FCP_RESID_OVER)) {</span>
<span class="p_add">+		/* FCP_DL was not sufficient for SCSI data length */</span>
<span class="p_add">+		if (fcp_rsp-&gt;resp.fr_status == SAM_STAT_GOOD)</span>
<span class="p_add">+			set_host_byte(scsi, DID_ERROR);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.c b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">index 27ff38f839fc..1964391db904 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_chunk">@@ -928,8 +928,8 @@</span> <span class="p_context"> static void zfcp_fsf_send_ct_handler(struct zfcp_fsf_req *req)</span>
 
 	switch (header-&gt;fsf_status) {
         case FSF_GOOD:
<span class="p_del">-		zfcp_dbf_san_res(&quot;fsscth2&quot;, req);</span>
 		ct-&gt;status = 0;
<span class="p_add">+		zfcp_dbf_san_res(&quot;fsscth2&quot;, req);</span>
 		break;
         case FSF_SERVICE_CLASS_NOT_SUPPORTED:
 		zfcp_fsf_class_not_supp(req);
<span class="p_chunk">@@ -1109,8 +1109,8 @@</span> <span class="p_context"> static void zfcp_fsf_send_els_handler(struct zfcp_fsf_req *req)</span>
 
 	switch (header-&gt;fsf_status) {
 	case FSF_GOOD:
<span class="p_del">-		zfcp_dbf_san_res(&quot;fsselh1&quot;, req);</span>
 		send_els-&gt;status = 0;
<span class="p_add">+		zfcp_dbf_san_res(&quot;fsselh1&quot;, req);</span>
 		break;
 	case FSF_SERVICE_CLASS_NOT_SUPPORTED:
 		zfcp_fsf_class_not_supp(req);
<span class="p_chunk">@@ -2258,7 +2258,8 @@</span> <span class="p_context"> int zfcp_fsf_fcp_cmnd(struct scsi_cmnd *scsi_cmnd)</span>
 	fcp_cmnd = (struct fcp_cmnd *) &amp;req-&gt;qtcb-&gt;bottom.io.fcp_cmnd;
 	zfcp_fc_scsi_to_fcp(fcp_cmnd, scsi_cmnd, 0);
 
<span class="p_del">-	if (scsi_prot_sg_count(scsi_cmnd)) {</span>
<span class="p_add">+	if ((scsi_get_prot_op(scsi_cmnd) != SCSI_PROT_NORMAL) &amp;&amp;</span>
<span class="p_add">+	    scsi_prot_sg_count(scsi_cmnd)) {</span>
 		zfcp_qdio_set_data_div(qdio, &amp;req-&gt;qdio_req,
 				       scsi_prot_sg_count(scsi_cmnd));
 		retval = zfcp_qdio_sbals_from_sg(qdio, &amp;req-&gt;qdio_req,
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">index 0678cf714c0e..a1eeeaaa0fca 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to Linux SCSI midlayer.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2016</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2017</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -273,25 +273,29 @@</span> <span class="p_context"> static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)</span>
 
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
<span class="p_del">-		if (ret)</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			zfcp_dbf_scsi_devreset(&quot;fiof&quot;, scpnt, tm_flags, NULL);</span>
 			return ret;
<span class="p_add">+		}</span>
 
 		if (!(atomic_read(&amp;adapter-&gt;status) &amp;
 		      ZFCP_STATUS_COMMON_RUNNING)) {
<span class="p_del">-			zfcp_dbf_scsi_devreset(&quot;nres&quot;, scpnt, tm_flags);</span>
<span class="p_add">+			zfcp_dbf_scsi_devreset(&quot;nres&quot;, scpnt, tm_flags, NULL);</span>
 			return SUCCESS;
 		}
 	}
<span class="p_del">-	if (!fsf_req)</span>
<span class="p_add">+	if (!fsf_req) {</span>
<span class="p_add">+		zfcp_dbf_scsi_devreset(&quot;reqf&quot;, scpnt, tm_flags, NULL);</span>
 		return FAILED;
<span class="p_add">+	}</span>
 
 	wait_for_completion(&amp;fsf_req-&gt;completion);
 
 	if (fsf_req-&gt;status &amp; ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
<span class="p_del">-		zfcp_dbf_scsi_devreset(&quot;fail&quot;, scpnt, tm_flags);</span>
<span class="p_add">+		zfcp_dbf_scsi_devreset(&quot;fail&quot;, scpnt, tm_flags, fsf_req);</span>
 		retval = FAILED;
 	} else {
<span class="p_del">-		zfcp_dbf_scsi_devreset(&quot;okay&quot;, scpnt, tm_flags);</span>
<span class="p_add">+		zfcp_dbf_scsi_devreset(&quot;okay&quot;, scpnt, tm_flags, fsf_req);</span>
 		zfcp_scsi_forget_cmnds(zfcp_sdev, tm_flags);
 	}
 
<span class="p_header">diff --git a/drivers/scsi/aacraid/aachba.c b/drivers/scsi/aacraid/aachba.c</span>
<span class="p_header">index a1a2c71e1626..b051d97af468 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/aachba.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/aachba.c</span>
<span class="p_chunk">@@ -594,6 +594,7 @@</span> <span class="p_context"> static int aac_get_container_name(struct scsi_cmnd * scsicmd)</span>
 
 	aac_fib_init(cmd_fibcontext);
 	dinfo = (struct aac_get_name *) fib_data(cmd_fibcontext);
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	dinfo-&gt;command = cpu_to_le32(VM_ContainerConfig);
 	dinfo-&gt;type = cpu_to_le32(CT_READ_NAME);
<span class="p_chunk">@@ -611,10 +612,8 @@</span> <span class="p_context"> static int aac_get_container_name(struct scsi_cmnd * scsicmd)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_get_container_name: aac_fib_send failed with status: %d.\n&quot;, status);
 	aac_fib_complete(cmd_fibcontext);
<span class="p_chunk">@@ -725,6 +724,7 @@</span> <span class="p_context"> static void _aac_probe_container1(void * context, struct fib * fibptr)</span>
 
 	dinfo-&gt;count = cpu_to_le32(scmd_id(scsicmd));
 	dinfo-&gt;type = cpu_to_le32(FT_FILESYS);
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	status = aac_fib_send(ContainerCommand,
 			  fibptr,
<span class="p_chunk">@@ -736,9 +736,7 @@</span> <span class="p_context"> static void _aac_probe_container1(void * context, struct fib * fibptr)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS)</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_del">-	else if (status &lt; 0) {</span>
<span class="p_add">+	if (status &lt; 0 &amp;&amp; status != -EINPROGRESS) {</span>
 		/* Inherit results from VM_NameServe, if any */
 		dresp-&gt;status = cpu_to_le32(ST_OK);
 		_aac_probe_container2(context, fibptr);
<span class="p_chunk">@@ -766,6 +764,7 @@</span> <span class="p_context"> static int _aac_probe_container(struct scsi_cmnd * scsicmd, int (*callback)(stru</span>
 		dinfo-&gt;count = cpu_to_le32(scmd_id(scsicmd));
 		dinfo-&gt;type = cpu_to_le32(FT_FILESYS);
 		scsicmd-&gt;SCp.ptr = (char *)callback;
<span class="p_add">+		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 		status = aac_fib_send(ContainerCommand,
 			  fibptr,
<span class="p_chunk">@@ -777,10 +776,9 @@</span> <span class="p_context"> static int _aac_probe_container(struct scsi_cmnd * scsicmd, int (*callback)(stru</span>
 		/*
 		 *	Check that the command queued to the controller
 		 */
<span class="p_del">-		if (status == -EINPROGRESS) {</span>
<span class="p_del">-			scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+		if (status == -EINPROGRESS)</span>
 			return 0;
<span class="p_del">-		}</span>
<span class="p_add">+</span>
 		if (status &lt; 0) {
 			scsicmd-&gt;SCp.ptr = NULL;
 			aac_fib_complete(fibptr);
<span class="p_chunk">@@ -1126,6 +1124,7 @@</span> <span class="p_context"> static int aac_get_container_serial(struct scsi_cmnd * scsicmd)</span>
 	dinfo-&gt;command = cpu_to_le32(VM_ContainerConfig);
 	dinfo-&gt;type = cpu_to_le32(CT_CID_TO_32BITS_UID);
 	dinfo-&gt;cid = cpu_to_le32(scmd_id(scsicmd));
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	status = aac_fib_send(ContainerCommand,
 		  cmd_fibcontext,
<span class="p_chunk">@@ -1138,10 +1137,8 @@</span> <span class="p_context"> static int aac_get_container_serial(struct scsi_cmnd * scsicmd)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_get_container_serial: aac_fib_send failed with status: %d.\n&quot;, status);
 	aac_fib_complete(cmd_fibcontext);
<span class="p_chunk">@@ -2335,16 +2332,14 @@</span> <span class="p_context"> static int aac_read(struct scsi_cmnd * scsicmd)</span>
 	 *	Alocate and initialize a Fib
 	 */
 	cmd_fibcontext = aac_fib_alloc_tag(dev, scsicmd);
<span class="p_del">-</span>
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 	status = aac_adapter_read(cmd_fibcontext, scsicmd, lba, count);
 
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_read: aac_fib_send failed with status: %d.\n&quot;, status);
 	/*
<span class="p_chunk">@@ -2429,16 +2424,14 @@</span> <span class="p_context"> static int aac_write(struct scsi_cmnd * scsicmd)</span>
 	 *	Allocate and initialize a Fib then setup a BlockWrite command
 	 */
 	cmd_fibcontext = aac_fib_alloc_tag(dev, scsicmd);
<span class="p_del">-</span>
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 	status = aac_adapter_write(cmd_fibcontext, scsicmd, lba, count, fua);
 
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_write: aac_fib_send failed with status: %d\n&quot;, status);
 	/*
<span class="p_chunk">@@ -2588,6 +2581,7 @@</span> <span class="p_context"> static int aac_synchronize(struct scsi_cmnd *scsicmd)</span>
 	synchronizecmd-&gt;cid = cpu_to_le32(scmd_id(scsicmd));
 	synchronizecmd-&gt;count =
 	     cpu_to_le32(sizeof(((struct aac_synchronize_reply *)NULL)-&gt;data));
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	/*
 	 *	Now send the Fib to the adapter
<span class="p_chunk">@@ -2603,10 +2597,8 @@</span> <span class="p_context"> static int aac_synchronize(struct scsi_cmnd *scsicmd)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING
 		&quot;aac_synchronize: aac_fib_send failed with status: %d.\n&quot;, status);
<span class="p_chunk">@@ -2666,6 +2658,7 @@</span> <span class="p_context"> static int aac_start_stop(struct scsi_cmnd *scsicmd)</span>
 	pmcmd-&gt;cid = cpu_to_le32(sdev_id(sdev));
 	pmcmd-&gt;parm = (scsicmd-&gt;cmnd[1] &amp; 1) ?
 		cpu_to_le32(CT_PM_UNIT_IMMEDIATE) : 0;
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	/*
 	 *	Now send the Fib to the adapter
<span class="p_chunk">@@ -2681,10 +2674,8 @@</span> <span class="p_context"> static int aac_start_stop(struct scsi_cmnd *scsicmd)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	aac_fib_complete(cmd_fibcontext);
 	aac_fib_free(cmd_fibcontext);
<span class="p_chunk">@@ -3692,16 +3683,14 @@</span> <span class="p_context"> static int aac_send_srb_fib(struct scsi_cmnd* scsicmd)</span>
 	 *	Allocate and initialize a Fib then setup a BlockWrite command
 	 */
 	cmd_fibcontext = aac_fib_alloc_tag(dev, scsicmd);
<span class="p_del">-</span>
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 	status = aac_adapter_scsi(cmd_fibcontext, scsicmd);
 
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_srb: aac_fib_send failed with status: %d\n&quot;, status);
 	aac_fib_complete(cmd_fibcontext);
<span class="p_chunk">@@ -3739,15 +3728,14 @@</span> <span class="p_context"> static int aac_send_hba_fib(struct scsi_cmnd *scsicmd)</span>
 	if (!cmd_fibcontext)
 		return -1;
 
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 	status = aac_adapter_hba(cmd_fibcontext, scsicmd);
 
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	pr_warn(&quot;aac_hba_cmd_req: aac_fib_send failed with status: %d\n&quot;,
 		status);
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 71c4746341ea..3ee4ea79f81a 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -1995,9 +1995,12 @@</span> <span class="p_context"> static void megasas_complete_outstanding_ioctls(struct megasas_instance *instanc</span>
 			if (cmd_fusion-&gt;sync_cmd_idx != (u32)ULONG_MAX) {
 				cmd_mfi = instance-&gt;cmd_list[cmd_fusion-&gt;sync_cmd_idx];
 				if (cmd_mfi-&gt;sync_cmd &amp;&amp;
<span class="p_del">-					cmd_mfi-&gt;frame-&gt;hdr.cmd != MFI_CMD_ABORT)</span>
<span class="p_add">+				    (cmd_mfi-&gt;frame-&gt;hdr.cmd != MFI_CMD_ABORT)) {</span>
<span class="p_add">+					cmd_mfi-&gt;frame-&gt;hdr.cmd_status =</span>
<span class="p_add">+							MFI_STAT_WRONG_STATE;</span>
 					megasas_complete_cmd(instance,
 							     cmd_mfi, DID_OK);
<span class="p_add">+				}</span>
 			}
 		}
 	} else {
<span class="p_chunk">@@ -5478,7 +5481,8 @@</span> <span class="p_context"> static int megasas_init_fw(struct megasas_instance *instance)</span>
 		instance-&gt;throttlequeuedepth =
 				MEGASAS_THROTTLE_QUEUE_DEPTH;
 
<span class="p_del">-	if (resetwaittime &gt; MEGASAS_RESET_WAIT_TIME)</span>
<span class="p_add">+	if ((resetwaittime &lt; 1) ||</span>
<span class="p_add">+	    (resetwaittime &gt; MEGASAS_RESET_WAIT_TIME))</span>
 		resetwaittime = MEGASAS_RESET_WAIT_TIME;
 
 	if ((scmd_timeout &lt; 10) || (scmd_timeout &gt; MEGASAS_DEFAULT_CMD_TIMEOUT))
<span class="p_chunk">@@ -5649,6 +5653,14 @@</span> <span class="p_context"> megasas_register_aen(struct megasas_instance *instance, u32 seq_num,</span>
 		prev_aen.word =
 			le32_to_cpu(instance-&gt;aen_cmd-&gt;frame-&gt;dcmd.mbox.w[1]);
 
<span class="p_add">+		if ((curr_aen.members.class &lt; MFI_EVT_CLASS_DEBUG) ||</span>
<span class="p_add">+		    (curr_aen.members.class &gt; MFI_EVT_CLASS_DEAD)) {</span>
<span class="p_add">+			dev_info(&amp;instance-&gt;pdev-&gt;dev,</span>
<span class="p_add">+				 &quot;%s %d out of range class %d send by application\n&quot;,</span>
<span class="p_add">+				 __func__, __LINE__, curr_aen.members.class);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/*
 		 * A class whose enum value is smaller is inclusive of all
 		 * higher values. If a PROGRESS (= -1) was previously
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index 985510628f56..8152962f152d 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -3287,7 +3287,7 @@</span> <span class="p_context"> build_mpt_mfi_pass_thru(struct megasas_instance *instance,</span>
 	mpi25_ieee_chain-&gt;Flags = IEEE_SGE_FLAGS_CHAIN_ELEMENT |
 		MPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR;
 
<span class="p_del">-	mpi25_ieee_chain-&gt;Length = cpu_to_le32(instance-&gt;max_chain_frame_sz);</span>
<span class="p_add">+	mpi25_ieee_chain-&gt;Length = cpu_to_le32(instance-&gt;mfi_frame_size);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/qedi/qedi_main.c b/drivers/scsi/qedi/qedi_main.c</span>
<span class="p_header">index 2c3783684815..85e7bae4a7ef 100644</span>
<span class="p_header">--- a/drivers/scsi/qedi/qedi_main.c</span>
<span class="p_header">+++ b/drivers/scsi/qedi/qedi_main.c</span>
<span class="p_chunk">@@ -1575,7 +1575,7 @@</span> <span class="p_context"> struct qedi_cmd *qedi_get_cmd_from_tid(struct qedi_ctx *qedi, u32 tid)</span>
 {
 	struct qedi_cmd *cmd = NULL;
 
<span class="p_del">-	if (tid &gt; MAX_ISCSI_TASK_ENTRIES)</span>
<span class="p_add">+	if (tid &gt;= MAX_ISCSI_TASK_ENTRIES)</span>
 		return NULL;
 
 	cmd = qedi-&gt;itt_map[tid].p_cmd;
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_header">index 08a1feb3a195..8c6ff1682fb1 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_chunk">@@ -318,6 +318,8 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,</span>
 		return -EINVAL;
 	if (start &gt; ha-&gt;optrom_size)
 		return -EINVAL;
<span class="p_add">+	if (size &gt; ha-&gt;optrom_size - start)</span>
<span class="p_add">+		size = ha-&gt;optrom_size - start;</span>
 
 	mutex_lock(&amp;ha-&gt;optrom_mutex);
 	switch (val) {
<span class="p_chunk">@@ -343,8 +345,7 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,</span>
 		}
 
 		ha-&gt;optrom_region_start = start;
<span class="p_del">-		ha-&gt;optrom_region_size = start + size &gt; ha-&gt;optrom_size ?</span>
<span class="p_del">-		    ha-&gt;optrom_size - start : size;</span>
<span class="p_add">+		ha-&gt;optrom_region_size = start + size;</span>
 
 		ha-&gt;optrom_state = QLA_SREADING;
 		ha-&gt;optrom_buffer = vmalloc(ha-&gt;optrom_region_size);
<span class="p_chunk">@@ -417,8 +418,7 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,</span>
 		}
 
 		ha-&gt;optrom_region_start = start;
<span class="p_del">-		ha-&gt;optrom_region_size = start + size &gt; ha-&gt;optrom_size ?</span>
<span class="p_del">-		    ha-&gt;optrom_size - start : size;</span>
<span class="p_add">+		ha-&gt;optrom_region_size = start + size;</span>
 
 		ha-&gt;optrom_state = QLA_SWRITING;
 		ha-&gt;optrom_buffer = vmalloc(ha-&gt;optrom_region_size);
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_gs.c b/drivers/scsi/qla2xxx/qla_gs.c</span>
<span class="p_header">index b323a7c71eda..0ec250993e93 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_gs.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_gs.c</span>
<span class="p_chunk">@@ -3080,7 +3080,7 @@</span> <span class="p_context"> int qla24xx_async_gpsc(scsi_qla_host_t *vha, fc_port_t *fcport)</span>
 		GPSC_RSP_SIZE);
 
 	/* GPSC req */
<span class="p_del">-	memcpy(ct_req-&gt;req.gpsc.port_name, fcport-&gt;port_name,</span>
<span class="p_add">+	memcpy(ct_req-&gt;req.gpsc.port_name, fcport-&gt;fabric_port_name,</span>
 		WWN_SIZE);
 
 	sp-&gt;u.iocb_cmd.u.ctarg.req = fcport-&gt;ct_desc.ct_sns;
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c</span>
<span class="p_header">index 072ad1aa5505..8f83571afc7b 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_init.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_init.c</span>
<span class="p_chunk">@@ -7804,6 +7804,7 @@</span> <span class="p_context"> struct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *vha, int qos,</span>
 		ha-&gt;queue_pair_map[qpair_id] = qpair;
 		qpair-&gt;id = qpair_id;
 		qpair-&gt;vp_idx = vp_idx;
<span class="p_add">+		qpair-&gt;fw_started = ha-&gt;flags.fw_started;</span>
 		INIT_LIST_HEAD(&amp;qpair-&gt;hints_list);
 		qpair-&gt;chip_reset = ha-&gt;base_qpair-&gt;chip_reset;
 		qpair-&gt;enable_class_2 = ha-&gt;base_qpair-&gt;enable_class_2;
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">index 7b3b702ef622..ec2c398f5663 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_chunk">@@ -3429,7 +3429,7 @@</span> <span class="p_context"> qla24xx_enable_msix(struct qla_hw_data *ha, struct rsp_que *rsp)</span>
 	}
 
 	/* Enable MSI-X vector for response queue update for queue 0 */
<span class="p_del">-	if (IS_QLA25XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha)) {</span>
<span class="p_add">+	if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {</span>
 		if (ha-&gt;msixbase &amp;&amp; ha-&gt;mqiobase &amp;&amp;
 		    (ha-&gt;max_rsp_queues &gt; 1 || ha-&gt;max_req_queues &gt; 1 ||
 		     ql2xmqsupport))
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c</span>
<span class="p_header">index 7c6d1a404011..1f1a81c6eaa9 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_mbx.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_mbx.c</span>
<span class="p_chunk">@@ -54,6 +54,7 @@</span> <span class="p_context"> static struct rom_cmd {</span>
 	{ MBC_GET_MEM_OFFLOAD_CNTRL_STAT },
 	{ MBC_GET_RETRY_COUNT },
 	{ MBC_TRACE_CONTROL },
<span class="p_add">+	{ MBC_INITIALIZE_MULTIQ },</span>
 };
 
 static int is_rom_cmd(uint16_t cmd)
<span class="p_chunk">@@ -3689,7 +3690,7 @@</span> <span class="p_context"> qla24xx_report_id_acquisition(scsi_qla_host_t *vha,</span>
 				if (qla_ini_mode_enabled(vha) &amp;&amp;
 				    ha-&gt;flags.fawwpn_enabled &amp;&amp;
 				    (rptid_entry-&gt;u.f1.flags &amp;
<span class="p_del">-				     VP_FLAGS_NAME_VALID)) {</span>
<span class="p_add">+				     BIT_6)) {</span>
 					memcpy(vha-&gt;port_name,
 					    rptid_entry-&gt;u.f1.port_name,
 					    WWN_SIZE);
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c</span>
<span class="p_header">index f0605cd196fb..3089094b48fa 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_mid.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_mid.c</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> qla24xx_deallocate_vp_id(scsi_qla_host_t *vha)</span>
 	 * ensures no active vp_list traversal while the vport is removed
 	 * from the queue)
 	 */
<span class="p_del">-	wait_event_timeout(vha-&gt;vref_waitq, atomic_read(&amp;vha-&gt;vref_count),</span>
<span class="p_add">+	wait_event_timeout(vha-&gt;vref_waitq, !atomic_read(&amp;vha-&gt;vref_count),</span>
 	    10*HZ);
 
 	spin_lock_irqsave(&amp;ha-&gt;vport_slock, flags);
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">index e101cd3043b9..4e2a64773060 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_chunk">@@ -6796,7 +6796,7 @@</span> <span class="p_context"> qlt_probe_one_stage1(struct scsi_qla_host *base_vha, struct qla_hw_data *ha)</span>
 	if (!QLA_TGT_MODE_ENABLED())
 		return;
 
<span class="p_del">-	if  (ha-&gt;mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha)) {</span>
<span class="p_add">+	if  (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {</span>
 		ISP_ATIO_Q_IN(base_vha) = &amp;ha-&gt;mqiobase-&gt;isp25mq.atio_q_in;
 		ISP_ATIO_Q_OUT(base_vha) = &amp;ha-&gt;mqiobase-&gt;isp25mq.atio_q_out;
 	} else {
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index aad6ebb51735..1a9de8419997 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -828,6 +828,39 @@</span> <span class="p_context"> static int max_sectors_bytes(struct request_queue *q)</span>
 	return max_sectors &lt;&lt; 9;
 }
 
<span class="p_add">+static void</span>
<span class="p_add">+sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)</span>
<span class="p_add">+{</span>
<span class="p_add">+	Sg_request *srp;</span>
<span class="p_add">+	int val;</span>
<span class="p_add">+	unsigned int ms;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = 0;</span>
<span class="p_add">+	list_for_each_entry(srp, &amp;sfp-&gt;rq_list, entry) {</span>
<span class="p_add">+		if (val &gt; SG_MAX_QUEUE)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		rinfo[val].req_state = srp-&gt;done + 1;</span>
<span class="p_add">+		rinfo[val].problem =</span>
<span class="p_add">+			srp-&gt;header.masked_status &amp;</span>
<span class="p_add">+			srp-&gt;header.host_status &amp;</span>
<span class="p_add">+			srp-&gt;header.driver_status;</span>
<span class="p_add">+		if (srp-&gt;done)</span>
<span class="p_add">+			rinfo[val].duration =</span>
<span class="p_add">+				srp-&gt;header.duration;</span>
<span class="p_add">+		else {</span>
<span class="p_add">+			ms = jiffies_to_msecs(jiffies);</span>
<span class="p_add">+			rinfo[val].duration =</span>
<span class="p_add">+				(ms &gt; srp-&gt;header.duration) ?</span>
<span class="p_add">+				(ms - srp-&gt;header.duration) : 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		rinfo[val].orphan = srp-&gt;orphan;</span>
<span class="p_add">+		rinfo[val].sg_io_owned = srp-&gt;sg_io_owned;</span>
<span class="p_add">+		rinfo[val].pack_id = srp-&gt;header.pack_id;</span>
<span class="p_add">+		rinfo[val].usr_ptr = srp-&gt;header.usr_ptr;</span>
<span class="p_add">+		val++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static long
 sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)
 {
<span class="p_chunk">@@ -1012,38 +1045,13 @@</span> <span class="p_context"> sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)</span>
 			return -EFAULT;
 		else {
 			sg_req_info_t *rinfo;
<span class="p_del">-			unsigned int ms;</span>
 
<span class="p_del">-			rinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,</span>
<span class="p_del">-								GFP_KERNEL);</span>
<span class="p_add">+			rinfo = kzalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,</span>
<span class="p_add">+					GFP_KERNEL);</span>
 			if (!rinfo)
 				return -ENOMEM;
 			read_lock_irqsave(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-			val = 0;</span>
<span class="p_del">-			list_for_each_entry(srp, &amp;sfp-&gt;rq_list, entry) {</span>
<span class="p_del">-				if (val &gt;= SG_MAX_QUEUE)</span>
<span class="p_del">-					break;</span>
<span class="p_del">-				memset(&amp;rinfo[val], 0, SZ_SG_REQ_INFO);</span>
<span class="p_del">-				rinfo[val].req_state = srp-&gt;done + 1;</span>
<span class="p_del">-				rinfo[val].problem =</span>
<span class="p_del">-					srp-&gt;header.masked_status &amp;</span>
<span class="p_del">-					srp-&gt;header.host_status &amp;</span>
<span class="p_del">-					srp-&gt;header.driver_status;</span>
<span class="p_del">-				if (srp-&gt;done)</span>
<span class="p_del">-					rinfo[val].duration =</span>
<span class="p_del">-						srp-&gt;header.duration;</span>
<span class="p_del">-				else {</span>
<span class="p_del">-					ms = jiffies_to_msecs(jiffies);</span>
<span class="p_del">-					rinfo[val].duration =</span>
<span class="p_del">-						(ms &gt; srp-&gt;header.duration) ?</span>
<span class="p_del">-						(ms - srp-&gt;header.duration) : 0;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				rinfo[val].orphan = srp-&gt;orphan;</span>
<span class="p_del">-				rinfo[val].sg_io_owned = srp-&gt;sg_io_owned;</span>
<span class="p_del">-				rinfo[val].pack_id = srp-&gt;header.pack_id;</span>
<span class="p_del">-				rinfo[val].usr_ptr = srp-&gt;header.usr_ptr;</span>
<span class="p_del">-				val++;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			sg_fill_request_table(sfp, rinfo);</span>
 			read_unlock_irqrestore(&amp;sfp-&gt;rq_list_lock, iflags);
 			result = __copy_to_user(p, rinfo,
 						SZ_SG_REQ_INFO * SG_MAX_QUEUE);
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 3cc8d67783a1..5e7200f05873 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -1640,6 +1640,8 @@</span> <span class="p_context"> static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)</span>
 	put_cpu();
 
 	if (ret == -EAGAIN) {
<span class="p_add">+		if (payload_sz &gt; sizeof(cmd_request-&gt;mpb))</span>
<span class="p_add">+			kfree(payload);</span>
 		/* no more space */
 		return SCSI_MLQUEUE_DEVICE_BUSY;
 	}
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index 4e7a4e9dcf4d..f8eba1c5412f 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -361,6 +361,32 @@</span> <span class="p_context"> int tty_insert_flip_string_flags(struct tty_port *port,</span>
 }
 EXPORT_SYMBOL(tty_insert_flip_string_flags);
 
<span class="p_add">+/**</span>
<span class="p_add">+ *	__tty_insert_flip_char   -	Add one character to the tty buffer</span>
<span class="p_add">+ *	@port: tty port</span>
<span class="p_add">+ *	@ch: character</span>
<span class="p_add">+ *	@flag: flag byte</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Queue a single byte to the tty buffering, with an optional flag.</span>
<span class="p_add">+ *	This is the slow path of tty_insert_flip_char.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __tty_insert_flip_char(struct tty_port *port, unsigned char ch, char flag)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct tty_buffer *tb;</span>
<span class="p_add">+	int flags = (flag == TTY_NORMAL) ? TTYB_NORMAL : 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!__tty_buffer_request_room(port, 1, flags))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	tb = port-&gt;buf.tail;</span>
<span class="p_add">+	if (~tb-&gt;flags &amp; TTYB_NORMAL)</span>
<span class="p_add">+		*flag_buf_ptr(tb, tb-&gt;used) = flag;</span>
<span class="p_add">+	*char_buf_ptr(tb, tb-&gt;used++) = ch;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(__tty_insert_flip_char);</span>
<span class="p_add">+</span>
 /**
  *	tty_schedule_flip	-	push characters to ldisc
  *	@port: tty port to push from
<span class="p_header">diff --git a/fs/ext4/file.c b/fs/ext4/file.c</span>
<span class="p_header">index 0d7cf0cc9b87..86ea1d92839a 100644</span>
<span class="p_header">--- a/fs/ext4/file.c</span>
<span class="p_header">+++ b/fs/ext4/file.c</span>
<span class="p_chunk">@@ -595,7 +595,7 @@</span> <span class="p_context"> static loff_t ext4_seek_data(struct file *file, loff_t offset, loff_t maxsize)</span>
 	inode_lock(inode);
 
 	isize = i_size_read(inode);
<span class="p_del">-	if (offset &gt;= isize) {</span>
<span class="p_add">+	if (offset &lt; 0 || offset &gt;= isize) {</span>
 		inode_unlock(inode);
 		return -ENXIO;
 	}
<span class="p_chunk">@@ -658,7 +658,7 @@</span> <span class="p_context"> static loff_t ext4_seek_hole(struct file *file, loff_t offset, loff_t maxsize)</span>
 	inode_lock(inode);
 
 	isize = i_size_read(inode);
<span class="p_del">-	if (offset &gt;= isize) {</span>
<span class="p_add">+	if (offset &lt; 0 || offset &gt;= isize) {</span>
 		inode_unlock(inode);
 		return -ENXIO;
 	}
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index d61a70e2193a..c9e7be58756b 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -2404,6 +2404,7 @@</span> <span class="p_context"> static void ext4_orphan_cleanup(struct super_block *sb,</span>
 	unsigned int s_flags = sb-&gt;s_flags;
 	int ret, nr_orphans = 0, nr_truncates = 0;
 #ifdef CONFIG_QUOTA
<span class="p_add">+	int quota_update = 0;</span>
 	int i;
 #endif
 	if (!es-&gt;s_last_orphan) {
<span class="p_chunk">@@ -2442,14 +2443,32 @@</span> <span class="p_context"> static void ext4_orphan_cleanup(struct super_block *sb,</span>
 #ifdef CONFIG_QUOTA
 	/* Needed for iput() to work correctly and not trash data */
 	sb-&gt;s_flags |= MS_ACTIVE;
<span class="p_del">-	/* Turn on quotas so that they are updated correctly */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Turn on quotas which were not enabled for read-only mounts if</span>
<span class="p_add">+	 * filesystem has quota feature, so that they are updated correctly.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ext4_has_feature_quota(sb) &amp;&amp; (s_flags &amp; MS_RDONLY)) {</span>
<span class="p_add">+		int ret = ext4_enable_quotas(sb);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			quota_update = 1;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ext4_msg(sb, KERN_ERR,</span>
<span class="p_add">+				&quot;Cannot turn on quotas: error %d&quot;, ret);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Turn on journaled quotas used for old sytle */</span>
 	for (i = 0; i &lt; EXT4_MAXQUOTAS; i++) {
 		if (EXT4_SB(sb)-&gt;s_qf_names[i]) {
 			int ret = ext4_quota_on_mount(sb, i);
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				quota_update = 1;</span>
<span class="p_add">+			else</span>
 				ext4_msg(sb, KERN_ERR,
 					&quot;Cannot turn on journaled &quot;
<span class="p_del">-					&quot;quota: error %d&quot;, ret);</span>
<span class="p_add">+					&quot;quota: type %d: error %d&quot;, i, ret);</span>
 		}
 	}
 #endif
<span class="p_chunk">@@ -2510,10 +2529,12 @@</span> <span class="p_context"> static void ext4_orphan_cleanup(struct super_block *sb,</span>
 		ext4_msg(sb, KERN_INFO, &quot;%d truncate%s cleaned up&quot;,
 		       PLURAL(nr_truncates));
 #ifdef CONFIG_QUOTA
<span class="p_del">-	/* Turn quotas off */</span>
<span class="p_del">-	for (i = 0; i &lt; EXT4_MAXQUOTAS; i++) {</span>
<span class="p_del">-		if (sb_dqopt(sb)-&gt;files[i])</span>
<span class="p_del">-			dquot_quota_off(sb, i);</span>
<span class="p_add">+	/* Turn off quotas if they were enabled for orphan cleanup */</span>
<span class="p_add">+	if (quota_update) {</span>
<span class="p_add">+		for (i = 0; i &lt; EXT4_MAXQUOTAS; i++) {</span>
<span class="p_add">+			if (sb_dqopt(sb)-&gt;files[i])</span>
<span class="p_add">+				dquot_quota_off(sb, i);</span>
<span class="p_add">+		}</span>
 	}
 #endif
 	sb-&gt;s_flags = s_flags; /* Restore MS_RDONLY status */
<span class="p_chunk">@@ -5512,6 +5533,9 @@</span> <span class="p_context"> static int ext4_enable_quotas(struct super_block *sb)</span>
 				DQUOT_USAGE_ENABLED |
 				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
 			if (err) {
<span class="p_add">+				for (type--; type &gt;= 0; type--)</span>
<span class="p_add">+					dquot_quota_off(sb, type);</span>
<span class="p_add">+</span>
 				ext4_warning(sb,
 					&quot;Failed to enable quota tracking &quot;
 					&quot;(type=%d, err=%d). Please run &quot;
<span class="p_header">diff --git a/fs/orangefs/acl.c b/fs/orangefs/acl.c</span>
<span class="p_header">index 7a3754488312..9409aac232f7 100644</span>
<span class="p_header">--- a/fs/orangefs/acl.c</span>
<span class="p_header">+++ b/fs/orangefs/acl.c</span>
<span class="p_chunk">@@ -61,9 +61,9 @@</span> <span class="p_context"> struct posix_acl *orangefs_get_acl(struct inode *inode, int type)</span>
 	return acl;
 }
 
<span class="p_del">-int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
<span class="p_add">+static int __orangefs_set_acl(struct inode *inode, struct posix_acl *acl,</span>
<span class="p_add">+			      int type)</span>
 {
<span class="p_del">-	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);</span>
 	int error = 0;
 	void *value = NULL;
 	size_t size = 0;
<span class="p_chunk">@@ -72,22 +72,6 @@</span> <span class="p_context"> int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			umode_t mode;</span>
<span class="p_del">-</span>
<span class="p_del">-			error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_del">-			if (error) {</span>
<span class="p_del">-				gossip_err(&quot;%s: posix_acl_update_mode err: %d\n&quot;,</span>
<span class="p_del">-					   __func__,</span>
<span class="p_del">-					   error);</span>
<span class="p_del">-				return error;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			if (inode-&gt;i_mode != mode)</span>
<span class="p_del">-				SetModeFlag(orangefs_inode);</span>
<span class="p_del">-			inode-&gt;i_mode = mode;</span>
<span class="p_del">-			mark_inode_dirty_sync(inode);</span>
<span class="p_del">-		}</span>
 		break;
 	case ACL_TYPE_DEFAULT:
 		name = XATTR_NAME_POSIX_ACL_DEFAULT;
<span class="p_chunk">@@ -132,6 +116,29 @@</span> <span class="p_context"> int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	return error;
 }
 
<span class="p_add">+int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		umode_t mode;</span>
<span class="p_add">+</span>
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (error) {</span>
<span class="p_add">+			gossip_err(&quot;%s: posix_acl_update_mode err: %d\n&quot;,</span>
<span class="p_add">+				   __func__,</span>
<span class="p_add">+				   error);</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (inode-&gt;i_mode != mode)</span>
<span class="p_add">+			SetModeFlag(ORANGEFS_I(inode));</span>
<span class="p_add">+		inode-&gt;i_mode = mode;</span>
<span class="p_add">+		mark_inode_dirty_sync(inode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return __orangefs_set_acl(inode, acl, type);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int orangefs_init_acl(struct inode *inode, struct inode *dir)
 {
 	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
<span class="p_chunk">@@ -146,13 +153,14 @@</span> <span class="p_context"> int orangefs_init_acl(struct inode *inode, struct inode *dir)</span>
 		return error;
 
 	if (default_acl) {
<span class="p_del">-		error = orangefs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);</span>
<span class="p_add">+		error = __orangefs_set_acl(inode, default_acl,</span>
<span class="p_add">+					   ACL_TYPE_DEFAULT);</span>
 		posix_acl_release(default_acl);
 	}
 
 	if (acl) {
 		if (!error)
<span class="p_del">-			error = orangefs_set_acl(inode, acl, ACL_TYPE_ACCESS);</span>
<span class="p_add">+			error = __orangefs_set_acl(inode, acl, ACL_TYPE_ACCESS);</span>
 		posix_acl_release(acl);
 	}
 
<span class="p_header">diff --git a/include/linux/ccp.h b/include/linux/ccp.h</span>
<span class="p_header">index 3285c944194a..ab693c3afd0d 100644</span>
<span class="p_header">--- a/include/linux/ccp.h</span>
<span class="p_header">+++ b/include/linux/ccp.h</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 /*
  * AMD Cryptographic Coprocessor (CCP) driver
  *
<span class="p_del">- * Copyright (C) 2013,2016 Advanced Micro Devices, Inc.</span>
<span class="p_add">+ * Copyright (C) 2013,2017 Advanced Micro Devices, Inc.</span>
  *
  * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
  * Author: Gary R Hook &lt;gary.hook@amd.com&gt;
<span class="p_chunk">@@ -231,6 +231,7 @@</span> <span class="p_context"> enum ccp_xts_aes_unit_size {</span>
  * AES operation the new IV overwrites the old IV.
  */
 struct ccp_xts_aes_engine {
<span class="p_add">+	enum ccp_aes_type type;</span>
 	enum ccp_aes_action action;
 	enum ccp_xts_aes_unit_size unit_size;
 
<span class="p_header">diff --git a/include/linux/cpuset.h b/include/linux/cpuset.h</span>
<span class="p_header">index 898cfe2eeb42..bc46e729fdde 100644</span>
<span class="p_header">--- a/include/linux/cpuset.h</span>
<span class="p_header">+++ b/include/linux/cpuset.h</span>
<span class="p_chunk">@@ -57,7 +57,9 @@</span> <span class="p_context"> static inline void cpuset_dec(void)</span>
 
 extern int cpuset_init(void);
 extern void cpuset_init_smp(void);
<span class="p_add">+extern void cpuset_force_rebuild(void);</span>
 extern void cpuset_update_active_cpus(void);
<span class="p_add">+extern void cpuset_wait_for_hotplug(void);</span>
 extern void cpuset_cpus_allowed(struct task_struct *p, struct cpumask *mask);
 extern void cpuset_cpus_allowed_fallback(struct task_struct *p);
 extern nodemask_t cpuset_mems_allowed(struct task_struct *p);
<span class="p_chunk">@@ -170,11 +172,15 @@</span> <span class="p_context"> static inline bool cpusets_enabled(void) { return false; }</span>
 static inline int cpuset_init(void) { return 0; }
 static inline void cpuset_init_smp(void) {}
 
<span class="p_add">+static inline void cpuset_force_rebuild(void) { }</span>
<span class="p_add">+</span>
 static inline void cpuset_update_active_cpus(void)
 {
 	partition_sched_domains(1, NULL, NULL);
 }
 
<span class="p_add">+static inline void cpuset_wait_for_hotplug(void) { }</span>
<span class="p_add">+</span>
 static inline void cpuset_cpus_allowed(struct task_struct *p,
 				       struct cpumask *mask)
 {
<span class="p_header">diff --git a/include/linux/ftrace.h b/include/linux/ftrace.h</span>
<span class="p_header">index 6383115e9d2c..2e028854bac7 100644</span>
<span class="p_header">--- a/include/linux/ftrace.h</span>
<span class="p_header">+++ b/include/linux/ftrace.h</span>
<span class="p_chunk">@@ -307,7 +307,7 @@</span> <span class="p_context"> DECLARE_PER_CPU(int, disable_stack_tracer);</span>
 static inline void stack_tracer_disable(void)
 {
 	/* Preemption or interupts must be disabled */
<span class="p_del">-	if (IS_ENABLED(CONFIG_PREEMPT_DEBUG))</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_DEBUG_PREEMPT))</span>
 		WARN_ON_ONCE(!preempt_count() || !irqs_disabled());
 	this_cpu_inc(disable_stack_tracer);
 }
<span class="p_chunk">@@ -320,7 +320,7 @@</span> <span class="p_context"> static inline void stack_tracer_disable(void)</span>
  */
 static inline void stack_tracer_enable(void)
 {
<span class="p_del">-	if (IS_ENABLED(CONFIG_PREEMPT_DEBUG))</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_DEBUG_PREEMPT))</span>
 		WARN_ON_ONCE(!preempt_count() || !irqs_disabled());
 	this_cpu_dec(disable_stack_tracer);
 }
<span class="p_header">diff --git a/include/linux/tty_flip.h b/include/linux/tty_flip.h</span>
<span class="p_header">index c28dd523f96e..d43837f2ce3a 100644</span>
<span class="p_header">--- a/include/linux/tty_flip.h</span>
<span class="p_header">+++ b/include/linux/tty_flip.h</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"> extern int tty_prepare_flip_string(struct tty_port *port,</span>
 		unsigned char **chars, size_t size);
 extern void tty_flip_buffer_push(struct tty_port *port);
 void tty_schedule_flip(struct tty_port *port);
<span class="p_add">+int __tty_insert_flip_char(struct tty_port *port, unsigned char ch, char flag);</span>
 
 static inline int tty_insert_flip_char(struct tty_port *port,
 					unsigned char ch, char flag)
<span class="p_chunk">@@ -26,7 +27,7 @@</span> <span class="p_context"> static inline int tty_insert_flip_char(struct tty_port *port,</span>
 		*char_buf_ptr(tb, tb-&gt;used++) = ch;
 		return 1;
 	}
<span class="p_del">-	return tty_insert_flip_string_flags(port, &amp;ch, &amp;flag, 1);</span>
<span class="p_add">+	return __tty_insert_flip_char(port, ch, flag);</span>
 }
 
 static inline int tty_insert_flip_string(struct tty_port *port,
<span class="p_header">diff --git a/include/linux/uaccess.h b/include/linux/uaccess.h</span>
<span class="p_header">index acdd6f915a8d..20ef8e6ec2db 100644</span>
<span class="p_header">--- a/include/linux/uaccess.h</span>
<span class="p_header">+++ b/include/linux/uaccess.h</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> copy_to_user(void __user *to, const void *from, unsigned long n)</span>
 }
 #ifdef CONFIG_COMPAT
 static __always_inline unsigned long __must_check
<span class="p_del">-copy_in_user(void __user *to, const void *from, unsigned long n)</span>
<span class="p_add">+copy_in_user(void __user *to, const void __user *from, unsigned long n)</span>
 {
 	might_fault();
 	if (access_ok(VERIFY_WRITE, to, n) &amp;&amp; access_ok(VERIFY_READ, from, n))
<span class="p_header">diff --git a/kernel/cgroup/cpuset.c b/kernel/cgroup/cpuset.c</span>
<span class="p_header">index 87a1213dd326..e8cb34193433 100644</span>
<span class="p_header">--- a/kernel/cgroup/cpuset.c</span>
<span class="p_header">+++ b/kernel/cgroup/cpuset.c</span>
<span class="p_chunk">@@ -2260,6 +2260,13 @@</span> <span class="p_context"> static void cpuset_hotplug_update_tasks(struct cpuset *cs)</span>
 	mutex_unlock(&amp;cpuset_mutex);
 }
 
<span class="p_add">+static bool force_rebuild;</span>
<span class="p_add">+</span>
<span class="p_add">+void cpuset_force_rebuild(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	force_rebuild = true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * cpuset_hotplug_workfn - handle CPU/memory hotunplug for a cpuset
  *
<span class="p_chunk">@@ -2334,8 +2341,10 @@</span> <span class="p_context"> static void cpuset_hotplug_workfn(struct work_struct *work)</span>
 	}
 
 	/* rebuild sched domains if cpus_allowed has changed */
<span class="p_del">-	if (cpus_updated)</span>
<span class="p_add">+	if (cpus_updated || force_rebuild) {</span>
<span class="p_add">+		force_rebuild = false;</span>
 		rebuild_sched_domains();
<span class="p_add">+	}</span>
 }
 
 void cpuset_update_active_cpus(void)
<span class="p_chunk">@@ -2354,6 +2363,11 @@</span> <span class="p_context"> void cpuset_update_active_cpus(void)</span>
 	schedule_work(&amp;cpuset_hotplug_work);
 }
 
<span class="p_add">+void cpuset_wait_for_hotplug(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	flush_work(&amp;cpuset_hotplug_work);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Keep top_cpuset.mems_allowed tracking node_states[N_MEMORY].
  * Call this routine anytime after node_states[N_MEMORY] changes.
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index eee033134262..a88c29ab09be 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -1252,7 +1252,17 @@</span> <span class="p_context"> static int cpuhp_store_callbacks(enum cpuhp_state state, const char *name,</span>
 	struct cpuhp_step *sp;
 	int ret = 0;
 
<span class="p_del">-	if (state == CPUHP_AP_ONLINE_DYN || state == CPUHP_BP_PREPARE_DYN) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If name is NULL, then the state gets removed.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * CPUHP_AP_ONLINE_DYN and CPUHP_BP_PREPARE_DYN are handed out on</span>
<span class="p_add">+	 * the first allocation from these dynamic ranges, so the removal</span>
<span class="p_add">+	 * would trigger a new allocation and clear the wrong (already</span>
<span class="p_add">+	 * empty) state, leaving the callbacks of the to be cleared state</span>
<span class="p_add">+	 * dangling, which causes wreckage on the next hotplug operation.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (name &amp;&amp; (state == CPUHP_AP_ONLINE_DYN ||</span>
<span class="p_add">+		     state == CPUHP_BP_PREPARE_DYN)) {</span>
 		ret = cpuhp_reserve_state(state);
 		if (ret &lt; 0)
 			return ret;
<span class="p_header">diff --git a/kernel/power/process.c b/kernel/power/process.c</span>
<span class="p_header">index 78672d324a6e..50f25cb370c6 100644</span>
<span class="p_header">--- a/kernel/power/process.c</span>
<span class="p_header">+++ b/kernel/power/process.c</span>
<span class="p_chunk">@@ -20,8 +20,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/workqueue.h&gt;
 #include &lt;linux/kmod.h&gt;
 #include &lt;trace/events/power.h&gt;
<span class="p_add">+#include &lt;linux/cpuset.h&gt;</span>
 
<span class="p_del">-/* </span>
<span class="p_add">+/*</span>
  * Timeout for stopping processes
  */
 unsigned int __read_mostly freeze_timeout_msecs = 20 * MSEC_PER_SEC;
<span class="p_chunk">@@ -202,6 +203,8 @@</span> <span class="p_context"> void thaw_processes(void)</span>
 	__usermodehelper_set_disable_depth(UMH_FREEZING);
 	thaw_workqueues();
 
<span class="p_add">+	cpuset_wait_for_hotplug();</span>
<span class="p_add">+</span>
 	read_lock(&amp;tasklist_lock);
 	for_each_process_thread(g, p) {
 		/* No other threads should have PF_SUSPEND_TASK set */
<span class="p_header">diff --git a/kernel/rcu/srcutree.c b/kernel/rcu/srcutree.c</span>
<span class="p_header">index d0ca524bf042..258a9abee0b0 100644</span>
<span class="p_header">--- a/kernel/rcu/srcutree.c</span>
<span class="p_header">+++ b/kernel/rcu/srcutree.c</span>
<span class="p_chunk">@@ -896,6 +896,15 @@</span> <span class="p_context"> static void __synchronize_srcu(struct srcu_struct *sp, bool do_norm)</span>
 	__call_srcu(sp, &amp;rcu.head, wakeme_after_rcu, do_norm);
 	wait_for_completion(&amp;rcu.completion);
 	destroy_rcu_head_on_stack(&amp;rcu.head);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure that later code is ordered after the SRCU grace</span>
<span class="p_add">+	 * period.  This pairs with the raw_spin_lock_irq_rcu_node()</span>
<span class="p_add">+	 * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed</span>
<span class="p_add">+	 * because the current CPU might have been totally uninvolved with</span>
<span class="p_add">+	 * (and thus unordered against) that grace period.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
 }
 
 /**
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 0869b20fba81..99326c370c9c 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -5538,16 +5538,15 @@</span> <span class="p_context"> static void cpuset_cpu_active(void)</span>
 		 * operation in the resume sequence, just build a single sched
 		 * domain, ignoring cpusets.
 		 */
<span class="p_del">-		num_cpus_frozen--;</span>
<span class="p_del">-		if (likely(num_cpus_frozen)) {</span>
<span class="p_del">-			partition_sched_domains(1, NULL, NULL);</span>
<span class="p_add">+		partition_sched_domains(1, NULL, NULL);</span>
<span class="p_add">+		if (--num_cpus_frozen)</span>
 			return;
<span class="p_del">-		}</span>
 		/*
 		 * This is the last CPU online operation. So fall through and
 		 * restore the original sched domains by considering the
 		 * cpuset configurations.
 		 */
<span class="p_add">+		cpuset_force_rebuild();</span>
 	}
 	cpuset_update_active_cpus();
 }
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index 96cea88fa00f..725819569fa7 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -2828,13 +2828,14 @@</span> <span class="p_context"> static int ftrace_shutdown(struct ftrace_ops *ops, int command)</span>
 
 	if (!command || !ftrace_enabled) {
 		/*
<span class="p_del">-		 * If these are per_cpu ops, they still need their</span>
<span class="p_del">-		 * per_cpu field freed. Since, function tracing is</span>
<span class="p_add">+		 * If these are dynamic or per_cpu ops, they still</span>
<span class="p_add">+		 * need their data freed. Since, function tracing is</span>
 		 * not currently active, we can just free them
 		 * without synchronizing all CPUs.
 		 */
<span class="p_del">-		if (ops-&gt;flags &amp; FTRACE_OPS_FL_PER_CPU)</span>
<span class="p_del">-			per_cpu_ops_free(ops);</span>
<span class="p_add">+		if (ops-&gt;flags &amp; (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_PER_CPU))</span>
<span class="p_add">+			goto free_ops;</span>
<span class="p_add">+</span>
 		return 0;
 	}
 
<span class="p_chunk">@@ -2900,6 +2901,7 @@</span> <span class="p_context"> static int ftrace_shutdown(struct ftrace_ops *ops, int command)</span>
 		if (IS_ENABLED(CONFIG_PREEMPT))
 			synchronize_rcu_tasks();
 
<span class="p_add">+ free_ops:</span>
 		arch_ftrace_trampoline_free(ops);
 
 		if (ops-&gt;flags &amp; FTRACE_OPS_FL_PER_CPU)
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 44004d8aa3b3..5efb4b63174e 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -2799,11 +2799,17 @@</span> <span class="p_context"> static char *get_trace_buf(void)</span>
 	if (!buffer || buffer-&gt;nesting &gt;= 4)
 		return NULL;
 
<span class="p_del">-	return &amp;buffer-&gt;buffer[buffer-&gt;nesting++][0];</span>
<span class="p_add">+	buffer-&gt;nesting++;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Interrupts must see nesting incremented before we use the buffer */</span>
<span class="p_add">+	barrier();</span>
<span class="p_add">+	return &amp;buffer-&gt;buffer[buffer-&gt;nesting][0];</span>
 }
 
 static void put_trace_buf(void)
 {
<span class="p_add">+	/* Don&#39;t let the decrement of nesting leak before this */</span>
<span class="p_add">+	barrier();</span>
 	this_cpu_dec(trace_percpu_buffer-&gt;nesting);
 }
 
<span class="p_chunk">@@ -6220,7 +6226,7 @@</span> <span class="p_context"> static int tracing_set_clock(struct trace_array *tr, const char *clockstr)</span>
 	tracing_reset_online_cpus(&amp;tr-&gt;trace_buffer);
 
 #ifdef CONFIG_TRACER_MAX_TRACE
<span class="p_del">-	if (tr-&gt;flags &amp; TRACE_ARRAY_FL_GLOBAL &amp;&amp; tr-&gt;max_buffer.buffer)</span>
<span class="p_add">+	if (tr-&gt;max_buffer.buffer)</span>
 		ring_buffer_set_clock(tr-&gt;max_buffer.buffer, trace_clocks[i].func);
 	tracing_reset_online_cpus(&amp;tr-&gt;max_buffer);
 #endif
<span class="p_header">diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c</span>
<span class="p_header">index 36132f9280e6..51a6e09a7410 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events.c</span>
<span class="p_chunk">@@ -406,7 +406,7 @@</span> <span class="p_context"> static int __ftrace_event_enable_disable(struct trace_event_file *file,</span>
 
 			if (file-&gt;flags &amp; EVENT_FILE_FL_RECORDED_TGID) {
 				tracing_stop_tgid_record();
<span class="p_del">-				clear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &amp;file-&gt;flags);</span>
<span class="p_add">+				clear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &amp;file-&gt;flags);</span>
 			}
 
 			call-&gt;class-&gt;reg(call, TRACE_REG_UNREGISTER, file);
<span class="p_header">diff --git a/kernel/trace/trace_selftest.c b/kernel/trace/trace_selftest.c</span>
<span class="p_header">index cb917cebae29..b17ec642793b 100644</span>
<span class="p_header">--- a/kernel/trace/trace_selftest.c</span>
<span class="p_header">+++ b/kernel/trace/trace_selftest.c</span>
<span class="p_chunk">@@ -273,7 +273,7 @@</span> <span class="p_context"> static int trace_selftest_ops(struct trace_array *tr, int cnt)</span>
 		goto out_free;
 	if (cnt &gt; 1) {
 		if (trace_selftest_test_global_cnt == 0)
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto out_free;</span>
 	}
 	if (trace_selftest_test_dyn_cnt == 0)
 		goto out_free;
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">index 9979f46c81dc..51390febd5e3 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_chunk">@@ -96,19 +96,26 @@</span> <span class="p_context"> static struct conntrack_gc_work conntrack_gc_work;</span>
 
 void nf_conntrack_lock(spinlock_t *lock) __acquires(lock)
 {
<span class="p_add">+	/* 1) Acquire the lock */</span>
 	spin_lock(lock);
<span class="p_del">-	while (unlikely(nf_conntrack_locks_all)) {</span>
<span class="p_del">-		spin_unlock(lock);</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Order the &#39;nf_conntrack_locks_all&#39; load vs. the</span>
<span class="p_del">-		 * spin_unlock_wait() loads below, to ensure</span>
<span class="p_del">-		 * that &#39;nf_conntrack_locks_all_lock&#39; is indeed held:</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		smp_rmb(); /* spin_lock(&amp;nf_conntrack_locks_all_lock) */</span>
<span class="p_del">-		spin_unlock_wait(&amp;nf_conntrack_locks_all_lock);</span>
<span class="p_del">-		spin_lock(lock);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* 2) read nf_conntrack_locks_all, with ACQUIRE semantics</span>
<span class="p_add">+	 * It pairs with the smp_store_release() in nf_conntrack_all_unlock()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (likely(smp_load_acquire(&amp;nf_conntrack_locks_all) == false))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* fast path failed, unlock */</span>
<span class="p_add">+	spin_unlock(lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Slow path 1) get global lock */</span>
<span class="p_add">+	spin_lock(&amp;nf_conntrack_locks_all_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Slow path 2) get the lock we want */</span>
<span class="p_add">+	spin_lock(lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Slow path 3) release the global lock */</span>
<span class="p_add">+	spin_unlock(&amp;nf_conntrack_locks_all_lock);</span>
 }
 EXPORT_SYMBOL_GPL(nf_conntrack_lock);
 
<span class="p_chunk">@@ -149,28 +156,27 @@</span> <span class="p_context"> static void nf_conntrack_all_lock(void)</span>
 	int i;
 
 	spin_lock(&amp;nf_conntrack_locks_all_lock);
<span class="p_del">-	nf_conntrack_locks_all = true;</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Order the above store of &#39;nf_conntrack_locks_all&#39; against</span>
<span class="p_del">-	 * the spin_unlock_wait() loads below, such that if</span>
<span class="p_del">-	 * nf_conntrack_lock() observes &#39;nf_conntrack_locks_all&#39;</span>
<span class="p_del">-	 * we must observe nf_conntrack_locks[] held:</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	smp_mb(); /* spin_lock(&amp;nf_conntrack_locks_all_lock) */</span>
<span class="p_add">+	nf_conntrack_locks_all = true;</span>
 
 	for (i = 0; i &lt; CONNTRACK_LOCKS; i++) {
<span class="p_del">-		spin_unlock_wait(&amp;nf_conntrack_locks[i]);</span>
<span class="p_add">+		spin_lock(&amp;nf_conntrack_locks[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* This spin_unlock provides the &quot;release&quot; to ensure that</span>
<span class="p_add">+		 * nf_conntrack_locks_all==true is visible to everyone that</span>
<span class="p_add">+		 * acquired spin_lock(&amp;nf_conntrack_locks[]).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		spin_unlock(&amp;nf_conntrack_locks[i]);</span>
 	}
 }
 
 static void nf_conntrack_all_unlock(void)
 {
<span class="p_del">-	/*</span>
<span class="p_del">-	 * All prior stores must be complete before we clear</span>
<span class="p_add">+	/* All prior stores must be complete before we clear</span>
 	 * &#39;nf_conntrack_locks_all&#39;. Otherwise nf_conntrack_lock()
 	 * might observe the false value but not the entire
<span class="p_del">-	 * critical section:</span>
<span class="p_add">+	 * critical section.</span>
<span class="p_add">+	 * It pairs with the smp_load_acquire() in nf_conntrack_lock()</span>
 	 */
 	smp_store_release(&amp;nf_conntrack_locks_all, false);
 	spin_unlock(&amp;nf_conntrack_locks_all_lock);
<span class="p_header">diff --git a/sound/core/seq_device.c b/sound/core/seq_device.c</span>
<span class="p_header">index c4acf17e9f5e..e40a2cba5002 100644</span>
<span class="p_header">--- a/sound/core/seq_device.c</span>
<span class="p_header">+++ b/sound/core/seq_device.c</span>
<span class="p_chunk">@@ -148,8 +148,10 @@</span> <span class="p_context"> void snd_seq_device_load_drivers(void)</span>
 	flush_work(&amp;autoload_work);
 }
 EXPORT_SYMBOL(snd_seq_device_load_drivers);
<span class="p_add">+#define cancel_autoload_drivers()	cancel_work_sync(&amp;autoload_work)</span>
 #else
 #define queue_autoload_drivers() /* NOP */
<span class="p_add">+#define cancel_autoload_drivers() /* NOP */</span>
 #endif
 
 /*
<span class="p_chunk">@@ -159,6 +161,7 @@</span> <span class="p_context"> static int snd_seq_device_dev_free(struct snd_device *device)</span>
 {
 	struct snd_seq_device *dev = device-&gt;device_data;
 
<span class="p_add">+	cancel_autoload_drivers();</span>
 	put_device(&amp;dev-&gt;dev);
 	return 0;
 }

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



