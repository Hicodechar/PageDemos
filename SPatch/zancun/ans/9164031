
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4,4/5] iommu/mediatek: add support for mtk iommu generation one HW - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4,4/5] iommu/mediatek: add support for mtk iommu generation one HW</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=166241">honghui.zhang@mediatek.com</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 8, 2016, 9:51 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1465379461-14757-5-git-send-email-honghui.zhang@mediatek.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9164031/mbox/"
   >mbox</a>
|
   <a href="/patch/9164031/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9164031/">/patch/9164031/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	0D94A60467 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  8 Jun 2016 09:52:37 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id EF2D72837A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  8 Jun 2016 09:52:36 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E34C1283A0; Wed,  8 Jun 2016 09:52:36 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	UNPARSEABLE_RELAY autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 672032837A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  8 Jun 2016 09:52:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1424314AbcFHJw3 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 8 Jun 2016 05:52:29 -0400
Received: from mailgw01.mediatek.com ([210.61.82.183]:12840 &quot;EHLO
	mailgw01.mediatek.com&quot; rhost-flags-OK-FAIL-OK-FAIL) by
	vger.kernel.org with ESMTP id S1423076AbcFHJv3 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 8 Jun 2016 05:51:29 -0400
Received: from mtkhts09.mediatek.inc [(172.21.101.70)] by
	mailgw01.mediatek.com (envelope-from &lt;honghui.zhang@mediatek.com&gt;)
	(mhqrelay.mediatek.com ESMTP with TLS)
	with ESMTP id 995056777; Wed, 08 Jun 2016 17:51:24 +0800
Received: from localhost.localdomain (172.21.77.4) by mtkhts09.mediatek.inc
	(172.21.101.73) with Microsoft SMTP Server id 14.3.266.1;
	Wed, 8 Jun 2016 17:51:24 +0800
From: &lt;honghui.zhang@mediatek.com&gt;
To: &lt;joro@8bytes.org&gt;, &lt;treding@nvidia.com&gt;, &lt;mark.rutland@arm.com&gt;,
	&lt;matthias.bgg@gmail.com&gt;, &lt;robh@kernel.org&gt;, &lt;robin.murphy@arm.com&gt;
CC: &lt;p.zabel@pengutronix.de&gt;, &lt;devicetree@vger.kernel.org&gt;,
	&lt;pebolle@tiscali.nl&gt;, &lt;kendrick.hsu@mediatek.com&gt;, &lt;arnd@arndb.de&gt;,
	&lt;srv_heupstream@mediatek.com&gt;, &lt;catalin.marinas@arm.com&gt;,
	&lt;will.deacon@arm.com&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	&lt;tfiga@google.com&gt;, &lt;iommu@lists.linux-foundation.org&gt;,
	&lt;robh+dt@kernel.org&gt;, &lt;djkurtz@google.com&gt;,
	&lt;kernel@pengutronix.de&gt;, &lt;linux-mediatek@lists.infradead.org&gt;,
	&lt;linux-arm-kernel@lists.infradead.org&gt;, &lt;l.stach@pengutronix.de&gt;,
	&lt;yingjoe.chen@mediatek.com&gt;, &lt;eddie.huang@mediatek.com&gt;,
	&lt;youlin.pei@mediatek.com&gt;, &lt;erin.lo@mediatek.com&gt;,
	Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;
Subject: [PATCH v4 4/5] iommu/mediatek: add support for mtk iommu generation
	one HW
Date: Wed, 8 Jun 2016 17:51:00 +0800
Message-ID: &lt;1465379461-14757-5-git-send-email-honghui.zhang@mediatek.com&gt;
X-Mailer: git-send-email 1.7.9.5
In-Reply-To: &lt;1465379461-14757-1-git-send-email-honghui.zhang@mediatek.com&gt;
References: &lt;1465379461-14757-1-git-send-email-honghui.zhang@mediatek.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166241">honghui.zhang@mediatek.com</a> - June 8, 2016, 9:51 a.m.</div>
<pre class="content">
<span class="from">From: Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;</span>

Mediatek SoC&#39;s M4U has two generations of HW architcture. Generation one
uses flat, one layer pagetable, and was shipped with ARM architecture, it
only supports 4K size page mapping. MT2701 SoC uses this generation one
m4u HW. Generation two uses the ARM short-descriptor translation table
format for address translation, and was shipped with ARM64 architecture,
MT8173 uses this generation two m4u HW. All the two generation iommu HW
only have one iommu domain, and all its iommu clients share the same
iova address.

These two generation m4u HW have slit different register groups and
register offset, but most register names are the same. This patch add iommu
support for mediatek SoC mt2701.
<span class="signed-off-by">
Signed-off-by: Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;</span>
---
 drivers/iommu/Kconfig        |  18 ++
 drivers/iommu/Makefile       |   1 +
 drivers/iommu/mtk_iommu_v1.c | 727 +++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 746 insertions(+)
 create mode 100644 drivers/iommu/mtk_iommu_v1.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="p_header">index ad08603..32bb1e5 100644</span>
<span class="p_header">--- a/drivers/iommu/Kconfig</span>
<span class="p_header">+++ b/drivers/iommu/Kconfig</span>
<span class="p_chunk">@@ -343,4 +343,22 @@</span> <span class="p_context"> config MTK_IOMMU</span>
 
 	  If unsure, say N here.
 
<span class="p_add">+config MTK_IOMMU_V1</span>
<span class="p_add">+	bool &quot;MTK IOMMU Version 1 (M4U gen1) Support&quot;</span>
<span class="p_add">+	depends on ARM</span>
<span class="p_add">+	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="p_add">+	select ARM_DMA_USE_IOMMU</span>
<span class="p_add">+	select IOMMU_API</span>
<span class="p_add">+	select MEMORY</span>
<span class="p_add">+	select MTK_SMI</span>
<span class="p_add">+	select COMMON_CLK_MT2701_MMSYS</span>
<span class="p_add">+	select COMMON_CLK_MT2701_IMGSYS</span>
<span class="p_add">+	select COMMON_CLK_MT2701_VDECSYS</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Support for the M4U on certain Mediatek SoCs. M4U generation 1 HW is</span>
<span class="p_add">+	  Multimedia Memory Managememt Unit. This option enables remapping of</span>
<span class="p_add">+	  DMA memory accesses for the multimedia subsystem.</span>
<span class="p_add">+</span>
<span class="p_add">+	  if unsure, say N here.</span>
<span class="p_add">+</span>
 endif # IOMMU_SUPPORT
<span class="p_header">diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="p_header">index c6edb31..778baf5 100644</span>
<span class="p_header">--- a/drivers/iommu/Makefile</span>
<span class="p_header">+++ b/drivers/iommu/Makefile</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"> obj-$(CONFIG_INTEL_IOMMU_SVM) += intel-svm.o</span>
 obj-$(CONFIG_IPMMU_VMSA) += ipmmu-vmsa.o
 obj-$(CONFIG_IRQ_REMAP) += intel_irq_remapping.o irq_remapping.o
 obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o
<span class="p_add">+obj-$(CONFIG_MTK_IOMMU_V1) += mtk_iommu_v1.o</span>
 obj-$(CONFIG_OMAP_IOMMU) += omap-iommu.o
 obj-$(CONFIG_OMAP_IOMMU_DEBUG) += omap-iommu-debug.o
 obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu_v1.c b/drivers/iommu/mtk_iommu_v1.c</span>
new file mode 100644
<span class="p_header">index 0000000..294485d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu_v1.c</span>
<span class="p_chunk">@@ -0,0 +1,727 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (c) 2015-2016 MediaTek Inc.</span>
<span class="p_add">+ * Author: Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Based on driver/iommu/mtk_iommu.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/bootmem.h&gt;</span>
<span class="p_add">+#include &lt;linux/bug.h&gt;</span>
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
<span class="p_add">+#include &lt;linux/component.h&gt;</span>
<span class="p_add">+#include &lt;linux/device.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/iopoll.h&gt;</span>
<span class="p_add">+#include &lt;linux/kmemleak.h&gt;</span>
<span class="p_add">+#include &lt;linux/list.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/spinlock.h&gt;</span>
<span class="p_add">+#include &lt;asm/barrier.h&gt;</span>
<span class="p_add">+#include &lt;asm/dma-iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;dt-bindings/memory/mt2701-larb-port.h&gt;</span>
<span class="p_add">+#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="p_add">+#include &quot;mtk_iommu.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="p_add">+</span>
<span class="p_add">+#define F_ALL_INVLD				0x2</span>
<span class="p_add">+#define F_MMU_INV_RANGE				0x1</span>
<span class="p_add">+#define F_INVLD_EN0				BIT(0)</span>
<span class="p_add">+#define F_INVLD_EN1				BIT(1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="p_add">+#define MTK_PROTECT_PA_ALIGN			128</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CTRL_REG			0x210</span>
<span class="p_add">+#define F_MMU_CTRL_COHERENT_EN			BIT(8)</span>
<span class="p_add">+#define REG_MMU_IVRP_PADDR			0x214</span>
<span class="p_add">+#define REG_MMU_INT_CONTROL			0x220</span>
<span class="p_add">+#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="p_add">+#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="p_add">+#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="p_add">+#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="p_add">+#define F_INT_TABLE_WALK_FAULT			BIT(4)</span>
<span class="p_add">+#define F_INT_TLB_MISS_FAULT			BIT(5)</span>
<span class="p_add">+#define F_INT_PFH_DMA_FIFO_OVERFLOW		BIT(6)</span>
<span class="p_add">+#define F_INT_MISS_DMA_FIFO_OVERFLOW		BIT(7)</span>
<span class="p_add">+</span>
<span class="p_add">+#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="p_add">+#define F_INT_CLR_BIT				BIT(12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_ST			0x224</span>
<span class="p_add">+#define REG_MMU_FAULT_VA			0x228</span>
<span class="p_add">+#define REG_MMU_INVLD_PA			0x22C</span>
<span class="p_add">+#define REG_MMU_INT_ID				0x388</span>
<span class="p_add">+#define REG_MMU_INVALIDATE			0x5c0</span>
<span class="p_add">+#define REG_MMU_INVLD_START_A			0x5c4</span>
<span class="p_add">+#define REG_MMU_INVLD_END_A			0x5c8</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INV_SEL				0x5d8</span>
<span class="p_add">+#define REG_MMU_STANDARD_AXI_MODE		0x5e8</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_DCM				0x5f0</span>
<span class="p_add">+#define F_MMU_DCM_ON				BIT(1)</span>
<span class="p_add">+#define REG_MMU_CPE_DONE			0x60c</span>
<span class="p_add">+#define F_DESC_VALID				0x2</span>
<span class="p_add">+#define F_DESC_NONSEC				BIT(3)</span>
<span class="p_add">+#define MT2701_M4U_TF_LARB(TF)			(6 - (((TF) &gt;&gt; 13) &amp; 0x7))</span>
<span class="p_add">+#define MT2701_M4U_TF_PORT(TF)			(((TF) &gt;&gt; 8) &amp; 0xF)</span>
<span class="p_add">+/* MTK generation one iommu HW only support 4K size mapping */</span>
<span class="p_add">+#define MT2701_IOMMU_PAGE_SHIFT			12</span>
<span class="p_add">+#define MT2701_IOMMU_PAGE_SIZE			(1UL &lt;&lt; MT2701_IOMMU_PAGE_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MTK m4u support 4GB iova address space, and only support 4K page</span>
<span class="p_add">+ * mapping. So the pagetable size should be exactly as 4M.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define M2701_IOMMU_PGT_SIZE			SZ_4M</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_domain {</span>
<span class="p_add">+	spinlock_t			pgtlock; /* lock for page table */</span>
<span class="p_add">+	struct iommu_domain		domain;</span>
<span class="p_add">+	u32				*pgt_va;</span>
<span class="p_add">+	dma_addr_t			pgt_pa;</span>
<span class="p_add">+	struct mtk_iommu_data		*data;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return container_of(dom, struct mtk_iommu_domain, domain);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const int mt2701_m4u_in_larb[] = {</span>
<span class="p_add">+	LARB0_PORT_OFFSET, LARB1_PORT_OFFSET,</span>
<span class="p_add">+	LARB2_PORT_OFFSET, LARB3_PORT_OFFSET</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int mt2701_m4u_to_larb(int id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = ARRAY_SIZE(mt2701_m4u_in_larb) - 1; i &gt;= 0; i--)</span>
<span class="p_add">+		if ((id) &gt;= mt2701_m4u_in_larb[i])</span>
<span class="p_add">+			return i;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int mt2701_m4u_to_port(int id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int larb = mt2701_m4u_to_larb(id);</span>
<span class="p_add">+</span>
<span class="p_add">+	return id - mt2701_m4u_in_larb[larb];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_flush_all(struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,</span>
<span class="p_add">+			data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="p_add">+	writel_relaxed(F_ALL_INVLD, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+	wmb(); /* Make sure the tlb flush all done */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_flush_range(struct mtk_iommu_data *data,</span>
<span class="p_add">+				unsigned long iova, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	u32 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,</span>
<span class="p_add">+		data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="p_add">+	writel_relaxed(iova &amp; F_MMU_FAULT_VA_MSK,</span>
<span class="p_add">+		data-&gt;base + REG_MMU_INVLD_START_A);</span>
<span class="p_add">+	writel_relaxed((iova + size - 1) &amp; F_MMU_FAULT_VA_MSK,</span>
<span class="p_add">+		data-&gt;base + REG_MMU_INVLD_END_A);</span>
<span class="p_add">+	writel_relaxed(F_MMU_INV_RANGE, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = readl_poll_timeout_atomic(data-&gt;base + REG_MMU_CPE_DONE,</span>
<span class="p_add">+				tmp, tmp != 0, 10, 100000);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_warn(data-&gt;dev,</span>
<span class="p_add">+			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="p_add">+		mtk_iommu_tlb_flush_all(data);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Clear the CPE status */</span>
<span class="p_add">+	writel_relaxed(0, data-&gt;base + REG_MMU_CPE_DONE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_id;</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="p_add">+	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="p_add">+	unsigned int fault_larb, fault_port;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Read error information from registers */</span>
<span class="p_add">+	int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST);</span>
<span class="p_add">+	fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);</span>
<span class="p_add">+</span>
<span class="p_add">+	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="p_add">+	fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);</span>
<span class="p_add">+	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);</span>
<span class="p_add">+	fault_larb = MT2701_M4U_TF_LARB(regval);</span>
<span class="p_add">+	fault_port = MT2701_M4U_TF_PORT(regval);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * MTK v1 iommu HW could not determine whether the fault is read or</span>
<span class="p_add">+	 * write fault, report as read fault.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (report_iommu_fault(&amp;dom-&gt;domain, data-&gt;dev, fault_iova,</span>
<span class="p_add">+			IOMMU_FAULT_READ))</span>
<span class="p_add">+		dev_err_ratelimited(data-&gt;dev,</span>
<span class="p_add">+			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d\n&quot;,</span>
<span class="p_add">+			int_state, fault_iova, fault_pa,</span>
<span class="p_add">+			fault_larb, fault_port);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Interrupt clear */</span>
<span class="p_add">+	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+	regval |= F_INT_CLR_BIT;</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_tlb_flush_all(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_config(struct mtk_iommu_data *data,</span>
<span class="p_add">+			     struct device *dev, bool enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="p_add">+	struct mtk_smi_larb_iommu    *larb_mmu;</span>
<span class="p_add">+	unsigned int                 larbid, portid;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="p_add">+		larbid = mt2701_m4u_to_larb(cur-&gt;mtk_m4u_id);</span>
<span class="p_add">+		portid = mt2701_m4u_to_port(cur-&gt;mtk_m4u_id);</span>
<span class="p_add">+		larb_mmu = &amp;data-&gt;smi_imu.larb_imu[larbid];</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_dbg(dev, &quot;%s iommu port: %d\n&quot;,</span>
<span class="p_add">+			enable ? &quot;enable&quot; : &quot;disable&quot;, portid);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (enable)</span>
<span class="p_add">+			larb_mmu-&gt;mmu |= MTK_SMI_MMU_EN(portid);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			larb_mmu-&gt;mmu &amp;= ~MTK_SMI_MMU_EN(portid);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_domain_finalise(struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;pgt_va = dma_zalloc_coherent(data-&gt;dev,</span>
<span class="p_add">+				M2701_IOMMU_PGT_SIZE,</span>
<span class="p_add">+				&amp;dom-&gt;pgt_pa, GFP_KERNEL);</span>
<span class="p_add">+	if (!dom-&gt;pgt_va)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(dom-&gt;pgt_pa, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;data = data;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	dom = kzalloc(sizeof(*dom), GFP_KERNEL);</span>
<span class="p_add">+	if (!dom)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;dom-&gt;domain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	struct mtk_iommu_data *data = dom-&gt;data;</span>
<span class="p_add">+</span>
<span class="p_add">+	dma_free_coherent(data-&gt;dev, M2701_IOMMU_PGT_SIZE,</span>
<span class="p_add">+			dom-&gt;pgt_va, dom-&gt;pgt_pa);</span>
<span class="p_add">+	kfree(to_mtk_domain(domain));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				   struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	struct mtk_iommu_data *data;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+	if (!data-&gt;m4u_dom) {</span>
<span class="p_add">+		data-&gt;m4u_dom = dom;</span>
<span class="p_add">+		ret = mtk_iommu_domain_finalise(data);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			data-&gt;m4u_dom = NULL;</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_config(data, dev, true);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				    struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	struct mtk_iommu_data *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+	mtk_iommu_config(data, dev, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="p_add">+			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned int page_num = size &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+	u32 *pgt_base_iova = dom-&gt;pgt_va + (iova  &gt;&gt; MT2701_IOMMU_PAGE_SHIFT);</span>
<span class="p_add">+	u32 pabase = (u32)paddr;</span>
<span class="p_add">+	int map_size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+	for (i = 0; i &lt; page_num; i++) {</span>
<span class="p_add">+		if (pgt_base_iova[i]) {</span>
<span class="p_add">+			memset(pgt_base_iova, 0, i * sizeof(u32));</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		pgt_base_iova[i] = pabase | F_DESC_VALID | F_DESC_NONSEC;</span>
<span class="p_add">+		pabase += MT2701_IOMMU_PAGE_SIZE;</span>
<span class="p_add">+		map_size += MT2701_IOMMU_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_tlb_flush_range(dom-&gt;data, iova, size);</span>
<span class="p_add">+</span>
<span class="p_add">+	return map_size == size ? 0 : -EEXIST;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="p_add">+			      unsigned long iova, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 *pgt_base_iova = dom-&gt;pgt_va + (iova  &gt;&gt; MT2701_IOMMU_PAGE_SHIFT);</span>
<span class="p_add">+	unsigned int page_num = size &gt;&gt; MT2701_IOMMU_PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+	memset(pgt_base_iova, 0, page_num * sizeof(u32));</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_tlb_flush_range(dom-&gt;data, iova, size);</span>
<span class="p_add">+</span>
<span class="p_add">+	return size;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="p_add">+					  dma_addr_t iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	phys_addr_t pa;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+	pa = *(dom-&gt;pgt_va + (iova &gt;&gt; MT2701_IOMMU_PAGE_SHIFT));</span>
<span class="p_add">+	pa = pa &amp; (~(MT2701_IOMMU_PAGE_SIZE - 1));</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pa;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MTK generation one iommu HW only support one iommu domain, and all the client</span>
<span class="p_add">+ * sharing the same iova address space.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int mtk_iommu_create_mapping(struct device *dev,</span>
<span class="p_add">+				    struct of_phandle_args *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *priv, *next;</span>
<span class="p_add">+	struct platform_device *m4updev;</span>
<span class="p_add">+	struct dma_iommu_mapping *mtk_mapping;</span>
<span class="p_add">+	struct device *m4udev;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (args-&gt;args_count != 1) {</span>
<span class="p_add">+		dev_err(dev, &quot;invalid #iommu-cells(%d) property for IOMMU\n&quot;,</span>
<span class="p_add">+			args-&gt;args_count);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) {</span>
<span class="p_add">+		/* Get the m4u device */</span>
<span class="p_add">+		m4updev = of_find_device_by_node(args-&gt;np);</span>
<span class="p_add">+		if (WARN_ON(!m4updev))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		head = kzalloc(sizeof(*head), GFP_KERNEL);</span>
<span class="p_add">+		if (!head)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev-&gt;archdata.iommu = head;</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;head-&gt;client);</span>
<span class="p_add">+		head-&gt;m4udev = &amp;m4updev-&gt;dev;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto err_free_mem;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	priv-&gt;mtk_m4u_id = args-&gt;args[0];</span>
<span class="p_add">+	list_add_tail(&amp;priv-&gt;client, &amp;head-&gt;client);</span>
<span class="p_add">+</span>
<span class="p_add">+	m4udev = head-&gt;m4udev;</span>
<span class="p_add">+	mtk_mapping = m4udev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!mtk_mapping) {</span>
<span class="p_add">+		/* MTK iommu support 4GB iova address space. */</span>
<span class="p_add">+		mtk_mapping = arm_iommu_create_mapping(&amp;platform_bus_type,</span>
<span class="p_add">+						0, 1ULL &lt;&lt; 32);</span>
<span class="p_add">+		if (IS_ERR(mtk_mapping)) {</span>
<span class="p_add">+			ret = PTR_ERR(mtk_mapping);</span>
<span class="p_add">+			goto err_free_mem;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		m4udev-&gt;archdata.iommu = mtk_mapping;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = arm_iommu_attach_device(dev, mtk_mapping);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto err_release_mapping;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_release_mapping:</span>
<span class="p_add">+	arm_iommu_release_mapping(mtk_mapping);</span>
<span class="p_add">+	m4udev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+err_free_mem:</span>
<span class="p_add">+	list_for_each_entry_safe(priv, next, &amp;head-&gt;client, client)</span>
<span class="p_add">+		kfree(priv);</span>
<span class="p_add">+	kfree(head);</span>
<span class="p_add">+	dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_add_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iommu_group *group;</span>
<span class="p_add">+	struct of_phandle_args iommu_spec;</span>
<span class="p_add">+	struct of_phandle_iterator it;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	of_for_each_phandle(&amp;it, err, dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="p_add">+			&quot;#iommu-cells&quot;, 0) {</span>
<span class="p_add">+		int count = of_phandle_iterator_args(&amp;it, iommu_spec.args,</span>
<span class="p_add">+					MAX_PHANDLE_ARGS);</span>
<span class="p_add">+		iommu_spec.np = of_node_get(it.node);</span>
<span class="p_add">+		iommu_spec.args_count = count;</span>
<span class="p_add">+</span>
<span class="p_add">+		mtk_iommu_create_mapping(dev, &amp;iommu_spec);</span>
<span class="p_add">+		of_node_put(iommu_spec.np);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	group = iommu_group_get_for_dev(dev);</span>
<span class="p_add">+	if (IS_ERR(group))</span>
<span class="p_add">+		return PTR_ERR(group);</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu_group_put(group);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_remove_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!head)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="p_add">+		list_del(&amp;cur-&gt;client);</span>
<span class="p_add">+		kfree(cur);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kfree(head);</span>
<span class="p_add">+	dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu_group_remove_device(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return ERR_PTR(-ENODEV);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All the client devices are in the same m4u iommu-group */</span>
<span class="p_add">+	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+	if (!data-&gt;m4u_group) {</span>
<span class="p_add">+		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="p_add">+		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return data-&gt;m4u_group;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 regval;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed to enable iommu bclk(%d)\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_MMU_CTRL_COHERENT_EN | F_MMU_TF_PROTECT_SEL(2);</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="p_add">+		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="p_add">+		F_INT_INVALID_PA_FAULT |</span>
<span class="p_add">+		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="p_add">+		F_INT_TABLE_WALK_FAULT |</span>
<span class="p_add">+		F_INT_TLB_MISS_FAULT |</span>
<span class="p_add">+		F_INT_PFH_DMA_FIFO_OVERFLOW |</span>
<span class="p_add">+		F_INT_MISS_DMA_FIFO_OVERFLOW;</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* protect memory,hw will write here while translation fault */</span>
<span class="p_add">+	writel_relaxed(data-&gt;protect_base,</span>
<span class="p_add">+			data-&gt;base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(F_MMU_DCM_ON, data-&gt;base + REG_MMU_DCM);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="p_add">+			     dev_name(data-&gt;dev), (void *)data)) {</span>
<span class="p_add">+		writel_relaxed(0, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops = {</span>
<span class="p_add">+	.domain_alloc	= mtk_iommu_domain_alloc,</span>
<span class="p_add">+	.domain_free	= mtk_iommu_domain_free,</span>
<span class="p_add">+	.attach_dev	= mtk_iommu_attach_device,</span>
<span class="p_add">+	.detach_dev	= mtk_iommu_detach_device,</span>
<span class="p_add">+	.map		= mtk_iommu_map,</span>
<span class="p_add">+	.unmap		= mtk_iommu_unmap,</span>
<span class="p_add">+	.map_sg		= default_iommu_map_sg,</span>
<span class="p_add">+	.iova_to_phys	= mtk_iommu_iova_to_phys,</span>
<span class="p_add">+	.add_device	= mtk_iommu_add_device,</span>
<span class="p_add">+	.remove_device	= mtk_iommu_remove_device,</span>
<span class="p_add">+	.device_group	= mtk_iommu_device_group,</span>
<span class="p_add">+	.pgsize_bitmap	= ~0UL &lt;&lt; MT2701_IOMMU_PAGE_SHIFT,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt2701-m4u&quot;, },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct component_master_ops mtk_iommu_com_ops = {</span>
<span class="p_add">+	.bind		= mtk_iommu_bind,</span>
<span class="p_add">+	.unbind		= mtk_iommu_unbind,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data		*data;</span>
<span class="p_add">+	struct device			*dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	struct resource			*res;</span>
<span class="p_add">+	struct component_match		*match = NULL;</span>
<span class="p_add">+	struct of_phandle_args		larb_spec;</span>
<span class="p_add">+	struct of_phandle_iterator	it;</span>
<span class="p_add">+	void				*protect;</span>
<span class="p_add">+	int				larb_nr, ret, err;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;dev = dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="p_add">+	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2,</span>
<span class="p_add">+			GFP_KERNEL | GFP_DMA);</span>
<span class="p_add">+	if (!protect)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	data-&gt;protect_base = ALIGN(virt_to_phys(protect), MTK_PROTECT_PA_ALIGN);</span>
<span class="p_add">+</span>
<span class="p_add">+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="p_add">+	data-&gt;base = devm_ioremap_resource(dev, res);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;base))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (data-&gt;irq &lt; 0)</span>
<span class="p_add">+		return data-&gt;irq;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;bclk))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;bclk);</span>
<span class="p_add">+</span>
<span class="p_add">+	larb_nr = 0;</span>
<span class="p_add">+	of_for_each_phandle(&amp;it, err, dev-&gt;of_node,</span>
<span class="p_add">+			&quot;mediatek,larbs&quot;, NULL, 0) {</span>
<span class="p_add">+		struct platform_device *plarbdev;</span>
<span class="p_add">+		int count = of_phandle_iterator_args(&amp;it, larb_spec.args,</span>
<span class="p_add">+					MAX_PHANDLE_ARGS);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (count)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		larb_spec.np = of_node_get(it.node);</span>
<span class="p_add">+		if (!of_device_is_available(larb_spec.np))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		plarbdev = of_find_device_by_node(larb_spec.np);</span>
<span class="p_add">+		of_node_put(larb_spec.np);</span>
<span class="p_add">+		if (!plarbdev) {</span>
<span class="p_add">+			plarbdev = of_platform_device_create(</span>
<span class="p_add">+						larb_spec.np, NULL,</span>
<span class="p_add">+						platform_bus_type.dev_root);</span>
<span class="p_add">+			if (!plarbdev)</span>
<span class="p_add">+				return -EPROBE_DEFER;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		data-&gt;smi_imu.larb_imu[larb_nr].dev = &amp;plarbdev-&gt;dev;</span>
<span class="p_add">+		component_match_add(dev, &amp;match, compare_of, larb_spec.np);</span>
<span class="p_add">+		larb_nr++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;smi_imu.larb_nr = larb_nr;</span>
<span class="p_add">+</span>
<span class="p_add">+	platform_set_drvdata(pdev, data);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_hw_init(data);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!iommu_present(&amp;platform_bus_type))</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type,  &amp;mtk_iommu_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return component_master_add_with_match(dev, &amp;mtk_iommu_com_ops, match);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = platform_get_drvdata(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (iommu_present(&amp;platform_bus_type))</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	clk_disable_unprepare(data-&gt;bclk);</span>
<span class="p_add">+	devm_free_irq(&amp;pdev-&gt;dev, data-&gt;irq, data);</span>
<span class="p_add">+	component_master_del(&amp;pdev-&gt;dev, &amp;mtk_iommu_com_ops);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __maybe_unused mtk_iommu_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg-&gt;standard_axi_mode = readl_relaxed(base +</span>
<span class="p_add">+					       REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	reg-&gt;dcm_dis = readl_relaxed(base + REG_MMU_DCM);</span>
<span class="p_add">+	reg-&gt;ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	reg-&gt;int_control0 = readl_relaxed(base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(data-&gt;m4u_dom-&gt;pgt_pa, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="p_add">+		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL);</span>
<span class="p_add">+	writel_relaxed(data-&gt;protect_base, base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="p_add">+	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mtk_iommu_driver = {</span>
<span class="p_add">+	.probe	= mtk_iommu_probe,</span>
<span class="p_add">+	.remove	= mtk_iommu_remove,</span>
<span class="p_add">+	.driver	= {</span>
<span class="p_add">+		.name = &quot;mtk-iommu&quot;,</span>
<span class="p_add">+		.of_match_table = mtk_iommu_of_ids,</span>
<span class="p_add">+		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="p_add">+	}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init m4u_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit m4u_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return platform_driver_unregister(&amp;mtk_iommu_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+subsys_initcall(m4u_init);</span>
<span class="p_add">+module_exit(m4u_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;IOMMU API for MTK architected m4u v1 implementations&quot;);</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Honghui Zhang &lt;honghui.zhang@mediatek.com&gt;&quot;);</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



