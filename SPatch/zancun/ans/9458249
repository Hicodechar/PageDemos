
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.36 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.36</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 2, 2016, 11:19 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161202111911.GB11865@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9458249/mbox/"
   >mbox</a>
|
   <a href="/patch/9458249/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9458249/">/patch/9458249/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	6A3AC60515 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  2 Dec 2016 11:19:34 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 56DB4284F0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  2 Dec 2016 11:19:34 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 4B67928533; Fri,  2 Dec 2016 11:19:34 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 870B5284F0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  2 Dec 2016 11:19:32 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1758911AbcLBLTK (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 2 Dec 2016 06:19:10 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:46702 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1758242AbcLBLTF (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 2 Dec 2016 06:19:05 -0500
Received: from localhost (unknown [37.166.252.87])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 477709C;
	Fri,  2 Dec 2016 11:19:03 +0000 (UTC)
Date: Fri, 2 Dec 2016 12:19:11 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.36
Message-ID: &lt;20161202111911.GB11865@kroah.com&gt;
References: &lt;20161202111906.GA11865@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161202111906.GA11865@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 2, 2016, 11:19 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f88830af1533..705eb9e38fce 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 35</span>
<span class="p_add">+SUBLEVEL = 36</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/parisc/kernel/cache.c b/arch/parisc/kernel/cache.c</span>
<span class="p_header">index cda6dbbe9842..fd5979f28ada 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/cache.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/cache.c</span>
<span class="p_chunk">@@ -351,6 +351,7 @@</span> <span class="p_context"> void __init parisc_setup_cache_timing(void)</span>
 {
 	unsigned long rangetime, alltime;
 	unsigned long size, start;
<span class="p_add">+	unsigned long threshold;</span>
 
 	alltime = mfctl(16);
 	flush_data_cache();
<span class="p_chunk">@@ -364,17 +365,12 @@</span> <span class="p_context"> void __init parisc_setup_cache_timing(void)</span>
 	printk(KERN_DEBUG &quot;Whole cache flush %lu cycles, flushing %lu bytes %lu cycles\n&quot;,
 		alltime, size, rangetime);
 
<span class="p_del">-	/* Racy, but if we see an intermediate value, it&#39;s ok too... */</span>
<span class="p_del">-	parisc_cache_flush_threshold = size * alltime / rangetime;</span>
<span class="p_del">-</span>
<span class="p_del">-	parisc_cache_flush_threshold = L1_CACHE_ALIGN(parisc_cache_flush_threshold);</span>
<span class="p_del">-	if (!parisc_cache_flush_threshold)</span>
<span class="p_del">-		parisc_cache_flush_threshold = FLUSH_THRESHOLD;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (parisc_cache_flush_threshold &gt; cache_info.dc_size)</span>
<span class="p_del">-		parisc_cache_flush_threshold = cache_info.dc_size;</span>
<span class="p_del">-</span>
<span class="p_del">-	printk(KERN_INFO &quot;Setting cache flush threshold to %lu kB\n&quot;,</span>
<span class="p_add">+	threshold = L1_CACHE_ALIGN(size * alltime / rangetime);</span>
<span class="p_add">+	if (threshold &gt; cache_info.dc_size)</span>
<span class="p_add">+		threshold = cache_info.dc_size;</span>
<span class="p_add">+	if (threshold)</span>
<span class="p_add">+		parisc_cache_flush_threshold = threshold;</span>
<span class="p_add">+	printk(KERN_INFO &quot;Cache flush threshold set to %lu KiB\n&quot;,</span>
 		parisc_cache_flush_threshold/1024);
 
 	/* calculate TLB flush threshold */
<span class="p_chunk">@@ -383,7 +379,7 @@</span> <span class="p_context"> void __init parisc_setup_cache_timing(void)</span>
 	flush_tlb_all();
 	alltime = mfctl(16) - alltime;
 
<span class="p_del">-	size = PAGE_SIZE;</span>
<span class="p_add">+	size = 0;</span>
 	start = (unsigned long) _text;
 	rangetime = mfctl(16);
 	while (start &lt; (unsigned long) _end) {
<span class="p_chunk">@@ -396,13 +392,10 @@</span> <span class="p_context"> void __init parisc_setup_cache_timing(void)</span>
 	printk(KERN_DEBUG &quot;Whole TLB flush %lu cycles, flushing %lu bytes %lu cycles\n&quot;,
 		alltime, size, rangetime);
 
<span class="p_del">-	parisc_tlb_flush_threshold = size * alltime / rangetime;</span>
<span class="p_del">-	parisc_tlb_flush_threshold *= num_online_cpus();</span>
<span class="p_del">-	parisc_tlb_flush_threshold = PAGE_ALIGN(parisc_tlb_flush_threshold);</span>
<span class="p_del">-	if (!parisc_tlb_flush_threshold)</span>
<span class="p_del">-		parisc_tlb_flush_threshold = FLUSH_TLB_THRESHOLD;</span>
<span class="p_del">-</span>
<span class="p_del">-	printk(KERN_INFO &quot;Setting TLB flush threshold to %lu kB\n&quot;,</span>
<span class="p_add">+	threshold = PAGE_ALIGN(num_online_cpus() * size * alltime / rangetime);</span>
<span class="p_add">+	if (threshold)</span>
<span class="p_add">+		parisc_tlb_flush_threshold = threshold;</span>
<span class="p_add">+	printk(KERN_INFO &quot;TLB flush threshold set to %lu KiB\n&quot;,</span>
 		parisc_tlb_flush_threshold/1024);
 }
 
<span class="p_header">diff --git a/arch/parisc/kernel/pacache.S b/arch/parisc/kernel/pacache.S</span>
<span class="p_header">index b743a80eaba0..675521919229 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pacache.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/pacache.S</span>
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> fitmanyloop:					/* Loop if LOOP &gt;= 2 */</span>
 
 fitmanymiddle:					/* Loop if LOOP &gt;= 2 */
 	addib,COND(&gt;)		-1, %r31, fitmanymiddle	/* Adjusted inner loop decr */
<span class="p_del">-	pitlbe		0(%sr1, %r28)</span>
<span class="p_add">+	pitlbe		%r0(%sr1, %r28)</span>
 	pitlbe,m	%arg1(%sr1, %r28)	/* Last pitlbe and addr adjust */
 	addib,COND(&gt;)		-1, %r29, fitmanymiddle	/* Middle loop decr */
 	copy		%arg3, %r31		/* Re-init inner loop count */
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"> fdtmanyloop:					/* Loop if LOOP &gt;= 2 */</span>
 
 fdtmanymiddle:					/* Loop if LOOP &gt;= 2 */
 	addib,COND(&gt;)		-1, %r31, fdtmanymiddle	/* Adjusted inner loop decr */
<span class="p_del">-	pdtlbe		0(%sr1, %r28)</span>
<span class="p_add">+	pdtlbe		%r0(%sr1, %r28)</span>
 	pdtlbe,m	%arg1(%sr1, %r28)	/* Last pdtlbe and addr adjust */
 	addib,COND(&gt;)		-1, %r29, fdtmanymiddle	/* Middle loop decr */
 	copy		%arg3, %r31		/* Re-init inner loop count */
<span class="p_chunk">@@ -620,12 +620,12 @@</span> <span class="p_context"> ENTRY(copy_user_page_asm)</span>
 	/* Purge any old translations */
 
 #ifdef CONFIG_PA20
<span class="p_del">-	pdtlb,l		0(%r28)</span>
<span class="p_del">-	pdtlb,l		0(%r29)</span>
<span class="p_add">+	pdtlb,l		%r0(%r28)</span>
<span class="p_add">+	pdtlb,l		%r0(%r29)</span>
 #else
 	tlb_lock	%r20,%r21,%r22
<span class="p_del">-	pdtlb		0(%r28)</span>
<span class="p_del">-	pdtlb		0(%r29)</span>
<span class="p_add">+	pdtlb		%r0(%r28)</span>
<span class="p_add">+	pdtlb		%r0(%r29)</span>
 	tlb_unlock	%r20,%r21,%r22
 #endif
 
<span class="p_chunk">@@ -768,10 +768,10 @@</span> <span class="p_context"> ENTRY(clear_user_page_asm)</span>
 	/* Purge any old translation */
 
 #ifdef CONFIG_PA20
<span class="p_del">-	pdtlb,l		0(%r28)</span>
<span class="p_add">+	pdtlb,l		%r0(%r28)</span>
 #else
 	tlb_lock	%r20,%r21,%r22
<span class="p_del">-	pdtlb		0(%r28)</span>
<span class="p_add">+	pdtlb		%r0(%r28)</span>
 	tlb_unlock	%r20,%r21,%r22
 #endif
 
<span class="p_chunk">@@ -852,10 +852,10 @@</span> <span class="p_context"> ENTRY(flush_dcache_page_asm)</span>
 	/* Purge any old translation */
 
 #ifdef CONFIG_PA20
<span class="p_del">-	pdtlb,l		0(%r28)</span>
<span class="p_add">+	pdtlb,l		%r0(%r28)</span>
 #else
 	tlb_lock	%r20,%r21,%r22
<span class="p_del">-	pdtlb		0(%r28)</span>
<span class="p_add">+	pdtlb		%r0(%r28)</span>
 	tlb_unlock	%r20,%r21,%r22
 #endif
 
<span class="p_chunk">@@ -892,10 +892,10 @@</span> <span class="p_context"> ENTRY(flush_dcache_page_asm)</span>
 	sync
 
 #ifdef CONFIG_PA20
<span class="p_del">-	pdtlb,l		0(%r25)</span>
<span class="p_add">+	pdtlb,l		%r0(%r25)</span>
 #else
 	tlb_lock	%r20,%r21,%r22
<span class="p_del">-	pdtlb		0(%r25)</span>
<span class="p_add">+	pdtlb		%r0(%r25)</span>
 	tlb_unlock	%r20,%r21,%r22
 #endif
 
<span class="p_chunk">@@ -925,13 +925,18 @@</span> <span class="p_context"> ENTRY(flush_icache_page_asm)</span>
 	depwi		0, 31,PAGE_SHIFT, %r28	/* Clear any offset bits */
 #endif
 
<span class="p_del">-	/* Purge any old translation */</span>
<span class="p_add">+	/* Purge any old translation.  Note that the FIC instruction</span>
<span class="p_add">+	 * may use either the instruction or data TLB.  Given that we</span>
<span class="p_add">+	 * have a flat address space, it&#39;s not clear which TLB will be</span>
<span class="p_add">+	 * used.  So, we purge both entries.  */</span>
 
 #ifdef CONFIG_PA20
<span class="p_add">+	pdtlb,l		%r0(%r28)</span>
 	pitlb,l         %r0(%sr4,%r28)
 #else
 	tlb_lock        %r20,%r21,%r22
<span class="p_del">-	pitlb           (%sr4,%r28)</span>
<span class="p_add">+	pdtlb		%r0(%r28)</span>
<span class="p_add">+	pitlb           %r0(%sr4,%r28)</span>
 	tlb_unlock      %r20,%r21,%r22
 #endif
 
<span class="p_chunk">@@ -970,10 +975,12 @@</span> <span class="p_context"> ENTRY(flush_icache_page_asm)</span>
 	sync
 
 #ifdef CONFIG_PA20
<span class="p_add">+	pdtlb,l		%r0(%r28)</span>
 	pitlb,l         %r0(%sr4,%r25)
 #else
 	tlb_lock        %r20,%r21,%r22
<span class="p_del">-	pitlb           (%sr4,%r25)</span>
<span class="p_add">+	pdtlb		%r0(%r28)</span>
<span class="p_add">+	pitlb           %r0(%sr4,%r25)</span>
 	tlb_unlock      %r20,%r21,%r22
 #endif
 
<span class="p_header">diff --git a/arch/parisc/kernel/pci-dma.c b/arch/parisc/kernel/pci-dma.c</span>
<span class="p_header">index b9402c9b3454..af0d7fae7aa7 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pci-dma.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/pci-dma.c</span>
<span class="p_chunk">@@ -95,8 +95,8 @@</span> <span class="p_context"> static inline int map_pte_uncached(pte_t * pte,</span>
 
 		if (!pte_none(*pte))
 			printk(KERN_ERR &quot;map_pte_uncached: page already exists\n&quot;);
<span class="p_del">-		set_pte(pte, __mk_pte(*paddr_ptr, PAGE_KERNEL_UNC));</span>
 		purge_tlb_start(flags);
<span class="p_add">+		set_pte(pte, __mk_pte(*paddr_ptr, PAGE_KERNEL_UNC));</span>
 		pdtlb_kernel(orig_vaddr);
 		purge_tlb_end(flags);
 		vaddr += PAGE_SIZE;
<span class="p_header">diff --git a/arch/parisc/kernel/setup.c b/arch/parisc/kernel/setup.c</span>
<span class="p_header">index 81d6f6391944..2e66a887788e 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/setup.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/setup.c</span>
<span class="p_chunk">@@ -334,6 +334,10 @@</span> <span class="p_context"> static int __init parisc_init(void)</span>
 	/* tell PDC we&#39;re Linux. Nevermind failure. */
 	pdc_stable_write(0x40, &amp;osid, sizeof(osid));
 	
<span class="p_add">+	/* start with known state */</span>
<span class="p_add">+	flush_cache_all_local();</span>
<span class="p_add">+	flush_tlb_all_local(NULL);</span>
<span class="p_add">+</span>
 	processor_init();
 #ifdef CONFIG_SMP
 	pr_info(&quot;CPU(s): %d out of %d %s at %d.%06d MHz online\n&quot;,
<span class="p_header">diff --git a/arch/tile/kernel/time.c b/arch/tile/kernel/time.c</span>
<span class="p_header">index 178989e6d3e3..ea960d660917 100644</span>
<span class="p_header">--- a/arch/tile/kernel/time.c</span>
<span class="p_header">+++ b/arch/tile/kernel/time.c</span>
<span class="p_chunk">@@ -218,8 +218,8 @@</span> <span class="p_context"> void do_timer_interrupt(struct pt_regs *regs, int fault_num)</span>
  */
 unsigned long long sched_clock(void)
 {
<span class="p_del">-	return clocksource_cyc2ns(get_cycles(),</span>
<span class="p_del">-				  sched_clock_mult, SCHED_CLOCK_SHIFT);</span>
<span class="p_add">+	return mult_frac(get_cycles(),</span>
<span class="p_add">+			 sched_clock_mult, 1ULL &lt;&lt; SCHED_CLOCK_SHIFT);</span>
 }
 
 int setup_profiling_timer(unsigned int multiplier)
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index 5fa652c16a50..f49e98062ea5 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -2093,16 +2093,10 @@</span> <span class="p_context"> static int em_iret(struct x86_emulate_ctxt *ctxt)</span>
 static int em_jmp_far(struct x86_emulate_ctxt *ctxt)
 {
 	int rc;
<span class="p_del">-	unsigned short sel, old_sel;</span>
<span class="p_del">-	struct desc_struct old_desc, new_desc;</span>
<span class="p_del">-	const struct x86_emulate_ops *ops = ctxt-&gt;ops;</span>
<span class="p_add">+	unsigned short sel;</span>
<span class="p_add">+	struct desc_struct new_desc;</span>
 	u8 cpl = ctxt-&gt;ops-&gt;cpl(ctxt);
 
<span class="p_del">-	/* Assignment of RIP may only fail in 64-bit mode */</span>
<span class="p_del">-	if (ctxt-&gt;mode == X86EMUL_MODE_PROT64)</span>
<span class="p_del">-		ops-&gt;get_segment(ctxt, &amp;old_sel, &amp;old_desc, NULL,</span>
<span class="p_del">-				 VCPU_SREG_CS);</span>
<span class="p_del">-</span>
 	memcpy(&amp;sel, ctxt-&gt;src.valptr + ctxt-&gt;op_bytes, 2);
 
 	rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,
<span class="p_chunk">@@ -2112,12 +2106,10 @@</span> <span class="p_context"> static int em_jmp_far(struct x86_emulate_ctxt *ctxt)</span>
 		return rc;
 
 	rc = assign_eip_far(ctxt, ctxt-&gt;src.val, &amp;new_desc);
<span class="p_del">-	if (rc != X86EMUL_CONTINUE) {</span>
<span class="p_del">-		WARN_ON(ctxt-&gt;mode != X86EMUL_MODE_PROT64);</span>
<span class="p_del">-		/* assigning eip failed; restore the old cs */</span>
<span class="p_del">-		ops-&gt;set_segment(ctxt, old_sel, &amp;old_desc, 0, VCPU_SREG_CS);</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Error handling is not implemented. */</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return X86EMUL_UNHANDLEABLE;</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -2177,14 +2169,8 @@</span> <span class="p_context"> static int em_ret_far(struct x86_emulate_ctxt *ctxt)</span>
 {
 	int rc;
 	unsigned long eip, cs;
<span class="p_del">-	u16 old_cs;</span>
 	int cpl = ctxt-&gt;ops-&gt;cpl(ctxt);
<span class="p_del">-	struct desc_struct old_desc, new_desc;</span>
<span class="p_del">-	const struct x86_emulate_ops *ops = ctxt-&gt;ops;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ctxt-&gt;mode == X86EMUL_MODE_PROT64)</span>
<span class="p_del">-		ops-&gt;get_segment(ctxt, &amp;old_cs, &amp;old_desc, NULL,</span>
<span class="p_del">-				 VCPU_SREG_CS);</span>
<span class="p_add">+	struct desc_struct new_desc;</span>
 
 	rc = emulate_pop(ctxt, &amp;eip, ctxt-&gt;op_bytes);
 	if (rc != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -2201,10 +2187,10 @@</span> <span class="p_context"> static int em_ret_far(struct x86_emulate_ctxt *ctxt)</span>
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
 	rc = assign_eip_far(ctxt, eip, &amp;new_desc);
<span class="p_del">-	if (rc != X86EMUL_CONTINUE) {</span>
<span class="p_del">-		WARN_ON(ctxt-&gt;mode != X86EMUL_MODE_PROT64);</span>
<span class="p_del">-		ops-&gt;set_segment(ctxt, old_cs, &amp;old_desc, 0, VCPU_SREG_CS);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Error handling is not implemented. */</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return X86EMUL_UNHANDLEABLE;</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/irq_comm.c b/arch/x86/kvm/irq_comm.c</span>
<span class="p_header">index 84b96d319909..d09544e826f6 100644</span>
<span class="p_header">--- a/arch/x86/kvm/irq_comm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/irq_comm.c</span>
<span class="p_chunk">@@ -38,6 +38,15 @@</span> <span class="p_context"> static int kvm_set_pic_irq(struct kvm_kernel_irq_routing_entry *e,</span>
 			   bool line_status)
 {
 	struct kvm_pic *pic = pic_irqchip(kvm);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * XXX: rejecting pic routes when pic isn&#39;t in use would be better,</span>
<span class="p_add">+	 * but the default routing table is installed while kvm-&gt;arch.vpic is</span>
<span class="p_add">+	 * NULL and KVM_CREATE_IRQCHIP can race with KVM_IRQ_LINE.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!pic)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	return kvm_pic_set_irq(pic, e-&gt;irqchip.pin, irq_source_id, level);
 }
 
<span class="p_chunk">@@ -46,6 +55,10 @@</span> <span class="p_context"> static int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,</span>
 			      bool line_status)
 {
 	struct kvm_ioapic *ioapic = kvm-&gt;arch.vioapic;
<span class="p_add">+</span>
<span class="p_add">+	if (!ioapic)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	return kvm_ioapic_set_irq(ioapic, e-&gt;irqchip.pin, irq_source_id, level,
 				line_status);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 79bab6fd76bb..6755d4768f59 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -275,6 +275,8 @@</span> <span class="p_context"> void atombios_crtc_dpms(struct drm_crtc *crtc, int mode)</span>
 			atombios_enable_crtc_memreq(crtc, ATOM_ENABLE);
 		atombios_blank_crtc(crtc, ATOM_DISABLE);
 		drm_vblank_post_modeset(dev, radeon_crtc-&gt;crtc_id);
<span class="p_add">+		/* Make sure vblank interrupt is still enabled if needed */</span>
<span class="p_add">+		radeon_irq_set(rdev);</span>
 		radeon_crtc_load_lut(crtc);
 		break;
 	case DRM_MODE_DPMS_STANDBY:
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_legacy_crtc.c b/drivers/gpu/drm/radeon/radeon_legacy_crtc.c</span>
<span class="p_header">index 678b4386540d..89f22bdde298 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_legacy_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_legacy_crtc.c</span>
<span class="p_chunk">@@ -331,6 +331,8 @@</span> <span class="p_context"> static void radeon_crtc_dpms(struct drm_crtc *crtc, int mode)</span>
 			WREG32_P(RADEON_CRTC_EXT_CNTL, crtc_ext_cntl, ~(mask | crtc_ext_cntl));
 		}
 		drm_vblank_post_modeset(dev, radeon_crtc-&gt;crtc_id);
<span class="p_add">+		/* Make sure vblank interrupt is still enabled if needed */</span>
<span class="p_add">+		radeon_irq_set(rdev);</span>
 		radeon_crtc_load_lut(crtc);
 		break;
 	case DRM_MODE_DPMS_STANDBY:
<span class="p_header">diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c</span>
<span class="p_header">index 565bb2c140ed..e913a930ac80 100644</span>
<span class="p_header">--- a/drivers/iommu/dmar.c</span>
<span class="p_header">+++ b/drivers/iommu/dmar.c</span>
<span class="p_chunk">@@ -326,7 +326,9 @@</span> <span class="p_context"> static int dmar_pci_bus_notifier(struct notifier_block *nb,</span>
 	struct pci_dev *pdev = to_pci_dev(data);
 	struct dmar_pci_notify_info *info;
 
<span class="p_del">-	/* Only care about add/remove events for physical functions */</span>
<span class="p_add">+	/* Only care about add/remove events for physical functions.</span>
<span class="p_add">+	 * For VFs we actually do the lookup based on the corresponding</span>
<span class="p_add">+	 * PF in device_to_iommu() anyway. */</span>
 	if (pdev-&gt;is_virtfn)
 		return NOTIFY_DONE;
 	if (action != BUS_NOTIFY_ADD_DEVICE &amp;&amp;
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 5baa830ce49f..59e9abd3345e 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -885,7 +885,13 @@</span> <span class="p_context"> static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devf</span>
 		return NULL;
 
 	if (dev_is_pci(dev)) {
<span class="p_add">+		struct pci_dev *pf_pdev;</span>
<span class="p_add">+</span>
 		pdev = to_pci_dev(dev);
<span class="p_add">+		/* VFs aren&#39;t listed in scope tables; we need to look up</span>
<span class="p_add">+		 * the PF instead to find the IOMMU. */</span>
<span class="p_add">+		pf_pdev = pci_physfn(pdev);</span>
<span class="p_add">+		dev = &amp;pf_pdev-&gt;dev;</span>
 		segment = pci_domain_nr(pdev-&gt;bus);
 	} else if (has_acpi_companion(dev))
 		dev = &amp;ACPI_COMPANION(dev)-&gt;dev;
<span class="p_chunk">@@ -898,6 +904,13 @@</span> <span class="p_context"> static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devf</span>
 		for_each_active_dev_scope(drhd-&gt;devices,
 					  drhd-&gt;devices_cnt, i, tmp) {
 			if (tmp == dev) {
<span class="p_add">+				/* For a VF use its original BDF# not that of the PF</span>
<span class="p_add">+				 * which we used for the IOMMU lookup. Strictly speaking</span>
<span class="p_add">+				 * we could do this for all PCI devices; we only need to</span>
<span class="p_add">+				 * get the BDF# from the scope table for ACPI matches. */</span>
<span class="p_add">+				if (pdev-&gt;is_virtfn)</span>
<span class="p_add">+					goto got_pdev;</span>
<span class="p_add">+</span>
 				*bus = drhd-&gt;devices[i].bus;
 				*devfn = drhd-&gt;devices[i].devfn;
 				goto out;
<span class="p_header">diff --git a/drivers/iommu/intel-svm.c b/drivers/iommu/intel-svm.c</span>
<span class="p_header">index d9939fa9b588..f929879ecae6 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-svm.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-svm.c</span>
<span class="p_chunk">@@ -39,10 +39,18 @@</span> <span class="p_context"> int intel_svm_alloc_pasid_tables(struct intel_iommu *iommu)</span>
 	struct page *pages;
 	int order;
 
<span class="p_del">-	order = ecap_pss(iommu-&gt;ecap) + 7 - PAGE_SHIFT;</span>
<span class="p_del">-	if (order &lt; 0)</span>
<span class="p_del">-		order = 0;</span>
<span class="p_del">-</span>
<span class="p_add">+	/* Start at 2 because it&#39;s defined as 2^(1+PSS) */</span>
<span class="p_add">+	iommu-&gt;pasid_max = 2 &lt;&lt; ecap_pss(iommu-&gt;ecap);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Eventually I&#39;m promised we will get a multi-level PASID table</span>
<span class="p_add">+	 * and it won&#39;t have to be physically contiguous. Until then,</span>
<span class="p_add">+	 * limit the size because 8MiB contiguous allocations can be hard</span>
<span class="p_add">+	 * to come by. The limit of 0x20000, which is 1MiB for each of</span>
<span class="p_add">+	 * the PASID and PASID-state tables, is somewhat arbitrary. */</span>
<span class="p_add">+	if (iommu-&gt;pasid_max &gt; 0x20000)</span>
<span class="p_add">+		iommu-&gt;pasid_max = 0x20000;</span>
<span class="p_add">+</span>
<span class="p_add">+	order = get_order(sizeof(struct pasid_entry) * iommu-&gt;pasid_max);</span>
 	pages = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
 	if (!pages) {
 		pr_warn(&quot;IOMMU: %s: Failed to allocate PASID table\n&quot;,
<span class="p_chunk">@@ -53,6 +61,8 @@</span> <span class="p_context"> int intel_svm_alloc_pasid_tables(struct intel_iommu *iommu)</span>
 	pr_info(&quot;%s: Allocated order %d PASID table.\n&quot;, iommu-&gt;name, order);
 
 	if (ecap_dis(iommu-&gt;ecap)) {
<span class="p_add">+		/* Just making it explicit... */</span>
<span class="p_add">+		BUILD_BUG_ON(sizeof(struct pasid_entry) != sizeof(struct pasid_state_entry));</span>
 		pages = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
 		if (pages)
 			iommu-&gt;pasid_state_table = page_address(pages);
<span class="p_chunk">@@ -68,11 +78,7 @@</span> <span class="p_context"> int intel_svm_alloc_pasid_tables(struct intel_iommu *iommu)</span>
 
 int intel_svm_free_pasid_tables(struct intel_iommu *iommu)
 {
<span class="p_del">-	int order;</span>
<span class="p_del">-</span>
<span class="p_del">-	order = ecap_pss(iommu-&gt;ecap) + 7 - PAGE_SHIFT;</span>
<span class="p_del">-	if (order &lt; 0)</span>
<span class="p_del">-		order = 0;</span>
<span class="p_add">+	int order = get_order(sizeof(struct pasid_entry) * iommu-&gt;pasid_max);</span>
 
 	if (iommu-&gt;pasid_table) {
 		free_pages((unsigned long)iommu-&gt;pasid_table, order);
<span class="p_chunk">@@ -371,8 +377,8 @@</span> <span class="p_context"> int intel_svm_bind_mm(struct device *dev, int *pasid, int flags, struct svm_dev_</span>
 		}
 		svm-&gt;iommu = iommu;
 
<span class="p_del">-		if (pasid_max &gt; 2 &lt;&lt; ecap_pss(iommu-&gt;ecap))</span>
<span class="p_del">-			pasid_max = 2 &lt;&lt; ecap_pss(iommu-&gt;ecap);</span>
<span class="p_add">+		if (pasid_max &gt; iommu-&gt;pasid_max)</span>
<span class="p_add">+			pasid_max = iommu-&gt;pasid_max;</span>
 
 		/* Do not use PASID 0 in caching mode (virtualised IOMMU) */
 		ret = idr_alloc(&amp;iommu-&gt;pasid_idr, svm,
<span class="p_header">diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c</span>
<span class="p_header">index a77643954523..e59838231703 100644</span>
<span class="p_header">--- a/drivers/misc/mei/bus.c</span>
<span class="p_header">+++ b/drivers/misc/mei/bus.c</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)</span>
 		mutex_lock(&amp;bus-&gt;device_lock);
 
 		if (!mei_cl_is_connected(cl)) {
<span class="p_del">-			rets = -EBUSY;</span>
<span class="p_add">+			rets = -ENODEV;</span>
 			goto out;
 		}
 	}
<span class="p_header">diff --git a/drivers/misc/mei/hw-me-regs.h b/drivers/misc/mei/hw-me-regs.h</span>
<span class="p_header">index 4e8069866c85..a2661381ddfc 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hw-me-regs.h</span>
<span class="p_header">+++ b/drivers/misc/mei/hw-me-regs.h</span>
<span class="p_chunk">@@ -66,9 +66,6 @@</span> <span class="p_context"></span>
 #ifndef _MEI_HW_MEI_REGS_H_
 #define _MEI_HW_MEI_REGS_H_
 
<span class="p_del">-#define MEI_DEV_ID_KBP        0xA2BA  /* Kaby Point */</span>
<span class="p_del">-#define MEI_DEV_ID_KBP_2      0xA2BB  /* Kaby Point 2 */</span>
<span class="p_del">-</span>
 /*
  * MEI device IDs
  */
<span class="p_chunk">@@ -124,6 +121,10 @@</span> <span class="p_context"></span>
 #define MEI_DEV_ID_SPT_2      0x9D3B  /* Sunrise Point 2 */
 #define MEI_DEV_ID_SPT_H      0xA13A  /* Sunrise Point H */
 #define MEI_DEV_ID_SPT_H_2    0xA13B  /* Sunrise Point H 2 */
<span class="p_add">+</span>
<span class="p_add">+#define MEI_DEV_ID_KBP        0xA2BA  /* Kaby Point */</span>
<span class="p_add">+#define MEI_DEV_ID_KBP_2      0xA2BB  /* Kaby Point 2 */</span>
<span class="p_add">+</span>
 /*
  * MEI HW Section
  */
<span class="p_header">diff --git a/drivers/misc/mei/hw-me.c b/drivers/misc/mei/hw-me.c</span>
<span class="p_header">index 25b1997a62cb..36333750c512 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hw-me.c</span>
<span class="p_header">+++ b/drivers/misc/mei/hw-me.c</span>
<span class="p_chunk">@@ -1258,8 +1258,14 @@</span> <span class="p_context"> static bool mei_me_fw_type_nm(struct pci_dev *pdev)</span>
 static bool mei_me_fw_type_sps(struct pci_dev *pdev)
 {
 	u32 reg;
<span class="p_del">-	/* Read ME FW Status check for SPS Firmware */</span>
<span class="p_del">-	pci_read_config_dword(pdev, PCI_CFG_HFS_1, &amp;reg);</span>
<span class="p_add">+	unsigned int devfn;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Read ME FW Status register to check for SPS Firmware</span>
<span class="p_add">+	 * The SPS FW is only signaled in pci function 0</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	devfn = PCI_DEVFN(PCI_SLOT(pdev-&gt;devfn), 0);</span>
<span class="p_add">+	pci_bus_read_config_dword(pdev-&gt;bus, devfn, PCI_CFG_HFS_1, &amp;reg);</span>
 	/* if bits [19:16] = 15, running SPS Firmware */
 	return (reg &amp; 0xf0000) == 0xf0000;
 }
<span class="p_header">diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c</span>
<span class="p_header">index 80f9afcb1382..4ef189a7a2fb 100644</span>
<span class="p_header">--- a/drivers/misc/mei/main.c</span>
<span class="p_header">+++ b/drivers/misc/mei/main.c</span>
<span class="p_chunk">@@ -207,7 +207,7 @@</span> <span class="p_context"> static ssize_t mei_read(struct file *file, char __user *ubuf,</span>
 
 		mutex_lock(&amp;dev-&gt;device_lock);
 		if (!mei_cl_is_connected(cl)) {
<span class="p_del">-			rets = -EBUSY;</span>
<span class="p_add">+			rets = -ENODEV;</span>
 			goto out;
 		}
 	}
<span class="p_header">diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c</span>
<span class="p_header">index 0af3d7d30419..01e20384ac44 100644</span>
<span class="p_header">--- a/drivers/misc/mei/pci-me.c</span>
<span class="p_header">+++ b/drivers/misc/mei/pci-me.c</span>
<span class="p_chunk">@@ -84,8 +84,8 @@</span> <span class="p_context"> static const struct pci_device_id mei_me_pci_tbl[] = {</span>
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT, mei_me_pch8_cfg)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_2, mei_me_pch8_cfg)},
<span class="p_del">-	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H, mei_me_pch8_cfg)},</span>
<span class="p_del">-	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H_2, mei_me_pch8_cfg)},</span>
<span class="p_add">+	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H, mei_me_pch8_sps_cfg)},</span>
<span class="p_add">+	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H_2, mei_me_pch8_sps_cfg)},</span>
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_KBP, mei_me_pch8_cfg)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_KBP_2, mei_me_pch8_cfg)},
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index 2d867c5bfd9f..8cead04f26d6 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -3706,6 +3706,11 @@</span> <span class="p_context"> _scsih_temp_threshold_events(struct MPT3SAS_ADAPTER *ioc,</span>
 	}
 }
 
<span class="p_add">+static inline bool ata_12_16_cmd(struct scsi_cmnd *scmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (scmd-&gt;cmnd[0] == ATA_12 || scmd-&gt;cmnd[0] == ATA_16);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * _scsih_flush_running_cmds - completing outstanding commands.
  * @ioc: per adapter object
<span class="p_chunk">@@ -3727,6 +3732,9 @@</span> <span class="p_context"> _scsih_flush_running_cmds(struct MPT3SAS_ADAPTER *ioc)</span>
 		if (!scmd)
 			continue;
 		count++;
<span class="p_add">+		if (ata_12_16_cmd(scmd))</span>
<span class="p_add">+			scsi_internal_device_unblock(scmd-&gt;device,</span>
<span class="p_add">+							SDEV_RUNNING);</span>
 		mpt3sas_base_free_smid(ioc, smid);
 		scsi_dma_unmap(scmd);
 		if (ioc-&gt;pci_error_recovery)
<span class="p_chunk">@@ -3831,8 +3839,6 @@</span> <span class="p_context"> _scsih_eedp_error_handling(struct scsi_cmnd *scmd, u16 ioc_status)</span>
 	    SAM_STAT_CHECK_CONDITION;
 }
 
<span class="p_del">-</span>
<span class="p_del">-</span>
 /**
  * scsih_qcmd - main scsi request entry point
  * @scmd: pointer to scsi command object
<span class="p_chunk">@@ -3859,6 +3865,13 @@</span> <span class="p_context"> scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)</span>
 	if (ioc-&gt;logging_level &amp; MPT_DEBUG_SCSI)
 		scsi_print_command(scmd);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Lock the device for any subsequent command until command is</span>
<span class="p_add">+	 * done.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ata_12_16_cmd(scmd))</span>
<span class="p_add">+		scsi_internal_device_block(scmd-&gt;device);</span>
<span class="p_add">+</span>
 	sas_device_priv_data = scmd-&gt;device-&gt;hostdata;
 	if (!sas_device_priv_data || !sas_device_priv_data-&gt;sas_target) {
 		scmd-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
<span class="p_chunk">@@ -4431,6 +4444,9 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 	if (scmd == NULL)
 		return 1;
 
<span class="p_add">+	if (ata_12_16_cmd(scmd))</span>
<span class="p_add">+		scsi_internal_device_unblock(scmd-&gt;device, SDEV_RUNNING);</span>
<span class="p_add">+</span>
 	mpi_request = mpt3sas_base_get_msg_frame(ioc, smid);
 
 	if (mpi_reply == NULL) {
<span class="p_header">diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c</span>
<span class="p_header">index 965d0e240dcb..ba4a2a1eb3ff 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/core.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/core.c</span>
<span class="p_chunk">@@ -926,6 +926,7 @@</span> <span class="p_context"> static int ci_hdrc_probe(struct platform_device *pdev)</span>
 	if (!ci)
 		return -ENOMEM;
 
<span class="p_add">+	spin_lock_init(&amp;ci-&gt;lock);</span>
 	ci-&gt;dev = dev;
 	ci-&gt;platdata = dev_get_platdata(dev);
 	ci-&gt;imx28_write_fix = !!(ci-&gt;platdata-&gt;flags &amp;
<span class="p_header">diff --git a/drivers/usb/chipidea/udc.c b/drivers/usb/chipidea/udc.c</span>
<span class="p_header">index 68fc5fce4cc5..d8a045fc1fdb 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/udc.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/udc.c</span>
<span class="p_chunk">@@ -1884,8 +1884,6 @@</span> <span class="p_context"> static int udc_start(struct ci_hdrc *ci)</span>
 	struct usb_otg_caps *otg_caps = &amp;ci-&gt;platdata-&gt;ci_otg_caps;
 	int retval = 0;
 
<span class="p_del">-	spin_lock_init(&amp;ci-&gt;lock);</span>
<span class="p_del">-</span>
 	ci-&gt;gadget.ops          = &amp;usb_gadget_ops;
 	ci-&gt;gadget.speed        = USB_SPEED_UNKNOWN;
 	ci-&gt;gadget.max_speed    = USB_SPEED_HIGH;
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 976195e748a3..fe7452f0f38a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -130,6 +130,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x88A4) }, /* MMB Networks ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x88A5) }, /* Planet Innovation Ingeni ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8962) }, /* Brim Brothers charging dock */</span>
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
 	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */
 	{ USB_DEVICE(0x10C4, 0x8A2A) }, /* HubZ dual ZigBee and Z-Wave dongle */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 494167fe6a2c..d3d6ec455151 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -1012,6 +1012,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7561U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7563U_PID) },
 	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },
<span class="p_add">+	{ USB_DEVICE(TI_VID, TI_CC3200_LAUNCHPAD_PID),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 21011c0a4c64..48ee04c94a75 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -596,6 +596,12 @@</span> <span class="p_context"></span>
 #define STK541_PID		0x2109 /* Zigbee Controller */
 
 /*
<span class="p_add">+ * Texas Instruments</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define TI_VID			0x0451</span>
<span class="p_add">+#define TI_CC3200_LAUNCHPAD_PID	0xC32A /* SimpleLink Wi-Fi CC3200 LaunchPad */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Blackfin gnICE JTAG
  * http://docs.blackfin.uclinux.org/doku.php?id=hw:jtag:gnice
  */
<span class="p_header">diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c</span>
<span class="p_header">index 5e67f63b2e46..02f86dd1a340 100644</span>
<span class="p_header">--- a/drivers/usb/storage/transport.c</span>
<span class="p_header">+++ b/drivers/usb/storage/transport.c</span>
<span class="p_chunk">@@ -919,10 +919,15 @@</span> <span class="p_context"> int usb_stor_CB_transport(struct scsi_cmnd *srb, struct us_data *us)</span>
 
 	/* COMMAND STAGE */
 	/* let&#39;s send the command via the control pipe */
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Command is sometime (f.e. after scsi_eh_prep_cmnd) on the stack.</span>
<span class="p_add">+	 * Stack may be vmallocated.  So no DMA for us.  Make a copy.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memcpy(us-&gt;iobuf, srb-&gt;cmnd, srb-&gt;cmd_len);</span>
 	result = usb_stor_ctrl_transfer(us, us-&gt;send_ctrl_pipe,
 				      US_CBI_ADSC, 
 				      USB_TYPE_CLASS | USB_RECIP_INTERFACE, 0, 
<span class="p_del">-				      us-&gt;ifnum, srb-&gt;cmnd, srb-&gt;cmd_len);</span>
<span class="p_add">+				      us-&gt;ifnum, us-&gt;iobuf, srb-&gt;cmd_len);</span>
 
 	/* check the return code for the command */
 	usb_stor_dbg(us, &quot;Call to usb_stor_ctrl_transfer() returned %d\n&quot;,
<span class="p_header">diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c</span>
<span class="p_header">index 52a28311e2a4..48efe62e1302 100644</span>
<span class="p_header">--- a/fs/nfs/callback.c</span>
<span class="p_header">+++ b/fs/nfs/callback.c</span>
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> static int nfs_callback_up_net(int minorversion, struct svc_serv *serv,</span>
 	}
 
 	ret = -EPROTONOSUPPORT;
<span class="p_del">-	if (minorversion == 0)</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_NFS_V4_1) || minorversion == 0)</span>
 		ret = nfs4_callback_up_net(serv, net);
 	else if (xprt-&gt;ops-&gt;bc_up)
 		ret = xprt-&gt;ops-&gt;bc_up(serv, net);
<span class="p_header">diff --git a/include/linux/intel-iommu.h b/include/linux/intel-iommu.h</span>
<span class="p_header">index 2d9b650047a5..d49e26c6cdc7 100644</span>
<span class="p_header">--- a/include/linux/intel-iommu.h</span>
<span class="p_header">+++ b/include/linux/intel-iommu.h</span>
<span class="p_chunk">@@ -429,6 +429,7 @@</span> <span class="p_context"> struct intel_iommu {</span>
 	struct page_req_dsc *prq;
 	unsigned char prq_name[16];    /* Name for PRQ interrupt */
 	struct idr pasid_idr;
<span class="p_add">+	u32 pasid_max;</span>
 #endif
 	struct q_inval  *qi;            /* Queued invalidation info */
 	u32 *iommu_state; /* Store iommu states between suspend and resume.*/
<span class="p_header">diff --git a/lib/mpi/mpi-pow.c b/lib/mpi/mpi-pow.c</span>
<span class="p_header">index 5464c8744ea9..e24388a863a7 100644</span>
<span class="p_header">--- a/lib/mpi/mpi-pow.c</span>
<span class="p_header">+++ b/lib/mpi/mpi-pow.c</span>
<span class="p_chunk">@@ -64,8 +64,13 @@</span> <span class="p_context"> int mpi_powm(MPI res, MPI base, MPI exp, MPI mod)</span>
 	if (!esize) {
 		/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0
 		 * depending on if MOD equals 1.  */
<span class="p_del">-		rp[0] = 1;</span>
 		res-&gt;nlimbs = (msize == 1 &amp;&amp; mod-&gt;d[0] == 1) ? 0 : 1;
<span class="p_add">+		if (res-&gt;nlimbs) {</span>
<span class="p_add">+			if (mpi_resize(res, 1) &lt; 0)</span>
<span class="p_add">+				goto enomem;</span>
<span class="p_add">+			rp = res-&gt;d;</span>
<span class="p_add">+			rp[0] = 1;</span>
<span class="p_add">+		}</span>
 		res-&gt;sign = 0;
 		goto leave;
 	}
<span class="p_header">diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c</span>
<span class="p_header">index 9aba9e93c0a2..ee9082792530 100644</span>
<span class="p_header">--- a/net/core/flow_dissector.c</span>
<span class="p_header">+++ b/net/core/flow_dissector.c</span>
<span class="p_chunk">@@ -949,4 +949,4 @@</span> <span class="p_context"> static int __init init_default_flow_dissectors(void)</span>
 	return 0;
 }
 
<span class="p_del">-late_initcall_sync(init_default_flow_dissectors);</span>
<span class="p_add">+core_initcall(init_default_flow_dissectors);</span>
<span class="p_header">diff --git a/net/wireless/core.h b/net/wireless/core.h</span>
<span class="p_header">index a618b4b86fa4..47a967fed8ff 100644</span>
<span class="p_header">--- a/net/wireless/core.h</span>
<span class="p_header">+++ b/net/wireless/core.h</span>
<span class="p_chunk">@@ -72,6 +72,7 @@</span> <span class="p_context"> struct cfg80211_registered_device {</span>
 	struct list_head bss_list;
 	struct rb_root bss_tree;
 	u32 bss_generation;
<span class="p_add">+	u32 bss_entries;</span>
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	struct sk_buff *scan_msg;
 	struct cfg80211_sched_scan_request __rcu *sched_scan_req;
<span class="p_header">diff --git a/net/wireless/scan.c b/net/wireless/scan.c</span>
<span class="p_header">index 14d5369eb778..8dde12a11725 100644</span>
<span class="p_header">--- a/net/wireless/scan.c</span>
<span class="p_header">+++ b/net/wireless/scan.c</span>
<span class="p_chunk">@@ -56,6 +56,19 @@</span> <span class="p_context"></span>
  * also linked into the probe response struct.
  */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Limit the number of BSS entries stored in mac80211. Each one is</span>
<span class="p_add">+ * a bit over 4k at most, so this limits to roughly 4-5M of memory.</span>
<span class="p_add">+ * If somebody wants to really attack this though, they&#39;d likely</span>
<span class="p_add">+ * use small beacons, and only one type of frame, limiting each of</span>
<span class="p_add">+ * the entries to a much smaller size (in order to generate more</span>
<span class="p_add">+ * entries in total, so overhead is bigger.)</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int bss_entries_limit = 1000;</span>
<span class="p_add">+module_param(bss_entries_limit, int, 0644);</span>
<span class="p_add">+MODULE_PARM_DESC(bss_entries_limit,</span>
<span class="p_add">+                 &quot;limit to number of scan BSS entries (per wiphy, default 1000)&quot;);</span>
<span class="p_add">+</span>
 #define IEEE80211_SCAN_RESULT_EXPIRE	(30 * HZ)
 
 static void bss_free(struct cfg80211_internal_bss *bss)
<span class="p_chunk">@@ -136,6 +149,10 @@</span> <span class="p_context"> static bool __cfg80211_unlink_bss(struct cfg80211_registered_device *rdev,</span>
 
 	list_del_init(&amp;bss-&gt;list);
 	rb_erase(&amp;bss-&gt;rbn, &amp;rdev-&gt;bss_tree);
<span class="p_add">+	rdev-&gt;bss_entries--;</span>
<span class="p_add">+	WARN_ONCE((rdev-&gt;bss_entries == 0) ^ list_empty(&amp;rdev-&gt;bss_list),</span>
<span class="p_add">+		  &quot;rdev bss entries[%d]/list[empty:%d] corruption\n&quot;,</span>
<span class="p_add">+		  rdev-&gt;bss_entries, list_empty(&amp;rdev-&gt;bss_list));</span>
 	bss_ref_put(rdev, bss);
 	return true;
 }
<span class="p_chunk">@@ -162,6 +179,40 @@</span> <span class="p_context"> static void __cfg80211_bss_expire(struct cfg80211_registered_device *rdev,</span>
 		rdev-&gt;bss_generation++;
 }
 
<span class="p_add">+static bool cfg80211_bss_expire_oldest(struct cfg80211_registered_device *rdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cfg80211_internal_bss *bss, *oldest = NULL;</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	lockdep_assert_held(&amp;rdev-&gt;bss_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(bss, &amp;rdev-&gt;bss_list, list) {</span>
<span class="p_add">+		if (atomic_read(&amp;bss-&gt;hold))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!list_empty(&amp;bss-&gt;hidden_list) &amp;&amp;</span>
<span class="p_add">+		    !bss-&gt;pub.hidden_beacon_bss)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (oldest &amp;&amp; time_before(oldest-&gt;ts, bss-&gt;ts))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		oldest = bss;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (WARN_ON(!oldest))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The callers make sure to increase rdev-&gt;bss_generation if anything</span>
<span class="p_add">+	 * gets removed (and a new entry added), so there&#39;s no need to also do</span>
<span class="p_add">+	 * it here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = __cfg80211_unlink_bss(rdev, oldest);</span>
<span class="p_add">+	WARN_ON(!ret);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
 			   bool send_message)
 {
<span class="p_chunk">@@ -687,6 +738,7 @@</span> <span class="p_context"> static bool cfg80211_combine_bsses(struct cfg80211_registered_device *rdev,</span>
 	const u8 *ie;
 	int i, ssidlen;
 	u8 fold = 0;
<span class="p_add">+	u32 n_entries = 0;</span>
 
 	ies = rcu_access_pointer(new-&gt;pub.beacon_ies);
 	if (WARN_ON(!ies))
<span class="p_chunk">@@ -710,6 +762,12 @@</span> <span class="p_context"> static bool cfg80211_combine_bsses(struct cfg80211_registered_device *rdev,</span>
 	/* This is the bad part ... */
 
 	list_for_each_entry(bss, &amp;rdev-&gt;bss_list, list) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * we&#39;re iterating all the entries anyway, so take the</span>
<span class="p_add">+		 * opportunity to validate the list length accounting</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		n_entries++;</span>
<span class="p_add">+</span>
 		if (!ether_addr_equal(bss-&gt;pub.bssid, new-&gt;pub.bssid))
 			continue;
 		if (bss-&gt;pub.channel != new-&gt;pub.channel)
<span class="p_chunk">@@ -738,6 +796,10 @@</span> <span class="p_context"> static bool cfg80211_combine_bsses(struct cfg80211_registered_device *rdev,</span>
 				   new-&gt;pub.beacon_ies);
 	}
 
<span class="p_add">+	WARN_ONCE(n_entries != rdev-&gt;bss_entries,</span>
<span class="p_add">+		  &quot;rdev bss entries[%d]/list[len:%d] corruption\n&quot;,</span>
<span class="p_add">+		  rdev-&gt;bss_entries, n_entries);</span>
<span class="p_add">+</span>
 	return true;
 }
 
<span class="p_chunk">@@ -890,7 +952,14 @@</span> <span class="p_context"> cfg80211_bss_update(struct cfg80211_registered_device *rdev,</span>
 			}
 		}
 
<span class="p_add">+		if (rdev-&gt;bss_entries &gt;= bss_entries_limit &amp;&amp;</span>
<span class="p_add">+		    !cfg80211_bss_expire_oldest(rdev)) {</span>
<span class="p_add">+			kfree(new);</span>
<span class="p_add">+			goto drop;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		list_add_tail(&amp;new-&gt;list, &amp;rdev-&gt;bss_list);
<span class="p_add">+		rdev-&gt;bss_entries++;</span>
 		rb_insert_bss(rdev, new);
 		found = new;
 	}
<span class="p_header">diff --git a/security/apparmor/domain.c b/security/apparmor/domain.c</span>
<span class="p_header">index dc0027b28b04..53426a6ee6dc 100644</span>
<span class="p_header">--- a/security/apparmor/domain.c</span>
<span class="p_header">+++ b/security/apparmor/domain.c</span>
<span class="p_chunk">@@ -623,8 +623,8 @@</span> <span class="p_context"> int aa_change_hat(const char *hats[], int count, u64 token, bool permtest)</span>
 	/* released below */
 	cred = get_current_cred();
 	cxt = cred_cxt(cred);
<span class="p_del">-	profile = aa_cred_profile(cred);</span>
<span class="p_del">-	previous_profile = cxt-&gt;previous;</span>
<span class="p_add">+	profile = aa_get_newest_profile(aa_cred_profile(cred));</span>
<span class="p_add">+	previous_profile = aa_get_newest_profile(cxt-&gt;previous);</span>
 
 	if (unconfined(profile)) {
 		info = &quot;unconfined&quot;;
<span class="p_chunk">@@ -720,6 +720,8 @@</span> <span class="p_context"> audit:</span>
 out:
 	aa_put_profile(hat);
 	kfree(name);
<span class="p_add">+	aa_put_profile(profile);</span>
<span class="p_add">+	aa_put_profile(previous_profile);</span>
 	put_cred(cred);
 
 	return error;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



