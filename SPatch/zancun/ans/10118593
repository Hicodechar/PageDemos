
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.106 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.106</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 18, 2017, 9:36 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171218093618.GB3829@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10118593/mbox/"
   >mbox</a>
|
   <a href="/patch/10118593/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10118593/">/patch/10118593/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	C91F8603FA for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 18 Dec 2017 09:36:36 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A051E28CAA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 18 Dec 2017 09:36:36 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 944C128DEB; Mon, 18 Dec 2017 09:36:36 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3DE7E28CAA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 18 Dec 2017 09:36:31 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933185AbdLRJg0 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 18 Dec 2017 04:36:26 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:53686 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1758449AbdLRJgQ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 18 Dec 2017 04:36:16 -0500
Received: from localhost (LFbn-1-12262-44.w90-92.abo.wanadoo.fr
	[90.92.75.44])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 34404904;
	Mon, 18 Dec 2017 09:36:15 +0000 (UTC)
Date: Mon, 18 Dec 2017 10:36:18 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.106
Message-ID: &lt;20171218093618.GB3829@kroah.com&gt;
References: &lt;20171218093614.GA3829@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171218093614.GA3829@kroah.com&gt;
User-Agent: Mutt/1.9.2 (2017-12-15)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 18, 2017, 9:36 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 69f4ace70276..8225da6b520f 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 105</span>
<span class="p_add">+SUBLEVEL = 106</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/include/asm/assembler.h b/arch/arm/include/asm/assembler.h</span>
<span class="p_header">index b2bc8e11471d..2c16d9e7c03c 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/assembler.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/assembler.h</span>
<span class="p_chunk">@@ -512,4 +512,22 @@</span> <span class="p_context"> THUMB(	orr	\reg , \reg , #PSR_T_BIT	)</span>
 #endif
 	.endm
 
<span class="p_add">+	.macro	bug, msg, line</span>
<span class="p_add">+#ifdef CONFIG_THUMB2_KERNEL</span>
<span class="p_add">+1:	.inst	0xde02</span>
<span class="p_add">+#else</span>
<span class="p_add">+1:	.inst	0xe7f001f2</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_DEBUG_BUGVERBOSE</span>
<span class="p_add">+	.pushsection .rodata.str, &quot;aMS&quot;, %progbits, 1</span>
<span class="p_add">+2:	.asciz	&quot;\msg&quot;</span>
<span class="p_add">+	.popsection</span>
<span class="p_add">+	.pushsection __bug_table, &quot;aw&quot;</span>
<span class="p_add">+	.align	2</span>
<span class="p_add">+	.word	1b, 2b</span>
<span class="p_add">+	.hword	\line</span>
<span class="p_add">+	.popsection</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
 #endif /* __ASM_ASSEMBLER_H__ */
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_arm.h b/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_header">index dc641ddf0784..14602e883509 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_chunk">@@ -161,8 +161,7 @@</span> <span class="p_context"></span>
 #else
 #define VTTBR_X		(5 - KVM_T0SZ)
 #endif
<span class="p_del">-#define VTTBR_BADDR_SHIFT (VTTBR_X - 1)</span>
<span class="p_del">-#define VTTBR_BADDR_MASK  (((1LLU &lt;&lt; (40 - VTTBR_X)) - 1) &lt;&lt; VTTBR_BADDR_SHIFT)</span>
<span class="p_add">+#define VTTBR_BADDR_MASK  (((1LLU &lt;&lt; (40 - VTTBR_X)) - 1) &lt;&lt; VTTBR_X)</span>
 #define VTTBR_VMID_SHIFT  (48LLU)
 #define VTTBR_VMID_MASK	  (0xffLLU &lt;&lt; VTTBR_VMID_SHIFT)
 
<span class="p_chunk">@@ -209,6 +208,7 @@</span> <span class="p_context"></span>
 #define HSR_EC_IABT_HYP	(0x21)
 #define HSR_EC_DABT	(0x24)
 #define HSR_EC_DABT_HYP	(0x25)
<span class="p_add">+#define HSR_EC_MAX	(0x3f)</span>
 
 #define HSR_WFI_IS_WFE		(1U &lt;&lt; 0)
 
<span class="p_header">diff --git a/arch/arm/kernel/entry-header.S b/arch/arm/kernel/entry-header.S</span>
<span class="p_header">index 0d22ad206d52..6d243e830516 100644</span>
<span class="p_header">--- a/arch/arm/kernel/entry-header.S</span>
<span class="p_header">+++ b/arch/arm/kernel/entry-header.S</span>
<span class="p_chunk">@@ -295,6 +295,8 @@</span> <span class="p_context"></span>
 	mov	r2, sp
 	ldr	r1, [r2, #\offset + S_PSR]	@ get calling cpsr
 	ldr	lr, [r2, #\offset + S_PC]!	@ get pc
<span class="p_add">+	tst	r1, #PSR_I_BIT | 0x0f</span>
<span class="p_add">+	bne	1f</span>
 	msr	spsr_cxsf, r1			@ save in spsr_svc
 #if defined(CONFIG_CPU_V6) || defined(CONFIG_CPU_32v6K)
 	@ We must avoid clrex due to Cortex-A15 erratum #830321
<span class="p_chunk">@@ -309,6 +311,7 @@</span> <span class="p_context"></span>
 						@ after ldm {}^
 	add	sp, sp, #\offset + S_FRAME_SIZE
 	movs	pc, lr				@ return &amp; move spsr_svc into cpsr
<span class="p_add">+1:	bug	&quot;Returning to usermode but unexpected PSR bits set?&quot;, \@</span>
 #elif defined(CONFIG_CPU_V7M)
 	@ V7M restore.
 	@ Note that we don&#39;t need to do clrex here as clearing the local
<span class="p_chunk">@@ -324,6 +327,8 @@</span> <span class="p_context"></span>
 	ldr	r1, [sp, #\offset + S_PSR]	@ get calling cpsr
 	ldr	lr, [sp, #\offset + S_PC]	@ get pc
 	add	sp, sp, #\offset + S_SP
<span class="p_add">+	tst	r1, #PSR_I_BIT | 0x0f</span>
<span class="p_add">+	bne	1f</span>
 	msr	spsr_cxsf, r1			@ save in spsr_svc
 
 	@ We must avoid clrex due to Cortex-A15 erratum #830321
<span class="p_chunk">@@ -336,6 +341,7 @@</span> <span class="p_context"></span>
 	.endif
 	add	sp, sp, #S_FRAME_SIZE - S_SP
 	movs	pc, lr				@ return &amp; move spsr_svc into cpsr
<span class="p_add">+1:	bug	&quot;Returning to usermode but unexpected PSR bits set?&quot;, \@</span>
 #endif	/* !CONFIG_THUMB2_KERNEL */
 	.endm
 
<span class="p_header">diff --git a/arch/arm/kvm/handle_exit.c b/arch/arm/kvm/handle_exit.c</span>
<span class="p_header">index 95f12b2ccdcb..f36b5b1acd1f 100644</span>
<span class="p_header">--- a/arch/arm/kvm/handle_exit.c</span>
<span class="p_header">+++ b/arch/arm/kvm/handle_exit.c</span>
<span class="p_chunk">@@ -100,7 +100,19 @@</span> <span class="p_context"> static int kvm_handle_wfx(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	return 1;
 }
 
<span class="p_add">+static int kvm_handle_unknown_ec(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 hsr = kvm_vcpu_get_hsr(vcpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_pr_unimpl(&quot;Unknown exception class: hsr: %#08x\n&quot;,</span>
<span class="p_add">+		      hsr);</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_inject_undefined(vcpu);</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static exit_handle_fn arm_exit_handlers[] = {
<span class="p_add">+	[0 ... HSR_EC_MAX]	= kvm_handle_unknown_ec,</span>
 	[HSR_EC_WFI]		= kvm_handle_wfx,
 	[HSR_EC_CP15_32]	= kvm_handle_cp15_32,
 	[HSR_EC_CP15_64]	= kvm_handle_cp15_64,
<span class="p_chunk">@@ -122,13 +134,6 @@</span> <span class="p_context"> static exit_handle_fn kvm_get_exit_handler(struct kvm_vcpu *vcpu)</span>
 {
 	u8 hsr_ec = kvm_vcpu_trap_get_class(vcpu);
 
<span class="p_del">-	if (hsr_ec &gt;= ARRAY_SIZE(arm_exit_handlers) ||</span>
<span class="p_del">-	    !arm_exit_handlers[hsr_ec]) {</span>
<span class="p_del">-		kvm_err(&quot;Unknown exception class: hsr: %#08x\n&quot;,</span>
<span class="p_del">-			(unsigned int)kvm_vcpu_get_hsr(vcpu));</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return arm_exit_handlers[hsr_ec];
 }
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/gpmc-onenand.c b/arch/arm/mach-omap2/gpmc-onenand.c</span>
<span class="p_header">index 8633c703546a..2944af820558 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/gpmc-onenand.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/gpmc-onenand.c</span>
<span class="p_chunk">@@ -367,7 +367,7 @@</span> <span class="p_context"> static int gpmc_onenand_setup(void __iomem *onenand_base, int *freq_ptr)</span>
 	return ret;
 }
 
<span class="p_del">-void gpmc_onenand_init(struct omap_onenand_platform_data *_onenand_data)</span>
<span class="p_add">+int gpmc_onenand_init(struct omap_onenand_platform_data *_onenand_data)</span>
 {
 	int err;
 	struct device *dev = &amp;gpmc_onenand_device.dev;
<span class="p_chunk">@@ -393,15 +393,17 @@</span> <span class="p_context"> void gpmc_onenand_init(struct omap_onenand_platform_data *_onenand_data)</span>
 	if (err &lt; 0) {
 		dev_err(dev, &quot;Cannot request GPMC CS %d, error %d\n&quot;,
 			gpmc_onenand_data-&gt;cs, err);
<span class="p_del">-		return;</span>
<span class="p_add">+		return err;</span>
 	}
 
 	gpmc_onenand_resource.end = gpmc_onenand_resource.start +
 							ONENAND_IO_SIZE - 1;
 
<span class="p_del">-	if (platform_device_register(&amp;gpmc_onenand_device) &lt; 0) {</span>
<span class="p_add">+	err = platform_device_register(&amp;gpmc_onenand_device);</span>
<span class="p_add">+	if (err) {</span>
 		dev_err(dev, &quot;Unable to register OneNAND device\n&quot;);
 		gpmc_cs_free(gpmc_onenand_data-&gt;cs);
<span class="p_del">-		return;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c b/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_header">index 131f8967589b..13e22a4a5a20 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_chunk">@@ -3885,16 +3885,20 @@</span> <span class="p_context"> static struct omap_hwmod_ocp_if *omap3xxx_dss_hwmod_ocp_ifs[] __initdata = {</span>
  * Return: 0 if device named @dev_name is not likely to be accessible,
  * or 1 if it is likely to be accessible.
  */
<span class="p_del">-static int __init omap3xxx_hwmod_is_hs_ip_block_usable(struct device_node *bus,</span>
<span class="p_del">-						       const char *dev_name)</span>
<span class="p_add">+static bool __init omap3xxx_hwmod_is_hs_ip_block_usable(struct device_node *bus,</span>
<span class="p_add">+							const char *dev_name)</span>
 {
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	bool available;</span>
<span class="p_add">+</span>
 	if (!bus)
<span class="p_del">-		return (omap_type() == OMAP2_DEVICE_TYPE_GP) ? 1 : 0;</span>
<span class="p_add">+		return omap_type() == OMAP2_DEVICE_TYPE_GP;</span>
 
<span class="p_del">-	if (of_device_is_available(of_find_node_by_name(bus, dev_name)))</span>
<span class="p_del">-		return 1;</span>
<span class="p_add">+	node = of_get_child_by_name(bus, dev_name);</span>
<span class="p_add">+	available = of_device_is_available(node);</span>
<span class="p_add">+	of_node_put(node);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return available;</span>
 }
 
 int __init omap3xxx_hwmod_init(void)
<span class="p_chunk">@@ -3963,15 +3967,20 @@</span> <span class="p_context"> int __init omap3xxx_hwmod_init(void)</span>
 
 	if (h_sham &amp;&amp; omap3xxx_hwmod_is_hs_ip_block_usable(bus, &quot;sham&quot;)) {
 		r = omap_hwmod_register_links(h_sham);
<span class="p_del">-		if (r &lt; 0)</span>
<span class="p_add">+		if (r &lt; 0) {</span>
<span class="p_add">+			of_node_put(bus);</span>
 			return r;
<span class="p_add">+		}</span>
 	}
 
 	if (h_aes &amp;&amp; omap3xxx_hwmod_is_hs_ip_block_usable(bus, &quot;aes&quot;)) {
 		r = omap_hwmod_register_links(h_aes);
<span class="p_del">-		if (r &lt; 0)</span>
<span class="p_add">+		if (r &lt; 0) {</span>
<span class="p_add">+			of_node_put(bus);</span>
 			return r;
<span class="p_add">+		}</span>
 	}
<span class="p_add">+	of_node_put(bus);</span>
 
 	/*
 	 * Register hwmod links specific to certain ES levels of a
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_arm.h b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">index 2d960f8588b0..ef8e13d379cb 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_chunk">@@ -164,8 +164,7 @@</span> <span class="p_context"></span>
 #define VTTBR_X		(37 - VTCR_EL2_T0SZ_40B)
 #endif
 
<span class="p_del">-#define VTTBR_BADDR_SHIFT (VTTBR_X - 1)</span>
<span class="p_del">-#define VTTBR_BADDR_MASK  (((UL(1) &lt;&lt; (PHYS_MASK_SHIFT - VTTBR_X)) - 1) &lt;&lt; VTTBR_BADDR_SHIFT)</span>
<span class="p_add">+#define VTTBR_BADDR_MASK  (((UL(1) &lt;&lt; (PHYS_MASK_SHIFT - VTTBR_X)) - 1) &lt;&lt; VTTBR_X)</span>
 #define VTTBR_VMID_SHIFT  (UL(48))
 #define VTTBR_VMID_MASK	  (UL(0xFF) &lt;&lt; VTTBR_VMID_SHIFT)
 
<span class="p_header">diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c</span>
<span class="p_header">index f75b540bc3b4..10d6627673cb 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/process.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/process.c</span>
<span class="p_chunk">@@ -251,6 +251,15 @@</span> <span class="p_context"> int copy_thread(unsigned long clone_flags, unsigned long stack_start,</span>
 
 	memset(&amp;p-&gt;thread.cpu_context, 0, sizeof(struct cpu_context));
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case p was allocated the same task_struct pointer as some</span>
<span class="p_add">+	 * other recently-exited task, make sure p is disassociated from</span>
<span class="p_add">+	 * any cpu that may have run that now-exited task recently.</span>
<span class="p_add">+	 * Otherwise we could erroneously skip reloading the FPSIMD</span>
<span class="p_add">+	 * registers for p.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fpsimd_flush_task_state(p);</span>
<span class="p_add">+</span>
 	if (likely(!(p-&gt;flags &amp; PF_KTHREAD))) {
 		*childregs = *current_pt_regs();
 		childregs-&gt;regs[0] = 0;
<span class="p_header">diff --git a/arch/arm64/kvm/handle_exit.c b/arch/arm64/kvm/handle_exit.c</span>
<span class="p_header">index 15f0477b0d2a..ba93a09eb536 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/handle_exit.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/handle_exit.c</span>
<span class="p_chunk">@@ -121,7 +121,19 @@</span> <span class="p_context"> static int kvm_handle_guest_debug(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	return ret;
 }
 
<span class="p_add">+static int kvm_handle_unknown_ec(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 hsr = kvm_vcpu_get_hsr(vcpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_pr_unimpl(&quot;Unknown exception class: hsr: %#08x -- %s\n&quot;,</span>
<span class="p_add">+		      hsr, esr_get_class_string(hsr));</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_inject_undefined(vcpu);</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static exit_handle_fn arm_exit_handlers[] = {
<span class="p_add">+	[0 ... ESR_ELx_EC_MAX]	= kvm_handle_unknown_ec,</span>
 	[ESR_ELx_EC_WFx]	= kvm_handle_wfx,
 	[ESR_ELx_EC_CP15_32]	= kvm_handle_cp15_32,
 	[ESR_ELx_EC_CP15_64]	= kvm_handle_cp15_64,
<span class="p_chunk">@@ -147,13 +159,6 @@</span> <span class="p_context"> static exit_handle_fn kvm_get_exit_handler(struct kvm_vcpu *vcpu)</span>
 	u32 hsr = kvm_vcpu_get_hsr(vcpu);
 	u8 hsr_ec = hsr &gt;&gt; ESR_ELx_EC_SHIFT;
 
<span class="p_del">-	if (hsr_ec &gt;= ARRAY_SIZE(arm_exit_handlers) ||</span>
<span class="p_del">-	    !arm_exit_handlers[hsr_ec]) {</span>
<span class="p_del">-		kvm_err(&quot;Unknown exception class: hsr: %#08x -- %s\n&quot;,</span>
<span class="p_del">-			hsr, esr_get_class_string(hsr));</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return arm_exit_handlers[hsr_ec];
 }
 
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">index e40d0714679e..ecb7f3220355 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_chunk">@@ -2270,6 +2270,9 @@</span> <span class="p_context"> static long pnv_pci_ioda2_table_alloc_pages(int nid, __u64 bus_offset,</span>
 	level_shift = entries_shift + 3;
 	level_shift = max_t(unsigned, level_shift, PAGE_SHIFT);
 
<span class="p_add">+	if ((level_shift - 3) * levels + page_shift &gt;= 60)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Allocate TCE table */
 	addr = pnv_pci_ioda2_table_do_alloc_pages(nid, level_shift,
 			levels, tce_table_size, &amp;offset, &amp;total_allocated);
<span class="p_header">diff --git a/arch/powerpc/sysdev/axonram.c b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">index 7a399b4d60a0..566e8fc341f3 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_chunk">@@ -276,7 +276,9 @@</span> <span class="p_context"> failed:</span>
 			if (bank-&gt;disk-&gt;major &gt; 0)
 				unregister_blkdev(bank-&gt;disk-&gt;major,
 						bank-&gt;disk-&gt;disk_name);
<span class="p_del">-			del_gendisk(bank-&gt;disk);</span>
<span class="p_add">+			if (bank-&gt;disk-&gt;flags &amp; GENHD_FL_UP)</span>
<span class="p_add">+				del_gendisk(bank-&gt;disk);</span>
<span class="p_add">+			put_disk(bank-&gt;disk);</span>
 		}
 		device-&gt;dev.platform_data = NULL;
 		if (bank-&gt;io_addr != 0)
<span class="p_chunk">@@ -301,6 +303,7 @@</span> <span class="p_context"> axon_ram_remove(struct platform_device *device)</span>
 	device_remove_file(&amp;device-&gt;dev, &amp;dev_attr_ecc);
 	free_irq(bank-&gt;irq_id, device);
 	del_gendisk(bank-&gt;disk);
<span class="p_add">+	put_disk(bank-&gt;disk);</span>
 	iounmap((void __iomem *) bank-&gt;io_addr);
 	kfree(bank);
 
<span class="p_header">diff --git a/arch/s390/include/asm/asm-prototypes.h b/arch/s390/include/asm/asm-prototypes.h</span>
deleted file mode 100644
<span class="p_header">index 2c3413b0ca52..000000000000</span>
<span class="p_header">--- a/arch/s390/include/asm/asm-prototypes.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,8 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _ASM_S390_PROTOTYPES_H</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/kvm_host.h&gt;</span>
<span class="p_del">-#include &lt;linux/ftrace.h&gt;</span>
<span class="p_del">-#include &lt;asm/fpu/api.h&gt;</span>
<span class="p_del">-#include &lt;asm-generic/asm-prototypes.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* _ASM_S390_PROTOTYPES_H */</span>
<span class="p_header">diff --git a/arch/s390/include/asm/switch_to.h b/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">index dde6b52359c5..ff2fbdafe689 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/switch_to.h</span>
<span class="p_chunk">@@ -29,17 +29,16 @@</span> <span class="p_context"> static inline void restore_access_regs(unsigned int *acrs)</span>
 }
 
 #define switch_to(prev,next,last) do {					\
<span class="p_del">-	if (prev-&gt;mm) {							\</span>
<span class="p_del">-		save_fpu_regs();					\</span>
<span class="p_del">-		save_access_regs(&amp;prev-&gt;thread.acrs[0]);		\</span>
<span class="p_del">-		save_ri_cb(prev-&gt;thread.ri_cb);				\</span>
<span class="p_del">-	}								\</span>
<span class="p_add">+	/* save_fpu_regs() sets the CIF_FPU flag, which enforces	\</span>
<span class="p_add">+	 * a restore of the floating point / vector registers as	\</span>
<span class="p_add">+	 * soon as the next task returns to user space			\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	save_fpu_regs();						\</span>
<span class="p_add">+	save_access_regs(&amp;prev-&gt;thread.acrs[0]);			\</span>
<span class="p_add">+	save_ri_cb(prev-&gt;thread.ri_cb);					\</span>
 	update_cr_regs(next);						\
<span class="p_del">-	if (next-&gt;mm) {							\</span>
<span class="p_del">-		set_cpu_flag(CIF_FPU);					\</span>
<span class="p_del">-		restore_access_regs(&amp;next-&gt;thread.acrs[0]);		\</span>
<span class="p_del">-		restore_ri_cb(next-&gt;thread.ri_cb, prev-&gt;thread.ri_cb);	\</span>
<span class="p_del">-	}								\</span>
<span class="p_add">+	restore_access_regs(&amp;next-&gt;thread.acrs[0]);			\</span>
<span class="p_add">+	restore_ri_cb(next-&gt;thread.ri_cb, prev-&gt;thread.ri_cb);		\</span>
 	prev = __switch_to(prev,next);					\
 } while (0)
 
<span class="p_header">diff --git a/arch/s390/kernel/syscalls.S b/arch/s390/kernel/syscalls.S</span>
<span class="p_header">index 5378c3ea1b98..a1eeaa0db8b7 100644</span>
<span class="p_header">--- a/arch/s390/kernel/syscalls.S</span>
<span class="p_header">+++ b/arch/s390/kernel/syscalls.S</span>
<span class="p_chunk">@@ -369,10 +369,10 @@</span> <span class="p_context"> SYSCALL(sys_recvmmsg,compat_sys_recvmmsg)</span>
 SYSCALL(sys_sendmmsg,compat_sys_sendmmsg)
 SYSCALL(sys_socket,sys_socket)
 SYSCALL(sys_socketpair,compat_sys_socketpair)		/* 360 */
<span class="p_del">-SYSCALL(sys_bind,sys_bind)</span>
<span class="p_del">-SYSCALL(sys_connect,sys_connect)</span>
<span class="p_add">+SYSCALL(sys_bind,compat_sys_bind)</span>
<span class="p_add">+SYSCALL(sys_connect,compat_sys_connect)</span>
 SYSCALL(sys_listen,sys_listen)
<span class="p_del">-SYSCALL(sys_accept4,sys_accept4)</span>
<span class="p_add">+SYSCALL(sys_accept4,compat_sys_accept4)</span>
 SYSCALL(sys_getsockopt,compat_sys_getsockopt)		/* 365 */
 SYSCALL(sys_setsockopt,compat_sys_setsockopt)
 SYSCALL(sys_getsockname,compat_sys_getsockname)
<span class="p_header">diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c</span>
<span class="p_header">index 384aba109d7c..c2f376ce443b 100644</span>
<span class="p_header">--- a/arch/sparc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/sparc/mm/init_64.c</span>
<span class="p_chunk">@@ -2402,9 +2402,16 @@</span> <span class="p_context"> void __init mem_init(void)</span>
 {
 	high_memory = __va(last_valid_pfn &lt;&lt; PAGE_SHIFT);
 
<span class="p_del">-	register_page_bootmem_info();</span>
 	free_all_bootmem();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Must be done after boot memory is put on freelist, because here we</span>
<span class="p_add">+	 * might set fields in deferred struct pages that have not yet been</span>
<span class="p_add">+	 * initialized, and free_all_bootmem() initializes all the reserved</span>
<span class="p_add">+	 * deferred pages for us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	register_page_bootmem_info();</span>
<span class="p_add">+</span>
 	/*
 	 * Set up the zero page, mark it reserved, so that page count
 	 * is not manipulated when freeing the page from user ptes.
<span class="p_header">diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h</span>
<span class="p_header">index 8fd9e637629a..0010c78c4998 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/efi.h</span>
<span class="p_chunk">@@ -3,7 +3,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/fpu/api.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_del">-#include &lt;asm/tlb.h&gt;</span>
 
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
<span class="p_chunk">@@ -65,17 +64,6 @@</span> <span class="p_context"> extern u64 asmlinkage efi_call(void *fp, ...);</span>
 
 #define efi_call_phys(f, args...)		efi_call((f), args)
 
<span class="p_del">-/*</span>
<span class="p_del">- * Scratch space used for switching the pagetable in the EFI stub</span>
<span class="p_del">- */</span>
<span class="p_del">-struct efi_scratch {</span>
<span class="p_del">-	u64	r15;</span>
<span class="p_del">-	u64	prev_cr3;</span>
<span class="p_del">-	pgd_t	*efi_pgt;</span>
<span class="p_del">-	bool	use_pgd;</span>
<span class="p_del">-	u64	phys_stack;</span>
<span class="p_del">-} __packed;</span>
<span class="p_del">-</span>
 #define efi_call_virt(f, ...)						\
 ({									\
 	efi_status_t __s;						\
<span class="p_chunk">@@ -83,20 +71,7 @@</span> <span class="p_context"> struct efi_scratch {</span>
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
 	__kernel_fpu_begin();						\
<span class="p_del">-									\</span>
<span class="p_del">-	if (efi_scratch.use_pgd) {					\</span>
<span class="p_del">-		efi_scratch.prev_cr3 = read_cr3();			\</span>
<span class="p_del">-		write_cr3((unsigned long)efi_scratch.efi_pgt);		\</span>
<span class="p_del">-		__flush_tlb_all();					\</span>
<span class="p_del">-	}								\</span>
<span class="p_del">-									\</span>
 	__s = efi_call((void *)efi.systab-&gt;runtime-&gt;f, __VA_ARGS__);	\
<span class="p_del">-									\</span>
<span class="p_del">-	if (efi_scratch.use_pgd) {					\</span>
<span class="p_del">-		write_cr3(efi_scratch.prev_cr3);			\</span>
<span class="p_del">-		__flush_tlb_all();					\</span>
<span class="p_del">-	}								\</span>
<span class="p_del">-									\</span>
 	__kernel_fpu_end();						\
 	preempt_enable();						\
 	__s;								\
<span class="p_chunk">@@ -136,7 +111,6 @@</span> <span class="p_context"> extern void __init efi_memory_uc(u64 addr, unsigned long size);</span>
 extern void __init efi_map_region(efi_memory_desc_t *md);
 extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
 extern void efi_sync_low_kernel_mappings(void);
<span class="p_del">-extern int __init efi_alloc_page_tables(void);</span>
 extern int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init old_map_region(efi_memory_desc_t *md);
<span class="p_header">diff --git a/arch/x86/kernel/hpet.c b/arch/x86/kernel/hpet.c</span>
<span class="p_header">index acc9b8f19ca8..f48eb8eeefe2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/hpet.c</span>
<span class="p_header">+++ b/arch/x86/kernel/hpet.c</span>
<span class="p_chunk">@@ -353,7 +353,7 @@</span> <span class="p_context"> static int hpet_resume(struct clock_event_device *evt, int timer)</span>
 
 		irq_domain_deactivate_irq(irq_get_irq_data(hdev-&gt;irq));
 		irq_domain_activate_irq(irq_get_irq_data(hdev-&gt;irq));
<span class="p_del">-		disable_irq(hdev-&gt;irq);</span>
<span class="p_add">+		disable_hardirq(hdev-&gt;irq);</span>
 		irq_set_affinity(hdev-&gt;irq, cpumask_of(hdev-&gt;cpu));
 		enable_irq(hdev-&gt;irq);
 	}
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 253a8c8207bb..dcbafe53e2d4 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -6182,12 +6182,7 @@</span> <span class="p_context"> static __init int hardware_setup(void)</span>
 	memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);
 	memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Allow direct access to the PC debug port (it is often used for I/O</span>
<span class="p_del">-	 * delays, but the vmexits simply slow things down).</span>
<span class="p_del">-	 */</span>
 	memset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);
<span class="p_del">-	clear_bit(0x80, vmx_io_bitmap_a);</span>
 
 	memset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);
 
<span class="p_chunk">@@ -6929,9 +6924,8 @@</span> <span class="p_context"> static int handle_vmoff(struct kvm_vcpu *vcpu)</span>
 static int handle_vmclear(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
<span class="p_add">+	u32 zero = 0;</span>
 	gpa_t vmptr;
<span class="p_del">-	struct vmcs12 *vmcs12;</span>
<span class="p_del">-	struct page *page;</span>
 
 	if (!nested_vmx_check_permission(vcpu))
 		return 1;
<span class="p_chunk">@@ -6942,22 +6936,9 @@</span> <span class="p_context"> static int handle_vmclear(struct kvm_vcpu *vcpu)</span>
 	if (vmptr == vmx-&gt;nested.current_vmptr)
 		nested_release_vmcs12(vmx);
 
<span class="p_del">-	page = nested_get_page(vcpu, vmptr);</span>
<span class="p_del">-	if (page == NULL) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * For accurate processor emulation, VMCLEAR beyond available</span>
<span class="p_del">-		 * physical memory should do nothing at all. However, it is</span>
<span class="p_del">-		 * possible that a nested vmx bug, not a guest hypervisor bug,</span>
<span class="p_del">-		 * resulted in this case, so let&#39;s shut down before doing any</span>
<span class="p_del">-		 * more damage:</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	vmcs12 = kmap(page);</span>
<span class="p_del">-	vmcs12-&gt;launch_state = 0;</span>
<span class="p_del">-	kunmap(page);</span>
<span class="p_del">-	nested_release_page(page);</span>
<span class="p_add">+	kvm_vcpu_write_guest(vcpu,</span>
<span class="p_add">+			vmptr + offsetof(struct vmcs12, launch_state),</span>
<span class="p_add">+			&amp;zero, sizeof(zero));</span>
 
 	nested_free_vmcs02(vmx, vmptr);
 
<span class="p_chunk">@@ -10574,8 +10555,10 @@</span> <span class="p_context"> static void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,</span>
  */
 static void vmx_leave_nested(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	if (is_guest_mode(vcpu))</span>
<span class="p_add">+	if (is_guest_mode(vcpu)) {</span>
<span class="p_add">+		to_vmx(vcpu)-&gt;nested.nested_run_pending = 0;</span>
 		nested_vmx_vmexit(vcpu, -1, 0, 0);
<span class="p_add">+	}</span>
 	free_nested(to_vmx(vcpu));
 }
 
<span class="p_header">diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c</span>
<span class="p_header">index a0fe62e3f4a3..b599a780a5a9 100644</span>
<span class="p_header">--- a/arch/x86/mm/pageattr.c</span>
<span class="p_header">+++ b/arch/x86/mm/pageattr.c</span>
<span class="p_chunk">@@ -911,10 +911,15 @@</span> <span class="p_context"> static void populate_pte(struct cpa_data *cpa,</span>
 	pte = pte_offset_kernel(pmd, start);
 
 	while (num_pages-- &amp;&amp; start &lt; end) {
<span class="p_del">-		set_pte(pte, pfn_pte(cpa-&gt;pfn, pgprot));</span>
<span class="p_add">+</span>
<span class="p_add">+		/* deal with the NX bit */</span>
<span class="p_add">+		if (!(pgprot_val(pgprot) &amp; _PAGE_NX))</span>
<span class="p_add">+			cpa-&gt;pfn &amp;= ~_PAGE_NX;</span>
<span class="p_add">+</span>
<span class="p_add">+		set_pte(pte, pfn_pte(cpa-&gt;pfn &gt;&gt; PAGE_SHIFT, pgprot));</span>
 
 		start	 += PAGE_SIZE;
<span class="p_del">-		cpa-&gt;pfn++;</span>
<span class="p_add">+		cpa-&gt;pfn += PAGE_SIZE;</span>
 		pte++;
 	}
 }
<span class="p_chunk">@@ -970,11 +975,11 @@</span> <span class="p_context"> static int populate_pmd(struct cpa_data *cpa,</span>
 
 		pmd = pmd_offset(pud, start);
 
<span class="p_del">-		set_pmd(pmd, __pmd(cpa-&gt;pfn &lt;&lt; PAGE_SHIFT | _PAGE_PSE |</span>
<span class="p_add">+		set_pmd(pmd, __pmd(cpa-&gt;pfn | _PAGE_PSE |</span>
 				   massage_pgprot(pmd_pgprot)));
 
 		start	  += PMD_SIZE;
<span class="p_del">-		cpa-&gt;pfn  += PMD_SIZE &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		cpa-&gt;pfn  += PMD_SIZE;</span>
 		cur_pages += PMD_SIZE &gt;&gt; PAGE_SHIFT;
 	}
 
<span class="p_chunk">@@ -1043,11 +1048,11 @@</span> <span class="p_context"> static int populate_pud(struct cpa_data *cpa, unsigned long start, pgd_t *pgd,</span>
 	 * Map everything starting from the Gb boundary, possibly with 1G pages
 	 */
 	while (end - start &gt;= PUD_SIZE) {
<span class="p_del">-		set_pud(pud, __pud(cpa-&gt;pfn &lt;&lt; PAGE_SHIFT | _PAGE_PSE |</span>
<span class="p_add">+		set_pud(pud, __pud(cpa-&gt;pfn | _PAGE_PSE |</span>
 				   massage_pgprot(pud_pgprot)));
 
 		start	  += PUD_SIZE;
<span class="p_del">-		cpa-&gt;pfn  += PUD_SIZE &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		cpa-&gt;pfn  += PUD_SIZE;</span>
 		cur_pages += PUD_SIZE &gt;&gt; PAGE_SHIFT;
 		pud++;
 	}
<span class="p_header">diff --git a/arch/x86/pci/broadcom_bus.c b/arch/x86/pci/broadcom_bus.c</span>
<span class="p_header">index bb461cfd01ab..526536c81ddc 100644</span>
<span class="p_header">--- a/arch/x86/pci/broadcom_bus.c</span>
<span class="p_header">+++ b/arch/x86/pci/broadcom_bus.c</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> static int __init broadcom_postcore_init(void)</span>
 	 * We should get host bridge information from ACPI unless the BIOS
 	 * doesn&#39;t support it.
 	 */
<span class="p_del">-	if (acpi_os_get_root_pointer())</span>
<span class="p_add">+	if (!acpi_disabled &amp;&amp; acpi_os_get_root_pointer())</span>
 		return 0;
 #endif
 
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index 3c1f3cd7b2ba..ad285404ea7f 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -869,7 +869,7 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
  * This function will switch the EFI runtime services to virtual mode.
  * Essentially, we look through the EFI memmap and map every region that
  * has the runtime attribute bit set in its memory descriptor into the
<span class="p_del">- * efi_pgd page table.</span>
<span class="p_add">+ * -&gt;trampoline_pgd page table using a top-down VA allocation scheme.</span>
  *
  * The old method which used to update that memory descriptor with the
  * virtual address obtained from ioremap() is still supported when the
<span class="p_chunk">@@ -879,8 +879,8 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
  *
  * The new method does a pagetable switch in a preemption-safe manner
  * so that we&#39;re in a different address space when calling a runtime
<span class="p_del">- * function. For function arguments passing we do copy the PUDs of the</span>
<span class="p_del">- * kernel page table into efi_pgd prior to each call.</span>
<span class="p_add">+ * function. For function arguments passing we do copy the PGDs of the</span>
<span class="p_add">+ * kernel page table into -&gt;trampoline_pgd prior to each call.</span>
  *
  * Specially for kexec boot, efi runtime maps in previous kernel should
  * be passed in via setup_data. In that case runtime ranges will be mapped
<span class="p_chunk">@@ -895,12 +895,6 @@</span> <span class="p_context"> static void __init __efi_enter_virtual_mode(void)</span>
 
 	efi.systab = NULL;
 
<span class="p_del">-	if (efi_alloc_page_tables()) {</span>
<span class="p_del">-		pr_err(&quot;Failed to allocate EFI page tables\n&quot;);</span>
<span class="p_del">-		clear_bit(EFI_RUNTIME_SERVICES, &amp;efi.flags);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	efi_merge_regions();
 	new_memmap = efi_map_regions(&amp;count, &amp;pg_shift);
 	if (!new_memmap) {
<span class="p_chunk">@@ -960,11 +954,28 @@</span> <span class="p_context"> static void __init __efi_enter_virtual_mode(void)</span>
 	efi_runtime_mkexec();
 
 	/*
<span class="p_del">-	 * We mapped the descriptor array into the EFI pagetable above</span>
<span class="p_del">-	 * but we&#39;re not unmapping it here because if we&#39;re running in</span>
<span class="p_del">-	 * EFI mixed mode we need all of memory to be accessible when</span>
<span class="p_del">-	 * we pass parameters to the EFI runtime services in the</span>
<span class="p_del">-	 * thunking code.</span>
<span class="p_add">+	 * We mapped the descriptor array into the EFI pagetable above but we&#39;re</span>
<span class="p_add">+	 * not unmapping it here. Here&#39;s why:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We&#39;re copying select PGDs from the kernel page table to the EFI page</span>
<span class="p_add">+	 * table and when we do so and make changes to those PGDs like unmapping</span>
<span class="p_add">+	 * stuff from them, those changes appear in the kernel page table and we</span>
<span class="p_add">+	 * go boom.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * From setup_real_mode():</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * ...</span>
<span class="p_add">+	 * trampoline_pgd[0] = init_level4_pgt[pgd_index(__PAGE_OFFSET)].pgd;</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * In this particular case, our allocation is in PGD 0 of the EFI page</span>
<span class="p_add">+	 * table but we&#39;ve copied that PGD from PGD[272] of the EFI page table:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *	pgd_index(__PAGE_OFFSET = 0xffff880000000000) = 272</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * where the direct memory mapping in kernel space is.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * new_memmap&#39;s VA comes from that direct mapping and thus clearing it,</span>
<span class="p_add">+	 * it would get cleared in the kernel page table too.</span>
 	 *
 	 * efi_cleanup_page_tables(__pa(new_memmap), 1 &lt;&lt; pg_shift);
 	 */
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_32.c b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">index 58d669bc8250..ed5b67338294 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_chunk">@@ -38,11 +38,6 @@</span> <span class="p_context"></span>
  * say 0 - 3G.
  */
 
<span class="p_del">-int __init efi_alloc_page_tables(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void efi_sync_low_kernel_mappings(void) {}
 void __init efi_dump_pagetable(void) {}
 int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index 18dfaad71c99..a0ac0f9c307f 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -40,7 +40,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/realmode.h&gt;
 #include &lt;asm/time.h&gt;
<span class="p_del">-#include &lt;asm/pgalloc.h&gt;</span>
 
 /*
  * We allocate runtime services regions bottom-up, starting from -4G, i.e.
<span class="p_chunk">@@ -48,7 +47,16 @@</span> <span class="p_context"></span>
  */
 static u64 efi_va = EFI_VA_START;
 
<span class="p_del">-struct efi_scratch efi_scratch;</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Scratch space used for switching the pagetable in the EFI stub</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct efi_scratch {</span>
<span class="p_add">+	u64 r15;</span>
<span class="p_add">+	u64 prev_cr3;</span>
<span class="p_add">+	pgd_t *efi_pgt;</span>
<span class="p_add">+	bool use_pgd;</span>
<span class="p_add">+	u64 phys_stack;</span>
<span class="p_add">+} __packed;</span>
 
 static void __init early_code_mapping_set_exec(int executable)
 {
<span class="p_chunk">@@ -75,11 +83,8 @@</span> <span class="p_context"> pgd_t * __init efi_call_phys_prolog(void)</span>
 	int pgd;
 	int n_pgds;
 
<span class="p_del">-	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="p_del">-		save_pgd = (pgd_t *)read_cr3();</span>
<span class="p_del">-		write_cr3((unsigned long)efi_scratch.efi_pgt);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!efi_enabled(EFI_OLD_MEMMAP))</span>
<span class="p_add">+		return NULL;</span>
 
 	early_code_mapping_set_exec(1);
 
<span class="p_chunk">@@ -91,7 +96,6 @@</span> <span class="p_context"> pgd_t * __init efi_call_phys_prolog(void)</span>
 		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);
 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));
 	}
<span class="p_del">-out:</span>
 	__flush_tlb_all();
 
 	return save_pgd;
<span class="p_chunk">@@ -105,11 +109,8 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 	int pgd_idx;
 	int nr_pgds;
 
<span class="p_del">-	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="p_del">-		write_cr3((unsigned long)save_pgd);</span>
<span class="p_del">-		__flush_tlb_all();</span>
<span class="p_add">+	if (!save_pgd)</span>
 		return;
<span class="p_del">-	}</span>
 
 	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);
 
<span class="p_chunk">@@ -122,97 +123,27 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 	early_code_mapping_set_exec(0);
 }
 
<span class="p_del">-static pgd_t *efi_pgd;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We need our own copy of the higher levels of the page tables</span>
<span class="p_del">- * because we want to avoid inserting EFI region mappings (EFI_VA_END</span>
<span class="p_del">- * to EFI_VA_START) into the standard kernel page tables. Everything</span>
<span class="p_del">- * else can be shared, see efi_sync_low_kernel_mappings().</span>
<span class="p_del">- */</span>
<span class="p_del">-int __init efi_alloc_page_tables(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd_t *pgd;</span>
<span class="p_del">-	pud_t *pud;</span>
<span class="p_del">-	gfp_t gfp_mask;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (efi_enabled(EFI_OLD_MEMMAP))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	gfp_mask = GFP_KERNEL | __GFP_NOTRACK | __GFP_REPEAT | __GFP_ZERO;</span>
<span class="p_del">-	efi_pgd = (pgd_t *)__get_free_page(gfp_mask);</span>
<span class="p_del">-	if (!efi_pgd)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	pgd = efi_pgd + pgd_index(EFI_VA_END);</span>
<span class="p_del">-</span>
<span class="p_del">-	pud = pud_alloc_one(NULL, 0);</span>
<span class="p_del">-	if (!pud) {</span>
<span class="p_del">-		free_page((unsigned long)efi_pgd);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	pgd_populate(NULL, pgd, pud);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * Add low kernel mappings for passing arguments to EFI functions.
  */
 void efi_sync_low_kernel_mappings(void)
 {
<span class="p_del">-	unsigned num_entries;</span>
<span class="p_del">-	pgd_t *pgd_k, *pgd_efi;</span>
<span class="p_del">-	pud_t *pud_k, *pud_efi;</span>
<span class="p_add">+	unsigned num_pgds;</span>
<span class="p_add">+	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
 
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We can share all PGD entries apart from the one entry that</span>
<span class="p_del">-	 * covers the EFI runtime mapping space.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Make sure the EFI runtime region mappings are guaranteed to</span>
<span class="p_del">-	 * only span a single PGD entry and that the entry also maps</span>
<span class="p_del">-	 * other important kernel regions.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	BUILD_BUG_ON(pgd_index(EFI_VA_END) != pgd_index(MODULES_END));</span>
<span class="p_del">-	BUILD_BUG_ON((EFI_VA_START &amp; PGDIR_MASK) !=</span>
<span class="p_del">-			(EFI_VA_END &amp; PGDIR_MASK));</span>
<span class="p_del">-</span>
<span class="p_del">-	pgd_efi = efi_pgd + pgd_index(PAGE_OFFSET);</span>
<span class="p_del">-	pgd_k = pgd_offset_k(PAGE_OFFSET);</span>
<span class="p_add">+	num_pgds = pgd_index(MODULES_END - 1) - pgd_index(PAGE_OFFSET);</span>
 
<span class="p_del">-	num_entries = pgd_index(EFI_VA_END) - pgd_index(PAGE_OFFSET);</span>
<span class="p_del">-	memcpy(pgd_efi, pgd_k, sizeof(pgd_t) * num_entries);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We share all the PUD entries apart from those that map the</span>
<span class="p_del">-	 * EFI regions. Copy around them.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	BUILD_BUG_ON((EFI_VA_START &amp; ~PUD_MASK) != 0);</span>
<span class="p_del">-	BUILD_BUG_ON((EFI_VA_END &amp; ~PUD_MASK) != 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	pgd_efi = efi_pgd + pgd_index(EFI_VA_END);</span>
<span class="p_del">-	pud_efi = pud_offset(pgd_efi, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	pgd_k = pgd_offset_k(EFI_VA_END);</span>
<span class="p_del">-	pud_k = pud_offset(pgd_k, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	num_entries = pud_index(EFI_VA_END);</span>
<span class="p_del">-	memcpy(pud_efi, pud_k, sizeof(pud_t) * num_entries);</span>
<span class="p_del">-</span>
<span class="p_del">-	pud_efi = pud_offset(pgd_efi, EFI_VA_START);</span>
<span class="p_del">-	pud_k = pud_offset(pgd_k, EFI_VA_START);</span>
<span class="p_del">-</span>
<span class="p_del">-	num_entries = PTRS_PER_PUD - pud_index(EFI_VA_START);</span>
<span class="p_del">-	memcpy(pud_efi, pud_k, sizeof(pud_t) * num_entries);</span>
<span class="p_add">+	memcpy(pgd + pgd_index(PAGE_OFFSET),</span>
<span class="p_add">+		init_mm.pgd + pgd_index(PAGE_OFFSET),</span>
<span class="p_add">+		sizeof(pgd_t) * num_pgds);</span>
 }
 
 int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)
 {
<span class="p_del">-	unsigned long pfn, text;</span>
<span class="p_add">+	unsigned long text;</span>
 	struct page *page;
 	unsigned npages;
 	pgd_t *pgd;
<span class="p_chunk">@@ -220,8 +151,8 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
<span class="p_del">-	efi_scratch.efi_pgt = (pgd_t *)__pa(efi_pgd);</span>
<span class="p_del">-	pgd = efi_pgd;</span>
<span class="p_add">+	efi_scratch.efi_pgt = (pgd_t *)(unsigned long)real_mode_header-&gt;trampoline_pgd;</span>
<span class="p_add">+	pgd = __va(efi_scratch.efi_pgt);</span>
 
 	/*
 	 * It can happen that the physical address of new_memmap lands in memory
<span class="p_chunk">@@ -229,8 +160,7 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	 * and ident-map those pages containing the map before calling
 	 * phys_efi_set_virtual_address_map().
 	 */
<span class="p_del">-	pfn = pa_memmap &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-	if (kernel_map_pages_in_pgd(pgd, pfn, pa_memmap, num_pages, _PAGE_NX)) {</span>
<span class="p_add">+	if (kernel_map_pages_in_pgd(pgd, pa_memmap, pa_memmap, num_pages, _PAGE_NX)) {</span>
 		pr_err(&quot;Error ident-mapping new memmap (0x%lx)!\n&quot;, pa_memmap);
 		return 1;
 	}
<span class="p_chunk">@@ -255,9 +185,8 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 
 	npages = (_end - _text) &gt;&gt; PAGE_SHIFT;
 	text = __pa(_text);
<span class="p_del">-	pfn = text &gt;&gt; PAGE_SHIFT;</span>
 
<span class="p_del">-	if (kernel_map_pages_in_pgd(pgd, pfn, text, npages, 0)) {</span>
<span class="p_add">+	if (kernel_map_pages_in_pgd(pgd, text &gt;&gt; PAGE_SHIFT, text, npages, 0)) {</span>
 		pr_err(&quot;Failed to map kernel text 1:1\n&quot;);
 		return 1;
 	}
<span class="p_chunk">@@ -267,20 +196,20 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 
 void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages)
 {
<span class="p_del">-	kernel_unmap_pages_in_pgd(efi_pgd, pa_memmap, num_pages);</span>
<span class="p_add">+	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	kernel_unmap_pages_in_pgd(pgd, pa_memmap, num_pages);</span>
 }
 
 static void __init __map_region(efi_memory_desc_t *md, u64 va)
 {
<span class="p_del">-	unsigned long flags = 0;</span>
<span class="p_del">-	unsigned long pfn;</span>
<span class="p_del">-	pgd_t *pgd = efi_pgd;</span>
<span class="p_add">+	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_add">+	unsigned long pf = 0;</span>
 
 	if (!(md-&gt;attribute &amp; EFI_MEMORY_WB))
<span class="p_del">-		flags |= _PAGE_PCD;</span>
<span class="p_add">+		pf |= _PAGE_PCD;</span>
 
<span class="p_del">-	pfn = md-&gt;phys_addr &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-	if (kernel_map_pages_in_pgd(pgd, pfn, va, md-&gt;num_pages, flags))</span>
<span class="p_add">+	if (kernel_map_pages_in_pgd(pgd, md-&gt;phys_addr, va, md-&gt;num_pages, pf))</span>
 		pr_warn(&quot;Error mapping PA 0x%llx -&gt; VA 0x%llx!\n&quot;,
 			   md-&gt;phys_addr, va);
 }
<span class="p_chunk">@@ -383,7 +312,9 @@</span> <span class="p_context"> void __init efi_runtime_mkexec(void)</span>
 void __init efi_dump_pagetable(void)
 {
 #ifdef CONFIG_EFI_PGT_DUMP
<span class="p_del">-	ptdump_walk_pgd_level(NULL, efi_pgd);</span>
<span class="p_add">+	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	ptdump_walk_pgd_level(NULL, pgd);</span>
 #endif
 }
 
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_stub_64.S b/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_header">index 32020cb8bb08..86d0f9e08dd9 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_chunk">@@ -38,6 +38,41 @@</span> <span class="p_context"></span>
 	mov %rsi, %cr0;			\
 	mov (%rsp), %rsp
 
<span class="p_add">+	/* stolen from gcc */</span>
<span class="p_add">+	.macro FLUSH_TLB_ALL</span>
<span class="p_add">+	movq %r15, efi_scratch(%rip)</span>
<span class="p_add">+	movq %r14, efi_scratch+8(%rip)</span>
<span class="p_add">+	movq %cr4, %r15</span>
<span class="p_add">+	movq %r15, %r14</span>
<span class="p_add">+	andb $0x7f, %r14b</span>
<span class="p_add">+	movq %r14, %cr4</span>
<span class="p_add">+	movq %r15, %cr4</span>
<span class="p_add">+	movq efi_scratch+8(%rip), %r14</span>
<span class="p_add">+	movq efi_scratch(%rip), %r15</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro SWITCH_PGT</span>
<span class="p_add">+	cmpb $0, efi_scratch+24(%rip)</span>
<span class="p_add">+	je 1f</span>
<span class="p_add">+	movq %r15, efi_scratch(%rip)		# r15</span>
<span class="p_add">+	# save previous CR3</span>
<span class="p_add">+	movq %cr3, %r15</span>
<span class="p_add">+	movq %r15, efi_scratch+8(%rip)		# prev_cr3</span>
<span class="p_add">+	movq efi_scratch+16(%rip), %r15		# EFI pgt</span>
<span class="p_add">+	movq %r15, %cr3</span>
<span class="p_add">+	1:</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro RESTORE_PGT</span>
<span class="p_add">+	cmpb $0, efi_scratch+24(%rip)</span>
<span class="p_add">+	je 2f</span>
<span class="p_add">+	movq efi_scratch+8(%rip), %r15</span>
<span class="p_add">+	movq %r15, %cr3</span>
<span class="p_add">+	movq efi_scratch(%rip), %r15</span>
<span class="p_add">+	FLUSH_TLB_ALL</span>
<span class="p_add">+	2:</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
 ENTRY(efi_call)
 	SAVE_XMM
 	mov (%rsp), %rax
<span class="p_chunk">@@ -48,8 +83,16 @@</span> <span class="p_context"> ENTRY(efi_call)</span>
 	mov %r8, %r9
 	mov %rcx, %r8
 	mov %rsi, %rcx
<span class="p_add">+	SWITCH_PGT</span>
 	call *%rdi
<span class="p_add">+	RESTORE_PGT</span>
 	addq $48, %rsp
 	RESTORE_XMM
 	ret
 ENDPROC(efi_call)
<span class="p_add">+</span>
<span class="p_add">+	.data</span>
<span class="p_add">+ENTRY(efi_scratch)</span>
<span class="p_add">+	.fill 3,8,0</span>
<span class="p_add">+	.byte 0</span>
<span class="p_add">+	.quad 0</span>
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index 68bbc835bacc..63363a689922 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -1268,6 +1268,7 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 	int ret, offset;
 	struct iov_iter i;
 	struct iovec iov;
<span class="p_add">+	struct bio_vec *bvec;</span>
 
 	iov_for_each(iov, i, *iter) {
 		unsigned long uaddr = (unsigned long) iov.iov_base;
<span class="p_chunk">@@ -1312,7 +1313,12 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 		ret = get_user_pages_fast(uaddr, local_nr_pages,
 				(iter-&gt;type &amp; WRITE) != WRITE,
 				&amp;pages[cur_page]);
<span class="p_del">-		if (ret &lt; local_nr_pages) {</span>
<span class="p_add">+		if (unlikely(ret &lt; local_nr_pages)) {</span>
<span class="p_add">+			for (j = cur_page; j &lt; page_limit; j++) {</span>
<span class="p_add">+				if (!pages[j])</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				put_page(pages[j]);</span>
<span class="p_add">+			}</span>
 			ret = -EFAULT;
 			goto out_unmap;
 		}
<span class="p_chunk">@@ -1374,10 +1380,8 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 	return bio;
 
  out_unmap:
<span class="p_del">-	for (j = 0; j &lt; nr_pages; j++) {</span>
<span class="p_del">-		if (!pages[j])</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		page_cache_release(pages[j]);</span>
<span class="p_add">+	bio_for_each_segment_all(bvec, bio, j) {</span>
<span class="p_add">+		put_page(bvec-&gt;bv_page);</span>
 	}
  out:
 	kfree(pages);
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 119658534dfd..f5f1a55703ae 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -526,8 +526,8 @@</span> <span class="p_context"> void blk_set_queue_dying(struct request_queue *q)</span>
 
 		blk_queue_for_each_rl(rl, q) {
 			if (rl-&gt;rq_pool) {
<span class="p_del">-				wake_up(&amp;rl-&gt;wait[BLK_RW_SYNC]);</span>
<span class="p_del">-				wake_up(&amp;rl-&gt;wait[BLK_RW_ASYNC]);</span>
<span class="p_add">+				wake_up_all(&amp;rl-&gt;wait[BLK_RW_SYNC]);</span>
<span class="p_add">+				wake_up_all(&amp;rl-&gt;wait[BLK_RW_ASYNC]);</span>
 			}
 		}
 	}
<span class="p_header">diff --git a/crypto/asymmetric_keys/x509_cert_parser.c b/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_header">index 13c4e5a5fe8c..4471e7ed8c12 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_chunk">@@ -399,6 +399,8 @@</span> <span class="p_context"> int x509_extract_key_data(void *context, size_t hdrlen,</span>
 	ctx-&gt;cert-&gt;pub-&gt;pkey_algo = PKEY_ALGO_RSA;
 
 	/* Discard the BIT STRING metadata */
<span class="p_add">+	if (vlen &lt; 1 || *(const u8 *)value != 0)</span>
<span class="p_add">+		return -EBADMSG;</span>
 	ctx-&gt;key = value + 1;
 	ctx-&gt;key_size = vlen - 1;
 	return 0;
<span class="p_header">diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c</span>
<span class="p_header">index 7dbba387d12a..18de4c457068 100644</span>
<span class="p_header">--- a/drivers/ata/libata-sff.c</span>
<span class="p_header">+++ b/drivers/ata/libata-sff.c</span>
<span class="p_chunk">@@ -1480,7 +1480,6 @@</span> <span class="p_context"> unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc)</span>
 		break;
 
 	default:
<span class="p_del">-		WARN_ON_ONCE(1);</span>
 		return AC_ERR_SYSTEM;
 	}
 
<span class="p_header">diff --git a/drivers/atm/horizon.c b/drivers/atm/horizon.c</span>
<span class="p_header">index 527bbd595e37..d9b762a62e25 100644</span>
<span class="p_header">--- a/drivers/atm/horizon.c</span>
<span class="p_header">+++ b/drivers/atm/horizon.c</span>
<span class="p_chunk">@@ -2804,7 +2804,7 @@</span> <span class="p_context"> out:</span>
 	return err;
 
 out_free_irq:
<span class="p_del">-	free_irq(dev-&gt;irq, dev);</span>
<span class="p_add">+	free_irq(irq, dev);</span>
 out_free:
 	kfree(dev);
 out_release:
<span class="p_header">diff --git a/drivers/base/isa.c b/drivers/base/isa.c</span>
<span class="p_header">index 91dba65d7264..901d8185309e 100644</span>
<span class="p_header">--- a/drivers/base/isa.c</span>
<span class="p_header">+++ b/drivers/base/isa.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"> static int isa_bus_probe(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;probe)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;probe)</span>
 		return isa_driver-&gt;probe(dev, to_isa_dev(dev)-&gt;id);
 
 	return 0;
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> static int isa_bus_remove(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;remove)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;remove)</span>
 		return isa_driver-&gt;remove(dev, to_isa_dev(dev)-&gt;id);
 
 	return 0;
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> static void isa_bus_shutdown(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;shutdown)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;shutdown)</span>
 		isa_driver-&gt;shutdown(dev, to_isa_dev(dev)-&gt;id);
 }
 
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> static int isa_bus_suspend(struct device *dev, pm_message_t state)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;suspend)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;suspend)</span>
 		return isa_driver-&gt;suspend(dev, to_isa_dev(dev)-&gt;id, state);
 
 	return 0;
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> static int isa_bus_resume(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;resume)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;resume)</span>
 		return isa_driver-&gt;resume(dev, to_isa_dev(dev)-&gt;id);
 
 	return 0;
<span class="p_header">diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c</span>
<span class="p_header">index 62a93b685c54..502406c9e6e1 100644</span>
<span class="p_header">--- a/drivers/block/zram/zram_drv.c</span>
<span class="p_header">+++ b/drivers/block/zram/zram_drv.c</span>
<span class="p_chunk">@@ -1247,6 +1247,8 @@</span> <span class="p_context"> static int zram_add(void)</span>
 	blk_queue_io_min(zram-&gt;disk-&gt;queue, PAGE_SIZE);
 	blk_queue_io_opt(zram-&gt;disk-&gt;queue, PAGE_SIZE);
 	zram-&gt;disk-&gt;queue-&gt;limits.discard_granularity = PAGE_SIZE;
<span class="p_add">+	zram-&gt;disk-&gt;queue-&gt;limits.max_sectors = SECTORS_PER_PAGE;</span>
<span class="p_add">+	zram-&gt;disk-&gt;queue-&gt;limits.chunk_sectors = 0;</span>
 	blk_queue_max_discard_sectors(zram-&gt;disk-&gt;queue, UINT_MAX);
 	/*
 	 * zram_bio_discard() will clear all logical blocks if logical block
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index 4cc72fa017c7..2f9abe0d04dc 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -239,6 +239,9 @@</span> <span class="p_context"> struct smi_info {</span>
 	/* The timer for this si. */
 	struct timer_list   si_timer;
 
<span class="p_add">+	/* This flag is set, if the timer can be set */</span>
<span class="p_add">+	bool		    timer_can_start;</span>
<span class="p_add">+</span>
 	/* This flag is set, if the timer is running (timer_pending() isn&#39;t enough) */
 	bool		    timer_running;
 
<span class="p_chunk">@@ -414,6 +417,8 @@</span> <span class="p_context"> static enum si_sm_result start_next_msg(struct smi_info *smi_info)</span>
 
 static void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)
 {
<span class="p_add">+	if (!smi_info-&gt;timer_can_start)</span>
<span class="p_add">+		return;</span>
 	smi_info-&gt;last_timeout_jiffies = jiffies;
 	mod_timer(&amp;smi_info-&gt;si_timer, new_val);
 	smi_info-&gt;timer_running = true;
<span class="p_chunk">@@ -433,21 +438,18 @@</span> <span class="p_context"> static void start_new_msg(struct smi_info *smi_info, unsigned char *msg,</span>
 	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, size);
 }
 
<span class="p_del">-static void start_check_enables(struct smi_info *smi_info, bool start_timer)</span>
<span class="p_add">+static void start_check_enables(struct smi_info *smi_info)</span>
 {
 	unsigned char msg[2];
 
 	msg[0] = (IPMI_NETFN_APP_REQUEST &lt;&lt; 2);
 	msg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;
 
<span class="p_del">-	if (start_timer)</span>
<span class="p_del">-		start_new_msg(smi_info, msg, 2);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 2);</span>
<span class="p_add">+	start_new_msg(smi_info, msg, 2);</span>
 	smi_info-&gt;si_state = SI_CHECKING_ENABLES;
 }
 
<span class="p_del">-static void start_clear_flags(struct smi_info *smi_info, bool start_timer)</span>
<span class="p_add">+static void start_clear_flags(struct smi_info *smi_info)</span>
 {
 	unsigned char msg[3];
 
<span class="p_chunk">@@ -456,10 +458,7 @@</span> <span class="p_context"> static void start_clear_flags(struct smi_info *smi_info, bool start_timer)</span>
 	msg[1] = IPMI_CLEAR_MSG_FLAGS_CMD;
 	msg[2] = WDT_PRE_TIMEOUT_INT;
 
<span class="p_del">-	if (start_timer)</span>
<span class="p_del">-		start_new_msg(smi_info, msg, 3);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 3);</span>
<span class="p_add">+	start_new_msg(smi_info, msg, 3);</span>
 	smi_info-&gt;si_state = SI_CLEARING_FLAGS;
 }
 
<span class="p_chunk">@@ -494,11 +493,11 @@</span> <span class="p_context"> static void start_getting_events(struct smi_info *smi_info)</span>
  * Note that we cannot just use disable_irq(), since the interrupt may
  * be shared.
  */
<span class="p_del">-static inline bool disable_si_irq(struct smi_info *smi_info, bool start_timer)</span>
<span class="p_add">+static inline bool disable_si_irq(struct smi_info *smi_info)</span>
 {
 	if ((smi_info-&gt;irq) &amp;&amp; (!smi_info-&gt;interrupt_disabled)) {
 		smi_info-&gt;interrupt_disabled = true;
<span class="p_del">-		start_check_enables(smi_info, start_timer);</span>
<span class="p_add">+		start_check_enables(smi_info);</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -508,7 +507,7 @@</span> <span class="p_context"> static inline bool enable_si_irq(struct smi_info *smi_info)</span>
 {
 	if ((smi_info-&gt;irq) &amp;&amp; (smi_info-&gt;interrupt_disabled)) {
 		smi_info-&gt;interrupt_disabled = false;
<span class="p_del">-		start_check_enables(smi_info, true);</span>
<span class="p_add">+		start_check_enables(smi_info);</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -526,7 +525,7 @@</span> <span class="p_context"> static struct ipmi_smi_msg *alloc_msg_handle_irq(struct smi_info *smi_info)</span>
 
 	msg = ipmi_alloc_smi_msg();
 	if (!msg) {
<span class="p_del">-		if (!disable_si_irq(smi_info, true))</span>
<span class="p_add">+		if (!disable_si_irq(smi_info))</span>
 			smi_info-&gt;si_state = SI_NORMAL;
 	} else if (enable_si_irq(smi_info)) {
 		ipmi_free_smi_msg(msg);
<span class="p_chunk">@@ -542,7 +541,7 @@</span> <span class="p_context"> static void handle_flags(struct smi_info *smi_info)</span>
 		/* Watchdog pre-timeout */
 		smi_inc_stat(smi_info, watchdog_pretimeouts);
 
<span class="p_del">-		start_clear_flags(smi_info, true);</span>
<span class="p_add">+		start_clear_flags(smi_info);</span>
 		smi_info-&gt;msg_flags &amp;= ~WDT_PRE_TIMEOUT_INT;
 		if (smi_info-&gt;intf)
 			ipmi_smi_watchdog_pretimeout(smi_info-&gt;intf);
<span class="p_chunk">@@ -925,7 +924,7 @@</span> <span class="p_context"> static enum si_sm_result smi_event_handler(struct smi_info *smi_info,</span>
 		 * disable and messages disabled.
 		 */
 		if (smi_info-&gt;supports_event_msg_buff || smi_info-&gt;irq) {
<span class="p_del">-			start_check_enables(smi_info, true);</span>
<span class="p_add">+			start_check_enables(smi_info);</span>
 		} else {
 			smi_info-&gt;curr_msg = alloc_msg_handle_irq(smi_info);
 			if (!smi_info-&gt;curr_msg)
<span class="p_chunk">@@ -1232,6 +1231,7 @@</span> <span class="p_context"> static int smi_start_processing(void       *send_info,</span>
 
 	/* Set up the timer that drives the interface. */
 	setup_timer(&amp;new_smi-&gt;si_timer, smi_timeout, (long)new_smi);
<span class="p_add">+	new_smi-&gt;timer_can_start = true;</span>
 	smi_mod_timer(new_smi, jiffies + SI_TIMEOUT_JIFFIES);
 
 	/* Try to claim any interrupts. */
<span class="p_chunk">@@ -3434,10 +3434,12 @@</span> <span class="p_context"> static void check_for_broken_irqs(struct smi_info *smi_info)</span>
 	check_set_rcv_irq(smi_info);
 }
 
<span class="p_del">-static inline void wait_for_timer_and_thread(struct smi_info *smi_info)</span>
<span class="p_add">+static inline void stop_timer_and_thread(struct smi_info *smi_info)</span>
 {
 	if (smi_info-&gt;thread != NULL)
 		kthread_stop(smi_info-&gt;thread);
<span class="p_add">+</span>
<span class="p_add">+	smi_info-&gt;timer_can_start = false;</span>
 	if (smi_info-&gt;timer_running)
 		del_timer_sync(&amp;smi_info-&gt;si_timer);
 }
<span class="p_chunk">@@ -3635,7 +3637,7 @@</span> <span class="p_context"> static int try_smi_init(struct smi_info *new_smi)</span>
 	 * Start clearing the flags before we enable interrupts or the
 	 * timer to avoid racing with the timer.
 	 */
<span class="p_del">-	start_clear_flags(new_smi, false);</span>
<span class="p_add">+	start_clear_flags(new_smi);</span>
 
 	/*
 	 * IRQ is defined to be set when non-zero.  req_events will
<span class="p_chunk">@@ -3713,7 +3715,7 @@</span> <span class="p_context"> static int try_smi_init(struct smi_info *new_smi)</span>
 	return 0;
 
  out_err_stop_timer:
<span class="p_del">-	wait_for_timer_and_thread(new_smi);</span>
<span class="p_add">+	stop_timer_and_thread(new_smi);</span>
 
  out_err:
 	new_smi-&gt;interrupt_disabled = true;
<span class="p_chunk">@@ -3919,7 +3921,7 @@</span> <span class="p_context"> static void cleanup_one_si(struct smi_info *to_clean)</span>
 	 */
 	if (to_clean-&gt;irq_cleanup)
 		to_clean-&gt;irq_cleanup(to_clean);
<span class="p_del">-	wait_for_timer_and_thread(to_clean);</span>
<span class="p_add">+	stop_timer_and_thread(to_clean);</span>
 
 	/*
 	 * Timeouts are stopped, now make sure the interrupts are off
<span class="p_chunk">@@ -3930,7 +3932,7 @@</span> <span class="p_context"> static void cleanup_one_si(struct smi_info *to_clean)</span>
 		poll(to_clean);
 		schedule_timeout_uninterruptible(1);
 	}
<span class="p_del">-	disable_si_irq(to_clean, false);</span>
<span class="p_add">+	disable_si_irq(to_clean);</span>
 	while (to_clean-&gt;curr_msg || (to_clean-&gt;si_state != SI_NORMAL)) {
 		poll(to_clean);
 		schedule_timeout_uninterruptible(1);
<span class="p_header">diff --git a/drivers/crypto/s5p-sss.c b/drivers/crypto/s5p-sss.c</span>
<span class="p_header">index f214a8755827..fd39893079d5 100644</span>
<span class="p_header">--- a/drivers/crypto/s5p-sss.c</span>
<span class="p_header">+++ b/drivers/crypto/s5p-sss.c</span>
<span class="p_chunk">@@ -664,8 +664,9 @@</span> <span class="p_context"> static int s5p_aes_probe(struct platform_device *pdev)</span>
 		dev_warn(dev, &quot;feed control interrupt is not available.\n&quot;);
 		goto err_irq;
 	}
<span class="p_del">-	err = devm_request_irq(dev, pdata-&gt;irq_fc, s5p_aes_interrupt,</span>
<span class="p_del">-			       IRQF_SHARED, pdev-&gt;name, pdev);</span>
<span class="p_add">+	err = devm_request_threaded_irq(dev, pdata-&gt;irq_fc, NULL,</span>
<span class="p_add">+					s5p_aes_interrupt, IRQF_ONESHOT,</span>
<span class="p_add">+					pdev-&gt;name, pdev);</span>
 	if (err &lt; 0) {
 		dev_warn(dev, &quot;feed control interrupt is not available.\n&quot;);
 		goto err_irq;
<span class="p_header">diff --git a/drivers/edac/i5000_edac.c b/drivers/edac/i5000_edac.c</span>
<span class="p_header">index 72e07e3cf718..16e0eb523439 100644</span>
<span class="p_header">--- a/drivers/edac/i5000_edac.c</span>
<span class="p_header">+++ b/drivers/edac/i5000_edac.c</span>
<span class="p_chunk">@@ -227,7 +227,7 @@</span> <span class="p_context"></span>
 #define			NREC_RDWR(x)		(((x)&gt;&gt;11) &amp; 1)
 #define			NREC_RANK(x)		(((x)&gt;&gt;8) &amp; 0x7)
 #define		NRECMEMB		0xC0
<span class="p_del">-#define			NREC_CAS(x)		(((x)&gt;&gt;16) &amp; 0xFFFFFF)</span>
<span class="p_add">+#define			NREC_CAS(x)		(((x)&gt;&gt;16) &amp; 0xFFF)</span>
 #define			NREC_RAS(x)		((x) &amp; 0x7FFF)
 #define		NRECFGLOG		0xC4
 #define		NREEECFBDA		0xC8
<span class="p_chunk">@@ -371,7 +371,7 @@</span> <span class="p_context"> struct i5000_error_info {</span>
 	/* These registers are input ONLY if there was a
 	 * Non-Recoverable Error */
 	u16 nrecmema;		/* Non-Recoverable Mem log A */
<span class="p_del">-	u16 nrecmemb;		/* Non-Recoverable Mem log B */</span>
<span class="p_add">+	u32 nrecmemb;		/* Non-Recoverable Mem log B */</span>
 
 };
 
<span class="p_chunk">@@ -407,7 +407,7 @@</span> <span class="p_context"> static void i5000_get_error_info(struct mem_ctl_info *mci,</span>
 				NERR_FAT_FBD, &amp;info-&gt;nerr_fat_fbd);
 		pci_read_config_word(pvt-&gt;branchmap_werrors,
 				NRECMEMA, &amp;info-&gt;nrecmema);
<span class="p_del">-		pci_read_config_word(pvt-&gt;branchmap_werrors,</span>
<span class="p_add">+		pci_read_config_dword(pvt-&gt;branchmap_werrors,</span>
 				NRECMEMB, &amp;info-&gt;nrecmemb);
 
 		/* Clear the error bits, by writing them back */
<span class="p_chunk">@@ -1293,7 +1293,7 @@</span> <span class="p_context"> static int i5000_init_csrows(struct mem_ctl_info *mci)</span>
 			dimm-&gt;mtype = MEM_FB_DDR2;
 
 			/* ask what device type on this row */
<span class="p_del">-			if (MTR_DRAM_WIDTH(mtr))</span>
<span class="p_add">+			if (MTR_DRAM_WIDTH(mtr) == 8)</span>
 				dimm-&gt;dtype = DEV_X8;
 			else
 				dimm-&gt;dtype = DEV_X4;
<span class="p_header">diff --git a/drivers/edac/i5400_edac.c b/drivers/edac/i5400_edac.c</span>
<span class="p_header">index 6ef6ad1ba16e..2ea2f32e608b 100644</span>
<span class="p_header">--- a/drivers/edac/i5400_edac.c</span>
<span class="p_header">+++ b/drivers/edac/i5400_edac.c</span>
<span class="p_chunk">@@ -368,7 +368,7 @@</span> <span class="p_context"> struct i5400_error_info {</span>
 
 	/* These registers are input ONLY if there was a Non-Rec Error */
 	u16 nrecmema;		/* Non-Recoverable Mem log A */
<span class="p_del">-	u16 nrecmemb;		/* Non-Recoverable Mem log B */</span>
<span class="p_add">+	u32 nrecmemb;		/* Non-Recoverable Mem log B */</span>
 
 };
 
<span class="p_chunk">@@ -458,7 +458,7 @@</span> <span class="p_context"> static void i5400_get_error_info(struct mem_ctl_info *mci,</span>
 				NERR_FAT_FBD, &amp;info-&gt;nerr_fat_fbd);
 		pci_read_config_word(pvt-&gt;branchmap_werrors,
 				NRECMEMA, &amp;info-&gt;nrecmema);
<span class="p_del">-		pci_read_config_word(pvt-&gt;branchmap_werrors,</span>
<span class="p_add">+		pci_read_config_dword(pvt-&gt;branchmap_werrors,</span>
 				NRECMEMB, &amp;info-&gt;nrecmemb);
 
 		/* Clear the error bits, by writing them back */
<span class="p_chunk">@@ -1207,13 +1207,14 @@</span> <span class="p_context"> static int i5400_init_dimms(struct mem_ctl_info *mci)</span>
 
 			dimm-&gt;nr_pages = size_mb &lt;&lt; 8;
 			dimm-&gt;grain = 8;
<span class="p_del">-			dimm-&gt;dtype = MTR_DRAM_WIDTH(mtr) ? DEV_X8 : DEV_X4;</span>
<span class="p_add">+			dimm-&gt;dtype = MTR_DRAM_WIDTH(mtr) == 8 ?</span>
<span class="p_add">+				      DEV_X8 : DEV_X4;</span>
 			dimm-&gt;mtype = MEM_FB_DDR2;
 			/*
 			 * The eccc mechanism is SDDC (aka SECC), with
 			 * is similar to Chipkill.
 			 */
<span class="p_del">-			dimm-&gt;edac_mode = MTR_DRAM_WIDTH(mtr) ?</span>
<span class="p_add">+			dimm-&gt;edac_mode = MTR_DRAM_WIDTH(mtr) == 8 ?</span>
 					  EDAC_S8ECD8ED : EDAC_S4ECD4ED;
 			ndimms++;
 		}
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index 0cd8f039602e..78fe416126d1 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -113,8 +113,7 @@</span> <span class="p_context"> static ssize_t systab_show(struct kobject *kobj,</span>
 	return str - buf;
 }
 
<span class="p_del">-static struct kobj_attribute efi_attr_systab =</span>
<span class="p_del">-			__ATTR(systab, 0400, systab_show, NULL);</span>
<span class="p_add">+static struct kobj_attribute efi_attr_systab = __ATTR_RO_MODE(systab, 0400);</span>
 
 #define EFI_FIELD(var) efi.var
 
<span class="p_header">diff --git a/drivers/firmware/efi/esrt.c b/drivers/firmware/efi/esrt.c</span>
<span class="p_header">index 22c5285f7705..0ca4c34f9441 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/esrt.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/esrt.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static const struct sysfs_ops esre_attr_ops = {</span>
 };
 
 /* Generic ESRT Entry (&quot;ESRE&quot;) support. */
<span class="p_del">-static ssize_t esre_fw_class_show(struct esre_entry *entry, char *buf)</span>
<span class="p_add">+static ssize_t fw_class_show(struct esre_entry *entry, char *buf)</span>
 {
 	char *str = buf;
 
<span class="p_chunk">@@ -116,18 +116,16 @@</span> <span class="p_context"> static ssize_t esre_fw_class_show(struct esre_entry *entry, char *buf)</span>
 	return str - buf;
 }
 
<span class="p_del">-static struct esre_attribute esre_fw_class = __ATTR(fw_class, 0400,</span>
<span class="p_del">-	esre_fw_class_show, NULL);</span>
<span class="p_add">+static struct esre_attribute esre_fw_class = __ATTR_RO_MODE(fw_class, 0400);</span>
 
 #define esre_attr_decl(name, size, fmt) \
<span class="p_del">-static ssize_t esre_##name##_show(struct esre_entry *entry, char *buf) \</span>
<span class="p_add">+static ssize_t name##_show(struct esre_entry *entry, char *buf) \</span>
 { \
 	return sprintf(buf, fmt &quot;\n&quot;, \
 		       le##size##_to_cpu(entry-&gt;esre.esre1-&gt;name)); \
 } \
 \
<span class="p_del">-static struct esre_attribute esre_##name = __ATTR(name, 0400, \</span>
<span class="p_del">-	esre_##name##_show, NULL)</span>
<span class="p_add">+static struct esre_attribute esre_##name = __ATTR_RO_MODE(name, 0400)</span>
 
 esre_attr_decl(fw_type, 32, &quot;%u&quot;);
 esre_attr_decl(fw_version, 32, &quot;%u&quot;);
<span class="p_chunk">@@ -195,14 +193,13 @@</span> <span class="p_context"> static int esre_create_sysfs_entry(void *esre, int entry_num)</span>
 
 /* support for displaying ESRT fields at the top level */
 #define esrt_attr_decl(name, size, fmt) \
<span class="p_del">-static ssize_t esrt_##name##_show(struct kobject *kobj, \</span>
<span class="p_add">+static ssize_t name##_show(struct kobject *kobj, \</span>
 				  struct kobj_attribute *attr, char *buf)\
 { \
 	return sprintf(buf, fmt &quot;\n&quot;, le##size##_to_cpu(esrt-&gt;name)); \
 } \
 \
<span class="p_del">-static struct kobj_attribute esrt_##name = __ATTR(name, 0400, \</span>
<span class="p_del">-	esrt_##name##_show, NULL)</span>
<span class="p_add">+static struct kobj_attribute esrt_##name = __ATTR_RO_MODE(name, 0400)</span>
 
 esrt_attr_decl(fw_resource_count, 32, &quot;%u&quot;);
 esrt_attr_decl(fw_resource_count_max, 32, &quot;%u&quot;);
<span class="p_header">diff --git a/drivers/firmware/efi/runtime-map.c b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">index 5c55227a34c8..2400b3e1d840 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_chunk">@@ -67,11 +67,11 @@</span> <span class="p_context"> static ssize_t map_attr_show(struct kobject *kobj, struct attribute *attr,</span>
 	return map_attr-&gt;show(entry, buf);
 }
 
<span class="p_del">-static struct map_attribute map_type_attr = __ATTR_RO(type);</span>
<span class="p_del">-static struct map_attribute map_phys_addr_attr   = __ATTR_RO(phys_addr);</span>
<span class="p_del">-static struct map_attribute map_virt_addr_attr  = __ATTR_RO(virt_addr);</span>
<span class="p_del">-static struct map_attribute map_num_pages_attr  = __ATTR_RO(num_pages);</span>
<span class="p_del">-static struct map_attribute map_attribute_attr  = __ATTR_RO(attribute);</span>
<span class="p_add">+static struct map_attribute map_type_attr = __ATTR_RO_MODE(type, 0400);</span>
<span class="p_add">+static struct map_attribute map_phys_addr_attr = __ATTR_RO_MODE(phys_addr, 0400);</span>
<span class="p_add">+static struct map_attribute map_virt_addr_attr = __ATTR_RO_MODE(virt_addr, 0400);</span>
<span class="p_add">+static struct map_attribute map_num_pages_attr = __ATTR_RO_MODE(num_pages, 0400);</span>
<span class="p_add">+static struct map_attribute map_attribute_attr = __ATTR_RO_MODE(attribute, 0400);</span>
 
 /*
  * These are default attributes that are added for every memmap entry.
<span class="p_header">diff --git a/drivers/gpio/gpio-altera.c b/drivers/gpio/gpio-altera.c</span>
<span class="p_header">index 3e6661bab54a..ddf9cd3ad974 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-altera.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-altera.c</span>
<span class="p_chunk">@@ -94,21 +94,18 @@</span> <span class="p_context"> static int altera_gpio_irq_set_type(struct irq_data *d,</span>
 
 	altera_gc = to_altera(irq_data_get_irq_chip_data(d));
 
<span class="p_del">-	if (type == IRQ_TYPE_NONE)</span>
<span class="p_add">+	if (type == IRQ_TYPE_NONE) {</span>
<span class="p_add">+		irq_set_handler_locked(d, handle_bad_irq);</span>
 		return 0;
<span class="p_del">-	if (type == IRQ_TYPE_LEVEL_HIGH &amp;&amp;</span>
<span class="p_del">-		altera_gc-&gt;interrupt_trigger == IRQ_TYPE_LEVEL_HIGH)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (type == IRQ_TYPE_EDGE_RISING &amp;&amp;</span>
<span class="p_del">-		altera_gc-&gt;interrupt_trigger == IRQ_TYPE_EDGE_RISING)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (type == IRQ_TYPE_EDGE_FALLING &amp;&amp;</span>
<span class="p_del">-		altera_gc-&gt;interrupt_trigger == IRQ_TYPE_EDGE_FALLING)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (type == IRQ_TYPE_EDGE_BOTH &amp;&amp;</span>
<span class="p_del">-		altera_gc-&gt;interrupt_trigger == IRQ_TYPE_EDGE_BOTH)</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (type == altera_gc-&gt;interrupt_trigger) {</span>
<span class="p_add">+		if (type == IRQ_TYPE_LEVEL_HIGH)</span>
<span class="p_add">+			irq_set_handler_locked(d, handle_level_irq);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			irq_set_handler_locked(d, handle_simple_irq);</span>
 		return 0;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
<span class="p_add">+	irq_set_handler_locked(d, handle_bad_irq);</span>
 	return -EINVAL;
 }
 
<span class="p_chunk">@@ -234,7 +231,6 @@</span> <span class="p_context"> static void altera_gpio_irq_edge_handler(struct irq_desc *desc)</span>
 	chained_irq_exit(chip, desc);
 }
 
<span class="p_del">-</span>
 static void altera_gpio_irq_leveL_high_handler(struct irq_desc *desc)
 {
 	struct altera_gpio_chip *altera_gc;
<span class="p_chunk">@@ -314,7 +310,7 @@</span> <span class="p_context"> static int altera_gpio_probe(struct platform_device *pdev)</span>
 	altera_gc-&gt;interrupt_trigger = reg;
 
 	ret = gpiochip_irqchip_add(&amp;altera_gc-&gt;mmchip.gc, &amp;altera_irq_chip, 0,
<span class="p_del">-		handle_simple_irq, IRQ_TYPE_NONE);</span>
<span class="p_add">+		handle_bad_irq, IRQ_TYPE_NONE);</span>
 
 	if (ret) {
 		dev_info(&amp;pdev-&gt;dev, &quot;could not add irqchip\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">index 16302f7d59f6..fc9f14747f70 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_chunk">@@ -1760,8 +1760,11 @@</span> <span class="p_context"> int amdgpu_resume_kms(struct drm_device *dev, bool resume, bool fbcon)</span>
 	}
 
 	r = amdgpu_late_init(adev);
<span class="p_del">-	if (r)</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		if (fbcon)</span>
<span class="p_add">+			console_unlock();</span>
 		return r;
<span class="p_add">+	}</span>
 
 	/* pin cursors */
 	list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
<span class="p_header">diff --git a/drivers/gpu/drm/armada/Makefile b/drivers/gpu/drm/armada/Makefile</span>
<span class="p_header">index 26412d2f8c98..ffd673615772 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/armada/Makefile</span>
<span class="p_header">+++ b/drivers/gpu/drm/armada/Makefile</span>
<span class="p_chunk">@@ -4,5 +4,3 @@</span> <span class="p_context"> armada-y	+= armada_510.o</span>
 armada-$(CONFIG_DEBUG_FS) += armada_debugfs.o
 
 obj-$(CONFIG_DRM_ARMADA) := armada.o
<span class="p_del">-</span>
<span class="p_del">-CFLAGS_armada_trace.o := -I$(src)</span>
<span class="p_header">diff --git a/drivers/gpu/drm/exynos/exynos_drm_gem.c b/drivers/gpu/drm/exynos/exynos_drm_gem.c</span>
<span class="p_header">index 252eb301470c..c147043af1ca 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/exynos/exynos_drm_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/exynos/exynos_drm_gem.c</span>
<span class="p_chunk">@@ -245,6 +245,15 @@</span> <span class="p_context"> struct exynos_drm_gem *exynos_drm_gem_create(struct drm_device *dev,</span>
 	if (IS_ERR(exynos_gem))
 		return exynos_gem;
 
<span class="p_add">+	if (!is_drm_iommu_supported(dev) &amp;&amp; (flags &amp; EXYNOS_BO_NONCONTIG)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * when no IOMMU is available, all allocated buffers are</span>
<span class="p_add">+		 * contiguous anyway, so drop EXYNOS_BO_NONCONTIG flag</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		flags &amp;= ~EXYNOS_BO_NONCONTIG;</span>
<span class="p_add">+		DRM_WARN(&quot;Non-contiguous allocation is not supported without IOMMU, falling back to contiguous buffer\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* set memory type and cache attribute from user side. */
 	exynos_gem-&gt;flags = flags;
 
<span class="p_header">diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig</span>
<span class="p_header">index 513a16cc6e18..2729ab3557bb 100644</span>
<span class="p_header">--- a/drivers/hid/Kconfig</span>
<span class="p_header">+++ b/drivers/hid/Kconfig</span>
<span class="p_chunk">@@ -165,11 +165,11 @@</span> <span class="p_context"> config HID_CHERRY</span>
 	Support for Cherry Cymotion keyboard.
 
 config HID_CHICONY
<span class="p_del">-	tristate &quot;Chicony Tactical pad&quot;</span>
<span class="p_add">+	tristate &quot;Chicony devices&quot;</span>
 	depends on HID
 	default !EXPERT
 	---help---
<span class="p_del">-	Support for Chicony Tactical pad.</span>
<span class="p_add">+	Support for Chicony Tactical pad and special keys on Chicony keyboards.</span>
 
 config HID_CORSAIR
 	tristate &quot;Corsair devices&quot;
<span class="p_header">diff --git a/drivers/hid/hid-chicony.c b/drivers/hid/hid-chicony.c</span>
<span class="p_header">index bc3cec199fee..f04ed9aabc3f 100644</span>
<span class="p_header">--- a/drivers/hid/hid-chicony.c</span>
<span class="p_header">+++ b/drivers/hid/hid-chicony.c</span>
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> static const struct hid_device_id ch_devices[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS2) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_AK1D) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_ACER_SWITCH12) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_JESS, USB_DEVICE_ID_JESS_ZEN_AIO_KBD) },</span>
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, ch_devices);
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index 11a051bd8a8b..1a1fc8351289 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -1867,6 +1867,7 @@</span> <span class="p_context"> static const struct hid_device_id hid_have_special_driver[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A081) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A0C2) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_HUION, USB_DEVICE_ID_HUION_TABLET) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_JESS, USB_DEVICE_ID_JESS_ZEN_AIO_KBD) },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_JESS2, USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD) },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ION, USB_DEVICE_ID_ICADE) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_KENSINGTON, USB_DEVICE_ID_KS_SLIMBLADE) },
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index 37cbc2ecfc5f..6937086060a6 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -523,6 +523,7 @@</span> <span class="p_context"></span>
 
 #define USB_VENDOR_ID_JESS		0x0c45
 #define USB_DEVICE_ID_JESS_YUREX	0x1010
<span class="p_add">+#define USB_DEVICE_ID_JESS_ZEN_AIO_KBD	0x5112</span>
 
 #define USB_VENDOR_ID_JESS2		0x0f30
 #define USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD 0x0111
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-riic.c b/drivers/i2c/busses/i2c-riic.c</span>
<span class="p_header">index d8803c3bbfdc..16833365475f 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-riic.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-riic.c</span>
<span class="p_chunk">@@ -218,8 +218,12 @@</span> <span class="p_context"> static irqreturn_t riic_tend_isr(int irq, void *data)</span>
 	}
 
 	if (riic-&gt;is_last || riic-&gt;err) {
<span class="p_del">-		riic_clear_set_bit(riic, 0, ICIER_SPIE, RIIC_ICIER);</span>
<span class="p_add">+		riic_clear_set_bit(riic, ICIER_TEIE, ICIER_SPIE, RIIC_ICIER);</span>
 		writeb(ICCR2_SP, riic-&gt;base + RIIC_ICCR2);
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Transfer is complete, but do not send STOP */</span>
<span class="p_add">+		riic_clear_set_bit(riic, ICIER_TEIE, 0, RIIC_ICIER);</span>
<span class="p_add">+		complete(&amp;riic-&gt;msg_done);</span>
 	}
 
 	return IRQ_HANDLED;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 1c8b7c22c822..348828271cb0 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -1564,7 +1564,7 @@</span> <span class="p_context"> static int __mlx4_ib_modify_qp(struct ib_qp *ibqp,</span>
 			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) |
 					      ilog2(dev-&gt;dev-&gt;caps.max_gso_sz);
 		else
<span class="p_del">-			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) | 12;</span>
<span class="p_add">+			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) | 13;</span>
 	} else if (attr_mask &amp; IB_QP_PATH_MTU) {
 		if (attr-&gt;path_mtu &lt; IB_MTU_256 || attr-&gt;path_mtu &gt; IB_MTU_4096) {
 			pr_err(&quot;path MTU (%u) is invalid\n&quot;,
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index 2a1fdcaa3044..dbd5adc62c3f 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -1123,6 +1123,8 @@</span> <span class="p_context"> static int create_umr_res(struct mlx5_ib_dev *dev)</span>
 	qp-&gt;real_qp    = qp;
 	qp-&gt;uobject    = NULL;
 	qp-&gt;qp_type    = MLX5_IB_QPT_REG_UMR;
<span class="p_add">+	qp-&gt;send_cq    = init_attr-&gt;send_cq;</span>
<span class="p_add">+	qp-&gt;recv_cq    = init_attr-&gt;recv_cq;</span>
 
 	attr-&gt;qp_state = IB_QPS_INIT;
 	attr-&gt;port_num = 1;
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index f9711aceef54..4efec2db4ee2 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -2201,10 +2201,12 @@</span> <span class="p_context"> static int __domain_mapping(struct dmar_domain *domain, unsigned long iov_pfn,</span>
 		uint64_t tmp;
 
 		if (!sg_res) {
<span class="p_add">+			unsigned int pgoff = sg-&gt;offset &amp; ~PAGE_MASK;</span>
<span class="p_add">+</span>
 			sg_res = aligned_nrpages(sg-&gt;offset, sg-&gt;length);
<span class="p_del">-			sg-&gt;dma_address = ((dma_addr_t)iov_pfn &lt;&lt; VTD_PAGE_SHIFT) + sg-&gt;offset;</span>
<span class="p_add">+			sg-&gt;dma_address = ((dma_addr_t)iov_pfn &lt;&lt; VTD_PAGE_SHIFT) + pgoff;</span>
 			sg-&gt;dma_length = sg-&gt;length;
<span class="p_del">-			pteval = page_to_phys(sg_page(sg)) | prot;</span>
<span class="p_add">+			pteval = (sg_phys(sg) - pgoff) | prot;</span>
 			phys_pfn = pteval &gt;&gt; VTD_PAGE_SHIFT;
 		}
 
<span class="p_chunk">@@ -3757,7 +3759,7 @@</span> <span class="p_context"> static int intel_nontranslate_map_sg(struct device *hddev,</span>
 
 	for_each_sg(sglist, sg, nelems, i) {
 		BUG_ON(!sg_page(sg));
<span class="p_del">-		sg-&gt;dma_address = page_to_phys(sg_page(sg)) + sg-&gt;offset;</span>
<span class="p_add">+		sg-&gt;dma_address = sg_phys(sg);</span>
 		sg-&gt;dma_length = sg-&gt;length;
 	}
 	return nelems;
<span class="p_header">diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c</span>
<span class="p_header">index 63faee04a008..636187a4c1a3 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-crossbar.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-crossbar.c</span>
<span class="p_chunk">@@ -199,7 +199,7 @@</span> <span class="p_context"> static const struct irq_domain_ops crossbar_domain_ops = {</span>
 static int __init crossbar_of_init(struct device_node *node)
 {
 	int i, size, reserved = 0;
<span class="p_del">-	u32 max = 0, entry;</span>
<span class="p_add">+	u32 max = 0, entry, reg_size;</span>
 	const __be32 *irqsr;
 	int ret = -ENOMEM;
 
<span class="p_chunk">@@ -276,9 +276,9 @@</span> <span class="p_context"> static int __init crossbar_of_init(struct device_node *node)</span>
 	if (!cb-&gt;register_offsets)
 		goto err_irq_map;
 
<span class="p_del">-	of_property_read_u32(node, &quot;ti,reg-size&quot;, &amp;size);</span>
<span class="p_add">+	of_property_read_u32(node, &quot;ti,reg-size&quot;, &amp;reg_size);</span>
 
<span class="p_del">-	switch (size) {</span>
<span class="p_add">+	switch (reg_size) {</span>
 	case 1:
 		cb-&gt;write = crossbar_writeb;
 		break;
<span class="p_chunk">@@ -304,7 +304,7 @@</span> <span class="p_context"> static int __init crossbar_of_init(struct device_node *node)</span>
 			continue;
 
 		cb-&gt;register_offsets[i] = reserved;
<span class="p_del">-		reserved += size;</span>
<span class="p_add">+		reserved += reg_size;</span>
 	}
 
 	of_property_read_u32(node, &quot;ti,irqs-safe-map&quot;, &amp;cb-&gt;safe_map);
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dibusb-common.c b/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_header">index ef3a8f75f82e..7b15aea2723d 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_chunk">@@ -179,8 +179,20 @@</span> <span class="p_context"> EXPORT_SYMBOL(dibusb_i2c_algo);</span>
 
 int dibusb_read_eeprom_byte(struct dvb_usb_device *d, u8 offs, u8 *val)
 {
<span class="p_del">-	u8 wbuf[1] = { offs };</span>
<span class="p_del">-	return dibusb_i2c_msg(d, 0x50, wbuf, 1, val, 1);</span>
<span class="p_add">+	u8 *buf;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = kmalloc(2, GFP_KERNEL);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf[0] = offs;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = dibusb_i2c_msg(d, 0x50, &amp;buf[0], 1, &amp;buf[1], 1);</span>
<span class="p_add">+	*val = buf[1];</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
 }
 EXPORT_SYMBOL(dibusb_read_eeprom_byte);
 
<span class="p_header">diff --git a/drivers/memory/omap-gpmc.c b/drivers/memory/omap-gpmc.c</span>
<span class="p_header">index 55cba89dbdb8..49691a8c74ee 100644</span>
<span class="p_header">--- a/drivers/memory/omap-gpmc.c</span>
<span class="p_header">+++ b/drivers/memory/omap-gpmc.c</span>
<span class="p_chunk">@@ -1890,9 +1890,7 @@</span> <span class="p_context"> static int gpmc_probe_onenand_child(struct platform_device *pdev,</span>
 	if (!of_property_read_u32(child, &quot;dma-channel&quot;, &amp;val))
 		gpmc_onenand_data-&gt;dma_channel = val;
 
<span class="p_del">-	gpmc_onenand_init(gpmc_onenand_data);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return gpmc_onenand_init(gpmc_onenand_data);</span>
 }
 #else
 static int gpmc_probe_onenand_child(struct platform_device *pdev,
<span class="p_header">diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c</span>
<span class="p_header">index 6749b1829469..4d01d7bc24ef 100644</span>
<span class="p_header">--- a/drivers/net/can/ti_hecc.c</span>
<span class="p_header">+++ b/drivers/net/can/ti_hecc.c</span>
<span class="p_chunk">@@ -652,6 +652,9 @@</span> <span class="p_context"> static int ti_hecc_rx_poll(struct napi_struct *napi, int quota)</span>
 		mbx_mask = hecc_read(priv, HECC_CANMIM);
 		mbx_mask |= HECC_TX_MBOX_MASK;
 		hecc_write(priv, HECC_CANMIM, mbx_mask);
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* repoll is done only if whole budget is used */</span>
<span class="p_add">+		num_pkts = quota;</span>
 	}
 
 	return num_pkts;
<span class="p_header">diff --git a/drivers/net/can/usb/ems_usb.c b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">index eb7192fab593..357c9e89fdf9 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_chunk">@@ -290,6 +290,8 @@</span> <span class="p_context"> static void ems_usb_read_interrupt_callback(struct urb *urb)</span>
 
 	case -ECONNRESET: /* unlink */
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/can/usb/esd_usb2.c b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">index 4c6707ecc619..afa5b4a7a4a2 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_chunk">@@ -393,6 +393,8 @@</span> <span class="p_context"> static void esd_usb2_read_bulk_callback(struct urb *urb)</span>
 		break;
 
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/can/usb/kvaser_usb.c b/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_header">index c2e2821a3346..db1855b0e08f 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_chunk">@@ -603,8 +603,8 @@</span> <span class="p_context"> static int kvaser_usb_wait_msg(const struct kvaser_usb *dev, u8 id,</span>
 			}
 
 			if (pos + tmp-&gt;len &gt; actual_len) {
<span class="p_del">-				dev_err(dev-&gt;udev-&gt;dev.parent,</span>
<span class="p_del">-					&quot;Format error\n&quot;);</span>
<span class="p_add">+				dev_err_ratelimited(dev-&gt;udev-&gt;dev.parent,</span>
<span class="p_add">+						    &quot;Format error\n&quot;);</span>
 				break;
 			}
 
<span class="p_chunk">@@ -809,6 +809,7 @@</span> <span class="p_context"> static int kvaser_usb_simple_msg_async(struct kvaser_usb_net_priv *priv,</span>
 	if (err) {
 		netdev_err(netdev, &quot;Error transmitting URB\n&quot;);
 		usb_unanchor_urb(urb);
<span class="p_add">+		kfree(buf);</span>
 		usb_free_urb(urb);
 		return err;
 	}
<span class="p_chunk">@@ -1321,6 +1322,8 @@</span> <span class="p_context"> static void kvaser_usb_read_bulk_callback(struct urb *urb)</span>
 	case 0:
 		break;
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 	default:
<span class="p_chunk">@@ -1329,7 +1332,7 @@</span> <span class="p_context"> static void kvaser_usb_read_bulk_callback(struct urb *urb)</span>
 		goto resubmit_urb;
 	}
 
<span class="p_del">-	while (pos &lt;= urb-&gt;actual_length - MSG_HEADER_LEN) {</span>
<span class="p_add">+	while (pos &lt;= (int)(urb-&gt;actual_length - MSG_HEADER_LEN)) {</span>
 		msg = urb-&gt;transfer_buffer + pos;
 
 		/* The Kvaser firmware can only read and write messages that
<span class="p_chunk">@@ -1348,7 +1351,8 @@</span> <span class="p_context"> static void kvaser_usb_read_bulk_callback(struct urb *urb)</span>
 		}
 
 		if (pos + msg-&gt;len &gt; urb-&gt;actual_length) {
<span class="p_del">-			dev_err(dev-&gt;udev-&gt;dev.parent, &quot;Format error\n&quot;);</span>
<span class="p_add">+			dev_err_ratelimited(dev-&gt;udev-&gt;dev.parent,</span>
<span class="p_add">+					    &quot;Format error\n&quot;);</span>
 			break;
 		}
 
<span class="p_chunk">@@ -1767,6 +1771,7 @@</span> <span class="p_context"> static netdev_tx_t kvaser_usb_start_xmit(struct sk_buff *skb,</span>
 		spin_unlock_irqrestore(&amp;priv-&gt;tx_contexts_lock, flags);
 
 		usb_unanchor_urb(urb);
<span class="p_add">+		kfree(buf);</span>
 
 		stats-&gt;tx_dropped++;
 
<span class="p_header">diff --git a/drivers/net/can/usb/usb_8dev.c b/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_header">index 449b2a47f9a8..522286cc0f9c 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_chunk">@@ -524,6 +524,8 @@</span> <span class="p_context"> static void usb_8dev_read_bulk_callback(struct urb *urb)</span>
 		break;
 
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">index 1c8123816745..abb3ff6498dc 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_chunk">@@ -13646,7 +13646,7 @@</span> <span class="p_context"> static int bnx2x_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)</span>
 	if (!netif_running(bp-&gt;dev)) {
 		DP(BNX2X_MSG_PTP,
 		   &quot;PTP adjfreq called while the interface is down\n&quot;);
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+		return -ENETDOWN;</span>
 	}
 
 	if (ppb &lt; 0) {
<span class="p_chunk">@@ -13705,6 +13705,12 @@</span> <span class="p_context"> static int bnx2x_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)</span>
 {
 	struct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);
 
<span class="p_add">+	if (!netif_running(bp-&gt;dev)) {</span>
<span class="p_add">+		DP(BNX2X_MSG_PTP,</span>
<span class="p_add">+		   &quot;PTP adjtime called while the interface is down\n&quot;);</span>
<span class="p_add">+		return -ENETDOWN;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	DP(BNX2X_MSG_PTP, &quot;PTP adjtime called, delta = %llx\n&quot;, delta);
 
 	timecounter_adjtime(&amp;bp-&gt;timecounter, delta);
<span class="p_chunk">@@ -13717,6 +13723,12 @@</span> <span class="p_context"> static int bnx2x_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)</span>
 	struct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);
 	u64 ns;
 
<span class="p_add">+	if (!netif_running(bp-&gt;dev)) {</span>
<span class="p_add">+		DP(BNX2X_MSG_PTP,</span>
<span class="p_add">+		   &quot;PTP gettime called while the interface is down\n&quot;);</span>
<span class="p_add">+		return -ENETDOWN;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ns = timecounter_read(&amp;bp-&gt;timecounter);
 
 	DP(BNX2X_MSG_PTP, &quot;PTP gettime called, ns = %llu\n&quot;, ns);
<span class="p_chunk">@@ -13732,6 +13744,12 @@</span> <span class="p_context"> static int bnx2x_ptp_settime(struct ptp_clock_info *ptp,</span>
 	struct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);
 	u64 ns;
 
<span class="p_add">+	if (!netif_running(bp-&gt;dev)) {</span>
<span class="p_add">+		DP(BNX2X_MSG_PTP,</span>
<span class="p_add">+		   &quot;PTP settime called while the interface is down\n&quot;);</span>
<span class="p_add">+		return -ENETDOWN;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ns = timespec64_to_ns(ts);
 
 	DP(BNX2X_MSG_PTP, &quot;PTP settime called, ns = %llu\n&quot;, ns);
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c</span>
<span class="p_header">index 9d027348cd09..5780830f78ad 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c</span>
<span class="p_chunk">@@ -434,7 +434,9 @@</span> <span class="p_context"> static int bnx2x_vf_mac_vlan_config(struct bnx2x *bp,</span>
 
 	/* Add/Remove the filter */
 	rc = bnx2x_config_vlan_mac(bp, &amp;ramrod);
<span class="p_del">-	if (rc &amp;&amp; rc != -EEXIST) {</span>
<span class="p_add">+	if (rc == -EEXIST)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (rc) {</span>
 		BNX2X_ERR(&quot;Failed to %s %s\n&quot;,
 			  filter-&gt;add ? &quot;add&quot; : &quot;delete&quot;,
 			  (filter-&gt;type == BNX2X_VF_FILTER_VLAN_MAC) ?
<span class="p_chunk">@@ -444,6 +446,8 @@</span> <span class="p_context"> static int bnx2x_vf_mac_vlan_config(struct bnx2x *bp,</span>
 		return rc;
 	}
 
<span class="p_add">+	filter-&gt;applied = true;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -471,6 +475,8 @@</span> <span class="p_context"> int bnx2x_vf_mac_vlan_config_list(struct bnx2x *bp, struct bnx2x_virtf *vf,</span>
 		BNX2X_ERR(&quot;Managed only %d/%d filters - rolling back\n&quot;,
 			  i, filters-&gt;count + 1);
 		while (--i &gt;= 0) {
<span class="p_add">+			if (!filters-&gt;filters[i].applied)</span>
<span class="p_add">+				continue;</span>
 			filters-&gt;filters[i].add = !filters-&gt;filters[i].add;
 			bnx2x_vf_mac_vlan_config(bp, vf, qid,
 						 &amp;filters-&gt;filters[i],
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h</span>
<span class="p_header">index 670a581ffabc..6f6f13dc2be3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h</span>
<span class="p_chunk">@@ -114,6 +114,7 @@</span> <span class="p_context"> struct bnx2x_vf_mac_vlan_filter {</span>
 	(BNX2X_VF_FILTER_MAC | BNX2X_VF_FILTER_VLAN) /*shortcut*/
 
 	bool add;
<span class="p_add">+	bool applied;</span>
 	u8 *mac;
 	u16 vid;
 };
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c</span>
<span class="p_header">index 1374e5394a79..a12a4236b143 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c</span>
<span class="p_chunk">@@ -868,7 +868,7 @@</span> <span class="p_context"> int bnx2x_vfpf_set_mcast(struct net_device *dev)</span>
 	struct bnx2x *bp = netdev_priv(dev);
 	struct vfpf_set_q_filters_tlv *req = &amp;bp-&gt;vf2pf_mbox-&gt;req.set_q_filters;
 	struct pfvf_general_resp_tlv *resp = &amp;bp-&gt;vf2pf_mbox-&gt;resp.general_resp;
<span class="p_del">-	int rc, i = 0;</span>
<span class="p_add">+	int rc = 0, i = 0;</span>
 	struct netdev_hw_addr *ha;
 
 	if (bp-&gt;state != BNX2X_STATE_OPEN) {
<span class="p_chunk">@@ -883,6 +883,15 @@</span> <span class="p_context"> int bnx2x_vfpf_set_mcast(struct net_device *dev)</span>
 	/* Get Rx mode requested */
 	DP(NETIF_MSG_IFUP, &quot;dev-&gt;flags = %x\n&quot;, dev-&gt;flags);
 
<span class="p_add">+	/* We support PFVF_MAX_MULTICAST_PER_VF mcast addresses tops */</span>
<span class="p_add">+	if (netdev_mc_count(dev) &gt; PFVF_MAX_MULTICAST_PER_VF) {</span>
<span class="p_add">+		DP(NETIF_MSG_IFUP,</span>
<span class="p_add">+		   &quot;VF supports not more than %d multicast MAC addresses\n&quot;,</span>
<span class="p_add">+		   PFVF_MAX_MULTICAST_PER_VF);</span>
<span class="p_add">+		rc = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	netdev_for_each_mc_addr(ha, dev) {
 		DP(NETIF_MSG_IFUP, &quot;Adding mcast MAC: %pM\n&quot;,
 		   bnx2x_mc_addr(ha));
<span class="p_chunk">@@ -890,16 +899,6 @@</span> <span class="p_context"> int bnx2x_vfpf_set_mcast(struct net_device *dev)</span>
 		i++;
 	}
 
<span class="p_del">-	/* We support four PFVF_MAX_MULTICAST_PER_VF mcast</span>
<span class="p_del">-	  * addresses tops</span>
<span class="p_del">-	  */</span>
<span class="p_del">-	if (i &gt;= PFVF_MAX_MULTICAST_PER_VF) {</span>
<span class="p_del">-		DP(NETIF_MSG_IFUP,</span>
<span class="p_del">-		   &quot;VF supports not more than %d multicast MAC addresses\n&quot;,</span>
<span class="p_del">-		   PFVF_MAX_MULTICAST_PER_VF);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	req-&gt;n_multicast = i;
 	req-&gt;flags |= VFPF_SET_Q_FILTERS_MULTICAST_CHANGED;
 	req-&gt;vf_qid = 0;
<span class="p_chunk">@@ -924,7 +923,7 @@</span> <span class="p_context"> int bnx2x_vfpf_set_mcast(struct net_device *dev)</span>
 out:
 	bnx2x_vfpf_finalize(bp, &amp;req-&gt;first_tlv);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return rc;</span>
 }
 
 /* request pf to add a vlan for the vf */
<span class="p_header">diff --git a/drivers/net/ipvlan/ipvlan_core.c b/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_header">index 8c48bb2a94ea..af827faec7fe 100644</span>
<span class="p_header">--- a/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_header">+++ b/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static int ipvlan_process_v6_outbound(struct sk_buff *skb)</span>
 	struct dst_entry *dst;
 	int err, ret = NET_XMIT_DROP;
 	struct flowi6 fl6 = {
<span class="p_del">-		.flowi6_iif = dev-&gt;ifindex,</span>
<span class="p_add">+		.flowi6_oif = dev-&gt;ifindex,</span>
 		.daddr = ip6h-&gt;daddr,
 		.saddr = ip6h-&gt;saddr,
 		.flowi6_flags = FLOWI_FLAG_ANYSRC,
<span class="p_header">diff --git a/drivers/net/phy/spi_ks8995.c b/drivers/net/phy/spi_ks8995.c</span>
<span class="p_header">index c72c42206850..21d22f86134e 100644</span>
<span class="p_header">--- a/drivers/net/phy/spi_ks8995.c</span>
<span class="p_header">+++ b/drivers/net/phy/spi_ks8995.c</span>
<span class="p_chunk">@@ -310,6 +310,7 @@</span> <span class="p_context"> static int ks8995_probe(struct spi_device *spi)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	sysfs_attr_init(&amp;ks-&gt;regs_attr.attr);</span>
 	err = sysfs_create_bin_file(&amp;spi-&gt;dev.kobj, &amp;ks-&gt;regs_attr);
 	if (err) {
 		dev_err(&amp;spi-&gt;dev, &quot;unable to create sysfs file, err=%d\n&quot;,
<span class="p_header">diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">index 2a996a68fc2b..f877fbc7d7af 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_chunk">@@ -2885,6 +2885,7 @@</span> <span class="p_context"> static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)</span>
 {
 	struct hwsim_new_radio_params param = { 0 };
 	const char *hwname = NULL;
<span class="p_add">+	int ret;</span>
 
 	param.reg_strict = info-&gt;attrs[HWSIM_ATTR_REG_STRICT_REG];
 	param.p2p_device = info-&gt;attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];
<span class="p_chunk">@@ -2924,7 +2925,9 @@</span> <span class="p_context"> static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)</span>
 		param.regd = hwsim_world_regdom_custom[idx];
 	}
 
<span class="p_del">-	return mac80211_hwsim_new_radio(info, &amp;param);</span>
<span class="p_add">+	ret = mac80211_hwsim_new_radio(info, &amp;param);</span>
<span class="p_add">+	kfree(hwname);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int hwsim_del_radio_nl(struct sk_buff *msg, struct genl_info *info)
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">index d278362448ca..fc8f9b446556 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_chunk">@@ -7887,11 +7887,17 @@</span> <span class="p_context"> lpfc_cmpl_reg_new_vport(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)</span>
 			spin_lock_irq(shost-&gt;host_lock);
 			vport-&gt;fc_flag |= FC_VPORT_NEEDS_REG_VPI;
 			spin_unlock_irq(shost-&gt;host_lock);
<span class="p_del">-			if (vport-&gt;port_type == LPFC_PHYSICAL_PORT</span>
<span class="p_del">-				&amp;&amp; !(vport-&gt;fc_flag &amp; FC_LOGO_RCVD_DID_CHNG))</span>
<span class="p_del">-				lpfc_issue_init_vfi(vport);</span>
<span class="p_del">-			else</span>
<span class="p_add">+			if (mb-&gt;mbxStatus == MBX_NOT_FINISHED)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			if ((vport-&gt;port_type == LPFC_PHYSICAL_PORT) &amp;&amp;</span>
<span class="p_add">+			    !(vport-&gt;fc_flag &amp; FC_LOGO_RCVD_DID_CHNG)) {</span>
<span class="p_add">+				if (phba-&gt;sli_rev == LPFC_SLI_REV4)</span>
<span class="p_add">+					lpfc_issue_init_vfi(vport);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					lpfc_initial_flogi(vport);</span>
<span class="p_add">+			} else {</span>
 				lpfc_initial_fdisc(vport);
<span class="p_add">+			}</span>
 			break;
 		}
 	} else {
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 6df2841cb7f9..5e4e1ba96f10 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -379,8 +379,6 @@</span> <span class="p_context"> MODULE_PARM_DESC(vcpus_per_sub_channel, &quot;Ratio of VCPUs to subchannels&quot;);</span>
  */
 static int storvsc_timeout = 180;
 
<span class="p_del">-static int msft_blist_flags = BLIST_TRY_VPD_PAGES;</span>
<span class="p_del">-</span>
 
 static void storvsc_on_channel_callback(void *context);
 
<span class="p_chunk">@@ -1241,6 +1239,22 @@</span> <span class="p_context"> static int storvsc_do_io(struct hv_device *device,</span>
 	return ret;
 }
 
<span class="p_add">+static int storvsc_device_alloc(struct scsi_device *sdevice)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set blist flag to permit the reading of the VPD pages even when</span>
<span class="p_add">+	 * the target may claim SPC-2 compliance. MSFT targets currently</span>
<span class="p_add">+	 * claim SPC-2 compliance while they implement post SPC-2 features.</span>
<span class="p_add">+	 * With this flag we can correctly handle WRITE_SAME_16 issues.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Hypervisor reports SCSI_UNKNOWN type for DVD ROM device but</span>
<span class="p_add">+	 * still supports REPORT LUN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sdevice-&gt;sdev_bflags = BLIST_REPORTLUN2 | BLIST_TRY_VPD_PAGES;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int storvsc_device_configure(struct scsi_device *sdevice)
 {
 
<span class="p_chunk">@@ -1255,14 +1269,6 @@</span> <span class="p_context"> static int storvsc_device_configure(struct scsi_device *sdevice)</span>
 
 	sdevice-&gt;no_write_same = 1;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Add blist flags to permit the reading of the VPD pages even when</span>
<span class="p_del">-	 * the target may claim SPC-2 compliance. MSFT targets currently</span>
<span class="p_del">-	 * claim SPC-2 compliance while they implement post SPC-2 features.</span>
<span class="p_del">-	 * With this patch we can correctly handle WRITE_SAME_16 issues.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	sdevice-&gt;sdev_bflags |= msft_blist_flags;</span>
<span class="p_del">-</span>
 	/*
 	 * If the host is WIN8 or WIN8 R2, claim conformance to SPC-3
 	 * if the device is a MSFT virtual device.  If the host is
<span class="p_chunk">@@ -1529,6 +1535,7 @@</span> <span class="p_context"> static struct scsi_host_template scsi_driver = {</span>
 	.eh_host_reset_handler =	storvsc_host_reset_handler,
 	.proc_name =		&quot;storvsc_host&quot;,
 	.eh_timed_out =		storvsc_eh_timed_out,
<span class="p_add">+	.slave_alloc =		storvsc_device_alloc,</span>
 	.slave_configure =	storvsc_device_configure,
 	.cmd_per_lun =		255,
 	.this_id =		-1,
<span class="p_header">diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig</span>
<span class="p_header">index b0a24dedd1ed..8b9c2a38d1cc 100644</span>
<span class="p_header">--- a/drivers/spi/Kconfig</span>
<span class="p_header">+++ b/drivers/spi/Kconfig</span>
<span class="p_chunk">@@ -315,7 +315,6 @@</span> <span class="p_context"> config SPI_FSL_SPI</span>
 config SPI_FSL_DSPI
 	tristate &quot;Freescale DSPI controller&quot;
 	select REGMAP_MMIO
<span class="p_del">-	depends on HAS_DMA</span>
 	depends on SOC_VF610 || SOC_LS1021A || ARCH_LAYERSCAPE || COMPILE_TEST
 	help
 	  This enables support for the Freescale DSPI controller in master
<span class="p_header">diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c</span>
<span class="p_header">index 163d305e1200..6abb6a10ee82 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/configfs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/configfs.c</span>
<span class="p_chunk">@@ -270,6 +270,7 @@</span> <span class="p_context"> static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,</span>
 		ret = unregister_gadget(gi);
 		if (ret)
 			goto err;
<span class="p_add">+		kfree(name);</span>
 	} else {
 		if (gi-&gt;udc_name) {
 			ret = -EBUSY;
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index 732e6ed5d7b4..39bb65265bff 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -791,7 +791,7 @@</span> <span class="p_context"> static ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)</span>
 		}
 
 		if (io_data-&gt;aio) {
<span class="p_del">-			req = usb_ep_alloc_request(ep-&gt;ep, GFP_KERNEL);</span>
<span class="p_add">+			req = usb_ep_alloc_request(ep-&gt;ep, GFP_ATOMIC);</span>
 			if (unlikely(!req))
 				goto error_lock;
 
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">index b6df47aa25af..81f3c9cb333c 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_chunk">@@ -1837,8 +1837,10 @@</span> <span class="p_context"> dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 
 	spin_lock_irq (&amp;dev-&gt;lock);
 	value = -EINVAL;
<span class="p_del">-	if (dev-&gt;buf)</span>
<span class="p_add">+	if (dev-&gt;buf) {</span>
<span class="p_add">+		kfree(kbuf);</span>
 		goto fail;
<span class="p_add">+	}</span>
 	dev-&gt;buf = kbuf;
 
 	/* full or low speed config */
<span class="p_header">diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c</span>
<span class="p_header">index 7062bb0975a5..462e183609b6 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio.c</span>
<span class="p_chunk">@@ -323,6 +323,8 @@</span> <span class="p_context"> int register_virtio_device(struct virtio_device *dev)</span>
 	/* device_register() causes the bus infrastructure to look for a
 	 * matching driver. */
 	err = device_register(&amp;dev-&gt;dev);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		ida_simple_remove(&amp;virtio_index_ida, dev-&gt;index);</span>
 out:
 	if (err)
 		add_status(dev, VIRTIO_CONFIG_S_FAILED);
<span class="p_header">diff --git a/fs/afs/cmservice.c b/fs/afs/cmservice.c</span>
<span class="p_header">index 4b0eff6da674..83a8a33a0d73 100644</span>
<span class="p_header">--- a/fs/afs/cmservice.c</span>
<span class="p_header">+++ b/fs/afs/cmservice.c</span>
<span class="p_chunk">@@ -115,6 +115,9 @@</span> <span class="p_context"> bool afs_cm_incoming_call(struct afs_call *call)</span>
 	case CBProbe:
 		call-&gt;type = &amp;afs_SRXCBProbe;
 		return true;
<span class="p_add">+	case CBProbeUuid:</span>
<span class="p_add">+		call-&gt;type = &amp;afs_SRXCBProbeUuid;</span>
<span class="p_add">+		return true;</span>
 	case CBTellMeAboutYourself:
 		call-&gt;type = &amp;afs_SRXCBTellMeAboutYourself;
 		return true;
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index 44e09483d2cd..c690a1c0c4e5 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -2051,7 +2051,7 @@</span> <span class="p_context"> out:</span>
 		if (new_inode != NULL)
 			nfs_drop_nlink(new_inode);
 		d_move(old_dentry, new_dentry);
<span class="p_del">-		nfs_set_verifier(new_dentry,</span>
<span class="p_add">+		nfs_set_verifier(old_dentry,</span>
 					nfs_save_change_attribute(new_dir));
 	} else if (error == -ENOENT)
 		nfs_dentry_handle_enoent(old_dentry);
<span class="p_header">diff --git a/include/drm/drmP.h b/include/drm/drmP.h</span>
<span class="p_header">index a31976c860f6..a5d506b93daf 100644</span>
<span class="p_header">--- a/include/drm/drmP.h</span>
<span class="p_header">+++ b/include/drm/drmP.h</span>
<span class="p_chunk">@@ -158,6 +158,26 @@</span> <span class="p_context"> void drm_err(const char *format, ...);</span>
 /** \name Macros to make printk easier */
 /*@{*/
 
<span class="p_add">+#define _DRM_PRINTK(once, level, fmt, ...)				\</span>
<span class="p_add">+	do {								\</span>
<span class="p_add">+		printk##once(KERN_##level &quot;[&quot; DRM_NAME &quot;] &quot; fmt,	\</span>
<span class="p_add">+			     ##__VA_ARGS__);				\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define DRM_INFO(fmt, ...)						\</span>
<span class="p_add">+	_DRM_PRINTK(, INFO, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DRM_NOTE(fmt, ...)						\</span>
<span class="p_add">+	_DRM_PRINTK(, NOTICE, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DRM_WARN(fmt, ...)						\</span>
<span class="p_add">+	_DRM_PRINTK(, WARNING, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+</span>
<span class="p_add">+#define DRM_INFO_ONCE(fmt, ...)						\</span>
<span class="p_add">+	_DRM_PRINTK(_once, INFO, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DRM_NOTE_ONCE(fmt, ...)						\</span>
<span class="p_add">+	_DRM_PRINTK(_once, NOTICE, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DRM_WARN_ONCE(fmt, ...)						\</span>
<span class="p_add">+	_DRM_PRINTK(_once, WARNING, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+</span>
 /**
  * Error output.
  *
<span class="p_chunk">@@ -183,12 +203,6 @@</span> <span class="p_context"> void drm_err(const char *format, ...);</span>
 		drm_err(fmt, ##__VA_ARGS__);				\
 })
 
<span class="p_del">-#define DRM_INFO(fmt, ...)				\</span>
<span class="p_del">-	printk(KERN_INFO &quot;[&quot; DRM_NAME &quot;] &quot; fmt, ##__VA_ARGS__)</span>
<span class="p_del">-</span>
<span class="p_del">-#define DRM_INFO_ONCE(fmt, ...)				\</span>
<span class="p_del">-	printk_once(KERN_INFO &quot;[&quot; DRM_NAME &quot;] &quot; fmt, ##__VA_ARGS__)</span>
<span class="p_del">-</span>
 /**
  * Debug output.
  *
<span class="p_header">diff --git a/include/linux/genalloc.h b/include/linux/genalloc.h</span>
<span class="p_header">index 7ff168d06967..46156ff5b01d 100644</span>
<span class="p_header">--- a/include/linux/genalloc.h</span>
<span class="p_header">+++ b/include/linux/genalloc.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 #define __GENALLOC_H__
 
 #include &lt;linux/spinlock_types.h&gt;
<span class="p_add">+#include &lt;linux/atomic.h&gt;</span>
 
 struct device;
 struct device_node;
<span class="p_chunk">@@ -68,7 +69,7 @@</span> <span class="p_context"> struct gen_pool {</span>
  */
 struct gen_pool_chunk {
 	struct list_head next_chunk;	/* next chunk in pool */
<span class="p_del">-	atomic_t avail;</span>
<span class="p_add">+	atomic_long_t avail;</span>
 	phys_addr_t phys_addr;		/* physical starting address of memory chunk */
 	unsigned long start_addr;	/* start address of memory chunk */
 	unsigned long end_addr;		/* end address of memory chunk (inclusive) */
<span class="p_header">diff --git a/include/linux/mmu_notifier.h b/include/linux/mmu_notifier.h</span>
<span class="p_header">index a1a210d59961..38c5eb21883e 100644</span>
<span class="p_header">--- a/include/linux/mmu_notifier.h</span>
<span class="p_header">+++ b/include/linux/mmu_notifier.h</span>
<span class="p_chunk">@@ -381,18 +381,6 @@</span> <span class="p_context"> static inline void mmu_notifier_mm_destroy(struct mm_struct *mm)</span>
 	___pmd;								\
 })
 
<span class="p_del">-#define pmdp_huge_get_and_clear_notify(__mm, __haddr, __pmd)		\</span>
<span class="p_del">-({									\</span>
<span class="p_del">-	unsigned long ___haddr = __haddr &amp; HPAGE_PMD_MASK;		\</span>
<span class="p_del">-	pmd_t ___pmd;							\</span>
<span class="p_del">-									\</span>
<span class="p_del">-	___pmd = pmdp_huge_get_and_clear(__mm, __haddr, __pmd);		\</span>
<span class="p_del">-	mmu_notifier_invalidate_range(__mm, ___haddr,			\</span>
<span class="p_del">-				      ___haddr + HPAGE_PMD_SIZE);	\</span>
<span class="p_del">-									\</span>
<span class="p_del">-	___pmd;								\</span>
<span class="p_del">-})</span>
<span class="p_del">-</span>
 /*
  * set_pte_at_notify() sets the pte _after_ running the notifier.
  * This is safe to start by updating the secondary MMUs, because the primary MMU
<span class="p_chunk">@@ -475,7 +463,6 @@</span> <span class="p_context"> static inline void mmu_notifier_mm_destroy(struct mm_struct *mm)</span>
 #define pmdp_clear_young_notify pmdp_test_and_clear_young
 #define	ptep_clear_flush_notify ptep_clear_flush
 #define pmdp_huge_clear_flush_notify pmdp_huge_clear_flush
<span class="p_del">-#define pmdp_huge_get_and_clear_notify pmdp_huge_get_and_clear</span>
 #define set_pte_at_notify set_pte_at
 
 #endif /* CONFIG_MMU_NOTIFIER */
<span class="p_header">diff --git a/include/linux/omap-gpmc.h b/include/linux/omap-gpmc.h</span>
<span class="p_header">index 7dee00143afd..c201e31e9d7e 100644</span>
<span class="p_header">--- a/include/linux/omap-gpmc.h</span>
<span class="p_header">+++ b/include/linux/omap-gpmc.h</span>
<span class="p_chunk">@@ -191,10 +191,11 @@</span> <span class="p_context"> static inline int gpmc_nand_init(struct omap_nand_platform_data *d,</span>
 #endif
 
 #if IS_ENABLED(CONFIG_MTD_ONENAND_OMAP2)
<span class="p_del">-extern void gpmc_onenand_init(struct omap_onenand_platform_data *d);</span>
<span class="p_add">+extern int gpmc_onenand_init(struct omap_onenand_platform_data *d);</span>
 #else
 #define board_onenand_data	NULL
<span class="p_del">-static inline void gpmc_onenand_init(struct omap_onenand_platform_data *d)</span>
<span class="p_add">+static inline int gpmc_onenand_init(struct omap_onenand_platform_data *d)</span>
 {
<span class="p_add">+	return 0;</span>
 }
 #endif
<span class="p_header">diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h</span>
<span class="p_header">index c6f0f0d0e17e..00a1f330f93a 100644</span>
<span class="p_header">--- a/include/linux/sysfs.h</span>
<span class="p_header">+++ b/include/linux/sysfs.h</span>
<span class="p_chunk">@@ -116,6 +116,12 @@</span> <span class="p_context"> struct attribute_group {</span>
 	.show	= _name##_show,						\
 }
 
<span class="p_add">+#define __ATTR_RO_MODE(_name, _mode) {					\</span>
<span class="p_add">+	.attr	= { .name = __stringify(_name),				\</span>
<span class="p_add">+		    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },		\</span>
<span class="p_add">+	.show	= _name##_show,						\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define __ATTR_WO(_name) {						\
 	.attr	= { .name = __stringify(_name), .mode = S_IWUSR },	\
 	.store	= _name##_store,					\
<span class="p_header">diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h</span>
<span class="p_header">index dae99d7d2bc0..706a7017885c 100644</span>
<span class="p_header">--- a/include/scsi/libsas.h</span>
<span class="p_header">+++ b/include/scsi/libsas.h</span>
<span class="p_chunk">@@ -165,11 +165,11 @@</span> <span class="p_context"> struct expander_device {</span>
 
 struct sata_device {
 	unsigned int class;
<span class="p_del">-	struct smp_resp        rps_resp; /* report_phy_sata_resp */</span>
 	u8     port_no;        /* port number, if this is a PM (Port) */
 
 	struct ata_port *ap;
 	struct ata_host ata_host;
<span class="p_add">+	struct smp_resp rps_resp ____cacheline_aligned; /* report_phy_sata_resp */</span>
 	u8     fis[ATA_RESP_FIS_SIZE];
 };
 
<span class="p_header">diff --git a/kernel/audit.c b/kernel/audit.c</span>
<span class="p_header">index 5ffcbd354a52..41f9a38bb800 100644</span>
<span class="p_header">--- a/kernel/audit.c</span>
<span class="p_header">+++ b/kernel/audit.c</span>
<span class="p_chunk">@@ -80,13 +80,13 @@</span> <span class="p_context"> static int	audit_initialized;</span>
 #define AUDIT_OFF	0
 #define AUDIT_ON	1
 #define AUDIT_LOCKED	2
<span class="p_del">-u32		audit_enabled;</span>
<span class="p_del">-u32		audit_ever_enabled;</span>
<span class="p_add">+u32		audit_enabled = AUDIT_OFF;</span>
<span class="p_add">+u32		audit_ever_enabled = !!AUDIT_OFF;</span>
 
 EXPORT_SYMBOL_GPL(audit_enabled);
 
 /* Default state when kernel boots without any parameters. */
<span class="p_del">-static u32	audit_default;</span>
<span class="p_add">+static u32	audit_default = AUDIT_OFF;</span>
 
 /* If auditing cannot proceed, audit_failure selects what happens. */
 static u32	audit_failure = AUDIT_FAIL_PRINTK;
<span class="p_chunk">@@ -1179,8 +1179,6 @@</span> <span class="p_context"> static int __init audit_init(void)</span>
 	skb_queue_head_init(&amp;audit_skb_queue);
 	skb_queue_head_init(&amp;audit_skb_hold_queue);
 	audit_initialized = AUDIT_INITIALIZED;
<span class="p_del">-	audit_enabled = audit_default;</span>
<span class="p_del">-	audit_ever_enabled |= !!audit_default;</span>
 
 	audit_log(NULL, GFP_KERNEL, AUDIT_KERNEL, &quot;initialized&quot;);
 
<span class="p_chunk">@@ -1197,6 +1195,8 @@</span> <span class="p_context"> static int __init audit_enable(char *str)</span>
 	audit_default = !!simple_strtol(str, NULL, 0);
 	if (!audit_default)
 		audit_initialized = AUDIT_DISABLED;
<span class="p_add">+	audit_enabled = audit_default;</span>
<span class="p_add">+	audit_ever_enabled = !!audit_enabled;</span>
 
 	pr_info(&quot;%s\n&quot;, audit_default ?
 		&quot;enabled (after initialization)&quot; : &quot;disabled (until reboot)&quot;);
<span class="p_header">diff --git a/kernel/debug/kdb/kdb_io.c b/kernel/debug/kdb/kdb_io.c</span>
<span class="p_header">index fc1ef736253c..77777d918676 100644</span>
<span class="p_header">--- a/kernel/debug/kdb/kdb_io.c</span>
<span class="p_header">+++ b/kernel/debug/kdb/kdb_io.c</span>
<span class="p_chunk">@@ -349,7 +349,7 @@</span> <span class="p_context"> poll_again:</span>
 			}
 			kdb_printf(&quot;\n&quot;);
 			for (i = 0; i &lt; count; i++) {
<span class="p_del">-				if (kallsyms_symbol_next(p_tmp, i) &lt; 0)</span>
<span class="p_add">+				if (WARN_ON(!kallsyms_symbol_next(p_tmp, i)))</span>
 					break;
 				kdb_printf(&quot;%s &quot;, p_tmp);
 				*(p_tmp + len) = &#39;\0&#39;;
<span class="p_header">diff --git a/kernel/jump_label.c b/kernel/jump_label.c</span>
<span class="p_header">index 453ec4232852..e863b2339174 100644</span>
<span class="p_header">--- a/kernel/jump_label.c</span>
<span class="p_header">+++ b/kernel/jump_label.c</span>
<span class="p_chunk">@@ -553,7 +553,7 @@</span> <span class="p_context"> static __init int jump_label_test(void)</span>
 
 	return 0;
 }
<span class="p_del">-late_initcall(jump_label_test);</span>
<span class="p_add">+early_initcall(jump_label_test);</span>
 #endif /* STATIC_KEYS_SELFTEST */
 
 #endif /* HAVE_JUMP_LABEL */
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index 95cc76785a12..85555eb4d3cb 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -1479,6 +1479,7 @@</span> <span class="p_context"> static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,</span>
 	struct timer_list *timer = &amp;dwork-&gt;timer;
 	struct work_struct *work = &amp;dwork-&gt;work;
 
<span class="p_add">+	WARN_ON_ONCE(!wq);</span>
 	WARN_ON_ONCE(timer-&gt;function != delayed_work_timer_fn ||
 		     timer-&gt;data != (unsigned long)dwork);
 	WARN_ON_ONCE(timer_pending(timer));
<span class="p_header">diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c</span>
<span class="p_header">index 4fa2e54b3f59..76d110301251 100644</span>
<span class="p_header">--- a/lib/asn1_decoder.c</span>
<span class="p_header">+++ b/lib/asn1_decoder.c</span>
<span class="p_chunk">@@ -312,42 +312,47 @@</span> <span class="p_context"> next_op:</span>
 
 	/* Decide how to handle the operation */
 	switch (op) {
<span class="p_del">-	case ASN1_OP_MATCH_ANY_ACT:</span>
<span class="p_del">-	case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:</span>
<span class="p_del">-	case ASN1_OP_COND_MATCH_ANY_ACT:</span>
<span class="p_del">-	case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:</span>
<span class="p_del">-		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		goto skip_data;</span>
<span class="p_del">-</span>
<span class="p_del">-	case ASN1_OP_MATCH_ACT:</span>
<span class="p_del">-	case ASN1_OP_MATCH_ACT_OR_SKIP:</span>
<span class="p_del">-	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:</span>
<span class="p_del">-		ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		goto skip_data;</span>
<span class="p_del">-</span>
 	case ASN1_OP_MATCH:
 	case ASN1_OP_MATCH_OR_SKIP:
<span class="p_add">+	case ASN1_OP_MATCH_ACT:</span>
<span class="p_add">+	case ASN1_OP_MATCH_ACT_OR_SKIP:</span>
 	case ASN1_OP_MATCH_ANY:
 	case ASN1_OP_MATCH_ANY_OR_SKIP:
<span class="p_add">+	case ASN1_OP_MATCH_ANY_ACT:</span>
<span class="p_add">+	case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:</span>
 	case ASN1_OP_COND_MATCH_OR_SKIP:
<span class="p_add">+	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:</span>
 	case ASN1_OP_COND_MATCH_ANY:
 	case ASN1_OP_COND_MATCH_ANY_OR_SKIP:
<span class="p_del">-	skip_data:</span>
<span class="p_add">+	case ASN1_OP_COND_MATCH_ANY_ACT:</span>
<span class="p_add">+	case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:</span>
<span class="p_add">+</span>
 		if (!(flags &amp; FLAG_CONS)) {
 			if (flags &amp; FLAG_INDEFINITE_LENGTH) {
<span class="p_add">+				size_t tmp = dp;</span>
<span class="p_add">+</span>
 				ret = asn1_find_indefinite_length(
<span class="p_del">-					data, datalen, &amp;dp, &amp;len, &amp;errmsg);</span>
<span class="p_add">+					data, datalen, &amp;tmp, &amp;len, &amp;errmsg);</span>
 				if (ret &lt; 0)
 					goto error;
<span class="p_del">-			} else {</span>
<span class="p_del">-				dp += len;</span>
 			}
 			pr_debug(&quot;- LEAF: %zu\n&quot;, len);
 		}
<span class="p_add">+</span>
<span class="p_add">+		if (op &amp; ASN1_OP_MATCH__ACT) {</span>
<span class="p_add">+			unsigned char act;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (op &amp; ASN1_OP_MATCH__ANY)</span>
<span class="p_add">+				act = machine[pc + 1];</span>
<span class="p_add">+			else</span>
<span class="p_add">+				act = machine[pc + 2];</span>
<span class="p_add">+			ret = actions[act](context, hdr, tag, data + dp, len);</span>
<span class="p_add">+			if (ret &lt; 0)</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!(flags &amp; FLAG_CONS))</span>
<span class="p_add">+			dp += len;</span>
 		pc += asn1_op_lengths[op];
 		goto next_op;
 
<span class="p_chunk">@@ -433,6 +438,8 @@</span> <span class="p_context"> next_op:</span>
 			else
 				act = machine[pc + 1];
 			ret = actions[act](context, hdr, 0, data + tdp, len);
<span class="p_add">+			if (ret &lt; 0)</span>
<span class="p_add">+				return ret;</span>
 		}
 		pc += asn1_op_lengths[op];
 		goto next_op;
<span class="p_header">diff --git a/lib/dynamic_debug.c b/lib/dynamic_debug.c</span>
<span class="p_header">index e3952e9c8ec0..c6368ae93fe6 100644</span>
<span class="p_header">--- a/lib/dynamic_debug.c</span>
<span class="p_header">+++ b/lib/dynamic_debug.c</span>
<span class="p_chunk">@@ -353,6 +353,10 @@</span> <span class="p_context"> static int ddebug_parse_query(char *words[], int nwords,</span>
 				if (parse_lineno(last, &amp;query-&gt;last_lineno) &lt; 0)
 					return -EINVAL;
 
<span class="p_add">+				/* special case for last lineno not specified */</span>
<span class="p_add">+				if (query-&gt;last_lineno == 0)</span>
<span class="p_add">+					query-&gt;last_lineno = UINT_MAX;</span>
<span class="p_add">+</span>
 				if (query-&gt;last_lineno &lt; query-&gt;first_lineno) {
 					pr_err(&quot;last-line:%d &lt; 1st-line:%d\n&quot;,
 						query-&gt;last_lineno,
<span class="p_header">diff --git a/lib/genalloc.c b/lib/genalloc.c</span>
<span class="p_header">index 27aa9c629d13..e4303fb2a7b2 100644</span>
<span class="p_header">--- a/lib/genalloc.c</span>
<span class="p_header">+++ b/lib/genalloc.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> int gen_pool_add_virt(struct gen_pool *pool, unsigned long virt, phys_addr_t phy</span>
 	chunk-&gt;phys_addr = phys;
 	chunk-&gt;start_addr = virt;
 	chunk-&gt;end_addr = virt + size - 1;
<span class="p_del">-	atomic_set(&amp;chunk-&gt;avail, size);</span>
<span class="p_add">+	atomic_long_set(&amp;chunk-&gt;avail, size);</span>
 
 	spin_lock(&amp;pool-&gt;lock);
 	list_add_rcu(&amp;chunk-&gt;next_chunk, &amp;pool-&gt;chunks);
<span class="p_chunk">@@ -285,7 +285,7 @@</span> <span class="p_context"> unsigned long gen_pool_alloc(struct gen_pool *pool, size_t size)</span>
 	nbits = (size + (1UL &lt;&lt; order) - 1) &gt;&gt; order;
 	rcu_read_lock();
 	list_for_each_entry_rcu(chunk, &amp;pool-&gt;chunks, next_chunk) {
<span class="p_del">-		if (size &gt; atomic_read(&amp;chunk-&gt;avail))</span>
<span class="p_add">+		if (size &gt; atomic_long_read(&amp;chunk-&gt;avail))</span>
 			continue;
 
 		start_bit = 0;
<span class="p_chunk">@@ -305,7 +305,7 @@</span> <span class="p_context"> retry:</span>
 
 		addr = chunk-&gt;start_addr + ((unsigned long)start_bit &lt;&lt; order);
 		size = nbits &lt;&lt; order;
<span class="p_del">-		atomic_sub(size, &amp;chunk-&gt;avail);</span>
<span class="p_add">+		atomic_long_sub(size, &amp;chunk-&gt;avail);</span>
 		break;
 	}
 	rcu_read_unlock();
<span class="p_chunk">@@ -371,7 +371,7 @@</span> <span class="p_context"> void gen_pool_free(struct gen_pool *pool, unsigned long addr, size_t size)</span>
 			remain = bitmap_clear_ll(chunk-&gt;bits, start_bit, nbits);
 			BUG_ON(remain);
 			size = nbits &lt;&lt; order;
<span class="p_del">-			atomic_add(size, &amp;chunk-&gt;avail);</span>
<span class="p_add">+			atomic_long_add(size, &amp;chunk-&gt;avail);</span>
 			rcu_read_unlock();
 			return;
 		}
<span class="p_chunk">@@ -445,7 +445,7 @@</span> <span class="p_context"> size_t gen_pool_avail(struct gen_pool *pool)</span>
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(chunk, &amp;pool-&gt;chunks, next_chunk)
<span class="p_del">-		avail += atomic_read(&amp;chunk-&gt;avail);</span>
<span class="p_add">+		avail += atomic_long_read(&amp;chunk-&gt;avail);</span>
 	rcu_read_unlock();
 	return avail;
 }
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 8f3769ec8575..0127b788272f 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1566,35 +1566,69 @@</span> <span class="p_context"> int change_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,</span>
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
 	spinlock_t *ptl;
<span class="p_add">+	pmd_t entry;</span>
<span class="p_add">+	bool preserve_write;</span>
<span class="p_add">+</span>
 	int ret = 0;
 
<span class="p_del">-	if (__pmd_trans_huge_lock(pmd, vma, &amp;ptl) == 1) {</span>
<span class="p_del">-		pmd_t entry;</span>
<span class="p_del">-		bool preserve_write = prot_numa &amp;&amp; pmd_write(*pmd);</span>
<span class="p_del">-		ret = 1;</span>
<span class="p_add">+	if (__pmd_trans_huge_lock(pmd, vma, &amp;ptl) != 1)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Avoid trapping faults against the zero page. The read-only</span>
<span class="p_del">-		 * data is likely to be read-cached on the local CPU and</span>
<span class="p_del">-		 * local/remote hits to the zero page are not interesting.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (prot_numa &amp;&amp; is_huge_zero_pmd(*pmd)) {</span>
<span class="p_del">-			spin_unlock(ptl);</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	preserve_write = prot_numa &amp;&amp; pmd_write(*pmd);</span>
<span class="p_add">+	ret = 1;</span>
 
<span class="p_del">-		if (!prot_numa || !pmd_protnone(*pmd)) {</span>
<span class="p_del">-			entry = pmdp_huge_get_and_clear_notify(mm, addr, pmd);</span>
<span class="p_del">-			entry = pmd_modify(entry, newprot);</span>
<span class="p_del">-			if (preserve_write)</span>
<span class="p_del">-				entry = pmd_mkwrite(entry);</span>
<span class="p_del">-			ret = HPAGE_PMD_NR;</span>
<span class="p_del">-			set_pmd_at(mm, addr, pmd, entry);</span>
<span class="p_del">-			BUG_ON(!preserve_write &amp;&amp; pmd_write(entry));</span>
<span class="p_del">-		}</span>
<span class="p_del">-		spin_unlock(ptl);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Avoid trapping faults against the zero page. The read-only</span>
<span class="p_add">+	 * data is likely to be read-cached on the local CPU and</span>
<span class="p_add">+	 * local/remote hits to the zero page are not interesting.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (prot_numa &amp;&amp; is_huge_zero_pmd(*pmd))</span>
<span class="p_add">+		goto unlock;</span>
 
<span class="p_add">+	if (prot_numa &amp;&amp; pmd_protnone(*pmd))</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case prot_numa, we are under down_read(mmap_sem). It&#39;s critical</span>
<span class="p_add">+	 * to not clear pmd intermittently to avoid race with MADV_DONTNEED</span>
<span class="p_add">+	 * which is also under down_read(mmap_sem):</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *	CPU0:				CPU1:</span>
<span class="p_add">+	 *				change_huge_pmd(prot_numa=1)</span>
<span class="p_add">+	 *				 pmdp_huge_get_and_clear_notify()</span>
<span class="p_add">+	 * madvise_dontneed()</span>
<span class="p_add">+	 *  zap_pmd_range()</span>
<span class="p_add">+	 *   pmd_trans_huge(*pmd) == 0 (without ptl)</span>
<span class="p_add">+	 *   // skip the pmd</span>
<span class="p_add">+	 *				 set_pmd_at();</span>
<span class="p_add">+	 *				 // pmd is re-established</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The race makes MADV_DONTNEED miss the huge pmd and don&#39;t clear it</span>
<span class="p_add">+	 * which may break userspace.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * pmdp_invalidate() is required to make sure we don&#39;t miss</span>
<span class="p_add">+	 * dirty/young flags set by hardware.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	entry = *pmd;</span>
<span class="p_add">+	pmdp_invalidate(vma, addr, pmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Recover dirty/young flags.  It relies on pmdp_invalidate to not</span>
<span class="p_add">+	 * corrupt them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pmd_dirty(*pmd))</span>
<span class="p_add">+		entry = pmd_mkdirty(entry);</span>
<span class="p_add">+	if (pmd_young(*pmd))</span>
<span class="p_add">+		entry = pmd_mkyoung(entry);</span>
<span class="p_add">+</span>
<span class="p_add">+	entry = pmd_modify(entry, newprot);</span>
<span class="p_add">+	if (preserve_write)</span>
<span class="p_add">+		entry = pmd_mkwrite(entry);</span>
<span class="p_add">+	ret = HPAGE_PMD_NR;</span>
<span class="p_add">+	set_pmd_at(mm, addr, pmd, entry);</span>
<span class="p_add">+	BUG_ON(!preserve_write &amp;&amp; pmd_write(entry));</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	spin_unlock(ptl);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c</span>
<span class="p_header">index 461ca926fd39..6a20195a3a2a 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c</span>
<span class="p_chunk">@@ -158,6 +158,10 @@</span> <span class="p_context"> static unsigned int ipv4_conntrack_local(void *priv,</span>
 	if (skb-&gt;len &lt; sizeof(struct iphdr) ||
 	    ip_hdrlen(skb) &lt; sizeof(struct iphdr))
 		return NF_ACCEPT;
<span class="p_add">+</span>
<span class="p_add">+	if (ip_is_fragment(ip_hdr(skb))) /* IP_NODEFRAG setsockopt set */</span>
<span class="p_add">+		return NF_ACCEPT;</span>
<span class="p_add">+</span>
 	return nf_conntrack_in(state-&gt;net, PF_INET, state-&gt;hook, skb);
 }
 
<span class="p_header">diff --git a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c</span>
<span class="p_header">index 5075b7ecd26d..98a56077f604 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c</span>
<span class="p_chunk">@@ -268,11 +268,6 @@</span> <span class="p_context"> nf_nat_ipv4_fn(void *priv, struct sk_buff *skb,</span>
 	/* maniptype == SRC for postrouting. */
 	enum nf_nat_manip_type maniptype = HOOK2MANIP(state-&gt;hook);
 
<span class="p_del">-	/* We never see fragments: conntrack defrags on pre-routing</span>
<span class="p_del">-	 * and local-out, and nf_nat_out protects post-routing.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	NF_CT_ASSERT(!ip_is_fragment(ip_hdr(skb)));</span>
<span class="p_del">-</span>
 	ct = nf_ct_get(skb, &amp;ctinfo);
 	/* Can&#39;t track?  It&#39;s not due to stress, or conntrack would
 	 * have dropped it.  Hence it&#39;s the user&#39;s responsibilty to
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 0294f7c99c85..52d718e3f077 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -624,9 +624,12 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 	struct fnhe_hash_bucket *hash;
 	struct fib_nh_exception *fnhe;
 	struct rtable *rt;
<span class="p_add">+	u32 genid, hval;</span>
 	unsigned int i;
 	int depth;
<span class="p_del">-	u32 hval = fnhe_hashfun(daddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	genid = fnhe_genid(dev_net(nh-&gt;nh_dev));</span>
<span class="p_add">+	hval = fnhe_hashfun(daddr);</span>
 
 	spin_lock_bh(&amp;fnhe_lock);
 
<span class="p_chunk">@@ -649,12 +652,13 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 	}
 
 	if (fnhe) {
<span class="p_add">+		if (fnhe-&gt;fnhe_genid != genid)</span>
<span class="p_add">+			fnhe-&gt;fnhe_genid = genid;</span>
 		if (gw)
 			fnhe-&gt;fnhe_gw = gw;
<span class="p_del">-		if (pmtu) {</span>
<span class="p_add">+		if (pmtu)</span>
 			fnhe-&gt;fnhe_pmtu = pmtu;
<span class="p_del">-			fnhe-&gt;fnhe_expires = max(1UL, expires);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		fnhe-&gt;fnhe_expires = max(1UL, expires);</span>
 		/* Update all cached dsts too */
 		rt = rcu_dereference(fnhe-&gt;fnhe_rth_input);
 		if (rt)
<span class="p_chunk">@@ -673,7 +677,7 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 			fnhe-&gt;fnhe_next = hash-&gt;chain;
 			rcu_assign_pointer(hash-&gt;chain, fnhe);
 		}
<span class="p_del">-		fnhe-&gt;fnhe_genid = fnhe_genid(dev_net(nh-&gt;nh_dev));</span>
<span class="p_add">+		fnhe-&gt;fnhe_genid = genid;</span>
 		fnhe-&gt;fnhe_daddr = daddr;
 		fnhe-&gt;fnhe_gw = gw;
 		fnhe-&gt;fnhe_pmtu = pmtu;
<span class="p_header">diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c</span>
<span class="p_header">index 9f5137cd604e..83ec6639b04d 100644</span>
<span class="p_header">--- a/net/ipv6/af_inet6.c</span>
<span class="p_header">+++ b/net/ipv6/af_inet6.c</span>
<span class="p_chunk">@@ -893,12 +893,12 @@</span> <span class="p_context"> static int __init inet6_init(void)</span>
 	err = register_pernet_subsys(&amp;inet6_net_ops);
 	if (err)
 		goto register_pernet_fail;
<span class="p_del">-	err = icmpv6_init();</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto icmp_fail;</span>
 	err = ip6_mr_init();
 	if (err)
 		goto ipmr_fail;
<span class="p_add">+	err = icmpv6_init();</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto icmp_fail;</span>
 	err = ndisc_init();
 	if (err)
 		goto ndisc_fail;
<span class="p_chunk">@@ -1016,10 +1016,10 @@</span> <span class="p_context"> igmp_fail:</span>
 	ndisc_cleanup();
 ndisc_fail:
 	ip6_mr_cleanup();
<span class="p_del">-ipmr_fail:</span>
<span class="p_del">-	icmpv6_cleanup();</span>
 icmp_fail:
 	unregister_pernet_subsys(&amp;inet6_net_ops);
<span class="p_add">+ipmr_fail:</span>
<span class="p_add">+	icmpv6_cleanup();</span>
 register_pernet_fail:
 	sock_unregister(PF_INET6);
 	rtnl_unregister_all(PF_INET6);
<span class="p_header">diff --git a/net/ipv6/ip6_vti.c b/net/ipv6/ip6_vti.c</span>
<span class="p_header">index f58ad70f693e..24dfc2de0165 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_vti.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_vti.c</span>
<span class="p_chunk">@@ -474,11 +474,15 @@</span> <span class="p_context"> vti6_xmit(struct sk_buff *skb, struct net_device *dev, struct flowi *fl)</span>
 	if (!skb-&gt;ignore_df &amp;&amp; skb-&gt;len &gt; mtu) {
 		skb_dst(skb)-&gt;ops-&gt;update_pmtu(dst, NULL, skb, mtu);
 
<span class="p_del">-		if (skb-&gt;protocol == htons(ETH_P_IPV6))</span>
<span class="p_add">+		if (skb-&gt;protocol == htons(ETH_P_IPV6)) {</span>
<span class="p_add">+			if (mtu &lt; IPV6_MIN_MTU)</span>
<span class="p_add">+				mtu = IPV6_MIN_MTU;</span>
<span class="p_add">+</span>
 			icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
 				  htonl(mtu));
<span class="p_add">+		}</span>
 
 		return -EMSGSIZE;
 	}
<span class="p_header">diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c</span>
<span class="p_header">index 184f0fe35dc6..b7ea5eaa4fd1 100644</span>
<span class="p_header">--- a/net/ipv6/sit.c</span>
<span class="p_header">+++ b/net/ipv6/sit.c</span>
<span class="p_chunk">@@ -1093,6 +1093,7 @@</span> <span class="p_context"> static void ipip6_tunnel_update(struct ip_tunnel *t, struct ip_tunnel_parm *p)</span>
 	ipip6_tunnel_link(sitn, t);
 	t-&gt;parms.iph.ttl = p-&gt;iph.ttl;
 	t-&gt;parms.iph.tos = p-&gt;iph.tos;
<span class="p_add">+	t-&gt;parms.iph.frag_off = p-&gt;iph.frag_off;</span>
 	if (t-&gt;parms.link != p-&gt;link) {
 		t-&gt;parms.link = p-&gt;link;
 		ipip6_tunnel_bind_dev(t-&gt;dev);
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 1584f89c456a..92ca3e106c2b 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1665,7 +1665,6 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 		atomic_long_set(&amp;rollover-&gt;num, 0);
 		atomic_long_set(&amp;rollover-&gt;num_huge, 0);
 		atomic_long_set(&amp;rollover-&gt;num_failed, 0);
<span class="p_del">-		po-&gt;rollover = rollover;</span>
 	}
 
 	match = NULL;
<span class="p_chunk">@@ -1710,6 +1709,8 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 		if (atomic_read(&amp;match-&gt;sk_ref) &lt; PACKET_FANOUT_MAX) {
 			__dev_remove_pack(&amp;po-&gt;prot_hook);
 			po-&gt;fanout = match;
<span class="p_add">+			po-&gt;rollover = rollover;</span>
<span class="p_add">+			rollover = NULL;</span>
 			atomic_inc(&amp;match-&gt;sk_ref);
 			__fanout_link(sk, po);
 			err = 0;
<span class="p_chunk">@@ -1723,10 +1724,7 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 	}
 
 out:
<span class="p_del">-	if (err &amp;&amp; rollover) {</span>
<span class="p_del">-		kfree_rcu(rollover, rcu);</span>
<span class="p_del">-		po-&gt;rollover = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	kfree(rollover);</span>
 	mutex_unlock(&amp;fanout_mutex);
 	return err;
 }
<span class="p_chunk">@@ -1750,11 +1748,6 @@</span> <span class="p_context"> static struct packet_fanout *fanout_release(struct sock *sk)</span>
 			list_del(&amp;f-&gt;list);
 		else
 			f = NULL;
<span class="p_del">-</span>
<span class="p_del">-		if (po-&gt;rollover) {</span>
<span class="p_del">-			kfree_rcu(po-&gt;rollover, rcu);</span>
<span class="p_del">-			po-&gt;rollover = NULL;</span>
<span class="p_del">-		}</span>
 	}
 	mutex_unlock(&amp;fanout_mutex);
 
<span class="p_chunk">@@ -2914,6 +2907,7 @@</span> <span class="p_context"> static int packet_release(struct socket *sock)</span>
 	synchronize_net();
 
 	if (f) {
<span class="p_add">+		kfree(po-&gt;rollover);</span>
 		fanout_release_data(f);
 		kfree(f);
 	}
<span class="p_chunk">@@ -2982,6 +2976,10 @@</span> <span class="p_context"> static int packet_do_bind(struct sock *sk, const char *name, int ifindex,</span>
 	if (need_rehook) {
 		if (po-&gt;running) {
 			rcu_read_unlock();
<span class="p_add">+			/* prevents packet_notifier() from calling</span>
<span class="p_add">+			 * register_prot_hook()</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			po-&gt;num = 0;</span>
 			__unregister_prot_hook(sk, true);
 			rcu_read_lock();
 			dev_curr = po-&gt;prot_hook.dev;
<span class="p_chunk">@@ -2990,6 +2988,7 @@</span> <span class="p_context"> static int packet_do_bind(struct sock *sk, const char *name, int ifindex,</span>
 								 dev-&gt;ifindex);
 		}
 
<span class="p_add">+		BUG_ON(po-&gt;running);</span>
 		po-&gt;num = proto;
 		po-&gt;prot_hook.type = proto;
 
<span class="p_chunk">@@ -3771,7 +3770,6 @@</span> <span class="p_context"> static int packet_getsockopt(struct socket *sock, int level, int optname,</span>
 	void *data = &amp;val;
 	union tpacket_stats_u st;
 	struct tpacket_rollover_stats rstats;
<span class="p_del">-	struct packet_rollover *rollover;</span>
 
 	if (level != SOL_PACKET)
 		return -ENOPROTOOPT;
<span class="p_chunk">@@ -3850,18 +3848,13 @@</span> <span class="p_context"> static int packet_getsockopt(struct socket *sock, int level, int optname,</span>
 		       0);
 		break;
 	case PACKET_ROLLOVER_STATS:
<span class="p_del">-		rcu_read_lock();</span>
<span class="p_del">-		rollover = rcu_dereference(po-&gt;rollover);</span>
<span class="p_del">-		if (rollover) {</span>
<span class="p_del">-			rstats.tp_all = atomic_long_read(&amp;rollover-&gt;num);</span>
<span class="p_del">-			rstats.tp_huge = atomic_long_read(&amp;rollover-&gt;num_huge);</span>
<span class="p_del">-			rstats.tp_failed = atomic_long_read(&amp;rollover-&gt;num_failed);</span>
<span class="p_del">-			data = &amp;rstats;</span>
<span class="p_del">-			lv = sizeof(rstats);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		rcu_read_unlock();</span>
<span class="p_del">-		if (!rollover)</span>
<span class="p_add">+		if (!po-&gt;rollover)</span>
 			return -EINVAL;
<span class="p_add">+		rstats.tp_all = atomic_long_read(&amp;po-&gt;rollover-&gt;num);</span>
<span class="p_add">+		rstats.tp_huge = atomic_long_read(&amp;po-&gt;rollover-&gt;num_huge);</span>
<span class="p_add">+		rstats.tp_failed = atomic_long_read(&amp;po-&gt;rollover-&gt;num_failed);</span>
<span class="p_add">+		data = &amp;rstats;</span>
<span class="p_add">+		lv = sizeof(rstats);</span>
 		break;
 	case PACKET_TX_HAS_OFF:
 		val = po-&gt;tp_tx_has_off;
<span class="p_header">diff --git a/net/packet/internal.h b/net/packet/internal.h</span>
<span class="p_header">index 9ee46314b7d7..d55bfc34d6b3 100644</span>
<span class="p_header">--- a/net/packet/internal.h</span>
<span class="p_header">+++ b/net/packet/internal.h</span>
<span class="p_chunk">@@ -92,7 +92,6 @@</span> <span class="p_context"> struct packet_fanout {</span>
 
 struct packet_rollover {
 	int			sock;
<span class="p_del">-	struct rcu_head		rcu;</span>
 	atomic_long_t		num;
 	atomic_long_t		num_huge;
 	atomic_long_t		num_failed;
<span class="p_header">diff --git a/net/rds/rdma.c b/net/rds/rdma.c</span>
<span class="p_header">index 8d3a851a3476..bdf151c6307d 100644</span>
<span class="p_header">--- a/net/rds/rdma.c</span>
<span class="p_header">+++ b/net/rds/rdma.c</span>
<span class="p_chunk">@@ -184,7 +184,7 @@</span> <span class="p_context"> static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,</span>
 	long i;
 	int ret;
 
<span class="p_del">-	if (rs-&gt;rs_bound_addr == 0) {</span>
<span class="p_add">+	if (rs-&gt;rs_bound_addr == 0 || !rs-&gt;rs_transport) {</span>
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 7f0f689b8d2b..61189c576963 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -82,8 +82,8 @@</span> <span class="p_context"></span>
 /* Forward declarations for internal helper functions. */
 static int sctp_writeable(struct sock *sk);
 static void sctp_wfree(struct sk_buff *skb);
<span class="p_del">-static int sctp_wait_for_sndbuf(struct sctp_association *, long *timeo_p,</span>
<span class="p_del">-				size_t msg_len);</span>
<span class="p_add">+static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
<span class="p_add">+				size_t msg_len, struct sock **orig_sk);</span>
 static int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p);
 static int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);
 static int sctp_wait_for_accept(struct sock *sk, long timeo);
<span class="p_chunk">@@ -1953,9 +1953,16 @@</span> <span class="p_context"> static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)</span>
 
 	timeo = sock_sndtimeo(sk, msg-&gt;msg_flags &amp; MSG_DONTWAIT);
 	if (!sctp_wspace(asoc)) {
<span class="p_del">-		err = sctp_wait_for_sndbuf(asoc, &amp;timeo, msg_len);</span>
<span class="p_del">-		if (err)</span>
<span class="p_add">+		/* sk can be changed by peel off when waiting for buf. */</span>
<span class="p_add">+		err = sctp_wait_for_sndbuf(asoc, &amp;timeo, msg_len, &amp;sk);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			if (err == -ESRCH) {</span>
<span class="p_add">+				/* asoc is already dead. */</span>
<span class="p_add">+				new_asoc = NULL;</span>
<span class="p_add">+				err = -EPIPE;</span>
<span class="p_add">+			}</span>
 			goto out_free;
<span class="p_add">+		}</span>
 	}
 
 	/* If an address is passed with the sendto/sendmsg call, it is used
<span class="p_chunk">@@ -4460,12 +4467,6 @@</span> <span class="p_context"> int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)</span>
 	if (!asoc)
 		return -EINVAL;
 
<span class="p_del">-	/* If there is a thread waiting on more sndbuf space for</span>
<span class="p_del">-	 * sending on this asoc, it cannot be peeled.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (waitqueue_active(&amp;asoc-&gt;wait))</span>
<span class="p_del">-		return -EBUSY;</span>
<span class="p_del">-</span>
 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
<span class="p_chunk">@@ -6975,7 +6976,7 @@</span> <span class="p_context"> void sctp_sock_rfree(struct sk_buff *skb)</span>
 
 /* Helper function to wait for space in the sndbuf.  */
 static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
<span class="p_del">-				size_t msg_len)</span>
<span class="p_add">+				size_t msg_len, struct sock **orig_sk)</span>
 {
 	struct sock *sk = asoc-&gt;base.sk;
 	int err = 0;
<span class="p_chunk">@@ -6992,10 +6993,11 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 	for (;;) {
 		prepare_to_wait_exclusive(&amp;asoc-&gt;wait, &amp;wait,
 					  TASK_INTERRUPTIBLE);
<span class="p_add">+		if (asoc-&gt;base.dead)</span>
<span class="p_add">+			goto do_dead;</span>
 		if (!*timeo_p)
 			goto do_nonblock;
<span class="p_del">-		if (sk-&gt;sk_err || asoc-&gt;state &gt;= SCTP_STATE_SHUTDOWN_PENDING ||</span>
<span class="p_del">-		    asoc-&gt;base.dead)</span>
<span class="p_add">+		if (sk-&gt;sk_err || asoc-&gt;state &gt;= SCTP_STATE_SHUTDOWN_PENDING)</span>
 			goto do_error;
 		if (signal_pending(current))
 			goto do_interrupted;
<span class="p_chunk">@@ -7008,11 +7010,17 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
 		lock_sock(sk);
<span class="p_add">+		if (sk != asoc-&gt;base.sk) {</span>
<span class="p_add">+			release_sock(sk);</span>
<span class="p_add">+			sk = asoc-&gt;base.sk;</span>
<span class="p_add">+			lock_sock(sk);</span>
<span class="p_add">+		}</span>
 
 		*timeo_p = current_timeo;
 	}
 
 out:
<span class="p_add">+	*orig_sk = sk;</span>
 	finish_wait(&amp;asoc-&gt;wait, &amp;wait);
 
 	/* Release the association&#39;s refcnt.  */
<span class="p_chunk">@@ -7020,6 +7028,10 @@</span> <span class="p_context"> out:</span>
 
 	return err;
 
<span class="p_add">+do_dead:</span>
<span class="p_add">+	err = -ESRCH;</span>
<span class="p_add">+	goto out;</span>
<span class="p_add">+</span>
 do_error:
 	err = -EPIPE;
 	goto out;
<span class="p_header">diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c</span>
<span class="p_header">index 73ad57a59989..1cb35c753dcd 100644</span>
<span class="p_header">--- a/net/sunrpc/sched.c</span>
<span class="p_header">+++ b/net/sunrpc/sched.c</span>
<span class="p_chunk">@@ -273,10 +273,9 @@</span> <span class="p_context"> static inline void rpc_task_set_debuginfo(struct rpc_task *task)</span>
 
 static void rpc_set_active(struct rpc_task *task)
 {
<span class="p_del">-	trace_rpc_task_begin(task-&gt;tk_client, task, NULL);</span>
<span class="p_del">-</span>
 	rpc_task_set_debuginfo(task);
 	set_bit(RPC_TASK_ACTIVE, &amp;task-&gt;tk_runstate);
<span class="p_add">+	trace_rpc_task_begin(task-&gt;tk_client, task, NULL);</span>
 }
 
 /*
<span class="p_header">diff --git a/net/tipc/server.c b/net/tipc/server.c</span>
<span class="p_header">index c416e5184a3f..f351863076c2 100644</span>
<span class="p_header">--- a/net/tipc/server.c</span>
<span class="p_header">+++ b/net/tipc/server.c</span>
<span class="p_chunk">@@ -311,6 +311,7 @@</span> <span class="p_context"> static int tipc_accept_from_sock(struct tipc_conn *con)</span>
 	newcon-&gt;usr_data = s-&gt;tipc_conn_new(newcon-&gt;conid);
 	if (!newcon-&gt;usr_data) {
 		sock_release(newsock);
<span class="p_add">+		conn_put(newcon);</span>
 		return -ENOMEM;
 	}
 
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index 0e01250f2072..22df3b51e905 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -1361,6 +1361,7 @@</span> <span class="p_context"> static struct xfrm_policy *clone_policy(const struct xfrm_policy *old, int dir)</span>
 		newp-&gt;xfrm_nr = old-&gt;xfrm_nr;
 		newp-&gt;index = old-&gt;index;
 		newp-&gt;type = old-&gt;type;
<span class="p_add">+		newp-&gt;family = old-&gt;family;</span>
 		memcpy(newp-&gt;xfrm_vec, old-&gt;xfrm_vec,
 		       newp-&gt;xfrm_nr*sizeof(struct xfrm_tmpl));
 		write_lock_bh(&amp;net-&gt;xfrm.xfrm_policy_lock);
<span class="p_header">diff --git a/scripts/module-common.lds b/scripts/module-common.lds</span>
<span class="p_header">index 73a2c7da0e55..53234e85192a 100644</span>
<span class="p_header">--- a/scripts/module-common.lds</span>
<span class="p_header">+++ b/scripts/module-common.lds</span>
<span class="p_chunk">@@ -19,4 +19,6 @@</span> <span class="p_context"> SECTIONS {</span>
 
 	. = ALIGN(8);
 	.init_array		0 : { *(SORT(.init_array.*)) *(.init_array) }
<span class="p_add">+</span>
<span class="p_add">+	__jump_table		0 : ALIGN(8) { KEEP(*(__jump_table)) }</span>
 }
<span class="p_header">diff --git a/scripts/package/Makefile b/scripts/package/Makefile</span>
<span class="p_header">index 493e226356ca..52917fb8e0c5 100644</span>
<span class="p_header">--- a/scripts/package/Makefile</span>
<span class="p_header">+++ b/scripts/package/Makefile</span>
<span class="p_chunk">@@ -39,10 +39,9 @@</span> <span class="p_context"> if test &quot;$(objtree)&quot; != &quot;$(srctree)&quot;; then \</span>
 	false; \
 fi ; \
 $(srctree)/scripts/setlocalversion --save-scmversion; \
<span class="p_del">-ln -sf $(srctree) $(2); \</span>
 tar -cz $(RCS_TAR_IGNORE) -f $(2).tar.gz \
<span class="p_del">-	$(addprefix $(2)/,$(TAR_CONTENT) $(3)); \</span>
<span class="p_del">-rm -f $(2) $(objtree)/.scmversion</span>
<span class="p_add">+	--transform &#39;s:^:$(2)/:S&#39; $(TAR_CONTENT) $(3); \</span>
<span class="p_add">+rm -f $(objtree)/.scmversion</span>
 
 # rpm-pkg
 # ---------------------------------------------------------------------------
<span class="p_header">diff --git a/sound/core/pcm.c b/sound/core/pcm.c</span>
<span class="p_header">index 8e980aa678d0..074363b63cc4 100644</span>
<span class="p_header">--- a/sound/core/pcm.c</span>
<span class="p_header">+++ b/sound/core/pcm.c</span>
<span class="p_chunk">@@ -149,7 +149,9 @@</span> <span class="p_context"> static int snd_pcm_control_ioctl(struct snd_card *card,</span>
 				err = -ENXIO;
 				goto _error;
 			}
<span class="p_add">+			mutex_lock(&amp;pcm-&gt;open_mutex);</span>
 			err = snd_pcm_info_user(substream, info);
<span class="p_add">+			mutex_unlock(&amp;pcm-&gt;open_mutex);</span>
 		_error:
 			mutex_unlock(&amp;register_mutex);
 			return err;
<span class="p_header">diff --git a/sound/core/seq/seq_timer.c b/sound/core/seq/seq_timer.c</span>
<span class="p_header">index 293104926098..3be67560ead5 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_timer.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_timer.c</span>
<span class="p_chunk">@@ -355,7 +355,7 @@</span> <span class="p_context"> static int initialize_timer(struct snd_seq_timer *tmr)</span>
 	unsigned long freq;
 
 	t = tmr-&gt;timeri-&gt;timer;
<span class="p_del">-	if (snd_BUG_ON(!t))</span>
<span class="p_add">+	if (!t)</span>
 		return -EINVAL;
 
 	freq = tmr-&gt;preferred_resolution;
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 1050008d7719..0ed9ae030ce1 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -203,6 +203,10 @@</span> <span class="p_context"> static int snd_usb_copy_string_desc(struct mixer_build *state,</span>
 				    int index, char *buf, int maxlen)
 {
 	int len = usb_string(state-&gt;chip-&gt;dev, index, buf, maxlen - 1);
<span class="p_add">+</span>
<span class="p_add">+	if (len &lt; 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	buf[len] = 0;
 	return len;
 }
<span class="p_chunk">@@ -2102,13 +2106,14 @@</span> <span class="p_context"> static int parse_audio_selector_unit(struct mixer_build *state, int unitid,</span>
 	if (len)
 		;
 	else if (nameid)
<span class="p_del">-		snd_usb_copy_string_desc(state, nameid, kctl-&gt;id.name,</span>
<span class="p_add">+		len = snd_usb_copy_string_desc(state, nameid, kctl-&gt;id.name,</span>
 					 sizeof(kctl-&gt;id.name));
<span class="p_del">-	else {</span>
<span class="p_add">+	else</span>
 		len = get_term_name(state, &amp;state-&gt;oterm,
 				    kctl-&gt;id.name, sizeof(kctl-&gt;id.name), 0);
<span class="p_del">-		if (!len)</span>
<span class="p_del">-			strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!len) {</span>
<span class="p_add">+		strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
 
 		if (desc-&gt;bDescriptorSubtype == UAC2_CLOCK_SELECTOR)
 			append_ctl_name(kctl, &quot; Clock Source&quot;);
<span class="p_header">diff --git a/tools/hv/hv_kvp_daemon.c b/tools/hv/hv_kvp_daemon.c</span>
<span class="p_header">index bc7adb84e679..60a94b3e532e 100644</span>
<span class="p_header">--- a/tools/hv/hv_kvp_daemon.c</span>
<span class="p_header">+++ b/tools/hv/hv_kvp_daemon.c</span>
<span class="p_chunk">@@ -193,11 +193,14 @@</span> <span class="p_context"> static void kvp_update_mem_state(int pool)</span>
 	for (;;) {
 		readp = &amp;record[records_read];
 		records_read += fread(readp, sizeof(struct kvp_record),
<span class="p_del">-					ENTRIES_PER_BLOCK * num_blocks,</span>
<span class="p_del">-					filep);</span>
<span class="p_add">+				ENTRIES_PER_BLOCK * num_blocks - records_read,</span>
<span class="p_add">+				filep);</span>
 
 		if (ferror(filep)) {
<span class="p_del">-			syslog(LOG_ERR, &quot;Failed to read file, pool: %d&quot;, pool);</span>
<span class="p_add">+			syslog(LOG_ERR,</span>
<span class="p_add">+				&quot;Failed to read file, pool: %d; error: %d %s&quot;,</span>
<span class="p_add">+				 pool, errno, strerror(errno));</span>
<span class="p_add">+			kvp_release_lock(pool);</span>
 			exit(EXIT_FAILURE);
 		}
 
<span class="p_chunk">@@ -210,6 +213,7 @@</span> <span class="p_context"> static void kvp_update_mem_state(int pool)</span>
 
 			if (record == NULL) {
 				syslog(LOG_ERR, &quot;malloc failed&quot;);
<span class="p_add">+				kvp_release_lock(pool);</span>
 				exit(EXIT_FAILURE);
 			}
 			continue;
<span class="p_chunk">@@ -224,15 +228,11 @@</span> <span class="p_context"> static void kvp_update_mem_state(int pool)</span>
 	fclose(filep);
 	kvp_release_lock(pool);
 }
<span class="p_add">+</span>
 static int kvp_file_init(void)
 {
 	int  fd;
<span class="p_del">-	FILE *filep;</span>
<span class="p_del">-	size_t records_read;</span>
 	char *fname;
<span class="p_del">-	struct kvp_record *record;</span>
<span class="p_del">-	struct kvp_record *readp;</span>
<span class="p_del">-	int num_blocks;</span>
 	int i;
 	int alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;
 
<span class="p_chunk">@@ -246,61 +246,19 @@</span> <span class="p_context"> static int kvp_file_init(void)</span>
 
 	for (i = 0; i &lt; KVP_POOL_COUNT; i++) {
 		fname = kvp_file_info[i].fname;
<span class="p_del">-		records_read = 0;</span>
<span class="p_del">-		num_blocks = 1;</span>
 		sprintf(fname, &quot;%s/.kvp_pool_%d&quot;, KVP_CONFIG_LOC, i);
 		fd = open(fname, O_RDWR | O_CREAT | O_CLOEXEC, 0644 /* rw-r--r-- */);
 
 		if (fd == -1)
 			return 1;
 
<span class="p_del">-</span>
<span class="p_del">-		filep = fopen(fname, &quot;re&quot;);</span>
<span class="p_del">-		if (!filep) {</span>
<span class="p_del">-			close(fd);</span>
<span class="p_del">-			return 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		record = malloc(alloc_unit * num_blocks);</span>
<span class="p_del">-		if (record == NULL) {</span>
<span class="p_del">-			fclose(filep);</span>
<span class="p_del">-			close(fd);</span>
<span class="p_del">-			return 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		for (;;) {</span>
<span class="p_del">-			readp = &amp;record[records_read];</span>
<span class="p_del">-			records_read += fread(readp, sizeof(struct kvp_record),</span>
<span class="p_del">-					ENTRIES_PER_BLOCK,</span>
<span class="p_del">-					filep);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (ferror(filep)) {</span>
<span class="p_del">-				syslog(LOG_ERR, &quot;Failed to read file, pool: %d&quot;,</span>
<span class="p_del">-				       i);</span>
<span class="p_del">-				exit(EXIT_FAILURE);</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!feof(filep)) {</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * We have more data to read.</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				num_blocks++;</span>
<span class="p_del">-				record = realloc(record, alloc_unit *</span>
<span class="p_del">-						num_blocks);</span>
<span class="p_del">-				if (record == NULL) {</span>
<span class="p_del">-					fclose(filep);</span>
<span class="p_del">-					close(fd);</span>
<span class="p_del">-					return 1;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 		kvp_file_info[i].fd = fd;
<span class="p_del">-		kvp_file_info[i].num_blocks = num_blocks;</span>
<span class="p_del">-		kvp_file_info[i].records = record;</span>
<span class="p_del">-		kvp_file_info[i].num_records = records_read;</span>
<span class="p_del">-		fclose(filep);</span>
<span class="p_del">-</span>
<span class="p_add">+		kvp_file_info[i].num_blocks = 1;</span>
<span class="p_add">+		kvp_file_info[i].records = malloc(alloc_unit);</span>
<span class="p_add">+		if (kvp_file_info[i].records == NULL)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		kvp_file_info[i].num_records = 0;</span>
<span class="p_add">+		kvp_update_mem_state(i);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/tools/testing/selftests/powerpc/harness.c b/tools/testing/selftests/powerpc/harness.c</span>
<span class="p_header">index f7997affd143..f45cee80c58b 100644</span>
<span class="p_header">--- a/tools/testing/selftests/powerpc/harness.c</span>
<span class="p_header">+++ b/tools/testing/selftests/powerpc/harness.c</span>
<span class="p_chunk">@@ -109,9 +109,11 @@</span> <span class="p_context"> int test_harness(int (test_function)(void), char *name)</span>
 
 	rc = run_test(test_function, name);
 
<span class="p_del">-	if (rc == MAGIC_SKIP_RETURN_VALUE)</span>
<span class="p_add">+	if (rc == MAGIC_SKIP_RETURN_VALUE) {</span>
 		test_skip(name);
<span class="p_del">-	else</span>
<span class="p_add">+		/* so that skipped test is not marked as failed */</span>
<span class="p_add">+		rc = 0;</span>
<span class="p_add">+	} else</span>
 		test_finish(name, rc);
 
 	return rc;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



