
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[draft] mm: use pagefault_disable() to check for disabled pagefaults in the handler - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [draft] mm: use pagefault_disable() to check for disabled pagefaults in the handler</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=103951">David Hildenbrand</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 7, 2015, 3:45 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1431013520-21543-1-git-send-email-dahi@linux.vnet.ibm.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6359241/mbox/"
   >mbox</a>
|
   <a href="/patch/6359241/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6359241/">/patch/6359241/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 10CCE9F32B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 15:45:56 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 1BA5620361
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 15:45:54 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id DE8EA203AA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 15:45:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751858AbbEGPpp (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 7 May 2015 11:45:45 -0400
Received: from e06smtp11.uk.ibm.com ([195.75.94.107]:60678 &quot;EHLO
	e06smtp11.uk.ibm.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751021AbbEGPpj (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 7 May 2015 11:45:39 -0400
Received: from /spool/local
	by e06smtp11.uk.ibm.com with IBM ESMTP SMTP Gateway: Authorized Use
	Only! Violators will be prosecuted
	for &lt;linux-kernel@vger.kernel.org&gt; from &lt;dahi@linux.vnet.ibm.com&gt;;
	Thu, 7 May 2015 16:45:37 +0100
Received: from d06dlp01.portsmouth.uk.ibm.com (9.149.20.13)
	by e06smtp11.uk.ibm.com (192.168.101.141) with IBM ESMTP SMTP
	Gateway: Authorized Use Only! Violators will be prosecuted; 
	Thu, 7 May 2015 16:45:35 +0100
Received: from b06cxnps3075.portsmouth.uk.ibm.com
	(d06relay10.portsmouth.uk.ibm.com [9.149.109.195])
	by d06dlp01.portsmouth.uk.ibm.com (Postfix) with ESMTP id
	41A3217D8056; Thu,  7 May 2015 16:46:20 +0100 (BST)
Received: from d06av07.portsmouth.uk.ibm.com (d06av07.portsmouth.uk.ibm.com
	[9.149.37.248])
	by b06cxnps3075.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
	ESMTP id t47FjYCv11207102; Thu, 7 May 2015 15:45:34 GMT
Received: from d06av07.portsmouth.uk.ibm.com (localhost [127.0.0.1])
	by d06av07.portsmouth.uk.ibm.com (8.14.4/8.14.4/NCO v10.0 AVout) with
	ESMTP id t47FjVql008046; Thu, 7 May 2015 11:45:34 -0400
Received: from tuxmaker.boeblingen.de.ibm.com
	(tuxmaker.boeblingen.de.ibm.com [9.152.85.9])
	by d06av07.portsmouth.uk.ibm.com (8.14.4/8.14.4/NCO v10.0 AVin) with
	ESMTP id t47FjU97008015; Thu, 7 May 2015 11:45:30 -0400
From: David Hildenbrand &lt;dahi@linux.vnet.ibm.com&gt;
To: linux-kernel@vger.kernel.org
Cc: dahi@linux.vnet.ibm.com, mingo@redhat.com, peterz@infradead.org,
	yang.shi@windriver.com, bigeasy@linutronix.de,
	benh@kernel.crashing.org, paulus@samba.org,
	akpm@linux-foundation.org, heiko.carstens@de.ibm.com,
	schwidefsky@de.ibm.com, borntraeger@de.ibm.com, mst@redhat.com,
	tglx@linutronix.de, David.Laight@ACULAB.COM, hughd@google.com,
	ralf@linux-mips.org, herbert@gondor.apana.org.au,
	linux@arm.linux.org.uk, airlied@linux.ie, daniel.vetter@intel.com,
	cmetcalf@ezchip.com, linux-mm@kvack.org, linux-arch@vger.kernel.org
Subject: [PATCH draft] mm: use pagefault_disable() to check for disabled
	pagefaults in the handler
Date: Thu,  7 May 2015 17:45:20 +0200
Message-Id: &lt;1431013520-21543-1-git-send-email-dahi@linux.vnet.ibm.com&gt;
X-Mailer: git-send-email 2.1.4
In-Reply-To: &lt;20150507115118.GT21418@twins.programming.kicks-ass.net&gt;
References: &lt;20150507115118.GT21418@twins.programming.kicks-ass.net&gt;
X-TM-AS-MML: disable
X-Content-Scanned: Fidelis XPS MAILER
x-cbid: 15050715-0041-0000-0000-0000045227E9
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=103951">David Hildenbrand</a> - May 7, 2015, 3:45 p.m.</div>
<pre class="content">
---- zip ---

This will replacement patch nr 6 if we have an agreement :)

So this is my suggestion to fix the irq context problem. We should not modify
pagefault_disabled() to check for in_atomic(), otherwise we can&#39;t reuse it
for might_fault()/might_sleep() checks.

This also allows to clean it up later (if ever :) ).

Thanks!

---- zip ---

Introduce faulthandler_disabled() and use it to check for irq context and
disabled pagefaults (via pagefault_disable()) in the pagefault handlers.

Please note that we keep the in_atomic() checks in place. This is needed
to detect irq context (in which case preemption is always properly disabled).

In contrast, preempt_disable() should never be used to disable pagefaults.
With !CONFIG_PREEMPT_COUNT, preempt_disable() doesn&#39;t modify the preempt
counter, and therefore the result of in_atomic() differs.
We validate that condition by using might_fault() checks when calling
might_sleep().

Therefore, we add an comment to faulthandler_disabled(), describing why this
is needed.

faulthandler_disabled() and pagefault_disable() are defined in
linux/uaccess.h, so let&#39;s properly add that include to all relevant files.

This patch is based on a patch from Thomas Gleixner.
<span class="signed-off-by">
Signed-off-by: David Hildenbrand &lt;dahi@linux.vnet.ibm.com&gt;</span>
---
 arch/alpha/mm/fault.c      |  5 ++---
 arch/arc/mm/fault.c        |  2 +-
 arch/arm/mm/fault.c        |  2 +-
 arch/arm64/mm/fault.c      |  2 +-
 arch/avr32/mm/fault.c      |  4 ++--
 arch/cris/mm/fault.c       |  6 +++---
 arch/frv/mm/fault.c        |  4 ++--
 arch/ia64/mm/fault.c       |  4 ++--
 arch/m32r/mm/fault.c       |  8 ++++----
 arch/m68k/mm/fault.c       |  4 ++--
 arch/metag/mm/fault.c      |  2 +-
 arch/microblaze/mm/fault.c |  8 ++++----
 arch/mips/mm/fault.c       |  4 ++--
 arch/mn10300/mm/fault.c    |  4 ++--
 arch/nios2/mm/fault.c      |  2 +-
 arch/parisc/kernel/traps.c |  4 ++--
 arch/parisc/mm/fault.c     |  4 ++--
 arch/powerpc/mm/fault.c    |  9 +++++----
 arch/s390/mm/fault.c       |  2 +-
 arch/score/mm/fault.c      |  3 ++-
 arch/sh/mm/fault.c         |  5 +++--
 arch/sparc/mm/fault_32.c   |  4 ++--
 arch/sparc/mm/fault_64.c   |  4 ++--
 arch/sparc/mm/init_64.c    |  2 +-
 arch/tile/mm/fault.c       |  4 ++--
 arch/um/kernel/trap.c      |  4 ++--
 arch/unicore32/mm/fault.c  |  2 +-
 arch/x86/mm/fault.c        |  5 +++--
 arch/xtensa/mm/fault.c     |  4 ++--
 include/linux/uaccess.h    | 12 ++++++++++++
 30 files changed, 72 insertions(+), 57 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/alpha/mm/fault.c b/arch/alpha/mm/fault.c</span>
<span class="p_header">index 9d0ac09..4a905bd 100644</span>
<span class="p_header">--- a/arch/alpha/mm/fault.c</span>
<span class="p_header">+++ b/arch/alpha/mm/fault.c</span>
<span class="p_chunk">@@ -23,8 +23,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/smp.h&gt;
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/module.h&gt;
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 extern void die_if_kernel(char *,struct pt_regs *,long, unsigned long *);
 
<span class="p_chunk">@@ -107,7 +106,7 @@</span> <span class="p_context"> do_page_fault(unsigned long address, unsigned long mmcsr,</span>
 
 	/* If we&#39;re in an interrupt context, or have no user context,
 	   we must not take the fault.  */
<span class="p_del">-	if (!mm || in_atomic())</span>
<span class="p_add">+	if (!mm || faulthandler_disabled())</span>
 		goto no_context;
 
 #ifdef CONFIG_ALPHA_LARGE_VMALLOC
<span class="p_header">diff --git a/arch/arc/mm/fault.c b/arch/arc/mm/fault.c</span>
<span class="p_header">index 6a2e006..d948e4e 100644</span>
<span class="p_header">--- a/arch/arc/mm/fault.c</span>
<span class="p_header">+++ b/arch/arc/mm/fault.c</span>
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"> void do_page_fault(unsigned long address, struct pt_regs *regs)</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c</span>
<span class="p_header">index 6333d9c..0d629b8 100644</span>
<span class="p_header">--- a/arch/arm/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm/mm/fault.c</span>
<span class="p_chunk">@@ -276,7 +276,7 @@</span> <span class="p_context"> do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c</span>
<span class="p_header">index 96da131..0948d32 100644</span>
<span class="p_header">--- a/arch/arm64/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm64/mm/fault.c</span>
<span class="p_chunk">@@ -211,7 +211,7 @@</span> <span class="p_context"> static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,</span>
 	 * If we&#39;re in an interrupt or have no user context, we must not take
 	 * the fault.
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/avr32/mm/fault.c b/arch/avr32/mm/fault.c</span>
<span class="p_header">index d223a8b..c035339 100644</span>
<span class="p_header">--- a/arch/avr32/mm/fault.c</span>
<span class="p_header">+++ b/arch/avr32/mm/fault.c</span>
<span class="p_chunk">@@ -14,11 +14,11 @@</span> <span class="p_context"></span>
 #include &lt;linux/pagemap.h&gt;
 #include &lt;linux/kdebug.h&gt;
 #include &lt;linux/kprobes.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/sysreg.h&gt;
 #include &lt;asm/tlb.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 
 #ifdef CONFIG_KPROBES
 static inline int notify_page_fault(struct pt_regs *regs, int trap)
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> asmlinkage void do_page_fault(unsigned long ecr, struct pt_regs *regs)</span>
 	 * If we&#39;re in an interrupt or have no user context, we must
 	 * not take the fault...
 	 */
<span class="p_del">-	if (in_atomic() || !mm || regs-&gt;sr &amp; SYSREG_BIT(GM))</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm || regs-&gt;sr &amp; SYSREG_BIT(GM))</span>
 		goto no_context;
 
 	local_irq_enable();
<span class="p_header">diff --git a/arch/cris/mm/fault.c b/arch/cris/mm/fault.c</span>
<span class="p_header">index 83f12f2..3066d40 100644</span>
<span class="p_header">--- a/arch/cris/mm/fault.c</span>
<span class="p_header">+++ b/arch/cris/mm/fault.c</span>
<span class="p_chunk">@@ -8,7 +8,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/wait.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 #include &lt;arch/system.h&gt;
 
 extern int find_fixup_code(struct pt_regs *);
<span class="p_chunk">@@ -109,11 +109,11 @@</span> <span class="p_context"> do_page_fault(unsigned long address, struct pt_regs *regs,</span>
 	info.si_code = SEGV_MAPERR;
 
 	/*
<span class="p_del">-	 * If we&#39;re in an interrupt or &quot;atomic&quot; operation or have no</span>
<span class="p_add">+	 * If we&#39;re in an interrupt, have pagefaults disabled or have no</span>
 	 * user context, we must not take the fault.
 	 */
 
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/frv/mm/fault.c b/arch/frv/mm/fault.c</span>
<span class="p_header">index ec4917d..61d9976 100644</span>
<span class="p_header">--- a/arch/frv/mm/fault.c</span>
<span class="p_header">+++ b/arch/frv/mm/fault.c</span>
<span class="p_chunk">@@ -19,9 +19,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/ptrace.h&gt;
 #include &lt;linux/hardirq.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/pgtable.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/gdb-stub.h&gt;
 
 /*****************************************************************************/
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> asmlinkage void do_page_fault(int datammu, unsigned long esr0, unsigned long ear</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 	if (user_mode(__frame))
<span class="p_header">diff --git a/arch/ia64/mm/fault.c b/arch/ia64/mm/fault.c</span>
<span class="p_header">index ba5ba7a..70b40d1 100644</span>
<span class="p_header">--- a/arch/ia64/mm/fault.c</span>
<span class="p_header">+++ b/arch/ia64/mm/fault.c</span>
<span class="p_chunk">@@ -11,10 +11,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/kprobes.h&gt;
 #include &lt;linux/kdebug.h&gt;
 #include &lt;linux/prefetch.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/processor.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 
 extern int die(char *, struct pt_regs *, long);
 
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *re</span>
 	/*
 	 * If we&#39;re in an interrupt or have no user context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 #ifdef CONFIG_VIRTUAL_MEM_MAP
<span class="p_header">diff --git a/arch/m32r/mm/fault.c b/arch/m32r/mm/fault.c</span>
<span class="p_header">index e3d4d48901..8f9875b 100644</span>
<span class="p_header">--- a/arch/m32r/mm/fault.c</span>
<span class="p_header">+++ b/arch/m32r/mm/fault.c</span>
<span class="p_chunk">@@ -24,9 +24,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/vt_kern.h&gt;		/* For unblank_screen() */
 #include &lt;linux/highmem.h&gt;
 #include &lt;linux/module.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/m32r.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/hardirq.h&gt;
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/tlbflush.h&gt;
<span class="p_chunk">@@ -111,10 +111,10 @@</span> <span class="p_context"> asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code,</span>
 	mm = tsk-&gt;mm;
 
 	/*
<span class="p_del">-	 * If we&#39;re in an interrupt or have no user context or are running in an</span>
<span class="p_del">-	 * atomic region then we must not take the fault..</span>
<span class="p_add">+	 * If we&#39;re in an interrupt or have no user context or have pagefaults</span>
<span class="p_add">+	 * disabled then we must not take the fault.</span>
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto bad_area_nosemaphore;
 
 	if (error_code &amp; ACE_USERMODE)
<span class="p_header">diff --git a/arch/m68k/mm/fault.c b/arch/m68k/mm/fault.c</span>
<span class="p_header">index b2f04ae..6a94cdd 100644</span>
<span class="p_header">--- a/arch/m68k/mm/fault.c</span>
<span class="p_header">+++ b/arch/m68k/mm/fault.c</span>
<span class="p_chunk">@@ -10,10 +10,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/ptrace.h&gt;
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/module.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/traps.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/pgalloc.h&gt;
 
 extern void die_if_kernel(char *, struct pt_regs *, long);
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> int do_page_fault(struct pt_regs *regs, unsigned long address,</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/metag/mm/fault.c b/arch/metag/mm/fault.c</span>
<span class="p_header">index 2de5dc6..f57edca 100644</span>
<span class="p_header">--- a/arch/metag/mm/fault.c</span>
<span class="p_header">+++ b/arch/metag/mm/fault.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> int do_page_fault(struct pt_regs *regs, unsigned long address,</span>
 
 	mm = tsk-&gt;mm;
 
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/microblaze/mm/fault.c b/arch/microblaze/mm/fault.c</span>
<span class="p_header">index d46a5eb..177dfc0 100644</span>
<span class="p_header">--- a/arch/microblaze/mm/fault.c</span>
<span class="p_header">+++ b/arch/microblaze/mm/fault.c</span>
<span class="p_chunk">@@ -107,14 +107,14 @@</span> <span class="p_context"> void do_page_fault(struct pt_regs *regs, unsigned long address,</span>
 	if ((error_code &amp; 0x13) == 0x13 || (error_code &amp; 0x11) == 0x11)
 		is_write = 0;
 
<span class="p_del">-	if (unlikely(in_atomic() || !mm)) {</span>
<span class="p_add">+	if (unlikely(faulthandler_disabled() || !mm)) {</span>
 		if (kernel_mode(regs))
 			goto bad_area_nosemaphore;
 
<span class="p_del">-		/* in_atomic() in user mode is really bad,</span>
<span class="p_add">+		/* faulthandler_disabled() in user mode is really bad,</span>
 		   as is current-&gt;mm == NULL. */
<span class="p_del">-		pr_emerg(&quot;Page fault in user mode with in_atomic(), mm = %p\n&quot;,</span>
<span class="p_del">-									mm);</span>
<span class="p_add">+		pr_emerg(&quot;Page fault in user mode with faulthandler_disabled(), mm = %p\n&quot;,</span>
<span class="p_add">+			 mm);</span>
 		pr_emerg(&quot;r15 = %lx  MSR = %lx\n&quot;,
 		       regs-&gt;r15, regs-&gt;msr);
 		die(&quot;Weird page fault&quot;, regs, SIGSEGV);
<span class="p_header">diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c</span>
<span class="p_header">index 7ff8637..36c0f26 100644</span>
<span class="p_header">--- a/arch/mips/mm/fault.c</span>
<span class="p_header">+++ b/arch/mips/mm/fault.c</span>
<span class="p_chunk">@@ -21,10 +21,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kprobes.h&gt;
 #include &lt;linux/perf_event.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/branch.h&gt;
 #include &lt;asm/mmu_context.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/ptrace.h&gt;
 #include &lt;asm/highmem.h&gt;		/* For VMALLOC_END */
 #include &lt;linux/kdebug.h&gt;
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"> static void __kprobes __do_page_fault(struct pt_regs *regs, unsigned long write,</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto bad_area_nosemaphore;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/mn10300/mm/fault.c b/arch/mn10300/mm/fault.c</span>
<span class="p_header">index 0c2cc5d..4a1d181 100644</span>
<span class="p_header">--- a/arch/mn10300/mm/fault.c</span>
<span class="p_header">+++ b/arch/mn10300/mm/fault.c</span>
<span class="p_chunk">@@ -23,8 +23,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/vt_kern.h&gt;		/* For unblank_screen() */
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/pgalloc.h&gt;
 #include &lt;asm/hardirq.h&gt;
 #include &lt;asm/cpu-regs.h&gt;
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long fault_code,</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 	if ((fault_code &amp; MMUFCR_xFC_ACCESS) == MMUFCR_xFC_ACCESS_USR)
<span class="p_header">diff --git a/arch/nios2/mm/fault.c b/arch/nios2/mm/fault.c</span>
<span class="p_header">index 0c9b6af..b51878b 100644</span>
<span class="p_header">--- a/arch/nios2/mm/fault.c</span>
<span class="p_header">+++ b/arch/nios2/mm/fault.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long cause,</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto bad_area_nosemaphore;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/parisc/kernel/traps.c b/arch/parisc/kernel/traps.c</span>
<span class="p_header">index 47ee620..6548fd1 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/traps.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/traps.c</span>
<span class="p_chunk">@@ -26,9 +26,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/console.h&gt;
 #include &lt;linux/bug.h&gt;
 #include &lt;linux/ratelimit.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/assembly.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/io.h&gt;
 #include &lt;asm/irq.h&gt;
 #include &lt;asm/traps.h&gt;
<span class="p_chunk">@@ -800,7 +800,7 @@</span> <span class="p_context"> void notrace handle_interruption(int code, struct pt_regs *regs)</span>
 	     * unless pagefault_disable() was called before.
 	     */
 
<span class="p_del">-	    if (fault_space == 0 &amp;&amp; !in_atomic())</span>
<span class="p_add">+	    if (fault_space == 0 &amp;&amp; !faulthandler_disabled())</span>
 	    {
 		pdc_chassis_send_status(PDC_CHASSIS_DIRECT_PANIC);
 		parisc_terminate(&quot;Kernel Fault&quot;, regs, code, fault_address);
<span class="p_header">diff --git a/arch/parisc/mm/fault.c b/arch/parisc/mm/fault.c</span>
<span class="p_header">index e5120e6..15503ad 100644</span>
<span class="p_header">--- a/arch/parisc/mm/fault.c</span>
<span class="p_header">+++ b/arch/parisc/mm/fault.c</span>
<span class="p_chunk">@@ -15,8 +15,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/module.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/traps.h&gt;
 
 /* Various important other fields */
<span class="p_chunk">@@ -207,7 +207,7 @@</span> <span class="p_context"> void do_page_fault(struct pt_regs *regs, unsigned long code,</span>
 	int fault;
 	unsigned int flags;
 
<span class="p_del">-	if (in_atomic())</span>
<span class="p_add">+	if (pagefault_disabled())</span>
 		goto no_context;
 
 	tsk = current;
<span class="p_header">diff --git a/arch/powerpc/mm/fault.c b/arch/powerpc/mm/fault.c</span>
<span class="p_header">index b396868..6d53597 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/fault.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/fault.c</span>
<span class="p_chunk">@@ -33,13 +33,13 @@</span> <span class="p_context"></span>
 #include &lt;linux/ratelimit.h&gt;
 #include &lt;linux/context_tracking.h&gt;
 #include &lt;linux/hugetlb.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/firmware.h&gt;
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/mmu.h&gt;
 #include &lt;asm/mmu_context.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/siginfo.h&gt;
 #include &lt;asm/debug.h&gt;
<span class="p_chunk">@@ -272,15 +272,16 @@</span> <span class="p_context"> int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address,</span>
 	if (!arch_irq_disabled_regs(regs))
 		local_irq_enable();
 
<span class="p_del">-	if (in_atomic() || mm == NULL) {</span>
<span class="p_add">+	if (faulthandler_disabled() || mm == NULL) {</span>
 		if (!user_mode(regs)) {
 			rc = SIGSEGV;
 			goto bail;
 		}
<span class="p_del">-		/* in_atomic() in user mode is really bad,</span>
<span class="p_add">+		/* faulthandler_disabled() in user mode is really bad,</span>
 		   as is current-&gt;mm == NULL. */
 		printk(KERN_EMERG &quot;Page fault in user mode with &quot;
<span class="p_del">-		       &quot;in_atomic() = %d mm = %p\n&quot;, in_atomic(), mm);</span>
<span class="p_add">+		       &quot;faulthandler_disabled() = %d mm = %p\n&quot;,</span>
<span class="p_add">+		       faulthandler_disabled(), mm);</span>
 		printk(KERN_EMERG &quot;NIP = %lx  MSR = %lx\n&quot;,
 		       regs-&gt;nip, regs-&gt;msr);
 		die(&quot;Weird page fault&quot;, regs, SIGSEGV);
<span class="p_header">diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c</span>
<span class="p_header">index 76515bc..4c8f5d7 100644</span>
<span class="p_header">--- a/arch/s390/mm/fault.c</span>
<span class="p_header">+++ b/arch/s390/mm/fault.c</span>
<span class="p_chunk">@@ -399,7 +399,7 @@</span> <span class="p_context"> static inline int do_exception(struct pt_regs *regs, int access)</span>
 	 * user context.
 	 */
 	fault = VM_FAULT_BADCONTEXT;
<span class="p_del">-	if (unlikely(!user_space_fault(regs) || in_atomic() || !mm))</span>
<span class="p_add">+	if (unlikely(!user_space_fault(regs) || faulthandler_disabled() || !mm))</span>
 		goto out;
 
 	address = trans_exc_code &amp; __FAIL_ADDR_MASK;
<span class="p_header">diff --git a/arch/score/mm/fault.c b/arch/score/mm/fault.c</span>
<span class="p_header">index 6860beb..37a6c2e 100644</span>
<span class="p_header">--- a/arch/score/mm/fault.c</span>
<span class="p_header">+++ b/arch/score/mm/fault.c</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/string.h&gt;
 #include &lt;linux/types.h&gt;
 #include &lt;linux/ptrace.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 /*
  * This routine handles page faults.  It determines the address,
<span class="p_chunk">@@ -73,7 +74,7 @@</span> <span class="p_context"> asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long write,</span>
 	* If we&#39;re in an interrupt or have no user
 	* context, we must not take the fault..
 	*/
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (pagefault_disabled() || !mm)</span>
 		goto bad_area_nosemaphore;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/sh/mm/fault.c b/arch/sh/mm/fault.c</span>
<span class="p_header">index a58fec9..79d8276 100644</span>
<span class="p_header">--- a/arch/sh/mm/fault.c</span>
<span class="p_header">+++ b/arch/sh/mm/fault.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kprobes.h&gt;
 #include &lt;linux/perf_event.h&gt;
 #include &lt;linux/kdebug.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 #include &lt;asm/io_trapped.h&gt;
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/tlbflush.h&gt;
<span class="p_chunk">@@ -438,9 +439,9 @@</span> <span class="p_context"> asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,</span>
 
 	/*
 	 * If we&#39;re in an interrupt, have no user context or are running
<span class="p_del">-	 * in an atomic region then we must not take the fault:</span>
<span class="p_add">+	 * with pagefaults disabled then we must not take the fault:</span>
 	 */
<span class="p_del">-	if (unlikely(in_atomic() || !mm)) {</span>
<span class="p_add">+	if (unlikely(faulthandler_disabled() || !mm)) {</span>
 		bad_area_nosemaphore(regs, error_code, address);
 		return;
 	}
<span class="p_header">diff --git a/arch/sparc/mm/fault_32.c b/arch/sparc/mm/fault_32.c</span>
<span class="p_header">index 70d8171..c399e7b 100644</span>
<span class="p_header">--- a/arch/sparc/mm/fault_32.c</span>
<span class="p_header">+++ b/arch/sparc/mm/fault_32.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/perf_event.h&gt;
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/kdebug.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_chunk">@@ -29,7 +30,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/smp.h&gt;
 #include &lt;asm/traps.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 
 #include &quot;mm_32.h&quot;
 
<span class="p_chunk">@@ -196,7 +196,7 @@</span> <span class="p_context"> asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (pagefault_disabled() || !mm)</span>
 		goto no_context;
 
 	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
<span class="p_header">diff --git a/arch/sparc/mm/fault_64.c b/arch/sparc/mm/fault_64.c</span>
<span class="p_header">index 4798232..e9268ea 100644</span>
<span class="p_header">--- a/arch/sparc/mm/fault_64.c</span>
<span class="p_header">+++ b/arch/sparc/mm/fault_64.c</span>
<span class="p_chunk">@@ -22,12 +22,12 @@</span> <span class="p_context"></span>
 #include &lt;linux/kdebug.h&gt;
 #include &lt;linux/percpu.h&gt;
 #include &lt;linux/context_tracking.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/openprom.h&gt;
 #include &lt;asm/oplib.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/asi.h&gt;
 #include &lt;asm/lsu.h&gt;
 #include &lt;asm/sections.h&gt;
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto intr_or_no_mm;
 
 	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
<span class="p_header">diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c</span>
<span class="p_header">index 4ca0d6b..cee9b77 100644</span>
<span class="p_header">--- a/arch/sparc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/sparc/mm/init_64.c</span>
<span class="p_chunk">@@ -2706,7 +2706,7 @@</span> <span class="p_context"> void hugetlb_setup(struct pt_regs *regs)</span>
 	struct mm_struct *mm = current-&gt;mm;
 	struct tsb_config *tp;
 
<span class="p_del">-	if (in_atomic() || !mm) {</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm) {</span>
 		const struct exception_table_entry *entry;
 
 		entry = search_exception_tables(regs-&gt;tpc);
<span class="p_header">diff --git a/arch/tile/mm/fault.c b/arch/tile/mm/fault.c</span>
<span class="p_header">index e83cc99..3f4f58d 100644</span>
<span class="p_header">--- a/arch/tile/mm/fault.c</span>
<span class="p_header">+++ b/arch/tile/mm/fault.c</span>
<span class="p_chunk">@@ -354,9 +354,9 @@</span> <span class="p_context"> static int handle_page_fault(struct pt_regs *regs,</span>
 
 	/*
 	 * If we&#39;re in an interrupt, have no user context or are running in an
<span class="p_del">-	 * atomic region then we must not take the fault.</span>
<span class="p_add">+	 * region with pagefaults disabled then we must not take the fault.</span>
 	 */
<span class="p_del">-	if (in_atomic() || !mm) {</span>
<span class="p_add">+	if (pagefault_disabled() || !mm) {</span>
 		vma = NULL;  /* happy compiler */
 		goto bad_area_nosemaphore;
 	}
<span class="p_header">diff --git a/arch/um/kernel/trap.c b/arch/um/kernel/trap.c</span>
<span class="p_header">index 8e4daf4..f9c9e5a 100644</span>
<span class="p_header">--- a/arch/um/kernel/trap.c</span>
<span class="p_header">+++ b/arch/um/kernel/trap.c</span>
<span class="p_chunk">@@ -35,10 +35,10 @@</span> <span class="p_context"> int handle_page_fault(unsigned long address, unsigned long ip,</span>
 	*code_out = SEGV_MAPERR;
 
 	/*
<span class="p_del">-	 * If the fault was during atomic operation, don&#39;t take the fault, just</span>
<span class="p_add">+	 * If the fault was with pagefaults disabled, don&#39;t take the fault, just</span>
 	 * fail.
 	 */
<span class="p_del">-	if (in_atomic())</span>
<span class="p_add">+	if (faulthandler_disabled())</span>
 		goto out_nosemaphore;
 
 	if (is_user)
<span class="p_header">diff --git a/arch/unicore32/mm/fault.c b/arch/unicore32/mm/fault.c</span>
<span class="p_header">index 0dc922d..afccef552 100644</span>
<span class="p_header">--- a/arch/unicore32/mm/fault.c</span>
<span class="p_header">+++ b/arch/unicore32/mm/fault.c</span>
<span class="p_chunk">@@ -218,7 +218,7 @@</span> <span class="p_context"> static int do_pf(unsigned long addr, unsigned int fsr, struct pt_regs *regs)</span>
 	 * If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm)</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm)</span>
 		goto no_context;
 
 	if (user_mode(regs))
<span class="p_header">diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c</span>
<span class="p_header">index 181c53b..9dc9098 100644</span>
<span class="p_header">--- a/arch/x86/mm/fault.c</span>
<span class="p_header">+++ b/arch/x86/mm/fault.c</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/hugetlb.h&gt;		/* hstate_index_to_shift	*/
 #include &lt;linux/prefetch.h&gt;		/* prefetchw			*/
 #include &lt;linux/context_tracking.h&gt;	/* exception_enter(), ...	*/
<span class="p_add">+#include &lt;linux/uaccess.h&gt;		/* faulthandler_disabled()	*/</span>
 
 #include &lt;asm/traps.h&gt;			/* dotraplinkage, ...		*/
 #include &lt;asm/pgalloc.h&gt;		/* pgd_*(), ...			*/
<span class="p_chunk">@@ -1126,9 +1127,9 @@</span> <span class="p_context"> __do_page_fault(struct pt_regs *regs, unsigned long error_code,</span>
 
 	/*
 	 * If we&#39;re in an interrupt, have no user context or are running
<span class="p_del">-	 * in an atomic region then we must not take the fault:</span>
<span class="p_add">+	 * in a region with pagefaults disabled then we must not take the fault</span>
 	 */
<span class="p_del">-	if (unlikely(in_atomic() || !mm)) {</span>
<span class="p_add">+	if (unlikely(faulthandler_disabled() || !mm)) {</span>
 		bad_area_nosemaphore(regs, error_code, address);
 		return;
 	}
<span class="p_header">diff --git a/arch/xtensa/mm/fault.c b/arch/xtensa/mm/fault.c</span>
<span class="p_header">index 9e3571a..83a44a3 100644</span>
<span class="p_header">--- a/arch/xtensa/mm/fault.c</span>
<span class="p_header">+++ b/arch/xtensa/mm/fault.c</span>
<span class="p_chunk">@@ -15,10 +15,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/hardirq.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/cacheflush.h&gt;
 #include &lt;asm/hardirq.h&gt;
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
 #include &lt;asm/pgalloc.h&gt;
 
 DEFINE_PER_CPU(unsigned long, asid_cache) = ASID_USER_FIRST;
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> void do_page_fault(struct pt_regs *regs)</span>
 	/* If we&#39;re in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
<span class="p_del">-	if (in_atomic() || !mm) {</span>
<span class="p_add">+	if (faulthandler_disabled() || !mm) {</span>
 		bad_page_fault(regs, address, SIGSEGV);
 		return;
 	}
<span class="p_header">diff --git a/include/linux/uaccess.h b/include/linux/uaccess.h</span>
<span class="p_header">index 23290cc..90786d2 100644</span>
<span class="p_header">--- a/include/linux/uaccess.h</span>
<span class="p_header">+++ b/include/linux/uaccess.h</span>
<span class="p_chunk">@@ -59,6 +59,18 @@</span> <span class="p_context"> static inline void pagefault_enable(void)</span>
  */
 #define pagefault_disabled() (current-&gt;pagefault_disabled != 0)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The pagefault handler is in general disabled by pagefault_disable() or</span>
<span class="p_add">+ * when in irq context (via in_atomic()).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function should only be used by the fault handlers. Other users should</span>
<span class="p_add">+ * stick to pagefault_disabled().</span>
<span class="p_add">+ * Please NEVER use preempt_disable() to disable the fault handler. With</span>
<span class="p_add">+ * !CONFIG_PREEMPT_COUNT, this is like a NOP. So the handler won&#39;t be disabled.</span>
<span class="p_add">+ * in_atomic() will report different values based on !CONFIG_PREEMPT_COUNT.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define faulthandler_disabled() (pagefault_disabled() || in_atomic())</span>
<span class="p_add">+</span>
 #ifndef ARCH_HAS_NOCACHE_UACCESS
 
 static inline unsigned long __copy_from_user_inatomic_nocache(void *to,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



