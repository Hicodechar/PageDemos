
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3/9] iommu: Introduce iommu do invalidate API function - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3/9] iommu: Introduce iommu do invalidate API function</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 27, 2017, 7:47 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1498592883-56224-4-git-send-email-jacob.jun.pan@linux.intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9813031/mbox/"
   >mbox</a>
|
   <a href="/patch/9813031/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9813031/">/patch/9813031/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4FFF160210 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 27 Jun 2017 19:46:55 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E85E327F90
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 27 Jun 2017 19:46:54 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id DC3F728448; Tue, 27 Jun 2017 19:46:54 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6C1B627F90
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 27 Jun 2017 19:46:54 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753629AbdF0Tqp (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 27 Jun 2017 15:46:45 -0400
Received: from mga04.intel.com ([192.55.52.120]:37142 &quot;EHLO mga04.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1753499AbdF0Tqe (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 27 Jun 2017 15:46:34 -0400
Received: from orsmga002.jf.intel.com ([10.7.209.21])
	by fmsmga104.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384;
	27 Jun 2017 12:46:32 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.40,271,1496127600&quot;; d=&quot;scan&#39;208&quot;;a=&quot;104284146&quot;
Received: from jacob-builder.jf.intel.com ([10.7.199.158])
	by orsmga002.jf.intel.com with ESMTP; 27 Jun 2017 12:46:32 -0700
From: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;
To: iommu@lists.linux-foundation.org, LKML &lt;linux-kernel@vger.kernel.org&gt;,
	Joerg Roedel &lt;joro@8bytes.org&gt;, David Woodhouse &lt;dwmw2@infradead.org&gt;
Cc: &quot;Liu, Yi L&quot; &lt;yi.l.liu@intel.com&gt;, Lan Tianyu &lt;tianyu.lan@intel.com&gt;,
	&quot;Tian, Kevin&quot; &lt;kevin.tian@intel.com&gt;, Raj Ashok &lt;ashok.raj@intel.com&gt;,
	Alex Williamson &lt;alex.williamson@redhat.com&gt;,
	Jean Delvare &lt;khali@linux-fr.org&gt;,
	&quot;Liu, Yi L&quot; &lt;yi.l.liu@linux.intel.com&gt;, Liu@vger.kernel.org,
	Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;
Subject: [PATCH 3/9] iommu: Introduce iommu do invalidate API function
Date: Tue, 27 Jun 2017 12:47:57 -0700
Message-Id: &lt;1498592883-56224-4-git-send-email-jacob.jun.pan@linux.intel.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1498592883-56224-1-git-send-email-jacob.jun.pan@linux.intel.com&gt;
References: &lt;1498592883-56224-1-git-send-email-jacob.jun.pan@linux.intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - June 27, 2017, 7:47 p.m.</div>
<pre class="content">
<span class="from">From: &quot;Liu, Yi L&quot; &lt;yi.l.liu@linux.intel.com&gt;</span>

When a SVM capable device is assigned to a guest, the first level page
tables are owned by the guest and the guest PASID table pointer is
linked to the device context entry of the physical IOMMU.

Host IOMMU driver has no knowledge of caching structure updates unless
the guest invalidation activities are passed down to the host. The
primary usage is derived from emulated IOMMU in the guest, where QEMU
can trap invalidation activities before pass them down the
host/physical IOMMU. There are IOMMU architectural specific actions
need to be taken which requires the generic APIs introduced in this
patch to have opaque data in the tlb_invalidate_info argument.
<span class="signed-off-by">
Signed-off-by: Liu, Yi L &lt;yi.l.liu@linux.intel.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
---
 drivers/iommu/iommu.c      | 14 ++++++++++++++
 include/linux/iommu.h      | 12 ++++++++++++
 include/uapi/linux/iommu.h | 13 +++++++++++++
 3 files changed, 39 insertions(+)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - June 28, 2017, 10:08 a.m.</div>
<pre class="content">
On Tue, Jun 27, 2017 at 12:47:57PM -0700, Jacob Pan wrote:
<span class="quote">&gt; From: &quot;Liu, Yi L&quot; &lt;yi.l.liu@linux.intel.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; When a SVM capable device is assigned to a guest, the first level page</span>
<span class="quote">&gt; tables are owned by the guest and the guest PASID table pointer is</span>
<span class="quote">&gt; linked to the device context entry of the physical IOMMU.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Host IOMMU driver has no knowledge of caching structure updates unless</span>
<span class="quote">&gt; the guest invalidation activities are passed down to the host. The</span>
<span class="quote">&gt; primary usage is derived from emulated IOMMU in the guest, where QEMU</span>
<span class="quote">&gt; can trap invalidation activities before pass them down the</span>
<span class="quote">&gt; host/physical IOMMU. There are IOMMU architectural specific actions</span>
<span class="quote">&gt; need to be taken which requires the generic APIs introduced in this</span>
<span class="quote">&gt; patch to have opaque data in the tlb_invalidate_info argument.</span>

Which &quot;IOMMU architectural specific actions&quot; are you thinking of?
<span class="quote">
&gt; +int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="quote">&gt; +		struct device *dev, struct tlb_invalidate_info *inv_info)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (unlikely(!domain-&gt;ops-&gt;invalidate))</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = domain-&gt;ops-&gt;invalidate(domain, dev, inv_info);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(iommu_invalidate);</span>

[...]
<span class="quote">
&gt; +struct tlb_invalidate_info {</span>
<span class="quote">&gt; +	__u32	model;</span>
<span class="quote">&gt; +	__u32	length;</span>
<span class="quote">&gt; +	__u8	opaque[];</span>
<span class="quote">&gt; +};</span>

This interface is aweful. It requires the user of a generic api to know
details about the implementation behind to do anything useful.

Please explain in more detail why this is needed. My feeling is that we
can make this more generic with a small set of invalidation functions in
the iommu-api.



	Joerg
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - June 28, 2017, 4:09 p.m.</div>
<pre class="content">
On Wed, 28 Jun 2017 12:08:23 +0200
Joerg Roedel &lt;joro@8bytes.org&gt; wrote:
<span class="quote">
&gt; On Tue, Jun 27, 2017 at 12:47:57PM -0700, Jacob Pan wrote:</span>
<span class="quote">&gt; &gt; From: &quot;Liu, Yi L&quot; &lt;yi.l.liu@linux.intel.com&gt;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; When a SVM capable device is assigned to a guest, the first level</span>
<span class="quote">&gt; &gt; page tables are owned by the guest and the guest PASID table</span>
<span class="quote">&gt; &gt; pointer is linked to the device context entry of the physical IOMMU.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Host IOMMU driver has no knowledge of caching structure updates</span>
<span class="quote">&gt; &gt; unless the guest invalidation activities are passed down to the</span>
<span class="quote">&gt; &gt; host. The primary usage is derived from emulated IOMMU in the</span>
<span class="quote">&gt; &gt; guest, where QEMU can trap invalidation activities before pass them</span>
<span class="quote">&gt; &gt; down the host/physical IOMMU. There are IOMMU architectural</span>
<span class="quote">&gt; &gt; specific actions need to be taken which requires the generic APIs</span>
<span class="quote">&gt; &gt; introduced in this patch to have opaque data in the</span>
<span class="quote">&gt; &gt; tlb_invalidate_info argument.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Which &quot;IOMMU architectural specific actions&quot; are you thinking of?</span>
<span class="quote">&gt; </span>
construction of queued invalidation descriptors, then submit them to
the IOMMU QI interface.
<span class="quote">&gt; &gt; +int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; +		struct device *dev, struct tlb_invalidate_info</span>
<span class="quote">&gt; &gt; *inv_info) +{</span>
<span class="quote">&gt; &gt; +	int ret = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (unlikely(!domain-&gt;ops-&gt;invalidate))</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = domain-&gt;ops-&gt;invalidate(domain, dev, inv_info);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +EXPORT_SYMBOL_GPL(iommu_invalidate);  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +struct tlb_invalidate_info {</span>
<span class="quote">&gt; &gt; +	__u32	model;</span>
<span class="quote">&gt; &gt; +	__u32	length;</span>
<span class="quote">&gt; &gt; +	__u8	opaque[];</span>
<span class="quote">&gt; &gt; +};  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This interface is aweful. It requires the user of a generic api to</span>
<span class="quote">&gt; know details about the implementation behind to do anything useful.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Please explain in more detail why this is needed. My feeling is that</span>
<span class="quote">&gt; we can make this more generic with a small set of invalidation</span>
<span class="quote">&gt; functions in the iommu-api.</span>
<span class="quote">&gt; </span>
My thinking was that via configuration control, there will be unlikely
any mixed IOMMU models between pIOMMU and vIOMMU. We could have just
model specific data pass through layers of SW (QEMU, VFIO) for
performance reasons. We do have an earlier hybrid version that has
generic data and opaque raw data. Would the below work for all IOMMU
models?

https://www.spinics.net/lists/kvm/msg148798.html

struct tlb_invalidate_info
{
        __u32   model;  /* Vendor number */
        __u8 granularity
#define DEVICE_SELECTVIE_INV    (1 &lt;&lt; 0)
#define PAGE_SELECTIVE_INV      (1 &lt;&lt; 0)
#define PASID_SELECTIVE_INV     (1 &lt;&lt; 1)
        __u32 pasid;
        __u64 addr;
        __u64 size;

        /* Since IOMMU format has already been validated for this table,
           the IOMMU driver knows that the following structure is in a
           format it knows */
        __u8 opaque[];
};
<span class="quote">
&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	Joerg</span>
<span class="quote">&gt; </span>

[Jacob Pan]
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - June 28, 2017, 5:07 p.m.</div>
<pre class="content">
On 28/06/17 17:09, Jacob Pan wrote:
<span class="quote">&gt; On Wed, 28 Jun 2017 12:08:23 +0200</span>
<span class="quote">&gt; Joerg Roedel &lt;joro@8bytes.org&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; On Tue, Jun 27, 2017 at 12:47:57PM -0700, Jacob Pan wrote:</span>
<span class="quote">&gt;&gt;&gt; From: &quot;Liu, Yi L&quot; &lt;yi.l.liu@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; When a SVM capable device is assigned to a guest, the first level</span>
<span class="quote">&gt;&gt;&gt; page tables are owned by the guest and the guest PASID table</span>
<span class="quote">&gt;&gt;&gt; pointer is linked to the device context entry of the physical IOMMU.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Host IOMMU driver has no knowledge of caching structure updates</span>
<span class="quote">&gt;&gt;&gt; unless the guest invalidation activities are passed down to the</span>
<span class="quote">&gt;&gt;&gt; host. The primary usage is derived from emulated IOMMU in the</span>
<span class="quote">&gt;&gt;&gt; guest, where QEMU can trap invalidation activities before pass them</span>
<span class="quote">&gt;&gt;&gt; down the host/physical IOMMU. There are IOMMU architectural</span>
<span class="quote">&gt;&gt;&gt; specific actions need to be taken which requires the generic APIs</span>
<span class="quote">&gt;&gt;&gt; introduced in this patch to have opaque data in the</span>
<span class="quote">&gt;&gt;&gt; tlb_invalidate_info argument.  </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Which &quot;IOMMU architectural specific actions&quot; are you thinking of?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; construction of queued invalidation descriptors, then submit them to</span>
<span class="quote">&gt; the IOMMU QI interface.</span>
<span class="quote">&gt;&gt;&gt; +int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="quote">&gt;&gt;&gt; +		struct device *dev, struct tlb_invalidate_info</span>
<span class="quote">&gt;&gt;&gt; *inv_info) +{</span>
<span class="quote">&gt;&gt;&gt; +	int ret = 0;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	if (unlikely(!domain-&gt;ops-&gt;invalidate))</span>
<span class="quote">&gt;&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	ret = domain-&gt;ops-&gt;invalidate(domain, dev, inv_info);</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	return ret;</span>
<span class="quote">&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt; +EXPORT_SYMBOL_GPL(iommu_invalidate);  </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +struct tlb_invalidate_info {</span>
<span class="quote">&gt;&gt;&gt; +	__u32	model;</span>
<span class="quote">&gt;&gt;&gt; +	__u32	length;</span>
<span class="quote">&gt;&gt;&gt; +	__u8	opaque[];</span>
<span class="quote">&gt;&gt;&gt; +};  </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This interface is aweful. It requires the user of a generic api to</span>
<span class="quote">&gt;&gt; know details about the implementation behind to do anything useful.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Please explain in more detail why this is needed. My feeling is that</span>
<span class="quote">&gt;&gt; we can make this more generic with a small set of invalidation</span>
<span class="quote">&gt;&gt; functions in the iommu-api.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; My thinking was that via configuration control, there will be unlikely</span>
<span class="quote">&gt; any mixed IOMMU models between pIOMMU and vIOMMU. We could have just</span>
<span class="quote">&gt; model specific data pass through layers of SW (QEMU, VFIO) for</span>
<span class="quote">&gt; performance reasons. We do have an earlier hybrid version that has</span>
<span class="quote">&gt; generic data and opaque raw data. Would the below work for all IOMMU</span>
<span class="quote">&gt; models?</span>

For reference, this was also discussed in the initial posting of the series:
https://lists.gnu.org/archive/html/qemu-devel/2017-05/msg03452.html

At least for ARM SMMUv2 and v3, I think the invalidation format you
propose should be sufficient, although &quot;device_selective&quot; should probably
be &quot;domain_selective&quot;. And maybe a flag field could contain relatively
generic hints such as &quot;only invalidate leaf table when page_selective&quot;.

Thanks,
Jean
<span class="quote">
&gt; https://www.spinics.net/lists/kvm/msg148798.html</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; struct tlb_invalidate_info</span>
<span class="quote">&gt; {</span>
<span class="quote">&gt;         __u32   model;  /* Vendor number */</span>
<span class="quote">&gt;         __u8 granularity</span>
<span class="quote">&gt; #define DEVICE_SELECTVIE_INV    (1 &lt;&lt; 0)</span>
<span class="quote">&gt; #define PAGE_SELECTIVE_INV      (1 &lt;&lt; 0)</span>
<span class="quote">&gt; #define PASID_SELECTIVE_INV     (1 &lt;&lt; 1)</span>
<span class="quote">&gt;         __u32 pasid;</span>
<span class="quote">&gt;         __u64 addr;</span>
<span class="quote">&gt;         __u64 size;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;         /* Since IOMMU format has already been validated for this table,</span>
<span class="quote">&gt;            the IOMMU driver knows that the following structure is in a</span>
<span class="quote">&gt;            format it knows */</span>
<span class="quote">&gt;         __u8 opaque[];</span>
<span class="quote">&gt; };</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 	Joerg</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [Jacob Pan]</span>
<span class="quote">&gt; _______________________________________________</span>
<span class="quote">&gt; iommu mailing list</span>
<span class="quote">&gt; iommu@lists.linux-foundation.org</span>
<span class="quote">&gt; https://lists.linuxfoundation.org/mailman/listinfo/iommu</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1631">Tian, Kevin</a> - July 5, 2017, 7:57 a.m.</div>
<pre class="content">
<span class="quote">&gt; From: Jean-Philippe Brucker [mailto:jean-philippe.brucker@arm.com]</span>
<span class="quote">&gt; Sent: Thursday, June 29, 2017 1:08 AM</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 28/06/17 17:09, Jacob Pan wrote:</span>
<span class="quote">&gt; &gt; On Wed, 28 Jun 2017 12:08:23 +0200</span>
<span class="quote">&gt; &gt; Joerg Roedel &lt;joro@8bytes.org&gt; wrote:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; On Tue, Jun 27, 2017 at 12:47:57PM -0700, Jacob Pan wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; From: &quot;Liu, Yi L&quot; &lt;yi.l.liu@linux.intel.com&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; When a SVM capable device is assigned to a guest, the first level</span>
<span class="quote">&gt; &gt;&gt;&gt; page tables are owned by the guest and the guest PASID table</span>
<span class="quote">&gt; &gt;&gt;&gt; pointer is linked to the device context entry of the physical IOMMU.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Host IOMMU driver has no knowledge of caching structure updates</span>
<span class="quote">&gt; &gt;&gt;&gt; unless the guest invalidation activities are passed down to the</span>
<span class="quote">&gt; &gt;&gt;&gt; host. The primary usage is derived from emulated IOMMU in the</span>
<span class="quote">&gt; &gt;&gt;&gt; guest, where QEMU can trap invalidation activities before pass them</span>
<span class="quote">&gt; &gt;&gt;&gt; down the host/physical IOMMU. There are IOMMU architectural</span>
<span class="quote">&gt; &gt;&gt;&gt; specific actions need to be taken which requires the generic APIs</span>
<span class="quote">&gt; &gt;&gt;&gt; introduced in this patch to have opaque data in the</span>
<span class="quote">&gt; &gt;&gt;&gt; tlb_invalidate_info argument.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Which &quot;IOMMU architectural specific actions&quot; are you thinking of?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; construction of queued invalidation descriptors, then submit them to</span>
<span class="quote">&gt; &gt; the IOMMU QI interface.</span>
<span class="quote">&gt; &gt;&gt;&gt; +int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt;&gt;&gt; +		struct device *dev, struct tlb_invalidate_info</span>
<span class="quote">&gt; &gt;&gt;&gt; *inv_info) +{</span>
<span class="quote">&gt; &gt;&gt;&gt; +	int ret = 0;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	if (unlikely(!domain-&gt;ops-&gt;invalidate))</span>
<span class="quote">&gt; &gt;&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	ret = domain-&gt;ops-&gt;invalidate(domain, dev, inv_info);</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	return ret;</span>
<span class="quote">&gt; &gt;&gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt;&gt; +EXPORT_SYMBOL_GPL(iommu_invalidate);</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; +struct tlb_invalidate_info {</span>
<span class="quote">&gt; &gt;&gt;&gt; +	__u32	model;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	__u32	length;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	__u8	opaque[];</span>
<span class="quote">&gt; &gt;&gt;&gt; +};</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; This interface is aweful. It requires the user of a generic api to</span>
<span class="quote">&gt; &gt;&gt; know details about the implementation behind to do anything useful.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Please explain in more detail why this is needed. My feeling is that</span>
<span class="quote">&gt; &gt;&gt; we can make this more generic with a small set of invalidation</span>
<span class="quote">&gt; &gt;&gt; functions in the iommu-api.</span>

A curious question here. Joreg, which part based on below information
could be generalized in your mind? Previously I also preferred to defining
a common structure. However later I realized there is little code logic
which can be further abstracted to use that structure, since the main
task here is just to construct vendor specific invalidation descriptor upon 
the request...
<span class="quote">
&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; My thinking was that via configuration control, there will be unlikely</span>
<span class="quote">&gt; &gt; any mixed IOMMU models between pIOMMU and vIOMMU. We could</span>
<span class="quote">&gt; have just</span>
<span class="quote">&gt; &gt; model specific data pass through layers of SW (QEMU, VFIO) for</span>
<span class="quote">&gt; &gt; performance reasons. We do have an earlier hybrid version that has</span>
<span class="quote">&gt; &gt; generic data and opaque raw data. Would the below work for all IOMMU</span>
<span class="quote">&gt; &gt; models?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For reference, this was also discussed in the initial posting of the series:</span>
<span class="quote">&gt; https://lists.gnu.org/archive/html/qemu-devel/2017-05/msg03452.html</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; At least for ARM SMMUv2 and v3, I think the invalidation format you</span>
<span class="quote">&gt; propose should be sufficient, although &quot;device_selective&quot; should probably</span>
<span class="quote">&gt; be &quot;domain_selective&quot;. And maybe a flag field could contain relatively</span>
<span class="quote">&gt; generic hints such as &quot;only invalidate leaf table when page_selective&quot;.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Jean</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; https://www.spinics.net/lists/kvm/msg148798.html</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; struct tlb_invalidate_info</span>
<span class="quote">&gt; &gt; {</span>
<span class="quote">&gt; &gt;         __u32   model;  /* Vendor number */</span>
<span class="quote">&gt; &gt;         __u8 granularity</span>
<span class="quote">&gt; &gt; #define DEVICE_SELECTVIE_INV    (1 &lt;&lt; 0)</span>
<span class="quote">&gt; &gt; #define PAGE_SELECTIVE_INV      (1 &lt;&lt; 0)</span>
<span class="quote">&gt; &gt; #define PASID_SELECTIVE_INV     (1 &lt;&lt; 1)</span>
<span class="quote">&gt; &gt;         __u32 pasid;</span>
<span class="quote">&gt; &gt;         __u64 addr;</span>
<span class="quote">&gt; &gt;         __u64 size;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;         /* Since IOMMU format has already been validated for this table,</span>
<span class="quote">&gt; &gt;            the IOMMU driver knows that the following structure is in a</span>
<span class="quote">&gt; &gt;            format it knows */</span>
<span class="quote">&gt; &gt;         __u8 opaque[];</span>
<span class="quote">&gt; &gt; };</span>
<span class="quote">&gt; &gt;</span>

I just gave some information in another thread:

https://lists.gnu.org/archive/html/qemu-devel/2017-07/msg00853.html

Below summarizes all the invalidation capabilities supported by Intel VTd:

Scope: All PASIDs, single PASID
for each PASID:
        all mappings, or page-selective mappings (addr, size)
invalidation target:
        IOTLB entries (leaf)
        paging structure cache (non-leaf)
        PASID cache (pasid-&gt;cr3)
invalidation hint:
        whether global pages are included
        drain reads/writes

(Jean, you may add ARM specific capabilities here)

If we want to define a common structure, go with defining a superset 
of all possible capabilities from all vendors (no opaque then) or only 
including a subset used by some common IOMMU abstraction?
The latter depends on what exactly need to be generalized which needs
to be solved first, otherwise it&#39;s difficult to judge why proposed format
is necessary and enough...

Thanks
Kevin
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - July 5, 2017, 12:42 p.m.</div>
<pre class="content">
On 05/07/17 08:57, Tian, Kevin wrote:
<span class="quote">&gt;&gt; From: Jean-Philippe Brucker [mailto:jean-philippe.brucker@arm.com]</span>
<span class="quote">&gt;&gt; Sent: Thursday, June 29, 2017 1:08 AM</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 28/06/17 17:09, Jacob Pan wrote:</span>
<span class="quote">&gt;&gt;&gt; On Wed, 28 Jun 2017 12:08:23 +0200</span>
<span class="quote">&gt;&gt;&gt; Joerg Roedel &lt;joro@8bytes.org&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; On Tue, Jun 27, 2017 at 12:47:57PM -0700, Jacob Pan wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; From: &quot;Liu, Yi L&quot; &lt;yi.l.liu@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; When a SVM capable device is assigned to a guest, the first level</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; page tables are owned by the guest and the guest PASID table</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; pointer is linked to the device context entry of the physical IOMMU.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Host IOMMU driver has no knowledge of caching structure updates</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; unless the guest invalidation activities are passed down to the</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; host. The primary usage is derived from emulated IOMMU in the</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; guest, where QEMU can trap invalidation activities before pass them</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; down the host/physical IOMMU. There are IOMMU architectural</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; specific actions need to be taken which requires the generic APIs</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; introduced in this patch to have opaque data in the</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; tlb_invalidate_info argument.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Which &quot;IOMMU architectural specific actions&quot; are you thinking of?</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; construction of queued invalidation descriptors, then submit them to</span>
<span class="quote">&gt;&gt;&gt; the IOMMU QI interface.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		struct device *dev, struct tlb_invalidate_info</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; *inv_info) +{</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	int ret = 0;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	if (unlikely(!domain-&gt;ops-&gt;invalidate))</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	ret = domain-&gt;ops-&gt;invalidate(domain, dev, inv_info);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	return ret;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +EXPORT_SYMBOL_GPL(iommu_invalidate);</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +struct tlb_invalidate_info {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	__u32	model;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	__u32	length;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	__u8	opaque[];</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +};</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; This interface is aweful. It requires the user of a generic api to</span>
<span class="quote">&gt;&gt;&gt;&gt; know details about the implementation behind to do anything useful.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Please explain in more detail why this is needed. My feeling is that</span>
<span class="quote">&gt;&gt;&gt;&gt; we can make this more generic with a small set of invalidation</span>
<span class="quote">&gt;&gt;&gt;&gt; functions in the iommu-api.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; A curious question here. Joreg, which part based on below information</span>
<span class="quote">&gt; could be generalized in your mind? Previously I also preferred to defining</span>
<span class="quote">&gt; a common structure. However later I realized there is little code logic</span>
<span class="quote">&gt; which can be further abstracted to use that structure, since the main</span>
<span class="quote">&gt; task here is just to construct vendor specific invalidation descriptor upon </span>
<span class="quote">&gt; the request...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; My thinking was that via configuration control, there will be unlikely</span>
<span class="quote">&gt;&gt;&gt; any mixed IOMMU models between pIOMMU and vIOMMU. We could</span>
<span class="quote">&gt;&gt; have just</span>
<span class="quote">&gt;&gt;&gt; model specific data pass through layers of SW (QEMU, VFIO) for</span>
<span class="quote">&gt;&gt;&gt; performance reasons. We do have an earlier hybrid version that has</span>
<span class="quote">&gt;&gt;&gt; generic data and opaque raw data. Would the below work for all IOMMU</span>
<span class="quote">&gt;&gt;&gt; models?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; For reference, this was also discussed in the initial posting of the series:</span>
<span class="quote">&gt;&gt; https://lists.gnu.org/archive/html/qemu-devel/2017-05/msg03452.html</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; At least for ARM SMMUv2 and v3, I think the invalidation format you</span>
<span class="quote">&gt;&gt; propose should be sufficient, although &quot;device_selective&quot; should probably</span>
<span class="quote">&gt;&gt; be &quot;domain_selective&quot;. And maybe a flag field could contain relatively</span>
<span class="quote">&gt;&gt; generic hints such as &quot;only invalidate leaf table when page_selective&quot;.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Thanks,</span>
<span class="quote">&gt;&gt; Jean</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; https://www.spinics.net/lists/kvm/msg148798.html</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; struct tlb_invalidate_info</span>
<span class="quote">&gt;&gt;&gt; {</span>
<span class="quote">&gt;&gt;&gt;         __u32   model;  /* Vendor number */</span>
<span class="quote">&gt;&gt;&gt;         __u8 granularity</span>
<span class="quote">&gt;&gt;&gt; #define DEVICE_SELECTVIE_INV    (1 &lt;&lt; 0)</span>
<span class="quote">&gt;&gt;&gt; #define PAGE_SELECTIVE_INV      (1 &lt;&lt; 0)</span>
<span class="quote">&gt;&gt;&gt; #define PASID_SELECTIVE_INV     (1 &lt;&lt; 1)</span>
<span class="quote">&gt;&gt;&gt;         __u32 pasid;</span>
<span class="quote">&gt;&gt;&gt;         __u64 addr;</span>
<span class="quote">&gt;&gt;&gt;         __u64 size;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;         /* Since IOMMU format has already been validated for this table,</span>
<span class="quote">&gt;&gt;&gt;            the IOMMU driver knows that the following structure is in a</span>
<span class="quote">&gt;&gt;&gt;            format it knows */</span>
<span class="quote">&gt;&gt;&gt;         __u8 opaque[];</span>
<span class="quote">&gt;&gt;&gt; };</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I just gave some information in another thread:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; https://lists.gnu.org/archive/html/qemu-devel/2017-07/msg00853.html</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Below summarizes all the invalidation capabilities supported by Intel VTd:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Scope: All PASIDs, single PASID</span>
<span class="quote">&gt; for each PASID:</span>
<span class="quote">&gt;         all mappings, or page-selective mappings (addr, size)</span>
<span class="quote">&gt; invalidation target:</span>
<span class="quote">&gt;         IOTLB entries (leaf)</span>
<span class="quote">&gt;         paging structure cache (non-leaf)</span>
<span class="quote">&gt;         PASID cache (pasid-&gt;cr3)</span>
<span class="quote">
&gt; invalidation hint:</span>
<span class="quote">&gt;         whether global pages are included</span>
<span class="quote">&gt;         drain reads/writes</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; (Jean, you may add ARM specific capabilities here)</span>

None so far, we don&#39;t have hints except for &#39;leaf&#39;, but future revisions
of the architecture are likely to add fields. And some implementations
might want the guest to specify an ASID instead of/in addition to the
PASID. (see my reply in the linked thread)

Thanks,
Jean
<span class="quote">
&gt; If we want to define a common structure, go with defining a superset </span>
<span class="quote">&gt; of all possible capabilities from all vendors (no opaque then) or only </span>
<span class="quote">&gt; including a subset used by some common IOMMU abstraction?</span>
<span class="quote">&gt; The latter depends on what exactly need to be generalized which needs</span>
<span class="quote">&gt; to be solved first, otherwise it&#39;s difficult to judge why proposed format</span>
<span class="quote">&gt; is necessary and enough...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks</span>
<span class="quote">&gt; Kevin</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - July 26, 2017, 9:02 a.m.</div>
<pre class="content">
On Wed, Jul 05, 2017 at 07:57:57AM +0000, Tian, Kevin wrote:
<span class="quote">&gt; &gt; &gt; struct tlb_invalidate_info</span>
<span class="quote">&gt; &gt; &gt; {</span>
<span class="quote">&gt; &gt; &gt;         __u32   model;  /* Vendor number */</span>

I don&#39;t like to have a model-specifier here, as I don&#39;t think its
needed.
<span class="quote">
&gt; &gt; &gt;         __u8 granularity</span>
<span class="quote">&gt; &gt; &gt; #define DEVICE_SELECTVIE_INV    (1 &lt;&lt; 0)</span>
<span class="quote">&gt; &gt; &gt; #define PAGE_SELECTIVE_INV      (1 &lt;&lt; 0)</span>
<span class="quote">&gt; &gt; &gt; #define PASID_SELECTIVE_INV     (1 &lt;&lt; 1)</span>
<span class="quote">&gt; &gt; &gt;         __u32 pasid;</span>
<span class="quote">&gt; &gt; &gt;         __u64 addr;</span>
<span class="quote">&gt; &gt; &gt;         __u64 size;</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt;         /* Since IOMMU format has already been validated for this table,</span>
<span class="quote">&gt; &gt; &gt;            the IOMMU driver knows that the following structure is in a</span>
<span class="quote">&gt; &gt; &gt;            format it knows */</span>
<span class="quote">&gt; &gt; &gt;         __u8 opaque[];</span>
<span class="quote">&gt; &gt; &gt; };</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I just gave some information in another thread:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; https://lists.gnu.org/archive/html/qemu-devel/2017-07/msg00853.html</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Below summarizes all the invalidation capabilities supported by Intel VTd:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Scope: All PASIDs, single PASID</span>
<span class="quote">&gt; for each PASID:</span>
<span class="quote">&gt;         all mappings, or page-selective mappings (addr, size)</span>
<span class="quote">&gt; invalidation target:</span>
<span class="quote">&gt;         IOTLB entries (leaf)</span>
<span class="quote">&gt;         paging structure cache (non-leaf)</span>
<span class="quote">&gt;         PASID cache (pasid-&gt;cr3)</span>
<span class="quote">&gt; invalidation hint:</span>
<span class="quote">&gt;         whether global pages are included</span>
<span class="quote">&gt;         drain reads/writes</span>

The AMD IOMMU for example supports similar flushing capabilities. They
are all based on a IOMMU-independent PCI standards (PASID, PRI, ATS),
and the interface can be designed around those standards instead of
IOMMU hardware implementations.

If a given hardware implementation does not support all of the above
flushing modes, it is always free to flush more than requested as
supported by its capabilities.

Regards,

	Joerg
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="p_header">index 494309b..d973555 100644</span>
<span class="p_header">--- a/drivers/iommu/iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/iommu.c</span>
<span class="p_chunk">@@ -1347,6 +1347,20 @@</span> <span class="p_context"> int iommu_unbind_pasid_table(struct iommu_domain *domain, struct device *dev)</span>
 }
 EXPORT_SYMBOL_GPL(iommu_unbind_pasid_table);
 
<span class="p_add">+int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="p_add">+		struct device *dev, struct tlb_invalidate_info *inv_info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(!domain-&gt;ops-&gt;invalidate))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = domain-&gt;ops-&gt;invalidate(domain, dev, inv_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(iommu_invalidate);</span>
<span class="p_add">+</span>
 static void __iommu_detach_device(struct iommu_domain *domain,
 				  struct device *dev)
 {
<span class="p_header">diff --git a/include/linux/iommu.h b/include/linux/iommu.h</span>
<span class="p_header">index 7122add..fbc08ae 100644</span>
<span class="p_header">--- a/include/linux/iommu.h</span>
<span class="p_header">+++ b/include/linux/iommu.h</span>
<span class="p_chunk">@@ -186,6 +186,7 @@</span> <span class="p_context"> struct iommu_resv_region {</span>
  * @pgsize_bitmap: bitmap of all possible supported page sizes
  * @bind_pasid_table: bind pasid table pointer for guest SVM
  * @unbind_pasid_table: unbind pasid table pointer and restore defaults
<span class="p_add">+ * @invalidate: invalidate translation caches</span>
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
<span class="p_chunk">@@ -232,6 +233,8 @@</span> <span class="p_context"> struct iommu_ops {</span>
 				struct pasid_table_info *pasidt_binfo);
 	int (*unbind_pasid_table)(struct iommu_domain *domain,
 				struct device *dev);
<span class="p_add">+	int (*invalidate)(struct iommu_domain *domain,</span>
<span class="p_add">+		struct device *dev, struct tlb_invalidate_info *inv_info);</span>
 
 	unsigned long pgsize_bitmap;
 };
<span class="p_chunk">@@ -293,6 +296,9 @@</span> <span class="p_context"> extern int iommu_bind_pasid_table(struct iommu_domain *domain,</span>
 		struct device *dev, struct pasid_table_info *pasidt_binfo);
 extern int iommu_unbind_pasid_table(struct iommu_domain *domain,
 				struct device *dev);
<span class="p_add">+extern int iommu_do_invalidate(struct iommu_domain *domain,</span>
<span class="p_add">+		struct device *dev, struct tlb_invalidate_info *inv_info);</span>
<span class="p_add">+</span>
 extern struct iommu_domain *iommu_get_domain_for_dev(struct device *dev);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 		     phys_addr_t paddr, size_t size, int prot);
<span class="p_chunk">@@ -660,6 +666,12 @@</span> <span class="p_context"> int iommu_unbind_pasid_table(struct iommu_domain *domain, struct device *dev)</span>
 	return -EINVAL;
 }
 
<span class="p_add">+static inline int iommu_do_invalidate(struct iommu_domain *domain,</span>
<span class="p_add">+		struct device *dev, struct tlb_invalidate_info *inv_info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */
<span class="p_header">diff --git a/include/uapi/linux/iommu.h b/include/uapi/linux/iommu.h</span>
<span class="p_header">index 9089a30..f077353 100644</span>
<span class="p_header">--- a/include/uapi/linux/iommu.h</span>
<span class="p_header">+++ b/include/uapi/linux/iommu.h</span>
<span class="p_chunk">@@ -34,5 +34,18 @@</span> <span class="p_context"> struct pasid_table_info {</span>
 	__u8	opaque[];
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Translation cache invalidation information, contains IOMMU model specific</span>
<span class="p_add">+ * data which can be parsed based on model ID by model specific drivers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @model	iommu_model number</span>
<span class="p_add">+ * @length	length of the opaque data in bytes</span>
<span class="p_add">+ * @opaque	model specific IOMMU data</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct tlb_invalidate_info {</span>
<span class="p_add">+	__u32	model;</span>
<span class="p_add">+	__u32	length;</span>
<span class="p_add">+	__u8	opaque[];</span>
<span class="p_add">+};</span>
 
 #endif /* _UAPI_IOMMU_H */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



