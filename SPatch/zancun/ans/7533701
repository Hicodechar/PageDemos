
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3,07/15] kvm: rename pfn_t to kvm_pfn_t - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3,07/15] kvm: rename pfn_t to kvm_pfn_t</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=320">Dan Williams</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 2, 2015, 4:30 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20151102043020.6610.98552.stgit@dwillia2-desk3.amr.corp.intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7533701/mbox/"
   >mbox</a>
|
   <a href="/patch/7533701/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7533701/">/patch/7533701/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id D6492BEEA4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  2 Nov 2015 04:39:49 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id A3C7C205C1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  2 Nov 2015 04:39:47 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 0B762205BA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  2 Nov 2015 04:39:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752956AbbKBEjl (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 1 Nov 2015 23:39:41 -0500
Received: from mga11.intel.com ([192.55.52.93]:54691 &quot;EHLO mga11.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751470AbbKBEgD (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 1 Nov 2015 23:36:03 -0500
Received: from orsmga003.jf.intel.com ([10.7.209.27])
	by fmsmga102.fm.intel.com with ESMTP; 01 Nov 2015 20:36:02 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.20,232,1444719600&quot;; d=&quot;scan&#39;208&quot;;a=&quot;676381323&quot;
Received: from dwillia2-desk3.jf.intel.com (HELO
	dwillia2-desk3.amr.corp.intel.com) ([10.54.39.39])
	by orsmga003.jf.intel.com with ESMTP; 01 Nov 2015 20:36:02 -0800
Subject: [PATCH v3 07/15] kvm: rename pfn_t to kvm_pfn_t
From: Dan Williams &lt;dan.j.williams@intel.com&gt;
To: axboe@fb.com
Cc: jack@suse.cz, linux-nvdimm@lists.01.org, david@fromorbit.com,
	linux-kernel@vger.kernel.org, Paolo Bonzini &lt;pbonzini@redhat.com&gt;,
	ross.zwisler@linux.intel.com, hch@lst.de,
	Christoffer Dall &lt;christoffer.dall@linaro.org&gt;
Date: Sun, 01 Nov 2015 23:30:20 -0500
Message-ID: &lt;20151102043020.6610.98552.stgit@dwillia2-desk3.amr.corp.intel.com&gt;
In-Reply-To: &lt;20151102042941.6610.27784.stgit@dwillia2-desk3.amr.corp.intel.com&gt;
References: &lt;20151102042941.6610.27784.stgit@dwillia2-desk3.amr.corp.intel.com&gt;
User-Agent: StGit/0.17.1-9-g687f
MIME-Version: 1.0
Content-Type: text/plain; charset=&quot;utf-8&quot;
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=320">Dan Williams</a> - Nov. 2, 2015, 4:30 a.m.</div>
<pre class="content">
The core has developed a need for a &quot;pfn_t&quot; type [1].  Move the existing
pfn_t in KVM to kvm_pfn_t [2].

[1]: https://lists.01.org/pipermail/linux-nvdimm/2015-September/002199.html
[2]: https://lists.01.org/pipermail/linux-nvdimm/2015-September/002218.html

Cc: Paolo Bonzini &lt;pbonzini@redhat.com&gt;
<span class="acked-by">Acked-by: Christoffer Dall &lt;christoffer.dall@linaro.org&gt;</span>
<span class="signed-off-by">Signed-off-by: Dan Williams &lt;dan.j.williams@intel.com&gt;</span>
---
 arch/arm/include/asm/kvm_mmu.h        |    5 ++--
 arch/arm/kvm/mmu.c                    |   10 ++++---
 arch/arm64/include/asm/kvm_mmu.h      |    3 +-
 arch/mips/include/asm/kvm_host.h      |    6 ++--
 arch/mips/kvm/emulate.c               |    2 +
 arch/mips/kvm/tlb.c                   |   14 +++++-----
 arch/powerpc/include/asm/kvm_book3s.h |    4 +--
 arch/powerpc/include/asm/kvm_ppc.h    |    2 +
 arch/powerpc/kvm/book3s.c             |    6 ++--
 arch/powerpc/kvm/book3s_32_mmu_host.c |    2 +
 arch/powerpc/kvm/book3s_64_mmu_host.c |    2 +
 arch/powerpc/kvm/e500.h               |    2 +
 arch/powerpc/kvm/e500_mmu_host.c      |    8 +++---
 arch/powerpc/kvm/trace_pr.h           |    2 +
 arch/x86/kvm/iommu.c                  |   11 ++++----
 arch/x86/kvm/mmu.c                    |   37 +++++++++++++-------------
 arch/x86/kvm/mmu_audit.c              |    2 +
 arch/x86/kvm/paging_tmpl.h            |    6 ++--
 arch/x86/kvm/vmx.c                    |    2 +
 arch/x86/kvm/x86.c                    |    2 +
 include/linux/kvm_host.h              |   37 +++++++++++++-------------
 include/linux/kvm_types.h             |    2 +
 virt/kvm/kvm_main.c                   |   47 +++++++++++++++++----------------
 23 files changed, 110 insertions(+), 104 deletions(-)


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_mmu.h b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">index 405aa1883307..8ebd282dfc2b 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -182,7 +182,8 @@</span> <span class="p_context"> static inline bool vcpu_has_cache_enabled(struct kvm_vcpu *vcpu)</span>
 	return (vcpu-&gt;arch.cp15[c1_SCTLR] &amp; 0b101) == 0b101;
 }
 
<span class="p_del">-static inline void __coherent_cache_guest_page(struct kvm_vcpu *vcpu, pfn_t pfn,</span>
<span class="p_add">+static inline void __coherent_cache_guest_page(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+					       kvm_pfn_t pfn,</span>
 					       unsigned long size,
 					       bool ipa_uncached)
 {
<span class="p_chunk">@@ -246,7 +247,7 @@</span> <span class="p_context"> static inline void __kvm_flush_dcache_pte(pte_t pte)</span>
 static inline void __kvm_flush_dcache_pmd(pmd_t pmd)
 {
 	unsigned long size = PMD_SIZE;
<span class="p_del">-	pfn_t pfn = pmd_pfn(pmd);</span>
<span class="p_add">+	kvm_pfn_t pfn = pmd_pfn(pmd);</span>
 
 	while (size) {
 		void *va = kmap_atomic_pfn(pfn);
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 6984342da13d..e2dcbfdc4a8c 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -988,9 +988,9 @@</span> <span class="p_context"> out:</span>
 	return ret;
 }
 
<span class="p_del">-static bool transparent_hugepage_adjust(pfn_t *pfnp, phys_addr_t *ipap)</span>
<span class="p_add">+static bool transparent_hugepage_adjust(kvm_pfn_t *pfnp, phys_addr_t *ipap)</span>
 {
<span class="p_del">-	pfn_t pfn = *pfnp;</span>
<span class="p_add">+	kvm_pfn_t pfn = *pfnp;</span>
 	gfn_t gfn = *ipap &gt;&gt; PAGE_SHIFT;
 
 	if (PageTransCompound(pfn_to_page(pfn))) {
<span class="p_chunk">@@ -1202,7 +1202,7 @@</span> <span class="p_context"> void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm,</span>
 	kvm_mmu_write_protect_pt_masked(kvm, slot, gfn_offset, mask);
 }
 
<span class="p_del">-static void coherent_cache_guest_page(struct kvm_vcpu *vcpu, pfn_t pfn,</span>
<span class="p_add">+static void coherent_cache_guest_page(struct kvm_vcpu *vcpu, kvm_pfn_t pfn,</span>
 				      unsigned long size, bool uncached)
 {
 	__coherent_cache_guest_page(vcpu, pfn, size, uncached);
<span class="p_chunk">@@ -1219,7 +1219,7 @@</span> <span class="p_context"> static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,</span>
 	struct kvm *kvm = vcpu-&gt;kvm;
 	struct kvm_mmu_memory_cache *memcache = &amp;vcpu-&gt;arch.mmu_page_cache;
 	struct vm_area_struct *vma;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	pgprot_t mem_type = PAGE_S2;
 	bool fault_ipa_uncached;
 	bool logging_active = memslot_is_logging(memslot);
<span class="p_chunk">@@ -1347,7 +1347,7 @@</span> <span class="p_context"> static void handle_access_fault(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa)</span>
 {
 	pmd_t *pmd;
 	pte_t *pte;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	bool pfn_valid = false;
 
 	trace_kvm_access_fault(fault_ipa);
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_mmu.h b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">index 61505676d085..385fc8cef82d 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -230,7 +230,8 @@</span> <span class="p_context"> static inline bool vcpu_has_cache_enabled(struct kvm_vcpu *vcpu)</span>
 	return (vcpu_sys_reg(vcpu, SCTLR_EL1) &amp; 0b101) == 0b101;
 }
 
<span class="p_del">-static inline void __coherent_cache_guest_page(struct kvm_vcpu *vcpu, pfn_t pfn,</span>
<span class="p_add">+static inline void __coherent_cache_guest_page(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+					       kvm_pfn_t pfn,</span>
 					       unsigned long size,
 					       bool ipa_uncached)
 {
<span class="p_header">diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">index 5a1a882e0a75..9c67f05a0a1b 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -101,9 +101,9 @@</span> <span class="p_context"></span>
 #define CAUSEF_DC			(_ULCAST_(1) &lt;&lt; 27)
 
 extern atomic_t kvm_mips_instance;
<span class="p_del">-extern pfn_t(*kvm_mips_gfn_to_pfn) (struct kvm *kvm, gfn_t gfn);</span>
<span class="p_del">-extern void (*kvm_mips_release_pfn_clean) (pfn_t pfn);</span>
<span class="p_del">-extern bool(*kvm_mips_is_error_pfn) (pfn_t pfn);</span>
<span class="p_add">+extern kvm_pfn_t (*kvm_mips_gfn_to_pfn)(struct kvm *kvm, gfn_t gfn);</span>
<span class="p_add">+extern void (*kvm_mips_release_pfn_clean)(kvm_pfn_t pfn);</span>
<span class="p_add">+extern bool (*kvm_mips_is_error_pfn)(kvm_pfn_t pfn);</span>
 
 struct kvm_vm_stat {
 	u32 remote_tlb_flush;
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index d5fa3eaf39a1..476296cf37d3 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -1525,7 +1525,7 @@</span> <span class="p_context"> int kvm_mips_sync_icache(unsigned long va, struct kvm_vcpu *vcpu)</span>
 	struct kvm *kvm = vcpu-&gt;kvm;
 	unsigned long pa;
 	gfn_t gfn;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 
 	gfn = va &gt;&gt; PAGE_SHIFT;
 
<span class="p_header">diff --git a/arch/mips/kvm/tlb.c b/arch/mips/kvm/tlb.c</span>
<span class="p_header">index aed0ac2a4972..570479c03bdc 100644</span>
<span class="p_header">--- a/arch/mips/kvm/tlb.c</span>
<span class="p_header">+++ b/arch/mips/kvm/tlb.c</span>
<span class="p_chunk">@@ -38,13 +38,13 @@</span> <span class="p_context"> atomic_t kvm_mips_instance;</span>
 EXPORT_SYMBOL(kvm_mips_instance);
 
 /* These function pointers are initialized once the KVM module is loaded */
<span class="p_del">-pfn_t (*kvm_mips_gfn_to_pfn)(struct kvm *kvm, gfn_t gfn);</span>
<span class="p_add">+kvm_pfn_t (*kvm_mips_gfn_to_pfn)(struct kvm *kvm, gfn_t gfn);</span>
 EXPORT_SYMBOL(kvm_mips_gfn_to_pfn);
 
<span class="p_del">-void (*kvm_mips_release_pfn_clean)(pfn_t pfn);</span>
<span class="p_add">+void (*kvm_mips_release_pfn_clean)(kvm_pfn_t pfn);</span>
 EXPORT_SYMBOL(kvm_mips_release_pfn_clean);
 
<span class="p_del">-bool (*kvm_mips_is_error_pfn)(pfn_t pfn);</span>
<span class="p_add">+bool (*kvm_mips_is_error_pfn)(kvm_pfn_t pfn);</span>
 EXPORT_SYMBOL(kvm_mips_is_error_pfn);
 
 uint32_t kvm_mips_get_kernel_asid(struct kvm_vcpu *vcpu)
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(kvm_mips_dump_guest_tlbs);</span>
 static int kvm_mips_map_page(struct kvm *kvm, gfn_t gfn)
 {
 	int srcu_idx, err = 0;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 
 	if (kvm-&gt;arch.guest_pmap[gfn] != KVM_INVALID_PAGE)
 		return 0;
<span class="p_chunk">@@ -262,7 +262,7 @@</span> <span class="p_context"> int kvm_mips_handle_kseg0_tlb_fault(unsigned long badvaddr,</span>
 				    struct kvm_vcpu *vcpu)
 {
 	gfn_t gfn;
<span class="p_del">-	pfn_t pfn0, pfn1;</span>
<span class="p_add">+	kvm_pfn_t pfn0, pfn1;</span>
 	unsigned long vaddr = 0;
 	unsigned long entryhi = 0, entrylo0 = 0, entrylo1 = 0;
 	int even;
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(kvm_mips_handle_kseg0_tlb_fault);</span>
 int kvm_mips_handle_commpage_tlb_fault(unsigned long badvaddr,
 	struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	pfn_t pfn0, pfn1;</span>
<span class="p_add">+	kvm_pfn_t pfn0, pfn1;</span>
 	unsigned long flags, old_entryhi = 0, vaddr = 0;
 	unsigned long entrylo0 = 0, entrylo1 = 0;
 
<span class="p_chunk">@@ -360,7 +360,7 @@</span> <span class="p_context"> int kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,</span>
 {
 	unsigned long entryhi = 0, entrylo0 = 0, entrylo1 = 0;
 	struct kvm *kvm = vcpu-&gt;kvm;
<span class="p_del">-	pfn_t pfn0, pfn1;</span>
<span class="p_add">+	kvm_pfn_t pfn0, pfn1;</span>
 
 	if ((tlb-&gt;tlb_hi &amp; VPN2_MASK) == 0) {
 		pfn0 = 0;
<span class="p_header">diff --git a/arch/powerpc/include/asm/kvm_book3s.h b/arch/powerpc/include/asm/kvm_book3s.h</span>
<span class="p_header">index 9fac01cb89c1..8f39796c9da8 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/kvm_book3s.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/kvm_book3s.h</span>
<span class="p_chunk">@@ -154,8 +154,8 @@</span> <span class="p_context"> extern void kvmppc_set_bat(struct kvm_vcpu *vcpu, struct kvmppc_bat *bat,</span>
 			   bool upper, u32 val);
 extern void kvmppc_giveup_ext(struct kvm_vcpu *vcpu, ulong msr);
 extern int kvmppc_emulate_paired_single(struct kvm_run *run, struct kvm_vcpu *vcpu);
<span class="p_del">-extern pfn_t kvmppc_gpa_to_pfn(struct kvm_vcpu *vcpu, gpa_t gpa, bool writing,</span>
<span class="p_del">-			bool *writable);</span>
<span class="p_add">+extern kvm_pfn_t kvmppc_gpa_to_pfn(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
<span class="p_add">+			bool writing, bool *writable);</span>
 extern void kvmppc_add_revmap_chain(struct kvm *kvm, struct revmap_entry *rev,
 			unsigned long *rmap, long pte_index, int realmode);
 extern void kvmppc_update_rmap_change(unsigned long *rmap, unsigned long psize);
<span class="p_header">diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="p_header">index c6ef05bd0765..2241d5357129 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="p_chunk">@@ -515,7 +515,7 @@</span> <span class="p_context"> void kvmppc_claim_lpid(long lpid);</span>
 void kvmppc_free_lpid(long lpid);
 void kvmppc_init_lpid(unsigned long nr_lpids);
 
<span class="p_del">-static inline void kvmppc_mmu_flush_icache(pfn_t pfn)</span>
<span class="p_add">+static inline void kvmppc_mmu_flush_icache(kvm_pfn_t pfn)</span>
 {
 	struct page *page;
 	/*
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s.c b/arch/powerpc/kvm/book3s.c</span>
<span class="p_header">index 099c79d8c160..638c6d9be9e0 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s.c</span>
<span class="p_chunk">@@ -366,7 +366,7 @@</span> <span class="p_context"> int kvmppc_core_prepare_to_enter(struct kvm_vcpu *vcpu)</span>
 }
 EXPORT_SYMBOL_GPL(kvmppc_core_prepare_to_enter);
 
<span class="p_del">-pfn_t kvmppc_gpa_to_pfn(struct kvm_vcpu *vcpu, gpa_t gpa, bool writing,</span>
<span class="p_add">+kvm_pfn_t kvmppc_gpa_to_pfn(struct kvm_vcpu *vcpu, gpa_t gpa, bool writing,</span>
 			bool *writable)
 {
 	ulong mp_pa = vcpu-&gt;arch.magic_page_pa &amp; KVM_PAM;
<span class="p_chunk">@@ -379,9 +379,9 @@</span> <span class="p_context"> pfn_t kvmppc_gpa_to_pfn(struct kvm_vcpu *vcpu, gpa_t gpa, bool writing,</span>
 	gpa &amp;= ~0xFFFULL;
 	if (unlikely(mp_pa) &amp;&amp; unlikely((gpa &amp; KVM_PAM) == mp_pa)) {
 		ulong shared_page = ((ulong)vcpu-&gt;arch.shared) &amp; PAGE_MASK;
<span class="p_del">-		pfn_t pfn;</span>
<span class="p_add">+		kvm_pfn_t pfn;</span>
 
<span class="p_del">-		pfn = (pfn_t)virt_to_phys((void*)shared_page) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		pfn = (kvm_pfn_t)virt_to_phys((void*)shared_page) &gt;&gt; PAGE_SHIFT;</span>
 		get_page(pfn_to_page(pfn));
 		if (writable)
 			*writable = true;
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_32_mmu_host.c b/arch/powerpc/kvm/book3s_32_mmu_host.c</span>
<span class="p_header">index d5c9bfeb0c9c..55c4d51ea3e2 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_32_mmu_host.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_32_mmu_host.c</span>
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"> extern char etext[];</span>
 int kvmppc_mmu_map_page(struct kvm_vcpu *vcpu, struct kvmppc_pte *orig_pte,
 			bool iswrite)
 {
<span class="p_del">-	pfn_t hpaddr;</span>
<span class="p_add">+	kvm_pfn_t hpaddr;</span>
 	u64 vpn;
 	u64 vsid;
 	struct kvmppc_sid_map *map;
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_64_mmu_host.c b/arch/powerpc/kvm/book3s_64_mmu_host.c</span>
<span class="p_header">index 79ad35abd196..913cd2198fa6 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_64_mmu_host.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_64_mmu_host.c</span>
<span class="p_chunk">@@ -83,7 +83,7 @@</span> <span class="p_context"> int kvmppc_mmu_map_page(struct kvm_vcpu *vcpu, struct kvmppc_pte *orig_pte,</span>
 			bool iswrite)
 {
 	unsigned long vpn;
<span class="p_del">-	pfn_t hpaddr;</span>
<span class="p_add">+	kvm_pfn_t hpaddr;</span>
 	ulong hash, hpteg;
 	u64 vsid;
 	int ret;
<span class="p_header">diff --git a/arch/powerpc/kvm/e500.h b/arch/powerpc/kvm/e500.h</span>
<span class="p_header">index 72920bed3ac6..94f04fcb373e 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/e500.h</span>
<span class="p_header">+++ b/arch/powerpc/kvm/e500.h</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> enum vcpu_ftr {</span>
 #define E500_TLB_MAS2_ATTR	(0x7f)
 
 struct tlbe_ref {
<span class="p_del">-	pfn_t pfn;		/* valid only for TLB0, except briefly */</span>
<span class="p_add">+	kvm_pfn_t pfn;		/* valid only for TLB0, except briefly */</span>
 	unsigned int flags;	/* E500_TLB_* */
 };
 
<span class="p_header">diff --git a/arch/powerpc/kvm/e500_mmu_host.c b/arch/powerpc/kvm/e500_mmu_host.c</span>
<span class="p_header">index 4d33e199edcc..8a5bb6dfcc2d 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/e500_mmu_host.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/e500_mmu_host.c</span>
<span class="p_chunk">@@ -163,9 +163,9 @@</span> <span class="p_context"> void kvmppc_map_magic(struct kvm_vcpu *vcpu)</span>
 	struct kvm_book3e_206_tlb_entry magic;
 	ulong shared_page = ((ulong)vcpu-&gt;arch.shared) &amp; PAGE_MASK;
 	unsigned int stid;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 
<span class="p_del">-	pfn = (pfn_t)virt_to_phys((void *)shared_page) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	pfn = (kvm_pfn_t)virt_to_phys((void *)shared_page) &gt;&gt; PAGE_SHIFT;</span>
 	get_page(pfn_to_page(pfn));
 
 	preempt_disable();
<span class="p_chunk">@@ -246,7 +246,7 @@</span> <span class="p_context"> static inline int tlbe_is_writable(struct kvm_book3e_206_tlb_entry *tlbe)</span>
 
 static inline void kvmppc_e500_ref_setup(struct tlbe_ref *ref,
 					 struct kvm_book3e_206_tlb_entry *gtlbe,
<span class="p_del">-					 pfn_t pfn, unsigned int wimg)</span>
<span class="p_add">+					 kvm_pfn_t pfn, unsigned int wimg)</span>
 {
 	ref-&gt;pfn = pfn;
 	ref-&gt;flags = E500_TLB_VALID;
<span class="p_chunk">@@ -309,7 +309,7 @@</span> <span class="p_context"> static void kvmppc_e500_setup_stlbe(</span>
 	int tsize, struct tlbe_ref *ref, u64 gvaddr,
 	struct kvm_book3e_206_tlb_entry *stlbe)
 {
<span class="p_del">-	pfn_t pfn = ref-&gt;pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn = ref-&gt;pfn;</span>
 	u32 pr = vcpu-&gt;arch.shared-&gt;msr &amp; MSR_PR;
 
 	BUG_ON(!(ref-&gt;flags &amp; E500_TLB_VALID));
<span class="p_header">diff --git a/arch/powerpc/kvm/trace_pr.h b/arch/powerpc/kvm/trace_pr.h</span>
<span class="p_header">index 810507cb688a..d44f324184fb 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/trace_pr.h</span>
<span class="p_header">+++ b/arch/powerpc/kvm/trace_pr.h</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"> TRACE_EVENT(kvm_book3s_reenter,</span>
 #ifdef CONFIG_PPC_BOOK3S_64
 
 TRACE_EVENT(kvm_book3s_64_mmu_map,
<span class="p_del">-	TP_PROTO(int rflags, ulong hpteg, ulong va, pfn_t hpaddr,</span>
<span class="p_add">+	TP_PROTO(int rflags, ulong hpteg, ulong va, kvm_pfn_t hpaddr,</span>
 		 struct kvmppc_pte *orig_pte),
 	TP_ARGS(rflags, hpteg, va, hpaddr, orig_pte),
 
<span class="p_header">diff --git a/arch/x86/kvm/iommu.c b/arch/x86/kvm/iommu.c</span>
<span class="p_header">index 5c520ebf6343..a22a488b4622 100644</span>
<span class="p_header">--- a/arch/x86/kvm/iommu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/iommu.c</span>
<span class="p_chunk">@@ -43,11 +43,11 @@</span> <span class="p_context"> static int kvm_iommu_unmap_memslots(struct kvm *kvm);</span>
 static void kvm_iommu_put_pages(struct kvm *kvm,
 				gfn_t base_gfn, unsigned long npages);
 
<span class="p_del">-static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,</span>
<span class="p_add">+static kvm_pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,</span>
 			   unsigned long npages)
 {
 	gfn_t end_gfn;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 
 	pfn     = gfn_to_pfn_memslot(slot, gfn);
 	end_gfn = gfn + npages;
<span class="p_chunk">@@ -62,7 +62,8 @@</span> <span class="p_context"> static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,</span>
 	return pfn;
 }
 
<span class="p_del">-static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)</span>
<span class="p_add">+static void kvm_unpin_pages(struct kvm *kvm, kvm_pfn_t pfn,</span>
<span class="p_add">+		unsigned long npages)</span>
 {
 	unsigned long i;
 
<span class="p_chunk">@@ -73,7 +74,7 @@</span> <span class="p_context"> static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)</span>
 int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 {
 	gfn_t gfn, end_gfn;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	int r = 0;
 	struct iommu_domain *domain = kvm-&gt;arch.iommu_domain;
 	int flags;
<span class="p_chunk">@@ -275,7 +276,7 @@</span> <span class="p_context"> static void kvm_iommu_put_pages(struct kvm *kvm,</span>
 {
 	struct iommu_domain *domain;
 	gfn_t end_gfn, gfn;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	u64 phys;
 
 	domain  = kvm-&gt;arch.iommu_domain;
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index ff606f507913..6ab963ae0427 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -259,7 +259,7 @@</span> <span class="p_context"> static unsigned get_mmio_spte_access(u64 spte)</span>
 }
 
 static bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,
<span class="p_del">-			  pfn_t pfn, unsigned access)</span>
<span class="p_add">+			  kvm_pfn_t pfn, unsigned access)</span>
 {
 	if (unlikely(is_noslot_pfn(pfn))) {
 		mark_mmio_spte(vcpu, sptep, gfn, access);
<span class="p_chunk">@@ -325,7 +325,7 @@</span> <span class="p_context"> static int is_last_spte(u64 pte, int level)</span>
 	return 0;
 }
 
<span class="p_del">-static pfn_t spte_to_pfn(u64 pte)</span>
<span class="p_add">+static kvm_pfn_t spte_to_pfn(u64 pte)</span>
 {
 	return (pte &amp; PT64_BASE_ADDR_MASK) &gt;&gt; PAGE_SHIFT;
 }
<span class="p_chunk">@@ -587,7 +587,7 @@</span> <span class="p_context"> static bool mmu_spte_update(u64 *sptep, u64 new_spte)</span>
  */
 static int mmu_spte_clear_track_bits(u64 *sptep)
 {
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	u64 old_spte = *sptep;
 
 	if (!spte_has_volatile_bits(old_spte))
<span class="p_chunk">@@ -1369,7 +1369,7 @@</span> <span class="p_context"> static int kvm_set_pte_rmapp(struct kvm *kvm, unsigned long *rmapp,</span>
 	int need_flush = 0;
 	u64 new_spte;
 	pte_t *ptep = (pte_t *)data;
<span class="p_del">-	pfn_t new_pfn;</span>
<span class="p_add">+	kvm_pfn_t new_pfn;</span>
 
 	WARN_ON(pte_huge(*ptep));
 	new_pfn = pte_pfn(*ptep);
<span class="p_chunk">@@ -2456,7 +2456,7 @@</span> <span class="p_context"> static int mmu_need_write_protect(struct kvm_vcpu *vcpu, gfn_t gfn,</span>
 	return 0;
 }
 
<span class="p_del">-static bool kvm_is_mmio_pfn(pfn_t pfn)</span>
<span class="p_add">+static bool kvm_is_mmio_pfn(kvm_pfn_t pfn)</span>
 {
 	if (pfn_valid(pfn))
 		return !is_zero_pfn(pfn) &amp;&amp; PageReserved(pfn_to_page(pfn));
<span class="p_chunk">@@ -2466,7 +2466,7 @@</span> <span class="p_context"> static bool kvm_is_mmio_pfn(pfn_t pfn)</span>
 
 static int set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 		    unsigned pte_access, int level,
<span class="p_del">-		    gfn_t gfn, pfn_t pfn, bool speculative,</span>
<span class="p_add">+		    gfn_t gfn, kvm_pfn_t pfn, bool speculative,</span>
 		    bool can_unsync, bool host_writable)
 {
 	u64 spte;
<span class="p_chunk">@@ -2546,7 +2546,7 @@</span> <span class="p_context"> done:</span>
 
 static void mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 			 unsigned pte_access, int write_fault, int *emulate,
<span class="p_del">-			 int level, gfn_t gfn, pfn_t pfn, bool speculative,</span>
<span class="p_add">+			 int level, gfn_t gfn, kvm_pfn_t pfn, bool speculative,</span>
 			 bool host_writable)
 {
 	int was_rmapped = 0;
<span class="p_chunk">@@ -2606,7 +2606,7 @@</span> <span class="p_context"> static void mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,</span>
 	kvm_release_pfn_clean(pfn);
 }
 
<span class="p_del">-static pfn_t pte_prefetch_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn,</span>
<span class="p_add">+static kvm_pfn_t pte_prefetch_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn,</span>
 				     bool no_dirty_log)
 {
 	struct kvm_memory_slot *slot;
<span class="p_chunk">@@ -2689,7 +2689,7 @@</span> <span class="p_context"> static void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)</span>
 }
 
 static int __direct_map(struct kvm_vcpu *vcpu, gpa_t v, int write,
<span class="p_del">-			int map_writable, int level, gfn_t gfn, pfn_t pfn,</span>
<span class="p_add">+			int map_writable, int level, gfn_t gfn, kvm_pfn_t pfn,</span>
 			bool prefault)
 {
 	struct kvm_shadow_walk_iterator iterator;
<span class="p_chunk">@@ -2739,7 +2739,7 @@</span> <span class="p_context"> static void kvm_send_hwpoison_signal(unsigned long address, struct task_struct *</span>
 	send_sig_info(SIGBUS, &amp;info, tsk);
 }
 
<span class="p_del">-static int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, pfn_t pfn)</span>
<span class="p_add">+static int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)</span>
 {
 	/*
 	 * Do not cache the mmio info caused by writing the readonly gfn
<span class="p_chunk">@@ -2759,9 +2759,10 @@</span> <span class="p_context"> static int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, pfn_t pfn)</span>
 }
 
 static void transparent_hugepage_adjust(struct kvm_vcpu *vcpu,
<span class="p_del">-					gfn_t *gfnp, pfn_t *pfnp, int *levelp)</span>
<span class="p_add">+					gfn_t *gfnp, kvm_pfn_t *pfnp,</span>
<span class="p_add">+					int *levelp)</span>
 {
<span class="p_del">-	pfn_t pfn = *pfnp;</span>
<span class="p_add">+	kvm_pfn_t pfn = *pfnp;</span>
 	gfn_t gfn = *gfnp;
 	int level = *levelp;
 
<span class="p_chunk">@@ -2800,7 +2801,7 @@</span> <span class="p_context"> static void transparent_hugepage_adjust(struct kvm_vcpu *vcpu,</span>
 }
 
 static bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,
<span class="p_del">-				pfn_t pfn, unsigned access, int *ret_val)</span>
<span class="p_add">+				kvm_pfn_t pfn, unsigned access, int *ret_val)</span>
 {
 	bool ret = true;
 
<span class="p_chunk">@@ -2954,7 +2955,7 @@</span> <span class="p_context"> exit:</span>
 }
 
 static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,
<span class="p_del">-			 gva_t gva, pfn_t *pfn, bool write, bool *writable);</span>
<span class="p_add">+			 gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);</span>
 static void make_mmu_pages_available(struct kvm_vcpu *vcpu);
 
 static int nonpaging_map(struct kvm_vcpu *vcpu, gva_t v, u32 error_code,
<span class="p_chunk">@@ -2963,7 +2964,7 @@</span> <span class="p_context"> static int nonpaging_map(struct kvm_vcpu *vcpu, gva_t v, u32 error_code,</span>
 	int r;
 	int level;
 	int force_pt_level;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	unsigned long mmu_seq;
 	bool map_writable, write = error_code &amp; PFERR_WRITE_MASK;
 
<span class="p_chunk">@@ -3435,7 +3436,7 @@</span> <span class="p_context"> static bool can_do_async_pf(struct kvm_vcpu *vcpu)</span>
 }
 
 static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,
<span class="p_del">-			 gva_t gva, pfn_t *pfn, bool write, bool *writable)</span>
<span class="p_add">+			 gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)</span>
 {
 	struct kvm_memory_slot *slot;
 	bool async;
<span class="p_chunk">@@ -3473,7 +3474,7 @@</span> <span class="p_context"> check_hugepage_cache_consistency(struct kvm_vcpu *vcpu, gfn_t gfn, int level)</span>
 static int tdp_page_fault(struct kvm_vcpu *vcpu, gva_t gpa, u32 error_code,
 			  bool prefault)
 {
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	int r;
 	int level;
 	int force_pt_level;
<span class="p_chunk">@@ -4627,7 +4628,7 @@</span> <span class="p_context"> static bool kvm_mmu_zap_collapsible_spte(struct kvm *kvm,</span>
 	u64 *sptep;
 	struct rmap_iterator iter;
 	int need_tlb_flush = 0;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	struct kvm_mmu_page *sp;
 
 restart:
<span class="p_header">diff --git a/arch/x86/kvm/mmu_audit.c b/arch/x86/kvm/mmu_audit.c</span>
<span class="p_header">index 03d518e499a6..37a4d14115c0 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu_audit.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu_audit.c</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> static void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)</span>
 {
 	struct kvm_mmu_page *sp;
 	gfn_t gfn;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	hpa_t hpa;
 
 	sp = page_header(__pa(sptep));
<span class="p_header">diff --git a/arch/x86/kvm/paging_tmpl.h b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">index 736e6ab8784d..9dd02cb74724 100644</span>
<span class="p_header">--- a/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">+++ b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_chunk">@@ -456,7 +456,7 @@</span> <span class="p_context"> FNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,</span>
 {
 	unsigned pte_access;
 	gfn_t gfn;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 
 	if (FNAME(prefetch_invalid_gpte)(vcpu, sp, spte, gpte))
 		return false;
<span class="p_chunk">@@ -551,7 +551,7 @@</span> <span class="p_context"> static void FNAME(pte_prefetch)(struct kvm_vcpu *vcpu, struct guest_walker *gw,</span>
 static int FNAME(fetch)(struct kvm_vcpu *vcpu, gva_t addr,
 			 struct guest_walker *gw,
 			 int write_fault, int hlevel,
<span class="p_del">-			 pfn_t pfn, bool map_writable, bool prefault)</span>
<span class="p_add">+			 kvm_pfn_t pfn, bool map_writable, bool prefault)</span>
 {
 	struct kvm_mmu_page *sp = NULL;
 	struct kvm_shadow_walk_iterator it;
<span class="p_chunk">@@ -696,7 +696,7 @@</span> <span class="p_context"> static int FNAME(page_fault)(struct kvm_vcpu *vcpu, gva_t addr, u32 error_code,</span>
 	int user_fault = error_code &amp; PFERR_USER_MASK;
 	struct guest_walker walker;
 	int r;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 	int level = PT_PAGE_TABLE_LEVEL;
 	int force_pt_level;
 	unsigned long mmu_seq;
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 6a8bc64566ab..52aba0f1207b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -4046,7 +4046,7 @@</span> <span class="p_context"> out:</span>
 static int init_rmode_identity_map(struct kvm *kvm)
 {
 	int i, idx, r = 0;
<span class="p_del">-	pfn_t identity_map_pfn;</span>
<span class="p_add">+	kvm_pfn_t identity_map_pfn;</span>
 	u32 tmp;
 
 	if (!enable_ept)
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 9a9a19830321..60b08427ca6c 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -4935,7 +4935,7 @@</span> <span class="p_context"> static bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t cr2,</span>
 				  int emulation_type)
 {
 	gpa_t gpa = cr2;
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 
 	if (emulation_type &amp; EMULTYPE_NO_REEXECUTE)
 		return false;
<span class="p_header">diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h</span>
<span class="p_header">index 1bef9e21e725..2420b43f3acc 100644</span>
<span class="p_header">--- a/include/linux/kvm_host.h</span>
<span class="p_header">+++ b/include/linux/kvm_host.h</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"></span>
  * error pfns indicate that the gfn is in slot but faild to
  * translate it to pfn on host.
  */
<span class="p_del">-static inline bool is_error_pfn(pfn_t pfn)</span>
<span class="p_add">+static inline bool is_error_pfn(kvm_pfn_t pfn)</span>
 {
 	return !!(pfn &amp; KVM_PFN_ERR_MASK);
 }
<span class="p_chunk">@@ -75,13 +75,13 @@</span> <span class="p_context"> static inline bool is_error_pfn(pfn_t pfn)</span>
  * translated to pfn - it is not in slot or failed to
  * translate it to pfn.
  */
<span class="p_del">-static inline bool is_error_noslot_pfn(pfn_t pfn)</span>
<span class="p_add">+static inline bool is_error_noslot_pfn(kvm_pfn_t pfn)</span>
 {
 	return !!(pfn &amp; KVM_PFN_ERR_NOSLOT_MASK);
 }
 
 /* noslot pfn indicates that the gfn is not in slot. */
<span class="p_del">-static inline bool is_noslot_pfn(pfn_t pfn)</span>
<span class="p_add">+static inline bool is_noslot_pfn(kvm_pfn_t pfn)</span>
 {
 	return pfn == KVM_PFN_NOSLOT;
 }
<span class="p_chunk">@@ -569,19 +569,20 @@</span> <span class="p_context"> void kvm_release_page_clean(struct page *page);</span>
 void kvm_release_page_dirty(struct page *page);
 void kvm_set_page_accessed(struct page *page);
 
<span class="p_del">-pfn_t gfn_to_pfn_atomic(struct kvm *kvm, gfn_t gfn);</span>
<span class="p_del">-pfn_t gfn_to_pfn(struct kvm *kvm, gfn_t gfn);</span>
<span class="p_del">-pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn_atomic(struct kvm *kvm, gfn_t gfn);</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn(struct kvm *kvm, gfn_t gfn);</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,</span>
 		      bool *writable);
<span class="p_del">-pfn_t gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn);</span>
<span class="p_del">-pfn_t gfn_to_pfn_memslot_atomic(struct kvm_memory_slot *slot, gfn_t gfn);</span>
<span class="p_del">-pfn_t __gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,</span>
<span class="p_del">-			   bool *async, bool write_fault, bool *writable);</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn);</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn_memslot_atomic(struct kvm_memory_slot *slot, gfn_t gfn);</span>
<span class="p_add">+kvm_pfn_t __gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn,</span>
<span class="p_add">+			       bool atomic, bool *async, bool write_fault,</span>
<span class="p_add">+			       bool *writable);</span>
 
<span class="p_del">-void kvm_release_pfn_clean(pfn_t pfn);</span>
<span class="p_del">-void kvm_set_pfn_dirty(pfn_t pfn);</span>
<span class="p_del">-void kvm_set_pfn_accessed(pfn_t pfn);</span>
<span class="p_del">-void kvm_get_pfn(pfn_t pfn);</span>
<span class="p_add">+void kvm_release_pfn_clean(kvm_pfn_t pfn);</span>
<span class="p_add">+void kvm_set_pfn_dirty(kvm_pfn_t pfn);</span>
<span class="p_add">+void kvm_set_pfn_accessed(kvm_pfn_t pfn);</span>
<span class="p_add">+void kvm_get_pfn(kvm_pfn_t pfn);</span>
 
 int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,
 			int len);
<span class="p_chunk">@@ -607,8 +608,8 @@</span> <span class="p_context"> void mark_page_dirty(struct kvm *kvm, gfn_t gfn);</span>
 
 struct kvm_memslots *kvm_vcpu_memslots(struct kvm_vcpu *vcpu);
 struct kvm_memory_slot *kvm_vcpu_gfn_to_memslot(struct kvm_vcpu *vcpu, gfn_t gfn);
<span class="p_del">-pfn_t kvm_vcpu_gfn_to_pfn_atomic(struct kvm_vcpu *vcpu, gfn_t gfn);</span>
<span class="p_del">-pfn_t kvm_vcpu_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn);</span>
<span class="p_add">+kvm_pfn_t kvm_vcpu_gfn_to_pfn_atomic(struct kvm_vcpu *vcpu, gfn_t gfn);</span>
<span class="p_add">+kvm_pfn_t kvm_vcpu_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn);</span>
 struct page *kvm_vcpu_gfn_to_page(struct kvm_vcpu *vcpu, gfn_t gfn);
 unsigned long kvm_vcpu_gfn_to_hva(struct kvm_vcpu *vcpu, gfn_t gfn);
 unsigned long kvm_vcpu_gfn_to_hva_prot(struct kvm_vcpu *vcpu, gfn_t gfn, bool *writable);
<span class="p_chunk">@@ -789,7 +790,7 @@</span> <span class="p_context"> void kvm_arch_sync_events(struct kvm *kvm);</span>
 int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu);
 void kvm_vcpu_kick(struct kvm_vcpu *vcpu);
 
<span class="p_del">-bool kvm_is_reserved_pfn(pfn_t pfn);</span>
<span class="p_add">+bool kvm_is_reserved_pfn(kvm_pfn_t pfn);</span>
 
 struct kvm_irq_ack_notifier {
 	struct hlist_node link;
<span class="p_chunk">@@ -940,7 +941,7 @@</span> <span class="p_context"> static inline gfn_t gpa_to_gfn(gpa_t gpa)</span>
 	return (gfn_t)(gpa &gt;&gt; PAGE_SHIFT);
 }
 
<span class="p_del">-static inline hpa_t pfn_to_hpa(pfn_t pfn)</span>
<span class="p_add">+static inline hpa_t pfn_to_hpa(kvm_pfn_t pfn)</span>
 {
 	return (hpa_t)pfn &lt;&lt; PAGE_SHIFT;
 }
<span class="p_header">diff --git a/include/linux/kvm_types.h b/include/linux/kvm_types.h</span>
<span class="p_header">index 1b47a185c2f0..8bf259dae9f6 100644</span>
<span class="p_header">--- a/include/linux/kvm_types.h</span>
<span class="p_header">+++ b/include/linux/kvm_types.h</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> typedef unsigned long  hva_t;</span>
 typedef u64            hpa_t;
 typedef u64            hfn_t;
 
<span class="p_del">-typedef hfn_t pfn_t;</span>
<span class="p_add">+typedef hfn_t kvm_pfn_t;</span>
 
 struct gfn_to_hva_cache {
 	u64 generation;
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 8db1d9361993..02cd2eddd3ff 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> static void hardware_disable_all(void);</span>
 
 static void kvm_io_bus_destroy(struct kvm_io_bus *bus);
 
<span class="p_del">-static void kvm_release_pfn_dirty(pfn_t pfn);</span>
<span class="p_add">+static void kvm_release_pfn_dirty(kvm_pfn_t pfn);</span>
 static void mark_page_dirty_in_slot(struct kvm_memory_slot *memslot, gfn_t gfn);
 
 __visible bool kvm_rebooting;
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(kvm_rebooting);</span>
 
 static bool largepages_enabled = true;
 
<span class="p_del">-bool kvm_is_reserved_pfn(pfn_t pfn)</span>
<span class="p_add">+bool kvm_is_reserved_pfn(kvm_pfn_t pfn)</span>
 {
 	if (pfn_valid(pfn))
 		return PageReserved(pfn_to_page(pfn));
<span class="p_chunk">@@ -1296,7 +1296,7 @@</span> <span class="p_context"> static inline int check_user_page_hwpoison(unsigned long addr)</span>
  * true indicates success, otherwise false is returned.
  */
 static bool hva_to_pfn_fast(unsigned long addr, bool atomic, bool *async,
<span class="p_del">-			    bool write_fault, bool *writable, pfn_t *pfn)</span>
<span class="p_add">+			    bool write_fault, bool *writable, kvm_pfn_t *pfn)</span>
 {
 	struct page *page[1];
 	int npages;
<span class="p_chunk">@@ -1329,7 +1329,7 @@</span> <span class="p_context"> static bool hva_to_pfn_fast(unsigned long addr, bool atomic, bool *async,</span>
  * 1 indicates success, -errno is returned if error is detected.
  */
 static int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,
<span class="p_del">-			   bool *writable, pfn_t *pfn)</span>
<span class="p_add">+			   bool *writable, kvm_pfn_t *pfn)</span>
 {
 	struct page *page[1];
 	int npages = 0;
<span class="p_chunk">@@ -1393,11 +1393,11 @@</span> <span class="p_context"> static bool vma_is_valid(struct vm_area_struct *vma, bool write_fault)</span>
  * 2): @write_fault = false &amp;&amp; @writable, @writable will tell the caller
  *     whether the mapping is writable.
  */
<span class="p_del">-static pfn_t hva_to_pfn(unsigned long addr, bool atomic, bool *async,</span>
<span class="p_add">+static kvm_pfn_t hva_to_pfn(unsigned long addr, bool atomic, bool *async,</span>
 			bool write_fault, bool *writable)
 {
 	struct vm_area_struct *vma;
<span class="p_del">-	pfn_t pfn = 0;</span>
<span class="p_add">+	kvm_pfn_t pfn = 0;</span>
 	int npages;
 
 	/* we can do it either atomically or asynchronously, not both */
<span class="p_chunk">@@ -1438,8 +1438,9 @@</span> <span class="p_context"> exit:</span>
 	return pfn;
 }
 
<span class="p_del">-pfn_t __gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,</span>
<span class="p_del">-			   bool *async, bool write_fault, bool *writable)</span>
<span class="p_add">+kvm_pfn_t __gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn,</span>
<span class="p_add">+			       bool atomic, bool *async, bool write_fault,</span>
<span class="p_add">+			       bool *writable)</span>
 {
 	unsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);
 
<span class="p_chunk">@@ -1460,7 +1461,7 @@</span> <span class="p_context"> pfn_t __gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn, bool atomic,</span>
 }
 EXPORT_SYMBOL_GPL(__gfn_to_pfn_memslot);
 
<span class="p_del">-pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,</span>
 		      bool *writable)
 {
 	return __gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn, false, NULL,
<span class="p_chunk">@@ -1468,37 +1469,37 @@</span> <span class="p_context"> pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,</span>
 }
 EXPORT_SYMBOL_GPL(gfn_to_pfn_prot);
 
<span class="p_del">-pfn_t gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn)</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn_memslot(struct kvm_memory_slot *slot, gfn_t gfn)</span>
 {
 	return __gfn_to_pfn_memslot(slot, gfn, false, NULL, true, NULL);
 }
 EXPORT_SYMBOL_GPL(gfn_to_pfn_memslot);
 
<span class="p_del">-pfn_t gfn_to_pfn_memslot_atomic(struct kvm_memory_slot *slot, gfn_t gfn)</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn_memslot_atomic(struct kvm_memory_slot *slot, gfn_t gfn)</span>
 {
 	return __gfn_to_pfn_memslot(slot, gfn, true, NULL, true, NULL);
 }
 EXPORT_SYMBOL_GPL(gfn_to_pfn_memslot_atomic);
 
<span class="p_del">-pfn_t gfn_to_pfn_atomic(struct kvm *kvm, gfn_t gfn)</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn_atomic(struct kvm *kvm, gfn_t gfn)</span>
 {
 	return gfn_to_pfn_memslot_atomic(gfn_to_memslot(kvm, gfn), gfn);
 }
 EXPORT_SYMBOL_GPL(gfn_to_pfn_atomic);
 
<span class="p_del">-pfn_t kvm_vcpu_gfn_to_pfn_atomic(struct kvm_vcpu *vcpu, gfn_t gfn)</span>
<span class="p_add">+kvm_pfn_t kvm_vcpu_gfn_to_pfn_atomic(struct kvm_vcpu *vcpu, gfn_t gfn)</span>
 {
 	return gfn_to_pfn_memslot_atomic(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);
 }
 EXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_pfn_atomic);
 
<span class="p_del">-pfn_t gfn_to_pfn(struct kvm *kvm, gfn_t gfn)</span>
<span class="p_add">+kvm_pfn_t gfn_to_pfn(struct kvm *kvm, gfn_t gfn)</span>
 {
 	return gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn);
 }
 EXPORT_SYMBOL_GPL(gfn_to_pfn);
 
<span class="p_del">-pfn_t kvm_vcpu_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn)</span>
<span class="p_add">+kvm_pfn_t kvm_vcpu_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn)</span>
 {
 	return gfn_to_pfn_memslot(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);
 }
<span class="p_chunk">@@ -1521,7 +1522,7 @@</span> <span class="p_context"> int gfn_to_page_many_atomic(struct kvm_memory_slot *slot, gfn_t gfn,</span>
 }
 EXPORT_SYMBOL_GPL(gfn_to_page_many_atomic);
 
<span class="p_del">-static struct page *kvm_pfn_to_page(pfn_t pfn)</span>
<span class="p_add">+static struct page *kvm_pfn_to_page(kvm_pfn_t pfn)</span>
 {
 	if (is_error_noslot_pfn(pfn))
 		return KVM_ERR_PTR_BAD_PAGE;
<span class="p_chunk">@@ -1536,7 +1537,7 @@</span> <span class="p_context"> static struct page *kvm_pfn_to_page(pfn_t pfn)</span>
 
 struct page *gfn_to_page(struct kvm *kvm, gfn_t gfn)
 {
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 
 	pfn = gfn_to_pfn(kvm, gfn);
 
<span class="p_chunk">@@ -1546,7 +1547,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(gfn_to_page);</span>
 
 struct page *kvm_vcpu_gfn_to_page(struct kvm_vcpu *vcpu, gfn_t gfn)
 {
<span class="p_del">-	pfn_t pfn;</span>
<span class="p_add">+	kvm_pfn_t pfn;</span>
 
 	pfn = kvm_vcpu_gfn_to_pfn(vcpu, gfn);
 
<span class="p_chunk">@@ -1562,7 +1563,7 @@</span> <span class="p_context"> void kvm_release_page_clean(struct page *page)</span>
 }
 EXPORT_SYMBOL_GPL(kvm_release_page_clean);
 
<span class="p_del">-void kvm_release_pfn_clean(pfn_t pfn)</span>
<span class="p_add">+void kvm_release_pfn_clean(kvm_pfn_t pfn)</span>
 {
 	if (!is_error_noslot_pfn(pfn) &amp;&amp; !kvm_is_reserved_pfn(pfn))
 		put_page(pfn_to_page(pfn));
<span class="p_chunk">@@ -1577,13 +1578,13 @@</span> <span class="p_context"> void kvm_release_page_dirty(struct page *page)</span>
 }
 EXPORT_SYMBOL_GPL(kvm_release_page_dirty);
 
<span class="p_del">-static void kvm_release_pfn_dirty(pfn_t pfn)</span>
<span class="p_add">+static void kvm_release_pfn_dirty(kvm_pfn_t pfn)</span>
 {
 	kvm_set_pfn_dirty(pfn);
 	kvm_release_pfn_clean(pfn);
 }
 
<span class="p_del">-void kvm_set_pfn_dirty(pfn_t pfn)</span>
<span class="p_add">+void kvm_set_pfn_dirty(kvm_pfn_t pfn)</span>
 {
 	if (!kvm_is_reserved_pfn(pfn)) {
 		struct page *page = pfn_to_page(pfn);
<span class="p_chunk">@@ -1594,14 +1595,14 @@</span> <span class="p_context"> void kvm_set_pfn_dirty(pfn_t pfn)</span>
 }
 EXPORT_SYMBOL_GPL(kvm_set_pfn_dirty);
 
<span class="p_del">-void kvm_set_pfn_accessed(pfn_t pfn)</span>
<span class="p_add">+void kvm_set_pfn_accessed(kvm_pfn_t pfn)</span>
 {
 	if (!kvm_is_reserved_pfn(pfn))
 		mark_page_accessed(pfn_to_page(pfn));
 }
 EXPORT_SYMBOL_GPL(kvm_set_pfn_accessed);
 
<span class="p_del">-void kvm_get_pfn(pfn_t pfn)</span>
<span class="p_add">+void kvm_get_pfn(kvm_pfn_t pfn)</span>
 {
 	if (!kvm_is_reserved_pfn(pfn))
 		get_page(pfn_to_page(pfn));

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



