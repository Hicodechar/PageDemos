
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>x86/kernel: use pr_&lt;level&gt;() and dev_&lt;level&gt; - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    x86/kernel: use pr_&lt;level&gt;() and dev_&lt;level&gt;</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=96691">Chen Yucong</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 5, 2016, 9:55 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1454666121-14972-1-git-send-email-slaoub@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8233141/mbox/"
   >mbox</a>
|
   <a href="/patch/8233141/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8233141/">/patch/8233141/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id E32E0BEEE5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  5 Feb 2016 09:56:08 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id ECC7920390
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  5 Feb 2016 09:56:02 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id AF51220389
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  5 Feb 2016 09:55:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752116AbcBEJzw (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 5 Feb 2016 04:55:52 -0500
Received: from mail-ig0-f194.google.com ([209.85.213.194]:35866 &quot;EHLO
	mail-ig0-f194.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751294AbcBEJzk (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 5 Feb 2016 04:55:40 -0500
Received: by mail-ig0-f194.google.com with SMTP id o2so801901iga.3
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Fri, 05 Feb 2016 01:55:39 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=from:to:cc:subject:date:message-id;
	bh=uIDpwnh+FV4pomTlH3repyqzZw1odzJB1XElpNgoCyg=;
	b=As/Q53B7/kWX+LFSdpzkXHxiscp7FVJw4ykfUfRm9PCF0resIT7/8r5X8kU8xjxkU3
	/RwcBV+cMg/8joU1wa+JqcNZk9K9w8bR8+DkZK7Ry2HpSyhLPR6zmswfzJpAdh5B8So5
	B/j6Ir9sbYmQs9FR7QiE0g+pOukK/GVAVkHiMt3ZANkivDyFIKDDbb6HOd4YXRpIbLkw
	rqsZ6tlFXtYr7qo8eiX2Nt2I2qIfCj8CdQ2Ak1EOpeYeCfG6p72QdkPdTJZiH7Ws8Rsi
	rCIHL2sthaKr8i3lT/4FriMoEr1qIpK7hsegZsiwuDTQ/bllng5euPZpw6aPU9oHdhYU
	QPwQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:from:to:cc:subject:date:message-id;
	bh=uIDpwnh+FV4pomTlH3repyqzZw1odzJB1XElpNgoCyg=;
	b=O9u8+kt1G6sJVA1+zJR8O717p8w8UAVCFidGH+BJs9w3u9ymT7rwVAIF0cnPFAm69B
	Zvy/688in0fPDXDfwMkY9Wm3pOZwFighU9tE64YGdiz+Nhz3YnFtL9QdjbeObGs/Jb6S
	TU7kuFckQ24/Et3OtksC6/mfuvwGgDK4ksIaC0Fda5kgE0fX8XbZOfNHkf1KbuUFGcAV
	uCzzFjtw+jZPNO3RFdykAloofVJKG7uxGRXULWeG1BjMdlJDQwn24jApas1Z840zFIld
	ydswf/XkSNX+J1EiAahTs1cIfx0KarPe6qUwmp5tJCptCn3Qr/TJSig78BKeDO2I2bIB
	xf6A==
X-Gm-Message-State: AG10YOScGkugVQkbwHX2b+aRvo6hbNkamCEl7Jm92qguIEl4dMvEdZn8eBUGV4UAbwvICg==
X-Received: by 10.50.13.102 with SMTP id g6mr15274518igc.77.1454666139102;
	Fri, 05 Feb 2016 01:55:39 -0800 (PST)
Received: from localhost.localdomain ([210.77.76.71])
	by smtp.googlemail.com with ESMTPSA id
	f14sm6482427ioi.20.2016.02.05.01.55.35
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Fri, 05 Feb 2016 01:55:38 -0800 (PST)
From: Chen Yucong &lt;slaoub@gmail.com&gt;
To: mingo@kernel.org
Cc: tglx@linutronix.de, hpa@zytor.com, x86@kernel.org,
	linux-kernel@vger.kernel.org
Subject: [PATCH] x86/kernel: use pr_&lt;level&gt;() and dev_&lt;level&gt;
Date: Fri,  5 Feb 2016 17:55:21 +0800
Message-Id: &lt;1454666121-14972-1-git-send-email-slaoub@gmail.com&gt;
X-Mailer: git-send-email 1.8.3.1
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.3 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, FREEMAIL_FROM, RCVD_IN_DNSWL_HI,
	RP_MATCHES_RCVD, 
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96691">Chen Yucong</a> - Feb. 5, 2016, 9:55 a.m.</div>
<pre class="content">
arch/x86/kernel/* use a mixture of printk(KERN_&lt;level&gt; ) and pr_&lt;level&gt;().
This patch converts the bulk of printk(KERN_&lt;level&gt; ) to pr_&lt;level&gt;() and
uses dev_dbg() instead of the dev_printk(KERN_DEBUG,). All pr_warning()
calls have been replaced with pr_warn().

Not sure what to do about the printk(KERN_DEFAULT) and printk() without a
log level.
<span class="signed-off-by">
Signed-off-by: Chen Yucong &lt;slaoub@gmail.com&gt;</span>
---
 arch/x86/kernel/acpi/boot.c         | 106 ++++++++++++++++--------------------
 arch/x86/kernel/acpi/cstate.c       |   5 +-
 arch/x86/kernel/acpi/sleep.c        |   2 +-
 arch/x86/kernel/alternative.c       |   8 +--
 arch/x86/kernel/amd_gart_64.c       |  13 ++---
 arch/x86/kernel/apb_timer.c         |  23 ++++----
 arch/x86/kernel/apic/apic.c         |  44 +++++++--------
 arch/x86/kernel/apic/apic_flat_64.c |   4 +-
 arch/x86/kernel/apic/apic_noop.c    |   2 +-
 arch/x86/kernel/apic/bigsmp_32.c    |   5 +-
 arch/x86/kernel/apic/io_apic.c      |  95 ++++++++++++++++----------------
 arch/x86/kernel/apic/probe_32.c     |   9 ++-
 arch/x86/kernel/apic/x2apic_phys.c  |   2 +-
 arch/x86/kernel/apic/x2apic_uv_x.c  |   3 +-
 arch/x86/kernel/apm_32.c            |  79 +++++++++++++--------------
 arch/x86/kernel/bootflag.c          |   4 +-
 arch/x86/kernel/check.c             |  11 ++--
 arch/x86/kernel/cpuid.c             |   2 +-
 arch/x86/kernel/crash_dump_32.c     |   6 +-
 arch/x86/kernel/devicetree.c        |   6 +-
 arch/x86/kernel/doublefault.c       |  16 +++---
 arch/x86/kernel/dumpstack.c         |   4 +-
 arch/x86/kernel/e820.c              |  66 +++++++++++-----------
 arch/x86/kernel/early-quirks.c      |  44 +++++++--------
 arch/x86/kernel/early_printk.c      |   4 +-
 arch/x86/kernel/fpu/init.c          |   3 +-
 arch/x86/kernel/fpu/xstate.c        |   3 +-
 arch/x86/kernel/hpet.c              |  32 +++++------
 arch/x86/kernel/i8259.c             |   5 +-
 arch/x86/kernel/irq_32.c            |   6 +-
 arch/x86/kernel/jump_label.c        |   4 +-
 arch/x86/kernel/kgdb.c              |   8 +--
 arch/x86/kernel/kprobes/core.c      |  11 ++--
 arch/x86/kernel/kvm.c               |  12 ++--
 arch/x86/kernel/kvmclock.c          |  10 ++--
 arch/x86/kernel/mmconf-fam10h_64.c  |   2 +-
 arch/x86/kernel/module.c            |   4 +-
 arch/x86/kernel/nmi_selftest.c      |  12 ++--
 arch/x86/kernel/paravirt.c          |   2 +-
 arch/x86/kernel/pci-calgary_64.c    |  84 ++++++++++++++--------------
 arch/x86/kernel/pci-iommu_table.c   |   4 +-
 arch/x86/kernel/pci-nommu.c         |   3 +-
 arch/x86/kernel/pci-swiotlb.c       |   4 +-
 arch/x86/kernel/quirks.c            |  48 ++++++++--------
 arch/x86/kernel/rtc.c               |   7 +--
 arch/x86/kernel/setup.c             |  22 ++++----
 arch/x86/kernel/setup_percpu.c      |   2 +-
 arch/x86/kernel/smpboot.c           |   6 +-
 arch/x86/kernel/sysfb_efi.c         |   8 +--
 arch/x86/kernel/sysfb_simplefb.c    |   2 +-
 arch/x86/kernel/tboot.c             |  16 +++---
 arch/x86/kernel/tce_64.c            |   6 +-
 arch/x86/kernel/test_nx.c           |  16 +++---
 arch/x86/kernel/test_rodata.c       |  10 ++--
 arch/x86/kernel/tsc_sync.c          |   6 +-
 arch/x86/kernel/vsmp_64.c           |   2 +-
 56 files changed, 444 insertions(+), 479 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Feb. 9, 2016, 9:57 a.m.</div>
<pre class="content">
* Chen Yucong &lt;slaoub@gmail.com&gt; wrote:
<span class="quote">
&gt; arch/x86/kernel/* use a mixture of printk(KERN_&lt;level&gt; ) and pr_&lt;level&gt;().</span>
<span class="quote">&gt; This patch converts the bulk of printk(KERN_&lt;level&gt; ) to pr_&lt;level&gt;() and</span>
<span class="quote">&gt; uses dev_dbg() instead of the dev_printk(KERN_DEBUG,). All pr_warning()</span>
<span class="quote">&gt; calls have been replaced with pr_warn().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Not sure what to do about the printk(KERN_DEFAULT) and printk() without a</span>
<span class="quote">&gt; log level.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Chen Yucong &lt;slaoub@gmail.com&gt;</span>

When converting please also join broken up format strings, such as:

-               printk(KERN_WARNING PREFIX
-                      &quot;HPET id: %#x base: 0xfed0000000000000 fixed up &quot;
-                      &quot;to 0xfed00000.\n&quot;, hpet_tbl-&gt;id);
+               pr_warn(PREFIX &quot;HPET id: %#x base: 0xfed0000000000000 fixed up &quot;
+                       &quot;to 0xfed00000.\n&quot;, hpet_tbl-&gt;id);

ignore checkpatch: we don&#39;t line-break user visible strings.

Thanks,

	Ingo
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a> - Feb. 9, 2016, 10:52 a.m.</div>
<pre class="content">
On Tue, 9 Feb 2016, Ingo Molnar wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; * Chen Yucong &lt;slaoub@gmail.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; arch/x86/kernel/* use a mixture of printk(KERN_&lt;level&gt; ) and pr_&lt;level&gt;().</span>
<span class="quote">&gt; &gt; This patch converts the bulk of printk(KERN_&lt;level&gt; ) to pr_&lt;level&gt;() and</span>
<span class="quote">&gt; &gt; uses dev_dbg() instead of the dev_printk(KERN_DEBUG,). All pr_warning()</span>
<span class="quote">&gt; &gt; calls have been replaced with pr_warn().</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Not sure what to do about the printk(KERN_DEFAULT) and printk() without a</span>
<span class="quote">&gt; &gt; log level.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Chen Yucong &lt;slaoub@gmail.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; When converting please also join broken up format strings, such as:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; -               printk(KERN_WARNING PREFIX</span>
<span class="quote">&gt; -                      &quot;HPET id: %#x base: 0xfed0000000000000 fixed up &quot;</span>
<span class="quote">&gt; -                      &quot;to 0xfed00000.\n&quot;, hpet_tbl-&gt;id);</span>
<span class="quote">&gt; +               pr_warn(PREFIX &quot;HPET id: %#x base: 0xfed0000000000000 fixed up &quot;</span>
<span class="quote">&gt; +                       &quot;to 0xfed00000.\n&quot;, hpet_tbl-&gt;id);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ignore checkpatch: we don&#39;t line-break user visible strings.</span>

And please get rid of PREFIX. define pr_fmt instead.

Thanks,

	tglx
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=325">Joe Perches</a> - Feb. 9, 2016, 11:53 p.m.</div>
<pre class="content">
On Tue, 2016-02-09 at 10:57 +0100, Ingo Molnar wrote:
<span class="quote">&gt; * Chen Yucong &lt;slaoub@gmail.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; arch/x86/kernel/* use a mixture of printk(KERN_ ) and pr_().</span>
<span class="quote">&gt; &gt; This patch converts the bulk of printk(KERN_ ) to pr_() and</span>
<span class="quote">&gt; &gt; uses dev_dbg() instead of the dev_printk(KERN_DEBUG,). All pr_warning()</span>
<span class="quote">&gt; &gt; calls have been replaced with pr_warn().</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Not sure what to do about the printk(KERN_DEFAULT) and printk() without a</span>
<span class="quote">&gt; &gt; log level.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Chen Yucong &lt;slaoub@gmail.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; When converting please also join broken up format strings, such as:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; -               printk(KERN_WARNING PREFIX</span>
<span class="quote">&gt; -                      &quot;HPET id: %#x base: 0xfed0000000000000 fixed up &quot;</span>
<span class="quote">&gt; -                      &quot;to 0xfed00000.\n&quot;, hpet_tbl-&gt;id);</span>
<span class="quote">&gt; +               pr_warn(PREFIX &quot;HPET id: %#x base: 0xfed0000000000000 fixed up &quot;</span>
<span class="quote">&gt; +                       &quot;to 0xfed00000.\n&quot;, hpet_tbl-&gt;id);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ignore checkpatch: we don&#39;t line-break user visible strings.</span>

Umm, checkpatch already suggests to coalesce split strings.

ie:

WARNING: quoted string split across lines
#850: FILE: arch/x86/kernel/hpet.c:850:
+			       &quot;HPET config register value = 0xFFFFFFFF. &quot;
+			       &quot;Disabling HPET\n&quot;);

and checkpatch does the fixing using something like:

$ ./scripts/checkpatch.pl -f --fix-inplace --types=split_string arch/x86/kernel/hpet.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">index e759076..1ba8328 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_chunk">@@ -141,14 +141,14 @@</span> <span class="p_context"> static int __init acpi_parse_madt(struct acpi_table_header *table)</span>
 
 	madt = (struct acpi_table_madt *)table;
 	if (!madt) {
<span class="p_del">-		printk(KERN_WARNING PREFIX &quot;Unable to map MADT\n&quot;);</span>
<span class="p_add">+		pr_warn(PREFIX &quot;Unable to map MADT\n&quot;);</span>
 		return -ENODEV;
 	}
 
 	if (madt-&gt;address) {
 		acpi_lapic_addr = (u64) madt-&gt;address;
 
<span class="p_del">-		printk(KERN_DEBUG PREFIX &quot;Local APIC address 0x%08x\n&quot;,</span>
<span class="p_add">+		pr_debug(PREFIX &quot;Local APIC address 0x%08x\n&quot;,</span>
 		       madt-&gt;address);
 	}
 
<span class="p_chunk">@@ -170,7 +170,7 @@</span> <span class="p_context"> static int acpi_register_lapic(int id, u8 enabled)</span>
 	unsigned int ver = 0;
 
 	if (id &gt;= MAX_LOCAL_APIC) {
<span class="p_del">-		printk(KERN_INFO PREFIX &quot;skipped apicid that is too big\n&quot;);</span>
<span class="p_add">+		pr_info(PREFIX &quot;skipped apicid that is too big\n&quot;);</span>
 		return -EINVAL;
 	}
 
<span class="p_chunk">@@ -210,11 +210,11 @@</span> <span class="p_context"> acpi_parse_x2apic(struct acpi_subtable_header *header, const unsigned long end)</span>
 	 * when we use CPU hotplug.
 	 */
 	if (!apic-&gt;apic_id_valid(apic_id) &amp;&amp; enabled)
<span class="p_del">-		printk(KERN_WARNING PREFIX &quot;x2apic entry ignored\n&quot;);</span>
<span class="p_add">+		pr_warn(PREFIX &quot;x2apic entry ignored\n&quot;);</span>
 	else
 		acpi_register_lapic(apic_id, enabled);
 #else
<span class="p_del">-	printk(KERN_WARNING PREFIX &quot;x2apic entry ignored\n&quot;);</span>
<span class="p_add">+	pr_warn(PREFIX &quot;x2apic entry ignored\n&quot;);</span>
 #endif
 
 	return 0;
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> acpi_parse_x2apic_nmi(struct acpi_subtable_header *header,</span>
 	acpi_table_print_madt_entry(header);
 
 	if (x2apic_nmi-&gt;lint != 1)
<span class="p_del">-		printk(KERN_WARNING PREFIX &quot;NMI not connected to LINT 1!\n&quot;);</span>
<span class="p_add">+		pr_warn(PREFIX &quot;NMI not connected to LINT 1!\n&quot;);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -311,7 +311,7 @@</span> <span class="p_context"> acpi_parse_lapic_nmi(struct acpi_subtable_header * header, const unsigned long e</span>
 	acpi_table_print_madt_entry(header);
 
 	if (lapic_nmi-&gt;lint != 1)
<span class="p_del">-		printk(KERN_WARNING PREFIX &quot;NMI not connected to LINT 1!\n&quot;);</span>
<span class="p_add">+		pr_warn(PREFIX &quot;NMI not connected to LINT 1!\n&quot;);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -478,14 +478,14 @@</span> <span class="p_context"> acpi_parse_int_src_ovr(struct acpi_subtable_header * header,</span>
 
 	if (intsrc-&gt;source_irq == 0) {
 		if (acpi_skip_timer_override) {
<span class="p_del">-			printk(PREFIX &quot;BIOS IRQ0 override ignored.\n&quot;);</span>
<span class="p_add">+			pr_info(PREFIX &quot;BIOS IRQ0 override ignored.\n&quot;);</span>
 			return 0;
 		}
 
 		if ((intsrc-&gt;global_irq == 2) &amp;&amp; acpi_fix_pin2_polarity
 			&amp;&amp; (intsrc-&gt;inti_flags &amp; ACPI_MADT_POLARITY_MASK)) {
 			intsrc-&gt;inti_flags &amp;= ~ACPI_MADT_POLARITY_MASK;
<span class="p_del">-			printk(PREFIX &quot;BIOS IRQ0 pin2 override: forcing polarity to high active.\n&quot;);</span>
<span class="p_add">+			pr_info(PREFIX &quot;BIOS IRQ0 pin2 override: forcing polarity to high active.\n&quot;);</span>
 		}
 	}
 
<span class="p_chunk">@@ -561,7 +561,7 @@</span> <span class="p_context"> void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger)</span>
 	if (old == new)
 		return;
 
<span class="p_del">-	printk(PREFIX &quot;setting ELCR to %04x (from %04x)\n&quot;, new, old);</span>
<span class="p_add">+	pr_info(PREFIX &quot;setting ELCR to %04x (from %04x)\n&quot;, new, old);</span>
 	outb(new, 0x4d0);
 	outb(new &gt;&gt; 8, 0x4d1);
 }
<span class="p_chunk">@@ -833,8 +833,7 @@</span> <span class="p_context"> static int __init acpi_parse_hpet(struct acpi_table_header *table)</span>
 	struct acpi_table_hpet *hpet_tbl = (struct acpi_table_hpet *)table;
 
 	if (hpet_tbl-&gt;address.space_id != ACPI_SPACE_MEM) {
<span class="p_del">-		printk(KERN_WARNING PREFIX &quot;HPET timers must be located in &quot;</span>
<span class="p_del">-		       &quot;memory.\n&quot;);</span>
<span class="p_add">+		pr_warn(PREFIX &quot;HPET timers must be located in memory.\n&quot;);</span>
 		return -1;
 	}
 
<span class="p_chunk">@@ -846,9 +845,8 @@</span> <span class="p_context"> static int __init acpi_parse_hpet(struct acpi_table_header *table)</span>
 	 * want to allocate a resource there.
 	 */
 	if (!hpet_address) {
<span class="p_del">-		printk(KERN_WARNING PREFIX</span>
<span class="p_del">-		       &quot;HPET id: %#x base: %#lx is invalid\n&quot;,</span>
<span class="p_del">-		       hpet_tbl-&gt;id, hpet_address);</span>
<span class="p_add">+		pr_warn(PREFIX &quot;HPET id: %#x base: %#lx is invalid\n&quot;,</span>
<span class="p_add">+			hpet_tbl-&gt;id, hpet_address);</span>
 		return 0;
 	}
 #ifdef CONFIG_X86_64
<span class="p_chunk">@@ -859,20 +857,19 @@</span> <span class="p_context"> static int __init acpi_parse_hpet(struct acpi_table_header *table)</span>
 	 */
 	if (hpet_address == 0xfed0000000000000UL) {
 		if (!hpet_force_user) {
<span class="p_del">-			printk(KERN_WARNING PREFIX &quot;HPET id: %#x &quot;</span>
<span class="p_add">+			pr_warn(PREFIX &quot;HPET id: %#x &quot;</span>
 			       &quot;base: 0xfed0000000000000 is bogus\n &quot;
 			       &quot;try hpet=force on the kernel command line to &quot;
 			       &quot;fix it up to 0xfed00000.\n&quot;, hpet_tbl-&gt;id);
 			hpet_address = 0;
 			return 0;
 		}
<span class="p_del">-		printk(KERN_WARNING PREFIX</span>
<span class="p_del">-		       &quot;HPET id: %#x base: 0xfed0000000000000 fixed up &quot;</span>
<span class="p_del">-		       &quot;to 0xfed00000.\n&quot;, hpet_tbl-&gt;id);</span>
<span class="p_add">+		pr_warn(PREFIX &quot;HPET id: %#x base: 0xfed0000000000000 fixed up &quot;</span>
<span class="p_add">+			&quot;to 0xfed00000.\n&quot;, hpet_tbl-&gt;id);</span>
 		hpet_address &gt;&gt;= 32;
 	}
 #endif
<span class="p_del">-	printk(KERN_INFO PREFIX &quot;HPET id: %#x base: %#lx\n&quot;,</span>
<span class="p_add">+	pr_info(PREFIX &quot;HPET id: %#x base: %#lx\n&quot;,</span>
 	       hpet_tbl-&gt;id, hpet_address);
 
 	/*
<span class="p_chunk">@@ -935,7 +932,7 @@</span> <span class="p_context"> static int __init acpi_parse_fadt(struct acpi_table_header *table)</span>
 		pmtmr_ioport = acpi_gbl_FADT.pm_timer_block;
 	}
 	if (pmtmr_ioport)
<span class="p_del">-		printk(KERN_INFO PREFIX &quot;PM-Timer IO Port: %#x\n&quot;,</span>
<span class="p_add">+		pr_info(PREFIX &quot;PM-Timer IO Port: %#x\n&quot;,</span>
 		       pmtmr_ioport);
 #endif
 	return 0;
<span class="p_chunk">@@ -962,8 +959,7 @@</span> <span class="p_context"> static int __init early_acpi_parse_madt_lapic_addr_ovr(void)</span>
 	count = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE,
 				      acpi_parse_lapic_addr_ovr, 0);
 	if (count &lt; 0) {
<span class="p_del">-		printk(KERN_ERR PREFIX</span>
<span class="p_del">-		       &quot;Error parsing LAPIC address override entry\n&quot;);</span>
<span class="p_add">+		pr_err(PREFIX &quot;Error parsing LAPIC address override entry\n&quot;);</span>
 		return count;
 	}
 
<span class="p_chunk">@@ -990,8 +986,7 @@</span> <span class="p_context"> static int __init acpi_parse_madt_lapic_entries(void)</span>
 	count = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE,
 				      acpi_parse_lapic_addr_ovr, 0);
 	if (count &lt; 0) {
<span class="p_del">-		printk(KERN_ERR PREFIX</span>
<span class="p_del">-		       &quot;Error parsing LAPIC address override entry\n&quot;);</span>
<span class="p_add">+		pr_err(PREFIX &quot;Error parsing LAPIC address override entry\n&quot;);</span>
 		return count;
 	}
 
<span class="p_chunk">@@ -1010,8 +1005,7 @@</span> <span class="p_context"> static int __init acpi_parse_madt_lapic_entries(void)</span>
 				sizeof(struct acpi_table_madt),
 				madt_proc, ARRAY_SIZE(madt_proc), MAX_LOCAL_APIC);
 		if (ret &lt; 0) {
<span class="p_del">-			printk(KERN_ERR PREFIX</span>
<span class="p_del">-					&quot;Error parsing LAPIC/X2APIC entries\n&quot;);</span>
<span class="p_add">+			pr_err(PREFIX &quot;Error parsing LAPIC/X2APIC entries\n&quot;);</span>
 			return ret;
 		}
 
<span class="p_chunk">@@ -1019,11 +1013,11 @@</span> <span class="p_context"> static int __init acpi_parse_madt_lapic_entries(void)</span>
 		count = madt_proc[1].count;
 	}
 	if (!count &amp;&amp; !x2count) {
<span class="p_del">-		printk(KERN_ERR PREFIX &quot;No LAPIC entries present\n&quot;);</span>
<span class="p_add">+		pr_err(PREFIX &quot;No LAPIC entries present\n&quot;);</span>
 		/* TBD: Cleanup to allow fallback to MPS */
 		return -ENODEV;
 	} else if (count &lt; 0 || x2count &lt; 0) {
<span class="p_del">-		printk(KERN_ERR PREFIX &quot;Error parsing LAPIC entry\n&quot;);</span>
<span class="p_add">+		pr_err(PREFIX &quot;Error parsing LAPIC entry\n&quot;);</span>
 		/* TBD: Cleanup to allow fallback to MPS */
 		return count;
 	}
<span class="p_chunk">@@ -1033,7 +1027,7 @@</span> <span class="p_context"> static int __init acpi_parse_madt_lapic_entries(void)</span>
 	count = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC_NMI,
 				      acpi_parse_lapic_nmi, 0);
 	if (count &lt; 0 || x2count &lt; 0) {
<span class="p_del">-		printk(KERN_ERR PREFIX &quot;Error parsing LAPIC NMI entry\n&quot;);</span>
<span class="p_add">+		pr_err(PREFIX &quot;Error parsing LAPIC NMI entry\n&quot;);</span>
 		/* TBD: Cleanup to allow fallback to MPS */
 		return count;
 	}
<span class="p_chunk">@@ -1092,7 +1086,7 @@</span> <span class="p_context"> static void __init mp_config_acpi_legacy_irqs(void)</span>
 		}
 
 		if (idx != mp_irq_entries) {
<span class="p_del">-			printk(KERN_DEBUG &quot;ACPI: IRQ%d used by override.\n&quot;, i);</span>
<span class="p_add">+			pr_debug(&quot;ACPI: IRQ%d used by override.\n&quot;, i);</span>
 			continue;	/* IRQ already used */
 		}
 
<span class="p_chunk">@@ -1132,7 +1126,7 @@</span> <span class="p_context"> static int __init acpi_parse_madt_ioapic_entries(void)</span>
 	 * if &quot;noapic&quot; boot option, don&#39;t look for IO-APICs
 	 */
 	if (skip_ioapic_setup) {
<span class="p_del">-		printk(KERN_INFO PREFIX &quot;Skipping IOAPIC probe &quot;</span>
<span class="p_add">+		pr_info(PREFIX &quot;Skipping IOAPIC probe &quot;</span>
 		       &quot;due to &#39;noapic&#39; option.\n&quot;);
 		return -ENODEV;
 	}
<span class="p_chunk">@@ -1140,17 +1134,17 @@</span> <span class="p_context"> static int __init acpi_parse_madt_ioapic_entries(void)</span>
 	count = acpi_table_parse_madt(ACPI_MADT_TYPE_IO_APIC, acpi_parse_ioapic,
 				      MAX_IO_APICS);
 	if (!count) {
<span class="p_del">-		printk(KERN_ERR PREFIX &quot;No IOAPIC entries present\n&quot;);</span>
<span class="p_add">+		pr_err(PREFIX &quot;No IOAPIC entries present\n&quot;);</span>
 		return -ENODEV;
 	} else if (count &lt; 0) {
<span class="p_del">-		printk(KERN_ERR PREFIX &quot;Error parsing IOAPIC entry\n&quot;);</span>
<span class="p_add">+		pr_err(PREFIX &quot;Error parsing IOAPIC entry\n&quot;);</span>
 		return count;
 	}
 
 	count = acpi_table_parse_madt(ACPI_MADT_TYPE_INTERRUPT_OVERRIDE,
 				      acpi_parse_int_src_ovr, nr_irqs);
 	if (count &lt; 0) {
<span class="p_del">-		printk(KERN_ERR PREFIX</span>
<span class="p_add">+		pr_err(PREFIX</span>
 		       &quot;Error parsing interrupt source overrides entry\n&quot;);
 		/* TBD: Cleanup to allow fallback to MPS */
 		return count;
<span class="p_chunk">@@ -1170,7 +1164,7 @@</span> <span class="p_context"> static int __init acpi_parse_madt_ioapic_entries(void)</span>
 	count = acpi_table_parse_madt(ACPI_MADT_TYPE_NMI_SOURCE,
 				      acpi_parse_nmi_src, nr_irqs);
 	if (count &lt; 0) {
<span class="p_del">-		printk(KERN_ERR PREFIX &quot;Error parsing NMI SRC entry\n&quot;);</span>
<span class="p_add">+		pr_err(PREFIX &quot;Error parsing NMI SRC entry\n&quot;);</span>
 		/* TBD: Cleanup to allow fallback to MPS */
 		return count;
 	}
<span class="p_chunk">@@ -1203,8 +1197,7 @@</span> <span class="p_context"> static void __init early_acpi_process_madt(void)</span>
 			/*
 			 * Dell Precision Workstation 410, 610 come here.
 			 */
<span class="p_del">-			printk(KERN_ERR PREFIX</span>
<span class="p_del">-			       &quot;Invalid BIOS MADT, disabling ACPI\n&quot;);</span>
<span class="p_add">+			pr_err(PREFIX &quot;Invalid BIOS MADT, disabling ACPI\n&quot;);</span>
 			disable_acpi();
 		}
 	}
<span class="p_chunk">@@ -1241,8 +1234,7 @@</span> <span class="p_context"> static void __init acpi_process_madt(void)</span>
 			/*
 			 * Dell Precision Workstation 410, 610 come here.
 			 */
<span class="p_del">-			printk(KERN_ERR PREFIX</span>
<span class="p_del">-			       &quot;Invalid BIOS MADT, disabling ACPI\n&quot;);</span>
<span class="p_add">+			pr_err(PREFIX &quot;Invalid BIOS MADT, disabling ACPI\n&quot;);</span>
 			disable_acpi();
 		}
 	} else {
<span class="p_chunk">@@ -1252,8 +1244,7 @@</span> <span class="p_context"> static void __init acpi_process_madt(void)</span>
  		 * Boot with &quot;acpi=off&quot; to use MPS on such a system.
  		 */
 		if (smp_found_config) {
<span class="p_del">-			printk(KERN_WARNING PREFIX</span>
<span class="p_del">-				&quot;No APIC-table, disabling MPS\n&quot;);</span>
<span class="p_add">+			pr_warn(PREFIX &quot;No APIC-table, disabling MPS\n&quot;);</span>
 			smp_found_config = 0;
 		}
 	}
<span class="p_chunk">@@ -1263,11 +1254,11 @@</span> <span class="p_context"> static void __init acpi_process_madt(void)</span>
 	 * processors, where MPS only supports physical.
 	 */
 	if (acpi_lapic &amp;&amp; acpi_ioapic)
<span class="p_del">-		printk(KERN_INFO &quot;Using ACPI (MADT) for SMP configuration &quot;</span>
<span class="p_del">-		       &quot;information\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Using ACPI (MADT) for SMP configuration &quot;</span>
<span class="p_add">+			&quot;information\n&quot;);</span>
 	else if (acpi_lapic)
<span class="p_del">-		printk(KERN_INFO &quot;Using ACPI for processor (LAPIC) &quot;</span>
<span class="p_del">-		       &quot;configuration information\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Using ACPI for processor (LAPIC) &quot;</span>
<span class="p_add">+			&quot;configuration information\n&quot;);</span>
 #endif
 	return;
 }
<span class="p_chunk">@@ -1275,8 +1266,8 @@</span> <span class="p_context"> static void __init acpi_process_madt(void)</span>
 static int __init disable_acpi_irq(const struct dmi_system_id *d)
 {
 	if (!acpi_force) {
<span class="p_del">-		printk(KERN_NOTICE &quot;%s detected: force use of acpi=noirq\n&quot;,</span>
<span class="p_del">-		       d-&gt;ident);</span>
<span class="p_add">+		pr_notice(&quot;%s detected: force use of acpi=noirq\n&quot;,</span>
<span class="p_add">+			  d-&gt;ident);</span>
 		acpi_noirq_set();
 	}
 	return 0;
<span class="p_chunk">@@ -1285,8 +1276,8 @@</span> <span class="p_context"> static int __init disable_acpi_irq(const struct dmi_system_id *d)</span>
 static int __init disable_acpi_pci(const struct dmi_system_id *d)
 {
 	if (!acpi_force) {
<span class="p_del">-		printk(KERN_NOTICE &quot;%s detected: force use of pci=noacpi\n&quot;,</span>
<span class="p_del">-		       d-&gt;ident);</span>
<span class="p_add">+		pr_notice(&quot;%s detected: force use of pci=noacpi\n&quot;,</span>
<span class="p_add">+			  d-&gt;ident);</span>
 		acpi_disable_pci();
 	}
 	return 0;
<span class="p_chunk">@@ -1295,11 +1286,10 @@</span> <span class="p_context"> static int __init disable_acpi_pci(const struct dmi_system_id *d)</span>
 static int __init dmi_disable_acpi(const struct dmi_system_id *d)
 {
 	if (!acpi_force) {
<span class="p_del">-		printk(KERN_NOTICE &quot;%s detected: acpi off\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_notice(&quot;%s detected: acpi off\n&quot;, d-&gt;ident);</span>
 		disable_acpi();
 	} else {
<span class="p_del">-		printk(KERN_NOTICE</span>
<span class="p_del">-		       &quot;Warning: DMI blacklist says broken, but acpi forced\n&quot;);</span>
<span class="p_add">+		pr_notice(&quot;Warning: DMI blacklist says broken, but acpi forced\n&quot;);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1514,9 +1504,9 @@</span> <span class="p_context"> void __init acpi_boot_table_init(void)</span>
 	 */
 	if (acpi_blacklisted()) {
 		if (acpi_force) {
<span class="p_del">-			printk(KERN_WARNING PREFIX &quot;acpi=force override\n&quot;);</span>
<span class="p_add">+			pr_warn(PREFIX &quot;acpi=force override\n&quot;);</span>
 		} else {
<span class="p_del">-			printk(KERN_WARNING PREFIX &quot;Disabling ACPI support\n&quot;);</span>
<span class="p_add">+			pr_warn(PREFIX &quot;Disabling ACPI support\n&quot;);</span>
 			disable_acpi();
 			return;
 		}
<span class="p_chunk">@@ -1630,9 +1620,9 @@</span> <span class="p_context"> int __init acpi_mps_check(void)</span>
 #if defined(CONFIG_X86_LOCAL_APIC) &amp;&amp; !defined(CONFIG_X86_MPPARSE)
 /* mptable code is not built-in*/
 	if (acpi_disabled || acpi_noirq) {
<span class="p_del">-		printk(KERN_WARNING &quot;MPS support code is not built-in.\n&quot;</span>
<span class="p_del">-		       &quot;Using acpi=off or acpi=noirq or pci=noacpi &quot;</span>
<span class="p_del">-		       &quot;may have problem\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;MPS support code is not built-in.\n&quot;</span>
<span class="p_add">+			&quot;Using acpi=off or acpi=noirq or pci=noacpi &quot;</span>
<span class="p_add">+			&quot;may have problem\n&quot;);</span>
 		return 1;
 	}
 #endif
<span class="p_header">diff --git a/arch/x86/kernel/acpi/cstate.c b/arch/x86/kernel/acpi/cstate.c</span>
<span class="p_header">index 4b28159..d94cb2a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/cstate.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/cstate.c</span>
<span class="p_chunk">@@ -103,9 +103,8 @@</span> <span class="p_context"> static long acpi_processor_ffh_cstate_probe_cpu(void *_cx)</span>
 
 	if (!mwait_supported[cstate_type]) {
 		mwait_supported[cstate_type] = 1;
<span class="p_del">-		printk(KERN_DEBUG</span>
<span class="p_del">-			&quot;Monitor-Mwait will be used to enter C-%d &quot;</span>
<span class="p_del">-			&quot;state\n&quot;, cx-&gt;type);</span>
<span class="p_add">+		pr_debug(&quot;Monitor-Mwait will be used to enter C-%d state\n&quot;,</span>
<span class="p_add">+			 cx-&gt;type);</span>
 	}
 	snprintf(cx-&gt;desc,
 			ACPI_CX_DESC_LEN, &quot;ACPI FFH INTEL MWAIT 0x%x&quot;,
<span class="p_header">diff --git a/arch/x86/kernel/acpi/sleep.c b/arch/x86/kernel/acpi/sleep.c</span>
<span class="p_header">index d1daead..a850963 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/sleep.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/sleep.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> int x86_acpi_suspend_lowlevel(void)</span>
 		(struct wakeup_header *) __va(real_mode_header-&gt;wakeup_header);
 
 	if (header-&gt;signature != WAKEUP_HEADER_SIGNATURE) {
<span class="p_del">-		printk(KERN_ERR &quot;wakeup header does not match\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;wakeup header does not match\n&quot;);</span>
 		return -EINVAL;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c</span>
<span class="p_header">index 25f9093..0ecb579 100644</span>
<span class="p_header">--- a/arch/x86/kernel/alternative.c</span>
<span class="p_header">+++ b/arch/x86/kernel/alternative.c</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> __setup(&quot;noreplace-paravirt&quot;, setup_noreplace_paravirt);</span>
 #define DPRINTK(fmt, args...)						\
 do {									\
 	if (debug_alternative)						\
<span class="p_del">-		printk(KERN_DEBUG &quot;%s: &quot; fmt &quot;\n&quot;, __func__, ##args);	\</span>
<span class="p_add">+		pr_debug(&quot;%s: &quot; fmt &quot;\n&quot;, __func__, ##args);	\</span>
 } while (0)
 
 #define DUMP_BYTES(buf, len, fmt, args...)				\
<span class="p_chunk">@@ -70,10 +70,10 @@</span> <span class="p_context"> do {									\</span>
 		if (!(len))						\
 			break;						\
 									\
<span class="p_del">-		printk(KERN_DEBUG fmt, ##args);				\</span>
<span class="p_add">+		pr_debug(fmt, ##args);				\</span>
 		for (j = 0; j &lt; (len) - 1; j++)				\
<span class="p_del">-			printk(KERN_CONT &quot;%02hhx &quot;, buf[j]);		\</span>
<span class="p_del">-		printk(KERN_CONT &quot;%02hhx\n&quot;, buf[j]);			\</span>
<span class="p_add">+			pr_cont(&quot;%02hhx &quot;, buf[j]);		\</span>
<span class="p_add">+		pr_cont(&quot;%02hhx\n&quot;, buf[j]);			\</span>
 	}								\
 } while (0)
 
<span class="p_header">diff --git a/arch/x86/kernel/amd_gart_64.c b/arch/x86/kernel/amd_gart_64.c</span>
<span class="p_header">index 8e3842f..24fb9cf 100644</span>
<span class="p_header">--- a/arch/x86/kernel/amd_gart_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/amd_gart_64.c</span>
<span class="p_chunk">@@ -536,10 +536,9 @@</span> <span class="p_context"> static __init unsigned long check_iommu_size(unsigned long aper, u64 aper_size)</span>
 	iommu_size -= round_up(a, PMD_PAGE_SIZE) - a;
 
 	if (iommu_size &lt; 64*1024*1024) {
<span class="p_del">-		pr_warning(</span>
<span class="p_del">-			&quot;PCI-DMA: Warning: Small IOMMU %luMB.&quot;</span>
<span class="p_add">+		pr_warn(&quot;PCI-DMA: Warning: Small IOMMU %luMB.&quot;</span>
 			&quot; Consider increasing the AGP aperture in BIOS\n&quot;,
<span class="p_del">-				iommu_size &gt;&gt; 20);</span>
<span class="p_add">+			iommu_size &gt;&gt; 20);</span>
 	}
 
 	return iommu_size;
<span class="p_chunk">@@ -691,8 +690,8 @@</span> <span class="p_context"> static __init int init_amd_gatt(struct agp_kern_info *info)</span>
 
  nommu:
 	/* Should not happen anymore */
<span class="p_del">-	pr_warning(&quot;PCI-DMA: More than 4GB of RAM and no IOMMU\n&quot;</span>
<span class="p_del">-	       &quot;falling back to iommu=soft.\n&quot;);</span>
<span class="p_add">+	pr_warn(&quot;PCI-DMA: More than 4GB of RAM and no IOMMU\n&quot;</span>
<span class="p_add">+		&quot;falling back to iommu=soft.\n&quot;);</span>
 	return -1;
 }
 
<span class="p_chunk">@@ -757,8 +756,8 @@</span> <span class="p_context"> int __init gart_iommu_init(void)</span>
 	    !gart_iommu_aperture ||
 	    (no_agp &amp;&amp; init_amd_gatt(&amp;info) &lt; 0)) {
 		if (max_pfn &gt; MAX_DMA32_PFN) {
<span class="p_del">-			pr_warning(&quot;More than 4GB of memory but GART IOMMU not available.\n&quot;);</span>
<span class="p_del">-			pr_warning(&quot;falling back to iommu=soft.\n&quot;);</span>
<span class="p_add">+			pr_warn(&quot;More than 4GB of memory but GART IOMMU not available.\n&quot;);</span>
<span class="p_add">+			pr_warn(&quot;falling back to iommu=soft.\n&quot;);</span>
 		}
 		return 0;
 	}
<span class="p_header">diff --git a/arch/x86/kernel/apb_timer.c b/arch/x86/kernel/apb_timer.c</span>
<span class="p_header">index 222a570..c5b378a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apb_timer.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apb_timer.c</span>
<span class="p_chunk">@@ -90,13 +90,13 @@</span> <span class="p_context"> static inline void apbt_set_mapping(void)</span>
 	}
 	mtmr = sfi_get_mtmr(APBT_CLOCKEVENT0_NUM);
 	if (mtmr == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;Failed to get MTMR %d from SFI\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;Failed to get MTMR %d from SFI\n&quot;,</span>
 		       APBT_CLOCKEVENT0_NUM);
 		return;
 	}
 	apbt_address = (phys_addr_t)mtmr-&gt;phys_addr;
 	if (!apbt_address) {
<span class="p_del">-		printk(KERN_WARNING &quot;No timer base from SFI, use default\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;No timer base from SFI, use default\n&quot;);</span>
 		apbt_address = APBT_DEFAULT_BASE;
 	}
 	apbt_virt_address = ioremap_nocache(apbt_address, APBT_MMAP_SIZE);
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"> static int __init apbt_clockevent_register(void)</span>
 
 	mtmr = sfi_get_mtmr(APBT_CLOCKEVENT0_NUM);
 	if (mtmr == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;Failed to get MTMR %d from SFI\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;Failed to get MTMR %d from SFI\n&quot;,</span>
 		       APBT_CLOCKEVENT0_NUM);
 		return -ENODEV;
 	}
<span class="p_chunk">@@ -157,8 +157,8 @@</span> <span class="p_context"> static int __init apbt_clockevent_register(void)</span>
 
 	if (intel_mid_timer_options == INTEL_MID_TIMER_LAPIC_APBT) {
 		global_clock_event = &amp;adev-&gt;timer-&gt;ced;
<span class="p_del">-		printk(KERN_DEBUG &quot;%s clockevent registered as global\n&quot;,</span>
<span class="p_del">-		       global_clock_event-&gt;name);</span>
<span class="p_add">+		pr_debug(&quot;%s clockevent registered as global\n&quot;,</span>
<span class="p_add">+			 global_clock_event-&gt;name);</span>
 	}
 
 	dw_apb_clockevent_register(adev-&gt;timer);
<span class="p_chunk">@@ -196,8 +196,8 @@</span> <span class="p_context"> void apbt_setup_secondary_clock(void)</span>
 		dw_apb_clockevent_resume(adev-&gt;timer);
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;Registering CPU %d clockevent device %s, cpu %08x\n&quot;,</span>
<span class="p_del">-	       cpu, adev-&gt;name, adev-&gt;cpu);</span>
<span class="p_add">+	pr_info(&quot;Registering CPU %d clockevent device %s, cpu %08x\n&quot;,</span>
<span class="p_add">+		cpu, adev-&gt;name, adev-&gt;cpu);</span>
 
 	apbt_setup_irq(adev);
 	dw_apb_clockevent_register(adev-&gt;timer);
<span class="p_chunk">@@ -327,7 +327,7 @@</span> <span class="p_context"> void __init apbt_time_init(void)</span>
 #ifdef CONFIG_SMP
 	/* kernel cmdline disable apb timer, so we will use lapic timers */
 	if (intel_mid_timer_options == INTEL_MID_TIMER_LAPIC_APBT) {
<span class="p_del">-		printk(KERN_INFO &quot;apbt: disabled per cpu timer\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;apbt: disabled per cpu timer\n&quot;);</span>
 		return;
 	}
 	pr_debug(&quot;%s: %d CPUs online\n&quot;, __func__, num_online_cpus());
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> void __init apbt_time_init(void)</span>
 		if (p_mtmr)
 			adev-&gt;irq = p_mtmr-&gt;irq;
 		else
<span class="p_del">-			printk(KERN_ERR &quot;Failed to get timer for cpu %d\n&quot;, i);</span>
<span class="p_add">+			pr_err(&quot;Failed to get timer for cpu %d\n&quot;, i);</span>
 		snprintf(adev-&gt;name, sizeof(adev-&gt;name) - 1, &quot;apbt%d&quot;, i);
 	}
 #endif
<span class="p_chunk">@@ -400,13 +400,12 @@</span> <span class="p_context"> unsigned long apbt_quick_calibrate(void)</span>
 
 	shift = 5;
 	if (unlikely(loop &gt;&gt; shift == 0)) {
<span class="p_del">-		printk(KERN_INFO</span>
<span class="p_del">-		       &quot;APBT TSC calibration failed, not enough resolution\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;APBT TSC calibration failed, not enough resolution\n&quot;);</span>
 		return 0;
 	}
 	scale = (int)div_u64((t2 - t1), loop &gt;&gt; shift);
 	khz = (scale * (apbt_freq / 1000)) &gt;&gt; shift;
<span class="p_del">-	printk(KERN_INFO &quot;TSC freq calculated by APB timer is %lu khz\n&quot;, khz);</span>
<span class="p_add">+	pr_info(&quot;TSC freq calculated by APB timer is %lu khz\n&quot;, khz);</span>
 	return khz;
 failed:
 	return 0;
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">index 8a5cdda..028c46f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic.c</span>
<span class="p_chunk">@@ -349,7 +349,7 @@</span> <span class="p_context"> static void __setup_APIC_LVTT(unsigned int clocks, int oneshot, int irqen)</span>
 		 */
 		asm volatile(&quot;mfence&quot; : : : &quot;memory&quot;);
 
<span class="p_del">-		printk_once(KERN_DEBUG &quot;TSC deadline timer enabled\n&quot;);</span>
<span class="p_add">+		pr_debug_once(&quot;TSC deadline timer enabled\n&quot;);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -657,8 +657,8 @@</span> <span class="p_context"> calibrate_by_pmtimer(long deltapm, long *delta, long *deltatsc)</span>
 
 	res = (((u64)deltapm) *  mult) &gt;&gt; 22;
 	do_div(res, 1000000);
<span class="p_del">-	pr_warning(&quot;APIC calibration not consistent &quot;</span>
<span class="p_del">-		   &quot;with PM-Timer: %ldms instead of 100ms\n&quot;,(long)res);</span>
<span class="p_add">+	pr_warn(&quot;APIC calibration not consistent &quot;</span>
<span class="p_add">+		&quot;with PM-Timer: %ldms instead of 100ms\n&quot;, (long)res);</span>
 
 	/* Correct the lapic counter value */
 	res = (((u64)(*delta)) * pm_100ms);
<span class="p_chunk">@@ -777,7 +777,7 @@</span> <span class="p_context"> static int __init calibrate_APIC_clock(void)</span>
 	 */
 	if (lapic_timer_frequency &lt; (1000000 / HZ)) {
 		local_irq_enable();
<span class="p_del">-		pr_warning(&quot;APIC frequency too slow, disabling apic timer\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;APIC frequency too slow, disabling apic timer\n&quot;);</span>
 		return -1;
 	}
 
<span class="p_chunk">@@ -820,7 +820,7 @@</span> <span class="p_context"> static int __init calibrate_APIC_clock(void)</span>
 	local_irq_enable();
 
 	if (levt-&gt;features &amp; CLOCK_EVT_FEAT_DUMMY) {
<span class="p_del">-		pr_warning(&quot;APIC timer disabled due to verification failure\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;APIC timer disabled due to verification failure\n&quot;);</span>
 			return -1;
 	}
 
<span class="p_chunk">@@ -893,7 +893,7 @@</span> <span class="p_context"> static void local_apic_timer_interrupt(void)</span>
 	 * spurious.
 	 */
 	if (!evt-&gt;event_handler) {
<span class="p_del">-		pr_warning(&quot;Spurious LAPIC timer interrupt on cpu %d\n&quot;, cpu);</span>
<span class="p_add">+		pr_warn(&quot;Spurious LAPIC timer interrupt on cpu %d\n&quot;, cpu);</span>
 		/* Switch it off */
 		lapic_timer_shutdown(evt);
 		return;
<span class="p_chunk">@@ -1306,7 +1306,7 @@</span> <span class="p_context"> void setup_local_APIC(void)</span>
 			}
 		}
 		if (acked &gt; 256) {
<span class="p_del">-			printk(KERN_ERR &quot;LAPIC pending interrupts after %d EOI\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;LAPIC pending interrupts after %d EOI\n&quot;,</span>
 			       acked);
 			break;
 		}
<span class="p_chunk">@@ -1454,7 +1454,7 @@</span> <span class="p_context"> static void __x2apic_disable(void)</span>
 	/* Disable xapic and x2apic first and then reenable xapic mode */
 	wrmsrl(MSR_IA32_APICBASE, msr &amp; ~(X2APIC_ENABLE | XAPIC_ENABLE));
 	wrmsrl(MSR_IA32_APICBASE, msr &amp; ~X2APIC_ENABLE);
<span class="p_del">-	printk_once(KERN_INFO &quot;x2apic disabled\n&quot;);</span>
<span class="p_add">+	pr_info_once(&quot;x2apic disabled\n&quot;);</span>
 }
 
 static void __x2apic_enable(void)
<span class="p_chunk">@@ -1465,7 +1465,7 @@</span> <span class="p_context"> static void __x2apic_enable(void)</span>
 	if (msr &amp; X2APIC_ENABLE)
 		return;
 	wrmsrl(MSR_IA32_APICBASE, msr | X2APIC_ENABLE);
<span class="p_del">-	printk_once(KERN_INFO &quot;x2apic enabled\n&quot;);</span>
<span class="p_add">+	pr_info_once(&quot;x2apic enabled\n&quot;);</span>
 }
 
 static int __init setup_nox2apic(char *str)
<span class="p_chunk">@@ -1474,11 +1474,11 @@</span> <span class="p_context"> static int __init setup_nox2apic(char *str)</span>
 		int apicid = native_apic_msr_read(APIC_ID);
 
 		if (apicid &gt;= 255) {
<span class="p_del">-			pr_warning(&quot;Apicid: %08x, cannot enforce nox2apic\n&quot;,</span>
<span class="p_add">+			pr_warn(&quot;Apicid: %08x, cannot enforce nox2apic\n&quot;,</span>
 				   apicid);
 			return 0;
 		}
<span class="p_del">-		pr_warning(&quot;x2apic already enabled.\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;x2apic already enabled.\n&quot;);</span>
 		__x2apic_disable();
 	}
 	setup_clear_cpu_cap(X86_FEATURE_X2APIC);
<span class="p_chunk">@@ -1652,7 +1652,7 @@</span> <span class="p_context"> static int __init apic_verify(void)</span>
 	 */
 	features = cpuid_edx(1);
 	if (!(features &amp; (1 &lt;&lt; X86_FEATURE_APIC))) {
<span class="p_del">-		pr_warning(&quot;Could not enable APIC!\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;Could not enable APIC!\n&quot;);</span>
 		return -1;
 	}
 	set_cpu_cap(&amp;boot_cpu_data, X86_FEATURE_APIC);
<span class="p_chunk">@@ -2028,9 +2028,9 @@</span> <span class="p_context"> int generic_processor_info(int apicid, int version)</span>
 	    disabled_cpu_apicid == apicid) {
 		int thiscpu = num_processors + disabled_cpus;
 
<span class="p_del">-		pr_warning(&quot;APIC: Disabling requested cpu.&quot;</span>
<span class="p_del">-			   &quot; Processor %d/0x%x ignored.\n&quot;,</span>
<span class="p_del">-			   thiscpu, apicid);</span>
<span class="p_add">+		pr_warn(&quot;APIC: Disabling requested cpu.&quot;</span>
<span class="p_add">+			&quot; Processor %d/0x%x ignored.\n&quot;,</span>
<span class="p_add">+			thiscpu, apicid);</span>
 
 		disabled_cpus++;
 		return -ENODEV;
<span class="p_chunk">@@ -2044,8 +2044,7 @@</span> <span class="p_context"> int generic_processor_info(int apicid, int version)</span>
 	    apicid != boot_cpu_physical_apicid) {
 		int thiscpu = max + disabled_cpus - 1;
 
<span class="p_del">-		pr_warning(</span>
<span class="p_del">-			&quot;ACPI: NR_CPUS/possible_cpus limit of %i almost&quot;</span>
<span class="p_add">+		pr_warn(&quot;ACPI: NR_CPUS/possible_cpus limit of %i almost&quot;</span>
 			&quot; reached. Keeping one slot for boot cpu.&quot;
 			&quot;  Processor %d/0x%x ignored.\n&quot;, max, thiscpu, apicid);
 
<span class="p_chunk">@@ -2056,8 +2055,7 @@</span> <span class="p_context"> int generic_processor_info(int apicid, int version)</span>
 	if (num_processors &gt;= nr_cpu_ids) {
 		int thiscpu = max + disabled_cpus;
 
<span class="p_del">-		pr_warning(</span>
<span class="p_del">-			&quot;ACPI: NR_CPUS/possible_cpus limit of %i reached.&quot;</span>
<span class="p_add">+		pr_warn(&quot;ACPI: NR_CPUS/possible_cpus limit of %i reached.&quot;</span>
 			&quot;  Processor %d/0x%x ignored.\n&quot;, max, thiscpu, apicid);
 
 		disabled_cpus++;
<span class="p_chunk">@@ -2081,14 +2079,14 @@</span> <span class="p_context"> int generic_processor_info(int apicid, int version)</span>
 	 * Validate version
 	 */
 	if (version == 0x0) {
<span class="p_del">-		pr_warning(&quot;BIOS bug: APIC version is 0 for CPU %d/0x%x, fixing up to 0x10\n&quot;,</span>
<span class="p_del">-			   cpu, apicid);</span>
<span class="p_add">+		pr_warn(&quot;BIOS bug: APIC version is 0 for CPU %d/0x%x, fixing up to 0x10\n&quot;,</span>
<span class="p_add">+			cpu, apicid);</span>
 		version = 0x10;
 	}
 	apic_version[apicid] = version;
 
 	if (version != apic_version[boot_cpu_physical_apicid]) {
<span class="p_del">-		pr_warning(&quot;BIOS bug: APIC version mismatch, boot CPU: %x, CPU %d: version %x\n&quot;,</span>
<span class="p_add">+		pr_warn(&quot;BIOS bug: APIC version mismatch, boot CPU: %x, CPU %d: version %x\n&quot;,</span>
 			apic_version[boot_cpu_physical_apicid], cpu, version);
 	}
 
<span class="p_chunk">@@ -2531,7 +2529,7 @@</span> <span class="p_context"> static int __init apic_set_verbosity(char *arg)</span>
 	else if (strcmp(&quot;verbose&quot;, arg) == 0)
 		apic_verbosity = APIC_VERBOSE;
 	else {
<span class="p_del">-		pr_warning(&quot;APIC Verbosity level %s not recognised&quot;</span>
<span class="p_add">+		pr_warn(&quot;APIC Verbosity level %s not recognised&quot;</span>
 			&quot; use apic=verbose or apic=debug\n&quot;, arg);
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic_flat_64.c b/arch/x86/kernel/apic/apic_flat_64.c</span>
<span class="p_header">index 9968f30..1af714c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic_flat_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic_flat_64.c</span>
<span class="p_chunk">@@ -218,12 +218,12 @@</span> <span class="p_context"> static int physflat_acpi_madt_oem_check(char *oem_id, char *oem_table_id)</span>
 	 */
 	if (acpi_gbl_FADT.header.revision &gt;= FADT2_REVISION_ID &amp;&amp;
 		(acpi_gbl_FADT.flags &amp; ACPI_FADT_APIC_PHYSICAL)) {
<span class="p_del">-		printk(KERN_DEBUG &quot;system APIC only can use physical flat&quot;);</span>
<span class="p_add">+		pr_debug(&quot;system APIC only can use physical flat&quot;);</span>
 		return 1;
 	}
 
 	if (!strncmp(oem_id, &quot;IBM&quot;, 3) &amp;&amp; !strncmp(oem_table_id, &quot;EXA&quot;, 3)) {
<span class="p_del">-		printk(KERN_DEBUG &quot;IBM Summit detected, will use apic physical&quot;);</span>
<span class="p_add">+		pr_debug(&quot;IBM Summit detected, will use apic physical&quot;);</span>
 		return 1;
 	}
 #endif
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic_noop.c b/arch/x86/kernel/apic/apic_noop.c</span>
<span class="p_header">index 331a7a0..80380d4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic_noop.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic_noop.c</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"> static void noop_vector_allocation_domain(int cpu, struct cpumask *retmask,</span>
 					  const struct cpumask *mask)
 {
 	if (cpu != 0)
<span class="p_del">-		pr_warning(&quot;APIC: Vector allocated for non-BSP cpu\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;APIC: Vector allocated for non-BSP cpu\n&quot;);</span>
 	cpumask_copy(retmask, cpumask_of(cpu));
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/apic/bigsmp_32.c b/arch/x86/kernel/apic/bigsmp_32.c</span>
<span class="p_header">index cf9bd89..52f0fb5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/bigsmp_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/bigsmp_32.c</span>
<span class="p_chunk">@@ -67,8 +67,7 @@</span> <span class="p_context"> static void bigsmp_init_apic_ldr(void)</span>
 
 static void bigsmp_setup_apic_routing(void)
 {
<span class="p_del">-	printk(KERN_INFO</span>
<span class="p_del">-		&quot;Enabling APIC mode:  Physflat.  Using %d I/O APICs\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Enabling APIC mode:  Physflat.  Using %d I/O APICs\n&quot;,</span>
 		nr_ioapics);
 }
 
<span class="p_chunk">@@ -110,7 +109,7 @@</span> <span class="p_context"> static int dmi_bigsmp; /* can be set by dmi scanners */</span>
 
 static int hp_ht_bigsmp(const struct dmi_system_id *d)
 {
<span class="p_del">-	printk(KERN_NOTICE &quot;%s detected: force use of apic=bigsmp\n&quot;, d-&gt;ident);</span>
<span class="p_add">+	pr_notice(&quot;%s detected: force use of apic=bigsmp\n&quot;, d-&gt;ident);</span>
 	dmi_bigsmp = 1;
 
 	return 0;
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index fdb0fbf..71b05654 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -1253,7 +1253,7 @@</span> <span class="p_context"> static void io_apic_print_entries(unsigned int apic, unsigned int nr_entries)</span>
 	struct IO_APIC_route_entry entry;
 	struct IR_IO_APIC_route_entry *ir_entry = (void *)&amp;entry;
 
<span class="p_del">-	printk(KERN_DEBUG &quot;IOAPIC %d:\n&quot;, apic);</span>
<span class="p_add">+	pr_debug(&quot;IOAPIC %d:\n&quot;, apic);</span>
 	for (i = 0; i &lt;= nr_entries; i++) {
 		entry = ioapic_read_entry(apic, i);
 		snprintf(buf, sizeof(buf),
<span class="p_chunk">@@ -1264,15 +1264,14 @@</span> <span class="p_context"> static void io_apic_print_entries(unsigned int apic, unsigned int nr_entries)</span>
 			 entry.polarity == IOAPIC_POL_LOW ? &quot;low &quot; : &quot;high&quot;,
 			 entry.vector, entry.irr, entry.delivery_status);
 		if (ir_entry-&gt;format)
<span class="p_del">-			printk(KERN_DEBUG &quot;%s, remapped, I(%04X),  Z(%X)\n&quot;,</span>
<span class="p_del">-			       buf, (ir_entry-&gt;index &lt;&lt; 15) | ir_entry-&gt;index,</span>
<span class="p_del">-			       ir_entry-&gt;zero);</span>
<span class="p_add">+			pr_debug(&quot;%s, remapped, I(%04X),  Z(%X)\n&quot;, buf,</span>
<span class="p_add">+				 (ir_entry-&gt;index &lt;&lt; 15) | ir_entry-&gt;index,</span>
<span class="p_add">+				 ir_entry-&gt;zero);</span>
 		else
<span class="p_del">-			printk(KERN_DEBUG &quot;%s, %s, D(%02X), M(%1d)\n&quot;,</span>
<span class="p_del">-			       buf,</span>
<span class="p_del">-			       entry.dest_mode == IOAPIC_DEST_MODE_LOGICAL ?</span>
<span class="p_del">-			       &quot;logical &quot; : &quot;physical&quot;,</span>
<span class="p_del">-			       entry.dest, entry.delivery_mode);</span>
<span class="p_add">+			pr_debug(&quot;%s, %s, D(%02X), M(%1d)\n&quot;, buf,</span>
<span class="p_add">+				 entry.dest_mode == IOAPIC_DEST_MODE_LOGICAL ?</span>
<span class="p_add">+				 &quot;logical &quot; : &quot;physical&quot;,</span>
<span class="p_add">+				 entry.dest, entry.delivery_mode);</span>
 	}
 }
 
<span class="p_chunk">@@ -1293,19 +1292,19 @@</span> <span class="p_context"> static void __init print_IO_APIC(int ioapic_idx)</span>
 		reg_03.raw = io_apic_read(ioapic_idx, 3);
 	raw_spin_unlock_irqrestore(&amp;ioapic_lock, flags);
 
<span class="p_del">-	printk(KERN_DEBUG &quot;IO APIC #%d......\n&quot;, mpc_ioapic_id(ioapic_idx));</span>
<span class="p_del">-	printk(KERN_DEBUG &quot;.... register #00: %08X\n&quot;, reg_00.raw);</span>
<span class="p_del">-	printk(KERN_DEBUG &quot;.......    : physical APIC id: %02X\n&quot;, reg_00.bits.ID);</span>
<span class="p_del">-	printk(KERN_DEBUG &quot;.......    : Delivery Type: %X\n&quot;, reg_00.bits.delivery_type);</span>
<span class="p_del">-	printk(KERN_DEBUG &quot;.......    : LTS          : %X\n&quot;, reg_00.bits.LTS);</span>
<span class="p_add">+	pr_debug(&quot;IO APIC #%d......\n&quot;, mpc_ioapic_id(ioapic_idx));</span>
<span class="p_add">+	pr_debug(&quot;.... register #00: %08X\n&quot;, reg_00.raw);</span>
<span class="p_add">+	pr_debug(&quot;.......    : physical APIC id: %02X\n&quot;, reg_00.bits.ID);</span>
<span class="p_add">+	pr_debug(&quot;.......    : Delivery Type: %X\n&quot;, reg_00.bits.delivery_type);</span>
<span class="p_add">+	pr_debug(&quot;.......    : LTS          : %X\n&quot;, reg_00.bits.LTS);</span>
 
<span class="p_del">-	printk(KERN_DEBUG &quot;.... register #01: %08X\n&quot;, *(int *)&amp;reg_01);</span>
<span class="p_del">-	printk(KERN_DEBUG &quot;.......     : max redirection entries: %02X\n&quot;,</span>
<span class="p_del">-		reg_01.bits.entries);</span>
<span class="p_add">+	pr_debug(&quot;.... register #01: %08X\n&quot;, *(int *)&amp;reg_01);</span>
<span class="p_add">+	pr_debug(&quot;.......     : max redirection entries: %02X\n&quot;,</span>
<span class="p_add">+		 reg_01.bits.entries);</span>
 
<span class="p_del">-	printk(KERN_DEBUG &quot;.......     : PRQ implemented: %X\n&quot;, reg_01.bits.PRQ);</span>
<span class="p_del">-	printk(KERN_DEBUG &quot;.......     : IO APIC version: %02X\n&quot;,</span>
<span class="p_del">-		reg_01.bits.version);</span>
<span class="p_add">+	pr_debug(&quot;.......     : PRQ implemented: %X\n&quot;, reg_01.bits.PRQ);</span>
<span class="p_add">+	pr_debug(&quot;.......     : IO APIC version: %02X\n&quot;,</span>
<span class="p_add">+		 reg_01.bits.version);</span>
 
 	/*
 	 * Some Intel chipsets with IO APIC VERSION of 0x1? don&#39;t have reg_02,
<span class="p_chunk">@@ -1313,8 +1312,9 @@</span> <span class="p_context"> static void __init print_IO_APIC(int ioapic_idx)</span>
 	 * value, so ignore it if reg_02 == reg_01.
 	 */
 	if (reg_01.bits.version &gt;= 0x10 &amp;&amp; reg_02.raw != reg_01.raw) {
<span class="p_del">-		printk(KERN_DEBUG &quot;.... register #02: %08X\n&quot;, reg_02.raw);</span>
<span class="p_del">-		printk(KERN_DEBUG &quot;.......     : arbitration: %02X\n&quot;, reg_02.bits.arbitration);</span>
<span class="p_add">+		pr_debug(&quot;.... register #02: %08X\n&quot;, reg_02.raw);</span>
<span class="p_add">+		pr_debug(&quot;.......     : arbitration: %02X\n&quot;,</span>
<span class="p_add">+			 reg_02.bits.arbitration);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -1324,11 +1324,12 @@</span> <span class="p_context"> static void __init print_IO_APIC(int ioapic_idx)</span>
 	 */
 	if (reg_01.bits.version &gt;= 0x20 &amp;&amp; reg_03.raw != reg_02.raw &amp;&amp;
 	    reg_03.raw != reg_01.raw) {
<span class="p_del">-		printk(KERN_DEBUG &quot;.... register #03: %08X\n&quot;, reg_03.raw);</span>
<span class="p_del">-		printk(KERN_DEBUG &quot;.......     : Boot DT    : %X\n&quot;, reg_03.bits.boot_DT);</span>
<span class="p_add">+		pr_debug(&quot;.... register #03: %08X\n&quot;, reg_03.raw);</span>
<span class="p_add">+		pr_debug(&quot;.......     : Boot DT    : %X\n&quot;,</span>
<span class="p_add">+			 reg_03.bits.boot_DT);</span>
 	}
 
<span class="p_del">-	printk(KERN_DEBUG &quot;.... IRQ redirection table:\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;.... IRQ redirection table:\n&quot;);</span>
 	io_apic_print_entries(ioapic_idx, reg_01.bits.entries);
 }
 
<span class="p_chunk">@@ -1337,22 +1338,22 @@</span> <span class="p_context"> void __init print_IO_APICs(void)</span>
 	int ioapic_idx;
 	unsigned int irq;
 
<span class="p_del">-	printk(KERN_DEBUG &quot;number of MP IRQ sources: %d.\n&quot;, mp_irq_entries);</span>
<span class="p_add">+	pr_debug(&quot;number of MP IRQ sources: %d.\n&quot;, mp_irq_entries);</span>
 	for_each_ioapic(ioapic_idx)
<span class="p_del">-		printk(KERN_DEBUG &quot;number of IO-APIC #%d registers: %d.\n&quot;,</span>
<span class="p_del">-		       mpc_ioapic_id(ioapic_idx),</span>
<span class="p_del">-		       ioapics[ioapic_idx].nr_registers);</span>
<span class="p_add">+		pr_debug(&quot;number of IO-APIC #%d registers: %d.\n&quot;,</span>
<span class="p_add">+			 mpc_ioapic_id(ioapic_idx),</span>
<span class="p_add">+			 ioapics[ioapic_idx].nr_registers);</span>
 
 	/*
 	 * We are a bit conservative about what we expect.  We have to
 	 * know about every hardware change ASAP.
 	 */
<span class="p_del">-	printk(KERN_INFO &quot;testing the IO APIC.......................\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;testing the IO APIC.......................\n&quot;);</span>
 
 	for_each_ioapic(ioapic_idx)
 		print_IO_APIC(ioapic_idx);
 
<span class="p_del">-	printk(KERN_DEBUG &quot;IRQ to pin mappings:\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;IRQ to pin mappings:\n&quot;);</span>
 	for_each_active_irq(irq) {
 		struct irq_pin_list *entry;
 		struct irq_chip *chip;
<span class="p_chunk">@@ -1367,13 +1368,13 @@</span> <span class="p_context"> void __init print_IO_APICs(void)</span>
 		if (list_empty(&amp;data-&gt;irq_2_pin))
 			continue;
 
<span class="p_del">-		printk(KERN_DEBUG &quot;IRQ%d &quot;, irq);</span>
<span class="p_add">+		pr_debug(&quot;IRQ%d &quot;, irq);</span>
 		for_each_irq_pin(entry, data-&gt;irq_2_pin)
 			pr_cont(&quot;-&gt; %d:%d&quot;, entry-&gt;apic, entry-&gt;pin);
 		pr_cont(&quot;\n&quot;);
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;.................................... done.\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;.................................... done.\n&quot;);</span>
 }
 
 /* Where if anywhere is the i8259 connect in external int mode */
<span class="p_chunk">@@ -1413,7 +1414,7 @@</span> <span class="p_context"> void __init enable_IO_APIC(void)</span>
 	i8259_apic = find_isa_irq_apic(0, mp_ExtINT);
 	/* Trust the MP table if nothing is setup in the hardware */
 	if ((ioapic_i8259.pin == -1) &amp;&amp; (i8259_pin &gt;= 0)) {
<span class="p_del">-		printk(KERN_WARNING &quot;ExtINT not setup in hardware but reported by MP table\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;ExtINT not setup in hardware but reported by MP table\n&quot;);</span>
 		ioapic_i8259.pin  = i8259_pin;
 		ioapic_i8259.apic = i8259_apic;
 	}
<span class="p_chunk">@@ -1421,7 +1422,7 @@</span> <span class="p_context"> void __init enable_IO_APIC(void)</span>
 	if (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) &amp;&amp;
 		(i8259_pin &gt;= 0) &amp;&amp; (ioapic_i8259.pin &gt;= 0))
 	{
<span class="p_del">-		printk(KERN_WARNING &quot;ExtINT in hardware and MP table differ\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;ExtINT in hardware and MP table differ\n&quot;);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -1508,9 +1509,9 @@</span> <span class="p_context"> void __init setup_ioapic_ids_from_mpc_nocheck(void)</span>
 		old_id = mpc_ioapic_id(ioapic_idx);
 
 		if (mpc_ioapic_id(ioapic_idx) &gt;= get_physical_broadcast()) {
<span class="p_del">-			printk(KERN_ERR &quot;BIOS bug, IO-APIC#%d ID is %d in the MPC table!...\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;BIOS bug, IO-APIC#%d ID is %d in the MPC table!...\n&quot;,</span>
 				ioapic_idx, mpc_ioapic_id(ioapic_idx));
<span class="p_del">-			printk(KERN_ERR &quot;... fixing up to %d. (tell your hw vendor)\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;... fixing up to %d. (tell your hw vendor)\n&quot;,</span>
 				reg_00.bits.ID);
 			ioapics[ioapic_idx].mp_config.apicid = reg_00.bits.ID;
 		}
<span class="p_chunk">@@ -1522,14 +1523,14 @@</span> <span class="p_context"> void __init setup_ioapic_ids_from_mpc_nocheck(void)</span>
 		 */
 		if (apic-&gt;check_apicid_used(&amp;phys_id_present_map,
 					    mpc_ioapic_id(ioapic_idx))) {
<span class="p_del">-			printk(KERN_ERR &quot;BIOS bug, IO-APIC#%d ID %d is already used!...\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;BIOS bug, IO-APIC#%d ID %d is already used!...\n&quot;,</span>
 				ioapic_idx, mpc_ioapic_id(ioapic_idx));
 			for (i = 0; i &lt; get_physical_broadcast(); i++)
 				if (!physid_isset(i, phys_id_present_map))
 					break;
 			if (i &gt;= get_physical_broadcast())
 				panic(&quot;Max APIC ID exceeded!\n&quot;);
<span class="p_del">-			printk(KERN_ERR &quot;... fixing up to %d. (tell your hw vendor)\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;... fixing up to %d. (tell your hw vendor)\n&quot;,</span>
 				i);
 			physid_set(i, phys_id_present_map);
 			ioapics[ioapic_idx].mp_config.apicid = i;
<span class="p_chunk">@@ -2369,8 +2370,8 @@</span> <span class="p_context"> static int io_apic_get_unique_id(int ioapic, int apic_id)</span>
 	raw_spin_unlock_irqrestore(&amp;ioapic_lock, flags);
 
 	if (apic_id &gt;= get_physical_broadcast()) {
<span class="p_del">-		printk(KERN_WARNING &quot;IOAPIC[%d]: Invalid apic_id %d, trying &quot;</span>
<span class="p_del">-			&quot;%d\n&quot;, ioapic, apic_id, reg_00.bits.ID);</span>
<span class="p_add">+		pr_warn(&quot;IOAPIC[%d]: Invalid apic_id %d, trying %d\n&quot;,</span>
<span class="p_add">+			ioapic, apic_id, reg_00.bits.ID);</span>
 		apic_id = reg_00.bits.ID;
 	}
 
<span class="p_chunk">@@ -2388,8 +2389,8 @@</span> <span class="p_context"> static int io_apic_get_unique_id(int ioapic, int apic_id)</span>
 		if (i == get_physical_broadcast())
 			panic(&quot;Max apic_id exceeded!\n&quot;);
 
<span class="p_del">-		printk(KERN_WARNING &quot;IOAPIC[%d]: apic_id %d already used, &quot;</span>
<span class="p_del">-			&quot;trying %d\n&quot;, ioapic, apic_id, i);</span>
<span class="p_add">+		pr_warn(&quot;IOAPIC[%d]: apic_id %d already used, trying %d\n&quot;,</span>
<span class="p_add">+			ioapic, apic_id, i);</span>
 
 		apic_id = i;
 	}
<span class="p_chunk">@@ -2609,8 +2610,7 @@</span> <span class="p_context"> void __init io_apic_init_mappings(void)</span>
 			ioapic_phys = mpc_ioapic_addr(i);
 #ifdef CONFIG_X86_32
 			if (!ioapic_phys) {
<span class="p_del">-				printk(KERN_ERR</span>
<span class="p_del">-				       &quot;WARNING: bogus zero IO-APIC &quot;</span>
<span class="p_add">+				pr_err(&quot;WARNING: bogus zero IO-APIC &quot;</span>
 				       &quot;address found in MPTABLE, &quot;
 				       &quot;disabling IO/APIC support!\n&quot;);
 				smp_found_config = 0;
<span class="p_chunk">@@ -2644,8 +2644,7 @@</span> <span class="p_context"> void __init ioapic_insert_resources(void)</span>
 
 	if (!r) {
 		if (nr_ioapics &gt; 0)
<span class="p_del">-			printk(KERN_ERR</span>
<span class="p_del">-				&quot;IO APIC resources couldn&#39;t be allocated.\n&quot;);</span>
<span class="p_add">+			pr_err(&quot;IO APIC resources couldn&#39;t be allocated.\n&quot;);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -2669,7 +2668,7 @@</span> <span class="p_context"> int mp_find_ioapic(u32 gsi)</span>
 			return i;
 	}
 
<span class="p_del">-	printk(KERN_ERR &quot;ERROR: Unable to locate IOAPIC for GSI %d\n&quot;, gsi);</span>
<span class="p_add">+	pr_err(&quot;ERROR: Unable to locate IOAPIC for GSI %d\n&quot;, gsi);</span>
 	return -1;
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/apic/probe_32.c b/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_header">index f316e34..fd2a3dc 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_chunk">@@ -60,8 +60,7 @@</span> <span class="p_context"> static int default_x86_32_early_logical_apicid(int cpu)</span>
 static void setup_apic_flat_routing(void)
 {
 #ifdef CONFIG_X86_IO_APIC
<span class="p_del">-	printk(KERN_INFO</span>
<span class="p_del">-		&quot;Enabling APIC mode:  Flat.  Using %d I/O APICs\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Enabling APIC mode:  Flat.  Using %d I/O APICs\n&quot;,</span>
 		nr_ioapics);
 #endif
 }
<span class="p_chunk">@@ -202,7 +201,7 @@</span> <span class="p_context"> void __init generic_apic_probe(void)</span>
 		if (drv == __apicdrivers_end)
 			panic(&quot;Didn&#39;t find an APIC driver&quot;);
 	}
<span class="p_del">-	printk(KERN_INFO &quot;Using APIC driver %s\n&quot;, apic-&gt;name);</span>
<span class="p_add">+	pr_info(&quot;Using APIC driver %s\n&quot;, apic-&gt;name);</span>
 }
 
 /* This function can switch the APIC even after the initial -&gt;probe() */
<span class="p_chunk">@@ -218,8 +217,8 @@</span> <span class="p_context"> int __init default_acpi_madt_oem_check(char *oem_id, char *oem_table_id)</span>
 
 		if (!cmdline_apic) {
 			apic = *drv;
<span class="p_del">-			printk(KERN_INFO &quot;Switched to APIC driver `%s&#39;.\n&quot;,</span>
<span class="p_del">-			       apic-&gt;name);</span>
<span class="p_add">+			pr_info(&quot;Switched to APIC driver `%s&#39;.\n&quot;,</span>
<span class="p_add">+				apic-&gt;name);</span>
 		}
 		return 1;
 	}
<span class="p_header">diff --git a/arch/x86/kernel/apic/x2apic_phys.c b/arch/x86/kernel/apic/x2apic_phys.c</span>
<span class="p_header">index a1242e2..e7b2d58 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/x2apic_phys.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/x2apic_phys.c</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"> static bool x2apic_fadt_phys(void)</span>
 #ifdef CONFIG_ACPI
 	if ((acpi_gbl_FADT.header.revision &gt;= FADT2_REVISION_ID) &amp;&amp;
 		(acpi_gbl_FADT.flags &amp; ACPI_FADT_APIC_PHYSICAL)) {
<span class="p_del">-		printk(KERN_DEBUG &quot;System requires x2apic physical mode\n&quot;);</span>
<span class="p_add">+		pr_debug(&quot;System requires x2apic physical mode\n&quot;);</span>
 		return true;
 	}
 #endif
<span class="p_header">diff --git a/arch/x86/kernel/apic/x2apic_uv_x.c b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">index 624db005..81a856d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_chunk">@@ -725,8 +725,7 @@</span> <span class="p_context"> static __init void uv_rtc_init(void)</span>
 	status = uv_bios_freq_base(BIOS_FREQ_BASE_REALTIME_CLOCK,
 					&amp;ticks_per_sec);
 	if (status != BIOS_STATUS_SUCCESS || ticks_per_sec &lt; 100000) {
<span class="p_del">-		printk(KERN_WARNING</span>
<span class="p_del">-			&quot;unable to determine platform RTC clock frequency, &quot;</span>
<span class="p_add">+		pr_warn(&quot;unable to determine platform RTC clock frequency, &quot;</span>
 			&quot;guessing.\n&quot;);
 		/* BIOS gives wrong value for clock freq. so guess */
 		sn_rtc_cycles_per_second = 1000000000000UL / 30000UL;
<span class="p_header">diff --git a/arch/x86/kernel/apm_32.c b/arch/x86/kernel/apm_32.c</span>
<span class="p_header">index 052c9c3..f7b02af 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apm_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apm_32.c</span>
<span class="p_chunk">@@ -857,7 +857,7 @@</span> <span class="p_context"> static int apm_do_idle(void)</span>
 		 * Only report the failure the first 5 times.
 		 */
 		if (++t &lt; 5) {
<span class="p_del">-			printk(KERN_DEBUG &quot;apm_do_idle failed (%d)\n&quot;, err);</span>
<span class="p_add">+			pr_debug(&quot;apm_do_idle failed (%d)\n&quot;, err);</span>
 			t = jiffies;
 		}
 		return -1;
<span class="p_chunk">@@ -1326,11 +1326,11 @@</span> <span class="p_context"> static void check_events(void)</span>
 	while ((event = get_event()) != 0) {
 		if (debug) {
 			if (event &lt;= NR_APM_EVENT_NAME)
<span class="p_del">-				printk(KERN_DEBUG &quot;apm: received %s notify\n&quot;,</span>
<span class="p_del">-				       apm_event_name[event - 1]);</span>
<span class="p_add">+				pr_debug(&quot;apm: received %s notify\n&quot;,</span>
<span class="p_add">+					 apm_event_name[event - 1]);</span>
 			else
<span class="p_del">-				printk(KERN_DEBUG &quot;apm: received unknown &quot;</span>
<span class="p_del">-				       &quot;event 0x%02x\n&quot;, event);</span>
<span class="p_add">+				pr_debug(&quot;apm: received unknown event 0x%02x\n&quot;,</span>
<span class="p_add">+					 event);</span>
 		}
 		if (ignore_bounce
 		    &amp;&amp; (time_after(jiffies, last_resume + bounce_interval)))
<span class="p_chunk">@@ -1416,7 +1416,7 @@</span> <span class="p_context"> static void apm_event_handler(void)</span>
 		    (pending_count-- &lt;= 0)) {
 			pending_count = 4;
 			if (debug)
<span class="p_del">-				printk(KERN_DEBUG &quot;apm: setting state busy\n&quot;);</span>
<span class="p_add">+				pr_debug(&quot;apm: setting state busy\n&quot;);</span>
 			err = set_system_power_state(APM_STATE_BUSY);
 			if (err)
 				apm_error(&quot;busy&quot;, err);
<span class="p_chunk">@@ -1760,7 +1760,7 @@</span> <span class="p_context"> static int apm(void *unused)</span>
 	}
 
 	if (debug)
<span class="p_del">-		printk(KERN_INFO &quot;apm: Connection version %d.%d\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;apm: Connection version %d.%d\n&quot;,</span>
 			(apm_info.connection_version &gt;&gt; 8) &amp; 0xff,
 			apm_info.connection_version &amp; 0xff);
 
<span class="p_chunk">@@ -1791,7 +1791,7 @@</span> <span class="p_context"> static int apm(void *unused)</span>
 	if (debug &amp;&amp; (num_online_cpus() == 1 || smp)) {
 		error = apm_get_power_status(&amp;bx, &amp;cx, &amp;dx);
 		if (error)
<span class="p_del">-			printk(KERN_INFO &quot;apm: power status not available\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;apm: power status not available\n&quot;);</span>
 		else {
 			switch ((bx &gt;&gt; 8) &amp; 0xff) {
 			case 0:
<span class="p_chunk">@@ -1824,17 +1824,15 @@</span> <span class="p_context"> static int apm(void *unused)</span>
 				bat_stat = &quot;unknown&quot;;
 				break;
 			}
<span class="p_del">-			printk(KERN_INFO</span>
<span class="p_del">-			       &quot;apm: AC %s, battery status %s, battery life &quot;,</span>
<span class="p_del">-			       power_stat, bat_stat);</span>
<span class="p_add">+			pr_info(&quot;apm: AC %s, battery status %s, battery life &quot;,</span>
<span class="p_add">+				power_stat, bat_stat);</span>
 			if ((cx &amp; 0xff) == 0xff)
 				printk(&quot;unknown\n&quot;);
 			else
 				printk(&quot;%d%%\n&quot;, cx &amp; 0xff);
 			if (apm_info.connection_version &gt; 0x100) {
<span class="p_del">-				printk(KERN_INFO</span>
<span class="p_del">-				       &quot;apm: battery flag 0x%02x, battery life &quot;,</span>
<span class="p_del">-				       (cx &gt;&gt; 8) &amp; 0xff);</span>
<span class="p_add">+				pr_info(&quot;apm: battery flag 0x%02x, battery life &quot;,</span>
<span class="p_add">+					(cx &gt;&gt; 8) &amp; 0xff);</span>
 				if (dx == 0xffff)
 					printk(&quot;unknown\n&quot;);
 				else
<span class="p_chunk">@@ -1943,8 +1941,8 @@</span> <span class="p_context"> static int __init print_if_true(const struct dmi_system_id *d)</span>
  */
 static int __init broken_ps2_resume(const struct dmi_system_id *d)
 {
<span class="p_del">-	printk(KERN_INFO &quot;%s machine detected. Mousepad Resume Bug &quot;</span>
<span class="p_del">-	       &quot;workaround hopefully not needed.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+	pr_info(&quot;%s machine detected. Mousepad Resume Bug &quot;</span>
<span class="p_add">+		&quot;workaround hopefully not needed.\n&quot;, d-&gt;ident);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1953,8 +1951,8 @@</span> <span class="p_context"> static int __init set_realmode_power_off(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.realmode_power_off == 0) {
 		apm_info.realmode_power_off = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s bios detected. &quot;</span>
<span class="p_del">-		       &quot;Using realmode poweroff only.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;%s bios detected. &quot;</span>
<span class="p_add">+			&quot;Using realmode poweroff only.\n&quot;, d-&gt;ident);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1964,8 +1962,8 @@</span> <span class="p_context"> static int __init set_apm_ints(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.allow_ints == 0) {
 		apm_info.allow_ints = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s machine detected. &quot;</span>
<span class="p_del">-		       &quot;Enabling interrupts during APM calls.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;%s machine detected. &quot;</span>
<span class="p_add">+			&quot;Enabling interrupts during APM calls.\n&quot;, d-&gt;ident);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1975,8 +1973,8 @@</span> <span class="p_context"> static int __init apm_is_horked(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.disabled == 0) {
 		apm_info.disabled = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s machine detected. &quot;</span>
<span class="p_del">-		       &quot;Disabling APM.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;%s machine detected. &quot;</span>
<span class="p_add">+			&quot;Disabling APM.\n&quot;, d-&gt;ident);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1985,10 +1983,10 @@</span> <span class="p_context"> static int __init apm_is_horked_d850md(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.disabled == 0) {
 		apm_info.disabled = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s machine detected. &quot;</span>
<span class="p_del">-		       &quot;Disabling APM.\n&quot;, d-&gt;ident);</span>
<span class="p_del">-		printk(KERN_INFO &quot;This bug is fixed in bios P15 which is available for\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;download from support.intel.com\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;%s machine detected. &quot;</span>
<span class="p_add">+			&quot;Disabling APM.\n&quot;, d-&gt;ident);</span>
<span class="p_add">+		pr_info(&quot;This bug is fixed in bios P15 which is available for\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;download from support.intel.com\n&quot;);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1998,7 +1996,7 @@</span> <span class="p_context"> static int __init apm_likes_to_melt(const struct dmi_system_id *d)</span>
 {
 	if (apm_info.forbid_idle == 0) {
 		apm_info.forbid_idle = 1;
<span class="p_del">-		printk(KERN_INFO &quot;%s machine detected. &quot;</span>
<span class="p_add">+		pr_info(&quot;%s machine detected. &quot;</span>
 		       &quot;Disabling APM idle calls.\n&quot;, d-&gt;ident);
 	}
 	return 0;
<span class="p_chunk">@@ -2022,7 +2020,7 @@</span> <span class="p_context"> static int __init apm_likes_to_melt(const struct dmi_system_id *d)</span>
 static int __init broken_apm_power(const struct dmi_system_id *d)
 {
 	apm_info.get_power_status_broken = 1;
<span class="p_del">-	printk(KERN_WARNING &quot;BIOS strings suggest APM bugs, &quot;</span>
<span class="p_add">+	pr_warn(&quot;BIOS strings suggest APM bugs, &quot;</span>
 	       &quot;disabling power status reporting.\n&quot;);
 	return 0;
 }
<span class="p_chunk">@@ -2034,7 +2032,7 @@</span> <span class="p_context"> static int __init broken_apm_power(const struct dmi_system_id *d)</span>
 static int __init swab_apm_power_in_minutes(const struct dmi_system_id *d)
 {
 	apm_info.get_power_status_swabinminutes = 1;
<span class="p_del">-	printk(KERN_WARNING &quot;BIOS strings suggest APM reports battery life &quot;</span>
<span class="p_add">+	pr_warn(&quot;BIOS strings suggest APM reports battery life &quot;</span>
 	       &quot;in minutes and wrong byte order.\n&quot;);
 	return 0;
 }
<span class="p_chunk">@@ -2268,17 +2266,16 @@</span> <span class="p_context"> static int __init apm_init(void)</span>
 	dmi_check_system(apm_dmi_table);
 
 	if (apm_info.bios.version == 0 || paravirt_enabled() || machine_is_olpc()) {
<span class="p_del">-		printk(KERN_INFO &quot;apm: BIOS not found.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;apm: BIOS not found.\n&quot;);</span>
 		return -ENODEV;
 	}
<span class="p_del">-	printk(KERN_INFO</span>
<span class="p_del">-	       &quot;apm: BIOS version %d.%d Flags 0x%02x (Driver version %s)\n&quot;,</span>
<span class="p_del">-	       ((apm_info.bios.version &gt;&gt; 8) &amp; 0xff),</span>
<span class="p_del">-	       (apm_info.bios.version &amp; 0xff),</span>
<span class="p_del">-	       apm_info.bios.flags,</span>
<span class="p_del">-	       driver_version);</span>
<span class="p_add">+	pr_info(&quot;apm: BIOS version %d.%d Flags 0x%02x (Driver version %s)\n&quot;,</span>
<span class="p_add">+		((apm_info.bios.version &gt;&gt; 8) &amp; 0xff),</span>
<span class="p_add">+		(apm_info.bios.version &amp; 0xff),</span>
<span class="p_add">+		apm_info.bios.flags,</span>
<span class="p_add">+		driver_version);</span>
 	if ((apm_info.bios.flags &amp; APM_32_BIT_SUPPORT) == 0) {
<span class="p_del">-		printk(KERN_INFO &quot;apm: no 32 bit BIOS support\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;apm: no 32 bit BIOS support\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_chunk">@@ -2304,7 +2301,7 @@</span> <span class="p_context"> static int __init apm_init(void)</span>
 		apm_info.bios.cseg_16_len = 0; /* 64k */
 
 	if (debug) {
<span class="p_del">-		printk(KERN_INFO &quot;apm: entry %x:%x cseg16 %x dseg %x&quot;,</span>
<span class="p_add">+		pr_info(&quot;apm: entry %x:%x cseg16 %x dseg %x&quot;,</span>
 			apm_info.bios.cseg, apm_info.bios.offset,
 			apm_info.bios.cseg_16, apm_info.bios.dseg);
 		if (apm_info.bios.version &gt; 0x100)
<span class="p_chunk">@@ -2369,8 +2366,8 @@</span> <span class="p_context"> static int __init apm_init(void)</span>
 	wake_up_process(kapmd_task);
 
 	if (num_online_cpus() &gt; 1 &amp;&amp; !smp) {
<span class="p_del">-		printk(KERN_NOTICE</span>
<span class="p_del">-		       &quot;apm: disabled - APM is not SMP safe (power off active).\n&quot;);</span>
<span class="p_add">+		pr_notice(&quot;apm: disabled - APM is not SMP &quot;</span>
<span class="p_add">+			  &quot;safe (power off active).\n&quot;);</span>
 		return 0;
 	}
 
<span class="p_chunk">@@ -2380,7 +2377,7 @@</span> <span class="p_context"> static int __init apm_init(void)</span>
 	 * control it.  just log the error
 	 */
 	if (misc_register(&amp;apm_device))
<span class="p_del">-		printk(KERN_WARNING &quot;apm: Could not register misc device.\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;apm: Could not register misc device.\n&quot;);</span>
 
 	if (HZ != 100)
 		idle_period = (idle_period * HZ) / 100;
<span class="p_header">diff --git a/arch/x86/kernel/bootflag.c b/arch/x86/kernel/bootflag.c</span>
<span class="p_header">index 52c8e3c..e16e24e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/bootflag.c</span>
<span class="p_header">+++ b/arch/x86/kernel/bootflag.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> static void __init sbf_write(u8 v)</span>
 		if (!parity(v))
 			v |= SBF_PARITY;
 
<span class="p_del">-		printk(KERN_INFO &quot;Simple Boot Flag at 0x%x set to 0x%x\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;Simple Boot Flag at 0x%x set to 0x%x\n&quot;,</span>
 			sbf_port, v);
 
 		spin_lock_irqsave(&amp;rtc_lock, flags);
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> static int __init sbf_init(void)</span>
 
 	v = sbf_read();
 	if (!sbf_value_valid(v)) {
<span class="p_del">-		printk(KERN_WARNING &quot;Simple Boot Flag value 0x%x read from &quot;</span>
<span class="p_add">+		pr_warn(&quot;Simple Boot Flag value 0x%x read from &quot;</span>
 			&quot;CMOS RAM was invalid\n&quot;, v);
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/check.c b/arch/x86/kernel/check.c</span>
<span class="p_header">index 145863d..3a54dad 100644</span>
<span class="p_header">--- a/arch/x86/kernel/check.c</span>
<span class="p_header">+++ b/arch/x86/kernel/check.c</span>
<span class="p_chunk">@@ -112,7 +112,8 @@</span> <span class="p_context"> void __init setup_bios_corruption_check(void)</span>
 	}
 
 	if (num_scan_areas)
<span class="p_del">-		printk(KERN_INFO &quot;Scanning %d areas for low memory corruption\n&quot;, num_scan_areas);</span>
<span class="p_add">+		pr_info(&quot;Scanning %d areas for low memory corruption\n&quot;,</span>
<span class="p_add">+			num_scan_areas);</span>
 }
 
 
<span class="p_chunk">@@ -131,8 +132,8 @@</span> <span class="p_context"> void check_for_bios_corruption(void)</span>
 		for (; size; addr++, size -= sizeof(unsigned long)) {
 			if (!*addr)
 				continue;
<span class="p_del">-			printk(KERN_ERR &quot;Corrupted low memory at %p (%lx phys) = %08lx\n&quot;,</span>
<span class="p_del">-			       addr, __pa(addr), *addr);</span>
<span class="p_add">+			pr_err(&quot;Corrupted low memory at %p (%lx phys) = %08lx\n&quot;,</span>
<span class="p_add">+				addr, __pa(addr), *addr);</span>
 			corruption = 1;
 			*addr = 0;
 		}
<span class="p_chunk">@@ -156,8 +157,8 @@</span> <span class="p_context"> static int start_periodic_check_for_corruption(void)</span>
 	if (!num_scan_areas || !memory_corruption_check || corruption_check_period == 0)
 		return 0;
 
<span class="p_del">-	printk(KERN_INFO &quot;Scanning for low memory corruption every %d seconds\n&quot;,</span>
<span class="p_del">-	       corruption_check_period);</span>
<span class="p_add">+	pr_info(&quot;Scanning for low memory corruption every %d seconds\n&quot;,</span>
<span class="p_add">+		corruption_check_period);</span>
 
 	/* First time we run the checks right away */
 	schedule_delayed_work(&amp;bios_check_work, 0);
<span class="p_header">diff --git a/arch/x86/kernel/cpuid.c b/arch/x86/kernel/cpuid.c</span>
<span class="p_header">index 2836de3..5d0abd0 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpuid.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpuid.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static int __init cpuid_init(void)</span>
 
 	if (__register_chrdev(CPUID_MAJOR, 0, NR_CPUS,
 			      &quot;cpu/cpuid&quot;, &amp;cpuid_fops)) {
<span class="p_del">-		printk(KERN_ERR &quot;cpuid: unable to get major %d for cpuid\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;cpuid: unable to get major %d for cpuid\n&quot;,</span>
 		       CPUID_MAJOR);
 		err = -EBUSY;
 		goto out;
<span class="p_header">diff --git a/arch/x86/kernel/crash_dump_32.c b/arch/x86/kernel/crash_dump_32.c</span>
<span class="p_header">index 11891ca..0deb4c7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/crash_dump_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/crash_dump_32.c</span>
<span class="p_chunk">@@ -65,8 +65,7 @@</span> <span class="p_context"> ssize_t copy_oldmem_page(unsigned long pfn, char *buf,</span>
 		kunmap_atomic(vaddr);
 	} else {
 		if (!kdump_buf_page) {
<span class="p_del">-			printk(KERN_WARNING &quot;Kdump: Kdump buffer page not&quot;</span>
<span class="p_del">-				&quot; allocated\n&quot;);</span>
<span class="p_add">+			pr_warn(&quot;Kdump: Kdump buffer page not allocated\n&quot;);</span>
 			kunmap_atomic(vaddr);
 			return -EFAULT;
 		}
<span class="p_chunk">@@ -85,8 +84,7 @@</span> <span class="p_context"> static int __init kdump_buf_page_init(void)</span>
 
 	kdump_buf_page = kmalloc(PAGE_SIZE, GFP_KERNEL);
 	if (!kdump_buf_page) {
<span class="p_del">-		printk(KERN_WARNING &quot;Kdump: Failed to allocate kdump buffer&quot;</span>
<span class="p_del">-			 &quot; page\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;Kdump: Failed to allocate kdump buffer page\n&quot;);</span>
 		ret = -ENOMEM;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/devicetree.c b/arch/x86/kernel/devicetree.c</span>
<span class="p_header">index 1f4acd6..8468af7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/devicetree.c</span>
<span class="p_header">+++ b/arch/x86/kernel/devicetree.c</span>
<span class="p_chunk">@@ -235,8 +235,8 @@</span> <span class="p_context"> static void __init dtb_add_ioapic(struct device_node *dn)</span>
 
 	ret = of_address_to_resource(dn, 0, &amp;r);
 	if (ret) {
<span class="p_del">-		printk(KERN_ERR &quot;Can&#39;t obtain address from node %s.\n&quot;,</span>
<span class="p_del">-				dn-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;Can&#39;t obtain address from node %s.\n&quot;,</span>
<span class="p_add">+			dn-&gt;full_name);</span>
 		return;
 	}
 	mp_register_ioapic(++ioapic_id, r.start, gsi_top, &amp;cfg);
<span class="p_chunk">@@ -253,7 +253,7 @@</span> <span class="p_context"> static void __init dtb_ioapic_setup(void)</span>
 		of_ioapic = 1;
 		return;
 	}
<span class="p_del">-	printk(KERN_ERR &quot;Error: No information about IO-APIC in OF.\n&quot;);</span>
<span class="p_add">+	pr_err(&quot;Error: No information about IO-APIC in OF.\n&quot;);</span>
 }
 #else
 static void __init dtb_ioapic_setup(void) {}
<span class="p_header">diff --git a/arch/x86/kernel/doublefault.c b/arch/x86/kernel/doublefault.c</span>
<span class="p_header">index f6dfd93..8f7ba71 100644</span>
<span class="p_header">--- a/arch/x86/kernel/doublefault.c</span>
<span class="p_header">+++ b/arch/x86/kernel/doublefault.c</span>
<span class="p_chunk">@@ -24,23 +24,23 @@</span> <span class="p_context"> static void doublefault_fn(void)</span>
 	native_store_gdt(&amp;gdt_desc);
 	gdt = gdt_desc.address;
 
<span class="p_del">-	printk(KERN_EMERG &quot;PANIC: double fault, gdt at %08lx [%d bytes]\n&quot;, gdt, gdt_desc.size);</span>
<span class="p_add">+	pr_emerg(&quot;PANIC: double fault, gdt at %08lx [%d bytes]\n&quot;, gdt, gdt_desc.size);</span>
 
 	if (ptr_ok(gdt)) {
 		gdt += GDT_ENTRY_TSS &lt;&lt; 3;
 		tss = get_desc_base((struct desc_struct *)gdt);
<span class="p_del">-		printk(KERN_EMERG &quot;double fault, tss at %08lx\n&quot;, tss);</span>
<span class="p_add">+		pr_emerg(&quot;double fault, tss at %08lx\n&quot;, tss);</span>
 
 		if (ptr_ok(tss)) {
 			struct x86_hw_tss *t = (struct x86_hw_tss *)tss;
 
<span class="p_del">-			printk(KERN_EMERG &quot;eip = %08lx, esp = %08lx\n&quot;,</span>
<span class="p_del">-			       t-&gt;ip, t-&gt;sp);</span>
<span class="p_add">+			pr_emerg(&quot;eip = %08lx, esp = %08lx\n&quot;,</span>
<span class="p_add">+				 t-&gt;ip, t-&gt;sp);</span>
 
<span class="p_del">-			printk(KERN_EMERG &quot;eax = %08lx, ebx = %08lx, ecx = %08lx, edx = %08lx\n&quot;,</span>
<span class="p_del">-				t-&gt;ax, t-&gt;bx, t-&gt;cx, t-&gt;dx);</span>
<span class="p_del">-			printk(KERN_EMERG &quot;esi = %08lx, edi = %08lx\n&quot;,</span>
<span class="p_del">-				t-&gt;si, t-&gt;di);</span>
<span class="p_add">+			pr_emerg(&quot;eax = %08lx, ebx = %08lx, ecx = %08lx, edx = %08lx\n&quot;,</span>
<span class="p_add">+				 t-&gt;ax, t-&gt;bx, t-&gt;cx, t-&gt;dx);</span>
<span class="p_add">+			pr_emerg(&quot;esi = %08lx, edi = %08lx\n&quot;,</span>
<span class="p_add">+				 t-&gt;si, t-&gt;di);</span>
 		}
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c</span>
<span class="p_header">index 32e5699..993706a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/dumpstack.c</span>
<span class="p_header">+++ b/arch/x86/kernel/dumpstack.c</span>
<span class="p_chunk">@@ -285,12 +285,12 @@</span> <span class="p_context"> int __die(const char *str, struct pt_regs *regs, long err)</span>
 		sp = kernel_stack_pointer(regs);
 		savesegment(ss, ss);
 	}
<span class="p_del">-	printk(KERN_EMERG &quot;EIP: [&lt;%08lx&gt;] &quot;, regs-&gt;ip);</span>
<span class="p_add">+	pr_emerg(&quot;EIP: [&lt;%08lx&gt;] &quot;, regs-&gt;ip);</span>
 	print_symbol(&quot;%s&quot;, regs-&gt;ip);
 	printk(&quot; SS:ESP %04x:%08lx\n&quot;, ss, sp);
 #else
 	/* Executive summary in case the oops scrolled away */
<span class="p_del">-	printk(KERN_ALERT &quot;RIP &quot;);</span>
<span class="p_add">+	pr_alert(&quot;RIP &quot;);</span>
 	printk_address(regs-&gt;ip);
 	printk(&quot; RSP &lt;%016lx&gt;\n&quot;, regs-&gt;sp);
 #endif
<span class="p_header">diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c</span>
<span class="p_header">index 621b501..3cec9c2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/e820.c</span>
<span class="p_header">+++ b/arch/x86/kernel/e820.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> static void __init __e820_add_region(struct e820map *e820x, u64 start, u64 size,</span>
 	int x = e820x-&gt;nr_map;
 
 	if (x &gt;= ARRAY_SIZE(e820x-&gt;map)) {
<span class="p_del">-		printk(KERN_ERR &quot;e820: too many entries; ignoring [mem %#010llx-%#010llx]\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;e820: too many entries; ignoring [mem %#010llx-%#010llx]\n&quot;,</span>
 		       (unsigned long long) start,
 		       (unsigned long long) (start + size - 1));
 		return;
<span class="p_chunk">@@ -136,26 +136,26 @@</span> <span class="p_context"> static void __init e820_print_type(u32 type)</span>
 	switch (type) {
 	case E820_RAM:
 	case E820_RESERVED_KERN:
<span class="p_del">-		printk(KERN_CONT &quot;usable&quot;);</span>
<span class="p_add">+		pr_cont(&quot;usable&quot;);</span>
 		break;
 	case E820_RESERVED:
<span class="p_del">-		printk(KERN_CONT &quot;reserved&quot;);</span>
<span class="p_add">+		pr_cont(&quot;reserved&quot;);</span>
 		break;
 	case E820_ACPI:
<span class="p_del">-		printk(KERN_CONT &quot;ACPI data&quot;);</span>
<span class="p_add">+		pr_cont(&quot;ACPI data&quot;);</span>
 		break;
 	case E820_NVS:
<span class="p_del">-		printk(KERN_CONT &quot;ACPI NVS&quot;);</span>
<span class="p_add">+		pr_cont(&quot;ACPI NVS&quot;);</span>
 		break;
 	case E820_UNUSABLE:
<span class="p_del">-		printk(KERN_CONT &quot;unusable&quot;);</span>
<span class="p_add">+		pr_cont(&quot;unusable&quot;);</span>
 		break;
 	case E820_PMEM:
 	case E820_PRAM:
<span class="p_del">-		printk(KERN_CONT &quot;persistent (type %u)&quot;, type);</span>
<span class="p_add">+		pr_cont(&quot;persistent (type %u)&quot;, type);</span>
 		break;
 	default:
<span class="p_del">-		printk(KERN_CONT &quot;type %u&quot;, type);</span>
<span class="p_add">+		pr_cont(&quot;type %u&quot;, type);</span>
 		break;
 	}
 }
<span class="p_chunk">@@ -165,12 +165,12 @@</span> <span class="p_context"> void __init e820_print_map(char *who)</span>
 	int i;
 
 	for (i = 0; i &lt; e820.nr_map; i++) {
<span class="p_del">-		printk(KERN_INFO &quot;%s: [mem %#018Lx-%#018Lx] &quot;, who,</span>
<span class="p_add">+		pr_info(&quot;%s: [mem %#018Lx-%#018Lx] &quot;, who,</span>
 		       (unsigned long long) e820.map[i].addr,
 		       (unsigned long long)
 		       (e820.map[i].addr + e820.map[i].size - 1));
 		e820_print_type(e820.map[i].type);
<span class="p_del">-		printk(KERN_CONT &quot;\n&quot;);</span>
<span class="p_add">+		pr_cont(&quot;\n&quot;);</span>
 	}
 }
 
<span class="p_chunk">@@ -435,12 +435,12 @@</span> <span class="p_context"> static u64 __init __e820_update_range(struct e820map *e820x, u64 start,</span>
 		size = ULLONG_MAX - start;
 
 	end = start + size;
<span class="p_del">-	printk(KERN_DEBUG &quot;e820: update [mem %#010Lx-%#010Lx] &quot;,</span>
<span class="p_del">-	       (unsigned long long) start, (unsigned long long) (end - 1));</span>
<span class="p_add">+	pr_debug(&quot;e820: update [mem %#010Lx-%#010Lx] &quot;,</span>
<span class="p_add">+		 (unsigned long long) start, (unsigned long long) (end - 1));</span>
 	e820_print_type(old_type);
<span class="p_del">-	printk(KERN_CONT &quot; ==&gt; &quot;);</span>
<span class="p_add">+	pr_cont(&quot; ==&gt; &quot;);</span>
 	e820_print_type(new_type);
<span class="p_del">-	printk(KERN_CONT &quot;\n&quot;);</span>
<span class="p_add">+	pr_cont(&quot;\n&quot;);</span>
 
 	for (i = 0; i &lt; e820x-&gt;nr_map; i++) {
 		struct e820entry *ei = &amp;e820x-&gt;map[i];
<span class="p_chunk">@@ -515,11 +515,11 @@</span> <span class="p_context"> u64 __init e820_remove_range(u64 start, u64 size, unsigned old_type,</span>
 		size = ULLONG_MAX - start;
 
 	end = start + size;
<span class="p_del">-	printk(KERN_DEBUG &quot;e820: remove [mem %#010Lx-%#010Lx] &quot;,</span>
<span class="p_del">-	       (unsigned long long) start, (unsigned long long) (end - 1));</span>
<span class="p_add">+	pr_debug(&quot;e820: remove [mem %#010Lx-%#010Lx] &quot;,</span>
<span class="p_add">+		 (unsigned long long) start, (unsigned long long) (end - 1));</span>
 	if (checktype)
 		e820_print_type(old_type);
<span class="p_del">-	printk(KERN_CONT &quot;\n&quot;);</span>
<span class="p_add">+	pr_cont(&quot;\n&quot;);</span>
 
 	for (i = 0; i &lt; e820.nr_map; i++) {
 		struct e820entry *ei = &amp;e820.map[i];
<span class="p_chunk">@@ -568,7 +568,7 @@</span> <span class="p_context"> void __init update_e820(void)</span>
 {
 	if (sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &amp;e820.nr_map))
 		return;
<span class="p_del">-	printk(KERN_INFO &quot;e820: modified physical RAM map:\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;e820: modified physical RAM map:\n&quot;);</span>
 	e820_print_map(&quot;modified&quot;);
 }
 static void __init update_e820_saved(void)
<span class="p_chunk">@@ -633,9 +633,9 @@</span> <span class="p_context"> __init void e820_setup_gap(void)</span>
 #ifdef CONFIG_X86_64
 	if (!found) {
 		gapstart = (max_pfn &lt;&lt; PAGE_SHIFT) + 1024*1024;
<span class="p_del">-		printk(KERN_ERR</span>
<span class="p_del">-	&quot;e820: cannot find a gap in the 32bit address range\n&quot;</span>
<span class="p_del">-	&quot;e820: PCI devices with unassigned 32bit BARs may break!\n&quot;);</span>
<span class="p_add">+		pr_err(</span>
<span class="p_add">+		  &quot;e820: cannot find a gap in the 32bit address range\n&quot;</span>
<span class="p_add">+		  &quot;e820: PCI devices with unassigned 32bit BARs may break!\n&quot;);</span>
 	}
 #endif
 
<span class="p_chunk">@@ -644,9 +644,8 @@</span> <span class="p_context"> __init void e820_setup_gap(void)</span>
 	 */
 	pci_mem_start = gapstart;
 
<span class="p_del">-	printk(KERN_INFO</span>
<span class="p_del">-	       &quot;e820: [mem %#010lx-%#010lx] available for PCI devices\n&quot;,</span>
<span class="p_del">-	       gapstart, gapstart + gapsize - 1);</span>
<span class="p_add">+	pr_info(&quot;e820: [mem %#010lx-%#010lx] available for PCI devices\n&quot;,</span>
<span class="p_add">+		gapstart, gapstart + gapsize - 1);</span>
 }
 
 /**
<span class="p_chunk">@@ -667,7 +666,7 @@</span> <span class="p_context"> void __init parse_e820_ext(u64 phys_addr, u32 data_len)</span>
 	__append_e820_map(extmap, entries);
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &amp;e820.nr_map);
 	early_memunmap(sdata, data_len);
<span class="p_del">-	printk(KERN_INFO &quot;e820: extended physical RAM map:\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;e820: extended physical RAM map:\n&quot;);</span>
 	e820_print_map(&quot;extended&quot;);
 }
 
<span class="p_chunk">@@ -734,7 +733,7 @@</span> <span class="p_context"> u64 __init early_reserve_e820(u64 size, u64 align)</span>
 	addr = __memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (addr) {
 		e820_update_range_saved(addr, size, E820_RAM, E820_RESERVED);
<span class="p_del">-		printk(KERN_INFO &quot;e820: update e820_saved for early_reserve_e820\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;e820: update e820_saved for early_reserve_e820\n&quot;);</span>
 		update_e820_saved();
 	}
 
<span class="p_chunk">@@ -788,8 +787,8 @@</span> <span class="p_context"> static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
 	if (last_pfn &gt; max_arch_pfn)
 		last_pfn = max_arch_pfn;
 
<span class="p_del">-	printk(KERN_INFO &quot;e820: last_pfn = %#lx max_arch_pfn = %#lx\n&quot;,</span>
<span class="p_del">-			 last_pfn, max_arch_pfn);</span>
<span class="p_add">+	pr_info(&quot;e820: last_pfn = %#lx max_arch_pfn = %#lx\n&quot;,</span>
<span class="p_add">+		last_pfn, max_arch_pfn);</span>
 	return last_pfn;
 }
 unsigned long __init e820_end_of_ram_pfn(void)
<span class="p_chunk">@@ -823,7 +822,7 @@</span> <span class="p_context"> static int __init parse_memopt(char *p)</span>
 		setup_clear_cpu_cap(X86_FEATURE_PSE);
 		return 0;
 #else
<span class="p_del">-		printk(KERN_WARNING &quot;mem=nopentium ignored! (only supported on x86_32)\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;mem=nopentium ignored! (only supported on x86_32)\n&quot;);</span>
 		return -EINVAL;
 #endif
 	}
<span class="p_chunk">@@ -907,7 +906,7 @@</span> <span class="p_context"> void __init finish_e820_parsing(void)</span>
 					&amp;e820.nr_map) &lt; 0)
 			early_panic(&quot;Invalid user supplied memory map&quot;);
 
<span class="p_del">-		printk(KERN_INFO &quot;e820: user-defined physical RAM map:\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;e820: user-defined physical RAM map:\n&quot;);</span>
 		e820_print_map(&quot;user&quot;);
 	}
 }
<span class="p_chunk">@@ -1073,9 +1072,8 @@</span> <span class="p_context"> void __init e820_reserve_resources_late(void)</span>
 			end = MAX_RESOURCE_SIZE;
 		if (start &gt;= end)
 			continue;
<span class="p_del">-		printk(KERN_DEBUG</span>
<span class="p_del">-		       &quot;e820: reserve RAM buffer [mem %#010llx-%#010llx]\n&quot;,</span>
<span class="p_del">-		       start, end);</span>
<span class="p_add">+		pr_debug(&quot;e820: reserve RAM buffer [mem %#010llx-%#010llx]\n&quot;,</span>
<span class="p_add">+			 start, end);</span>
 		reserve_region_with_split(&amp;iomem_resource, start, end,
 					  &quot;RAM buffer&quot;);
 	}
<span class="p_chunk">@@ -1125,7 +1123,7 @@</span> <span class="p_context"> void __init setup_memory_map(void)</span>
 
 	who = x86_init.resources.memory_setup();
 	memcpy(&amp;e820_saved, &amp;e820, sizeof(struct e820map));
<span class="p_del">-	printk(KERN_INFO &quot;e820: BIOS-provided physical RAM map:\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;e820: BIOS-provided physical RAM map:\n&quot;);</span>
 	e820_print_map(who);
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">index bca14c8..0cd99ae 100644</span>
<span class="p_header">--- a/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/early-quirks.c</span>
<span class="p_chunk">@@ -33,13 +33,13 @@</span> <span class="p_context"> static void __init fix_hypertransport_config(int num, int slot, int func)</span>
 	 */
 	htcfg = read_pci_config(num, slot, func, 0x68);
 	if (htcfg &amp; (1 &lt;&lt; 18)) {
<span class="p_del">-		printk(KERN_INFO &quot;Detected use of extended apic ids &quot;</span>
<span class="p_del">-				 &quot;on hypertransport bus\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Detected use of extended apic ids &quot;</span>
<span class="p_add">+			&quot;on hypertransport bus\n&quot;);</span>
 		if ((htcfg &amp; (1 &lt;&lt; 17)) == 0) {
<span class="p_del">-			printk(KERN_INFO &quot;Enabling hypertransport extended &quot;</span>
<span class="p_del">-					 &quot;apic interrupt broadcast\n&quot;);</span>
<span class="p_del">-			printk(KERN_INFO &quot;Note this is a bios bug, &quot;</span>
<span class="p_del">-					 &quot;please contact your hw vendor\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;Enabling hypertransport extended &quot;</span>
<span class="p_add">+				&quot;apic interrupt broadcast\n&quot;);</span>
<span class="p_add">+			pr_info(&quot;Note this is a bios bug, &quot;</span>
<span class="p_add">+				&quot;please contact your hw vendor\n&quot;);</span>
 			htcfg |= (1 &lt;&lt; 17);
 			write_pci_config(num, slot, func, 0x68, htcfg);
 		}
<span class="p_chunk">@@ -53,9 +53,8 @@</span> <span class="p_context"> static void __init via_bugs(int  num, int slot, int func)</span>
 #ifdef CONFIG_GART_IOMMU
 	if ((max_pfn &gt; MAX_DMA32_PFN ||  force_iommu) &amp;&amp;
 	    !gart_iommu_aperture_allowed) {
<span class="p_del">-		printk(KERN_INFO</span>
<span class="p_del">-		       &quot;Looks like a VIA chipset. Disabling IOMMU.&quot;</span>
<span class="p_del">-		       &quot; Override with iommu=allowed\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Looks like a VIA chipset. Disabling IOMMU.&quot;</span>
<span class="p_add">+			&quot; Override with iommu=allowed\n&quot;);</span>
 		gart_iommu_aperture_disabled = 1;
 	}
 #endif
<span class="p_chunk">@@ -87,10 +86,9 @@</span> <span class="p_context"> static void __init nvidia_bugs(int num, int slot, int func)</span>
 
 	if (acpi_table_parse(ACPI_SIG_HPET, nvidia_hpet_check)) {
 		acpi_skip_timer_override = 1;
<span class="p_del">-		printk(KERN_INFO &quot;Nvidia board &quot;</span>
<span class="p_del">-		       &quot;detected. Ignoring ACPI &quot;</span>
<span class="p_del">-		       &quot;timer override.\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;If you got timer trouble &quot;</span>
<span class="p_add">+		pr_info(&quot;Nvidia board detected. Ignoring ACPI &quot;</span>
<span class="p_add">+			&quot;timer override.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;If you got timer trouble &quot;</span>
 			&quot;try acpi_use_timer_override\n&quot;);
 	}
 #endif
<span class="p_chunk">@@ -137,10 +135,10 @@</span> <span class="p_context"> static void __init ati_bugs(int num, int slot, int func)</span>
 	}
 
 	if (acpi_skip_timer_override) {
<span class="p_del">-		printk(KERN_INFO &quot;SB4X0 revision 0x%x\n&quot;, d);</span>
<span class="p_del">-		printk(KERN_INFO &quot;Ignoring ACPI timer override.\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;If you got timer trouble &quot;</span>
<span class="p_del">-		       &quot;try acpi_use_timer_override\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;SB4X0 revision 0x%x\n&quot;, d);</span>
<span class="p_add">+		pr_info(&quot;Ignoring ACPI timer override.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;If you got timer trouble &quot;</span>
<span class="p_add">+			&quot;try acpi_use_timer_override\n&quot;);</span>
 	}
 }
 
<span class="p_chunk">@@ -179,10 +177,10 @@</span> <span class="p_context"> static void __init ati_bugs_contd(int num, int slot, int func)</span>
 		acpi_skip_timer_override = 1;
 
 	if (acpi_skip_timer_override) {
<span class="p_del">-		printk(KERN_INFO &quot;SB600 revision 0x%x\n&quot;, rev);</span>
<span class="p_del">-		printk(KERN_INFO &quot;Ignoring ACPI timer override.\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;If you got timer trouble &quot;</span>
<span class="p_del">-		       &quot;try acpi_use_timer_override\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;SB600 revision 0x%x\n&quot;, rev);</span>
<span class="p_add">+		pr_info(&quot;Ignoring ACPI timer override.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;If you got timer trouble &quot;</span>
<span class="p_add">+			&quot;try acpi_use_timer_override\n&quot;);</span>
 	}
 }
 #else
<span class="p_chunk">@@ -569,8 +567,8 @@</span> <span class="p_context"> static void __init intel_graphics_stolen(int num, int slot, int func)</span>
 			size = stolen_funcs-&gt;size(num, slot, func);
 			start = stolen_funcs-&gt;base(num, slot, func, size);
 			if (size &amp;&amp; start) {
<span class="p_del">-				printk(KERN_INFO &quot;Reserving Intel graphics stolen memory at 0x%x-0x%x\n&quot;,</span>
<span class="p_del">-				       start, start + (u32)size - 1);</span>
<span class="p_add">+				pr_info(&quot;Reserving Intel graphics stolen memory at 0x%x-0x%x\n&quot;,</span>
<span class="p_add">+					start, start + (u32)size - 1);</span>
 				/* Mark this space as reserved */
 				e820_add_region(start, size, E820_RESERVED);
 				sanitize_e820_map(e820.map,
<span class="p_header">diff --git a/arch/x86/kernel/early_printk.c b/arch/x86/kernel/early_printk.c</span>
<span class="p_header">index 21bf924..be6dcb0 100644</span>
<span class="p_header">--- a/arch/x86/kernel/early_printk.c</span>
<span class="p_header">+++ b/arch/x86/kernel/early_printk.c</span>
<span class="p_chunk">@@ -319,8 +319,8 @@</span> <span class="p_context"> static struct console early_serial_console = {</span>
 static void early_console_register(struct console *con, int keep_early)
 {
 	if (con-&gt;index != -1) {
<span class="p_del">-		printk(KERN_CRIT &quot;ERROR: earlyprintk= %s already used\n&quot;,</span>
<span class="p_del">-		       con-&gt;name);</span>
<span class="p_add">+		pr_crit(&quot;ERROR: earlyprintk= %s already used\n&quot;,</span>
<span class="p_add">+			con-&gt;name);</span>
 		return;
 	}
 	early_console = con;
<span class="p_header">diff --git a/arch/x86/kernel/fpu/init.c b/arch/x86/kernel/fpu/init.c</span>
<span class="p_header">index 6d9f0a7..66d1b87 100644</span>
<span class="p_header">--- a/arch/x86/kernel/fpu/init.c</span>
<span class="p_header">+++ b/arch/x86/kernel/fpu/init.c</span>
<span class="p_chunk">@@ -339,7 +339,8 @@</span> <span class="p_context"> static void __init fpu__init_system_ctx_switch(void)</span>
 	if (eagerfpu == ENABLE)
 		setup_force_cpu_cap(X86_FEATURE_EAGER_FPU);
 
<span class="p_del">-	printk(KERN_INFO &quot;x86/fpu: Using &#39;%s&#39; FPU context switches.\n&quot;, eagerfpu == ENABLE ? &quot;eager&quot; : &quot;lazy&quot;);</span>
<span class="p_add">+	pr_info(&quot;x86/fpu: Using &#39;%s&#39; FPU context switches.\n&quot;,</span>
<span class="p_add">+		eagerfpu == ENABLE ? &quot;eager&quot; : &quot;lazy&quot;);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c</span>
<span class="p_header">index d425cda5..4fb56f9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/fpu/xstate.c</span>
<span class="p_header">+++ b/arch/x86/kernel/fpu/xstate.c</span>
<span class="p_chunk">@@ -222,7 +222,8 @@</span> <span class="p_context"> static void __init setup_xstate_features(void)</span>
 			&quot;x86/fpu: misordered xstate at %d\n&quot;, last_good_offset);
 		last_good_offset = xstate_offsets[i];
 
<span class="p_del">-		printk(KERN_INFO &quot;x86/fpu: xstate_offset[%d]: %4d, xstate_sizes[%d]: %4d\n&quot;, i, ebx, i, eax);</span>
<span class="p_add">+		pr_info(&quot;x86/fpu: xstate_offset[%d]: %4d, xstate_sizes[%d]: %4d\n&quot;,</span>
<span class="p_add">+			i, ebx, i, eax);</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/hpet.c b/arch/x86/kernel/hpet.c</span>
<span class="p_header">index be0ebbb..49a0b08 100644</span>
<span class="p_header">--- a/arch/x86/kernel/hpet.c</span>
<span class="p_header">+++ b/arch/x86/kernel/hpet.c</span>
<span class="p_chunk">@@ -139,30 +139,30 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(is_hpet_enabled);</span>
 static void _hpet_print_config(const char *function, int line)
 {
 	u32 i, timers, l, h;
<span class="p_del">-	printk(KERN_INFO &quot;hpet: %s(%d):\n&quot;, function, line);</span>
<span class="p_add">+	pr_info(&quot;hpet: %s(%d):\n&quot;, function, line);</span>
 	l = hpet_readl(HPET_ID);
 	h = hpet_readl(HPET_PERIOD);
 	timers = ((l &amp; HPET_ID_NUMBER) &gt;&gt; HPET_ID_NUMBER_SHIFT) + 1;
<span class="p_del">-	printk(KERN_INFO &quot;hpet: ID: 0x%x, PERIOD: 0x%x\n&quot;, l, h);</span>
<span class="p_add">+	pr_info(&quot;hpet: ID: 0x%x, PERIOD: 0x%x\n&quot;, l, h);</span>
 	l = hpet_readl(HPET_CFG);
 	h = hpet_readl(HPET_STATUS);
<span class="p_del">-	printk(KERN_INFO &quot;hpet: CFG: 0x%x, STATUS: 0x%x\n&quot;, l, h);</span>
<span class="p_add">+	pr_info(&quot;hpet: CFG: 0x%x, STATUS: 0x%x\n&quot;, l, h);</span>
 	l = hpet_readl(HPET_COUNTER);
 	h = hpet_readl(HPET_COUNTER+4);
<span class="p_del">-	printk(KERN_INFO &quot;hpet: COUNTER_l: 0x%x, COUNTER_h: 0x%x\n&quot;, l, h);</span>
<span class="p_add">+	pr_info(&quot;hpet: COUNTER_l: 0x%x, COUNTER_h: 0x%x\n&quot;, l, h);</span>
 
 	for (i = 0; i &lt; timers; i++) {
 		l = hpet_readl(HPET_Tn_CFG(i));
 		h = hpet_readl(HPET_Tn_CFG(i)+4);
<span class="p_del">-		printk(KERN_INFO &quot;hpet: T%d: CFG_l: 0x%x, CFG_h: 0x%x\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;hpet: T%d: CFG_l: 0x%x, CFG_h: 0x%x\n&quot;,</span>
 		       i, l, h);
 		l = hpet_readl(HPET_Tn_CMP(i));
 		h = hpet_readl(HPET_Tn_CMP(i)+4);
<span class="p_del">-		printk(KERN_INFO &quot;hpet: T%d: CMP_l: 0x%x, CMP_h: 0x%x\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;hpet: T%d: CMP_l: 0x%x, CMP_h: 0x%x\n&quot;,</span>
 		       i, l, h);
 		l = hpet_readl(HPET_Tn_ROUTE(i));
 		h = hpet_readl(HPET_Tn_ROUTE(i)+4);
<span class="p_del">-		printk(KERN_INFO &quot;hpet: T%d ROUTE_l: 0x%x, ROUTE_h: 0x%x\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;hpet: T%d ROUTE_l: 0x%x, ROUTE_h: 0x%x\n&quot;,</span>
 		       i, l, h);
 	}
 }
<span class="p_chunk">@@ -289,7 +289,7 @@</span> <span class="p_context"> static void hpet_legacy_clockevent_register(void)</span>
 	clockevents_config_and_register(&amp;hpet_clockevent, hpet_freq,
 					HPET_MIN_PROG_DELTA, 0x7FFFFFFF);
 	global_clock_event = &amp;hpet_clockevent;
<span class="p_del">-	printk(KERN_DEBUG &quot;hpet clockevent registered\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;hpet clockevent registered\n&quot;);</span>
 }
 
 static int hpet_set_periodic(struct clock_event_device *evt, int timer)
<span class="p_chunk">@@ -526,7 +526,7 @@</span> <span class="p_context"> static irqreturn_t hpet_interrupt_handler(int irq, void *data)</span>
 	struct clock_event_device *hevt = &amp;dev-&gt;evt;
 
 	if (!hevt-&gt;event_handler) {
<span class="p_del">-		printk(KERN_INFO &quot;Spurious HPET timer interrupt on HPET timer %d\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;Spurious HPET timer interrupt on HPET timer %d\n&quot;,</span>
 				dev-&gt;num);
 		return IRQ_HANDLED;
 	}
<span class="p_chunk">@@ -547,7 +547,7 @@</span> <span class="p_context"> static int hpet_setup_irq(struct hpet_dev *dev)</span>
 	irq_set_affinity(dev-&gt;irq, cpumask_of(dev-&gt;cpu));
 	enable_irq(dev-&gt;irq);
 
<span class="p_del">-	printk(KERN_DEBUG &quot;hpet: %s irq %d for MSI\n&quot;,</span>
<span class="p_add">+	pr_debug(&quot;hpet: %s irq %d for MSI\n&quot;,</span>
 			 dev-&gt;name, dev-&gt;irq);
 
 	return 0;
<span class="p_chunk">@@ -646,7 +646,7 @@</span> <span class="p_context"> static void hpet_msi_capability_lookup(unsigned int start_timer)</span>
 			break;
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;HPET: %d timers in total, %d timers will be used for per-cpu timer\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;HPET: %d timers in total, %d timers will be used for per-cpu timer\n&quot;,</span>
 		num_timers, num_timers_used);
 }
 
<span class="p_chunk">@@ -800,8 +800,7 @@</span> <span class="p_context"> static int hpet_clocksource_register(void)</span>
 	} while ((now - start) &lt; 200000UL);
 
 	if (t1 == hpet_readl(HPET_COUNTER)) {
<span class="p_del">-		printk(KERN_WARNING</span>
<span class="p_del">-		       &quot;HPET counter not counting. HPET disabled\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;HPET counter not counting. HPET disabled\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_chunk">@@ -845,9 +844,8 @@</span> <span class="p_context"> int __init hpet_enable(void)</span>
 	 */
 	for (i = 0; hpet_readl(HPET_CFG) == 0xFFFFFFFF; i++) {
 		if (i == 1000) {
<span class="p_del">-			printk(KERN_WARNING</span>
<span class="p_del">-			       &quot;HPET config register value = 0xFFFFFFFF. &quot;</span>
<span class="p_del">-			       &quot;Disabling HPET\n&quot;);</span>
<span class="p_add">+			pr_warn(&quot;HPET config register value = 0xFFFFFFFF. &quot;</span>
<span class="p_add">+				&quot;Disabling HPET\n&quot;);</span>
 			goto out_nohpet;
 		}
 	}
<span class="p_chunk">@@ -1231,7 +1229,7 @@</span> <span class="p_context"> static void hpet_rtc_timer_reinit(void)</span>
 		if (hpet_rtc_flags &amp; RTC_PIE)
 			hpet_pie_count += lost_ints;
 		if (printk_ratelimit())
<span class="p_del">-			printk(KERN_WARNING &quot;hpet1: lost %d rtc interrupts\n&quot;,</span>
<span class="p_add">+			pr_warn(&quot;hpet1: lost %d rtc interrupts\n&quot;,</span>
 				lost_ints);
 	}
 }
<span class="p_header">diff --git a/arch/x86/kernel/i8259.c b/arch/x86/kernel/i8259.c</span>
<span class="p_header">index be22f5a..c069219 100644</span>
<span class="p_header">--- a/arch/x86/kernel/i8259.c</span>
<span class="p_header">+++ b/arch/x86/kernel/i8259.c</span>
<span class="p_chunk">@@ -204,8 +204,7 @@</span> <span class="p_context"> spurious_8259A_irq:</span>
 		 * lets ACK and report it. [once per IRQ]
 		 */
 		if (!(spurious_irq_mask &amp; irqmask)) {
<span class="p_del">-			printk(KERN_DEBUG</span>
<span class="p_del">-			       &quot;spurious 8259A interrupt: IRQ%d.\n&quot;, irq);</span>
<span class="p_add">+			pr_debug(&quot;spurious 8259A interrupt: IRQ%d.\n&quot;, irq);</span>
 			spurious_irq_mask |= irqmask;
 		}
 		atomic_inc(&amp;irq_err_count);
<span class="p_chunk">@@ -313,7 +312,7 @@</span> <span class="p_context"> static int probe_8259A(void)</span>
 	outb(probe_val, PIC_MASTER_IMR);
 	new_val = inb(PIC_MASTER_IMR);
 	if (new_val != probe_val) {
<span class="p_del">-		printk(KERN_INFO &quot;Using NULL legacy PIC\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Using NULL legacy PIC\n&quot;);</span>
 		legacy_pic = &amp;null_legacy_pic;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/irq_32.c b/arch/x86/kernel/irq_32.c</span>
<span class="p_header">index 38da8f2..3b3b230 100644</span>
<span class="p_header">--- a/arch/x86/kernel/irq_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/irq_32.c</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> static int check_stack_overflow(void)</span>
 
 static void print_stack_overflow(void)
 {
<span class="p_del">-	printk(KERN_WARNING &quot;low stack detected by irq handler\n&quot;);</span>
<span class="p_add">+	pr_warn(&quot;low stack detected by irq handler\n&quot;);</span>
 	dump_stack();
 	if (sysctl_panic_on_stackoverflow)
 		panic(&quot;low stack detected by irq handler - check messages\n&quot;);
<span class="p_chunk">@@ -124,8 +124,8 @@</span> <span class="p_context"> void irq_ctx_init(int cpu)</span>
 					       THREAD_SIZE_ORDER));
 	per_cpu(softirq_stack, cpu) = irqstk;
 
<span class="p_del">-	printk(KERN_DEBUG &quot;CPU %u irqstacks, hard=%p soft=%p\n&quot;,</span>
<span class="p_del">-	       cpu, per_cpu(hardirq_stack, cpu),  per_cpu(softirq_stack, cpu));</span>
<span class="p_add">+	pr_debug(&quot;CPU %u irqstacks, hard=%p soft=%p\n&quot;,</span>
<span class="p_add">+		 cpu, per_cpu(hardirq_stack, cpu), per_cpu(softirq_stack, cpu));</span>
 }
 
 void do_softirq_own_stack(void)
<span class="p_header">diff --git a/arch/x86/kernel/jump_label.c b/arch/x86/kernel/jump_label.c</span>
<span class="p_header">index e565e0e..c4c705b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/jump_label.c</span>
<span class="p_header">+++ b/arch/x86/kernel/jump_label.c</span>
<span class="p_chunk">@@ -31,8 +31,8 @@</span> <span class="p_context"> static void bug_at(unsigned char *ip, int line)</span>
 	 * Something went wrong. Crash the box, as something could be
 	 * corrupting the kernel.
 	 */
<span class="p_del">-	pr_warning(&quot;Unexpected op at %pS [%p] (%02x %02x %02x %02x %02x) %s:%d\n&quot;,</span>
<span class="p_del">-	       ip, ip, ip[0], ip[1], ip[2], ip[3], ip[4], __FILE__, line);</span>
<span class="p_add">+	pr_warn(&quot;Unexpected op at %pS [%p] (%02x %02x %02x %02x %02x) %s:%d\n&quot;,</span>
<span class="p_add">+		ip, ip, ip[0], ip[1], ip[2], ip[3], ip[4], __FILE__, line);</span>
 	BUG();
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/kgdb.c b/arch/x86/kernel/kgdb.c</span>
<span class="p_header">index 44256a6..d13f181 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kgdb.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kgdb.c</span>
<span class="p_chunk">@@ -300,7 +300,7 @@</span> <span class="p_context"> kgdb_remove_hw_break(unsigned long addr, int len, enum kgdb_bptype bptype)</span>
 		return -1;
 
 	if (hw_break_release_slot(i)) {
<span class="p_del">-		printk(KERN_ERR &quot;Cannot remove hw breakpoint at %lx\n&quot;, addr);</span>
<span class="p_add">+		pr_err(&quot;Cannot remove hw breakpoint at %lx\n&quot;, addr);</span>
 		return -1;
 	}
 	breakinfo[i].enabled = 0;
<span class="p_chunk">@@ -327,7 +327,7 @@</span> <span class="p_context"> static void kgdb_remove_all_hw_break(void)</span>
 			early_dr7 &amp;= ~encode_dr7(i, breakinfo[i].len,
 						 breakinfo[i].type);
 		else if (hw_break_release_slot(i))
<span class="p_del">-			printk(KERN_ERR &quot;KGDB: hw bpt remove failed %lx\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;KGDB: hw bpt remove failed %lx\n&quot;,</span>
 			       breakinfo[i].addr);
 		breakinfo[i].enabled = 0;
 	}
<span class="p_chunk">@@ -498,7 +498,7 @@</span> <span class="p_context"> single_step_cont(struct pt_regs *regs, struct die_args *args)</span>
 	 * Single step exception from kernel space to user space so
 	 * eat the exception and continue the process:
 	 */
<span class="p_del">-	printk(KERN_ERR &quot;KGDB: trap/step from kernel to user space, &quot;</span>
<span class="p_add">+	pr_err(&quot;KGDB: trap/step from kernel to user space, &quot;</span>
 			&quot;resuming...\n&quot;);
 	kgdb_arch_handle_exception(args-&gt;trapnr, args-&gt;signr,
 				   args-&gt;err, &quot;c&quot;, &quot;&quot;, regs);
<span class="p_chunk">@@ -675,7 +675,7 @@</span> <span class="p_context"> void kgdb_arch_late(void)</span>
 			continue;
 		breakinfo[i].pev = register_wide_hw_breakpoint(&amp;attr, NULL, NULL);
 		if (IS_ERR((void * __force)breakinfo[i].pev)) {
<span class="p_del">-			printk(KERN_ERR &quot;kgdb: Could not allocate hw&quot;</span>
<span class="p_add">+			pr_err(&quot;kgdb: Could not allocate hw&quot;</span>
 			       &quot;breakpoints\nDisabling the kernel debugger\n&quot;);
 			breakinfo[i].pev = NULL;
 			kgdb_arch_exit();
<span class="p_header">diff --git a/arch/x86/kernel/kprobes/core.c b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">index 1deffe6..7d738d6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_chunk">@@ -581,8 +581,8 @@</span> <span class="p_context"> static int reenter_kprobe(struct kprobe *p, struct pt_regs *regs,</span>
 		 * Raise a BUG or we&#39;ll continue in an endless reentering loop
 		 * and eventually a stack overflow.
 		 */
<span class="p_del">-		printk(KERN_WARNING &quot;Unrecoverable kprobe detected at %p.\n&quot;,</span>
<span class="p_del">-		       p-&gt;addr);</span>
<span class="p_add">+		pr_warn(&quot;Unrecoverable kprobe detected at %p.\n&quot;,</span>
<span class="p_add">+			p-&gt;addr);</span>
 		dump_kprobe(p);
 		BUG();
 	default:
<span class="p_chunk">@@ -1092,12 +1092,11 @@</span> <span class="p_context"> int longjmp_break_handler(struct kprobe *p, struct pt_regs *regs)</span>
 	    (addr &lt; (u8 *) jprobe_return_end)) {
 		if (stack_addr(regs) != saved_sp) {
 			struct pt_regs *saved_regs = &amp;kcb-&gt;jprobe_saved_regs;
<span class="p_del">-			printk(KERN_ERR</span>
<span class="p_del">-			       &quot;current sp %p does not match saved sp %p\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;current sp %p does not match saved sp %p\n&quot;,</span>
 			       stack_addr(regs), saved_sp);
<span class="p_del">-			printk(KERN_ERR &quot;Saved registers for jprobe %p\n&quot;, jp);</span>
<span class="p_add">+			pr_err(&quot;Saved registers for jprobe %p\n&quot;, jp);</span>
 			show_regs(saved_regs);
<span class="p_del">-			printk(KERN_ERR &quot;Current registers\n&quot;);</span>
<span class="p_add">+			pr_err(&quot;Current registers\n&quot;);</span>
 			show_regs(regs);
 			BUG();
 		}
<span class="p_header">diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c</span>
<span class="p_header">index 47190bd..1cc3176 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvm.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvm.c</span>
<span class="p_chunk">@@ -344,8 +344,8 @@</span> <span class="p_context"> static void kvm_guest_cpu_init(void)</span>
 #endif
 		wrmsrl(MSR_KVM_ASYNC_PF_EN, pa | KVM_ASYNC_PF_ENABLED);
 		__this_cpu_write(apf_reason.enabled, 1);
<span class="p_del">-		printk(KERN_INFO&quot;KVM setup async PF for cpu %d\n&quot;,</span>
<span class="p_del">-		       smp_processor_id());</span>
<span class="p_add">+		pr_info(&quot;KVM setup async PF for cpu %d\n&quot;,</span>
<span class="p_add">+			smp_processor_id());</span>
 	}
 
 	if (kvm_para_has_feature(KVM_FEATURE_PV_EOI)) {
<span class="p_chunk">@@ -370,8 +370,8 @@</span> <span class="p_context"> static void kvm_pv_disable_apf(void)</span>
 	wrmsrl(MSR_KVM_ASYNC_PF_EN, 0);
 	__this_cpu_write(apf_reason.enabled, 0);
 
<span class="p_del">-	printk(KERN_INFO&quot;Unregister pv shared memory for cpu %d\n&quot;,</span>
<span class="p_del">-	       smp_processor_id());</span>
<span class="p_add">+	pr_info(&quot;Unregister pv shared memory for cpu %d\n&quot;,</span>
<span class="p_add">+		smp_processor_id());</span>
 }
 
 static void kvm_pv_guest_cpu_reboot(void *unused)
<span class="p_chunk">@@ -692,7 +692,7 @@</span> <span class="p_context"> static struct dentry *kvm_init_debugfs(void)</span>
 {
 	d_kvm_debug = debugfs_create_dir(&quot;kvm-guest&quot;, NULL);
 	if (!d_kvm_debug)
<span class="p_del">-		printk(KERN_WARNING &quot;Could not create &#39;kvm&#39; debugfs directory\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;Could not create &#39;kvm&#39; debugfs directory\n&quot;);</span>
 
 	return d_kvm_debug;
 }
<span class="p_chunk">@@ -883,7 +883,7 @@</span> <span class="p_context"> static __init int kvm_spinlock_init_jump(void)</span>
 		return 0;
 
 	static_key_slow_inc(&amp;paravirt_ticketlocks_enabled);
<span class="p_del">-	printk(KERN_INFO &quot;KVM setup paravirtual spinlock\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;KVM setup paravirtual spinlock\n&quot;);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/x86/kernel/kvmclock.c b/arch/x86/kernel/kvmclock.c</span>
<span class="p_header">index 72cef58..553f9bd 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvmclock.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvmclock.c</span>
<span class="p_chunk">@@ -114,8 +114,8 @@</span> <span class="p_context"> static inline void kvm_sched_clock_init(bool stable)</span>
 	pv_time_ops.sched_clock = kvm_sched_clock_read;
 	set_sched_clock_stable();
 
<span class="p_del">-	printk(KERN_INFO &quot;kvm-clock: using sched offset of %llu cycles\n&quot;,</span>
<span class="p_del">-			kvm_sched_clock_offset);</span>
<span class="p_add">+	pr_info(&quot;kvm-clock: using sched offset of %llu cycles\n&quot;,</span>
<span class="p_add">+		kvm_sched_clock_offset);</span>
 
 	BUILD_BUG_ON(sizeof(kvm_sched_clock_offset) &gt;
 	         sizeof(((struct pvclock_vcpu_time_info *)NULL)-&gt;system_time));
<span class="p_chunk">@@ -195,8 +195,8 @@</span> <span class="p_context"> int kvm_register_clock(char *txt)</span>
 	low = (int)slow_virt_to_phys(src) | 1;
 	high = ((u64)slow_virt_to_phys(src) &gt;&gt; 32);
 	ret = native_write_msr_safe(msr_kvm_system_time, low, high);
<span class="p_del">-	printk(KERN_INFO &quot;kvm-clock: cpu %d, msr %x:%x, %s\n&quot;,</span>
<span class="p_del">-	       cpu, high, low, txt);</span>
<span class="p_add">+	pr_info(&quot;kvm-clock: cpu %d, msr %x:%x, %s\n&quot;,</span>
<span class="p_add">+		cpu, high, low, txt);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> void __init kvmclock_init(void)</span>
 	} else if (!(kvmclock &amp;&amp; kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))
 		return;
 
<span class="p_del">-	printk(KERN_INFO &quot;kvm-clock: Using msrs %x and %x&quot;,</span>
<span class="p_add">+	pr_info(&quot;kvm-clock: Using msrs %x and %x&quot;,</span>
 		msr_kvm_system_time, msr_kvm_wall_clock);
 
 	mem = memblock_alloc(size, PAGE_SIZE);
<span class="p_header">diff --git a/arch/x86/kernel/mmconf-fam10h_64.c b/arch/x86/kernel/mmconf-fam10h_64.c</span>
<span class="p_header">index f4c886d..1e49af9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/mmconf-fam10h_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/mmconf-fam10h_64.c</span>
<span class="p_chunk">@@ -205,7 +205,7 @@</span> <span class="p_context"> void fam10h_check_enable_mmcfg(void)</span>
 		return;
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;Enable MMCONFIG on AMD Family 10h\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Enable MMCONFIG on AMD Family 10h\n&quot;);</span>
 	val &amp;= ~((FAM10H_MMIO_CONF_BASE_MASK&lt;&lt;FAM10H_MMIO_CONF_BASE_SHIFT) |
 	     (FAM10H_MMIO_CONF_BUSRANGE_MASK&lt;&lt;FAM10H_MMIO_CONF_BUSRANGE_SHIFT));
 	val |= fam10h_pci_mmconf_base | (8 &lt;&lt; FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |
<span class="p_header">diff --git a/arch/x86/kernel/module.c b/arch/x86/kernel/module.c</span>
<span class="p_header">index 005c03e..3edc48d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/module.c</span>
<span class="p_header">+++ b/arch/x86/kernel/module.c</span>
<span class="p_chunk">@@ -37,12 +37,12 @@</span> <span class="p_context"></span>
 
 #if 0
 #define DEBUGP(fmt, ...)				\
<span class="p_del">-	printk(KERN_DEBUG fmt, ##__VA_ARGS__)</span>
<span class="p_add">+	pr_debug(fmt, ##__VA_ARGS__)</span>
 #else
 #define DEBUGP(fmt, ...)				\
 do {							\
 	if (0)						\
<span class="p_del">-		printk(KERN_DEBUG fmt, ##__VA_ARGS__);	\</span>
<span class="p_add">+		pr_debug(fmt, ##__VA_ARGS__);	\</span>
 } while (0)
 #endif
 
<span class="p_header">diff --git a/arch/x86/kernel/nmi_selftest.c b/arch/x86/kernel/nmi_selftest.c</span>
<span class="p_header">index 6d9582e..14a678d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/nmi_selftest.c</span>
<span class="p_header">+++ b/arch/x86/kernel/nmi_selftest.c</span>
<span class="p_chunk">@@ -119,15 +119,15 @@</span> <span class="p_context"> static void __init dotest(void (*testcase_fn)(void), int expected)</span>
 		unexpected_testcase_failures++;
 
 		if (nmi_fail == FAILURE)
<span class="p_del">-			printk(KERN_CONT &quot;FAILED |&quot;);</span>
<span class="p_add">+			pr_cont(&quot;FAILED |&quot;);</span>
 		else if (nmi_fail == TIMEOUT)
<span class="p_del">-			printk(KERN_CONT &quot;TIMEOUT|&quot;);</span>
<span class="p_add">+			pr_cont(&quot;TIMEOUT|&quot;);</span>
 		else
<span class="p_del">-			printk(KERN_CONT &quot;ERROR  |&quot;);</span>
<span class="p_add">+			pr_cont(&quot;ERROR  |&quot;);</span>
 		dump_stack();
 	} else {
 		testcase_successes++;
<span class="p_del">-		printk(KERN_CONT &quot;  ok  |&quot;);</span>
<span class="p_add">+		pr_cont(&quot;  ok  |&quot;);</span>
 	}
 	testcase_total++;
 
<span class="p_chunk">@@ -152,10 +152,10 @@</span> <span class="p_context"> void __init nmi_selftest(void)</span>
 
 	print_testname(&quot;remote IPI&quot;);
 	dotest(remote_ipi, SUCCESS);
<span class="p_del">-	printk(KERN_CONT &quot;\n&quot;);</span>
<span class="p_add">+	pr_cont(&quot;\n&quot;);</span>
 	print_testname(&quot;local IPI&quot;);
 	dotest(local_ipi, SUCCESS);
<span class="p_del">-	printk(KERN_CONT &quot;\n&quot;);</span>
<span class="p_add">+	pr_cont(&quot;\n&quot;);</span>
 
 	cleanup_nmi_testsuite();
 
<span class="p_header">diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c</span>
<span class="p_header">index f08ac28..938fff9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/paravirt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/paravirt.c</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> u64 _paravirt_ident_64(u64 x)</span>
 
 void __init default_banner(void)
 {
<span class="p_del">-	printk(KERN_INFO &quot;Booting paravirtualized kernel on %s\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Booting paravirtualized kernel on %s\n&quot;,</span>
 	       pv_info.name);
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/pci-calgary_64.c b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">index 833b1d3..0c88cf6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_chunk">@@ -586,19 +586,19 @@</span> <span class="p_context"> static void calioc2_tce_cache_blast(struct iommu_table *tbl)</span>
 	unsigned char bus = tbl-&gt;it_busno;
 
 begin:
<span class="p_del">-	printk(KERN_DEBUG &quot;Calgary: CalIOC2 bus 0x%x entering tce cache blast &quot;</span>
<span class="p_add">+	pr_debug(&quot;Calgary: CalIOC2 bus 0x%x entering tce cache blast &quot;</span>
 	       &quot;sequence - count %d\n&quot;, bus, count);
 
 	/* 1. using the Page Migration Control reg set SoftStop */
 	target = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_CTRL);
 	val = be32_to_cpu(readl(target));
<span class="p_del">-	printk(KERN_DEBUG &quot;1a. read 0x%x [LE] from %p\n&quot;, val, target);</span>
<span class="p_add">+	pr_debug(&quot;1a. read 0x%x [LE] from %p\n&quot;, val, target);</span>
 	val |= PMR_SOFTSTOP;
<span class="p_del">-	printk(KERN_DEBUG &quot;1b. writing 0x%x [LE] to %p\n&quot;, val, target);</span>
<span class="p_add">+	pr_debug(&quot;1b. writing 0x%x [LE] to %p\n&quot;, val, target);</span>
 	writel(cpu_to_be32(val), target);
 
 	/* 2. poll split queues until all DMA activity is done */
<span class="p_del">-	printk(KERN_DEBUG &quot;2a. starting to poll split queues\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;2a. starting to poll split queues\n&quot;);</span>
 	target = calgary_reg(bbar, split_queue_offset(bus));
 	do {
 		val64 = readq(target);
<span class="p_chunk">@@ -610,7 +610,7 @@</span> <span class="p_context"> begin:</span>
 	/* 3. poll Page Migration DEBUG for SoftStopFault */
 	target = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_DEBUG);
 	val = be32_to_cpu(readl(target));
<span class="p_del">-	printk(KERN_DEBUG &quot;3. read 0x%x [LE] from %p\n&quot;, val, target);</span>
<span class="p_add">+	pr_debug(&quot;3. read 0x%x [LE] from %p\n&quot;, val, target);</span>
 
 	/* 4. if SoftStopFault - goto (1) */
 	if (val &amp; PMR_SOFTSTOPFAULT) {
<span class="p_chunk">@@ -624,32 +624,32 @@</span> <span class="p_context"> begin:</span>
 
 	/* 5. Slam into HardStop by reading PHB_PAGE_MIG_CTRL */
 	target = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_CTRL);
<span class="p_del">-	printk(KERN_DEBUG &quot;5a. slamming into HardStop by reading %p\n&quot;, target);</span>
<span class="p_add">+	pr_debug(&quot;5a. slamming into HardStop by reading %p\n&quot;, target);</span>
 	val = be32_to_cpu(readl(target));
<span class="p_del">-	printk(KERN_DEBUG &quot;5b. read 0x%x [LE] from %p\n&quot;, val, target);</span>
<span class="p_add">+	pr_debug(&quot;5b. read 0x%x [LE] from %p\n&quot;, val, target);</span>
 	target = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_DEBUG);
 	val = be32_to_cpu(readl(target));
<span class="p_del">-	printk(KERN_DEBUG &quot;5c. read 0x%x [LE] from %p (debug)\n&quot;, val, target);</span>
<span class="p_add">+	pr_debug(&quot;5c. read 0x%x [LE] from %p (debug)\n&quot;, val, target);</span>
 
 	/* 6. invalidate TCE cache */
<span class="p_del">-	printk(KERN_DEBUG &quot;6. invalidating TCE cache\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;6. invalidating TCE cache\n&quot;);</span>
 	target = calgary_reg(bbar, tar_offset(bus));
 	writeq(tbl-&gt;tar_val, target);
 
 	/* 7. Re-read PMCR */
<span class="p_del">-	printk(KERN_DEBUG &quot;7a. Re-reading PMCR\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;7a. Re-reading PMCR\n&quot;);</span>
 	target = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_CTRL);
 	val = be32_to_cpu(readl(target));
<span class="p_del">-	printk(KERN_DEBUG &quot;7b. read 0x%x [LE] from %p\n&quot;, val, target);</span>
<span class="p_add">+	pr_debug(&quot;7b. read 0x%x [LE] from %p\n&quot;, val, target);</span>
 
 	/* 8. Remove HardStop */
<span class="p_del">-	printk(KERN_DEBUG &quot;8a. removing HardStop from PMCR\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;8a. removing HardStop from PMCR\n&quot;);</span>
 	target = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_CTRL);
 	val = 0;
<span class="p_del">-	printk(KERN_DEBUG &quot;8b. writing 0x%x [LE] to %p\n&quot;, val, target);</span>
<span class="p_add">+	pr_debug(&quot;8b. writing 0x%x [LE] to %p\n&quot;, val, target);</span>
 	writel(cpu_to_be32(val), target);
 	val = be32_to_cpu(readl(target));
<span class="p_del">-	printk(KERN_DEBUG &quot;8c. read 0x%x [LE] from %p\n&quot;, val, target);</span>
<span class="p_add">+	pr_debug(&quot;8c. read 0x%x [LE] from %p\n&quot;, val, target);</span>
 }
 
 static void __init calgary_reserve_mem_region(struct pci_dev *dev, u64 start,
<span class="p_chunk">@@ -885,8 +885,8 @@</span> <span class="p_context"> static void calioc2_dump_error_regs(struct iommu_table *tbl)</span>
 	/* root complex status */
 	target = calgary_reg(bbar, phboff | PHB_ROOT_COMPLEX_STATUS);
 	rcstat = be32_to_cpu(readl(target));
<span class="p_del">-	printk(KERN_EMERG &quot;Calgary: 0x%08x@0x%x\n&quot;, rcstat,</span>
<span class="p_del">-	       PHB_ROOT_COMPLEX_STATUS);</span>
<span class="p_add">+	pr_emerg(&quot;Calgary: 0x%08x@0x%x\n&quot;, rcstat,</span>
<span class="p_add">+		 PHB_ROOT_COMPLEX_STATUS);</span>
 }
 
 static void calgary_watchdog(unsigned long data)
<span class="p_chunk">@@ -998,11 +998,11 @@</span> <span class="p_context"> static void __init calgary_enable_translation(struct pci_dev *dev)</span>
 	val32 = be32_to_cpu(readl(target));
 	val32 |= PHB_TCE_ENABLE | PHB_DAC_DISABLE | PHB_MCSR_ENABLE;
 
<span class="p_del">-	printk(KERN_INFO &quot;Calgary: enabling translation on %s PHB %#x\n&quot;,</span>
<span class="p_del">-	       (dev-&gt;device == PCI_DEVICE_ID_IBM_CALGARY) ?</span>
<span class="p_del">-	       &quot;Calgary&quot; : &quot;CalIOC2&quot;, busnum);</span>
<span class="p_del">-	printk(KERN_INFO &quot;Calgary: errant DMAs will now be prevented on this &quot;</span>
<span class="p_del">-	       &quot;bus.\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Calgary: enabling translation on %s PHB %#x\n&quot;,</span>
<span class="p_add">+		(dev-&gt;device == PCI_DEVICE_ID_IBM_CALGARY) ?</span>
<span class="p_add">+		&quot;Calgary&quot; : &quot;CalIOC2&quot;, busnum);</span>
<span class="p_add">+	pr_info(&quot;Calgary: errant DMAs will now be prevented on this &quot;</span>
<span class="p_add">+		&quot;bus.\n&quot;);</span>
 
 	writel(cpu_to_be32(val32), target);
 	readl(target); /* flush */
<span class="p_chunk">@@ -1030,7 +1030,7 @@</span> <span class="p_context"> static void __init calgary_disable_translation(struct pci_dev *dev)</span>
 	val32 = be32_to_cpu(readl(target));
 	val32 &amp;= ~(PHB_TCE_ENABLE | PHB_DAC_DISABLE | PHB_MCSR_ENABLE);
 
<span class="p_del">-	printk(KERN_INFO &quot;Calgary: disabling translation on PHB %#x!\n&quot;, busnum);</span>
<span class="p_add">+	pr_info(&quot;Calgary: disabling translation on PHB %#x!\n&quot;, busnum);</span>
 	writel(cpu_to_be32(val32), target);
 	readl(target); /* flush */
 
<span class="p_chunk">@@ -1064,8 +1064,8 @@</span> <span class="p_context"> static int __init calgary_init_one(struct pci_dev *dev)</span>
 
 	if (dev-&gt;bus-&gt;parent) {
 		if (dev-&gt;bus-&gt;parent-&gt;self)
<span class="p_del">-			printk(KERN_WARNING &quot;Calgary: IEEEE, dev %p has &quot;</span>
<span class="p_del">-			       &quot;bus-&gt;parent-&gt;self!\n&quot;, dev);</span>
<span class="p_add">+			pr_warn(&quot;Calgary: IEEEE, dev %p has &quot;</span>
<span class="p_add">+				&quot;bus-&gt;parent-&gt;self!\n&quot;, dev);</span>
 		dev-&gt;bus-&gt;parent-&gt;self = dev;
 	} else
 		dev-&gt;bus-&gt;self = dev;
<span class="p_chunk">@@ -1244,8 +1244,7 @@</span> <span class="p_context"> static int __init build_detail_arrays(void)</span>
 
 	numnodes = rio_table_hdr-&gt;num_scal_dev;
 	if (numnodes &gt; MAX_NUMNODES){
<span class="p_del">-		printk(KERN_WARNING</span>
<span class="p_del">-			&quot;Calgary: MAX_NUMNODES too low! Defined as %d, &quot;</span>
<span class="p_add">+		pr_warn(&quot;Calgary: MAX_NUMNODES too low! Defined as %d, &quot;</span>
 			&quot;but system has %d nodes.\n&quot;,
 			MAX_NUMNODES, numnodes);
 		return -ENODEV;
<span class="p_chunk">@@ -1261,9 +1260,8 @@</span> <span class="p_context"> static int __init build_detail_arrays(void)</span>
 		rio_detail_size = 15;
 		break;
 	default:
<span class="p_del">-		printk(KERN_WARNING</span>
<span class="p_del">-		       &quot;Calgary: Invalid Rio Grande Table Version: %d\n&quot;,</span>
<span class="p_del">-		       rio_table_hdr-&gt;version);</span>
<span class="p_add">+		pr_warn(&quot;Calgary: Invalid Rio Grande Table Version: %d\n&quot;,</span>
<span class="p_add">+			rio_table_hdr-&gt;version);</span>
 		return -EPROTO;
 	}
 
<span class="p_chunk">@@ -1359,11 +1357,11 @@</span> <span class="p_context"> static int __init calgary_iommu_init(void)</span>
 	int ret;
 
 	/* ok, we&#39;re trying to use Calgary - let&#39;s roll */
<span class="p_del">-	printk(KERN_INFO &quot;PCI-DMA: Using Calgary IOMMU\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;PCI-DMA: Using Calgary IOMMU\n&quot;);</span>
 
 	ret = calgary_init();
 	if (ret) {
<span class="p_del">-		printk(KERN_ERR &quot;PCI-DMA: Calgary init failed %d, &quot;</span>
<span class="p_add">+		pr_err(&quot;PCI-DMA: Calgary init failed %d, &quot;</span>
 		       &quot;falling back to no_iommu\n&quot;, ret);
 		return ret;
 	}
<span class="p_chunk">@@ -1393,7 +1391,7 @@</span> <span class="p_context"> int __init detect_calgary(void)</span>
 	if (!early_pci_allowed())
 		return -ENODEV;
 
<span class="p_del">-	printk(KERN_DEBUG &quot;Calgary: detecting Calgary via BIOS EBDA area\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;Calgary: detecting Calgary via BIOS EBDA area\n&quot;);</span>
 
 	ptr = (unsigned long)phys_to_virt(get_bios_ebda());
 
<span class="p_chunk">@@ -1415,14 +1413,14 @@</span> <span class="p_context"> int __init detect_calgary(void)</span>
 		offset = *((unsigned short *)(ptr + offset));
 	}
 	if (!rio_table_hdr) {
<span class="p_del">-		printk(KERN_DEBUG &quot;Calgary: Unable to locate Rio Grande table &quot;</span>
<span class="p_del">-		       &quot;in EBDA - bailing!\n&quot;);</span>
<span class="p_add">+		pr_debug(&quot;Calgary: Unable to locate Rio Grande table &quot;</span>
<span class="p_add">+			 &quot;in EBDA - bailing!\n&quot;);</span>
 		return -ENODEV;
 	}
 
 	ret = build_detail_arrays();
 	if (ret) {
<span class="p_del">-		printk(KERN_DEBUG &quot;Calgary: build_detail_arrays ret %d\n&quot;, ret);</span>
<span class="p_add">+		pr_debug(&quot;Calgary: build_detail_arrays ret %d\n&quot;, ret);</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -1458,15 +1456,15 @@</span> <span class="p_context"> int __init detect_calgary(void)</span>
 		}
 	}
 
<span class="p_del">-	printk(KERN_DEBUG &quot;Calgary: finished detection, Calgary %s\n&quot;,</span>
<span class="p_del">-	       calgary_found ? &quot;found&quot; : &quot;not found&quot;);</span>
<span class="p_add">+	pr_debug(&quot;Calgary: finished detection, Calgary %s\n&quot;,</span>
<span class="p_add">+		 calgary_found ? &quot;found&quot; : &quot;not found&quot;);</span>
 
 	if (calgary_found) {
 		iommu_detected = 1;
 		calgary_detected = 1;
<span class="p_del">-		printk(KERN_INFO &quot;PCI-DMA: Calgary IOMMU detected.\n&quot;);</span>
<span class="p_del">-		printk(KERN_INFO &quot;PCI-DMA: Calgary TCE table spec is %d\n&quot;,</span>
<span class="p_del">-		       specified_table_size);</span>
<span class="p_add">+		pr_info(&quot;PCI-DMA: Calgary IOMMU detected.\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;PCI-DMA: Calgary TCE table spec is %d\n&quot;,</span>
<span class="p_add">+			specified_table_size);</span>
 
 		x86_init.iommu.iommu_init = calgary_iommu_init;
 	}
<span class="p_chunk">@@ -1524,8 +1522,8 @@</span> <span class="p_context"> static int __init calgary_parse_options(char *p)</span>
 
 			bridge = val;
 			if (bridge &lt; MAX_PHB_BUS_NUM) {
<span class="p_del">-				printk(KERN_INFO &quot;Calgary: disabling &quot;</span>
<span class="p_del">-				       &quot;translation for PHB %#x\n&quot;, bridge);</span>
<span class="p_add">+				pr_info(&quot;Calgary: disabling &quot;</span>
<span class="p_add">+					&quot;translation for PHB %#x\n&quot;, bridge);</span>
 				bus_info[bridge].translation_disabled = 1;
 			}
 		}
<span class="p_chunk">@@ -1575,7 +1573,7 @@</span> <span class="p_context"> static int __init calgary_fixup_tce_spaces(void)</span>
 	if (no_iommu || swiotlb || !calgary_detected)
 		return -ENODEV;
 
<span class="p_del">-	printk(KERN_DEBUG &quot;Calgary: fixing up tce spaces\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;Calgary: fixing up tce spaces\n&quot;);</span>
 
 	do {
 		dev = pci_get_device(PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);
<span class="p_header">diff --git a/arch/x86/kernel/pci-iommu_table.c b/arch/x86/kernel/pci-iommu_table.c</span>
<span class="p_header">index 35ccf75..79149db 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-iommu_table.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-iommu_table.c</span>
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"> void __init check_iommu_entries(struct iommu_table_entry *start,</span>
 		q = find_dependents_of(start, finish, p);
 		x = find_dependents_of(start, finish, q);
 		if (p == x) {
<span class="p_del">-			printk(KERN_ERR &quot;CYCLIC DEPENDENCY FOUND! %pS depends on %pS and vice-versa. BREAKING IT.\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;CYCLIC DEPENDENCY FOUND! %pS depends on %pS and vice-versa. BREAKING IT.\n&quot;,</span>
 			       p-&gt;detect, q-&gt;detect);
 			/* Heavy handed way..*/
 			x-&gt;depend = 0;
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> void __init check_iommu_entries(struct iommu_table_entry *start,</span>
 	for (p = start; p &lt; finish; p++) {
 		q = find_dependents_of(p, finish, p);
 		if (q &amp;&amp; q &gt; p) {
<span class="p_del">-			printk(KERN_ERR &quot;EXECUTION ORDER INVALID! %pS should be called before %pS!\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;EXECUTION ORDER INVALID! %pS should be called before %pS!\n&quot;,</span>
 			       p-&gt;detect, q-&gt;detect);
 		}
 	}
<span class="p_header">diff --git a/arch/x86/kernel/pci-nommu.c b/arch/x86/kernel/pci-nommu.c</span>
<span class="p_header">index da15918..4c365495 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-nommu.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-nommu.c</span>
<span class="p_chunk">@@ -16,8 +16,7 @@</span> <span class="p_context"> check_addr(char *name, struct device *hwdev, dma_addr_t bus, size_t size)</span>
 {
 	if (hwdev &amp;&amp; !dma_capable(hwdev, bus, size)) {
 		if (*hwdev-&gt;dma_mask &gt;= DMA_BIT_MASK(32))
<span class="p_del">-			printk(KERN_ERR</span>
<span class="p_del">-			    &quot;nommu_%s: overflow %Lx+%zu of device mask %Lx\n&quot;,</span>
<span class="p_add">+			pr_err(&quot;nommu_%s: overflow %Lx+%zu of device mask %Lx\n&quot;,</span>
 				name, (long long)bus, size,
 				(long long)*hwdev-&gt;dma_mask);
 		return 0;
<span class="p_header">diff --git a/arch/x86/kernel/pci-swiotlb.c b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">index 7c577a1..9374856 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_chunk">@@ -112,8 +112,8 @@</span> <span class="p_context"> void __init pci_swiotlb_late_init(void)</span>
 	if (!swiotlb)
 		swiotlb_free();
 	else {
<span class="p_del">-		printk(KERN_INFO &quot;PCI-DMA: &quot;</span>
<span class="p_del">-		       &quot;Using software bounce buffering for IO (SWIOTLB)\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;PCI-DMA: &quot;</span>
<span class="p_add">+			&quot;Using software bounce buffering for IO (SWIOTLB)\n&quot;);</span>
 		swiotlb_print_info();
 	}
 }
<span class="p_header">diff --git a/arch/x86/kernel/quirks.c b/arch/x86/kernel/quirks.c</span>
<span class="p_header">index cc457ff..f3e2642 100644</span>
<span class="p_header">--- a/arch/x86/kernel/quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/quirks.c</span>
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"> static void ich_force_hpet_resume(void)</span>
 	if (!(val &amp; 0x80))
 		BUG();
 	else
<span class="p_del">-		printk(KERN_DEBUG &quot;Force enabled HPET at resume\n&quot;);</span>
<span class="p_add">+		pr_debug(&quot;Force enabled HPET at resume\n&quot;);</span>
 
 	return;
 }
<span class="p_chunk">@@ -103,7 +103,7 @@</span> <span class="p_context"> static void ich_force_enable_hpet(struct pci_dev *dev)</span>
 	pci_read_config_dword(dev, 0xF0, &amp;rcba);
 	rcba &amp;= 0xFFFFC000;
 	if (rcba == 0) {
<span class="p_del">-		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;RCBA disabled; &quot;</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;RCBA disabled; &quot;</span>
 			&quot;cannot force enable HPET\n&quot;);
 		return;
 	}
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> static void ich_force_enable_hpet(struct pci_dev *dev)</span>
 	/* use bits 31:14, 16 kB aligned */
 	rcba_base = ioremap_nocache(rcba, 0x4000);
 	if (rcba_base == NULL) {
<span class="p_del">-		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;ioremap failed; &quot;</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;ioremap failed; &quot;</span>
 			&quot;cannot force enable HPET\n&quot;);
 		return;
 	}
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> static void ich_force_enable_hpet(struct pci_dev *dev)</span>
 		/* HPET is enabled in HPTC. Just not reported by BIOS */
 		val = val &amp; 0x3;
 		force_hpet_address = 0xFED00000 | (val &lt;&lt; 12);
<span class="p_del">-		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;Force enabled HPET at &quot;</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;Force enabled HPET at &quot;</span>
 			&quot;0x%lx\n&quot;, force_hpet_address);
 		iounmap(rcba_base);
 		return;
<span class="p_chunk">@@ -143,12 +143,11 @@</span> <span class="p_context"> static void ich_force_enable_hpet(struct pci_dev *dev)</span>
 	if (err) {
 		force_hpet_address = 0;
 		iounmap(rcba_base);
<span class="p_del">-		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev,</span>
<span class="p_del">-			&quot;Failed to force enable HPET\n&quot;);</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;Failed to force enable HPET\n&quot;);</span>
 	} else {
 		force_hpet_resume_type = ICH_FORCE_HPET_RESUME;
<span class="p_del">-		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;Force enabled HPET at &quot;</span>
<span class="p_del">-			&quot;0x%lx\n&quot;, force_hpet_address);</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;Force enabled HPET at 0x%lx\n&quot;,</span>
<span class="p_add">+			force_hpet_address);</span>
 	}
 }
 
<span class="p_chunk">@@ -177,7 +176,7 @@</span> <span class="p_context"> static struct pci_dev *cached_dev;</span>
 
 static void hpet_print_force_info(void)
 {
<span class="p_del">-	printk(KERN_INFO &quot;HPET not enabled in BIOS. &quot;</span>
<span class="p_add">+	pr_info(&quot;HPET not enabled in BIOS. &quot;</span>
 	       &quot;You might try hpet=force boot option\n&quot;);
 }
 
<span class="p_chunk">@@ -198,7 +197,7 @@</span> <span class="p_context"> static void old_ich_force_hpet_resume(void)</span>
 	val = gen_cntl &gt;&gt; 15;
 	val &amp;= 0x7;
 	if (val == 0x4)
<span class="p_del">-		printk(KERN_DEBUG &quot;Force enabled HPET at resume\n&quot;);</span>
<span class="p_add">+		pr_debug(&quot;Force enabled HPET at resume\n&quot;);</span>
 	else
 		BUG();
 }
<span class="p_chunk">@@ -221,8 +220,7 @@</span> <span class="p_context"> static void old_ich_force_enable_hpet(struct pci_dev *dev)</span>
 	if (val &amp; 0x4) {
 		val &amp;= 0x3;
 		force_hpet_address = 0xFED00000 | (val &lt;&lt; 12);
<span class="p_del">-		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;HPET at 0x%lx\n&quot;,</span>
<span class="p_del">-			force_hpet_address);</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;HPET at 0x%lx\n&quot;, force_hpet_address);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -242,14 +240,14 @@</span> <span class="p_context"> static void old_ich_force_enable_hpet(struct pci_dev *dev)</span>
 		/* HPET is enabled in HPTC. Just not reported by BIOS */
 		val &amp;= 0x3;
 		force_hpet_address = 0xFED00000 | (val &lt;&lt; 12);
<span class="p_del">-		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;Force enabled HPET at &quot;</span>
<span class="p_del">-			&quot;0x%lx\n&quot;, force_hpet_address);</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;Force enabled HPET at 0x%lx\n&quot;,</span>
<span class="p_add">+			force_hpet_address);</span>
 		cached_dev = dev;
 		force_hpet_resume_type = OLD_ICH_FORCE_HPET_RESUME;
 		return;
 	}
 
<span class="p_del">-	dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;Failed to force enable HPET\n&quot;);</span>
<span class="p_add">+	dev_dbg(&amp;dev-&gt;dev, &quot;Failed to force enable HPET\n&quot;);</span>
 }
 
 /*
<span class="p_chunk">@@ -290,7 +288,7 @@</span> <span class="p_context"> static void vt8237_force_hpet_resume(void)</span>
 
 	pci_read_config_dword(cached_dev, 0x68, &amp;val);
 	if (val &amp; 0x80)
<span class="p_del">-		printk(KERN_DEBUG &quot;Force enabled HPET at resume\n&quot;);</span>
<span class="p_add">+		pr_debug(&quot;Force enabled HPET at resume\n&quot;);</span>
 	else
 		BUG();
 }
<span class="p_chunk">@@ -314,7 +312,7 @@</span> <span class="p_context"> static void vt8237_force_enable_hpet(struct pci_dev *dev)</span>
 	 */
 	if (val &amp; 0x80) {
 		force_hpet_address = (val &amp; ~0x3ff);
<span class="p_del">-		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;HPET at 0x%lx\n&quot;,</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;HPET at 0x%lx\n&quot;,</span>
 			force_hpet_address);
 		return;
 	}
<span class="p_chunk">@@ -329,14 +327,14 @@</span> <span class="p_context"> static void vt8237_force_enable_hpet(struct pci_dev *dev)</span>
 	pci_read_config_dword(dev, 0x68, &amp;val);
 	if (val &amp; 0x80) {
 		force_hpet_address = (val &amp; ~0x3ff);
<span class="p_del">-		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;Force enabled HPET at &quot;</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;Force enabled HPET at &quot;</span>
 			&quot;0x%lx\n&quot;, force_hpet_address);
 		cached_dev = dev;
 		force_hpet_resume_type = VT8237_FORCE_HPET_RESUME;
 		return;
 	}
 
<span class="p_del">-	dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;Failed to force enable HPET\n&quot;);</span>
<span class="p_add">+	dev_dbg(&amp;dev-&gt;dev, &quot;Failed to force enable HPET\n&quot;);</span>
 }
 
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8235,
<span class="p_chunk">@@ -349,7 +347,7 @@</span> <span class="p_context"> DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_CX700,</span>
 static void ati_force_hpet_resume(void)
 {
 	pci_write_config_dword(cached_dev, 0x14, 0xfed00000);
<span class="p_del">-	printk(KERN_DEBUG &quot;Force enabled HPET at resume\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;Force enabled HPET at resume\n&quot;);</span>
 }
 
 static u32 ati_ixp4x0_rev(struct pci_dev *dev)
<span class="p_chunk">@@ -366,7 +364,7 @@</span> <span class="p_context"> static u32 ati_ixp4x0_rev(struct pci_dev *dev)</span>
 	err |= pci_write_config_dword(dev, 0x70, d);
 	err |= pci_read_config_dword(dev, 0x8, &amp;d);
 	d &amp;= 0xff;
<span class="p_del">-	dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;SB4X0 revision 0x%x\n&quot;, d);</span>
<span class="p_add">+	dev_dbg(&amp;dev-&gt;dev, &quot;SB4X0 revision 0x%x\n&quot;, d);</span>
 
 	WARN_ON_ONCE(err);
 
<span class="p_chunk">@@ -410,7 +408,7 @@</span> <span class="p_context"> static void ati_force_enable_hpet(struct pci_dev *dev)</span>
 
 	force_hpet_address = val;
 	force_hpet_resume_type = ATI_FORCE_HPET_RESUME;
<span class="p_del">-	dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;Force enabled HPET at 0x%lx\n&quot;,</span>
<span class="p_add">+	dev_dbg(&amp;dev-&gt;dev, &quot;Force enabled HPET at 0x%lx\n&quot;,</span>
 		   force_hpet_address);
 	cached_dev = dev;
 }
<span class="p_chunk">@@ -423,7 +421,7 @@</span> <span class="p_context"> DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP400_SMBUS,</span>
 static void nvidia_force_hpet_resume(void)
 {
 	pci_write_config_dword(cached_dev, 0x44, 0xfed00001);
<span class="p_del">-	printk(KERN_DEBUG &quot;Force enabled HPET at resume\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;Force enabled HPET at resume\n&quot;);</span>
 }
 
 static void nvidia_force_enable_hpet(struct pci_dev *dev)
<span class="p_chunk">@@ -442,7 +440,7 @@</span> <span class="p_context"> static void nvidia_force_enable_hpet(struct pci_dev *dev)</span>
 	pci_read_config_dword(dev, 0x44, &amp;val);
 	force_hpet_address = val &amp; 0xfffffffe;
 	force_hpet_resume_type = NVIDIA_FORCE_HPET_RESUME;
<span class="p_del">-	dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;Force enabled HPET at 0x%lx\n&quot;,</span>
<span class="p_add">+	dev_dbg(&amp;dev-&gt;dev, &quot;Force enabled HPET at 0x%lx\n&quot;,</span>
 		force_hpet_address);
 	cached_dev = dev;
 	return;
<span class="p_chunk">@@ -508,7 +506,7 @@</span> <span class="p_context"> static void e6xx_force_enable_hpet(struct pci_dev *dev)</span>
 
 	force_hpet_address = 0xFED00000;
 	force_hpet_resume_type = NONE_FORCE_HPET_RESUME;
<span class="p_del">-	dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;Force enabled HPET at &quot;</span>
<span class="p_add">+	dev_dbg(&amp;dev-&gt;dev, &quot;Force enabled HPET at &quot;</span>
 		&quot;0x%lx\n&quot;, force_hpet_address);
 	return;
 }
<span class="p_header">diff --git a/arch/x86/kernel/rtc.c b/arch/x86/kernel/rtc.c</span>
<span class="p_header">index 4af8d06..0ff3fbc 100644</span>
<span class="p_header">--- a/arch/x86/kernel/rtc.c</span>
<span class="p_header">+++ b/arch/x86/kernel/rtc.c</span>
<span class="p_chunk">@@ -48,11 +48,10 @@</span> <span class="p_context"> int mach_set_rtc_mmss(const struct timespec *now)</span>
 	if (!rtc_valid_tm(&amp;tm)) {
 		retval = set_rtc_time(&amp;tm);
 		if (retval)
<span class="p_del">-			printk(KERN_ERR &quot;%s: RTC write failed with error %d\n&quot;,</span>
<span class="p_del">-			       __func__, retval);</span>
<span class="p_add">+			pr_err(&quot;%s: RTC write failed with error %d\n&quot;,</span>
<span class="p_add">+				__func__, retval);</span>
 	} else {
<span class="p_del">-		printk(KERN_ERR</span>
<span class="p_del">-		       &quot;%s: Invalid RTC value: write of %lx to RTC failed\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;%s: Invalid RTC value: write of %lx to RTC failed\n&quot;,</span>
 			__func__, nowtime);
 		retval = -EINVAL;
 	}
<span class="p_header">diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c</span>
<span class="p_header">index aa52c10..c0d783d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/setup.c</span>
<span class="p_header">+++ b/arch/x86/kernel/setup.c</span>
<span class="p_chunk">@@ -338,12 +338,12 @@</span> <span class="p_context"> static void __init relocate_initrd(void)</span>
 	memblock_reserve(relocated_ramdisk, area_size);
 	initrd_start = relocated_ramdisk + PAGE_OFFSET;
 	initrd_end   = initrd_start + ramdisk_size;
<span class="p_del">-	printk(KERN_INFO &quot;Allocated new RAMDISK: [mem %#010llx-%#010llx]\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;Allocated new RAMDISK: [mem %#010llx-%#010llx]\n&quot;,</span>
 	       relocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);
 
 	copy_from_early_mem((void *)initrd_start, ramdisk_image, ramdisk_size);
 
<span class="p_del">-	printk(KERN_INFO &quot;Move RAMDISK from [mem %#010llx-%#010llx] to&quot;</span>
<span class="p_add">+	pr_info(&quot;Move RAMDISK from [mem %#010llx-%#010llx] to&quot;</span>
 		&quot; [mem %#010llx-%#010llx]\n&quot;,
 		ramdisk_image, ramdisk_image + ramdisk_size - 1,
 		relocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);
<span class="p_chunk">@@ -382,7 +382,7 @@</span> <span class="p_context"> static void __init reserve_initrd(void)</span>
 		       &quot;disabling initrd (%lld needed, %lld available)\n&quot;,
 		       ramdisk_size, mapped_size&gt;&gt;1);
 
<span class="p_del">-	printk(KERN_INFO &quot;RAMDISK: [mem %#010llx-%#010llx]\n&quot;, ramdisk_image,</span>
<span class="p_add">+	pr_info(&quot;RAMDISK: [mem %#010llx-%#010llx]\n&quot;, ramdisk_image,</span>
 			ramdisk_end - 1);
 
 	if (pfn_range_is_mapped(PFN_DOWN(ramdisk_image),
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"> static void __init e820_reserve_setup_data(void)</span>
 
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &amp;e820.nr_map);
 	memcpy(&amp;e820_saved, &amp;e820, sizeof(struct e820map));
<span class="p_del">-	printk(KERN_INFO &quot;extended physical RAM map:\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;extended physical RAM map:\n&quot;);</span>
 	e820_print_map(&quot;reserve setup_data&quot;);
 }
 
<span class="p_chunk">@@ -713,7 +713,7 @@</span> <span class="p_context"> static void __init trim_snb_memory(void)</span>
 	if (!snb_gfx_workaround_needed())
 		return;
 
<span class="p_del">-	printk(KERN_DEBUG &quot;reserving inaccessible SNB gfx pages\n&quot;);</span>
<span class="p_add">+	pr_debug(&quot;reserving inaccessible SNB gfx pages\n&quot;);</span>
 
 	/*
 	 * Reserve all memory below the 1 MB mark that has not
<span class="p_chunk">@@ -723,8 +723,8 @@</span> <span class="p_context"> static void __init trim_snb_memory(void)</span>
 	
 	for (i = 0; i &lt; ARRAY_SIZE(bad_pages); i++) {
 		if (memblock_reserve(bad_pages[i], PAGE_SIZE))
<span class="p_del">-			printk(KERN_WARNING &quot;failed to reserve 0x%08lx\n&quot;,</span>
<span class="p_del">-			       bad_pages[i]);</span>
<span class="p_add">+			pr_warn(&quot;failed to reserve 0x%08lx\n&quot;,</span>
<span class="p_add">+				bad_pages[i]);</span>
 	}
 }
 
<span class="p_chunk">@@ -881,7 +881,7 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 	 */
 	__flush_tlb_all();
 #else
<span class="p_del">-	printk(KERN_INFO &quot;Command line: %s\n&quot;, boot_command_line);</span>
<span class="p_add">+	pr_info(&quot;Command line: %s\n&quot;, boot_command_line);</span>
 #endif
 
 	/*
<span class="p_chunk">@@ -1030,7 +1030,7 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 		e820_update_range(0x70000000ULL, 0x40000ULL, E820_RAM,
 				  E820_RESERVED);
 		sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &amp;e820.nr_map);
<span class="p_del">-		printk(KERN_INFO &quot;fixed physical RAM map:\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;fixed physical RAM map:\n&quot;);</span>
 		e820_print_map(&quot;bad_ppro&quot;);
 	}
 #else
<span class="p_chunk">@@ -1107,8 +1107,8 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 #endif
 
 #ifdef CONFIG_X86_32
<span class="p_del">-	printk(KERN_DEBUG &quot;initial memory mapped: [mem 0x00000000-%#010lx]\n&quot;,</span>
<span class="p_del">-			(max_pfn_mapped&lt;&lt;PAGE_SHIFT) - 1);</span>
<span class="p_add">+	pr_debug(&quot;initial memory mapped: [mem 0x00000000-%#010lx]\n&quot;,</span>
<span class="p_add">+		 (max_pfn_mapped&lt;&lt;PAGE_SHIFT) - 1);</span>
 #endif
 
 	reserve_real_mode();
<span class="p_header">diff --git a/arch/x86/kernel/setup_percpu.c b/arch/x86/kernel/setup_percpu.c</span>
<span class="p_header">index e4fcb87..ce3527b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/setup_percpu.c</span>
<span class="p_header">+++ b/arch/x86/kernel/setup_percpu.c</span>
<span class="p_chunk">@@ -206,7 +206,7 @@</span> <span class="p_context"> void __init setup_per_cpu_areas(void)</span>
 					    pcpu_cpu_distance,
 					    pcpu_fc_alloc, pcpu_fc_free);
 		if (rc &lt; 0)
<span class="p_del">-			pr_warning(&quot;%s allocator failed (%d), falling back to page size\n&quot;,</span>
<span class="p_add">+			pr_warn(&quot;%s allocator failed (%d), falling back to page size\n&quot;,</span>
 				   pcpu_fc_names[pcpu_chosen_fc], rc);
 	}
 	if (rc &lt; 0)
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 24d57f7..f0907e4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -692,7 +692,7 @@</span> <span class="p_context"> void smp_announce(void)</span>
 {
 	int num_nodes = num_online_nodes();
 
<span class="p_del">-	printk(KERN_INFO &quot;x86: Booted up %d node%s, %d CPUs\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;x86: Booted up %d node%s, %d CPUs\n&quot;,</span>
 	       num_nodes, (num_nodes &gt; 1 ? &quot;s&quot; : &quot;&quot;), num_online_cpus());
 }
 
<span class="p_chunk">@@ -710,7 +710,7 @@</span> <span class="p_context"> static void announce_cpu(int cpu, int apicid)</span>
 		node_width = num_digits(num_possible_nodes()) + 1; /* + &#39;#&#39; */
 
 	if (cpu == 1)
<span class="p_del">-		printk(KERN_INFO &quot;x86: Booting SMP configuration:\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;x86: Booting SMP configuration:\n&quot;);</span>
 
 	if (system_state == SYSTEM_BOOTING) {
 		if (node != current_node) {
<span class="p_chunk">@@ -718,7 +718,7 @@</span> <span class="p_context"> static void announce_cpu(int cpu, int apicid)</span>
 				pr_cont(&quot;\n&quot;);
 			current_node = node;
 
<span class="p_del">-			printk(KERN_INFO &quot;.... node %*s#%d, CPUs:  &quot;,</span>
<span class="p_add">+			pr_info(&quot;.... node %*s#%d, CPUs:  &quot;,</span>
 			       node_width - num_digits(node), &quot; &quot;, node);
 		}
 
<span class="p_header">diff --git a/arch/x86/kernel/sysfb_efi.c b/arch/x86/kernel/sysfb_efi.c</span>
<span class="p_header">index b285d4e..38baf09 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sysfb_efi.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sysfb_efi.c</span>
<span class="p_chunk">@@ -142,10 +142,10 @@</span> <span class="p_context"> static int __init efifb_set_system(const struct dmi_system_id *id)</span>
 		return 0;
 	}
 
<span class="p_del">-	printk(KERN_INFO &quot;efifb: dmi detected %s - framebuffer at 0x%08x &quot;</span>
<span class="p_del">-			 &quot;(%dx%d, stride %d)\n&quot;, id-&gt;ident,</span>
<span class="p_del">-			 screen_info.lfb_base, screen_info.lfb_width,</span>
<span class="p_del">-			 screen_info.lfb_height, screen_info.lfb_linelength);</span>
<span class="p_add">+	pr_info(&quot;efifb: dmi detected %s - framebuffer at 0x%08x &quot;</span>
<span class="p_add">+		&quot;(%dx%d, stride %d)\n&quot;, id-&gt;ident,</span>
<span class="p_add">+		screen_info.lfb_base, screen_info.lfb_width,</span>
<span class="p_add">+		screen_info.lfb_height, screen_info.lfb_linelength);</span>
 
 	return 1;
 }
<span class="p_header">diff --git a/arch/x86/kernel/sysfb_simplefb.c b/arch/x86/kernel/sysfb_simplefb.c</span>
<span class="p_header">index 764a29f..c5b64cd 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sysfb_simplefb.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sysfb_simplefb.c</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> __init int create_simplefb(const struct screen_info *si,</span>
 	len = mode-&gt;height * mode-&gt;stride;
 	len = PAGE_ALIGN(len);
 	if (len &gt; (u64)si-&gt;lfb_size &lt;&lt; 16) {
<span class="p_del">-		printk(KERN_WARNING &quot;sysfb: VRAM smaller than advertised\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;sysfb: VRAM smaller than advertised\n&quot;);</span>
 		return -EINVAL;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/tboot.c b/arch/x86/kernel/tboot.c</span>
<span class="p_header">index 91a4496..27b0452 100644</span>
<span class="p_header">--- a/arch/x86/kernel/tboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/tboot.c</span>
<span class="p_chunk">@@ -70,13 +70,13 @@</span> <span class="p_context"> void __init tboot_probe(void)</span>
 	 */
 	if (!e820_any_mapped(boot_params.tboot_addr,
 			     boot_params.tboot_addr, E820_RESERVED)) {
<span class="p_del">-		pr_warning(&quot;non-0 tboot_addr but it is not of type E820_RESERVED\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;non-0 tboot_addr but it is not of type E820_RESERVED\n&quot;);</span>
 		return;
 	}
 
 	/* only a natively booted kernel should be using TXT */
 	if (paravirt_enabled()) {
<span class="p_del">-		pr_warning(&quot;non-0 tboot_addr but pv_ops is enabled\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;non-0 tboot_addr but pv_ops is enabled\n&quot;);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -84,13 +84,13 @@</span> <span class="p_context"> void __init tboot_probe(void)</span>
 	set_fixmap(FIX_TBOOT_BASE, boot_params.tboot_addr);
 	tboot = (struct tboot *)fix_to_virt(FIX_TBOOT_BASE);
 	if (memcmp(&amp;tboot_uuid, &amp;tboot-&gt;uuid, sizeof(tboot-&gt;uuid))) {
<span class="p_del">-		pr_warning(&quot;tboot at 0x%llx is invalid\n&quot;,</span>
<span class="p_add">+		pr_warn(&quot;tboot at 0x%llx is invalid\n&quot;,</span>
 			   boot_params.tboot_addr);
 		tboot = NULL;
 		return;
 	}
 	if (tboot-&gt;version &lt; 5) {
<span class="p_del">-		pr_warning(&quot;tboot version is invalid: %u\n&quot;, tboot-&gt;version);</span>
<span class="p_add">+		pr_warn(&quot;tboot version is invalid: %u\n&quot;, tboot-&gt;version);</span>
 		tboot = NULL;
 		return;
 	}
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> static int tboot_sleep(u8 sleep_state, u32 pm1a_control, u32 pm1b_control)</span>
 
 	if (sleep_state &gt;= ACPI_S_STATE_COUNT ||
 	    acpi_shutdown_map[sleep_state] == -1) {
<span class="p_del">-		pr_warning(&quot;unsupported sleep state 0x%x\n&quot;, sleep_state);</span>
<span class="p_add">+		pr_warn(&quot;unsupported sleep state 0x%x\n&quot;, sleep_state);</span>
 		return -1;
 	}
 
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> static int tboot_extended_sleep(u8 sleep_state, u32 val_a, u32 val_b)</span>
 	if (!tboot_enabled())
 		return 0;
 
<span class="p_del">-	pr_warning(&quot;tboot is not able to suspend on platforms with reduced hardware sleep (ACPIv5)&quot;);</span>
<span class="p_add">+	pr_warn(&quot;tboot is not able to suspend on platforms with reduced hardware sleep (ACPIv5)&quot;);</span>
 	return -ENODEV;
 }
 
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> static int tboot_wait_for_aps(int num_aps)</span>
 	}
 
 	if (timeout)
<span class="p_del">-		pr_warning(&quot;tboot wait for APs timeout\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;tboot wait for APs timeout\n&quot;);</span>
 
 	return !(atomic_read((atomic_t *)&amp;tboot-&gt;num_in_wfs) == num_aps);
 }
<span class="p_chunk">@@ -526,7 +526,7 @@</span> <span class="p_context"> int tboot_force_iommu(void)</span>
 		return 0;
 
 	if (no_iommu || swiotlb || dmar_disabled)
<span class="p_del">-		pr_warning(&quot;Forcing Intel-IOMMU to enabled\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;Forcing Intel-IOMMU to enabled\n&quot;);</span>
 
 	dmar_disabled = 0;
 #ifdef CONFIG_SWIOTLB
<span class="p_header">diff --git a/arch/x86/kernel/tce_64.c b/arch/x86/kernel/tce_64.c</span>
<span class="p_header">index ab40954..60c4a20 100644</span>
<span class="p_header">--- a/arch/x86/kernel/tce_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/tce_64.c</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static int tce_table_setparms(struct pci_dev *dev, struct iommu_table *tbl)</span>
 	bitmapsz = tbl-&gt;it_size / BITS_PER_BYTE;
 	bmppages = __get_free_pages(GFP_KERNEL, get_order(bitmapsz));
 	if (!bmppages) {
<span class="p_del">-		printk(KERN_ERR &quot;Calgary: cannot allocate bitmap\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;Calgary: cannot allocate bitmap\n&quot;);</span>
 		ret = -ENOMEM;
 		goto done;
 	}
<span class="p_chunk">@@ -138,14 +138,14 @@</span> <span class="p_context"> int __init build_tce_table(struct pci_dev *dev, void __iomem *bbar)</span>
 	int ret;
 
 	if (pci_iommu(dev-&gt;bus)) {
<span class="p_del">-		printk(KERN_ERR &quot;Calgary: dev %p has sysdata-&gt;iommu %p\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;Calgary: dev %p has sysdata-&gt;iommu %p\n&quot;,</span>
 		       dev, pci_iommu(dev-&gt;bus));
 		BUG();
 	}
 
 	tbl = kzalloc(sizeof(struct iommu_table), GFP_KERNEL);
 	if (!tbl) {
<span class="p_del">-		printk(KERN_ERR &quot;Calgary: error allocating iommu_table\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;Calgary: error allocating iommu_table\n&quot;);</span>
 		ret = -ENOMEM;
 		goto done;
 	}
<span class="p_header">diff --git a/arch/x86/kernel/test_nx.c b/arch/x86/kernel/test_nx.c</span>
<span class="p_header">index 3f92ce0..9bc948c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/test_nx.c</span>
<span class="p_header">+++ b/arch/x86/kernel/test_nx.c</span>
<span class="p_chunk">@@ -54,8 +54,8 @@</span> <span class="p_context"> static void fudze_exception_table(void *marker, void *new)</span>
 	 * table.
 	 */
 	if (mod-&gt;num_exentries &gt; 1) {
<span class="p_del">-		printk(KERN_ERR &quot;test_nx: too many exception table entries!\n&quot;);</span>
<span class="p_del">-		printk(KERN_ERR &quot;test_nx: test results are not reliable.\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;test_nx: too many exception table entries!\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;test_nx: test results are not reliable.\n&quot;);</span>
 		return;
 	}
 	extable = (struct exception_table_entry *)mod-&gt;extable;
<span class="p_chunk">@@ -115,11 +115,11 @@</span> <span class="p_context"> static int test_NX(void)</span>
 
 	test_data = 0xC3;
 
<span class="p_del">-	printk(KERN_INFO &quot;Testing NX protection\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;Testing NX protection\n&quot;);</span>
 
 	/* Test 1: check if the stack is not executable */
 	if (test_address(&amp;stackcode)) {
<span class="p_del">-		printk(KERN_ERR &quot;test_nx: stack was executable\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;test_nx: stack was executable\n&quot;);</span>
 		ret = -ENODEV;
 	}
 
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> static int test_NX(void)</span>
 	heap[0] = 0xC3; /* opcode for &quot;ret&quot; */
 
 	if (test_address(heap)) {
<span class="p_del">-		printk(KERN_ERR &quot;test_nx: heap was executable\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;test_nx: heap was executable\n&quot;);</span>
 		ret = -ENODEV;
 	}
 	kfree(heap);
<span class="p_chunk">@@ -145,10 +145,10 @@</span> <span class="p_context"> static int test_NX(void)</span>
 #ifdef CONFIG_DEBUG_RODATA
 	/* Test 3: Check if the .rodata section is executable */
 	if (rodata_test_data != 0xC3) {
<span class="p_del">-		printk(KERN_ERR &quot;test_nx: .rodata marker has invalid value\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;test_nx: .rodata marker has invalid value\n&quot;);</span>
 		ret = -ENODEV;
 	} else if (test_address(&amp;rodata_test_data)) {
<span class="p_del">-		printk(KERN_ERR &quot;test_nx: .rodata section is executable\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;test_nx: .rodata section is executable\n&quot;);</span>
 		ret = -ENODEV;
 	}
 #endif
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> static int test_NX(void)</span>
 #if 0
 	/* Test 4: Check if the .data section of a module is executable */
 	if (test_address(&amp;test_data)) {
<span class="p_del">-		printk(KERN_ERR &quot;test_nx: .data section is executable\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;test_nx: .data section is executable\n&quot;);</span>
 		ret = -ENODEV;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/test_rodata.c b/arch/x86/kernel/test_rodata.c</span>
<span class="p_header">index 5ecbfe5..e578b83 100644</span>
<span class="p_header">--- a/arch/x86/kernel/test_rodata.c</span>
<span class="p_header">+++ b/arch/x86/kernel/test_rodata.c</span>
<span class="p_chunk">@@ -22,7 +22,7 @@</span> <span class="p_context"> int rodata_test(void)</span>
 	/* test 1: read the value */
 	/* If this test fails, some previous testrun has clobbered the state */
 	if (!rodata_test_data) {
<span class="p_del">-		printk(KERN_ERR &quot;rodata_test: test 1 fails (start data)\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;rodata_test: test 1 fails (start data)\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_chunk">@@ -50,25 +50,25 @@</span> <span class="p_context"> int rodata_test(void)</span>
 
 
 	if (!result) {
<span class="p_del">-		printk(KERN_ERR &quot;rodata_test: test data was not read only\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;rodata_test: test data was not read only\n&quot;);</span>
 		return -ENODEV;
 	}
 
 	/* test 3: check the value hasn&#39;t changed */
 	/* If this test fails, we managed to overwrite the data */
 	if (!rodata_test_data) {
<span class="p_del">-		printk(KERN_ERR &quot;rodata_test: Test 3 fails (end data)\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;rodata_test: Test 3 fails (end data)\n&quot;);</span>
 		return -ENODEV;
 	}
 	/* test 4: check if the rodata section is 4Kb aligned */
 	start = (unsigned long)__start_rodata;
 	end = (unsigned long)__end_rodata;
 	if (start &amp; (PAGE_SIZE - 1)) {
<span class="p_del">-		printk(KERN_ERR &quot;rodata_test: .rodata is not 4k aligned\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;rodata_test: .rodata is not 4k aligned\n&quot;);</span>
 		return -ENODEV;
 	}
 	if (end &amp; (PAGE_SIZE - 1)) {
<span class="p_del">-		printk(KERN_ERR &quot;rodata_test: .rodata end is not 4k aligned\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;rodata_test: .rodata end is not 4k aligned\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/tsc_sync.c b/arch/x86/kernel/tsc_sync.c</span>
<span class="p_header">index 78083bf..8bb441c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/tsc_sync.c</span>
<span class="p_header">+++ b/arch/x86/kernel/tsc_sync.c</span>
<span class="p_chunk">@@ -156,10 +156,10 @@</span> <span class="p_context"> void check_tsc_sync_source(int cpu)</span>
 		cpu_relax();
 
 	if (nr_warps) {
<span class="p_del">-		pr_warning(&quot;TSC synchronization [CPU#%d -&gt; CPU#%d]:\n&quot;,</span>
<span class="p_add">+		pr_warn(&quot;TSC synchronization [CPU#%d -&gt; CPU#%d]:\n&quot;,</span>
 			smp_processor_id(), cpu);
<span class="p_del">-		pr_warning(&quot;Measured %Ld cycles TSC warp between CPUs, &quot;</span>
<span class="p_del">-			   &quot;turning off TSC clock.\n&quot;, max_warp);</span>
<span class="p_add">+		pr_warn(&quot;Measured %Ld cycles TSC warp between CPUs, &quot;</span>
<span class="p_add">+			&quot;turning off TSC clock.\n&quot;, max_warp);</span>
 		mark_tsc_unstable(&quot;check_tsc_sync_source failed&quot;);
 	} else {
 		pr_debug(&quot;TSC synchronization [CPU#%d -&gt; CPU#%d]: passed\n&quot;,
<span class="p_header">diff --git a/arch/x86/kernel/vsmp_64.c b/arch/x86/kernel/vsmp_64.c</span>
<span class="p_header">index b034b1b..f4b8927 100644</span>
<span class="p_header">--- a/arch/x86/kernel/vsmp_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/vsmp_64.c</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> static void __init set_vsmp_pv_ops(void)</span>
 	address = early_ioremap(cfg, 8);
 	cap = readl(address);
 	ctl = readl(address + 4);
<span class="p_del">-	printk(KERN_INFO &quot;vSMP CTL: capabilities:0x%08x  control:0x%08x\n&quot;,</span>
<span class="p_add">+	pr_info(&quot;vSMP CTL: capabilities:0x%08x  control:0x%08x\n&quot;,</span>
 	       cap, ctl);
 
 	/* If possible, let the vSMP foundation route the interrupt optimally */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



