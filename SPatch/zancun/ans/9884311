
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.41 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.41</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 7, 2017, 2:32 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170807023207.GB9256@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9884311/mbox/"
   >mbox</a>
|
   <a href="/patch/9884311/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9884311/">/patch/9884311/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	8A20060360 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  7 Aug 2017 02:32:47 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 61E3228249
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  7 Aug 2017 02:32:47 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 553C6283A5; Mon,  7 Aug 2017 02:32:47 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9DBB828249
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  7 Aug 2017 02:32:41 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751920AbdHGCcN (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 6 Aug 2017 22:32:13 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:36482 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751422AbdHGCcI (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 6 Aug 2017 22:32:08 -0400
Received: from localhost (c-73-158-54-216.hsd1.ca.comcast.net
	[73.158.54.216])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id C2008360;
	Mon,  7 Aug 2017 02:32:07 +0000 (UTC)
Date: Sun, 6 Aug 2017 19:32:07 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.41
Message-ID: &lt;20170807023207.GB9256@kroah.com&gt;
References: &lt;20170807023146.GA9256@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170807023146.GA9256@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 7, 2017, 2:32 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/input/tps65218-pwrbutton.txt b/Documentation/devicetree/bindings/input/tps65218-pwrbutton.txt</span>
<span class="p_header">index 3e5b9793341f..8682ab6d4a50 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/input/tps65218-pwrbutton.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/input/tps65218-pwrbutton.txt</span>
<span class="p_chunk">@@ -8,8 +8,9 @@</span> <span class="p_context"> This driver provides a simple power button event via an Interrupt.</span>
 Required properties:
 - compatible: should be &quot;ti,tps65217-pwrbutton&quot; or &quot;ti,tps65218-pwrbutton&quot;
 
<span class="p_del">-Required properties for TPS65218:</span>
<span class="p_add">+Required properties:</span>
 - interrupts: should be one of the following
<span class="p_add">+   - &lt;2&gt;: For controllers compatible with tps65217</span>
    - &lt;3 IRQ_TYPE_EDGE_BOTH&gt;: For controllers compatible with tps65218
 
 Examples:
<span class="p_chunk">@@ -17,6 +18,7 @@</span> <span class="p_context"> Examples:</span>
 &amp;tps {
 	tps65217-pwrbutton {
 		compatible = &quot;ti,tps65217-pwrbutton&quot;;
<span class="p_add">+		interrupts = &lt;2&gt;;</span>
 	};
 };
 
<span class="p_header">diff --git a/Documentation/devicetree/bindings/power/supply/tps65217_charger.txt b/Documentation/devicetree/bindings/power/supply/tps65217_charger.txt</span>
<span class="p_header">index 98d131acee95..a11072c5a866 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/power/supply/tps65217_charger.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/power/supply/tps65217_charger.txt</span>
<span class="p_chunk">@@ -2,11 +2,16 @@</span> <span class="p_context"> TPS65217 Charger</span>
 
 Required Properties:
 -compatible: &quot;ti,tps65217-charger&quot;
<span class="p_add">+-interrupts: TPS65217 interrupt numbers for the AC and USB charger input change.</span>
<span class="p_add">+             Should be &lt;0&gt; for the USB charger and &lt;1&gt; for the AC adapter.</span>
<span class="p_add">+-interrupt-names: Should be &quot;USB&quot; and &quot;AC&quot;</span>
 
 This node is a subnode of the tps65217 PMIC.
 
 Example:
 
 	tps65217-charger {
<span class="p_del">-		compatible = &quot;ti,tps65090-charger&quot;;</span>
<span class="p_add">+		compatible = &quot;ti,tps65217-charger&quot;;</span>
<span class="p_add">+		interrupts = &lt;0&gt;, &lt;1&gt;;</span>
<span class="p_add">+		interrupt-names = &quot;USB&quot;, &quot;AC&quot;;</span>
 	};
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index d9397a912c31..82eb3d1ee801 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 40</span>
<span class="p_add">+SUBLEVEL = 41</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arc/kernel/mcip.c b/arch/arc/kernel/mcip.c</span>
<span class="p_header">index f39142acc89e..be131b296a55 100644</span>
<span class="p_header">--- a/arch/arc/kernel/mcip.c</span>
<span class="p_header">+++ b/arch/arc/kernel/mcip.c</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/smp.h&gt;
 #include &lt;linux/irq.h&gt;
<span class="p_add">+#include &lt;linux/irqchip/chained_irq.h&gt;</span>
 #include &lt;linux/spinlock.h&gt;
 #include &lt;asm/irqflags-arcv2.h&gt;
 #include &lt;asm/mcip.h&gt;
<span class="p_chunk">@@ -221,10 +222,13 @@</span> <span class="p_context"> static irq_hw_number_t idu_first_hwirq;</span>
 static void idu_cascade_isr(struct irq_desc *desc)
 {
 	struct irq_domain *idu_domain = irq_desc_get_handler_data(desc);
<span class="p_add">+	struct irq_chip *core_chip = irq_desc_get_chip(desc);</span>
 	irq_hw_number_t core_hwirq = irqd_to_hwirq(irq_desc_get_irq_data(desc));
 	irq_hw_number_t idu_hwirq = core_hwirq - idu_first_hwirq;
 
<span class="p_add">+	chained_irq_enter(core_chip, desc);</span>
 	generic_handle_irq(irq_find_mapping(idu_domain, idu_hwirq));
<span class="p_add">+	chained_irq_exit(core_chip, desc);</span>
 }
 
 static int idu_irq_map(struct irq_domain *d, unsigned int virq, irq_hw_number_t hwirq)
<span class="p_header">diff --git a/arch/arm/boot/dts/am57xx-idk-common.dtsi b/arch/arm/boot/dts/am57xx-idk-common.dtsi</span>
<span class="p_header">index 03cec62260e1..db858fff4e18 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am57xx-idk-common.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am57xx-idk-common.dtsi</span>
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"></span>
 };
 
 &amp;usb2 {
<span class="p_del">-	dr_mode = &quot;otg&quot;;</span>
<span class="p_add">+	dr_mode = &quot;peripheral&quot;;</span>
 };
 
 &amp;mmc2 {
<span class="p_header">diff --git a/arch/arm/boot/dts/omap3-n900.dts b/arch/arm/boot/dts/omap3-n900.dts</span>
<span class="p_header">index 87ca50b53002..4d448f145ed1 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/omap3-n900.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/omap3-n900.dts</span>
<span class="p_chunk">@@ -734,6 +734,8 @@</span> <span class="p_context"></span>
 	vmmc_aux-supply = &lt;&amp;vsim&gt;;
 	bus-width = &lt;8&gt;;
 	non-removable;
<span class="p_add">+	no-sdio;</span>
<span class="p_add">+	no-sd;</span>
 };
 
 &amp;mmc3 {
<span class="p_header">diff --git a/arch/arm/configs/s3c2410_defconfig b/arch/arm/configs/s3c2410_defconfig</span>
<span class="p_header">index bc4bfe02e611..60d3fecd7a22 100644</span>
<span class="p_header">--- a/arch/arm/configs/s3c2410_defconfig</span>
<span class="p_header">+++ b/arch/arm/configs/s3c2410_defconfig</span>
<span class="p_chunk">@@ -86,9 +86,9 @@</span> <span class="p_context"> CONFIG_IPV6_TUNNEL=m</span>
 CONFIG_NETFILTER=y
 CONFIG_NF_CONNTRACK=m
 CONFIG_NF_CONNTRACK_EVENTS=y
<span class="p_del">-CONFIG_NF_CT_PROTO_DCCP=m</span>
<span class="p_del">-CONFIG_NF_CT_PROTO_SCTP=m</span>
<span class="p_del">-CONFIG_NF_CT_PROTO_UDPLITE=m</span>
<span class="p_add">+CONFIG_NF_CT_PROTO_DCCP=y</span>
<span class="p_add">+CONFIG_NF_CT_PROTO_SCTP=y</span>
<span class="p_add">+CONFIG_NF_CT_PROTO_UDPLITE=y</span>
 CONFIG_NF_CONNTRACK_AMANDA=m
 CONFIG_NF_CONNTRACK_FTP=m
 CONFIG_NF_CONNTRACK_H323=m
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">index 1052b29697b8..b5c1714ebfdd 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_chunk">@@ -790,14 +790,14 @@</span> <span class="p_context"> static int _init_main_clk(struct omap_hwmod *oh)</span>
 	int ret = 0;
 	char name[MOD_CLK_MAX_NAME_LEN];
 	struct clk *clk;
<span class="p_add">+	static const char modck[] = &quot;_mod_ck&quot;;</span>
 
<span class="p_del">-	/* +7 magic comes from &#39;_mod_ck&#39; suffix */</span>
<span class="p_del">-	if (strlen(oh-&gt;name) + 7 &gt; MOD_CLK_MAX_NAME_LEN)</span>
<span class="p_add">+	if (strlen(oh-&gt;name) &gt;= MOD_CLK_MAX_NAME_LEN - strlen(modck))</span>
 		pr_warn(&quot;%s: warning: cropping name for %s\n&quot;, __func__,
 			oh-&gt;name);
 
<span class="p_del">-	strncpy(name, oh-&gt;name, MOD_CLK_MAX_NAME_LEN - 7);</span>
<span class="p_del">-	strcat(name, &quot;_mod_ck&quot;);</span>
<span class="p_add">+	strlcpy(name, oh-&gt;name, MOD_CLK_MAX_NAME_LEN - strlen(modck));</span>
<span class="p_add">+	strlcat(name, modck, MOD_CLK_MAX_NAME_LEN);</span>
 
 	clk = clk_get(NULL, name);
 	if (!IS_ERR(clk)) {
<span class="p_header">diff --git a/arch/arm64/boot/dts/xilinx/zynqmp-ep108.dts b/arch/arm64/boot/dts/xilinx/zynqmp-ep108.dts</span>
<span class="p_header">index 358089687a69..ef1b9e573af0 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/xilinx/zynqmp-ep108.dts</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/xilinx/zynqmp-ep108.dts</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"></span>
 		stdout-path = &quot;serial0:115200n8&quot;;
 	};
 
<span class="p_del">-	memory {</span>
<span class="p_add">+	memory@0 {</span>
 		device_type = &quot;memory&quot;;
 		reg = &lt;0x0 0x0 0x0 0x40000000&gt;;
 	};
<span class="p_header">diff --git a/arch/arm64/boot/dts/xilinx/zynqmp.dtsi b/arch/arm64/boot/dts/xilinx/zynqmp.dtsi</span>
<span class="p_header">index 68a908334c7b..54dc28351c8c 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/xilinx/zynqmp.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/xilinx/zynqmp.dtsi</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"></span>
 			     &lt;1 10 0xf08&gt;;
 	};
 
<span class="p_del">-	amba_apu {</span>
<span class="p_add">+	amba_apu: amba_apu@0 {</span>
 		compatible = &quot;simple-bus&quot;;
 		#address-cells = &lt;2&gt;;
 		#size-cells = &lt;1&gt;;
<span class="p_chunk">@@ -175,7 +175,7 @@</span> <span class="p_context"></span>
 		};
 
 		i2c0: i2c@ff020000 {
<span class="p_del">-			compatible = &quot;cdns,i2c-r1p10&quot;;</span>
<span class="p_add">+			compatible = &quot;cdns,i2c-r1p14&quot;, &quot;cdns,i2c-r1p10&quot;;</span>
 			status = &quot;disabled&quot;;
 			interrupt-parent = &lt;&amp;gic&gt;;
 			interrupts = &lt;0 17 4&gt;;
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"></span>
 		};
 
 		i2c1: i2c@ff030000 {
<span class="p_del">-			compatible = &quot;cdns,i2c-r1p10&quot;;</span>
<span class="p_add">+			compatible = &quot;cdns,i2c-r1p14&quot;, &quot;cdns,i2c-r1p10&quot;;</span>
 			status = &quot;disabled&quot;;
 			interrupt-parent = &lt;&amp;gic&gt;;
 			interrupts = &lt;0 18 4&gt;;
<span class="p_header">diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c</span>
<span class="p_header">index 8b8ac3db4092..0e90c7e0279c 100644</span>
<span class="p_header">--- a/arch/arm64/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm64/mm/fault.c</span>
<span class="p_chunk">@@ -101,21 +101,21 @@</span> <span class="p_context"> void show_pte(struct mm_struct *mm, unsigned long addr)</span>
 			break;
 
 		pud = pud_offset(pgd, addr);
<span class="p_del">-		printk(&quot;, *pud=%016llx&quot;, pud_val(*pud));</span>
<span class="p_add">+		pr_cont(&quot;, *pud=%016llx&quot;, pud_val(*pud));</span>
 		if (pud_none(*pud) || pud_bad(*pud))
 			break;
 
 		pmd = pmd_offset(pud, addr);
<span class="p_del">-		printk(&quot;, *pmd=%016llx&quot;, pmd_val(*pmd));</span>
<span class="p_add">+		pr_cont(&quot;, *pmd=%016llx&quot;, pmd_val(*pmd));</span>
 		if (pmd_none(*pmd) || pmd_bad(*pmd))
 			break;
 
 		pte = pte_offset_map(pmd, addr);
<span class="p_del">-		printk(&quot;, *pte=%016llx&quot;, pte_val(*pte));</span>
<span class="p_add">+		pr_cont(&quot;, *pte=%016llx&quot;, pte_val(*pte));</span>
 		pte_unmap(pte);
 	} while(0);
 
<span class="p_del">-	printk(&quot;\n&quot;);</span>
<span class="p_add">+	pr_cont(&quot;\n&quot;);</span>
 }
 
 #ifdef CONFIG_ARM64_HW_AFDBM
<span class="p_header">diff --git a/arch/openrisc/kernel/vmlinux.lds.S b/arch/openrisc/kernel/vmlinux.lds.S</span>
<span class="p_header">index d68b9ede8423..c50609aead35 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/openrisc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -38,6 +38,8 @@</span> <span class="p_context"> SECTIONS</span>
         /* Read-only sections, merged into text segment: */
         . = LOAD_BASE ;
 
<span class="p_add">+	_text = .;</span>
<span class="p_add">+</span>
 	/* _s_kernel_ro must be page aligned */
 	. = ALIGN(PAGE_SIZE);
 	_s_kernel_ro = .;
<span class="p_header">diff --git a/arch/parisc/kernel/cache.c b/arch/parisc/kernel/cache.c</span>
<span class="p_header">index 53ec75f8e237..c721ea2fdbd8 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/cache.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/cache.c</span>
<span class="p_chunk">@@ -452,8 +452,8 @@</span> <span class="p_context"> void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,</span>
 	  before it can be accessed through the kernel mapping. */
 	preempt_disable();
 	flush_dcache_page_asm(__pa(vfrom), vaddr);
<span class="p_del">-	preempt_enable();</span>
 	copy_page_asm(vto, vfrom);
<span class="p_add">+	preempt_enable();</span>
 }
 EXPORT_SYMBOL(copy_user_page);
 
<span class="p_chunk">@@ -538,6 +538,10 @@</span> <span class="p_context"> void flush_cache_mm(struct mm_struct *mm)</span>
 	struct vm_area_struct *vma;
 	pgd_t *pgd;
 
<span class="p_add">+	/* Flush the TLB to avoid speculation if coherency is required. */</span>
<span class="p_add">+	if (parisc_requires_coherency())</span>
<span class="p_add">+		flush_tlb_all();</span>
<span class="p_add">+</span>
 	/* Flushing the whole cache on each cpu takes forever on
 	   rp3440, etc.  So, avoid it if the mm isn&#39;t too big.  */
 	if (mm_total_size(mm) &gt;= parisc_cache_flush_threshold) {
<span class="p_chunk">@@ -594,33 +598,22 @@</span> <span class="p_context"> flush_user_icache_range(unsigned long start, unsigned long end)</span>
 void flush_cache_range(struct vm_area_struct *vma,
 		unsigned long start, unsigned long end)
 {
<span class="p_del">-	unsigned long addr;</span>
<span class="p_del">-	pgd_t *pgd;</span>
<span class="p_del">-</span>
 	BUG_ON(!vma-&gt;vm_mm-&gt;context);
 
<span class="p_add">+	/* Flush the TLB to avoid speculation if coherency is required. */</span>
<span class="p_add">+	if (parisc_requires_coherency())</span>
<span class="p_add">+		flush_tlb_range(vma, start, end);</span>
<span class="p_add">+</span>
 	if ((end - start) &gt;= parisc_cache_flush_threshold) {
 		flush_cache_all();
 		return;
 	}
 
<span class="p_del">-	if (vma-&gt;vm_mm-&gt;context == mfsp(3)) {</span>
<span class="p_del">-		flush_user_dcache_range_asm(start, end);</span>
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_EXEC)</span>
<span class="p_del">-			flush_user_icache_range_asm(start, end);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	BUG_ON(vma-&gt;vm_mm-&gt;context != mfsp(3));</span>
 
<span class="p_del">-	pgd = vma-&gt;vm_mm-&gt;pgd;</span>
<span class="p_del">-	for (addr = start &amp; PAGE_MASK; addr &lt; end; addr += PAGE_SIZE) {</span>
<span class="p_del">-		unsigned long pfn;</span>
<span class="p_del">-		pte_t *ptep = get_ptep(pgd, addr);</span>
<span class="p_del">-		if (!ptep)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		pfn = pte_pfn(*ptep);</span>
<span class="p_del">-		if (pfn_valid(pfn))</span>
<span class="p_del">-			__flush_cache_page(vma, addr, PFN_PHYS(pfn));</span>
<span class="p_del">-	}</span>
<span class="p_add">+	flush_user_dcache_range_asm(start, end);</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_EXEC)</span>
<span class="p_add">+		flush_user_icache_range_asm(start, end);</span>
 }
 
 void
<span class="p_chunk">@@ -629,7 +622,8 @@</span> <span class="p_context"> flush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr, unsigned long</span>
 	BUG_ON(!vma-&gt;vm_mm-&gt;context);
 
 	if (pfn_valid(pfn)) {
<span class="p_del">-		flush_tlb_page(vma, vmaddr);</span>
<span class="p_add">+		if (parisc_requires_coherency())</span>
<span class="p_add">+			flush_tlb_page(vma, vmaddr);</span>
 		__flush_cache_page(vma, vmaddr, PFN_PHYS(pfn));
 	}
 }
<span class="p_header">diff --git a/arch/parisc/kernel/process.c b/arch/parisc/kernel/process.c</span>
<span class="p_header">index e7ffde2758fc..7593787ed4c3 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/process.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/process.c</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/random.h&gt;
<span class="p_add">+#include &lt;linux/nmi.h&gt;</span>
 
 #include &lt;asm/io.h&gt;
 #include &lt;asm/asm-offsets.h&gt;
<span class="p_chunk">@@ -142,6 +143,7 @@</span> <span class="p_context"> void machine_power_off(void)</span>
 
 	/* prevent soft lockup/stalled CPU messages for endless loop. */
 	rcu_sysrq_start();
<span class="p_add">+	lockup_detector_suspend();</span>
 	for (;;);
 }
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/topology.h b/arch/powerpc/include/asm/topology.h</span>
<span class="p_header">index 329771559cbb..8b3b46b7b0f2 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/topology.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/topology.h</span>
<span class="p_chunk">@@ -44,22 +44,8 @@</span> <span class="p_context"> extern void __init dump_numa_cpu_topology(void);</span>
 extern int sysfs_add_device_to_node(struct device *dev, int nid);
 extern void sysfs_remove_device_from_node(struct device *dev, int nid);
 
<span class="p_del">-static inline int early_cpu_to_node(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int nid;</span>
<span class="p_del">-</span>
<span class="p_del">-	nid = numa_cpu_lookup_table[cpu];</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Fall back to node 0 if nid is unset (it should be, except bugs).</span>
<span class="p_del">-	 * This allows callers to safely do NODE_DATA(early_cpu_to_node(cpu)).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return (nid &lt; 0) ? 0 : nid;</span>
<span class="p_del">-}</span>
 #else
 
<span class="p_del">-static inline int early_cpu_to_node(int cpu) { return 0; }</span>
<span class="p_del">-</span>
 static inline void dump_numa_cpu_topology(void) {}
 
 static inline int sysfs_add_device_to_node(struct device *dev, int nid)
<span class="p_header">diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c</span>
<span class="p_header">index ada71bee176d..a12be60181bf 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/setup_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/setup_64.c</span>
<span class="p_chunk">@@ -595,7 +595,7 @@</span> <span class="p_context"> void __init emergency_stack_init(void)</span>
 
 static void * __init pcpu_fc_alloc(unsigned int cpu, size_t size, size_t align)
 {
<span class="p_del">-	return __alloc_bootmem_node(NODE_DATA(early_cpu_to_node(cpu)), size, align,</span>
<span class="p_add">+	return __alloc_bootmem_node(NODE_DATA(cpu_to_node(cpu)), size, align,</span>
 				    __pa(MAX_DMA_ADDRESS));
 }
 
<span class="p_chunk">@@ -606,7 +606,7 @@</span> <span class="p_context"> static void __init pcpu_fc_free(void *ptr, size_t size)</span>
 
 static int pcpu_cpu_distance(unsigned int from, unsigned int to)
 {
<span class="p_del">-	if (early_cpu_to_node(from) == early_cpu_to_node(to))</span>
<span class="p_add">+	if (cpu_to_node(from) == cpu_to_node(to))</span>
 		return LOCAL_DISTANCE;
 	else
 		return REMOTE_DISTANCE;
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index 5c0298422300..218cba2f5699 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -2808,6 +2808,8 @@</span> <span class="p_context"> static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 	int r;
 	int srcu_idx;
 	unsigned long ebb_regs[3] = {};	/* shut up GCC */
<span class="p_add">+	unsigned long user_tar = 0;</span>
<span class="p_add">+	unsigned int user_vrsave;</span>
 
 	if (!vcpu-&gt;arch.sane) {
 		run-&gt;exit_reason = KVM_EXIT_INTERNAL_ERROR;
<span class="p_chunk">@@ -2828,6 +2830,8 @@</span> <span class="p_context"> static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 			run-&gt;fail_entry.hardware_entry_failure_reason = 0;
 			return -EINVAL;
 		}
<span class="p_add">+		/* Enable TM so we can read the TM SPRs */</span>
<span class="p_add">+		mtmsr(mfmsr() | MSR_TM);</span>
 		current-&gt;thread.tm_tfhar = mfspr(SPRN_TFHAR);
 		current-&gt;thread.tm_tfiar = mfspr(SPRN_TFIAR);
 		current-&gt;thread.tm_texasr = mfspr(SPRN_TEXASR);
<span class="p_chunk">@@ -2856,12 +2860,14 @@</span> <span class="p_context"> static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 
 	flush_all_to_thread(current);
 
<span class="p_del">-	/* Save userspace EBB register values */</span>
<span class="p_add">+	/* Save userspace EBB and other register values */</span>
 	if (cpu_has_feature(CPU_FTR_ARCH_207S)) {
 		ebb_regs[0] = mfspr(SPRN_EBBHR);
 		ebb_regs[1] = mfspr(SPRN_EBBRR);
 		ebb_regs[2] = mfspr(SPRN_BESCR);
<span class="p_add">+		user_tar = mfspr(SPRN_TAR);</span>
 	}
<span class="p_add">+	user_vrsave = mfspr(SPRN_VRSAVE);</span>
 
 	vcpu-&gt;arch.wqp = &amp;vcpu-&gt;arch.vcore-&gt;wq;
 	vcpu-&gt;arch.pgdir = current-&gt;mm-&gt;pgd;
<span class="p_chunk">@@ -2885,12 +2891,15 @@</span> <span class="p_context"> static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 			r = kvmppc_xics_rm_complete(vcpu, 0);
 	} while (is_kvmppc_resume_guest(r));
 
<span class="p_del">-	/* Restore userspace EBB register values */</span>
<span class="p_add">+	/* Restore userspace EBB and other register values */</span>
 	if (cpu_has_feature(CPU_FTR_ARCH_207S)) {
 		mtspr(SPRN_EBBHR, ebb_regs[0]);
 		mtspr(SPRN_EBBRR, ebb_regs[1]);
 		mtspr(SPRN_BESCR, ebb_regs[2]);
<span class="p_add">+		mtspr(SPRN_TAR, user_tar);</span>
<span class="p_add">+		mtspr(SPRN_FSCR, current-&gt;thread.fscr);</span>
 	}
<span class="p_add">+	mtspr(SPRN_VRSAVE, user_vrsave);</span>
 
  out:
 	vcpu-&gt;arch.state = KVMPPC_VCPU_NOTREADY;
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index 6f81adb112f1..0447a22a4df6 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -37,6 +37,13 @@</span> <span class="p_context"></span>
 #define NAPPING_CEDE	1
 #define NAPPING_NOVCPU	2
 
<span class="p_add">+/* Stack frame offsets for kvmppc_hv_entry */</span>
<span class="p_add">+#define SFS			112</span>
<span class="p_add">+#define STACK_SLOT_TRAP		(SFS-4)</span>
<span class="p_add">+#define STACK_SLOT_CIABR	(SFS-16)</span>
<span class="p_add">+#define STACK_SLOT_DAWR		(SFS-24)</span>
<span class="p_add">+#define STACK_SLOT_DAWRX	(SFS-32)</span>
<span class="p_add">+</span>
 /*
  * Call kvmppc_hv_entry in real mode.
  * Must be called with interrupts hard-disabled.
<span class="p_chunk">@@ -289,10 +296,10 @@</span> <span class="p_context"> kvm_novcpu_exit:</span>
 	bl	kvmhv_accumulate_time
 #endif
 13:	mr	r3, r12
<span class="p_del">-	stw	r12, 112-4(r1)</span>
<span class="p_add">+	stw	r12, STACK_SLOT_TRAP(r1)</span>
 	bl	kvmhv_commence_exit
 	nop
<span class="p_del">-	lwz	r12, 112-4(r1)</span>
<span class="p_add">+	lwz	r12, STACK_SLOT_TRAP(r1)</span>
 	b	kvmhv_switch_to_host
 
 /*
<span class="p_chunk">@@ -537,7 +544,7 @@</span> <span class="p_context"> kvmppc_hv_entry:</span>
 	 */
 	mflr	r0
 	std	r0, PPC_LR_STKOFF(r1)
<span class="p_del">-	stdu	r1, -112(r1)</span>
<span class="p_add">+	stdu	r1, -SFS(r1)</span>
 
 	/* Save R1 in the PACA */
 	std	r1, HSTATE_HOST_R1(r13)
<span class="p_chunk">@@ -698,6 +705,16 @@</span> <span class="p_context"> kvmppc_got_guest:</span>
 	mtspr	SPRN_PURR,r7
 	mtspr	SPRN_SPURR,r8
 
<span class="p_add">+	/* Save host values of some registers */</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	mfspr	r5, SPRN_CIABR</span>
<span class="p_add">+	mfspr	r6, SPRN_DAWR</span>
<span class="p_add">+	mfspr	r7, SPRN_DAWRX</span>
<span class="p_add">+	std	r5, STACK_SLOT_CIABR(r1)</span>
<span class="p_add">+	std	r6, STACK_SLOT_DAWR(r1)</span>
<span class="p_add">+	std	r7, STACK_SLOT_DAWRX(r1)</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
<span class="p_add">+</span>
 BEGIN_FTR_SECTION
 	/* Set partition DABR */
 	/* Do this before re-enabling PMU to avoid P7 DABR corruption bug */
<span class="p_chunk">@@ -1361,8 +1378,7 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)</span>
 	 */
 	li	r0, 0
 	mtspr	SPRN_IAMR, r0
<span class="p_del">-	mtspr	SPRN_CIABR, r0</span>
<span class="p_del">-	mtspr	SPRN_DAWRX, r0</span>
<span class="p_add">+	mtspr	SPRN_PSPB, r0</span>
 	mtspr	SPRN_TCSCR, r0
 	mtspr	SPRN_WORT, r0
 	/* Set MMCRS to 1&lt;&lt;31 to freeze and disable the SPMC counters */
<span class="p_chunk">@@ -1378,6 +1394,7 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)</span>
 	std	r6,VCPU_UAMOR(r9)
 	li	r6,0
 	mtspr	SPRN_AMR,r6
<span class="p_add">+	mtspr	SPRN_UAMOR, r6</span>
 
 	/* Switch DSCR back to host value */
 	mfspr	r8, SPRN_DSCR
<span class="p_chunk">@@ -1519,6 +1536,16 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
 	slbia
 	ptesync
 
<span class="p_add">+	/* Restore host values of some registers */</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	ld	r5, STACK_SLOT_CIABR(r1)</span>
<span class="p_add">+	ld	r6, STACK_SLOT_DAWR(r1)</span>
<span class="p_add">+	ld	r7, STACK_SLOT_DAWRX(r1)</span>
<span class="p_add">+	mtspr	SPRN_CIABR, r5</span>
<span class="p_add">+	mtspr	SPRN_DAWR, r6</span>
<span class="p_add">+	mtspr	SPRN_DAWRX, r7</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
<span class="p_add">+</span>
 	/*
 	 * POWER7/POWER8 guest -&gt; host partition switch code.
 	 * We don&#39;t have to lock against tlbies but we do
<span class="p_chunk">@@ -1652,8 +1679,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
 	li	r0, KVM_GUEST_MODE_NONE
 	stb	r0, HSTATE_IN_GUEST(r13)
 
<span class="p_del">-	ld	r0, 112+PPC_LR_STKOFF(r1)</span>
<span class="p_del">-	addi	r1, r1, 112</span>
<span class="p_add">+	ld	r0, SFS+PPC_LR_STKOFF(r1)</span>
<span class="p_add">+	addi	r1, r1, SFS</span>
 	mtlr	r0
 	blr
 
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/reconfig.c b/arch/powerpc/platforms/pseries/reconfig.c</span>
<span class="p_header">index cc66c49f07aa..666ad0611e63 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/reconfig.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/reconfig.c</span>
<span class="p_chunk">@@ -82,7 +82,6 @@</span> <span class="p_context"> static int pSeries_reconfig_remove_node(struct device_node *np)</span>
 
 	of_detach_node(np);
 	of_node_put(parent);
<span class="p_del">-	of_node_put(np); /* Must decrement the refcount */</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/x86/events/intel/cstate.c b/arch/x86/events/intel/cstate.c</span>
<span class="p_header">index fec8a461bdef..1076c9a77292 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/cstate.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/cstate.c</span>
<span class="p_chunk">@@ -434,6 +434,7 @@</span> <span class="p_context"> static struct pmu cstate_core_pmu = {</span>
 	.stop		= cstate_pmu_event_stop,
 	.read		= cstate_pmu_event_update,
 	.capabilities	= PERF_PMU_CAP_NO_INTERRUPT,
<span class="p_add">+	.module		= THIS_MODULE,</span>
 };
 
 static struct pmu cstate_pkg_pmu = {
<span class="p_chunk">@@ -447,6 +448,7 @@</span> <span class="p_context"> static struct pmu cstate_pkg_pmu = {</span>
 	.stop		= cstate_pmu_event_stop,
 	.read		= cstate_pmu_event_update,
 	.capabilities	= PERF_PMU_CAP_NO_INTERRUPT,
<span class="p_add">+	.module		= THIS_MODULE,</span>
 };
 
 static const struct cstate_model nhm_cstates __initconst = {
<span class="p_header">diff --git a/arch/x86/events/intel/rapl.c b/arch/x86/events/intel/rapl.c</span>
<span class="p_header">index 8b902b67342a..970c1de3b86e 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/rapl.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/rapl.c</span>
<span class="p_chunk">@@ -697,6 +697,7 @@</span> <span class="p_context"> static int __init init_rapl_pmus(void)</span>
 	rapl_pmus-&gt;pmu.start		= rapl_pmu_event_start;
 	rapl_pmus-&gt;pmu.stop		= rapl_pmu_event_stop;
 	rapl_pmus-&gt;pmu.read		= rapl_pmu_event_read;
<span class="p_add">+	rapl_pmus-&gt;pmu.module		= THIS_MODULE;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/x86/events/intel/uncore.c b/arch/x86/events/intel/uncore.c</span>
<span class="p_header">index 19d646a783fd..aec6cc925af8 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/uncore.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/uncore.c</span>
<span class="p_chunk">@@ -733,6 +733,7 @@</span> <span class="p_context"> static int uncore_pmu_register(struct intel_uncore_pmu *pmu)</span>
 			.start		= uncore_pmu_event_start,
 			.stop		= uncore_pmu_event_stop,
 			.read		= uncore_pmu_event_read,
<span class="p_add">+			.module		= THIS_MODULE,</span>
 		};
 	} else {
 		pmu-&gt;pmu = *pmu-&gt;type-&gt;pmu;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce_amd.c b/arch/x86/kernel/cpu/mcheck/mce_amd.c</span>
<span class="p_header">index 3dfca7b302dc..a5b47c1361a0 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c</span>
<span class="p_chunk">@@ -955,6 +955,9 @@</span> <span class="p_context"> static int threshold_create_bank(unsigned int cpu, unsigned int bank)</span>
 	const char *name = get_name(bank, NULL);
 	int err = 0;
 
<span class="p_add">+	if (!dev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	if (is_shared_bank(bank)) {
 		nb = node_to_amd_nb(amd_get_nb_id(cpu));
 
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_header">index dd6cfa4ad3ac..75029d0cfa15 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_chunk">@@ -15,7 +15,7 @@</span> <span class="p_context"> obj-$(subst m,y,$(CONFIG_INTEL_MID_POWER_BUTTON)) += platform_msic_power_btn.o</span>
 obj-$(subst m,y,$(CONFIG_GPIO_INTEL_PMIC)) += platform_pmic_gpio.o
 obj-$(subst m,y,$(CONFIG_INTEL_MFLD_THERMAL)) += platform_msic_thermal.o
 # SPI Devices
<span class="p_del">-obj-$(subst m,y,$(CONFIG_SPI_SPIDEV)) += platform_spidev.o</span>
<span class="p_add">+obj-$(subst m,y,$(CONFIG_SPI_SPIDEV)) += platform_mrfld_spidev.o</span>
 # I2C Devices
 obj-$(subst m,y,$(CONFIG_SENSORS_EMC1403)) += platform_emc1403.o
 obj-$(subst m,y,$(CONFIG_SENSORS_LIS3LV02D)) += platform_lis331.o
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfld_spidev.c b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_spidev.c</span>
new file mode 100644
<span class="p_header">index 000000000000..27186ad654c9</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_spidev.c</span>
<span class="p_chunk">@@ -0,0 +1,54 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * spidev platform data initilization file</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (C) Copyright 2014, 2016 Intel Corporation</span>
<span class="p_add">+ * Authors: Andy Shevchenko &lt;andriy.shevchenko@linux.intel.com&gt;</span>
<span class="p_add">+ *	    Dan O&#39;Donovan &lt;dan@emutex.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ * modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ * as published by the Free Software Foundation; version 2</span>
<span class="p_add">+ * of the License.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/sfi.h&gt;</span>
<span class="p_add">+#include &lt;linux/spi/pxa2xx_spi.h&gt;</span>
<span class="p_add">+#include &lt;linux/spi/spi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/intel-mid.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define MRFLD_SPI_DEFAULT_DMA_BURST	8</span>
<span class="p_add">+#define MRFLD_SPI_DEFAULT_TIMEOUT	500</span>
<span class="p_add">+</span>
<span class="p_add">+/* GPIO pin for spidev chipselect */</span>
<span class="p_add">+#define MRFLD_SPIDEV_GPIO_CS		111</span>
<span class="p_add">+</span>
<span class="p_add">+static struct pxa2xx_spi_chip spidev_spi_chip = {</span>
<span class="p_add">+	.dma_burst_size		= MRFLD_SPI_DEFAULT_DMA_BURST,</span>
<span class="p_add">+	.timeout		= MRFLD_SPI_DEFAULT_TIMEOUT,</span>
<span class="p_add">+	.gpio_cs		= MRFLD_SPIDEV_GPIO_CS,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init *spidev_platform_data(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct spi_board_info *spi_info = info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_TANGIER)</span>
<span class="p_add">+		return ERR_PTR(-ENODEV);</span>
<span class="p_add">+</span>
<span class="p_add">+	spi_info-&gt;mode = SPI_MODE_0;</span>
<span class="p_add">+	spi_info-&gt;controller_data = &amp;spidev_spi_chip;</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct devs_id spidev_dev_id __initconst = {</span>
<span class="p_add">+	.name			= &quot;spidev&quot;,</span>
<span class="p_add">+	.type			= SFI_DEV_TYPE_SPI,</span>
<span class="p_add">+	.delay			= 0,</span>
<span class="p_add">+	.get_platform_data	= &amp;spidev_platform_data,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+sfi_device(spidev_dev_id);</span>
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_spidev.c b/arch/x86/platform/intel-mid/device_libs/platform_spidev.c</span>
deleted file mode 100644
<span class="p_header">index 30c601b399ee..000000000000</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_spidev.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,50 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * spidev platform data initilization file</span>
<span class="p_del">- *</span>
<span class="p_del">- * (C) Copyright 2014, 2016 Intel Corporation</span>
<span class="p_del">- * Authors: Andy Shevchenko &lt;andriy.shevchenko@linux.intel.com&gt;</span>
<span class="p_del">- *	    Dan O&#39;Donovan &lt;dan@emutex.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or</span>
<span class="p_del">- * modify it under the terms of the GNU General Public License</span>
<span class="p_del">- * as published by the Free Software Foundation; version 2</span>
<span class="p_del">- * of the License.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/init.h&gt;</span>
<span class="p_del">-#include &lt;linux/sfi.h&gt;</span>
<span class="p_del">-#include &lt;linux/spi/pxa2xx_spi.h&gt;</span>
<span class="p_del">-#include &lt;linux/spi/spi.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/intel-mid.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#define MRFLD_SPI_DEFAULT_DMA_BURST	8</span>
<span class="p_del">-#define MRFLD_SPI_DEFAULT_TIMEOUT	500</span>
<span class="p_del">-</span>
<span class="p_del">-/* GPIO pin for spidev chipselect */</span>
<span class="p_del">-#define MRFLD_SPIDEV_GPIO_CS		111</span>
<span class="p_del">-</span>
<span class="p_del">-static struct pxa2xx_spi_chip spidev_spi_chip = {</span>
<span class="p_del">-	.dma_burst_size		= MRFLD_SPI_DEFAULT_DMA_BURST,</span>
<span class="p_del">-	.timeout		= MRFLD_SPI_DEFAULT_TIMEOUT,</span>
<span class="p_del">-	.gpio_cs		= MRFLD_SPIDEV_GPIO_CS,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init *spidev_platform_data(void *info)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct spi_board_info *spi_info = info;</span>
<span class="p_del">-</span>
<span class="p_del">-	spi_info-&gt;mode = SPI_MODE_0;</span>
<span class="p_del">-	spi_info-&gt;controller_data = &amp;spidev_spi_chip;</span>
<span class="p_del">-</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static const struct devs_id spidev_dev_id __initconst = {</span>
<span class="p_del">-	.name			= &quot;spidev&quot;,</span>
<span class="p_del">-	.type			= SFI_DEV_TYPE_SPI,</span>
<span class="p_del">-	.delay			= 0,</span>
<span class="p_del">-	.get_platform_data	= &amp;spidev_platform_data,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-sfi_device(spidev_dev_id);</span>
<span class="p_header">diff --git a/crypto/authencesn.c b/crypto/authencesn.c</span>
<span class="p_header">index 121010ac9962..18c94e1c31d1 100644</span>
<span class="p_header">--- a/crypto/authencesn.c</span>
<span class="p_header">+++ b/crypto/authencesn.c</span>
<span class="p_chunk">@@ -248,6 +248,9 @@</span> <span class="p_context"> static int crypto_authenc_esn_decrypt_tail(struct aead_request *req,</span>
 	u8 *ihash = ohash + crypto_ahash_digestsize(auth);
 	u32 tmp[2];
 
<span class="p_add">+	if (!authsize)</span>
<span class="p_add">+		goto decrypt;</span>
<span class="p_add">+</span>
 	/* Move high-order bits of sequence number back. */
 	scatterwalk_map_and_copy(tmp, dst, 4, 4, 0);
 	scatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 0);
<span class="p_chunk">@@ -256,6 +259,8 @@</span> <span class="p_context"> static int crypto_authenc_esn_decrypt_tail(struct aead_request *req,</span>
 	if (crypto_memneq(ihash, ohash, authsize))
 		return -EBADMSG;
 
<span class="p_add">+decrypt:</span>
<span class="p_add">+</span>
 	sg_init_table(areq_ctx-&gt;dst, 2);
 	dst = scatterwalk_ffwd(areq_ctx-&gt;dst, dst, assoclen);
 
<span class="p_header">diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c</span>
<span class="p_header">index 5ea5dc219f56..73c9c7fa9001 100644</span>
<span class="p_header">--- a/drivers/acpi/glue.c</span>
<span class="p_header">+++ b/drivers/acpi/glue.c</span>
<span class="p_chunk">@@ -98,7 +98,15 @@</span> <span class="p_context"> static int find_child_checks(struct acpi_device *adev, bool check_children)</span>
 	if (check_children &amp;&amp; list_empty(&amp;adev-&gt;children))
 		return -ENODEV;
 
<span class="p_del">-	return sta_present ? FIND_CHILD_MAX_SCORE : FIND_CHILD_MIN_SCORE;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the device has a _HID (or _CID) returning a valid ACPI/PNP</span>
<span class="p_add">+	 * device ID, it is better to make it look less attractive here, so that</span>
<span class="p_add">+	 * the other device with the same _ADR value (that may not have a valid</span>
<span class="p_add">+	 * device ID) can be matched going forward.  [This means a second spec</span>
<span class="p_add">+	 * violation in a row, so whatever we do here is best effort anyway.]</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return sta_present &amp;&amp; list_empty(&amp;adev-&gt;pnp.ids) ?</span>
<span class="p_add">+			FIND_CHILD_MAX_SCORE : FIND_CHILD_MIN_SCORE;</span>
 }
 
 struct acpi_device *acpi_find_child_device(struct acpi_device *parent,
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_watchdog.c b/drivers/char/ipmi/ipmi_watchdog.c</span>
<span class="p_header">index 4facc7517a6a..909311016108 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_watchdog.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_watchdog.c</span>
<span class="p_chunk">@@ -1162,10 +1162,11 @@</span> <span class="p_context"> static int wdog_reboot_handler(struct notifier_block *this,</span>
 			ipmi_watchdog_state = WDOG_TIMEOUT_NONE;
 			ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);
 		} else if (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {
<span class="p_del">-			/* Set a long timer to let the reboot happens, but</span>
<span class="p_del">-			   reboot if it hangs, but only if the watchdog</span>
<span class="p_add">+			/* Set a long timer to let the reboot happen or</span>
<span class="p_add">+			   reset if it hangs, but only if the watchdog</span>
 			   timer was already running. */
<span class="p_del">-			timeout = 120;</span>
<span class="p_add">+			if (timeout &lt; 120)</span>
<span class="p_add">+				timeout = 120;</span>
 			pretimeout = 0;
 			ipmi_watchdog_state = WDOG_TIMEOUT_RESET;
 			ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);
<span class="p_header">diff --git a/drivers/dax/dax.c b/drivers/dax/dax.c</span>
<span class="p_header">index 586f9543de73..40be3747724d 100644</span>
<span class="p_header">--- a/drivers/dax/dax.c</span>
<span class="p_header">+++ b/drivers/dax/dax.c</span>
<span class="p_chunk">@@ -546,7 +546,8 @@</span> <span class="p_context"> static void dax_dev_release(struct device *dev)</span>
 	struct dax_dev *dax_dev = to_dax_dev(dev);
 	struct dax_region *dax_region = dax_dev-&gt;region;
 
<span class="p_del">-	ida_simple_remove(&amp;dax_region-&gt;ida, dax_dev-&gt;id);</span>
<span class="p_add">+	if (dax_dev-&gt;id &gt;= 0)</span>
<span class="p_add">+		ida_simple_remove(&amp;dax_region-&gt;ida, dax_dev-&gt;id);</span>
 	ida_simple_remove(&amp;dax_minor_ida, MINOR(dev-&gt;devt));
 	dax_region_put(dax_region);
 	iput(dax_dev-&gt;inode);
<span class="p_chunk">@@ -581,7 +582,7 @@</span> <span class="p_context"> static void unregister_dax_dev(void *dev)</span>
 }
 
 struct dax_dev *devm_create_dax_dev(struct dax_region *dax_region,
<span class="p_del">-		struct resource *res, int count)</span>
<span class="p_add">+		int id, struct resource *res, int count)</span>
 {
 	struct device *parent = dax_region-&gt;dev;
 	struct dax_dev *dax_dev;
<span class="p_chunk">@@ -608,10 +609,16 @@</span> <span class="p_context"> struct dax_dev *devm_create_dax_dev(struct dax_region *dax_region,</span>
 	if (i &lt; count)
 		goto err_id;
 
<span class="p_del">-	dax_dev-&gt;id = ida_simple_get(&amp;dax_region-&gt;ida, 0, 0, GFP_KERNEL);</span>
<span class="p_del">-	if (dax_dev-&gt;id &lt; 0) {</span>
<span class="p_del">-		rc = dax_dev-&gt;id;</span>
<span class="p_del">-		goto err_id;</span>
<span class="p_add">+	if (id &lt; 0) {</span>
<span class="p_add">+		id = ida_simple_get(&amp;dax_region-&gt;ida, 0, 0, GFP_KERNEL);</span>
<span class="p_add">+		dax_dev-&gt;id = id;</span>
<span class="p_add">+		if (id &lt; 0) {</span>
<span class="p_add">+			rc = id;</span>
<span class="p_add">+			goto err_id;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* region provider owns @id lifetime */</span>
<span class="p_add">+		dax_dev-&gt;id = -1;</span>
 	}
 
 	minor = ida_simple_get(&amp;dax_minor_ida, 0, 0, GFP_KERNEL);
<span class="p_chunk">@@ -650,7 +657,7 @@</span> <span class="p_context"> struct dax_dev *devm_create_dax_dev(struct dax_region *dax_region,</span>
 	dev-&gt;parent = parent;
 	dev-&gt;groups = dax_attribute_groups;
 	dev-&gt;release = dax_dev_release;
<span class="p_del">-	dev_set_name(dev, &quot;dax%d.%d&quot;, dax_region-&gt;id, dax_dev-&gt;id);</span>
<span class="p_add">+	dev_set_name(dev, &quot;dax%d.%d&quot;, dax_region-&gt;id, id);</span>
 	rc = device_add(dev);
 	if (rc) {
 		kill_dax_dev(dax_dev);
<span class="p_chunk">@@ -669,7 +676,8 @@</span> <span class="p_context"> struct dax_dev *devm_create_dax_dev(struct dax_region *dax_region,</span>
  err_inode:
 	ida_simple_remove(&amp;dax_minor_ida, minor);
  err_minor:
<span class="p_del">-	ida_simple_remove(&amp;dax_region-&gt;ida, dax_dev-&gt;id);</span>
<span class="p_add">+	if (dax_dev-&gt;id &gt;= 0)</span>
<span class="p_add">+		ida_simple_remove(&amp;dax_region-&gt;ida, dax_dev-&gt;id);</span>
  err_id:
 	kfree(dax_dev);
 
<span class="p_header">diff --git a/drivers/dax/dax.h b/drivers/dax/dax.h</span>
<span class="p_header">index ddd829ab58c0..b5ed85036b2a 100644</span>
<span class="p_header">--- a/drivers/dax/dax.h</span>
<span class="p_header">+++ b/drivers/dax/dax.h</span>
<span class="p_chunk">@@ -21,5 +21,5 @@</span> <span class="p_context"> struct dax_region *alloc_dax_region(struct device *parent,</span>
 		int region_id, struct resource *res, unsigned int align,
 		void *addr, unsigned long flags);
 struct dax_dev *devm_create_dax_dev(struct dax_region *dax_region,
<span class="p_del">-		struct resource *res, int count);</span>
<span class="p_add">+		int id, struct resource *res, int count);</span>
 #endif /* __DAX_H__ */
<span class="p_header">diff --git a/drivers/dax/pmem.c b/drivers/dax/pmem.c</span>
<span class="p_header">index 73c6ce93a0d9..eebb35720398 100644</span>
<span class="p_header">--- a/drivers/dax/pmem.c</span>
<span class="p_header">+++ b/drivers/dax/pmem.c</span>
<span class="p_chunk">@@ -58,13 +58,12 @@</span> <span class="p_context"> static void dax_pmem_percpu_kill(void *data)</span>
 
 static int dax_pmem_probe(struct device *dev)
 {
<span class="p_del">-	int rc;</span>
 	void *addr;
 	struct resource res;
 	struct dax_dev *dax_dev;
<span class="p_add">+	int rc, id, region_id;</span>
 	struct nd_pfn_sb *pfn_sb;
 	struct dax_pmem *dax_pmem;
<span class="p_del">-	struct nd_region *nd_region;</span>
 	struct nd_namespace_io *nsio;
 	struct dax_region *dax_region;
 	struct nd_namespace_common *ndns;
<span class="p_chunk">@@ -122,14 +121,17 @@</span> <span class="p_context"> static int dax_pmem_probe(struct device *dev)</span>
 	/* adjust the dax_region resource to the start of data */
 	res.start += le64_to_cpu(pfn_sb-&gt;dataoff);
 
<span class="p_del">-	nd_region = to_nd_region(dev-&gt;parent);</span>
<span class="p_del">-	dax_region = alloc_dax_region(dev, nd_region-&gt;id, &amp;res,</span>
<span class="p_add">+	rc = sscanf(dev_name(&amp;ndns-&gt;dev), &quot;namespace%d.%d&quot;, &amp;region_id, &amp;id);</span>
<span class="p_add">+	if (rc != 2)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	dax_region = alloc_dax_region(dev, region_id, &amp;res,</span>
 			le32_to_cpu(pfn_sb-&gt;align), addr, PFN_DEV|PFN_MAP);
 	if (!dax_region)
 		return -ENOMEM;
 
 	/* TODO: support for subdividing a dax region... */
<span class="p_del">-	dax_dev = devm_create_dax_dev(dax_region, &amp;res, 1);</span>
<span class="p_add">+	dax_dev = devm_create_dax_dev(dax_region, id, &amp;res, 1);</span>
 
 	/* child dax_dev instances now own the lifetime of the dax_region */
 	dax_region_put(dax_region);
<span class="p_header">diff --git a/drivers/dma/ioat/hw.h b/drivers/dma/ioat/hw.h</span>
<span class="p_header">index 8e67895bcca3..abcc51b343ce 100644</span>
<span class="p_header">--- a/drivers/dma/ioat/hw.h</span>
<span class="p_header">+++ b/drivers/dma/ioat/hw.h</span>
<span class="p_chunk">@@ -64,6 +64,8 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_IOAT_BDX8	0x6f2e
 #define PCI_DEVICE_ID_INTEL_IOAT_BDX9	0x6f2f
 
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_IOAT_SKX	0x2021</span>
<span class="p_add">+</span>
 #define IOAT_VER_1_2            0x12    /* Version 1.2 */
 #define IOAT_VER_2_0            0x20    /* Version 2.0 */
 #define IOAT_VER_3_0            0x30    /* Version 3.0 */
<span class="p_header">diff --git a/drivers/dma/ioat/init.c b/drivers/dma/ioat/init.c</span>
<span class="p_header">index d235fbe2564f..0dea6d55f0ff 100644</span>
<span class="p_header">--- a/drivers/dma/ioat/init.c</span>
<span class="p_header">+++ b/drivers/dma/ioat/init.c</span>
<span class="p_chunk">@@ -106,6 +106,8 @@</span> <span class="p_context"> static struct pci_device_id ioat_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX8) },
 	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BDX9) },
 
<span class="p_add">+	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_SKX) },</span>
<span class="p_add">+</span>
 	/* I/OAT v3.3 platforms */
 	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BWD0) },
 	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_IOAT_BWD1) },
<span class="p_chunk">@@ -243,10 +245,15 @@</span> <span class="p_context"> static bool is_bdx_ioat(struct pci_dev *pdev)</span>
 	}
 }
 
<span class="p_add">+static inline bool is_skx_ioat(struct pci_dev *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (pdev-&gt;device == PCI_DEVICE_ID_INTEL_IOAT_SKX) ? true : false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool is_xeon_cb32(struct pci_dev *pdev)
 {
 	return is_jf_ioat(pdev) || is_snb_ioat(pdev) || is_ivb_ioat(pdev) ||
<span class="p_del">-		is_hsw_ioat(pdev) || is_bdx_ioat(pdev);</span>
<span class="p_add">+		is_hsw_ioat(pdev) || is_bdx_ioat(pdev) || is_skx_ioat(pdev);</span>
 }
 
 bool is_bwd_ioat(struct pci_dev *pdev)
<span class="p_chunk">@@ -1350,6 +1357,8 @@</span> <span class="p_context"> static int ioat_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 
 	device-&gt;version = readb(device-&gt;reg_base + IOAT_VER_OFFSET);
 	if (device-&gt;version &gt;= IOAT_VER_3_0) {
<span class="p_add">+		if (is_skx_ioat(pdev))</span>
<span class="p_add">+			device-&gt;version = IOAT_VER_3_2;</span>
 		err = ioat3_dma_probe(device, ioat_dca_enabled);
 
 		if (device-&gt;version &gt;= IOAT_VER_3_3)
<span class="p_header">diff --git a/drivers/dma/ti-dma-crossbar.c b/drivers/dma/ti-dma-crossbar.c</span>
<span class="p_header">index 3f24aeb48c0e..2403475a37cf 100644</span>
<span class="p_header">--- a/drivers/dma/ti-dma-crossbar.c</span>
<span class="p_header">+++ b/drivers/dma/ti-dma-crossbar.c</span>
<span class="p_chunk">@@ -149,6 +149,7 @@</span> <span class="p_context"> static int ti_am335x_xbar_probe(struct platform_device *pdev)</span>
 	match = of_match_node(ti_am335x_master_match, dma_node);
 	if (!match) {
 		dev_err(&amp;pdev-&gt;dev, &quot;DMA master is not supported\n&quot;);
<span class="p_add">+		of_node_put(dma_node);</span>
 		return -EINVAL;
 	}
 
<span class="p_chunk">@@ -339,6 +340,7 @@</span> <span class="p_context"> static int ti_dra7_xbar_probe(struct platform_device *pdev)</span>
 	match = of_match_node(ti_dra7_master_match, dma_node);
 	if (!match) {
 		dev_err(&amp;pdev-&gt;dev, &quot;DMA master is not supported\n&quot;);
<span class="p_add">+		of_node_put(dma_node);</span>
 		return -EINVAL;
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/msm/adreno/adreno_gpu.c b/drivers/gpu/drm/msm/adreno/adreno_gpu.c</span>
<span class="p_header">index f386f463278d..a904082ed206 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/adreno/adreno_gpu.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/adreno/adreno_gpu.c</span>
<span class="p_chunk">@@ -210,7 +210,14 @@</span> <span class="p_context"> void adreno_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,</span>
 void adreno_flush(struct msm_gpu *gpu)
 {
 	struct adreno_gpu *adreno_gpu = to_adreno_gpu(gpu);
<span class="p_del">-	uint32_t wptr = get_wptr(gpu-&gt;rb);</span>
<span class="p_add">+	uint32_t wptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Mask wptr value that we calculate to fit in the HW range. This is</span>
<span class="p_add">+	 * to account for the possibility that the last command fit exactly into</span>
<span class="p_add">+	 * the ringbuffer and rb-&gt;next hasn&#39;t wrapped to zero yet</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	wptr = get_wptr(gpu-&gt;rb) &amp; ((gpu-&gt;rb-&gt;size / 4) - 1);</span>
 
 	/* ensure writes to ringbuffer have hit system memory: */
 	mb();
<span class="p_header">diff --git a/drivers/gpu/drm/msm/msm_gem_submit.c b/drivers/gpu/drm/msm/msm_gem_submit.c</span>
<span class="p_header">index b6a0f37a65f3..393973016b52 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/msm_gem_submit.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/msm_gem_submit.c</span>
<span class="p_chunk">@@ -106,7 +106,8 @@</span> <span class="p_context"> static int submit_lookup_objects(struct msm_gem_submit *submit,</span>
 			pagefault_disable();
 		}
 
<span class="p_del">-		if (submit_bo.flags &amp; ~MSM_SUBMIT_BO_FLAGS) {</span>
<span class="p_add">+		if ((submit_bo.flags &amp; ~MSM_SUBMIT_BO_FLAGS) ||</span>
<span class="p_add">+			!(submit_bo.flags &amp; MSM_SUBMIT_BO_FLAGS)) {</span>
 			DRM_ERROR(&quot;invalid flags: %x\n&quot;, submit_bo.flags);
 			ret = -EINVAL;
 			goto out_unlock;
<span class="p_chunk">@@ -290,7 +291,7 @@</span> <span class="p_context"> static int submit_reloc(struct msm_gem_submit *submit, struct msm_gem_object *ob</span>
 {
 	uint32_t i, last_offset = 0;
 	uint32_t *ptr;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	if (offset % 4) {
 		DRM_ERROR(&quot;non-aligned cmdstream buffer: %u\n&quot;, offset);
<span class="p_chunk">@@ -317,12 +318,13 @@</span> <span class="p_context"> static int submit_reloc(struct msm_gem_submit *submit, struct msm_gem_object *ob</span>
 
 		ret = copy_from_user(&amp;submit_reloc, userptr, sizeof(submit_reloc));
 		if (ret)
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+			goto out;</span>
 
 		if (submit_reloc.submit_offset % 4) {
 			DRM_ERROR(&quot;non-aligned reloc offset: %u\n&quot;,
 					submit_reloc.submit_offset);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		/* offset in dwords: */
<span class="p_chunk">@@ -331,12 +333,13 @@</span> <span class="p_context"> static int submit_reloc(struct msm_gem_submit *submit, struct msm_gem_object *ob</span>
 		if ((off &gt;= (obj-&gt;base.size / 4)) ||
 				(off &lt; last_offset)) {
 			DRM_ERROR(&quot;invalid offset %u at reloc %u\n&quot;, off, i);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		ret = submit_bo(submit, submit_reloc.reloc_idx, NULL, &amp;iova, &amp;valid);
 		if (ret)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out;</span>
 
 		if (valid)
 			continue;
<span class="p_chunk">@@ -353,9 +356,10 @@</span> <span class="p_context"> static int submit_reloc(struct msm_gem_submit *submit, struct msm_gem_object *ob</span>
 		last_offset = off;
 	}
 
<span class="p_add">+out:</span>
 	msm_gem_put_vaddr_locked(&amp;obj-&gt;base);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void submit_cleanup(struct msm_gem_submit *submit)
<span class="p_header">diff --git a/drivers/gpu/drm/msm/msm_ringbuffer.c b/drivers/gpu/drm/msm/msm_ringbuffer.c</span>
<span class="p_header">index f326cf6a32e6..67b34e069abf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/msm_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/msm_ringbuffer.c</span>
<span class="p_chunk">@@ -23,7 +23,8 @@</span> <span class="p_context"> struct msm_ringbuffer *msm_ringbuffer_new(struct msm_gpu *gpu, int size)</span>
 	struct msm_ringbuffer *ring;
 	int ret;
 
<span class="p_del">-	size = ALIGN(size, 4);   /* size should be dword aligned */</span>
<span class="p_add">+	if (WARN_ON(!is_power_of_2(size)))</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
 
 	ring = kzalloc(sizeof(*ring), GFP_KERNEL);
 	if (!ring) {
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h</span>
<span class="p_header">index 1e1de6bfe85a..5893be9788d3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"> struct nv50_disp {</span>
 		u8 type[3];
 	} pior;
 
<span class="p_del">-	struct nv50_disp_chan *chan[17];</span>
<span class="p_add">+	struct nv50_disp_chan *chan[21];</span>
 };
 
 int nv50_disp_root_scanoutpos(NV50_DISP_MTHD_V0);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c</span>
<span class="p_header">index c794b2c2d21e..6d8f21290aa2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c</span>
<span class="p_chunk">@@ -129,7 +129,7 @@</span> <span class="p_context"> gf100_bar_init(struct nvkm_bar *base)</span>
 
 	if (bar-&gt;bar[0].mem) {
 		addr = nvkm_memory_addr(bar-&gt;bar[0].mem) &gt;&gt; 12;
<span class="p_del">-		nvkm_wr32(device, 0x001714, 0xc0000000 | addr);</span>
<span class="p_add">+		nvkm_wr32(device, 0x001714, 0x80000000 | addr);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.c b/drivers/gpu/drm/rcar-du/rcar_du_drv.c</span>
<span class="p_header">index 73c971e39b1c..ae125d070212 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.c</span>
<span class="p_chunk">@@ -285,7 +285,6 @@</span> <span class="p_context"> static int rcar_du_remove(struct platform_device *pdev)</span>
 
 	drm_kms_helper_poll_fini(ddev);
 	drm_mode_config_cleanup(ddev);
<span class="p_del">-	drm_vblank_cleanup(ddev);</span>
 
 	drm_dev_unref(ddev);
 
<span class="p_chunk">@@ -305,7 +304,7 @@</span> <span class="p_context"> static int rcar_du_probe(struct platform_device *pdev)</span>
 		return -ENODEV;
 	}
 
<span class="p_del">-	/* Allocate and initialize the DRM and R-Car device structures. */</span>
<span class="p_add">+	/* Allocate and initialize the R-Car device structure. */</span>
 	rcdu = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*rcdu), GFP_KERNEL);
 	if (rcdu == NULL)
 		return -ENOMEM;
<span class="p_chunk">@@ -315,31 +314,22 @@</span> <span class="p_context"> static int rcar_du_probe(struct platform_device *pdev)</span>
 	rcdu-&gt;dev = &amp;pdev-&gt;dev;
 	rcdu-&gt;info = of_match_device(rcar_du_of_table, rcdu-&gt;dev)-&gt;data;
 
<span class="p_del">-	ddev = drm_dev_alloc(&amp;rcar_du_driver, &amp;pdev-&gt;dev);</span>
<span class="p_del">-	if (IS_ERR(ddev))</span>
<span class="p_del">-		return PTR_ERR(ddev);</span>
<span class="p_del">-</span>
<span class="p_del">-	rcdu-&gt;ddev = ddev;</span>
<span class="p_del">-	ddev-&gt;dev_private = rcdu;</span>
<span class="p_del">-</span>
 	platform_set_drvdata(pdev, rcdu);
 
 	/* I/O resources */
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	rcdu-&gt;mmio = devm_ioremap_resource(&amp;pdev-&gt;dev, mem);
<span class="p_del">-	if (IS_ERR(rcdu-&gt;mmio)) {</span>
<span class="p_del">-		ret = PTR_ERR(rcdu-&gt;mmio);</span>
<span class="p_del">-		goto error;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Initialize vertical blanking interrupts handling. Start with vblank</span>
<span class="p_del">-	 * disabled for all CRTCs.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = drm_vblank_init(ddev, (1 &lt;&lt; rcdu-&gt;info-&gt;num_crtcs) - 1);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		goto error;</span>
<span class="p_add">+	if (IS_ERR(rcdu-&gt;mmio))</span>
<span class="p_add">+		return PTR_ERR(rcdu-&gt;mmio);</span>
 
 	/* DRM/KMS objects */
<span class="p_add">+	ddev = drm_dev_alloc(&amp;rcar_du_driver, &amp;pdev-&gt;dev);</span>
<span class="p_add">+	if (IS_ERR(ddev))</span>
<span class="p_add">+		return PTR_ERR(ddev);</span>
<span class="p_add">+</span>
<span class="p_add">+	rcdu-&gt;ddev = ddev;</span>
<span class="p_add">+	ddev-&gt;dev_private = rcdu;</span>
<span class="p_add">+</span>
 	ret = rcar_du_modeset_init(rcdu);
 	if (ret &lt; 0) {
 		if (ret != -EPROBE_DEFER)
<span class="p_header">diff --git a/drivers/gpu/drm/rcar-du/rcar_du_kms.c b/drivers/gpu/drm/rcar-du/rcar_du_kms.c</span>
<span class="p_header">index 392c7e6de042..cfc302c65b0b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/rcar-du/rcar_du_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/rcar-du/rcar_du_kms.c</span>
<span class="p_chunk">@@ -567,6 +567,13 @@</span> <span class="p_context"> int rcar_du_modeset_init(struct rcar_du_device *rcdu)</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_add">+	/* Initialize vertical blanking interrupts handling. Start with vblank</span>
<span class="p_add">+	 * disabled for all CRTCs.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = drm_vblank_init(dev, (1 &lt;&lt; rcdu-&gt;info-&gt;num_crtcs) - 1);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	/* Initialize the groups. */
 	num_groups = DIV_ROUND_UP(rcdu-&gt;num_crtcs, 2);
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">index c7b53d987f06..fefb9d995d2c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_chunk">@@ -519,7 +519,7 @@</span> <span class="p_context"> static int vmw_cmd_invalid(struct vmw_private *dev_priv,</span>
 			   struct vmw_sw_context *sw_context,
 			   SVGA3dCmdHeader *header)
 {
<span class="p_del">-	return capable(CAP_SYS_ADMIN) ? : -EINVAL;</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int vmw_cmd_ok(struct vmw_private *dev_priv,
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index a5dd7e63ada3..4f3f5749b0c1 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -2484,6 +2484,7 @@</span> <span class="p_context"> static const struct hid_device_id hid_ignore_list[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0002) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0003) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0004) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_PETZL, USB_DEVICE_ID_PETZL_HEADLAMP) },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_PHILIPS, USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_POWERCOM, USB_DEVICE_ID_POWERCOM_UPS) },
 #if IS_ENABLED(CONFIG_MOUSE_SYNAPTICS_USB)
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index cfca43f635a6..08fd3f831d62 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -819,6 +819,9 @@</span> <span class="p_context"></span>
 #define USB_VENDOR_ID_PETALYNX		0x18b1
 #define USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE	0x0037
 
<span class="p_add">+#define USB_VENDOR_ID_PETZL		0x2122</span>
<span class="p_add">+#define USB_DEVICE_ID_PETZL_HEADLAMP	0x1234</span>
<span class="p_add">+</span>
 #define USB_VENDOR_ID_PHILIPS		0x0471
 #define USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE 0x0617
 
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">index 01e3a37b0aef..d118ffe0bfb6 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_chunk">@@ -2342,8 +2342,9 @@</span> <span class="p_context"> ssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,</span>
 	if (copy_from_user(&amp;cmd, buf, sizeof cmd))
 		return -EFAULT;
 
<span class="p_del">-	if (cmd.port_num &lt; rdma_start_port(ib_dev) ||</span>
<span class="p_del">-	    cmd.port_num &gt; rdma_end_port(ib_dev))</span>
<span class="p_add">+	if ((cmd.attr_mask &amp; IB_QP_PORT) &amp;&amp;</span>
<span class="p_add">+	    (cmd.port_num &lt; rdma_start_port(ib_dev) ||</span>
<span class="p_add">+	     cmd.port_num &gt; rdma_end_port(ib_dev)))</span>
 		return -EINVAL;
 
 	INIT_UDATA(&amp;udata, buf + sizeof cmd, NULL, in_len - sizeof cmd,
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/main.c b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">index f2a885eee4bb..8059b7eaf3a8 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_chunk">@@ -1680,9 +1680,19 @@</span> <span class="p_context"> static int __mlx4_ib_create_flow(struct ib_qp *qp, struct ib_flow_attr *flow_att</span>
 		size += ret;
 	}
 
<span class="p_add">+	if (mlx4_is_master(mdev-&gt;dev) &amp;&amp; flow_type == MLX4_FS_REGULAR &amp;&amp;</span>
<span class="p_add">+	    flow_attr-&gt;num_of_specs == 1) {</span>
<span class="p_add">+		struct _rule_hw *rule_header = (struct _rule_hw *)(ctrl + 1);</span>
<span class="p_add">+		enum ib_flow_spec_type header_spec =</span>
<span class="p_add">+			((union ib_flow_spec *)(flow_attr + 1))-&gt;type;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (header_spec == IB_FLOW_SPEC_ETH)</span>
<span class="p_add">+			mlx4_handle_eth_header_mcast_prio(ctrl, rule_header);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = mlx4_cmd_imm(mdev-&gt;dev, mailbox-&gt;dma, reg_id, size &gt;&gt; 2, 0,
 			   MLX4_QP_FLOW_STEERING_ATTACH, MLX4_CMD_TIME_CLASS_A,
<span class="p_del">-			   MLX4_CMD_WRAPPED);</span>
<span class="p_add">+			   MLX4_CMD_NATIVE);</span>
 	if (ret == -ENOMEM)
 		pr_err(&quot;mcg table is full. Fail to register network rule.\n&quot;);
 	else if (ret == -ENXIO)
<span class="p_chunk">@@ -1699,7 +1709,7 @@</span> <span class="p_context"> static int __mlx4_ib_destroy_flow(struct mlx4_dev *dev, u64 reg_id)</span>
 	int err;
 	err = mlx4_cmd(dev, reg_id, 0, 0,
 		       MLX4_QP_FLOW_STEERING_DETACH, MLX4_CMD_TIME_CLASS_A,
<span class="p_del">-		       MLX4_CMD_WRAPPED);</span>
<span class="p_add">+		       MLX4_CMD_NATIVE);</span>
 	if (err)
 		pr_err(&quot;Fail to detach network rule. registration id = 0x%llx\n&quot;,
 		       reg_id);
<span class="p_header">diff --git a/drivers/irqchip/irq-keystone.c b/drivers/irqchip/irq-keystone.c</span>
<span class="p_header">index 54a5e870a8f5..efbcf8435185 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-keystone.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-keystone.c</span>
<span class="p_chunk">@@ -19,9 +19,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/bitops.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/moduleparam.h&gt;
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
 #include &lt;linux/irqdomain.h&gt;
 #include &lt;linux/irqchip.h&gt;
<span class="p_del">-#include &lt;linux/irqchip/chained_irq.h&gt;</span>
 #include &lt;linux/of.h&gt;
 #include &lt;linux/of_platform.h&gt;
 #include &lt;linux/mfd/syscon.h&gt;
<span class="p_chunk">@@ -39,6 +39,7 @@</span> <span class="p_context"> struct keystone_irq_device {</span>
 	struct irq_domain	*irqd;
 	struct regmap		*devctrl_regs;
 	u32			devctrl_offset;
<span class="p_add">+	raw_spinlock_t		wa_lock;</span>
 };
 
 static inline u32 keystone_irq_readl(struct keystone_irq_device *kirq)
<span class="p_chunk">@@ -83,17 +84,15 @@</span> <span class="p_context"> static void keystone_irq_ack(struct irq_data *d)</span>
 	/* nothing to do here */
 }
 
<span class="p_del">-static void keystone_irq_handler(struct irq_desc *desc)</span>
<span class="p_add">+static irqreturn_t keystone_irq_handler(int irq, void *keystone_irq)</span>
 {
<span class="p_del">-	unsigned int irq = irq_desc_get_irq(desc);</span>
<span class="p_del">-	struct keystone_irq_device *kirq = irq_desc_get_handler_data(desc);</span>
<span class="p_add">+	struct keystone_irq_device *kirq = keystone_irq;</span>
<span class="p_add">+	unsigned long wa_lock_flags;</span>
 	unsigned long pending;
 	int src, virq;
 
 	dev_dbg(kirq-&gt;dev, &quot;start irq %d\n&quot;, irq);
 
<span class="p_del">-	chained_irq_enter(irq_desc_get_chip(desc), desc);</span>
<span class="p_del">-</span>
 	pending = keystone_irq_readl(kirq);
 	keystone_irq_writel(kirq, pending);
 
<span class="p_chunk">@@ -111,13 +110,15 @@</span> <span class="p_context"> static void keystone_irq_handler(struct irq_desc *desc)</span>
 			if (!virq)
 				dev_warn(kirq-&gt;dev, &quot;spurious irq detected hwirq %d, virq %d\n&quot;,
 					 src, virq);
<span class="p_add">+			raw_spin_lock_irqsave(&amp;kirq-&gt;wa_lock, wa_lock_flags);</span>
 			generic_handle_irq(virq);
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;kirq-&gt;wa_lock,</span>
<span class="p_add">+						   wa_lock_flags);</span>
 		}
 	}
 
<span class="p_del">-	chained_irq_exit(irq_desc_get_chip(desc), desc);</span>
<span class="p_del">-</span>
 	dev_dbg(kirq-&gt;dev, &quot;end irq %d\n&quot;, irq);
<span class="p_add">+	return IRQ_HANDLED;</span>
 }
 
 static int keystone_irq_map(struct irq_domain *h, unsigned int virq,
<span class="p_chunk">@@ -182,9 +183,16 @@</span> <span class="p_context"> static int keystone_irq_probe(struct platform_device *pdev)</span>
 		return -ENODEV;
 	}
 
<span class="p_add">+	raw_spin_lock_init(&amp;kirq-&gt;wa_lock);</span>
<span class="p_add">+</span>
 	platform_set_drvdata(pdev, kirq);
 
<span class="p_del">-	irq_set_chained_handler_and_data(kirq-&gt;irq, keystone_irq_handler, kirq);</span>
<span class="p_add">+	ret = request_irq(kirq-&gt;irq, keystone_irq_handler,</span>
<span class="p_add">+			  0, dev_name(dev), kirq);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		irq_domain_remove(kirq-&gt;irqd);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
 	/* clear all source bits */
 	keystone_irq_writel(kirq, ~0x0);
<span class="p_chunk">@@ -199,6 +207,8 @@</span> <span class="p_context"> static int keystone_irq_remove(struct platform_device *pdev)</span>
 	struct keystone_irq_device *kirq = platform_get_drvdata(pdev);
 	int hwirq;
 
<span class="p_add">+	free_irq(kirq-&gt;irq, kirq);</span>
<span class="p_add">+</span>
 	for (hwirq = 0; hwirq &lt; KEYSTONE_N_IRQ; hwirq++)
 		irq_dispose_mapping(irq_find_mapping(kirq-&gt;irqd, hwirq));
 
<span class="p_header">diff --git a/drivers/irqchip/irq-mxs.c b/drivers/irqchip/irq-mxs.c</span>
<span class="p_header">index 17304705f2cf..05fa9f7af53c 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-mxs.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-mxs.c</span>
<span class="p_chunk">@@ -131,12 +131,16 @@</span> <span class="p_context"> static struct irq_chip mxs_icoll_chip = {</span>
 	.irq_ack = icoll_ack_irq,
 	.irq_mask = icoll_mask_irq,
 	.irq_unmask = icoll_unmask_irq,
<span class="p_add">+	.flags = IRQCHIP_MASK_ON_SUSPEND |</span>
<span class="p_add">+		 IRQCHIP_SKIP_SET_WAKE,</span>
 };
 
 static struct irq_chip asm9260_icoll_chip = {
 	.irq_ack = icoll_ack_irq,
 	.irq_mask = asm9260_mask_irq,
 	.irq_unmask = asm9260_unmask_irq,
<span class="p_add">+	.flags = IRQCHIP_MASK_ON_SUSPEND |</span>
<span class="p_add">+		 IRQCHIP_SKIP_SET_WAKE,</span>
 };
 
 asmlinkage void __exception_irq_entry icoll_handle_irq(struct pt_regs *regs)
<span class="p_header">diff --git a/drivers/isdn/i4l/isdn_common.c b/drivers/isdn/i4l/isdn_common.c</span>
<span class="p_header">index 9b856e1890d1..e4c43a17b333 100644</span>
<span class="p_header">--- a/drivers/isdn/i4l/isdn_common.c</span>
<span class="p_header">+++ b/drivers/isdn/i4l/isdn_common.c</span>
<span class="p_chunk">@@ -1379,6 +1379,7 @@</span> <span class="p_context"> isdn_ioctl(struct file *file, uint cmd, ulong arg)</span>
 			if (arg) {
 				if (copy_from_user(bname, argp, sizeof(bname) - 1))
 					return -EFAULT;
<span class="p_add">+				bname[sizeof(bname)-1] = 0;</span>
 			} else
 				return -EINVAL;
 			ret = mutex_lock_interruptible(&amp;dev-&gt;mtx);
<span class="p_header">diff --git a/drivers/isdn/i4l/isdn_net.c b/drivers/isdn/i4l/isdn_net.c</span>
<span class="p_header">index c151c6daa67e..f63a110b7bcb 100644</span>
<span class="p_header">--- a/drivers/isdn/i4l/isdn_net.c</span>
<span class="p_header">+++ b/drivers/isdn/i4l/isdn_net.c</span>
<span class="p_chunk">@@ -2611,10 +2611,9 @@</span> <span class="p_context"> isdn_net_newslave(char *parm)</span>
 	char newname[10];
 
 	if (p) {
<span class="p_del">-		/* Slave-Name MUST not be empty */</span>
<span class="p_del">-		if (!strlen(p + 1))</span>
<span class="p_add">+		/* Slave-Name MUST not be empty or overflow &#39;newname&#39; */</span>
<span class="p_add">+		if (strscpy(newname, p + 1, sizeof(newname)) &lt;= 0)</span>
 			return NULL;
<span class="p_del">-		strcpy(newname, p + 1);</span>
 		*p = 0;
 		/* Master must already exist */
 		if (!(n = isdn_net_findif(parm)))
<span class="p_header">diff --git a/drivers/isdn/i4l/isdn_ppp.c b/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_header">index 9c1e8adaf4fc..bf3fbd00a091 100644</span>
<span class="p_header">--- a/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_header">+++ b/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_chunk">@@ -2364,7 +2364,7 @@</span> <span class="p_context"> static struct ippp_ccp_reset_state *isdn_ppp_ccp_reset_alloc_state(struct ippp_s</span>
 		       id);
 		return NULL;
 	} else {
<span class="p_del">-		rs = kzalloc(sizeof(struct ippp_ccp_reset_state), GFP_KERNEL);</span>
<span class="p_add">+		rs = kzalloc(sizeof(struct ippp_ccp_reset_state), GFP_ATOMIC);</span>
 		if (!rs)
 			return NULL;
 		rs-&gt;state = CCPResetIdle;
<span class="p_header">diff --git a/drivers/mailbox/mailbox.c b/drivers/mailbox/mailbox.c</span>
<span class="p_header">index 4a36632c236f..87ef465c6947 100644</span>
<span class="p_header">--- a/drivers/mailbox/mailbox.c</span>
<span class="p_header">+++ b/drivers/mailbox/mailbox.c</span>
<span class="p_chunk">@@ -104,11 +104,14 @@</span> <span class="p_context"> static void tx_tick(struct mbox_chan *chan, int r)</span>
 	/* Submit next message */
 	msg_submit(chan);
 
<span class="p_add">+	if (!mssg)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* Notify the client */
<span class="p_del">-	if (mssg &amp;&amp; chan-&gt;cl-&gt;tx_done)</span>
<span class="p_add">+	if (chan-&gt;cl-&gt;tx_done)</span>
 		chan-&gt;cl-&gt;tx_done(chan-&gt;cl, mssg, r);
 
<span class="p_del">-	if (chan-&gt;cl-&gt;tx_block)</span>
<span class="p_add">+	if (r != -ETIME &amp;&amp; chan-&gt;cl-&gt;tx_block)</span>
 		complete(&amp;chan-&gt;tx_complete);
 }
 
<span class="p_chunk">@@ -261,7 +264,7 @@</span> <span class="p_context"> int mbox_send_message(struct mbox_chan *chan, void *mssg)</span>
 
 	msg_submit(chan);
 
<span class="p_del">-	if (chan-&gt;cl-&gt;tx_block &amp;&amp; chan-&gt;active_req) {</span>
<span class="p_add">+	if (chan-&gt;cl-&gt;tx_block) {</span>
 		unsigned long wait;
 		int ret;
 
<span class="p_chunk">@@ -272,8 +275,8 @@</span> <span class="p_context"> int mbox_send_message(struct mbox_chan *chan, void *mssg)</span>
 
 		ret = wait_for_completion_timeout(&amp;chan-&gt;tx_complete, wait);
 		if (ret == 0) {
<span class="p_del">-			t = -EIO;</span>
<span class="p_del">-			tx_tick(chan, -EIO);</span>
<span class="p_add">+			t = -ETIME;</span>
<span class="p_add">+			tx_tick(chan, t);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 8f117d6372c9..383f19c6bf24 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -5843,6 +5843,8 @@</span> <span class="p_context"> static void raid5_do_work(struct work_struct *work)</span>
 	pr_debug(&quot;%d stripes handled\n&quot;, handled);
 
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
<span class="p_add">+</span>
<span class="p_add">+	async_tx_issue_pending_all();</span>
 	blk_finish_plug(&amp;plug);
 
 	pr_debug(&quot;--- raid5worker inactive\n&quot;);
<span class="p_header">diff --git a/drivers/media/i2c/s5c73m3/s5c73m3-ctrls.c b/drivers/media/i2c/s5c73m3/s5c73m3-ctrls.c</span>
<span class="p_header">index 0a060339e516..2e7185030741 100644</span>
<span class="p_header">--- a/drivers/media/i2c/s5c73m3/s5c73m3-ctrls.c</span>
<span class="p_header">+++ b/drivers/media/i2c/s5c73m3/s5c73m3-ctrls.c</span>
<span class="p_chunk">@@ -211,7 +211,7 @@</span> <span class="p_context"> static int s5c73m3_3a_lock(struct s5c73m3 *state, struct v4l2_ctrl *ctrl)</span>
 	}
 
 	if ((ctrl-&gt;val ^ ctrl-&gt;cur.val) &amp; V4L2_LOCK_FOCUS)
<span class="p_del">-		ret = s5c73m3_af_run(state, ~af_lock);</span>
<span class="p_add">+		ret = s5c73m3_af_run(state, !af_lock);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">index b3c9cbef766e..5626908f3f7a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_chunk">@@ -5186,7 +5186,9 @@</span> <span class="p_context"> static netdev_features_t be_features_check(struct sk_buff *skb,</span>
 	    skb-&gt;inner_protocol_type != ENCAP_TYPE_ETHER ||
 	    skb-&gt;inner_protocol != htons(ETH_P_TEB) ||
 	    skb_inner_mac_header(skb) - skb_transport_header(skb) !=
<span class="p_del">-	    sizeof(struct udphdr) + sizeof(struct vxlanhdr))</span>
<span class="p_add">+		sizeof(struct udphdr) + sizeof(struct vxlanhdr) ||</span>
<span class="p_add">+	    !adapter-&gt;vxlan_port ||</span>
<span class="p_add">+	    udp_hdr(skb)-&gt;dest != adapter-&gt;vxlan_port)</span>
 		return features &amp; ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);
 
 	return features;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/icm.c b/drivers/net/ethernet/mellanox/mlx4/icm.c</span>
<span class="p_header">index 2a9dd460a95f..e1f9e7cebf8f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/icm.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/icm.c</span>
<span class="p_chunk">@@ -118,8 +118,13 @@</span> <span class="p_context"> static int mlx4_alloc_icm_coherent(struct device *dev, struct scatterlist *mem,</span>
 	if (!buf)
 		return -ENOMEM;
 
<span class="p_add">+	if (offset_in_page(buf)) {</span>
<span class="p_add">+		dma_free_coherent(dev, PAGE_SIZE &lt;&lt; order,</span>
<span class="p_add">+				  buf, sg_dma_address(mem));</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sg_set_buf(mem, buf, PAGE_SIZE &lt;&lt; order);
<span class="p_del">-	BUG_ON(mem-&gt;offset);</span>
 	sg_dma_len(mem) = PAGE_SIZE &lt;&lt; order;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">index b2ca8a635b2e..551786f58e59 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_chunk">@@ -42,6 +42,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/io-mapping.h&gt;
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/kmod.h&gt;
<span class="p_add">+#include &lt;linux/etherdevice.h&gt;</span>
 #include &lt;net/devlink.h&gt;
 
 #include &lt;linux/mlx4/device.h&gt;
<span class="p_chunk">@@ -782,6 +783,23 @@</span> <span class="p_context"> int mlx4_is_slave_active(struct mlx4_dev *dev, int slave)</span>
 }
 EXPORT_SYMBOL(mlx4_is_slave_active);
 
<span class="p_add">+void mlx4_handle_eth_header_mcast_prio(struct mlx4_net_trans_rule_hw_ctrl *ctrl,</span>
<span class="p_add">+				       struct _rule_hw *eth_header)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (is_multicast_ether_addr(eth_header-&gt;eth.dst_mac) ||</span>
<span class="p_add">+	    is_broadcast_ether_addr(eth_header-&gt;eth.dst_mac)) {</span>
<span class="p_add">+		struct mlx4_net_trans_rule_hw_eth *eth =</span>
<span class="p_add">+			(struct mlx4_net_trans_rule_hw_eth *)eth_header;</span>
<span class="p_add">+		struct _rule_hw *next_rule = (struct _rule_hw *)(eth + 1);</span>
<span class="p_add">+		bool last_rule = next_rule-&gt;size == 0 &amp;&amp; next_rule-&gt;id == 0 &amp;&amp;</span>
<span class="p_add">+			next_rule-&gt;rsvd == 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (last_rule)</span>
<span class="p_add">+			ctrl-&gt;prio = cpu_to_be16(MLX4_DOMAIN_NIC);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(mlx4_handle_eth_header_mcast_prio);</span>
<span class="p_add">+</span>
 static void slave_adjust_steering_mode(struct mlx4_dev *dev,
 				       struct mlx4_dev_cap *dev_cap,
 				       struct mlx4_init_hca_param *hca_param)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c</span>
<span class="p_header">index 32f76bf018c3..1822382212ee 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c</span>
<span class="p_chunk">@@ -4165,22 +4165,6 @@</span> <span class="p_context"> static int validate_eth_header_mac(int slave, struct _rule_hw *eth_header,</span>
 	return 0;
 }
 
<span class="p_del">-static void handle_eth_header_mcast_prio(struct mlx4_net_trans_rule_hw_ctrl *ctrl,</span>
<span class="p_del">-					 struct _rule_hw *eth_header)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (is_multicast_ether_addr(eth_header-&gt;eth.dst_mac) ||</span>
<span class="p_del">-	    is_broadcast_ether_addr(eth_header-&gt;eth.dst_mac)) {</span>
<span class="p_del">-		struct mlx4_net_trans_rule_hw_eth *eth =</span>
<span class="p_del">-			(struct mlx4_net_trans_rule_hw_eth *)eth_header;</span>
<span class="p_del">-		struct _rule_hw *next_rule = (struct _rule_hw *)(eth + 1);</span>
<span class="p_del">-		bool last_rule = next_rule-&gt;size == 0 &amp;&amp; next_rule-&gt;id == 0 &amp;&amp;</span>
<span class="p_del">-			next_rule-&gt;rsvd == 0;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (last_rule)</span>
<span class="p_del">-			ctrl-&gt;prio = cpu_to_be16(MLX4_DOMAIN_NIC);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * In case of missing eth header, append eth header with a MAC address
  * assigned to the VF.
<span class="p_chunk">@@ -4364,10 +4348,7 @@</span> <span class="p_context"> int mlx4_QP_FLOW_STEERING_ATTACH_wrapper(struct mlx4_dev *dev, int slave,</span>
 	header_id = map_hw_to_sw_id(be16_to_cpu(rule_header-&gt;id));
 
 	if (header_id == MLX4_NET_TRANS_RULE_ID_ETH)
<span class="p_del">-		handle_eth_header_mcast_prio(ctrl, rule_header);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (slave == dev-&gt;caps.function)</span>
<span class="p_del">-		goto execute;</span>
<span class="p_add">+		mlx4_handle_eth_header_mcast_prio(ctrl, rule_header);</span>
 
 	switch (header_id) {
 	case MLX4_NET_TRANS_RULE_ID_ETH:
<span class="p_chunk">@@ -4395,7 +4376,6 @@</span> <span class="p_context"> int mlx4_QP_FLOW_STEERING_ATTACH_wrapper(struct mlx4_dev *dev, int slave,</span>
 		goto err_put_qp;
 	}
 
<span class="p_del">-execute:</span>
 	err = mlx4_cmd_imm(dev, inbox-&gt;dma, &amp;vhcr-&gt;out_param,
 			   vhcr-&gt;in_modifier, 0,
 			   MLX4_QP_FLOW_STEERING_ATTACH, MLX4_CMD_TIME_CLASS_A,
<span class="p_chunk">@@ -4474,6 +4454,7 @@</span> <span class="p_context"> int mlx4_QP_FLOW_STEERING_DETACH_wrapper(struct mlx4_dev *dev, int slave,</span>
 	struct res_qp *rqp;
 	struct res_fs_rule *rrule;
 	u64 mirr_reg_id;
<span class="p_add">+	int qpn;</span>
 
 	if (dev-&gt;caps.steering_mode !=
 	    MLX4_STEERING_MODE_DEVICE_MANAGED)
<span class="p_chunk">@@ -4490,10 +4471,11 @@</span> <span class="p_context"> int mlx4_QP_FLOW_STEERING_DETACH_wrapper(struct mlx4_dev *dev, int slave,</span>
 	}
 	mirr_reg_id = rrule-&gt;mirr_rule_id;
 	kfree(rrule-&gt;mirr_mbox);
<span class="p_add">+	qpn = rrule-&gt;qpn;</span>
 
 	/* Release the rule form busy state before removal */
 	put_res(dev, slave, vhcr-&gt;in_param, RES_FS_RULE);
<span class="p_del">-	err = get_res(dev, slave, rrule-&gt;qpn, RES_QP, &amp;rqp);</span>
<span class="p_add">+	err = get_res(dev, slave, qpn, RES_QP, &amp;rqp);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -4518,7 +4500,7 @@</span> <span class="p_context"> int mlx4_QP_FLOW_STEERING_DETACH_wrapper(struct mlx4_dev *dev, int slave,</span>
 	if (!err)
 		atomic_dec(&amp;rqp-&gt;ref_count);
 out:
<span class="p_del">-	put_res(dev, slave, rrule-&gt;qpn, RES_QP);</span>
<span class="p_add">+	put_res(dev, slave, qpn, RES_QP);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c</span>
<span class="p_header">index b08b9e2c6a76..6ffd5d2a70aa 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c</span>
<span class="p_chunk">@@ -672,6 +672,12 @@</span> <span class="p_context"> int esw_offloads_init(struct mlx5_eswitch *esw, int nvports)</span>
 		if (err)
 			goto err_reps;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* disable PF RoCE so missed packets don&#39;t go through RoCE steering */</span>
<span class="p_add">+	mlx5_dev_list_lock();</span>
<span class="p_add">+	mlx5_remove_dev_by_protocol(esw-&gt;dev, MLX5_INTERFACE_PROTOCOL_IB);</span>
<span class="p_add">+	mlx5_dev_list_unlock();</span>
<span class="p_add">+</span>
 	return 0;
 
 err_reps:
<span class="p_chunk">@@ -695,6 +701,11 @@</span> <span class="p_context"> static int esw_offloads_stop(struct mlx5_eswitch *esw)</span>
 {
 	int err, err1, num_vfs = esw-&gt;dev-&gt;priv.sriov.num_vfs;
 
<span class="p_add">+	/* enable back PF RoCE */</span>
<span class="p_add">+	mlx5_dev_list_lock();</span>
<span class="p_add">+	mlx5_add_dev_by_protocol(esw-&gt;dev, MLX5_INTERFACE_PROTOCOL_IB);</span>
<span class="p_add">+	mlx5_dev_list_unlock();</span>
<span class="p_add">+</span>
 	mlx5_eswitch_disable_sriov(esw);
 	err = mlx5_eswitch_enable_sriov(esw, num_vfs, SRIOV_LEGACY);
 	if (err) {
<span class="p_header">diff --git a/drivers/net/ethernet/realtek/r8169.c b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">index bf000d819a21..2c4350a1c629 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_chunk">@@ -326,6 +326,7 @@</span> <span class="p_context"> enum cfg_version {</span>
 static const struct pci_device_id rtl8169_pci_tbl[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK,	0x8129), 0, 0, RTL_CFG_0 },
 	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK,	0x8136), 0, 0, RTL_CFG_2 },
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK,	0x8161), 0, 0, RTL_CFG_1 },</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK,	0x8167), 0, 0, RTL_CFG_0 },
 	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK,	0x8168), 0, 0, RTL_CFG_1 },
 	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK,	0x8169), 0, 0, RTL_CFG_0 },
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">index a2d218b28c0e..12be259394c6 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_chunk">@@ -819,6 +819,7 @@</span> <span class="p_context"> static struct sh_eth_cpu_data sh7734_data = {</span>
 	.tsu		= 1,
 	.hw_crc		= 1,
 	.select_mii	= 1,
<span class="p_add">+	.shift_rd0	= 1,</span>
 };
 
 /* SH7763 */
<span class="p_header">diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c</span>
<span class="p_header">index 32b555a72e13..9e7b7836774f 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy_device.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy_device.c</span>
<span class="p_chunk">@@ -1792,7 +1792,7 @@</span> <span class="p_context"> static struct phy_driver genphy_driver[] = {</span>
 	.phy_id		= 0xffffffff,
 	.phy_id_mask	= 0xffffffff,
 	.name		= &quot;Generic PHY&quot;,
<span class="p_del">-	.soft_reset	= genphy_soft_reset,</span>
<span class="p_add">+	.soft_reset	= genphy_no_soft_reset,</span>
 	.config_init	= genphy_config_init,
 	.features	= PHY_GBIT_FEATURES | SUPPORTED_MII |
 			  SUPPORTED_AUI | SUPPORTED_FIBRE |
<span class="p_header">diff --git a/drivers/net/usb/asix_devices.c b/drivers/net/usb/asix_devices.c</span>
<span class="p_header">index dc7b6392e75a..50737def774c 100644</span>
<span class="p_header">--- a/drivers/net/usb/asix_devices.c</span>
<span class="p_header">+++ b/drivers/net/usb/asix_devices.c</span>
<span class="p_chunk">@@ -1369,6 +1369,7 @@</span> <span class="p_context"> static struct usb_driver asix_driver = {</span>
 	.probe =	usbnet_probe,
 	.suspend =	asix_suspend,
 	.resume =	asix_resume,
<span class="p_add">+	.reset_resume =	asix_resume,</span>
 	.disconnect =	usbnet_disconnect,
 	.supports_autosuspend = 1,
 	.disable_hub_initiated_lpm = 1,
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/wmi-ops.h b/drivers/net/wireless/ath/ath10k/wmi-ops.h</span>
<span class="p_header">index c9a8bb1186f2..c7956e181f80 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/wmi-ops.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/wmi-ops.h</span>
<span class="p_chunk">@@ -660,6 +660,9 @@</span> <span class="p_context"> ath10k_wmi_vdev_spectral_conf(struct ath10k *ar,</span>
 	struct sk_buff *skb;
 	u32 cmd_id;
 
<span class="p_add">+	if (!ar-&gt;wmi.ops-&gt;gen_vdev_spectral_conf)</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
 	skb = ar-&gt;wmi.ops-&gt;gen_vdev_spectral_conf(ar, arg);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
<span class="p_chunk">@@ -675,6 +678,9 @@</span> <span class="p_context"> ath10k_wmi_vdev_spectral_enable(struct ath10k *ar, u32 vdev_id, u32 trigger,</span>
 	struct sk_buff *skb;
 	u32 cmd_id;
 
<span class="p_add">+	if (!ar-&gt;wmi.ops-&gt;gen_vdev_spectral_enable)</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
 	skb = ar-&gt;wmi.ops-&gt;gen_vdev_spectral_enable(ar, vdev_id, trigger,
 						    enable);
 	if (IS_ERR(skb))
<span class="p_header">diff --git a/drivers/net/wireless/ath/wil6210/main.c b/drivers/net/wireless/ath/wil6210/main.c</span>
<span class="p_header">index e7130b54d1d8..24b07a0ce6f7 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/wil6210/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/wil6210/main.c</span>
<span class="p_chunk">@@ -384,18 +384,19 @@</span> <span class="p_context"> static void wil_fw_error_worker(struct work_struct *work)</span>
 
 	wil-&gt;last_fw_recovery = jiffies;
 
<span class="p_add">+	wil_info(wil, &quot;fw error recovery requested (try %d)...\n&quot;,</span>
<span class="p_add">+		 wil-&gt;recovery_count);</span>
<span class="p_add">+	if (!no_fw_recovery)</span>
<span class="p_add">+		wil-&gt;recovery_state = fw_recovery_running;</span>
<span class="p_add">+	if (wil_wait_for_recovery(wil) != 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;wil-&gt;mutex);
 	switch (wdev-&gt;iftype) {
 	case NL80211_IFTYPE_STATION:
 	case NL80211_IFTYPE_P2P_CLIENT:
 	case NL80211_IFTYPE_MONITOR:
<span class="p_del">-		wil_info(wil, &quot;fw error recovery requested (try %d)...\n&quot;,</span>
<span class="p_del">-			 wil-&gt;recovery_count);</span>
<span class="p_del">-		if (!no_fw_recovery)</span>
<span class="p_del">-			wil-&gt;recovery_state = fw_recovery_running;</span>
<span class="p_del">-		if (0 != wil_wait_for_recovery(wil))</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_add">+		/* silent recovery, upper layers will see disconnect */</span>
 		__wil_down(wil);
 		__wil_up(wil);
 		break;
<span class="p_header">diff --git a/drivers/nfc/fdp/i2c.c b/drivers/nfc/fdp/i2c.c</span>
<span class="p_header">index 5e797d5c38ed..712936f5d2d6 100644</span>
<span class="p_header">--- a/drivers/nfc/fdp/i2c.c</span>
<span class="p_header">+++ b/drivers/nfc/fdp/i2c.c</span>
<span class="p_chunk">@@ -210,14 +210,14 @@</span> <span class="p_context"> static irqreturn_t fdp_nci_i2c_irq_thread_fn(int irq, void *phy_id)</span>
 	struct sk_buff *skb;
 	int r;
 
<span class="p_del">-	client = phy-&gt;i2c_dev;</span>
<span class="p_del">-	dev_dbg(&amp;client-&gt;dev, &quot;%s\n&quot;, __func__);</span>
<span class="p_del">-</span>
 	if (!phy || irq != phy-&gt;i2c_dev-&gt;irq) {
 		WARN_ON_ONCE(1);
 		return IRQ_NONE;
 	}
 
<span class="p_add">+	client = phy-&gt;i2c_dev;</span>
<span class="p_add">+	dev_dbg(&amp;client-&gt;dev, &quot;%s\n&quot;, __func__);</span>
<span class="p_add">+</span>
 	r = fdp_nci_i2c_read(phy, &amp;skb);
 
 	if (r == -EREMOTEIO)
<span class="p_header">diff --git a/drivers/nfc/port100.c b/drivers/nfc/port100.c</span>
<span class="p_header">index 2b2330b235e6..073e4a478c89 100644</span>
<span class="p_header">--- a/drivers/nfc/port100.c</span>
<span class="p_header">+++ b/drivers/nfc/port100.c</span>
<span class="p_chunk">@@ -725,23 +725,33 @@</span> <span class="p_context"> static int port100_submit_urb_for_ack(struct port100 *dev, gfp_t flags)</span>
 
 static int port100_send_ack(struct port100 *dev)
 {
<span class="p_del">-	int rc;</span>
<span class="p_add">+	int rc = 0;</span>
 
 	mutex_lock(&amp;dev-&gt;out_urb_lock);
 
<span class="p_del">-	init_completion(&amp;dev-&gt;cmd_cancel_done);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If prior cancel is in-flight (dev-&gt;cmd_cancel == true), we</span>
<span class="p_add">+	 * can skip to send cancel. Then this will wait the prior</span>
<span class="p_add">+	 * cancel, or merged into the next cancel rarely if next</span>
<span class="p_add">+	 * cancel was started before waiting done. In any case, this</span>
<span class="p_add">+	 * will be waked up soon or later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!dev-&gt;cmd_cancel) {</span>
<span class="p_add">+		reinit_completion(&amp;dev-&gt;cmd_cancel_done);</span>
 
<span class="p_del">-	usb_kill_urb(dev-&gt;out_urb);</span>
<span class="p_add">+		usb_kill_urb(dev-&gt;out_urb);</span>
 
<span class="p_del">-	dev-&gt;out_urb-&gt;transfer_buffer = ack_frame;</span>
<span class="p_del">-	dev-&gt;out_urb-&gt;transfer_buffer_length = sizeof(ack_frame);</span>
<span class="p_del">-	rc = usb_submit_urb(dev-&gt;out_urb, GFP_KERNEL);</span>
<span class="p_add">+		dev-&gt;out_urb-&gt;transfer_buffer = ack_frame;</span>
<span class="p_add">+		dev-&gt;out_urb-&gt;transfer_buffer_length = sizeof(ack_frame);</span>
<span class="p_add">+		rc = usb_submit_urb(dev-&gt;out_urb, GFP_KERNEL);</span>
 
<span class="p_del">-	/* Set the cmd_cancel flag only if the URB has been successfully</span>
<span class="p_del">-	 * submitted. It will be reset by the out URB completion callback</span>
<span class="p_del">-	 * port100_send_complete().</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	dev-&gt;cmd_cancel = !rc;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Set the cmd_cancel flag only if the URB has been</span>
<span class="p_add">+		 * successfully submitted. It will be reset by the out</span>
<span class="p_add">+		 * URB completion callback port100_send_complete().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		dev-&gt;cmd_cancel = !rc;</span>
<span class="p_add">+	}</span>
 
 	mutex_unlock(&amp;dev-&gt;out_urb_lock);
 
<span class="p_chunk">@@ -928,8 +938,8 @@</span> <span class="p_context"> static void port100_send_complete(struct urb *urb)</span>
 	struct port100 *dev = urb-&gt;context;
 
 	if (dev-&gt;cmd_cancel) {
<span class="p_add">+		complete_all(&amp;dev-&gt;cmd_cancel_done);</span>
 		dev-&gt;cmd_cancel = false;
<span class="p_del">-		complete(&amp;dev-&gt;cmd_cancel_done);</span>
 	}
 
 	switch (urb-&gt;status) {
<span class="p_chunk">@@ -1543,6 +1553,7 @@</span> <span class="p_context"> static int port100_probe(struct usb_interface *interface,</span>
 			    PORT100_COMM_RF_HEAD_MAX_LEN;
 	dev-&gt;skb_tailroom = PORT100_FRAME_TAIL_LEN;
 
<span class="p_add">+	init_completion(&amp;dev-&gt;cmd_cancel_done);</span>
 	INIT_WORK(&amp;dev-&gt;cmd_complete_work, port100_wq_cmd_complete);
 
 	/* The first thing to do with the Port-100 is to set the command type
<span class="p_header">diff --git a/drivers/nvmem/imx-ocotp.c b/drivers/nvmem/imx-ocotp.c</span>
<span class="p_header">index ac27b9bac3b9..8e7b120696fa 100644</span>
<span class="p_header">--- a/drivers/nvmem/imx-ocotp.c</span>
<span class="p_header">+++ b/drivers/nvmem/imx-ocotp.c</span>
<span class="p_chunk">@@ -71,7 +71,7 @@</span> <span class="p_context"> static struct nvmem_config imx_ocotp_nvmem_config = {</span>
 
 static const struct of_device_id imx_ocotp_dt_ids[] = {
 	{ .compatible = &quot;fsl,imx6q-ocotp&quot;,  (void *)128 },
<span class="p_del">-	{ .compatible = &quot;fsl,imx6sl-ocotp&quot;, (void *)32 },</span>
<span class="p_add">+	{ .compatible = &quot;fsl,imx6sl-ocotp&quot;, (void *)64 },</span>
 	{ .compatible = &quot;fsl,imx6sx-ocotp&quot;, (void *)128 },
 	{ },
 };
<span class="p_header">diff --git a/drivers/scsi/bfa/bfad.c b/drivers/scsi/bfa/bfad.c</span>
<span class="p_header">index 9d253cb83ee7..e70410beb83a 100644</span>
<span class="p_header">--- a/drivers/scsi/bfa/bfad.c</span>
<span class="p_header">+++ b/drivers/scsi/bfa/bfad.c</span>
<span class="p_chunk">@@ -64,9 +64,9 @@</span> <span class="p_context"> int		max_rport_logins = BFA_FCS_MAX_RPORT_LOGINS;</span>
 u32	bfi_image_cb_size, bfi_image_ct_size, bfi_image_ct2_size;
 u32	*bfi_image_cb, *bfi_image_ct, *bfi_image_ct2;
 
<span class="p_del">-#define BFAD_FW_FILE_CB		&quot;cbfw-3.2.3.0.bin&quot;</span>
<span class="p_del">-#define BFAD_FW_FILE_CT		&quot;ctfw-3.2.3.0.bin&quot;</span>
<span class="p_del">-#define BFAD_FW_FILE_CT2	&quot;ct2fw-3.2.3.0.bin&quot;</span>
<span class="p_add">+#define BFAD_FW_FILE_CB		&quot;cbfw-3.2.5.1.bin&quot;</span>
<span class="p_add">+#define BFAD_FW_FILE_CT		&quot;ctfw-3.2.5.1.bin&quot;</span>
<span class="p_add">+#define BFAD_FW_FILE_CT2	&quot;ct2fw-3.2.5.1.bin&quot;</span>
 
 static u32 *bfad_load_fwimg(struct pci_dev *pdev);
 static void bfad_free_fwimg(void);
<span class="p_header">diff --git a/drivers/scsi/bfa/bfad_drv.h b/drivers/scsi/bfa/bfad_drv.h</span>
<span class="p_header">index f9e862093a25..cfcfff48e8e1 100644</span>
<span class="p_header">--- a/drivers/scsi/bfa/bfad_drv.h</span>
<span class="p_header">+++ b/drivers/scsi/bfa/bfad_drv.h</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"></span>
 #ifdef BFA_DRIVER_VERSION
 #define BFAD_DRIVER_VERSION    BFA_DRIVER_VERSION
 #else
<span class="p_del">-#define BFAD_DRIVER_VERSION    &quot;3.2.25.0&quot;</span>
<span class="p_add">+#define BFAD_DRIVER_VERSION    &quot;3.2.25.1&quot;</span>
 #endif
 
 #define BFAD_PROTO_NAME FCPI_NAME
<span class="p_header">diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h</span>
<span class="p_header">index 9ddc9200e0a4..9e4b7709043e 100644</span>
<span class="p_header">--- a/drivers/scsi/fnic/fnic.h</span>
<span class="p_header">+++ b/drivers/scsi/fnic/fnic.h</span>
<span class="p_chunk">@@ -248,6 +248,7 @@</span> <span class="p_context"> struct fnic {</span>
 	struct completion *remove_wait; /* device remove thread blocks */
 
 	atomic_t in_flight;		/* io counter */
<span class="p_add">+	bool internal_reset_inprogress;</span>
 	u32 _reserved;			/* fill hole */
 	unsigned long state_flags;	/* protected by host lock */
 	enum fnic_state state;
<span class="p_header">diff --git a/drivers/scsi/fnic/fnic_scsi.c b/drivers/scsi/fnic/fnic_scsi.c</span>
<span class="p_header">index d9fd2f841585..44dd372aa7d3 100644</span>
<span class="p_header">--- a/drivers/scsi/fnic/fnic_scsi.c</span>
<span class="p_header">+++ b/drivers/scsi/fnic/fnic_scsi.c</span>
<span class="p_chunk">@@ -2573,6 +2573,19 @@</span> <span class="p_context"> int fnic_host_reset(struct scsi_cmnd *sc)</span>
 	unsigned long wait_host_tmo;
 	struct Scsi_Host *shost = sc-&gt;device-&gt;host;
 	struct fc_lport *lp = shost_priv(shost);
<span class="p_add">+	struct fnic *fnic = lport_priv(lp);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;fnic-&gt;fnic_lock, flags);</span>
<span class="p_add">+	if (fnic-&gt;internal_reset_inprogress == 0) {</span>
<span class="p_add">+		fnic-&gt;internal_reset_inprogress = 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;fnic-&gt;fnic_lock, flags);</span>
<span class="p_add">+		FNIC_SCSI_DBG(KERN_DEBUG, fnic-&gt;lport-&gt;host,</span>
<span class="p_add">+			&quot;host reset in progress skipping another host reset\n&quot;);</span>
<span class="p_add">+		return SUCCESS;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;fnic-&gt;fnic_lock, flags);</span>
 
 	/*
 	 * If fnic_reset is successful, wait for fabric login to complete
<span class="p_chunk">@@ -2593,6 +2606,9 @@</span> <span class="p_context"> int fnic_host_reset(struct scsi_cmnd *sc)</span>
 		}
 	}
 
<span class="p_add">+	spin_lock_irqsave(&amp;fnic-&gt;fnic_lock, flags);</span>
<span class="p_add">+	fnic-&gt;internal_reset_inprogress = 0;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;fnic-&gt;fnic_lock, flags);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/scsi/snic/snic_main.c b/drivers/scsi/snic/snic_main.c</span>
<span class="p_header">index 396b32dca074..7cf70aaec0ba 100644</span>
<span class="p_header">--- a/drivers/scsi/snic/snic_main.c</span>
<span class="p_header">+++ b/drivers/scsi/snic/snic_main.c</span>
<span class="p_chunk">@@ -591,6 +591,7 @@</span> <span class="p_context"> snic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	if (!pool) {
 		SNIC_HOST_ERR(shost, &quot;dflt sgl pool creation failed\n&quot;);
 
<span class="p_add">+		ret = -ENOMEM;</span>
 		goto err_free_res;
 	}
 
<span class="p_chunk">@@ -601,6 +602,7 @@</span> <span class="p_context"> snic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	if (!pool) {
 		SNIC_HOST_ERR(shost, &quot;max sgl pool creation failed\n&quot;);
 
<span class="p_add">+		ret = -ENOMEM;</span>
 		goto err_free_dflt_sgl_pool;
 	}
 
<span class="p_chunk">@@ -611,6 +613,7 @@</span> <span class="p_context"> snic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	if (!pool) {
 		SNIC_HOST_ERR(shost, &quot;snic tmreq info pool creation failed.\n&quot;);
 
<span class="p_add">+		ret = -ENOMEM;</span>
 		goto err_free_max_sgl_pool;
 	}
 
<span class="p_header">diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c</span>
<span class="p_header">index 27960e46135d..c4226c07e091 100644</span>
<span class="p_header">--- a/drivers/spi/spi-dw.c</span>
<span class="p_header">+++ b/drivers/spi/spi-dw.c</span>
<span class="p_chunk">@@ -107,7 +107,10 @@</span> <span class="p_context"> static const struct file_operations dw_spi_regs_ops = {</span>
 
 static int dw_spi_debugfs_init(struct dw_spi *dws)
 {
<span class="p_del">-	dws-&gt;debugfs = debugfs_create_dir(&quot;dw_spi&quot;, NULL);</span>
<span class="p_add">+	char name[128];</span>
<span class="p_add">+</span>
<span class="p_add">+	snprintf(name, 128, &quot;dw_spi-%s&quot;, dev_name(&amp;dws-&gt;master-&gt;dev));</span>
<span class="p_add">+	dws-&gt;debugfs = debugfs_create_dir(name, NULL);</span>
 	if (!dws-&gt;debugfs)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c</span>
<span class="p_header">index a34fd5afb9a8..ec9979070479 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/comedi_fops.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/comedi_fops.c</span>
<span class="p_chunk">@@ -2898,9 +2898,6 @@</span> <span class="p_context"> static int __init comedi_init(void)</span>
 
 	comedi_class-&gt;dev_groups = comedi_dev_groups;
 
<span class="p_del">-	/* XXX requires /proc interface */</span>
<span class="p_del">-	comedi_proc_init();</span>
<span class="p_del">-</span>
 	/* create devices files for legacy/manual use */
 	for (i = 0; i &lt; comedi_num_legacy_minors; i++) {
 		struct comedi_device *dev;
<span class="p_chunk">@@ -2918,6 +2915,9 @@</span> <span class="p_context"> static int __init comedi_init(void)</span>
 		mutex_unlock(&amp;dev-&gt;mutex);
 	}
 
<span class="p_add">+	/* XXX requires /proc interface */</span>
<span class="p_add">+	comedi_proc_init();</span>
<span class="p_add">+</span>
 	return 0;
 }
 module_init(comedi_init);
<span class="p_header">diff --git a/drivers/usb/dwc3/dwc3-omap.c b/drivers/usb/dwc3/dwc3-omap.c</span>
<span class="p_header">index 5dd1832564c7..35b63518baf6 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/dwc3-omap.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/dwc3-omap.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/platform_data/dwc3-omap.h&gt;
<span class="p_chunk">@@ -511,7 +512,7 @@</span> <span class="p_context"> static int dwc3_omap_probe(struct platform_device *pdev)</span>
 
 	/* check the DMA Status */
 	reg = dwc3_omap_readl(omap-&gt;base, USBOTGSS_SYSCONFIG);
<span class="p_del">-</span>
<span class="p_add">+	irq_set_status_flags(omap-&gt;irq, IRQ_NOAUTOEN);</span>
 	ret = devm_request_threaded_irq(dev, omap-&gt;irq, dwc3_omap_interrupt,
 					dwc3_omap_interrupt_thread, IRQF_SHARED,
 					&quot;dwc3-omap&quot;, omap);
<span class="p_chunk">@@ -532,7 +533,7 @@</span> <span class="p_context"> static int dwc3_omap_probe(struct platform_device *pdev)</span>
 	}
 
 	dwc3_omap_enable_irqs(omap);
<span class="p_del">-</span>
<span class="p_add">+	enable_irq(omap-&gt;irq);</span>
 	return 0;
 
 err2:
<span class="p_chunk">@@ -553,6 +554,7 @@</span> <span class="p_context"> static int dwc3_omap_remove(struct platform_device *pdev)</span>
 	extcon_unregister_notifier(omap-&gt;edev, EXTCON_USB, &amp;omap-&gt;vbus_nb);
 	extcon_unregister_notifier(omap-&gt;edev, EXTCON_USB_HOST, &amp;omap-&gt;id_nb);
 	dwc3_omap_disable_irqs(omap);
<span class="p_add">+	disable_irq(omap-&gt;irq);</span>
 	of_platform_depopulate(omap-&gt;dev);
 	pm_runtime_put_sync(&amp;pdev-&gt;dev);
 	pm_runtime_disable(&amp;pdev-&gt;dev);
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_hid.c b/drivers/usb/gadget/function/f_hid.c</span>
<span class="p_header">index b0f71957d00b..b6d4b484c51a 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_hid.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_hid.c</span>
<span class="p_chunk">@@ -582,7 +582,7 @@</span> <span class="p_context"> static int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)</span>
 		}
 		status = usb_ep_enable(hidg-&gt;out_ep);
 		if (status &lt; 0) {
<span class="p_del">-			ERROR(cdev, &quot;Enable IN endpoint FAILED!\n&quot;);</span>
<span class="p_add">+			ERROR(cdev, &quot;Enable OUT endpoint FAILED!\n&quot;);</span>
 			goto fail;
 		}
 		hidg-&gt;out_ep-&gt;driver_data = hidg;
<span class="p_header">diff --git a/drivers/vfio/pci/vfio_pci.c b/drivers/vfio/pci/vfio_pci.c</span>
<span class="p_header">index 031bc08d000d..43559bed7822 100644</span>
<span class="p_header">--- a/drivers/vfio/pci/vfio_pci.c</span>
<span class="p_header">+++ b/drivers/vfio/pci/vfio_pci.c</span>
<span class="p_chunk">@@ -1173,6 +1173,10 @@</span> <span class="p_context"> static int vfio_pci_mmap(void *device_data, struct vm_area_struct *vma)</span>
 			return ret;
 
 		vdev-&gt;barmap[index] = pci_iomap(pdev, index, 0);
<span class="p_add">+		if (!vdev-&gt;barmap[index]) {</span>
<span class="p_add">+			pci_release_selected_regions(pdev, 1 &lt;&lt; index);</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		}</span>
 	}
 
 	vma-&gt;vm_private_data = vdev;
<span class="p_header">diff --git a/drivers/vfio/pci/vfio_pci_rdwr.c b/drivers/vfio/pci/vfio_pci_rdwr.c</span>
<span class="p_header">index 5ffd1d9ad4bd..357243d76f10 100644</span>
<span class="p_header">--- a/drivers/vfio/pci/vfio_pci_rdwr.c</span>
<span class="p_header">+++ b/drivers/vfio/pci/vfio_pci_rdwr.c</span>
<span class="p_chunk">@@ -193,7 +193,10 @@</span> <span class="p_context"> ssize_t vfio_pci_vga_rw(struct vfio_pci_device *vdev, char __user *buf,</span>
 	if (!vdev-&gt;has_vga)
 		return -EINVAL;
 
<span class="p_del">-	switch (pos) {</span>
<span class="p_add">+	if (pos &gt; 0xbfffful)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch ((u32)pos) {</span>
 	case 0xa0000 ... 0xbffff:
 		count = min(count, (size_t)(0xc0000 - pos));
 		iomem = ioremap_nocache(0xa0000, 0xbffff - 0xa0000 + 1);
<span class="p_header">diff --git a/drivers/video/fbdev/cobalt_lcdfb.c b/drivers/video/fbdev/cobalt_lcdfb.c</span>
<span class="p_header">index 2d3b691f3fc4..038ac6934fe9 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/cobalt_lcdfb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/cobalt_lcdfb.c</span>
<span class="p_chunk">@@ -308,6 +308,11 @@</span> <span class="p_context"> static int cobalt_lcdfb_probe(struct platform_device *dev)</span>
 	info-&gt;screen_size = resource_size(res);
 	info-&gt;screen_base = devm_ioremap(&amp;dev-&gt;dev, res-&gt;start,
 					 info-&gt;screen_size);
<span class="p_add">+	if (!info-&gt;screen_base) {</span>
<span class="p_add">+		framebuffer_release(info);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	info-&gt;fbops = &amp;cobalt_lcd_fbops;
 	info-&gt;fix = cobalt_lcdfb_fix;
 	info-&gt;fix.smem_start = res-&gt;start;
<span class="p_header">diff --git a/drivers/xen/arm-device.c b/drivers/xen/arm-device.c</span>
<span class="p_header">index 778acf80aacb..85dd20e05726 100644</span>
<span class="p_header">--- a/drivers/xen/arm-device.c</span>
<span class="p_header">+++ b/drivers/xen/arm-device.c</span>
<span class="p_chunk">@@ -58,9 +58,13 @@</span> <span class="p_context"> static int xen_map_device_mmio(const struct resource *resources,</span>
 	xen_pfn_t *gpfns;
 	xen_ulong_t *idxs;
 	int *errs;
<span class="p_del">-	struct xen_add_to_physmap_range xatp;</span>
 
 	for (i = 0; i &lt; count; i++) {
<span class="p_add">+		struct xen_add_to_physmap_range xatp = {</span>
<span class="p_add">+			.domid = DOMID_SELF,</span>
<span class="p_add">+			.space = XENMAPSPACE_dev_mmio</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
 		r = &amp;resources[i];
 		nr = DIV_ROUND_UP(resource_size(r), XEN_PAGE_SIZE);
 		if ((resource_type(r) != IORESOURCE_MEM) || (nr == 0))
<span class="p_chunk">@@ -87,9 +91,7 @@</span> <span class="p_context"> static int xen_map_device_mmio(const struct resource *resources,</span>
 			idxs[j] = XEN_PFN_DOWN(r-&gt;start) + j;
 		}
 
<span class="p_del">-		xatp.domid = DOMID_SELF;</span>
 		xatp.size = nr;
<span class="p_del">-		xatp.space = XENMAPSPACE_dev_mmio;</span>
 
 		set_xen_guest_handle(xatp.gpfns, gpfns);
 		set_xen_guest_handle(xatp.idxs, idxs);
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index e46e7fbe1b34..14a37ff0b9e3 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -7401,7 +7401,8 @@</span> <span class="p_context"> btrfs_lock_cluster(struct btrfs_block_group_cache *block_group,</span>
 
 		spin_unlock(&amp;cluster-&gt;refill_lock);
 
<span class="p_del">-		down_read(&amp;used_bg-&gt;data_rwsem);</span>
<span class="p_add">+		/* We should only have one-level nested. */</span>
<span class="p_add">+		down_read_nested(&amp;used_bg-&gt;data_rwsem, SINGLE_DEPTH_NESTING);</span>
 
 		spin_lock(&amp;cluster-&gt;refill_lock);
 		if (used_bg == cluster-&gt;block_group)
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index a2a014b19f18..8a05fa7e2152 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -7648,11 +7648,18 @@</span> <span class="p_context"> static void adjust_dio_outstanding_extents(struct inode *inode,</span>
 	 * within our reservation, otherwise we need to adjust our inode
 	 * counter appropriately.
 	 */
<span class="p_del">-	if (dio_data-&gt;outstanding_extents) {</span>
<span class="p_add">+	if (dio_data-&gt;outstanding_extents &gt;= num_extents) {</span>
 		dio_data-&gt;outstanding_extents -= num_extents;
 	} else {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If dio write length has been split due to no large enough</span>
<span class="p_add">+		 * contiguous space, we need to compensate our inode counter</span>
<span class="p_add">+		 * appropriately.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u64 num_needed = num_extents - dio_data-&gt;outstanding_extents;</span>
<span class="p_add">+</span>
 		spin_lock(&amp;BTRFS_I(inode)-&gt;lock);
<span class="p_del">-		BTRFS_I(inode)-&gt;outstanding_extents += num_extents;</span>
<span class="p_add">+		BTRFS_I(inode)-&gt;outstanding_extents += num_needed;</span>
 		spin_unlock(&amp;BTRFS_I(inode)-&gt;lock);
 	}
 }
<span class="p_header">diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c</span>
<span class="p_header">index b89004513c09..309313b71617 100644</span>
<span class="p_header">--- a/fs/btrfs/tree-log.c</span>
<span class="p_header">+++ b/fs/btrfs/tree-log.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
  */
 #define LOG_INODE_ALL 0
 #define LOG_INODE_EXISTS 1
<span class="p_add">+#define LOG_OTHER_INODE 2</span>
 
 /*
  * directory trouble cases
<span class="p_chunk">@@ -4623,7 +4624,7 @@</span> <span class="p_context"> static int btrfs_log_inode(struct btrfs_trans_handle *trans,</span>
 	if (S_ISDIR(inode-&gt;i_mode) ||
 	    (!test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,
 		       &amp;BTRFS_I(inode)-&gt;runtime_flags) &amp;&amp;
<span class="p_del">-	     inode_only == LOG_INODE_EXISTS))</span>
<span class="p_add">+	     inode_only &gt;= LOG_INODE_EXISTS))</span>
 		max_key.type = BTRFS_XATTR_ITEM_KEY;
 	else
 		max_key.type = (u8)-1;
<span class="p_chunk">@@ -4647,7 +4648,13 @@</span> <span class="p_context"> static int btrfs_log_inode(struct btrfs_trans_handle *trans,</span>
 		return ret;
 	}
 
<span class="p_del">-	mutex_lock(&amp;BTRFS_I(inode)-&gt;log_mutex);</span>
<span class="p_add">+	if (inode_only == LOG_OTHER_INODE) {</span>
<span class="p_add">+		inode_only = LOG_INODE_EXISTS;</span>
<span class="p_add">+		mutex_lock_nested(&amp;BTRFS_I(inode)-&gt;log_mutex,</span>
<span class="p_add">+				  SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		mutex_lock(&amp;BTRFS_I(inode)-&gt;log_mutex);</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * a brute force approach to making sure we get the most uptodate
<span class="p_chunk">@@ -4799,7 +4806,7 @@</span> <span class="p_context"> static int btrfs_log_inode(struct btrfs_trans_handle *trans,</span>
 				 * unpin it.
 				 */
 				err = btrfs_log_inode(trans, root, other_inode,
<span class="p_del">-						      LOG_INODE_EXISTS,</span>
<span class="p_add">+						      LOG_OTHER_INODE,</span>
 						      0, LLONG_MAX, ctx);
 				iput(other_inode);
 				if (err)
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 1dbc6b560fef..67957f5b325c 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -277,6 +277,33 @@</span> <span class="p_context"> static inline int dname_external(const struct dentry *dentry)</span>
 	return dentry-&gt;d_name.name != dentry-&gt;d_iname;
 }
 
<span class="p_add">+void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	spin_lock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+	if (unlikely(dname_external(dentry))) {</span>
<span class="p_add">+		struct external_name *p = external_name(dentry);</span>
<span class="p_add">+		atomic_inc(&amp;p-&gt;u.count);</span>
<span class="p_add">+		spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+		name-&gt;name = p-&gt;name;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		memcpy(name-&gt;inline_name, dentry-&gt;d_iname, DNAME_INLINE_LEN);</span>
<span class="p_add">+		spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+		name-&gt;name = name-&gt;inline_name;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(take_dentry_name_snapshot);</span>
<span class="p_add">+</span>
<span class="p_add">+void release_dentry_name_snapshot(struct name_snapshot *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(name-&gt;name != name-&gt;inline_name)) {</span>
<span class="p_add">+		struct external_name *p;</span>
<span class="p_add">+		p = container_of(name-&gt;name, struct external_name, name[0]);</span>
<span class="p_add">+		if (unlikely(atomic_dec_and_test(&amp;p-&gt;u.count)))</span>
<span class="p_add">+			kfree_rcu(p, u.head);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(release_dentry_name_snapshot);</span>
<span class="p_add">+</span>
 static inline void __d_set_inode_and_type(struct dentry *dentry,
 					  struct inode *inode,
 					  unsigned type_flags)
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index 1e30f74a9527..3d7de9f4f545 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -730,7 +730,7 @@</span> <span class="p_context"> struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,</span>
 {
 	int error;
 	struct dentry *dentry = NULL, *trap;
<span class="p_del">-	const char *old_name;</span>
<span class="p_add">+	struct name_snapshot old_name;</span>
 
 	trap = lock_rename(new_dir, old_dir);
 	/* Source or destination directories don&#39;t exist? */
<span class="p_chunk">@@ -745,19 +745,19 @@</span> <span class="p_context"> struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,</span>
 	if (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))
 		goto exit;
 
<span class="p_del">-	old_name = fsnotify_oldname_init(old_dentry-&gt;d_name.name);</span>
<span class="p_add">+	take_dentry_name_snapshot(&amp;old_name, old_dentry);</span>
 
 	error = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),
 			      dentry, 0);
 	if (error) {
<span class="p_del">-		fsnotify_oldname_free(old_name);</span>
<span class="p_add">+		release_dentry_name_snapshot(&amp;old_name);</span>
 		goto exit;
 	}
 	d_move(old_dentry, dentry);
<span class="p_del">-	fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,</span>
<span class="p_add">+	fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,</span>
 		d_is_dir(old_dentry),
 		NULL, old_dentry);
<span class="p_del">-	fsnotify_oldname_free(old_name);</span>
<span class="p_add">+	release_dentry_name_snapshot(&amp;old_name);</span>
 	unlock_rename(new_dir, old_dir);
 	dput(dentry);
 	return old_dentry;
<span class="p_header">diff --git a/fs/jfs/acl.c b/fs/jfs/acl.c</span>
<span class="p_header">index 7bc186f4ed4d..1be45c8d460d 100644</span>
<span class="p_header">--- a/fs/jfs/acl.c</span>
<span class="p_header">+++ b/fs/jfs/acl.c</span>
<span class="p_chunk">@@ -77,13 +77,6 @@</span> <span class="p_context"> static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			rc = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_del">-			if (rc)</span>
<span class="p_del">-				return rc;</span>
<span class="p_del">-			inode-&gt;i_ctime = current_time(inode);</span>
<span class="p_del">-			mark_inode_dirty(inode);</span>
<span class="p_del">-		}</span>
 		break;
 	case ACL_TYPE_DEFAULT:
 		ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;
<span class="p_chunk">@@ -118,9 +111,17 @@</span> <span class="p_context"> int jfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 
 	tid = txBegin(inode-&gt;i_sb, 0);
 	mutex_lock(&amp;JFS_IP(inode)-&gt;commit_mutex);
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		rc = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (rc)</span>
<span class="p_add">+			goto end_tx;</span>
<span class="p_add">+		inode-&gt;i_ctime = current_time(inode);</span>
<span class="p_add">+		mark_inode_dirty(inode);</span>
<span class="p_add">+	}</span>
 	rc = __jfs_set_acl(tid, inode, type, acl);
 	if (!rc)
 		rc = txCommit(tid, 1, &amp;inode, 0);
<span class="p_add">+end_tx:</span>
 	txEnd(tid);
 	mutex_unlock(&amp;JFS_IP(inode)-&gt;commit_mutex);
 	return rc;
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index d5e5140c1045..66209f720146 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -4336,11 +4336,11 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 {
 	int error;
 	bool is_dir = d_is_dir(old_dentry);
<span class="p_del">-	const unsigned char *old_name;</span>
 	struct inode *source = old_dentry-&gt;d_inode;
 	struct inode *target = new_dentry-&gt;d_inode;
 	bool new_is_dir = false;
 	unsigned max_links = new_dir-&gt;i_sb-&gt;s_max_links;
<span class="p_add">+	struct name_snapshot old_name;</span>
 
 	/*
 	 * Check source == target.
<span class="p_chunk">@@ -4391,7 +4391,7 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 	if (error)
 		return error;
 
<span class="p_del">-	old_name = fsnotify_oldname_init(old_dentry-&gt;d_name.name);</span>
<span class="p_add">+	take_dentry_name_snapshot(&amp;old_name, old_dentry);</span>
 	dget(new_dentry);
 	if (!is_dir || (flags &amp; RENAME_EXCHANGE))
 		lock_two_nondirectories(source, target);
<span class="p_chunk">@@ -4446,14 +4446,14 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 		inode_unlock(target);
 	dput(new_dentry);
 	if (!error) {
<span class="p_del">-		fsnotify_move(old_dir, new_dir, old_name, is_dir,</span>
<span class="p_add">+		fsnotify_move(old_dir, new_dir, old_name.name, is_dir,</span>
 			      !(flags &amp; RENAME_EXCHANGE) ? target : NULL, old_dentry);
 		if (flags &amp; RENAME_EXCHANGE) {
 			fsnotify_move(new_dir, old_dir, old_dentry-&gt;d_name.name,
 				      new_is_dir, NULL, new_dentry);
 		}
 	}
<span class="p_del">-	fsnotify_oldname_free(old_name);</span>
<span class="p_add">+	release_dentry_name_snapshot(&amp;old_name);</span>
 
 	return error;
 }
<span class="p_header">diff --git a/fs/nfs/file.c b/fs/nfs/file.c</span>
<span class="p_header">index a1de8ef63e56..84c1cb9237d0 100644</span>
<span class="p_header">--- a/fs/nfs/file.c</span>
<span class="p_header">+++ b/fs/nfs/file.c</span>
<span class="p_chunk">@@ -757,7 +757,7 @@</span> <span class="p_context"> do_setlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)</span>
 	 */
 	nfs_sync_mapping(filp-&gt;f_mapping);
 	if (!NFS_PROTO(inode)-&gt;have_delegation(inode, FMODE_READ))
<span class="p_del">-		nfs_zap_mapping(inode, filp-&gt;f_mapping);</span>
<span class="p_add">+		nfs_zap_caches(inode);</span>
 out:
 	return status;
 }
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 401ea6e4cab8..46ca7881d80d 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -6419,7 +6419,7 @@</span> <span class="p_context"> nfs4_retry_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)</span>
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_irqrestore(&amp;q-&gt;lock, flags);
 
<span class="p_del">-		freezable_schedule_timeout_interruptible(NFS4_LOCK_MAXTIMEOUT);</span>
<span class="p_add">+		freezable_schedule_timeout(NFS4_LOCK_MAXTIMEOUT);</span>
 	}
 
 	finish_wait(q, &amp;wait);
<span class="p_header">diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.c</span>
<span class="p_header">index db39de2dd4cb..a64adc2fced9 100644</span>
<span class="p_header">--- a/fs/notify/fsnotify.c</span>
<span class="p_header">+++ b/fs/notify/fsnotify.c</span>
<span class="p_chunk">@@ -104,16 +104,20 @@</span> <span class="p_context"> int __fsnotify_parent(struct path *path, struct dentry *dentry, __u32 mask)</span>
 	if (unlikely(!fsnotify_inode_watches_children(p_inode)))
 		__fsnotify_update_child_dentry_flags(p_inode);
 	else if (p_inode-&gt;i_fsnotify_mask &amp; mask) {
<span class="p_add">+		struct name_snapshot name;</span>
<span class="p_add">+</span>
 		/* we are notifying a parent so come up with the new mask which
 		 * specifies these are events which came from a child. */
 		mask |= FS_EVENT_ON_CHILD;
 
<span class="p_add">+		take_dentry_name_snapshot(&amp;name, dentry);</span>
 		if (path)
 			ret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,
<span class="p_del">-				       dentry-&gt;d_name.name, 0);</span>
<span class="p_add">+				       name.name, 0);</span>
 		else
 			ret = fsnotify(p_inode, mask, dentry-&gt;d_inode, FSNOTIFY_EVENT_INODE,
<span class="p_del">-				       dentry-&gt;d_name.name, 0);</span>
<span class="p_add">+				       name.name, 0);</span>
<span class="p_add">+		release_dentry_name_snapshot(&amp;name);</span>
 	}
 
 	dput(parent);
<span class="p_header">diff --git a/fs/pstore/ram.c b/fs/pstore/ram.c</span>
<span class="p_header">index 6ad831b9d1b8..8b09271e5d66 100644</span>
<span class="p_header">--- a/fs/pstore/ram.c</span>
<span class="p_header">+++ b/fs/pstore/ram.c</span>
<span class="p_chunk">@@ -434,7 +434,7 @@</span> <span class="p_context"> static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,</span>
 	for (i = 0; i &lt; cxt-&gt;max_dump_cnt; i++) {
 		cxt-&gt;przs[i] = persistent_ram_new(*paddr, cxt-&gt;record_size, 0,
 						  &amp;cxt-&gt;ecc_info,
<span class="p_del">-						  cxt-&gt;memtype);</span>
<span class="p_add">+						  cxt-&gt;memtype, 0);</span>
 		if (IS_ERR(cxt-&gt;przs[i])) {
 			err = PTR_ERR(cxt-&gt;przs[i]);
 			dev_err(dev, &quot;failed to request mem region (0x%zx@0x%llx): %d\n&quot;,
<span class="p_chunk">@@ -471,7 +471,8 @@</span> <span class="p_context"> static int ramoops_init_prz(struct device *dev, struct ramoops_context *cxt,</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	*prz = persistent_ram_new(*paddr, sz, sig, &amp;cxt-&gt;ecc_info, cxt-&gt;memtype);</span>
<span class="p_add">+	*prz = persistent_ram_new(*paddr, sz, sig, &amp;cxt-&gt;ecc_info,</span>
<span class="p_add">+				  cxt-&gt;memtype, 0);</span>
 	if (IS_ERR(*prz)) {
 		int err = PTR_ERR(*prz);
 
<span class="p_header">diff --git a/fs/pstore/ram_core.c b/fs/pstore/ram_core.c</span>
<span class="p_header">index 3975deec02f8..e11672aa4575 100644</span>
<span class="p_header">--- a/fs/pstore/ram_core.c</span>
<span class="p_header">+++ b/fs/pstore/ram_core.c</span>
<span class="p_chunk">@@ -48,16 +48,15 @@</span> <span class="p_context"> static inline size_t buffer_start(struct persistent_ram_zone *prz)</span>
 	return atomic_read(&amp;prz-&gt;buffer-&gt;start);
 }
 
<span class="p_del">-static DEFINE_RAW_SPINLOCK(buffer_lock);</span>
<span class="p_del">-</span>
 /* increase and wrap the start pointer, returning the old value */
 static size_t buffer_start_add(struct persistent_ram_zone *prz, size_t a)
 {
 	int old;
 	int new;
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	unsigned long flags = 0;</span>
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;buffer_lock, flags);</span>
<span class="p_add">+	if (!(prz-&gt;flags &amp; PRZ_FLAG_NO_LOCK))</span>
<span class="p_add">+		raw_spin_lock_irqsave(&amp;prz-&gt;buffer_lock, flags);</span>
 
 	old = atomic_read(&amp;prz-&gt;buffer-&gt;start);
 	new = old + a;
<span class="p_chunk">@@ -65,7 +64,8 @@</span> <span class="p_context"> static size_t buffer_start_add(struct persistent_ram_zone *prz, size_t a)</span>
 		new -= prz-&gt;buffer_size;
 	atomic_set(&amp;prz-&gt;buffer-&gt;start, new);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;buffer_lock, flags);</span>
<span class="p_add">+	if (!(prz-&gt;flags &amp; PRZ_FLAG_NO_LOCK))</span>
<span class="p_add">+		raw_spin_unlock_irqrestore(&amp;prz-&gt;buffer_lock, flags);</span>
 
 	return old;
 }
<span class="p_chunk">@@ -75,9 +75,10 @@</span> <span class="p_context"> static void buffer_size_add(struct persistent_ram_zone *prz, size_t a)</span>
 {
 	size_t old;
 	size_t new;
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	unsigned long flags = 0;</span>
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;buffer_lock, flags);</span>
<span class="p_add">+	if (!(prz-&gt;flags &amp; PRZ_FLAG_NO_LOCK))</span>
<span class="p_add">+		raw_spin_lock_irqsave(&amp;prz-&gt;buffer_lock, flags);</span>
 
 	old = atomic_read(&amp;prz-&gt;buffer-&gt;size);
 	if (old == prz-&gt;buffer_size)
<span class="p_chunk">@@ -89,7 +90,8 @@</span> <span class="p_context"> static void buffer_size_add(struct persistent_ram_zone *prz, size_t a)</span>
 	atomic_set(&amp;prz-&gt;buffer-&gt;size, new);
 
 exit:
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;buffer_lock, flags);</span>
<span class="p_add">+	if (!(prz-&gt;flags &amp; PRZ_FLAG_NO_LOCK))</span>
<span class="p_add">+		raw_spin_unlock_irqrestore(&amp;prz-&gt;buffer_lock, flags);</span>
 }
 
 static void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,
<span class="p_chunk">@@ -491,6 +493,7 @@</span> <span class="p_context"> static int persistent_ram_post_init(struct persistent_ram_zone *prz, u32 sig,</span>
 			 prz-&gt;buffer-&gt;sig);
 	}
 
<span class="p_add">+	/* Rewind missing or invalid memory area. */</span>
 	prz-&gt;buffer-&gt;sig = sig;
 	persistent_ram_zap(prz);
 
<span class="p_chunk">@@ -517,7 +520,7 @@</span> <span class="p_context"> void persistent_ram_free(struct persistent_ram_zone *prz)</span>
 
 struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,
 			u32 sig, struct persistent_ram_ecc_info *ecc_info,
<span class="p_del">-			unsigned int memtype)</span>
<span class="p_add">+			unsigned int memtype, u32 flags)</span>
 {
 	struct persistent_ram_zone *prz;
 	int ret = -ENOMEM;
<span class="p_chunk">@@ -528,6 +531,10 @@</span> <span class="p_context"> struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,</span>
 		goto err;
 	}
 
<span class="p_add">+	/* Initialize general buffer state. */</span>
<span class="p_add">+	raw_spin_lock_init(&amp;prz-&gt;buffer_lock);</span>
<span class="p_add">+	prz-&gt;flags = flags;</span>
<span class="p_add">+</span>
 	ret = persistent_ram_buffer_map(start, size, prz, memtype);
 	if (ret)
 		goto err;
<span class="p_header">diff --git a/include/linux/dcache.h b/include/linux/dcache.h</span>
<span class="p_header">index 5beed7b30561..ff295e166b2c 100644</span>
<span class="p_header">--- a/include/linux/dcache.h</span>
<span class="p_header">+++ b/include/linux/dcache.h</span>
<span class="p_chunk">@@ -590,5 +590,11 @@</span> <span class="p_context"> static inline struct inode *d_real_inode(const struct dentry *dentry)</span>
 	return d_backing_inode(d_real((struct dentry *) dentry, NULL, 0));
 }
 
<span class="p_add">+struct name_snapshot {</span>
<span class="p_add">+	const char *name;</span>
<span class="p_add">+	char inline_name[DNAME_INLINE_LEN];</span>
<span class="p_add">+};</span>
<span class="p_add">+void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);</span>
<span class="p_add">+void release_dentry_name_snapshot(struct name_snapshot *);</span>
 
 #endif	/* __LINUX_DCACHE_H */
<span class="p_header">diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h</span>
<span class="p_header">index b8bcc058e031..e5f03a4d8430 100644</span>
<span class="p_header">--- a/include/linux/fsnotify.h</span>
<span class="p_header">+++ b/include/linux/fsnotify.h</span>
<span class="p_chunk">@@ -293,35 +293,4 @@</span> <span class="p_context"> static inline void fsnotify_change(struct dentry *dentry, unsigned int ia_valid)</span>
 	}
 }
 
<span class="p_del">-#if defined(CONFIG_FSNOTIFY)	/* notify helpers */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * fsnotify_oldname_init - save off the old filename before we change it</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return kstrdup(name, GFP_KERNEL);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * fsnotify_oldname_free - free the name we got from fsnotify_oldname_init</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void fsnotify_oldname_free(const unsigned char *old_name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	kfree(old_name);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#else	/* CONFIG_FSNOTIFY */</span>
<span class="p_del">-</span>
<span class="p_del">-static inline const char *fsnotify_oldname_init(const unsigned char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void fsnotify_oldname_free(const unsigned char *old_name)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#endif	/*  CONFIG_FSNOTIFY */</span>
<span class="p_del">-</span>
 #endif	/* _LINUX_FS_NOTIFY_H */
<span class="p_header">diff --git a/include/linux/mlx4/device.h b/include/linux/mlx4/device.h</span>
<span class="p_header">index c9f379689dd0..80faf44b8887 100644</span>
<span class="p_header">--- a/include/linux/mlx4/device.h</span>
<span class="p_header">+++ b/include/linux/mlx4/device.h</span>
<span class="p_chunk">@@ -1384,6 +1384,8 @@</span> <span class="p_context"> int set_phv_bit(struct mlx4_dev *dev, u8 port, int new_val);</span>
 int get_phv_bit(struct mlx4_dev *dev, u8 port, int *phv);
 int mlx4_get_is_vlan_offload_disabled(struct mlx4_dev *dev, u8 port,
 				      bool *vlan_offload_disabled);
<span class="p_add">+void mlx4_handle_eth_header_mcast_prio(struct mlx4_net_trans_rule_hw_ctrl *ctrl,</span>
<span class="p_add">+				       struct _rule_hw *eth_header);</span>
 int mlx4_find_cached_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *idx);
 int mlx4_find_cached_vlan(struct mlx4_dev *dev, u8 port, u16 vid, int *idx);
 int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index);
<span class="p_header">diff --git a/include/linux/phy.h b/include/linux/phy.h</span>
<span class="p_header">index 6c9b1e0006ee..8431c8c0c320 100644</span>
<span class="p_header">--- a/include/linux/phy.h</span>
<span class="p_header">+++ b/include/linux/phy.h</span>
<span class="p_chunk">@@ -799,6 +799,10 @@</span> <span class="p_context"> int genphy_read_status(struct phy_device *phydev);</span>
 int genphy_suspend(struct phy_device *phydev);
 int genphy_resume(struct phy_device *phydev);
 int genphy_soft_reset(struct phy_device *phydev);
<span class="p_add">+static inline int genphy_no_soft_reset(struct phy_device *phydev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 void phy_driver_unregister(struct phy_driver *drv);
 void phy_drivers_unregister(struct phy_driver *drv, int n);
 int phy_driver_register(struct phy_driver *new_driver, struct module *owner);
<span class="p_header">diff --git a/include/linux/pstore_ram.h b/include/linux/pstore_ram.h</span>
<span class="p_header">index c668c861c96c..4058bf991868 100644</span>
<span class="p_header">--- a/include/linux/pstore_ram.h</span>
<span class="p_header">+++ b/include/linux/pstore_ram.h</span>
<span class="p_chunk">@@ -24,6 +24,13 @@</span> <span class="p_context"></span>
 #include &lt;linux/list.h&gt;
 #include &lt;linux/types.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Choose whether access to the RAM zone requires locking or not.  If a zone</span>
<span class="p_add">+ * can be written to from different CPUs like with ftrace for example, then</span>
<span class="p_add">+ * PRZ_FLAG_NO_LOCK is used. For all other cases, locking is required.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PRZ_FLAG_NO_LOCK	BIT(0)</span>
<span class="p_add">+</span>
 struct persistent_ram_buffer;
 struct rs_control;
 
<span class="p_chunk">@@ -40,6 +47,8 @@</span> <span class="p_context"> struct persistent_ram_zone {</span>
 	void *vaddr;
 	struct persistent_ram_buffer *buffer;
 	size_t buffer_size;
<span class="p_add">+	u32 flags;</span>
<span class="p_add">+	raw_spinlock_t buffer_lock;</span>
 
 	/* ECC correction */
 	char *par_buffer;
<span class="p_chunk">@@ -55,7 +64,7 @@</span> <span class="p_context"> struct persistent_ram_zone {</span>
 
 struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,
 			u32 sig, struct persistent_ram_ecc_info *ecc_info,
<span class="p_del">-			unsigned int memtype);</span>
<span class="p_add">+			unsigned int memtype, u32 flags);</span>
 void persistent_ram_free(struct persistent_ram_zone *prz);
 void persistent_ram_zap(struct persistent_ram_zone *prz);
 
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index 8f52977aad59..26a4f74bff83 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -410,11 +410,26 @@</span> <span class="p_context"> static int notify_online(unsigned int cpu)</span>
 	return 0;
 }
 
<span class="p_add">+static void __cpuhp_kick_ap_work(struct cpuhp_cpu_state *st);</span>
<span class="p_add">+</span>
 static int bringup_wait_for_ap(unsigned int cpu)
 {
 	struct cpuhp_cpu_state *st = per_cpu_ptr(&amp;cpuhp_state, cpu);
 
<span class="p_add">+	/* Wait for the CPU to reach CPUHP_AP_ONLINE_IDLE */</span>
 	wait_for_completion(&amp;st-&gt;done);
<span class="p_add">+	if (WARN_ON_ONCE((!cpu_online(cpu))))</span>
<span class="p_add">+		return -ECANCELED;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Unpark the stopper thread and the hotplug thread of the target cpu */</span>
<span class="p_add">+	stop_machine_unpark(cpu);</span>
<span class="p_add">+	kthread_unpark(st-&gt;thread);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Should we go further up ? */</span>
<span class="p_add">+	if (st-&gt;target &gt; CPUHP_AP_ONLINE_IDLE) {</span>
<span class="p_add">+		__cpuhp_kick_ap_work(st);</span>
<span class="p_add">+		wait_for_completion(&amp;st-&gt;done);</span>
<span class="p_add">+	}</span>
 	return st-&gt;result;
 }
 
<span class="p_chunk">@@ -437,9 +452,7 @@</span> <span class="p_context"> static int bringup_cpu(unsigned int cpu)</span>
 		cpu_notify(CPU_UP_CANCELED, cpu);
 		return ret;
 	}
<span class="p_del">-	ret = bringup_wait_for_ap(cpu);</span>
<span class="p_del">-	BUG_ON(!cpu_online(cpu));</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return bringup_wait_for_ap(cpu);</span>
 }
 
 /*
<span class="p_chunk">@@ -974,31 +987,20 @@</span> <span class="p_context"> void notify_cpu_starting(unsigned int cpu)</span>
 }
 
 /*
<span class="p_del">- * Called from the idle task. We need to set active here, so we can kick off</span>
<span class="p_del">- * the stopper thread and unpark the smpboot threads. If the target state is</span>
<span class="p_del">- * beyond CPUHP_AP_ONLINE_IDLE we kick cpuhp thread and let it bring up the</span>
<span class="p_del">- * cpu further.</span>
<span class="p_add">+ * Called from the idle task. Wake up the controlling task which brings the</span>
<span class="p_add">+ * stopper and the hotplug thread of the upcoming CPU up and then delegates</span>
<span class="p_add">+ * the rest of the online bringup to the hotplug thread.</span>
  */
 void cpuhp_online_idle(enum cpuhp_state state)
 {
 	struct cpuhp_cpu_state *st = this_cpu_ptr(&amp;cpuhp_state);
<span class="p_del">-	unsigned int cpu = smp_processor_id();</span>
 
 	/* Happens for the boot cpu */
 	if (state != CPUHP_AP_ONLINE_IDLE)
 		return;
 
 	st-&gt;state = CPUHP_AP_ONLINE_IDLE;
<span class="p_del">-</span>
<span class="p_del">-	/* Unpark the stopper thread and the hotplug thread of this cpu */</span>
<span class="p_del">-	stop_machine_unpark(cpu);</span>
<span class="p_del">-	kthread_unpark(st-&gt;thread);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Should we go further up ? */</span>
<span class="p_del">-	if (st-&gt;target &gt; CPUHP_AP_ONLINE_IDLE)</span>
<span class="p_del">-		__cpuhp_kick_ap_work(st);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		complete(&amp;st-&gt;done);</span>
<span class="p_add">+	complete(&amp;st-&gt;done);</span>
 }
 
 /* Requires cpu_add_remove_lock to be held */
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index d177b21d04ce..2098954c690f 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -8376,11 +8376,20 @@</span> <span class="p_context"> cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)</span>
 	if (IS_ERR(tg))
 		return ERR_PTR(-ENOMEM);
 
<span class="p_del">-	sched_online_group(tg, parent);</span>
<span class="p_del">-</span>
 	return &amp;tg-&gt;css;
 }
 
<span class="p_add">+/* Expose task group only after completing cgroup initialization */</span>
<span class="p_add">+static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_group *tg = css_tg(css);</span>
<span class="p_add">+	struct task_group *parent = css_tg(css-&gt;parent);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (parent)</span>
<span class="p_add">+		sched_online_group(tg, parent);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cpu_cgroup_css_released(struct cgroup_subsys_state *css)
 {
 	struct task_group *tg = css_tg(css);
<span class="p_chunk">@@ -8783,6 +8792,7 @@</span> <span class="p_context"> static struct cftype cpu_files[] = {</span>
 
 struct cgroup_subsys cpu_cgrp_subsys = {
 	.css_alloc	= cpu_cgroup_css_alloc,
<span class="p_add">+	.css_online	= cpu_cgroup_css_online,</span>
 	.css_released	= cpu_cgroup_css_released,
 	.css_free	= cpu_cgroup_css_free,
 	.fork		= cpu_cgroup_fork,
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index c17952b6e0b6..0af019dfe846 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2702,9 +2702,10 @@</span> <span class="p_context"> EXPORT_SYMBOL(skb_mac_gso_segment);</span>
 static inline bool skb_needs_check(struct sk_buff *skb, bool tx_path)
 {
 	if (tx_path)
<span class="p_del">-		return skb-&gt;ip_summed != CHECKSUM_PARTIAL;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return skb-&gt;ip_summed == CHECKSUM_NONE;</span>
<span class="p_add">+		return skb-&gt;ip_summed != CHECKSUM_PARTIAL &amp;&amp;</span>
<span class="p_add">+		       skb-&gt;ip_summed != CHECKSUM_NONE;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skb-&gt;ip_summed == CHECKSUM_NONE;</span>
 }
 
 /**
<span class="p_chunk">@@ -2723,11 +2724,12 @@</span> <span class="p_context"> static inline bool skb_needs_check(struct sk_buff *skb, bool tx_path)</span>
 struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 				  netdev_features_t features, bool tx_path)
 {
<span class="p_add">+	struct sk_buff *segs;</span>
<span class="p_add">+</span>
 	if (unlikely(skb_needs_check(skb, tx_path))) {
 		int err;
 
<span class="p_del">-		skb_warn_bad_offload(skb);</span>
<span class="p_del">-</span>
<span class="p_add">+		/* We&#39;re going to init -&gt;check field in TCP or UDP header */</span>
 		err = skb_cow_head(skb, 0);
 		if (err &lt; 0)
 			return ERR_PTR(err);
<span class="p_chunk">@@ -2755,7 +2757,12 @@</span> <span class="p_context"> struct sk_buff *__skb_gso_segment(struct sk_buff *skb,</span>
 	skb_reset_mac_header(skb);
 	skb_reset_mac_len(skb);
 
<span class="p_del">-	return skb_mac_gso_segment(skb, features);</span>
<span class="p_add">+	segs = skb_mac_gso_segment(skb, features);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(skb_needs_check(skb, tx_path)))</span>
<span class="p_add">+		skb_warn_bad_offload(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	return segs;</span>
 }
 EXPORT_SYMBOL(__skb_gso_segment);
 
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index fd649599620e..5a4b8e7bcedd 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1376,7 +1376,7 @@</span> <span class="p_context"> static int __ip6_append_data(struct sock *sk,</span>
 	 */
 
 	cork-&gt;length += length;
<span class="p_del">-	if (((length &gt; mtu) ||</span>
<span class="p_add">+	if ((((length + fragheaderlen) &gt; mtu) ||</span>
 	     (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !rt-&gt;dst.header_len &amp;&amp;
<span class="p_header">diff --git a/net/key/af_key.c b/net/key/af_key.c</span>
<span class="p_header">index d8d95b6415e4..2e1050ec2cf0 100644</span>
<span class="p_header">--- a/net/key/af_key.c</span>
<span class="p_header">+++ b/net/key/af_key.c</span>
<span class="p_chunk">@@ -63,6 +63,7 @@</span> <span class="p_context"> struct pfkey_sock {</span>
 		} u;
 		struct sk_buff	*skb;
 	} dump;
<span class="p_add">+	struct mutex dump_lock;</span>
 };
 
 static int parse_sockaddr_pair(struct sockaddr *sa, int ext_len,
<span class="p_chunk">@@ -143,6 +144,7 @@</span> <span class="p_context"> static int pfkey_create(struct net *net, struct socket *sock, int protocol,</span>
 {
 	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
 	struct sock *sk;
<span class="p_add">+	struct pfkey_sock *pfk;</span>
 	int err;
 
 	if (!ns_capable(net-&gt;user_ns, CAP_NET_ADMIN))
<span class="p_chunk">@@ -157,6 +159,9 @@</span> <span class="p_context"> static int pfkey_create(struct net *net, struct socket *sock, int protocol,</span>
 	if (sk == NULL)
 		goto out;
 
<span class="p_add">+	pfk = pfkey_sk(sk);</span>
<span class="p_add">+	mutex_init(&amp;pfk-&gt;dump_lock);</span>
<span class="p_add">+</span>
 	sock-&gt;ops = &amp;pfkey_ops;
 	sock_init_data(sock, sk);
 
<span class="p_chunk">@@ -285,13 +290,23 @@</span> <span class="p_context"> static int pfkey_do_dump(struct pfkey_sock *pfk)</span>
 	struct sadb_msg *hdr;
 	int rc;
 
<span class="p_add">+	mutex_lock(&amp;pfk-&gt;dump_lock);</span>
<span class="p_add">+	if (!pfk-&gt;dump.dump) {</span>
<span class="p_add">+		rc = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	rc = pfk-&gt;dump.dump(pfk);
<span class="p_del">-	if (rc == -ENOBUFS)</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	if (rc == -ENOBUFS) {</span>
<span class="p_add">+		rc = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	if (pfk-&gt;dump.skb) {
<span class="p_del">-		if (!pfkey_can_dump(&amp;pfk-&gt;sk))</span>
<span class="p_del">-			return 0;</span>
<span class="p_add">+		if (!pfkey_can_dump(&amp;pfk-&gt;sk)) {</span>
<span class="p_add">+			rc = 0;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 
 		hdr = (struct sadb_msg *) pfk-&gt;dump.skb-&gt;data;
 		hdr-&gt;sadb_msg_seq = 0;
<span class="p_chunk">@@ -302,6 +317,9 @@</span> <span class="p_context"> static int pfkey_do_dump(struct pfkey_sock *pfk)</span>
 	}
 
 	pfkey_terminate_dump(pfk);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;pfk-&gt;dump_lock);</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -1806,19 +1824,26 @@</span> <span class="p_context"> static int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_ms</span>
 	struct xfrm_address_filter *filter = NULL;
 	struct pfkey_sock *pfk = pfkey_sk(sk);
 
<span class="p_del">-	if (pfk-&gt;dump.dump != NULL)</span>
<span class="p_add">+	mutex_lock(&amp;pfk-&gt;dump_lock);</span>
<span class="p_add">+	if (pfk-&gt;dump.dump != NULL) {</span>
<span class="p_add">+		mutex_unlock(&amp;pfk-&gt;dump_lock);</span>
 		return -EBUSY;
<span class="p_add">+	}</span>
 
 	proto = pfkey_satype2proto(hdr-&gt;sadb_msg_satype);
<span class="p_del">-	if (proto == 0)</span>
<span class="p_add">+	if (proto == 0) {</span>
<span class="p_add">+		mutex_unlock(&amp;pfk-&gt;dump_lock);</span>
 		return -EINVAL;
<span class="p_add">+	}</span>
 
 	if (ext_hdrs[SADB_X_EXT_FILTER - 1]) {
 		struct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];
 
 		filter = kmalloc(sizeof(*filter), GFP_KERNEL);
<span class="p_del">-		if (filter == NULL)</span>
<span class="p_add">+		if (filter == NULL) {</span>
<span class="p_add">+			mutex_unlock(&amp;pfk-&gt;dump_lock);</span>
 			return -ENOMEM;
<span class="p_add">+		}</span>
 
 		memcpy(&amp;filter-&gt;saddr, &amp;xfilter-&gt;sadb_x_filter_saddr,
 		       sizeof(xfrm_address_t));
<span class="p_chunk">@@ -1834,6 +1859,7 @@</span> <span class="p_context"> static int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_ms</span>
 	pfk-&gt;dump.dump = pfkey_dump_sa;
 	pfk-&gt;dump.done = pfkey_dump_sa_done;
 	xfrm_state_walk_init(&amp;pfk-&gt;dump.u.state, proto, filter);
<span class="p_add">+	mutex_unlock(&amp;pfk-&gt;dump_lock);</span>
 
 	return pfkey_do_dump(pfk);
 }
<span class="p_chunk">@@ -2693,14 +2719,18 @@</span> <span class="p_context"> static int pfkey_spddump(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 {
 	struct pfkey_sock *pfk = pfkey_sk(sk);
 
<span class="p_del">-	if (pfk-&gt;dump.dump != NULL)</span>
<span class="p_add">+	mutex_lock(&amp;pfk-&gt;dump_lock);</span>
<span class="p_add">+	if (pfk-&gt;dump.dump != NULL) {</span>
<span class="p_add">+		mutex_unlock(&amp;pfk-&gt;dump_lock);</span>
 		return -EBUSY;
<span class="p_add">+	}</span>
 
 	pfk-&gt;dump.msg_version = hdr-&gt;sadb_msg_version;
 	pfk-&gt;dump.msg_portid = hdr-&gt;sadb_msg_pid;
 	pfk-&gt;dump.dump = pfkey_dump_sp;
 	pfk-&gt;dump.done = pfkey_dump_sp_done;
 	xfrm_policy_walk_init(&amp;pfk-&gt;dump.u.policy, XFRM_POLICY_TYPE_MAIN);
<span class="p_add">+	mutex_unlock(&amp;pfk-&gt;dump_lock);</span>
 
 	return pfkey_do_dump(pfk);
 }
<span class="p_header">diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">index b10abef6b0a0..1d522ce833e6 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip6.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> static struct sock *__l2tp_ip6_bind_lookup(struct net *net,</span>
 	struct sock *sk;
 
 	sk_for_each_bound(sk, &amp;l2tp_ip6_bind_table) {
<span class="p_del">-		const struct in6_addr *addr = inet6_rcv_saddr(sk);</span>
<span class="p_add">+		const struct in6_addr *sk_laddr = inet6_rcv_saddr(sk);</span>
 		struct l2tp_ip6_sock *l2tp = l2tp_ip6_sk(sk);
 
 		if (l2tp == NULL)
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> static struct sock *__l2tp_ip6_bind_lookup(struct net *net,</span>
 
 		if ((l2tp-&gt;conn_id == tunnel_id) &amp;&amp;
 		    net_eq(sock_net(sk), net) &amp;&amp;
<span class="p_del">-		    (!addr || ipv6_addr_equal(addr, laddr)) &amp;&amp;</span>
<span class="p_add">+		    (!sk_laddr || ipv6_addr_any(sk_laddr) || ipv6_addr_equal(sk_laddr, laddr)) &amp;&amp;</span>
 		    (!sk-&gt;sk_bound_dev_if || !dif ||
 		     sk-&gt;sk_bound_dev_if == dif))
 			goto found;
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index 8da67f7c9c5a..e26b515f7794 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -1248,7 +1248,7 @@</span> <span class="p_context"> static inline int policy_to_flow_dir(int dir)</span>
 }
 
 static struct xfrm_policy *xfrm_sk_policy_lookup(const struct sock *sk, int dir,
<span class="p_del">-						 const struct flowi *fl)</span>
<span class="p_add">+						 const struct flowi *fl, u16 family)</span>
 {
 	struct xfrm_policy *pol;
 
<span class="p_chunk">@@ -1256,8 +1256,7 @@</span> <span class="p_context"> static struct xfrm_policy *xfrm_sk_policy_lookup(const struct sock *sk, int dir,</span>
  again:
 	pol = rcu_dereference(sk-&gt;sk_policy[dir]);
 	if (pol != NULL) {
<span class="p_del">-		bool match = xfrm_selector_match(&amp;pol-&gt;selector, fl,</span>
<span class="p_del">-						 sk-&gt;sk_family);</span>
<span class="p_add">+		bool match = xfrm_selector_match(&amp;pol-&gt;selector, fl, family);</span>
 		int err = 0;
 
 		if (match) {
<span class="p_chunk">@@ -2206,7 +2205,7 @@</span> <span class="p_context"> struct dst_entry *xfrm_lookup(struct net *net, struct dst_entry *dst_orig,</span>
 	sk = sk_const_to_full_sk(sk);
 	if (sk &amp;&amp; sk-&gt;sk_policy[XFRM_POLICY_OUT]) {
 		num_pols = 1;
<span class="p_del">-		pols[0] = xfrm_sk_policy_lookup(sk, XFRM_POLICY_OUT, fl);</span>
<span class="p_add">+		pols[0] = xfrm_sk_policy_lookup(sk, XFRM_POLICY_OUT, fl, family);</span>
 		err = xfrm_expand_policies(fl, family, pols,
 					   &amp;num_pols, &amp;num_xfrms);
 		if (err &lt; 0)
<span class="p_chunk">@@ -2485,7 +2484,7 @@</span> <span class="p_context"> int __xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb,</span>
 	pol = NULL;
 	sk = sk_to_full_sk(sk);
 	if (sk &amp;&amp; sk-&gt;sk_policy[dir]) {
<span class="p_del">-		pol = xfrm_sk_policy_lookup(sk, dir, &amp;fl);</span>
<span class="p_add">+		pol = xfrm_sk_policy_lookup(sk, dir, &amp;fl, family);</span>
 		if (IS_ERR(pol)) {
 			XFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);
 			return 0;
<span class="p_header">diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c</span>
<span class="p_header">index c47287d79306..a178e0d03088 100644</span>
<span class="p_header">--- a/sound/pci/fm801.c</span>
<span class="p_header">+++ b/sound/pci/fm801.c</span>
<span class="p_chunk">@@ -1235,8 +1235,6 @@</span> <span class="p_context"> static int snd_fm801_create(struct snd_card *card,</span>
 		}
 	}
 
<span class="p_del">-	snd_fm801_chip_init(chip);</span>
<span class="p_del">-</span>
 	if ((chip-&gt;tea575x_tuner &amp; TUNER_ONLY) == 0) {
 		if (devm_request_irq(&amp;pci-&gt;dev, pci-&gt;irq, snd_fm801_interrupt,
 				IRQF_SHARED, KBUILD_MODNAME, chip)) {
<span class="p_chunk">@@ -1248,6 +1246,8 @@</span> <span class="p_context"> static int snd_fm801_create(struct snd_card *card,</span>
 		pci_set_master(pci);
 	}
 
<span class="p_add">+	snd_fm801_chip_init(chip);</span>
<span class="p_add">+</span>
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops)) &lt; 0) {
 		snd_fm801_free(chip);
 		return err;
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index 4bf48336b0fc..775c67818bf1 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -3600,11 +3600,15 @@</span> <span class="p_context"> HDA_CODEC_ENTRY(0x1002aa01, &quot;R6xx HDMI&quot;,	patch_atihdmi),</span>
 HDA_CODEC_ENTRY(0x10951390, &quot;SiI1390 HDMI&quot;,	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x10951392, &quot;SiI1392 HDMI&quot;,	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x17e80047, &quot;Chrontel HDMI&quot;,	patch_generic_hdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0001, &quot;MCP73 HDMI&quot;,	patch_nvhdmi_2ch),</span>
 HDA_CODEC_ENTRY(0x10de0002, &quot;MCP77/78 HDMI&quot;,	patch_nvhdmi_8ch_7x),
 HDA_CODEC_ENTRY(0x10de0003, &quot;MCP77/78 HDMI&quot;,	patch_nvhdmi_8ch_7x),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0004, &quot;GPU 04 HDMI&quot;,	patch_nvhdmi_8ch_7x),</span>
 HDA_CODEC_ENTRY(0x10de0005, &quot;MCP77/78 HDMI&quot;,	patch_nvhdmi_8ch_7x),
 HDA_CODEC_ENTRY(0x10de0006, &quot;MCP77/78 HDMI&quot;,	patch_nvhdmi_8ch_7x),
 HDA_CODEC_ENTRY(0x10de0007, &quot;MCP79/7A HDMI&quot;,	patch_nvhdmi_8ch_7x),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0008, &quot;GPU 08 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0009, &quot;GPU 09 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de000a, &quot;GPU 0a HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de000b, &quot;GPU 0b HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de000c, &quot;MCP89 HDMI&quot;,	patch_nvhdmi),
<span class="p_chunk">@@ -3631,17 +3635,40 @@</span> <span class="p_context"> HDA_CODEC_ENTRY(0x10de0041, &quot;GPU 41 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0042, &quot;GPU 42 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0043, &quot;GPU 43 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0044, &quot;GPU 44 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0045, &quot;GPU 45 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0050, &quot;GPU 50 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0051, &quot;GPU 51 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0052, &quot;GPU 52 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0060, &quot;GPU 60 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0061, &quot;GPU 61 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0062, &quot;GPU 62 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0067, &quot;MCP67 HDMI&quot;,	patch_nvhdmi_2ch),
 HDA_CODEC_ENTRY(0x10de0070, &quot;GPU 70 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0071, &quot;GPU 71 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0072, &quot;GPU 72 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0073, &quot;GPU 73 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0074, &quot;GPU 74 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0076, &quot;GPU 76 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de007b, &quot;GPU 7b HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de007c, &quot;GPU 7c HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de007d, &quot;GPU 7d HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de007e, &quot;GPU 7e HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0080, &quot;GPU 80 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0081, &quot;GPU 81 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0082, &quot;GPU 82 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0083, &quot;GPU 83 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0084, &quot;GPU 84 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0090, &quot;GPU 90 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0091, &quot;GPU 91 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0092, &quot;GPU 92 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0093, &quot;GPU 93 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0094, &quot;GPU 94 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0095, &quot;GPU 95 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0097, &quot;GPU 97 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0098, &quot;GPU 98 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0099, &quot;GPU 99 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de8001, &quot;MCP73 HDMI&quot;,	patch_nvhdmi_2ch),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de8067, &quot;MCP67/68 HDMI&quot;,	patch_nvhdmi_2ch),</span>
 HDA_CODEC_ENTRY(0x11069f80, &quot;VX900 HDMI/DP&quot;,	patch_via_hdmi),
 HDA_CODEC_ENTRY(0x11069f81, &quot;VX900 HDMI/DP&quot;,	patch_via_hdmi),
 HDA_CODEC_ENTRY(0x11069f84, &quot;VX11 HDMI/DP&quot;,	patch_generic_hdmi),
<span class="p_header">diff --git a/sound/soc/codecs/nau8825.c b/sound/soc/codecs/nau8825.c</span>
<span class="p_header">index e643be91d762..f9f2737c4ad2 100644</span>
<span class="p_header">--- a/sound/soc/codecs/nau8825.c</span>
<span class="p_header">+++ b/sound/soc/codecs/nau8825.c</span>
<span class="p_chunk">@@ -1928,7 +1928,8 @@</span> <span class="p_context"> static void nau8825_fll_apply(struct nau8825 *nau8825,</span>
 			NAU8825_FLL_INTEGER_MASK, fll_param-&gt;fll_int);
 	/* FLL pre-scaler */
 	regmap_update_bits(nau8825-&gt;regmap, NAU8825_REG_FLL4,
<span class="p_del">-			NAU8825_FLL_REF_DIV_MASK, fll_param-&gt;clk_ref_div);</span>
<span class="p_add">+			NAU8825_FLL_REF_DIV_MASK,</span>
<span class="p_add">+			fll_param-&gt;clk_ref_div &lt;&lt; NAU8825_FLL_REF_DIV_SFT);</span>
 	/* select divided VCO input */
 	regmap_update_bits(nau8825-&gt;regmap, NAU8825_REG_FLL5,
 		NAU8825_FLL_CLK_SW_MASK, NAU8825_FLL_CLK_SW_REF);
<span class="p_header">diff --git a/sound/soc/codecs/nau8825.h b/sound/soc/codecs/nau8825.h</span>
<span class="p_header">index 1c63e2abafa9..574d6f936135 100644</span>
<span class="p_header">--- a/sound/soc/codecs/nau8825.h</span>
<span class="p_header">+++ b/sound/soc/codecs/nau8825.h</span>
<span class="p_chunk">@@ -129,7 +129,8 @@</span> <span class="p_context"></span>
 #define NAU8825_FLL_CLK_SRC_FS			(0x3 &lt;&lt; NAU8825_FLL_CLK_SRC_SFT)
 
 /* FLL4 (0x07) */
<span class="p_del">-#define NAU8825_FLL_REF_DIV_MASK		(0x3 &lt;&lt; 10)</span>
<span class="p_add">+#define NAU8825_FLL_REF_DIV_SFT	10</span>
<span class="p_add">+#define NAU8825_FLL_REF_DIV_MASK	(0x3 &lt;&lt; NAU8825_FLL_REF_DIV_SFT)</span>
 
 /* FLL5 (0x08) */
 #define NAU8825_FLL_PDB_DAC_EN		(0x1 &lt;&lt; 15)
<span class="p_header">diff --git a/sound/soc/codecs/tlv320aic3x.c b/sound/soc/codecs/tlv320aic3x.c</span>
<span class="p_header">index 5a8d96ec058c..fe45a16a5142 100644</span>
<span class="p_header">--- a/sound/soc/codecs/tlv320aic3x.c</span>
<span class="p_header">+++ b/sound/soc/codecs/tlv320aic3x.c</span>
<span class="p_chunk">@@ -126,6 +126,16 @@</span> <span class="p_context"> static const struct reg_default aic3x_reg[] = {</span>
 	{ 108, 0x00 }, { 109, 0x00 },
 };
 
<span class="p_add">+static bool aic3x_volatile_reg(struct device *dev, unsigned int reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (reg) {</span>
<span class="p_add">+	case AIC3X_RESET:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct regmap_config aic3x_regmap = {
 	.reg_bits = 8,
 	.val_bits = 8,
<span class="p_chunk">@@ -133,6 +143,9 @@</span> <span class="p_context"> static const struct regmap_config aic3x_regmap = {</span>
 	.max_register = DAC_ICC_ADJ,
 	.reg_defaults = aic3x_reg,
 	.num_reg_defaults = ARRAY_SIZE(aic3x_reg),
<span class="p_add">+</span>
<span class="p_add">+	.volatile_reg = aic3x_volatile_reg,</span>
<span class="p_add">+</span>
 	.cache_type = REGCACHE_RBTREE,
 };
 
<span class="p_header">diff --git a/sound/soc/fsl/fsl_ssi.c b/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_header">index 50349437d961..fde08660b63b 100644</span>
<span class="p_header">--- a/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_header">+++ b/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_chunk">@@ -224,6 +224,12 @@</span> <span class="p_context"> struct fsl_ssi_soc_data {</span>
  * @dbg_stats: Debugging statistics
  *
  * @soc: SoC specific data
<span class="p_add">+ *</span>
<span class="p_add">+ * @fifo_watermark: the FIFO watermark setting.  Notifies DMA when</span>
<span class="p_add">+ *             there are @fifo_watermark or fewer words in TX fifo or</span>
<span class="p_add">+ *             @fifo_watermark or more empty words in RX fifo.</span>
<span class="p_add">+ * @dma_maxburst: max number of words to transfer in one go.  So far,</span>
<span class="p_add">+ *             this is always the same as fifo_watermark.</span>
  */
 struct fsl_ssi_private {
 	struct regmap *regs;
<span class="p_chunk">@@ -263,6 +269,9 @@</span> <span class="p_context"> struct fsl_ssi_private {</span>
 
 	const struct fsl_ssi_soc_data *soc;
 	struct device *dev;
<span class="p_add">+</span>
<span class="p_add">+	u32 fifo_watermark;</span>
<span class="p_add">+	u32 dma_maxburst;</span>
 };
 
 /*
<span class="p_chunk">@@ -1051,21 +1060,7 @@</span> <span class="p_context"> static int _fsl_ssi_set_dai_fmt(struct device *dev,</span>
 	regmap_write(regs, CCSR_SSI_SRCR, srcr);
 	regmap_write(regs, CCSR_SSI_SCR, scr);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Set the watermark for transmit FIFI 0 and receive FIFO 0. We don&#39;t</span>
<span class="p_del">-	 * use FIFO 1. We program the transmit water to signal a DMA transfer</span>
<span class="p_del">-	 * if there are only two (or fewer) elements left in the FIFO. Two</span>
<span class="p_del">-	 * elements equals one frame (left channel, right channel). This value,</span>
<span class="p_del">-	 * however, depends on the depth of the transmit buffer.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We set the watermark on the same level as the DMA burstsize.  For</span>
<span class="p_del">-	 * fiq it is probably better to use the biggest possible watermark</span>
<span class="p_del">-	 * size.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (ssi_private-&gt;use_dma)</span>
<span class="p_del">-		wm = ssi_private-&gt;fifo_depth - 2;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		wm = ssi_private-&gt;fifo_depth;</span>
<span class="p_add">+	wm = ssi_private-&gt;fifo_watermark;</span>
 
 	regmap_write(regs, CCSR_SSI_SFCSR,
 			CCSR_SSI_SFCSR_TFWM0(wm) | CCSR_SSI_SFCSR_RFWM0(wm) |
<span class="p_chunk">@@ -1373,12 +1368,8 @@</span> <span class="p_context"> static int fsl_ssi_imx_probe(struct platform_device *pdev,</span>
 		dev_dbg(&amp;pdev-&gt;dev, &quot;could not get baud clock: %ld\n&quot;,
 			 PTR_ERR(ssi_private-&gt;baudclk));
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We have burstsize be &quot;fifo_depth - 2&quot; to match the SSI</span>
<span class="p_del">-	 * watermark setting in fsl_ssi_startup().</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ssi_private-&gt;dma_params_tx.maxburst = ssi_private-&gt;fifo_depth - 2;</span>
<span class="p_del">-	ssi_private-&gt;dma_params_rx.maxburst = ssi_private-&gt;fifo_depth - 2;</span>
<span class="p_add">+	ssi_private-&gt;dma_params_tx.maxburst = ssi_private-&gt;dma_maxburst;</span>
<span class="p_add">+	ssi_private-&gt;dma_params_rx.maxburst = ssi_private-&gt;dma_maxburst;</span>
 	ssi_private-&gt;dma_params_tx.addr = ssi_private-&gt;ssi_phys + CCSR_SSI_STX0;
 	ssi_private-&gt;dma_params_rx.addr = ssi_private-&gt;ssi_phys + CCSR_SSI_SRX0;
 
<span class="p_chunk">@@ -1543,6 +1534,47 @@</span> <span class="p_context"> static int fsl_ssi_probe(struct platform_device *pdev)</span>
                 /* Older 8610 DTs didn&#39;t have the fifo-depth property */
 		ssi_private-&gt;fifo_depth = 8;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set the watermark for transmit FIFO 0 and receive FIFO 0. We don&#39;t</span>
<span class="p_add">+	 * use FIFO 1 but set the watermark appropriately nontheless.</span>
<span class="p_add">+	 * We program the transmit water to signal a DMA transfer</span>
<span class="p_add">+	 * if there are N elements left in the FIFO. For chips with 15-deep</span>
<span class="p_add">+	 * FIFOs, set watermark to 8.  This allows the SSI to operate at a</span>
<span class="p_add">+	 * high data rate without channel slipping. Behavior is unchanged</span>
<span class="p_add">+	 * for the older chips with a fifo depth of only 8.  A value of 4</span>
<span class="p_add">+	 * might be appropriate for the older chips, but is left at</span>
<span class="p_add">+	 * fifo_depth-2 until sombody has a chance to test.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We set the watermark on the same level as the DMA burstsize.  For</span>
<span class="p_add">+	 * fiq it is probably better to use the biggest possible watermark</span>
<span class="p_add">+	 * size.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	switch (ssi_private-&gt;fifo_depth) {</span>
<span class="p_add">+	case 15:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * 2 samples is not enough when running at high data</span>
<span class="p_add">+		 * rates (like 48kHz @ 16 bits/channel, 16 channels)</span>
<span class="p_add">+		 * 8 seems to split things evenly and leave enough time</span>
<span class="p_add">+		 * for the DMA to fill the FIFO before it&#39;s over/under</span>
<span class="p_add">+		 * run.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ssi_private-&gt;fifo_watermark = 8;</span>
<span class="p_add">+		ssi_private-&gt;dma_maxburst = 8;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 8:</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * maintain old behavior for older chips.</span>
<span class="p_add">+		 * Keeping it the same because I don&#39;t have an older</span>
<span class="p_add">+		 * board to test with.</span>
<span class="p_add">+		 * I suspect this could be changed to be something to</span>
<span class="p_add">+		 * leave some more space in the fifo.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ssi_private-&gt;fifo_watermark = ssi_private-&gt;fifo_depth - 2;</span>
<span class="p_add">+		ssi_private-&gt;dma_maxburst = ssi_private-&gt;fifo_depth - 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev_set_drvdata(&amp;pdev-&gt;dev, ssi_private);
 
 	if (ssi_private-&gt;soc-&gt;imx) {
<span class="p_header">diff --git a/sound/soc/intel/boards/bytcr_rt5640.c b/sound/soc/intel/boards/bytcr_rt5640.c</span>
<span class="p_header">index d5873eeae1aa..bd19fad2d91b 100644</span>
<span class="p_header">--- a/sound/soc/intel/boards/bytcr_rt5640.c</span>
<span class="p_header">+++ b/sound/soc/intel/boards/bytcr_rt5640.c</span>
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"> static int platform_clock_control(struct snd_soc_dapm_widget *w,</span>
 		 * for Jack detection and button press
 		 */
 		ret = snd_soc_dai_set_sysclk(codec_dai, RT5640_SCLK_S_RCCLK,
<span class="p_del">-					     0,</span>
<span class="p_add">+					     48000 * 512,</span>
 					     SND_SOC_CLOCK_IN);
 		if (!ret) {
 			if ((byt_rt5640_quirk &amp; BYT_RT5640_MCLK_EN) &amp;&amp; priv-&gt;mclk)
<span class="p_header">diff --git a/sound/soc/intel/skylake/skl-sst.c b/sound/soc/intel/skylake/skl-sst.c</span>
<span class="p_header">index 8fc3178bc79c..b30bd384c8d3 100644</span>
<span class="p_header">--- a/sound/soc/intel/skylake/skl-sst.c</span>
<span class="p_header">+++ b/sound/soc/intel/skylake/skl-sst.c</span>
<span class="p_chunk">@@ -515,6 +515,9 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(skl_sst_init_fw);</span>
 
 void skl_sst_dsp_cleanup(struct device *dev, struct skl_sst *ctx)
 {
<span class="p_add">+</span>
<span class="p_add">+	if (ctx-&gt;dsp-&gt;fw)</span>
<span class="p_add">+		release_firmware(ctx-&gt;dsp-&gt;fw);</span>
 	skl_clear_module_table(ctx-&gt;dsp);
 	skl_freeup_uuid_list(ctx);
 	skl_ipc_free(&amp;ctx-&gt;ipc);
<span class="p_header">diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c</span>
<span class="p_header">index d56a16a0f6fa..21c3ef01c438 100644</span>
<span class="p_header">--- a/sound/soc/soc-pcm.c</span>
<span class="p_header">+++ b/sound/soc/soc-pcm.c</span>
<span class="p_chunk">@@ -2184,9 +2184,11 @@</span> <span class="p_context"> static int dpcm_fe_dai_do_trigger(struct snd_pcm_substream *substream, int cmd)</span>
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
<span class="p_del">-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:</span>
 		fe-&gt;dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;
 		break;
<span class="p_add">+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:</span>
<span class="p_add">+		fe-&gt;dpcm[stream].state = SND_SOC_DPCM_STATE_PAUSED;</span>
<span class="p_add">+		break;</span>
 	}
 
 out:
<span class="p_header">diff --git a/sound/usb/endpoint.c b/sound/usb/endpoint.c</span>
<span class="p_header">index c5251aaad844..b8044c6034b3 100644</span>
<span class="p_header">--- a/sound/usb/endpoint.c</span>
<span class="p_header">+++ b/sound/usb/endpoint.c</span>
<span class="p_chunk">@@ -384,6 +384,9 @@</span> <span class="p_context"> static void snd_complete_urb(struct urb *urb)</span>
 	if (unlikely(atomic_read(&amp;ep-&gt;chip-&gt;shutdown)))
 		goto exit_clear;
 
<span class="p_add">+	if (unlikely(!test_bit(EP_FLAG_RUNNING, &amp;ep-&gt;flags)))</span>
<span class="p_add">+		goto exit_clear;</span>
<span class="p_add">+</span>
 	if (usb_pipeout(ep-&gt;pipe)) {
 		retire_outbound_urb(ep, ctx);
 		/* can be stopped during retire callback */
<span class="p_header">diff --git a/tools/lib/traceevent/plugin_sched_switch.c b/tools/lib/traceevent/plugin_sched_switch.c</span>
<span class="p_header">index f1ce60065258..ec30c2fcbac0 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/plugin_sched_switch.c</span>
<span class="p_header">+++ b/tools/lib/traceevent/plugin_sched_switch.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> static int sched_switch_handler(struct trace_seq *s,</span>
 	trace_seq_printf(s, &quot;%lld &quot;, val);
 
 	if (pevent_get_field_val(s, event, &quot;prev_prio&quot;, record, &amp;val, 0) == 0)
<span class="p_del">-		trace_seq_printf(s, &quot;[%lld] &quot;, val);</span>
<span class="p_add">+		trace_seq_printf(s, &quot;[%d] &quot;, (int) val);</span>
 
 	if (pevent_get_field_val(s,  event, &quot;prev_state&quot;, record, &amp;val, 0) == 0)
 		write_state(s, val);
<span class="p_chunk">@@ -129,7 +129,7 @@</span> <span class="p_context"> static int sched_switch_handler(struct trace_seq *s,</span>
 	trace_seq_printf(s, &quot;%lld&quot;, val);
 
 	if (pevent_get_field_val(s, event, &quot;next_prio&quot;, record, &amp;val, 0) == 0)
<span class="p_del">-		trace_seq_printf(s, &quot; [%lld]&quot;, val);</span>
<span class="p_add">+		trace_seq_printf(s, &quot; [%d]&quot;, (int) val);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/tools/perf/Makefile.perf b/tools/perf/Makefile.perf</span>
<span class="p_header">index 982d6439bb07..ef52d1e3d431 100644</span>
<span class="p_header">--- a/tools/perf/Makefile.perf</span>
<span class="p_header">+++ b/tools/perf/Makefile.perf</span>
<span class="p_chunk">@@ -729,9 +729,9 @@</span> <span class="p_context"> install-tests: all install-gtk</span>
 		$(INSTALL) -d -m 755 &#39;$(DESTDIR_SQ)$(perfexec_instdir_SQ)/tests/attr&#39;; \
 		$(INSTALL) tests/attr/* &#39;$(DESTDIR_SQ)$(perfexec_instdir_SQ)/tests/attr&#39;
 
<span class="p_del">-install-bin: install-tools install-tests</span>
<span class="p_add">+install-bin: install-tools install-tests install-traceevent-plugins</span>
 
<span class="p_del">-install: install-bin try-install-man install-traceevent-plugins</span>
<span class="p_add">+install: install-bin try-install-man</span>
 
 install-python_ext:
 	$(PYTHON_WORD) util/setup.py --quiet install --root=&#39;/$(DESTDIR_SQ)&#39;
<span class="p_header">diff --git a/tools/perf/util/probe-event.c b/tools/perf/util/probe-event.c</span>
<span class="p_header">index 7ea13f44178d..6c50d9f8e210 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-event.c</span>
<span class="p_header">+++ b/tools/perf/util/probe-event.c</span>
<span class="p_chunk">@@ -268,21 +268,6 @@</span> <span class="p_context"> static bool kprobe_warn_out_range(const char *symbol, unsigned long address)</span>
 }
 
 /*
<span class="p_del">- * NOTE:</span>
<span class="p_del">- * &#39;.gnu.linkonce.this_module&#39; section of kernel module elf directly</span>
<span class="p_del">- * maps to &#39;struct module&#39; from linux/module.h. This section contains</span>
<span class="p_del">- * actual module name which will be used by kernel after loading it.</span>
<span class="p_del">- * But, we cannot use &#39;struct module&#39; here since linux/module.h is not</span>
<span class="p_del">- * exposed to user-space. Offset of &#39;name&#39; has remained same from long</span>
<span class="p_del">- * time, so hardcoding it here.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifdef __LP64__</span>
<span class="p_del">-#define MOD_NAME_OFFSET 24</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define MOD_NAME_OFFSET 12</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * @module can be module name of module file path. In case of path,
  * inspect elf and find out what is actual module name.
  * Caller has to free mod_name after using it.
<span class="p_chunk">@@ -296,6 +281,7 @@</span> <span class="p_context"> static char *find_module_name(const char *module)</span>
 	Elf_Data *data;
 	Elf_Scn *sec;
 	char *mod_name = NULL;
<span class="p_add">+	int name_offset;</span>
 
 	fd = open(module, O_RDONLY);
 	if (fd &lt; 0)
<span class="p_chunk">@@ -317,7 +303,21 @@</span> <span class="p_context"> static char *find_module_name(const char *module)</span>
 	if (!data || !data-&gt;d_buf)
 		goto ret_err;
 
<span class="p_del">-	mod_name = strdup((char *)data-&gt;d_buf + MOD_NAME_OFFSET);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * NOTE:</span>
<span class="p_add">+	 * &#39;.gnu.linkonce.this_module&#39; section of kernel module elf directly</span>
<span class="p_add">+	 * maps to &#39;struct module&#39; from linux/module.h. This section contains</span>
<span class="p_add">+	 * actual module name which will be used by kernel after loading it.</span>
<span class="p_add">+	 * But, we cannot use &#39;struct module&#39; here since linux/module.h is not</span>
<span class="p_add">+	 * exposed to user-space. Offset of &#39;name&#39; has remained same from long</span>
<span class="p_add">+	 * time, so hardcoding it here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ehdr.e_ident[EI_CLASS] == ELFCLASS32)</span>
<span class="p_add">+		name_offset = 12;</span>
<span class="p_add">+	else	/* expect ELFCLASS64 by default */</span>
<span class="p_add">+		name_offset = 24;</span>
<span class="p_add">+</span>
<span class="p_add">+	mod_name = strdup((char *)data-&gt;d_buf + name_offset);</span>
 
 ret_err:
 	elf_end(elf);
<span class="p_header">diff --git a/tools/perf/util/symbol-elf.c b/tools/perf/util/symbol-elf.c</span>
<span class="p_header">index 99400b0e8f2a..adbc6c02c3aa 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol-elf.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol-elf.c</span>
<span class="p_chunk">@@ -537,6 +537,12 @@</span> <span class="p_context"> int sysfs__read_build_id(const char *filename, void *build_id, size_t size)</span>
 				break;
 		} else {
 			int n = namesz + descsz;
<span class="p_add">+</span>
<span class="p_add">+			if (n &gt; (int)sizeof(bf)) {</span>
<span class="p_add">+				n = sizeof(bf);</span>
<span class="p_add">+				pr_debug(&quot;%s: truncating reading of build id in sysfs file %s: n_namesz=%u, n_descsz=%u.\n&quot;,</span>
<span class="p_add">+					 __func__, filename, nhdr.n_namesz, nhdr.n_descsz);</span>
<span class="p_add">+			}</span>
 			if (read(fd, bf, n) != n)
 				break;
 		}

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



