
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[01/19] tree wide: get rid of __GFP_REPEAT for order-0 allocations part I - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [01/19] tree wide: get rid of __GFP_REPEAT for order-0 allocations part I</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>April 11, 2016, 11:07 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1460372892-8157-2-git-send-email-mhocko@kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8799771/mbox/"
   >mbox</a>
|
   <a href="/patch/8799771/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8799771/">/patch/8799771/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id B7480C0554
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 11 Apr 2016 11:09:20 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 34F85201BC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 11 Apr 2016 11:09:19 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 604BD20306
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 11 Apr 2016 11:09:16 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753666AbcDKLIh (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 11 Apr 2016 07:08:37 -0400
Received: from mail-wm0-f66.google.com ([74.125.82.66]:34854 &quot;EHLO
	mail-wm0-f66.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753476AbcDKLIc (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 11 Apr 2016 07:08:32 -0400
Received: by mail-wm0-f66.google.com with SMTP id a140so20427598wma.2;
	Mon, 11 Apr 2016 04:08:26 -0700 (PDT)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references;
	bh=8i2YaInBghaI/FiBWogMOkwfVM2qrK61Ny1QNY2v4k8=;
	b=Mw17udhnCgZnBgDviZaMm8TY2EYGpPj2cg+M3bRjgfMkCVP9QpWYnFYSN+aHC3DqPK
	XGalQmSwWufKonWzqrDaAYOpEe0ezthZZwYwo3wiE0+BYIKS/LYGC+Ps0SwaZPF1Fn3u
	p6SLbUrWdERV8jeizli7N8G8C4bPcPx1dJbz57CNWY5o5YXjaYzTXOkyqOUeE2KcCqX0
	S2ltg12hrDImlc13JP5fhwHCd3M4igOOeUIp7R/4apFesLbQozx2DMzIb1K/bsvev23n
	zvlLzI8pZtvRDWoMr35kj9V0mcFEmVfjtypaSBSOpdAIxZ2oTssZDmMi0Sc0vB8m2Mxw
	IOWw==
X-Gm-Message-State: AOPr4FWwTEtRVDUzDaSYFphL00IVPL8I/Befq6azherHYpwk33iczijQOqHVGHGlKbtJLw==
X-Received: by 10.28.130.133 with SMTP id e127mr10340831wmd.48.1460372905623;
	Mon, 11 Apr 2016 04:08:25 -0700 (PDT)
Received: from tiehlicka.suse.cz (ip-86-49-65-8.net.upcbroadband.cz.
	[86.49.65.8]) by smtp.gmail.com with ESMTPSA id
	w75sm16786130wmw.4.2016.04.11.04.08.24
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-SHA bits=128/128);
	Mon, 11 Apr 2016 04:08:25 -0700 (PDT)
From: Michal Hocko &lt;mhocko@kernel.org&gt;
To: &lt;linux-mm@kvack.org&gt;
Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	LKML &lt;linux-kernel@vger.kernel.org&gt;,
	Michal Hocko &lt;mhocko@suse.com&gt;, linux-arch@vger.kernel.org
Subject: [PATCH 01/19] tree wide: get rid of __GFP_REPEAT for order-0
	allocations part I
Date: Mon, 11 Apr 2016 13:07:54 +0200
Message-Id: &lt;1460372892-8157-2-git-send-email-mhocko@kernel.org&gt;
X-Mailer: git-send-email 2.8.0.rc3
In-Reply-To: &lt;1460372892-8157-1-git-send-email-mhocko@kernel.org&gt;
References: &lt;1460372892-8157-1-git-send-email-mhocko@kernel.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - April 11, 2016, 11:07 a.m.</div>
<pre class="content">
<span class="from">From: Michal Hocko &lt;mhocko@suse.com&gt;</span>

__GFP_REPEAT has a rather weak semantic but since it has been introduced
around 2.6.12 it has been ignored for low order allocations. Yet we have
the full kernel tree with its usage for apparently order-0 allocations.
This is really confusing because __GFP_REPEAT is explicitly documented
to allow allocation failures which is a weaker semantic than the current
order-0 has (basically nofail).

Let&#39;s simply drop __GFP_REPEAT from those places. This would allow
to identify place which really need allocator to retry harder and
formulate a more specific semantic for what the flag is supposed to do
actually.

Cc: linux-arch@vger.kernel.org
<span class="signed-off-by">Signed-off-by: Michal Hocko &lt;mhocko@suse.com&gt;</span>
---
 arch/alpha/include/asm/pgalloc.h         | 4 ++--
 arch/arm/include/asm/pgalloc.h           | 2 +-
 arch/avr32/include/asm/pgalloc.h         | 6 +++---
 arch/cris/include/asm/pgalloc.h          | 4 ++--
 arch/frv/mm/pgalloc.c                    | 6 +++---
 arch/hexagon/include/asm/pgalloc.h       | 4 ++--
 arch/m68k/include/asm/mcf_pgalloc.h      | 4 ++--
 arch/m68k/include/asm/motorola_pgalloc.h | 4 ++--
 arch/m68k/include/asm/sun3_pgalloc.h     | 4 ++--
 arch/metag/include/asm/pgalloc.h         | 5 ++---
 arch/microblaze/include/asm/pgalloc.h    | 4 ++--
 arch/microblaze/mm/pgtable.c             | 3 +--
 arch/mn10300/mm/pgtable.c                | 6 +++---
 arch/openrisc/include/asm/pgalloc.h      | 2 +-
 arch/openrisc/mm/ioremap.c               | 2 +-
 arch/parisc/include/asm/pgalloc.h        | 4 ++--
 arch/powerpc/include/asm/pgalloc-64.h    | 2 +-
 arch/powerpc/mm/pgtable_32.c             | 4 ++--
 arch/powerpc/mm/pgtable_64.c             | 3 +--
 arch/sh/include/asm/pgalloc.h            | 4 ++--
 arch/sparc/mm/init_64.c                  | 6 ++----
 arch/um/kernel/mem.c                     | 4 ++--
 arch/x86/include/asm/pgalloc.h           | 4 ++--
 arch/x86/xen/p2m.c                       | 2 +-
 arch/xtensa/include/asm/pgalloc.h        | 2 +-
 drivers/block/aoe/aoecmd.c               | 2 +-
 26 files changed, 46 insertions(+), 51 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=579">David Rientjes</a> - April 14, 2016, 7:56 p.m.</div>
<pre class="content">
On Mon, 11 Apr 2016, Michal Hocko wrote:
<span class="quote">
&gt; From: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; __GFP_REPEAT has a rather weak semantic but since it has been introduced</span>
<span class="quote">&gt; around 2.6.12 it has been ignored for low order allocations. Yet we have</span>
<span class="quote">&gt; the full kernel tree with its usage for apparently order-0 allocations.</span>
<span class="quote">&gt; This is really confusing because __GFP_REPEAT is explicitly documented</span>
<span class="quote">&gt; to allow allocation failures which is a weaker semantic than the current</span>
<span class="quote">&gt; order-0 has (basically nofail).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Let&#39;s simply drop __GFP_REPEAT from those places. This would allow</span>
<span class="quote">&gt; to identify place which really need allocator to retry harder and</span>
<span class="quote">&gt; formulate a more specific semantic for what the flag is supposed to do</span>
<span class="quote">&gt; actually.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Cc: linux-arch@vger.kernel.org</span>
<span class="quote">&gt; Signed-off-by: Michal Hocko &lt;mhocko@suse.com&gt;</span>

I did exactly this before, and Andrew objected saying that __GFP_REPEAT 
may not be needed for the current page allocator&#39;s implementation but 
could with others and that setting __GFP_REPEAT for an allocation 
provided useful information with regards to intent.  At the time, I 
attempted to eliminate __GFP_REPEAT entirely.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - April 15, 2016, 7:44 a.m.</div>
<pre class="content">
On Thu 14-04-16 12:56:28, David Rientjes wrote:
<span class="quote">&gt; On Mon, 11 Apr 2016, Michal Hocko wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; From: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; __GFP_REPEAT has a rather weak semantic but since it has been introduced</span>
<span class="quote">&gt; &gt; around 2.6.12 it has been ignored for low order allocations. Yet we have</span>
<span class="quote">&gt; &gt; the full kernel tree with its usage for apparently order-0 allocations.</span>
<span class="quote">&gt; &gt; This is really confusing because __GFP_REPEAT is explicitly documented</span>
<span class="quote">&gt; &gt; to allow allocation failures which is a weaker semantic than the current</span>
<span class="quote">&gt; &gt; order-0 has (basically nofail).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Let&#39;s simply drop __GFP_REPEAT from those places. This would allow</span>
<span class="quote">&gt; &gt; to identify place which really need allocator to retry harder and</span>
<span class="quote">&gt; &gt; formulate a more specific semantic for what the flag is supposed to do</span>
<span class="quote">&gt; &gt; actually.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Cc: linux-arch@vger.kernel.org</span>
<span class="quote">&gt; &gt; Signed-off-by: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I did exactly this before, and Andrew objected saying that __GFP_REPEAT </span>
<span class="quote">&gt; may not be needed for the current page allocator&#39;s implementation but </span>
<span class="quote">&gt; could with others and that setting __GFP_REPEAT for an allocation </span>
<span class="quote">&gt; provided useful information with regards to intent.</span>

From what I&#39;ve seen it was more a copy&amp;paste of the arch code which
spread out this flag and there was also a misleading usage.
<span class="quote">
&gt; At the time, I attempted to eliminate __GFP_REPEAT entirely.</span>

This is not my plan. I actually want to provide a useful semantic for
something like this flag - aka try really hard but eventually fail
for all orders and stop being special only for those that are costly. I
will call it __GFP_BEST_EFFORT. But I have to clean up the current usage
first. Costly orders will keep __GFP_REPEAT because the intent is clear
there. All others will lose the flag and then we can start adding
__GFP_BEST_EFFORT where it matters also for lower orders.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/alpha/include/asm/pgalloc.h b/arch/alpha/include/asm/pgalloc.h</span>
<span class="p_header">index aab14a019c20..c2ebb6f36c9d 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
 static inline pmd_t *
 pmd_alloc_one(struct mm_struct *mm, unsigned long address)
 {
<span class="p_del">-	pmd_t *ret = (pmd_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);</span>
<span class="p_add">+	pmd_t *ret = (pmd_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> pmd_free(struct mm_struct *mm, pmd_t *pmd)</span>
 static inline pte_t *
 pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
 {
<span class="p_del">-	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);</span>
<span class="p_add">+	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);</span>
 	return pte;
 }
 
<span class="p_header">diff --git a/arch/arm/include/asm/pgalloc.h b/arch/arm/include/asm/pgalloc.h</span>
<span class="p_header">index 19cfab526d13..20febb368844 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
 
 static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
<span class="p_del">-	return (pmd_t *)get_zeroed_page(GFP_KERNEL | __GFP_REPEAT);</span>
<span class="p_add">+	return (pmd_t *)get_zeroed_page(GFP_KERNEL);</span>
 }
 
 static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)
<span class="p_header">diff --git a/arch/avr32/include/asm/pgalloc.h b/arch/avr32/include/asm/pgalloc.h</span>
<span class="p_header">index 1aba19d68c5e..db039cb368be 100644</span>
<span class="p_header">--- a/arch/avr32/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/avr32/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> static inline void pgd_ctor(void *x)</span>
  */
 static inline pgd_t *pgd_alloc(struct mm_struct *mm)
 {
<span class="p_del">-	return quicklist_alloc(QUICK_PGD, GFP_KERNEL | __GFP_REPEAT, pgd_ctor);</span>
<span class="p_add">+	return quicklist_alloc(QUICK_PGD, GFP_KERNEL, pgd_ctor);</span>
 }
 
 static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
 					  unsigned long address)
 {
<span class="p_del">-	return quicklist_alloc(QUICK_PT, GFP_KERNEL | __GFP_REPEAT, NULL);</span>
<span class="p_add">+	return quicklist_alloc(QUICK_PT, GFP_KERNEL, NULL);</span>
 }
 
 static inline pgtable_t pte_alloc_one(struct mm_struct *mm,
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static inline pgtable_t pte_alloc_one(struct mm_struct *mm,</span>
 	struct page *page;
 	void *pg;
 
<span class="p_del">-	pg = quicklist_alloc(QUICK_PT, GFP_KERNEL | __GFP_REPEAT, NULL);</span>
<span class="p_add">+	pg = quicklist_alloc(QUICK_PT, GFP_KERNEL, NULL);</span>
 	if (!pg)
 		return NULL;
 
<span class="p_header">diff --git a/arch/cris/include/asm/pgalloc.h b/arch/cris/include/asm/pgalloc.h</span>
<span class="p_header">index 235ece437ddd..42f1affb9c2d 100644</span>
<span class="p_header">--- a/arch/cris/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/cris/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -24,14 +24,14 @@</span> <span class="p_context"> static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
 
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
 {
<span class="p_del">-  	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);</span>
<span class="p_add">+	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);</span>
  	return pte;
 }
 
 static inline pgtable_t pte_alloc_one(struct mm_struct *mm, unsigned long address)
 {
 	struct page *pte;
<span class="p_del">-	pte = alloc_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO, 0);</span>
<span class="p_add">+	pte = alloc_pages(GFP_KERNEL|__GFP_ZERO, 0);</span>
 	if (!pte)
 		return NULL;
 	if (!pgtable_page_ctor(pte)) {
<span class="p_header">diff --git a/arch/frv/mm/pgalloc.c b/arch/frv/mm/pgalloc.c</span>
<span class="p_header">index 41907d25ed38..c9ed14f6c67d 100644</span>
<span class="p_header">--- a/arch/frv/mm/pgalloc.c</span>
<span class="p_header">+++ b/arch/frv/mm/pgalloc.c</span>
<span class="p_chunk">@@ -22,7 +22,7 @@</span> <span class="p_context"> pgd_t swapper_pg_dir[PTRS_PER_PGD] __attribute__((aligned(PAGE_SIZE)));</span>
 
 pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
 {
<span class="p_del">-	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT);</span>
<span class="p_add">+	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL);</span>
 	if (pte)
 		clear_page(pte);
 	return pte;
<span class="p_chunk">@@ -33,9 +33,9 @@</span> <span class="p_context"> pgtable_t pte_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 	struct page *page;
 
 #ifdef CONFIG_HIGHPTE
<span class="p_del">-	page = alloc_pages(GFP_KERNEL|__GFP_HIGHMEM|__GFP_REPEAT, 0);</span>
<span class="p_add">+	page = alloc_pages(GFP_KERNEL|__GFP_HIGHMEM, 0);</span>
 #else
<span class="p_del">-	page = alloc_pages(GFP_KERNEL|__GFP_REPEAT, 0);</span>
<span class="p_add">+	page = alloc_pages(GFP_KERNEL, 0);</span>
 #endif
 	if (!page)
 		return NULL;
<span class="p_header">diff --git a/arch/hexagon/include/asm/pgalloc.h b/arch/hexagon/include/asm/pgalloc.h</span>
<span class="p_header">index 77da3b0ae3c2..eeebf862c46c 100644</span>
<span class="p_header">--- a/arch/hexagon/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/hexagon/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> static inline struct page *pte_alloc_one(struct mm_struct *mm,</span>
 {
 	struct page *pte;
 
<span class="p_del">-	pte = alloc_page(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO);</span>
<span class="p_add">+	pte = alloc_page(GFP_KERNEL | __GFP_ZERO);</span>
 	if (!pte)
 		return NULL;
 	if (!pgtable_page_ctor(pte)) {
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> static inline struct page *pte_alloc_one(struct mm_struct *mm,</span>
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
 					  unsigned long address)
 {
<span class="p_del">-	gfp_t flags =  GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO;</span>
<span class="p_add">+	gfp_t flags =  GFP_KERNEL | __GFP_ZERO;</span>
 	return (pte_t *) __get_free_page(flags);
 }
 
<span class="p_header">diff --git a/arch/m68k/include/asm/mcf_pgalloc.h b/arch/m68k/include/asm/mcf_pgalloc.h</span>
<span class="p_header">index f9924fbcfe42..fb95aed5f428 100644</span>
<span class="p_header">--- a/arch/m68k/include/asm/mcf_pgalloc.h</span>
<span class="p_header">+++ b/arch/m68k/include/asm/mcf_pgalloc.h</span>
<span class="p_chunk">@@ -14,7 +14,7 @@</span> <span class="p_context"> extern const char bad_pmd_string[];</span>
 extern inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
 	unsigned long address)
 {
<span class="p_del">-	unsigned long page = __get_free_page(GFP_DMA|__GFP_REPEAT);</span>
<span class="p_add">+	unsigned long page = __get_free_page(GFP_DMA);</span>
 
 	if (!page)
 		return NULL;
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> static inline void __pte_free_tlb(struct mmu_gather *tlb, pgtable_t page,</span>
 static inline struct page *pte_alloc_one(struct mm_struct *mm,
 	unsigned long address)
 {
<span class="p_del">-	struct page *page = alloc_pages(GFP_DMA|__GFP_REPEAT, 0);</span>
<span class="p_add">+	struct page *page = alloc_pages(GFP_DMA, 0);</span>
 	pte_t *pte;
 
 	if (!page)
<span class="p_header">diff --git a/arch/m68k/include/asm/motorola_pgalloc.h b/arch/m68k/include/asm/motorola_pgalloc.h</span>
<span class="p_header">index 24bcba496c75..c895b987202c 100644</span>
<span class="p_header">--- a/arch/m68k/include/asm/motorola_pgalloc.h</span>
<span class="p_header">+++ b/arch/m68k/include/asm/motorola_pgalloc.h</span>
<span class="p_chunk">@@ -11,7 +11,7 @@</span> <span class="p_context"> static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long ad</span>
 {
 	pte_t *pte;
 
<span class="p_del">-	pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);</span>
<span class="p_add">+	pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);</span>
 	if (pte) {
 		__flush_page_to_ram(pte);
 		flush_tlb_kernel_page(pte);
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> static inline pgtable_t pte_alloc_one(struct mm_struct *mm, unsigned long addres</span>
 	struct page *page;
 	pte_t *pte;
 
<span class="p_del">-	page = alloc_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO, 0);</span>
<span class="p_add">+	page = alloc_pages(GFP_KERNEL|__GFP_ZERO, 0);</span>
 	if(!page)
 		return NULL;
 	if (!pgtable_page_ctor(page)) {
<span class="p_header">diff --git a/arch/m68k/include/asm/sun3_pgalloc.h b/arch/m68k/include/asm/sun3_pgalloc.h</span>
<span class="p_header">index 0931388de47f..1901f61f926f 100644</span>
<span class="p_header">--- a/arch/m68k/include/asm/sun3_pgalloc.h</span>
<span class="p_header">+++ b/arch/m68k/include/asm/sun3_pgalloc.h</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"> do {							\</span>
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
 					  unsigned long address)
 {
<span class="p_del">-	unsigned long page = __get_free_page(GFP_KERNEL|__GFP_REPEAT);</span>
<span class="p_add">+	unsigned long page = __get_free_page(GFP_KERNEL);</span>
 
 	if (!page)
 		return NULL;
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,</span>
 static inline pgtable_t pte_alloc_one(struct mm_struct *mm,
 					unsigned long address)
 {
<span class="p_del">-        struct page *page = alloc_pages(GFP_KERNEL|__GFP_REPEAT, 0);</span>
<span class="p_add">+        struct page *page = alloc_pages(GFP_KERNEL, 0);</span>
 
 	if (page == NULL)
 		return NULL;
<span class="p_header">diff --git a/arch/metag/include/asm/pgalloc.h b/arch/metag/include/asm/pgalloc.h</span>
<span class="p_header">index 3104df0a4822..c2caa1ee4360 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -42,8 +42,7 @@</span> <span class="p_context"> static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
 					  unsigned long address)
 {
<span class="p_del">-	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL | __GFP_REPEAT |</span>
<span class="p_del">-					      __GFP_ZERO);</span>
<span class="p_add">+	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL | __GFP_ZERO);</span>
 	return pte;
 }
 
<span class="p_chunk">@@ -51,7 +50,7 @@</span> <span class="p_context"> static inline pgtable_t pte_alloc_one(struct mm_struct *mm,</span>
 				      unsigned long address)
 {
 	struct page *pte;
<span class="p_del">-	pte = alloc_pages(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO, 0);</span>
<span class="p_add">+	pte = alloc_pages(GFP_KERNEL  | __GFP_ZERO, 0);</span>
 	if (!pte)
 		return NULL;
 	if (!pgtable_page_ctor(pte)) {
<span class="p_header">diff --git a/arch/microblaze/include/asm/pgalloc.h b/arch/microblaze/include/asm/pgalloc.h</span>
<span class="p_header">index 61436d69775c..7c89390c0c13 100644</span>
<span class="p_header">--- a/arch/microblaze/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/microblaze/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -116,9 +116,9 @@</span> <span class="p_context"> static inline struct page *pte_alloc_one(struct mm_struct *mm,</span>
 	struct page *ptepage;
 
 #ifdef CONFIG_HIGHPTE
<span class="p_del">-	int flags = GFP_KERNEL | __GFP_HIGHMEM | __GFP_REPEAT;</span>
<span class="p_add">+	int flags = GFP_KERNEL | __GFP_HIGHMEM;</span>
 #else
<span class="p_del">-	int flags = GFP_KERNEL | __GFP_REPEAT;</span>
<span class="p_add">+	int flags = GFP_KERNEL;</span>
 #endif
 
 	ptepage = alloc_pages(flags, 0);
<span class="p_header">diff --git a/arch/microblaze/mm/pgtable.c b/arch/microblaze/mm/pgtable.c</span>
<span class="p_header">index 4f4520e779a5..eb99fcc76088 100644</span>
<span class="p_header">--- a/arch/microblaze/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/microblaze/mm/pgtable.c</span>
<span class="p_chunk">@@ -239,8 +239,7 @@</span> <span class="p_context"> __init_refok pte_t *pte_alloc_one_kernel(struct mm_struct *mm,</span>
 {
 	pte_t *pte;
 	if (mem_init_done) {
<span class="p_del">-		pte = (pte_t *)__get_free_page(GFP_KERNEL |</span>
<span class="p_del">-					__GFP_REPEAT | __GFP_ZERO);</span>
<span class="p_add">+		pte = (pte_t *)__get_free_page(GFP_KERNEL | __GFP_ZERO);</span>
 	} else {
 		pte = (pte_t *)early_get_page();
 		if (pte)
<span class="p_header">diff --git a/arch/mn10300/mm/pgtable.c b/arch/mn10300/mm/pgtable.c</span>
<span class="p_header">index e77a7c728081..9577cf768875 100644</span>
<span class="p_header">--- a/arch/mn10300/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/mn10300/mm/pgtable.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> void set_pmd_pfn(unsigned long vaddr, unsigned long pfn, pgprot_t flags)</span>
 
 pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
 {
<span class="p_del">-	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT);</span>
<span class="p_add">+	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL);</span>
 	if (pte)
 		clear_page(pte);
 	return pte;
<span class="p_chunk">@@ -74,9 +74,9 @@</span> <span class="p_context"> struct page *pte_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 	struct page *pte;
 
 #ifdef CONFIG_HIGHPTE
<span class="p_del">-	pte = alloc_pages(GFP_KERNEL|__GFP_HIGHMEM|__GFP_REPEAT, 0);</span>
<span class="p_add">+	pte = alloc_pages(GFP_KERNEL|__GFP_HIGHMEM, 0);</span>
 #else
<span class="p_del">-	pte = alloc_pages(GFP_KERNEL|__GFP_REPEAT, 0);</span>
<span class="p_add">+	pte = alloc_pages(GFP_KERNEL, 0);</span>
 #endif
 	if (!pte)
 		return NULL;
<span class="p_header">diff --git a/arch/openrisc/include/asm/pgalloc.h b/arch/openrisc/include/asm/pgalloc.h</span>
<span class="p_header">index 21484e5b9e9a..87eebd185089 100644</span>
<span class="p_header">--- a/arch/openrisc/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> static inline struct page *pte_alloc_one(struct mm_struct *mm,</span>
 					 unsigned long address)
 {
 	struct page *pte;
<span class="p_del">-	pte = alloc_pages(GFP_KERNEL|__GFP_REPEAT, 0);</span>
<span class="p_add">+	pte = alloc_pages(GFP_KERNEL, 0);</span>
 	if (!pte)
 		return NULL;
 	clear_page(page_address(pte));
<span class="p_header">diff --git a/arch/openrisc/mm/ioremap.c b/arch/openrisc/mm/ioremap.c</span>
<span class="p_header">index 62b08ef392be..5b2a95116e8f 100644</span>
<span class="p_header">--- a/arch/openrisc/mm/ioremap.c</span>
<span class="p_header">+++ b/arch/openrisc/mm/ioremap.c</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> pte_t __init_refok *pte_alloc_one_kernel(struct mm_struct *mm,</span>
 	pte_t *pte;
 
 	if (likely(mem_init_done)) {
<span class="p_del">-		pte = (pte_t *) __get_free_page(GFP_KERNEL | __GFP_REPEAT);</span>
<span class="p_add">+		pte = (pte_t *) __get_free_page(GFP_KERNEL);</span>
 	} else {
 		pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
 #if 0
<span class="p_header">diff --git a/arch/parisc/include/asm/pgalloc.h b/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_header">index f2fd327dce2e..52c3defb40c9 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> pmd_populate_kernel(struct mm_struct *mm, pmd_t *pmd, pte_t *pte)</span>
 static inline pgtable_t
 pte_alloc_one(struct mm_struct *mm, unsigned long address)
 {
<span class="p_del">-	struct page *page = alloc_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);</span>
<span class="p_add">+	struct page *page = alloc_page(GFP_KERNEL|__GFP_ZERO);</span>
 	if (!page)
 		return NULL;
 	if (!pgtable_page_ctor(page)) {
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> pte_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 static inline pte_t *
 pte_alloc_one_kernel(struct mm_struct *mm, unsigned long addr)
 {
<span class="p_del">-	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);</span>
<span class="p_add">+	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);</span>
 	return pte;
 }
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/pgalloc-64.h b/arch/powerpc/include/asm/pgalloc-64.h</span>
<span class="p_header">index 8d5fc3ac43da..5dcfde5dc673 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/pgalloc-64.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/pgalloc-64.h</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd,</span>
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
 					  unsigned long address)
 {
<span class="p_del">-	return (pte_t *)__get_free_page(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO);</span>
<span class="p_add">+	return (pte_t *)__get_free_page(GFP_KERNEL | __GFP_ZERO);</span>
 }
 
 static inline pgtable_t pte_alloc_one(struct mm_struct *mm,
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable_32.c b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">index bf7bf32b54f8..7f922f557936 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> __init_refok pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long add</span>
 	pte_t *pte;
 
 	if (slab_is_available()) {
<span class="p_del">-		pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);</span>
<span class="p_add">+		pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);</span>
 	} else {
 		pte = __va(memblock_alloc(PAGE_SIZE, PAGE_SIZE));
 		if (pte)
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> pgtable_t pte_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 {
 	struct page *ptepage;
 
<span class="p_del">-	gfp_t flags = GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO;</span>
<span class="p_add">+	gfp_t flags = GFP_KERNEL | __GFP_ZERO;</span>
 
 	ptepage = alloc_pages(flags, 0);
 	if (!ptepage)
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable_64.c b/arch/powerpc/mm/pgtable_64.c</span>
<span class="p_header">index 347106080bb1..03cc73e86675 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable_64.c</span>
<span class="p_chunk">@@ -386,8 +386,7 @@</span> <span class="p_context"> static pte_t *get_from_cache(struct mm_struct *mm)</span>
 static pte_t *__alloc_for_cache(struct mm_struct *mm, int kernel)
 {
 	void *ret = NULL;
<span class="p_del">-	struct page *page = alloc_page(GFP_KERNEL | __GFP_NOTRACK |</span>
<span class="p_del">-				       __GFP_REPEAT | __GFP_ZERO);</span>
<span class="p_add">+	struct page *page = alloc_page(GFP_KERNEL | __GFP_NOTRACK | __GFP_ZERO);</span>
 	if (!page)
 		return NULL;
 	if (!kernel &amp;&amp; !pgtable_page_ctor(page)) {
<span class="p_header">diff --git a/arch/sh/include/asm/pgalloc.h b/arch/sh/include/asm/pgalloc.h</span>
<span class="p_header">index a33673b3687d..f3f42c84c40f 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -34,7 +34,7 @@</span> <span class="p_context"> static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd,</span>
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
 					  unsigned long address)
 {
<span class="p_del">-	return quicklist_alloc(QUICK_PT, GFP_KERNEL | __GFP_REPEAT, NULL);</span>
<span class="p_add">+	return quicklist_alloc(QUICK_PT, GFP_KERNEL, NULL);</span>
 }
 
 static inline pgtable_t pte_alloc_one(struct mm_struct *mm,
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> static inline pgtable_t pte_alloc_one(struct mm_struct *mm,</span>
 	struct page *page;
 	void *pg;
 
<span class="p_del">-	pg = quicklist_alloc(QUICK_PT, GFP_KERNEL | __GFP_REPEAT, NULL);</span>
<span class="p_add">+	pg = quicklist_alloc(QUICK_PT, GFP_KERNEL, NULL);</span>
 	if (!pg)
 		return NULL;
 	page = virt_to_page(pg);
<span class="p_header">diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c</span>
<span class="p_header">index 1cfe6aab7a11..43bbeeb84268 100644</span>
<span class="p_header">--- a/arch/sparc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/sparc/mm/init_64.c</span>
<span class="p_chunk">@@ -2713,8 +2713,7 @@</span> <span class="p_context"> void __flush_tlb_all(void)</span>
 pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
 			    unsigned long address)
 {
<span class="p_del">-	struct page *page = alloc_page(GFP_KERNEL | __GFP_NOTRACK |</span>
<span class="p_del">-				       __GFP_REPEAT | __GFP_ZERO);</span>
<span class="p_add">+	struct page *page = alloc_page(GFP_KERNEL | __GFP_NOTRACK | __GFP_ZERO);</span>
 	pte_t *pte = NULL;
 
 	if (page)
<span class="p_chunk">@@ -2726,8 +2725,7 @@</span> <span class="p_context"> pte_t *pte_alloc_one_kernel(struct mm_struct *mm,</span>
 pgtable_t pte_alloc_one(struct mm_struct *mm,
 			unsigned long address)
 {
<span class="p_del">-	struct page *page = alloc_page(GFP_KERNEL | __GFP_NOTRACK |</span>
<span class="p_del">-				       __GFP_REPEAT | __GFP_ZERO);</span>
<span class="p_add">+	struct page *page = alloc_page(GFP_KERNEL | __GFP_NOTRACK | __GFP_ZERO);</span>
 	if (!page)
 		return NULL;
 	if (!pgtable_page_ctor(page)) {
<span class="p_header">diff --git a/arch/um/kernel/mem.c b/arch/um/kernel/mem.c</span>
<span class="p_header">index b2a2dff50b4e..e7437ec62710 100644</span>
<span class="p_header">--- a/arch/um/kernel/mem.c</span>
<span class="p_header">+++ b/arch/um/kernel/mem.c</span>
<span class="p_chunk">@@ -204,7 +204,7 @@</span> <span class="p_context"> pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)</span>
 {
 	pte_t *pte;
 
<span class="p_del">-	pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);</span>
<span class="p_add">+	pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);</span>
 	return pte;
 }
 
<span class="p_chunk">@@ -212,7 +212,7 @@</span> <span class="p_context"> pgtable_t pte_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 {
 	struct page *pte;
 
<span class="p_del">-	pte = alloc_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);</span>
<span class="p_add">+	pte = alloc_page(GFP_KERNEL|__GFP_ZERO);</span>
 	if (!pte)
 		return NULL;
 	if (!pgtable_page_ctor(pte)) {
<span class="p_header">diff --git a/arch/x86/include/asm/pgalloc.h b/arch/x86/include/asm/pgalloc.h</span>
<span class="p_header">index bf7f8b55b0f9..574c23cf761a 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd,</span>
 static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
 	struct page *page;
<span class="p_del">-	page = alloc_pages(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO, 0);</span>
<span class="p_add">+	page = alloc_pages(GFP_KERNEL |  __GFP_ZERO, 0);</span>
 	if (!page)
 		return NULL;
 	if (!pgtable_pmd_page_ctor(page)) {
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> static inline void pgd_populate(struct mm_struct *mm, pgd_t *pgd, pud_t *pud)</span>
 
 static inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long addr)
 {
<span class="p_del">-	return (pud_t *)get_zeroed_page(GFP_KERNEL|__GFP_REPEAT);</span>
<span class="p_add">+	return (pud_t *)get_zeroed_page(GFP_KERNEL);</span>
 }
 
 static inline void pud_free(struct mm_struct *mm, pud_t *pud)
<span class="p_header">diff --git a/arch/x86/xen/p2m.c b/arch/x86/xen/p2m.c</span>
<span class="p_header">index cab9f766bb06..dd2a49a8aacc 100644</span>
<span class="p_header">--- a/arch/x86/xen/p2m.c</span>
<span class="p_header">+++ b/arch/x86/xen/p2m.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> static void * __ref alloc_p2m_page(void)</span>
 	if (unlikely(!slab_is_available()))
 		return alloc_bootmem_align(PAGE_SIZE, PAGE_SIZE);
 
<span class="p_del">-	return (void *)__get_free_page(GFP_KERNEL | __GFP_REPEAT);</span>
<span class="p_add">+	return (void *)__get_free_page(GFP_KERNEL);</span>
 }
 
 static void __ref free_p2m_page(void *p)
<span class="p_header">diff --git a/arch/xtensa/include/asm/pgalloc.h b/arch/xtensa/include/asm/pgalloc.h</span>
<span class="p_header">index d38eb9237e64..1065bc8bcae5 100644</span>
<span class="p_header">--- a/arch/xtensa/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/xtensa/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,</span>
 	pte_t *ptep;
 	int i;
 
<span class="p_del">-	ptep = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT);</span>
<span class="p_add">+	ptep = (pte_t *)__get_free_page(GFP_KERNEL);</span>
 	if (!ptep)
 		return NULL;
 	for (i = 0; i &lt; 1024; i++)
<span class="p_header">diff --git a/drivers/block/aoe/aoecmd.c b/drivers/block/aoe/aoecmd.c</span>
<span class="p_header">index d597e432e195..ab19adb07a12 100644</span>
<span class="p_header">--- a/drivers/block/aoe/aoecmd.c</span>
<span class="p_header">+++ b/drivers/block/aoe/aoecmd.c</span>
<span class="p_chunk">@@ -1750,7 +1750,7 @@</span> <span class="p_context"> aoecmd_init(void)</span>
 	int ret;
 
 	/* get_zeroed_page returns page with ref count 1 */
<span class="p_del">-	p = (void *) get_zeroed_page(GFP_KERNEL | __GFP_REPEAT);</span>
<span class="p_add">+	p = (void *) get_zeroed_page(GFP_KERNEL);</span>
 	if (!p)
 		return -ENOMEM;
 	empty_page = virt_to_page(p);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



