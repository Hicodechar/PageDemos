
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.0.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.0.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 23, 2015, 2:35 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150623023517.GB18511@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6658751/mbox/"
   >mbox</a>
|
   <a href="/patch/6658751/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6658751/">/patch/6658751/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 7458E9F39B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 Jun 2015 02:36:36 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id B38ED2050E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 Jun 2015 02:36:29 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 22F7B20524
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 Jun 2015 02:36:17 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932245AbbFWCgN (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 22 Jun 2015 22:36:13 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:39327 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932213AbbFWCfv (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 22 Jun 2015 22:35:51 -0400
Received: from localhost (unknown [64.88.227.134])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 7C974BB6;
	Tue, 23 Jun 2015 02:35:34 +0000 (UTC)
Date: Mon, 22 Jun 2015 19:35:17 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.0.6
Message-ID: &lt;20150623023517.GB18511@kroah.com&gt;
References: &lt;20150623023510.GA18511@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150623023510.GA18511@kroah.com&gt;
User-Agent: Mutt/1.5.23+89 (0255b37be491) (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-3.3 required=5.0 tests=BAYES_00,RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 23, 2015, 2:35 a.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 1880cf77059b..af6da040b952 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 0
<span class="p_del">-SUBLEVEL = 5</span>
<span class="p_add">+SUBLEVEL = 6</span>
 EXTRAVERSION =
 NAME = Hurr durr I&#39;ma sheep
 
<span class="p_header">diff --git a/arch/arm/boot/dts/am335x-bone-common.dtsi b/arch/arm/boot/dts/am335x-bone-common.dtsi</span>
<span class="p_header">index c3255e0c90aa..dbb3f4d2bf84 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am335x-bone-common.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am335x-bone-common.dtsi</span>
<span class="p_chunk">@@ -223,6 +223,25 @@</span> <span class="p_context"></span>
 /include/ &quot;tps65217.dtsi&quot;
 
 &amp;tps {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Configure pmic to enter OFF-state instead of SLEEP-state (&quot;RTC-only</span>
<span class="p_add">+	 * mode&quot;) at poweroff.  Most BeagleBone versions do not support RTC-only</span>
<span class="p_add">+	 * mode and risk hardware damage if this mode is entered.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For details, see linux-omap mailing list May 2015 thread</span>
<span class="p_add">+	 *	[PATCH] ARM: dts: am335x-bone* enable pmic-shutdown-controller</span>
<span class="p_add">+	 * In particular, messages:</span>
<span class="p_add">+	 *	http://www.spinics.net/lists/linux-omap/msg118585.html</span>
<span class="p_add">+	 *	http://www.spinics.net/lists/linux-omap/msg118615.html</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * You can override this later with</span>
<span class="p_add">+	 *	&amp;tps {  /delete-property/ ti,pmic-shutdown-controller;  }</span>
<span class="p_add">+	 * if you want to use RTC-only mode and made sure you are not affected</span>
<span class="p_add">+	 * by the hardware problems. (Tip: double-check by performing a current</span>
<span class="p_add">+	 * measurement after shutdown: it should be less than 1 mA.)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ti,pmic-shutdown-controller;</span>
<span class="p_add">+</span>
 	regulators {
 		dcdc1_reg: regulator@0 {
 			regulator-name = &quot;vdds_dpr&quot;;
<span class="p_header">diff --git a/arch/arm64/boot/dts/mediatek/mt8173-evb.dts b/arch/arm64/boot/dts/mediatek/mt8173-evb.dts</span>
<span class="p_header">index 43d54017b779..d0ab012fa379 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/mediatek/mt8173-evb.dts</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/mediatek/mt8173-evb.dts</span>
<span class="p_chunk">@@ -16,7 +16,8 @@</span> <span class="p_context"></span>
 #include &quot;mt8173.dtsi&quot;
 
 / {
<span class="p_del">-	model = &quot;mediatek,mt8173-evb&quot;;</span>
<span class="p_add">+	model = &quot;MediaTek MT8173 evaluation board&quot;;</span>
<span class="p_add">+	compatible = &quot;mediatek,mt8173-evb&quot;, &quot;mediatek,mt8173&quot;;</span>
 
 	aliases {
 		serial0 = &amp;uart0;
<span class="p_header">diff --git a/arch/mips/kernel/irq.c b/arch/mips/kernel/irq.c</span>
<span class="p_header">index d2bfbc2e8995..be15e52a47a0 100644</span>
<span class="p_header">--- a/arch/mips/kernel/irq.c</span>
<span class="p_header">+++ b/arch/mips/kernel/irq.c</span>
<span class="p_chunk">@@ -109,7 +109,7 @@</span> <span class="p_context"> void __init init_IRQ(void)</span>
 #endif
 }
 
<span class="p_del">-#ifdef DEBUG_STACKOVERFLOW</span>
<span class="p_add">+#ifdef CONFIG_DEBUG_STACKOVERFLOW</span>
 static inline void check_stack_overflow(void)
 {
 	unsigned long sp;
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index 838d3a6a5b7d..cea02968a908 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -2101,7 +2101,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu,</span>
 		if (vcpu-&gt;mmio_needed == 2)
 			*gpr = *(int16_t *) run-&gt;mmio.data;
 		else
<span class="p_del">-			*gpr = *(int16_t *) run-&gt;mmio.data;</span>
<span class="p_add">+			*gpr = *(uint16_t *)run-&gt;mmio.data;</span>
 
 		break;
 	case 1:
<span class="p_header">diff --git a/arch/mips/ralink/ill_acc.c b/arch/mips/ralink/ill_acc.c</span>
<span class="p_header">index e20b02e3ae28..e10d10b9e82a 100644</span>
<span class="p_header">--- a/arch/mips/ralink/ill_acc.c</span>
<span class="p_header">+++ b/arch/mips/ralink/ill_acc.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> static irqreturn_t ill_acc_irq_handler(int irq, void *_priv)</span>
 		addr, (type &gt;&gt; ILL_ACC_OFF_S) &amp; ILL_ACC_OFF_M,
 		type &amp; ILL_ACC_LEN_M);
 
<span class="p_del">-	rt_memc_w32(REG_ILL_ACC_TYPE, REG_ILL_ACC_TYPE);</span>
<span class="p_add">+	rt_memc_w32(ILL_INT_STATUS, REG_ILL_ACC_TYPE);</span>
 
 	return IRQ_HANDLED;
 }
<span class="p_header">diff --git a/arch/x86/include/asm/segment.h b/arch/x86/include/asm/segment.h</span>
<span class="p_header">index db257a58571f..e657b7ba3292 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/segment.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/segment.h</span>
<span class="p_chunk">@@ -200,10 +200,21 @@</span> <span class="p_context"></span>
 #define TLS_SIZE (GDT_ENTRY_TLS_ENTRIES * 8)
 
 #ifdef __KERNEL__
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * early_idt_handler_array is an array of entry points referenced in the</span>
<span class="p_add">+ * early IDT.  For simplicity, it&#39;s a real array with one entry point</span>
<span class="p_add">+ * every nine bytes.  That leaves room for an optional &#39;push $0&#39; if the</span>
<span class="p_add">+ * vector has no error code (two bytes), a &#39;push $vector_number&#39; (two</span>
<span class="p_add">+ * bytes), and a jump to the common entry code (up to five bytes).</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define EARLY_IDT_HANDLER_SIZE 9</span>
<span class="p_add">+</span>
 #ifndef __ASSEMBLY__
<span class="p_del">-extern const char early_idt_handlers[NUM_EXCEPTION_VECTORS][2+2+5];</span>
<span class="p_add">+</span>
<span class="p_add">+extern const char early_idt_handler_array[NUM_EXCEPTION_VECTORS][EARLY_IDT_HANDLER_SIZE];</span>
 #ifdef CONFIG_TRACING
<span class="p_del">-#define trace_early_idt_handlers early_idt_handlers</span>
<span class="p_add">+# define trace_early_idt_handler_array early_idt_handler_array</span>
 #endif
 
 /*
<span class="p_header">diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c</span>
<span class="p_header">index c4f8d4659070..b111ab5c4509 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/head64.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> asmlinkage __visible void __init x86_64_start_kernel(char * real_mode_data)</span>
 	clear_bss();
 
 	for (i = 0; i &lt; NUM_EXCEPTION_VECTORS; i++)
<span class="p_del">-		set_intr_gate(i, early_idt_handlers[i]);</span>
<span class="p_add">+		set_intr_gate(i, early_idt_handler_array[i]);</span>
 	load_idt((const struct desc_ptr *)&amp;idt_descr);
 
 	copy_bootdata(__va(real_mode_data));
<span class="p_header">diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S</span>
<span class="p_header">index f36bd42d6f0c..30a2aa3782fa 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head_32.S</span>
<span class="p_header">+++ b/arch/x86/kernel/head_32.S</span>
<span class="p_chunk">@@ -477,21 +477,22 @@</span> <span class="p_context"> is486:</span>
 __INIT
 setup_once:
 	/*
<span class="p_del">-	 * Set up a idt with 256 entries pointing to ignore_int,</span>
<span class="p_del">-	 * interrupt gates. It doesn&#39;t actually load idt - that needs</span>
<span class="p_del">-	 * to be done on each CPU. Interrupts are enabled elsewhere,</span>
<span class="p_del">-	 * when we can be relatively sure everything is ok.</span>
<span class="p_add">+	 * Set up a idt with 256 interrupt gates that push zero if there</span>
<span class="p_add">+	 * is no error code and then jump to early_idt_handler_common.</span>
<span class="p_add">+	 * It doesn&#39;t actually load the idt - that needs to be done on</span>
<span class="p_add">+	 * each CPU. Interrupts are enabled elsewhere, when we can be</span>
<span class="p_add">+	 * relatively sure everything is ok.</span>
 	 */
 
 	movl $idt_table,%edi
<span class="p_del">-	movl $early_idt_handlers,%eax</span>
<span class="p_add">+	movl $early_idt_handler_array,%eax</span>
 	movl $NUM_EXCEPTION_VECTORS,%ecx
 1:
 	movl %eax,(%edi)
 	movl %eax,4(%edi)
 	/* interrupt gate, dpl=0, present */
 	movl $(0x8E000000 + __KERNEL_CS),2(%edi)
<span class="p_del">-	addl $9,%eax</span>
<span class="p_add">+	addl $EARLY_IDT_HANDLER_SIZE,%eax</span>
 	addl $8,%edi
 	loop 1b
 
<span class="p_chunk">@@ -523,26 +524,28 @@</span> <span class="p_context"> setup_once:</span>
 	andl $0,setup_once_ref	/* Once is enough, thanks */
 	ret
 
<span class="p_del">-ENTRY(early_idt_handlers)</span>
<span class="p_add">+ENTRY(early_idt_handler_array)</span>
 	# 36(%esp) %eflags
 	# 32(%esp) %cs
 	# 28(%esp) %eip
 	# 24(%rsp) error code
 	i = 0
 	.rept NUM_EXCEPTION_VECTORS
<span class="p_del">-	.if (EXCEPTION_ERRCODE_MASK &gt;&gt; i) &amp; 1</span>
<span class="p_del">-	ASM_NOP2</span>
<span class="p_del">-	.else</span>
<span class="p_add">+	.ifeq (EXCEPTION_ERRCODE_MASK &gt;&gt; i) &amp; 1</span>
 	pushl $0		# Dummy error code, to make stack frame uniform
 	.endif
 	pushl $i		# 20(%esp) Vector number
<span class="p_del">-	jmp early_idt_handler</span>
<span class="p_add">+	jmp early_idt_handler_common</span>
 	i = i + 1
<span class="p_add">+	.fill early_idt_handler_array + i*EARLY_IDT_HANDLER_SIZE - ., 1, 0xcc</span>
 	.endr
<span class="p_del">-ENDPROC(early_idt_handlers)</span>
<span class="p_add">+ENDPROC(early_idt_handler_array)</span>
 	
<span class="p_del">-	/* This is global to keep gas from relaxing the jumps */</span>
<span class="p_del">-ENTRY(early_idt_handler)</span>
<span class="p_add">+early_idt_handler_common:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The stack is the hardware frame, an error code or zero, and the</span>
<span class="p_add">+	 * vector number.</span>
<span class="p_add">+	 */</span>
 	cld
 
 	cmpl $2,(%esp)		# X86_TRAP_NMI
<span class="p_chunk">@@ -602,7 +605,7 @@</span> <span class="p_context"> ex_entry:</span>
 is_nmi:
 	addl $8,%esp		/* drop vector number and error code */
 	iret
<span class="p_del">-ENDPROC(early_idt_handler)</span>
<span class="p_add">+ENDPROC(early_idt_handler_common)</span>
 
 /* This is the default interrupt &quot;handler&quot; :-) */
 	ALIGN
<span class="p_header">diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S</span>
<span class="p_header">index 6fd514d9f69a..f8a8406033c3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/head_64.S</span>
<span class="p_chunk">@@ -321,26 +321,28 @@</span> <span class="p_context"> bad_address:</span>
 	jmp bad_address
 
 	__INIT
<span class="p_del">-	.globl early_idt_handlers</span>
<span class="p_del">-early_idt_handlers:</span>
<span class="p_add">+ENTRY(early_idt_handler_array)</span>
 	# 104(%rsp) %rflags
 	#  96(%rsp) %cs
 	#  88(%rsp) %rip
 	#  80(%rsp) error code
 	i = 0
 	.rept NUM_EXCEPTION_VECTORS
<span class="p_del">-	.if (EXCEPTION_ERRCODE_MASK &gt;&gt; i) &amp; 1</span>
<span class="p_del">-	ASM_NOP2</span>
<span class="p_del">-	.else</span>
<span class="p_add">+	.ifeq (EXCEPTION_ERRCODE_MASK &gt;&gt; i) &amp; 1</span>
 	pushq $0		# Dummy error code, to make stack frame uniform
 	.endif
 	pushq $i		# 72(%rsp) Vector number
<span class="p_del">-	jmp early_idt_handler</span>
<span class="p_add">+	jmp early_idt_handler_common</span>
 	i = i + 1
<span class="p_add">+	.fill early_idt_handler_array + i*EARLY_IDT_HANDLER_SIZE - ., 1, 0xcc</span>
 	.endr
<span class="p_add">+ENDPROC(early_idt_handler_array)</span>
 
<span class="p_del">-/* This is global to keep gas from relaxing the jumps */</span>
<span class="p_del">-ENTRY(early_idt_handler)</span>
<span class="p_add">+early_idt_handler_common:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The stack is the hardware frame, an error code or zero, and the</span>
<span class="p_add">+	 * vector number.</span>
<span class="p_add">+	 */</span>
 	cld
 
 	cmpl $2,(%rsp)		# X86_TRAP_NMI
<span class="p_chunk">@@ -412,7 +414,7 @@</span> <span class="p_context"> ENTRY(early_idt_handler)</span>
 is_nmi:
 	addq $16,%rsp		# drop vector number and error code
 	INTERRUPT_RETURN
<span class="p_del">-ENDPROC(early_idt_handler)</span>
<span class="p_add">+ENDPROC(early_idt_handler_common)</span>
 
 	__INITDATA
 
<span class="p_header">diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">index 987514396c1e..ddeff4844a10 100644</span>
<span class="p_header">--- a/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -559,6 +559,13 @@</span> <span class="p_context"> static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,</span>
 				if (is_ereg(dst_reg))
 					EMIT1(0x41);
 				EMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);
<span class="p_add">+</span>
<span class="p_add">+				/* emit &#39;movzwl eax, ax&#39; */</span>
<span class="p_add">+				if (is_ereg(dst_reg))</span>
<span class="p_add">+					EMIT3(0x45, 0x0F, 0xB7);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					EMIT2(0x0F, 0xB7);</span>
<span class="p_add">+				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));</span>
 				break;
 			case 32:
 				/* emit &#39;bswap eax&#39; to swap lower 4 bytes */
<span class="p_chunk">@@ -577,6 +584,27 @@</span> <span class="p_context"> static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,</span>
 			break;
 
 		case BPF_ALU | BPF_END | BPF_FROM_LE:
<span class="p_add">+			switch (imm32) {</span>
<span class="p_add">+			case 16:</span>
<span class="p_add">+				/* emit &#39;movzwl eax, ax&#39; to zero extend 16-bit</span>
<span class="p_add">+				 * into 64 bit</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (is_ereg(dst_reg))</span>
<span class="p_add">+					EMIT3(0x45, 0x0F, 0xB7);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					EMIT2(0x0F, 0xB7);</span>
<span class="p_add">+				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case 32:</span>
<span class="p_add">+				/* emit &#39;mov eax, eax&#39; to clear upper 32-bits */</span>
<span class="p_add">+				if (is_ereg(dst_reg))</span>
<span class="p_add">+					EMIT1(0x45);</span>
<span class="p_add">+				EMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case 64:</span>
<span class="p_add">+				/* nop */</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 			break;
 
 			/* ST: *(u8*)(dst_reg + off) = imm */
<span class="p_chunk">@@ -938,7 +966,12 @@</span> <span class="p_context"> void bpf_int_jit_compile(struct bpf_prog *prog)</span>
 	}
 	ctx.cleanup_addr = proglen;
 
<span class="p_del">-	for (pass = 0; pass &lt; 10; pass++) {</span>
<span class="p_add">+	/* JITed image shrinks with every pass and the loop iterates</span>
<span class="p_add">+	 * until the image stops shrinking. Very large bpf programs</span>
<span class="p_add">+	 * may converge on the last pass. In such case do one more</span>
<span class="p_add">+	 * pass to emit the final image</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (pass = 0; pass &lt; 10 || image; pass++) {</span>
 		proglen = do_jit(prog, addrs, image, oldproglen, &amp;ctx);
 		if (proglen &lt;= 0) {
 			image = NULL;
<span class="p_header">diff --git a/arch/x86/vdso/Makefile b/arch/x86/vdso/Makefile</span>
<span class="p_header">index 7b9be9822724..8533c96bab13 100644</span>
<span class="p_header">--- a/arch/x86/vdso/Makefile</span>
<span class="p_header">+++ b/arch/x86/vdso/Makefile</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> VDSO_LDFLAGS_vdso.lds = -m64 -Wl,-soname=linux-vdso.so.1 \</span>
 $(obj)/vdso64.so.dbg: $(src)/vdso.lds $(vobjs) FORCE
 	$(call if_changed,vdso)
 
<span class="p_del">-HOST_EXTRACFLAGS += -I$(srctree)/tools/include</span>
<span class="p_add">+HOST_EXTRACFLAGS += -I$(srctree)/tools/include -I$(srctree)/include/uapi -I$(srctree)/arch/x86/include/uapi</span>
 hostprogs-y			+= vdso2c
 
 quiet_cmd_vdso2c = VDSO2C  $@
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 5c39703e644f..b2e73e1ef8a4 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -1589,6 +1589,7 @@</span> <span class="p_context"> static int blk_mq_hctx_notify(void *data, unsigned long action,</span>
 	return NOTIFY_OK;
 }
 
<span class="p_add">+/* hctx-&gt;ctxs will be freed in queue&#39;s release handler */</span>
 static void blk_mq_exit_hctx(struct request_queue *q,
 		struct blk_mq_tag_set *set,
 		struct blk_mq_hw_ctx *hctx, unsigned int hctx_idx)
<span class="p_chunk">@@ -1607,7 +1608,6 @@</span> <span class="p_context"> static void blk_mq_exit_hctx(struct request_queue *q,</span>
 
 	blk_mq_unregister_cpu_notifier(&amp;hctx-&gt;cpu_notifier);
 	blk_free_flush_queue(hctx-&gt;fq);
<span class="p_del">-	kfree(hctx-&gt;ctxs);</span>
 	blk_mq_free_bitmap(&amp;hctx-&gt;ctx_map);
 }
 
<span class="p_chunk">@@ -1873,8 +1873,12 @@</span> <span class="p_context"> void blk_mq_release(struct request_queue *q)</span>
 	unsigned int i;
 
 	/* hctx kobj stays in hctx */
<span class="p_del">-	queue_for_each_hw_ctx(q, hctx, i)</span>
<span class="p_add">+	queue_for_each_hw_ctx(q, hctx, i) {</span>
<span class="p_add">+		if (!hctx)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		kfree(hctx-&gt;ctxs);</span>
 		kfree(hctx);
<span class="p_add">+	}</span>
 
 	kfree(q-&gt;queue_hw_ctx);
 
<span class="p_header">diff --git a/block/genhd.c b/block/genhd.c</span>
<span class="p_header">index 0a536dc05f3b..ea982eadaf63 100644</span>
<span class="p_header">--- a/block/genhd.c</span>
<span class="p_header">+++ b/block/genhd.c</span>
<span class="p_chunk">@@ -422,9 +422,9 @@</span> <span class="p_context"> int blk_alloc_devt(struct hd_struct *part, dev_t *devt)</span>
 	/* allocate ext devt */
 	idr_preload(GFP_KERNEL);
 
<span class="p_del">-	spin_lock(&amp;ext_devt_lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;ext_devt_lock);</span>
 	idx = idr_alloc(&amp;ext_devt_idr, part, 0, NR_EXT_DEVT, GFP_NOWAIT);
<span class="p_del">-	spin_unlock(&amp;ext_devt_lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;ext_devt_lock);</span>
 
 	idr_preload_end();
 	if (idx &lt; 0)
<span class="p_chunk">@@ -449,9 +449,9 @@</span> <span class="p_context"> void blk_free_devt(dev_t devt)</span>
 		return;
 
 	if (MAJOR(devt) == BLOCK_EXT_MAJOR) {
<span class="p_del">-		spin_lock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_lock_bh(&amp;ext_devt_lock);</span>
 		idr_remove(&amp;ext_devt_idr, blk_mangle_minor(MINOR(devt)));
<span class="p_del">-		spin_unlock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_unlock_bh(&amp;ext_devt_lock);</span>
 	}
 }
 
<span class="p_chunk">@@ -653,7 +653,6 @@</span> <span class="p_context"> void del_gendisk(struct gendisk *disk)</span>
 	disk-&gt;flags &amp;= ~GENHD_FL_UP;
 
 	sysfs_remove_link(&amp;disk_to_dev(disk)-&gt;kobj, &quot;bdi&quot;);
<span class="p_del">-	bdi_unregister(&amp;disk-&gt;queue-&gt;backing_dev_info);</span>
 	blk_unregister_queue(disk);
 	blk_unregister_region(disk_devt(disk), disk-&gt;minors);
 
<span class="p_chunk">@@ -691,13 +690,13 @@</span> <span class="p_context"> struct gendisk *get_gendisk(dev_t devt, int *partno)</span>
 	} else {
 		struct hd_struct *part;
 
<span class="p_del">-		spin_lock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_lock_bh(&amp;ext_devt_lock);</span>
 		part = idr_find(&amp;ext_devt_idr, blk_mangle_minor(MINOR(devt)));
 		if (part &amp;&amp; get_disk(part_to_disk(part))) {
 			*partno = part-&gt;partno;
 			disk = part_to_disk(part);
 		}
<span class="p_del">-		spin_unlock(&amp;ext_devt_lock);</span>
<span class="p_add">+		spin_unlock_bh(&amp;ext_devt_lock);</span>
 	}
 
 	return disk;
<span class="p_header">diff --git a/drivers/ata/ahci_mvebu.c b/drivers/ata/ahci_mvebu.c</span>
<span class="p_header">index 23716dd8a7ec..5928d0746a27 100644</span>
<span class="p_header">--- a/drivers/ata/ahci_mvebu.c</span>
<span class="p_header">+++ b/drivers/ata/ahci_mvebu.c</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> static void ahci_mvebu_mbus_config(struct ahci_host_priv *hpriv,</span>
 		writel((cs-&gt;mbus_attr &lt;&lt; 8) |
 		       (dram-&gt;mbus_dram_target_id &lt;&lt; 4) | 1,
 		       hpriv-&gt;mmio + AHCI_WINDOW_CTRL(i));
<span class="p_del">-		writel(cs-&gt;base, hpriv-&gt;mmio + AHCI_WINDOW_BASE(i));</span>
<span class="p_add">+		writel(cs-&gt;base &gt;&gt; 16, hpriv-&gt;mmio + AHCI_WINDOW_BASE(i));</span>
 		writel(((cs-&gt;size - 1) &amp; 0xffff0000),
 		       hpriv-&gt;mmio + AHCI_WINDOW_SIZE(i));
 	}
<span class="p_header">diff --git a/drivers/ata/pata_octeon_cf.c b/drivers/ata/pata_octeon_cf.c</span>
<span class="p_header">index 80a80548ad0a..27245957eee3 100644</span>
<span class="p_header">--- a/drivers/ata/pata_octeon_cf.c</span>
<span class="p_header">+++ b/drivers/ata/pata_octeon_cf.c</span>
<span class="p_chunk">@@ -1053,7 +1053,7 @@</span> <span class="p_context"> static struct of_device_id octeon_cf_match[] = {</span>
 	},
 	{},
 };
<span class="p_del">-MODULE_DEVICE_TABLE(of, octeon_i2c_match);</span>
<span class="p_add">+MODULE_DEVICE_TABLE(of, octeon_cf_match);</span>
 
 static struct platform_driver octeon_cf_driver = {
 	.probe		= octeon_cf_probe,
<span class="p_header">diff --git a/drivers/base/cacheinfo.c b/drivers/base/cacheinfo.c</span>
<span class="p_header">index 9c2ba1c97c42..df0c66cb7ad3 100644</span>
<span class="p_header">--- a/drivers/base/cacheinfo.c</span>
<span class="p_header">+++ b/drivers/base/cacheinfo.c</span>
<span class="p_chunk">@@ -179,7 +179,7 @@</span> <span class="p_context"> static int detect_cache_attributes(unsigned int cpu)</span>
 {
 	int ret;
 
<span class="p_del">-	if (init_cache_level(cpu))</span>
<span class="p_add">+	if (init_cache_level(cpu) || !cache_leaves(cpu))</span>
 		return -ENOENT;
 
 	per_cpu_cacheinfo(cpu) = kcalloc(cache_leaves(cpu),
<span class="p_header">diff --git a/drivers/bus/mvebu-mbus.c b/drivers/bus/mvebu-mbus.c</span>
<span class="p_header">index fb9ec6221730..6f047dcb94c2 100644</span>
<span class="p_header">--- a/drivers/bus/mvebu-mbus.c</span>
<span class="p_header">+++ b/drivers/bus/mvebu-mbus.c</span>
<span class="p_chunk">@@ -58,7 +58,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/debugfs.h&gt;
 #include &lt;linux/log2.h&gt;
 #include &lt;linux/syscore_ops.h&gt;
<span class="p_del">-#include &lt;linux/memblock.h&gt;</span>
 
 /*
  * DDR target is the same on all platforms.
<span class="p_chunk">@@ -70,6 +69,7 @@</span> <span class="p_context"></span>
  */
 #define WIN_CTRL_OFF		0x0000
 #define   WIN_CTRL_ENABLE       BIT(0)
<span class="p_add">+/* Only on HW I/O coherency capable platforms */</span>
 #define   WIN_CTRL_SYNCBARRIER  BIT(1)
 #define   WIN_CTRL_TGT_MASK     0xf0
 #define   WIN_CTRL_TGT_SHIFT    4
<span class="p_chunk">@@ -102,9 +102,7 @@</span> <span class="p_context"></span>
 
 /* Relative to mbusbridge_base */
 #define MBUS_BRIDGE_CTRL_OFF	0x0
<span class="p_del">-#define  MBUS_BRIDGE_SIZE_MASK  0xffff0000</span>
 #define MBUS_BRIDGE_BASE_OFF	0x4
<span class="p_del">-#define  MBUS_BRIDGE_BASE_MASK  0xffff0000</span>
 
 /* Maximum number of windows, for all known platforms */
 #define MBUS_WINS_MAX           20
<span class="p_chunk">@@ -323,8 +321,9 @@</span> <span class="p_context"> static int mvebu_mbus_setup_window(struct mvebu_mbus_state *mbus,</span>
 	ctrl = ((size - 1) &amp; WIN_CTRL_SIZE_MASK) |
 		(attr &lt;&lt; WIN_CTRL_ATTR_SHIFT)    |
 		(target &lt;&lt; WIN_CTRL_TGT_SHIFT)   |
<span class="p_del">-		WIN_CTRL_SYNCBARRIER             |</span>
 		WIN_CTRL_ENABLE;
<span class="p_add">+	if (mbus-&gt;hw_io_coherency)</span>
<span class="p_add">+		ctrl |= WIN_CTRL_SYNCBARRIER;</span>
 
 	writel(base &amp; WIN_BASE_LOW, addr + WIN_BASE_OFF);
 	writel(ctrl, addr + WIN_CTRL_OFF);
<span class="p_chunk">@@ -577,106 +576,36 @@</span> <span class="p_context"> static unsigned int armada_xp_mbus_win_remap_offset(int win)</span>
 		return MVEBU_MBUS_NO_REMAP;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Use the memblock information to find the MBus bridge hole in the</span>
<span class="p_del">- * physical address space.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void __init</span>
<span class="p_del">-mvebu_mbus_find_bridge_hole(uint64_t *start, uint64_t *end)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct memblock_region *r;</span>
<span class="p_del">-	uint64_t s = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	for_each_memblock(memory, r) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * This part of the memory is above 4 GB, so we don&#39;t</span>
<span class="p_del">-		 * care for the MBus bridge hole.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (r-&gt;base &gt;= 0x100000000)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The MBus bridge hole is at the end of the RAM under</span>
<span class="p_del">-		 * the 4 GB limit.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (r-&gt;base + r-&gt;size &gt; s)</span>
<span class="p_del">-			s = r-&gt;base + r-&gt;size;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	*start = s;</span>
<span class="p_del">-	*end = 0x100000000;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void __init
 mvebu_mbus_default_setup_cpu_target(struct mvebu_mbus_state *mbus)
 {
 	int i;
 	int cs;
<span class="p_del">-	uint64_t mbus_bridge_base, mbus_bridge_end;</span>
 
 	mvebu_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
 
<span class="p_del">-	mvebu_mbus_find_bridge_hole(&amp;mbus_bridge_base, &amp;mbus_bridge_end);</span>
<span class="p_del">-</span>
 	for (i = 0, cs = 0; i &lt; 4; i++) {
<span class="p_del">-		u64 base = readl(mbus-&gt;sdramwins_base + DDR_BASE_CS_OFF(i));</span>
<span class="p_del">-		u64 size = readl(mbus-&gt;sdramwins_base + DDR_SIZE_CS_OFF(i));</span>
<span class="p_del">-		u64 end;</span>
<span class="p_del">-		struct mbus_dram_window *w;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Ignore entries that are not enabled */</span>
<span class="p_del">-		if (!(size &amp; DDR_SIZE_ENABLED))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Ignore entries whose base address is above 2^32,</span>
<span class="p_del">-		 * since devices cannot DMA to such high addresses</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (base &amp; DDR_BASE_CS_HIGH_MASK)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		base = base &amp; DDR_BASE_CS_LOW_MASK;</span>
<span class="p_del">-		size = (size | ~DDR_SIZE_MASK) + 1;</span>
<span class="p_del">-		end = base + size;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Adjust base/size of the current CS to make sure it</span>
<span class="p_del">-		 * doesn&#39;t overlap with the MBus bridge hole. This is</span>
<span class="p_del">-		 * particularly important for devices that do DMA from</span>
<span class="p_del">-		 * DRAM to a SRAM mapped in a MBus window, such as the</span>
<span class="p_del">-		 * CESA cryptographic engine.</span>
<span class="p_del">-		 */</span>
<span class="p_add">+		u32 base = readl(mbus-&gt;sdramwins_base + DDR_BASE_CS_OFF(i));</span>
<span class="p_add">+		u32 size = readl(mbus-&gt;sdramwins_base + DDR_SIZE_CS_OFF(i));</span>
 
 		/*
<span class="p_del">-		 * The CS is fully enclosed inside the MBus bridge</span>
<span class="p_del">-		 * area, so ignore it.</span>
<span class="p_add">+		 * We only take care of entries for which the chip</span>
<span class="p_add">+		 * select is enabled, and that don&#39;t have high base</span>
<span class="p_add">+		 * address bits set (devices can only access the first</span>
<span class="p_add">+		 * 32 bits of the memory).</span>
 		 */
<span class="p_del">-		if (base &gt;= mbus_bridge_base &amp;&amp; end &lt;= mbus_bridge_end)</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+		if ((size &amp; DDR_SIZE_ENABLED) &amp;&amp;</span>
<span class="p_add">+		    !(base &amp; DDR_BASE_CS_HIGH_MASK)) {</span>
<span class="p_add">+			struct mbus_dram_window *w;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Beginning of CS overlaps with end of MBus, raise CS</span>
<span class="p_del">-		 * base address, and shrink its size.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (base &gt;= mbus_bridge_base &amp;&amp; end &gt; mbus_bridge_end) {</span>
<span class="p_del">-			size -= mbus_bridge_end - base;</span>
<span class="p_del">-			base = mbus_bridge_end;</span>
<span class="p_add">+			w = &amp;mvebu_mbus_dram_info.cs[cs++];</span>
<span class="p_add">+			w-&gt;cs_index = i;</span>
<span class="p_add">+			w-&gt;mbus_attr = 0xf &amp; ~(1 &lt;&lt; i);</span>
<span class="p_add">+			if (mbus-&gt;hw_io_coherency)</span>
<span class="p_add">+				w-&gt;mbus_attr |= ATTR_HW_COHERENCY;</span>
<span class="p_add">+			w-&gt;base = base &amp; DDR_BASE_CS_LOW_MASK;</span>
<span class="p_add">+			w-&gt;size = (size | ~DDR_SIZE_MASK) + 1;</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * End of CS overlaps with beginning of MBus, shrink</span>
<span class="p_del">-		 * CS size.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (base &lt; mbus_bridge_base &amp;&amp; end &gt; mbus_bridge_base)</span>
<span class="p_del">-			size -= end - mbus_bridge_base;</span>
<span class="p_del">-</span>
<span class="p_del">-		w = &amp;mvebu_mbus_dram_info.cs[cs++];</span>
<span class="p_del">-		w-&gt;cs_index = i;</span>
<span class="p_del">-		w-&gt;mbus_attr = 0xf &amp; ~(1 &lt;&lt; i);</span>
<span class="p_del">-		if (mbus-&gt;hw_io_coherency)</span>
<span class="p_del">-			w-&gt;mbus_attr |= ATTR_HW_COHERENCY;</span>
<span class="p_del">-		w-&gt;base = base;</span>
<span class="p_del">-		w-&gt;size = size;</span>
 	}
 	mvebu_mbus_dram_info.num_cs = cs;
 }
<span class="p_header">diff --git a/drivers/dma/at_xdmac.c b/drivers/dma/at_xdmac.c</span>
<span class="p_header">index d9891d3461f6..7992164ea9ec 100644</span>
<span class="p_header">--- a/drivers/dma/at_xdmac.c</span>
<span class="p_header">+++ b/drivers/dma/at_xdmac.c</span>
<span class="p_chunk">@@ -174,6 +174,8 @@</span> <span class="p_context"></span>
 #define AT_XDMAC_MBR_UBC_NDV3		(0x3 &lt;&lt; 27)	/* Next Descriptor View 3 */
 
 #define AT_XDMAC_MAX_CHAN	0x20
<span class="p_add">+#define AT_XDMAC_MAX_CSIZE	16	/* 16 data */</span>
<span class="p_add">+#define AT_XDMAC_MAX_DWIDTH	8	/* 64 bits */</span>
 
 #define AT_XDMAC_DMA_BUSWIDTHS\
 	(BIT(DMA_SLAVE_BUSWIDTH_UNDEFINED) |\
<span class="p_chunk">@@ -192,20 +194,17 @@</span> <span class="p_context"> struct at_xdmac_chan {</span>
 	struct dma_chan			chan;
 	void __iomem			*ch_regs;
 	u32				mask;		/* Channel Mask */
<span class="p_del">-	u32				cfg[2];		/* Channel Configuration Register */</span>
<span class="p_del">-	#define	AT_XDMAC_DEV_TO_MEM_CFG	0		/* Predifined dev to mem channel conf */</span>
<span class="p_del">-	#define	AT_XDMAC_MEM_TO_DEV_CFG	1		/* Predifined mem to dev channel conf */</span>
<span class="p_add">+	u32				cfg;		/* Channel Configuration Register */</span>
 	u8				perid;		/* Peripheral ID */
 	u8				perif;		/* Peripheral Interface */
 	u8				memif;		/* Memory Interface */
<span class="p_del">-	u32				per_src_addr;</span>
<span class="p_del">-	u32				per_dst_addr;</span>
 	u32				save_cc;
 	u32				save_cim;
 	u32				save_cnda;
 	u32				save_cndc;
 	unsigned long			status;
 	struct tasklet_struct		tasklet;
<span class="p_add">+	struct dma_slave_config		sconfig;</span>
 
 	spinlock_t			lock;
 
<span class="p_chunk">@@ -415,8 +414,9 @@</span> <span class="p_context"> static dma_cookie_t at_xdmac_tx_submit(struct dma_async_tx_descriptor *tx)</span>
 	struct at_xdmac_desc	*desc = txd_to_at_desc(tx);
 	struct at_xdmac_chan	*atchan = to_at_xdmac_chan(tx-&gt;chan);
 	dma_cookie_t		cookie;
<span class="p_add">+	unsigned long		irqflags;</span>
 
<span class="p_del">-	spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;atchan-&gt;lock, irqflags);</span>
 	cookie = dma_cookie_assign(tx);
 
 	dev_vdbg(chan2dev(tx-&gt;chan), &quot;%s: atchan 0x%p, add desc 0x%p to xfers_list\n&quot;,
<span class="p_chunk">@@ -425,7 +425,7 @@</span> <span class="p_context"> static dma_cookie_t at_xdmac_tx_submit(struct dma_async_tx_descriptor *tx)</span>
 	if (list_is_singular(&amp;atchan-&gt;xfers_list))
 		at_xdmac_start_xfer(atchan, desc);
 
<span class="p_del">-	spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;atchan-&gt;lock, irqflags);</span>
 	return cookie;
 }
 
<span class="p_chunk">@@ -494,61 +494,94 @@</span> <span class="p_context"> static struct dma_chan *at_xdmac_xlate(struct of_phandle_args *dma_spec,</span>
 	return chan;
 }
 
<span class="p_add">+static int at_xdmac_compute_chan_conf(struct dma_chan *chan,</span>
<span class="p_add">+				      enum dma_transfer_direction direction)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct at_xdmac_chan	*atchan = to_at_xdmac_chan(chan);</span>
<span class="p_add">+	int			csize, dwidth;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (direction == DMA_DEV_TO_MEM) {</span>
<span class="p_add">+		atchan-&gt;cfg =</span>
<span class="p_add">+			AT91_XDMAC_DT_PERID(atchan-&gt;perid)</span>
<span class="p_add">+			| AT_XDMAC_CC_DAM_INCREMENTED_AM</span>
<span class="p_add">+			| AT_XDMAC_CC_SAM_FIXED_AM</span>
<span class="p_add">+			| AT_XDMAC_CC_DIF(atchan-&gt;memif)</span>
<span class="p_add">+			| AT_XDMAC_CC_SIF(atchan-&gt;perif)</span>
<span class="p_add">+			| AT_XDMAC_CC_SWREQ_HWR_CONNECTED</span>
<span class="p_add">+			| AT_XDMAC_CC_DSYNC_PER2MEM</span>
<span class="p_add">+			| AT_XDMAC_CC_MBSIZE_SIXTEEN</span>
<span class="p_add">+			| AT_XDMAC_CC_TYPE_PER_TRAN;</span>
<span class="p_add">+		csize = ffs(atchan-&gt;sconfig.src_maxburst) - 1;</span>
<span class="p_add">+		if (csize &lt; 0) {</span>
<span class="p_add">+			dev_err(chan2dev(chan), &quot;invalid src maxburst value\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		atchan-&gt;cfg |= AT_XDMAC_CC_CSIZE(csize);</span>
<span class="p_add">+		dwidth = ffs(atchan-&gt;sconfig.src_addr_width) - 1;</span>
<span class="p_add">+		if (dwidth &lt; 0) {</span>
<span class="p_add">+			dev_err(chan2dev(chan), &quot;invalid src addr width value\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		atchan-&gt;cfg |= AT_XDMAC_CC_DWIDTH(dwidth);</span>
<span class="p_add">+	} else if (direction == DMA_MEM_TO_DEV) {</span>
<span class="p_add">+		atchan-&gt;cfg =</span>
<span class="p_add">+			AT91_XDMAC_DT_PERID(atchan-&gt;perid)</span>
<span class="p_add">+			| AT_XDMAC_CC_DAM_FIXED_AM</span>
<span class="p_add">+			| AT_XDMAC_CC_SAM_INCREMENTED_AM</span>
<span class="p_add">+			| AT_XDMAC_CC_DIF(atchan-&gt;perif)</span>
<span class="p_add">+			| AT_XDMAC_CC_SIF(atchan-&gt;memif)</span>
<span class="p_add">+			| AT_XDMAC_CC_SWREQ_HWR_CONNECTED</span>
<span class="p_add">+			| AT_XDMAC_CC_DSYNC_MEM2PER</span>
<span class="p_add">+			| AT_XDMAC_CC_MBSIZE_SIXTEEN</span>
<span class="p_add">+			| AT_XDMAC_CC_TYPE_PER_TRAN;</span>
<span class="p_add">+		csize = ffs(atchan-&gt;sconfig.dst_maxburst) - 1;</span>
<span class="p_add">+		if (csize &lt; 0) {</span>
<span class="p_add">+			dev_err(chan2dev(chan), &quot;invalid src maxburst value\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		atchan-&gt;cfg |= AT_XDMAC_CC_CSIZE(csize);</span>
<span class="p_add">+		dwidth = ffs(atchan-&gt;sconfig.dst_addr_width) - 1;</span>
<span class="p_add">+		if (dwidth &lt; 0) {</span>
<span class="p_add">+			dev_err(chan2dev(chan), &quot;invalid dst addr width value\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		atchan-&gt;cfg |= AT_XDMAC_CC_DWIDTH(dwidth);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_dbg(chan2dev(chan),	&quot;%s: cfg=0x%08x\n&quot;, __func__, atchan-&gt;cfg);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Only check that maxburst and addr width values are supported by the</span>
<span class="p_add">+ * the controller but not that the configuration is good to perform the</span>
<span class="p_add">+ * transfer since we don&#39;t know the direction at this stage.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int at_xdmac_check_slave_config(struct dma_slave_config *sconfig)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if ((sconfig-&gt;src_maxburst &gt; AT_XDMAC_MAX_CSIZE)</span>
<span class="p_add">+	    || (sconfig-&gt;dst_maxburst &gt; AT_XDMAC_MAX_CSIZE))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((sconfig-&gt;src_addr_width &gt; AT_XDMAC_MAX_DWIDTH)</span>
<span class="p_add">+	    || (sconfig-&gt;dst_addr_width &gt; AT_XDMAC_MAX_DWIDTH))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int at_xdmac_set_slave_config(struct dma_chan *chan,
 				      struct dma_slave_config *sconfig)
 {
 	struct at_xdmac_chan	*atchan = to_at_xdmac_chan(chan);
<span class="p_del">-	u8 dwidth;</span>
<span class="p_del">-	int csize;</span>
 
<span class="p_del">-	atchan-&gt;cfg[AT_XDMAC_DEV_TO_MEM_CFG] =</span>
<span class="p_del">-		AT91_XDMAC_DT_PERID(atchan-&gt;perid)</span>
<span class="p_del">-		| AT_XDMAC_CC_DAM_INCREMENTED_AM</span>
<span class="p_del">-		| AT_XDMAC_CC_SAM_FIXED_AM</span>
<span class="p_del">-		| AT_XDMAC_CC_DIF(atchan-&gt;memif)</span>
<span class="p_del">-		| AT_XDMAC_CC_SIF(atchan-&gt;perif)</span>
<span class="p_del">-		| AT_XDMAC_CC_SWREQ_HWR_CONNECTED</span>
<span class="p_del">-		| AT_XDMAC_CC_DSYNC_PER2MEM</span>
<span class="p_del">-		| AT_XDMAC_CC_MBSIZE_SIXTEEN</span>
<span class="p_del">-		| AT_XDMAC_CC_TYPE_PER_TRAN;</span>
<span class="p_del">-	csize = at_xdmac_csize(sconfig-&gt;src_maxburst);</span>
<span class="p_del">-	if (csize &lt; 0) {</span>
<span class="p_del">-		dev_err(chan2dev(chan), &quot;invalid src maxburst value\n&quot;);</span>
<span class="p_add">+	if (at_xdmac_check_slave_config(sconfig)) {</span>
<span class="p_add">+		dev_err(chan2dev(chan), &quot;invalid slave configuration\n&quot;);</span>
 		return -EINVAL;
 	}
<span class="p_del">-	atchan-&gt;cfg[AT_XDMAC_DEV_TO_MEM_CFG] |= AT_XDMAC_CC_CSIZE(csize);</span>
<span class="p_del">-	dwidth = ffs(sconfig-&gt;src_addr_width) - 1;</span>
<span class="p_del">-	atchan-&gt;cfg[AT_XDMAC_DEV_TO_MEM_CFG] |= AT_XDMAC_CC_DWIDTH(dwidth);</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-	atchan-&gt;cfg[AT_XDMAC_MEM_TO_DEV_CFG] =</span>
<span class="p_del">-		AT91_XDMAC_DT_PERID(atchan-&gt;perid)</span>
<span class="p_del">-		| AT_XDMAC_CC_DAM_FIXED_AM</span>
<span class="p_del">-		| AT_XDMAC_CC_SAM_INCREMENTED_AM</span>
<span class="p_del">-		| AT_XDMAC_CC_DIF(atchan-&gt;perif)</span>
<span class="p_del">-		| AT_XDMAC_CC_SIF(atchan-&gt;memif)</span>
<span class="p_del">-		| AT_XDMAC_CC_SWREQ_HWR_CONNECTED</span>
<span class="p_del">-		| AT_XDMAC_CC_DSYNC_MEM2PER</span>
<span class="p_del">-		| AT_XDMAC_CC_MBSIZE_SIXTEEN</span>
<span class="p_del">-		| AT_XDMAC_CC_TYPE_PER_TRAN;</span>
<span class="p_del">-	csize = at_xdmac_csize(sconfig-&gt;dst_maxburst);</span>
<span class="p_del">-	if (csize &lt; 0) {</span>
<span class="p_del">-		dev_err(chan2dev(chan), &quot;invalid src maxburst value\n&quot;);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	atchan-&gt;cfg[AT_XDMAC_MEM_TO_DEV_CFG] |= AT_XDMAC_CC_CSIZE(csize);</span>
<span class="p_del">-	dwidth = ffs(sconfig-&gt;dst_addr_width) - 1;</span>
<span class="p_del">-	atchan-&gt;cfg[AT_XDMAC_MEM_TO_DEV_CFG] |= AT_XDMAC_CC_DWIDTH(dwidth);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Src and dst addr are needed to configure the link list descriptor. */</span>
<span class="p_del">-	atchan-&gt;per_src_addr = sconfig-&gt;src_addr;</span>
<span class="p_del">-	atchan-&gt;per_dst_addr = sconfig-&gt;dst_addr;</span>
 
<span class="p_del">-	dev_dbg(chan2dev(chan),</span>
<span class="p_del">-		&quot;%s: cfg[dev2mem]=0x%08x, cfg[mem2dev]=0x%08x, per_src_addr=0x%08x, per_dst_addr=0x%08x\n&quot;,</span>
<span class="p_del">-		__func__, atchan-&gt;cfg[AT_XDMAC_DEV_TO_MEM_CFG],</span>
<span class="p_del">-		atchan-&gt;cfg[AT_XDMAC_MEM_TO_DEV_CFG],</span>
<span class="p_del">-		atchan-&gt;per_src_addr, atchan-&gt;per_dst_addr);</span>
<span class="p_add">+	memcpy(&amp;atchan-&gt;sconfig, sconfig, sizeof(atchan-&gt;sconfig));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -563,6 +596,8 @@</span> <span class="p_context"> at_xdmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,</span>
 	struct scatterlist	*sg;
 	int			i;
 	unsigned int		xfer_size = 0;
<span class="p_add">+	unsigned long		irqflags;</span>
<span class="p_add">+	struct dma_async_tx_descriptor	*ret = NULL;</span>
 
 	if (!sgl)
 		return NULL;
<span class="p_chunk">@@ -578,7 +613,10 @@</span> <span class="p_context"> at_xdmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,</span>
 		 flags);
 
 	/* Protect dma_sconfig field that can be modified by set_slave_conf. */
<span class="p_del">-	spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;atchan-&gt;lock, irqflags);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (at_xdmac_compute_chan_conf(chan, direction))</span>
<span class="p_add">+		goto spin_unlock;</span>
 
 	/* Prepare descriptors. */
 	for_each_sg(sgl, sg, sg_len, i) {
<span class="p_chunk">@@ -589,8 +627,7 @@</span> <span class="p_context"> at_xdmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,</span>
 		mem = sg_dma_address(sg);
 		if (unlikely(!len)) {
 			dev_err(chan2dev(chan), &quot;sg data length is zero\n&quot;);
<span class="p_del">-			spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_del">-			return NULL;</span>
<span class="p_add">+			goto spin_unlock;</span>
 		}
 		dev_dbg(chan2dev(chan), &quot;%s: * sg%d len=%u, mem=0x%08x\n&quot;,
 			 __func__, i, len, mem);
<span class="p_chunk">@@ -600,20 +637,18 @@</span> <span class="p_context"> at_xdmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,</span>
 			dev_err(chan2dev(chan), &quot;can&#39;t get descriptor\n&quot;);
 			if (first)
 				list_splice_init(&amp;first-&gt;descs_list, &amp;atchan-&gt;free_descs_list);
<span class="p_del">-			spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_del">-			return NULL;</span>
<span class="p_add">+			goto spin_unlock;</span>
 		}
 
 		/* Linked list descriptor setup. */
 		if (direction == DMA_DEV_TO_MEM) {
<span class="p_del">-			desc-&gt;lld.mbr_sa = atchan-&gt;per_src_addr;</span>
<span class="p_add">+			desc-&gt;lld.mbr_sa = atchan-&gt;sconfig.src_addr;</span>
 			desc-&gt;lld.mbr_da = mem;
<span class="p_del">-			desc-&gt;lld.mbr_cfg = atchan-&gt;cfg[AT_XDMAC_DEV_TO_MEM_CFG];</span>
 		} else {
 			desc-&gt;lld.mbr_sa = mem;
<span class="p_del">-			desc-&gt;lld.mbr_da = atchan-&gt;per_dst_addr;</span>
<span class="p_del">-			desc-&gt;lld.mbr_cfg = atchan-&gt;cfg[AT_XDMAC_MEM_TO_DEV_CFG];</span>
<span class="p_add">+			desc-&gt;lld.mbr_da = atchan-&gt;sconfig.dst_addr;</span>
 		}
<span class="p_add">+		desc-&gt;lld.mbr_cfg = atchan-&gt;cfg;</span>
 		dwidth = at_xdmac_get_dwidth(desc-&gt;lld.mbr_cfg);
 		fixed_dwidth = IS_ALIGNED(len, 1 &lt;&lt; dwidth)
 			       ? at_xdmac_get_dwidth(desc-&gt;lld.mbr_cfg)
<span class="p_chunk">@@ -645,13 +680,15 @@</span> <span class="p_context"> at_xdmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,</span>
 		xfer_size += len;
 	}
 
<span class="p_del">-	spin_unlock_bh(&amp;atchan-&gt;lock);</span>
 
 	first-&gt;tx_dma_desc.flags = flags;
 	first-&gt;xfer_size = xfer_size;
 	first-&gt;direction = direction;
<span class="p_add">+	ret = &amp;first-&gt;tx_dma_desc;</span>
 
<span class="p_del">-	return &amp;first-&gt;tx_dma_desc;</span>
<span class="p_add">+spin_unlock:</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;atchan-&gt;lock, irqflags);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static struct dma_async_tx_descriptor *
<span class="p_chunk">@@ -664,6 +701,7 @@</span> <span class="p_context"> at_xdmac_prep_dma_cyclic(struct dma_chan *chan, dma_addr_t buf_addr,</span>
 	struct at_xdmac_desc	*first = NULL, *prev = NULL;
 	unsigned int		periods = buf_len / period_len;
 	int			i;
<span class="p_add">+	unsigned long		irqflags;</span>
 
 	dev_dbg(chan2dev(chan), &quot;%s: buf_addr=%pad, buf_len=%zd, period_len=%zd, dir=%s, flags=0x%lx\n&quot;,
 		__func__, &amp;buf_addr, buf_len, period_len,
<span class="p_chunk">@@ -679,32 +717,34 @@</span> <span class="p_context"> at_xdmac_prep_dma_cyclic(struct dma_chan *chan, dma_addr_t buf_addr,</span>
 		return NULL;
 	}
 
<span class="p_add">+	if (at_xdmac_compute_chan_conf(chan, direction))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; periods; i++) {
 		struct at_xdmac_desc	*desc = NULL;
 
<span class="p_del">-		spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;atchan-&gt;lock, irqflags);</span>
 		desc = at_xdmac_get_desc(atchan);
 		if (!desc) {
 			dev_err(chan2dev(chan), &quot;can&#39;t get descriptor\n&quot;);
 			if (first)
 				list_splice_init(&amp;first-&gt;descs_list, &amp;atchan-&gt;free_descs_list);
<span class="p_del">-			spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+			spin_unlock_irqrestore(&amp;atchan-&gt;lock, irqflags);</span>
 			return NULL;
 		}
<span class="p_del">-		spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;atchan-&gt;lock, irqflags);</span>
 		dev_dbg(chan2dev(chan),
 			&quot;%s: desc=0x%p, tx_dma_desc.phys=%pad\n&quot;,
 			__func__, desc, &amp;desc-&gt;tx_dma_desc.phys);
 
 		if (direction == DMA_DEV_TO_MEM) {
<span class="p_del">-			desc-&gt;lld.mbr_sa = atchan-&gt;per_src_addr;</span>
<span class="p_add">+			desc-&gt;lld.mbr_sa = atchan-&gt;sconfig.src_addr;</span>
 			desc-&gt;lld.mbr_da = buf_addr + i * period_len;
<span class="p_del">-			desc-&gt;lld.mbr_cfg = atchan-&gt;cfg[AT_XDMAC_DEV_TO_MEM_CFG];</span>
 		} else {
 			desc-&gt;lld.mbr_sa = buf_addr + i * period_len;
<span class="p_del">-			desc-&gt;lld.mbr_da = atchan-&gt;per_dst_addr;</span>
<span class="p_del">-			desc-&gt;lld.mbr_cfg = atchan-&gt;cfg[AT_XDMAC_MEM_TO_DEV_CFG];</span>
<span class="p_add">+			desc-&gt;lld.mbr_da = atchan-&gt;sconfig.dst_addr;</span>
 		}
<span class="p_add">+		desc-&gt;lld.mbr_cfg = atchan-&gt;cfg;</span>
 		desc-&gt;lld.mbr_ubc = AT_XDMAC_MBR_UBC_NDV1
 			| AT_XDMAC_MBR_UBC_NDEN
 			| AT_XDMAC_MBR_UBC_NSEN
<span class="p_chunk">@@ -766,6 +806,7 @@</span> <span class="p_context"> at_xdmac_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,</span>
 					| AT_XDMAC_CC_SIF(0)
 					| AT_XDMAC_CC_MBSIZE_SIXTEEN
 					| AT_XDMAC_CC_TYPE_MEM_TRAN;
<span class="p_add">+	unsigned long		irqflags;</span>
 
 	dev_dbg(chan2dev(chan), &quot;%s: src=%pad, dest=%pad, len=%zd, flags=0x%lx\n&quot;,
 		__func__, &amp;src, &amp;dest, len, flags);
<span class="p_chunk">@@ -798,9 +839,9 @@</span> <span class="p_context"> at_xdmac_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,</span>
 
 		dev_dbg(chan2dev(chan), &quot;%s: remaining_size=%zu\n&quot;, __func__, remaining_size);
 
<span class="p_del">-		spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;atchan-&gt;lock, irqflags);</span>
 		desc = at_xdmac_get_desc(atchan);
<span class="p_del">-		spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;atchan-&gt;lock, irqflags);</span>
 		if (!desc) {
 			dev_err(chan2dev(chan), &quot;can&#39;t get descriptor\n&quot;);
 			if (first)
<span class="p_chunk">@@ -886,6 +927,7 @@</span> <span class="p_context"> at_xdmac_tx_status(struct dma_chan *chan, dma_cookie_t cookie,</span>
 	int			residue;
 	u32			cur_nda, mask, value;
 	u8			dwidth = 0;
<span class="p_add">+	unsigned long		flags;</span>
 
 	ret = dma_cookie_status(chan, cookie, txstate);
 	if (ret == DMA_COMPLETE)
<span class="p_chunk">@@ -894,7 +936,7 @@</span> <span class="p_context"> at_xdmac_tx_status(struct dma_chan *chan, dma_cookie_t cookie,</span>
 	if (!txstate)
 		return ret;
 
<span class="p_del">-	spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;atchan-&gt;lock, flags);</span>
 
 	desc = list_first_entry(&amp;atchan-&gt;xfers_list, struct at_xdmac_desc, xfer_node);
 
<span class="p_chunk">@@ -904,8 +946,7 @@</span> <span class="p_context"> at_xdmac_tx_status(struct dma_chan *chan, dma_cookie_t cookie,</span>
 	 */
 	if (!desc-&gt;active_xfer) {
 		dma_set_residue(txstate, desc-&gt;xfer_size);
<span class="p_del">-		spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto spin_unlock;</span>
 	}
 
 	residue = desc-&gt;xfer_size;
<span class="p_chunk">@@ -936,14 +977,14 @@</span> <span class="p_context"> at_xdmac_tx_status(struct dma_chan *chan, dma_cookie_t cookie,</span>
 	}
 	residue += at_xdmac_chan_read(atchan, AT_XDMAC_CUBC) &lt;&lt; dwidth;
 
<span class="p_del">-	spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_del">-</span>
 	dma_set_residue(txstate, residue);
 
 	dev_dbg(chan2dev(chan),
 		 &quot;%s: desc=0x%p, tx_dma_desc.phys=%pad, tx_status=%d, cookie=%d, residue=%d\n&quot;,
 		 __func__, desc, &amp;desc-&gt;tx_dma_desc.phys, ret, cookie, residue);
 
<span class="p_add">+spin_unlock:</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;atchan-&gt;lock, flags);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -964,8 +1005,9 @@</span> <span class="p_context"> static void at_xdmac_remove_xfer(struct at_xdmac_chan *atchan,</span>
 static void at_xdmac_advance_work(struct at_xdmac_chan *atchan)
 {
 	struct at_xdmac_desc	*desc;
<span class="p_add">+	unsigned long		flags;</span>
 
<span class="p_del">-	spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;atchan-&gt;lock, flags);</span>
 
 	/*
 	 * If channel is enabled, do nothing, advance_work will be triggered
<span class="p_chunk">@@ -980,7 +1022,7 @@</span> <span class="p_context"> static void at_xdmac_advance_work(struct at_xdmac_chan *atchan)</span>
 			at_xdmac_start_xfer(atchan, desc);
 	}
 
<span class="p_del">-	spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;atchan-&gt;lock, flags);</span>
 }
 
 static void at_xdmac_handle_cyclic(struct at_xdmac_chan *atchan)
<span class="p_chunk">@@ -1116,12 +1158,13 @@</span> <span class="p_context"> static int at_xdmac_device_config(struct dma_chan *chan,</span>
 {
 	struct at_xdmac_chan	*atchan = to_at_xdmac_chan(chan);
 	int ret;
<span class="p_add">+	unsigned long		flags;</span>
 
 	dev_dbg(chan2dev(chan), &quot;%s\n&quot;, __func__);
 
<span class="p_del">-	spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;atchan-&gt;lock, flags);</span>
 	ret = at_xdmac_set_slave_config(chan, config);
<span class="p_del">-	spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;atchan-&gt;lock, flags);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1130,18 +1173,19 @@</span> <span class="p_context"> static int at_xdmac_device_pause(struct dma_chan *chan)</span>
 {
 	struct at_xdmac_chan	*atchan = to_at_xdmac_chan(chan);
 	struct at_xdmac		*atxdmac = to_at_xdmac(atchan-&gt;chan.device);
<span class="p_add">+	unsigned long		flags;</span>
 
 	dev_dbg(chan2dev(chan), &quot;%s\n&quot;, __func__);
 
 	if (test_and_set_bit(AT_XDMAC_CHAN_IS_PAUSED, &amp;atchan-&gt;status))
 		return 0;
 
<span class="p_del">-	spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;atchan-&gt;lock, flags);</span>
 	at_xdmac_write(atxdmac, AT_XDMAC_GRWS, atchan-&gt;mask);
 	while (at_xdmac_chan_read(atchan, AT_XDMAC_CC)
 	       &amp; (AT_XDMAC_CC_WRIP | AT_XDMAC_CC_RDIP))
 		cpu_relax();
<span class="p_del">-	spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;atchan-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1150,16 +1194,19 @@</span> <span class="p_context"> static int at_xdmac_device_resume(struct dma_chan *chan)</span>
 {
 	struct at_xdmac_chan	*atchan = to_at_xdmac_chan(chan);
 	struct at_xdmac		*atxdmac = to_at_xdmac(atchan-&gt;chan.device);
<span class="p_add">+	unsigned long		flags;</span>
 
 	dev_dbg(chan2dev(chan), &quot;%s\n&quot;, __func__);
 
<span class="p_del">-	spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_del">-	if (!at_xdmac_chan_is_paused(atchan))</span>
<span class="p_add">+	spin_lock_irqsave(&amp;atchan-&gt;lock, flags);</span>
<span class="p_add">+	if (!at_xdmac_chan_is_paused(atchan)) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;atchan-&gt;lock, flags);</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	at_xdmac_write(atxdmac, AT_XDMAC_GRWR, atchan-&gt;mask);
 	clear_bit(AT_XDMAC_CHAN_IS_PAUSED, &amp;atchan-&gt;status);
<span class="p_del">-	spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;atchan-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1169,10 +1216,11 @@</span> <span class="p_context"> static int at_xdmac_device_terminate_all(struct dma_chan *chan)</span>
 	struct at_xdmac_desc	*desc, *_desc;
 	struct at_xdmac_chan	*atchan = to_at_xdmac_chan(chan);
 	struct at_xdmac		*atxdmac = to_at_xdmac(atchan-&gt;chan.device);
<span class="p_add">+	unsigned long		flags;</span>
 
 	dev_dbg(chan2dev(chan), &quot;%s\n&quot;, __func__);
 
<span class="p_del">-	spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;atchan-&gt;lock, flags);</span>
 	at_xdmac_write(atxdmac, AT_XDMAC_GD, atchan-&gt;mask);
 	while (at_xdmac_read(atxdmac, AT_XDMAC_GS) &amp; atchan-&gt;mask)
 		cpu_relax();
<span class="p_chunk">@@ -1182,7 +1230,7 @@</span> <span class="p_context"> static int at_xdmac_device_terminate_all(struct dma_chan *chan)</span>
 		at_xdmac_remove_xfer(atchan, desc);
 
 	clear_bit(AT_XDMAC_CHAN_IS_CYCLIC, &amp;atchan-&gt;status);
<span class="p_del">-	spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;atchan-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1192,8 +1240,9 @@</span> <span class="p_context"> static int at_xdmac_alloc_chan_resources(struct dma_chan *chan)</span>
 	struct at_xdmac_chan	*atchan = to_at_xdmac_chan(chan);
 	struct at_xdmac_desc	*desc;
 	int			i;
<span class="p_add">+	unsigned long		flags;</span>
 
<span class="p_del">-	spin_lock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;atchan-&gt;lock, flags);</span>
 
 	if (at_xdmac_chan_is_enabled(atchan)) {
 		dev_err(chan2dev(chan),
<span class="p_chunk">@@ -1224,7 +1273,7 @@</span> <span class="p_context"> static int at_xdmac_alloc_chan_resources(struct dma_chan *chan)</span>
 	dev_dbg(chan2dev(chan), &quot;%s: allocated %d descriptors\n&quot;, __func__, i);
 
 spin_unlock:
<span class="p_del">-	spin_unlock_bh(&amp;atchan-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;atchan-&gt;lock, flags);</span>
 	return i;
 }
 
<span class="p_header">diff --git a/drivers/dma/dmaengine.c b/drivers/dma/dmaengine.c</span>
<span class="p_header">index ac336a961dea..8e70e580c98a 100644</span>
<span class="p_header">--- a/drivers/dma/dmaengine.c</span>
<span class="p_header">+++ b/drivers/dma/dmaengine.c</span>
<span class="p_chunk">@@ -505,7 +505,11 @@</span> <span class="p_context"> int dma_get_slave_caps(struct dma_chan *chan, struct dma_slave_caps *caps)</span>
 	caps-&gt;directions = device-&gt;directions;
 	caps-&gt;residue_granularity = device-&gt;residue_granularity;
 
<span class="p_del">-	caps-&gt;cmd_pause = !!device-&gt;device_pause;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some devices implement only pause (e.g. to get residuum) but no</span>
<span class="p_add">+	 * resume. However cmd_pause is advertised as pause AND resume.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	caps-&gt;cmd_pause = !!(device-&gt;device_pause &amp;&amp; device-&gt;device_resume);</span>
 	caps-&gt;cmd_terminate = !!device-&gt;device_terminate_all;
 
 	return 0;
<span class="p_header">diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.c</span>
<span class="p_header">index 0e1f56772855..a2771a8d4377 100644</span>
<span class="p_header">--- a/drivers/dma/pl330.c</span>
<span class="p_header">+++ b/drivers/dma/pl330.c</span>
<span class="p_chunk">@@ -2127,6 +2127,7 @@</span> <span class="p_context"> static int pl330_terminate_all(struct dma_chan *chan)</span>
 	struct pl330_dmac *pl330 = pch-&gt;dmac;
 	LIST_HEAD(list);
 
<span class="p_add">+	pm_runtime_get_sync(pl330-&gt;ddma.dev);</span>
 	spin_lock_irqsave(&amp;pch-&gt;lock, flags);
 	spin_lock(&amp;pl330-&gt;lock);
 	_stop(pch-&gt;thread);
<span class="p_chunk">@@ -2151,6 +2152,8 @@</span> <span class="p_context"> static int pl330_terminate_all(struct dma_chan *chan)</span>
 	list_splice_tail_init(&amp;pch-&gt;work_list, &amp;pl330-&gt;desc_pool);
 	list_splice_tail_init(&amp;pch-&gt;completed_list, &amp;pl330-&gt;desc_pool);
 	spin_unlock_irqrestore(&amp;pch-&gt;lock, flags);
<span class="p_add">+	pm_runtime_mark_last_busy(pl330-&gt;ddma.dev);</span>
<span class="p_add">+	pm_runtime_put_autosuspend(pl330-&gt;ddma.dev);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_topology.c b/drivers/gpu/drm/amd/amdkfd/kfd_topology.c</span>
<span class="p_header">index 406624a0b201..340e21918f33 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdkfd/kfd_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdkfd/kfd_topology.c</span>
<span class="p_chunk">@@ -684,8 +684,6 @@</span> <span class="p_context"> static ssize_t node_show(struct kobject *kobj, struct attribute *attr,</span>
 			dev-&gt;node_props.cpu_core_id_base);
 	sysfs_show_32bit_prop(buffer, &quot;simd_id_base&quot;,
 			dev-&gt;node_props.simd_id_base);
<span class="p_del">-	sysfs_show_32bit_prop(buffer, &quot;capability&quot;,</span>
<span class="p_del">-			dev-&gt;node_props.capability);</span>
 	sysfs_show_32bit_prop(buffer, &quot;max_waves_per_simd&quot;,
 			dev-&gt;node_props.max_waves_per_simd);
 	sysfs_show_32bit_prop(buffer, &quot;lds_size_in_kb&quot;,
<span class="p_chunk">@@ -735,6 +733,8 @@</span> <span class="p_context"> static ssize_t node_show(struct kobject *kobj, struct attribute *attr,</span>
 				kfd2kgd-&gt;get_fw_version(
 						dev-&gt;gpu-&gt;kgd,
 						KGD_ENGINE_MEC1));
<span class="p_add">+		sysfs_show_32bit_prop(buffer, &quot;capability&quot;,</span>
<span class="p_add">+				dev-&gt;node_props.capability);</span>
 	}
 
 	return sysfs_show_32bit_prop(buffer, &quot;max_engine_clk_ccompute&quot;,
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">index 27ea6bdebce7..7a628e4cb27a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_chunk">@@ -2732,9 +2732,6 @@</span> <span class="p_context"> void i915_gem_reset(struct drm_device *dev)</span>
 void
 i915_gem_retire_requests_ring(struct intel_engine_cs *ring)
 {
<span class="p_del">-	if (list_empty(&amp;ring-&gt;request_list))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	WARN_ON(i915_verify_lists(ring-&gt;dev));
 
 	/* Retire requests first as we use it above for the early return.
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index 88b36a9173c9..336e8b63ca08 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -881,10 +881,8 @@</span> <span class="p_context"> intel_dp_aux_ch(struct intel_dp *intel_dp,</span>
 				      DP_AUX_CH_CTL_RECEIVE_ERROR))
 				continue;
 			if (status &amp; DP_AUX_CH_CTL_DONE)
<span class="p_del">-				break;</span>
<span class="p_add">+				goto done;</span>
 		}
<span class="p_del">-		if (status &amp; DP_AUX_CH_CTL_DONE)</span>
<span class="p_del">-			break;</span>
 	}
 
 	if ((status &amp; DP_AUX_CH_CTL_DONE) == 0) {
<span class="p_chunk">@@ -893,6 +891,7 @@</span> <span class="p_context"> intel_dp_aux_ch(struct intel_dp *intel_dp,</span>
 		goto out;
 	}
 
<span class="p_add">+done:</span>
 	/* Check for timeout or receive error.
 	 * Timeouts occur when the sink is not connected
 	 */
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">index 56e437e31580..ae628001fd97 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_chunk">@@ -435,7 +435,7 @@</span> <span class="p_context"> gmbus_xfer(struct i2c_adapter *adapter,</span>
 					       struct intel_gmbus,
 					       adapter);
 	struct drm_i915_private *dev_priv = bus-&gt;dev_priv;
<span class="p_del">-	int i, reg_offset;</span>
<span class="p_add">+	int i = 0, inc, try = 0, reg_offset;</span>
 	int ret = 0;
 
 	intel_aux_display_runtime_get(dev_priv);
<span class="p_chunk">@@ -448,12 +448,14 @@</span> <span class="p_context"> gmbus_xfer(struct i2c_adapter *adapter,</span>
 
 	reg_offset = dev_priv-&gt;gpio_mmio_base;
 
<span class="p_add">+retry:</span>
 	I915_WRITE(GMBUS0 + reg_offset, bus-&gt;reg0);
 
<span class="p_del">-	for (i = 0; i &lt; num; i++) {</span>
<span class="p_add">+	for (; i &lt; num; i += inc) {</span>
<span class="p_add">+		inc = 1;</span>
 		if (gmbus_is_index_read(msgs, i, num)) {
 			ret = gmbus_xfer_index_read(dev_priv, &amp;msgs[i]);
<span class="p_del">-			i += 1;  /* set i to the index of the read xfer */</span>
<span class="p_add">+			inc = 2; /* an index read is two msgs */</span>
 		} else if (msgs[i].flags &amp; I2C_M_RD) {
 			ret = gmbus_xfer_read(dev_priv, &amp;msgs[i], 0);
 		} else {
<span class="p_chunk">@@ -525,6 +527,18 @@</span> <span class="p_context"> clear_err:</span>
 			 adapter-&gt;name, msgs[i].addr,
 			 (msgs[i].flags &amp; I2C_M_RD) ? &#39;r&#39; : &#39;w&#39;, msgs[i].len);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Passive adapters sometimes NAK the first probe. Retry the first</span>
<span class="p_add">+	 * message once on -ENXIO for GMBUS transfers; the bit banging algorithm</span>
<span class="p_add">+	 * has retries internally. See also the retry loop in</span>
<span class="p_add">+	 * drm_do_probe_ddc_edid, which bails out on the first -ENXIO.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ret == -ENXIO &amp;&amp; i == 0 &amp;&amp; try++ == 0) {</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;GMBUS [%s] NAK on first message, retry\n&quot;,</span>
<span class="p_add">+			      adapter-&gt;name);</span>
<span class="p_add">+		goto retry;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	goto out;
 
 timeout:
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 965a45619f6b..9bd56116fd5a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -580,9 +580,6 @@</span> <span class="p_context"> static u32 atombios_adjust_pll(struct drm_crtc *crtc,</span>
 		else
 			radeon_crtc-&gt;pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
 
<span class="p_del">-		/* if there is no audio, set MINM_OVER_MAXP  */</span>
<span class="p_del">-		if (!drm_detect_monitor_audio(radeon_connector_edid(connector)))</span>
<span class="p_del">-			radeon_crtc-&gt;pll_flags |= RADEON_PLL_PREFER_MINM_OVER_MAXP;</span>
 		if (rdev-&gt;family &lt; CHIP_RV770)
 			radeon_crtc-&gt;pll_flags |= RADEON_PLL_PREFER_MINM_OVER_MAXP;
 		/* use frac fb div on APUs */
<span class="p_chunk">@@ -1789,9 +1786,7 @@</span> <span class="p_context"> static int radeon_get_shared_nondp_ppll(struct drm_crtc *crtc)</span>
 			if ((crtc-&gt;mode.clock == test_crtc-&gt;mode.clock) &amp;&amp;
 			    (adjusted_clock == test_adjusted_clock) &amp;&amp;
 			    (radeon_crtc-&gt;ss_enabled == test_radeon_crtc-&gt;ss_enabled) &amp;&amp;
<span class="p_del">-			    (test_radeon_crtc-&gt;pll_id != ATOM_PPLL_INVALID) &amp;&amp;</span>
<span class="p_del">-			    (drm_detect_monitor_audio(radeon_connector_edid(test_radeon_crtc-&gt;connector)) ==</span>
<span class="p_del">-			     drm_detect_monitor_audio(radeon_connector_edid(radeon_crtc-&gt;connector))))</span>
<span class="p_add">+			    (test_radeon_crtc-&gt;pll_id != ATOM_PPLL_INVALID))</span>
 				return test_radeon_crtc-&gt;pll_id;
 		}
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/dce3_1_afmt.c b/drivers/gpu/drm/radeon/dce3_1_afmt.c</span>
<span class="p_header">index f04205170b8a..cfa3a84a2af0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/dce3_1_afmt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/dce3_1_afmt.c</span>
<span class="p_chunk">@@ -173,7 +173,7 @@</span> <span class="p_context"> void dce3_2_hdmi_update_acr(struct drm_encoder *encoder, long offset,</span>
 	struct drm_device *dev = encoder-&gt;dev;
 	struct radeon_device *rdev = dev-&gt;dev_private;
 
<span class="p_del">-	WREG32(HDMI0_ACR_PACKET_CONTROL + offset,</span>
<span class="p_add">+	WREG32(DCE3_HDMI0_ACR_PACKET_CONTROL + offset,</span>
 		HDMI0_ACR_SOURCE |		/* select SW CTS value */
 		HDMI0_ACR_AUTO_SEND);	/* allow hw to sent ACR packets when required */
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index bd7519fdd3f4..aa232fd25992 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -1458,6 +1458,21 @@</span> <span class="p_context"> int radeon_device_init(struct radeon_device *rdev,</span>
 	if (r)
 		DRM_ERROR(&quot;ib ring test failed (%d).\n&quot;, r);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Turks/Thames GPU will freeze whole laptop if DPM is not restarted</span>
<span class="p_add">+	 * after the CP ring have chew one packet at least. Hence here we stop</span>
<span class="p_add">+	 * and restart DPM after the radeon_ib_ring_tests().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rdev-&gt;pm.dpm_enabled &amp;&amp;</span>
<span class="p_add">+	    (rdev-&gt;pm.pm_method == PM_METHOD_DPM) &amp;&amp;</span>
<span class="p_add">+	    (rdev-&gt;family == CHIP_TURKS) &amp;&amp;</span>
<span class="p_add">+	    (rdev-&gt;flags &amp; RADEON_IS_MOBILITY)) {</span>
<span class="p_add">+		mutex_lock(&amp;rdev-&gt;pm.mutex);</span>
<span class="p_add">+		radeon_dpm_disable(rdev);</span>
<span class="p_add">+		radeon_dpm_enable(rdev);</span>
<span class="p_add">+		mutex_unlock(&amp;rdev-&gt;pm.mutex);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if ((radeon_testing &amp; 1)) {
 		if (rdev-&gt;accel_working)
 			radeon_test_moves(rdev);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_vm.c b/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_header">index de42fc4a22b8..9c3377ca17b7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_chunk">@@ -458,14 +458,16 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 		/* make sure object fit at this offset */
 		eoffset = soffset + size;
 		if (soffset &gt;= eoffset) {
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto error_unreserve;</span>
 		}
 
 		last_pfn = eoffset / RADEON_GPU_PAGE_SIZE;
 		if (last_pfn &gt; rdev-&gt;vm_manager.max_pfn) {
 			dev_err(rdev-&gt;dev, &quot;va above limit (0x%08X &gt; 0x%08X)\n&quot;,
 				last_pfn, rdev-&gt;vm_manager.max_pfn);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto error_unreserve;</span>
 		}
 
 	} else {
<span class="p_chunk">@@ -486,7 +488,8 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 				&quot;(bo %p 0x%010lx 0x%010lx)\n&quot;, bo_va-&gt;bo,
 				soffset, tmp-&gt;bo, tmp-&gt;it.start, tmp-&gt;it.last);
 			mutex_unlock(&amp;vm-&gt;mutex);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto error_unreserve;</span>
 		}
 	}
 
<span class="p_chunk">@@ -497,7 +500,8 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 			tmp = kzalloc(sizeof(struct radeon_bo_va), GFP_KERNEL);
 			if (!tmp) {
 				mutex_unlock(&amp;vm-&gt;mutex);
<span class="p_del">-				return -ENOMEM;</span>
<span class="p_add">+				r = -ENOMEM;</span>
<span class="p_add">+				goto error_unreserve;</span>
 			}
 			tmp-&gt;it.start = bo_va-&gt;it.start;
 			tmp-&gt;it.last = bo_va-&gt;it.last;
<span class="p_chunk">@@ -555,7 +559,6 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 		r = radeon_vm_clear_bo(rdev, pt);
 		if (r) {
 			radeon_bo_unref(&amp;pt);
<span class="p_del">-			radeon_bo_reserve(bo_va-&gt;bo, false);</span>
 			return r;
 		}
 
<span class="p_chunk">@@ -575,6 +578,10 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 
 	mutex_unlock(&amp;vm-&gt;mutex);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+error_unreserve:</span>
<span class="p_add">+	radeon_bo_unreserve(bo_va-&gt;bo);</span>
<span class="p_add">+	return r;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-hix5hd2.c b/drivers/i2c/busses/i2c-hix5hd2.c</span>
<span class="p_header">index 8fe78d08e01c..7c6966434ee7 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-hix5hd2.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-hix5hd2.c</span>
<span class="p_chunk">@@ -554,4 +554,4 @@</span> <span class="p_context"> module_platform_driver(hix5hd2_i2c_driver);</span>
 MODULE_DESCRIPTION(&quot;Hix5hd2 I2C Bus driver&quot;);
 MODULE_AUTHOR(&quot;Wei Yan &lt;sledge.yanwei@huawei.com&gt;&quot;);
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_del">-MODULE_ALIAS(&quot;platform:i2c-hix5hd2&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;platform:hix5hd2-i2c&quot;);</span>
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-s3c2410.c b/drivers/i2c/busses/i2c-s3c2410.c</span>
<span class="p_header">index 958c8db4ec30..297e9c9ac943 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-s3c2410.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-s3c2410.c</span>
<span class="p_chunk">@@ -1143,6 +1143,7 @@</span> <span class="p_context"> static int s3c24xx_i2c_probe(struct platform_device *pdev)</span>
 		return -ENOMEM;
 
 	i2c-&gt;quirks = s3c24xx_get_device_quirks(pdev);
<span class="p_add">+	i2c-&gt;sysreg = ERR_PTR(-ENOENT);</span>
 	if (pdata)
 		memcpy(i2c-&gt;pdata, pdata, sizeof(*pdata));
 	else
<span class="p_header">diff --git a/drivers/iio/adc/twl6030-gpadc.c b/drivers/iio/adc/twl6030-gpadc.c</span>
<span class="p_header">index 89d8aa1d2818..df12c57e6ce0 100644</span>
<span class="p_header">--- a/drivers/iio/adc/twl6030-gpadc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/twl6030-gpadc.c</span>
<span class="p_chunk">@@ -1001,7 +1001,7 @@</span> <span class="p_context"> static struct platform_driver twl6030_gpadc_driver = {</span>
 
 module_platform_driver(twl6030_gpadc_driver);
 
<span class="p_del">-MODULE_ALIAS(&quot;platform: &quot; DRIVER_NAME);</span>
<span class="p_add">+MODULE_ALIAS(&quot;platform:&quot; DRIVER_NAME);</span>
 MODULE_AUTHOR(&quot;Balaji T K &lt;balajitk@ti.com&gt;&quot;);
 MODULE_AUTHOR(&quot;Graeme Gregory &lt;gg@slimlogic.co.uk&gt;&quot;);
 MODULE_AUTHOR(&quot;Oleksandr Kozaruk &lt;oleksandr.kozaruk@ti.com&quot;);
<span class="p_header">diff --git a/drivers/iio/imu/adis16400.h b/drivers/iio/imu/adis16400.h</span>
<span class="p_header">index 0916bf6b6c31..73b189c1c0fb 100644</span>
<span class="p_header">--- a/drivers/iio/imu/adis16400.h</span>
<span class="p_header">+++ b/drivers/iio/imu/adis16400.h</span>
<span class="p_chunk">@@ -139,6 +139,7 @@</span> <span class="p_context"></span>
 #define ADIS16400_NO_BURST		BIT(1)
 #define ADIS16400_HAS_SLOW_MODE		BIT(2)
 #define ADIS16400_HAS_SERIAL_NUMBER	BIT(3)
<span class="p_add">+#define ADIS16400_BURST_DIAG_STAT	BIT(4)</span>
 
 struct adis16400_state;
 
<span class="p_chunk">@@ -165,6 +166,7 @@</span> <span class="p_context"> struct adis16400_state {</span>
 	int				filt_int;
 
 	struct adis adis;
<span class="p_add">+	unsigned long avail_scan_mask[2];</span>
 };
 
 /* At the moment triggers are only used for ring buffer
<span class="p_header">diff --git a/drivers/iio/imu/adis16400_buffer.c b/drivers/iio/imu/adis16400_buffer.c</span>
<span class="p_header">index 6e727ffe5262..90c24a23c679 100644</span>
<span class="p_header">--- a/drivers/iio/imu/adis16400_buffer.c</span>
<span class="p_header">+++ b/drivers/iio/imu/adis16400_buffer.c</span>
<span class="p_chunk">@@ -18,7 +18,8 @@</span> <span class="p_context"> int adis16400_update_scan_mode(struct iio_dev *indio_dev,</span>
 {
 	struct adis16400_state *st = iio_priv(indio_dev);
 	struct adis *adis = &amp;st-&gt;adis;
<span class="p_del">-	uint16_t *tx;</span>
<span class="p_add">+	unsigned int burst_length;</span>
<span class="p_add">+	u8 *tx;</span>
 
 	if (st-&gt;variant-&gt;flags &amp; ADIS16400_NO_BURST)
 		return adis_update_scan_mode(indio_dev, scan_mask);
<span class="p_chunk">@@ -26,26 +27,29 @@</span> <span class="p_context"> int adis16400_update_scan_mode(struct iio_dev *indio_dev,</span>
 	kfree(adis-&gt;xfer);
 	kfree(adis-&gt;buffer);
 
<span class="p_add">+	/* All but the timestamp channel */</span>
<span class="p_add">+	burst_length = (indio_dev-&gt;num_channels - 1) * sizeof(u16);</span>
<span class="p_add">+	if (st-&gt;variant-&gt;flags &amp; ADIS16400_BURST_DIAG_STAT)</span>
<span class="p_add">+		burst_length += sizeof(u16);</span>
<span class="p_add">+</span>
 	adis-&gt;xfer = kcalloc(2, sizeof(*adis-&gt;xfer), GFP_KERNEL);
 	if (!adis-&gt;xfer)
 		return -ENOMEM;
 
<span class="p_del">-	adis-&gt;buffer = kzalloc(indio_dev-&gt;scan_bytes + sizeof(u16),</span>
<span class="p_del">-		GFP_KERNEL);</span>
<span class="p_add">+	adis-&gt;buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);</span>
 	if (!adis-&gt;buffer)
 		return -ENOMEM;
 
<span class="p_del">-	tx = adis-&gt;buffer + indio_dev-&gt;scan_bytes;</span>
<span class="p_del">-</span>
<span class="p_add">+	tx = adis-&gt;buffer + burst_length;</span>
 	tx[0] = ADIS_READ_REG(ADIS16400_GLOB_CMD);
 	tx[1] = 0;
 
 	adis-&gt;xfer[0].tx_buf = tx;
 	adis-&gt;xfer[0].bits_per_word = 8;
 	adis-&gt;xfer[0].len = 2;
<span class="p_del">-	adis-&gt;xfer[1].tx_buf = tx;</span>
<span class="p_add">+	adis-&gt;xfer[1].rx_buf = adis-&gt;buffer;</span>
 	adis-&gt;xfer[1].bits_per_word = 8;
<span class="p_del">-	adis-&gt;xfer[1].len = indio_dev-&gt;scan_bytes;</span>
<span class="p_add">+	adis-&gt;xfer[1].len = burst_length;</span>
 
 	spi_message_init(&amp;adis-&gt;msg);
 	spi_message_add_tail(&amp;adis-&gt;xfer[0], &amp;adis-&gt;msg);
<span class="p_chunk">@@ -61,6 +65,7 @@</span> <span class="p_context"> irqreturn_t adis16400_trigger_handler(int irq, void *p)</span>
 	struct adis16400_state *st = iio_priv(indio_dev);
 	struct adis *adis = &amp;st-&gt;adis;
 	u32 old_speed_hz = st-&gt;adis.spi-&gt;max_speed_hz;
<span class="p_add">+	void *buffer;</span>
 	int ret;
 
 	if (!adis-&gt;buffer)
<span class="p_chunk">@@ -81,7 +86,12 @@</span> <span class="p_context"> irqreturn_t adis16400_trigger_handler(int irq, void *p)</span>
 		spi_setup(st-&gt;adis.spi);
 	}
 
<span class="p_del">-	iio_push_to_buffers_with_timestamp(indio_dev, adis-&gt;buffer,</span>
<span class="p_add">+	if (st-&gt;variant-&gt;flags &amp; ADIS16400_BURST_DIAG_STAT)</span>
<span class="p_add">+		buffer = adis-&gt;buffer + sizeof(u16);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		buffer = adis-&gt;buffer;</span>
<span class="p_add">+</span>
<span class="p_add">+	iio_push_to_buffers_with_timestamp(indio_dev, buffer,</span>
 		pf-&gt;timestamp);
 
 	iio_trigger_notify_done(indio_dev-&gt;trig);
<span class="p_header">diff --git a/drivers/iio/imu/adis16400_core.c b/drivers/iio/imu/adis16400_core.c</span>
<span class="p_header">index fa795dcd5f75..2fd68f2219a7 100644</span>
<span class="p_header">--- a/drivers/iio/imu/adis16400_core.c</span>
<span class="p_header">+++ b/drivers/iio/imu/adis16400_core.c</span>
<span class="p_chunk">@@ -405,6 +405,11 @@</span> <span class="p_context"> static int adis16400_read_raw(struct iio_dev *indio_dev,</span>
 			*val = st-&gt;variant-&gt;temp_scale_nano / 1000000;
 			*val2 = (st-&gt;variant-&gt;temp_scale_nano % 1000000);
 			return IIO_VAL_INT_PLUS_MICRO;
<span class="p_add">+		case IIO_PRESSURE:</span>
<span class="p_add">+			/* 20 uBar = 0.002kPascal */</span>
<span class="p_add">+			*val = 0;</span>
<span class="p_add">+			*val2 = 2000;</span>
<span class="p_add">+			return IIO_VAL_INT_PLUS_MICRO;</span>
 		default:
 			return -EINVAL;
 		}
<span class="p_chunk">@@ -454,10 +459,10 @@</span> <span class="p_context"> static int adis16400_read_raw(struct iio_dev *indio_dev,</span>
 	}
 }
 
<span class="p_del">-#define ADIS16400_VOLTAGE_CHAN(addr, bits, name, si) { \</span>
<span class="p_add">+#define ADIS16400_VOLTAGE_CHAN(addr, bits, name, si, chn) { \</span>
 	.type = IIO_VOLTAGE, \
 	.indexed = 1, \
<span class="p_del">-	.channel = 0, \</span>
<span class="p_add">+	.channel = chn, \</span>
 	.extend_name = name, \
 	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
 		BIT(IIO_CHAN_INFO_SCALE), \
<span class="p_chunk">@@ -474,10 +479,10 @@</span> <span class="p_context"> static int adis16400_read_raw(struct iio_dev *indio_dev,</span>
 }
 
 #define ADIS16400_SUPPLY_CHAN(addr, bits) \
<span class="p_del">-	ADIS16400_VOLTAGE_CHAN(addr, bits, &quot;supply&quot;, ADIS16400_SCAN_SUPPLY)</span>
<span class="p_add">+	ADIS16400_VOLTAGE_CHAN(addr, bits, &quot;supply&quot;, ADIS16400_SCAN_SUPPLY, 0)</span>
 
 #define ADIS16400_AUX_ADC_CHAN(addr, bits) \
<span class="p_del">-	ADIS16400_VOLTAGE_CHAN(addr, bits, NULL, ADIS16400_SCAN_ADC)</span>
<span class="p_add">+	ADIS16400_VOLTAGE_CHAN(addr, bits, NULL, ADIS16400_SCAN_ADC, 1)</span>
 
 #define ADIS16400_GYRO_CHAN(mod, addr, bits) { \
 	.type = IIO_ANGL_VEL, \
<span class="p_chunk">@@ -773,7 +778,8 @@</span> <span class="p_context"> static struct adis16400_chip_info adis16400_chips[] = {</span>
 		.channels = adis16448_channels,
 		.num_channels = ARRAY_SIZE(adis16448_channels),
 		.flags = ADIS16400_HAS_PROD_ID |
<span class="p_del">-				ADIS16400_HAS_SERIAL_NUMBER,</span>
<span class="p_add">+				ADIS16400_HAS_SERIAL_NUMBER |</span>
<span class="p_add">+				ADIS16400_BURST_DIAG_STAT,</span>
 		.gyro_scale_micro = IIO_DEGREE_TO_RAD(10000), /* 0.01 deg/s */
 		.accel_scale_micro = IIO_G_TO_M_S_2(833), /* 1/1200 g */
 		.temp_scale_nano = 73860000, /* 0.07386 C */
<span class="p_chunk">@@ -791,11 +797,6 @@</span> <span class="p_context"> static const struct iio_info adis16400_info = {</span>
 	.debugfs_reg_access = adis_debugfs_reg_access,
 };
 
<span class="p_del">-static const unsigned long adis16400_burst_scan_mask[] = {</span>
<span class="p_del">-	~0UL,</span>
<span class="p_del">-	0,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static const char * const adis16400_status_error_msgs[] = {
 	[ADIS16400_DIAG_STAT_ZACCL_FAIL] = &quot;Z-axis accelerometer self-test failure&quot;,
 	[ADIS16400_DIAG_STAT_YACCL_FAIL] = &quot;Y-axis accelerometer self-test failure&quot;,
<span class="p_chunk">@@ -843,6 +844,20 @@</span> <span class="p_context"> static const struct adis_data adis16400_data = {</span>
 		BIT(ADIS16400_DIAG_STAT_POWER_LOW),
 };
 
<span class="p_add">+static void adis16400_setup_chan_mask(struct adis16400_state *st)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct adis16400_chip_info *chip_info = st-&gt;variant;</span>
<span class="p_add">+	unsigned i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; chip_info-&gt;num_channels; i++) {</span>
<span class="p_add">+		const struct iio_chan_spec *ch = &amp;chip_info-&gt;channels[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ch-&gt;scan_index &gt;= 0 &amp;&amp;</span>
<span class="p_add">+		    ch-&gt;scan_index != ADIS16400_SCAN_TIMESTAMP)</span>
<span class="p_add">+			st-&gt;avail_scan_mask[0] |= BIT(ch-&gt;scan_index);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int adis16400_probe(struct spi_device *spi)
 {
 	struct adis16400_state *st;
<span class="p_chunk">@@ -866,8 +881,10 @@</span> <span class="p_context"> static int adis16400_probe(struct spi_device *spi)</span>
 	indio_dev-&gt;info = &amp;adis16400_info;
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 
<span class="p_del">-	if (!(st-&gt;variant-&gt;flags &amp; ADIS16400_NO_BURST))</span>
<span class="p_del">-		indio_dev-&gt;available_scan_masks = adis16400_burst_scan_mask;</span>
<span class="p_add">+	if (!(st-&gt;variant-&gt;flags &amp; ADIS16400_NO_BURST)) {</span>
<span class="p_add">+		adis16400_setup_chan_mask(st);</span>
<span class="p_add">+		indio_dev-&gt;available_scan_masks = st-&gt;avail_scan_mask;</span>
<span class="p_add">+	}</span>
 
 	ret = adis_init(&amp;st-&gt;adis, indio_dev, spi, &amp;adis16400_data);
 	if (ret)
<span class="p_header">diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c</span>
<span class="p_header">index ea6cb64dfb28..d5335e664240 100644</span>
<span class="p_header">--- a/drivers/input/mouse/alps.c</span>
<span class="p_header">+++ b/drivers/input/mouse/alps.c</span>
<span class="p_chunk">@@ -1042,9 +1042,8 @@</span> <span class="p_context"> static void alps_process_trackstick_packet_v7(struct psmouse *psmouse)</span>
 	right = (packet[1] &amp; 0x02) &gt;&gt; 1;
 	middle = (packet[1] &amp; 0x04) &gt;&gt; 2;
 
<span class="p_del">-	/* Divide 2 since trackpoint&#39;s speed is too fast */</span>
<span class="p_del">-	input_report_rel(dev2, REL_X, (char)x / 2);</span>
<span class="p_del">-	input_report_rel(dev2, REL_Y, -((char)y / 2));</span>
<span class="p_add">+	input_report_rel(dev2, REL_X, (char)x);</span>
<span class="p_add">+	input_report_rel(dev2, REL_Y, -((char)y));</span>
 
 	input_report_key(dev2, BTN_LEFT, left);
 	input_report_key(dev2, BTN_RIGHT, right);
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 79363b687195..ce3d40004458 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -1376,10 +1376,11 @@</span> <span class="p_context"> static bool elantech_is_signature_valid(const unsigned char *param)</span>
 		return true;
 
 	/*
<span class="p_del">-	 * Some models have a revision higher then 20. Meaning param[2] may</span>
<span class="p_del">-	 * be 10 or 20, skip the rates check for these.</span>
<span class="p_add">+	 * Some hw_version &gt;= 4 models have a revision higher then 20. Meaning</span>
<span class="p_add">+	 * that param[2] may be 10 or 20, skip the rates check for these.</span>
 	 */
<span class="p_del">-	if (param[0] == 0x46 &amp;&amp; (param[1] &amp; 0xef) == 0x0f &amp;&amp; param[2] &lt; 40)</span>
<span class="p_add">+	if ((param[0] &amp; 0x0f) &gt;= 0x06 &amp;&amp; (param[1] &amp; 0xaf) == 0x0f &amp;&amp;</span>
<span class="p_add">+	    param[2] &lt; 40)</span>
 		return true;
 
 	for (i = 0; i &lt; ARRAY_SIZE(rates); i++)
<span class="p_chunk">@@ -1555,6 +1556,7 @@</span> <span class="p_context"> static int elantech_set_properties(struct elantech_data *etd)</span>
 		case 9:
 		case 10:
 		case 13:
<span class="p_add">+		case 14:</span>
 			etd-&gt;hw_version = 4;
 			break;
 		default:
<span class="p_header">diff --git a/drivers/input/mouse/synaptics.c b/drivers/input/mouse/synaptics.c</span>
<span class="p_header">index 3b06c8a360b6..907ac9bdd763 100644</span>
<span class="p_header">--- a/drivers/input/mouse/synaptics.c</span>
<span class="p_header">+++ b/drivers/input/mouse/synaptics.c</span>
<span class="p_chunk">@@ -148,6 +148,11 @@</span> <span class="p_context"> static const struct min_max_quirk min_max_pnpid_table[] = {</span>
 		1024, 5112, 2024, 4832
 	},
 	{
<span class="p_add">+		(const char * const []){&quot;LEN2000&quot;, NULL},</span>
<span class="p_add">+		{ANY_BOARD_ID, ANY_BOARD_ID},</span>
<span class="p_add">+		1024, 5113, 2021, 4832</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		(const char * const []){&quot;LEN2001&quot;, NULL},
 		{ANY_BOARD_ID, ANY_BOARD_ID},
 		1024, 5022, 2508, 4832
<span class="p_chunk">@@ -188,7 +193,7 @@</span> <span class="p_context"> static const char * const topbuttonpad_pnp_ids[] = {</span>
 	&quot;LEN0045&quot;,
 	&quot;LEN0047&quot;,
 	&quot;LEN0049&quot;,
<span class="p_del">-	&quot;LEN2000&quot;,</span>
<span class="p_add">+	&quot;LEN2000&quot;, /* S540 */</span>
 	&quot;LEN2001&quot;, /* Edge E431 */
 	&quot;LEN2002&quot;, /* Edge E531 */
 	&quot;LEN2003&quot;,
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 2d1e05bdbb53..272149d66f5b 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"></span>
 #define CONTEXT_SIZE		VTD_PAGE_SIZE
 
 #define IS_GFX_DEVICE(pdev) ((pdev-&gt;class &gt;&gt; 16) == PCI_BASE_CLASS_DISPLAY)
<span class="p_add">+#define IS_USB_DEVICE(pdev) ((pdev-&gt;class &gt;&gt; 8) == PCI_CLASS_SERIAL_USB)</span>
 #define IS_ISA_DEVICE(pdev) ((pdev-&gt;class &gt;&gt; 8) == PCI_CLASS_BRIDGE_ISA)
 #define IS_AZALIA(pdev) ((pdev)-&gt;vendor == 0x8086 &amp;&amp; (pdev)-&gt;device == 0x3a3e)
 
<span class="p_chunk">@@ -672,6 +673,11 @@</span> <span class="p_context"> static void domain_update_iommu_cap(struct dmar_domain *domain)</span>
 	domain-&gt;iommu_superpage = domain_update_iommu_superpage(NULL);
 }
 
<span class="p_add">+static int iommu_dummy(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev-&gt;archdata.iommu == DUMMY_DEVICE_DOMAIN_INFO;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devfn)
 {
 	struct dmar_drhd_unit *drhd = NULL;
<span class="p_chunk">@@ -681,6 +687,9 @@</span> <span class="p_context"> static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devf</span>
 	u16 segment = 0;
 	int i;
 
<span class="p_add">+	if (iommu_dummy(dev))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
 	if (dev_is_pci(dev)) {
 		pdev = to_pci_dev(dev);
 		segment = pci_domain_nr(pdev-&gt;bus);
<span class="p_chunk">@@ -2554,6 +2563,10 @@</span> <span class="p_context"> static bool device_has_rmrr(struct device *dev)</span>
  * In both cases we assume that PCI USB devices with RMRRs have them largely
  * for historical reasons and that the RMRR space is not actively used post
  * boot.  This exclusion may change if vendors begin to abuse it.
<span class="p_add">+ *</span>
<span class="p_add">+ * The same exception is made for graphics devices, with the requirement that</span>
<span class="p_add">+ * any use of the RMRR regions will be torn down before assigning the device</span>
<span class="p_add">+ * to a guest.</span>
  */
 static bool device_is_rmrr_locked(struct device *dev)
 {
<span class="p_chunk">@@ -2563,7 +2576,7 @@</span> <span class="p_context"> static bool device_is_rmrr_locked(struct device *dev)</span>
 	if (dev_is_pci(dev)) {
 		struct pci_dev *pdev = to_pci_dev(dev);
 
<span class="p_del">-		if ((pdev-&gt;class &gt;&gt; 8) == PCI_CLASS_SERIAL_USB)</span>
<span class="p_add">+		if (IS_USB_DEVICE(pdev) || IS_GFX_DEVICE(pdev))</span>
 			return false;
 	}
 
<span class="p_chunk">@@ -2969,11 +2982,6 @@</span> <span class="p_context"> static inline struct dmar_domain *get_valid_domain_for_dev(struct device *dev)</span>
 	return __get_valid_domain_for_dev(dev);
 }
 
<span class="p_del">-static int iommu_dummy(struct device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return dev-&gt;archdata.iommu == DUMMY_DEVICE_DOMAIN_INFO;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Check if the dev needs to go through non-identity map and unmap process.*/
 static int iommu_no_mapping(struct device *dev)
 {
<span class="p_header">diff --git a/drivers/irqchip/irq-sunxi-nmi.c b/drivers/irqchip/irq-sunxi-nmi.c</span>
<span class="p_header">index 4a9ce5b50c5b..6b2b582433bd 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-sunxi-nmi.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-sunxi-nmi.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> static int sunxi_sc_nmi_set_type(struct irq_data *data, unsigned int flow_type)</span>
 	irqd_set_trigger_type(data, flow_type);
 	irq_setup_alt_chip(data, flow_type);
 
<span class="p_del">-	for (i = 0; i &lt;= gc-&gt;num_ct; i++, ct++)</span>
<span class="p_add">+	for (i = 0; i &lt; gc-&gt;num_ct; i++, ct++)</span>
 		if (ct-&gt;type &amp; flow_type)
 			ctrl_off = ct-&gt;regs.type;
 
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 907534b7f40d..b7bf8ee857fa 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -3765,7 +3765,7 @@</span> <span class="p_context"> array_state_store(struct mddev *mddev, const char *buf, size_t len)</span>
 				err = -EBUSY;
 		}
 		spin_unlock(&amp;mddev-&gt;lock);
<span class="p_del">-		return err;</span>
<span class="p_add">+		return err ?: len;</span>
 	}
 	err = mddev_lock(mddev);
 	if (err)
<span class="p_chunk">@@ -4144,13 +4144,14 @@</span> <span class="p_context"> action_store(struct mddev *mddev, const char *page, size_t len)</span>
 			set_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);
 		else
 			clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);
<span class="p_del">-		flush_workqueue(md_misc_wq);</span>
<span class="p_del">-		if (mddev-&gt;sync_thread) {</span>
<span class="p_del">-			set_bit(MD_RECOVERY_INTR, &amp;mddev-&gt;recovery);</span>
<span class="p_del">-			if (mddev_lock(mddev) == 0) {</span>
<span class="p_add">+		if (test_bit(MD_RECOVERY_RUNNING, &amp;mddev-&gt;recovery) &amp;&amp;</span>
<span class="p_add">+		    mddev_lock(mddev) == 0) {</span>
<span class="p_add">+			flush_workqueue(md_misc_wq);</span>
<span class="p_add">+			if (mddev-&gt;sync_thread) {</span>
<span class="p_add">+				set_bit(MD_RECOVERY_INTR, &amp;mddev-&gt;recovery);</span>
 				md_reap_sync_thread(mddev);
<span class="p_del">-				mddev_unlock(mddev);</span>
 			}
<span class="p_add">+			mddev_unlock(mddev);</span>
 		}
 	} else if (test_bit(MD_RECOVERY_RUNNING, &amp;mddev-&gt;recovery) ||
 		   test_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery))
<span class="p_header">diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c</span>
<span class="p_header">index 4df28943d222..e8d3c1d35453 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_options.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_options.c</span>
<span class="p_chunk">@@ -624,7 +624,7 @@</span> <span class="p_context"> int __bond_opt_set(struct bonding *bond,</span>
 out:
 	if (ret)
 		bond_opt_error_interpret(bond, opt, ret, val);
<span class="p_del">-	else</span>
<span class="p_add">+	else if (bond-&gt;dev-&gt;reg_state == NETREG_REGISTERED)</span>
 		call_netdevice_notifiers(NETDEV_CHANGEINFODATA, bond-&gt;dev);
 
 	return ret;
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">index 7f05f309e935..da36bcf32404 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_chunk">@@ -1773,9 +1773,9 @@</span> <span class="p_context"> int be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf)</span>
 	total_size = buf_len;
 
 	get_fat_cmd.size = sizeof(struct be_cmd_req_get_fat) + 60*1024;
<span class="p_del">-	get_fat_cmd.va = pci_alloc_consistent(adapter-&gt;pdev,</span>
<span class="p_del">-					      get_fat_cmd.size,</span>
<span class="p_del">-					      &amp;get_fat_cmd.dma);</span>
<span class="p_add">+	get_fat_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					     get_fat_cmd.size,</span>
<span class="p_add">+					     &amp;get_fat_cmd.dma, GFP_ATOMIC);</span>
 	if (!get_fat_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev,
 			&quot;Memory allocation failure while reading FAT data\n&quot;);
<span class="p_chunk">@@ -1820,8 +1820,8 @@</span> <span class="p_context"> int be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf)</span>
 		log_offset += buf_size;
 	}
 err:
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, get_fat_cmd.size,</span>
<span class="p_del">-			    get_fat_cmd.va, get_fat_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, get_fat_cmd.size,</span>
<span class="p_add">+			  get_fat_cmd.va, get_fat_cmd.dma);</span>
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
 	return status;
 }
<span class="p_chunk">@@ -2272,12 +2272,12 @@</span> <span class="p_context"> int be_cmd_read_port_transceiver_data(struct be_adapter *adapter,</span>
 		return -EINVAL;
 
 	cmd.size = sizeof(struct be_cmd_resp_port_type);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory allocation failed\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_del">-	memset(cmd.va, 0, cmd.size);</span>
 
 	spin_lock_bh(&amp;adapter-&gt;mcc_lock);
 
<span class="p_chunk">@@ -2302,7 +2302,7 @@</span> <span class="p_context"> int be_cmd_read_port_transceiver_data(struct be_adapter *adapter,</span>
 	}
 err:
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va, cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -2777,7 +2777,8 @@</span> <span class="p_context"> int be_cmd_get_phy_info(struct be_adapter *adapter)</span>
 		goto err;
 	}
 	cmd.size = sizeof(struct be_cmd_req_get_phy_info);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory alloc failure\n&quot;);
 		status = -ENOMEM;
<span class="p_chunk">@@ -2811,7 +2812,7 @@</span> <span class="p_context"> int be_cmd_get_phy_info(struct be_adapter *adapter)</span>
 				BE_SUPPORTED_SPEED_1GBPS;
 		}
 	}
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va, cmd.dma);</span>
 err:
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
 	return status;
<span class="p_chunk">@@ -2862,8 +2863,9 @@</span> <span class="p_context"> int be_cmd_get_cntl_attributes(struct be_adapter *adapter)</span>
 
 	memset(&amp;attribs_cmd, 0, sizeof(struct be_dma_mem));
 	attribs_cmd.size = sizeof(struct be_cmd_resp_cntl_attribs);
<span class="p_del">-	attribs_cmd.va = pci_alloc_consistent(adapter-&gt;pdev, attribs_cmd.size,</span>
<span class="p_del">-					      &amp;attribs_cmd.dma);</span>
<span class="p_add">+	attribs_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					     attribs_cmd.size,</span>
<span class="p_add">+					     &amp;attribs_cmd.dma, GFP_ATOMIC);</span>
 	if (!attribs_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory allocation failure\n&quot;);
 		status = -ENOMEM;
<span class="p_chunk">@@ -2890,8 +2892,8 @@</span> <span class="p_context"> int be_cmd_get_cntl_attributes(struct be_adapter *adapter)</span>
 err:
 	mutex_unlock(&amp;adapter-&gt;mbox_lock);
 	if (attribs_cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, attribs_cmd.size,</span>
<span class="p_del">-				    attribs_cmd.va, attribs_cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, attribs_cmd.size,</span>
<span class="p_add">+				  attribs_cmd.va, attribs_cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -3029,9 +3031,10 @@</span> <span class="p_context"> int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,</span>
 
 	memset(&amp;get_mac_list_cmd, 0, sizeof(struct be_dma_mem));
 	get_mac_list_cmd.size = sizeof(struct be_cmd_resp_get_mac_list);
<span class="p_del">-	get_mac_list_cmd.va = pci_alloc_consistent(adapter-&gt;pdev,</span>
<span class="p_del">-						   get_mac_list_cmd.size,</span>
<span class="p_del">-						   &amp;get_mac_list_cmd.dma);</span>
<span class="p_add">+	get_mac_list_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+						  get_mac_list_cmd.size,</span>
<span class="p_add">+						  &amp;get_mac_list_cmd.dma,</span>
<span class="p_add">+						  GFP_ATOMIC);</span>
 
 	if (!get_mac_list_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev,
<span class="p_chunk">@@ -3104,8 +3107,8 @@</span> <span class="p_context"> int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,</span>
 
 out:
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, get_mac_list_cmd.size,</span>
<span class="p_del">-			    get_mac_list_cmd.va, get_mac_list_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, get_mac_list_cmd.size,</span>
<span class="p_add">+			  get_mac_list_cmd.va, get_mac_list_cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -3158,8 +3161,8 @@</span> <span class="p_context"> int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array,</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_req_set_mac_list);
<span class="p_del">-	cmd.va = dma_alloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size,</span>
<span class="p_del">-				    &amp;cmd.dma, GFP_KERNEL);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_KERNEL);</span>
 	if (!cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -3348,7 +3351,8 @@</span> <span class="p_context"> int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter)</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_resp_acpi_wol_magic_config_v1);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory allocation failure\n&quot;);
 		status = -ENOMEM;
<span class="p_chunk">@@ -3383,7 +3387,8 @@</span> <span class="p_context"> int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter)</span>
 err:
 	mutex_unlock(&amp;adapter-&gt;mbox_lock);
 	if (cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va,</span>
<span class="p_add">+				  cmd.dma);</span>
 	return status;
 
 }
<span class="p_chunk">@@ -3397,8 +3402,9 @@</span> <span class="p_context"> int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)</span>
 
 	memset(&amp;extfat_cmd, 0, sizeof(struct be_dma_mem));
 	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
<span class="p_del">-	extfat_cmd.va = pci_alloc_consistent(adapter-&gt;pdev, extfat_cmd.size,</span>
<span class="p_del">-					     &amp;extfat_cmd.dma);</span>
<span class="p_add">+	extfat_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    extfat_cmd.size, &amp;extfat_cmd.dma,</span>
<span class="p_add">+					    GFP_ATOMIC);</span>
 	if (!extfat_cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -3420,8 +3426,8 @@</span> <span class="p_context"> int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)</span>
 
 	status = be_cmd_set_ext_fat_capabilites(adapter, &amp;extfat_cmd, cfgs);
 err:
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, extfat_cmd.size, extfat_cmd.va,</span>
<span class="p_del">-			    extfat_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, extfat_cmd.size, extfat_cmd.va,</span>
<span class="p_add">+			  extfat_cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -3434,8 +3440,9 @@</span> <span class="p_context"> int be_cmd_get_fw_log_level(struct be_adapter *adapter)</span>
 
 	memset(&amp;extfat_cmd, 0, sizeof(struct be_dma_mem));
 	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
<span class="p_del">-	extfat_cmd.va = pci_alloc_consistent(adapter-&gt;pdev, extfat_cmd.size,</span>
<span class="p_del">-					     &amp;extfat_cmd.dma);</span>
<span class="p_add">+	extfat_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    extfat_cmd.size, &amp;extfat_cmd.dma,</span>
<span class="p_add">+					    GFP_ATOMIC);</span>
 
 	if (!extfat_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;%s: Memory allocation failure\n&quot;,
<span class="p_chunk">@@ -3453,8 +3460,8 @@</span> <span class="p_context"> int be_cmd_get_fw_log_level(struct be_adapter *adapter)</span>
 				level = cfgs-&gt;module[0].trace_lvl[j].dbg_lvl;
 		}
 	}
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, extfat_cmd.size, extfat_cmd.va,</span>
<span class="p_del">-			    extfat_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, extfat_cmd.size, extfat_cmd.va,</span>
<span class="p_add">+			  extfat_cmd.dma);</span>
 err:
 	return level;
 }
<span class="p_chunk">@@ -3652,7 +3659,8 @@</span> <span class="p_context"> int be_cmd_get_func_config(struct be_adapter *adapter, struct be_resources *res)</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_resp_get_func_config);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory alloc failure\n&quot;);
 		status = -ENOMEM;
<span class="p_chunk">@@ -3692,7 +3700,8 @@</span> <span class="p_context"> int be_cmd_get_func_config(struct be_adapter *adapter, struct be_resources *res)</span>
 err:
 	mutex_unlock(&amp;adapter-&gt;mbox_lock);
 	if (cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va,</span>
<span class="p_add">+				  cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -3713,7 +3722,8 @@</span> <span class="p_context"> int be_cmd_get_profile_config(struct be_adapter *adapter,</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_resp_get_profile_config);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -3752,7 +3762,8 @@</span> <span class="p_context"> int be_cmd_get_profile_config(struct be_adapter *adapter,</span>
 		res-&gt;vf_if_cap_flags = vf_res-&gt;cap_flags;
 err:
 	if (cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va,</span>
<span class="p_add">+				  cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -3767,7 +3778,8 @@</span> <span class="p_context"> static int be_cmd_set_profile_config(struct be_adapter *adapter, void *desc,</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_req_set_profile_config);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -3783,7 +3795,8 @@</span> <span class="p_context"> static int be_cmd_set_profile_config(struct be_adapter *adapter, void *desc,</span>
 	status = be_cmd_notify_wait(adapter, &amp;wrb);
 
 	if (cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va,</span>
<span class="p_add">+				  cmd.dma);</span>
 	return status;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_ethtool.c b/drivers/net/ethernet/emulex/benet/be_ethtool.c</span>
<span class="p_header">index 4d2de4700769..22ffcd81a6b5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_ethtool.c</span>
<span class="p_chunk">@@ -264,8 +264,8 @@</span> <span class="p_context"> static int lancer_cmd_read_file(struct be_adapter *adapter, u8 *file_name,</span>
 	int status = 0;
 
 	read_cmd.size = LANCER_READ_FILE_CHUNK;
<span class="p_del">-	read_cmd.va = pci_alloc_consistent(adapter-&gt;pdev, read_cmd.size,</span>
<span class="p_del">-					   &amp;read_cmd.dma);</span>
<span class="p_add">+	read_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, read_cmd.size,</span>
<span class="p_add">+					  &amp;read_cmd.dma, GFP_ATOMIC);</span>
 
 	if (!read_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev,
<span class="p_chunk">@@ -289,8 +289,8 @@</span> <span class="p_context"> static int lancer_cmd_read_file(struct be_adapter *adapter, u8 *file_name,</span>
 			break;
 		}
 	}
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, read_cmd.size, read_cmd.va,</span>
<span class="p_del">-			    read_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, read_cmd.size, read_cmd.va,</span>
<span class="p_add">+			  read_cmd.dma);</span>
 
 	return status;
 }
<span class="p_chunk">@@ -818,8 +818,9 @@</span> <span class="p_context"> static int be_test_ddr_dma(struct be_adapter *adapter)</span>
 	};
 
 	ddrdma_cmd.size = sizeof(struct be_cmd_req_ddrdma_test);
<span class="p_del">-	ddrdma_cmd.va = dma_alloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, ddrdma_cmd.size,</span>
<span class="p_del">-					   &amp;ddrdma_cmd.dma, GFP_KERNEL);</span>
<span class="p_add">+	ddrdma_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    ddrdma_cmd.size, &amp;ddrdma_cmd.dma,</span>
<span class="p_add">+					    GFP_KERNEL);</span>
 	if (!ddrdma_cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -941,8 +942,9 @@</span> <span class="p_context"> static int be_read_eeprom(struct net_device *netdev,</span>
 
 	memset(&amp;eeprom_cmd, 0, sizeof(struct be_dma_mem));
 	eeprom_cmd.size = sizeof(struct be_cmd_req_seeprom_read);
<span class="p_del">-	eeprom_cmd.va = dma_alloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, eeprom_cmd.size,</span>
<span class="p_del">-					   &amp;eeprom_cmd.dma, GFP_KERNEL);</span>
<span class="p_add">+	eeprom_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    eeprom_cmd.size, &amp;eeprom_cmd.dma,</span>
<span class="p_add">+					    GFP_KERNEL);</span>
 
 	if (!eeprom_cmd.va)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">index e6b790f0d9dc..893753f18098 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_chunk">@@ -4392,8 +4392,8 @@</span> <span class="p_context"> static int lancer_fw_download(struct be_adapter *adapter,</span>
 
 	flash_cmd.size = sizeof(struct lancer_cmd_req_write_object)
 				+ LANCER_FW_DOWNLOAD_CHUNK;
<span class="p_del">-	flash_cmd.va = dma_alloc_coherent(dev, flash_cmd.size,</span>
<span class="p_del">-					  &amp;flash_cmd.dma, GFP_KERNEL);</span>
<span class="p_add">+	flash_cmd.va = dma_zalloc_coherent(dev, flash_cmd.size,</span>
<span class="p_add">+					   &amp;flash_cmd.dma, GFP_KERNEL);</span>
 	if (!flash_cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -4526,8 +4526,8 @@</span> <span class="p_context"> static int be_fw_download(struct be_adapter *adapter, const struct firmware* fw)</span>
 	}
 
 	flash_cmd.size = sizeof(struct be_cmd_write_flashrom);
<span class="p_del">-	flash_cmd.va = dma_alloc_coherent(dev, flash_cmd.size, &amp;flash_cmd.dma,</span>
<span class="p_del">-					  GFP_KERNEL);</span>
<span class="p_add">+	flash_cmd.va = dma_zalloc_coherent(dev, flash_cmd.size, &amp;flash_cmd.dma,</span>
<span class="p_add">+					   GFP_KERNEL);</span>
 	if (!flash_cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -4941,10 +4941,10 @@</span> <span class="p_context"> static int be_ctrl_init(struct be_adapter *adapter)</span>
 		goto done;
 
 	mbox_mem_alloc-&gt;size = sizeof(struct be_mcc_mailbox) + 16;
<span class="p_del">-	mbox_mem_alloc-&gt;va = dma_alloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_del">-						mbox_mem_alloc-&gt;size,</span>
<span class="p_del">-						&amp;mbox_mem_alloc-&gt;dma,</span>
<span class="p_del">-						GFP_KERNEL);</span>
<span class="p_add">+	mbox_mem_alloc-&gt;va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+						 mbox_mem_alloc-&gt;size,</span>
<span class="p_add">+						 &amp;mbox_mem_alloc-&gt;dma,</span>
<span class="p_add">+						 GFP_KERNEL);</span>
 	if (!mbox_mem_alloc-&gt;va) {
 		status = -ENOMEM;
 		goto unmap_pci_bars;
<span class="p_header">diff --git a/drivers/net/phy/dp83640.c b/drivers/net/phy/dp83640.c</span>
<span class="p_header">index e22e602beef3..c5789cdf7778 100644</span>
<span class="p_header">--- a/drivers/net/phy/dp83640.c</span>
<span class="p_header">+++ b/drivers/net/phy/dp83640.c</span>
<span class="p_chunk">@@ -47,7 +47,7 @@</span> <span class="p_context"></span>
 #define PSF_TX		0x1000
 #define EXT_EVENT	1
 #define CAL_EVENT	7
<span class="p_del">-#define CAL_TRIGGER	7</span>
<span class="p_add">+#define CAL_TRIGGER	1</span>
 #define DP83640_N_PINS	12
 
 #define MII_DP83640_MICR 0x11
<span class="p_chunk">@@ -495,7 +495,9 @@</span> <span class="p_context"> static int ptp_dp83640_enable(struct ptp_clock_info *ptp,</span>
 			else
 				evnt |= EVNT_RISE;
 		}
<span class="p_add">+		mutex_lock(&amp;clock-&gt;extreg_lock);</span>
 		ext_write(0, phydev, PAGE5, PTP_EVNT, evnt);
<span class="p_add">+		mutex_unlock(&amp;clock-&gt;extreg_lock);</span>
 		return 0;
 
 	case PTP_CLK_REQ_PEROUT:
<span class="p_chunk">@@ -531,6 +533,8 @@</span> <span class="p_context"> static u8 status_frame_src[6] = { 0x08, 0x00, 0x17, 0x0B, 0x6B, 0x0F };</span>
 
 static void enable_status_frames(struct phy_device *phydev, bool on)
 {
<span class="p_add">+	struct dp83640_private *dp83640 = phydev-&gt;priv;</span>
<span class="p_add">+	struct dp83640_clock *clock = dp83640-&gt;clock;</span>
 	u16 cfg0 = 0, ver;
 
 	if (on)
<span class="p_chunk">@@ -538,9 +542,13 @@</span> <span class="p_context"> static void enable_status_frames(struct phy_device *phydev, bool on)</span>
 
 	ver = (PSF_PTPVER &amp; VERSIONPTP_MASK) &lt;&lt; VERSIONPTP_SHIFT;
 
<span class="p_add">+	mutex_lock(&amp;clock-&gt;extreg_lock);</span>
<span class="p_add">+</span>
 	ext_write(0, phydev, PAGE5, PSF_CFG0, cfg0);
 	ext_write(0, phydev, PAGE6, PSF_CFG1, ver);
 
<span class="p_add">+	mutex_unlock(&amp;clock-&gt;extreg_lock);</span>
<span class="p_add">+</span>
 	if (!phydev-&gt;attached_dev) {
 		pr_warn(&quot;expected to find an attached netdevice\n&quot;);
 		return;
<span class="p_chunk">@@ -837,7 +845,7 @@</span> <span class="p_context"> static void decode_rxts(struct dp83640_private *dp83640,</span>
 	list_del_init(&amp;rxts-&gt;list);
 	phy2rxts(phy_rxts, rxts);
 
<span class="p_del">-	spin_lock_irqsave(&amp;dp83640-&gt;rx_queue.lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;dp83640-&gt;rx_queue.lock);</span>
 	skb_queue_walk(&amp;dp83640-&gt;rx_queue, skb) {
 		struct dp83640_skb_info *skb_info;
 
<span class="p_chunk">@@ -852,7 +860,7 @@</span> <span class="p_context"> static void decode_rxts(struct dp83640_private *dp83640,</span>
 			break;
 		}
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;dp83640-&gt;rx_queue.lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;dp83640-&gt;rx_queue.lock);</span>
 
 	if (!shhwtstamps)
 		list_add_tail(&amp;rxts-&gt;list, &amp;dp83640-&gt;rxts);
<span class="p_chunk">@@ -1172,11 +1180,18 @@</span> <span class="p_context"> static int dp83640_config_init(struct phy_device *phydev)</span>
 
 	if (clock-&gt;chosen &amp;&amp; !list_empty(&amp;clock-&gt;phylist))
 		recalibrate(clock);
<span class="p_del">-	else</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		mutex_lock(&amp;clock-&gt;extreg_lock);</span>
 		enable_broadcast(phydev, clock-&gt;page, 1);
<span class="p_add">+		mutex_unlock(&amp;clock-&gt;extreg_lock);</span>
<span class="p_add">+	}</span>
 
 	enable_status_frames(phydev, true);
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;clock-&gt;extreg_lock);</span>
 	ext_write(0, phydev, PAGE4, PTP_CTL, PTP_ENABLE);
<span class="p_add">+	mutex_unlock(&amp;clock-&gt;extreg_lock);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c</span>
<span class="p_header">index 52cd8db2c57d..757f28a4284c 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy.c</span>
<span class="p_chunk">@@ -1053,13 +1053,14 @@</span> <span class="p_context"> int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable)</span>
 {
 	/* According to 802.3az,the EEE is supported only in full duplex-mode.
 	 * Also EEE feature is active when core is operating with MII, GMII
<span class="p_del">-	 * or RGMII. Internal PHYs are also allowed to proceed and should</span>
<span class="p_del">-	 * return an error if they do not support EEE.</span>
<span class="p_add">+	 * or RGMII (all kinds). Internal PHYs are also allowed to proceed and</span>
<span class="p_add">+	 * should return an error if they do not support EEE.</span>
 	 */
 	if ((phydev-&gt;duplex == DUPLEX_FULL) &amp;&amp;
 	    ((phydev-&gt;interface == PHY_INTERFACE_MODE_MII) ||
 	    (phydev-&gt;interface == PHY_INTERFACE_MODE_GMII) ||
<span class="p_del">-	    (phydev-&gt;interface == PHY_INTERFACE_MODE_RGMII) ||</span>
<span class="p_add">+	    (phydev-&gt;interface &gt;= PHY_INTERFACE_MODE_RGMII &amp;&amp;</span>
<span class="p_add">+	     phydev-&gt;interface &lt;= PHY_INTERFACE_MODE_RGMII_TXID) ||</span>
 	     phy_is_internal(phydev))) {
 		int eee_lp, eee_cap, eee_adv;
 		u32 lp, cap, adv;
<span class="p_header">diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">index c3e4da9e79ca..8067b8fbb0ee 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_chunk">@@ -1182,7 +1182,7 @@</span> <span class="p_context"> cdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign)</span>
 	 * payload data instead.
 	 */
 	usbnet_set_skb_tx_stats(skb_out, n,
<span class="p_del">-				ctx-&gt;tx_curr_frame_payload - skb_out-&gt;len);</span>
<span class="p_add">+				(long)ctx-&gt;tx_curr_frame_payload - skb_out-&gt;len);</span>
 
 	return skb_out;
 
<span class="p_header">diff --git a/drivers/net/xen-netback/xenbus.c b/drivers/net/xen-netback/xenbus.c</span>
<span class="p_header">index 794204e34fba..152131a10047 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/xenbus.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/xenbus.c</span>
<span class="p_chunk">@@ -34,6 +34,8 @@</span> <span class="p_context"> struct backend_info {</span>
 	enum xenbus_state frontend_state;
 	struct xenbus_watch hotplug_status_watch;
 	u8 have_hotplug_status_watch:1;
<span class="p_add">+</span>
<span class="p_add">+	const char *hotplug_script;</span>
 };
 
 static int connect_rings(struct backend_info *be, struct xenvif_queue *queue);
<span class="p_chunk">@@ -236,6 +238,7 @@</span> <span class="p_context"> static int netback_remove(struct xenbus_device *dev)</span>
 		xenvif_free(be-&gt;vif);
 		be-&gt;vif = NULL;
 	}
<span class="p_add">+	kfree(be-&gt;hotplug_script);</span>
 	kfree(be);
 	dev_set_drvdata(&amp;dev-&gt;dev, NULL);
 	return 0;
<span class="p_chunk">@@ -253,6 +256,7 @@</span> <span class="p_context"> static int netback_probe(struct xenbus_device *dev,</span>
 	struct xenbus_transaction xbt;
 	int err;
 	int sg;
<span class="p_add">+	const char *script;</span>
 	struct backend_info *be = kzalloc(sizeof(struct backend_info),
 					  GFP_KERNEL);
 	if (!be) {
<span class="p_chunk">@@ -345,6 +349,15 @@</span> <span class="p_context"> static int netback_probe(struct xenbus_device *dev,</span>
 	if (err)
 		pr_debug(&quot;Error writing multi-queue-max-queues\n&quot;);
 
<span class="p_add">+	script = xenbus_read(XBT_NIL, dev-&gt;nodename, &quot;script&quot;, NULL);</span>
<span class="p_add">+	if (IS_ERR(script)) {</span>
<span class="p_add">+		err = PTR_ERR(script);</span>
<span class="p_add">+		xenbus_dev_fatal(dev, err, &quot;reading script&quot;);</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	be-&gt;hotplug_script = script;</span>
<span class="p_add">+</span>
 	err = xenbus_switch_state(dev, XenbusStateInitWait);
 	if (err)
 		goto fail;
<span class="p_chunk">@@ -377,22 +390,14 @@</span> <span class="p_context"> static int netback_uevent(struct xenbus_device *xdev,</span>
 			  struct kobj_uevent_env *env)
 {
 	struct backend_info *be = dev_get_drvdata(&amp;xdev-&gt;dev);
<span class="p_del">-	char *val;</span>
 
<span class="p_del">-	val = xenbus_read(XBT_NIL, xdev-&gt;nodename, &quot;script&quot;, NULL);</span>
<span class="p_del">-	if (IS_ERR(val)) {</span>
<span class="p_del">-		int err = PTR_ERR(val);</span>
<span class="p_del">-		xenbus_dev_fatal(xdev, err, &quot;reading script&quot;);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (add_uevent_var(env, &quot;script=%s&quot;, val)) {</span>
<span class="p_del">-			kfree(val);</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		kfree(val);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!be)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (add_uevent_var(env, &quot;script=%s&quot;, be-&gt;hotplug_script))</span>
<span class="p_add">+		return -ENOMEM;</span>
 
<span class="p_del">-	if (!be || !be-&gt;vif)</span>
<span class="p_add">+	if (!be-&gt;vif)</span>
 		return 0;
 
 	return add_uevent_var(env, &quot;vif=%s&quot;, be-&gt;vif-&gt;dev-&gt;name);
<span class="p_chunk">@@ -736,6 +741,7 @@</span> <span class="p_context"> static void connect(struct backend_info *be)</span>
 			goto err;
 		}
 
<span class="p_add">+		queue-&gt;credit_bytes = credit_bytes;</span>
 		queue-&gt;remaining_credit = credit_bytes;
 		queue-&gt;credit_usec = credit_usec;
 
<span class="p_header">diff --git a/drivers/of/dynamic.c b/drivers/of/dynamic.c</span>
<span class="p_header">index 3351ef408125..53826b84e0ec 100644</span>
<span class="p_header">--- a/drivers/of/dynamic.c</span>
<span class="p_header">+++ b/drivers/of/dynamic.c</span>
<span class="p_chunk">@@ -225,7 +225,7 @@</span> <span class="p_context"> void __of_attach_node(struct device_node *np)</span>
 	phandle = __of_get_property(np, &quot;phandle&quot;, &amp;sz);
 	if (!phandle)
 		phandle = __of_get_property(np, &quot;linux,phandle&quot;, &amp;sz);
<span class="p_del">-	if (IS_ENABLED(PPC_PSERIES) &amp;&amp; !phandle)</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_PPC_PSERIES) &amp;&amp; !phandle)</span>
 		phandle = __of_get_property(np, &quot;ibm,phandle&quot;, &amp;sz);
 	np-&gt;phandle = (phandle &amp;&amp; (sz &gt;= 4)) ? be32_to_cpup(phandle) : 0;
 
<span class="p_header">diff --git a/drivers/staging/ozwpan/ozhcd.c b/drivers/staging/ozwpan/ozhcd.c</span>
<span class="p_header">index 8543bb29a138..9737a979b8db 100644</span>
<span class="p_header">--- a/drivers/staging/ozwpan/ozhcd.c</span>
<span class="p_header">+++ b/drivers/staging/ozwpan/ozhcd.c</span>
<span class="p_chunk">@@ -743,8 +743,8 @@</span> <span class="p_context"> void oz_hcd_pd_reset(void *hpd, void *hport)</span>
 /*
  * Context: softirq
  */
<span class="p_del">-void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,</span>
<span class="p_del">-			int length, int offset, int total_size)</span>
<span class="p_add">+void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,</span>
<span class="p_add">+			u8 length, u16 offset, u16 total_size)</span>
 {
 	struct oz_port *port = hport;
 	struct urb *urb;
<span class="p_chunk">@@ -756,8 +756,8 @@</span> <span class="p_context"> void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,</span>
 	if (!urb)
 		return;
 	if (status == 0) {
<span class="p_del">-		int copy_len;</span>
<span class="p_del">-		int required_size = urb-&gt;transfer_buffer_length;</span>
<span class="p_add">+		unsigned int copy_len;</span>
<span class="p_add">+		unsigned int required_size = urb-&gt;transfer_buffer_length;</span>
 
 		if (required_size &gt; total_size)
 			required_size = total_size;
<span class="p_header">diff --git a/drivers/staging/ozwpan/ozusbif.h b/drivers/staging/ozwpan/ozusbif.h</span>
<span class="p_header">index 4249fa374012..d2a6085345be 100644</span>
<span class="p_header">--- a/drivers/staging/ozwpan/ozusbif.h</span>
<span class="p_header">+++ b/drivers/staging/ozwpan/ozusbif.h</span>
<span class="p_chunk">@@ -29,8 +29,8 @@</span> <span class="p_context"> void oz_usb_request_heartbeat(void *hpd);</span>
 
 /* Confirmation functions.
  */
<span class="p_del">-void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status,</span>
<span class="p_del">-	const u8 *desc, int length, int offset, int total_size);</span>
<span class="p_add">+void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status,</span>
<span class="p_add">+	const u8 *desc, u8 length, u16 offset, u16 total_size);</span>
 void oz_hcd_control_cnf(void *hport, u8 req_id, u8 rcode,
 	const u8 *data, int data_len);
 
<span class="p_header">diff --git a/drivers/staging/ozwpan/ozusbsvc1.c b/drivers/staging/ozwpan/ozusbsvc1.c</span>
<span class="p_header">index d434d8c6fff6..f660bb198c65 100644</span>
<span class="p_header">--- a/drivers/staging/ozwpan/ozusbsvc1.c</span>
<span class="p_header">+++ b/drivers/staging/ozwpan/ozusbsvc1.c</span>
<span class="p_chunk">@@ -326,7 +326,11 @@</span> <span class="p_context"> static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,</span>
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body-&gt;data;
<span class="p_del">-			int n = (len - sizeof(struct oz_multiple_fixed)+1)</span>
<span class="p_add">+			unsigned int n;</span>
<span class="p_add">+			if (!body-&gt;unit_size ||</span>
<span class="p_add">+				len &lt; sizeof(struct oz_multiple_fixed) - 1)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			n = (len - (sizeof(struct oz_multiple_fixed) - 1))</span>
 				/ body-&gt;unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx-&gt;hport, body-&gt;endpoint,
<span class="p_chunk">@@ -390,10 +394,15 @@</span> <span class="p_context"> void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)</span>
 	case OZ_GET_DESC_RSP: {
 			struct oz_get_desc_rsp *body =
 				(struct oz_get_desc_rsp *)usb_hdr;
<span class="p_del">-			int data_len = elt-&gt;length -</span>
<span class="p_del">-					sizeof(struct oz_get_desc_rsp) + 1;</span>
<span class="p_del">-			u16 offs = le16_to_cpu(get_unaligned(&amp;body-&gt;offset));</span>
<span class="p_del">-			u16 total_size =</span>
<span class="p_add">+			u16 offs, total_size;</span>
<span class="p_add">+			u8 data_len;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (elt-&gt;length &lt; sizeof(struct oz_get_desc_rsp) - 1)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			data_len = elt-&gt;length -</span>
<span class="p_add">+					(sizeof(struct oz_get_desc_rsp) - 1);</span>
<span class="p_add">+			offs = le16_to_cpu(get_unaligned(&amp;body-&gt;offset));</span>
<span class="p_add">+			total_size =</span>
 				le16_to_cpu(get_unaligned(&amp;body-&gt;total_size));
 			oz_dbg(ON, &quot;USB_REQ_GET_DESCRIPTOR - cnf\n&quot;);
 			oz_hcd_get_desc_cnf(usb_ctx-&gt;hport, body-&gt;req_id,
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index cc57a3a6b02b..eee40b5cb025 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -162,6 +162,17 @@</span> <span class="p_context"> static inline int tty_put_user(struct tty_struct *tty, unsigned char x,</span>
 	return put_user(x, ptr);
 }
 
<span class="p_add">+static inline int tty_copy_to_user(struct tty_struct *tty,</span>
<span class="p_add">+					void __user *to,</span>
<span class="p_add">+					const void *from,</span>
<span class="p_add">+					unsigned long n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct n_tty_data *ldata = tty-&gt;disc_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	tty_audit_add_data(tty, to, n, ldata-&gt;icanon);</span>
<span class="p_add">+	return copy_to_user(to, from, n);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	n_tty_kick_worker - start input worker (if required)
  *	@tty: terminal
<span class="p_chunk">@@ -2084,12 +2095,12 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 		    __func__, eol, found, n, c, size, more);
 
 	if (n &gt; size) {
<span class="p_del">-		ret = copy_to_user(*b, read_buf_addr(ldata, tail), size);</span>
<span class="p_add">+		ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), size);</span>
 		if (ret)
 			return -EFAULT;
<span class="p_del">-		ret = copy_to_user(*b + size, ldata-&gt;read_buf, n - size);</span>
<span class="p_add">+		ret = tty_copy_to_user(tty, *b + size, ldata-&gt;read_buf, n - size);</span>
 	} else
<span class="p_del">-		ret = copy_to_user(*b, read_buf_addr(ldata, tail), n);</span>
<span class="p_add">+		ret = tty_copy_to_user(tty, *b, read_buf_addr(ldata, tail), n);</span>
 
 	if (ret)
 		return -EFAULT;
<span class="p_header">diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c</span>
<span class="p_header">index 23061918b0e4..f74f400fcb57 100644</span>
<span class="p_header">--- a/drivers/tty/serial/imx.c</span>
<span class="p_header">+++ b/drivers/tty/serial/imx.c</span>
<span class="p_chunk">@@ -959,6 +959,14 @@</span> <span class="p_context"> static void dma_rx_callback(void *data)</span>
 
 	status = dmaengine_tx_status(chan, (dma_cookie_t)0, &amp;state);
 	count = RX_BUF_SIZE - state.residue;
<span class="p_add">+</span>
<span class="p_add">+	if (readl(sport-&gt;port.membase + USR2) &amp; USR2_IDLE) {</span>
<span class="p_add">+		/* In condition [3] the SDMA counted up too early */</span>
<span class="p_add">+		count--;</span>
<span class="p_add">+</span>
<span class="p_add">+		writel(USR2_IDLE, sport-&gt;port.membase + USR2);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev_dbg(sport-&gt;port.dev, &quot;We get %d bytes.\n&quot;, count);
 
 	if (count) {
<span class="p_header">diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h</span>
<span class="p_header">index d201910b892f..f176941a92dd 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/core.h</span>
<span class="p_header">+++ b/drivers/usb/dwc3/core.h</span>
<span class="p_chunk">@@ -339,7 +339,7 @@</span> <span class="p_context"></span>
 #define DWC3_DGCMD_SET_ENDPOINT_NRDY	0x0c
 #define DWC3_DGCMD_RUN_SOC_BUS_LOOPBACK	0x10
 
<span class="p_del">-#define DWC3_DGCMD_STATUS(n)		(((n) &gt;&gt; 15) &amp; 1)</span>
<span class="p_add">+#define DWC3_DGCMD_STATUS(n)		(((n) &gt;&gt; 12) &amp; 0x0F)</span>
 #define DWC3_DGCMD_CMDACT		(1 &lt;&lt; 10)
 #define DWC3_DGCMD_CMDIOC		(1 &lt;&lt; 8)
 
<span class="p_chunk">@@ -355,7 +355,7 @@</span> <span class="p_context"></span>
 #define DWC3_DEPCMD_PARAM_SHIFT		16
 #define DWC3_DEPCMD_PARAM(x)		((x) &lt;&lt; DWC3_DEPCMD_PARAM_SHIFT)
 #define DWC3_DEPCMD_GET_RSC_IDX(x)	(((x) &gt;&gt; DWC3_DEPCMD_PARAM_SHIFT) &amp; 0x7f)
<span class="p_del">-#define DWC3_DEPCMD_STATUS(x)		(((x) &gt;&gt; 15) &amp; 1)</span>
<span class="p_add">+#define DWC3_DEPCMD_STATUS(x)		(((x) &gt;&gt; 12) &amp; 0x0F)</span>
 #define DWC3_DEPCMD_HIPRI_FORCERM	(1 &lt;&lt; 11)
 #define DWC3_DEPCMD_CMDACT		(1 &lt;&lt; 10)
 #define DWC3_DEPCMD_CMDIOC		(1 &lt;&lt; 8)
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index ec8ac1674854..36bf089b708f 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -3682,18 +3682,21 @@</span> <span class="p_context"> int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev)</span>
 {
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 	unsigned long flags;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, slot_id;</span>
 	struct xhci_command *command;
 
 	command = xhci_alloc_command(xhci, false, false, GFP_KERNEL);
 	if (!command)
 		return 0;
 
<span class="p_add">+	/* xhci-&gt;slot_id and xhci-&gt;addr_dev are not thread-safe */</span>
<span class="p_add">+	mutex_lock(&amp;xhci-&gt;mutex);</span>
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 	command-&gt;completion = &amp;xhci-&gt;addr_dev;
 	ret = xhci_queue_slot_control(xhci, command, TRB_ENABLE_SLOT, 0);
 	if (ret) {
 		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_add">+		mutex_unlock(&amp;xhci-&gt;mutex);</span>
 		xhci_dbg(xhci, &quot;FIXME: allocate a command ring segment\n&quot;);
 		kfree(command);
 		return 0;
<span class="p_chunk">@@ -3702,8 +3705,10 @@</span> <span class="p_context"> int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev)</span>
 	spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
 
 	wait_for_completion(command-&gt;completion);
<span class="p_add">+	slot_id = xhci-&gt;slot_id;</span>
<span class="p_add">+	mutex_unlock(&amp;xhci-&gt;mutex);</span>
 
<span class="p_del">-	if (!xhci-&gt;slot_id || command-&gt;status != COMP_SUCCESS) {</span>
<span class="p_add">+	if (!slot_id || command-&gt;status != COMP_SUCCESS) {</span>
 		xhci_err(xhci, &quot;Error while assigning device slot ID\n&quot;);
 		xhci_err(xhci, &quot;Max number of devices this xHCI host supports is %u.\n&quot;,
 				HCS_MAX_SLOTS(
<span class="p_chunk">@@ -3728,11 +3733,11 @@</span> <span class="p_context"> int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev)</span>
 	 * xhci_discover_or_reset_device(), which may be called as part of
 	 * mass storage driver error handling.
 	 */
<span class="p_del">-	if (!xhci_alloc_virt_device(xhci, xhci-&gt;slot_id, udev, GFP_NOIO)) {</span>
<span class="p_add">+	if (!xhci_alloc_virt_device(xhci, slot_id, udev, GFP_NOIO)) {</span>
 		xhci_warn(xhci, &quot;Could not allocate xHCI USB device data structures\n&quot;);
 		goto disable_slot;
 	}
<span class="p_del">-	udev-&gt;slot_id = xhci-&gt;slot_id;</span>
<span class="p_add">+	udev-&gt;slot_id = slot_id;</span>
 
 #ifndef CONFIG_USB_DEFAULT_PERSIST
 	/*
<span class="p_chunk">@@ -3778,12 +3783,15 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 	struct xhci_slot_ctx *slot_ctx;
 	struct xhci_input_control_ctx *ctrl_ctx;
 	u64 temp_64;
<span class="p_del">-	struct xhci_command *command;</span>
<span class="p_add">+	struct xhci_command *command = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;xhci-&gt;mutex);</span>
 
 	if (!udev-&gt;slot_id) {
 		xhci_dbg_trace(xhci, trace_xhci_dbg_address,
 				&quot;Bad Slot ID %d&quot;, udev-&gt;slot_id);
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	virt_dev = xhci-&gt;devs[udev-&gt;slot_id];
<span class="p_chunk">@@ -3796,7 +3804,8 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 		 */
 		xhci_warn(xhci, &quot;Virt dev invalid for slot_id 0x%x!\n&quot;,
 			udev-&gt;slot_id);
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	if (setup == SETUP_CONTEXT_ONLY) {
<span class="p_chunk">@@ -3804,13 +3813,15 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 		if (GET_SLOT_STATE(le32_to_cpu(slot_ctx-&gt;dev_state)) ==
 		    SLOT_STATE_DEFAULT) {
 			xhci_dbg(xhci, &quot;Slot already in default state\n&quot;);
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto out;</span>
 		}
 	}
 
 	command = xhci_alloc_command(xhci, false, false, GFP_KERNEL);
<span class="p_del">-	if (!command)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	if (!command) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	command-&gt;in_ctx = virt_dev-&gt;in_ctx;
 	command-&gt;completion = &amp;xhci-&gt;addr_dev;
<span class="p_chunk">@@ -3820,8 +3831,8 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 	if (!ctrl_ctx) {
 		xhci_warn(xhci, &quot;%s: Could not get input context, bad type.\n&quot;,
 				__func__);
<span class="p_del">-		kfree(command);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
 	}
 	/*
 	 * If this is the first Set Address since device plug-in or
<span class="p_chunk">@@ -3848,8 +3859,7 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
 		xhci_dbg_trace(xhci, trace_xhci_dbg_address,
 				&quot;FIXME: allocate a command ring segment&quot;);
<span class="p_del">-		kfree(command);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto out;</span>
 	}
 	xhci_ring_cmd_db(xhci);
 	spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_chunk">@@ -3896,10 +3906,8 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 		ret = -EINVAL;
 		break;
 	}
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		kfree(command);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
 	temp_64 = xhci_read_64(xhci, &amp;xhci-&gt;op_regs-&gt;dcbaa_ptr);
 	xhci_dbg_trace(xhci, trace_xhci_dbg_address,
 			&quot;Op regs DCBAA ptr = %#016llx&quot;, temp_64);
<span class="p_chunk">@@ -3932,8 +3940,10 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 	xhci_dbg_trace(xhci, trace_xhci_dbg_address,
 		       &quot;Internal device address = %d&quot;,
 		       le32_to_cpu(slot_ctx-&gt;dev_state) &amp; DEV_ADDR_MASK);
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;xhci-&gt;mutex);</span>
 	kfree(command);
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev)
<span class="p_chunk">@@ -4855,6 +4865,7 @@</span> <span class="p_context"> int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)</span>
 		return 0;
 	}
 
<span class="p_add">+	mutex_init(&amp;xhci-&gt;mutex);</span>
 	xhci-&gt;cap_regs = hcd-&gt;regs;
 	xhci-&gt;op_regs = hcd-&gt;regs +
 		HC_LENGTH(readl(&amp;xhci-&gt;cap_regs-&gt;hc_capbase));
<span class="p_chunk">@@ -5011,4 +5022,12 @@</span> <span class="p_context"> static int __init xhci_hcd_init(void)</span>
 	BUILD_BUG_ON(sizeof(struct xhci_run_regs) != (8+8*128)*32/8);
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * If an init function is provided, an exit function must also be provided</span>
<span class="p_add">+ * to allow module unload.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void __exit xhci_hcd_fini(void) { }</span>
<span class="p_add">+</span>
 module_init(xhci_hcd_init);
<span class="p_add">+module_exit(xhci_hcd_fini);</span>
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index ea75e8ccd3c1..6977f8491fa7 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1497,6 +1497,8 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 	struct list_head	lpm_failed_devs;
 
 	/* slot enabling and address device helpers */
<span class="p_add">+	/* these are not thread safe so use mutex */</span>
<span class="p_add">+	struct mutex mutex;</span>
 	struct completion	addr_dev;
 	int slot_id;
 	/* For USB 3.0 LPM enable/disable. */
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 9031750e7404..ffd739e31bfc 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -128,6 +128,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
 	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8A2A) }, /* HubZ dual ZigBee and Z-Wave dongle */</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 8eb68a31cab6..4c8b3b82103d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -699,6 +699,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_DONGLE_PID) },
 	{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_STATION_PID) },
 	{ USB_DEVICE(XSENS_VID, XSENS_CONVERTER_PID) },
<span class="p_add">+	{ USB_DEVICE(XSENS_VID, XSENS_MTDEVBOARD_PID) },</span>
 	{ USB_DEVICE(XSENS_VID, XSENS_MTW_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_OMNI1509) },
 	{ USB_DEVICE(MOBILITY_VID, MOBILITY_USB_SERIAL_PID) },
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 4e4f46f3c89c..792e054126de 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -155,6 +155,7 @@</span> <span class="p_context"></span>
 #define XSENS_AWINDA_STATION_PID 0x0101
 #define XSENS_AWINDA_DONGLE_PID 0x0102
 #define XSENS_MTW_PID		0x0200	/* Xsens MTw */
<span class="p_add">+#define XSENS_MTDEVBOARD_PID	0x0300	/* Motion Tracker Development Board */</span>
 #define XSENS_CONVERTER_PID	0xD00D	/* Xsens USB-serial converter */
 
 /* Xsens devices using FTDI VID */
<span class="p_header">diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c</span>
<span class="p_header">index e894eb278d83..eba1b7ac7294 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_pci_common.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_pci_common.c</span>
<span class="p_chunk">@@ -423,6 +423,7 @@</span> <span class="p_context"> int vp_set_vq_affinity(struct virtqueue *vq, int cpu)</span>
 		if (cpu == -1)
 			irq_set_affinity_hint(irq, NULL);
 		else {
<span class="p_add">+			cpumask_clear(mask);</span>
 			cpumask_set_cpu(cpu, mask);
 			irq_set_affinity_hint(irq, mask);
 		}
<span class="p_header">diff --git a/fs/aio.c b/fs/aio.c</span>
<span class="p_header">index a793f7023755..a1736e98c278 100644</span>
<span class="p_header">--- a/fs/aio.c</span>
<span class="p_header">+++ b/fs/aio.c</span>
<span class="p_chunk">@@ -77,6 +77,11 @@</span> <span class="p_context"> struct kioctx_cpu {</span>
 	unsigned		reqs_available;
 };
 
<span class="p_add">+struct ctx_rq_wait {</span>
<span class="p_add">+	struct completion comp;</span>
<span class="p_add">+	atomic_t count;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct kioctx {
 	struct percpu_ref	users;
 	atomic_t		dead;
<span class="p_chunk">@@ -115,7 +120,7 @@</span> <span class="p_context"> struct kioctx {</span>
 	/*
 	 * signals when all in-flight requests are done
 	 */
<span class="p_del">-	struct completion *requests_done;</span>
<span class="p_add">+	struct ctx_rq_wait	*rq_wait;</span>
 
 	struct {
 		/*
<span class="p_chunk">@@ -539,8 +544,8 @@</span> <span class="p_context"> static void free_ioctx_reqs(struct percpu_ref *ref)</span>
 	struct kioctx *ctx = container_of(ref, struct kioctx, reqs);
 
 	/* At this point we know that there are no any in-flight requests */
<span class="p_del">-	if (ctx-&gt;requests_done)</span>
<span class="p_del">-		complete(ctx-&gt;requests_done);</span>
<span class="p_add">+	if (ctx-&gt;rq_wait &amp;&amp; atomic_dec_and_test(&amp;ctx-&gt;rq_wait-&gt;count))</span>
<span class="p_add">+		complete(&amp;ctx-&gt;rq_wait-&gt;comp);</span>
 
 	INIT_WORK(&amp;ctx-&gt;free_work, free_ioctx);
 	schedule_work(&amp;ctx-&gt;free_work);
<span class="p_chunk">@@ -751,7 +756,7 @@</span> <span class="p_context"> err:</span>
  *	the rapid destruction of the kioctx.
  */
 static int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,
<span class="p_del">-		struct completion *requests_done)</span>
<span class="p_add">+		      struct ctx_rq_wait *wait)</span>
 {
 	struct kioctx_table *table;
 
<span class="p_chunk">@@ -781,7 +786,7 @@</span> <span class="p_context"> static int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,</span>
 	if (ctx-&gt;mmap_size)
 		vm_munmap(ctx-&gt;mmap_base, ctx-&gt;mmap_size);
 
<span class="p_del">-	ctx-&gt;requests_done = requests_done;</span>
<span class="p_add">+	ctx-&gt;rq_wait = wait;</span>
 	percpu_ref_kill(&amp;ctx-&gt;users);
 	return 0;
 }
<span class="p_chunk">@@ -813,18 +818,24 @@</span> <span class="p_context"> EXPORT_SYMBOL(wait_on_sync_kiocb);</span>
 void exit_aio(struct mm_struct *mm)
 {
 	struct kioctx_table *table = rcu_dereference_raw(mm-&gt;ioctx_table);
<span class="p_del">-	int i;</span>
<span class="p_add">+	struct ctx_rq_wait wait;</span>
<span class="p_add">+	int i, skipped;</span>
 
 	if (!table)
 		return;
 
<span class="p_add">+	atomic_set(&amp;wait.count, table-&gt;nr);</span>
<span class="p_add">+	init_completion(&amp;wait.comp);</span>
<span class="p_add">+</span>
<span class="p_add">+	skipped = 0;</span>
 	for (i = 0; i &lt; table-&gt;nr; ++i) {
 		struct kioctx *ctx = table-&gt;table[i];
<span class="p_del">-		struct completion requests_done =</span>
<span class="p_del">-			COMPLETION_INITIALIZER_ONSTACK(requests_done);</span>
 
<span class="p_del">-		if (!ctx)</span>
<span class="p_add">+		if (!ctx) {</span>
<span class="p_add">+			skipped++;</span>
 			continue;
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/*
 		 * We don&#39;t need to bother with munmap() here - exit_mmap(mm)
 		 * is coming and it&#39;ll unmap everything. And we simply can&#39;t,
<span class="p_chunk">@@ -833,10 +844,12 @@</span> <span class="p_context"> void exit_aio(struct mm_struct *mm)</span>
 		 * that it needs to unmap the area, just set it to 0.
 		 */
 		ctx-&gt;mmap_size = 0;
<span class="p_del">-		kill_ioctx(mm, ctx, &amp;requests_done);</span>
<span class="p_add">+		kill_ioctx(mm, ctx, &amp;wait);</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	if (!atomic_sub_and_test(skipped, &amp;wait.count)) {</span>
 		/* Wait until all IO for the context are done. */
<span class="p_del">-		wait_for_completion(&amp;requests_done);</span>
<span class="p_add">+		wait_for_completion(&amp;wait.comp);</span>
 	}
 
 	RCU_INIT_POINTER(mm-&gt;ioctx_table, NULL);
<span class="p_chunk">@@ -1321,15 +1334,17 @@</span> <span class="p_context"> SYSCALL_DEFINE1(io_destroy, aio_context_t, ctx)</span>
 {
 	struct kioctx *ioctx = lookup_ioctx(ctx);
 	if (likely(NULL != ioctx)) {
<span class="p_del">-		struct completion requests_done =</span>
<span class="p_del">-			COMPLETION_INITIALIZER_ONSTACK(requests_done);</span>
<span class="p_add">+		struct ctx_rq_wait wait;</span>
 		int ret;
 
<span class="p_add">+		init_completion(&amp;wait.comp);</span>
<span class="p_add">+		atomic_set(&amp;wait.count, 1);</span>
<span class="p_add">+</span>
 		/* Pass requests_done to kill_ioctx() where it can be set
 		 * in a thread-safe way. If we try to set it here then we have
 		 * a race condition if two io_destroy() called simultaneously.
 		 */
<span class="p_del">-		ret = kill_ioctx(current-&gt;mm, ioctx, &amp;requests_done);</span>
<span class="p_add">+		ret = kill_ioctx(current-&gt;mm, ioctx, &amp;wait);</span>
 		percpu_ref_put(&amp;ioctx-&gt;users);
 
 		/* Wait until all IO for the context are done. Otherwise kernel
<span class="p_chunk">@@ -1337,7 +1352,7 @@</span> <span class="p_context"> SYSCALL_DEFINE1(io_destroy, aio_context_t, ctx)</span>
 		 * is destroyed.
 		 */
 		if (!ret)
<span class="p_del">-			wait_for_completion(&amp;requests_done);</span>
<span class="p_add">+			wait_for_completion(&amp;wait.comp);</span>
 
 		return ret;
 	}
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 8b33da6ec3dd..63be2a96ed6a 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -8535,6 +8535,24 @@</span> <span class="p_context"> int btrfs_set_block_group_ro(struct btrfs_root *root,</span>
 	trans = btrfs_join_transaction(root);
 	if (IS_ERR(trans))
 		return PTR_ERR(trans);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * if we are changing raid levels, try to allocate a corresponding</span>
<span class="p_add">+	 * block group with the new raid level.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	alloc_flags = update_block_group_flags(root, cache-&gt;flags);</span>
<span class="p_add">+	if (alloc_flags != cache-&gt;flags) {</span>
<span class="p_add">+		ret = do_chunk_alloc(trans, root, alloc_flags,</span>
<span class="p_add">+				     CHUNK_ALLOC_FORCE);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * ENOSPC is allowed here, we may have enough space</span>
<span class="p_add">+		 * already allocated at the new raid level to</span>
<span class="p_add">+		 * carry on</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (ret == -ENOSPC)</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+	}</span>
 
 	ret = set_block_group_ro(cache, 0);
 	if (!ret)
<span class="p_header">diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c</span>
<span class="p_header">index d688cfe5d496..782f3bc4651d 100644</span>
<span class="p_header">--- a/fs/btrfs/extent_io.c</span>
<span class="p_header">+++ b/fs/btrfs/extent_io.c</span>
<span class="p_chunk">@@ -4514,8 +4514,11 @@</span> <span class="p_context"> int extent_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,</span>
 		}
 		ret = fiemap_fill_next_extent(fieinfo, em_start, disko,
 					      em_len, flags);
<span class="p_del">-		if (ret)</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			if (ret == 1)</span>
<span class="p_add">+				ret = 0;</span>
 			goto out_free;
<span class="p_add">+		}</span>
 	}
 out_free:
 	free_extent_map(em);
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 2b4c5423672d..64e8fb639f72 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -3206,6 +3206,8 @@</span> <span class="p_context"> static int btrfs_clone(struct inode *src, struct inode *inode,</span>
 	key.offset = off;
 
 	while (1) {
<span class="p_add">+		u64 next_key_min_offset = key.offset + 1;</span>
<span class="p_add">+</span>
 		/*
 		 * note the key will change type as we walk through the
 		 * tree.
<span class="p_chunk">@@ -3286,7 +3288,7 @@</span> <span class="p_context"> process_slot:</span>
 			} else if (key.offset &gt;= off + len) {
 				break;
 			}
<span class="p_del">-</span>
<span class="p_add">+			next_key_min_offset = key.offset + datal;</span>
 			size = btrfs_item_size_nr(leaf, slot);
 			read_extent_buffer(leaf, buf,
 					   btrfs_item_ptr_offset(leaf, slot),
<span class="p_chunk">@@ -3501,7 +3503,7 @@</span> <span class="p_context"> process_slot:</span>
 				break;
 		}
 		btrfs_release_path(path);
<span class="p_del">-		key.offset++;</span>
<span class="p_add">+		key.offset = next_key_min_offset;</span>
 	}
 	ret = 0;
 
<span class="p_header">diff --git a/fs/btrfs/send.c b/fs/btrfs/send.c</span>
<span class="p_header">index d6033f540cc7..571de5a08fe7 100644</span>
<span class="p_header">--- a/fs/btrfs/send.c</span>
<span class="p_header">+++ b/fs/btrfs/send.c</span>
<span class="p_chunk">@@ -5852,19 +5852,20 @@</span> <span class="p_context"> long btrfs_ioctl_send(struct file *mnt_file, void __user *arg_)</span>
 				ret = PTR_ERR(clone_root);
 				goto out;
 			}
<span class="p_del">-			clone_sources_to_rollback = i + 1;</span>
 			spin_lock(&amp;clone_root-&gt;root_item_lock);
<span class="p_del">-			clone_root-&gt;send_in_progress++;</span>
<span class="p_del">-			if (!btrfs_root_readonly(clone_root)) {</span>
<span class="p_add">+			if (!btrfs_root_readonly(clone_root) ||</span>
<span class="p_add">+			    btrfs_root_dead(clone_root)) {</span>
 				spin_unlock(&amp;clone_root-&gt;root_item_lock);
 				srcu_read_unlock(&amp;fs_info-&gt;subvol_srcu, index);
 				ret = -EPERM;
 				goto out;
 			}
<span class="p_add">+			clone_root-&gt;send_in_progress++;</span>
 			spin_unlock(&amp;clone_root-&gt;root_item_lock);
 			srcu_read_unlock(&amp;fs_info-&gt;subvol_srcu, index);
 
 			sctx-&gt;clone_roots[i].root = clone_root;
<span class="p_add">+			clone_sources_to_rollback = i + 1;</span>
 		}
 		vfree(clone_sources_tmp);
 		clone_sources_tmp = NULL;
<span class="p_header">diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c</span>
<span class="p_header">index 05fef198ff94..e477ed67a49a 100644</span>
<span class="p_header">--- a/fs/btrfs/super.c</span>
<span class="p_header">+++ b/fs/btrfs/super.c</span>
<span class="p_chunk">@@ -901,6 +901,15 @@</span> <span class="p_context"> find_root:</span>
 	if (IS_ERR(new_root))
 		return ERR_CAST(new_root);
 
<span class="p_add">+	if (!(sb-&gt;s_flags &amp; MS_RDONLY)) {</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+		down_read(&amp;fs_info-&gt;cleanup_work_sem);</span>
<span class="p_add">+		ret = btrfs_orphan_cleanup(new_root);</span>
<span class="p_add">+		up_read(&amp;fs_info-&gt;cleanup_work_sem);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ERR_PTR(ret);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dir_id = btrfs_root_dirid(&amp;new_root-&gt;root_item);
 setup_root:
 	location.objectid = dir_id;
<span class="p_header">diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h</span>
<span class="p_header">index aff923ae8c4b..d87d8eced064 100644</span>
<span class="p_header">--- a/include/linux/backing-dev.h</span>
<span class="p_header">+++ b/include/linux/backing-dev.h</span>
<span class="p_chunk">@@ -116,7 +116,6 @@</span> <span class="p_context"> __printf(3, 4)</span>
 int bdi_register(struct backing_dev_info *bdi, struct device *parent,
 		const char *fmt, ...);
 int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev);
<span class="p_del">-void bdi_unregister(struct backing_dev_info *bdi);</span>
 int __must_check bdi_setup_and_register(struct backing_dev_info *, char *);
 void bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,
 			enum wb_reason reason);
<span class="p_header">diff --git a/include/net/inet_connection_sock.h b/include/net/inet_connection_sock.h</span>
<span class="p_header">index 5976bdecf58b..9fe865ccc3f3 100644</span>
<span class="p_header">--- a/include/net/inet_connection_sock.h</span>
<span class="p_header">+++ b/include/net/inet_connection_sock.h</span>
<span class="p_chunk">@@ -98,7 +98,8 @@</span> <span class="p_context"> struct inet_connection_sock {</span>
 	const struct tcp_congestion_ops *icsk_ca_ops;
 	const struct inet_connection_sock_af_ops *icsk_af_ops;
 	unsigned int		  (*icsk_sync_mss)(struct sock *sk, u32 pmtu);
<span class="p_del">-	__u8			  icsk_ca_state:7,</span>
<span class="p_add">+	__u8			  icsk_ca_state:6,</span>
<span class="p_add">+				  icsk_ca_setsockopt:1,</span>
 				  icsk_ca_dst_locked:1;
 	__u8			  icsk_retransmits;
 	__u8			  icsk_pending;
<span class="p_header">diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h</span>
<span class="p_header">index 856f01cb51dd..230775f5952a 100644</span>
<span class="p_header">--- a/include/net/sctp/sctp.h</span>
<span class="p_header">+++ b/include/net/sctp/sctp.h</span>
<span class="p_chunk">@@ -571,11 +571,14 @@</span> <span class="p_context"> static inline void sctp_v6_map_v4(union sctp_addr *addr)</span>
 /* Map v4 address to v4-mapped v6 address */
 static inline void sctp_v4_map_v6(union sctp_addr *addr)
 {
<span class="p_add">+	__be16 port;</span>
<span class="p_add">+</span>
<span class="p_add">+	port = addr-&gt;v4.sin_port;</span>
<span class="p_add">+	addr-&gt;v6.sin6_addr.s6_addr32[3] = addr-&gt;v4.sin_addr.s_addr;</span>
<span class="p_add">+	addr-&gt;v6.sin6_port = port;</span>
 	addr-&gt;v6.sin6_family = AF_INET6;
 	addr-&gt;v6.sin6_flowinfo = 0;
 	addr-&gt;v6.sin6_scope_id = 0;
<span class="p_del">-	addr-&gt;v6.sin6_port = addr-&gt;v4.sin_port;</span>
<span class="p_del">-	addr-&gt;v6.sin6_addr.s6_addr32[3] = addr-&gt;v4.sin_addr.s_addr;</span>
 	addr-&gt;v6.sin6_addr.s6_addr32[0] = 0;
 	addr-&gt;v6.sin6_addr.s6_addr32[1] = 0;
 	addr-&gt;v6.sin6_addr.s6_addr32[2] = htonl(0x0000ffff);
<span class="p_header">diff --git a/include/trace/events/writeback.h b/include/trace/events/writeback.h</span>
<span class="p_header">index 5a14ead59696..885d3a380451 100644</span>
<span class="p_header">--- a/include/trace/events/writeback.h</span>
<span class="p_header">+++ b/include/trace/events/writeback.h</span>
<span class="p_chunk">@@ -233,7 +233,6 @@</span> <span class="p_context"> DEFINE_EVENT(writeback_class, name, \</span>
 DEFINE_WRITEBACK_EVENT(writeback_nowork);
 DEFINE_WRITEBACK_EVENT(writeback_wake_background);
 DEFINE_WRITEBACK_EVENT(writeback_bdi_register);
<span class="p_del">-DEFINE_WRITEBACK_EVENT(writeback_bdi_unregister);</span>
 
 DECLARE_EVENT_CLASS(wbc_class,
 	TP_PROTO(struct writeback_control *wbc, struct backing_dev_info *bdi),
<span class="p_header">diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c</span>
<span class="p_header">index 241213be507c..486d00c408b0 100644</span>
<span class="p_header">--- a/kernel/sched/fair.c</span>
<span class="p_header">+++ b/kernel/sched/fair.c</span>
<span class="p_chunk">@@ -2166,7 +2166,7 @@</span> <span class="p_context"> void task_numa_work(struct callback_head *work)</span>
 	}
 	for (; vma; vma = vma-&gt;vm_next) {
 		if (!vma_migratable(vma) || !vma_policy_mof(vma) ||
<span class="p_del">-			is_vm_hugetlb_page(vma)) {</span>
<span class="p_add">+			is_vm_hugetlb_page(vma) || (vma-&gt;vm_flags &amp; VM_MIXEDMAP)) {</span>
 			continue;
 		}
 
<span class="p_header">diff --git a/kernel/trace/ring_buffer_benchmark.c b/kernel/trace/ring_buffer_benchmark.c</span>
<span class="p_header">index 13d945c0d03f..1b28df2d9104 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer_benchmark.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer_benchmark.c</span>
<span class="p_chunk">@@ -450,7 +450,7 @@</span> <span class="p_context"> static int __init ring_buffer_benchmark_init(void)</span>
 
 	if (producer_fifo &gt;= 0) {
 		struct sched_param param = {
<span class="p_del">-			.sched_priority = consumer_fifo</span>
<span class="p_add">+			.sched_priority = producer_fifo</span>
 		};
 		sched_setscheduler(producer, SCHED_FIFO, &amp;param);
 	} else
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index 6dc4580df2af..000e7b3b9896 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -359,23 +359,6 @@</span> <span class="p_context"> static void bdi_wb_shutdown(struct backing_dev_info *bdi)</span>
 	flush_delayed_work(&amp;bdi-&gt;wb.dwork);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Called when the device behind @bdi has been removed or ejected.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We can&#39;t really do much here except for reducing the dirty ratio at</span>
<span class="p_del">- * the moment.  In the future we should be able to set a flag so that</span>
<span class="p_del">- * the filesystem can handle errors at mark_inode_dirty time instead</span>
<span class="p_del">- * of only at writeback time.</span>
<span class="p_del">- */</span>
<span class="p_del">-void bdi_unregister(struct backing_dev_info *bdi)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (WARN_ON_ONCE(!bdi-&gt;dev))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	bdi_set_min_ratio(bdi, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(bdi_unregister);</span>
<span class="p_del">-</span>
 static void bdi_wb_init(struct bdi_writeback *wb, struct backing_dev_info *bdi)
 {
 	memset(wb, 0, sizeof(*wb));
<span class="p_chunk">@@ -443,6 +426,7 @@</span> <span class="p_context"> void bdi_destroy(struct backing_dev_info *bdi)</span>
 	int i;
 
 	bdi_wb_shutdown(bdi);
<span class="p_add">+	bdi_set_min_ratio(bdi, 0);</span>
 
 	WARN_ON(!list_empty(&amp;bdi-&gt;work_list));
 	WARN_ON(delayed_work_pending(&amp;bdi-&gt;wb.dwork));
<span class="p_header">diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c</span>
<span class="p_header">index 65842d688b7c..93caba791cde 100644</span>
<span class="p_header">--- a/mm/memory_hotplug.c</span>
<span class="p_header">+++ b/mm/memory_hotplug.c</span>
<span class="p_chunk">@@ -1978,8 +1978,10 @@</span> <span class="p_context"> void try_offline_node(int nid)</span>
 		 * wait_table may be allocated from boot memory,
 		 * here only free if it&#39;s allocated by vmalloc.
 		 */
<span class="p_del">-		if (is_vmalloc_addr(zone-&gt;wait_table))</span>
<span class="p_add">+		if (is_vmalloc_addr(zone-&gt;wait_table)) {</span>
 			vfree(zone-&gt;wait_table);
<span class="p_add">+			zone-&gt;wait_table = NULL;</span>
<span class="p_add">+		}</span>
 	}
 }
 EXPORT_SYMBOL(try_offline_node);
<span class="p_header">diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c</span>
<span class="p_header">index e0670d7054f9..659fb96672e4 100644</span>
<span class="p_header">--- a/net/bridge/br_fdb.c</span>
<span class="p_header">+++ b/net/bridge/br_fdb.c</span>
<span class="p_chunk">@@ -796,9 +796,11 @@</span> <span class="p_context"> static int __br_fdb_add(struct ndmsg *ndm, struct net_bridge_port *p,</span>
 	int err = 0;
 
 	if (ndm-&gt;ndm_flags &amp; NTF_USE) {
<span class="p_add">+		local_bh_disable();</span>
 		rcu_read_lock();
 		br_fdb_update(p-&gt;br, p, addr, vid, true);
 		rcu_read_unlock();
<span class="p_add">+		local_bh_enable();</span>
 	} else {
 		spin_lock_bh(&amp;p-&gt;br-&gt;hash_lock);
 		err = fdb_add_entry(p, addr, ndm-&gt;ndm_state,
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index c465876c7861..b0aee78dba41 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -1071,7 +1071,7 @@</span> <span class="p_context"> static int br_ip6_multicast_mld2_report(struct net_bridge *br,</span>
 
 		err = br_ip6_multicast_add_group(br, port, &amp;grec-&gt;grec_mca,
 						 vid);
<span class="p_del">-		if (!err)</span>
<span class="p_add">+		if (err)</span>
 			break;
 	}
 
<span class="p_chunk">@@ -1821,7 +1821,7 @@</span> <span class="p_context"> static void br_multicast_query_expired(struct net_bridge *br,</span>
 	if (query-&gt;startup_sent &lt; br-&gt;multicast_startup_query_count)
 		query-&gt;startup_sent++;
 
<span class="p_del">-	RCU_INIT_POINTER(querier, NULL);</span>
<span class="p_add">+	RCU_INIT_POINTER(querier-&gt;port, NULL);</span>
 	br_multicast_send_query(br, NULL, query);
 	spin_unlock(&amp;br-&gt;multicast_lock);
 }
<span class="p_header">diff --git a/net/caif/caif_socket.c b/net/caif/caif_socket.c</span>
<span class="p_header">index a6e2da0bc718..982101c12258 100644</span>
<span class="p_header">--- a/net/caif/caif_socket.c</span>
<span class="p_header">+++ b/net/caif/caif_socket.c</span>
<span class="p_chunk">@@ -330,6 +330,10 @@</span> <span class="p_context"> static long caif_stream_data_wait(struct sock *sk, long timeo)</span>
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
<span class="p_add">+</span>
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		clear_bit(SOCK_ASYNC_WAITDATA, &amp;sk-&gt;sk_socket-&gt;flags);
 	}
 
<span class="p_chunk">@@ -374,6 +378,10 @@</span> <span class="p_context"> static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 		struct sk_buff *skb;
 
 		lock_sock(sk);
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD)) {</span>
<span class="p_add">+			err = -ECONNRESET;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
 		skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue);
 		caif_check_flow_release(sk);
 
<span class="p_header">diff --git a/net/ceph/crush/mapper.c b/net/ceph/crush/mapper.c</span>
<span class="p_header">index a1ef53c04415..b1f2d1f44d37 100644</span>
<span class="p_header">--- a/net/ceph/crush/mapper.c</span>
<span class="p_header">+++ b/net/ceph/crush/mapper.c</span>
<span class="p_chunk">@@ -290,6 +290,7 @@</span> <span class="p_context"> static int is_out(const struct crush_map *map,</span>
  * @type: the type of item to choose
  * @out: pointer to output vector
  * @outpos: our position in that vector
<span class="p_add">+ * @out_size: size of the out vector</span>
  * @tries: number of attempts to make
  * @recurse_tries: number of attempts to have recursive chooseleaf make
  * @local_retries: localized retries
<span class="p_chunk">@@ -304,6 +305,7 @@</span> <span class="p_context"> static int crush_choose_firstn(const struct crush_map *map,</span>
 			       const __u32 *weight, int weight_max,
 			       int x, int numrep, int type,
 			       int *out, int outpos,
<span class="p_add">+			       int out_size,</span>
 			       unsigned int tries,
 			       unsigned int recurse_tries,
 			       unsigned int local_retries,
<span class="p_chunk">@@ -322,6 +324,7 @@</span> <span class="p_context"> static int crush_choose_firstn(const struct crush_map *map,</span>
 	int item = 0;
 	int itemtype;
 	int collide, reject;
<span class="p_add">+	int count = out_size;</span>
 
 	dprintk(&quot;CHOOSE%s bucket %d x %d outpos %d numrep %d tries %d recurse_tries %d local_retries %d local_fallback_retries %d parent_r %d\n&quot;,
 		recurse_to_leaf ? &quot;_LEAF&quot; : &quot;&quot;,
<span class="p_chunk">@@ -329,7 +332,7 @@</span> <span class="p_context"> static int crush_choose_firstn(const struct crush_map *map,</span>
 		tries, recurse_tries, local_retries, local_fallback_retries,
 		parent_r);
 
<span class="p_del">-	for (rep = outpos; rep &lt; numrep; rep++) {</span>
<span class="p_add">+	for (rep = outpos; rep &lt; numrep &amp;&amp; count &gt; 0 ; rep++) {</span>
 		/* keep trying until we get a non-out, non-colliding item */
 		ftotal = 0;
 		skip_rep = 0;
<span class="p_chunk">@@ -403,7 +406,7 @@</span> <span class="p_context"> static int crush_choose_firstn(const struct crush_map *map,</span>
 							 map-&gt;buckets[-1-item],
 							 weight, weight_max,
 							 x, outpos+1, 0,
<span class="p_del">-							 out2, outpos,</span>
<span class="p_add">+							 out2, outpos, count,</span>
 							 recurse_tries, 0,
 							 local_retries,
 							 local_fallback_retries,
<span class="p_chunk">@@ -463,6 +466,7 @@</span> <span class="p_context"> reject:</span>
 		dprintk(&quot;CHOOSE got %d\n&quot;, item);
 		out[outpos] = item;
 		outpos++;
<span class="p_add">+		count--;</span>
 	}
 
 	dprintk(&quot;CHOOSE returns %d\n&quot;, outpos);
<span class="p_chunk">@@ -654,6 +658,7 @@</span> <span class="p_context"> int crush_do_rule(const struct crush_map *map,</span>
 	__u32 step;
 	int i, j;
 	int numrep;
<span class="p_add">+	int out_size;</span>
 	/*
 	 * the original choose_total_tries value was off by one (it
 	 * counted &quot;retries&quot; and not &quot;tries&quot;).  add one.
<span class="p_chunk">@@ -761,6 +766,7 @@</span> <span class="p_context"> int crush_do_rule(const struct crush_map *map,</span>
 						x, numrep,
 						curstep-&gt;arg2,
 						o+osize, j,
<span class="p_add">+						result_max-osize,</span>
 						choose_tries,
 						recurse_tries,
 						choose_local_retries,
<span class="p_chunk">@@ -770,11 +776,13 @@</span> <span class="p_context"> int crush_do_rule(const struct crush_map *map,</span>
 						c+osize,
 						0);
 				} else {
<span class="p_add">+					out_size = ((numrep &lt; (result_max-osize)) ?</span>
<span class="p_add">+                                                    numrep : (result_max-osize));</span>
 					crush_choose_indep(
 						map,
 						map-&gt;buckets[-1-w[i]],
 						weight, weight_max,
<span class="p_del">-						x, numrep, numrep,</span>
<span class="p_add">+						x, out_size, numrep,</span>
 						curstep-&gt;arg2,
 						o+osize, j,
 						choose_tries,
<span class="p_chunk">@@ -783,7 +791,7 @@</span> <span class="p_context"> int crush_do_rule(const struct crush_map *map,</span>
 						recurse_to_leaf,
 						c+osize,
 						0);
<span class="p_del">-					osize += numrep;</span>
<span class="p_add">+					osize += out_size;</span>
 				}
 			}
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 22a53acdb5bb..e977e15c2ac0 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -5170,7 +5170,7 @@</span> <span class="p_context"> static int __netdev_upper_dev_link(struct net_device *dev,</span>
 	if (__netdev_find_adj(upper_dev, dev, &amp;upper_dev-&gt;all_adj_list.upper))
 		return -EBUSY;
 
<span class="p_del">-	if (__netdev_find_adj(dev, upper_dev, &amp;dev-&gt;all_adj_list.upper))</span>
<span class="p_add">+	if (__netdev_find_adj(dev, upper_dev, &amp;dev-&gt;adj_list.upper))</span>
 		return -EEXIST;
 
 	if (master &amp;&amp; netdev_master_upper_dev_get(dev))
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 7ebed55b5f7d..a2b90e1fc115 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -2337,6 +2337,9 @@</span> <span class="p_context"> void rtmsg_ifinfo(int type, struct net_device *dev, unsigned int change,</span>
 {
 	struct sk_buff *skb;
 
<span class="p_add">+	if (dev-&gt;reg_state != NETREG_REGISTERED)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	skb = rtmsg_ifinfo_build_skb(type, dev, change, flags);
 	if (skb)
 		rtmsg_ifinfo_send(skb, dev, flags);
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 20fc0202cbbe..e262a087050b 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -903,6 +903,10 @@</span> <span class="p_context"> static int ip_error(struct sk_buff *skb)</span>
 	bool send;
 	int code;
 
<span class="p_add">+	/* IP on this device is disabled. */</span>
<span class="p_add">+	if (!in_dev)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	net = dev_net(rt-&gt;dst.dev);
 	if (!IN_DEV_FORWARD(in_dev)) {
 		switch (rt-&gt;dst.error) {
<span class="p_header">diff --git a/net/ipv4/tcp_cong.c b/net/ipv4/tcp_cong.c</span>
<span class="p_header">index 62856e185a93..9d2fbd88df93 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_cong.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_cong.c</span>
<span class="p_chunk">@@ -187,6 +187,7 @@</span> <span class="p_context"> static void tcp_reinit_congestion_control(struct sock *sk,</span>
 
 	tcp_cleanup_congestion_control(sk);
 	icsk-&gt;icsk_ca_ops = ca;
<span class="p_add">+	icsk-&gt;icsk_ca_setsockopt = 1;</span>
 
 	if (sk-&gt;sk_state != TCP_CLOSE &amp;&amp; icsk-&gt;icsk_ca_ops-&gt;init)
 		icsk-&gt;icsk_ca_ops-&gt;init(sk);
<span class="p_chunk">@@ -335,8 +336,10 @@</span> <span class="p_context"> int tcp_set_congestion_control(struct sock *sk, const char *name)</span>
 	rcu_read_lock();
 	ca = __tcp_ca_find_autoload(name);
 	/* No change asking for existing value */
<span class="p_del">-	if (ca == icsk-&gt;icsk_ca_ops)</span>
<span class="p_add">+	if (ca == icsk-&gt;icsk_ca_ops) {</span>
<span class="p_add">+		icsk-&gt;icsk_ca_setsockopt = 1;</span>
 		goto out;
<span class="p_add">+	}</span>
 	if (!ca)
 		err = -ENOENT;
 	else if (!((ca-&gt;flags &amp; TCP_CONG_NON_RESTRICTED) ||
<span class="p_header">diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">index dd11ac7798c6..50277af92485 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_minisocks.c</span>
<span class="p_chunk">@@ -316,7 +316,7 @@</span> <span class="p_context"> void tcp_time_wait(struct sock *sk, int state, int timeo)</span>
 			tw-&gt;tw_v6_daddr = sk-&gt;sk_v6_daddr;
 			tw-&gt;tw_v6_rcv_saddr = sk-&gt;sk_v6_rcv_saddr;
 			tw-&gt;tw_tclass = np-&gt;tclass;
<span class="p_del">-			tw-&gt;tw_flowlabel = np-&gt;flow_label &gt;&gt; 12;</span>
<span class="p_add">+			tw-&gt;tw_flowlabel = be32_to_cpu(np-&gt;flow_label &amp; IPV6_FLOWLABEL_MASK);</span>
 			tw-&gt;tw_ipv6only = sk-&gt;sk_ipv6only;
 		}
 #endif
<span class="p_chunk">@@ -437,7 +437,10 @@</span> <span class="p_context"> void tcp_ca_openreq_child(struct sock *sk, const struct dst_entry *dst)</span>
 		rcu_read_unlock();
 	}
 
<span class="p_del">-	if (!ca_got_dst &amp;&amp; !try_module_get(icsk-&gt;icsk_ca_ops-&gt;owner))</span>
<span class="p_add">+	/* If no valid choice made yet, assign current system default ca. */</span>
<span class="p_add">+	if (!ca_got_dst &amp;&amp;</span>
<span class="p_add">+	    (!icsk-&gt;icsk_ca_setsockopt ||</span>
<span class="p_add">+	     !try_module_get(icsk-&gt;icsk_ca_ops-&gt;owner)))</span>
 		tcp_assign_congestion_control(sk);
 
 	tcp_set_ca_state(sk, TCP_CA_Open);
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 97ef1f8b7be8..51f17454bd7b 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -90,6 +90,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/socket.h&gt;
 #include &lt;linux/sockios.h&gt;
 #include &lt;linux/igmp.h&gt;
<span class="p_add">+#include &lt;linux/inetdevice.h&gt;</span>
 #include &lt;linux/in.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/timer.h&gt;
<span class="p_chunk">@@ -1348,10 +1349,8 @@</span> <span class="p_context"> csum_copy_err:</span>
 	}
 	unlock_sock_fast(sk, slow);
 
<span class="p_del">-	if (noblock)</span>
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* starting over for a new packet */</span>
<span class="p_add">+	/* starting over for a new packet, but check if we need to yield */</span>
<span class="p_add">+	cond_resched();</span>
 	msg-&gt;msg_flags &amp;= ~MSG_TRUNC;
 	goto try_again;
 }
<span class="p_chunk">@@ -1968,6 +1967,7 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 	struct sock *sk;
 	struct dst_entry *dst;
 	int dif = skb-&gt;dev-&gt;ifindex;
<span class="p_add">+	int ours;</span>
 
 	/* validate the packet */
 	if (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct udphdr)))
<span class="p_chunk">@@ -1977,14 +1977,24 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 	uh = udp_hdr(skb);
 
 	if (skb-&gt;pkt_type == PACKET_BROADCAST ||
<span class="p_del">-	    skb-&gt;pkt_type == PACKET_MULTICAST)</span>
<span class="p_add">+	    skb-&gt;pkt_type == PACKET_MULTICAST) {</span>
<span class="p_add">+		struct in_device *in_dev = __in_dev_get_rcu(skb-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!in_dev)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
<span class="p_add">+		ours = ip_check_mc_rcu(in_dev, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_add">+				       iph-&gt;protocol);</span>
<span class="p_add">+		if (!ours)</span>
<span class="p_add">+			return;</span>
 		sk = __udp4_lib_mcast_demux_lookup(net, uh-&gt;dest, iph-&gt;daddr,
 						   uh-&gt;source, iph-&gt;saddr, dif);
<span class="p_del">-	else if (skb-&gt;pkt_type == PACKET_HOST)</span>
<span class="p_add">+	} else if (skb-&gt;pkt_type == PACKET_HOST) {</span>
 		sk = __udp4_lib_demux_lookup(net, uh-&gt;dest, iph-&gt;daddr,
 					     uh-&gt;source, iph-&gt;saddr, dif);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		return;
<span class="p_add">+	}</span>
 
 	if (!sk)
 		return;
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 1f5e62229aaa..5ca3bc880fef 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -975,7 +975,7 @@</span> <span class="p_context"> static void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)</span>
 			tcptw-&gt;tw_rcv_wnd &gt;&gt; tw-&gt;tw_rcv_wscale,
 			tcp_time_stamp + tcptw-&gt;tw_ts_offset,
 			tcptw-&gt;tw_ts_recent, tw-&gt;tw_bound_dev_if, tcp_twsk_md5_key(tcptw),
<span class="p_del">-			tw-&gt;tw_tclass, (tw-&gt;tw_flowlabel &lt;&lt; 12));</span>
<span class="p_add">+			tw-&gt;tw_tclass, cpu_to_be32(tw-&gt;tw_flowlabel));</span>
 
 	inet_twsk_put(tw);
 }
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index d048d46779fc..1c9512aba77e 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -528,10 +528,8 @@</span> <span class="p_context"> csum_copy_err:</span>
 	}
 	unlock_sock_fast(sk, slow);
 
<span class="p_del">-	if (noblock)</span>
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* starting over for a new packet */</span>
<span class="p_add">+	/* starting over for a new packet, but check if we need to yield */</span>
<span class="p_add">+	cond_resched();</span>
 	msg-&gt;msg_flags &amp;= ~MSG_TRUNC;
 	goto try_again;
 }
<span class="p_chunk">@@ -734,7 +732,9 @@</span> <span class="p_context"> static bool __udp_v6_is_mcast_sock(struct net *net, struct sock *sk,</span>
 	    (inet-&gt;inet_dport &amp;&amp; inet-&gt;inet_dport != rmt_port) ||
 	    (!ipv6_addr_any(&amp;sk-&gt;sk_v6_daddr) &amp;&amp;
 		    !ipv6_addr_equal(&amp;sk-&gt;sk_v6_daddr, rmt_addr)) ||
<span class="p_del">-	    (sk-&gt;sk_bound_dev_if &amp;&amp; sk-&gt;sk_bound_dev_if != dif))</span>
<span class="p_add">+	    (sk-&gt;sk_bound_dev_if &amp;&amp; sk-&gt;sk_bound_dev_if != dif) ||</span>
<span class="p_add">+	    (!ipv6_addr_any(&amp;sk-&gt;sk_v6_rcv_saddr) &amp;&amp;</span>
<span class="p_add">+		    !ipv6_addr_equal(&amp;sk-&gt;sk_v6_rcv_saddr, loc_addr)))</span>
 		return false;
 	if (!inet6_mc_check(sk, loc_addr, rmt_addr))
 		return false;
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index d1d7a8166f46..0e9c28dc86b7 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -1052,7 +1052,7 @@</span> <span class="p_context"> static int netlink_insert(struct sock *sk, u32 portid)</span>
 	struct netlink_table *table = &amp;nl_table[sk-&gt;sk_protocol];
 	int err;
 
<span class="p_del">-	lock_sock(sk);</span>
<span class="p_add">+	mutex_lock(&amp;table-&gt;hash.mutex);</span>
 
 	err = -EBUSY;
 	if (nlk_sk(sk)-&gt;portid)
<span class="p_chunk">@@ -1069,11 +1069,12 @@</span> <span class="p_context"> static int netlink_insert(struct sock *sk, u32 portid)</span>
 	err = 0;
 	if (!__netlink_insert(table, sk)) {
 		err = -EADDRINUSE;
<span class="p_add">+		nlk_sk(sk)-&gt;portid = 0;</span>
 		sock_put(sk);
 	}
 
 err:
<span class="p_del">-	release_sock(sk);</span>
<span class="p_add">+	mutex_unlock(&amp;table-&gt;hash.mutex);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1082,10 +1083,12 @@</span> <span class="p_context"> static void netlink_remove(struct sock *sk)</span>
 	struct netlink_table *table;
 
 	table = &amp;nl_table[sk-&gt;sk_protocol];
<span class="p_add">+	mutex_lock(&amp;table-&gt;hash.mutex);</span>
 	if (rhashtable_remove(&amp;table-&gt;hash, &amp;nlk_sk(sk)-&gt;node)) {
 		WARN_ON(atomic_read(&amp;sk-&gt;sk_refcnt) == 1);
 		__sock_put(sk);
 	}
<span class="p_add">+	mutex_unlock(&amp;table-&gt;hash.mutex);</span>
 
 	netlink_table_grab();
 	if (nlk_sk(sk)-&gt;subscriptions) {
<span class="p_header">diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c</span>
<span class="p_header">index baef987fe2c0..d3328a19f5b2 100644</span>
<span class="p_header">--- a/net/sched/cls_api.c</span>
<span class="p_header">+++ b/net/sched/cls_api.c</span>
<span class="p_chunk">@@ -81,6 +81,11 @@</span> <span class="p_context"> int unregister_tcf_proto_ops(struct tcf_proto_ops *ops)</span>
 	struct tcf_proto_ops *t;
 	int rc = -ENOENT;
 
<span class="p_add">+	/* Wait for outstanding call_rcu()s, if any, from a</span>
<span class="p_add">+	 * tcf_proto_ops&#39;s destroy() handler.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rcu_barrier();</span>
<span class="p_add">+</span>
 	write_lock(&amp;cls_mod_lock);
 	list_for_each_entry(t, &amp;tcf_proto_base, head) {
 		if (t == ops) {
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index 243b7d169d61..d9c2ee6d2959 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -815,10 +815,8 @@</span> <span class="p_context"> static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,</span>
 		if (dev-&gt;flags &amp; IFF_UP)
 			dev_deactivate(dev);
 
<span class="p_del">-		if (new &amp;&amp; new-&gt;ops-&gt;attach) {</span>
<span class="p_del">-			new-&gt;ops-&gt;attach(new);</span>
<span class="p_del">-			num_q = 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (new &amp;&amp; new-&gt;ops-&gt;attach)</span>
<span class="p_add">+			goto skip;</span>
 
 		for (i = 0; i &lt; num_q; i++) {
 			struct netdev_queue *dev_queue = dev_ingress_queue(dev);
<span class="p_chunk">@@ -834,12 +832,16 @@</span> <span class="p_context"> static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,</span>
 				qdisc_destroy(old);
 		}
 
<span class="p_add">+skip:</span>
 		if (!ingress) {
 			notify_and_destroy(net, skb, n, classid,
 					   dev-&gt;qdisc, new);
 			if (new &amp;&amp; !new-&gt;ops-&gt;attach)
 				atomic_inc(&amp;new-&gt;refcnt);
 			dev-&gt;qdisc = new ? : &amp;noop_qdisc;
<span class="p_add">+</span>
<span class="p_add">+			if (new &amp;&amp; new-&gt;ops-&gt;attach)</span>
<span class="p_add">+				new-&gt;ops-&gt;attach(new);</span>
 		} else {
 			notify_and_destroy(net, skb, n, classid, old, new);
 		}
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 526b6edab018..146881f068e2 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -1887,6 +1887,10 @@</span> <span class="p_context"> static long unix_stream_data_wait(struct sock *sk, long timeo,</span>
 		unix_state_unlock(sk);
 		timeo = freezable_schedule_timeout(timeo);
 		unix_state_lock(sk);
<span class="p_add">+</span>
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		clear_bit(SOCK_ASYNC_WAITDATA, &amp;sk-&gt;sk_socket-&gt;flags);
 	}
 
<span class="p_chunk">@@ -1947,6 +1951,10 @@</span> <span class="p_context"> static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 		struct sk_buff *skb, *last;
 
 		unix_state_lock(sk);
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD)) {</span>
<span class="p_add">+			err = -ECONNRESET;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
 		last = skb = skb_peek(&amp;sk-&gt;sk_receive_queue);
 again:
 		if (skb == NULL) {
<span class="p_header">diff --git a/net/wireless/wext-compat.c b/net/wireless/wext-compat.c</span>
<span class="p_header">index 5b24d39d7903..318026617b57 100644</span>
<span class="p_header">--- a/net/wireless/wext-compat.c</span>
<span class="p_header">+++ b/net/wireless/wext-compat.c</span>
<span class="p_chunk">@@ -1333,6 +1333,8 @@</span> <span class="p_context"> static struct iw_statistics *cfg80211_wireless_stats(struct net_device *dev)</span>
 	memcpy(bssid, wdev-&gt;current_bss-&gt;pub.bssid, ETH_ALEN);
 	wdev_unlock(wdev);
 
<span class="p_add">+	memset(&amp;sinfo, 0, sizeof(sinfo));</span>
<span class="p_add">+</span>
 	if (rdev_get_station(rdev, dev, bssid, &amp;sinfo))
 		return NULL;
 
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 93c78c3c4b95..a556d63564e6 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -2167,6 +2167,7 @@</span> <span class="p_context"> static const struct hda_fixup alc882_fixups[] = {</span>
 static const struct snd_pci_quirk alc882_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x1025, 0x006c, &quot;Acer Aspire 9810&quot;, ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x0090, &quot;Acer Aspire&quot;, ALC883_FIXUP_ACER_EAPD),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x0107, &quot;Acer Aspire&quot;, ALC883_FIXUP_ACER_EAPD),</span>
 	SND_PCI_QUIRK(0x1025, 0x010a, &quot;Acer Ferrari 5000&quot;, ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x0110, &quot;Acer Aspire&quot;, ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x0112, &quot;Acer Aspire 9303&quot;, ALC883_FIXUP_ACER_EAPD),
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 3e2ef61c627b..8b7e391dd0b8 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -918,6 +918,7 @@</span> <span class="p_context"> static void volume_control_quirks(struct usb_mixer_elem_info *cval,</span>
 	case USB_ID(0x046d, 0x081d): /* HD Webcam c510 */
 	case USB_ID(0x046d, 0x0825): /* HD Webcam c270 */
 	case USB_ID(0x046d, 0x0826): /* HD Webcam c525 */
<span class="p_add">+	case USB_ID(0x046d, 0x08ca): /* Logitech Quickcam Fusion */</span>
 	case USB_ID(0x046d, 0x0991):
 	/* Most audio usb devices lie about volume resolution.
 	 * Most Logitech webcams have res = 384.
<span class="p_chunk">@@ -1582,12 +1583,6 @@</span> <span class="p_context"> static int parse_audio_mixer_unit(struct mixer_build *state, int unitid,</span>
 			      unitid);
 		return -EINVAL;
 	}
<span class="p_del">-	/* no bmControls field (e.g. Maya44) -&gt; ignore */</span>
<span class="p_del">-	if (desc-&gt;bLength &lt;= 10 + input_pins) {</span>
<span class="p_del">-		usb_audio_dbg(state-&gt;chip, &quot;MU %d has no bmControls field\n&quot;,</span>
<span class="p_del">-			      unitid);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
 
 	num_ins = 0;
 	ich = 0;
<span class="p_chunk">@@ -1595,6 +1590,9 @@</span> <span class="p_context"> static int parse_audio_mixer_unit(struct mixer_build *state, int unitid,</span>
 		err = parse_audio_unit(state, desc-&gt;baSourceID[pin]);
 		if (err &lt; 0)
 			continue;
<span class="p_add">+		/* no bmControls field (e.g. Maya44) -&gt; ignore */</span>
<span class="p_add">+		if (desc-&gt;bLength &lt;= 10 + input_pins)</span>
<span class="p_add">+			continue;</span>
 		err = check_input_term(state, desc-&gt;baSourceID[pin], &amp;iterm);
 		if (err &lt; 0)
 			return err;
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index b703cb3cda19..e5000da9e9d7 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -437,6 +437,11 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.map = ebox44_map,
 	},
 	{
<span class="p_add">+		/* MAYA44 USB+ */</span>
<span class="p_add">+		.id = USB_ID(0x2573, 0x0008),</span>
<span class="p_add">+		.map = maya44_map,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* KEF X300A */
 		.id = USB_ID(0x27ac, 0x1000),
 		.map = scms_usb3318_map,
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index e21ec5abcc3a..2a408c60114b 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1120,6 +1120,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
<span class="p_add">+	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -1266,8 +1267,9 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 		if (fp-&gt;altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
<span class="p_del">-	/* DIYINHK DSD DXD 384kHz USB to I2S/DSD */</span>
<span class="p_del">-	case USB_ID(0x20b1, 0x2009):</span>
<span class="p_add">+</span>
<span class="p_add">+	case USB_ID(0x20b1, 0x2009): /* DIYINHK DSD DXD 384kHz USB to I2S/DSD */</span>
<span class="p_add">+	case USB_ID(0x20b1, 0x2023): /* JLsounds I2SoverUSB */</span>
 		if (fp-&gt;altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



