
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.10.99 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.10.99</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 3, 2016, 11:32 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160303233255.GB28784@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8497011/mbox/"
   >mbox</a>
|
   <a href="/patch/8497011/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8497011/">/patch/8497011/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 7B6B29F2F0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  3 Mar 2016 23:33:25 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 00D9A2039D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  3 Mar 2016 23:33:21 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id E6E7020396
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  3 Mar 2016 23:33:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755032AbcCCXdF (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 3 Mar 2016 18:33:05 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:36013 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751003AbcCCXc4 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 3 Mar 2016 18:32:56 -0500
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id C8945B9F;
	Thu,  3 Mar 2016 23:32:55 +0000 (UTC)
Date: Thu, 3 Mar 2016 15:32:55 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.10.99
Message-ID: &lt;20160303233255.GB28784@kroah.com&gt;
References: &lt;20160303233248.GA28784@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160303233248.GA28784@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - March 3, 2016, 11:32 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index dadd1edc6f84..f1e6491fd7d8 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 10
<span class="p_del">-SUBLEVEL = 98</span>
<span class="p_add">+SUBLEVEL = 99</span>
 EXTRAVERSION =
 NAME = TOSSUG Baby Fish
 
<span class="p_header">diff --git a/arch/arc/kernel/unwind.c b/arch/arc/kernel/unwind.c</span>
<span class="p_header">index a8d02223da44..14558a9fa3b3 100644</span>
<span class="p_header">--- a/arch/arc/kernel/unwind.c</span>
<span class="p_header">+++ b/arch/arc/kernel/unwind.c</span>
<span class="p_chunk">@@ -984,42 +984,13 @@</span> <span class="p_context"> int arc_unwind(struct unwind_frame_info *frame)</span>
 							    (const u8 *)(fde +
 									 1) +
 							    *fde, ptrType);
<span class="p_del">-				if (pc &gt;= endLoc)</span>
<span class="p_add">+				if (pc &gt;= endLoc) {</span>
 					fde = NULL;
<span class="p_del">-			} else</span>
<span class="p_del">-				fde = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (fde == NULL) {</span>
<span class="p_del">-			for (fde = table-&gt;address, tableSize = table-&gt;size;</span>
<span class="p_del">-			     cie = NULL, tableSize &gt; sizeof(*fde)</span>
<span class="p_del">-			     &amp;&amp; tableSize - sizeof(*fde) &gt;= *fde;</span>
<span class="p_del">-			     tableSize -= sizeof(*fde) + *fde,</span>
<span class="p_del">-			     fde += 1 + *fde / sizeof(*fde)) {</span>
<span class="p_del">-				cie = cie_for_fde(fde, table);</span>
<span class="p_del">-				if (cie == &amp;bad_cie) {</span>
 					cie = NULL;
<span class="p_del">-					break;</span>
 				}
<span class="p_del">-				if (cie == NULL</span>
<span class="p_del">-				    || cie == &amp;not_fde</span>
<span class="p_del">-				    || (ptrType = fde_pointer_type(cie)) &lt; 0)</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-				ptr = (const u8 *)(fde + 2);</span>
<span class="p_del">-				startLoc = read_pointer(&amp;ptr,</span>
<span class="p_del">-							(const u8 *)(fde + 1) +</span>
<span class="p_del">-							*fde, ptrType);</span>
<span class="p_del">-				if (!startLoc)</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-				if (!(ptrType &amp; DW_EH_PE_indirect))</span>
<span class="p_del">-					ptrType &amp;=</span>
<span class="p_del">-					    DW_EH_PE_FORM | DW_EH_PE_signed;</span>
<span class="p_del">-				endLoc =</span>
<span class="p_del">-				    startLoc + read_pointer(&amp;ptr,</span>
<span class="p_del">-							    (const u8 *)(fde +</span>
<span class="p_del">-									 1) +</span>
<span class="p_del">-							    *fde, ptrType);</span>
<span class="p_del">-				if (pc &gt;= startLoc &amp;&amp; pc &lt; endLoc)</span>
<span class="p_del">-					break;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				fde = NULL;</span>
<span class="p_add">+				cie = NULL;</span>
 			}
 		}
 	}
<span class="p_header">diff --git a/arch/mips/kvm/kvm_locore.S b/arch/mips/kvm/kvm_locore.S</span>
<span class="p_header">index 920b63210806..34c35f0e3290 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_locore.S</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_locore.S</span>
<span class="p_chunk">@@ -156,9 +156,11 @@</span> <span class="p_context"> FEXPORT(__kvm_mips_vcpu_run)</span>
 
 FEXPORT(__kvm_mips_load_asid)
     /* Set the ASID for the Guest Kernel */
<span class="p_del">-    sll         t0, t0, 1                       /* with kseg0 @ 0x40000000, kernel */</span>
<span class="p_del">-                                                /* addresses shift to 0x80000000 */</span>
<span class="p_del">-    bltz        t0, 1f                          /* If kernel */</span>
<span class="p_add">+    PTR_L	t0, VCPU_COP0(k1)</span>
<span class="p_add">+    LONG_L	t0, COP0_STATUS(t0)</span>
<span class="p_add">+    andi	t0, KSU_USER | ST0_ERL | ST0_EXL</span>
<span class="p_add">+    xori	t0, KSU_USER</span>
<span class="p_add">+    bnez	t0, 1f		/* If kernel */</span>
 	addiu       t1, k1, VCPU_GUEST_KERNEL_ASID  /* (BD)  */
     addiu       t1, k1, VCPU_GUEST_USER_ASID    /* else user */
 1:
<span class="p_chunk">@@ -442,9 +444,11 @@</span> <span class="p_context"> __kvm_mips_return_to_guest:</span>
 	mtc0		t0, CP0_EPC
 
     /* Set the ASID for the Guest Kernel */
<span class="p_del">-    sll         t0, t0, 1                       /* with kseg0 @ 0x40000000, kernel */</span>
<span class="p_del">-                                                /* addresses shift to 0x80000000 */</span>
<span class="p_del">-    bltz        t0, 1f                          /* If kernel */</span>
<span class="p_add">+    PTR_L	t0, VCPU_COP0(k1)</span>
<span class="p_add">+    LONG_L	t0, COP0_STATUS(t0)</span>
<span class="p_add">+    andi	t0, KSU_USER | ST0_ERL | ST0_EXL</span>
<span class="p_add">+    xori	t0, KSU_USER</span>
<span class="p_add">+    bnez	t0, 1f		/* If kernel */</span>
 	addiu       t1, k1, VCPU_GUEST_KERNEL_ASID  /* (BD)  */
     addiu       t1, k1, VCPU_GUEST_USER_ASID    /* else user */
 1:
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">index 843ec38fec7b..8aa5f30d8579 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_chunk">@@ -308,7 +308,7 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)</span>
 
 	if (!gebase) {
 		err = -ENOMEM;
<span class="p_del">-		goto out_free_cpu;</span>
<span class="p_add">+		goto out_uninit_cpu;</span>
 	}
 	kvm_info(&quot;Allocated %d bytes for KVM Exception Handlers @ %p\n&quot;,
 		 ALIGN(size, PAGE_SIZE), gebase);
<span class="p_chunk">@@ -368,6 +368,9 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)</span>
 out_free_gebase:
 	kfree(gebase);
 
<span class="p_add">+out_uninit_cpu:</span>
<span class="p_add">+	kvm_vcpu_uninit(vcpu);</span>
<span class="p_add">+</span>
 out_free_cpu:
 	kfree(vcpu);
 
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">index c76f297b7149..33085819cd89 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_chunk">@@ -935,7 +935,7 @@</span> <span class="p_context"> kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc, uint32_t cause,</span>
 
 	base = (inst &gt;&gt; 21) &amp; 0x1f;
 	op_inst = (inst &gt;&gt; 16) &amp; 0x1f;
<span class="p_del">-	offset = inst &amp; 0xffff;</span>
<span class="p_add">+	offset = (int16_t)inst;</span>
 	cache = (inst &gt;&gt; 16) &amp; 0x3;
 	op = (inst &gt;&gt; 18) &amp; 0x7;
 
<span class="p_header">diff --git a/arch/s390/mm/extable.c b/arch/s390/mm/extable.c</span>
<span class="p_header">index 4d1ee88864e8..18c8b819b0aa 100644</span>
<span class="p_header">--- a/arch/s390/mm/extable.c</span>
<span class="p_header">+++ b/arch/s390/mm/extable.c</span>
<span class="p_chunk">@@ -52,12 +52,16 @@</span> <span class="p_context"> void sort_extable(struct exception_table_entry *start,</span>
 	int i;
 
 	/* Normalize entries to being relative to the start of the section */
<span class="p_del">-	for (p = start, i = 0; p &lt; finish; p++, i += 8)</span>
<span class="p_add">+	for (p = start, i = 0; p &lt; finish; p++, i += 8) {</span>
 		p-&gt;insn += i;
<span class="p_add">+		p-&gt;fixup += i + 4;</span>
<span class="p_add">+	}</span>
 	sort(start, finish - start, sizeof(*start), cmp_ex, NULL);
 	/* Denormalize all entries */
<span class="p_del">-	for (p = start, i = 0; p &lt; finish; p++, i += 8)</span>
<span class="p_add">+	for (p = start, i = 0; p &lt; finish; p++, i += 8) {</span>
 		p-&gt;insn -= i;
<span class="p_add">+		p-&gt;fixup -= i + 4;</span>
<span class="p_add">+	}</span>
 }
 
 #ifdef CONFIG_MODULES
<span class="p_header">diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">index be8db9bb7878..666510b39870 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_chunk">@@ -416,7 +416,7 @@</span> <span class="p_context"> out:</span>
 
 SYSCALL_DEFINE1(sparc64_personality, unsigned long, personality)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	long ret;</span>
 
 	if (personality(current-&gt;personality) == PER_LINUX32 &amp;&amp;
 	    personality(personality) == PER_LINUX)
<span class="p_header">diff --git a/arch/um/os-Linux/start_up.c b/arch/um/os-Linux/start_up.c</span>
<span class="p_header">index 337518c5042a..b412c62486f0 100644</span>
<span class="p_header">--- a/arch/um/os-Linux/start_up.c</span>
<span class="p_header">+++ b/arch/um/os-Linux/start_up.c</span>
<span class="p_chunk">@@ -95,6 +95,8 @@</span> <span class="p_context"> static int start_ptraced_child(void)</span>
 {
 	int pid, n, status;
 
<span class="p_add">+	fflush(stdout);</span>
<span class="p_add">+</span>
 	pid = fork();
 	if (pid == 0)
 		ptrace_child();
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index 6033be9ff81a..3c8bffdc71c8 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -250,12 +250,19 @@</span> <span class="p_context"> static efi_status_t __init phys_efi_set_virtual_address_map(</span>
 	efi_memory_desc_t *virtual_map)
 {
 	efi_status_t status;
<span class="p_add">+	unsigned long flags;</span>
 
 	efi_call_phys_prelog();
<span class="p_add">+</span>
<span class="p_add">+	/* Disable interrupts around EFI calls: */</span>
<span class="p_add">+	local_irq_save(flags);</span>
 	status = efi_call_phys4(efi_phys.set_virtual_address_map,
 				memory_map_size, descriptor_size,
 				descriptor_version, virtual_map);
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+</span>
 	efi_call_phys_epilog();
<span class="p_add">+</span>
 	return status;
 }
 
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_32.c b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">index 40e446941dd7..bebbee05e331 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_chunk">@@ -33,19 +33,16 @@</span> <span class="p_context"></span>
 
 /*
  * To make EFI call EFI runtime service in physical addressing mode we need
<span class="p_del">- * prelog/epilog before/after the invocation to disable interrupt, to</span>
<span class="p_del">- * claim EFI runtime service handler exclusively and to duplicate a memory in</span>
<span class="p_del">- * low memory space say 0 - 3G.</span>
<span class="p_add">+ * prolog/epilog before/after the invocation to claim the EFI runtime service</span>
<span class="p_add">+ * handler exclusively and to duplicate a memory mapping in low memory space,</span>
<span class="p_add">+ * say 0 - 3G.</span>
  */
 
<span class="p_del">-static unsigned long efi_rt_eflags;</span>
 
 void efi_call_phys_prelog(void)
 {
 	struct desc_ptr gdt_descr;
 
<span class="p_del">-	local_irq_save(efi_rt_eflags);</span>
<span class="p_del">-</span>
 	load_cr3(initial_page_table);
 	__flush_tlb_all();
 
<span class="p_chunk">@@ -64,6 +61,4 @@</span> <span class="p_context"> void efi_call_phys_epilog(void)</span>
 
 	load_cr3(swapper_pg_dir);
 	__flush_tlb_all();
<span class="p_del">-</span>
<span class="p_del">-	local_irq_restore(efi_rt_eflags);</span>
 }
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index 39a0e7f1f0a3..2f6c1a9734c8 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -40,7 +40,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/fixmap.h&gt;
 
 static pgd_t *save_pgd __initdata;
<span class="p_del">-static unsigned long efi_flags __initdata;</span>
 
 static void __init early_code_mapping_set_exec(int executable)
 {
<span class="p_chunk">@@ -66,7 +65,6 @@</span> <span class="p_context"> void __init efi_call_phys_prelog(void)</span>
 	int n_pgds;
 
 	early_code_mapping_set_exec(1);
<span class="p_del">-	local_irq_save(efi_flags);</span>
 
 	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);
 	save_pgd = kmalloc(n_pgds * sizeof(pgd_t), GFP_KERNEL);
<span class="p_chunk">@@ -90,7 +88,6 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(void)</span>
 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), save_pgd[pgd]);
 	kfree(save_pgd);
 	__flush_tlb_all();
<span class="p_del">-	local_irq_restore(efi_flags);</span>
 	early_code_mapping_set_exec(0);
 }
 
<span class="p_header">diff --git a/block/partitions/mac.c b/block/partitions/mac.c</span>
<span class="p_header">index 76d8ba6379a9..bd5b91465230 100644</span>
<span class="p_header">--- a/block/partitions/mac.c</span>
<span class="p_header">+++ b/block/partitions/mac.c</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	Sector sect;
 	unsigned char *data;
 	int slot, blocks_in_map;
<span class="p_del">-	unsigned secsize;</span>
<span class="p_add">+	unsigned secsize, datasize, partoffset;</span>
 #ifdef CONFIG_PPC_PMAC
 	int found_root = 0;
 	int found_root_goodness = 0;
<span class="p_chunk">@@ -50,10 +50,14 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	}
 	secsize = be16_to_cpu(md-&gt;block_size);
 	put_dev_sector(sect);
<span class="p_del">-	data = read_part_sector(state, secsize/512, &amp;sect);</span>
<span class="p_add">+	datasize = round_down(secsize, 512);</span>
<span class="p_add">+	data = read_part_sector(state, datasize / 512, &amp;sect);</span>
 	if (!data)
 		return -1;
<span class="p_del">-	part = (struct mac_partition *) (data + secsize%512);</span>
<span class="p_add">+	partoffset = secsize % 512;</span>
<span class="p_add">+	if (partoffset + sizeof(*part) &gt; datasize)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	part = (struct mac_partition *) (data + partoffset);</span>
 	if (be16_to_cpu(part-&gt;signature) != MAC_PARTITION_MAGIC) {
 		put_dev_sector(sect);
 		return 0;		/* not a MacOS disk */
<span class="p_header">diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c</span>
<span class="p_header">index 136803c47cdb..96e5ed188636 100644</span>
<span class="p_header">--- a/drivers/ata/libata-sff.c</span>
<span class="p_header">+++ b/drivers/ata/libata-sff.c</span>
<span class="p_chunk">@@ -997,12 +997,9 @@</span> <span class="p_context"> static inline int ata_hsm_ok_in_wq(struct ata_port *ap,</span>
 static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)
 {
 	struct ata_port *ap = qc-&gt;ap;
<span class="p_del">-	unsigned long flags;</span>
 
 	if (ap-&gt;ops-&gt;error_handler) {
 		if (in_wq) {
<span class="p_del">-			spin_lock_irqsave(ap-&gt;lock, flags);</span>
<span class="p_del">-</span>
 			/* EH might have kicked in while host lock is
 			 * released.
 			 */
<span class="p_chunk">@@ -1014,8 +1011,6 @@</span> <span class="p_context"> static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)</span>
 				} else
 					ata_port_freeze(ap);
 			}
<span class="p_del">-</span>
<span class="p_del">-			spin_unlock_irqrestore(ap-&gt;lock, flags);</span>
 		} else {
 			if (likely(!(qc-&gt;err_mask &amp; AC_ERR_HSM)))
 				ata_qc_complete(qc);
<span class="p_chunk">@@ -1024,10 +1019,8 @@</span> <span class="p_context"> static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)</span>
 		}
 	} else {
 		if (in_wq) {
<span class="p_del">-			spin_lock_irqsave(ap-&gt;lock, flags);</span>
 			ata_sff_irq_on(ap);
 			ata_qc_complete(qc);
<span class="p_del">-			spin_unlock_irqrestore(ap-&gt;lock, flags);</span>
 		} else
 			ata_qc_complete(qc);
 	}
<span class="p_chunk">@@ -1048,9 +1041,10 @@</span> <span class="p_context"> int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,</span>
 {
 	struct ata_link *link = qc-&gt;dev-&gt;link;
 	struct ata_eh_info *ehi = &amp;link-&gt;eh_info;
<span class="p_del">-	unsigned long flags = 0;</span>
 	int poll_next;
 
<span class="p_add">+	lockdep_assert_held(ap-&gt;lock);</span>
<span class="p_add">+</span>
 	WARN_ON_ONCE((qc-&gt;flags &amp; ATA_QCFLAG_ACTIVE) == 0);
 
 	/* Make sure ata_sff_qc_issue() does not throw things
<span class="p_chunk">@@ -1112,14 +1106,6 @@</span> <span class="p_context"> fsm_start:</span>
 			}
 		}
 
<span class="p_del">-		/* Send the CDB (atapi) or the first data block (ata pio out).</span>
<span class="p_del">-		 * During the state transition, interrupt handler shouldn&#39;t</span>
<span class="p_del">-		 * be invoked before the data transfer is complete and</span>
<span class="p_del">-		 * hsm_task_state is changed. Hence, the following locking.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (in_wq)</span>
<span class="p_del">-			spin_lock_irqsave(ap-&gt;lock, flags);</span>
<span class="p_del">-</span>
 		if (qc-&gt;tf.protocol == ATA_PROT_PIO) {
 			/* PIO data out protocol.
 			 * send first data block.
<span class="p_chunk">@@ -1135,9 +1121,6 @@</span> <span class="p_context"> fsm_start:</span>
 			/* send CDB */
 			atapi_send_cdb(ap, qc);
 
<span class="p_del">-		if (in_wq)</span>
<span class="p_del">-			spin_unlock_irqrestore(ap-&gt;lock, flags);</span>
<span class="p_del">-</span>
 		/* if polling, ata_sff_pio_task() handles the rest.
 		 * otherwise, interrupt handler takes over from here.
 		 */
<span class="p_chunk">@@ -1361,12 +1344,14 @@</span> <span class="p_context"> static void ata_sff_pio_task(struct work_struct *work)</span>
 	u8 status;
 	int poll_next;
 
<span class="p_add">+	spin_lock_irq(ap-&gt;lock);</span>
<span class="p_add">+</span>
 	BUG_ON(ap-&gt;sff_pio_task_link == NULL);
 	/* qc can be NULL if timeout occurred */
 	qc = ata_qc_from_tag(ap, link-&gt;active_tag);
 	if (!qc) {
 		ap-&gt;sff_pio_task_link = NULL;
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out_unlock;</span>
 	}
 
 fsm_start:
<span class="p_chunk">@@ -1381,11 +1366,14 @@</span> <span class="p_context"> fsm_start:</span>
 	 */
 	status = ata_sff_busy_wait(ap, ATA_BUSY, 5);
 	if (status &amp; ATA_BUSY) {
<span class="p_add">+		spin_unlock_irq(ap-&gt;lock);</span>
 		ata_msleep(ap, 2);
<span class="p_add">+		spin_lock_irq(ap-&gt;lock);</span>
<span class="p_add">+</span>
 		status = ata_sff_busy_wait(ap, ATA_BUSY, 10);
 		if (status &amp; ATA_BUSY) {
 			ata_sff_queue_pio_task(link, ATA_SHORT_PAUSE);
<span class="p_del">-			return;</span>
<span class="p_add">+			goto out_unlock;</span>
 		}
 	}
 
<span class="p_chunk">@@ -1402,6 +1390,8 @@</span> <span class="p_context"> fsm_start:</span>
 	 */
 	if (poll_next)
 		goto fsm_start;
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	spin_unlock_irq(ap-&gt;lock);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/ata/sata_sil.c b/drivers/ata/sata_sil.c</span>
<span class="p_header">index dd1faa564eb2..cdfb98e70cfd 100644</span>
<span class="p_header">--- a/drivers/ata/sata_sil.c</span>
<span class="p_header">+++ b/drivers/ata/sata_sil.c</span>
<span class="p_chunk">@@ -631,6 +631,9 @@</span> <span class="p_context"> static void sil_dev_config(struct ata_device *dev)</span>
 	unsigned int n, quirks = 0;
 	unsigned char model_num[ATA_ID_PROD_LEN + 1];
 
<span class="p_add">+	/* This controller doesn&#39;t support trim */</span>
<span class="p_add">+	dev-&gt;horkage |= ATA_HORKAGE_NOTRIM;</span>
<span class="p_add">+</span>
 	ata_id_c_string(dev-&gt;id, model_num, ATA_ID_PROD, sizeof(model_num));
 
 	for (n = 0; sil_blacklist[n].product; n++)
<span class="p_header">diff --git a/drivers/clocksource/vt8500_timer.c b/drivers/clocksource/vt8500_timer.c</span>
<span class="p_header">index 64f553f04fa4..5874ebf9dced 100644</span>
<span class="p_header">--- a/drivers/clocksource/vt8500_timer.c</span>
<span class="p_header">+++ b/drivers/clocksource/vt8500_timer.c</span>
<span class="p_chunk">@@ -50,6 +50,8 @@</span> <span class="p_context"></span>
 
 #define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)
 
<span class="p_add">+#define MIN_OSCR_DELTA		16</span>
<span class="p_add">+</span>
 static void __iomem *regbase;
 
 static cycle_t vt8500_timer_read(struct clocksource *cs)
<span class="p_chunk">@@ -80,7 +82,7 @@</span> <span class="p_context"> static int vt8500_timer_set_next_event(unsigned long cycles,</span>
 		cpu_relax();
 	writel((unsigned long)alarm, regbase + TIMER_MATCH_VAL);
 
<span class="p_del">-	if ((signed)(alarm - clocksource.read(&amp;clocksource)) &lt;= 16)</span>
<span class="p_add">+	if ((signed)(alarm - clocksource.read(&amp;clocksource)) &lt;= MIN_OSCR_DELTA)</span>
 		return -ETIME;
 
 	writel(1, regbase + TIMER_IER_VAL);
<span class="p_chunk">@@ -162,7 +164,7 @@</span> <span class="p_context"> static void __init vt8500_timer_init(struct device_node *np)</span>
 		pr_err(&quot;%s: setup_irq failed for %s\n&quot;, __func__,
 							clockevent.name);
 	clockevents_config_and_register(&amp;clockevent, VT8500_TIMER_HZ,
<span class="p_del">-					4, 0xf0000000);</span>
<span class="p_add">+					MIN_OSCR_DELTA * 2, 0xf0000000);</span>
 }
 
 CLOCKSOURCE_OF_DECLARE(vt8500, &quot;via,vt8500-timer&quot;, vt8500_timer_init);
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_drv.h b/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_header">index b6b7d70f2832..5cfc1765af74 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_chunk">@@ -296,6 +296,7 @@</span> <span class="p_context"> int ast_framebuffer_init(struct drm_device *dev,</span>
 int ast_fbdev_init(struct drm_device *dev);
 void ast_fbdev_fini(struct drm_device *dev);
 void ast_fbdev_set_suspend(struct drm_device *dev, int state);
<span class="p_add">+void ast_fbdev_set_base(struct ast_private *ast, unsigned long gpu_addr);</span>
 
 struct ast_bo {
 	struct ttm_buffer_object bo;
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_fb.c b/drivers/gpu/drm/ast/ast_fb.c</span>
<span class="p_header">index fbc0823cfa18..a298d8f72225 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_fb.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_fb.c</span>
<span class="p_chunk">@@ -366,3 +366,10 @@</span> <span class="p_context"> void ast_fbdev_set_suspend(struct drm_device *dev, int state)</span>
 
 	fb_set_suspend(ast-&gt;fbdev-&gt;helper.fbdev, state);
 }
<span class="p_add">+</span>
<span class="p_add">+void ast_fbdev_set_base(struct ast_private *ast, unsigned long gpu_addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ast-&gt;fbdev-&gt;helper.fbdev-&gt;fix.smem_start =</span>
<span class="p_add">+		ast-&gt;fbdev-&gt;helper.fbdev-&gt;apertures-&gt;ranges[0].base + gpu_addr;</span>
<span class="p_add">+	ast-&gt;fbdev-&gt;helper.fbdev-&gt;fix.smem_len = ast-&gt;vram_size - gpu_addr;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_main.c b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">index 96f874a508e2..313ccaf25f49 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_chunk">@@ -359,6 +359,7 @@</span> <span class="p_context"> int ast_driver_load(struct drm_device *dev, unsigned long flags)</span>
 	dev-&gt;mode_config.min_height = 0;
 	dev-&gt;mode_config.preferred_depth = 24;
 	dev-&gt;mode_config.prefer_shadow = 1;
<span class="p_add">+	dev-&gt;mode_config.fb_base = pci_resource_start(ast-&gt;dev-&gt;pdev, 0);</span>
 
 	if (ast-&gt;chip == AST2100 ||
 	    ast-&gt;chip == AST2200 ||
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_mode.c b/drivers/gpu/drm/ast/ast_mode.c</span>
<span class="p_header">index e8f6418b6dec..f3a54ad77e3f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_mode.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_mode.c</span>
<span class="p_chunk">@@ -509,6 +509,8 @@</span> <span class="p_context"> static int ast_crtc_do_set_base(struct drm_crtc *crtc,</span>
 		ret = ttm_bo_kmap(&amp;bo-&gt;bo, 0, bo-&gt;bo.num_pages, &amp;bo-&gt;kmap);
 		if (ret)
 			DRM_ERROR(&quot;failed to kmap fbcon\n&quot;);
<span class="p_add">+		else</span>
<span class="p_add">+			ast_fbdev_set_base(ast, gpu_addr);</span>
 	}
 	ast_bo_unreserve(bo);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">index ba2ab9a9b988..f3cce23f4a62 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_chunk">@@ -452,7 +452,9 @@</span> <span class="p_context"> static bool radeon_atom_apply_quirks(struct drm_device *dev,</span>
 	}
 
 	/* Fujitsu D3003-S2 board lists DVI-I as DVI-D and VGA */
<span class="p_del">-	if (((dev-&gt;pdev-&gt;device == 0x9802) || (dev-&gt;pdev-&gt;device == 0x9806)) &amp;&amp;</span>
<span class="p_add">+	if (((dev-&gt;pdev-&gt;device == 0x9802) ||</span>
<span class="p_add">+	     (dev-&gt;pdev-&gt;device == 0x9805) ||</span>
<span class="p_add">+	     (dev-&gt;pdev-&gt;device == 0x9806)) &amp;&amp;</span>
 	    (dev-&gt;pdev-&gt;subsystem_vendor == 0x1734) &amp;&amp;
 	    (dev-&gt;pdev-&gt;subsystem_device == 0x11bd)) {
 		if (*connector_type == DRM_MODE_CONNECTOR_VGA) {
<span class="p_chunk">@@ -463,14 +465,6 @@</span> <span class="p_context"> static bool radeon_atom_apply_quirks(struct drm_device *dev,</span>
 		}
 	}
 
<span class="p_del">-	/* Fujitsu D3003-S2 board lists DVI-I as DVI-I and VGA */</span>
<span class="p_del">-	if ((dev-&gt;pdev-&gt;device == 0x9805) &amp;&amp;</span>
<span class="p_del">-	    (dev-&gt;pdev-&gt;subsystem_vendor == 0x1734) &amp;&amp;</span>
<span class="p_del">-	    (dev-&gt;pdev-&gt;subsystem_device == 0x11bd)) {</span>
<span class="p_del">-		if (*connector_type == DRM_MODE_CONNECTOR_VGA)</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return true;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index db83d075606e..6acd3646ac08 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -73,6 +73,11 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	/* we can race here at startup, some boards seem to trigger</span>
<span class="p_add">+	 * hotplug irqs when they shouldn&#39;t. */</span>
<span class="p_add">+	if (!rdev-&gt;mode_info.mode_config_initialized)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;mode_config-&gt;mutex);
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_sa.c b/drivers/gpu/drm/radeon/radeon_sa.c</span>
<span class="p_header">index f0bac68254b7..bb166849aa6e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_sa.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_sa.c</span>
<span class="p_chunk">@@ -349,8 +349,13 @@</span> <span class="p_context"> int radeon_sa_bo_new(struct radeon_device *rdev,</span>
 			/* see if we can skip over some allocations */
 		} while (radeon_sa_bo_next_hole(sa_manager, fences, tries));
 
<span class="p_add">+		for (i = 0; i &lt; RADEON_NUM_RINGS; ++i)</span>
<span class="p_add">+			radeon_fence_ref(fences[i]);</span>
<span class="p_add">+</span>
 		spin_unlock(&amp;sa_manager-&gt;wq.lock);
 		r = radeon_fence_wait_any(rdev, fences, false);
<span class="p_add">+		for (i = 0; i &lt; RADEON_NUM_RINGS; ++i)</span>
<span class="p_add">+			radeon_fence_unref(&amp;fences[i]);</span>
 		spin_lock(&amp;sa_manager-&gt;wq.lock);
 		/* if we have nothing to wait for block */
 		if (r == -ENOENT &amp;&amp; block) {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">index 4a14e113369d..f7015592544f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_chunk">@@ -619,7 +619,7 @@</span> <span class="p_context"> static int radeon_ttm_tt_populate(struct ttm_tt *ttm)</span>
 						       0, PAGE_SIZE,
 						       PCI_DMA_BIDIRECTIONAL);
 		if (pci_dma_mapping_error(rdev-&gt;pdev, gtt-&gt;ttm.dma_address[i])) {
<span class="p_del">-			while (--i) {</span>
<span class="p_add">+			while (i--) {</span>
 				pci_unmap_page(rdev-&gt;pdev, gtt-&gt;ttm.dma_address[i],
 					       PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
 				gtt-&gt;ttm.dma_address[i] = 0;
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">index 6c44c69a5ba4..94a0baac93dd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
  *
  **************************************************************************/
 #include &lt;linux/module.h&gt;
<span class="p_add">+#include &lt;linux/console.h&gt;</span>
 
 #include &lt;drm/drmP.h&gt;
 #include &quot;vmwgfx_drv.h&quot;
<span class="p_chunk">@@ -1192,6 +1193,12 @@</span> <span class="p_context"> static int vmw_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 static int __init vmwgfx_init(void)
 {
 	int ret;
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_VGA_CONSOLE</span>
<span class="p_add">+	if (vgacon_text_force())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	ret = drm_pci_init(&amp;driver, &amp;vmw_pci_driver);
 	if (ret)
 		DRM_ERROR(&quot;Failed initializing DRM.\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/vga/vgaarb.c b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">index e893f6e1937d..3c84e96a485a 100644</span>
<span class="p_header">--- a/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">+++ b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_chunk">@@ -392,8 +392,10 @@</span> <span class="p_context"> int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible)</span>
 		set_current_state(interruptible ?
 				  TASK_INTERRUPTIBLE :
 				  TASK_UNINTERRUPTIBLE);
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_del">-			rc = -EINTR;</span>
<span class="p_add">+		if (interruptible &amp;&amp; signal_pending(current)) {</span>
<span class="p_add">+			__set_current_state(TASK_RUNNING);</span>
<span class="p_add">+			remove_wait_queue(&amp;vga_wait_queue, &amp;wait);</span>
<span class="p_add">+			rc = -ERESTARTSYS;</span>
 			break;
 		}
 		schedule();
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb3/iwch_cm.c b/drivers/infiniband/hw/cxgb3/iwch_cm.c</span>
<span class="p_header">index 3e094cd6a0e3..a9194ef626cd 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb3/iwch_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb3/iwch_cm.c</span>
<span class="p_chunk">@@ -149,7 +149,7 @@</span> <span class="p_context"> static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_en</span>
 	error = l2t_send(tdev, skb, l2e);
 	if (error &lt; 0)
 		kfree_skb(skb);
<span class="p_del">-	return error;</span>
<span class="p_add">+	return error &lt; 0 ? error : 0;</span>
 }
 
 int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)</span>
 	error = cxgb3_ofld_send(tdev, skb);
 	if (error &lt; 0)
 		kfree_skb(skb);
<span class="p_del">-	return error;</span>
<span class="p_add">+	return error &lt; 0 ? error : 0;</span>
 }
 
 static void release_tid(struct t3cdev *tdev, u32 hwtid, struct sk_buff *skb)
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_verbs_mcast.c b/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_header">index dabb697b1c2a..48ba1c3e945a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_chunk">@@ -286,15 +286,13 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	struct qib_ibdev *dev = to_idev(ibqp-&gt;device);
 	struct qib_ibport *ibp = to_iport(ibqp-&gt;device, qp-&gt;port_num);
 	struct qib_mcast *mcast = NULL;
<span class="p_del">-	struct qib_mcast_qp *p, *tmp;</span>
<span class="p_add">+	struct qib_mcast_qp *p, *tmp, *delp = NULL;</span>
 	struct rb_node *n;
 	int last = 0;
 	int ret;
 
<span class="p_del">-	if (ibqp-&gt;qp_num &lt;= 1 || qp-&gt;state == IB_QPS_RESET) {</span>
<span class="p_del">-		ret = -EINVAL;</span>
<span class="p_del">-		goto bail;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ibqp-&gt;qp_num &lt;= 1 || qp-&gt;state == IB_QPS_RESET)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	spin_lock_irq(&amp;ibp-&gt;lock);
 
<span class="p_chunk">@@ -303,8 +301,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	while (1) {
 		if (n == NULL) {
 			spin_unlock_irq(&amp;ibp-&gt;lock);
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			goto bail;</span>
<span class="p_add">+			return -EINVAL;</span>
 		}
 
 		mcast = rb_entry(n, struct qib_mcast, rb_node);
<span class="p_chunk">@@ -328,6 +325,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 		 */
 		list_del_rcu(&amp;p-&gt;list);
 		mcast-&gt;n_attached--;
<span class="p_add">+		delp = p;</span>
 
 		/* If this was the last attached QP, remove the GID too. */
 		if (list_empty(&amp;mcast-&gt;qp_list)) {
<span class="p_chunk">@@ -338,15 +336,16 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	}
 
 	spin_unlock_irq(&amp;ibp-&gt;lock);
<span class="p_add">+	/* QP not attached */</span>
<span class="p_add">+	if (!delp)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait for any list walkers to finish before freeing the</span>
<span class="p_add">+	 * list element.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	wait_event(mcast-&gt;wait, atomic_read(&amp;mcast-&gt;refcount) &lt;= 1);</span>
<span class="p_add">+	qib_mcast_qp_free(delp);</span>
 
<span class="p_del">-	if (p) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Wait for any list walkers to finish before freeing the</span>
<span class="p_del">-		 * list element.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		wait_event(mcast-&gt;wait, atomic_read(&amp;mcast-&gt;refcount) &lt;= 1);</span>
<span class="p_del">-		qib_mcast_qp_free(p);</span>
<span class="p_del">-	}</span>
 	if (last) {
 		atomic_dec(&amp;mcast-&gt;refcount);
 		wait_event(mcast-&gt;wait, !atomic_read(&amp;mcast-&gt;refcount));
<span class="p_chunk">@@ -355,11 +354,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 		dev-&gt;n_mcast_grps_allocated--;
 		spin_unlock_irq(&amp;dev-&gt;n_mcast_grps_lock);
 	}
<span class="p_del">-</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-bail:</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 int qib_mcast_tree_empty(struct qib_ibport *ibp)
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index b4713cea1913..2d2915fdbf02 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -1959,8 +1959,10 @@</span> <span class="p_context"> static int __init bcache_init(void)</span>
 	closure_debug_init();
 
 	bcache_major = register_blkdev(0, &quot;bcache&quot;);
<span class="p_del">-	if (bcache_major &lt; 0)</span>
<span class="p_add">+	if (bcache_major &lt; 0) {</span>
<span class="p_add">+		unregister_reboot_notifier(&amp;reboot);</span>
 		return bcache_major;
<span class="p_add">+	}</span>
 
 	if (!(bcache_wq = create_workqueue(&quot;bcache&quot;)) ||
 	    !(bcache_kobj = kobject_create_and_add(&quot;bcache&quot;, fs_kobj)) ||
<span class="p_header">diff --git a/drivers/md/dm-exception-store.h b/drivers/md/dm-exception-store.h</span>
<span class="p_header">index 0b2536247cf5..84e27708ad97 100644</span>
<span class="p_header">--- a/drivers/md/dm-exception-store.h</span>
<span class="p_header">+++ b/drivers/md/dm-exception-store.h</span>
<span class="p_chunk">@@ -70,7 +70,7 @@</span> <span class="p_context"> struct dm_exception_store_type {</span>
 	 * Update the metadata with this exception.
 	 */
 	void (*commit_exception) (struct dm_exception_store *store,
<span class="p_del">-				  struct dm_exception *e,</span>
<span class="p_add">+				  struct dm_exception *e, int valid,</span>
 				  void (*callback) (void *, int success),
 				  void *callback_context);
 
<span class="p_header">diff --git a/drivers/md/dm-snap-persistent.c b/drivers/md/dm-snap-persistent.c</span>
<span class="p_header">index 2d2b1b7588d7..8f6d3ea55401 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap-persistent.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap-persistent.c</span>
<span class="p_chunk">@@ -646,7 +646,7 @@</span> <span class="p_context"> static int persistent_prepare_exception(struct dm_exception_store *store,</span>
 }
 
 static void persistent_commit_exception(struct dm_exception_store *store,
<span class="p_del">-					struct dm_exception *e,</span>
<span class="p_add">+					struct dm_exception *e, int valid,</span>
 					void (*callback) (void *, int success),
 					void *callback_context)
 {
<span class="p_chunk">@@ -655,6 +655,9 @@</span> <span class="p_context"> static void persistent_commit_exception(struct dm_exception_store *store,</span>
 	struct core_exception ce;
 	struct commit_callback *cb;
 
<span class="p_add">+	if (!valid)</span>
<span class="p_add">+		ps-&gt;valid = 0;</span>
<span class="p_add">+</span>
 	ce.old_chunk = e-&gt;old_chunk;
 	ce.new_chunk = e-&gt;new_chunk;
 	write_exception(ps, ps-&gt;current_committed++, &amp;ce);
<span class="p_header">diff --git a/drivers/md/dm-snap-transient.c b/drivers/md/dm-snap-transient.c</span>
<span class="p_header">index 1ce9a2586e41..31439d53cf7e 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap-transient.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap-transient.c</span>
<span class="p_chunk">@@ -52,12 +52,12 @@</span> <span class="p_context"> static int transient_prepare_exception(struct dm_exception_store *store,</span>
 }
 
 static void transient_commit_exception(struct dm_exception_store *store,
<span class="p_del">-				       struct dm_exception *e,</span>
<span class="p_add">+				       struct dm_exception *e, int valid,</span>
 				       void (*callback) (void *, int success),
 				       void *callback_context)
 {
 	/* Just succeed */
<span class="p_del">-	callback(callback_context, 1);</span>
<span class="p_add">+	callback(callback_context, valid);</span>
 }
 
 static void transient_usage(struct dm_exception_store *store,
<span class="p_header">diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c</span>
<span class="p_header">index d892a05c84f4..dbd0f00f7395 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap.c</span>
<span class="p_chunk">@@ -1388,8 +1388,9 @@</span> <span class="p_context"> static void __invalidate_snapshot(struct dm_snapshot *s, int err)</span>
 	dm_table_event(s-&gt;ti-&gt;table);
 }
 
<span class="p_del">-static void pending_complete(struct dm_snap_pending_exception *pe, int success)</span>
<span class="p_add">+static void pending_complete(void *context, int success)</span>
 {
<span class="p_add">+	struct dm_snap_pending_exception *pe = context;</span>
 	struct dm_exception *e;
 	struct dm_snapshot *s = pe-&gt;snap;
 	struct bio *origin_bios = NULL;
<span class="p_chunk">@@ -1459,24 +1460,13 @@</span> <span class="p_context"> out:</span>
 	free_pending_exception(pe);
 }
 
<span class="p_del">-static void commit_callback(void *context, int success)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct dm_snap_pending_exception *pe = context;</span>
<span class="p_del">-</span>
<span class="p_del">-	pending_complete(pe, success);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void complete_exception(struct dm_snap_pending_exception *pe)
 {
 	struct dm_snapshot *s = pe-&gt;snap;
 
<span class="p_del">-	if (unlikely(pe-&gt;copy_error))</span>
<span class="p_del">-		pending_complete(pe, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	else</span>
<span class="p_del">-		/* Update the metadata if we are persistent */</span>
<span class="p_del">-		s-&gt;store-&gt;type-&gt;commit_exception(s-&gt;store, &amp;pe-&gt;e,</span>
<span class="p_del">-						 commit_callback, pe);</span>
<span class="p_add">+	/* Update the metadata if we are persistent */</span>
<span class="p_add">+	s-&gt;store-&gt;type-&gt;commit_exception(s-&gt;store, &amp;pe-&gt;e, !pe-&gt;copy_error,</span>
<span class="p_add">+					 pending_complete, pe);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/dm-thin-metadata.c b/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">index 43f6250baadd..4bf9211b2740 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin-metadata.c</span>
<span class="p_chunk">@@ -1191,6 +1191,12 @@</span> <span class="p_context"> static int __reserve_metadata_snap(struct dm_pool_metadata *pmd)</span>
 	dm_block_t held_root;
 
 	/*
<span class="p_add">+	 * We commit to ensure the btree roots which we increment in a</span>
<span class="p_add">+	 * moment are up to date.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__commit_transaction(pmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Copy the superblock.
 	 */
 	dm_sm_inc_block(pmd-&gt;metadata_sm, THIN_SUPERBLOCK_LOCATION);
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index ec56072c6326..295f74d4f0ab 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -2281,7 +2281,7 @@</span> <span class="p_context"> static void pool_postsuspend(struct dm_target *ti)</span>
 	struct pool_c *pt = ti-&gt;private;
 	struct pool *pool = pt-&gt;pool;
 
<span class="p_del">-	cancel_delayed_work(&amp;pool-&gt;waker);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;pool-&gt;waker);</span>
 	flush_workqueue(pool-&gt;wq);
 	(void) commit_or_fallback(pool);
 }
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 6d7f4d950b8f..b07fcda9ca71 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -235,6 +235,16 @@</span> <span class="p_context"> static bool is_internal_level(struct dm_btree_info *info, struct frame *f)</span>
 	return f-&gt;level &lt; (info-&gt;levels - 1);
 }
 
<span class="p_add">+static void unlock_all_frames(struct del_stack *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct frame *f;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (unprocessed_frames(s)) {</span>
<span class="p_add">+		f = s-&gt;spine + s-&gt;top--;</span>
<span class="p_add">+		dm_tm_unlock(s-&gt;tm, f-&gt;b);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int dm_btree_del(struct dm_btree_info *info, dm_block_t root)
 {
 	int r;
<span class="p_chunk">@@ -290,9 +300,13 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 			f-&gt;current_child = f-&gt;nr_children;
 		}
 	}
<span class="p_del">-</span>
 out:
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		/* cleanup all frames of del_stack */</span>
<span class="p_add">+		unlock_all_frames(s);</span>
<span class="p_add">+	}</span>
 	kfree(s);
<span class="p_add">+</span>
 	return r;
 }
 EXPORT_SYMBOL_GPL(dm_btree_del);
<span class="p_header">diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c</span>
<span class="p_header">index 1f925e856974..46a984291b7d 100644</span>
<span class="p_header">--- a/drivers/media/dvb-core/dvb_frontend.c</span>
<span class="p_header">+++ b/drivers/media/dvb-core/dvb_frontend.c</span>
<span class="p_chunk">@@ -2195,9 +2195,9 @@</span> <span class="p_context"> static int dvb_frontend_ioctl_legacy(struct file *file,</span>
 		dev_dbg(fe-&gt;dvb-&gt;device, &quot;%s: current delivery system on cache: %d, V3 type: %d\n&quot;,
 				 __func__, c-&gt;delivery_system, fe-&gt;ops.info.type);
 
<span class="p_del">-		/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn&#39;t</span>
<span class="p_del">-		 * do it, it is done for it. */</span>
<span class="p_del">-		info-&gt;caps |= FE_CAN_INVERSION_AUTO;</span>
<span class="p_add">+		/* Set CAN_INVERSION_AUTO bit on in other than oneshot mode */</span>
<span class="p_add">+		if (!(fepriv-&gt;tune_mode_flags &amp; FE_TUNE_MODE_ONESHOT))</span>
<span class="p_add">+			info-&gt;caps |= FE_CAN_INVERSION_AUTO;</span>
 		err = 0;
 		break;
 	}
<span class="p_header">diff --git a/drivers/media/dvb-frontends/tda1004x.c b/drivers/media/dvb-frontends/tda1004x.c</span>
<span class="p_header">index a2631be7ffac..08e0f0dd8728 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/tda1004x.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/tda1004x.c</span>
<span class="p_chunk">@@ -903,9 +903,18 @@</span> <span class="p_context"> static int tda1004x_get_fe(struct dvb_frontend *fe)</span>
 {
 	struct dtv_frontend_properties *fe_params = &amp;fe-&gt;dtv_property_cache;
 	struct tda1004x_state* state = fe-&gt;demodulator_priv;
<span class="p_add">+	int status;</span>
 
 	dprintk(&quot;%s\n&quot;, __func__);
 
<span class="p_add">+	status = tda1004x_read_byte(state, TDA1004X_STATUS_CD);</span>
<span class="p_add">+	if (status == -1)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only update the properties cache if device is locked */</span>
<span class="p_add">+	if (!(status &amp; 8))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	// inversion status
 	fe_params-&gt;inversion = INVERSION_OFF;
 	if (tda1004x_read_byte(state, TDA1004X_CONFC1) &amp; 0x20)
<span class="p_header">diff --git a/drivers/media/usb/gspca/ov534.c b/drivers/media/usb/gspca/ov534.c</span>
<span class="p_header">index 2e28c81a03ab..a5bee0d0d686 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/ov534.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/ov534.c</span>
<span class="p_chunk">@@ -1490,8 +1490,13 @@</span> <span class="p_context"> static void sd_set_streamparm(struct gspca_dev *gspca_dev,</span>
 	struct v4l2_fract *tpf = &amp;cp-&gt;timeperframe;
 	struct sd *sd = (struct sd *) gspca_dev;
 
<span class="p_del">-	/* Set requested framerate */</span>
<span class="p_del">-	sd-&gt;frame_rate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+	if (tpf-&gt;numerator == 0 || tpf-&gt;denominator == 0)</span>
<span class="p_add">+		/* Set default framerate */</span>
<span class="p_add">+		sd-&gt;frame_rate = 30;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		/* Set requested framerate */</span>
<span class="p_add">+		sd-&gt;frame_rate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+</span>
 	if (gspca_dev-&gt;streaming)
 		set_frame_rate(gspca_dev);
 
<span class="p_header">diff --git a/drivers/media/usb/gspca/topro.c b/drivers/media/usb/gspca/topro.c</span>
<span class="p_header">index 4cb511ccc5f6..22ea6aefd22f 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/topro.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/topro.c</span>
<span class="p_chunk">@@ -4791,7 +4791,11 @@</span> <span class="p_context"> static void sd_set_streamparm(struct gspca_dev *gspca_dev,</span>
 	struct v4l2_fract *tpf = &amp;cp-&gt;timeperframe;
 	int fr, i;
 
<span class="p_del">-	sd-&gt;framerate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+	if (tpf-&gt;numerator == 0 || tpf-&gt;denominator == 0)</span>
<span class="p_add">+		sd-&gt;framerate = 30;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sd-&gt;framerate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+</span>
 	if (gspca_dev-&gt;streaming)
 		setframerate(gspca_dev, v4l2_ctrl_g_ctrl(gspca_dev-&gt;exposure));
 
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 885ba4a19a6c..ebb40a292d67 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -59,8 +59,7 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;mmc:block&quot;);</span>
 #define INAND_CMD38_ARG_SECTRIM2 0x88
 #define MMC_BLK_TIMEOUT_MS  (10 * 60 * 1000)        /* 10 minute timeout */
 
<span class="p_del">-#define mmc_req_rel_wr(req)	(((req-&gt;cmd_flags &amp; REQ_FUA) || \</span>
<span class="p_del">-				  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp; \</span>
<span class="p_add">+#define mmc_req_rel_wr(req)	((req-&gt;cmd_flags &amp; REQ_FUA) &amp;&amp; \</span>
 				  (rq_data_dir(req) == WRITE))
 #define PACKED_CMD_VER	0x01
 #define PACKED_CMD_WR	0x02
<span class="p_chunk">@@ -1300,13 +1299,9 @@</span> <span class="p_context"> static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span>
 
 	/*
 	 * Reliable writes are used to implement Forced Unit Access and
<span class="p_del">-	 * REQ_META accesses, and are supported only on MMCs.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * XXX: this really needs a good explanation of why REQ_META</span>
<span class="p_del">-	 * is treated special.</span>
<span class="p_add">+	 * are supported only on MMCs.</span>
 	 */
<span class="p_del">-	bool do_rel_wr = ((req-&gt;cmd_flags &amp; REQ_FUA) ||</span>
<span class="p_del">-			  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp;</span>
<span class="p_add">+	bool do_rel_wr = (req-&gt;cmd_flags &amp; REQ_FUA) &amp;&amp;</span>
 		(rq_data_dir(req) == WRITE) &amp;&amp;
 		(md-&gt;flags &amp; MMC_BLK_REL_WR);
 
<span class="p_header">diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c</span>
<span class="p_header">index f4f3038c1df0..faeda85e78fa 100644</span>
<span class="p_header">--- a/drivers/mmc/host/mmci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/mmci.c</span>
<span class="p_chunk">@@ -1740,7 +1740,7 @@</span> <span class="p_context"> static struct amba_id mmci_ids[] = {</span>
 	{
 		.id     = 0x00280180,
 		.mask   = 0x00ffffff,
<span class="p_del">-		.data	= &amp;variant_u300,</span>
<span class="p_add">+		.data	= &amp;variant_nomadik,</span>
 	},
 	{
 		.id     = 0x00480180,
<span class="p_header">diff --git a/drivers/net/can/sja1000/sja1000.c b/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_header">index c2d0559115d3..732a8ed571c2 100644</span>
<span class="p_header">--- a/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_header">+++ b/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_chunk">@@ -187,6 +187,9 @@</span> <span class="p_context"> static void sja1000_start(struct net_device *dev)</span>
 	/* clear interrupt flags */
 	priv-&gt;read_reg(priv, SJA1000_IR);
 
<span class="p_add">+	/* clear interrupt flags */</span>
<span class="p_add">+	priv-&gt;read_reg(priv, SJA1000_IR);</span>
<span class="p_add">+</span>
 	/* leave reset mode */
 	set_normal_mode(dev);
 }
<span class="p_header">diff --git a/drivers/net/can/usb/ems_usb.c b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">index 5f9a7ad9b964..d921416295ce 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_chunk">@@ -118,6 +118,9 @@</span> <span class="p_context"> MODULE_LICENSE(&quot;GPL v2&quot;);</span>
  */
 #define EMS_USB_ARM7_CLOCK 8000000
 
<span class="p_add">+#define CPC_TX_QUEUE_TRIGGER_LOW	25</span>
<span class="p_add">+#define CPC_TX_QUEUE_TRIGGER_HIGH	35</span>
<span class="p_add">+</span>
 /*
  * CAN-Message representation in a CPC_MSG. Message object type is
  * CPC_MSG_TYPE_CAN_FRAME or CPC_MSG_TYPE_RTR_FRAME or
<span class="p_chunk">@@ -279,6 +282,11 @@</span> <span class="p_context"> static void ems_usb_read_interrupt_callback(struct urb *urb)</span>
 	switch (urb-&gt;status) {
 	case 0:
 		dev-&gt;free_slots = dev-&gt;intr_in_buffer[1];
<span class="p_add">+		if(dev-&gt;free_slots &gt; CPC_TX_QUEUE_TRIGGER_HIGH){</span>
<span class="p_add">+			if (netif_queue_stopped(netdev)){</span>
<span class="p_add">+				netif_wake_queue(netdev);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 		break;
 
 	case -ECONNRESET: /* unlink */
<span class="p_chunk">@@ -530,8 +538,6 @@</span> <span class="p_context"> static void ems_usb_write_bulk_callback(struct urb *urb)</span>
 	/* Release context */
 	context-&gt;echo_index = MAX_TX_URBS;
 
<span class="p_del">-	if (netif_queue_stopped(netdev))</span>
<span class="p_del">-		netif_wake_queue(netdev);</span>
 }
 
 /*
<span class="p_chunk">@@ -591,7 +597,7 @@</span> <span class="p_context"> static int ems_usb_start(struct ems_usb *dev)</span>
 	int err, i;
 
 	dev-&gt;intr_in_buffer[0] = 0;
<span class="p_del">-	dev-&gt;free_slots = 15; /* initial size */</span>
<span class="p_add">+	dev-&gt;free_slots = 50; /* initial size */</span>
 
 	for (i = 0; i &lt; MAX_RX_URBS; i++) {
 		struct urb *urb = NULL;
<span class="p_chunk">@@ -841,7 +847,7 @@</span> <span class="p_context"> static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *ne</span>
 
 		/* Slow down tx path */
 		if (atomic_read(&amp;dev-&gt;active_tx_urbs) &gt;= MAX_TX_URBS ||
<span class="p_del">-		    dev-&gt;free_slots &lt; 5) {</span>
<span class="p_add">+		    dev-&gt;free_slots &lt; CPC_TX_QUEUE_TRIGGER_LOW) {</span>
 			netif_stop_queue(netdev);
 		}
 	}
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv.c b/drivers/pci/pcie/aer/aerdrv.c</span>
<span class="p_header">index 76ef634caf6f..b84e713445d0 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv.c</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv.c</span>
<span class="p_chunk">@@ -262,7 +262,6 @@</span> <span class="p_context"> static struct aer_rpc *aer_alloc_rpc(struct pcie_device *dev)</span>
 	rpc-&gt;rpd = dev;
 	INIT_WORK(&amp;rpc-&gt;dpc_handler, aer_isr);
 	mutex_init(&amp;rpc-&gt;rpc_mutex);
<span class="p_del">-	init_waitqueue_head(&amp;rpc-&gt;wait_release);</span>
 
 	/* Use PCIe bus function to store rpc into PCIe device */
 	set_service_data(dev, rpc);
<span class="p_chunk">@@ -285,8 +284,7 @@</span> <span class="p_context"> static void aer_remove(struct pcie_device *dev)</span>
 		if (rpc-&gt;isr)
 			free_irq(dev-&gt;irq, dev);
 
<span class="p_del">-		wait_event(rpc-&gt;wait_release, rpc-&gt;prod_idx == rpc-&gt;cons_idx);</span>
<span class="p_del">-</span>
<span class="p_add">+		flush_work(&amp;rpc-&gt;dpc_handler);</span>
 		aer_disable_rootport(rpc);
 		kfree(rpc);
 		set_service_data(dev, NULL);
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv.h b/drivers/pci/pcie/aer/aerdrv.h</span>
<span class="p_header">index d12c77cd6991..3b8766e1e51b 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv.h</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv.h</span>
<span class="p_chunk">@@ -76,7 +76,6 @@</span> <span class="p_context"> struct aer_rpc {</span>
 					 * recovery on the same
 					 * root port hierarchy
 					 */
<span class="p_del">-	wait_queue_head_t wait_release;</span>
 };
 
 struct aer_broadcast_data {
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">index 0f4554e48cc5..a017aac0d7ed 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_chunk">@@ -817,8 +817,6 @@</span> <span class="p_context"> void aer_isr(struct work_struct *work)</span>
 	while (get_e_source(rpc, &amp;e_src))
 		aer_isr_one_error(p_device, &amp;e_src);
 	mutex_unlock(&amp;rpc-&gt;rpc_mutex);
<span class="p_del">-</span>
<span class="p_del">-	wake_up(&amp;rpc-&gt;wait_release);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/pci/xen-pcifront.c b/drivers/pci/xen-pcifront.c</span>
<span class="p_header">index f7197a790341..eb402f4f0e2f 100644</span>
<span class="p_header">--- a/drivers/pci/xen-pcifront.c</span>
<span class="p_header">+++ b/drivers/pci/xen-pcifront.c</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> struct pcifront_device {</span>
 };
 
 struct pcifront_sd {
<span class="p_del">-	int domain;</span>
<span class="p_add">+	struct pci_sysdata sd;</span>
 	struct pcifront_device *pdev;
 };
 
<span class="p_chunk">@@ -65,7 +65,9 @@</span> <span class="p_context"> static inline void pcifront_init_sd(struct pcifront_sd *sd,</span>
 				    unsigned int domain, unsigned int bus,
 				    struct pcifront_device *pdev)
 {
<span class="p_del">-	sd-&gt;domain = domain;</span>
<span class="p_add">+	/* Because we do not expose that information via XenBus. */</span>
<span class="p_add">+	sd-&gt;sd.node = first_online_node;</span>
<span class="p_add">+	sd-&gt;sd.domain = domain;</span>
 	sd-&gt;pdev = pdev;
 }
 
<span class="p_chunk">@@ -463,8 +465,8 @@</span> <span class="p_context"> static int pcifront_scan_root(struct pcifront_device *pdev,</span>
 	dev_info(&amp;pdev-&gt;xdev-&gt;dev, &quot;Creating PCI Frontend Bus %04x:%02x\n&quot;,
 		 domain, bus);
 
<span class="p_del">-	bus_entry = kmalloc(sizeof(*bus_entry), GFP_KERNEL);</span>
<span class="p_del">-	sd = kmalloc(sizeof(*sd), GFP_KERNEL);</span>
<span class="p_add">+	bus_entry = kzalloc(sizeof(*bus_entry), GFP_KERNEL);</span>
<span class="p_add">+	sd = kzalloc(sizeof(*sd), GFP_KERNEL);</span>
 	if (!bus_entry || !sd) {
 		err = -ENOMEM;
 		goto err_out;
<span class="p_header">diff --git a/drivers/power/wm831x_power.c b/drivers/power/wm831x_power.c</span>
<span class="p_header">index 3bed2f55cf7d..3ccadf631d45 100644</span>
<span class="p_header">--- a/drivers/power/wm831x_power.c</span>
<span class="p_header">+++ b/drivers/power/wm831x_power.c</span>
<span class="p_chunk">@@ -567,7 +567,7 @@</span> <span class="p_context"> static int wm831x_power_probe(struct platform_device *pdev)</span>
 
 	irq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, &quot;SYSLO&quot;));
 	ret = request_threaded_irq(irq, NULL, wm831x_syslo_irq,
<span class="p_del">-				   IRQF_TRIGGER_RISING, &quot;System power low&quot;,</span>
<span class="p_add">+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT, &quot;System power low&quot;,</span>
 				   power);
 	if (ret != 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to request SYSLO IRQ %d: %d\n&quot;,
<span class="p_chunk">@@ -577,7 +577,7 @@</span> <span class="p_context"> static int wm831x_power_probe(struct platform_device *pdev)</span>
 
 	irq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, &quot;PWR SRC&quot;));
 	ret = request_threaded_irq(irq, NULL, wm831x_pwr_src_irq,
<span class="p_del">-				   IRQF_TRIGGER_RISING, &quot;Power source&quot;,</span>
<span class="p_add">+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT, &quot;Power source&quot;,</span>
 				   power);
 	if (ret != 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to request PWR SRC IRQ %d: %d\n&quot;,
<span class="p_chunk">@@ -590,7 +590,7 @@</span> <span class="p_context"> static int wm831x_power_probe(struct platform_device *pdev)</span>
 				 platform_get_irq_byname(pdev,
 							 wm831x_bat_irqs[i]));
 		ret = request_threaded_irq(irq, NULL, wm831x_bat_irq,
<span class="p_del">-					   IRQF_TRIGGER_RISING,</span>
<span class="p_add">+					   IRQF_TRIGGER_RISING | IRQF_ONESHOT,</span>
 					   wm831x_bat_irqs[i],
 					   power);
 		if (ret != 0) {
<span class="p_header">diff --git a/drivers/s390/block/dasd_alias.c b/drivers/s390/block/dasd_alias.c</span>
<span class="p_header">index a2597e683e79..6a64e86e8ccd 100644</span>
<span class="p_header">--- a/drivers/s390/block/dasd_alias.c</span>
<span class="p_header">+++ b/drivers/s390/block/dasd_alias.c</span>
<span class="p_chunk">@@ -264,8 +264,10 @@</span> <span class="p_context"> void dasd_alias_disconnect_device_from_lcu(struct dasd_device *device)</span>
 		spin_unlock_irqrestore(&amp;lcu-&gt;lock, flags);
 		cancel_work_sync(&amp;lcu-&gt;suc_data.worker);
 		spin_lock_irqsave(&amp;lcu-&gt;lock, flags);
<span class="p_del">-		if (device == lcu-&gt;suc_data.device)</span>
<span class="p_add">+		if (device == lcu-&gt;suc_data.device) {</span>
<span class="p_add">+			dasd_put_device(device);</span>
 			lcu-&gt;suc_data.device = NULL;
<span class="p_add">+		}</span>
 	}
 	was_pending = 0;
 	if (device == lcu-&gt;ruac_data.device) {
<span class="p_chunk">@@ -273,8 +275,10 @@</span> <span class="p_context"> void dasd_alias_disconnect_device_from_lcu(struct dasd_device *device)</span>
 		was_pending = 1;
 		cancel_delayed_work_sync(&amp;lcu-&gt;ruac_data.dwork);
 		spin_lock_irqsave(&amp;lcu-&gt;lock, flags);
<span class="p_del">-		if (device == lcu-&gt;ruac_data.device)</span>
<span class="p_add">+		if (device == lcu-&gt;ruac_data.device) {</span>
<span class="p_add">+			dasd_put_device(device);</span>
 			lcu-&gt;ruac_data.device = NULL;
<span class="p_add">+		}</span>
 	}
 	private-&gt;lcu = NULL;
 	spin_unlock_irqrestore(&amp;lcu-&gt;lock, flags);
<span class="p_chunk">@@ -549,8 +553,10 @@</span> <span class="p_context"> static void lcu_update_work(struct work_struct *work)</span>
 	if ((rc &amp;&amp; (rc != -EOPNOTSUPP)) || (lcu-&gt;flags &amp; NEED_UAC_UPDATE)) {
 		DBF_DEV_EVENT(DBF_WARNING, device, &quot;could not update&quot;
 			    &quot; alias data in lcu (rc = %d), retry later&quot;, rc);
<span class="p_del">-		schedule_delayed_work(&amp;lcu-&gt;ruac_data.dwork, 30*HZ);</span>
<span class="p_add">+		if (!schedule_delayed_work(&amp;lcu-&gt;ruac_data.dwork, 30*HZ))</span>
<span class="p_add">+			dasd_put_device(device);</span>
 	} else {
<span class="p_add">+		dasd_put_device(device);</span>
 		lcu-&gt;ruac_data.device = NULL;
 		lcu-&gt;flags &amp;= ~UPDATE_PENDING;
 	}
<span class="p_chunk">@@ -593,8 +599,10 @@</span> <span class="p_context"> static int _schedule_lcu_update(struct alias_lcu *lcu,</span>
 	 */
 	if (!usedev)
 		return -EINVAL;
<span class="p_add">+	dasd_get_device(usedev);</span>
 	lcu-&gt;ruac_data.device = usedev;
<span class="p_del">-	schedule_delayed_work(&amp;lcu-&gt;ruac_data.dwork, 0);</span>
<span class="p_add">+	if (!schedule_delayed_work(&amp;lcu-&gt;ruac_data.dwork, 0))</span>
<span class="p_add">+		dasd_put_device(usedev);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -722,7 +730,7 @@</span> <span class="p_context"> static int reset_summary_unit_check(struct alias_lcu *lcu,</span>
 	ASCEBC((char *) &amp;cqr-&gt;magic, 4);
 	ccw = cqr-&gt;cpaddr;
 	ccw-&gt;cmd_code = DASD_ECKD_CCW_RSCK;
<span class="p_del">-	ccw-&gt;flags = 0 ;</span>
<span class="p_add">+	ccw-&gt;flags = CCW_FLAG_SLI;</span>
 	ccw-&gt;count = 16;
 	ccw-&gt;cda = (__u32)(addr_t) cqr-&gt;data;
 	((char *)cqr-&gt;data)[0] = reason;
<span class="p_chunk">@@ -926,6 +934,7 @@</span> <span class="p_context"> static void summary_unit_check_handling_work(struct work_struct *work)</span>
 	/* 3. read new alias configuration */
 	_schedule_lcu_update(lcu, device);
 	lcu-&gt;suc_data.device = NULL;
<span class="p_add">+	dasd_put_device(device);</span>
 	spin_unlock_irqrestore(&amp;lcu-&gt;lock, flags);
 }
 
<span class="p_chunk">@@ -985,6 +994,8 @@</span> <span class="p_context"> void dasd_alias_handle_summary_unit_check(struct dasd_device *device,</span>
 	}
 	lcu-&gt;suc_data.reason = reason;
 	lcu-&gt;suc_data.device = device;
<span class="p_add">+	dasd_get_device(device);</span>
 	spin_unlock(&amp;lcu-&gt;lock);
<span class="p_del">-	schedule_work(&amp;lcu-&gt;suc_data.worker);</span>
<span class="p_add">+	if (!schedule_work(&amp;lcu-&gt;suc_data.worker))</span>
<span class="p_add">+		dasd_put_device(device);</span>
 };
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">index b52121358385..280e769a1686 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_chunk">@@ -300,6 +300,8 @@</span> <span class="p_context"> enum MR_EVT_ARGS {</span>
 	MR_EVT_ARGS_GENERIC,
 };
 
<span class="p_add">+</span>
<span class="p_add">+#define SGE_BUFFER_SIZE	4096</span>
 /*
  * define constants for device list query options
  */
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 78b4fe845245..e6dfa8108301 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -3602,7 +3602,7 @@</span> <span class="p_context"> static int megasas_init_fw(struct megasas_instance *instance)</span>
 	}
 
 	instance-&gt;max_sectors_per_req = instance-&gt;max_num_sge *
<span class="p_del">-						PAGE_SIZE / 512;</span>
<span class="p_add">+						SGE_BUFFER_SIZE / 512;</span>
 	if (tmp_sectors &amp;&amp; (instance-&gt;max_sectors_per_req &gt; tmp_sectors))
 		instance-&gt;max_sectors_per_req = tmp_sectors;
 
<span class="p_chunk">@@ -5051,6 +5051,9 @@</span> <span class="p_context"> static int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)</span>
 	int i;
 	int error = 0;
 	compat_uptr_t ptr;
<span class="p_add">+	unsigned long local_raw_ptr;</span>
<span class="p_add">+	u32 local_sense_off;</span>
<span class="p_add">+	u32 local_sense_len;</span>
 
 	if (clear_user(ioc, sizeof(*ioc)))
 		return -EFAULT;
<span class="p_chunk">@@ -5068,9 +5071,15 @@</span> <span class="p_context"> static int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)</span>
 	 * sense_len is not null, so prepare the 64bit value under
 	 * the same condition.
 	 */
<span class="p_del">-	if (ioc-&gt;sense_len) {</span>
<span class="p_add">+	if (get_user(local_raw_ptr, ioc-&gt;frame.raw) ||</span>
<span class="p_add">+		get_user(local_sense_off, &amp;ioc-&gt;sense_off) ||</span>
<span class="p_add">+		get_user(local_sense_len, &amp;ioc-&gt;sense_len))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	if (local_sense_len) {</span>
 		void __user **sense_ioc_ptr =
<span class="p_del">-			(void __user **)(ioc-&gt;frame.raw + ioc-&gt;sense_off);</span>
<span class="p_add">+			(void __user **)((u8*)local_raw_ptr + local_sense_off);</span>
 		compat_uptr_t *sense_cioc_ptr =
 			(compat_uptr_t *)(cioc-&gt;frame.raw + cioc-&gt;sense_off);
 		if (get_user(ptr, sense_cioc_ptr) ||
<span class="p_header">diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c</span>
<span class="p_header">index eba183c428cf..3643bbf5456d 100644</span>
<span class="p_header">--- a/drivers/scsi/ses.c</span>
<span class="p_header">+++ b/drivers/scsi/ses.c</span>
<span class="p_chunk">@@ -70,6 +70,7 @@</span> <span class="p_context"> static int ses_probe(struct device *dev)</span>
 static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 			 void *buf, int bufflen)
 {
<span class="p_add">+	int ret;</span>
 	unsigned char cmd[] = {
 		RECEIVE_DIAGNOSTIC,
 		1,		/* Set PCV bit */
<span class="p_chunk">@@ -78,9 +79,26 @@</span> <span class="p_context"> static int ses_recv_diag(struct scsi_device *sdev, int page_code,</span>
 		bufflen &amp; 0xff,
 		0
 	};
<span class="p_add">+	unsigned char recv_page_code;</span>
 
<span class="p_del">-	return scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,</span>
<span class="p_add">+	ret =  scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,</span>
 				NULL, SES_TIMEOUT, SES_RETRIES, NULL);
<span class="p_add">+	if (unlikely(!ret))</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	recv_page_code = ((unsigned char *)buf)[0];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(recv_page_code == page_code))</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* successful diagnostic but wrong page code.  This happens to some</span>
<span class="p_add">+	 * USB devices, just print a message and pretend there was an error */</span>
<span class="p_add">+</span>
<span class="p_add">+	sdev_printk(KERN_ERR, sdev,</span>
<span class="p_add">+		    &quot;Wrong diagnostic page; asked for %d got %u\n&quot;,</span>
<span class="p_add">+		    page_code, recv_page_code);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int ses_send_diag(struct scsi_device *sdev, int page_code,
<span class="p_chunk">@@ -436,7 +454,15 @@</span> <span class="p_context"> static void ses_enclosure_data_process(struct enclosure_device *edev,</span>
 			if (desc_ptr)
 				desc_ptr += len;
 
<span class="p_del">-			if (addl_desc_ptr)</span>
<span class="p_add">+			if (addl_desc_ptr &amp;&amp;</span>
<span class="p_add">+			    /* only find additional descriptions for specific devices */</span>
<span class="p_add">+			    (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SAS_EXPANDER ||</span>
<span class="p_add">+			     /* these elements are optional */</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_TARGET_PORT ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS))</span>
 				addl_desc_ptr += addl_desc_ptr[1] + 2;
 
 		}
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index d2ea64de92df..d6dab8adf60e 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1726,6 +1726,11 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	},
 #endif
 
<span class="p_add">+	/*Samsung phone in firmware update mode */</span>
<span class="p_add">+	{ USB_DEVICE(0x04e8, 0x685d),</span>
<span class="p_add">+	.driver_info = IGNORE_DEVICE,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	/* Exclude Infineon Flash Loader utility */
 	{ USB_DEVICE(0x058b, 0x0041),
 	.driver_info = IGNORE_DEVICE,
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 89ba7cfba5bc..303f3b3fb65f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -162,6 +162,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
 	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */
<span class="p_add">+	{ USB_DEVICE(0x1901, 0x0190) }, /* GE B850 CP2105 Recorder interface */</span>
<span class="p_add">+	{ USB_DEVICE(0x1901, 0x0193) }, /* GE B650 CP2104 PMC interface */</span>
 	{ USB_DEVICE(0x1ADB, 0x0001) }, /* Schweitzer Engineering C662 Cable */
 	{ USB_DEVICE(0x1B1C, 0x1C00) }, /* Corsair USB Dongle */
 	{ USB_DEVICE(0x1BA4, 0x0002) },	/* Silicon Labs 358x factory default */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 81f6a572f016..9bab34cf01d4 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -315,6 +315,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TOSHIBA_PRODUCT_G450			0x0d45
 
 #define ALINK_VENDOR_ID				0x1e0e
<span class="p_add">+#define SIMCOM_PRODUCT_SIM7100E			0x9001 /* Yes, ALINK_VENDOR_ID */</span>
 #define ALINK_PRODUCT_PH300			0x9100
 #define ALINK_PRODUCT_3GU			0x9200
 
<span class="p_chunk">@@ -615,6 +616,10 @@</span> <span class="p_context"> static const struct option_blacklist_info zte_1255_blacklist = {</span>
 	.reserved = BIT(3) | BIT(4),
 };
 
<span class="p_add">+static const struct option_blacklist_info simcom_sim7100e_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(5) | BIT(6),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info telit_le910_blacklist = {
 	.sendsetup = BIT(0),
 	.reserved = BIT(1) | BIT(2),
<span class="p_chunk">@@ -1130,6 +1135,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_PRODUCT_KPC650) },
 	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_PRODUCT_KPC680) },
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6000)}, /* ZTE AC8700 */
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x6001, 0xff, 0xff, 0xff), /* 4G LTE usb-modem U901 */</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;net_intf3_blacklist },</span>
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6613)}, /* Onda H600/ZTE MF330 */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x0023)}, /* ONYX 3G device */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000)}, /* SIMCom SIM5218 */
<span class="p_chunk">@@ -1645,6 +1652,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(ALINK_VENDOR_ID, 0x9000) },
 	{ USB_DEVICE(ALINK_VENDOR_ID, ALINK_PRODUCT_PH300) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ALINK_VENDOR_ID, ALINK_PRODUCT_3GU, 0xff, 0xff, 0xff) },
<span class="p_add">+	{ USB_DEVICE(ALINK_VENDOR_ID, SIMCOM_PRODUCT_SIM7100E),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;simcom_sim7100e_blacklist },</span>
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_X060S_X200),
 	  .driver_info = (kernel_ulong_t)&amp;alcatel_x200_blacklist
 	},
<span class="p_header">diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c</span>
<span class="p_header">index ee59b74768d9..beaa7cc4e857 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio.c</span>
<span class="p_chunk">@@ -238,6 +238,7 @@</span> <span class="p_context"> static int virtio_init(void)</span>
 static void __exit virtio_exit(void)
 {
 	bus_unregister(&amp;virtio_bus);
<span class="p_add">+	ida_destroy(&amp;virtio_index_ida);</span>
 }
 core_initcall(virtio_init);
 module_exit(virtio_exit);
<span class="p_header">diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c</span>
<span class="p_header">index 7360f03ddbe1..9612a01198df 100644</span>
<span class="p_header">--- a/fs/btrfs/disk-io.c</span>
<span class="p_header">+++ b/fs/btrfs/disk-io.c</span>
<span class="p_chunk">@@ -2437,6 +2437,7 @@</span> <span class="p_context"> int open_ctree(struct super_block *sb,</span>
 		       &quot;unsupported option features (%Lx).\n&quot;,
 		       (unsigned long long)features);
 		err = -EINVAL;
<span class="p_add">+		brelse(bh);</span>
 		goto fail_alloc;
 	}
 
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index ae29b403a7e2..b5d13c4eea00 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -7477,15 +7477,28 @@</span> <span class="p_context"> int btrfs_readpage(struct file *file, struct page *page)</span>
 static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
 {
 	struct extent_io_tree *tree;
<span class="p_del">-</span>
<span class="p_add">+	struct inode *inode = page-&gt;mapping-&gt;host;</span>
<span class="p_add">+	int ret;</span>
 
 	if (current-&gt;flags &amp; PF_MEMALLOC) {
 		redirty_page_for_writepage(wbc, page);
 		unlock_page(page);
 		return 0;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we are under memory pressure we will call this directly from the</span>
<span class="p_add">+	 * VM, we need to make sure we have the inode referenced for the ordered</span>
<span class="p_add">+	 * extent.  If not just return like we didn&#39;t do anything.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!igrab(inode)) {</span>
<span class="p_add">+		redirty_page_for_writepage(wbc, page);</span>
<span class="p_add">+		return AOP_WRITEPAGE_ACTIVATE;</span>
<span class="p_add">+	}</span>
 	tree = &amp;BTRFS_I(page-&gt;mapping-&gt;host)-&gt;io_tree;
<span class="p_del">-	return extent_write_full_page(tree, page, btrfs_get_extent, wbc);</span>
<span class="p_add">+	ret = extent_write_full_page(tree, page, btrfs_get_extent, wbc);</span>
<span class="p_add">+	btrfs_add_delayed_iput(inode);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int btrfs_writepages(struct address_space *mapping,
<span class="p_chunk">@@ -8474,9 +8487,11 @@</span> <span class="p_context"> static int btrfs_symlink(struct inode *dir, struct dentry *dentry,</span>
 	/*
 	 * 2 items for inode item and ref
 	 * 2 items for dir items
<span class="p_add">+	 * 1 item for updating parent inode item</span>
<span class="p_add">+	 * 1 item for the inline extent item</span>
 	 * 1 item for xattr if selinux is on
 	 */
<span class="p_del">-	trans = btrfs_start_transaction(root, 5);</span>
<span class="p_add">+	trans = btrfs_start_transaction(root, 7);</span>
 	if (IS_ERR(trans))
 		return PTR_ERR(trans);
 
<span class="p_header">diff --git a/fs/btrfs/send.c b/fs/btrfs/send.c</span>
<span class="p_header">index 414c1b9eb896..3104e0eec816 100644</span>
<span class="p_header">--- a/fs/btrfs/send.c</span>
<span class="p_header">+++ b/fs/btrfs/send.c</span>
<span class="p_chunk">@@ -1338,7 +1338,21 @@</span> <span class="p_context"> static int read_symlink(struct send_ctx *sctx,</span>
 	ret = btrfs_search_slot(NULL, root, &amp;key, path, 0, 0);
 	if (ret &lt; 0)
 		goto out;
<span class="p_del">-	BUG_ON(ret);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * An empty symlink inode. Can happen in rare error paths when</span>
<span class="p_add">+		 * creating a symlink (transaction committed before the inode</span>
<span class="p_add">+		 * eviction handler removed the symlink inode items and a crash</span>
<span class="p_add">+		 * happened in between or the subvol was snapshoted in between).</span>
<span class="p_add">+		 * Print an informative message to dmesg/syslog so that the user</span>
<span class="p_add">+		 * can delete the symlink.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		btrfs_err(root-&gt;fs_info,</span>
<span class="p_add">+			  &quot;Found empty symlink inode %llu at root %llu&quot;,</span>
<span class="p_add">+			  ino, root-&gt;root_key.objectid);</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	ei = btrfs_item_ptr(path-&gt;nodes[0], path-&gt;slots[0],
 			struct btrfs_file_extent_item);
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index 32f35f187989..b58a9cbb9695 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -720,15 +720,13 @@</span> <span class="p_context"> static int hostfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,</span>
 
 	init_special_inode(inode, mode, dev);
 	err = do_mknod(name, mode, MAJOR(dev), MINOR(dev));
<span class="p_del">-	if (!err)</span>
<span class="p_add">+	if (err)</span>
 		goto out_free;
 
 	err = read_name(inode, name);
 	__putname(name);
 	if (err)
 		goto out_put;
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_put;</span>
 
 	d_instantiate(dentry, inode);
 	return 0;
<span class="p_header">diff --git a/fs/lockd/host.c b/fs/lockd/host.c</span>
<span class="p_header">index 969d589c848d..b5f3c3ab0d5f 100644</span>
<span class="p_header">--- a/fs/lockd/host.c</span>
<span class="p_header">+++ b/fs/lockd/host.c</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> static struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,</span>
 		atomic_inc(&amp;nsm-&gt;sm_count);
 	else {
 		host = NULL;
<span class="p_del">-		nsm = nsm_get_handle(ni-&gt;sap, ni-&gt;salen,</span>
<span class="p_add">+		nsm = nsm_get_handle(ni-&gt;net, ni-&gt;sap, ni-&gt;salen,</span>
 					ni-&gt;hostname, ni-&gt;hostname_len);
 		if (unlikely(nsm == NULL)) {
 			dprintk(&quot;lockd: %s failed; no nsm handle\n&quot;,
<span class="p_chunk">@@ -534,17 +534,18 @@</span> <span class="p_context"> static struct nlm_host *next_host_state(struct hlist_head *cache,</span>
 
 /**
  * nlm_host_rebooted - Release all resources held by rebooted host
<span class="p_add">+ * @net:  network namespace</span>
  * @info: pointer to decoded results of NLM_SM_NOTIFY call
  *
  * We were notified that the specified host has rebooted.  Release
  * all resources held by that peer.
  */
<span class="p_del">-void nlm_host_rebooted(const struct nlm_reboot *info)</span>
<span class="p_add">+void nlm_host_rebooted(const struct net *net, const struct nlm_reboot *info)</span>
 {
 	struct nsm_handle *nsm;
 	struct nlm_host	*host;
 
<span class="p_del">-	nsm = nsm_reboot_lookup(info);</span>
<span class="p_add">+	nsm = nsm_reboot_lookup(net, info);</span>
 	if (unlikely(nsm == NULL))
 		return;
 
<span class="p_header">diff --git a/fs/lockd/mon.c b/fs/lockd/mon.c</span>
<span class="p_header">index 6ae664b489af..13fac49aff7f 100644</span>
<span class="p_header">--- a/fs/lockd/mon.c</span>
<span class="p_header">+++ b/fs/lockd/mon.c</span>
<span class="p_chunk">@@ -51,7 +51,6 @@</span> <span class="p_context"> struct nsm_res {</span>
 };
 
 static const struct rpc_program	nsm_program;
<span class="p_del">-static				LIST_HEAD(nsm_handles);</span>
 static				DEFINE_SPINLOCK(nsm_lock);
 
 /*
<span class="p_chunk">@@ -259,33 +258,35 @@</span> <span class="p_context"> void nsm_unmonitor(const struct nlm_host *host)</span>
 	}
 }
 
<span class="p_del">-static struct nsm_handle *nsm_lookup_hostname(const char *hostname,</span>
<span class="p_del">-					      const size_t len)</span>
<span class="p_add">+static struct nsm_handle *nsm_lookup_hostname(const struct list_head *nsm_handles,</span>
<span class="p_add">+					const char *hostname, const size_t len)</span>
 {
 	struct nsm_handle *nsm;
 
<span class="p_del">-	list_for_each_entry(nsm, &amp;nsm_handles, sm_link)</span>
<span class="p_add">+	list_for_each_entry(nsm, nsm_handles, sm_link)</span>
 		if (strlen(nsm-&gt;sm_name) == len &amp;&amp;
 		    memcmp(nsm-&gt;sm_name, hostname, len) == 0)
 			return nsm;
 	return NULL;
 }
 
<span class="p_del">-static struct nsm_handle *nsm_lookup_addr(const struct sockaddr *sap)</span>
<span class="p_add">+static struct nsm_handle *nsm_lookup_addr(const struct list_head *nsm_handles,</span>
<span class="p_add">+					const struct sockaddr *sap)</span>
 {
 	struct nsm_handle *nsm;
 
<span class="p_del">-	list_for_each_entry(nsm, &amp;nsm_handles, sm_link)</span>
<span class="p_add">+	list_for_each_entry(nsm, nsm_handles, sm_link)</span>
 		if (rpc_cmp_addr(nsm_addr(nsm), sap))
 			return nsm;
 	return NULL;
 }
 
<span class="p_del">-static struct nsm_handle *nsm_lookup_priv(const struct nsm_private *priv)</span>
<span class="p_add">+static struct nsm_handle *nsm_lookup_priv(const struct list_head *nsm_handles,</span>
<span class="p_add">+					const struct nsm_private *priv)</span>
 {
 	struct nsm_handle *nsm;
 
<span class="p_del">-	list_for_each_entry(nsm, &amp;nsm_handles, sm_link)</span>
<span class="p_add">+	list_for_each_entry(nsm, nsm_handles, sm_link)</span>
 		if (memcmp(nsm-&gt;sm_priv.data, priv-&gt;data,
 					sizeof(priv-&gt;data)) == 0)
 			return nsm;
<span class="p_chunk">@@ -350,6 +351,7 @@</span> <span class="p_context"> static struct nsm_handle *nsm_create_handle(const struct sockaddr *sap,</span>
 
 /**
  * nsm_get_handle - Find or create a cached nsm_handle
<span class="p_add">+ * @net: network namespace</span>
  * @sap: pointer to socket address of handle to find
  * @salen: length of socket address
  * @hostname: pointer to C string containing hostname to find
<span class="p_chunk">@@ -362,11 +364,13 @@</span> <span class="p_context"> static struct nsm_handle *nsm_create_handle(const struct sockaddr *sap,</span>
  * @hostname cannot be found in the handle cache.  Returns NULL if
  * an error occurs.
  */
<span class="p_del">-struct nsm_handle *nsm_get_handle(const struct sockaddr *sap,</span>
<span class="p_add">+struct nsm_handle *nsm_get_handle(const struct net *net,</span>
<span class="p_add">+				  const struct sockaddr *sap,</span>
 				  const size_t salen, const char *hostname,
 				  const size_t hostname_len)
 {
 	struct nsm_handle *cached, *new = NULL;
<span class="p_add">+	struct lockd_net *ln = net_generic(net, lockd_net_id);</span>
 
 	if (hostname &amp;&amp; memchr(hostname, &#39;/&#39;, hostname_len) != NULL) {
 		if (printk_ratelimit()) {
<span class="p_chunk">@@ -381,9 +385,10 @@</span> <span class="p_context"> retry:</span>
 	spin_lock(&amp;nsm_lock);
 
 	if (nsm_use_hostnames &amp;&amp; hostname != NULL)
<span class="p_del">-		cached = nsm_lookup_hostname(hostname, hostname_len);</span>
<span class="p_add">+		cached = nsm_lookup_hostname(&amp;ln-&gt;nsm_handles,</span>
<span class="p_add">+					hostname, hostname_len);</span>
 	else
<span class="p_del">-		cached = nsm_lookup_addr(sap);</span>
<span class="p_add">+		cached = nsm_lookup_addr(&amp;ln-&gt;nsm_handles, sap);</span>
 
 	if (cached != NULL) {
 		atomic_inc(&amp;cached-&gt;sm_count);
<span class="p_chunk">@@ -397,7 +402,7 @@</span> <span class="p_context"> retry:</span>
 	}
 
 	if (new != NULL) {
<span class="p_del">-		list_add(&amp;new-&gt;sm_link, &amp;nsm_handles);</span>
<span class="p_add">+		list_add(&amp;new-&gt;sm_link, &amp;ln-&gt;nsm_handles);</span>
 		spin_unlock(&amp;nsm_lock);
 		dprintk(&quot;lockd: created nsm_handle for %s (%s)\n&quot;,
 				new-&gt;sm_name, new-&gt;sm_addrbuf);
<span class="p_chunk">@@ -414,19 +419,22 @@</span> <span class="p_context"> retry:</span>
 
 /**
  * nsm_reboot_lookup - match NLMPROC_SM_NOTIFY arguments to an nsm_handle
<span class="p_add">+ * @net:  network namespace</span>
  * @info: pointer to NLMPROC_SM_NOTIFY arguments
  *
  * Returns a matching nsm_handle if found in the nsm cache. The returned
  * nsm_handle&#39;s reference count is bumped. Otherwise returns NULL if some
  * error occurred.
  */
<span class="p_del">-struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info)</span>
<span class="p_add">+struct nsm_handle *nsm_reboot_lookup(const struct net *net,</span>
<span class="p_add">+				const struct nlm_reboot *info)</span>
 {
 	struct nsm_handle *cached;
<span class="p_add">+	struct lockd_net *ln = net_generic(net, lockd_net_id);</span>
 
 	spin_lock(&amp;nsm_lock);
 
<span class="p_del">-	cached = nsm_lookup_priv(&amp;info-&gt;priv);</span>
<span class="p_add">+	cached = nsm_lookup_priv(&amp;ln-&gt;nsm_handles, &amp;info-&gt;priv);</span>
 	if (unlikely(cached == NULL)) {
 		spin_unlock(&amp;nsm_lock);
 		dprintk(&quot;lockd: never saw rebooted peer &#39;%.*s&#39; before\n&quot;,
<span class="p_header">diff --git a/fs/lockd/netns.h b/fs/lockd/netns.h</span>
<span class="p_header">index 5010b55628b4..414da99744e9 100644</span>
<span class="p_header">--- a/fs/lockd/netns.h</span>
<span class="p_header">+++ b/fs/lockd/netns.h</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"> struct lockd_net {</span>
 	spinlock_t nsm_clnt_lock;
 	unsigned int nsm_users;
 	struct rpc_clnt *nsm_clnt;
<span class="p_add">+	struct list_head nsm_handles;</span>
 };
 
 extern int lockd_net_id;
<span class="p_header">diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c</span>
<span class="p_header">index 7a318480ab7a..ce05c60ff06d 100644</span>
<span class="p_header">--- a/fs/lockd/svc.c</span>
<span class="p_header">+++ b/fs/lockd/svc.c</span>
<span class="p_chunk">@@ -583,6 +583,7 @@</span> <span class="p_context"> static int lockd_init_net(struct net *net)</span>
 	INIT_DELAYED_WORK(&amp;ln-&gt;grace_period_end, grace_ender);
 	INIT_LIST_HEAD(&amp;ln-&gt;grace_list);
 	spin_lock_init(&amp;ln-&gt;nsm_clnt_lock);
<span class="p_add">+	INIT_LIST_HEAD(&amp;ln-&gt;nsm_handles);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/lockd/svc4proc.c b/fs/lockd/svc4proc.c</span>
<span class="p_header">index b147d1ae71fd..09c576f26c7b 100644</span>
<span class="p_header">--- a/fs/lockd/svc4proc.c</span>
<span class="p_header">+++ b/fs/lockd/svc4proc.c</span>
<span class="p_chunk">@@ -421,7 +421,7 @@</span> <span class="p_context"> nlm4svc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,</span>
 		return rpc_system_err;
 	}
 
<span class="p_del">-	nlm_host_rebooted(argp);</span>
<span class="p_add">+	nlm_host_rebooted(SVC_NET(rqstp), argp);</span>
 	return rpc_success;
 }
 
<span class="p_header">diff --git a/fs/lockd/svcproc.c b/fs/lockd/svcproc.c</span>
<span class="p_header">index 21171f0c6477..fb26b9f522e7 100644</span>
<span class="p_header">--- a/fs/lockd/svcproc.c</span>
<span class="p_header">+++ b/fs/lockd/svcproc.c</span>
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> nlmsvc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,</span>
 		return rpc_system_err;
 	}
 
<span class="p_del">-	nlm_host_rebooted(argp);</span>
<span class="p_add">+	nlm_host_rebooted(SVC_NET(rqstp), argp);</span>
 	return rpc_success;
 }
 
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 157c3dbacf6c..c87e15ee9255 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -2917,6 +2917,10 @@</span> <span class="p_context"> opened:</span>
 			goto exit_fput;
 	}
 out:
<span class="p_add">+	if (unlikely(error &gt; 0)) {</span>
<span class="p_add">+		WARN_ON(1);</span>
<span class="p_add">+		error = -EINVAL;</span>
<span class="p_add">+	}</span>
 	if (got_write)
 		mnt_drop_write(nd-&gt;path.mnt);
 	path_put(&amp;save_parent);
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index cfa9163b3bb7..2bdaf57c82d0 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1452,7 +1452,7 @@</span> <span class="p_context"> restart:</span>
 				}
 				spin_unlock(&amp;state-&gt;state_lock);
 				nfs4_put_open_state(state);
<span class="p_del">-				clear_bit(NFS4CLNT_RECLAIM_NOGRACE,</span>
<span class="p_add">+				clear_bit(NFS_STATE_RECLAIM_NOGRACE,</span>
 					&amp;state-&gt;flags);
 				spin_lock(&amp;sp-&gt;so_lock);
 				goto restart;
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index 9f285fb9bab3..b86db1236c7c 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -170,7 +170,7 @@</span> <span class="p_context"> static void *m_start(struct seq_file *m, loff_t *pos)</span>
 	if (!priv-&gt;task)
 		return ERR_PTR(-ESRCH);
 
<span class="p_del">-	mm = mm_access(priv-&gt;task, PTRACE_MODE_READ);</span>
<span class="p_add">+	mm = mm_access(priv-&gt;task, PTRACE_MODE_READ_FSCREDS);</span>
 	if (!mm || IS_ERR(mm))
 		return mm;
 	down_read(&amp;mm-&gt;mmap_sem);
<span class="p_chunk">@@ -1044,7 +1044,7 @@</span> <span class="p_context"> static ssize_t pagemap_read(struct file *file, char __user *buf,</span>
 	if (!pm.buffer)
 		goto out_task;
 
<span class="p_del">-	mm = mm_access(task, PTRACE_MODE_READ);</span>
<span class="p_add">+	mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);</span>
 	ret = PTR_ERR(mm);
 	if (!mm || IS_ERR(mm))
 		goto out_free;
<span class="p_header">diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c</span>
<span class="p_header">index 56123a6f462e..123c19890b14 100644</span>
<span class="p_header">--- a/fs/proc/task_nommu.c</span>
<span class="p_header">+++ b/fs/proc/task_nommu.c</span>
<span class="p_chunk">@@ -223,7 +223,7 @@</span> <span class="p_context"> static void *m_start(struct seq_file *m, loff_t *pos)</span>
 	if (!priv-&gt;task)
 		return ERR_PTR(-ESRCH);
 
<span class="p_del">-	mm = mm_access(priv-&gt;task, PTRACE_MODE_READ);</span>
<span class="p_add">+	mm = mm_access(priv-&gt;task, PTRACE_MODE_READ_FSCREDS);</span>
 	if (!mm || IS_ERR(mm)) {
 		put_task_struct(priv-&gt;task);
 		priv-&gt;task = NULL;
<span class="p_header">diff --git a/fs/splice.c b/fs/splice.c</span>
<span class="p_header">index f183f1342c01..3b94a6bba29f 100644</span>
<span class="p_header">--- a/fs/splice.c</span>
<span class="p_header">+++ b/fs/splice.c</span>
<span class="p_chunk">@@ -949,6 +949,7 @@</span> <span class="p_context"> ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,</span>
 
 	splice_from_pipe_begin(sd);
 	do {
<span class="p_add">+		cond_resched();</span>
 		ret = splice_from_pipe_next(pipe, sd);
 		if (ret &gt; 0)
 			ret = splice_from_pipe_feed(pipe, sd, actor);
<span class="p_chunk">@@ -1189,7 +1190,7 @@</span> <span class="p_context"> ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,</span>
 	long ret, bytes;
 	umode_t i_mode;
 	size_t len;
<span class="p_del">-	int i, flags;</span>
<span class="p_add">+	int i, flags, more;</span>
 
 	/*
 	 * We require the input being a regular file, as we don&#39;t want to
<span class="p_chunk">@@ -1232,6 +1233,7 @@</span> <span class="p_context"> ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,</span>
 	 * Don&#39;t block on output, we have to drain the direct pipe.
 	 */
 	sd-&gt;flags &amp;= ~SPLICE_F_NONBLOCK;
<span class="p_add">+	more = sd-&gt;flags &amp; SPLICE_F_MORE;</span>
 
 	while (len) {
 		size_t read_len;
<span class="p_chunk">@@ -1245,6 +1247,15 @@</span> <span class="p_context"> ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,</span>
 		sd-&gt;total_len = read_len;
 
 		/*
<span class="p_add">+		 * If more data is pending, set SPLICE_F_MORE</span>
<span class="p_add">+		 * If this is the last data and SPLICE_F_MORE was not set</span>
<span class="p_add">+		 * initially, clears it.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (read_len &lt; len)</span>
<span class="p_add">+			sd-&gt;flags |= SPLICE_F_MORE;</span>
<span class="p_add">+		else if (!more)</span>
<span class="p_add">+			sd-&gt;flags &amp;= ~SPLICE_F_MORE;</span>
<span class="p_add">+		/*</span>
 		 * NOTE: nonblocking mode only applies to the input. We
 		 * must not do the output in nonblocking mode as then we
 		 * could get stuck data in the internal pipe:
<span class="p_header">diff --git a/include/linux/enclosure.h b/include/linux/enclosure.h</span>
<span class="p_header">index 9a33c5f7e126..f6c229e2bffa 100644</span>
<span class="p_header">--- a/include/linux/enclosure.h</span>
<span class="p_header">+++ b/include/linux/enclosure.h</span>
<span class="p_chunk">@@ -29,7 +29,11 @@</span> <span class="p_context"></span>
 /* A few generic types ... taken from ses-2 */
 enum enclosure_component_type {
 	ENCLOSURE_COMPONENT_DEVICE = 0x01,
<span class="p_add">+	ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS = 0x07,</span>
<span class="p_add">+	ENCLOSURE_COMPONENT_SCSI_TARGET_PORT = 0x14,</span>
<span class="p_add">+	ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT = 0x15,</span>
 	ENCLOSURE_COMPONENT_ARRAY_DEVICE = 0x17,
<span class="p_add">+	ENCLOSURE_COMPONENT_SAS_EXPANDER = 0x18,</span>
 };
 
 /* ses-2 common element status */
<span class="p_header">diff --git a/include/linux/lockd/lockd.h b/include/linux/lockd/lockd.h</span>
<span class="p_header">index dcaad79f54ed..0adf073f13b3 100644</span>
<span class="p_header">--- a/include/linux/lockd/lockd.h</span>
<span class="p_header">+++ b/include/linux/lockd/lockd.h</span>
<span class="p_chunk">@@ -236,7 +236,8 @@</span> <span class="p_context"> void		  nlm_rebind_host(struct nlm_host *);</span>
 struct nlm_host * nlm_get_host(struct nlm_host *);
 void		  nlm_shutdown_hosts(void);
 void		  nlm_shutdown_hosts_net(struct net *net);
<span class="p_del">-void		  nlm_host_rebooted(const struct nlm_reboot *);</span>
<span class="p_add">+void		  nlm_host_rebooted(const struct net *net,</span>
<span class="p_add">+					const struct nlm_reboot *);</span>
 
 /*
  * Host monitoring
<span class="p_chunk">@@ -244,11 +245,13 @@</span> <span class="p_context"> void		  nlm_host_rebooted(const struct nlm_reboot *);</span>
 int		  nsm_monitor(const struct nlm_host *host);
 void		  nsm_unmonitor(const struct nlm_host *host);
 
<span class="p_del">-struct nsm_handle *nsm_get_handle(const struct sockaddr *sap,</span>
<span class="p_add">+struct nsm_handle *nsm_get_handle(const struct net *net,</span>
<span class="p_add">+					const struct sockaddr *sap,</span>
 					const size_t salen,
 					const char *hostname,
 					const size_t hostname_len);
<span class="p_del">-struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info);</span>
<span class="p_add">+struct nsm_handle *nsm_reboot_lookup(const struct net *net,</span>
<span class="p_add">+					const struct nlm_reboot *info);</span>
 void		  nsm_release(struct nsm_handle *nsm);
 
 /*
<span class="p_header">diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h</span>
<span class="p_header">index fc01d5cb4cf1..7d2021d3ee08 100644</span>
<span class="p_header">--- a/include/linux/nfs_fs.h</span>
<span class="p_header">+++ b/include/linux/nfs_fs.h</span>
<span class="p_chunk">@@ -578,9 +578,7 @@</span> <span class="p_context"> static inline void nfs3_forget_cached_acls(struct inode *inode)</span>
 
 static inline loff_t nfs_size_to_loff_t(__u64 size)
 {
<span class="p_del">-	if (size &gt; (__u64) OFFSET_MAX - 1)</span>
<span class="p_del">-		return OFFSET_MAX - 1;</span>
<span class="p_del">-	return (loff_t) size;</span>
<span class="p_add">+	return min_t(u64, size, OFFSET_MAX);</span>
 }
 
 static inline ino_t
<span class="p_header">diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h</span>
<span class="p_header">index ba605015c4d8..0b2d0cbe0bab 100644</span>
<span class="p_header">--- a/include/linux/tracepoint.h</span>
<span class="p_header">+++ b/include/linux/tracepoint.h</span>
<span class="p_chunk">@@ -14,8 +14,11 @@</span> <span class="p_context"></span>
  * See the file COPYING for more details.
  */
 
<span class="p_add">+#include &lt;linux/smp.h&gt;</span>
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;linux/percpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpumask.h&gt;</span>
 #include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/static_key.h&gt;
 
<span class="p_chunk">@@ -126,6 +129,9 @@</span> <span class="p_context"> static inline void tracepoint_synchronize_unregister(void)</span>
 		void *it_func;						\
 		void *__data;						\
 									\
<span class="p_add">+		if (!cpu_online(raw_smp_processor_id()))		\</span>
<span class="p_add">+			return;						\</span>
<span class="p_add">+									\</span>
 		if (!(cond))						\
 			return;						\
 		prercu;							\
<span class="p_header">diff --git a/include/net/af_unix.h b/include/net/af_unix.h</span>
<span class="p_header">index 686760024572..6278e4d32612 100644</span>
<span class="p_header">--- a/include/net/af_unix.h</span>
<span class="p_header">+++ b/include/net/af_unix.h</span>
<span class="p_chunk">@@ -6,8 +6,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/mutex.h&gt;
 #include &lt;net/sock.h&gt;
 
<span class="p_del">-extern void unix_inflight(struct file *fp);</span>
<span class="p_del">-extern void unix_notinflight(struct file *fp);</span>
<span class="p_add">+extern void unix_inflight(struct user_struct *user, struct file *fp);</span>
<span class="p_add">+extern void unix_notinflight(struct user_struct *user, struct file *fp);</span>
 extern void unix_gc(void);
 extern void wait_for_unix_gc(void);
 extern struct sock *unix_get_socket(struct file *filp);
<span class="p_header">diff --git a/include/net/scm.h b/include/net/scm.h</span>
<span class="p_header">index 8de2d37d2077..d00cd43a990c 100644</span>
<span class="p_header">--- a/include/net/scm.h</span>
<span class="p_header">+++ b/include/net/scm.h</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> struct scm_creds {</span>
 struct scm_fp_list {
 	short			count;
 	short			max;
<span class="p_add">+	struct user_struct	*user;</span>
 	struct file		*fp[SCM_MAX_FD];
 };
 
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index a79d267b64ec..7b0d31b67f6a 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -1229,6 +1229,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 	if (!desc)
 		return NULL;
 
<span class="p_add">+	chip_bus_lock(desc);</span>
 	raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);
 
 	/*
<span class="p_chunk">@@ -1242,7 +1243,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 		if (!action) {
 			WARN(1, &quot;Trying to free already-free IRQ %d\n&quot;, irq);
 			raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
<span class="p_del">-</span>
<span class="p_add">+			chip_bus_sync_unlock(desc);</span>
 			return NULL;
 		}
 
<span class="p_chunk">@@ -1265,6 +1266,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 #endif
 
 	raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
<span class="p_add">+	chip_bus_sync_unlock(desc);</span>
 
 	unregister_handler_proc(irq, action);
 
<span class="p_chunk">@@ -1338,9 +1340,7 @@</span> <span class="p_context"> void free_irq(unsigned int irq, void *dev_id)</span>
 		desc-&gt;affinity_notify = NULL;
 #endif
 
<span class="p_del">-	chip_bus_lock(desc);</span>
 	kfree(__free_irq(irq, dev_id));
<span class="p_del">-	chip_bus_sync_unlock(desc);</span>
 }
 EXPORT_SYMBOL(free_irq);
 
<span class="p_header">diff --git a/kernel/resource.c b/kernel/resource.c</span>
<span class="p_header">index d7386986e10e..b8422b135b68 100644</span>
<span class="p_header">--- a/kernel/resource.c</span>
<span class="p_header">+++ b/kernel/resource.c</span>
<span class="p_chunk">@@ -961,9 +961,10 @@</span> <span class="p_context"> struct resource * __request_region(struct resource *parent,</span>
 		if (!conflict)
 			break;
 		if (conflict != parent) {
<span class="p_del">-			parent = conflict;</span>
<span class="p_del">-			if (!(conflict-&gt;flags &amp; IORESOURCE_BUSY))</span>
<span class="p_add">+			if (!(conflict-&gt;flags &amp; IORESOURCE_BUSY)) {</span>
<span class="p_add">+				parent = conflict;</span>
 				continue;
<span class="p_add">+			}</span>
 		}
 		if (conflict-&gt;flags &amp; flags &amp; IORESOURCE_MUXED) {
 			add_wait_queue(&amp;muxed_resource_wait, &amp;wait);
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index c771f2547bef..f234c84d36c8 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -1587,7 +1587,6 @@</span> <span class="p_context"> out:</span>
  */
 int wake_up_process(struct task_struct *p)
 {
<span class="p_del">-	WARN_ON(task_is_stopped_or_traced(p));</span>
 	return try_to_wake_up(p, TASK_NORMAL, 0);
 }
 EXPORT_SYMBOL(wake_up_process);
<span class="p_header">diff --git a/kernel/time/posix-clock.c b/kernel/time/posix-clock.c</span>
<span class="p_header">index ce033c7aa2e8..9cff0ab82b63 100644</span>
<span class="p_header">--- a/kernel/time/posix-clock.c</span>
<span class="p_header">+++ b/kernel/time/posix-clock.c</span>
<span class="p_chunk">@@ -69,10 +69,10 @@</span> <span class="p_context"> static ssize_t posix_clock_read(struct file *fp, char __user *buf,</span>
 static unsigned int posix_clock_poll(struct file *fp, poll_table *wait)
 {
 	struct posix_clock *clk = get_posix_clock(fp);
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	unsigned int result = 0;</span>
 
 	if (!clk)
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		return POLLERR;</span>
 
 	if (clk-&gt;ops.poll)
 		result = clk-&gt;ops.poll(clk, fp, wait);
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index ab21b8c66535..cb73c4e0741e 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -1948,12 +1948,6 @@</span> <span class="p_context"> rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)</span>
 		goto again;
 }
 
<span class="p_del">-static void rb_reset_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
<span class="p_del">-{</span>
<span class="p_del">-	cpu_buffer-&gt;read_stamp = cpu_buffer-&gt;reader_page-&gt;page-&gt;time_stamp;</span>
<span class="p_del">-	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void rb_inc_iter(struct ring_buffer_iter *iter)
 {
 	struct ring_buffer_per_cpu *cpu_buffer = iter-&gt;cpu_buffer;
<span class="p_chunk">@@ -3591,7 +3585,7 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 
 	/* Finally update the reader page to the new head */
 	cpu_buffer-&gt;reader_page = reader;
<span class="p_del">-	rb_reset_reader_page(cpu_buffer);</span>
<span class="p_add">+	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
 
 	if (overwrite != cpu_buffer-&gt;last_overrun) {
 		cpu_buffer-&gt;lost_events = overwrite - cpu_buffer-&gt;last_overrun;
<span class="p_chunk">@@ -3601,6 +3595,10 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 	goto again;
 
  out:
<span class="p_add">+	/* Update the read_stamp on the first event */</span>
<span class="p_add">+	if (reader &amp;&amp; reader-&gt;read == 0)</span>
<span class="p_add">+		cpu_buffer-&gt;read_stamp = reader-&gt;page-&gt;time_stamp;</span>
<span class="p_add">+</span>
 	arch_spin_unlock(&amp;cpu_buffer-&gt;lock);
 	local_irq_restore(flags);
 
<span class="p_header">diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c</span>
<span class="p_header">index 5a898f15bfc6..7d054b7671ec 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events.c</span>
<span class="p_chunk">@@ -602,7 +602,8 @@</span> <span class="p_context"> t_next(struct seq_file *m, void *v, loff_t *pos)</span>
 		 * The ftrace subsystem is for showing formats only.
 		 * They can not be enabled or disabled via the event files.
 		 */
<span class="p_del">-		if (call-&gt;class &amp;&amp; call-&gt;class-&gt;reg)</span>
<span class="p_add">+		if (call-&gt;class &amp;&amp; call-&gt;class-&gt;reg &amp;&amp;</span>
<span class="p_add">+		    !(call-&gt;flags &amp; TRACE_EVENT_FL_IGNORE_ENABLE))</span>
 			return file;
 	}
 
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index fa927fd5778d..fe7c4b91d2e7 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -1450,13 +1450,13 @@</span> <span class="p_context"> static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,</span>
 	timer_stats_timer_set_start_info(&amp;dwork-&gt;timer);
 
 	dwork-&gt;wq = wq;
<span class="p_del">-	/* timer isn&#39;t guaranteed to run in this cpu, record earlier */</span>
<span class="p_del">-	if (cpu == WORK_CPU_UNBOUND)</span>
<span class="p_del">-		cpu = raw_smp_processor_id();</span>
 	dwork-&gt;cpu = cpu;
 	timer-&gt;expires = jiffies + delay;
 
<span class="p_del">-	add_timer_on(timer, cpu);</span>
<span class="p_add">+	if (unlikely(cpu != WORK_CPU_UNBOUND))</span>
<span class="p_add">+		add_timer_on(timer, cpu);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		add_timer(timer);</span>
 }
 
 /**
<span class="p_header">diff --git a/lib/devres.c b/lib/devres.c</span>
<span class="p_header">index 823533138fa0..20afaf181b27 100644</span>
<span class="p_header">--- a/lib/devres.c</span>
<span class="p_header">+++ b/lib/devres.c</span>
<span class="p_chunk">@@ -423,7 +423,7 @@</span> <span class="p_context"> void pcim_iounmap_regions(struct pci_dev *pdev, int mask)</span>
 	if (!iomap)
 		return;
 
<span class="p_del">-	for (i = 0; i &lt; DEVICE_COUNT_RESOURCE; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; PCIM_IOMAP_MAX; i++) {</span>
 		if (!(mask &amp; (1 &lt;&lt; i)))
 			continue;
 
<span class="p_header">diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c</span>
<span class="p_header">index e3bea2e0821a..025ced8fbb57 100644</span>
<span class="p_header">--- a/net/ceph/messenger.c</span>
<span class="p_header">+++ b/net/ceph/messenger.c</span>
<span class="p_chunk">@@ -2277,7 +2277,7 @@</span> <span class="p_context"> static int read_partial_message(struct ceph_connection *con)</span>
 		con-&gt;in_base_pos = -front_len - middle_len - data_len -
 			sizeof(m-&gt;footer);
 		con-&gt;in_tag = CEPH_MSGR_TAG_READY;
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return 1;</span>
 	} else if ((s64)seq - (s64)con-&gt;in_seq &gt; 1) {
 		pr_err(&quot;read_partial_message bad seq %lld expected %lld\n&quot;,
 		       seq, con-&gt;in_seq + 1);
<span class="p_chunk">@@ -2310,7 +2310,7 @@</span> <span class="p_context"> static int read_partial_message(struct ceph_connection *con)</span>
 				sizeof(m-&gt;footer);
 			con-&gt;in_tag = CEPH_MSGR_TAG_READY;
 			con-&gt;in_seq++;
<span class="p_del">-			return 0;</span>
<span class="p_add">+			return 1;</span>
 		}
 
 		BUG_ON(!con-&gt;in_msg);
<span class="p_header">diff --git a/net/core/scm.c b/net/core/scm.c</span>
<span class="p_header">index dbc6bfcdf446..7a6cf8351cde 100644</span>
<span class="p_header">--- a/net/core/scm.c</span>
<span class="p_header">+++ b/net/core/scm.c</span>
<span class="p_chunk">@@ -87,6 +87,7 @@</span> <span class="p_context"> static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)</span>
 		*fplp = fpl;
 		fpl-&gt;count = 0;
 		fpl-&gt;max = SCM_MAX_FD;
<span class="p_add">+		fpl-&gt;user = NULL;</span>
 	}
 	fpp = &amp;fpl-&gt;fp[fpl-&gt;count];
 
<span class="p_chunk">@@ -107,6 +108,10 @@</span> <span class="p_context"> static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)</span>
 		*fpp++ = file;
 		fpl-&gt;count++;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!fpl-&gt;user)</span>
<span class="p_add">+		fpl-&gt;user = get_uid(current_user());</span>
<span class="p_add">+</span>
 	return num;
 }
 
<span class="p_chunk">@@ -119,6 +124,7 @@</span> <span class="p_context"> void __scm_destroy(struct scm_cookie *scm)</span>
 		scm-&gt;fp = NULL;
 		for (i=fpl-&gt;count-1; i&gt;=0; i--)
 			fput(fpl-&gt;fp[i]);
<span class="p_add">+		free_uid(fpl-&gt;user);</span>
 		kfree(fpl);
 	}
 }
<span class="p_chunk">@@ -337,6 +343,7 @@</span> <span class="p_context"> struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)</span>
 		for (i = 0; i &lt; fpl-&gt;count; i++)
 			get_file(fpl-&gt;fp[i]);
 		new_fpl-&gt;max = new_fpl-&gt;count;
<span class="p_add">+		new_fpl-&gt;user = get_uid(fpl-&gt;user);</span>
 	}
 	return new_fpl;
 }
<span class="p_header">diff --git a/net/mac80211/mesh_pathtbl.c b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">index 89aacfd2756d..9ba6d8c7c793 100644</span>
<span class="p_header">--- a/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">+++ b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_chunk">@@ -747,10 +747,8 @@</span> <span class="p_context"> void mesh_plink_broken(struct sta_info *sta)</span>
 static void mesh_path_node_reclaim(struct rcu_head *rp)
 {
 	struct mpath_node *node = container_of(rp, struct mpath_node, rcu);
<span class="p_del">-	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
 
 	del_timer_sync(&amp;node-&gt;mpath-&gt;timer);
<span class="p_del">-	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	kfree(node-&gt;mpath);
 	kfree(node);
 }
<span class="p_chunk">@@ -758,8 +756,9 @@</span> <span class="p_context"> static void mesh_path_node_reclaim(struct rcu_head *rp)</span>
 /* needs to be called with the corresponding hashwlock taken */
 static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)
 {
<span class="p_del">-	struct mesh_path *mpath;</span>
<span class="p_del">-	mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct mesh_path *mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;mpath-&gt;state_lock);
 	mpath-&gt;flags |= MESH_PATH_RESOLVING;
 	if (mpath-&gt;is_gate)
<span class="p_chunk">@@ -767,6 +766,7 @@</span> <span class="p_context"> static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)</span>
 	hlist_del_rcu(&amp;node-&gt;list);
 	call_rcu(&amp;node-&gt;rcu, mesh_path_node_reclaim);
 	spin_unlock(&amp;mpath-&gt;state_lock);
<span class="p_add">+	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	atomic_dec(&amp;tbl-&gt;entries);
 }
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">index 0283baedcdfb..9dc979abb461 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_chunk">@@ -311,6 +311,21 @@</span> <span class="p_context"> static void death_by_timeout(unsigned long ul_conntrack)</span>
 	nf_ct_put(ct);
 }
 
<span class="p_add">+static inline bool</span>
<span class="p_add">+nf_ct_key_equal(struct nf_conntrack_tuple_hash *h,</span>
<span class="p_add">+			const struct nf_conntrack_tuple *tuple,</span>
<span class="p_add">+			u16 zone)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* A conntrack can be recreated with the equal tuple,</span>
<span class="p_add">+	 * so we need to check that the conntrack is confirmed</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return nf_ct_tuple_equal(tuple, &amp;h-&gt;tuple) &amp;&amp;</span>
<span class="p_add">+		nf_ct_zone(ct) == zone &amp;&amp;</span>
<span class="p_add">+		nf_ct_is_confirmed(ct);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Warning :
  * - Caller must take a reference on returned object
<span class="p_chunk">@@ -332,8 +347,7 @@</span> <span class="p_context"> ____nf_conntrack_find(struct net *net, u16 zone,</span>
 	local_bh_disable();
 begin:
 	hlist_nulls_for_each_entry_rcu(h, n, &amp;net-&gt;ct.hash[bucket], hnnode) {
<span class="p_del">-		if (nf_ct_tuple_equal(tuple, &amp;h-&gt;tuple) &amp;&amp;</span>
<span class="p_del">-		    nf_ct_zone(nf_ct_tuplehash_to_ctrack(h)) == zone) {</span>
<span class="p_add">+		if (nf_ct_key_equal(h, tuple, zone)) {</span>
 			NF_CT_STAT_INC(net, found);
 			local_bh_enable();
 			return h;
<span class="p_chunk">@@ -380,8 +394,7 @@</span> <span class="p_context"> begin:</span>
 			     !atomic_inc_not_zero(&amp;ct-&gt;ct_general.use)))
 			h = NULL;
 		else {
<span class="p_del">-			if (unlikely(!nf_ct_tuple_equal(tuple, &amp;h-&gt;tuple) ||</span>
<span class="p_del">-				     nf_ct_zone(ct) != zone)) {</span>
<span class="p_add">+			if (unlikely(!nf_ct_key_equal(h, tuple, zone))) {</span>
 				nf_ct_put(ct);
 				goto begin;
 			}
<span class="p_header">diff --git a/net/rds/connection.c b/net/rds/connection.c</span>
<span class="p_header">index e88bf3976e54..642ad42c416b 100644</span>
<span class="p_header">--- a/net/rds/connection.c</span>
<span class="p_header">+++ b/net/rds/connection.c</span>
<span class="p_chunk">@@ -177,12 +177,6 @@</span> <span class="p_context"> static struct rds_connection *__rds_conn_create(__be32 laddr, __be32 faddr,</span>
 		}
 	}
 
<span class="p_del">-	if (trans == NULL) {</span>
<span class="p_del">-		kmem_cache_free(rds_conn_slab, conn);</span>
<span class="p_del">-		conn = ERR_PTR(-ENODEV);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	conn-&gt;c_trans = trans;
 
 	ret = trans-&gt;conn_alloc(conn, gfp);
<span class="p_header">diff --git a/net/rds/send.c b/net/rds/send.c</span>
<span class="p_header">index 88eace57dd6b..31c9fa464b11 100644</span>
<span class="p_header">--- a/net/rds/send.c</span>
<span class="p_header">+++ b/net/rds/send.c</span>
<span class="p_chunk">@@ -955,11 +955,13 @@</span> <span class="p_context"> int rds_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,</span>
 		release_sock(sk);
 	}
 
<span class="p_del">-	/* racing with another thread binding seems ok here */</span>
<span class="p_add">+	lock_sock(sk);</span>
 	if (daddr == 0 || rs-&gt;rs_bound_addr == 0) {
<span class="p_add">+		release_sock(sk);</span>
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}
<span class="p_add">+	release_sock(sk);</span>
 
 	/* size of rm including all sgs */
 	ret = rds_rm_size(msg, payload_len);
<span class="p_header">diff --git a/net/rfkill/core.c b/net/rfkill/core.c</span>
<span class="p_header">index 1cec5e4f3a5e..6563cc04c578 100644</span>
<span class="p_header">--- a/net/rfkill/core.c</span>
<span class="p_header">+++ b/net/rfkill/core.c</span>
<span class="p_chunk">@@ -51,7 +51,6 @@</span> <span class="p_context"></span>
 struct rfkill {
 	spinlock_t		lock;
 
<span class="p_del">-	const char		*name;</span>
 	enum rfkill_type	type;
 
 	unsigned long		state;
<span class="p_chunk">@@ -75,6 +74,7 @@</span> <span class="p_context"> struct rfkill {</span>
 	struct delayed_work	poll_work;
 	struct work_struct	uevent_work;
 	struct work_struct	sync_work;
<span class="p_add">+	char			name[];</span>
 };
 #define to_rfkill(d)	container_of(d, struct rfkill, dev)
 
<span class="p_chunk">@@ -871,14 +871,14 @@</span> <span class="p_context"> struct rfkill * __must_check rfkill_alloc(const char *name,</span>
 	if (WARN_ON(type == RFKILL_TYPE_ALL || type &gt;= NUM_RFKILL_TYPES))
 		return NULL;
 
<span class="p_del">-	rfkill = kzalloc(sizeof(*rfkill), GFP_KERNEL);</span>
<span class="p_add">+	rfkill = kzalloc(sizeof(*rfkill) + strlen(name) + 1, GFP_KERNEL);</span>
 	if (!rfkill)
 		return NULL;
 
 	spin_lock_init(&amp;rfkill-&gt;lock);
 	INIT_LIST_HEAD(&amp;rfkill-&gt;node);
 	rfkill-&gt;type = type;
<span class="p_del">-	rfkill-&gt;name = name;</span>
<span class="p_add">+	strcpy(rfkill-&gt;name, name);</span>
 	rfkill-&gt;ops = ops;
 	rfkill-&gt;data = ops_data;
 
<span class="p_chunk">@@ -1088,17 +1088,6 @@</span> <span class="p_context"> static unsigned int rfkill_fop_poll(struct file *file, poll_table *wait)</span>
 	return res;
 }
 
<span class="p_del">-static bool rfkill_readable(struct rfkill_data *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	bool r;</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;data-&gt;mtx);</span>
<span class="p_del">-	r = !list_empty(&amp;data-&gt;events);</span>
<span class="p_del">-	mutex_unlock(&amp;data-&gt;mtx);</span>
<span class="p_del">-</span>
<span class="p_del">-	return r;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static ssize_t rfkill_fop_read(struct file *file, char __user *buf,
 			       size_t count, loff_t *pos)
 {
<span class="p_chunk">@@ -1115,8 +1104,11 @@</span> <span class="p_context"> static ssize_t rfkill_fop_read(struct file *file, char __user *buf,</span>
 			goto out;
 		}
 		mutex_unlock(&amp;data-&gt;mtx);
<span class="p_add">+		/* since we re-check and it just compares pointers,</span>
<span class="p_add">+		 * using !list_empty() without locking isn&#39;t a problem</span>
<span class="p_add">+		 */</span>
 		ret = wait_event_interruptible(data-&gt;read_wait,
<span class="p_del">-					       rfkill_readable(data));</span>
<span class="p_add">+					       !list_empty(&amp;data-&gt;events));</span>
 		mutex_lock(&amp;data-&gt;mtx);
 
 		if (ret)
<span class="p_header">diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c</span>
<span class="p_header">index 231b71944c52..a4266b9b2429 100644</span>
<span class="p_header">--- a/net/sunrpc/cache.c</span>
<span class="p_header">+++ b/net/sunrpc/cache.c</span>
<span class="p_chunk">@@ -1221,7 +1221,7 @@</span> <span class="p_context"> int qword_get(char **bpp, char *dest, int bufsize)</span>
 	if (bp[0] == &#39;\\&#39; &amp;&amp; bp[1] == &#39;x&#39;) {
 		/* HEX STRING */
 		bp += 2;
<span class="p_del">-		while (len &lt; bufsize) {</span>
<span class="p_add">+		while (len &lt; bufsize - 1) {</span>
 			int h, l;
 
 			h = hex_to_bin(bp[0]);
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index a673c1f4f638..8f118c7c19e1 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -1466,7 +1466,7 @@</span> <span class="p_context"> static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 	UNIXCB(skb).fp = NULL;
 
 	for (i = scm-&gt;fp-&gt;count-1; i &gt;= 0; i--)
<span class="p_del">-		unix_notinflight(scm-&gt;fp-&gt;fp[i]);</span>
<span class="p_add">+		unix_notinflight(scm-&gt;fp-&gt;user, scm-&gt;fp-&gt;fp[i]);</span>
 }
 
 static void unix_destruct_scm(struct sk_buff *skb)
<span class="p_chunk">@@ -1531,7 +1531,7 @@</span> <span class="p_context"> static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 		return -ENOMEM;
 
 	for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--)
<span class="p_del">-		unix_inflight(scm-&gt;fp-&gt;fp[i]);</span>
<span class="p_add">+		unix_inflight(scm-&gt;fp-&gt;user, scm-&gt;fp-&gt;fp[i]);</span>
 	return max_level;
 }
 
<span class="p_header">diff --git a/net/unix/garbage.c b/net/unix/garbage.c</span>
<span class="p_header">index 06730fe6ad9d..a72182d6750f 100644</span>
<span class="p_header">--- a/net/unix/garbage.c</span>
<span class="p_header">+++ b/net/unix/garbage.c</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> struct sock *unix_get_socket(struct file *filp)</span>
  *	descriptor if it is for an AF_UNIX socket.
  */
 
<span class="p_del">-void unix_inflight(struct file *fp)</span>
<span class="p_add">+void unix_inflight(struct user_struct *user, struct file *fp)</span>
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_chunk">@@ -139,11 +139,11 @@</span> <span class="p_context"> void unix_inflight(struct file *fp)</span>
 		}
 		unix_tot_inflight++;
 	}
<span class="p_del">-	fp-&gt;f_cred-&gt;user-&gt;unix_inflight++;</span>
<span class="p_add">+	user-&gt;unix_inflight++;</span>
 	spin_unlock(&amp;unix_gc_lock);
 }
 
<span class="p_del">-void unix_notinflight(struct file *fp)</span>
<span class="p_add">+void unix_notinflight(struct user_struct *user, struct file *fp)</span>
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> void unix_notinflight(struct file *fp)</span>
 			list_del_init(&amp;u-&gt;link);
 		unix_tot_inflight--;
 	}
<span class="p_del">-	fp-&gt;f_cred-&gt;user-&gt;unix_inflight--;</span>
<span class="p_add">+	user-&gt;unix_inflight--;</span>
 	spin_unlock(&amp;unix_gc_lock);
 }
 
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index 9c22317778eb..ee625e3a56ba 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -189,6 +189,20 @@</span> <span class="p_context"> static void *mmap_file(char const *fname)</span>
 		addr = umalloc(sb.st_size);
 		uread(fd_map, addr, sb.st_size);
 	}
<span class="p_add">+	if (sb.st_nlink != 1) {</span>
<span class="p_add">+		/* file is hard-linked, break the hard link */</span>
<span class="p_add">+		close(fd_map);</span>
<span class="p_add">+		if (unlink(fname) &lt; 0) {</span>
<span class="p_add">+			perror(fname);</span>
<span class="p_add">+			fail_file();</span>
<span class="p_add">+		}</span>
<span class="p_add">+		fd_map = open(fname, O_RDWR | O_CREAT, sb.st_mode);</span>
<span class="p_add">+		if (fd_map &lt; 0) {</span>
<span class="p_add">+			perror(fname);</span>
<span class="p_add">+			fail_file();</span>
<span class="p_add">+		}</span>
<span class="p_add">+		uwrite(fd_map, addr, sb.st_size);</span>
<span class="p_add">+	}</span>
 	return addr;
 }
 
<span class="p_header">diff --git a/tools/Makefile b/tools/Makefile</span>
<span class="p_header">index 41067f304215..b82a15b92b1c 100644</span>
<span class="p_header">--- a/tools/Makefile</span>
<span class="p_header">+++ b/tools/Makefile</span>
<span class="p_chunk">@@ -22,6 +22,10 @@</span> <span class="p_context"> help:</span>
 	@echo &#39;  from the kernel command line to build and install one of&#39;
 	@echo &#39;  the tools above&#39;
 	@echo &#39;&#39;
<span class="p_add">+	@echo &#39;  $$ make tools/all&#39;</span>
<span class="p_add">+	@echo &#39;&#39;</span>
<span class="p_add">+	@echo &#39;  builds all tools.&#39;</span>
<span class="p_add">+	@echo &#39;&#39;</span>
 	@echo &#39;  $$ make tools/install&#39;
 	@echo &#39;&#39;
 	@echo &#39;  installs all tools.&#39;
<span class="p_chunk">@@ -50,6 +54,10 @@</span> <span class="p_context"> selftests: FORCE</span>
 turbostat x86_energy_perf_policy: FORCE
 	$(call descend,power/x86/$@)
 
<span class="p_add">+all: cgroup cpupower firewire lguest \</span>
<span class="p_add">+		perf selftests turbostat usb \</span>
<span class="p_add">+		virtio vm net x86_energy_perf_policy</span>
<span class="p_add">+</span>
 cpupower_install:
 	$(call descend,power/$(@:_install=),install)
 
<span class="p_header">diff --git a/virt/kvm/async_pf.c b/virt/kvm/async_pf.c</span>
<span class="p_header">index ea475cd03511..ca2d05a07b57 100644</span>
<span class="p_header">--- a/virt/kvm/async_pf.c</span>
<span class="p_header">+++ b/virt/kvm/async_pf.c</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> int kvm_setup_async_pf(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,</span>
 	 * do alloc nowait since if we are going to sleep anyway we
 	 * may as well sleep faulting in page
 	 */
<span class="p_del">-	work = kmem_cache_zalloc(async_pf_cache, GFP_NOWAIT);</span>
<span class="p_add">+	work = kmem_cache_zalloc(async_pf_cache, GFP_NOWAIT | __GFP_NOWARN);</span>
 	if (!work)
 		return 0;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



