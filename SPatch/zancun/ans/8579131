
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] x86/microcode changes for v4.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] x86/microcode changes for v4.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 14, 2016, 1:21 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160314132120.GA6136@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8579131/mbox/"
   >mbox</a>
|
   <a href="/patch/8579131/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8579131/">/patch/8579131/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 98342C0553
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 14 Mar 2016 13:21:37 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 2C8C5203E3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 14 Mar 2016 13:21:35 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id D1A59203DC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 14 Mar 2016 13:21:32 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S934365AbcCNNV2 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 14 Mar 2016 09:21:28 -0400
Received: from mail-wm0-f65.google.com ([74.125.82.65]:35467 &quot;EHLO
	mail-wm0-f65.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751185AbcCNNVZ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 14 Mar 2016 09:21:25 -0400
Received: by mail-wm0-f65.google.com with SMTP id n205so15034123wmf.2
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 14 Mar 2016 06:21:25 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=h0f2xehiTUyOnRbPzFpo2uEXDqkWSAY00Gfh61SNQ0Q=;
	b=SuHhxNDZ9VMFvmeGFm2dj7guOeNrlJOZ1Bgo5IXHg0ewEmBPI6fmkgqfxWppvSjw4q
	uSWK4FkI87G+m6Yh1WGYyKlJkSb39HocfeyarVlnrvC9PSBj9RVOpfSRTvTleLYcNPFE
	v6MwVqEoWtJ1LoJ6eg1FfuCEi9RuwRArKDt9vLf+m8MxUR1cH2PDPZ5Y/GT+zTmiWf/6
	XSNHr8sCDp/3Kq/wOuUkEvdzu8Zdbzc4i53DuhaaOPG3fZnsV2DxjZhUixuIct9pw5BJ
	Sux9pODak0CYbqMOws0sPp57SrLSRZphhlX0HD7TTFB6Lh9u36CN7UMbJiZa2OLdPfCt
	mibw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=h0f2xehiTUyOnRbPzFpo2uEXDqkWSAY00Gfh61SNQ0Q=;
	b=a2uvMY7Z/GTwkR0LLtbba3hwgS4ibLZOWZ3GRIc1VTyG/WhvR3lRXn8P/8aZv+AuoF
	yDjFdji0AS4sJEGbbrXOmAY6w27poF9IYhLPPAw8dJd221vadwP+i5He3hDsEZiowmEZ
	h8e43zZUVFjNHaUw0hOF+FCiYHYBitgjx6NFpwr+vh8R7qoX7qj6XgIlDqxOGR8kJhLB
	uR0Ihp6qvPEspaCZ88PrudXqKnI0HKjs01WzZ0w8KW9DinuE5EBVDXHLNQ1soOQl6Udd
	uxhEo4Gqv0xALXhO2NJBIMeNXgdwTThlrggsr4jNJSwCnSge+cJR2+OlXLbYpDDt91rx
	5/uw==
X-Gm-Message-State: AD7BkJJYZcaNW06qshpgvqfgo3qTaqPdV8J6CBmAkIAQ7wycdRo6eMzFI2zM2G42KyR+EA==
X-Received: by 10.194.185.237 with SMTP id
	ff13mr26344316wjc.129.1457961683958; 
	Mon, 14 Mar 2016 06:21:23 -0700 (PDT)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	gg7sm22401955wjd.10.2016.03.14.06.21.22
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 14 Mar 2016 06:21:23 -0700 (PDT)
Date: Mon, 14 Mar 2016 14:21:21 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Borislav Petkov &lt;bp@alien8.de&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;
Subject: [GIT PULL] x86/microcode changes for v4.6
Message-ID: &lt;20160314132120.GA6136@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.8 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,RP_MATCHES_RCVD,T_DKIM_INVALID,UNPARSEABLE_RELAY
	autolearn=ham version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - March 14, 2016, 1:21 p.m.</div>
<pre class="content">
Linus,

Please pull the latest x86-microcode-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git x86-microcode-for-linus

   # HEAD: 4ace2e7a48ab426eaa9745ace4c50c6a7adb3992 x86/microcode/intel: Drop orig_sum from ext signature checksum

The biggest change in this cycle was the separation of the microcode loading 
mechanism from the initrd code plus the support of built-in microcode images. 
There were also lots cleanups and general restructuring. (by Borislav Petkov)

 Thanks,

	Ingo

------------------&gt;
Andrzej Hajda (1):
      x86/microcode: Use kmemdup() rather than duplicating its implementation

Boris Ostrovsky (1):
      x86/microcode: Remove unnecessary paravirt_enabled check

Borislav Petkov (20):
      x86/microcode: Untangle from BLK_DEV_INITRD
      x86/microcode/intel: Make early loader look for builtin microcode too
      x86/microcode: Remove redundant __setup() param parsing
      x86/microcode: Issue update message only once
      x86/microcode/AMD: Drop redundant printk prefix
      x86/microcode/intel: Rename local variables of type struct mc_saved_data
      x86/microcode/intel: Rename mc_saved_count to num_saved
      x86/microcode/intel: Rename mc_intel variable to mc
      x86/microcode/intel: Move the BUG_ON up and turn it into WARN_ON
      x86/microcode/intel: Cleanup apply_microcode_intel()
      x86/microcode/intel: Use *wrmsrl variants
      x86/microcode/intel: Rename mc_saved_in_initrd
      x86/microcode/intel: Remove unused arg of get_matching_model_microcode()
      x86/microcode/intel: Cleanup get_matching_model_microcode()
      x86/microcode/AMD: Issue microcode updated message later
      x86/microcode: Document builtin microcode loading method
      x86/microcode/intel: Get rid of DWSIZE
      x86/microcode/intel: Merge two consecutive if-statements
      x86/microcode/intel: Improve microcode sanity-checking error messages
      x86/microcode/intel: Drop orig_sum from ext signature checksum

Chris Bainbridge (1):
      x86/microcode/intel: Change checksum variables to u32

Dan Carpenter (1):
      x86/microcode: Remove an unneeded NULL check


 Documentation/x86/early-microcode.txt     |  25 +++
 arch/x86/Kconfig                          |  27 +--
 arch/x86/include/asm/microcode.h          |  26 +++
 arch/x86/include/asm/microcode_intel.h    |   1 -
 arch/x86/kernel/cpu/microcode/amd.c       |  15 +-
 arch/x86/kernel/cpu/microcode/core.c      |  19 +-
 arch/x86/kernel/cpu/microcode/intel.c     | 285 +++++++++++++++---------------
 arch/x86/kernel/cpu/microcode/intel_lib.c |  58 +++---
 8 files changed, 253 insertions(+), 203 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/x86/early-microcode.txt b/Documentation/x86/early-microcode.txt</span>
<span class="p_header">index d62bea6796da..c956d99cf1de 100644</span>
<span class="p_header">--- a/Documentation/x86/early-microcode.txt</span>
<span class="p_header">+++ b/Documentation/x86/early-microcode.txt</span>
<span class="p_chunk">@@ -40,3 +40,28 @@</span> <span class="p_context"> cp ../microcode.bin kernel/x86/microcode/GenuineIntel.bin (or AuthenticAMD.bin)</span>
 find . | cpio -o -H newc &gt;../ucode.cpio
 cd ..
 cat ucode.cpio /boot/initrd-3.5.0.img &gt;/boot/initrd-3.5.0.ucode.img
<span class="p_add">+</span>
<span class="p_add">+Builtin microcode</span>
<span class="p_add">+=================</span>
<span class="p_add">+</span>
<span class="p_add">+We can also load builtin microcode supplied through the regular firmware</span>
<span class="p_add">+builtin method CONFIG_FIRMWARE_IN_KERNEL. Here&#39;s an example:</span>
<span class="p_add">+</span>
<span class="p_add">+CONFIG_FIRMWARE_IN_KERNEL=y</span>
<span class="p_add">+CONFIG_EXTRA_FIRMWARE=&quot;intel-ucode/06-3a-09 amd-ucode/microcode_amd_fam15h.bin&quot;</span>
<span class="p_add">+CONFIG_EXTRA_FIRMWARE_DIR=&quot;/lib/firmware&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+This basically means, you have the following tree structure locally:</span>
<span class="p_add">+</span>
<span class="p_add">+/lib/firmware/</span>
<span class="p_add">+|-- amd-ucode</span>
<span class="p_add">+...</span>
<span class="p_add">+|   |-- microcode_amd_fam15h.bin</span>
<span class="p_add">+...</span>
<span class="p_add">+|-- intel-ucode</span>
<span class="p_add">+...</span>
<span class="p_add">+|   |-- 06-3a-09</span>
<span class="p_add">+...</span>
<span class="p_add">+</span>
<span class="p_add">+so that the build system can find those files and integrate them into</span>
<span class="p_add">+the final kernel image. The early loader finds them and applies them.</span>
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 9af2e6338400..405b1858134b 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -1159,22 +1159,23 @@</span> <span class="p_context"> config MICROCODE</span>
 	bool &quot;CPU microcode loading support&quot;
 	default y
 	depends on CPU_SUP_AMD || CPU_SUP_INTEL
<span class="p_del">-	depends on BLK_DEV_INITRD</span>
 	select FW_LOADER
 	---help---
<span class="p_del">-</span>
 	  If you say Y here, you will be able to update the microcode on
<span class="p_del">-	  certain Intel and AMD processors. The Intel support is for the</span>
<span class="p_del">-	  IA32 family, e.g. Pentium Pro, Pentium II, Pentium III, Pentium 4,</span>
<span class="p_del">-	  Xeon etc. The AMD support is for families 0x10 and later. You will</span>
<span class="p_del">-	  obviously need the actual microcode binary data itself which is not</span>
<span class="p_del">-	  shipped with the Linux kernel.</span>
<span class="p_del">-</span>
<span class="p_del">-	  This option selects the general module only, you need to select</span>
<span class="p_del">-	  at least one vendor specific module as well.</span>
<span class="p_del">-</span>
<span class="p_del">-	  To compile this driver as a module, choose M here: the module</span>
<span class="p_del">-	  will be called microcode.</span>
<span class="p_add">+	  Intel and AMD processors. The Intel support is for the IA32 family,</span>
<span class="p_add">+	  e.g. Pentium Pro, Pentium II, Pentium III, Pentium 4, Xeon etc. The</span>
<span class="p_add">+	  AMD support is for families 0x10 and later. You will obviously need</span>
<span class="p_add">+	  the actual microcode binary data itself which is not shipped with</span>
<span class="p_add">+	  the Linux kernel.</span>
<span class="p_add">+</span>
<span class="p_add">+	  The preferred method to load microcode from a detached initrd is described</span>
<span class="p_add">+	  in Documentation/x86/early-microcode.txt. For that you need to enable</span>
<span class="p_add">+	  CONFIG_BLK_DEV_INITRD in order for the loader to be able to scan the</span>
<span class="p_add">+	  initrd for microcode blobs.</span>
<span class="p_add">+</span>
<span class="p_add">+	  In addition, you can build-in the microcode into the kernel. For that you</span>
<span class="p_add">+	  need to enable FIRMWARE_IN_KERNEL and add the vendor-supplied microcode</span>
<span class="p_add">+	  to the CONFIG_EXTRA_FIRMWARE config option.</span>
 
 config MICROCODE_INTEL
 	bool &quot;Intel microcode loading support&quot;
<span class="p_header">diff --git a/arch/x86/include/asm/microcode.h b/arch/x86/include/asm/microcode.h</span>
<span class="p_header">index 1e1b07a5a738..9d3a96c4da78 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode.h</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/cpu.h&gt;
 #include &lt;linux/earlycpio.h&gt;
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
 
 #define native_rdmsr(msr, val1, val2)			\
 do {							\
<span class="p_chunk">@@ -143,4 +144,29 @@</span> <span class="p_context"> static inline void reload_early_microcode(void)			{ }</span>
 static inline bool
 get_builtin_firmware(struct cpio_data *cd, const char *name)	{ return false; }
 #endif
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long get_initrd_start(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+	return initrd_start;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long get_initrd_start_addr(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	unsigned long *initrd_start_p = (unsigned long *)__pa_nodebug(&amp;initrd_start);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (unsigned long)__pa_nodebug(*initrd_start_p);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return get_initrd_start();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#else /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* _ASM_X86_MICROCODE_H */
<span class="p_header">diff --git a/arch/x86/include/asm/microcode_intel.h b/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_header">index 8559b0102ea1..603417f8dd6c 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_chunk">@@ -40,7 +40,6 @@</span> <span class="p_context"> struct extended_sigtable {</span>
 #define DEFAULT_UCODE_TOTALSIZE (DEFAULT_UCODE_DATASIZE + MC_HEADER_SIZE)
 #define EXT_HEADER_SIZE		(sizeof(struct extended_sigtable))
 #define EXT_SIGNATURE_SIZE	(sizeof(struct extended_signature))
<span class="p_del">-#define DWSIZE			(sizeof(u32))</span>
 
 #define get_totalsize(mc) \
 	(((struct microcode_intel *)mc)-&gt;hdr.datasize ? \
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/amd.c b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">index 2233f8a76615..e397fc160b05 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_chunk">@@ -431,10 +431,6 @@</span> <span class="p_context"> int __init save_microcode_in_initrd_amd(void)</span>
 	else
 		container = cont_va;
 
<span class="p_del">-	if (ucode_new_rev)</span>
<span class="p_del">-		pr_info(&quot;microcode: updated early to new patch_level=0x%08x\n&quot;,</span>
<span class="p_del">-			ucode_new_rev);</span>
<span class="p_del">-</span>
 	eax   = cpuid_eax(0x00000001);
 	eax   = ((eax &gt;&gt; 8) &amp; 0xf) + ((eax &gt;&gt; 20) &amp; 0xff);
 
<span class="p_chunk">@@ -469,8 +465,7 @@</span> <span class="p_context"> void reload_ucode_amd(void)</span>
 	if (mc &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {
 		if (!__apply_microcode_amd(mc)) {
 			ucode_new_rev = mc-&gt;hdr.patch_id;
<span class="p_del">-			pr_info(&quot;microcode: reload patch_level=0x%08x\n&quot;,</span>
<span class="p_del">-				ucode_new_rev);</span>
<span class="p_add">+			pr_info(&quot;reload patch_level=0x%08x\n&quot;, ucode_new_rev);</span>
 		}
 	}
 }
<span class="p_chunk">@@ -793,15 +788,13 @@</span> <span class="p_context"> static int verify_and_add_patch(u8 family, u8 *fw, unsigned int leftover)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	patch-&gt;data = kzalloc(patch_size, GFP_KERNEL);</span>
<span class="p_add">+	patch-&gt;data = kmemdup(fw + SECTION_HDR_SIZE, patch_size, GFP_KERNEL);</span>
 	if (!patch-&gt;data) {
 		pr_err(&quot;Patch data allocation failure.\n&quot;);
 		kfree(patch);
 		return -EINVAL;
 	}
 
<span class="p_del">-	/* All looks ok, copy patch... */</span>
<span class="p_del">-	memcpy(patch-&gt;data, fw + SECTION_HDR_SIZE, patch_size);</span>
 	INIT_LIST_HEAD(&amp;patch-&gt;plist);
 	patch-&gt;patch_id  = mc_hdr-&gt;patch_id;
 	patch-&gt;equiv_cpu = proc_id;
<span class="p_chunk">@@ -957,6 +950,10 @@</span> <span class="p_context"> struct microcode_ops * __init init_amd_microcode(void)</span>
 		return NULL;
 	}
 
<span class="p_add">+	if (ucode_new_rev)</span>
<span class="p_add">+		pr_info_once(&quot;microcode updated early to new patch_level=0x%08x\n&quot;,</span>
<span class="p_add">+			     ucode_new_rev);</span>
<span class="p_add">+</span>
 	return &amp;microcode_amd_ops;
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/core.c b/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_header">index faec7120c508..ac360bfbbdb6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_chunk">@@ -43,16 +43,8 @@</span> <span class="p_context"></span>
 #define MICROCODE_VERSION	&quot;2.01&quot;
 
 static struct microcode_ops	*microcode_ops;
<span class="p_del">-</span>
 static bool dis_ucode_ldr;
 
<span class="p_del">-static int __init disable_loader(char *str)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dis_ucode_ldr = true;</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-__setup(&quot;dis_ucode_ldr&quot;, disable_loader);</span>
<span class="p_del">-</span>
 /*
  * Synchronization.
  *
<span class="p_chunk">@@ -81,15 +73,16 @@</span> <span class="p_context"> struct cpu_info_ctx {</span>
 
 static bool __init check_loader_disabled_bsp(void)
 {
<span class="p_add">+	static const char *__dis_opt_str = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_32
 	const char *cmdline = (const char *)__pa_nodebug(boot_command_line);
<span class="p_del">-	const char *opt	    = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_del">-	const char *option  = (const char *)__pa_nodebug(opt);</span>
<span class="p_add">+	const char *option  = (const char *)__pa_nodebug(__dis_opt_str);</span>
 	bool *res = (bool *)__pa_nodebug(&amp;dis_ucode_ldr);
 
 #else /* CONFIG_X86_64 */
 	const char *cmdline = boot_command_line;
<span class="p_del">-	const char *option  = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_add">+	const char *option  = __dis_opt_str;</span>
 	bool *res = &amp;dis_ucode_ldr;
 #endif
 
<span class="p_chunk">@@ -479,7 +472,7 @@</span> <span class="p_context"> static enum ucode_state microcode_init_cpu(int cpu, bool refresh_fw)</span>
 	enum ucode_state ustate;
 	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
 
<span class="p_del">-	if (uci &amp;&amp; uci-&gt;valid)</span>
<span class="p_add">+	if (uci-&gt;valid)</span>
 		return UCODE_OK;
 
 	if (collect_cpu_info(cpu))
<span class="p_chunk">@@ -630,7 +623,7 @@</span> <span class="p_context"> int __init microcode_init(void)</span>
 	struct cpuinfo_x86 *c = &amp;boot_cpu_data;
 	int error;
 
<span class="p_del">-	if (paravirt_enabled() || dis_ucode_ldr)</span>
<span class="p_add">+	if (dis_ucode_ldr)</span>
 		return -EINVAL;
 
 	if (c-&gt;x86_vendor == X86_VENDOR_INTEL)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">index ee81c544ee0d..cbb3cf09b065 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_chunk">@@ -39,9 +39,15 @@</span> <span class="p_context"></span>
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/msr.h&gt;
 
<span class="p_del">-static unsigned long mc_saved_in_initrd[MAX_UCODE_COUNT];</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Temporary microcode blobs pointers storage. We note here the pointers to</span>
<span class="p_add">+ * microcode blobs we&#39;ve got from whatever storage (detached initrd, builtin).</span>
<span class="p_add">+ * Later on, we put those into final storage mc_saved_data.mc_saved.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned long mc_tmp_ptrs[MAX_UCODE_COUNT];</span>
<span class="p_add">+</span>
 static struct mc_saved_data {
<span class="p_del">-	unsigned int mc_saved_count;</span>
<span class="p_add">+	unsigned int num_saved;</span>
 	struct microcode_intel **mc_saved;
 } mc_saved_data;
 
<span class="p_chunk">@@ -78,53 +84,50 @@</span> <span class="p_context"> load_microcode_early(struct microcode_intel **saved,</span>
 }
 
 static inline void
<span class="p_del">-copy_initrd_ptrs(struct microcode_intel **mc_saved, unsigned long *initrd,</span>
<span class="p_del">-		  unsigned long off, int num_saved)</span>
<span class="p_add">+copy_ptrs(struct microcode_intel **mc_saved, unsigned long *mc_ptrs,</span>
<span class="p_add">+	  unsigned long off, int num_saved)</span>
 {
 	int i;
 
 	for (i = 0; i &lt; num_saved; i++)
<span class="p_del">-		mc_saved[i] = (struct microcode_intel *)(initrd[i] + off);</span>
<span class="p_add">+		mc_saved[i] = (struct microcode_intel *)(mc_ptrs[i] + off);</span>
 }
 
 #ifdef CONFIG_X86_32
 static void
<span class="p_del">-microcode_phys(struct microcode_intel **mc_saved_tmp,</span>
<span class="p_del">-	       struct mc_saved_data *mc_saved_data)</span>
<span class="p_add">+microcode_phys(struct microcode_intel **mc_saved_tmp, struct mc_saved_data *mcs)</span>
 {
 	int i;
 	struct microcode_intel ***mc_saved;
 
<span class="p_del">-	mc_saved = (struct microcode_intel ***)</span>
<span class="p_del">-		   __pa_nodebug(&amp;mc_saved_data-&gt;mc_saved);</span>
<span class="p_del">-	for (i = 0; i &lt; mc_saved_data-&gt;mc_saved_count; i++) {</span>
<span class="p_add">+	mc_saved = (struct microcode_intel ***)__pa_nodebug(&amp;mcs-&gt;mc_saved);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; mcs-&gt;num_saved; i++) {</span>
 		struct microcode_intel *p;
 
<span class="p_del">-		p = *(struct microcode_intel **)</span>
<span class="p_del">-			__pa_nodebug(mc_saved_data-&gt;mc_saved + i);</span>
<span class="p_add">+		p = *(struct microcode_intel **)__pa_nodebug(mcs-&gt;mc_saved + i);</span>
 		mc_saved_tmp[i] = (struct microcode_intel *)__pa_nodebug(p);
 	}
 }
 #endif
 
 static enum ucode_state
<span class="p_del">-load_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_del">-	       unsigned long initrd_start, struct ucode_cpu_info *uci)</span>
<span class="p_add">+load_microcode(struct mc_saved_data *mcs, unsigned long *mc_ptrs,</span>
<span class="p_add">+	       unsigned long offset, struct ucode_cpu_info *uci)</span>
 {
 	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];
<span class="p_del">-	unsigned int count = mc_saved_data-&gt;mc_saved_count;</span>
<span class="p_add">+	unsigned int count = mcs-&gt;num_saved;</span>
 
<span class="p_del">-	if (!mc_saved_data-&gt;mc_saved) {</span>
<span class="p_del">-		copy_initrd_ptrs(mc_saved_tmp, initrd, initrd_start, count);</span>
<span class="p_add">+	if (!mcs-&gt;mc_saved) {</span>
<span class="p_add">+		copy_ptrs(mc_saved_tmp, mc_ptrs, offset, count);</span>
 
 		return load_microcode_early(mc_saved_tmp, count, uci);
 	} else {
 #ifdef CONFIG_X86_32
<span class="p_del">-		microcode_phys(mc_saved_tmp, mc_saved_data);</span>
<span class="p_add">+		microcode_phys(mc_saved_tmp, mcs);</span>
 		return load_microcode_early(mc_saved_tmp, count, uci);
 #else
<span class="p_del">-		return load_microcode_early(mc_saved_data-&gt;mc_saved,</span>
<span class="p_del">-						    count, uci);</span>
<span class="p_add">+		return load_microcode_early(mcs-&gt;mc_saved, count, uci);</span>
 #endif
 	}
 }
<span class="p_chunk">@@ -175,25 +178,25 @@</span> <span class="p_context"> matching_model_microcode(struct microcode_header_intel *mc_header,</span>
 }
 
 static int
<span class="p_del">-save_microcode(struct mc_saved_data *mc_saved_data,</span>
<span class="p_add">+save_microcode(struct mc_saved_data *mcs,</span>
 	       struct microcode_intel **mc_saved_src,
<span class="p_del">-	       unsigned int mc_saved_count)</span>
<span class="p_add">+	       unsigned int num_saved)</span>
 {
 	int i, j;
 	struct microcode_intel **saved_ptr;
 	int ret;
 
<span class="p_del">-	if (!mc_saved_count)</span>
<span class="p_add">+	if (!num_saved)</span>
 		return -EINVAL;
 
 	/*
 	 * Copy new microcode data.
 	 */
<span class="p_del">-	saved_ptr = kcalloc(mc_saved_count, sizeof(struct microcode_intel *), GFP_KERNEL);</span>
<span class="p_add">+	saved_ptr = kcalloc(num_saved, sizeof(struct microcode_intel *), GFP_KERNEL);</span>
 	if (!saved_ptr)
 		return -ENOMEM;
 
<span class="p_del">-	for (i = 0; i &lt; mc_saved_count; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; num_saved; i++) {</span>
 		struct microcode_header_intel *mc_hdr;
 		struct microcode_intel *mc;
 		unsigned long size;
<span class="p_chunk">@@ -207,20 +210,18 @@</span> <span class="p_context"> save_microcode(struct mc_saved_data *mc_saved_data,</span>
 		mc_hdr = &amp;mc-&gt;hdr;
 		size   = get_totalsize(mc_hdr);
 
<span class="p_del">-		saved_ptr[i] = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+		saved_ptr[i] = kmemdup(mc, size, GFP_KERNEL);</span>
 		if (!saved_ptr[i]) {
 			ret = -ENOMEM;
 			goto err;
 		}
<span class="p_del">-</span>
<span class="p_del">-		memcpy(saved_ptr[i], mc, size);</span>
 	}
 
 	/*
 	 * Point to newly saved microcode.
 	 */
<span class="p_del">-	mc_saved_data-&gt;mc_saved = saved_ptr;</span>
<span class="p_del">-	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_add">+	mcs-&gt;mc_saved  = saved_ptr;</span>
<span class="p_add">+	mcs-&gt;num_saved = num_saved;</span>
 
 	return 0;
 
<span class="p_chunk">@@ -284,22 +285,20 @@</span> <span class="p_context"> static unsigned int _save_mc(struct microcode_intel **mc_saved,</span>
  * BSP can stay in the platform.
  */
 static enum ucode_state __init
<span class="p_del">-get_matching_model_microcode(int cpu, unsigned long start,</span>
<span class="p_del">-			     void *data, size_t size,</span>
<span class="p_del">-			     struct mc_saved_data *mc_saved_data,</span>
<span class="p_del">-			     unsigned long *mc_saved_in_initrd,</span>
<span class="p_add">+get_matching_model_microcode(unsigned long start, void *data, size_t size,</span>
<span class="p_add">+			     struct mc_saved_data *mcs, unsigned long *mc_ptrs,</span>
 			     struct ucode_cpu_info *uci)
 {
<span class="p_del">-	u8 *ucode_ptr = data;</span>
<span class="p_del">-	unsigned int leftover = size;</span>
<span class="p_add">+	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_add">+	struct microcode_header_intel *mc_header;</span>
<span class="p_add">+	unsigned int num_saved = mcs-&gt;num_saved;</span>
 	enum ucode_state state = UCODE_OK;
<span class="p_add">+	unsigned int leftover = size;</span>
<span class="p_add">+	u8 *ucode_ptr = data;</span>
 	unsigned int mc_size;
<span class="p_del">-	struct microcode_header_intel *mc_header;</span>
<span class="p_del">-	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_del">-	unsigned int mc_saved_count = mc_saved_data-&gt;mc_saved_count;</span>
 	int i;
 
<span class="p_del">-	while (leftover &amp;&amp; mc_saved_count &lt; ARRAY_SIZE(mc_saved_tmp)) {</span>
<span class="p_add">+	while (leftover &amp;&amp; num_saved &lt; ARRAY_SIZE(mc_saved_tmp)) {</span>
 
 		if (leftover &lt; sizeof(mc_header))
 			break;
<span class="p_chunk">@@ -318,32 +317,31 @@</span> <span class="p_context"> get_matching_model_microcode(int cpu, unsigned long start,</span>
 		 * the platform, we need to find and save microcode patches
 		 * with the same family and model as the BSP.
 		 */
<span class="p_del">-		if (matching_model_microcode(mc_header, uci-&gt;cpu_sig.sig) !=</span>
<span class="p_del">-			 UCODE_OK) {</span>
<span class="p_add">+		if (matching_model_microcode(mc_header, uci-&gt;cpu_sig.sig) != UCODE_OK) {</span>
 			ucode_ptr += mc_size;
 			continue;
 		}
 
<span class="p_del">-		mc_saved_count = _save_mc(mc_saved_tmp, ucode_ptr, mc_saved_count);</span>
<span class="p_add">+		num_saved = _save_mc(mc_saved_tmp, ucode_ptr, num_saved);</span>
 
 		ucode_ptr += mc_size;
 	}
 
 	if (leftover) {
 		state = UCODE_ERROR;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return state;</span>
 	}
 
<span class="p_del">-	if (mc_saved_count == 0) {</span>
<span class="p_add">+	if (!num_saved) {</span>
 		state = UCODE_NFOUND;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return state;</span>
 	}
 
<span class="p_del">-	for (i = 0; i &lt; mc_saved_count; i++)</span>
<span class="p_del">-		mc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;</span>
<span class="p_add">+	for (i = 0; i &lt; num_saved; i++)</span>
<span class="p_add">+		mc_ptrs[i] = (unsigned long)mc_saved_tmp[i] - start;</span>
<span class="p_add">+</span>
<span class="p_add">+	mcs-&gt;num_saved = num_saved;</span>
 
<span class="p_del">-	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_del">-out:</span>
 	return state;
 }
 
<span class="p_chunk">@@ -373,7 +371,7 @@</span> <span class="p_context"> static int collect_cpu_info_early(struct ucode_cpu_info *uci)</span>
 		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);
 		csig.pf = 1 &lt;&lt; ((val[1] &gt;&gt; 18) &amp; 7);
 	}
<span class="p_del">-	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_add">+	native_wrmsrl(MSR_IA32_UCODE_REV, 0);</span>
 
 	/* As documented in the SDM: Do a CPUID 1 here */
 	sync_core();
<span class="p_chunk">@@ -396,11 +394,11 @@</span> <span class="p_context"> static void show_saved_mc(void)</span>
 	unsigned int sig, pf, rev, total_size, data_size, date;
 	struct ucode_cpu_info uci;
 
<span class="p_del">-	if (mc_saved_data.mc_saved_count == 0) {</span>
<span class="p_add">+	if (!mc_saved_data.num_saved) {</span>
 		pr_debug(&quot;no microcode data saved.\n&quot;);
 		return;
 	}
<span class="p_del">-	pr_debug(&quot;Total microcode saved: %d\n&quot;, mc_saved_data.mc_saved_count);</span>
<span class="p_add">+	pr_debug(&quot;Total microcode saved: %d\n&quot;, mc_saved_data.num_saved);</span>
 
 	collect_cpu_info_early(&amp;uci);
 
<span class="p_chunk">@@ -409,7 +407,7 @@</span> <span class="p_context"> static void show_saved_mc(void)</span>
 	rev = uci.cpu_sig.rev;
 	pr_debug(&quot;CPU: sig=0x%x, pf=0x%x, rev=0x%x\n&quot;, sig, pf, rev);
 
<span class="p_del">-	for (i = 0; i &lt; mc_saved_data.mc_saved_count; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; mc_saved_data.num_saved; i++) {</span>
 		struct microcode_header_intel *mc_saved_header;
 		struct extended_sigtable *ext_header;
 		int ext_sigcount;
<span class="p_chunk">@@ -465,7 +463,7 @@</span> <span class="p_context"> int save_mc_for_early(u8 *mc)</span>
 {
 	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];
 	unsigned int mc_saved_count_init;
<span class="p_del">-	unsigned int mc_saved_count;</span>
<span class="p_add">+	unsigned int num_saved;</span>
 	struct microcode_intel **mc_saved;
 	int ret = 0;
 	int i;
<span class="p_chunk">@@ -476,23 +474,23 @@</span> <span class="p_context"> int save_mc_for_early(u8 *mc)</span>
 	 */
 	mutex_lock(&amp;x86_cpu_microcode_mutex);
 
<span class="p_del">-	mc_saved_count_init = mc_saved_data.mc_saved_count;</span>
<span class="p_del">-	mc_saved_count = mc_saved_data.mc_saved_count;</span>
<span class="p_add">+	mc_saved_count_init = mc_saved_data.num_saved;</span>
<span class="p_add">+	num_saved = mc_saved_data.num_saved;</span>
 	mc_saved = mc_saved_data.mc_saved;
 
<span class="p_del">-	if (mc_saved &amp;&amp; mc_saved_count)</span>
<span class="p_add">+	if (mc_saved &amp;&amp; num_saved)</span>
 		memcpy(mc_saved_tmp, mc_saved,
<span class="p_del">-		       mc_saved_count * sizeof(struct microcode_intel *));</span>
<span class="p_add">+		       num_saved * sizeof(struct microcode_intel *));</span>
 	/*
 	 * Save the microcode patch mc in mc_save_tmp structure if it&#39;s a newer
 	 * version.
 	 */
<span class="p_del">-	mc_saved_count = _save_mc(mc_saved_tmp, mc, mc_saved_count);</span>
<span class="p_add">+	num_saved = _save_mc(mc_saved_tmp, mc, num_saved);</span>
 
 	/*
 	 * Save the mc_save_tmp in global mc_saved_data.
 	 */
<span class="p_del">-	ret = save_microcode(&amp;mc_saved_data, mc_saved_tmp, mc_saved_count);</span>
<span class="p_add">+	ret = save_microcode(&amp;mc_saved_data, mc_saved_tmp, num_saved);</span>
 	if (ret) {
 		pr_err(&quot;Cannot save microcode patch.\n&quot;);
 		goto out;
<span class="p_chunk">@@ -536,7 +534,7 @@</span> <span class="p_context"> static bool __init load_builtin_intel_microcode(struct cpio_data *cp)</span>
 
 static __initdata char ucode_name[] = &quot;kernel/x86/microcode/GenuineIntel.bin&quot;;
 static __init enum ucode_state
<span class="p_del">-scan_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_add">+scan_microcode(struct mc_saved_data *mcs, unsigned long *mc_ptrs,</span>
 	       unsigned long start, unsigned long size,
 	       struct ucode_cpu_info *uci)
 {
<span class="p_chunk">@@ -551,14 +549,18 @@</span> <span class="p_context"> scan_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
 	cd.data = NULL;
 	cd.size = 0;
 
<span class="p_del">-	cd = find_cpio_data(p, (void *)start, size, &amp;offset);</span>
<span class="p_del">-	if (!cd.data) {</span>
<span class="p_add">+	/* try built-in microcode if no initrd */</span>
<span class="p_add">+	if (!size) {</span>
 		if (!load_builtin_intel_microcode(&amp;cd))
 			return UCODE_ERROR;
<span class="p_add">+	} else {</span>
<span class="p_add">+		cd = find_cpio_data(p, (void *)start, size, &amp;offset);</span>
<span class="p_add">+		if (!cd.data)</span>
<span class="p_add">+			return UCODE_ERROR;</span>
 	}
 
<span class="p_del">-	return get_matching_model_microcode(0, start, cd.data, cd.size,</span>
<span class="p_del">-					    mc_saved_data, initrd, uci);</span>
<span class="p_add">+	return get_matching_model_microcode(start, cd.data, cd.size,</span>
<span class="p_add">+					    mcs, mc_ptrs, uci);</span>
 }
 
 /*
<span class="p_chunk">@@ -567,14 +569,11 @@</span> <span class="p_context"> scan_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
 static void
 print_ucode_info(struct ucode_cpu_info *uci, unsigned int date)
 {
<span class="p_del">-	int cpu = smp_processor_id();</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_info(&quot;CPU%d microcode updated early to revision 0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_del">-		cpu,</span>
<span class="p_del">-		uci-&gt;cpu_sig.rev,</span>
<span class="p_del">-		date &amp; 0xffff,</span>
<span class="p_del">-		date &gt;&gt; 24,</span>
<span class="p_del">-		(date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_add">+	pr_info_once(&quot;microcode updated early to revision 0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_add">+		     uci-&gt;cpu_sig.rev,</span>
<span class="p_add">+		     date &amp; 0xffff,</span>
<span class="p_add">+		     date &gt;&gt; 24,</span>
<span class="p_add">+		     (date &gt;&gt; 16) &amp; 0xff);</span>
 }
 
 #ifdef CONFIG_X86_32
<span class="p_chunk">@@ -603,19 +602,19 @@</span> <span class="p_context"> void show_ucode_info_early(void)</span>
  */
 static void print_ucode(struct ucode_cpu_info *uci)
 {
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_add">+	struct microcode_intel *mc;</span>
 	int *delay_ucode_info_p;
 	int *current_mc_date_p;
 
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_add">+	mc = uci-&gt;mc;</span>
<span class="p_add">+	if (!mc)</span>
 		return;
 
 	delay_ucode_info_p = (int *)__pa_nodebug(&amp;delay_ucode_info);
 	current_mc_date_p = (int *)__pa_nodebug(&amp;current_mc_date);
 
 	*delay_ucode_info_p = 1;
<span class="p_del">-	*current_mc_date_p = mc_intel-&gt;hdr.date;</span>
<span class="p_add">+	*current_mc_date_p = mc-&gt;hdr.date;</span>
 }
 #else
 
<span class="p_chunk">@@ -630,37 +629,35 @@</span> <span class="p_context"> static inline void flush_tlb_early(void)</span>
 
 static inline void print_ucode(struct ucode_cpu_info *uci)
 {
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_add">+	struct microcode_intel *mc;</span>
 
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_add">+	mc = uci-&gt;mc;</span>
<span class="p_add">+	if (!mc)</span>
 		return;
 
<span class="p_del">-	print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_add">+	print_ucode_info(uci, mc-&gt;hdr.date);</span>
 }
 #endif
 
 static int apply_microcode_early(struct ucode_cpu_info *uci, bool early)
 {
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_add">+	struct microcode_intel *mc;</span>
 	unsigned int val[2];
 
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_add">+	mc = uci-&gt;mc;</span>
<span class="p_add">+	if (!mc)</span>
 		return 0;
 
 	/* write microcode via MSR 0x79 */
<span class="p_del">-	native_wrmsr(MSR_IA32_UCODE_WRITE,</span>
<span class="p_del">-	      (unsigned long) mc_intel-&gt;bits,</span>
<span class="p_del">-	      (unsigned long) mc_intel-&gt;bits &gt;&gt; 16 &gt;&gt; 16);</span>
<span class="p_del">-	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_add">+	native_wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc-&gt;bits);</span>
<span class="p_add">+	native_wrmsrl(MSR_IA32_UCODE_REV, 0);</span>
 
 	/* As documented in the SDM: Do a CPUID 1 here */
 	sync_core();
 
 	/* get the current revision from MSR 0x8B */
 	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);
<span class="p_del">-	if (val[1] != mc_intel-&gt;hdr.rev)</span>
<span class="p_add">+	if (val[1] != mc-&gt;hdr.rev)</span>
 		return -1;
 
 #ifdef CONFIG_X86_64
<span class="p_chunk">@@ -672,25 +669,26 @@</span> <span class="p_context"> static int apply_microcode_early(struct ucode_cpu_info *uci, bool early)</span>
 	if (early)
 		print_ucode(uci);
 	else
<span class="p_del">-		print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_add">+		print_ucode_info(uci, mc-&gt;hdr.date);</span>
 
 	return 0;
 }
 
 /*
  * This function converts microcode patch offsets previously stored in
<span class="p_del">- * mc_saved_in_initrd to pointers and stores the pointers in mc_saved_data.</span>
<span class="p_add">+ * mc_tmp_ptrs to pointers and stores the pointers in mc_saved_data.</span>
  */
 int __init save_microcode_in_initrd_intel(void)
 {
<span class="p_del">-	unsigned int count = mc_saved_data.mc_saved_count;</span>
<span class="p_add">+	unsigned int count = mc_saved_data.num_saved;</span>
 	struct microcode_intel *mc_saved[MAX_UCODE_COUNT];
 	int ret = 0;
 
<span class="p_del">-	if (count == 0)</span>
<span class="p_add">+	if (!count)</span>
 		return ret;
 
<span class="p_del">-	copy_initrd_ptrs(mc_saved, mc_saved_in_initrd, initrd_start, count);</span>
<span class="p_add">+	copy_ptrs(mc_saved, mc_tmp_ptrs, get_initrd_start(), count);</span>
<span class="p_add">+</span>
 	ret = save_microcode(&amp;mc_saved_data, mc_saved, count);
 	if (ret)
 		pr_err(&quot;Cannot save microcode patches from initrd.\n&quot;);
<span class="p_chunk">@@ -701,8 +699,7 @@</span> <span class="p_context"> int __init save_microcode_in_initrd_intel(void)</span>
 }
 
 static void __init
<span class="p_del">-_load_ucode_intel_bsp(struct mc_saved_data *mc_saved_data,</span>
<span class="p_del">-		      unsigned long *initrd,</span>
<span class="p_add">+_load_ucode_intel_bsp(struct mc_saved_data *mcs, unsigned long *mc_ptrs,</span>
 		      unsigned long start, unsigned long size)
 {
 	struct ucode_cpu_info uci;
<span class="p_chunk">@@ -710,11 +707,11 @@</span> <span class="p_context"> _load_ucode_intel_bsp(struct mc_saved_data *mc_saved_data,</span>
 
 	collect_cpu_info_early(&amp;uci);
 
<span class="p_del">-	ret = scan_microcode(mc_saved_data, initrd, start, size, &amp;uci);</span>
<span class="p_add">+	ret = scan_microcode(mcs, mc_ptrs, start, size, &amp;uci);</span>
 	if (ret != UCODE_OK)
 		return;
 
<span class="p_del">-	ret = load_microcode(mc_saved_data, initrd, start, &amp;uci);</span>
<span class="p_add">+	ret = load_microcode(mcs, mc_ptrs, start, &amp;uci);</span>
 	if (ret != UCODE_OK)
 		return;
 
<span class="p_chunk">@@ -728,53 +725,49 @@</span> <span class="p_context"> void __init load_ucode_intel_bsp(void)</span>
 	struct boot_params *p;
 
 	p	= (struct boot_params *)__pa_nodebug(&amp;boot_params);
<span class="p_del">-	start	= p-&gt;hdr.ramdisk_image;</span>
 	size	= p-&gt;hdr.ramdisk_size;
 
<span class="p_del">-	_load_ucode_intel_bsp(</span>
<span class="p_del">-			(struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data),</span>
<span class="p_del">-			(unsigned long *)__pa_nodebug(&amp;mc_saved_in_initrd),</span>
<span class="p_del">-			start, size);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set start only if we have an initrd image. We cannot use initrd_start</span>
<span class="p_add">+	 * because it is not set that early yet.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	start	= (size ? p-&gt;hdr.ramdisk_image : 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	_load_ucode_intel_bsp((struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data),</span>
<span class="p_add">+			      (unsigned long *)__pa_nodebug(&amp;mc_tmp_ptrs),</span>
<span class="p_add">+			      start, size);</span>
 #else
<span class="p_del">-	start	= boot_params.hdr.ramdisk_image + PAGE_OFFSET;</span>
 	size	= boot_params.hdr.ramdisk_size;
<span class="p_add">+	start	= (size ? boot_params.hdr.ramdisk_image + PAGE_OFFSET : 0);</span>
 
<span class="p_del">-	_load_ucode_intel_bsp(&amp;mc_saved_data, mc_saved_in_initrd, start, size);</span>
<span class="p_add">+	_load_ucode_intel_bsp(&amp;mc_saved_data, mc_tmp_ptrs, start, size);</span>
 #endif
 }
 
 void load_ucode_intel_ap(void)
 {
<span class="p_del">-	struct mc_saved_data *mc_saved_data_p;</span>
<span class="p_add">+	unsigned long *mcs_tmp_p;</span>
<span class="p_add">+	struct mc_saved_data *mcs_p;</span>
 	struct ucode_cpu_info uci;
<span class="p_del">-	unsigned long *mc_saved_in_initrd_p;</span>
<span class="p_del">-	unsigned long initrd_start_addr;</span>
 	enum ucode_state ret;
 #ifdef CONFIG_X86_32
<span class="p_del">-	unsigned long *initrd_start_p;</span>
 
<span class="p_del">-	mc_saved_in_initrd_p =</span>
<span class="p_del">-		(unsigned long *)__pa_nodebug(mc_saved_in_initrd);</span>
<span class="p_del">-	mc_saved_data_p = (struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data);</span>
<span class="p_del">-	initrd_start_p = (unsigned long *)__pa_nodebug(&amp;initrd_start);</span>
<span class="p_del">-	initrd_start_addr = (unsigned long)__pa_nodebug(*initrd_start_p);</span>
<span class="p_add">+	mcs_tmp_p = (unsigned long *)__pa_nodebug(mc_tmp_ptrs);</span>
<span class="p_add">+	mcs_p = (struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data);</span>
 #else
<span class="p_del">-	mc_saved_data_p = &amp;mc_saved_data;</span>
<span class="p_del">-	mc_saved_in_initrd_p = mc_saved_in_initrd;</span>
<span class="p_del">-	initrd_start_addr = initrd_start;</span>
<span class="p_add">+	mcs_tmp_p = mc_tmp_ptrs;</span>
<span class="p_add">+	mcs_p = &amp;mc_saved_data;</span>
 #endif
 
 	/*
 	 * If there is no valid ucode previously saved in memory, no need to
 	 * update ucode on this AP.
 	 */
<span class="p_del">-	if (mc_saved_data_p-&gt;mc_saved_count == 0)</span>
<span class="p_add">+	if (!mcs_p-&gt;num_saved)</span>
 		return;
 
 	collect_cpu_info_early(&amp;uci);
<span class="p_del">-	ret = load_microcode(mc_saved_data_p, mc_saved_in_initrd_p,</span>
<span class="p_del">-			     initrd_start_addr, &amp;uci);</span>
<span class="p_del">-</span>
<span class="p_add">+	ret = load_microcode(mcs_p, mcs_tmp_p, get_initrd_start_addr(), &amp;uci);</span>
 	if (ret != UCODE_OK)
 		return;
 
<span class="p_chunk">@@ -786,13 +779,13 @@</span> <span class="p_context"> void reload_ucode_intel(void)</span>
 	struct ucode_cpu_info uci;
 	enum ucode_state ret;
 
<span class="p_del">-	if (!mc_saved_data.mc_saved_count)</span>
<span class="p_add">+	if (!mc_saved_data.num_saved)</span>
 		return;
 
 	collect_cpu_info_early(&amp;uci);
 
 	ret = load_microcode_early(mc_saved_data.mc_saved,
<span class="p_del">-				   mc_saved_data.mc_saved_count, &amp;uci);</span>
<span class="p_add">+				   mc_saved_data.num_saved, &amp;uci);</span>
 	if (ret != UCODE_OK)
 		return;
 
<span class="p_chunk">@@ -825,7 +818,7 @@</span> <span class="p_context"> static int collect_cpu_info(int cpu_num, struct cpu_signature *csig)</span>
  * return 0 - no update found
  * return 1 - found update
  */
<span class="p_del">-static int get_matching_mc(struct microcode_intel *mc_intel, int cpu)</span>
<span class="p_add">+static int get_matching_mc(struct microcode_intel *mc, int cpu)</span>
 {
 	struct cpu_signature cpu_sig;
 	unsigned int csig, cpf, crev;
<span class="p_chunk">@@ -836,39 +829,36 @@</span> <span class="p_context"> static int get_matching_mc(struct microcode_intel *mc_intel, int cpu)</span>
 	cpf = cpu_sig.pf;
 	crev = cpu_sig.rev;
 
<span class="p_del">-	return has_newer_microcode(mc_intel, csig, cpf, crev);</span>
<span class="p_add">+	return has_newer_microcode(mc, csig, cpf, crev);</span>
 }
 
 static int apply_microcode_intel(int cpu)
 {
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_add">+	struct microcode_intel *mc;</span>
 	struct ucode_cpu_info *uci;
<span class="p_add">+	struct cpuinfo_x86 *c;</span>
 	unsigned int val[2];
<span class="p_del">-	int cpu_num = raw_smp_processor_id();</span>
<span class="p_del">-	struct cpuinfo_x86 *c = &amp;cpu_data(cpu_num);</span>
<span class="p_del">-</span>
<span class="p_del">-	uci = ucode_cpu_info + cpu;</span>
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
 
 	/* We should bind the task to the CPU */
<span class="p_del">-	BUG_ON(cpu_num != cpu);</span>
<span class="p_add">+	if (WARN_ON(raw_smp_processor_id() != cpu))</span>
<span class="p_add">+		return -1;</span>
 
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_add">+	uci = ucode_cpu_info + cpu;</span>
<span class="p_add">+	mc = uci-&gt;mc;</span>
<span class="p_add">+	if (!mc)</span>
 		return 0;
 
 	/*
 	 * Microcode on this CPU could be updated earlier. Only apply the
<span class="p_del">-	 * microcode patch in mc_intel when it is newer than the one on this</span>
<span class="p_add">+	 * microcode patch in mc when it is newer than the one on this</span>
 	 * CPU.
 	 */
<span class="p_del">-	if (get_matching_mc(mc_intel, cpu) == 0)</span>
<span class="p_add">+	if (!get_matching_mc(mc, cpu))</span>
 		return 0;
 
 	/* write microcode via MSR 0x79 */
<span class="p_del">-	wrmsr(MSR_IA32_UCODE_WRITE,</span>
<span class="p_del">-	      (unsigned long) mc_intel-&gt;bits,</span>
<span class="p_del">-	      (unsigned long) mc_intel-&gt;bits &gt;&gt; 16 &gt;&gt; 16);</span>
<span class="p_del">-	wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_add">+	wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc-&gt;bits);</span>
<span class="p_add">+	wrmsrl(MSR_IA32_UCODE_REV, 0);</span>
 
 	/* As documented in the SDM: Do a CPUID 1 here */
 	sync_core();
<span class="p_chunk">@@ -876,16 +866,19 @@</span> <span class="p_context"> static int apply_microcode_intel(int cpu)</span>
 	/* get the current revision from MSR 0x8B */
 	rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);
 
<span class="p_del">-	if (val[1] != mc_intel-&gt;hdr.rev) {</span>
<span class="p_add">+	if (val[1] != mc-&gt;hdr.rev) {</span>
 		pr_err(&quot;CPU%d update to revision 0x%x failed\n&quot;,
<span class="p_del">-		       cpu_num, mc_intel-&gt;hdr.rev);</span>
<span class="p_add">+		       cpu, mc-&gt;hdr.rev);</span>
 		return -1;
 	}
<span class="p_add">+</span>
 	pr_info(&quot;CPU%d updated to revision 0x%x, date = %04x-%02x-%02x\n&quot;,
<span class="p_del">-		cpu_num, val[1],</span>
<span class="p_del">-		mc_intel-&gt;hdr.date &amp; 0xffff,</span>
<span class="p_del">-		mc_intel-&gt;hdr.date &gt;&gt; 24,</span>
<span class="p_del">-		(mc_intel-&gt;hdr.date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_add">+		cpu, val[1],</span>
<span class="p_add">+		mc-&gt;hdr.date &amp; 0xffff,</span>
<span class="p_add">+		mc-&gt;hdr.date &gt;&gt; 24,</span>
<span class="p_add">+		(mc-&gt;hdr.date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_add">+</span>
<span class="p_add">+	c = &amp;cpu_data(cpu);</span>
 
 	uci-&gt;cpu_sig.rev = val[1];
 	c-&gt;microcode = val[1];
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel_lib.c b/arch/x86/kernel/cpu/microcode/intel_lib.c</span>
<span class="p_header">index b96896bcbdaf..2ce1a7dc45b7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel_lib.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel_lib.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> int microcode_sanity_check(void *mc, int print_err)</span>
 	unsigned long total_size, data_size, ext_table_size;
 	struct microcode_header_intel *mc_header = mc;
 	struct extended_sigtable *ext_header = NULL;
<span class="p_del">-	int sum, orig_sum, ext_sigcount = 0, i;</span>
<span class="p_add">+	u32 sum, orig_sum, ext_sigcount = 0, i;</span>
 	struct extended_signature *ext_sig;
 
 	total_size = get_totalsize(mc_header);
<span class="p_chunk">@@ -57,69 +57,85 @@</span> <span class="p_context"> int microcode_sanity_check(void *mc, int print_err)</span>
 
 	if (data_size + MC_HEADER_SIZE &gt; total_size) {
 		if (print_err)
<span class="p_del">-			pr_err(&quot;error! Bad data size in microcode data file\n&quot;);</span>
<span class="p_add">+			pr_err(&quot;Error: bad microcode data file size.\n&quot;);</span>
 		return -EINVAL;
 	}
 
 	if (mc_header-&gt;ldrver != 1 || mc_header-&gt;hdrver != 1) {
 		if (print_err)
<span class="p_del">-			pr_err(&quot;error! Unknown microcode update format\n&quot;);</span>
<span class="p_add">+			pr_err(&quot;Error: invalid/unknown microcode update format.\n&quot;);</span>
 		return -EINVAL;
 	}
<span class="p_add">+</span>
 	ext_table_size = total_size - (MC_HEADER_SIZE + data_size);
 	if (ext_table_size) {
<span class="p_add">+		u32 ext_table_sum = 0;</span>
<span class="p_add">+		u32 *ext_tablep;</span>
<span class="p_add">+</span>
 		if ((ext_table_size &lt; EXT_HEADER_SIZE)
 		 || ((ext_table_size - EXT_HEADER_SIZE) % EXT_SIGNATURE_SIZE)) {
 			if (print_err)
<span class="p_del">-				pr_err(&quot;error! Small exttable size in microcode data file\n&quot;);</span>
<span class="p_add">+				pr_err(&quot;Error: truncated extended signature table.\n&quot;);</span>
 			return -EINVAL;
 		}
<span class="p_add">+</span>
 		ext_header = mc + MC_HEADER_SIZE + data_size;
 		if (ext_table_size != exttable_size(ext_header)) {
 			if (print_err)
<span class="p_del">-				pr_err(&quot;error! Bad exttable size in microcode data file\n&quot;);</span>
<span class="p_add">+				pr_err(&quot;Error: extended signature table size mismatch.\n&quot;);</span>
 			return -EFAULT;
 		}
<span class="p_add">+</span>
 		ext_sigcount = ext_header-&gt;count;
<span class="p_del">-	}</span>
 
<span class="p_del">-	/* check extended table checksum */</span>
<span class="p_del">-	if (ext_table_size) {</span>
<span class="p_del">-		int ext_table_sum = 0;</span>
<span class="p_del">-		int *ext_tablep = (int *)ext_header;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Check extended table checksum: the sum of all dwords that</span>
<span class="p_add">+		 * comprise a valid table must be 0.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ext_tablep = (u32 *)ext_header;</span>
 
<span class="p_del">-		i = ext_table_size / DWSIZE;</span>
<span class="p_add">+		i = ext_table_size / sizeof(u32);</span>
 		while (i--)
 			ext_table_sum += ext_tablep[i];
<span class="p_add">+</span>
 		if (ext_table_sum) {
 			if (print_err)
<span class="p_del">-				pr_warn(&quot;aborting, bad extended signature table checksum\n&quot;);</span>
<span class="p_add">+				pr_warn(&quot;Bad extended signature table checksum, aborting.\n&quot;);</span>
 			return -EINVAL;
 		}
 	}
 
<span class="p_del">-	/* calculate the checksum */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Calculate the checksum of update data and header. The checksum of</span>
<span class="p_add">+	 * valid update data and header including the extended signature table</span>
<span class="p_add">+	 * must be 0.</span>
<span class="p_add">+	 */</span>
 	orig_sum = 0;
<span class="p_del">-	i = (MC_HEADER_SIZE + data_size) / DWSIZE;</span>
<span class="p_add">+	i = (MC_HEADER_SIZE + data_size) / sizeof(u32);</span>
 	while (i--)
<span class="p_del">-		orig_sum += ((int *)mc)[i];</span>
<span class="p_add">+		orig_sum += ((u32 *)mc)[i];</span>
<span class="p_add">+</span>
 	if (orig_sum) {
 		if (print_err)
<span class="p_del">-			pr_err(&quot;aborting, bad checksum\n&quot;);</span>
<span class="p_add">+			pr_err(&quot;Bad microcode data checksum, aborting.\n&quot;);</span>
 		return -EINVAL;
 	}
<span class="p_add">+</span>
 	if (!ext_table_size)
 		return 0;
<span class="p_del">-	/* check extended signature checksum */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check extended signature checksum: 0 =&gt; valid.</span>
<span class="p_add">+	 */</span>
 	for (i = 0; i &lt; ext_sigcount; i++) {
 		ext_sig = (void *)ext_header + EXT_HEADER_SIZE +
 			  EXT_SIGNATURE_SIZE * i;
<span class="p_del">-		sum = orig_sum</span>
<span class="p_del">-			- (mc_header-&gt;sig + mc_header-&gt;pf + mc_header-&gt;cksum)</span>
<span class="p_del">-			+ (ext_sig-&gt;sig + ext_sig-&gt;pf + ext_sig-&gt;cksum);</span>
<span class="p_add">+</span>
<span class="p_add">+		sum = (mc_header-&gt;sig + mc_header-&gt;pf + mc_header-&gt;cksum) -</span>
<span class="p_add">+		      (ext_sig-&gt;sig + ext_sig-&gt;pf + ext_sig-&gt;cksum);</span>
 		if (sum) {
 			if (print_err)
<span class="p_del">-				pr_err(&quot;aborting, bad checksum\n&quot;);</span>
<span class="p_add">+				pr_err(&quot;Bad extended signature checksum, aborting.\n&quot;);</span>
 			return -EINVAL;
 		}
 	}

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



