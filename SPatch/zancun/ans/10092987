
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.14.4 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.14.4</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 5, 2017, 2:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171205140737.GB22092@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10092987/mbox/"
   >mbox</a>
|
   <a href="/patch/10092987/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10092987/">/patch/10092987/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	B63DE6035E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Dec 2017 14:08:02 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8A33C27D16
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Dec 2017 14:08:02 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 77F5628E90; Tue,  5 Dec 2017 14:08:02 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D7BD027D16
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Dec 2017 14:07:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753381AbdLEOHy (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 5 Dec 2017 09:07:54 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:46556 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753375AbdLEOHa (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 5 Dec 2017 09:07:30 -0500
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 167D0C0C;
	Tue,  5 Dec 2017 14:07:28 +0000 (UTC)
Date: Tue, 5 Dec 2017 15:07:37 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.14.4
Message-ID: &lt;20171205140737.GB22092@kroah.com&gt;
References: &lt;20171205140733.GA22092@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171205140733.GA22092@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 5, 2017, 2:07 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/hwmon/jc42.txt b/Documentation/devicetree/bindings/hwmon/jc42.txt</span>
<span class="p_header">index 07a250498fbb..f569db58f64a 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/hwmon/jc42.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/hwmon/jc42.txt</span>
<span class="p_chunk">@@ -34,6 +34,10 @@</span> <span class="p_context"> Required properties:</span>
 
 - reg: I2C address
 
<span class="p_add">+Optional properties:</span>
<span class="p_add">+- smbus-timeout-disable: When set, the smbus timeout function will be disabled.</span>
<span class="p_add">+			 This is not supported on all chips.</span>
<span class="p_add">+</span>
 Example:
 
 temp-sensor@1a {
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index ede4de0d8634..ba1648c093fe 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 4
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 3</span>
<span class="p_add">+SUBLEVEL = 4</span>
 EXTRAVERSION =
 NAME = Petit Gorille
 
<span class="p_header">diff --git a/arch/arm64/Makefile b/arch/arm64/Makefile</span>
<span class="p_header">index 939b310913cf..3eb4397150df 100644</span>
<span class="p_header">--- a/arch/arm64/Makefile</span>
<span class="p_header">+++ b/arch/arm64/Makefile</span>
<span class="p_chunk">@@ -77,9 +77,6 @@</span> <span class="p_context"> endif</span>
 
 ifeq ($(CONFIG_ARM64_MODULE_PLTS),y)
 KBUILD_LDFLAGS_MODULE	+= -T $(srctree)/arch/arm64/kernel/module.lds
<span class="p_del">-ifeq ($(CONFIG_DYNAMIC_FTRACE),y)</span>
<span class="p_del">-KBUILD_LDFLAGS_MODULE	+= $(objtree)/arch/arm64/kernel/ftrace-mod.o</span>
<span class="p_del">-endif</span>
 endif
 
 # Default value
<span class="p_header">diff --git a/arch/arm64/include/asm/module.h b/arch/arm64/include/asm/module.h</span>
<span class="p_header">index 19bd97671bb8..4f766178fa6f 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/module.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/module.h</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> struct mod_arch_specific {</span>
 	struct mod_plt_sec	init;
 
 	/* for CONFIG_DYNAMIC_FTRACE */
<span class="p_del">-	void			*ftrace_trampoline;</span>
<span class="p_add">+	struct plt_entry 	*ftrace_trampoline;</span>
 };
 #endif
 
<span class="p_chunk">@@ -45,4 +45,48 @@</span> <span class="p_context"> extern u64 module_alloc_base;</span>
 #define module_alloc_base	((u64)_etext - MODULES_VSIZE)
 #endif
 
<span class="p_add">+struct plt_entry {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * A program that conforms to the AArch64 Procedure Call Standard</span>
<span class="p_add">+	 * (AAPCS64) must assume that a veneer that alters IP0 (x16) and/or</span>
<span class="p_add">+	 * IP1 (x17) may be inserted at any branch instruction that is</span>
<span class="p_add">+	 * exposed to a relocation that supports long branches. Since that</span>
<span class="p_add">+	 * is exactly what we are dealing with here, we are free to use x16</span>
<span class="p_add">+	 * as a scratch register in the PLT veneers.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__le32	mov0;	/* movn	x16, #0x....			*/</span>
<span class="p_add">+	__le32	mov1;	/* movk	x16, #0x...., lsl #16		*/</span>
<span class="p_add">+	__le32	mov2;	/* movk	x16, #0x...., lsl #32		*/</span>
<span class="p_add">+	__le32	br;	/* br	x16				*/</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct plt_entry get_plt_entry(u64 val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * MOVK/MOVN/MOVZ opcode:</span>
<span class="p_add">+	 * +--------+------------+--------+-----------+-------------+---------+</span>
<span class="p_add">+	 * | sf[31] | opc[30:29] | 100101 | hw[22:21] | imm16[20:5] | Rd[4:0] |</span>
<span class="p_add">+	 * +--------+------------+--------+-----------+-------------+---------+</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Rd     := 0x10 (x16)</span>
<span class="p_add">+	 * hw     := 0b00 (no shift), 0b01 (lsl #16), 0b10 (lsl #32)</span>
<span class="p_add">+	 * opc    := 0b11 (MOVK), 0b00 (MOVN), 0b10 (MOVZ)</span>
<span class="p_add">+	 * sf     := 1 (64-bit variant)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return (struct plt_entry){</span>
<span class="p_add">+		cpu_to_le32(0x92800010 | (((~val      ) &amp; 0xffff)) &lt;&lt; 5),</span>
<span class="p_add">+		cpu_to_le32(0xf2a00010 | ((( val &gt;&gt; 16) &amp; 0xffff)) &lt;&lt; 5),</span>
<span class="p_add">+		cpu_to_le32(0xf2c00010 | ((( val &gt;&gt; 32) &amp; 0xffff)) &lt;&lt; 5),</span>
<span class="p_add">+		cpu_to_le32(0xd61f0200)</span>
<span class="p_add">+	};</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool plt_entries_equal(const struct plt_entry *a,</span>
<span class="p_add">+				     const struct plt_entry *b)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return a-&gt;mov0 == b-&gt;mov0 &amp;&amp;</span>
<span class="p_add">+	       a-&gt;mov1 == b-&gt;mov1 &amp;&amp;</span>
<span class="p_add">+	       a-&gt;mov2 == b-&gt;mov2;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* __ASM_MODULE_H */
<span class="p_header">diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile</span>
<span class="p_header">index 0029e13adb59..2f5ff2a65db3 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/Makefile</span>
<span class="p_header">+++ b/arch/arm64/kernel/Makefile</span>
<span class="p_chunk">@@ -63,6 +63,3 @@</span> <span class="p_context"> extra-y					+= $(head-y) vmlinux.lds</span>
 ifeq ($(CONFIG_DEBUG_EFI),y)
 AFLAGS_head.o += -DVMLINUX_PATH=&quot;\&quot;$(realpath $(objtree)/vmlinux)\&quot;&quot;
 endif
<span class="p_del">-</span>
<span class="p_del">-# will be included by each individual module but not by the core kernel itself</span>
<span class="p_del">-extra-$(CONFIG_DYNAMIC_FTRACE) += ftrace-mod.o</span>
<span class="p_header">diff --git a/arch/arm64/kernel/ftrace-mod.S b/arch/arm64/kernel/ftrace-mod.S</span>
deleted file mode 100644
<span class="p_header">index 00c4025be4ff..000000000000</span>
<span class="p_header">--- a/arch/arm64/kernel/ftrace-mod.S</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,18 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Copyright (C) 2017 Linaro Ltd &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_del">- * published by the Free Software Foundation.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/linkage.h&gt;</span>
<span class="p_del">-#include &lt;asm/assembler.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-	.section	&quot;.text.ftrace_trampoline&quot;, &quot;ax&quot;</span>
<span class="p_del">-	.align		3</span>
<span class="p_del">-0:	.quad		0</span>
<span class="p_del">-__ftrace_trampoline:</span>
<span class="p_del">-	ldr		x16, 0b</span>
<span class="p_del">-	br		x16</span>
<span class="p_del">-ENDPROC(__ftrace_trampoline)</span>
<span class="p_header">diff --git a/arch/arm64/kernel/ftrace.c b/arch/arm64/kernel/ftrace.c</span>
<span class="p_header">index c13b1fca0e5b..50986e388d2b 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/ftrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/ftrace.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)</span>
 
 	if (offset &lt; -SZ_128M || offset &gt;= SZ_128M) {
 #ifdef CONFIG_ARM64_MODULE_PLTS
<span class="p_del">-		unsigned long *trampoline;</span>
<span class="p_add">+		struct plt_entry trampoline;</span>
 		struct module *mod;
 
 		/*
<span class="p_chunk">@@ -104,22 +104,24 @@</span> <span class="p_context"> int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)</span>
 		 * is added in the future, but for now, the pr_err() below
 		 * deals with a theoretical issue only.
 		 */
<span class="p_del">-		trampoline = (unsigned long *)mod-&gt;arch.ftrace_trampoline;</span>
<span class="p_del">-		if (trampoline[0] != addr) {</span>
<span class="p_del">-			if (trampoline[0] != 0) {</span>
<span class="p_add">+		trampoline = get_plt_entry(addr);</span>
<span class="p_add">+		if (!plt_entries_equal(mod-&gt;arch.ftrace_trampoline,</span>
<span class="p_add">+				       &amp;trampoline)) {</span>
<span class="p_add">+			if (!plt_entries_equal(mod-&gt;arch.ftrace_trampoline,</span>
<span class="p_add">+					       &amp;(struct plt_entry){})) {</span>
 				pr_err(&quot;ftrace: far branches to multiple entry points unsupported inside a single module\n&quot;);
 				return -EINVAL;
 			}
 
 			/* point the trampoline to our ftrace entry point */
 			module_disable_ro(mod);
<span class="p_del">-			trampoline[0] = addr;</span>
<span class="p_add">+			*mod-&gt;arch.ftrace_trampoline = trampoline;</span>
 			module_enable_ro(mod, true);
 
 			/* update trampoline before patching in the branch */
 			smp_wmb();
 		}
<span class="p_del">-		addr = (unsigned long)&amp;trampoline[1];</span>
<span class="p_add">+		addr = (unsigned long)(void *)mod-&gt;arch.ftrace_trampoline;</span>
 #else /* CONFIG_ARM64_MODULE_PLTS */
 		return -EINVAL;
 #endif /* CONFIG_ARM64_MODULE_PLTS */
<span class="p_header">diff --git a/arch/arm64/kernel/module-plts.c b/arch/arm64/kernel/module-plts.c</span>
<span class="p_header">index d05dbe658409..ea640f92fe5a 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/module-plts.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/module-plts.c</span>
<span class="p_chunk">@@ -11,21 +11,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/sort.h&gt;
 
<span class="p_del">-struct plt_entry {</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * A program that conforms to the AArch64 Procedure Call Standard</span>
<span class="p_del">-	 * (AAPCS64) must assume that a veneer that alters IP0 (x16) and/or</span>
<span class="p_del">-	 * IP1 (x17) may be inserted at any branch instruction that is</span>
<span class="p_del">-	 * exposed to a relocation that supports long branches. Since that</span>
<span class="p_del">-	 * is exactly what we are dealing with here, we are free to use x16</span>
<span class="p_del">-	 * as a scratch register in the PLT veneers.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	__le32	mov0;	/* movn	x16, #0x....			*/</span>
<span class="p_del">-	__le32	mov1;	/* movk	x16, #0x...., lsl #16		*/</span>
<span class="p_del">-	__le32	mov2;	/* movk	x16, #0x...., lsl #32		*/</span>
<span class="p_del">-	__le32	br;	/* br	x16				*/</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static bool in_init(const struct module *mod, void *loc)
 {
 	return (u64)loc - (u64)mod-&gt;init_layout.base &lt; mod-&gt;init_layout.size;
<span class="p_chunk">@@ -40,33 +25,14 @@</span> <span class="p_context"> u64 module_emit_plt_entry(struct module *mod, void *loc, const Elf64_Rela *rela,</span>
 	int i = pltsec-&gt;plt_num_entries;
 	u64 val = sym-&gt;st_value + rela-&gt;r_addend;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * MOVK/MOVN/MOVZ opcode:</span>
<span class="p_del">-	 * +--------+------------+--------+-----------+-------------+---------+</span>
<span class="p_del">-	 * | sf[31] | opc[30:29] | 100101 | hw[22:21] | imm16[20:5] | Rd[4:0] |</span>
<span class="p_del">-	 * +--------+------------+--------+-----------+-------------+---------+</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Rd     := 0x10 (x16)</span>
<span class="p_del">-	 * hw     := 0b00 (no shift), 0b01 (lsl #16), 0b10 (lsl #32)</span>
<span class="p_del">-	 * opc    := 0b11 (MOVK), 0b00 (MOVN), 0b10 (MOVZ)</span>
<span class="p_del">-	 * sf     := 1 (64-bit variant)</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	plt[i] = (struct plt_entry){</span>
<span class="p_del">-		cpu_to_le32(0x92800010 | (((~val      ) &amp; 0xffff)) &lt;&lt; 5),</span>
<span class="p_del">-		cpu_to_le32(0xf2a00010 | ((( val &gt;&gt; 16) &amp; 0xffff)) &lt;&lt; 5),</span>
<span class="p_del">-		cpu_to_le32(0xf2c00010 | ((( val &gt;&gt; 32) &amp; 0xffff)) &lt;&lt; 5),</span>
<span class="p_del">-		cpu_to_le32(0xd61f0200)</span>
<span class="p_del">-	};</span>
<span class="p_add">+	plt[i] = get_plt_entry(val);</span>
 
 	/*
 	 * Check if the entry we just created is a duplicate. Given that the
 	 * relocations are sorted, this will be the last entry we allocated.
 	 * (if one exists).
 	 */
<span class="p_del">-	if (i &gt; 0 &amp;&amp;</span>
<span class="p_del">-	    plt[i].mov0 == plt[i - 1].mov0 &amp;&amp;</span>
<span class="p_del">-	    plt[i].mov1 == plt[i - 1].mov1 &amp;&amp;</span>
<span class="p_del">-	    plt[i].mov2 == plt[i - 1].mov2)</span>
<span class="p_add">+	if (i &gt; 0 &amp;&amp; plt_entries_equal(plt + i, plt + i - 1))</span>
 		return (u64)&amp;plt[i - 1];
 
 	pltsec-&gt;plt_num_entries++;
<span class="p_chunk">@@ -154,6 +120,7 @@</span> <span class="p_context"> int module_frob_arch_sections(Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,</span>
 	unsigned long core_plts = 0;
 	unsigned long init_plts = 0;
 	Elf64_Sym *syms = NULL;
<span class="p_add">+	Elf_Shdr *tramp = NULL;</span>
 	int i;
 
 	/*
<span class="p_chunk">@@ -165,6 +132,10 @@</span> <span class="p_context"> int module_frob_arch_sections(Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,</span>
 			mod-&gt;arch.core.plt = sechdrs + i;
 		else if (!strcmp(secstrings + sechdrs[i].sh_name, &quot;.init.plt&quot;))
 			mod-&gt;arch.init.plt = sechdrs + i;
<span class="p_add">+		else if (IS_ENABLED(CONFIG_DYNAMIC_FTRACE) &amp;&amp;</span>
<span class="p_add">+			 !strcmp(secstrings + sechdrs[i].sh_name,</span>
<span class="p_add">+				 &quot;.text.ftrace_trampoline&quot;))</span>
<span class="p_add">+			tramp = sechdrs + i;</span>
 		else if (sechdrs[i].sh_type == SHT_SYMTAB)
 			syms = (Elf64_Sym *)sechdrs[i].sh_addr;
 	}
<span class="p_chunk">@@ -215,5 +186,12 @@</span> <span class="p_context"> int module_frob_arch_sections(Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,</span>
 	mod-&gt;arch.init.plt_num_entries = 0;
 	mod-&gt;arch.init.plt_max_entries = init_plts;
 
<span class="p_add">+	if (tramp) {</span>
<span class="p_add">+		tramp-&gt;sh_type = SHT_NOBITS;</span>
<span class="p_add">+		tramp-&gt;sh_flags = SHF_EXECINSTR | SHF_ALLOC;</span>
<span class="p_add">+		tramp-&gt;sh_addralign = __alignof__(struct plt_entry);</span>
<span class="p_add">+		tramp-&gt;sh_size = sizeof(struct plt_entry);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
<span class="p_header">diff --git a/arch/arm64/kernel/module.lds b/arch/arm64/kernel/module.lds</span>
<span class="p_header">index f7c9781a9d48..22e36a21c113 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/module.lds</span>
<span class="p_header">+++ b/arch/arm64/kernel/module.lds</span>
<span class="p_chunk">@@ -1,4 +1,5 @@</span> <span class="p_context"></span>
 SECTIONS {
 	.plt (NOLOAD) : { BYTE(0) }
 	.init.plt (NOLOAD) : { BYTE(0) }
<span class="p_add">+	.text.ftrace_trampoline (NOLOAD) : { BYTE(0) }</span>
 }
<span class="p_header">diff --git a/arch/powerpc/kernel/misc_64.S b/arch/powerpc/kernel/misc_64.S</span>
<span class="p_header">index 8ac0bd2bddb0..3280953a82cf 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/misc_64.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/misc_64.S</span>
<span class="p_chunk">@@ -623,7 +623,9 @@</span> <span class="p_context"> BEGIN_FTR_SECTION</span>
 	 * NOTE, we rely on r0 being 0 from above.
 	 */
 	mtspr	SPRN_IAMR,r0
<span class="p_add">+BEGIN_FTR_SECTION_NESTED(42)</span>
 	mtspr	SPRN_AMOR,r0
<span class="p_add">+END_FTR_SECTION_NESTED_IFSET(CPU_FTR_HVMODE, 42)</span>
 END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)
 
 	/* save regs for local vars on new stack.
<span class="p_header">diff --git a/arch/powerpc/mm/hash_native_64.c b/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_header">index 3848af167df9..640cf566e986 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_chunk">@@ -47,7 +47,8 @@</span> <span class="p_context"></span>
 
 DEFINE_RAW_SPINLOCK(native_tlbie_lock);
 
<span class="p_del">-static inline void __tlbie(unsigned long vpn, int psize, int apsize, int ssize)</span>
<span class="p_add">+static inline unsigned long  ___tlbie(unsigned long vpn, int psize,</span>
<span class="p_add">+						int apsize, int ssize)</span>
 {
 	unsigned long va;
 	unsigned int penc;
<span class="p_chunk">@@ -100,7 +101,15 @@</span> <span class="p_context"> static inline void __tlbie(unsigned long vpn, int psize, int apsize, int ssize)</span>
 			     : &quot;memory&quot;);
 		break;
 	}
<span class="p_del">-	trace_tlbie(0, 0, va, 0, 0, 0, 0);</span>
<span class="p_add">+	return va;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __tlbie(unsigned long vpn, int psize, int apsize, int ssize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long rb;</span>
<span class="p_add">+</span>
<span class="p_add">+	rb = ___tlbie(vpn, psize, apsize, ssize);</span>
<span class="p_add">+	trace_tlbie(0, 0, rb, 0, 0, 0, 0);</span>
 }
 
 static inline void __tlbiel(unsigned long vpn, int psize, int apsize, int ssize)
<span class="p_chunk">@@ -652,7 +661,7 @@</span> <span class="p_context"> static void native_hpte_clear(void)</span>
 		if (hpte_v &amp; HPTE_V_VALID) {
 			hpte_decode(hptep, slot, &amp;psize, &amp;apsize, &amp;ssize, &amp;vpn);
 			hptep-&gt;v = 0;
<span class="p_del">-			__tlbie(vpn, psize, apsize, ssize);</span>
<span class="p_add">+			___tlbie(vpn, psize, apsize, ssize);</span>
 		}
 	}
 
<span class="p_header">diff --git a/arch/s390/include/asm/elf.h b/arch/s390/include/asm/elf.h</span>
<span class="p_header">index 9a3cb3983c01..1a61b1b997f2 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/elf.h</span>
<span class="p_chunk">@@ -194,13 +194,14 @@</span> <span class="p_context"> struct arch_elf_state {</span>
 #define CORE_DUMP_USE_REGSET
 #define ELF_EXEC_PAGESIZE	PAGE_SIZE
 
<span class="p_del">-/*</span>
<span class="p_del">- * This is the base location for PIE (ET_DYN with INTERP) loads. On</span>
<span class="p_del">- * 64-bit, this is raised to 4GB to leave the entire 32-bit address</span>
<span class="p_del">- * space open for things that want to use the area for 32-bit pointers.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define ELF_ET_DYN_BASE		(is_compat_task() ? 0x000400000UL : \</span>
<span class="p_del">-						    0x100000000UL)</span>
<span class="p_add">+/* This is the location that an ET_DYN program is loaded if exec&#39;ed.  Typical</span>
<span class="p_add">+   use of this is to invoke &quot;./ld.so someprog&quot; to test out a new version of</span>
<span class="p_add">+   the loader.  We need to make sure that it is out of the way of the program</span>
<span class="p_add">+   that it will &quot;exec&quot;, and that there is sufficient room for the brk. 64-bit</span>
<span class="p_add">+   tasks are aligned to 4GB. */</span>
<span class="p_add">+#define ELF_ET_DYN_BASE (is_compat_task() ? \</span>
<span class="p_add">+				(STACK_TOP / 3 * 2) : \</span>
<span class="p_add">+				(STACK_TOP / 3 * 2) &amp; ~((1UL &lt;&lt; 32) - 1))</span>
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports. */
<span class="p_header">diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S</span>
<span class="p_header">index 518d9286b3d1..2e956afe272c 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_64.S</span>
<span class="p_chunk">@@ -51,19 +51,15 @@</span> <span class="p_context"> ENTRY(native_usergs_sysret64)</span>
 END(native_usergs_sysret64)
 #endif /* CONFIG_PARAVIRT */
 
<span class="p_del">-.macro TRACE_IRQS_FLAGS flags:req</span>
<span class="p_add">+.macro TRACE_IRQS_IRETQ</span>
 #ifdef CONFIG_TRACE_IRQFLAGS
<span class="p_del">-	bt	$9, \flags		/* interrupts off? */</span>
<span class="p_add">+	bt	$9, EFLAGS(%rsp)		/* interrupts off? */</span>
 	jnc	1f
 	TRACE_IRQS_ON
 1:
 #endif
 .endm
 
<span class="p_del">-.macro TRACE_IRQS_IRETQ</span>
<span class="p_del">-	TRACE_IRQS_FLAGS EFLAGS(%rsp)</span>
<span class="p_del">-.endm</span>
<span class="p_del">-</span>
 /*
  * When dynamic function tracer is enabled it will add a breakpoint
  * to all locations that it is about to modify, sync CPUs, update
<span class="p_chunk">@@ -927,13 +923,11 @@</span> <span class="p_context"> ENTRY(native_load_gs_index)</span>
 	FRAME_BEGIN
 	pushfq
 	DISABLE_INTERRUPTS(CLBR_ANY &amp; ~CLBR_RDI)
<span class="p_del">-	TRACE_IRQS_OFF</span>
 	SWAPGS
 .Lgs_change:
 	movl	%edi, %gs
 2:	ALTERNATIVE &quot;&quot;, &quot;mfence&quot;, X86_BUG_SWAPGS_FENCE
 	SWAPGS
<span class="p_del">-	TRACE_IRQS_FLAGS (%rsp)</span>
 	popfq
 	FRAME_END
 	ret
<span class="p_header">diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h</span>
<span class="p_header">index f735c3016325..f02de8bc1f72 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -1093,6 +1093,12 @@</span> <span class="p_context"> static inline void pmdp_set_wrprotect(struct mm_struct *mm,</span>
 	clear_bit(_PAGE_BIT_RW, (unsigned long *)pmdp);
 }
 
<span class="p_add">+#define pud_write pud_write</span>
<span class="p_add">+static inline int pud_write(pud_t pud)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return pud_flags(pud) &amp; _PAGE_RW;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * clone_pgd_range(pgd_t *dst, pgd_t *src, int count);
  *
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 36c90d631096..ef03efba1c23 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -266,9 +266,14 @@</span> <span class="p_context"> static inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)</span>
 	recalculate_apic_map(apic-&gt;vcpu-&gt;kvm);
 }
 
<span class="p_add">+static inline u32 kvm_apic_calc_x2apic_ldr(u32 id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ((id &gt;&gt; 4) &lt;&lt; 16) | (1 &lt;&lt; (id &amp; 0xf));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)
 {
<span class="p_del">-	u32 ldr = ((id &gt;&gt; 4) &lt;&lt; 16) | (1 &lt;&lt; (id &amp; 0xf));</span>
<span class="p_add">+	u32 ldr = kvm_apic_calc_x2apic_ldr(id);</span>
 
 	WARN_ON_ONCE(id != apic-&gt;vcpu-&gt;vcpu_id);
 
<span class="p_chunk">@@ -2196,6 +2201,7 @@</span> <span class="p_context"> static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,</span>
 {
 	if (apic_x2apic_mode(vcpu-&gt;arch.apic)) {
 		u32 *id = (u32 *)(s-&gt;regs + APIC_ID);
<span class="p_add">+		u32 *ldr = (u32 *)(s-&gt;regs + APIC_LDR);</span>
 
 		if (vcpu-&gt;kvm-&gt;arch.x2apic_format) {
 			if (*id != vcpu-&gt;vcpu_id)
<span class="p_chunk">@@ -2206,6 +2212,10 @@</span> <span class="p_context"> static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,</span>
 			else
 				*id &lt;&lt;= 24;
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* In x2APIC mode, the LDR is fixed and based on the id */</span>
<span class="p_add">+		if (set)</span>
<span class="p_add">+			*ldr = kvm_apic_calc_x2apic_ldr(*id);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index ca209a4a7834..17fb6c6d939a 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -2189,6 +2189,8 @@</span> <span class="p_context"> static int ud_interception(struct vcpu_svm *svm)</span>
 	int er;
 
 	er = emulate_instruction(&amp;svm-&gt;vcpu, EMULTYPE_TRAP_UD);
<span class="p_add">+	if (er == EMULATE_USER_EXIT)</span>
<span class="p_add">+		return 0;</span>
 	if (er != EMULATE_DONE)
 		kvm_queue_exception(&amp;svm-&gt;vcpu, UD_VECTOR);
 	return 1;
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 21cad7068cbf..b21113bcf227 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -5914,6 +5914,8 @@</span> <span class="p_context"> static int handle_exception(struct kvm_vcpu *vcpu)</span>
 			return 1;
 		}
 		er = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);
<span class="p_add">+		if (er == EMULATE_USER_EXIT)</span>
<span class="p_add">+			return 0;</span>
 		if (er != EMULATE_DONE)
 			kvm_queue_exception(vcpu, UD_VECTOR);
 		return 1;
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 03869eb7fcd6..4195cbcdb310 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -1830,6 +1830,9 @@</span> <span class="p_context"> static void kvm_setup_pvclock_page(struct kvm_vcpu *v)</span>
 	 */
 	BUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);
 
<span class="p_add">+	if (guest_hv_clock.version &amp; 1)</span>
<span class="p_add">+		++guest_hv_clock.version;  /* first time write, random junk */</span>
<span class="p_add">+</span>
 	vcpu-&gt;hv_clock.version = guest_hv_clock.version + 1;
 	kvm_write_guest_cached(v-&gt;kvm, &amp;vcpu-&gt;pv_time,
 				&amp;vcpu-&gt;hv_clock,
<span class="p_chunk">@@ -5705,6 +5708,8 @@</span> <span class="p_context"> int x86_emulate_instruction(struct kvm_vcpu *vcpu,</span>
 			if (reexecute_instruction(vcpu, cr2, write_fault_to_spt,
 						emulation_type))
 				return EMULATE_DONE;
<span class="p_add">+			if (ctxt-&gt;have_exception &amp;&amp; inject_emulated_exception(vcpu))</span>
<span class="p_add">+				return EMULATE_DONE;</span>
 			if (emulation_type &amp; EMULTYPE_SKIP)
 				return EMULATE_FAIL;
 			return handle_emulation_failure(vcpu);
<span class="p_header">diff --git a/crypto/af_alg.c b/crypto/af_alg.c</span>
<span class="p_header">index 337cf382718e..a72659f452a5 100644</span>
<span class="p_header">--- a/crypto/af_alg.c</span>
<span class="p_header">+++ b/crypto/af_alg.c</span>
<span class="p_chunk">@@ -1047,6 +1047,18 @@</span> <span class="p_context"> ssize_t af_alg_sendpage(struct socket *sock, struct page *page,</span>
 }
 EXPORT_SYMBOL_GPL(af_alg_sendpage);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * af_alg_free_resources - release resources required for crypto request</span>
<span class="p_add">+ */</span>
<span class="p_add">+void af_alg_free_resources(struct af_alg_async_req *areq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sock *sk = areq-&gt;sk;</span>
<span class="p_add">+</span>
<span class="p_add">+	af_alg_free_areq_sgls(areq);</span>
<span class="p_add">+	sock_kfree_s(sk, areq, areq-&gt;areqlen);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(af_alg_free_resources);</span>
<span class="p_add">+</span>
 /**
  * af_alg_async_cb - AIO callback handler
  *
<span class="p_chunk">@@ -1063,18 +1075,13 @@</span> <span class="p_context"> void af_alg_async_cb(struct crypto_async_request *_req, int err)</span>
 	struct kiocb *iocb = areq-&gt;iocb;
 	unsigned int resultlen;
 
<span class="p_del">-	lock_sock(sk);</span>
<span class="p_del">-</span>
 	/* Buffer size written by crypto operation. */
 	resultlen = areq-&gt;outlen;
 
<span class="p_del">-	af_alg_free_areq_sgls(areq);</span>
<span class="p_del">-	sock_kfree_s(sk, areq, areq-&gt;areqlen);</span>
<span class="p_del">-	__sock_put(sk);</span>
<span class="p_add">+	af_alg_free_resources(areq);</span>
<span class="p_add">+	sock_put(sk);</span>
 
 	iocb-&gt;ki_complete(iocb, err ? err : resultlen, 0);
<span class="p_del">-</span>
<span class="p_del">-	release_sock(sk);</span>
 }
 EXPORT_SYMBOL_GPL(af_alg_async_cb);
 
<span class="p_header">diff --git a/crypto/algif_aead.c b/crypto/algif_aead.c</span>
<span class="p_header">index 516b38c3a169..d0b45145cb30 100644</span>
<span class="p_header">--- a/crypto/algif_aead.c</span>
<span class="p_header">+++ b/crypto/algif_aead.c</span>
<span class="p_chunk">@@ -101,10 +101,10 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 	struct aead_tfm *aeadc = pask-&gt;private;
 	struct crypto_aead *tfm = aeadc-&gt;aead;
 	struct crypto_skcipher *null_tfm = aeadc-&gt;null_tfm;
<span class="p_del">-	unsigned int as = crypto_aead_authsize(tfm);</span>
<span class="p_add">+	unsigned int i, as = crypto_aead_authsize(tfm);</span>
 	struct af_alg_async_req *areq;
<span class="p_del">-	struct af_alg_tsgl *tsgl;</span>
<span class="p_del">-	struct scatterlist *src;</span>
<span class="p_add">+	struct af_alg_tsgl *tsgl, *tmp;</span>
<span class="p_add">+	struct scatterlist *rsgl_src, *tsgl_src = NULL;</span>
 	int err = 0;
 	size_t used = 0;		/* [in]  TX bufs to be en/decrypted */
 	size_t outlen = 0;		/* [out] RX bufs produced by kernel */
<span class="p_chunk">@@ -178,7 +178,22 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 	}
 
 	processed = used + ctx-&gt;aead_assoclen;
<span class="p_del">-	tsgl = list_first_entry(&amp;ctx-&gt;tsgl_list, struct af_alg_tsgl, list);</span>
<span class="p_add">+	list_for_each_entry_safe(tsgl, tmp, &amp;ctx-&gt;tsgl_list, list) {</span>
<span class="p_add">+		for (i = 0; i &lt; tsgl-&gt;cur; i++) {</span>
<span class="p_add">+			struct scatterlist *process_sg = tsgl-&gt;sg + i;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!(process_sg-&gt;length) || !sg_page(process_sg))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			tsgl_src = process_sg;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (tsgl_src)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (processed &amp;&amp; !tsgl_src) {</span>
<span class="p_add">+		err = -EFAULT;</span>
<span class="p_add">+		goto free;</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * Copy of AAD from source to destination
<span class="p_chunk">@@ -194,7 +209,7 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 	 */
 
 	/* Use the RX SGL as source (and destination) for crypto op. */
<span class="p_del">-	src = areq-&gt;first_rsgl.sgl.sg;</span>
<span class="p_add">+	rsgl_src = areq-&gt;first_rsgl.sgl.sg;</span>
 
 	if (ctx-&gt;enc) {
 		/*
<span class="p_chunk">@@ -207,7 +222,7 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 		 *	    v	   v
 		 * RX SGL: AAD || PT || Tag
 		 */
<span class="p_del">-		err = crypto_aead_copy_sgl(null_tfm, tsgl-&gt;sg,</span>
<span class="p_add">+		err = crypto_aead_copy_sgl(null_tfm, tsgl_src,</span>
 					   areq-&gt;first_rsgl.sgl.sg, processed);
 		if (err)
 			goto free;
<span class="p_chunk">@@ -225,7 +240,7 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 		 */
 
 		 /* Copy AAD || CT to RX SGL buffer for in-place operation. */
<span class="p_del">-		err = crypto_aead_copy_sgl(null_tfm, tsgl-&gt;sg,</span>
<span class="p_add">+		err = crypto_aead_copy_sgl(null_tfm, tsgl_src,</span>
 					   areq-&gt;first_rsgl.sgl.sg, outlen);
 		if (err)
 			goto free;
<span class="p_chunk">@@ -257,23 +272,34 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 				 areq-&gt;tsgl);
 		} else
 			/* no RX SGL present (e.g. authentication only) */
<span class="p_del">-			src = areq-&gt;tsgl;</span>
<span class="p_add">+			rsgl_src = areq-&gt;tsgl;</span>
 	}
 
 	/* Initialize the crypto operation */
<span class="p_del">-	aead_request_set_crypt(&amp;areq-&gt;cra_u.aead_req, src,</span>
<span class="p_add">+	aead_request_set_crypt(&amp;areq-&gt;cra_u.aead_req, rsgl_src,</span>
 			       areq-&gt;first_rsgl.sgl.sg, used, ctx-&gt;iv);
 	aead_request_set_ad(&amp;areq-&gt;cra_u.aead_req, ctx-&gt;aead_assoclen);
 	aead_request_set_tfm(&amp;areq-&gt;cra_u.aead_req, tfm);
 
 	if (msg-&gt;msg_iocb &amp;&amp; !is_sync_kiocb(msg-&gt;msg_iocb)) {
 		/* AIO operation */
<span class="p_add">+		sock_hold(sk);</span>
 		areq-&gt;iocb = msg-&gt;msg_iocb;
 		aead_request_set_callback(&amp;areq-&gt;cra_u.aead_req,
 					  CRYPTO_TFM_REQ_MAY_BACKLOG,
 					  af_alg_async_cb, areq);
 		err = ctx-&gt;enc ? crypto_aead_encrypt(&amp;areq-&gt;cra_u.aead_req) :
 				 crypto_aead_decrypt(&amp;areq-&gt;cra_u.aead_req);
<span class="p_add">+</span>
<span class="p_add">+		/* AIO operation in progress */</span>
<span class="p_add">+		if (err == -EINPROGRESS || err == -EBUSY) {</span>
<span class="p_add">+			/* Remember output size that will be generated. */</span>
<span class="p_add">+			areq-&gt;outlen = outlen;</span>
<span class="p_add">+</span>
<span class="p_add">+			return -EIOCBQUEUED;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		sock_put(sk);</span>
 	} else {
 		/* Synchronous operation */
 		aead_request_set_callback(&amp;areq-&gt;cra_u.aead_req,
<span class="p_chunk">@@ -285,19 +311,9 @@</span> <span class="p_context"> static int _aead_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 						 &amp;ctx-&gt;completion);
 	}
 
<span class="p_del">-	/* AIO operation in progress */</span>
<span class="p_del">-	if (err == -EINPROGRESS) {</span>
<span class="p_del">-		sock_hold(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Remember output size that will be generated. */</span>
<span class="p_del">-		areq-&gt;outlen = outlen;</span>
<span class="p_del">-</span>
<span class="p_del">-		return -EIOCBQUEUED;</span>
<span class="p_del">-	}</span>
 
 free:
<span class="p_del">-	af_alg_free_areq_sgls(areq);</span>
<span class="p_del">-	sock_kfree_s(sk, areq, areq-&gt;areqlen);</span>
<span class="p_add">+	af_alg_free_resources(areq);</span>
 
 	return err ? err : outlen;
 }
<span class="p_header">diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c</span>
<span class="p_header">index 8ae4170aaeb4..30ee2a8e8f42 100644</span>
<span class="p_header">--- a/crypto/algif_skcipher.c</span>
<span class="p_header">+++ b/crypto/algif_skcipher.c</span>
<span class="p_chunk">@@ -117,6 +117,7 @@</span> <span class="p_context"> static int _skcipher_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 
 	if (msg-&gt;msg_iocb &amp;&amp; !is_sync_kiocb(msg-&gt;msg_iocb)) {
 		/* AIO operation */
<span class="p_add">+		sock_hold(sk);</span>
 		areq-&gt;iocb = msg-&gt;msg_iocb;
 		skcipher_request_set_callback(&amp;areq-&gt;cra_u.skcipher_req,
 					      CRYPTO_TFM_REQ_MAY_SLEEP,
<span class="p_chunk">@@ -124,6 +125,16 @@</span> <span class="p_context"> static int _skcipher_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 		err = ctx-&gt;enc ?
 			crypto_skcipher_encrypt(&amp;areq-&gt;cra_u.skcipher_req) :
 			crypto_skcipher_decrypt(&amp;areq-&gt;cra_u.skcipher_req);
<span class="p_add">+</span>
<span class="p_add">+		/* AIO operation in progress */</span>
<span class="p_add">+		if (err == -EINPROGRESS || err == -EBUSY) {</span>
<span class="p_add">+			/* Remember output size that will be generated. */</span>
<span class="p_add">+			areq-&gt;outlen = len;</span>
<span class="p_add">+</span>
<span class="p_add">+			return -EIOCBQUEUED;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		sock_put(sk);</span>
 	} else {
 		/* Synchronous operation */
 		skcipher_request_set_callback(&amp;areq-&gt;cra_u.skcipher_req,
<span class="p_chunk">@@ -137,19 +148,9 @@</span> <span class="p_context"> static int _skcipher_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 						 &amp;ctx-&gt;completion);
 	}
 
<span class="p_del">-	/* AIO operation in progress */</span>
<span class="p_del">-	if (err == -EINPROGRESS) {</span>
<span class="p_del">-		sock_hold(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Remember output size that will be generated. */</span>
<span class="p_del">-		areq-&gt;outlen = len;</span>
<span class="p_del">-</span>
<span class="p_del">-		return -EIOCBQUEUED;</span>
<span class="p_del">-	}</span>
 
 free:
<span class="p_del">-	af_alg_free_areq_sgls(areq);</span>
<span class="p_del">-	sock_kfree_s(sk, areq, areq-&gt;areqlen);</span>
<span class="p_add">+	af_alg_free_resources(areq);</span>
 
 	return err ? err : len;
 }
<span class="p_header">diff --git a/crypto/skcipher.c b/crypto/skcipher.c</span>
<span class="p_header">index d5692e35fab1..778e0ff42bfa 100644</span>
<span class="p_header">--- a/crypto/skcipher.c</span>
<span class="p_header">+++ b/crypto/skcipher.c</span>
<span class="p_chunk">@@ -522,6 +522,9 @@</span> <span class="p_context"> static int skcipher_walk_aead_common(struct skcipher_walk *walk,</span>
 	scatterwalk_copychunks(NULL, &amp;walk-&gt;in, req-&gt;assoclen, 2);
 	scatterwalk_copychunks(NULL, &amp;walk-&gt;out, req-&gt;assoclen, 2);
 
<span class="p_add">+	scatterwalk_done(&amp;walk-&gt;in, 0, walk-&gt;total);</span>
<span class="p_add">+	scatterwalk_done(&amp;walk-&gt;out, 0, walk-&gt;total);</span>
<span class="p_add">+</span>
 	walk-&gt;iv = req-&gt;iv;
 	walk-&gt;oiv = req-&gt;iv;
 
<span class="p_header">diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c</span>
<span class="p_header">index 82b3ce5e937e..df842465634a 100644</span>
<span class="p_header">--- a/drivers/acpi/ec.c</span>
<span class="p_header">+++ b/drivers/acpi/ec.c</span>
<span class="p_chunk">@@ -1597,32 +1597,41 @@</span> <span class="p_context"> static int acpi_ec_add(struct acpi_device *device)</span>
 {
 	struct acpi_ec *ec = NULL;
 	int ret;
<span class="p_add">+	bool is_ecdt = false;</span>
<span class="p_add">+	acpi_status status;</span>
 
 	strcpy(acpi_device_name(device), ACPI_EC_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_EC_CLASS);
 
<span class="p_del">-	ec = acpi_ec_alloc();</span>
<span class="p_del">-	if (!ec)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	if (ec_parse_device(device-&gt;handle, 0, ec, NULL) !=</span>
<span class="p_del">-		AE_CTRL_TERMINATE) {</span>
<span class="p_add">+	if (!strcmp(acpi_device_hid(device), ACPI_ECDT_HID)) {</span>
<span class="p_add">+		is_ecdt = true;</span>
<span class="p_add">+		ec = boot_ec;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ec = acpi_ec_alloc();</span>
<span class="p_add">+		if (!ec)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		status = ec_parse_device(device-&gt;handle, 0, ec, NULL);</span>
<span class="p_add">+		if (status != AE_CTRL_TERMINATE) {</span>
 			ret = -EINVAL;
 			goto err_alloc;
<span class="p_add">+		}</span>
 	}
 
 	if (acpi_is_boot_ec(ec)) {
<span class="p_del">-		boot_ec_is_ecdt = false;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Trust PNP0C09 namespace location rather than ECDT ID.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * But trust ECDT GPE rather than _GPE because of ASUS quirks,</span>
<span class="p_del">-		 * so do not change boot_ec-&gt;gpe to ec-&gt;gpe.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		boot_ec-&gt;handle = ec-&gt;handle;</span>
<span class="p_del">-		acpi_handle_debug(ec-&gt;handle, &quot;duplicated.\n&quot;);</span>
<span class="p_del">-		acpi_ec_free(ec);</span>
<span class="p_del">-		ec = boot_ec;</span>
<span class="p_del">-		ret = acpi_config_boot_ec(ec, ec-&gt;handle, true, false);</span>
<span class="p_add">+		boot_ec_is_ecdt = is_ecdt;</span>
<span class="p_add">+		if (!is_ecdt) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Trust PNP0C09 namespace location rather than</span>
<span class="p_add">+			 * ECDT ID. But trust ECDT GPE rather than _GPE</span>
<span class="p_add">+			 * because of ASUS quirks, so do not change</span>
<span class="p_add">+			 * boot_ec-&gt;gpe to ec-&gt;gpe.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			boot_ec-&gt;handle = ec-&gt;handle;</span>
<span class="p_add">+			acpi_handle_debug(ec-&gt;handle, &quot;duplicated.\n&quot;);</span>
<span class="p_add">+			acpi_ec_free(ec);</span>
<span class="p_add">+			ec = boot_ec;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ret = acpi_config_boot_ec(ec, ec-&gt;handle, true, is_ecdt);</span>
 	} else
 		ret = acpi_ec_setup(ec, true);
 	if (ret)
<span class="p_chunk">@@ -1635,8 +1644,10 @@</span> <span class="p_context"> static int acpi_ec_add(struct acpi_device *device)</span>
 	ret = !!request_region(ec-&gt;command_addr, 1, &quot;EC cmd&quot;);
 	WARN(!ret, &quot;Could not request EC cmd io port 0x%lx&quot;, ec-&gt;command_addr);
 
<span class="p_del">-	/* Reprobe devices depending on the EC */</span>
<span class="p_del">-	acpi_walk_dep_device_list(ec-&gt;handle);</span>
<span class="p_add">+	if (!is_ecdt) {</span>
<span class="p_add">+		/* Reprobe devices depending on the EC */</span>
<span class="p_add">+		acpi_walk_dep_device_list(ec-&gt;handle);</span>
<span class="p_add">+	}</span>
 	acpi_handle_debug(ec-&gt;handle, &quot;enumerated.\n&quot;);
 	return 0;
 
<span class="p_chunk">@@ -1692,6 +1703,7 @@</span> <span class="p_context"> ec_parse_io_ports(struct acpi_resource *resource, void *context)</span>
 
 static const struct acpi_device_id ec_device_ids[] = {
 	{&quot;PNP0C09&quot;, 0},
<span class="p_add">+	{ACPI_ECDT_HID, 0},</span>
 	{&quot;&quot;, 0},
 };
 
<span class="p_chunk">@@ -1764,11 +1776,14 @@</span> <span class="p_context"> static int __init acpi_ec_ecdt_start(void)</span>
 	 * Note: ec-&gt;handle can be valid if this function is called after
 	 * acpi_ec_add(), hence the fast path.
 	 */
<span class="p_del">-	if (boot_ec-&gt;handle != ACPI_ROOT_OBJECT)</span>
<span class="p_del">-		handle = boot_ec-&gt;handle;</span>
<span class="p_del">-	else if (!acpi_ec_ecdt_get_handle(&amp;handle))</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-	return acpi_config_boot_ec(boot_ec, handle, true, true);</span>
<span class="p_add">+	if (boot_ec-&gt;handle == ACPI_ROOT_OBJECT) {</span>
<span class="p_add">+		if (!acpi_ec_ecdt_get_handle(&amp;handle))</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+		boot_ec-&gt;handle = handle;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Register to ACPI bus with PM ops attached */</span>
<span class="p_add">+	return acpi_bus_register_early_device(ACPI_BUS_TYPE_ECDT_EC);</span>
 }
 
 #if 0
<span class="p_chunk">@@ -2020,6 +2035,12 @@</span> <span class="p_context"> int __init acpi_ec_init(void)</span>
 
 	/* Drivers must be started after acpi_ec_query_init() */
 	dsdt_fail = acpi_bus_register_driver(&amp;acpi_ec_driver);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Register ECDT to ACPI bus only when PNP0C09 probe fails. This is</span>
<span class="p_add">+	 * useful for platforms (confirmed on ASUS X550ZE) with valid ECDT</span>
<span class="p_add">+	 * settings but invalid DSDT settings.</span>
<span class="p_add">+	 * https://bugzilla.kernel.org/show_bug.cgi?id=196847</span>
<span class="p_add">+	 */</span>
 	ecdt_fail = acpi_ec_ecdt_start();
 	return ecdt_fail &amp;&amp; dsdt_fail ? -ENODEV : 0;
 }
<span class="p_header">diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h</span>
<span class="p_header">index 4361c4415b4f..ede83d38beed 100644</span>
<span class="p_header">--- a/drivers/acpi/internal.h</span>
<span class="p_header">+++ b/drivers/acpi/internal.h</span>
<span class="p_chunk">@@ -115,6 +115,7 @@</span> <span class="p_context"> bool acpi_device_is_present(const struct acpi_device *adev);</span>
 bool acpi_device_is_battery(struct acpi_device *adev);
 bool acpi_device_is_first_physical_node(struct acpi_device *adev,
 					const struct device *dev);
<span class="p_add">+int acpi_bus_register_early_device(int type);</span>
 
 /* --------------------------------------------------------------------------
                      Device Matching and Notification
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index 602f8ff212f2..2f2f50322ffb 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -1024,6 +1024,9 @@</span> <span class="p_context"> static void acpi_device_get_busid(struct acpi_device *device)</span>
 	case ACPI_BUS_TYPE_SLEEP_BUTTON:
 		strcpy(device-&gt;pnp.bus_id, &quot;SLPF&quot;);
 		break;
<span class="p_add">+	case ACPI_BUS_TYPE_ECDT_EC:</span>
<span class="p_add">+		strcpy(device-&gt;pnp.bus_id, &quot;ECDT&quot;);</span>
<span class="p_add">+		break;</span>
 	default:
 		acpi_get_name(device-&gt;handle, ACPI_SINGLE_NAME, &amp;buffer);
 		/* Clean up trailing underscores (if any) */
<span class="p_chunk">@@ -1304,6 +1307,9 @@</span> <span class="p_context"> static void acpi_set_pnp_ids(acpi_handle handle, struct acpi_device_pnp *pnp,</span>
 	case ACPI_BUS_TYPE_SLEEP_BUTTON:
 		acpi_add_id(pnp, ACPI_BUTTON_HID_SLEEPF);
 		break;
<span class="p_add">+	case ACPI_BUS_TYPE_ECDT_EC:</span>
<span class="p_add">+		acpi_add_id(pnp, ACPI_ECDT_HID);</span>
<span class="p_add">+		break;</span>
 	}
 }
 
<span class="p_chunk">@@ -2049,6 +2055,21 @@</span> <span class="p_context"> void acpi_bus_trim(struct acpi_device *adev)</span>
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 
<span class="p_add">+int acpi_bus_register_early_device(int type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct acpi_device *device = NULL;</span>
<span class="p_add">+	int result;</span>
<span class="p_add">+</span>
<span class="p_add">+	result = acpi_add_single_object(&amp;device, NULL,</span>
<span class="p_add">+					type, ACPI_STA_DEFAULT);</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		return result;</span>
<span class="p_add">+</span>
<span class="p_add">+	device-&gt;flags.match_driver = true;</span>
<span class="p_add">+	return device_attach(&amp;device-&gt;dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(acpi_bus_register_early_device);</span>
<span class="p_add">+</span>
 static int acpi_bus_scan_fixed(void)
 {
 	int result = 0;
<span class="p_header">diff --git a/drivers/dax/device.c b/drivers/dax/device.c</span>
<span class="p_header">index e9f3b3e4bbf4..375b99bca002 100644</span>
<span class="p_header">--- a/drivers/dax/device.c</span>
<span class="p_header">+++ b/drivers/dax/device.c</span>
<span class="p_chunk">@@ -427,9 +427,21 @@</span> <span class="p_context"> static int dev_dax_fault(struct vm_fault *vmf)</span>
 	return dev_dax_huge_fault(vmf, PE_SIZE_PTE);
 }
 
<span class="p_add">+static int dev_dax_split(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct file *filp = vma-&gt;vm_file;</span>
<span class="p_add">+	struct dev_dax *dev_dax = filp-&gt;private_data;</span>
<span class="p_add">+	struct dax_region *dax_region = dev_dax-&gt;region;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ALIGNED(addr, dax_region-&gt;align))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct vm_operations_struct dax_vm_ops = {
 	.fault = dev_dax_fault,
 	.huge_fault = dev_dax_huge_fault,
<span class="p_add">+	.split = dev_dax_split,</span>
 };
 
 static int dax_mmap(struct file *filp, struct vm_area_struct *vma)
<span class="p_header">diff --git a/drivers/dma-buf/reservation.c b/drivers/dma-buf/reservation.c</span>
<span class="p_header">index dec3a815455d..b44d9d7db347 100644</span>
<span class="p_header">--- a/drivers/dma-buf/reservation.c</span>
<span class="p_header">+++ b/drivers/dma-buf/reservation.c</span>
<span class="p_chunk">@@ -266,8 +266,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(reservation_object_add_excl_fence);</span>
 * @dst: the destination reservation object
 * @src: the source reservation object
 *
<span class="p_del">-* Copy all fences from src to dst. Both src-&gt;lock as well as dst-lock must be</span>
<span class="p_del">-* held.</span>
<span class="p_add">+* Copy all fences from src to dst. dst-lock must be held.</span>
 */
 int reservation_object_copy_fences(struct reservation_object *dst,
 				   struct reservation_object *src)
<span class="p_chunk">@@ -277,33 +276,62 @@</span> <span class="p_context"> int reservation_object_copy_fences(struct reservation_object *dst,</span>
 	size_t size;
 	unsigned i;
 
<span class="p_del">-	src_list = reservation_object_get_list(src);</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	src_list = rcu_dereference(src-&gt;fence);</span>
 
<span class="p_add">+retry:</span>
 	if (src_list) {
<span class="p_del">-		size = offsetof(typeof(*src_list),</span>
<span class="p_del">-				shared[src_list-&gt;shared_count]);</span>
<span class="p_add">+		unsigned shared_count = src_list-&gt;shared_count;</span>
<span class="p_add">+</span>
<span class="p_add">+		size = offsetof(typeof(*src_list), shared[shared_count]);</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+</span>
 		dst_list = kmalloc(size, GFP_KERNEL);
 		if (!dst_list)
 			return -ENOMEM;
 
<span class="p_del">-		dst_list-&gt;shared_count = src_list-&gt;shared_count;</span>
<span class="p_del">-		dst_list-&gt;shared_max = src_list-&gt;shared_count;</span>
<span class="p_del">-		for (i = 0; i &lt; src_list-&gt;shared_count; ++i)</span>
<span class="p_del">-			dst_list-&gt;shared[i] =</span>
<span class="p_del">-				dma_fence_get(src_list-&gt;shared[i]);</span>
<span class="p_add">+		rcu_read_lock();</span>
<span class="p_add">+		src_list = rcu_dereference(src-&gt;fence);</span>
<span class="p_add">+		if (!src_list || src_list-&gt;shared_count &gt; shared_count) {</span>
<span class="p_add">+			kfree(dst_list);</span>
<span class="p_add">+			goto retry;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dst_list-&gt;shared_count = 0;</span>
<span class="p_add">+		dst_list-&gt;shared_max = shared_count;</span>
<span class="p_add">+		for (i = 0; i &lt; src_list-&gt;shared_count; ++i) {</span>
<span class="p_add">+			struct dma_fence *fence;</span>
<span class="p_add">+</span>
<span class="p_add">+			fence = rcu_dereference(src_list-&gt;shared[i]);</span>
<span class="p_add">+			if (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT,</span>
<span class="p_add">+				     &amp;fence-&gt;flags))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!dma_fence_get_rcu(fence)) {</span>
<span class="p_add">+				kfree(dst_list);</span>
<span class="p_add">+				src_list = rcu_dereference(src-&gt;fence);</span>
<span class="p_add">+				goto retry;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (dma_fence_is_signaled(fence)) {</span>
<span class="p_add">+				dma_fence_put(fence);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			dst_list-&gt;shared[dst_list-&gt;shared_count++] = fence;</span>
<span class="p_add">+		}</span>
 	} else {
 		dst_list = NULL;
 	}
 
<span class="p_add">+	new = dma_fence_get_rcu_safe(&amp;src-&gt;fence_excl);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
 	kfree(dst-&gt;staged);
 	dst-&gt;staged = NULL;
 
 	src_list = reservation_object_get_list(dst);
<span class="p_del">-</span>
 	old = reservation_object_get_excl(dst);
<span class="p_del">-	new = reservation_object_get_excl(src);</span>
<span class="p_del">-</span>
<span class="p_del">-	dma_fence_get(new);</span>
 
 	preempt_disable();
 	write_seqcount_begin(&amp;dst-&gt;seq);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">index 103635ab784c..87801faaf264 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_chunk">@@ -1536,18 +1536,14 @@</span> <span class="p_context"> struct amdgpu_device {</span>
 	/* sdma */
 	struct amdgpu_sdma		sdma;
 
<span class="p_del">-	union {</span>
<span class="p_del">-		struct {</span>
<span class="p_del">-			/* uvd */</span>
<span class="p_del">-			struct amdgpu_uvd		uvd;</span>
<span class="p_del">-</span>
<span class="p_del">-			/* vce */</span>
<span class="p_del">-			struct amdgpu_vce		vce;</span>
<span class="p_del">-		};</span>
<span class="p_del">-</span>
<span class="p_del">-		/* vcn */</span>
<span class="p_del">-		struct amdgpu_vcn		vcn;</span>
<span class="p_del">-	};</span>
<span class="p_add">+	/* uvd */</span>
<span class="p_add">+	struct amdgpu_uvd		uvd;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* vce */</span>
<span class="p_add">+	struct amdgpu_vce		vce;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* vcn */</span>
<span class="p_add">+	struct amdgpu_vcn		vcn;</span>
 
 	/* firmwares */
 	struct amdgpu_firmware		firmware;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">index ce443586a0c7..cc4e18dcd8b6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_chunk">@@ -1766,34 +1766,32 @@</span> <span class="p_context"> bool amdgpu_atombios_scratch_need_asic_init(struct amdgpu_device *adev)</span>
 		return true;
 }
 
<span class="p_del">-/* Atom needs data in little endian format</span>
<span class="p_del">- * so swap as appropriate when copying data to</span>
<span class="p_del">- * or from atom. Note that atom operates on</span>
<span class="p_del">- * dw units.</span>
<span class="p_add">+/* Atom needs data in little endian format so swap as appropriate when copying</span>
<span class="p_add">+ * data to or from atom. Note that atom operates on dw units.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=true when sending data to atom and provide at least</span>
<span class="p_add">+ * ALIGN(num_bytes,4) bytes in the dst buffer.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=false when receiving data from atom and provide ALIGN(num_bytes,4)</span>
<span class="p_add">+ * byes in the src buffer.</span>
  */
 void amdgpu_atombios_copy_swap(u8 *dst, u8 *src, u8 num_bytes, bool to_le)
 {
 #ifdef __BIG_ENDIAN
<span class="p_del">-	u8 src_tmp[20], dst_tmp[20]; /* used for byteswapping */</span>
<span class="p_del">-	u32 *dst32, *src32;</span>
<span class="p_add">+	u32 src_tmp[5], dst_tmp[5];</span>
 	int i;
<span class="p_add">+	u8 align_num_bytes = ALIGN(num_bytes, 4);</span>
 
<span class="p_del">-	memcpy(src_tmp, src, num_bytes);</span>
<span class="p_del">-	src32 = (u32 *)src_tmp;</span>
<span class="p_del">-	dst32 = (u32 *)dst_tmp;</span>
 	if (to_le) {
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = cpu_to_le32(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, num_bytes);</span>
<span class="p_add">+		memcpy(src_tmp, src, num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = cpu_to_le32(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, align_num_bytes);</span>
 	} else {
<span class="p_del">-		u8 dws = num_bytes &amp; ~3;</span>
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = le32_to_cpu(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, dws);</span>
<span class="p_del">-		if (num_bytes % 4) {</span>
<span class="p_del">-			for (i = 0; i &lt; (num_bytes % 4); i++)</span>
<span class="p_del">-				dst[dws+i] = dst_tmp[dws+i];</span>
<span class="p_del">-		}</span>
<span class="p_add">+		memcpy(src_tmp, src, align_num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = le32_to_cpu(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, num_bytes);</span>
 	}
 #else
 	memcpy(dst, src, num_bytes);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c</span>
<span class="p_header">index c21adf60a7f2..057e1ecd83ce 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c</span>
<span class="p_chunk">@@ -59,12 +59,6 @@</span> <span class="p_context"> static bool check_atom_bios(uint8_t *bios, size_t size)</span>
 		return false;
 	}
 
<span class="p_del">-	tmp = bios[0x18] | (bios[0x19] &lt;&lt; 8);</span>
<span class="p_del">-	if (bios[tmp + 0x14] != 0x0) {</span>
<span class="p_del">-		DRM_INFO(&quot;Not an x86 BIOS ROM\n&quot;);</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	bios_header_start = bios[0x48] | (bios[0x49] &lt;&lt; 8);
 	if (!bios_header_start) {
 		DRM_INFO(&quot;Can&#39;t locate bios header\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c</span>
<span class="p_header">index 9e495da0bb03..ffe483980362 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c</span>
<span class="p_chunk">@@ -391,6 +391,9 @@</span> <span class="p_context"> int amdgpu_bo_create_restricted(struct amdgpu_device *adev,</span>
 	r = ttm_bo_init_reserved(&amp;adev-&gt;mman.bdev, &amp;bo-&gt;tbo, size, type,
 				 &amp;bo-&gt;placement, page_align, !kernel, NULL,
 				 acc_size, sg, resv, &amp;amdgpu_ttm_bo_destroy);
<span class="p_add">+	if (unlikely(r != 0))</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+</span>
 	bytes_moved = atomic64_read(&amp;adev-&gt;num_bytes_moved) -
 		      initial_bytes_moved;
 	if (adev-&gt;mc.visible_vram_size &lt; adev-&gt;mc.real_vram_size &amp;&amp;
<span class="p_chunk">@@ -400,9 +403,6 @@</span> <span class="p_context"> int amdgpu_bo_create_restricted(struct amdgpu_device *adev,</span>
 	else
 		amdgpu_cs_report_moved_bytes(adev, bytes_moved, 0);
 
<span class="p_del">-	if (unlikely(r != 0))</span>
<span class="p_del">-		return r;</span>
<span class="p_del">-</span>
 	if (kernel)
 		bo-&gt;tbo.priority = 1;
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_header">index c855366521ab..9fc3d387eae3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_chunk">@@ -647,7 +647,7 @@</span> <span class="p_context"> int amdgpu_vce_ring_parse_cs(struct amdgpu_cs_parser *p, uint32_t ib_idx)</span>
 	uint32_t allocated = 0;
 	uint32_t tmp, handle = 0;
 	uint32_t *size = &amp;tmp;
<span class="p_del">-	int i, r, idx = 0;</span>
<span class="p_add">+	int i, r = 0, idx = 0;</span>
 
 	p-&gt;job-&gt;vm = NULL;
 	ib-&gt;gpu_addr = amdgpu_sa_bo_gpu_addr(ib-&gt;sa_bo);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c</span>
<span class="p_header">index bd20ff018512..863c6dd0123a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c</span>
<span class="p_chunk">@@ -1201,7 +1201,7 @@</span> <span class="p_context"> static void amdgpu_vm_invalidate_level(struct amdgpu_vm_pt *parent)</span>
 int amdgpu_vm_update_directories(struct amdgpu_device *adev,
 				 struct amdgpu_vm *vm)
 {
<span class="p_del">-	int r;</span>
<span class="p_add">+	int r = 0;</span>
 
 	r = amdgpu_vm_update_level(adev, vm, &amp;vm-&gt;root, 0);
 	if (r)
<span class="p_chunk">@@ -2586,7 +2586,8 @@</span> <span class="p_context"> void amdgpu_vm_fini(struct amdgpu_device *adev, struct amdgpu_vm *vm)</span>
 {
 	struct amdgpu_bo_va_mapping *mapping, *tmp;
 	bool prt_fini_needed = !!adev-&gt;gart.gart_funcs-&gt;set_prt;
<span class="p_del">-	int i;</span>
<span class="p_add">+	struct amdgpu_bo *root;</span>
<span class="p_add">+	int i, r;</span>
 
 	amd_sched_entity_fini(vm-&gt;entity.sched, &amp;vm-&gt;entity);
 
<span class="p_chunk">@@ -2609,7 +2610,15 @@</span> <span class="p_context"> void amdgpu_vm_fini(struct amdgpu_device *adev, struct amdgpu_vm *vm)</span>
 		amdgpu_vm_free_mapping(adev, vm, mapping, NULL);
 	}
 
<span class="p_del">-	amdgpu_vm_free_levels(&amp;vm-&gt;root);</span>
<span class="p_add">+	root = amdgpu_bo_ref(vm-&gt;root.bo);</span>
<span class="p_add">+	r = amdgpu_bo_reserve(root, true);</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		dev_err(adev-&gt;dev, &quot;Leaking page tables because BO reservation failed\n&quot;);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		amdgpu_vm_free_levels(&amp;vm-&gt;root);</span>
<span class="p_add">+		amdgpu_bo_unreserve(root);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	amdgpu_bo_unref(&amp;root);</span>
 	dma_fence_put(vm-&gt;last_dir_update);
 	for (i = 0; i &lt; AMDGPU_MAX_VMHUBS; i++)
 		amdgpu_vm_free_reserved_vmid(adev, vm, i);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c</span>
<span class="p_header">index d04d0b123212..6dc0f6e346e7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v9_0.c</span>
<span class="p_chunk">@@ -395,7 +395,16 @@</span> <span class="p_context"> static int gmc_v9_0_early_init(void *handle)</span>
 static int gmc_v9_0_late_init(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
<span class="p_del">-	unsigned vm_inv_eng[AMDGPU_MAX_VMHUBS] = { 3, 3 };</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The latest engine allocation on gfx9 is:</span>
<span class="p_add">+	 * Engine 0, 1: idle</span>
<span class="p_add">+	 * Engine 2, 3: firmware</span>
<span class="p_add">+	 * Engine 4~13: amdgpu ring, subject to change when ring number changes</span>
<span class="p_add">+	 * Engine 14~15: idle</span>
<span class="p_add">+	 * Engine 16: kfd tlb invalidation</span>
<span class="p_add">+	 * Engine 17: Gart flushes</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned vm_inv_eng[AMDGPU_MAX_VMHUBS] = { 4, 4 };</span>
 	unsigned i;
 
 	for(i = 0; i &lt; adev-&gt;num_rings; ++i) {
<span class="p_chunk">@@ -408,9 +417,9 @@</span> <span class="p_context"> static int gmc_v9_0_late_init(void *handle)</span>
 			 ring-&gt;funcs-&gt;vmhub);
 	}
 
<span class="p_del">-	/* Engine 17 is used for GART flushes */</span>
<span class="p_add">+	/* Engine 16 is used for KFD and 17 for GART flushes */</span>
 	for(i = 0; i &lt; AMDGPU_MAX_VMHUBS; ++i)
<span class="p_del">-		BUG_ON(vm_inv_eng[i] &gt; 17);</span>
<span class="p_add">+		BUG_ON(vm_inv_eng[i] &gt; 16);</span>
 
 	return amdgpu_irq_get(adev, &amp;adev-&gt;mc.vm_fault, 0);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/soc15.c b/drivers/gpu/drm/amd/amdgpu/soc15.c</span>
<span class="p_header">index f2c3a49f73a0..3e59c766722c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/soc15.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/soc15.c</span>
<span class="p_chunk">@@ -279,10 +279,7 @@</span> <span class="p_context"> static void soc15_init_golden_registers(struct amdgpu_device *adev)</span>
 }
 static u32 soc15_get_xclk(struct amdgpu_device *adev)
 {
<span class="p_del">-	if (adev-&gt;asic_type == CHIP_VEGA10)</span>
<span class="p_del">-		return adev-&gt;clock.spll.reference_freq/4;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return adev-&gt;clock.spll.reference_freq;</span>
<span class="p_add">+	return adev-&gt;clock.spll.reference_freq;</span>
 }
 
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/vcn_v1_0.c b/drivers/gpu/drm/amd/amdgpu/vcn_v1_0.c</span>
<span class="p_header">index 21e7b88401e1..a098712bdd2f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/vcn_v1_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/vcn_v1_0.c</span>
<span class="p_chunk">@@ -1175,7 +1175,7 @@</span> <span class="p_context"> static const struct amdgpu_irq_src_funcs vcn_v1_0_irq_funcs = {</span>
 
 static void vcn_v1_0_set_irq_funcs(struct amdgpu_device *adev)
 {
<span class="p_del">-	adev-&gt;uvd.irq.num_types = adev-&gt;vcn.num_enc_rings + 1;</span>
<span class="p_add">+	adev-&gt;vcn.irq.num_types = adev-&gt;vcn.num_enc_rings + 1;</span>
 	adev-&gt;vcn.irq.funcs = &amp;vcn_v1_0_irq_funcs;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/process_pptables_v1_0.c b/drivers/gpu/drm/amd/powerplay/hwmgr/process_pptables_v1_0.c</span>
<span class="p_header">index 84f01fd33aff..b50aa292d026 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/hwmgr/process_pptables_v1_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/process_pptables_v1_0.c</span>
<span class="p_chunk">@@ -850,9 +850,9 @@</span> <span class="p_context"> static int init_over_drive_limits(</span>
 		const ATOM_Tonga_POWERPLAYTABLE *powerplay_table)
 {
 	hwmgr-&gt;platform_descriptor.overdriveLimit.engineClock =
<span class="p_del">-		le16_to_cpu(powerplay_table-&gt;ulMaxODEngineClock);</span>
<span class="p_add">+		le32_to_cpu(powerplay_table-&gt;ulMaxODEngineClock);</span>
 	hwmgr-&gt;platform_descriptor.overdriveLimit.memoryClock =
<span class="p_del">-		le16_to_cpu(powerplay_table-&gt;ulMaxODMemoryClock);</span>
<span class="p_add">+		le32_to_cpu(powerplay_table-&gt;ulMaxODMemoryClock);</span>
 
 	hwmgr-&gt;platform_descriptor.minOverdriveVDDC = 0;
 	hwmgr-&gt;platform_descriptor.maxOverdriveVDDC = 0;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">index 6bb6337be920..fc7946eb6665 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_chunk">@@ -4809,7 +4809,8 @@</span> <span class="p_context"> void</span>
 drm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,
 				   const struct drm_display_mode *mode,
 				   enum hdmi_quantization_range rgb_quant_range,
<span class="p_del">-				   bool rgb_quant_range_selectable)</span>
<span class="p_add">+				   bool rgb_quant_range_selectable,</span>
<span class="p_add">+				   bool is_hdmi2_sink)</span>
 {
 	/*
 	 * CEA-861:
<span class="p_chunk">@@ -4833,8 +4834,15 @@</span> <span class="p_context"> drm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,</span>
 	 *  YQ-field to match the RGB Quantization Range being transmitted
 	 *  (e.g., when Limited Range RGB, set YQ=0 or when Full Range RGB,
 	 *  set YQ=1) and the Sink shall ignore the YQ-field.&quot;
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Unfortunate certain sinks (eg. VIZ Model 67/E261VA) get confused</span>
<span class="p_add">+	 * by non-zero YQ when receiving RGB. There doesn&#39;t seem to be any</span>
<span class="p_add">+	 * good way to tell which version of CEA-861 the sink supports, so</span>
<span class="p_add">+	 * we limit non-zero YQ to HDMI 2.0 sinks only as HDMI 2.0 is based</span>
<span class="p_add">+	 * on on CEA-861-F.</span>
 	 */
<span class="p_del">-	if (rgb_quant_range == HDMI_QUANTIZATION_RANGE_LIMITED)</span>
<span class="p_add">+	if (!is_hdmi2_sink ||</span>
<span class="p_add">+	    rgb_quant_range == HDMI_QUANTIZATION_RANGE_LIMITED)</span>
 		frame-&gt;ycc_quantization_range =
 			HDMI_YCC_QUANTIZATION_RANGE_LIMITED;
 	else
<span class="p_header">diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">index 1b8f013ffa65..5e93589c335c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_chunk">@@ -1809,6 +1809,10 @@</span> <span class="p_context"> static int drm_fb_helper_single_fb_probe(struct drm_fb_helper *fb_helper,</span>
 
 	if (crtc_count == 0 || sizes.fb_width == -1 || sizes.fb_height == -1) {
 		DRM_INFO(&quot;Cannot find any crtc or sizes\n&quot;);
<span class="p_add">+</span>
<span class="p_add">+		/* First time: disable all crtc&#39;s.. */</span>
<span class="p_add">+		if (!fb_helper-&gt;deferred_setup &amp;&amp; !READ_ONCE(fb_helper-&gt;dev-&gt;master))</span>
<span class="p_add">+			restore_fbdev_mode(fb_helper);</span>
 		return -EAGAIN;
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_vblank.c b/drivers/gpu/drm/drm_vblank.c</span>
<span class="p_header">index 70f2b9593edc..17e8ef9a1c11 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_vblank.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_vblank.c</span>
<span class="p_chunk">@@ -311,8 +311,8 @@</span> <span class="p_context"> u32 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc)</span>
 	u32 vblank;
 	unsigned long flags;
 
<span class="p_del">-	WARN(!dev-&gt;driver-&gt;get_vblank_timestamp,</span>
<span class="p_del">-	     &quot;This function requires support for accurate vblank timestamps.&quot;);</span>
<span class="p_add">+	WARN_ONCE(drm_debug &amp; DRM_UT_VBL &amp;&amp; !dev-&gt;driver-&gt;get_vblank_timestamp,</span>
<span class="p_add">+		  &quot;This function requires support for accurate vblank timestamps.&quot;);</span>
 
 	spin_lock_irqsave(&amp;dev-&gt;vblank_time_lock, flags);
 
<span class="p_chunk">@@ -869,7 +869,7 @@</span> <span class="p_context"> void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,</span>
 	assert_spin_locked(&amp;dev-&gt;event_lock);
 
 	e-&gt;pipe = pipe;
<span class="p_del">-	e-&gt;event.sequence = drm_vblank_count(dev, pipe);</span>
<span class="p_add">+	e-&gt;event.sequence = drm_crtc_accurate_vblank_count(crtc) + 1;</span>
 	e-&gt;event.crtc_id = crtc-&gt;base.id;
 	list_add_tail(&amp;e-&gt;base.link, &amp;dev-&gt;vblank_event_list);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c</span>
<span class="p_header">index edd7d8127d19..c54806d08dd7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c</span>
<span class="p_chunk">@@ -102,7 +102,6 @@</span> <span class="p_context"> static int fsl_dcu_attach_panel(struct fsl_dcu_drm_device *fsl_dev,</span>
 {
 	struct drm_encoder *encoder = &amp;fsl_dev-&gt;encoder;
 	struct drm_connector *connector = &amp;fsl_dev-&gt;connector.base;
<span class="p_del">-	struct drm_mode_config *mode_config = &amp;fsl_dev-&gt;drm-&gt;mode_config;</span>
 	int ret;
 
 	fsl_dev-&gt;connector.encoder = encoder;
<span class="p_chunk">@@ -122,10 +121,6 @@</span> <span class="p_context"> static int fsl_dcu_attach_panel(struct fsl_dcu_drm_device *fsl_dev,</span>
 	if (ret &lt; 0)
 		goto err_sysfs;
 
<span class="p_del">-	drm_object_property_set_value(&amp;connector-&gt;base,</span>
<span class="p_del">-				      mode_config-&gt;dpms_property,</span>
<span class="p_del">-				      DRM_MODE_DPMS_OFF);</span>
<span class="p_del">-</span>
 	ret = drm_panel_attach(panel, connector);
 	if (ret) {
 		dev_err(fsl_dev-&gt;dev, &quot;failed to attach panel\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_ade.c b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_ade.c</span>
<span class="p_header">index 9823477b1855..2269be91f3e1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_ade.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_ade.c</span>
<span class="p_chunk">@@ -534,9 +534,12 @@</span> <span class="p_context"> static void ade_crtc_atomic_begin(struct drm_crtc *crtc,</span>
 {
 	struct ade_crtc *acrtc = to_ade_crtc(crtc);
 	struct ade_hw_ctx *ctx = acrtc-&gt;ctx;
<span class="p_add">+	struct drm_display_mode *mode = &amp;crtc-&gt;state-&gt;mode;</span>
<span class="p_add">+	struct drm_display_mode *adj_mode = &amp;crtc-&gt;state-&gt;adjusted_mode;</span>
 
 	if (!ctx-&gt;power_on)
 		(void)ade_power_up(ctx);
<span class="p_add">+	ade_ldi_set_mode(acrtc, mode, adj_mode);</span>
 }
 
 static void ade_crtc_atomic_flush(struct drm_crtc *crtc,
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/gtt.c b/drivers/gpu/drm/i915/gvt/gtt.c</span>
<span class="p_header">index e6dfc3331f4b..a385838e2919 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/gtt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/gtt.c</span>
<span class="p_chunk">@@ -311,9 +311,9 @@</span> <span class="p_context"> static inline int gtt_set_entry64(void *pt,</span>
 
 #define GTT_HAW 46
 
<span class="p_del">-#define ADDR_1G_MASK (((1UL &lt;&lt; (GTT_HAW - 30 + 1)) - 1) &lt;&lt; 30)</span>
<span class="p_del">-#define ADDR_2M_MASK (((1UL &lt;&lt; (GTT_HAW - 21 + 1)) - 1) &lt;&lt; 21)</span>
<span class="p_del">-#define ADDR_4K_MASK (((1UL &lt;&lt; (GTT_HAW - 12 + 1)) - 1) &lt;&lt; 12)</span>
<span class="p_add">+#define ADDR_1G_MASK (((1UL &lt;&lt; (GTT_HAW - 30)) - 1) &lt;&lt; 30)</span>
<span class="p_add">+#define ADDR_2M_MASK (((1UL &lt;&lt; (GTT_HAW - 21)) - 1) &lt;&lt; 21)</span>
<span class="p_add">+#define ADDR_4K_MASK (((1UL &lt;&lt; (GTT_HAW - 12)) - 1) &lt;&lt; 12)</span>
 
 static unsigned long gen8_gtt_get_pfn(struct intel_gvt_gtt_entry *e)
 {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">index 9f45cfeae775..82498f8232eb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_chunk">@@ -2591,6 +2591,8 @@</span> <span class="p_context"> static int intel_runtime_resume(struct device *kdev)</span>
 		ret = vlv_resume_prepare(dev_priv, true);
 	}
 
<span class="p_add">+	intel_uncore_runtime_resume(dev_priv);</span>
<span class="p_add">+</span>
 	/*
 	 * No point of rolling back things in case of an error, as the best
 	 * we can do is to hope that things will still work (and disable RPM).
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_fbdev.c b/drivers/gpu/drm/i915/intel_fbdev.c</span>
<span class="p_header">index 262e75c00dd2..da2d309574ba 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_fbdev.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_fbdev.c</span>
<span class="p_chunk">@@ -694,10 +694,8 @@</span> <span class="p_context"> static void intel_fbdev_initial_config(void *data, async_cookie_t cookie)</span>
 
 	/* Due to peculiar init order wrt to hpd handling this is separate. */
 	if (drm_fb_helper_initial_config(&amp;ifbdev-&gt;helper,
<span class="p_del">-					 ifbdev-&gt;preferred_bpp)) {</span>
<span class="p_add">+					 ifbdev-&gt;preferred_bpp))</span>
 		intel_fbdev_unregister(to_i915(ifbdev-&gt;helper.dev));
<span class="p_del">-		intel_fbdev_fini(to_i915(ifbdev-&gt;helper.dev));</span>
<span class="p_del">-	}</span>
 }
 
 void intel_fbdev_initial_config_async(struct drm_device *dev)
<span class="p_chunk">@@ -797,7 +795,11 @@</span> <span class="p_context"> void intel_fbdev_output_poll_changed(struct drm_device *dev)</span>
 {
 	struct intel_fbdev *ifbdev = to_i915(dev)-&gt;fbdev;
 
<span class="p_del">-	if (ifbdev)</span>
<span class="p_add">+	if (!ifbdev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_fbdev_sync(ifbdev);</span>
<span class="p_add">+	if (ifbdev-&gt;vma)</span>
 		drm_fb_helper_hotplug_event(&amp;ifbdev-&gt;helper);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_hdmi.c b/drivers/gpu/drm/i915/intel_hdmi.c</span>
<span class="p_header">index e8abea7594ec..3fed1d3ecded 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_hdmi.c</span>
<span class="p_chunk">@@ -481,7 +481,8 @@</span> <span class="p_context"> static void intel_hdmi_set_avi_infoframe(struct drm_encoder *encoder,</span>
 					   crtc_state-&gt;limited_color_range ?
 					   HDMI_QUANTIZATION_RANGE_LIMITED :
 					   HDMI_QUANTIZATION_RANGE_FULL,
<span class="p_del">-					   intel_hdmi-&gt;rgb_quant_range_selectable);</span>
<span class="p_add">+					   intel_hdmi-&gt;rgb_quant_range_selectable,</span>
<span class="p_add">+					   is_hdmi2_sink);</span>
 
 	/* TODO: handle pixel repetition for YCBCR420 outputs */
 	intel_write_infoframe(encoder, crtc_state, &amp;frame);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">index eb5827110d8f..49fdf09f9919 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_chunk">@@ -438,7 +438,9 @@</span> <span class="p_context"> static bool</span>
 gmbus_is_index_read(struct i2c_msg *msgs, int i, int num)
 {
 	return (i + 1 &lt; num &amp;&amp;
<span class="p_del">-		!(msgs[i].flags &amp; I2C_M_RD) &amp;&amp; msgs[i].len &lt;= 2 &amp;&amp;</span>
<span class="p_add">+		msgs[i].addr == msgs[i + 1].addr &amp;&amp;</span>
<span class="p_add">+		!(msgs[i].flags &amp; I2C_M_RD) &amp;&amp;</span>
<span class="p_add">+		(msgs[i].len == 1 || msgs[i].len == 2) &amp;&amp;</span>
 		(msgs[i + 1].flags &amp; I2C_M_RD));
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_uncore.c b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">index 1d7b879cc68c..e9ed02518406 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_chunk">@@ -434,6 +434,12 @@</span> <span class="p_context"> void intel_uncore_resume_early(struct drm_i915_private *dev_priv)</span>
 	i915_check_and_clear_faults(dev_priv);
 }
 
<span class="p_add">+void intel_uncore_runtime_resume(struct drm_i915_private *dev_priv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	iosf_mbi_register_pmic_bus_access_notifier(</span>
<span class="p_add">+		&amp;dev_priv-&gt;uncore.pmic_bus_access_nb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void intel_uncore_sanitize(struct drm_i915_private *dev_priv)
 {
 	i915.enable_rc6 = sanitize_rc6_option(dev_priv, i915.enable_rc6);
<span class="p_chunk">@@ -1171,8 +1177,15 @@</span> <span class="p_context"> static int i915_pmic_bus_access_notifier(struct notifier_block *nb,</span>
 		 * bus, which will be busy after this notification, leading to:
 		 * &quot;render: timed out waiting for forcewake ack request.&quot;
 		 * errors.
<span class="p_add">+		 *</span>
<span class="p_add">+		 * The notifier is unregistered during intel_runtime_suspend(),</span>
<span class="p_add">+		 * so it&#39;s ok to access the HW here without holding a RPM</span>
<span class="p_add">+		 * wake reference -&gt; disable wakeref asserts for the time of</span>
<span class="p_add">+		 * the access.</span>
 		 */
<span class="p_add">+		disable_rpm_wakeref_asserts(dev_priv);</span>
 		intel_uncore_forcewake_get(dev_priv, FORCEWAKE_ALL);
<span class="p_add">+		enable_rpm_wakeref_asserts(dev_priv);</span>
 		break;
 	case MBI_PMIC_BUS_ACCESS_END:
 		intel_uncore_forcewake_put(dev_priv, FORCEWAKE_ALL);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_uncore.h b/drivers/gpu/drm/i915/intel_uncore.h</span>
<span class="p_header">index 5f90278da461..0bdc3fcc0e64 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_uncore.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_uncore.h</span>
<span class="p_chunk">@@ -121,6 +121,7 @@</span> <span class="p_context"> bool intel_uncore_arm_unclaimed_mmio_detection(struct drm_i915_private *dev_priv</span>
 void intel_uncore_fini(struct drm_i915_private *dev_priv);
 void intel_uncore_suspend(struct drm_i915_private *dev_priv);
 void intel_uncore_resume_early(struct drm_i915_private *dev_priv);
<span class="p_add">+void intel_uncore_runtime_resume(struct drm_i915_private *dev_priv);</span>
 
 u64 intel_uncore_edram_size(struct drm_i915_private *dev_priv);
 void assert_forcewakes_inactive(struct drm_i915_private *dev_priv);
<span class="p_header">diff --git a/drivers/gpu/drm/omapdrm/dss/dpi.c b/drivers/gpu/drm/omapdrm/dss/dpi.c</span>
<span class="p_header">index daf286fc8a40..ca1e3b489540 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/omapdrm/dss/dpi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/omapdrm/dss/dpi.c</span>
<span class="p_chunk">@@ -566,8 +566,8 @@</span> <span class="p_context"> static int dpi_verify_pll(struct dss_pll *pll)</span>
 }
 
 static const struct soc_device_attribute dpi_soc_devices[] = {
<span class="p_del">-	{ .family = &quot;OMAP3[456]*&quot; },</span>
<span class="p_del">-	{ .family = &quot;[AD]M37*&quot; },</span>
<span class="p_add">+	{ .machine = &quot;OMAP3[456]*&quot; },</span>
<span class="p_add">+	{ .machine = &quot;[AD]M37*&quot; },</span>
 	{ /* sentinel */ }
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/omapdrm/dss/hdmi4_core.c b/drivers/gpu/drm/omapdrm/dss/hdmi4_core.c</span>
<span class="p_header">index 365cf07daa01..c3453f3bd603 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/omapdrm/dss/hdmi4_core.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/omapdrm/dss/hdmi4_core.c</span>
<span class="p_chunk">@@ -889,25 +889,36 @@</span> <span class="p_context"> struct hdmi4_features {</span>
 	bool audio_use_mclk;
 };
 
<span class="p_del">-static const struct hdmi4_features hdmi4_es1_features = {</span>
<span class="p_add">+static const struct hdmi4_features hdmi4430_es1_features = {</span>
 	.cts_swmode = false,
 	.audio_use_mclk = false,
 };
 
<span class="p_del">-static const struct hdmi4_features hdmi4_es2_features = {</span>
<span class="p_add">+static const struct hdmi4_features hdmi4430_es2_features = {</span>
 	.cts_swmode = true,
 	.audio_use_mclk = false,
 };
 
<span class="p_del">-static const struct hdmi4_features hdmi4_es3_features = {</span>
<span class="p_add">+static const struct hdmi4_features hdmi4_features = {</span>
 	.cts_swmode = true,
 	.audio_use_mclk = true,
 };
 
 static const struct soc_device_attribute hdmi4_soc_devices[] = {
<span class="p_del">-	{ .family = &quot;OMAP4&quot;, .revision = &quot;ES1.?&quot;, .data = &amp;hdmi4_es1_features },</span>
<span class="p_del">-	{ .family = &quot;OMAP4&quot;, .revision = &quot;ES2.?&quot;, .data = &amp;hdmi4_es2_features },</span>
<span class="p_del">-	{ .family = &quot;OMAP4&quot;,			  .data = &amp;hdmi4_es3_features },</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.machine = &quot;OMAP4430&quot;,</span>
<span class="p_add">+		.revision = &quot;ES1.?&quot;,</span>
<span class="p_add">+		.data = &amp;hdmi4430_es1_features,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.machine = &quot;OMAP4430&quot;,</span>
<span class="p_add">+		.revision = &quot;ES2.?&quot;,</span>
<span class="p_add">+		.data = &amp;hdmi4430_es2_features,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.family = &quot;OMAP4&quot;,</span>
<span class="p_add">+		.data = &amp;hdmi4_features,</span>
<span class="p_add">+	},</span>
 	{ /* sentinel */ }
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_header">index 474fa759e06e..234af81fb3d0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_chunk">@@ -369,6 +369,7 @@</span> <span class="p_context"> static int panel_simple_remove(struct device *dev)</span>
 	drm_panel_remove(&amp;panel-&gt;base);
 
 	panel_simple_disable(&amp;panel-&gt;base);
<span class="p_add">+	panel_simple_unprepare(&amp;panel-&gt;base);</span>
 
 	if (panel-&gt;ddc)
 		put_device(&amp;panel-&gt;ddc-&gt;dev);
<span class="p_chunk">@@ -384,6 +385,7 @@</span> <span class="p_context"> static void panel_simple_shutdown(struct device *dev)</span>
 	struct panel_simple *panel = dev_get_drvdata(dev);
 
 	panel_simple_disable(&amp;panel-&gt;base);
<span class="p_add">+	panel_simple_unprepare(&amp;panel-&gt;base);</span>
 }
 
 static const struct drm_display_mode ampire_am_480272h3tmqw_t01h_mode = {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index 432cb46f6a34..fd7682bf335d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -45,34 +45,32 @@</span> <span class="p_context"> static char *pre_emph_names[] = {</span>
 
 /***** radeon AUX functions *****/
 
<span class="p_del">-/* Atom needs data in little endian format</span>
<span class="p_del">- * so swap as appropriate when copying data to</span>
<span class="p_del">- * or from atom. Note that atom operates on</span>
<span class="p_del">- * dw units.</span>
<span class="p_add">+/* Atom needs data in little endian format so swap as appropriate when copying</span>
<span class="p_add">+ * data to or from atom. Note that atom operates on dw units.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=true when sending data to atom and provide at least</span>
<span class="p_add">+ * ALIGN(num_bytes,4) bytes in the dst buffer.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=false when receiving data from atom and provide ALIGN(num_bytes,4)</span>
<span class="p_add">+ * byes in the src buffer.</span>
  */
 void radeon_atom_copy_swap(u8 *dst, u8 *src, u8 num_bytes, bool to_le)
 {
 #ifdef __BIG_ENDIAN
<span class="p_del">-	u8 src_tmp[20], dst_tmp[20]; /* used for byteswapping */</span>
<span class="p_del">-	u32 *dst32, *src32;</span>
<span class="p_add">+	u32 src_tmp[5], dst_tmp[5];</span>
 	int i;
<span class="p_add">+	u8 align_num_bytes = ALIGN(num_bytes, 4);</span>
 
<span class="p_del">-	memcpy(src_tmp, src, num_bytes);</span>
<span class="p_del">-	src32 = (u32 *)src_tmp;</span>
<span class="p_del">-	dst32 = (u32 *)dst_tmp;</span>
 	if (to_le) {
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = cpu_to_le32(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, num_bytes);</span>
<span class="p_add">+		memcpy(src_tmp, src, num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = cpu_to_le32(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, align_num_bytes);</span>
 	} else {
<span class="p_del">-		u8 dws = num_bytes &amp; ~3;</span>
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = le32_to_cpu(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, dws);</span>
<span class="p_del">-		if (num_bytes % 4) {</span>
<span class="p_del">-			for (i = 0; i &lt; (num_bytes % 4); i++)</span>
<span class="p_del">-				dst[dws+i] = dst_tmp[dws+i];</span>
<span class="p_del">-		}</span>
<span class="p_add">+		memcpy(src_tmp, src, align_num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = le32_to_cpu(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, num_bytes);</span>
 	}
 #else
 	memcpy(dst, src, num_bytes);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_fb.c b/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_header">index fd25361ac681..4ef967d1a9de 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_chunk">@@ -245,7 +245,6 @@</span> <span class="p_context"> static int radeonfb_create(struct drm_fb_helper *helper,</span>
 	}
 
 	info-&gt;par = rfbdev;
<span class="p_del">-	info-&gt;skip_vt_switch = true;</span>
 
 	ret = radeon_framebuffer_init(rdev-&gt;ddev, &amp;rfbdev-&gt;rfb, &amp;mode_cmd, gobj);
 	if (ret) {
<span class="p_header">diff --git a/drivers/gpu/drm/tilcdc/tilcdc_crtc.c b/drivers/gpu/drm/tilcdc/tilcdc_crtc.c</span>
<span class="p_header">index 406fe4544b83..06d6e785c920 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/tilcdc/tilcdc_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/tilcdc/tilcdc_crtc.c</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/completion.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
 #include &lt;linux/of_graph.h&gt;
<span class="p_add">+#include &lt;linux/math64.h&gt;</span>
 
 #include &quot;tilcdc_drv.h&quot;
 #include &quot;tilcdc_regs.h&quot;
<span class="p_chunk">@@ -48,6 +49,7 @@</span> <span class="p_context"> struct tilcdc_crtc {</span>
 	unsigned int lcd_fck_rate;
 
 	ktime_t last_vblank;
<span class="p_add">+	unsigned int hvtotal_us;</span>
 
 	struct drm_framebuffer *curr_fb;
 	struct drm_framebuffer *next_fb;
<span class="p_chunk">@@ -292,6 +294,12 @@</span> <span class="p_context"> static void tilcdc_crtc_set_clk(struct drm_crtc *crtc)</span>
 				LCDC_V2_CORE_CLK_EN);
 }
 
<span class="p_add">+uint tilcdc_mode_hvtotal(const struct drm_display_mode *mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (uint) div_u64(1000llu * mode-&gt;htotal * mode-&gt;vtotal,</span>
<span class="p_add">+			      mode-&gt;clock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void tilcdc_crtc_set_mode(struct drm_crtc *crtc)
 {
 	struct tilcdc_crtc *tilcdc_crtc = to_tilcdc_crtc(crtc);
<span class="p_chunk">@@ -459,6 +467,9 @@</span> <span class="p_context"> static void tilcdc_crtc_set_mode(struct drm_crtc *crtc)</span>
 	drm_framebuffer_reference(fb);
 
 	crtc-&gt;hwmode = crtc-&gt;state-&gt;adjusted_mode;
<span class="p_add">+</span>
<span class="p_add">+	tilcdc_crtc-&gt;hvtotal_us =</span>
<span class="p_add">+		tilcdc_mode_hvtotal(&amp;crtc-&gt;hwmode);</span>
 }
 
 static void tilcdc_crtc_enable(struct drm_crtc *crtc)
<span class="p_chunk">@@ -648,7 +659,7 @@</span> <span class="p_context"> int tilcdc_crtc_update_fb(struct drm_crtc *crtc,</span>
 		spin_lock_irqsave(&amp;tilcdc_crtc-&gt;irq_lock, flags);
 
 		next_vblank = ktime_add_us(tilcdc_crtc-&gt;last_vblank,
<span class="p_del">-					   1000000 / crtc-&gt;hwmode.vrefresh);</span>
<span class="p_add">+					   tilcdc_crtc-&gt;hvtotal_us);</span>
 		tdiff = ktime_to_us(ktime_sub(next_vblank, ktime_get()));
 
 		if (tdiff &lt; TILCDC_VBLANK_SAFETY_THRESHOLD_US)
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_bo.c b/drivers/gpu/drm/ttm/ttm_bo.c</span>
<span class="p_header">index 180ce6296416..c088703777e2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_bo.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_bo.c</span>
<span class="p_chunk">@@ -150,8 +150,7 @@</span> <span class="p_context"> static void ttm_bo_release_list(struct kref *list_kref)</span>
 	ttm_tt_destroy(bo-&gt;ttm);
 	atomic_dec(&amp;bo-&gt;glob-&gt;bo_count);
 	dma_fence_put(bo-&gt;moving);
<span class="p_del">-	if (bo-&gt;resv == &amp;bo-&gt;ttm_resv)</span>
<span class="p_del">-		reservation_object_fini(&amp;bo-&gt;ttm_resv);</span>
<span class="p_add">+	reservation_object_fini(&amp;bo-&gt;ttm_resv);</span>
 	mutex_destroy(&amp;bo-&gt;wu_mutex);
 	if (bo-&gt;destroy)
 		bo-&gt;destroy(bo);
<span class="p_chunk">@@ -402,14 +401,11 @@</span> <span class="p_context"> static int ttm_bo_individualize_resv(struct ttm_buffer_object *bo)</span>
 	if (bo-&gt;resv == &amp;bo-&gt;ttm_resv)
 		return 0;
 
<span class="p_del">-	reservation_object_init(&amp;bo-&gt;ttm_resv);</span>
 	BUG_ON(!reservation_object_trylock(&amp;bo-&gt;ttm_resv));
 
 	r = reservation_object_copy_fences(&amp;bo-&gt;ttm_resv, bo-&gt;resv);
<span class="p_del">-	if (r) {</span>
<span class="p_add">+	if (r)</span>
 		reservation_object_unlock(&amp;bo-&gt;ttm_resv);
<span class="p_del">-		reservation_object_fini(&amp;bo-&gt;ttm_resv);</span>
<span class="p_del">-	}</span>
 
 	return r;
 }
<span class="p_chunk">@@ -440,28 +436,30 @@</span> <span class="p_context"> static void ttm_bo_cleanup_refs_or_queue(struct ttm_buffer_object *bo)</span>
 	struct ttm_bo_global *glob = bo-&gt;glob;
 	int ret;
 
<span class="p_add">+	ret = ttm_bo_individualize_resv(bo);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		/* Last resort, if we fail to allocate memory for the</span>
<span class="p_add">+		 * fences block for the BO to become idle</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		reservation_object_wait_timeout_rcu(bo-&gt;resv, true, false,</span>
<span class="p_add">+						    30 * HZ);</span>
<span class="p_add">+		spin_lock(&amp;glob-&gt;lru_lock);</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spin_lock(&amp;glob-&gt;lru_lock);
 	ret = __ttm_bo_reserve(bo, false, true, NULL);
<span class="p_del">-</span>
 	if (!ret) {
<span class="p_del">-		if (!ttm_bo_wait(bo, false, true)) {</span>
<span class="p_add">+		if (reservation_object_test_signaled_rcu(&amp;bo-&gt;ttm_resv, true)) {</span>
 			ttm_bo_del_from_lru(bo);
 			spin_unlock(&amp;glob-&gt;lru_lock);
<span class="p_del">-			ttm_bo_cleanup_memtype_use(bo);</span>
<span class="p_add">+			if (bo-&gt;resv != &amp;bo-&gt;ttm_resv)</span>
<span class="p_add">+				reservation_object_unlock(&amp;bo-&gt;ttm_resv);</span>
 
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = ttm_bo_individualize_resv(bo);</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			/* Last resort, if we fail to allocate memory for the</span>
<span class="p_del">-			 * fences block for the BO to become idle and free it.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			spin_unlock(&amp;glob-&gt;lru_lock);</span>
<span class="p_del">-			ttm_bo_wait(bo, true, true);</span>
 			ttm_bo_cleanup_memtype_use(bo);
 			return;
 		}
<span class="p_add">+</span>
 		ttm_bo_flush_all_fences(bo);
 
 		/*
<span class="p_chunk">@@ -474,11 +472,12 @@</span> <span class="p_context"> static void ttm_bo_cleanup_refs_or_queue(struct ttm_buffer_object *bo)</span>
 			ttm_bo_add_to_lru(bo);
 		}
 
<span class="p_del">-		if (bo-&gt;resv != &amp;bo-&gt;ttm_resv)</span>
<span class="p_del">-			reservation_object_unlock(&amp;bo-&gt;ttm_resv);</span>
 		__ttm_bo_unreserve(bo);
 	}
<span class="p_add">+	if (bo-&gt;resv != &amp;bo-&gt;ttm_resv)</span>
<span class="p_add">+		reservation_object_unlock(&amp;bo-&gt;ttm_resv);</span>
 
<span class="p_add">+error:</span>
 	kref_get(&amp;bo-&gt;list_kref);
 	list_add_tail(&amp;bo-&gt;ddestroy, &amp;bdev-&gt;ddestroy);
 	spin_unlock(&amp;glob-&gt;lru_lock);
<span class="p_chunk">@@ -1203,8 +1202,8 @@</span> <span class="p_context"> int ttm_bo_init_reserved(struct ttm_bo_device *bdev,</span>
 		lockdep_assert_held(&amp;bo-&gt;resv-&gt;lock.base);
 	} else {
 		bo-&gt;resv = &amp;bo-&gt;ttm_resv;
<span class="p_del">-		reservation_object_init(&amp;bo-&gt;ttm_resv);</span>
 	}
<span class="p_add">+	reservation_object_init(&amp;bo-&gt;ttm_resv);</span>
 	atomic_inc(&amp;bo-&gt;glob-&gt;bo_count);
 	drm_vma_node_reset(&amp;bo-&gt;vma_node);
 	bo-&gt;priority = 0;
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_bo_util.c b/drivers/gpu/drm/ttm/ttm_bo_util.c</span>
<span class="p_header">index c934ad5b3903..7c2fbdbbd048 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_bo_util.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_bo_util.c</span>
<span class="p_chunk">@@ -474,6 +474,7 @@</span> <span class="p_context"> static int ttm_buffer_object_transfer(struct ttm_buffer_object *bo,</span>
 	INIT_LIST_HEAD(&amp;fbo-&gt;lru);
 	INIT_LIST_HEAD(&amp;fbo-&gt;swap);
 	INIT_LIST_HEAD(&amp;fbo-&gt;io_reserve_lru);
<span class="p_add">+	mutex_init(&amp;fbo-&gt;wu_mutex);</span>
 	fbo-&gt;moving = NULL;
 	drm_vma_node_reset(&amp;fbo-&gt;vma_node);
 	atomic_set(&amp;fbo-&gt;cpu_writers, 0);
<span class="p_header">diff --git a/drivers/gpu/drm/vc4/vc4_hdmi.c b/drivers/gpu/drm/vc4/vc4_hdmi.c</span>
<span class="p_header">index 937da8dd65b8..8f71157a2b06 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vc4/vc4_hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vc4/vc4_hdmi.c</span>
<span class="p_chunk">@@ -433,7 +433,8 @@</span> <span class="p_context"> static void vc4_hdmi_set_avi_infoframe(struct drm_encoder *encoder)</span>
 					   vc4_encoder-&gt;limited_rgb_range ?
 					   HDMI_QUANTIZATION_RANGE_LIMITED :
 					   HDMI_QUANTIZATION_RANGE_FULL,
<span class="p_del">-					   vc4_encoder-&gt;rgb_range_selectable);</span>
<span class="p_add">+					   vc4_encoder-&gt;rgb_range_selectable,</span>
<span class="p_add">+					   false);</span>
 
 	vc4_hdmi_write_infoframe(encoder, &amp;frame);
 }
<span class="p_header">diff --git a/drivers/hwmon/jc42.c b/drivers/hwmon/jc42.c</span>
<span class="p_header">index 5f11dc014ed6..e5234f953a6d 100644</span>
<span class="p_header">--- a/drivers/hwmon/jc42.c</span>
<span class="p_header">+++ b/drivers/hwmon/jc42.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
<span class="p_add">+#include &lt;linux/bitops.h&gt;</span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_chunk">@@ -45,6 +46,7 @@</span> <span class="p_context"> static const unsigned short normal_i2c[] = {</span>
 #define JC42_REG_TEMP		0x05
 #define JC42_REG_MANID		0x06
 #define JC42_REG_DEVICEID	0x07
<span class="p_add">+#define JC42_REG_SMBUS		0x22 /* NXP and Atmel, possibly others? */</span>
 
 /* Status bits in temperature register */
 #define JC42_ALARM_CRIT_BIT	15
<span class="p_chunk">@@ -75,6 +77,9 @@</span> <span class="p_context"> static const unsigned short normal_i2c[] = {</span>
 #define GT_MANID		0x1c68	/* Giantec */
 #define GT_MANID2		0x132d	/* Giantec, 2nd mfg ID */
 
<span class="p_add">+/* SMBUS register */</span>
<span class="p_add">+#define SMBUS_STMOUT		BIT(7)  /* SMBus time-out, active low */</span>
<span class="p_add">+</span>
 /* Supported chips */
 
 /* Analog Devices */
<span class="p_chunk">@@ -495,6 +500,22 @@</span> <span class="p_context"> static int jc42_probe(struct i2c_client *client, const struct i2c_device_id *id)</span>
 
 	data-&gt;extended = !!(cap &amp; JC42_CAP_RANGE);
 
<span class="p_add">+	if (device_property_read_bool(dev, &quot;smbus-timeout-disable&quot;)) {</span>
<span class="p_add">+		int smbus;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Not all chips support this register, but from a</span>
<span class="p_add">+		 * quick read of various datasheets no chip appears</span>
<span class="p_add">+		 * incompatible with the below attempt to disable</span>
<span class="p_add">+		 * the timeout. And the whole thing is opt-in...</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smbus = i2c_smbus_read_word_swapped(client, JC42_REG_SMBUS);</span>
<span class="p_add">+		if (smbus &lt; 0)</span>
<span class="p_add">+			return smbus;</span>
<span class="p_add">+		i2c_smbus_write_word_swapped(client, JC42_REG_SMBUS,</span>
<span class="p_add">+					     smbus | SMBUS_STMOUT);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	config = i2c_smbus_read_word_swapped(client, JC42_REG_CONFIG);
 	if (config &lt; 0)
 		return config;
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-i801.c b/drivers/i2c/busses/i2c-i801.c</span>
<span class="p_header">index 9e12a53ef7b8..8eac00efadc1 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-i801.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-i801.c</span>
<span class="p_chunk">@@ -1617,6 +1617,9 @@</span> <span class="p_context"> static int i801_probe(struct pci_dev *dev, const struct pci_device_id *id)</span>
 	/* Default timeout in interrupt mode: 200 ms */
 	priv-&gt;adapter.timeout = HZ / 5;
 
<span class="p_add">+	if (dev-&gt;irq == IRQ_NOTCONNECTED)</span>
<span class="p_add">+		priv-&gt;features &amp;= ~FEATURE_IRQ;</span>
<span class="p_add">+</span>
 	if (priv-&gt;features &amp; FEATURE_IRQ) {
 		u16 pcictl, pcists;
 
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index 21e60b1e2ff4..130606c3b07c 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	sg_list_start = umem-&gt;sg_head.sgl;
 
 	while (npages) {
<span class="p_del">-		ret = get_user_pages(cur_base,</span>
<span class="p_add">+		ret = get_user_pages_longterm(cur_base,</span>
 				     min_t(unsigned long, npages,
 					   PAGE_SIZE / sizeof (struct page *)),
 				     gup_flags, page_list, vma_list);
<span class="p_header">diff --git a/drivers/infiniband/core/user_mad.c b/drivers/infiniband/core/user_mad.c</span>
<span class="p_header">index c1696e6084b2..603acaf91828 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/user_mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/user_mad.c</span>
<span class="p_chunk">@@ -229,7 +229,16 @@</span> <span class="p_context"> static void recv_handler(struct ib_mad_agent *agent,</span>
 	packet-&gt;mad.hdr.status	   = 0;
 	packet-&gt;mad.hdr.length	   = hdr_size(file) + mad_recv_wc-&gt;mad_len;
 	packet-&gt;mad.hdr.qpn	   = cpu_to_be32(mad_recv_wc-&gt;wc-&gt;src_qp);
<span class="p_del">-	packet-&gt;mad.hdr.lid	   = ib_lid_be16(mad_recv_wc-&gt;wc-&gt;slid);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On OPA devices it is okay to lose the upper 16 bits of LID as this</span>
<span class="p_add">+	 * information is obtained elsewhere. Mask off the upper 16 bits.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (agent-&gt;device-&gt;port_immutable[agent-&gt;port_num].core_cap_flags &amp;</span>
<span class="p_add">+	    RDMA_CORE_PORT_INTEL_OPA)</span>
<span class="p_add">+		packet-&gt;mad.hdr.lid = ib_lid_be16(0xFFFF &amp;</span>
<span class="p_add">+						  mad_recv_wc-&gt;wc-&gt;slid);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		packet-&gt;mad.hdr.lid = ib_lid_be16(mad_recv_wc-&gt;wc-&gt;slid);</span>
 	packet-&gt;mad.hdr.sl	   = mad_recv_wc-&gt;wc-&gt;sl;
 	packet-&gt;mad.hdr.path_bits  = mad_recv_wc-&gt;wc-&gt;dlid_path_bits;
 	packet-&gt;mad.hdr.pkey_index = mad_recv_wc-&gt;wc-&gt;pkey_index;
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/mad.c b/drivers/infiniband/hw/hfi1/mad.c</span>
<span class="p_header">index f4c0ffc040cc..07b80faf1675 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/mad.c</span>
<span class="p_chunk">@@ -4293,7 +4293,6 @@</span> <span class="p_context"> static int opa_local_smp_check(struct hfi1_ibport *ibp,</span>
 			       const struct ib_wc *in_wc)
 {
 	struct hfi1_pportdata *ppd = ppd_from_ibp(ibp);
<span class="p_del">-	u16 slid = ib_lid_cpu16(in_wc-&gt;slid);</span>
 	u16 pkey;
 
 	if (in_wc-&gt;pkey_index &gt;= ARRAY_SIZE(ppd-&gt;pkeys))
<span class="p_chunk">@@ -4320,7 +4319,11 @@</span> <span class="p_context"> static int opa_local_smp_check(struct hfi1_ibport *ibp,</span>
 	 */
 	if (pkey == LIM_MGMT_P_KEY || pkey == FULL_MGMT_P_KEY)
 		return 0;
<span class="p_del">-	ingress_pkey_table_fail(ppd, pkey, slid);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On OPA devices it is okay to lose the upper 16 bits of LID as this</span>
<span class="p_add">+	 * information is obtained elsewhere. Mask off the upper 16 bits.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ingress_pkey_table_fail(ppd, pkey, ib_lid_cpu16(0xFFFF &amp; in_wc-&gt;slid));</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/drivers/md/bcache/alloc.c b/drivers/md/bcache/alloc.c</span>
<span class="p_header">index c9934139d609..934b1fce4ce1 100644</span>
<span class="p_header">--- a/drivers/md/bcache/alloc.c</span>
<span class="p_header">+++ b/drivers/md/bcache/alloc.c</span>
<span class="p_chunk">@@ -480,7 +480,7 @@</span> <span class="p_context"> int __bch_bucket_alloc_set(struct cache_set *c, unsigned reserve,</span>
 		if (b == -1)
 			goto err;
 
<span class="p_del">-		k-&gt;ptr[i] = PTR(ca-&gt;buckets[b].gen,</span>
<span class="p_add">+		k-&gt;ptr[i] = MAKE_PTR(ca-&gt;buckets[b].gen,</span>
 				bucket_to_sector(c, b),
 				ca-&gt;sb.nr_this_dev);
 
<span class="p_header">diff --git a/drivers/md/bcache/extents.c b/drivers/md/bcache/extents.c</span>
<span class="p_header">index 41c238fc3733..f9d391711595 100644</span>
<span class="p_header">--- a/drivers/md/bcache/extents.c</span>
<span class="p_header">+++ b/drivers/md/bcache/extents.c</span>
<span class="p_chunk">@@ -585,7 +585,7 @@</span> <span class="p_context"> static bool bch_extent_merge(struct btree_keys *bk, struct bkey *l, struct bkey</span>
 		return false;
 
 	for (i = 0; i &lt; KEY_PTRS(l); i++)
<span class="p_del">-		if (l-&gt;ptr[i] + PTR(0, KEY_SIZE(l), 0) != r-&gt;ptr[i] ||</span>
<span class="p_add">+		if (l-&gt;ptr[i] + MAKE_PTR(0, KEY_SIZE(l), 0) != r-&gt;ptr[i] ||</span>
 		    PTR_BUCKET_NR(b-&gt;c, l, i) != PTR_BUCKET_NR(b-&gt;c, r, i))
 			return false;
 
<span class="p_header">diff --git a/drivers/md/bcache/journal.c b/drivers/md/bcache/journal.c</span>
<span class="p_header">index 02a98ddb592d..03cc0722ae48 100644</span>
<span class="p_header">--- a/drivers/md/bcache/journal.c</span>
<span class="p_header">+++ b/drivers/md/bcache/journal.c</span>
<span class="p_chunk">@@ -507,7 +507,7 @@</span> <span class="p_context"> static void journal_reclaim(struct cache_set *c)</span>
 			continue;
 
 		ja-&gt;cur_idx = next;
<span class="p_del">-		k-&gt;ptr[n++] = PTR(0,</span>
<span class="p_add">+		k-&gt;ptr[n++] = MAKE_PTR(0,</span>
 				  bucket_to_sector(c, ca-&gt;sb.d[ja-&gt;cur_idx]),
 				  ca-&gt;sb.nr_this_dev);
 	}
<span class="p_header">diff --git a/drivers/md/bcache/request.c b/drivers/md/bcache/request.c</span>
<span class="p_header">index 3475d6628e21..14d13cab5cda 100644</span>
<span class="p_header">--- a/drivers/md/bcache/request.c</span>
<span class="p_header">+++ b/drivers/md/bcache/request.c</span>
<span class="p_chunk">@@ -699,7 +699,14 @@</span> <span class="p_context"> static void cached_dev_read_error(struct closure *cl)</span>
 	struct search *s = container_of(cl, struct search, cl);
 	struct bio *bio = &amp;s-&gt;bio.bio;
 
<span class="p_del">-	if (s-&gt;recoverable) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If read request hit dirty data (s-&gt;read_dirty_data is true),</span>
<span class="p_add">+	 * then recovery a failed read request from cached device may</span>
<span class="p_add">+	 * get a stale data back. So read failure recovery is only</span>
<span class="p_add">+	 * permitted when read request hit clean data in cache device,</span>
<span class="p_add">+	 * or when cache read race happened.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (s-&gt;recoverable &amp;&amp; !s-&gt;read_dirty_data) {</span>
 		/* Retry from the backing device: */
 		trace_bcache_read_retry(s-&gt;orig_bio);
 
<span class="p_header">diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c</span>
<span class="p_header">index cae57b5be817..f425905c97fa 100644</span>
<span class="p_header">--- a/drivers/md/bitmap.c</span>
<span class="p_header">+++ b/drivers/md/bitmap.c</span>
<span class="p_chunk">@@ -1816,6 +1816,12 @@</span> <span class="p_context"> struct bitmap *bitmap_create(struct mddev *mddev, int slot)</span>
 
 	BUG_ON(file &amp;&amp; mddev-&gt;bitmap_info.offset);
 
<span class="p_add">+	if (test_bit(MD_HAS_JOURNAL, &amp;mddev-&gt;flags)) {</span>
<span class="p_add">+		pr_notice(&quot;md/raid:%s: array with journal cannot have bitmap\n&quot;,</span>
<span class="p_add">+			  mdname(mddev));</span>
<span class="p_add">+		return ERR_PTR(-EBUSY);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	bitmap = kzalloc(sizeof(*bitmap), GFP_KERNEL);
 	if (!bitmap)
 		return ERR_PTR(-ENOMEM);
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index e019cf8c0d13..98ea86309ceb 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -6362,7 +6362,7 @@</span> <span class="p_context"> static int add_new_disk(struct mddev *mddev, mdu_disk_info_t *info)</span>
 					break;
 				}
 			}
<span class="p_del">-			if (has_journal) {</span>
<span class="p_add">+			if (has_journal || mddev-&gt;bitmap) {</span>
 				export_rdev(rdev);
 				return -EBUSY;
 			}
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 928e24a07133..7aed69a4f655 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -7156,6 +7156,13 @@</span> <span class="p_context"> static int raid5_run(struct mddev *mddev)</span>
 			min_offset_diff = diff;
 	}
 
<span class="p_add">+	if ((test_bit(MD_HAS_JOURNAL, &amp;mddev-&gt;flags) || journal_dev) &amp;&amp;</span>
<span class="p_add">+	    (mddev-&gt;bitmap_info.offset || mddev-&gt;bitmap_info.file)) {</span>
<span class="p_add">+		pr_notice(&quot;md/raid:%s: array cannot have both journal and bitmap\n&quot;,</span>
<span class="p_add">+			  mdname(mddev));</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (mddev-&gt;reshape_position != MaxSector) {
 		/* Check that we can continue the reshape.
 		 * Difficulties arise if the stripe we would write to
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf-dma-sg.c b/drivers/media/v4l2-core/videobuf-dma-sg.c</span>
<span class="p_header">index 0b5c43f7e020..f412429cf5ba 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf-dma-sg.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf-dma-sg.c</span>
<span class="p_chunk">@@ -185,12 +185,13 @@</span> <span class="p_context"> static int videobuf_dma_init_user_locked(struct videobuf_dmabuf *dma,</span>
 	dprintk(1, &quot;init user [0x%lx+0x%lx =&gt; %d pages]\n&quot;,
 		data, size, dma-&gt;nr_pages);
 
<span class="p_del">-	err = get_user_pages(data &amp; PAGE_MASK, dma-&gt;nr_pages,</span>
<span class="p_add">+	err = get_user_pages_longterm(data &amp; PAGE_MASK, dma-&gt;nr_pages,</span>
 			     flags, dma-&gt;pages, NULL);
 
 	if (err != dma-&gt;nr_pages) {
 		dma-&gt;nr_pages = (err &gt;= 0) ? err : 0;
<span class="p_del">-		dprintk(1, &quot;get_user_pages: err=%d [%d]\n&quot;, err, dma-&gt;nr_pages);</span>
<span class="p_add">+		dprintk(1, &quot;get_user_pages_longterm: err=%d [%d]\n&quot;, err,</span>
<span class="p_add">+			dma-&gt;nr_pages);</span>
 		return err &lt; 0 ? err : -EINVAL;
 	}
 	return 0;
<span class="p_header">diff --git a/drivers/misc/cxl/pci.c b/drivers/misc/cxl/pci.c</span>
<span class="p_header">index 3ba04f371380..81093f8157a9 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/pci.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/pci.c</span>
<span class="p_chunk">@@ -2043,6 +2043,9 @@</span> <span class="p_context"> static pci_ers_result_t cxl_vphb_error_detected(struct cxl_afu *afu,</span>
 	/* There should only be one entry, but go through the list
 	 * anyway
 	 */
<span class="p_add">+	if (afu-&gt;phb == NULL)</span>
<span class="p_add">+		return result;</span>
<span class="p_add">+</span>
 	list_for_each_entry(afu_dev, &amp;afu-&gt;phb-&gt;bus-&gt;devices, bus_list) {
 		if (!afu_dev-&gt;driver)
 			continue;
<span class="p_chunk">@@ -2084,8 +2087,7 @@</span> <span class="p_context"> static pci_ers_result_t cxl_pci_error_detected(struct pci_dev *pdev,</span>
 			 * Tell the AFU drivers; but we don&#39;t care what they
 			 * say, we&#39;re going away.
 			 */
<span class="p_del">-			if (afu-&gt;phb != NULL)</span>
<span class="p_del">-				cxl_vphb_error_detected(afu, state);</span>
<span class="p_add">+			cxl_vphb_error_detected(afu, state);</span>
 		}
 		return PCI_ERS_RESULT_DISCONNECT;
 	}
<span class="p_chunk">@@ -2225,6 +2227,9 @@</span> <span class="p_context"> static pci_ers_result_t cxl_pci_slot_reset(struct pci_dev *pdev)</span>
 		if (cxl_afu_select_best_mode(afu))
 			goto err;
 
<span class="p_add">+		if (afu-&gt;phb == NULL)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		list_for_each_entry(afu_dev, &amp;afu-&gt;phb-&gt;bus-&gt;devices, bus_list) {
 			/* Reset the device context.
 			 * TODO: make this less disruptive
<span class="p_chunk">@@ -2287,6 +2292,9 @@</span> <span class="p_context"> static void cxl_pci_resume(struct pci_dev *pdev)</span>
 	for (i = 0; i &lt; adapter-&gt;slices; i++) {
 		afu = adapter-&gt;afu[i];
 
<span class="p_add">+		if (afu-&gt;phb == NULL)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		list_for_each_entry(afu_dev, &amp;afu-&gt;phb-&gt;bus-&gt;devices, bus_list) {
 			if (afu_dev-&gt;driver &amp;&amp; afu_dev-&gt;driver-&gt;err_handler &amp;&amp;
 			    afu_dev-&gt;driver-&gt;err_handler-&gt;resume)
<span class="p_header">diff --git a/drivers/misc/eeprom/at24.c b/drivers/misc/eeprom/at24.c</span>
<span class="p_header">index 764ff5df0dbc..372b2060fbba 100644</span>
<span class="p_header">--- a/drivers/misc/eeprom/at24.c</span>
<span class="p_header">+++ b/drivers/misc/eeprom/at24.c</span>
<span class="p_chunk">@@ -365,7 +365,8 @@</span> <span class="p_context"> static ssize_t at24_eeprom_read_mac(struct at24_data *at24, char *buf,</span>
 	memset(msg, 0, sizeof(msg));
 	msg[0].addr = client-&gt;addr;
 	msg[0].buf = addrbuf;
<span class="p_del">-	addrbuf[0] = 0x90 + offset;</span>
<span class="p_add">+	/* EUI-48 starts from 0x9a, EUI-64 from 0x98 */</span>
<span class="p_add">+	addrbuf[0] = 0xa0 - at24-&gt;chip.byte_len + offset;</span>
 	msg[0].len = 1;
 	msg[1].addr = client-&gt;addr;
 	msg[1].flags = I2C_M_RD;
<span class="p_chunk">@@ -506,6 +507,9 @@</span> <span class="p_context"> static int at24_read(void *priv, unsigned int off, void *val, size_t count)</span>
 	if (unlikely(!count))
 		return count;
 
<span class="p_add">+	if (off + count &gt; at24-&gt;chip.byte_len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/*
 	 * Read data from chip, protecting against concurrent updates
 	 * from this host, but not from other I2C masters.
<span class="p_chunk">@@ -538,6 +542,9 @@</span> <span class="p_context"> static int at24_write(void *priv, unsigned int off, void *val, size_t count)</span>
 	if (unlikely(!count))
 		return -EINVAL;
 
<span class="p_add">+	if (off + count &gt; at24-&gt;chip.byte_len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/*
 	 * Write data to chip, protecting against concurrent updates
 	 * from this host, but not from other I2C masters.
<span class="p_chunk">@@ -631,6 +638,16 @@</span> <span class="p_context"> static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)</span>
 		dev_warn(&amp;client-&gt;dev,
 			&quot;page_size looks suspicious (no power of 2)!\n&quot;);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * REVISIT: the size of the EUI-48 byte array is 6 in at24mac402, while</span>
<span class="p_add">+	 * the call to ilog2() in AT24_DEVICE_MAGIC() rounds it down to 4.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Eventually we&#39;ll get rid of the magic values altoghether in favor of</span>
<span class="p_add">+	 * real structs, but for now just manually set the right size.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (chip.flags &amp; AT24_FLAG_MAC &amp;&amp; chip.byte_len == 4)</span>
<span class="p_add">+		chip.byte_len = 6;</span>
<span class="p_add">+</span>
 	/* Use I2C operations unless we&#39;re stuck with SMBus extensions. */
 	if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C)) {
 		if (chip.flags &amp; AT24_FLAG_ADDR16)
<span class="p_header">diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span>
<span class="p_header">index 2ad7b5c69156..ccb516f18d72 100644</span>
<span class="p_header">--- a/drivers/mmc/core/block.c</span>
<span class="p_header">+++ b/drivers/mmc/core/block.c</span>
<span class="p_chunk">@@ -119,6 +119,10 @@</span> <span class="p_context"> struct mmc_blk_data {</span>
 	struct device_attribute force_ro;
 	struct device_attribute power_ro_lock;
 	int	area_type;
<span class="p_add">+</span>
<span class="p_add">+	/* debugfs files (only in main mmc_blk_data) */</span>
<span class="p_add">+	struct dentry *status_dentry;</span>
<span class="p_add">+	struct dentry *ext_csd_dentry;</span>
 };
 
 static DEFINE_MUTEX(open_lock);
<span class="p_chunk">@@ -204,9 +208,14 @@</span> <span class="p_context"> static ssize_t power_ro_lock_store(struct device *dev,</span>
 
 	/* Dispatch locking to the block layer */
 	req = blk_get_request(mq-&gt;queue, REQ_OP_DRV_OUT, __GFP_RECLAIM);
<span class="p_add">+	if (IS_ERR(req)) {</span>
<span class="p_add">+		count = PTR_ERR(req);</span>
<span class="p_add">+		goto out_put;</span>
<span class="p_add">+	}</span>
 	req_to_mmc_queue_req(req)-&gt;drv_op = MMC_DRV_OP_BOOT_WP;
 	blk_execute_rq(mq-&gt;queue, NULL, req, 0);
 	ret = req_to_mmc_queue_req(req)-&gt;drv_op_result;
<span class="p_add">+	blk_put_request(req);</span>
 
 	if (!ret) {
 		pr_info(&quot;%s: Locking boot partition ro until next power on\n&quot;,
<span class="p_chunk">@@ -219,7 +228,7 @@</span> <span class="p_context"> static ssize_t power_ro_lock_store(struct device *dev,</span>
 				set_disk_ro(part_md-&gt;disk, 1);
 			}
 	}
<span class="p_del">-</span>
<span class="p_add">+out_put:</span>
 	mmc_blk_put(md);
 	return count;
 }
<span class="p_chunk">@@ -580,6 +589,10 @@</span> <span class="p_context"> static int mmc_blk_ioctl_cmd(struct mmc_blk_data *md,</span>
 	req = blk_get_request(mq-&gt;queue,
 		idata-&gt;ic.write_flag ? REQ_OP_DRV_OUT : REQ_OP_DRV_IN,
 		__GFP_RECLAIM);
<span class="p_add">+	if (IS_ERR(req)) {</span>
<span class="p_add">+		err = PTR_ERR(req);</span>
<span class="p_add">+		goto cmd_done;</span>
<span class="p_add">+	}</span>
 	idatas[0] = idata;
 	req_to_mmc_queue_req(req)-&gt;drv_op = MMC_DRV_OP_IOCTL;
 	req_to_mmc_queue_req(req)-&gt;drv_op_data = idatas;
<span class="p_chunk">@@ -643,6 +656,10 @@</span> <span class="p_context"> static int mmc_blk_ioctl_multi_cmd(struct mmc_blk_data *md,</span>
 	req = blk_get_request(mq-&gt;queue,
 		idata[0]-&gt;ic.write_flag ? REQ_OP_DRV_OUT : REQ_OP_DRV_IN,
 		__GFP_RECLAIM);
<span class="p_add">+	if (IS_ERR(req)) {</span>
<span class="p_add">+		err = PTR_ERR(req);</span>
<span class="p_add">+		goto cmd_err;</span>
<span class="p_add">+	}</span>
 	req_to_mmc_queue_req(req)-&gt;drv_op = MMC_DRV_OP_IOCTL;
 	req_to_mmc_queue_req(req)-&gt;drv_op_data = idata;
 	req_to_mmc_queue_req(req)-&gt;ioc_count = num_of_cmds;
<span class="p_chunk">@@ -2314,6 +2331,8 @@</span> <span class="p_context"> static int mmc_dbg_card_status_get(void *data, u64 *val)</span>
 
 	/* Ask the block layer about the card status */
 	req = blk_get_request(mq-&gt;queue, REQ_OP_DRV_IN, __GFP_RECLAIM);
<span class="p_add">+	if (IS_ERR(req))</span>
<span class="p_add">+		return PTR_ERR(req);</span>
 	req_to_mmc_queue_req(req)-&gt;drv_op = MMC_DRV_OP_GET_CARD_STATUS;
 	blk_execute_rq(mq-&gt;queue, NULL, req, 0);
 	ret = req_to_mmc_queue_req(req)-&gt;drv_op_result;
<span class="p_chunk">@@ -2321,6 +2340,7 @@</span> <span class="p_context"> static int mmc_dbg_card_status_get(void *data, u64 *val)</span>
 		*val = ret;
 		ret = 0;
 	}
<span class="p_add">+	blk_put_request(req);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -2347,10 +2367,15 @@</span> <span class="p_context"> static int mmc_ext_csd_open(struct inode *inode, struct file *filp)</span>
 
 	/* Ask the block layer for the EXT CSD */
 	req = blk_get_request(mq-&gt;queue, REQ_OP_DRV_IN, __GFP_RECLAIM);
<span class="p_add">+	if (IS_ERR(req)) {</span>
<span class="p_add">+		err = PTR_ERR(req);</span>
<span class="p_add">+		goto out_free;</span>
<span class="p_add">+	}</span>
 	req_to_mmc_queue_req(req)-&gt;drv_op = MMC_DRV_OP_GET_EXT_CSD;
 	req_to_mmc_queue_req(req)-&gt;drv_op_data = &amp;ext_csd;
 	blk_execute_rq(mq-&gt;queue, NULL, req, 0);
 	err = req_to_mmc_queue_req(req)-&gt;drv_op_result;
<span class="p_add">+	blk_put_request(req);</span>
 	if (err) {
 		pr_err(&quot;FAILED %d\n&quot;, err);
 		goto out_free;
<span class="p_chunk">@@ -2396,7 +2421,7 @@</span> <span class="p_context"> static const struct file_operations mmc_dbg_ext_csd_fops = {</span>
 	.llseek		= default_llseek,
 };
 
<span class="p_del">-static int mmc_blk_add_debugfs(struct mmc_card *card)</span>
<span class="p_add">+static int mmc_blk_add_debugfs(struct mmc_card *card, struct mmc_blk_data *md)</span>
 {
 	struct dentry *root;
 
<span class="p_chunk">@@ -2406,28 +2431,53 @@</span> <span class="p_context"> static int mmc_blk_add_debugfs(struct mmc_card *card)</span>
 	root = card-&gt;debugfs_root;
 
 	if (mmc_card_mmc(card) || mmc_card_sd(card)) {
<span class="p_del">-		if (!debugfs_create_file(&quot;status&quot;, S_IRUSR, root, card,</span>
<span class="p_del">-					 &amp;mmc_dbg_card_status_fops))</span>
<span class="p_add">+		md-&gt;status_dentry =</span>
<span class="p_add">+			debugfs_create_file(&quot;status&quot;, S_IRUSR, root, card,</span>
<span class="p_add">+					    &amp;mmc_dbg_card_status_fops);</span>
<span class="p_add">+		if (!md-&gt;status_dentry)</span>
 			return -EIO;
 	}
 
 	if (mmc_card_mmc(card)) {
<span class="p_del">-		if (!debugfs_create_file(&quot;ext_csd&quot;, S_IRUSR, root, card,</span>
<span class="p_del">-					 &amp;mmc_dbg_ext_csd_fops))</span>
<span class="p_add">+		md-&gt;ext_csd_dentry =</span>
<span class="p_add">+			debugfs_create_file(&quot;ext_csd&quot;, S_IRUSR, root, card,</span>
<span class="p_add">+					    &amp;mmc_dbg_ext_csd_fops);</span>
<span class="p_add">+		if (!md-&gt;ext_csd_dentry)</span>
 			return -EIO;
 	}
 
 	return 0;
 }
 
<span class="p_add">+static void mmc_blk_remove_debugfs(struct mmc_card *card,</span>
<span class="p_add">+				   struct mmc_blk_data *md)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!card-&gt;debugfs_root)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ERR_OR_NULL(md-&gt;status_dentry)) {</span>
<span class="p_add">+		debugfs_remove(md-&gt;status_dentry);</span>
<span class="p_add">+		md-&gt;status_dentry = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ERR_OR_NULL(md-&gt;ext_csd_dentry)) {</span>
<span class="p_add">+		debugfs_remove(md-&gt;ext_csd_dentry);</span>
<span class="p_add">+		md-&gt;ext_csd_dentry = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 
 #else
 
<span class="p_del">-static int mmc_blk_add_debugfs(struct mmc_card *card)</span>
<span class="p_add">+static int mmc_blk_add_debugfs(struct mmc_card *card, struct mmc_blk_data *md)</span>
 {
 	return 0;
 }
 
<span class="p_add">+static void mmc_blk_remove_debugfs(struct mmc_card *card,</span>
<span class="p_add">+				   struct mmc_blk_data *md)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* CONFIG_DEBUG_FS */
 
 static int mmc_blk_probe(struct mmc_card *card)
<span class="p_chunk">@@ -2467,7 +2517,7 @@</span> <span class="p_context"> static int mmc_blk_probe(struct mmc_card *card)</span>
 	}
 
 	/* Add two debugfs entries */
<span class="p_del">-	mmc_blk_add_debugfs(card);</span>
<span class="p_add">+	mmc_blk_add_debugfs(card, md);</span>
 
 	pm_runtime_set_autosuspend_delay(&amp;card-&gt;dev, 3000);
 	pm_runtime_use_autosuspend(&amp;card-&gt;dev);
<span class="p_chunk">@@ -2493,6 +2543,7 @@</span> <span class="p_context"> static void mmc_blk_remove(struct mmc_card *card)</span>
 {
 	struct mmc_blk_data *md = dev_get_drvdata(&amp;card-&gt;dev);
 
<span class="p_add">+	mmc_blk_remove_debugfs(card, md);</span>
 	mmc_blk_remove_parts(card, md);
 	pm_runtime_get_sync(&amp;card-&gt;dev);
 	mmc_claim_host(card-&gt;host);
<span class="p_header">diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c</span>
<span class="p_header">index 301246513a37..7f428e387de3 100644</span>
<span class="p_header">--- a/drivers/mmc/core/bus.c</span>
<span class="p_header">+++ b/drivers/mmc/core/bus.c</span>
<span class="p_chunk">@@ -157,6 +157,9 @@</span> <span class="p_context"> static int mmc_bus_suspend(struct device *dev)</span>
 		return ret;
 
 	ret = host-&gt;bus_ops-&gt;suspend(host);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		pm_generic_resume(dev);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c</span>
<span class="p_header">index 01e459a34f33..0f4a7d7b2626 100644</span>
<span class="p_header">--- a/drivers/mmc/core/debugfs.c</span>
<span class="p_header">+++ b/drivers/mmc/core/debugfs.c</span>
<span class="p_chunk">@@ -314,4 +314,5 @@</span> <span class="p_context"> void mmc_add_card_debugfs(struct mmc_card *card)</span>
 void mmc_remove_card_debugfs(struct mmc_card *card)
 {
 	debugfs_remove_recursive(card-&gt;debugfs_root);
<span class="p_add">+	card-&gt;debugfs_root = NULL;</span>
 }
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index 36217ad5e9b1..bad5c1bf4ed9 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -780,7 +780,7 @@</span> <span class="p_context"> MMC_DEV_ATTR(manfid, &quot;0x%06x\n&quot;, card-&gt;cid.manfid);</span>
 MMC_DEV_ATTR(name, &quot;%s\n&quot;, card-&gt;cid.prod_name);
 MMC_DEV_ATTR(oemid, &quot;0x%04x\n&quot;, card-&gt;cid.oemid);
 MMC_DEV_ATTR(prv, &quot;0x%x\n&quot;, card-&gt;cid.prv);
<span class="p_del">-MMC_DEV_ATTR(pre_eol_info, &quot;%02x\n&quot;, card-&gt;ext_csd.pre_eol_info);</span>
<span class="p_add">+MMC_DEV_ATTR(pre_eol_info, &quot;0x%02x\n&quot;, card-&gt;ext_csd.pre_eol_info);</span>
 MMC_DEV_ATTR(life_time, &quot;0x%02x 0x%02x\n&quot;,
 	card-&gt;ext_csd.device_life_time_est_typ_a,
 	card-&gt;ext_csd.device_life_time_est_typ_b);
<span class="p_chunk">@@ -790,7 +790,7 @@</span> <span class="p_context"> MMC_DEV_ATTR(enhanced_area_offset, &quot;%llu\n&quot;,</span>
 MMC_DEV_ATTR(enhanced_area_size, &quot;%u\n&quot;, card-&gt;ext_csd.enhanced_area_size);
 MMC_DEV_ATTR(raw_rpmb_size_mult, &quot;%#x\n&quot;, card-&gt;ext_csd.raw_rpmb_size_mult);
 MMC_DEV_ATTR(rel_sectors, &quot;%#x\n&quot;, card-&gt;ext_csd.rel_sectors);
<span class="p_del">-MMC_DEV_ATTR(ocr, &quot;%08x\n&quot;, card-&gt;ocr);</span>
<span class="p_add">+MMC_DEV_ATTR(ocr, &quot;0x%08x\n&quot;, card-&gt;ocr);</span>
 MMC_DEV_ATTR(cmdq_en, &quot;%d\n&quot;, card-&gt;ext_csd.cmdq_en);
 
 static ssize_t mmc_fwrev_show(struct device *dev,
<span class="p_header">diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c</span>
<span class="p_header">index 4fd1620b732d..eb9de2134967 100644</span>
<span class="p_header">--- a/drivers/mmc/core/sd.c</span>
<span class="p_header">+++ b/drivers/mmc/core/sd.c</span>
<span class="p_chunk">@@ -675,7 +675,7 @@</span> <span class="p_context"> MMC_DEV_ATTR(manfid, &quot;0x%06x\n&quot;, card-&gt;cid.manfid);</span>
 MMC_DEV_ATTR(name, &quot;%s\n&quot;, card-&gt;cid.prod_name);
 MMC_DEV_ATTR(oemid, &quot;0x%04x\n&quot;, card-&gt;cid.oemid);
 MMC_DEV_ATTR(serial, &quot;0x%08x\n&quot;, card-&gt;cid.serial);
<span class="p_del">-MMC_DEV_ATTR(ocr, &quot;%08x\n&quot;, card-&gt;ocr);</span>
<span class="p_add">+MMC_DEV_ATTR(ocr, &quot;0x%08x\n&quot;, card-&gt;ocr);</span>
 
 
 static ssize_t mmc_dsr_show(struct device *dev,
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index 0d5fcca18c9e..6152e83ff935 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/dma-mapping.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/scatterlist.h&gt;
<span class="p_add">+#include &lt;linux/swiotlb.h&gt;</span>
 #include &lt;linux/regulator/consumer.h&gt;
 #include &lt;linux/pm_runtime.h&gt;
 #include &lt;linux/of.h&gt;
<span class="p_chunk">@@ -3650,23 +3651,30 @@</span> <span class="p_context"> int sdhci_setup_host(struct sdhci_host *host)</span>
 
 	spin_lock_init(&amp;host-&gt;lock);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Maximum number of sectors in one transfer. Limited by SDMA boundary</span>
<span class="p_add">+	 * size (512KiB). Note some tuning modes impose a 4MiB limit, but this</span>
<span class="p_add">+	 * is less anyway.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mmc-&gt;max_req_size = 524288;</span>
<span class="p_add">+</span>
 	/*
 	 * Maximum number of segments. Depends on if the hardware
 	 * can do scatter/gather or not.
 	 */
<span class="p_del">-	if (host-&gt;flags &amp; SDHCI_USE_ADMA)</span>
<span class="p_add">+	if (host-&gt;flags &amp; SDHCI_USE_ADMA) {</span>
 		mmc-&gt;max_segs = SDHCI_MAX_SEGS;
<span class="p_del">-	else if (host-&gt;flags &amp; SDHCI_USE_SDMA)</span>
<span class="p_add">+	} else if (host-&gt;flags &amp; SDHCI_USE_SDMA) {</span>
 		mmc-&gt;max_segs = 1;
<span class="p_del">-	else /* PIO */</span>
<span class="p_add">+		if (swiotlb_max_segment()) {</span>
<span class="p_add">+			unsigned int max_req_size = (1 &lt;&lt; IO_TLB_SHIFT) *</span>
<span class="p_add">+						IO_TLB_SEGSIZE;</span>
<span class="p_add">+			mmc-&gt;max_req_size = min(mmc-&gt;max_req_size,</span>
<span class="p_add">+						max_req_size);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else { /* PIO */</span>
 		mmc-&gt;max_segs = SDHCI_MAX_SEGS;
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Maximum number of sectors in one transfer. Limited by SDMA boundary</span>
<span class="p_del">-	 * size (512KiB). Note some tuning modes impose a 4MiB limit, but this</span>
<span class="p_del">-	 * is less anyway.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mmc-&gt;max_req_size = 524288;</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * Maximum segment size. Could be one segment with the maximum number
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/ich8lan.h b/drivers/net/ethernet/intel/e1000e/ich8lan.h</span>
<span class="p_header">index 67163ca898ba..00a36df02a3f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/ich8lan.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/ich8lan.h</span>
<span class="p_chunk">@@ -113,7 +113,8 @@</span> <span class="p_context"></span>
 #define NVM_SIZE_MULTIPLIER 4096	/*multiplier for NVMS field */
 #define E1000_FLASH_BASE_ADDR 0xE000	/*offset of NVM access regs */
 #define E1000_CTRL_EXT_NVMVS 0x3	/*NVM valid sector */
<span class="p_del">-#define E1000_TARC0_CB_MULTIQ_3_REQ	(1 &lt;&lt; 28 | 1 &lt;&lt; 29)</span>
<span class="p_add">+#define E1000_TARC0_CB_MULTIQ_3_REQ	0x30000000</span>
<span class="p_add">+#define E1000_TARC0_CB_MULTIQ_2_REQ	0x20000000</span>
 #define PCIE_ICH8_SNOOP_ALL	PCIE_NO_SNOOP_ALL
 
 #define E1000_ICH_RAR_ENTRIES	7
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">index c38b00c90f48..991c2a0dd67e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_chunk">@@ -3030,9 +3030,12 @@</span> <span class="p_context"> static void e1000_configure_tx(struct e1000_adapter *adapter)</span>
 		ew32(IOSFPC, reg_val);
 
 		reg_val = er32(TARC(0));
<span class="p_del">-		/* SPT and KBL Si errata workaround to avoid Tx hang */</span>
<span class="p_del">-		reg_val &amp;= ~BIT(28);</span>
<span class="p_del">-		reg_val |= BIT(29);</span>
<span class="p_add">+		/* SPT and KBL Si errata workaround to avoid Tx hang.</span>
<span class="p_add">+		 * Dropping the number of outstanding requests from</span>
<span class="p_add">+		 * 3 to 2 in order to avoid a buffer overrun.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		reg_val &amp;= ~E1000_TARC0_CB_MULTIQ_3_REQ;</span>
<span class="p_add">+		reg_val |= E1000_TARC0_CB_MULTIQ_2_REQ;</span>
 		ew32(TARC(0), reg_val);
 	}
 }
<span class="p_header">diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h</span>
<span class="p_header">index d3f3c4447515..044af553204c 100644</span>
<span class="p_header">--- a/drivers/nvme/host/nvme.h</span>
<span class="p_header">+++ b/drivers/nvme/host/nvme.h</span>
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> static inline struct nvme_request *nvme_req(struct request *req)</span>
  * NVME_QUIRK_DELAY_BEFORE_CHK_RDY quirk enabled. The value (in ms) was
  * found empirically.
  */
<span class="p_del">-#define NVME_QUIRK_DELAY_AMOUNT		2000</span>
<span class="p_add">+#define NVME_QUIRK_DELAY_AMOUNT		2300</span>
 
 enum nvme_ctrl_state {
 	NVME_CTRL_NEW,
<span class="p_header">diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c</span>
<span class="p_header">index 3f5a04c586ce..75539f7c58b9 100644</span>
<span class="p_header">--- a/drivers/nvme/host/pci.c</span>
<span class="p_header">+++ b/drivers/nvme/host/pci.c</span>
<span class="p_chunk">@@ -2519,6 +2519,8 @@</span> <span class="p_context"> static const struct pci_device_id nvme_id_table[] = {</span>
 		.driver_data = NVME_QUIRK_IDENTIFY_CNS, },
 	{ PCI_DEVICE(0x1c58, 0x0003),	/* HGST adapter */
 		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, },
<span class="p_add">+	{ PCI_DEVICE(0x1c58, 0x0023),	/* WDC SN200 adapter */</span>
<span class="p_add">+		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, },</span>
 	{ PCI_DEVICE(0x1c5f, 0x0540),	/* Memblaze Pblaze4 adapter */
 		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, },
 	{ PCI_DEVICE(0x144d, 0xa821),   /* Samsung PM1725 */
<span class="p_header">diff --git a/drivers/platform/x86/hp-wmi.c b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">index b4ed3dc983d5..b4224389febe 100644</span>
<span class="p_header">--- a/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_chunk">@@ -297,7 +297,7 @@</span> <span class="p_context"> static int hp_wmi_hw_state(int mask)</span>
 	if (state &lt; 0)
 		return state;
 
<span class="p_del">-	return state &amp; 0x1;</span>
<span class="p_add">+	return !!(state &amp; mask);</span>
 }
 
 static int __init hp_wmi_bios_2008_later(void)
<span class="p_header">diff --git a/fs/autofs4/root.c b/fs/autofs4/root.c</span>
<span class="p_header">index d79ced925861..82e8f6edfb48 100644</span>
<span class="p_header">--- a/fs/autofs4/root.c</span>
<span class="p_header">+++ b/fs/autofs4/root.c</span>
<span class="p_chunk">@@ -281,8 +281,8 @@</span> <span class="p_context"> static int autofs4_mount_wait(const struct path *path, bool rcu_walk)</span>
 		pr_debug(&quot;waiting for mount name=%pd\n&quot;, path-&gt;dentry);
 		status = autofs4_wait(sbi, path, NFY_MOUNT);
 		pr_debug(&quot;mount wait done status=%d\n&quot;, status);
<span class="p_del">-		ino-&gt;last_used = jiffies;</span>
 	}
<span class="p_add">+	ino-&gt;last_used = jiffies;</span>
 	return status;
 }
 
<span class="p_chunk">@@ -321,21 +321,16 @@</span> <span class="p_context"> static struct dentry *autofs4_mountpoint_changed(struct path *path)</span>
 	 */
 	if (autofs_type_indirect(sbi-&gt;type) &amp;&amp; d_unhashed(dentry)) {
 		struct dentry *parent = dentry-&gt;d_parent;
<span class="p_add">+		struct autofs_info *ino;</span>
 		struct dentry *new;
 
 		new = d_lookup(parent, &amp;dentry-&gt;d_name);
 		if (!new)
 			return NULL;
<span class="p_del">-		if (new == dentry)</span>
<span class="p_del">-			dput(new);</span>
<span class="p_del">-		else {</span>
<span class="p_del">-			struct autofs_info *ino;</span>
<span class="p_del">-</span>
<span class="p_del">-			ino = autofs4_dentry_ino(new);</span>
<span class="p_del">-			ino-&gt;last_used = jiffies;</span>
<span class="p_del">-			dput(path-&gt;dentry);</span>
<span class="p_del">-			path-&gt;dentry = new;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		ino = autofs4_dentry_ino(new);</span>
<span class="p_add">+		ino-&gt;last_used = jiffies;</span>
<span class="p_add">+		dput(path-&gt;dentry);</span>
<span class="p_add">+		path-&gt;dentry = new;</span>
 	}
 	return path-&gt;dentry;
 }
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 08698105fa4a..e4774c02d922 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -3526,13 +3526,6 @@</span> <span class="p_context"> static int cache_save_setup(struct btrfs_block_group_cache *block_group,</span>
 		goto again;
 	}
 
<span class="p_del">-	/* We&#39;ve already setup this transaction, go ahead and exit */</span>
<span class="p_del">-	if (block_group-&gt;cache_generation == trans-&gt;transid &amp;&amp;</span>
<span class="p_del">-	    i_size_read(inode)) {</span>
<span class="p_del">-		dcs = BTRFS_DC_SETUP;</span>
<span class="p_del">-		goto out_put;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/*
 	 * We want to set the generation to 0, that way if anything goes wrong
 	 * from here on out we know not to trust this cache when we load up next
<span class="p_chunk">@@ -3556,6 +3549,13 @@</span> <span class="p_context"> static int cache_save_setup(struct btrfs_block_group_cache *block_group,</span>
 	}
 	WARN_ON(ret);
 
<span class="p_add">+	/* We&#39;ve already setup this transaction, go ahead and exit */</span>
<span class="p_add">+	if (block_group-&gt;cache_generation == trans-&gt;transid &amp;&amp;</span>
<span class="p_add">+	    i_size_read(inode)) {</span>
<span class="p_add">+		dcs = BTRFS_DC_SETUP;</span>
<span class="p_add">+		goto out_put;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (i_size_read(inode) &gt; 0) {
 		ret = btrfs_check_trunc_cache_free_space(fs_info,
 					&amp;fs_info-&gt;global_block_rsv);
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 3e14ba25f678..4726c777dd38 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -1340,10 +1340,15 @@</span> <span class="p_context"> void setup_new_exec(struct linux_binprm * bprm)</span>
 		 * avoid bad behavior from the prior rlimits. This has to
 		 * happen before arch_pick_mmap_layout(), which examines
 		 * RLIMIT_STACK, but after the point of no return to avoid
<span class="p_del">-		 * needing to clean up the change on failure.</span>
<span class="p_add">+		 * races from other threads changing the limits. This also</span>
<span class="p_add">+		 * must be protected from races with prlimit() calls.</span>
 		 */
<span class="p_add">+		task_lock(current-&gt;group_leader);</span>
 		if (current-&gt;signal-&gt;rlim[RLIMIT_STACK].rlim_cur &gt; _STK_LIM)
 			current-&gt;signal-&gt;rlim[RLIMIT_STACK].rlim_cur = _STK_LIM;
<span class="p_add">+		if (current-&gt;signal-&gt;rlim[RLIMIT_STACK].rlim_max &gt; _STK_LIM)</span>
<span class="p_add">+			current-&gt;signal-&gt;rlim[RLIMIT_STACK].rlim_max = _STK_LIM;</span>
<span class="p_add">+		task_unlock(current-&gt;group_leader);</span>
 	}
 
 	arch_pick_mmap_layout(current-&gt;mm);
<span class="p_header">diff --git a/fs/fat/inode.c b/fs/fat/inode.c</span>
<span class="p_header">index 30c52394a7ad..c7a4dee206b9 100644</span>
<span class="p_header">--- a/fs/fat/inode.c</span>
<span class="p_header">+++ b/fs/fat/inode.c</span>
<span class="p_chunk">@@ -779,7 +779,7 @@</span> <span class="p_context"> static void __exit fat_destroy_inodecache(void)</span>
 
 static int fat_remount(struct super_block *sb, int *flags, char *data)
 {
<span class="p_del">-	int new_rdonly;</span>
<span class="p_add">+	bool new_rdonly;</span>
 	struct msdos_sb_info *sbi = MSDOS_SB(sb);
 	*flags |= MS_NODIRATIME | (sbi-&gt;options.isvfat ? 0 : MS_NOATIME);
 
<span class="p_header">diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c</span>
<span class="p_header">index f04ecfc7ece0..45e96549ebd2 100644</span>
<span class="p_header">--- a/fs/lockd/svc.c</span>
<span class="p_header">+++ b/fs/lockd/svc.c</span>
<span class="p_chunk">@@ -274,6 +274,8 @@</span> <span class="p_context"> static void lockd_down_net(struct svc_serv *serv, struct net *net)</span>
 	if (ln-&gt;nlmsvc_users) {
 		if (--ln-&gt;nlmsvc_users == 0) {
 			nlm_shutdown_hosts_net(net);
<span class="p_add">+			cancel_delayed_work_sync(&amp;ln-&gt;grace_period_end);</span>
<span class="p_add">+			locks_end_grace(&amp;ln-&gt;lockd_manager);</span>
 			svc_shutdown_net(serv, net);
 			dprintk(&quot;lockd_down_net: per-net data destroyed; net=%p\n&quot;, net);
 		}
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index ed8b9488a890..62a0db6e6725 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1129,18 +1129,9 @@</span> <span class="p_context"> static int follow_automount(struct path *path, struct nameidata *nd,</span>
 	 * of the daemon to instantiate them before they can be used.
 	 */
 	if (!(nd-&gt;flags &amp; (LOOKUP_PARENT | LOOKUP_DIRECTORY |
<span class="p_del">-			   LOOKUP_OPEN | LOOKUP_CREATE |</span>
<span class="p_del">-			   LOOKUP_AUTOMOUNT))) {</span>
<span class="p_del">-		/* Positive dentry that isn&#39;t meant to trigger an</span>
<span class="p_del">-		 * automount, EISDIR will allow it to be used,</span>
<span class="p_del">-		 * otherwise there&#39;s no mount here &quot;now&quot; so return</span>
<span class="p_del">-		 * ENOENT.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (path-&gt;dentry-&gt;d_inode)</span>
<span class="p_del">-			return -EISDIR;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			return -ENOENT;</span>
<span class="p_del">-	}</span>
<span class="p_add">+			   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &amp;&amp;</span>
<span class="p_add">+	    path-&gt;dentry-&gt;d_inode)</span>
<span class="p_add">+		return -EISDIR;</span>
 
 	if (path-&gt;dentry-&gt;d_sb-&gt;s_user_ns != &amp;init_user_ns)
 		return -EACCES;
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index d386d569edbc..a439a70177a4 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -3512,7 +3512,9 @@</span> <span class="p_context"> nfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 		/* ignore lock owners */
 		if (local-&gt;st_stateowner-&gt;so_is_open_owner == 0)
 			continue;
<span class="p_del">-		if (local-&gt;st_stateowner == &amp;oo-&gt;oo_owner) {</span>
<span class="p_add">+		if (local-&gt;st_stateowner != &amp;oo-&gt;oo_owner)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (local-&gt;st_stid.sc_type == NFS4_OPEN_STID) {</span>
 			ret = local;
 			atomic_inc(&amp;ret-&gt;st_stid.sc_count);
 			break;
<span class="p_chunk">@@ -3521,6 +3523,52 @@</span> <span class="p_context"> nfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 	return ret;
 }
 
<span class="p_add">+static __be32</span>
<span class="p_add">+nfsd4_verify_open_stid(struct nfs4_stid *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__be32 ret = nfs_ok;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (s-&gt;sc_type) {</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case NFS4_CLOSED_STID:</span>
<span class="p_add">+	case NFS4_CLOSED_DELEG_STID:</span>
<span class="p_add">+		ret = nfserr_bad_stateid;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case NFS4_REVOKED_DELEG_STID:</span>
<span class="p_add">+		ret = nfserr_deleg_revoked;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Lock the stateid st_mutex, and deal with races with CLOSE */</span>
<span class="p_add">+static __be32</span>
<span class="p_add">+nfsd4_lock_ol_stateid(struct nfs4_ol_stateid *stp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__be32 ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+	ret = nfsd4_verify_open_stid(&amp;stp-&gt;st_stid);</span>
<span class="p_add">+	if (ret != nfs_ok)</span>
<span class="p_add">+		mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct nfs4_ol_stateid *</span>
<span class="p_add">+nfsd4_find_and_lock_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfs4_ol_stateid *stp;</span>
<span class="p_add">+	for (;;) {</span>
<span class="p_add">+		spin_lock(&amp;fp-&gt;fi_lock);</span>
<span class="p_add">+		stp = nfsd4_find_existing_open(fp, open);</span>
<span class="p_add">+		spin_unlock(&amp;fp-&gt;fi_lock);</span>
<span class="p_add">+		if (!stp || nfsd4_lock_ol_stateid(stp) == nfs_ok)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		nfs4_put_stid(&amp;stp-&gt;st_stid);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return stp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct nfs4_openowner *
 alloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,
 			   struct nfsd4_compound_state *cstate)
<span class="p_chunk">@@ -3565,6 +3613,7 @@</span> <span class="p_context"> init_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 	mutex_init(&amp;stp-&gt;st_mutex);
 	mutex_lock(&amp;stp-&gt;st_mutex);
 
<span class="p_add">+retry:</span>
 	spin_lock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
 	spin_lock(&amp;fp-&gt;fi_lock);
 
<span class="p_chunk">@@ -3589,7 +3638,11 @@</span> <span class="p_context"> init_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 	spin_unlock(&amp;fp-&gt;fi_lock);
 	spin_unlock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
 	if (retstp) {
<span class="p_del">-		mutex_lock(&amp;retstp-&gt;st_mutex);</span>
<span class="p_add">+		/* Handle races with CLOSE */</span>
<span class="p_add">+		if (nfsd4_lock_ol_stateid(retstp) != nfs_ok) {</span>
<span class="p_add">+			nfs4_put_stid(&amp;retstp-&gt;st_stid);</span>
<span class="p_add">+			goto retry;</span>
<span class="p_add">+		}</span>
 		/* To keep mutex tracking happy */
 		mutex_unlock(&amp;stp-&gt;st_mutex);
 		stp = retstp;
<span class="p_chunk">@@ -4399,6 +4452,7 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 	struct nfs4_ol_stateid *stp = NULL;
 	struct nfs4_delegation *dp = NULL;
 	__be32 status;
<span class="p_add">+	bool new_stp = false;</span>
 
 	/*
 	 * Lookup file; if found, lookup stateid and check open request,
<span class="p_chunk">@@ -4410,9 +4464,7 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 		status = nfs4_check_deleg(cl, open, &amp;dp);
 		if (status)
 			goto out;
<span class="p_del">-		spin_lock(&amp;fp-&gt;fi_lock);</span>
<span class="p_del">-		stp = nfsd4_find_existing_open(fp, open);</span>
<span class="p_del">-		spin_unlock(&amp;fp-&gt;fi_lock);</span>
<span class="p_add">+		stp = nfsd4_find_and_lock_existing_open(fp, open);</span>
 	} else {
 		open-&gt;op_file = NULL;
 		status = nfserr_bad_stateid;
<span class="p_chunk">@@ -4420,35 +4472,31 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 			goto out;
 	}
 
<span class="p_add">+	if (!stp) {</span>
<span class="p_add">+		stp = init_open_stateid(fp, open);</span>
<span class="p_add">+		if (!open-&gt;op_stp)</span>
<span class="p_add">+			new_stp = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * OPEN the file, or upgrade an existing OPEN.
 	 * If truncate fails, the OPEN fails.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * stp is already locked.</span>
 	 */
<span class="p_del">-	if (stp) {</span>
<span class="p_add">+	if (!new_stp) {</span>
 		/* Stateid was found, this is an OPEN upgrade */
<span class="p_del">-		mutex_lock(&amp;stp-&gt;st_mutex);</span>
 		status = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);
 		if (status) {
 			mutex_unlock(&amp;stp-&gt;st_mutex);
 			goto out;
 		}
 	} else {
<span class="p_del">-		/* stp is returned locked. */</span>
<span class="p_del">-		stp = init_open_stateid(fp, open);</span>
<span class="p_del">-		/* See if we lost the race to some other thread */</span>
<span class="p_del">-		if (stp-&gt;st_access_bmap != 0) {</span>
<span class="p_del">-			status = nfs4_upgrade_open(rqstp, fp, current_fh,</span>
<span class="p_del">-						stp, open);</span>
<span class="p_del">-			if (status) {</span>
<span class="p_del">-				mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			goto upgrade_out;</span>
<span class="p_del">-		}</span>
 		status = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);
 		if (status) {
<span class="p_del">-			mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+			stp-&gt;st_stid.sc_type = NFS4_CLOSED_STID;</span>
 			release_open_stateid(stp);
<span class="p_add">+			mutex_unlock(&amp;stp-&gt;st_mutex);</span>
 			goto out;
 		}
 
<span class="p_chunk">@@ -4457,7 +4505,7 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 		if (stp-&gt;st_clnt_odstate == open-&gt;op_odstate)
 			open-&gt;op_odstate = NULL;
 	}
<span class="p_del">-upgrade_out:</span>
<span class="p_add">+</span>
 	nfs4_inc_and_copy_stateid(&amp;open-&gt;op_stateid, &amp;stp-&gt;st_stid);
 	mutex_unlock(&amp;stp-&gt;st_mutex);
 
<span class="p_chunk">@@ -4684,7 +4732,7 @@</span> <span class="p_context"> nfs4_laundromat(struct nfsd_net *nn)</span>
 	spin_unlock(&amp;nn-&gt;blocked_locks_lock);
 
 	while (!list_empty(&amp;reaplist)) {
<span class="p_del">-		nbl = list_first_entry(&amp;nn-&gt;blocked_locks_lru,</span>
<span class="p_add">+		nbl = list_first_entry(&amp;reaplist,</span>
 					struct nfsd4_blocked_lock, nbl_lru);
 		list_del_init(&amp;nbl-&gt;nbl_lru);
 		posix_unblock_lock(&amp;nbl-&gt;nbl_lock);
<span class="p_chunk">@@ -5317,7 +5365,6 @@</span> <span class="p_context"> static void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)</span>
 	bool unhashed;
 	LIST_HEAD(reaplist);
 
<span class="p_del">-	s-&gt;st_stid.sc_type = NFS4_CLOSED_STID;</span>
 	spin_lock(&amp;clp-&gt;cl_lock);
 	unhashed = unhash_open_stateid(s, &amp;reaplist);
 
<span class="p_chunk">@@ -5357,10 +5404,12 @@</span> <span class="p_context"> nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 	nfsd4_bump_seqid(cstate, status);
 	if (status)
 		goto out; 
<span class="p_add">+</span>
<span class="p_add">+	stp-&gt;st_stid.sc_type = NFS4_CLOSED_STID;</span>
 	nfs4_inc_and_copy_stateid(&amp;close-&gt;cl_stateid, &amp;stp-&gt;st_stid);
<span class="p_del">-	mutex_unlock(&amp;stp-&gt;st_mutex);</span>
 
 	nfsd4_close_open_stateid(stp);
<span class="p_add">+	mutex_unlock(&amp;stp-&gt;st_mutex);</span>
 
 	/* put reference from nfs4_preprocess_seqid_op */
 	nfs4_put_stid(&amp;stp-&gt;st_stid);
<span class="p_chunk">@@ -7103,7 +7152,7 @@</span> <span class="p_context"> nfs4_state_shutdown_net(struct net *net)</span>
 	spin_unlock(&amp;nn-&gt;blocked_locks_lock);
 
 	while (!list_empty(&amp;reaplist)) {
<span class="p_del">-		nbl = list_first_entry(&amp;nn-&gt;blocked_locks_lru,</span>
<span class="p_add">+		nbl = list_first_entry(&amp;reaplist,</span>
 					struct nfsd4_blocked_lock, nbl_lru);
 		list_del_init(&amp;nbl-&gt;nbl_lru);
 		posix_unblock_lock(&amp;nbl-&gt;nbl_lock);
<span class="p_header">diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h</span>
<span class="p_header">index fa1505292f6c..324a04df3785 100644</span>
<span class="p_header">--- a/include/acpi/acpi_bus.h</span>
<span class="p_header">+++ b/include/acpi/acpi_bus.h</span>
<span class="p_chunk">@@ -105,6 +105,7 @@</span> <span class="p_context"> enum acpi_bus_device_type {</span>
 	ACPI_BUS_TYPE_THERMAL,
 	ACPI_BUS_TYPE_POWER_BUTTON,
 	ACPI_BUS_TYPE_SLEEP_BUTTON,
<span class="p_add">+	ACPI_BUS_TYPE_ECDT_EC,</span>
 	ACPI_BUS_DEVICE_TYPE_COUNT
 };
 
<span class="p_header">diff --git a/include/acpi/acpi_drivers.h b/include/acpi/acpi_drivers.h</span>
<span class="p_header">index 29c691265b49..14499757338f 100644</span>
<span class="p_header">--- a/include/acpi/acpi_drivers.h</span>
<span class="p_header">+++ b/include/acpi/acpi_drivers.h</span>
<span class="p_chunk">@@ -58,6 +58,7 @@</span> <span class="p_context"></span>
 #define ACPI_VIDEO_HID			&quot;LNXVIDEO&quot;
 #define ACPI_BAY_HID			&quot;LNXIOBAY&quot;
 #define ACPI_DOCK_HID			&quot;LNXDOCK&quot;
<span class="p_add">+#define ACPI_ECDT_HID			&quot;LNXEC&quot;</span>
 /* Quirk for broken IBM BIOSes */
 #define ACPI_SMBUS_IBM_HID		&quot;SMBUSIBM&quot;
 
<span class="p_header">diff --git a/include/asm-generic/pgtable.h b/include/asm-generic/pgtable.h</span>
<span class="p_header">index 757dc6ffc7ba..1ac457511f4e 100644</span>
<span class="p_header">--- a/include/asm-generic/pgtable.h</span>
<span class="p_header">+++ b/include/asm-generic/pgtable.h</span>
<span class="p_chunk">@@ -814,6 +814,14 @@</span> <span class="p_context"> static inline int pmd_write(pmd_t pmd)</span>
 #endif /* __HAVE_ARCH_PMD_WRITE */
 #endif /* CONFIG_TRANSPARENT_HUGEPAGE */
 
<span class="p_add">+#ifndef pud_write</span>
<span class="p_add">+static inline int pud_write(pud_t pud)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG();</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* pud_write */</span>
<span class="p_add">+</span>
 #if !defined(CONFIG_TRANSPARENT_HUGEPAGE) || \
 	(defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; \
 	 !defined(CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD))
<span class="p_header">diff --git a/include/crypto/if_alg.h b/include/crypto/if_alg.h</span>
<span class="p_header">index 75ec9c662268..aeec003a566b 100644</span>
<span class="p_header">--- a/include/crypto/if_alg.h</span>
<span class="p_header">+++ b/include/crypto/if_alg.h</span>
<span class="p_chunk">@@ -255,6 +255,7 @@</span> <span class="p_context"> int af_alg_sendmsg(struct socket *sock, struct msghdr *msg, size_t size,</span>
 		   unsigned int ivsize);
 ssize_t af_alg_sendpage(struct socket *sock, struct page *page,
 			int offset, size_t size, int flags);
<span class="p_add">+void af_alg_free_resources(struct af_alg_async_req *areq);</span>
 void af_alg_async_cb(struct crypto_async_request *_req, int err);
 unsigned int af_alg_poll(struct file *file, struct socket *sock,
 			 poll_table *wait);
<span class="p_header">diff --git a/include/drm/drm_edid.h b/include/drm/drm_edid.h</span>
<span class="p_header">index 1e1908a6b1d6..a992434ded99 100644</span>
<span class="p_header">--- a/include/drm/drm_edid.h</span>
<span class="p_header">+++ b/include/drm/drm_edid.h</span>
<span class="p_chunk">@@ -360,7 +360,8 @@</span> <span class="p_context"> void</span>
 drm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,
 				   const struct drm_display_mode *mode,
 				   enum hdmi_quantization_range rgb_quant_range,
<span class="p_del">-				   bool rgb_quant_range_selectable);</span>
<span class="p_add">+				   bool rgb_quant_range_selectable,</span>
<span class="p_add">+				   bool is_hdmi2_sink);</span>
 
 /**
  * drm_eld_mnl - Get ELD monitor name length in bytes.
<span class="p_header">diff --git a/include/linux/compiler-clang.h b/include/linux/compiler-clang.h</span>
<span class="p_header">index 54dfef70a072..780b1242bf24 100644</span>
<span class="p_header">--- a/include/linux/compiler-clang.h</span>
<span class="p_header">+++ b/include/linux/compiler-clang.h</span>
<span class="p_chunk">@@ -16,3 +16,6 @@</span> <span class="p_context"></span>
  * with any version that can compile the kernel
  */
 #define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
<span class="p_add">+</span>
<span class="p_add">+#define randomized_struct_fields_start	struct {</span>
<span class="p_add">+#define randomized_struct_fields_end	};</span>
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index 885266aae2d7..440281f8564d 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -3069,7 +3069,8 @@</span> <span class="p_context"> static inline int vfs_lstat(const char __user *name, struct kstat *stat)</span>
 static inline int vfs_fstatat(int dfd, const char __user *filename,
 			      struct kstat *stat, int flags)
 {
<span class="p_del">-	return vfs_statx(dfd, filename, flags, stat, STATX_BASIC_STATS);</span>
<span class="p_add">+	return vfs_statx(dfd, filename, flags | AT_NO_AUTOMOUNT,</span>
<span class="p_add">+			 stat, STATX_BASIC_STATS);</span>
 }
 static inline int vfs_fstat(int fd, struct kstat *stat)
 {
<span class="p_chunk">@@ -3175,6 +3176,20 @@</span> <span class="p_context"> static inline bool vma_is_dax(struct vm_area_struct *vma)</span>
 	return vma-&gt;vm_file &amp;&amp; IS_DAX(vma-&gt;vm_file-&gt;f_mapping-&gt;host);
 }
 
<span class="p_add">+static inline bool vma_is_fsdax(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!vma-&gt;vm_file)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (!vma_is_dax(vma))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	inode = file_inode(vma-&gt;vm_file);</span>
<span class="p_add">+	if (inode-&gt;i_mode == S_IFCHR)</span>
<span class="p_add">+		return false; /* device-dax */</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int iocb_flags(struct file *file)
 {
 	int res = 0;
<span class="p_header">diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="p_header">index fbf5b31d47ee..82a25880714a 100644</span>
<span class="p_header">--- a/include/linux/hugetlb.h</span>
<span class="p_header">+++ b/include/linux/hugetlb.h</span>
<span class="p_chunk">@@ -239,14 +239,6 @@</span> <span class="p_context"> static inline int pgd_write(pgd_t pgd)</span>
 }
 #endif
 
<span class="p_del">-#ifndef pud_write</span>
<span class="p_del">-static inline int pud_write(pud_t pud)</span>
<span class="p_del">-{</span>
<span class="p_del">-	BUG();</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 #define HUGETLB_ANON_FILE &quot;anon_hugepage&quot;
 
 enum {
<span class="p_header">diff --git a/include/linux/migrate.h b/include/linux/migrate.h</span>
<span class="p_header">index 895ec0c4942e..a2246cf670ba 100644</span>
<span class="p_header">--- a/include/linux/migrate.h</span>
<span class="p_header">+++ b/include/linux/migrate.h</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> static inline struct page *new_page_nodemask(struct page *page,</span>
 	new_page = __alloc_pages_nodemask(gfp_mask, order,
 				preferred_nid, nodemask);
 
<span class="p_del">-	if (new_page &amp;&amp; PageTransHuge(page))</span>
<span class="p_add">+	if (new_page &amp;&amp; PageTransHuge(new_page))</span>
 		prep_transhuge_page(new_page);
 
 	return new_page;
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 43edf659453b..db647d428100 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -367,6 +367,7 @@</span> <span class="p_context"> enum page_entry_size {</span>
 struct vm_operations_struct {
 	void (*open)(struct vm_area_struct * area);
 	void (*close)(struct vm_area_struct * area);
<span class="p_add">+	int (*split)(struct vm_area_struct * area, unsigned long addr);</span>
 	int (*mremap)(struct vm_area_struct * area);
 	int (*fault)(struct vm_fault *vmf);
 	int (*huge_fault)(struct vm_fault *vmf, enum page_entry_size pe_size);
<span class="p_chunk">@@ -1367,6 +1368,19 @@</span> <span class="p_context"> long get_user_pages_locked(unsigned long start, unsigned long nr_pages,</span>
 		    unsigned int gup_flags, struct page **pages, int *locked);
 long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,
 		    struct page **pages, unsigned int gup_flags);
<span class="p_add">+#ifdef CONFIG_FS_DAX</span>
<span class="p_add">+long get_user_pages_longterm(unsigned long start, unsigned long nr_pages,</span>
<span class="p_add">+			    unsigned int gup_flags, struct page **pages,</span>
<span class="p_add">+			    struct vm_area_struct **vmas);</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline long get_user_pages_longterm(unsigned long start,</span>
<span class="p_add">+		unsigned long nr_pages, unsigned int gup_flags,</span>
<span class="p_add">+		struct page **pages, struct vm_area_struct **vmas)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return get_user_pages(start, nr_pages, gup_flags, pages, vmas);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_FS_DAX */</span>
<span class="p_add">+</span>
 int get_user_pages_fast(unsigned long start, int nr_pages, int write,
 			struct page **pages);
 
<span class="p_header">diff --git a/include/uapi/linux/bcache.h b/include/uapi/linux/bcache.h</span>
<span class="p_header">index 90fc490f973f..821f71a2e48f 100644</span>
<span class="p_header">--- a/include/uapi/linux/bcache.h</span>
<span class="p_header">+++ b/include/uapi/linux/bcache.h</span>
<span class="p_chunk">@@ -91,7 +91,7 @@</span> <span class="p_context"> PTR_FIELD(PTR_GEN,			0,  8)</span>
 
 #define PTR_CHECK_DEV			((1 &lt;&lt; PTR_DEV_BITS) - 1)
 
<span class="p_del">-#define PTR(gen, offset, dev)						\</span>
<span class="p_add">+#define MAKE_PTR(gen, offset, dev)					\</span>
 	((((__u64) dev) &lt;&lt; 51) | ((__u64) offset) &lt;&lt; 8 | gen)
 
 /* Bkey utility code */
<span class="p_header">diff --git a/mm/frame_vector.c b/mm/frame_vector.c</span>
<span class="p_header">index 2f98df0d460e..297c7238f7d4 100644</span>
<span class="p_header">--- a/mm/frame_vector.c</span>
<span class="p_header">+++ b/mm/frame_vector.c</span>
<span class="p_chunk">@@ -53,6 +53,18 @@</span> <span class="p_context"> int get_vaddr_frames(unsigned long start, unsigned int nr_frames,</span>
 		ret = -EFAULT;
 		goto out;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * While get_vaddr_frames() could be used for transient (kernel</span>
<span class="p_add">+	 * controlled lifetime) pinning of memory pages all current</span>
<span class="p_add">+	 * users establish long term (userspace controlled lifetime)</span>
<span class="p_add">+	 * page pinning. Treat get_vaddr_frames() like</span>
<span class="p_add">+	 * get_user_pages_longterm() and disallow it for filesystem-dax</span>
<span class="p_add">+	 * mappings.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (vma_is_fsdax(vma))</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
 	if (!(vma-&gt;vm_flags &amp; (VM_IO | VM_PFNMAP))) {
 		vec-&gt;got_ref = true;
 		vec-&gt;is_pfns = false;
<span class="p_header">diff --git a/mm/gup.c b/mm/gup.c</span>
<span class="p_header">index b2b4d4263768..165ba2174c75 100644</span>
<span class="p_header">--- a/mm/gup.c</span>
<span class="p_header">+++ b/mm/gup.c</span>
<span class="p_chunk">@@ -1095,6 +1095,70 @@</span> <span class="p_context"> long get_user_pages(unsigned long start, unsigned long nr_pages,</span>
 }
 EXPORT_SYMBOL(get_user_pages);
 
<span class="p_add">+#ifdef CONFIG_FS_DAX</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is the same as get_user_pages() in that it assumes we are</span>
<span class="p_add">+ * operating on the current task&#39;s mm, but it goes further to validate</span>
<span class="p_add">+ * that the vmas associated with the address range are suitable for</span>
<span class="p_add">+ * longterm elevated page reference counts. For example, filesystem-dax</span>
<span class="p_add">+ * mappings are subject to the lifetime enforced by the filesystem and</span>
<span class="p_add">+ * we need guarantees that longterm users like RDMA and V4L2 only</span>
<span class="p_add">+ * establish mappings that have a kernel enforced revocation mechanism.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * &quot;longterm&quot; == userspace controlled elevated page count lifetime.</span>
<span class="p_add">+ * Contrast this to iov_iter_get_pages() usages which are transient.</span>
<span class="p_add">+ */</span>
<span class="p_add">+long get_user_pages_longterm(unsigned long start, unsigned long nr_pages,</span>
<span class="p_add">+		unsigned int gup_flags, struct page **pages,</span>
<span class="p_add">+		struct vm_area_struct **vmas_arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vm_area_struct **vmas = vmas_arg;</span>
<span class="p_add">+	struct vm_area_struct *vma_prev = NULL;</span>
<span class="p_add">+	long rc, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pages)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!vmas) {</span>
<span class="p_add">+		vmas = kcalloc(nr_pages, sizeof(struct vm_area_struct *),</span>
<span class="p_add">+			       GFP_KERNEL);</span>
<span class="p_add">+		if (!vmas)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = get_user_pages(start, nr_pages, gup_flags, pages, vmas);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; rc; i++) {</span>
<span class="p_add">+		struct vm_area_struct *vma = vmas[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (vma == vma_prev)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		vma_prev = vma;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (vma_is_fsdax(vma))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Either get_user_pages() failed, or the vma validation</span>
<span class="p_add">+	 * succeeded, in either case we don&#39;t need to put_page() before</span>
<span class="p_add">+	 * returning.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (i &gt;= rc)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; rc; i++)</span>
<span class="p_add">+		put_page(pages[i]);</span>
<span class="p_add">+	rc = -EOPNOTSUPP;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	if (vmas != vmas_arg)</span>
<span class="p_add">+		kfree(vmas);</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(get_user_pages_longterm);</span>
<span class="p_add">+#endif /* CONFIG_FS_DAX */</span>
<span class="p_add">+</span>
 /**
  * populate_vma_page_range() -  populate a range of pages in the vma.
  * @vma:   target vma
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 1981ed697dab..eba34cdfc3e5 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -842,20 +842,15 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(vmf_insert_pfn_pud);</span>
 #endif /* CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD */
 
 static void touch_pmd(struct vm_area_struct *vma, unsigned long addr,
<span class="p_del">-		pmd_t *pmd)</span>
<span class="p_add">+		pmd_t *pmd, int flags)</span>
 {
 	pmd_t _pmd;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We should set the dirty bit only for FOLL_WRITE but for now</span>
<span class="p_del">-	 * the dirty bit in the pmd is meaningless.  And if the dirty</span>
<span class="p_del">-	 * bit will become meaningful and we&#39;ll only set it with</span>
<span class="p_del">-	 * FOLL_WRITE, an atomic set_bit will be required on the pmd to</span>
<span class="p_del">-	 * set the young bit, instead of the current set_pmd_at.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	_pmd = pmd_mkyoung(pmd_mkdirty(*pmd));</span>
<span class="p_add">+	_pmd = pmd_mkyoung(*pmd);</span>
<span class="p_add">+	if (flags &amp; FOLL_WRITE)</span>
<span class="p_add">+		_pmd = pmd_mkdirty(_pmd);</span>
 	if (pmdp_set_access_flags(vma, addr &amp; HPAGE_PMD_MASK,
<span class="p_del">-				pmd, _pmd,  1))</span>
<span class="p_add">+				pmd, _pmd, flags &amp; FOLL_WRITE))</span>
 		update_mmu_cache_pmd(vma, addr, pmd);
 }
 
<span class="p_chunk">@@ -884,7 +879,7 @@</span> <span class="p_context"> struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,</span>
 		return NULL;
 
 	if (flags &amp; FOLL_TOUCH)
<span class="p_del">-		touch_pmd(vma, addr, pmd);</span>
<span class="p_add">+		touch_pmd(vma, addr, pmd, flags);</span>
 
 	/*
 	 * device mapped pages can only be returned if the
<span class="p_chunk">@@ -995,20 +990,15 @@</span> <span class="p_context"> int copy_huge_pmd(struct mm_struct *dst_mm, struct mm_struct *src_mm,</span>
 
 #ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
 static void touch_pud(struct vm_area_struct *vma, unsigned long addr,
<span class="p_del">-		pud_t *pud)</span>
<span class="p_add">+		pud_t *pud, int flags)</span>
 {
 	pud_t _pud;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We should set the dirty bit only for FOLL_WRITE but for now</span>
<span class="p_del">-	 * the dirty bit in the pud is meaningless.  And if the dirty</span>
<span class="p_del">-	 * bit will become meaningful and we&#39;ll only set it with</span>
<span class="p_del">-	 * FOLL_WRITE, an atomic set_bit will be required on the pud to</span>
<span class="p_del">-	 * set the young bit, instead of the current set_pud_at.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	_pud = pud_mkyoung(pud_mkdirty(*pud));</span>
<span class="p_add">+	_pud = pud_mkyoung(*pud);</span>
<span class="p_add">+	if (flags &amp; FOLL_WRITE)</span>
<span class="p_add">+		_pud = pud_mkdirty(_pud);</span>
 	if (pudp_set_access_flags(vma, addr &amp; HPAGE_PUD_MASK,
<span class="p_del">-				pud, _pud,  1))</span>
<span class="p_add">+				pud, _pud, flags &amp; FOLL_WRITE))</span>
 		update_mmu_cache_pud(vma, addr, pud);
 }
 
<span class="p_chunk">@@ -1031,7 +1021,7 @@</span> <span class="p_context"> struct page *follow_devmap_pud(struct vm_area_struct *vma, unsigned long addr,</span>
 		return NULL;
 
 	if (flags &amp; FOLL_TOUCH)
<span class="p_del">-		touch_pud(vma, addr, pud);</span>
<span class="p_add">+		touch_pud(vma, addr, pud, flags);</span>
 
 	/*
 	 * device mapped pages can only be returned if the
<span class="p_chunk">@@ -1407,7 +1397,7 @@</span> <span class="p_context"> struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,</span>
 	page = pmd_page(*pmd);
 	VM_BUG_ON_PAGE(!PageHead(page) &amp;&amp; !is_zone_device_page(page), page);
 	if (flags &amp; FOLL_TOUCH)
<span class="p_del">-		touch_pmd(vma, addr, pmd);</span>
<span class="p_add">+		touch_pmd(vma, addr, pmd, flags);</span>
 	if ((flags &amp; FOLL_MLOCK) &amp;&amp; (vma-&gt;vm_flags &amp; VM_LOCKED)) {
 		/*
 		 * We don&#39;t mlock() pte-mapped THPs. This way we can avoid
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 2d2ff5e8bf2b..c539941671b4 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -3125,6 +3125,13 @@</span> <span class="p_context"> static void hugetlb_vm_op_close(struct vm_area_struct *vma)</span>
 	}
 }
 
<span class="p_add">+static int hugetlb_vm_op_split(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (addr &amp; ~(huge_page_mask(hstate_vma(vma))))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * We cannot handle pagefaults against hugetlb pages at all.  They cause
  * handle_mm_fault() to try to instantiate regular-sized pages in the
<span class="p_chunk">@@ -3141,6 +3148,7 @@</span> <span class="p_context"> const struct vm_operations_struct hugetlb_vm_ops = {</span>
 	.fault = hugetlb_vm_op_fault,
 	.open = hugetlb_vm_op_open,
 	.close = hugetlb_vm_op_close,
<span class="p_add">+	.split = hugetlb_vm_op_split,</span>
 };
 
 static pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,
<span class="p_chunk">@@ -4617,7 +4625,9 @@</span> <span class="p_context"> pte_t *huge_pte_alloc(struct mm_struct *mm,</span>
 	pte_t *pte = NULL;
 
 	pgd = pgd_offset(mm, addr);
<span class="p_del">-	p4d = p4d_offset(pgd, addr);</span>
<span class="p_add">+	p4d = p4d_alloc(mm, pgd, addr);</span>
<span class="p_add">+	if (!p4d)</span>
<span class="p_add">+		return NULL;</span>
 	pud = pud_alloc(mm, p4d, addr);
 	if (pud) {
 		if (sz == PUD_SIZE) {
<span class="p_header">diff --git a/mm/madvise.c b/mm/madvise.c</span>
<span class="p_header">index 375cf32087e4..751e97aa2210 100644</span>
<span class="p_header">--- a/mm/madvise.c</span>
<span class="p_header">+++ b/mm/madvise.c</span>
<span class="p_chunk">@@ -276,15 +276,14 @@</span> <span class="p_context"> static long madvise_willneed(struct vm_area_struct *vma,</span>
 {
 	struct file *file = vma-&gt;vm_file;
 
<span class="p_add">+	*prev = vma;</span>
 #ifdef CONFIG_SWAP
 	if (!file) {
<span class="p_del">-		*prev = vma;</span>
 		force_swapin_readahead(vma, start, end);
 		return 0;
 	}
 
 	if (shmem_mapping(file-&gt;f_mapping)) {
<span class="p_del">-		*prev = vma;</span>
 		force_shm_swapin_readahead(vma, start, end,
 					file-&gt;f_mapping);
 		return 0;
<span class="p_chunk">@@ -299,7 +298,6 @@</span> <span class="p_context"> static long madvise_willneed(struct vm_area_struct *vma,</span>
 		return 0;
 	}
 
<span class="p_del">-	*prev = vma;</span>
 	start = ((start - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;
 	if (end &gt; vma-&gt;vm_end)
 		end = vma-&gt;vm_end;
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 661f046ad318..53f7c919b916 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -6044,7 +6044,7 @@</span> <span class="p_context"> void mem_cgroup_swapout(struct page *page, swp_entry_t entry)</span>
 	memcg_check_events(memcg, page);
 
 	if (!mem_cgroup_is_root(memcg))
<span class="p_del">-		css_put(&amp;memcg-&gt;css);</span>
<span class="p_add">+		css_put_many(&amp;memcg-&gt;css, nr_entries);</span>
 }
 
 /**
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index 680506faceae..476e810cf100 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -2540,9 +2540,11 @@</span> <span class="p_context"> int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	struct vm_area_struct *new;
 	int err;
 
<span class="p_del">-	if (is_vm_hugetlb_page(vma) &amp;&amp; (addr &amp;</span>
<span class="p_del">-					~(huge_page_mask(hstate_vma(vma)))))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;split) {</span>
<span class="p_add">+		err = vma-&gt;vm_ops-&gt;split(vma, addr);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
 
 	new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
 	if (!new)
<span class="p_header">diff --git a/mm/oom_kill.c b/mm/oom_kill.c</span>
<span class="p_header">index dee0f75c3013..18c5b356b505 100644</span>
<span class="p_header">--- a/mm/oom_kill.c</span>
<span class="p_header">+++ b/mm/oom_kill.c</span>
<span class="p_chunk">@@ -532,7 +532,6 @@</span> <span class="p_context"> static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)</span>
 	 */
 	set_bit(MMF_UNSTABLE, &amp;mm-&gt;flags);
 
<span class="p_del">-	tlb_gather_mmu(&amp;tlb, mm, 0, -1);</span>
 	for (vma = mm-&gt;mmap ; vma; vma = vma-&gt;vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;
<span class="p_chunk">@@ -547,11 +546,13 @@</span> <span class="p_context"> static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)</span>
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
<span class="p_del">-		if (vma_is_anonymous(vma) || !(vma-&gt;vm_flags &amp; VM_SHARED))</span>
<span class="p_add">+		if (vma_is_anonymous(vma) || !(vma-&gt;vm_flags &amp; VM_SHARED)) {</span>
<span class="p_add">+			tlb_gather_mmu(&amp;tlb, mm, vma-&gt;vm_start, vma-&gt;vm_end);</span>
 			unmap_page_range(&amp;tlb, vma, vma-&gt;vm_start, vma-&gt;vm_end,
 					 NULL);
<span class="p_add">+			tlb_finish_mmu(&amp;tlb, vma-&gt;vm_start, vma-&gt;vm_end);</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-	tlb_finish_mmu(&amp;tlb, 0, -1);</span>
 	pr_info(&quot;oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n&quot;,
 			task_pid_nr(tsk), tsk-&gt;comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 82a6270c9743..d51c2087c498 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -2487,10 +2487,6 @@</span> <span class="p_context"> void drain_all_pages(struct zone *zone)</span>
 	if (WARN_ON_ONCE(!mm_percpu_wq))
 		return;
 
<span class="p_del">-	/* Workqueues cannot recurse */</span>
<span class="p_del">-	if (current-&gt;flags &amp; PF_WQ_WORKER)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	/*
 	 * Do not drain if one is already in progress unless it&#39;s specific to
 	 * a zone. Such callers are primarily CMA and memory hotplug and need
<span class="p_chunk">@@ -7591,11 +7587,18 @@</span> <span class="p_context"> int alloc_contig_range(unsigned long start, unsigned long end,</span>
 
 	/*
 	 * In case of -EBUSY, we&#39;d like to know which page causes problem.
<span class="p_del">-	 * So, just fall through. We will check it in test_pages_isolated().</span>
<span class="p_add">+	 * So, just fall through. test_pages_isolated() has a tracepoint</span>
<span class="p_add">+	 * which will report the busy page.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * It is possible that busy pages could become available before</span>
<span class="p_add">+	 * the call to test_pages_isolated, and the range will actually be</span>
<span class="p_add">+	 * allocated.  So, if we fall through be sure to clear ret so that</span>
<span class="p_add">+	 * -EBUSY is not accidentally used or returned to caller.</span>
 	 */
 	ret = __alloc_contig_migrate_range(&amp;cc, start, end);
 	if (ret &amp;&amp; ret != -EBUSY)
 		goto done;
<span class="p_add">+	ret =0;</span>
 
 	/*
 	 * Pages from [start, end) are within a MAX_ORDER_NR_PAGES
<span class="p_header">diff --git a/security/apparmor/include/audit.h b/security/apparmor/include/audit.h</span>
<span class="p_header">index 620e81169659..4ac095118717 100644</span>
<span class="p_header">--- a/security/apparmor/include/audit.h</span>
<span class="p_header">+++ b/security/apparmor/include/audit.h</span>
<span class="p_chunk">@@ -121,17 +121,19 @@</span> <span class="p_context"> struct apparmor_audit_data {</span>
 		/* these entries require a custom callback fn */
 		struct {
 			struct aa_label *peer;
<span class="p_del">-			struct {</span>
<span class="p_del">-				const char *target;</span>
<span class="p_del">-				kuid_t ouid;</span>
<span class="p_del">-			} fs;</span>
<span class="p_add">+			union {</span>
<span class="p_add">+				struct {</span>
<span class="p_add">+					const char *target;</span>
<span class="p_add">+					kuid_t ouid;</span>
<span class="p_add">+				} fs;</span>
<span class="p_add">+				int signal;</span>
<span class="p_add">+			};</span>
 		};
 		struct {
 			struct aa_profile *profile;
 			const char *ns;
 			long pos;
 		} iface;
<span class="p_del">-		int signal;</span>
 		struct {
 			int rlim;
 			unsigned long max;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



