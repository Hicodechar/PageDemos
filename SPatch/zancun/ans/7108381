
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.19.y-ckt,stable] Linux 3.19.8-ckt6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.19.y-ckt,stable] Linux 3.19.8-ckt6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 2, 2015, 1:41 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1441158074-26243-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7108381/mbox/"
   >mbox</a>
|
   <a href="/patch/7108381/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7108381/">/patch/7108381/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 6744B9F1CD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Sep 2015 01:42:06 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 9E777205F2
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Sep 2015 01:41:56 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id AFCBC205C4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Sep 2015 01:41:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752536AbbIBBli (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 1 Sep 2015 21:41:38 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:53075 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751561AbbIBBlV (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 1 Sep 2015 21:41:21 -0400
Received: from 1.general.kamal.us.vpn ([10.172.68.52] helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:DHE_RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1ZWx38-0003rx-KP; Wed, 02 Sep 2015 01:41:19 +0000
Received: from kamal by fourier with local (Exim 4.82)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1ZWx36-0006q5-CQ; Tue, 01 Sep 2015 18:41:16 -0700
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.19.y-ckt stable] Linux 3.19.8-ckt6
Date: Tue,  1 Sep 2015 18:41:14 -0700
Message-Id: &lt;1441158074-26243-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1441158074-26243-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1441158074-26243-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 3.19
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - Sept. 2, 2015, 1:41 a.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index b8ee707..535f2bd 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 19
 SUBLEVEL = 8
<span class="p_del">-EXTRAVERSION = -ckt5</span>
<span class="p_add">+EXTRAVERSION = -ckt6</span>
 NAME = Sedated Swine
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arm/boot/dts/imx35.dtsi b/arch/arm/boot/dts/imx35.dtsi</span>
<span class="p_header">index 6932928..667eb6a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx35.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx35.dtsi</span>
<span class="p_chunk">@@ -286,8 +286,8 @@</span> <span class="p_context"></span>
 			can1: can@53fe4000 {
 				compatible = &quot;fsl,imx35-flexcan&quot;, &quot;fsl,p1010-flexcan&quot;;
 				reg = &lt;0x53fe4000 0x1000&gt;;
<span class="p_del">-				clocks = &lt;&amp;clks 33&gt;;</span>
<span class="p_del">-				clock-names = &quot;ipg&quot;;</span>
<span class="p_add">+				clocks = &lt;&amp;clks 33&gt;, &lt;&amp;clks 33&gt;;</span>
<span class="p_add">+				clock-names = &quot;ipg&quot;, &quot;per&quot;;</span>
 				interrupts = &lt;43&gt;;
 				status = &quot;disabled&quot;;
 			};
<span class="p_chunk">@@ -295,8 +295,8 @@</span> <span class="p_context"></span>
 			can2: can@53fe8000 {
 				compatible = &quot;fsl,imx35-flexcan&quot;, &quot;fsl,p1010-flexcan&quot;;
 				reg = &lt;0x53fe8000 0x1000&gt;;
<span class="p_del">-				clocks = &lt;&amp;clks 34&gt;;</span>
<span class="p_del">-				clock-names = &quot;ipg&quot;;</span>
<span class="p_add">+				clocks = &lt;&amp;clks 34&gt;, &lt;&amp;clks 34&gt;;</span>
<span class="p_add">+				clock-names = &quot;ipg&quot;, &quot;per&quot;;</span>
 				interrupts = &lt;44&gt;;
 				status = &quot;disabled&quot;;
 			};
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">index 9025fff..bcb39fb 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_chunk">@@ -2368,6 +2368,9 @@</span> <span class="p_context"> static int of_dev_hwmod_lookup(struct device_node *np,</span>
  * registers.  This address is needed early so the OCP registers that
  * are part of the device&#39;s address space can be ioremapped properly.
  *
<span class="p_add">+ * If SYSC access is not needed, the registers will not be remapped</span>
<span class="p_add">+ * and non-availability of MPU access is not treated as an error.</span>
<span class="p_add">+ *</span>
  * Returns 0 on success, -EINVAL if an invalid hwmod is passed, and
  * -ENXIO on absent or invalid register target address space.
  */
<span class="p_chunk">@@ -2382,6 +2385,11 @@</span> <span class="p_context"> static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,</span>
 
 	_save_mpu_port_index(oh);
 
<span class="p_add">+	/* if we don&#39;t need sysc access we don&#39;t need to ioremap */</span>
<span class="p_add">+	if (!oh-&gt;class-&gt;sysc)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* we can&#39;t continue without MPU PORT if we need sysc access */</span>
 	if (oh-&gt;_int_flags &amp; _HWMOD_NO_MPU_PORT)
 		return -ENXIO;
 
<span class="p_chunk">@@ -2391,8 +2399,10 @@</span> <span class="p_context"> static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,</span>
 			 oh-&gt;name);
 
 		/* Extract the IO space from device tree blob */
<span class="p_del">-		if (!np)</span>
<span class="p_add">+		if (!np) {</span>
<span class="p_add">+			pr_err(&quot;omap_hwmod: %s: no dt node\n&quot;, oh-&gt;name);</span>
 			return -ENXIO;
<span class="p_add">+		}</span>
 
 		va_start = of_iomap(np, index + oh-&gt;mpu_rt_idx);
 	} else {
<span class="p_chunk">@@ -2451,13 +2461,11 @@</span> <span class="p_context"> static int __init _init(struct omap_hwmod *oh, void *data)</span>
 				oh-&gt;name, np-&gt;name);
 	}
 
<span class="p_del">-	if (oh-&gt;class-&gt;sysc) {</span>
<span class="p_del">-		r = _init_mpu_rt_base(oh, NULL, index, np);</span>
<span class="p_del">-		if (r &lt; 0) {</span>
<span class="p_del">-			WARN(1, &quot;omap_hwmod: %s: doesn&#39;t have mpu register target base\n&quot;,</span>
<span class="p_del">-			     oh-&gt;name);</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	r = _init_mpu_rt_base(oh, NULL, index, np);</span>
<span class="p_add">+	if (r &lt; 0) {</span>
<span class="p_add">+		WARN(1, &quot;omap_hwmod: %s: doesn&#39;t have mpu register target base\n&quot;,</span>
<span class="p_add">+		     oh-&gt;name);</span>
<span class="p_add">+		return 0;</span>
 	}
 
 	r = _init_clocks(oh, NULL);
<span class="p_header">diff --git a/arch/arm64/kernel/efi.c b/arch/arm64/kernel/efi.c</span>
<span class="p_header">index 2bb4347..dabc3f1 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/efi.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/efi.c</span>
<span class="p_chunk">@@ -100,12 +100,12 @@</span> <span class="p_context"> static int __init uefi_init(void)</span>
 
 	/* Show what we know for posterity */
 	c16 = early_memremap(efi.systab-&gt;fw_vendor,
<span class="p_del">-			     sizeof(vendor));</span>
<span class="p_add">+			     sizeof(vendor) * sizeof(efi_char16_t));</span>
 	if (c16) {
 		for (i = 0; i &lt; (int) sizeof(vendor) - 1 &amp;&amp; *c16; ++i)
 			vendor[i] = c16[i];
 		vendor[i] = &#39;\0&#39;;
<span class="p_del">-		early_memunmap(c16, sizeof(vendor));</span>
<span class="p_add">+		early_memunmap(c16, sizeof(vendor) * sizeof(efi_char16_t));</span>
 	}
 
 	pr_info(&quot;EFI v%u.%.02u by %s\n&quot;,
<span class="p_header">diff --git a/arch/avr32/mach-at32ap/clock.c b/arch/avr32/mach-at32ap/clock.c</span>
<span class="p_header">index 23b1a97..52c179b 100644</span>
<span class="p_header">--- a/arch/avr32/mach-at32ap/clock.c</span>
<span class="p_header">+++ b/arch/avr32/mach-at32ap/clock.c</span>
<span class="p_chunk">@@ -80,6 +80,9 @@</span> <span class="p_context"> int clk_enable(struct clk *clk)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;clk_lock, flags);
 	__clk_enable(clk);
 	spin_unlock_irqrestore(&amp;clk_lock, flags);
<span class="p_chunk">@@ -106,6 +109,9 @@</span> <span class="p_context"> void clk_disable(struct clk *clk)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (IS_ERR_OR_NULL(clk))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;clk_lock, flags);
 	__clk_disable(clk);
 	spin_unlock_irqrestore(&amp;clk_lock, flags);
<span class="p_chunk">@@ -117,6 +123,9 @@</span> <span class="p_context"> unsigned long clk_get_rate(struct clk *clk)</span>
 	unsigned long flags;
 	unsigned long rate;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;clk_lock, flags);
 	rate = clk-&gt;get_rate(clk);
 	spin_unlock_irqrestore(&amp;clk_lock, flags);
<span class="p_chunk">@@ -129,6 +138,9 @@</span> <span class="p_context"> long clk_round_rate(struct clk *clk, unsigned long rate)</span>
 {
 	unsigned long flags, actual_rate;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!clk-&gt;set_rate)
 		return -ENOSYS;
 
<span class="p_chunk">@@ -145,6 +157,9 @@</span> <span class="p_context"> int clk_set_rate(struct clk *clk, unsigned long rate)</span>
 	unsigned long flags;
 	long ret;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!clk-&gt;set_rate)
 		return -ENOSYS;
 
<span class="p_chunk">@@ -161,6 +176,9 @@</span> <span class="p_context"> int clk_set_parent(struct clk *clk, struct clk *parent)</span>
 	unsigned long flags;
 	int ret;
 
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!clk-&gt;set_parent)
 		return -ENOSYS;
 
<span class="p_chunk">@@ -174,7 +192,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(clk_set_parent);</span>
 
 struct clk *clk_get_parent(struct clk *clk)
 {
<span class="p_del">-	return clk-&gt;parent;</span>
<span class="p_add">+	return !clk ? NULL : clk-&gt;parent;</span>
 }
 EXPORT_SYMBOL(clk_get_parent);
 
<span class="p_header">diff --git a/arch/tile/kernel/setup.c b/arch/tile/kernel/setup.c</span>
<span class="p_header">index 864eea6..55d5982 100644</span>
<span class="p_header">--- a/arch/tile/kernel/setup.c</span>
<span class="p_header">+++ b/arch/tile/kernel/setup.c</span>
<span class="p_chunk">@@ -1139,7 +1139,7 @@</span> <span class="p_context"> static void __init load_hv_initrd(void)</span>
 
 void __init free_initrd_mem(unsigned long begin, unsigned long end)
 {
<span class="p_del">-	free_bootmem(__pa(begin), end - begin);</span>
<span class="p_add">+	free_bootmem_late(__pa(begin), end - begin);</span>
 }
 
 static int __init setup_initrd(char *str)
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">index 5999980..b451033 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_chunk">@@ -1194,6 +1194,10 @@</span> <span class="p_context"> static efi_status_t setup_e820(struct boot_params *params,</span>
 		unsigned int e820_type = 0;
 		unsigned long m = efi-&gt;efi_memmap;
 
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+		m |= (u64)efi-&gt;efi_memmap_hi &lt;&lt; 32;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 		d = (efi_memory_desc_t *)(m + (i * efi-&gt;efi_memdesc_size));
 		switch (d-&gt;type) {
 		case EFI_RESERVED_TYPE:
<span class="p_header">diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c</span>
<span class="p_header">index df4552b..2e0b964 100644</span>
<span class="p_header">--- a/arch/x86/mm/mmap.c</span>
<span class="p_header">+++ b/arch/x86/mm/mmap.c</span>
<span class="p_chunk">@@ -122,3 +122,10 @@</span> <span class="p_context"> void arch_pick_mmap_layout(struct mm_struct *mm)</span>
 		mm-&gt;get_unmapped_area = arch_get_unmapped_area_topdown;
 	}
 }
<span class="p_add">+</span>
<span class="p_add">+const char *arch_vma_name(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_MPX)</span>
<span class="p_add">+		return &quot;[mpx]&quot;;</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/mm/mpx.c b/arch/x86/mm/mpx.c</span>
<span class="p_header">index c439ec4..4d1c11c 100644</span>
<span class="p_header">--- a/arch/x86/mm/mpx.c</span>
<span class="p_header">+++ b/arch/x86/mm/mpx.c</span>
<span class="p_chunk">@@ -18,26 +18,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/processor.h&gt;
 #include &lt;asm/fpu-internal.h&gt;
 
<span class="p_del">-static const char *mpx_mapping_name(struct vm_area_struct *vma)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return &quot;[mpx]&quot;;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct vm_operations_struct mpx_vma_ops = {</span>
<span class="p_del">-	.name = mpx_mapping_name,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static int is_mpx_vma(struct vm_area_struct *vma)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_ops == &amp;mpx_vma_ops);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * This is really a simplified &quot;vm_mmap&quot;. it only handles MPX
  * bounds tables (the bounds directory is user-allocated).
<span class="p_del">- *</span>
<span class="p_del">- * Later on, we use the vma-&gt;vm_ops to uniquely identify these</span>
<span class="p_del">- * VMAs.</span>
  */
 static unsigned long mpx_mmap(unsigned long len)
 {
<span class="p_chunk">@@ -83,7 +66,6 @@</span> <span class="p_context"> static unsigned long mpx_mmap(unsigned long len)</span>
 		ret = -ENOMEM;
 		goto out;
 	}
<span class="p_del">-	vma-&gt;vm_ops = &amp;mpx_vma_ops;</span>
 
 	if (vm_flags &amp; VM_LOCKED) {
 		up_write(&amp;mm-&gt;mmap_sem);
<span class="p_chunk">@@ -661,7 +643,7 @@</span> <span class="p_context"> static int zap_bt_entries(struct mm_struct *mm,</span>
 		 * so stop immediately and return an error.  This
 		 * probably results in a SIGSEGV.
 		 */
<span class="p_del">-		if (!is_mpx_vma(vma))</span>
<span class="p_add">+		if (!(vma-&gt;vm_flags &amp; VM_MPX))</span>
 			return -EINVAL;
 
 		len = min(vma-&gt;vm_end, end) - addr;
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index ee61c36..020bcc7 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> static void flush_tlb_func(void *info)</span>
 		} else {
 			unsigned long addr;
 			unsigned long nr_pages =
<span class="p_del">-				f-&gt;flush_end - f-&gt;flush_start / PAGE_SIZE;</span>
<span class="p_add">+				(f-&gt;flush_end - f-&gt;flush_start) / PAGE_SIZE;</span>
 			addr = f-&gt;flush_start;
 			while (addr &lt; f-&gt;flush_end) {
 				__flush_tlb_single(addr);
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index dbc8627..e752f79 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -937,6 +937,11 @@</span> <span class="p_context"> u64 efi_mem_attributes(unsigned long phys_addr)</span>
 
 static int __init arch_parse_efi_cmdline(char *str)
 {
<span class="p_add">+	if (!str) {</span>
<span class="p_add">+		pr_warn(&quot;need at least one option\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (parse_option_str(str, &quot;old_map&quot;))
 		set_bit(EFI_OLD_MEMMAP, &amp;efi.flags);
 
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index 78a881b..f94ad30 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -483,6 +483,7 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 	pte_t pte;
 	unsigned long pfn;
 	struct page *page;
<span class="p_add">+	unsigned char dummy;</span>
 
 	ptep = lookup_address((unsigned long)v, &amp;level);
 	BUG_ON(ptep == NULL);
<span class="p_chunk">@@ -492,6 +493,32 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 
 	pte = pfn_pte(pfn, prot);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Careful: update_va_mapping() will fail if the virtual address</span>
<span class="p_add">+	 * we&#39;re poking isn&#39;t populated in the page tables.  We don&#39;t</span>
<span class="p_add">+	 * need to worry about the direct map (that&#39;s always in the page</span>
<span class="p_add">+	 * tables), but we need to be careful about vmap space.  In</span>
<span class="p_add">+	 * particular, the top level page table can lazily propagate</span>
<span class="p_add">+	 * entries between processes, so if we&#39;ve switched mms since we</span>
<span class="p_add">+	 * vmapped the target in the first place, we might not have the</span>
<span class="p_add">+	 * top-level page table entry populated.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We disable preemption because we want the same mm active when</span>
<span class="p_add">+	 * we probe the target and when we issue the hypercall.  We&#39;ll</span>
<span class="p_add">+	 * have the same nominal mm, but if we&#39;re a kernel thread, lazy</span>
<span class="p_add">+	 * mm dropping could change our pgd.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Out of an abundance of caution, this uses __get_user() to fault</span>
<span class="p_add">+	 * in the target address just in case there&#39;s some obscure case</span>
<span class="p_add">+	 * in which the target address isn&#39;t readable.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	pagefault_disable();	/* Avoid warnings due to being atomic. */</span>
<span class="p_add">+	__get_user(dummy, (unsigned char __user __force *)v);</span>
<span class="p_add">+	pagefault_enable();</span>
<span class="p_add">+</span>
 	if (HYPERVISOR_update_va_mapping((unsigned long)v, pte, 0))
 		BUG();
 
<span class="p_chunk">@@ -503,6 +530,8 @@</span> <span class="p_context"> static void set_aliased_prot(void *v, pgprot_t prot)</span>
 				BUG();
 	} else
 		kmap_flush_unused();
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
 }
 
 static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)
<span class="p_chunk">@@ -510,6 +539,17 @@</span> <span class="p_context"> static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)</span>
 	const unsigned entries_per_page = PAGE_SIZE / LDT_ENTRY_SIZE;
 	int i;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to mark the all aliases of the LDT pages RO.  We</span>
<span class="p_add">+	 * don&#39;t need to call vm_flush_aliases(), though, since that&#39;s</span>
<span class="p_add">+	 * only responsible for flushing aliases out the TLBs, not the</span>
<span class="p_add">+	 * page tables, and Xen will flush the TLB for us if needed.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * To avoid confusing future readers: none of this is necessary</span>
<span class="p_add">+	 * to load the LDT.  The hypervisor only checks this when the</span>
<span class="p_add">+	 * LDT is faulted in due to subsequent descriptor access.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	for(i = 0; i &lt; entries; i += entries_per_page)
 		set_aliased_prot(ldt + i, PAGE_KERNEL_RO);
 }
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index 471d738..dae3483 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -1858,8 +1858,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(bio_endio_nodec);</span>
  * Allocates and returns a new bio which represents @sectors from the start of
  * @bio, and updates @bio to represent the remaining sectors.
  *
<span class="p_del">- * The newly allocated bio will point to @bio&#39;s bi_io_vec; it is the caller&#39;s</span>
<span class="p_del">- * responsibility to ensure that @bio is not freed before the split.</span>
<span class="p_add">+ * Unless this is a discard request the newly allocated bio will point</span>
<span class="p_add">+ * to @bio&#39;s bi_io_vec; it is the caller&#39;s responsibility to ensure that</span>
<span class="p_add">+ * @bio is not freed before the split.</span>
  */
 struct bio *bio_split(struct bio *bio, int sectors,
 		      gfp_t gfp, struct bio_set *bs)
<span class="p_chunk">@@ -1869,7 +1870,15 @@</span> <span class="p_context"> struct bio *bio_split(struct bio *bio, int sectors,</span>
 	BUG_ON(sectors &lt;= 0);
 	BUG_ON(sectors &gt;= bio_sectors(bio));
 
<span class="p_del">-	split = bio_clone_fast(bio, gfp, bs);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Discards need a mutable bio_vec to accommodate the payload</span>
<span class="p_add">+	 * required by the DSM TRIM and UNMAP commands.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bio-&gt;bi_rw &amp; REQ_DISCARD)</span>
<span class="p_add">+		split = bio_clone_bioset(bio, gfp, bs);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		split = bio_clone_fast(bio, gfp, bs);</span>
<span class="p_add">+</span>
 	if (!split)
 		return NULL;
 
<span class="p_header">diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c</span>
<span class="p_header">index 0ac817b..6817e28 100644</span>
<span class="p_header">--- a/block/blk-cgroup.c</span>
<span class="p_header">+++ b/block/blk-cgroup.c</span>
<span class="p_chunk">@@ -716,8 +716,12 @@</span> <span class="p_context"> int blkg_conf_prep(struct blkcg *blkcg, const struct blkcg_policy *pol,</span>
 		return -EINVAL;
 
 	disk = get_gendisk(MKDEV(major, minor), &amp;part);
<span class="p_del">-	if (!disk || part)</span>
<span class="p_add">+	if (!disk)</span>
 		return -EINVAL;
<span class="p_add">+	if (part) {</span>
<span class="p_add">+		put_disk(disk);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
 
 	rcu_read_lock();
 	spin_lock_irq(disk-&gt;queue-&gt;queue_lock);
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index 0f762ab..da7d05e 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -2486,6 +2486,10 @@</span> <span class="p_context"> int ata_dev_configure(struct ata_device *dev)</span>
 		dev-&gt;max_sectors = min_t(unsigned int, ATA_MAX_SECTORS_128,
 					 dev-&gt;max_sectors);
 
<span class="p_add">+	if (dev-&gt;horkage &amp; ATA_HORKAGE_MAX_SEC_1024)</span>
<span class="p_add">+		dev-&gt;max_sectors = min_t(unsigned int, ATA_MAX_SECTORS_1024,</span>
<span class="p_add">+					 dev-&gt;max_sectors);</span>
<span class="p_add">+</span>
 	if (dev-&gt;horkage &amp; ATA_HORKAGE_MAX_SEC_LBA48)
 		dev-&gt;max_sectors = ATA_MAX_SECTORS_LBA48;
 
<span class="p_chunk">@@ -4154,6 +4158,12 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;Slimtype DVD A  DS8A8SH&quot;, NULL,	ATA_HORKAGE_MAX_SEC_LBA48 },
 	{ &quot;Slimtype DVD A  DS8A9SH&quot;, NULL,	ATA_HORKAGE_MAX_SEC_LBA48 },
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Causes silent data corruption with higher max sects.</span>
<span class="p_add">+	 * http://lkml.kernel.org/g/x49wpy40ysk.fsf@segfault.boston.devel.redhat.com</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{ &quot;ST380013AS&quot;,		&quot;3.20&quot;,		ATA_HORKAGE_MAX_SEC_1024 },</span>
<span class="p_add">+</span>
 	/* Devices we expect to fail diagnostics */
 
 	/* Devices where NCQ should be avoided */
<span class="p_chunk">@@ -4182,9 +4192,10 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;ST3320[68]13AS&quot;,	&quot;SD1[5-9]&quot;,	ATA_HORKAGE_NONCQ |
 						ATA_HORKAGE_FIRMWARE_WARN },
 
<span class="p_del">-	/* Seagate Momentus SpinPoint M8 seem to have FPMDA_AA issues */</span>
<span class="p_add">+	/* drives which fail FPDMA_AA activation (some may freeze afterwards) */</span>
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2AR10001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2BA30001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
<span class="p_add">+	{ &quot;VB0250EAVER&quot;,	&quot;HPG7&quot;,		ATA_HORKAGE_BROKEN_FPDMA_AA },</span>
 
 	/* Blacklist entries taken from Silicon Image 3124/3132
 	   Windows driver .inf file - also several Linux problem reports */
<span class="p_chunk">@@ -4237,7 +4248,7 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 	{ &quot;Crucial_CT*M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
<span class="p_del">-	{ &quot;Micron_M5[15]0*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
<span class="p_add">+	{ &quot;Micron_M5[15]0_*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 	{ &quot;Crucial_CT*M550*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM |
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
<span class="p_chunk">@@ -4246,6 +4257,9 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;Samsung SSD 8*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 
<span class="p_add">+	/* devices that don&#39;t properly handle TRIM commands */</span>
<span class="p_add">+	{ &quot;SuperSSpeed S238*&quot;,		NULL,	ATA_HORKAGE_NOTRIM, },</span>
<span class="p_add">+</span>
 	/*
 	 * As defined, the DRAT (Deterministic Read After Trim) and RZAT
 	 * (Return Zero After Trim) flags in the ATA Command Set are
<span class="p_chunk">@@ -4509,7 +4523,8 @@</span> <span class="p_context"> static unsigned int ata_dev_set_xfermode(struct ata_device *dev)</span>
 	else /* In the ancient relic department - skip all of this */
 		return 0;
 
<span class="p_del">-	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 0);</span>
<span class="p_add">+	/* On some disks, this command causes spin-up, so we need longer timeout */</span>
<span class="p_add">+	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 15000);</span>
 
 	DPRINTK(&quot;EXIT, err_mask=%x\n&quot;, err_mask);
 	return err_mask;
<span class="p_header">diff --git a/drivers/ata/libata-pmp.c b/drivers/ata/libata-pmp.c</span>
<span class="p_header">index 7ccc084..85aa761 100644</span>
<span class="p_header">--- a/drivers/ata/libata-pmp.c</span>
<span class="p_header">+++ b/drivers/ata/libata-pmp.c</span>
<span class="p_chunk">@@ -460,6 +460,13 @@</span> <span class="p_context"> static void sata_pmp_quirks(struct ata_port *ap)</span>
 				       ATA_LFLAG_NO_SRST |
 				       ATA_LFLAG_ASSUME_ATA;
 		}
<span class="p_add">+	} else if (vendor == 0x11ab &amp;&amp; devid == 0x4140) {</span>
<span class="p_add">+		/* Marvell 4140 quirks */</span>
<span class="p_add">+		ata_for_each_link(link, ap, EDGE) {</span>
<span class="p_add">+			/* port 4 is for SEMB device and it doesn&#39;t like SRST */</span>
<span class="p_add">+			if (link-&gt;pmp == 4)</span>
<span class="p_add">+				link-&gt;flags |= ATA_LFLAG_DISABLED;</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index 6abd17a..d13d49f 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -2531,7 +2531,8 @@</span> <span class="p_context"> static unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)</span>
 		rbuf[14] = (lowest_aligned &gt;&gt; 8) &amp; 0x3f;
 		rbuf[15] = lowest_aligned;
 
<span class="p_del">-		if (ata_id_has_trim(args-&gt;id)) {</span>
<span class="p_add">+		if (ata_id_has_trim(args-&gt;id) &amp;&amp;</span>
<span class="p_add">+		    !(dev-&gt;horkage &amp; ATA_HORKAGE_NOTRIM)) {</span>
 			rbuf[14] |= 0x80; /* LBPME */
 
 			if (ata_id_has_zero_after_trim(args-&gt;id) &amp;&amp;
<span class="p_header">diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.c</span>
<span class="p_header">index bdf40b5..c068ef1 100644</span>
<span class="p_header">--- a/drivers/dma/pl330.c</span>
<span class="p_header">+++ b/drivers/dma/pl330.c</span>
<span class="p_chunk">@@ -2521,6 +2521,7 @@</span> <span class="p_context"> pl330_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dst,</span>
 		desc-&gt;rqcfg.brst_len = 1;
 
 	desc-&gt;rqcfg.brst_len = get_burst_len(desc, len);
<span class="p_add">+	desc-&gt;bytes_requested = len;</span>
 
 	desc-&gt;txd.flags = flags;
 
<span class="p_header">diff --git a/drivers/firmware/efi/cper.c b/drivers/firmware/efi/cper.c</span>
<span class="p_header">index 4fd9961..d425374 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/cper.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/cper.c</span>
<span class="p_chunk">@@ -305,10 +305,17 @@</span> <span class="p_context"> const char *cper_mem_err_unpack(struct trace_seq *p,</span>
 	return ret;
 }
 
<span class="p_del">-static void cper_print_mem(const char *pfx, const struct cper_sec_mem_err *mem)</span>
<span class="p_add">+static void cper_print_mem(const char *pfx, const struct cper_sec_mem_err *mem,</span>
<span class="p_add">+	int len)</span>
 {
 	struct cper_mem_err_compact cmem;
 
<span class="p_add">+	/* Don&#39;t trust UEFI 2.1/2.2 structure with bad validation bits */</span>
<span class="p_add">+	if (len == sizeof(struct cper_sec_mem_err_old) &amp;&amp;</span>
<span class="p_add">+	    (mem-&gt;validation_bits &amp; ~(CPER_MEM_VALID_RANK_NUMBER - 1))) {</span>
<span class="p_add">+		pr_err(FW_WARN &quot;valid bits set for fields beyond structure\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	if (mem-&gt;validation_bits &amp; CPER_MEM_VALID_ERROR_STATUS)
 		printk(&quot;%s&quot;&quot;error_status: 0x%016llx\n&quot;, pfx, mem-&gt;error_status);
 	if (mem-&gt;validation_bits &amp; CPER_MEM_VALID_PA)
<span class="p_chunk">@@ -405,8 +412,10 @@</span> <span class="p_context"> static void cper_estatus_print_section(</span>
 	} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PLATFORM_MEM)) {
 		struct cper_sec_mem_err *mem_err = (void *)(gdata + 1);
 		printk(&quot;%s&quot;&quot;section_type: memory error\n&quot;, newpfx);
<span class="p_del">-		if (gdata-&gt;error_data_length &gt;= sizeof(*mem_err))</span>
<span class="p_del">-			cper_print_mem(newpfx, mem_err);</span>
<span class="p_add">+		if (gdata-&gt;error_data_length &gt;=</span>
<span class="p_add">+		    sizeof(struct cper_sec_mem_err_old))</span>
<span class="p_add">+			cper_print_mem(newpfx, mem_err,</span>
<span class="p_add">+				       gdata-&gt;error_data_length);</span>
 		else
 			goto err_section_too_small;
 	} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PCIE)) {
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index b1d7051..0ade9dc 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -57,6 +57,11 @@</span> <span class="p_context"> bool efi_runtime_disabled(void)</span>
 
 static int __init parse_efi_cmdline(char *str)
 {
<span class="p_add">+	if (!str) {</span>
<span class="p_add">+		pr_warn(&quot;need at least one option\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (parse_option_str(str, &quot;noruntime&quot;))
 		disable_runtime = true;
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index acb6e90..2d06f91 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -4821,12 +4821,9 @@</span> <span class="p_context"> void drm_mode_config_reset(struct drm_device *dev)</span>
 		if (encoder-&gt;funcs-&gt;reset)
 			encoder-&gt;funcs-&gt;reset(encoder);
 
<span class="p_del">-	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head) {</span>
<span class="p_del">-		connector-&gt;status = connector_status_unknown;</span>
<span class="p_del">-</span>
<span class="p_add">+	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head)</span>
 		if (connector-&gt;funcs-&gt;reset)
 			connector-&gt;funcs-&gt;reset(connector);
<span class="p_del">-	}</span>
 }
 EXPORT_SYMBOL(drm_mode_config_reset);
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index 44a3c38..46ef49b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -2996,15 +2996,14 @@</span> <span class="p_context"> int vlv_freq_opcode(struct drm_i915_private *dev_priv, int val);</span>
 #define I915_READ64(reg)	dev_priv-&gt;uncore.funcs.mmio_readq(dev_priv, (reg), true)
 
 #define I915_READ64_2x32(lower_reg, upper_reg) ({			\
<span class="p_del">-		u32 upper = I915_READ(upper_reg);			\</span>
<span class="p_del">-		u32 lower = I915_READ(lower_reg);			\</span>
<span class="p_del">-		u32 tmp = I915_READ(upper_reg);				\</span>
<span class="p_del">-		if (upper != tmp) {					\</span>
<span class="p_del">-			upper = tmp;					\</span>
<span class="p_del">-			lower = I915_READ(lower_reg);			\</span>
<span class="p_del">-			WARN_ON(I915_READ(upper_reg) != upper);		\</span>
<span class="p_del">-		}							\</span>
<span class="p_del">-		(u64)upper &lt;&lt; 32 | lower; })</span>
<span class="p_add">+	u32 upper, lower, tmp;						\</span>
<span class="p_add">+	tmp = I915_READ(upper_reg);					\</span>
<span class="p_add">+	do {								\</span>
<span class="p_add">+		upper = tmp;						\</span>
<span class="p_add">+		lower = I915_READ(lower_reg);				\</span>
<span class="p_add">+		tmp = I915_READ(upper_reg);				\</span>
<span class="p_add">+	} while (upper != tmp);						\</span>
<span class="p_add">+	(u64)upper &lt;&lt; 32 | lower; })</span>
 
 #define POSTING_READ(reg)	(void)I915_READ_NOTRACE(reg)
 #define POSTING_READ16(reg)	(void)I915_READ16_NOTRACE(reg)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_tiling.c b/drivers/gpu/drm/i915/i915_gem_tiling.c</span>
<span class="p_header">index ffe9072..c91d8aa 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_tiling.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_tiling.c</span>
<span class="p_chunk">@@ -464,7 +464,10 @@</span> <span class="p_context"> i915_gem_get_tiling(struct drm_device *dev, void *data,</span>
 	}
 
 	/* Hide bit 17 from the user -- see comment in i915_gem_set_tiling */
<span class="p_del">-	args-&gt;phys_swizzle_mode = args-&gt;swizzle_mode;</span>
<span class="p_add">+	if (dev_priv-&gt;quirks &amp; QUIRK_PIN_SWIZZLED_PAGES)</span>
<span class="p_add">+		args-&gt;phys_swizzle_mode = I915_BIT_6_SWIZZLE_UNKNOWN;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		args-&gt;phys_swizzle_mode = args-&gt;swizzle_mode;</span>
 	if (args-&gt;swizzle_mode == I915_BIT_6_SWIZZLE_9_17)
 		args-&gt;swizzle_mode = I915_BIT_6_SWIZZLE_9;
 	if (args-&gt;swizzle_mode == I915_BIT_6_SWIZZLE_9_10_17)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_uncore.c b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">index 46de8d7..5632611 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_chunk">@@ -1273,10 +1273,12 @@</span> <span class="p_context"> int i915_reg_read_ioctl(struct drm_device *dev,</span>
 	struct drm_i915_private *dev_priv = dev-&gt;dev_private;
 	struct drm_i915_reg_read *reg = data;
 	struct register_whitelist const *entry = whitelist;
<span class="p_add">+	unsigned size;</span>
<span class="p_add">+	u64 offset;</span>
 	int i, ret = 0;
 
 	for (i = 0; i &lt; ARRAY_SIZE(whitelist); i++, entry++) {
<span class="p_del">-		if (entry-&gt;offset == reg-&gt;offset &amp;&amp;</span>
<span class="p_add">+		if (entry-&gt;offset == (reg-&gt;offset &amp; -entry-&gt;size) &amp;&amp;</span>
 		    (1 &lt;&lt; INTEL_INFO(dev)-&gt;gen &amp; entry-&gt;gen_bitmask))
 			break;
 	}
<span class="p_chunk">@@ -1284,23 +1286,33 @@</span> <span class="p_context"> int i915_reg_read_ioctl(struct drm_device *dev,</span>
 	if (i == ARRAY_SIZE(whitelist))
 		return -EINVAL;
 
<span class="p_add">+	/* We use the low bits to encode extra flags as the register should</span>
<span class="p_add">+	 * be naturally aligned (and those that are not so aligned merely</span>
<span class="p_add">+	 * limit the available flags for that register).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	offset = entry-&gt;offset;</span>
<span class="p_add">+	size = entry-&gt;size;</span>
<span class="p_add">+	size |= reg-&gt;offset ^ offset;</span>
<span class="p_add">+</span>
 	intel_runtime_pm_get(dev_priv);
 
<span class="p_del">-	switch (entry-&gt;size) {</span>
<span class="p_add">+	switch (size) {</span>
<span class="p_add">+	case 8 | 1:</span>
<span class="p_add">+		reg-&gt;val = I915_READ64_2x32(offset, offset+4);</span>
<span class="p_add">+		break;</span>
 	case 8:
<span class="p_del">-		reg-&gt;val = I915_READ64(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ64(offset);</span>
 		break;
 	case 4:
<span class="p_del">-		reg-&gt;val = I915_READ(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ(offset);</span>
 		break;
 	case 2:
<span class="p_del">-		reg-&gt;val = I915_READ16(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ16(offset);</span>
 		break;
 	case 1:
<span class="p_del">-		reg-&gt;val = I915_READ8(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ8(offset);</span>
 		break;
 	default:
<span class="p_del">-		WARN_ON(1);</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv04_fbcon.c b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">index 4ef602c..495c576 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_chunk">@@ -203,7 +203,7 @@</span> <span class="p_context"> nv04_fbcon_accel_init(struct fb_info *info)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	if (RING_SPACE(chan, 49)) {</span>
<span class="p_add">+	if (RING_SPACE(chan, 49 + (device-&gt;info.chipset &gt;= 0x11 ? 4 : 0))) {</span>
 		nouveau_fbcon_gpu_lockup(info);
 		return 0;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">index 3e5f6b7..c097d3a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_chunk">@@ -1255,10 +1255,15 @@</span> <span class="p_context"> struct radeon_encoder_lvds *radeon_combios_get_lvds_info(struct radeon_encoder</span>
 
 			if ((RBIOS16(tmp) == lvds-&gt;native_mode.hdisplay) &amp;&amp;
 			    (RBIOS16(tmp + 2) == lvds-&gt;native_mode.vdisplay)) {
<span class="p_add">+				u32 hss = (RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (hss &gt; lvds-&gt;native_mode.hdisplay)</span>
<span class="p_add">+					hss = (10 - 1) * 8;</span>
<span class="p_add">+</span>
 				lvds-&gt;native_mode.htotal = lvds-&gt;native_mode.hdisplay +
 					(RBIOS16(tmp + 17) - RBIOS16(tmp + 19)) * 8;
 				lvds-&gt;native_mode.hsync_start = lvds-&gt;native_mode.hdisplay +
<span class="p_del">-					(RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;</span>
<span class="p_add">+					hss;</span>
 				lvds-&gt;native_mode.hsync_end = lvds-&gt;native_mode.hsync_start +
 					(RBIOS8(tmp + 23) * 8);
 
<span class="p_header">diff --git a/drivers/hid/hid-cp2112.c b/drivers/hid/hid-cp2112.c</span>
<span class="p_header">index 3318de6..a2dbbbe 100644</span>
<span class="p_header">--- a/drivers/hid/hid-cp2112.c</span>
<span class="p_header">+++ b/drivers/hid/hid-cp2112.c</span>
<span class="p_chunk">@@ -356,6 +356,8 @@</span> <span class="p_context"> static int cp2112_read(struct cp2112_device *dev, u8 *data, size_t size)</span>
 	struct cp2112_force_read_report report;
 	int ret;
 
<span class="p_add">+	if (size &gt; sizeof(dev-&gt;read_data))</span>
<span class="p_add">+		size = sizeof(dev-&gt;read_data);</span>
 	report.report = CP2112_DATA_READ_FORCE_SEND;
 	report.length = cpu_to_be16(size);
 
<span class="p_header">diff --git a/drivers/iio/adc/vf610_adc.c b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">index e63b8e7..60617ed 100644</span>
<span class="p_header">--- a/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_chunk">@@ -579,7 +579,7 @@</span> <span class="p_context"> static int vf610_adc_reg_access(struct iio_dev *indio_dev,</span>
 	struct vf610_adc *info = iio_priv(indio_dev);
 
 	if ((readval == NULL) ||
<span class="p_del">-		(!(reg % 4) || (reg &gt; VF610_REG_ADC_PCTL)))</span>
<span class="p_add">+		((reg % 4) || (reg &gt; VF610_REG_ADC_PCTL)))</span>
 		return -EINVAL;
 
 	*readval = readl(info-&gt;regs + reg);
<span class="p_header">diff --git a/drivers/input/touchscreen/usbtouchscreen.c b/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_header">index a096633..c6f7e91 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/usbtouchscreen.c</span>
<span class="p_chunk">@@ -625,6 +625,9 @@</span> <span class="p_context"> static int dmc_tsc10_init(struct usbtouch_usb *usbtouch)</span>
 		goto err_out;
 	}
 
<span class="p_add">+	/* TSC-25 data sheet specifies a delay after the RESET command */</span>
<span class="p_add">+	msleep(150);</span>
<span class="p_add">+</span>
 	/* set coordinate output rate */
 	buf[0] = buf[1] = 0xFF;
 	ret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 39b4dfd..0688303 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -1758,8 +1758,8 @@</span> <span class="p_context"> static int domain_init(struct dmar_domain *domain, int guest_width)</span>
 static void domain_exit(struct dmar_domain *domain)
 {
 	struct dmar_drhd_unit *drhd;
<span class="p_add">+	struct intel_iommu *iommu;</span>
 	struct page *freelist = NULL;
<span class="p_del">-	int i;</span>
 
 	/* Domain 0 is reserved, so dont process it */
 	if (!domain)
<span class="p_chunk">@@ -1779,8 +1779,10 @@</span> <span class="p_context"> static void domain_exit(struct dmar_domain *domain)</span>
 
 	/* clear attached or cached domains */
 	rcu_read_lock();
<span class="p_del">-	for_each_set_bit(i, domain-&gt;iommu_bmp, g_num_of_iommus)</span>
<span class="p_del">-		iommu_detach_domain(domain, g_iommus[i]);</span>
<span class="p_add">+	for_each_active_iommu(iommu, drhd)</span>
<span class="p_add">+		if (domain_type_is_vm(domain) ||</span>
<span class="p_add">+		    test_bit(iommu-&gt;seq_id, domain-&gt;iommu_bmp))</span>
<span class="p_add">+			iommu_detach_domain(domain, iommu);</span>
 	rcu_read_unlock();
 
 	dma_free_pagelist(freelist);
<span class="p_header">diff --git a/drivers/isdn/gigaset/ser-gigaset.c b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">index 8c91fd5..3ac9c41 100644</span>
<span class="p_header">--- a/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">+++ b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_chunk">@@ -524,9 +524,18 @@</span> <span class="p_context"> gigaset_tty_open(struct tty_struct *tty)</span>
 	cs-&gt;hw.ser-&gt;tty = tty;
 	atomic_set(&amp;cs-&gt;hw.ser-&gt;refcnt, 1);
 	init_completion(&amp;cs-&gt;hw.ser-&gt;dead_cmp);
<span class="p_del">-</span>
 	tty-&gt;disc_data = cs;
 
<span class="p_add">+	/* Set the amount of data we&#39;re willing to receive per call</span>
<span class="p_add">+	 * from the hardware driver to half of the input buffer size</span>
<span class="p_add">+	 * to leave some reserve.</span>
<span class="p_add">+	 * Note: We don&#39;t do flow control towards the hardware driver.</span>
<span class="p_add">+	 * If more data is received than will fit into the input buffer,</span>
<span class="p_add">+	 * it will be dropped and an error will be logged. This should</span>
<span class="p_add">+	 * never happen as the device is slow and the buffer size ample.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	tty-&gt;receive_room = RBUFSIZE/2;</span>
<span class="p_add">+</span>
 	/* OK.. Initialization of the datastructures and the HW is done.. Now
 	 * startup system and notify the LL that we are ready to run
 	 */
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 193feb9..a31e15b 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -5443,7 +5443,7 @@</span> <span class="p_context"> static int get_bitmap_file(struct mddev *mddev, void __user * arg)</span>
 	char *ptr, *buf = NULL;
 	int err = -ENOMEM;
 
<span class="p_del">-	file = kmalloc(sizeof(*file), GFP_NOIO);</span>
<span class="p_add">+	file = kzalloc(sizeof(*file), GFP_NOIO);</span>
 
 	if (!file)
 		goto out;
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 2f2f38f..8d9110f 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -336,7 +336,7 @@</span> <span class="p_context"> static void raid1_end_read_request(struct bio *bio, int error)</span>
 		spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);
 		if (r1_bio-&gt;mddev-&gt;degraded == conf-&gt;raid_disks ||
 		    (r1_bio-&gt;mddev-&gt;degraded == conf-&gt;raid_disks-1 &amp;&amp;
<span class="p_del">-		     !test_bit(Faulty, &amp;conf-&gt;mirrors[mirror].rdev-&gt;flags)))</span>
<span class="p_add">+		     test_bit(In_sync, &amp;conf-&gt;mirrors[mirror].rdev-&gt;flags)))</span>
 			uptodate = 1;
 		spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
 	}
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index 32e282f..17eb767 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -3581,6 +3581,7 @@</span> <span class="p_context"> static struct r10conf *setup_conf(struct mddev *mddev)</span>
 			/* far_copies must be 1 */
 			conf-&gt;prev.stride = conf-&gt;dev_sectors;
 	}
<span class="p_add">+	conf-&gt;reshape_safe = conf-&gt;reshape_progress;</span>
 	spin_lock_init(&amp;conf-&gt;device_lock);
 	INIT_LIST_HEAD(&amp;conf-&gt;retry_list);
 
<span class="p_chunk">@@ -3788,7 +3789,6 @@</span> <span class="p_context"> static int run(struct mddev *mddev)</span>
 		}
 		conf-&gt;offset_diff = min_offset_diff;
 
<span class="p_del">-		conf-&gt;reshape_safe = conf-&gt;reshape_progress;</span>
 		clear_bit(MD_RECOVERY_SYNC, &amp;mddev-&gt;recovery);
 		clear_bit(MD_RECOVERY_CHECK, &amp;mddev-&gt;recovery);
 		set_bit(MD_RECOVERY_RESHAPE, &amp;mddev-&gt;recovery);
<span class="p_chunk">@@ -4135,6 +4135,7 @@</span> <span class="p_context"> static int raid10_start_reshape(struct mddev *mddev)</span>
 		conf-&gt;reshape_progress = size;
 	} else
 		conf-&gt;reshape_progress = 0;
<span class="p_add">+	conf-&gt;reshape_safe = conf-&gt;reshape_progress;</span>
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
 
 	if (mddev-&gt;delta_disks &amp;&amp; mddev-&gt;bitmap) {
<span class="p_chunk">@@ -4201,6 +4202,7 @@</span> <span class="p_context"> abort:</span>
 		rdev-&gt;new_data_offset = rdev-&gt;data_offset;
 	smp_wmb();
 	conf-&gt;reshape_progress = MaxSector;
<span class="p_add">+	conf-&gt;reshape_safe = MaxSector;</span>
 	mddev-&gt;reshape_position = MaxSector;
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
 	return ret;
<span class="p_chunk">@@ -4555,6 +4557,7 @@</span> <span class="p_context"> static void end_reshape(struct r10conf *conf)</span>
 	md_finish_reshape(conf-&gt;mddev);
 	smp_wmb();
 	conf-&gt;reshape_progress = MaxSector;
<span class="p_add">+	conf-&gt;reshape_safe = MaxSector;</span>
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
 
 	/* read-ahead size must cover two whole stripes, which is
<span class="p_header">diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c</span>
<span class="p_header">index ae56ba6..f6b68e2 100644</span>
<span class="p_header">--- a/drivers/misc/mei/main.c</span>
<span class="p_header">+++ b/drivers/misc/mei/main.c</span>
<span class="p_chunk">@@ -738,7 +738,7 @@</span> <span class="p_context"> int mei_register(struct mei_device *dev, struct device *parent)</span>
 	/* Fill in the data structures */
 	devno = MKDEV(MAJOR(mei_devt), dev-&gt;minor);
 	cdev_init(&amp;dev-&gt;cdev, &amp;mei_fops);
<span class="p_del">-	dev-&gt;cdev.owner = mei_fops.owner;</span>
<span class="p_add">+	dev-&gt;cdev.owner = parent-&gt;driver-&gt;owner;</span>
 
 	/* Add the device */
 	ret = cdev_add(&amp;dev-&gt;cdev, devno, 1);
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index c972b97..28fb2ed 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -208,6 +208,8 @@</span> <span class="p_context"> static ssize_t power_ro_lock_show(struct device *dev,</span>
 
 	ret = snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, locked);
 
<span class="p_add">+	mmc_blk_put(md);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c</span>
<span class="p_header">index 7c71dcd..3357c83 100644</span>
<span class="p_header">--- a/drivers/mmc/host/omap_hsmmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/omap_hsmmc.c</span>
<span class="p_chunk">@@ -1129,6 +1129,10 @@</span> <span class="p_context"> static void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)</span>
 
 		if (status &amp; (CTO_EN | CCRC_EN))
 			end_cmd = 1;
<span class="p_add">+		if (host-&gt;data || host-&gt;response_busy) {</span>
<span class="p_add">+			end_trans = !end_cmd;</span>
<span class="p_add">+			host-&gt;response_busy = 0;</span>
<span class="p_add">+		}</span>
 		if (status &amp; (CTO_EN | DTO_EN))
 			hsmmc_command_incomplete(host, -ETIMEDOUT, end_cmd);
 		else if (status &amp; (CCRC_EN | DCRC_EN))
<span class="p_chunk">@@ -1148,10 +1152,6 @@</span> <span class="p_context"> static void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)</span>
 			}
 			dev_dbg(mmc_dev(host-&gt;mmc), &quot;AC12 err: 0x%x\n&quot;, ac12);
 		}
<span class="p_del">-		if (host-&gt;data || host-&gt;response_busy) {</span>
<span class="p_del">-			end_trans = !end_cmd;</span>
<span class="p_del">-			host-&gt;response_busy = 0;</span>
<span class="p_del">-		}</span>
 	}
 
 	OMAP_HSMMC_WRITE(host-&gt;base, STAT, status);
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h</span>
<span class="p_header">index 3497cfa..a870c42 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-esdhc.h</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-esdhc.h</span>
<span class="p_chunk">@@ -45,6 +45,6 @@</span> <span class="p_context"></span>
 #define ESDHC_DMA_SYSCTL	0x40c
 #define ESDHC_DMA_SNOOP		0x00000040
 
<span class="p_del">-#define ESDHC_HOST_CONTROL_RES	0x05</span>
<span class="p_add">+#define ESDHC_HOST_CONTROL_RES	0x01</span>
 
 #endif /* _DRIVERS_MMC_SDHCI_ESDHC_H */
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-pxav3.c b/drivers/mmc/host/sdhci-pxav3.c</span>
<span class="p_header">index e187f70..58c21b2 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-pxav3.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-pxav3.c</span>
<span class="p_chunk">@@ -369,6 +369,7 @@</span> <span class="p_context"> static int sdhci_pxav3_probe(struct platform_device *pdev)</span>
 			goto err_of_parse;
 		sdhci_get_of_property(pdev);
 		pdata = pxav3_get_mmc_pdata(dev);
<span class="p_add">+		pdev-&gt;dev.platform_data = pdata;</span>
 	} else if (pdata) {
 		/* on-chip device */
 		if (pdata-&gt;flags &amp; PXA_FLAG_CARD_PERMANENT)
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index 5c8b463..afb477a 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -2971,8 +2971,11 @@</span> <span class="p_context"> int sdhci_add_host(struct sdhci_host *host)</span>
 						      GFP_KERNEL);
 		host-&gt;align_buffer = kmalloc(host-&gt;align_buffer_sz, GFP_KERNEL);
 		if (!host-&gt;adma_table || !host-&gt;align_buffer) {
<span class="p_del">-			dma_free_coherent(mmc_dev(mmc), host-&gt;adma_table_sz,</span>
<span class="p_del">-					  host-&gt;adma_table, host-&gt;adma_addr);</span>
<span class="p_add">+			if (host-&gt;adma_table)</span>
<span class="p_add">+				dma_free_coherent(mmc_dev(mmc),</span>
<span class="p_add">+						  host-&gt;adma_table_sz,</span>
<span class="p_add">+						  host-&gt;adma_table,</span>
<span class="p_add">+						  host-&gt;adma_addr);</span>
 			kfree(host-&gt;align_buffer);
 			pr_warn(&quot;%s: Unable to allocate ADMA buffers - falling back to standard DMA\n&quot;,
 				mmc_hostname(mmc));
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index 68ad39a..58b687c 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -1617,9 +1617,16 @@</span> <span class="p_context"> err_free:</span>
 
 err_undo_flags:
 	/* Enslave of first slave has failed and we need to fix master&#39;s mac */
<span class="p_del">-	if (!bond_has_slaves(bond) &amp;&amp;</span>
<span class="p_del">-	    ether_addr_equal_64bits(bond_dev-&gt;dev_addr, slave_dev-&gt;dev_addr))</span>
<span class="p_del">-		eth_hw_addr_random(bond_dev);</span>
<span class="p_add">+	if (!bond_has_slaves(bond)) {</span>
<span class="p_add">+		if (ether_addr_equal_64bits(bond_dev-&gt;dev_addr,</span>
<span class="p_add">+					    slave_dev-&gt;dev_addr))</span>
<span class="p_add">+			eth_hw_addr_random(bond_dev);</span>
<span class="p_add">+		if (bond_dev-&gt;type != ARPHRD_ETHER) {</span>
<span class="p_add">+			ether_setup(bond_dev);</span>
<span class="p_add">+			bond_dev-&gt;flags |= IFF_MASTER;</span>
<span class="p_add">+			bond_dev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	return res;
 }
<span class="p_chunk">@@ -1808,6 +1815,7 @@</span> <span class="p_context"> static int  bond_release_and_destroy(struct net_device *bond_dev,</span>
 		bond_dev-&gt;priv_flags |= IFF_DISABLE_NETPOLL;
 		netdev_info(bond_dev, &quot;Destroying bond %s\n&quot;,
 			    bond_dev-&gt;name);
<span class="p_add">+		bond_remove_proc_entry(bond);</span>
 		unregister_netdevice(bond_dev);
 	}
 	return ret;
<span class="p_header">diff --git a/drivers/net/can/spi/mcp251x.c b/drivers/net/can/spi/mcp251x.c</span>
<span class="p_header">index c66d699..0c8094e 100644</span>
<span class="p_header">--- a/drivers/net/can/spi/mcp251x.c</span>
<span class="p_header">+++ b/drivers/net/can/spi/mcp251x.c</span>
<span class="p_chunk">@@ -1220,17 +1220,16 @@</span> <span class="p_context"> static int __maybe_unused mcp251x_can_resume(struct device *dev)</span>
 	struct spi_device *spi = to_spi_device(dev);
 	struct mcp251x_priv *priv = spi_get_drvdata(spi);
 
<span class="p_del">-	if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_POWER) {</span>
<span class="p_add">+	if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_POWER)</span>
 		mcp251x_power_enable(priv-&gt;power, 1);
<span class="p_add">+</span>
<span class="p_add">+	if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_UP) {</span>
<span class="p_add">+		mcp251x_power_enable(priv-&gt;transceiver, 1);</span>
 		queue_work(priv-&gt;wq, &amp;priv-&gt;restart_work);
 	} else {
<span class="p_del">-		if (priv-&gt;after_suspend &amp; AFTER_SUSPEND_UP) {</span>
<span class="p_del">-			mcp251x_power_enable(priv-&gt;transceiver, 1);</span>
<span class="p_del">-			queue_work(priv-&gt;wq, &amp;priv-&gt;restart_work);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			priv-&gt;after_suspend = 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		priv-&gt;after_suspend = 0;</span>
 	}
<span class="p_add">+</span>
 	priv-&gt;force_quit = 0;
 	enable_irq(spi-&gt;irq);
 	return 0;
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 2562249..fab4757 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -1435,7 +1435,7 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 		     struct mvneta_rx_queue *rxq)
 {
 	struct net_device *dev = pp-&gt;dev;
<span class="p_del">-	int rx_done, rx_filled;</span>
<span class="p_add">+	int rx_done;</span>
 	u32 rcvd_pkts = 0;
 	u32 rcvd_bytes = 0;
 
<span class="p_chunk">@@ -1446,7 +1446,6 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 		rx_todo = rx_done;
 
 	rx_done = 0;
<span class="p_del">-	rx_filled = 0;</span>
 
 	/* Fairness NAPI loop */
 	while (rx_done &lt; rx_todo) {
<span class="p_chunk">@@ -1457,7 +1456,6 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 		int rx_bytes, err;
 
 		rx_done++;
<span class="p_del">-		rx_filled++;</span>
 		rx_status = rx_desc-&gt;status;
 		rx_bytes = rx_desc-&gt;data_size - (ETH_FCS_LEN + MVNETA_MH_SIZE);
 		data = (unsigned char *)rx_desc-&gt;buf_cookie;
<span class="p_chunk">@@ -1497,6 +1495,14 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 			continue;
 		}
 
<span class="p_add">+		/* Refill processing */</span>
<span class="p_add">+		err = mvneta_rx_refill(pp, rx_desc);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			netdev_err(dev, &quot;Linux processing - Can&#39;t refill\n&quot;);</span>
<span class="p_add">+			rxq-&gt;missed++;</span>
<span class="p_add">+			goto err_drop_frame;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		skb = build_skb(data, pp-&gt;frag_size &gt; PAGE_SIZE ? 0 : pp-&gt;frag_size);
 		if (!skb)
 			goto err_drop_frame;
<span class="p_chunk">@@ -1516,14 +1522,6 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 		mvneta_rx_csum(pp, rx_status, skb);
 
 		napi_gro_receive(&amp;pp-&gt;napi, skb);
<span class="p_del">-</span>
<span class="p_del">-		/* Refill processing */</span>
<span class="p_del">-		err = mvneta_rx_refill(pp, rx_desc);</span>
<span class="p_del">-		if (err) {</span>
<span class="p_del">-			netdev_err(dev, &quot;Linux processing - Can&#39;t refill\n&quot;);</span>
<span class="p_del">-			rxq-&gt;missed++;</span>
<span class="p_del">-			rx_filled--;</span>
<span class="p_del">-		}</span>
 	}
 
 	if (rcvd_pkts) {
<span class="p_chunk">@@ -1536,7 +1534,7 @@</span> <span class="p_context"> static int mvneta_rx(struct mvneta_port *pp, int rx_todo,</span>
 	}
 
 	/* Update rxq management counters */
<span class="p_del">-	mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_filled);</span>
<span class="p_add">+	mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_done);</span>
 
 	return rx_done;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">index 3d275fb..5d2f56a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_chunk">@@ -568,7 +568,7 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 							continue;
 						mlx4_dbg(dev, &quot;%s: Sending MLX4_PORT_CHANGE_SUBTYPE_DOWN to slave: %d, port:%d\n&quot;,
 							 __func__, i, port);
<span class="p_del">-						s_info = &amp;priv-&gt;mfunc.master.vf_oper[slave].vport[port].state;</span>
<span class="p_add">+						s_info = &amp;priv-&gt;mfunc.master.vf_oper[i].vport[port].state;</span>
 						if (IFLA_VF_LINK_STATE_AUTO == s_info-&gt;link_state) {
 							eqe-&gt;event.port_change.port =
 								cpu_to_be32(
<span class="p_chunk">@@ -601,7 +601,7 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 							continue;
 						if (i == mlx4_master_func_num(dev))
 							continue;
<span class="p_del">-						s_info = &amp;priv-&gt;mfunc.master.vf_oper[slave].vport[port].state;</span>
<span class="p_add">+						s_info = &amp;priv-&gt;mfunc.master.vf_oper[i].vport[port].state;</span>
 						if (IFLA_VF_LINK_STATE_AUTO == s_info-&gt;link_state) {
 							eqe-&gt;event.port_change.port =
 								cpu_to_be32(
<span class="p_header">diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">index 0c64162..9655b01 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_chunk">@@ -6659,10 +6659,8 @@</span> <span class="p_context"> static netdev_tx_t niu_start_xmit(struct sk_buff *skb,</span>
 		struct sk_buff *skb_new;
 
 		skb_new = skb_realloc_headroom(skb, len);
<span class="p_del">-		if (!skb_new) {</span>
<span class="p_del">-			rp-&gt;tx_errors++;</span>
<span class="p_add">+		if (!skb_new)</span>
 			goto out_drop;
<span class="p_del">-		}</span>
 		kfree_skb(skb);
 		skb = skb_new;
 	} else
<span class="p_header">diff --git a/drivers/net/ipvlan/ipvlan.h b/drivers/net/ipvlan/ipvlan.h</span>
<span class="p_header">index 2729f64..af4284b 100644</span>
<span class="p_header">--- a/drivers/net/ipvlan/ipvlan.h</span>
<span class="p_header">+++ b/drivers/net/ipvlan/ipvlan.h</span>
<span class="p_chunk">@@ -102,6 +102,11 @@</span> <span class="p_context"> static inline struct ipvl_port *ipvlan_port_get_rcu(const struct net_device *d)</span>
 	return rcu_dereference(d-&gt;rx_handler_data);
 }
 
<span class="p_add">+static inline struct ipvl_port *ipvlan_port_get_rcu_bh(const struct net_device *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return rcu_dereference_bh(d-&gt;rx_handler_data);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline struct ipvl_port *ipvlan_port_get_rtnl(const struct net_device *d)
 {
 	return rtnl_dereference(d-&gt;rx_handler_data);
<span class="p_header">diff --git a/drivers/net/ipvlan/ipvlan_core.c b/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_header">index 2e19528..8df3268 100644</span>
<span class="p_header">--- a/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_header">+++ b/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_chunk">@@ -495,7 +495,7 @@</span> <span class="p_context"> static int ipvlan_xmit_mode_l2(struct sk_buff *skb, struct net_device *dev)</span>
 int ipvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct ipvl_dev *ipvlan = netdev_priv(dev);
<span class="p_del">-	struct ipvl_port *port = ipvlan_port_get_rcu(ipvlan-&gt;phy_dev);</span>
<span class="p_add">+	struct ipvl_port *port = ipvlan_port_get_rcu_bh(ipvlan-&gt;phy_dev);</span>
 
 	if (!port)
 		goto out;
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/tx.c b/drivers/net/wireless/iwlwifi/mvm/tx.c</span>
<span class="p_header">index 650a5f0..ac12bc5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/tx.c</span>
<span class="p_chunk">@@ -225,7 +225,7 @@</span> <span class="p_context"> void iwl_mvm_set_tx_cmd_rate(struct iwl_mvm *mvm, struct iwl_tx_cmd *tx_cmd,</span>
 
 	if (info-&gt;band == IEEE80211_BAND_2GHZ &amp;&amp;
 	    !iwl_mvm_bt_coex_is_shared_ant_avail(mvm))
<span class="p_del">-		rate_flags = BIT(mvm-&gt;cfg-&gt;non_shared_ant) &lt;&lt; RATE_MCS_ANT_POS;</span>
<span class="p_add">+		rate_flags = mvm-&gt;cfg-&gt;non_shared_ant &lt;&lt; RATE_MCS_ANT_POS;</span>
 	else
 		rate_flags =
 			BIT(mvm-&gt;mgmt_last_antenna_idx) &lt;&lt; RATE_MCS_ANT_POS;
<span class="p_header">diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c</span>
<span class="p_header">index c8ce701..409e296 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/netback.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/netback.c</span>
<span class="p_chunk">@@ -1758,13 +1758,13 @@</span> <span class="p_context"> static inline void xenvif_tx_dealloc_action(struct xenvif_queue *queue)</span>
 		smp_rmb();
 
 		while (dc != dp) {
<span class="p_del">-			BUG_ON(gop - queue-&gt;tx_unmap_ops &gt; MAX_PENDING_REQS);</span>
<span class="p_add">+			BUG_ON(gop - queue-&gt;tx_unmap_ops &gt;= MAX_PENDING_REQS);</span>
 			pending_idx =
 				queue-&gt;dealloc_ring[pending_index(dc++)];
 
<span class="p_del">-			pending_idx_release[gop-queue-&gt;tx_unmap_ops] =</span>
<span class="p_add">+			pending_idx_release[gop - queue-&gt;tx_unmap_ops] =</span>
 				pending_idx;
<span class="p_del">-			queue-&gt;pages_to_unmap[gop-queue-&gt;tx_unmap_ops] =</span>
<span class="p_add">+			queue-&gt;pages_to_unmap[gop - queue-&gt;tx_unmap_ops] =</span>
 				queue-&gt;mmap_pages[pending_idx];
 			gnttab_set_unmap_op(gop,
 					    idx_to_kaddr(queue, pending_idx),
<span class="p_header">diff --git a/drivers/phy/phy-berlin-usb.c b/drivers/phy/phy-berlin-usb.c</span>
<span class="p_header">index c8a8d53..cc5b26c 100644</span>
<span class="p_header">--- a/drivers/phy/phy-berlin-usb.c</span>
<span class="p_header">+++ b/drivers/phy/phy-berlin-usb.c</span>
<span class="p_chunk">@@ -109,8 +109,8 @@</span> <span class="p_context"></span>
 static const u32 phy_berlin_pll_dividers[] = {
 	/* Berlin 2 */
 	CLK_REF_DIV(0xc) | FEEDBACK_CLK_DIV(0x54),
<span class="p_del">-	/* Berlin 2CD */</span>
<span class="p_del">-	CLK_REF_DIV(0x6) | FEEDBACK_CLK_DIV(0x55),</span>
<span class="p_add">+	/* Berlin 2CD/Q */</span>
<span class="p_add">+	CLK_REF_DIV(0xc) | FEEDBACK_CLK_DIV(0x54),</span>
 };
 
 struct phy_berlin_usb_priv {
<span class="p_header">diff --git a/drivers/pinctrl/freescale/pinctrl-imx1-core.c b/drivers/pinctrl/freescale/pinctrl-imx1-core.c</span>
<span class="p_header">index 5ac59fb..d3a3be7 100644</span>
<span class="p_header">--- a/drivers/pinctrl/freescale/pinctrl-imx1-core.c</span>
<span class="p_header">+++ b/drivers/pinctrl/freescale/pinctrl-imx1-core.c</span>
<span class="p_chunk">@@ -403,14 +403,13 @@</span> <span class="p_context"> static int imx1_pinconf_set(struct pinctrl_dev *pctldev,</span>
 			     unsigned num_configs)
 {
 	struct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
<span class="p_del">-	const struct imx1_pinctrl_soc_info *info = ipctl-&gt;info;</span>
 	int i;
 
 	for (i = 0; i != num_configs; ++i) {
 		imx1_write_bit(ipctl, pin_id, configs[i] &amp; 0x01, MX1_PUEN);
 
 		dev_dbg(ipctl-&gt;dev, &quot;pinconf set pullup pin %s\n&quot;,
<span class="p_del">-			info-&gt;pins[pin_id].name);</span>
<span class="p_add">+			pin_desc_get(pctldev, pin_id)-&gt;name);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/regulator/s2mps11.c b/drivers/regulator/s2mps11.c</span>
<span class="p_header">index ff82811..8de1351 100644</span>
<span class="p_header">--- a/drivers/regulator/s2mps11.c</span>
<span class="p_header">+++ b/drivers/regulator/s2mps11.c</span>
<span class="p_chunk">@@ -34,6 +34,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/mfd/samsung/s2mps14.h&gt;
 #include &lt;linux/mfd/samsung/s2mpu02.h&gt;
 
<span class="p_add">+/* The highest number of possible regulators for supported devices. */</span>
<span class="p_add">+#define S2MPS_REGULATOR_MAX		S2MPS13_REGULATOR_MAX</span>
 struct s2mps11_info {
 	unsigned int rdev_num;
 	int ramp_delay2;
<span class="p_chunk">@@ -49,7 +51,7 @@</span> <span class="p_context"> struct s2mps11_info {</span>
 	 * One bit for each S2MPS13/S2MPS14/S2MPU02 regulator whether
 	 * the suspend mode was enabled.
 	 */
<span class="p_del">-	unsigned long long s2mps14_suspend_state:50;</span>
<span class="p_add">+	DECLARE_BITMAP(suspend_state, S2MPS_REGULATOR_MAX);</span>
 
 	/* Array of size rdev_num with GPIO-s for external sleep control */
 	int *ext_control_gpio;
<span class="p_chunk">@@ -500,7 +502,7 @@</span> <span class="p_context"> static int s2mps14_regulator_enable(struct regulator_dev *rdev)</span>
 	switch (s2mps11-&gt;dev_type) {
 	case S2MPS13X:
 	case S2MPS14X:
<span class="p_del">-		if (s2mps11-&gt;s2mps14_suspend_state &amp; (1 &lt;&lt; rdev_get_id(rdev)))</span>
<span class="p_add">+		if (test_bit(rdev_get_id(rdev), s2mps11-&gt;suspend_state))</span>
 			val = S2MPS14_ENABLE_SUSPEND;
 		else if (gpio_is_valid(s2mps11-&gt;ext_control_gpio[rdev_get_id(rdev)]))
 			val = S2MPS14_ENABLE_EXT_CONTROL;
<span class="p_chunk">@@ -508,7 +510,7 @@</span> <span class="p_context"> static int s2mps14_regulator_enable(struct regulator_dev *rdev)</span>
 			val = rdev-&gt;desc-&gt;enable_mask;
 		break;
 	case S2MPU02:
<span class="p_del">-		if (s2mps11-&gt;s2mps14_suspend_state &amp; (1 &lt;&lt; rdev_get_id(rdev)))</span>
<span class="p_add">+		if (test_bit(rdev_get_id(rdev), s2mps11-&gt;suspend_state))</span>
 			val = S2MPU02_ENABLE_SUSPEND;
 		else
 			val = rdev-&gt;desc-&gt;enable_mask;
<span class="p_chunk">@@ -562,7 +564,7 @@</span> <span class="p_context"> static int s2mps14_regulator_set_suspend_disable(struct regulator_dev *rdev)</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	s2mps11-&gt;s2mps14_suspend_state |= (1 &lt;&lt; rdev_get_id(rdev));</span>
<span class="p_add">+	set_bit(rdev_get_id(rdev), s2mps11-&gt;suspend_state);</span>
 	/*
 	 * Don&#39;t enable suspend mode if regulator is already disabled because
 	 * this would effectively for a short time turn on the regulator after
<span class="p_chunk">@@ -960,18 +962,22 @@</span> <span class="p_context"> static int s2mps11_pmic_probe(struct platform_device *pdev)</span>
 	case S2MPS11X:
 		s2mps11-&gt;rdev_num = ARRAY_SIZE(s2mps11_regulators);
 		regulators = s2mps11_regulators;
<span class="p_add">+		BUILD_BUG_ON(S2MPS_REGULATOR_MAX &lt; s2mps11-&gt;rdev_num);</span>
 		break;
 	case S2MPS13X:
 		s2mps11-&gt;rdev_num = ARRAY_SIZE(s2mps13_regulators);
 		regulators = s2mps13_regulators;
<span class="p_add">+		BUILD_BUG_ON(S2MPS_REGULATOR_MAX &lt; s2mps11-&gt;rdev_num);</span>
 		break;
 	case S2MPS14X:
 		s2mps11-&gt;rdev_num = ARRAY_SIZE(s2mps14_regulators);
 		regulators = s2mps14_regulators;
<span class="p_add">+		BUILD_BUG_ON(S2MPS_REGULATOR_MAX &lt; s2mps11-&gt;rdev_num);</span>
 		break;
 	case S2MPU02:
 		s2mps11-&gt;rdev_num = ARRAY_SIZE(s2mpu02_regulators);
 		regulators = s2mpu02_regulators;
<span class="p_add">+		BUILD_BUG_ON(S2MPS_REGULATOR_MAX &lt; s2mps11-&gt;rdev_num);</span>
 		break;
 	default:
 		dev_err(&amp;pdev-&gt;dev, &quot;Invalid device type: %u\n&quot;,
<span class="p_header">diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c</span>
<span class="p_header">index 9219953..f13996e 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.c</span>
<span class="p_header">+++ b/drivers/scsi/ipr.c</span>
<span class="p_chunk">@@ -592,9 +592,10 @@</span> <span class="p_context"> static void ipr_trc_hook(struct ipr_cmnd *ipr_cmd,</span>
 {
 	struct ipr_trace_entry *trace_entry;
 	struct ipr_ioa_cfg *ioa_cfg = ipr_cmd-&gt;ioa_cfg;
<span class="p_add">+	unsigned int trace_index;</span>
 
<span class="p_del">-	trace_entry = &amp;ioa_cfg-&gt;trace[atomic_add_return</span>
<span class="p_del">-			(1, &amp;ioa_cfg-&gt;trace_index)%IPR_NUM_TRACE_ENTRIES];</span>
<span class="p_add">+	trace_index = atomic_add_return(1, &amp;ioa_cfg-&gt;trace_index) &amp; IPR_TRACE_INDEX_MASK;</span>
<span class="p_add">+	trace_entry = &amp;ioa_cfg-&gt;trace[trace_index];</span>
 	trace_entry-&gt;time = jiffies;
 	trace_entry-&gt;op_code = ipr_cmd-&gt;ioarcb.cmd_pkt.cdb[0];
 	trace_entry-&gt;type = type;
<span class="p_chunk">@@ -1044,10 +1045,15 @@</span> <span class="p_context"> static void ipr_send_blocking_cmd(struct ipr_cmnd *ipr_cmd,</span>
 
 static int ipr_get_hrrq_index(struct ipr_ioa_cfg *ioa_cfg)
 {
<span class="p_add">+	unsigned int hrrq;</span>
<span class="p_add">+</span>
 	if (ioa_cfg-&gt;hrrq_num == 1)
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return (atomic_add_return(1, &amp;ioa_cfg-&gt;hrrq_index) % (ioa_cfg-&gt;hrrq_num - 1)) + 1;</span>
<span class="p_add">+		hrrq = 0;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		hrrq = atomic_add_return(1, &amp;ioa_cfg-&gt;hrrq_index);</span>
<span class="p_add">+		hrrq = (hrrq % (ioa_cfg-&gt;hrrq_num - 1)) + 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return hrrq;</span>
 }
 
 /**
<span class="p_chunk">@@ -6178,21 +6184,23 @@</span> <span class="p_context"> static void ipr_scsi_done(struct ipr_cmnd *ipr_cmd)</span>
 	struct ipr_ioa_cfg *ioa_cfg = ipr_cmd-&gt;ioa_cfg;
 	struct scsi_cmnd *scsi_cmd = ipr_cmd-&gt;scsi_cmd;
 	u32 ioasc = be32_to_cpu(ipr_cmd-&gt;s.ioasa.hdr.ioasc);
<span class="p_del">-	unsigned long hrrq_flags;</span>
<span class="p_add">+	unsigned long lock_flags;</span>
 
 	scsi_set_resid(scsi_cmd, be32_to_cpu(ipr_cmd-&gt;s.ioasa.hdr.residual_data_len));
 
 	if (likely(IPR_IOASC_SENSE_KEY(ioasc) == 0)) {
 		scsi_dma_unmap(scsi_cmd);
 
<span class="p_del">-		spin_lock_irqsave(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_lock_irqsave(ipr_cmd-&gt;hrrq-&gt;lock, lock_flags);</span>
 		list_add_tail(&amp;ipr_cmd-&gt;queue, &amp;ipr_cmd-&gt;hrrq-&gt;hrrq_free_q);
 		scsi_cmd-&gt;scsi_done(scsi_cmd);
<span class="p_del">-		spin_unlock_irqrestore(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_unlock_irqrestore(ipr_cmd-&gt;hrrq-&gt;lock, lock_flags);</span>
 	} else {
<span class="p_del">-		spin_lock_irqsave(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_lock_irqsave(ioa_cfg-&gt;host-&gt;host_lock, lock_flags);</span>
<span class="p_add">+		spin_lock(&amp;ipr_cmd-&gt;hrrq-&gt;_lock);</span>
 		ipr_erp_start(ioa_cfg, ipr_cmd);
<span class="p_del">-		spin_unlock_irqrestore(ipr_cmd-&gt;hrrq-&gt;lock, hrrq_flags);</span>
<span class="p_add">+		spin_unlock(&amp;ipr_cmd-&gt;hrrq-&gt;_lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(ioa_cfg-&gt;host-&gt;host_lock, lock_flags);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h</span>
<span class="p_header">index 70b0647..6948f9f 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.h</span>
<span class="p_header">+++ b/drivers/scsi/ipr.h</span>
<span class="p_chunk">@@ -1479,6 +1479,7 @@</span> <span class="p_context"> struct ipr_ioa_cfg {</span>
 
 #define IPR_NUM_TRACE_INDEX_BITS	8
 #define IPR_NUM_TRACE_ENTRIES		(1 &lt;&lt; IPR_NUM_TRACE_INDEX_BITS)
<span class="p_add">+#define IPR_TRACE_INDEX_MASK		(IPR_NUM_TRACE_ENTRIES - 1)</span>
 #define IPR_TRACE_SIZE	(sizeof(struct ipr_trace_entry) * IPR_NUM_TRACE_ENTRIES)
 	char trace_start[8];
 #define IPR_TRACE_START_LABEL			&quot;trace&quot;
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c</span>
<span class="p_header">index d77fe43..88ff7c3 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_dbg.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_dbg.c</span>
<span class="p_chunk">@@ -67,10 +67,10 @@</span> <span class="p_context"></span>
  * |                              |                    | 0xd031-0xd0ff	|
  * |                              |                    | 0xd101-0xd1fe	|
  * |                              |                    | 0xd214-0xd2fe	|
<span class="p_del">- * | Target Mode		  |	  0xe079       |		|</span>
<span class="p_del">- * | Target Mode Management	  |	  0xf072       | 0xf002		|</span>
<span class="p_add">+ * | Target Mode		  |	  0xe080       |		|</span>
<span class="p_add">+ * | Target Mode Management	  |	  0xf096       | 0xf002		|</span>
  * |                              |                    | 0xf046-0xf049  |
<span class="p_del">- * | Target Mode Task Management  |	  0x1000b      |		|</span>
<span class="p_add">+ * | Target Mode Task Management  |	  0x1000d      |		|</span>
  * ----------------------------------------------------------------------
  */
 
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h</span>
<span class="p_header">index 5f6b296..c03d33f 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_def.h</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_def.h</span>
<span class="p_chunk">@@ -274,6 +274,7 @@</span> <span class="p_context"></span>
 #define RESPONSE_ENTRY_CNT_FX00		256     /* Number of response entries.*/
 
 struct req_que;
<span class="p_add">+struct qla_tgt_sess;</span>
 
 /*
  * (sd.h is not exported, hence local inclusion)
<span class="p_chunk">@@ -2026,6 +2027,7 @@</span> <span class="p_context"> typedef struct fc_port {</span>
 	uint16_t port_id;
 
 	unsigned long retry_delay_timestamp;
<span class="p_add">+	struct qla_tgt_sess *tgt_session;</span>
 } fc_port_t;
 
 #include &quot;qla_mr.h&quot;
<span class="p_chunk">@@ -3576,6 +3578,16 @@</span> <span class="p_context"> typedef struct scsi_qla_host {</span>
 	uint16_t	fcoe_fcf_idx;
 	uint8_t		fcoe_vn_port_mac[6];
 
<span class="p_add">+	/* list of commands waiting on workqueue */</span>
<span class="p_add">+	struct list_head	qla_cmd_list;</span>
<span class="p_add">+	struct list_head	qla_sess_op_cmd_list;</span>
<span class="p_add">+	spinlock_t		cmd_list_lock;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Counter to detect races between ELS and RSCN events */</span>
<span class="p_add">+	atomic_t		generation_tick;</span>
<span class="p_add">+	/* Time when global fcport update has been scheduled */</span>
<span class="p_add">+	int			total_fcport_update_gen;</span>
<span class="p_add">+</span>
 	uint32_t	vp_abort_cnt;
 
 	struct fc_vport	*fc_vport;	/* holds fc_vport * for each vport */
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c</span>
<span class="p_header">index e59f25b..99fef23 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_init.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_init.c</span>
<span class="p_chunk">@@ -115,6 +115,8 @@</span> <span class="p_context"> qla2x00_async_iocb_timeout(void *data)</span>
 			QLA_LOGIO_LOGIN_RETRIED : 0;
 		qla2x00_post_async_login_done_work(fcport-&gt;vha, fcport,
 			lio-&gt;u.logio.data);
<span class="p_add">+	} else if (sp-&gt;type == SRB_LOGOUT_CMD) {</span>
<span class="p_add">+		qlt_logo_completion_handler(fcport, QLA_FUNCTION_TIMEOUT);</span>
 	}
 }
 
<span class="p_chunk">@@ -497,7 +499,10 @@</span> <span class="p_context"> void</span>
 qla2x00_async_logout_done(struct scsi_qla_host *vha, fc_port_t *fcport,
     uint16_t *data)
 {
<span class="p_del">-	qla2x00_mark_device_lost(vha, fcport, 1, 0);</span>
<span class="p_add">+	/* Don&#39;t re-login in target mode */</span>
<span class="p_add">+	if (!fcport-&gt;tgt_session)</span>
<span class="p_add">+		qla2x00_mark_device_lost(vha, fcport, 1, 0);</span>
<span class="p_add">+	qlt_logo_completion_handler(fcport, data[0]);</span>
 	return;
 }
 
<span class="p_chunk">@@ -2871,21 +2876,14 @@</span> <span class="p_context"> qla2x00_rport_del(void *data)</span>
 {
 	fc_port_t *fcport = data;
 	struct fc_rport *rport;
<span class="p_del">-	scsi_qla_host_t *vha = fcport-&gt;vha;</span>
 	unsigned long flags;
 
 	spin_lock_irqsave(fcport-&gt;vha-&gt;host-&gt;host_lock, flags);
 	rport = fcport-&gt;drport ? fcport-&gt;drport: fcport-&gt;rport;
 	fcport-&gt;drport = NULL;
 	spin_unlock_irqrestore(fcport-&gt;vha-&gt;host-&gt;host_lock, flags);
<span class="p_del">-	if (rport) {</span>
<span class="p_add">+	if (rport)</span>
 		fc_remote_port_delete(rport);
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Release the target mode FC NEXUS in qla_target.c code</span>
<span class="p_del">-		 * if target mod is enabled.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		qlt_fc_port_deleted(vha, fcport);</span>
<span class="p_del">-	}</span>
 }
 
 /**
<span class="p_chunk">@@ -3252,6 +3250,7 @@</span> <span class="p_context"> qla2x00_reg_remote_port(scsi_qla_host_t *vha, fc_port_t *fcport)</span>
 	 * Create target mode FC NEXUS in qla_target.c if target mode is
 	 * enabled..
 	 */
<span class="p_add">+</span>
 	qlt_fc_port_added(vha, fcport);
 
 	spin_lock_irqsave(fcport-&gt;vha-&gt;host-&gt;host_lock, flags);
<span class="p_chunk">@@ -3290,8 +3289,7 @@</span> <span class="p_context"> qla2x00_update_fcport(scsi_qla_host_t *vha, fc_port_t *fcport)</span>
 
 	if (IS_QLAFX00(vha-&gt;hw)) {
 		qla2x00_set_fcport_state(fcport, FCS_ONLINE);
<span class="p_del">-		qla2x00_reg_remote_port(vha, fcport);</span>
<span class="p_del">-		return;</span>
<span class="p_add">+		goto reg_port;</span>
 	}
 	fcport-&gt;login_retry = 0;
 	fcport-&gt;flags &amp;= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);
<span class="p_chunk">@@ -3299,7 +3297,16 @@</span> <span class="p_context"> qla2x00_update_fcport(scsi_qla_host_t *vha, fc_port_t *fcport)</span>
 	qla2x00_set_fcport_state(fcport, FCS_ONLINE);
 	qla2x00_iidma_fcport(vha, fcport);
 	qla24xx_update_fcport_fcp_prio(vha, fcport);
<span class="p_del">-	qla2x00_reg_remote_port(vha, fcport);</span>
<span class="p_add">+</span>
<span class="p_add">+reg_port:</span>
<span class="p_add">+	if (qla_ini_mode_enabled(vha))</span>
<span class="p_add">+		qla2x00_reg_remote_port(vha, fcport);</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Create target mode FC NEXUS in qla_target.c</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		qlt_fc_port_added(vha, fcport);</span>
<span class="p_add">+	}</span>
 }
 
 /*
<span class="p_chunk">@@ -3324,6 +3331,7 @@</span> <span class="p_context"> qla2x00_configure_fabric(scsi_qla_host_t *vha)</span>
 	LIST_HEAD(new_fcports);
 	struct qla_hw_data *ha = vha-&gt;hw;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha-&gt;pdev);
<span class="p_add">+	int		discovery_gen;</span>
 
 	/* If FL port exists, then SNS is present */
 	if (IS_FWI2_CAPABLE(ha))
<span class="p_chunk">@@ -3394,6 +3402,14 @@</span> <span class="p_context"> qla2x00_configure_fabric(scsi_qla_host_t *vha)</span>
 			fcport-&gt;scan_state = QLA_FCPORT_SCAN;
 		}
 
<span class="p_add">+		/* Mark the time right before querying FW for connected ports.</span>
<span class="p_add">+		 * This process is long, asynchronous and by the time it&#39;s done,</span>
<span class="p_add">+		 * collected information might not be accurate anymore. E.g.</span>
<span class="p_add">+		 * disconnected port might have re-connected and a brand new</span>
<span class="p_add">+		 * session has been created. In this case session&#39;s generation</span>
<span class="p_add">+		 * will be newer than discovery_gen. */</span>
<span class="p_add">+		qlt_do_generation_tick(vha, &amp;discovery_gen);</span>
<span class="p_add">+</span>
 		rval = qla2x00_find_all_fabric_devs(vha, &amp;new_fcports);
 		if (rval != QLA_SUCCESS)
 			break;
<span class="p_chunk">@@ -3409,20 +3425,44 @@</span> <span class="p_context"> qla2x00_configure_fabric(scsi_qla_host_t *vha)</span>
 			if ((fcport-&gt;flags &amp; FCF_FABRIC_DEVICE) == 0)
 				continue;
 
<span class="p_del">-			if (fcport-&gt;scan_state == QLA_FCPORT_SCAN &amp;&amp;</span>
<span class="p_del">-			    atomic_read(&amp;fcport-&gt;state) == FCS_ONLINE) {</span>
<span class="p_del">-				qla2x00_mark_device_lost(vha, fcport,</span>
<span class="p_del">-				    ql2xplogiabsentdevice, 0);</span>
<span class="p_del">-				if (fcport-&gt;loop_id != FC_NO_LOOP_ID &amp;&amp;</span>
<span class="p_del">-				    (fcport-&gt;flags &amp; FCF_FCP2_DEVICE) == 0 &amp;&amp;</span>
<span class="p_del">-				    fcport-&gt;port_type != FCT_INITIATOR &amp;&amp;</span>
<span class="p_del">-				    fcport-&gt;port_type != FCT_BROADCAST) {</span>
<span class="p_del">-					ha-&gt;isp_ops-&gt;fabric_logout(vha,</span>
<span class="p_del">-					    fcport-&gt;loop_id,</span>
<span class="p_del">-					    fcport-&gt;d_id.b.domain,</span>
<span class="p_del">-					    fcport-&gt;d_id.b.area,</span>
<span class="p_del">-					    fcport-&gt;d_id.b.al_pa);</span>
<span class="p_del">-					qla2x00_clear_loop_id(fcport);</span>
<span class="p_add">+			if (fcport-&gt;scan_state == QLA_FCPORT_SCAN) {</span>
<span class="p_add">+				if (qla_ini_mode_enabled(base_vha) &amp;&amp;</span>
<span class="p_add">+				    atomic_read(&amp;fcport-&gt;state) == FCS_ONLINE) {</span>
<span class="p_add">+					qla2x00_mark_device_lost(vha, fcport,</span>
<span class="p_add">+					    ql2xplogiabsentdevice, 0);</span>
<span class="p_add">+					if (fcport-&gt;loop_id != FC_NO_LOOP_ID &amp;&amp;</span>
<span class="p_add">+					    (fcport-&gt;flags &amp; FCF_FCP2_DEVICE) == 0 &amp;&amp;</span>
<span class="p_add">+					    fcport-&gt;port_type != FCT_INITIATOR &amp;&amp;</span>
<span class="p_add">+					    fcport-&gt;port_type != FCT_BROADCAST) {</span>
<span class="p_add">+						ha-&gt;isp_ops-&gt;fabric_logout(vha,</span>
<span class="p_add">+						    fcport-&gt;loop_id,</span>
<span class="p_add">+						    fcport-&gt;d_id.b.domain,</span>
<span class="p_add">+						    fcport-&gt;d_id.b.area,</span>
<span class="p_add">+						    fcport-&gt;d_id.b.al_pa);</span>
<span class="p_add">+						qla2x00_clear_loop_id(fcport);</span>
<span class="p_add">+					}</span>
<span class="p_add">+				} else if (!qla_ini_mode_enabled(base_vha)) {</span>
<span class="p_add">+					/*</span>
<span class="p_add">+					 * In target mode, explicitly kill</span>
<span class="p_add">+					 * sessions and log out of devices</span>
<span class="p_add">+					 * that are gone, so that we don&#39;t</span>
<span class="p_add">+					 * end up with an initiator using the</span>
<span class="p_add">+					 * wrong ACL (if the fabric recycles</span>
<span class="p_add">+					 * an FC address and we have a stale</span>
<span class="p_add">+					 * session around) and so that we don&#39;t</span>
<span class="p_add">+					 * report initiators that are no longer</span>
<span class="p_add">+					 * on the fabric.</span>
<span class="p_add">+					 */</span>
<span class="p_add">+					ql_dbg(ql_dbg_tgt_mgt, vha, 0xf077,</span>
<span class="p_add">+					    &quot;port gone, logging out/killing session: &quot;</span>
<span class="p_add">+					    &quot;%8phC state 0x%x flags 0x%x fc4_type 0x%x &quot;</span>
<span class="p_add">+					    &quot;scan_state %d\n&quot;,</span>
<span class="p_add">+					    fcport-&gt;port_name,</span>
<span class="p_add">+					    atomic_read(&amp;fcport-&gt;state),</span>
<span class="p_add">+					    fcport-&gt;flags, fcport-&gt;fc4_type,</span>
<span class="p_add">+					    fcport-&gt;scan_state);</span>
<span class="p_add">+					qlt_fc_port_deleted(vha, fcport,</span>
<span class="p_add">+					    discovery_gen);</span>
 				}
 			}
 		}
<span class="p_chunk">@@ -3443,6 +3483,28 @@</span> <span class="p_context"> qla2x00_configure_fabric(scsi_qla_host_t *vha)</span>
 			    (fcport-&gt;flags &amp; FCF_LOGIN_NEEDED) == 0)
 				continue;
 
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If we&#39;re not an initiator, skip looking for devices</span>
<span class="p_add">+			 * and logging in.  There&#39;s no reason for us to do it,</span>
<span class="p_add">+			 * and it seems to actively cause problems in target</span>
<span class="p_add">+			 * mode if we race with the initiator logging into us</span>
<span class="p_add">+			 * (we might get the &quot;port ID used&quot; status back from</span>
<span class="p_add">+			 * our login command and log out the initiator, which</span>
<span class="p_add">+			 * seems to cause havoc).</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!qla_ini_mode_enabled(base_vha)) {</span>
<span class="p_add">+				if (fcport-&gt;scan_state == QLA_FCPORT_FOUND) {</span>
<span class="p_add">+					ql_dbg(ql_dbg_tgt_mgt, vha, 0xf078,</span>
<span class="p_add">+					    &quot;port %8phC state 0x%x flags 0x%x fc4_type 0x%x &quot;</span>
<span class="p_add">+					    &quot;scan_state %d (initiator mode disabled; skipping &quot;</span>
<span class="p_add">+					    &quot;login)\n&quot;, fcport-&gt;port_name,</span>
<span class="p_add">+					    atomic_read(&amp;fcport-&gt;state),</span>
<span class="p_add">+					    fcport-&gt;flags, fcport-&gt;fc4_type,</span>
<span class="p_add">+					    fcport-&gt;scan_state);</span>
<span class="p_add">+				}</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (fcport-&gt;loop_id == FC_NO_LOOP_ID) {
 				fcport-&gt;loop_id = next_loopid;
 				rval = qla2x00_find_new_loop_id(
<span class="p_chunk">@@ -3469,16 +3531,38 @@</span> <span class="p_context"> qla2x00_configure_fabric(scsi_qla_host_t *vha)</span>
 			    test_bit(LOOP_RESYNC_NEEDED, &amp;vha-&gt;dpc_flags))
 				break;
 
<span class="p_del">-			/* Find a new loop ID to use. */</span>
<span class="p_del">-			fcport-&gt;loop_id = next_loopid;</span>
<span class="p_del">-			rval = qla2x00_find_new_loop_id(base_vha, fcport);</span>
<span class="p_del">-			if (rval != QLA_SUCCESS) {</span>
<span class="p_del">-				/* Ran out of IDs to use */</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If we&#39;re not an initiator, skip looking for devices</span>
<span class="p_add">+			 * and logging in.  There&#39;s no reason for us to do it,</span>
<span class="p_add">+			 * and it seems to actively cause problems in target</span>
<span class="p_add">+			 * mode if we race with the initiator logging into us</span>
<span class="p_add">+			 * (we might get the &quot;port ID used&quot; status back from</span>
<span class="p_add">+			 * our login command and log out the initiator, which</span>
<span class="p_add">+			 * seems to cause havoc).</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (qla_ini_mode_enabled(base_vha)) {</span>
<span class="p_add">+				/* Find a new loop ID to use. */</span>
<span class="p_add">+				fcport-&gt;loop_id = next_loopid;</span>
<span class="p_add">+				rval = qla2x00_find_new_loop_id(base_vha,</span>
<span class="p_add">+				    fcport);</span>
<span class="p_add">+				if (rval != QLA_SUCCESS) {</span>
<span class="p_add">+					/* Ran out of IDs to use */</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
<span class="p_del">-			/* Login and update database */</span>
<span class="p_del">-			qla2x00_fabric_dev_login(vha, fcport, &amp;next_loopid);</span>
<span class="p_add">+				/* Login and update database */</span>
<span class="p_add">+				qla2x00_fabric_dev_login(vha, fcport,</span>
<span class="p_add">+				    &amp;next_loopid);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf079,</span>
<span class="p_add">+					&quot;new port %8phC state 0x%x flags 0x%x fc4_type &quot;</span>
<span class="p_add">+					&quot;0x%x scan_state %d (initiator mode disabled; &quot;</span>
<span class="p_add">+					&quot;skipping login)\n&quot;,</span>
<span class="p_add">+					fcport-&gt;port_name,</span>
<span class="p_add">+					atomic_read(&amp;fcport-&gt;state),</span>
<span class="p_add">+					fcport-&gt;flags, fcport-&gt;fc4_type,</span>
<span class="p_add">+					fcport-&gt;scan_state);</span>
<span class="p_add">+			}</span>
 
 			list_move_tail(&amp;fcport-&gt;list, &amp;vha-&gt;vp_fcports);
 		}
<span class="p_chunk">@@ -3674,11 +3758,12 @@</span> <span class="p_context"> qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha,</span>
 			fcport-&gt;fp_speed = new_fcport-&gt;fp_speed;
 
 			/*
<span class="p_del">-			 * If address the same and state FCS_ONLINE, nothing</span>
<span class="p_del">-			 * changed.</span>
<span class="p_add">+			 * If address the same and state FCS_ONLINE</span>
<span class="p_add">+			 * (or in target mode), nothing changed.</span>
 			 */
 			if (fcport-&gt;d_id.b24 == new_fcport-&gt;d_id.b24 &amp;&amp;
<span class="p_del">-			    atomic_read(&amp;fcport-&gt;state) == FCS_ONLINE) {</span>
<span class="p_add">+			    (atomic_read(&amp;fcport-&gt;state) == FCS_ONLINE ||</span>
<span class="p_add">+			     !qla_ini_mode_enabled(base_vha))) {</span>
 				break;
 			}
 
<span class="p_chunk">@@ -3698,6 +3783,22 @@</span> <span class="p_context"> qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha,</span>
 			 * Log it out if still logged in and mark it for
 			 * relogin later.
 			 */
<span class="p_add">+			if (!qla_ini_mode_enabled(base_vha)) {</span>
<span class="p_add">+				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf080,</span>
<span class="p_add">+					 &quot;port changed FC ID, %8phC&quot;</span>
<span class="p_add">+					 &quot; old %x:%x:%x (loop_id 0x%04x)-&gt; new %x:%x:%x\n&quot;,</span>
<span class="p_add">+					 fcport-&gt;port_name,</span>
<span class="p_add">+					 fcport-&gt;d_id.b.domain,</span>
<span class="p_add">+					 fcport-&gt;d_id.b.area,</span>
<span class="p_add">+					 fcport-&gt;d_id.b.al_pa,</span>
<span class="p_add">+					 fcport-&gt;loop_id,</span>
<span class="p_add">+					 new_fcport-&gt;d_id.b.domain,</span>
<span class="p_add">+					 new_fcport-&gt;d_id.b.area,</span>
<span class="p_add">+					 new_fcport-&gt;d_id.b.al_pa);</span>
<span class="p_add">+				fcport-&gt;d_id.b24 = new_fcport-&gt;d_id.b24;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			fcport-&gt;d_id.b24 = new_fcport-&gt;d_id.b24;
 			fcport-&gt;flags |= FCF_LOGIN_NEEDED;
 			if (fcport-&gt;loop_id != FC_NO_LOOP_ID &amp;&amp;
<span class="p_chunk">@@ -3717,6 +3818,7 @@</span> <span class="p_context"> qla2x00_find_all_fabric_devs(scsi_qla_host_t *vha,</span>
 		if (found)
 			continue;
 		/* If device was not in our fcports list, then add it. */
<span class="p_add">+		new_fcport-&gt;scan_state = QLA_FCPORT_FOUND;</span>
 		list_add_tail(&amp;new_fcport-&gt;list, new_fcports);
 
 		/* Allocate a new replacement fcport. */
<span class="p_chunk">@@ -4137,6 +4239,14 @@</span> <span class="p_context"> qla2x00_update_fcports(scsi_qla_host_t *base_vha)</span>
 			    atomic_read(&amp;fcport-&gt;state) != FCS_UNCONFIGURED) {
 				spin_unlock_irqrestore(&amp;ha-&gt;vport_slock, flags);
 				qla2x00_rport_del(fcport);
<span class="p_add">+</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Release the target mode FC NEXUS in</span>
<span class="p_add">+				 * qla_target.c, if target mod is enabled.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				qlt_fc_port_deleted(vha, fcport,</span>
<span class="p_add">+				    base_vha-&gt;total_fcport_update_gen);</span>
<span class="p_add">+</span>
 				spin_lock_irqsave(&amp;ha-&gt;vport_slock, flags);
 			}
 		}
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_iocb.c b/drivers/scsi/qla2xxx/qla_iocb.c</span>
<span class="p_header">index a1ab25f..dc96f31 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_iocb.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_iocb.c</span>
<span class="p_chunk">@@ -1943,6 +1943,9 @@</span> <span class="p_context"> qla24xx_logout_iocb(srb_t *sp, struct logio_entry_24xx *logio)</span>
 	logio-&gt;entry_type = LOGINOUT_PORT_IOCB_TYPE;
 	logio-&gt;control_flags =
 	    cpu_to_le16(LCF_COMMAND_LOGO|LCF_IMPL_LOGO);
<span class="p_add">+	if (!sp-&gt;fcport-&gt;tgt_session ||</span>
<span class="p_add">+	    !sp-&gt;fcport-&gt;tgt_session-&gt;keep_nport_handle)</span>
<span class="p_add">+		logio-&gt;control_flags |= cpu_to_le16(LCF_FREE_NPORT);</span>
 	logio-&gt;nport_handle = cpu_to_le16(sp-&gt;fcport-&gt;loop_id);
 	logio-&gt;port_id[0] = sp-&gt;fcport-&gt;d_id.b.al_pa;
 	logio-&gt;port_id[1] = sp-&gt;fcport-&gt;d_id.b.area;
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">index cce1cbc..56d8684 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_chunk">@@ -3229,11 +3229,15 @@</span> <span class="p_context"> qla2x00_schedule_rport_del(struct scsi_qla_host *vha, fc_port_t *fcport,</span>
 		spin_lock_irqsave(vha-&gt;host-&gt;host_lock, flags);
 		fcport-&gt;drport = rport;
 		spin_unlock_irqrestore(vha-&gt;host-&gt;host_lock, flags);
<span class="p_add">+		qlt_do_generation_tick(vha, &amp;base_vha-&gt;total_fcport_update_gen);</span>
 		set_bit(FCPORT_UPDATE_NEEDED, &amp;base_vha-&gt;dpc_flags);
 		qla2xxx_wake_dpc(base_vha);
 	} else {
<span class="p_del">-		fc_remote_port_delete(rport);</span>
<span class="p_del">-		qlt_fc_port_deleted(vha, fcport);</span>
<span class="p_add">+		int now;</span>
<span class="p_add">+		if (rport)</span>
<span class="p_add">+			fc_remote_port_delete(rport);</span>
<span class="p_add">+		qlt_do_generation_tick(vha, &amp;now);</span>
<span class="p_add">+		qlt_fc_port_deleted(vha, fcport, now);</span>
 	}
 }
 
<span class="p_chunk">@@ -3763,8 +3767,11 @@</span> <span class="p_context"> struct scsi_qla_host *qla2x00_create_host(struct scsi_host_template *sht,</span>
 	INIT_LIST_HEAD(&amp;vha-&gt;vp_fcports);
 	INIT_LIST_HEAD(&amp;vha-&gt;work_list);
 	INIT_LIST_HEAD(&amp;vha-&gt;list);
<span class="p_add">+	INIT_LIST_HEAD(&amp;vha-&gt;qla_cmd_list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;vha-&gt;qla_sess_op_cmd_list);</span>
 
 	spin_lock_init(&amp;vha-&gt;work_lock);
<span class="p_add">+	spin_lock_init(&amp;vha-&gt;cmd_list_lock);</span>
 
 	sprintf(vha-&gt;host_str, &quot;%s_%ld&quot;, QLA2XXX_DRIVER_NAME, vha-&gt;host_no);
 	ql_dbg(ql_dbg_init, vha, 0x0041,
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">index 5741825..a033912 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_chunk">@@ -113,6 +113,11 @@</span> <span class="p_context"> static void qlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha,</span>
 static void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,
 	struct atio_from_isp *atio, uint16_t status, int qfull);
 static void qlt_disable_vha(struct scsi_qla_host *vha);
<span class="p_add">+static void qlt_clear_tgt_db(struct qla_tgt *tgt);</span>
<span class="p_add">+static void qlt_send_notify_ack(struct scsi_qla_host *vha,</span>
<span class="p_add">+	struct imm_ntfy_from_isp *ntfy,</span>
<span class="p_add">+	uint32_t add_flags, uint16_t resp_code, int resp_code_valid,</span>
<span class="p_add">+	uint16_t srr_flags, uint16_t srr_reject_code, uint8_t srr_explan);</span>
 /*
  * Global Variables
  */
<span class="p_chunk">@@ -122,6 +127,16 @@</span> <span class="p_context"> static struct workqueue_struct *qla_tgt_wq;</span>
 static DEFINE_MUTEX(qla_tgt_mutex);
 static LIST_HEAD(qla_tgt_glist);
 
<span class="p_add">+/* This API intentionally takes dest as a parameter, rather than returning</span>
<span class="p_add">+ * int value to avoid caller forgetting to issue wmb() after the store */</span>
<span class="p_add">+void qlt_do_generation_tick(struct scsi_qla_host *vha, int *dest)</span>
<span class="p_add">+{</span>
<span class="p_add">+	scsi_qla_host_t *base_vha = pci_get_drvdata(vha-&gt;hw-&gt;pdev);</span>
<span class="p_add">+	*dest = atomic_inc_return(&amp;base_vha-&gt;generation_tick);</span>
<span class="p_add">+	/* memory barrier */</span>
<span class="p_add">+	wmb();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* ha-&gt;hardware_lock supposed to be held on entry (to protect tgt-&gt;sess_list) */
 static struct qla_tgt_sess *qlt_find_sess_by_port_name(
 	struct qla_tgt *tgt,
<span class="p_chunk">@@ -381,14 +396,73 @@</span> <span class="p_context"> static void qlt_free_session_done(struct work_struct *work)</span>
 	struct qla_tgt *tgt = sess-&gt;tgt;
 	struct scsi_qla_host *vha = sess-&gt;vha;
 	struct qla_hw_data *ha = vha-&gt;hw;
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	bool logout_started = false;</span>
<span class="p_add">+	fc_port_t fcport;</span>
<span class="p_add">+</span>
<span class="p_add">+	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf084,</span>
<span class="p_add">+		&quot;%s: se_sess %p / sess %p from port %8phC loop_id %#04x&quot;</span>
<span class="p_add">+		&quot; s_id %02x:%02x:%02x logout %d keep %d plogi %d\n&quot;,</span>
<span class="p_add">+		__func__, sess-&gt;se_sess, sess, sess-&gt;port_name, sess-&gt;loop_id,</span>
<span class="p_add">+		sess-&gt;s_id.b.domain, sess-&gt;s_id.b.area, sess-&gt;s_id.b.al_pa,</span>
<span class="p_add">+		sess-&gt;logout_on_delete, sess-&gt;keep_nport_handle,</span>
<span class="p_add">+		sess-&gt;plogi_ack_needed);</span>
 
 	BUG_ON(!tgt);
<span class="p_add">+</span>
<span class="p_add">+	if (sess-&gt;logout_on_delete) {</span>
<span class="p_add">+		int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+		memset(&amp;fcport, 0, sizeof(fcport));</span>
<span class="p_add">+		fcport.loop_id = sess-&gt;loop_id;</span>
<span class="p_add">+		fcport.d_id = sess-&gt;s_id;</span>
<span class="p_add">+		memcpy(fcport.port_name, sess-&gt;port_name, WWN_SIZE);</span>
<span class="p_add">+		fcport.vha = vha;</span>
<span class="p_add">+		fcport.tgt_session = sess;</span>
<span class="p_add">+</span>
<span class="p_add">+		rc = qla2x00_post_async_logout_work(vha, &amp;fcport, NULL);</span>
<span class="p_add">+		if (rc != QLA_SUCCESS)</span>
<span class="p_add">+			ql_log(ql_log_warn, vha, 0xf085,</span>
<span class="p_add">+			       &quot;Schedule logo failed sess %p rc %d\n&quot;,</span>
<span class="p_add">+			       sess, rc);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			logout_started = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Release the target session for FC Nexus from fabric module code.
 	 */
 	if (sess-&gt;se_sess != NULL)
 		ha-&gt;tgt.tgt_ops-&gt;free_session(sess);
 
<span class="p_add">+	if (logout_started) {</span>
<span class="p_add">+		bool traced = false;</span>
<span class="p_add">+</span>
<span class="p_add">+		while (!ACCESS_ONCE(sess-&gt;logout_completed)) {</span>
<span class="p_add">+			if (!traced) {</span>
<span class="p_add">+				ql_dbg(ql_dbg_tgt_mgt, vha, 0xf086,</span>
<span class="p_add">+					&quot;%s: waiting for sess %p logout\n&quot;,</span>
<span class="p_add">+					__func__, sess);</span>
<span class="p_add">+				traced = true;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			msleep(100);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf087,</span>
<span class="p_add">+			&quot;%s: sess %p logout completed\n&quot;,</span>
<span class="p_add">+			__func__, sess);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sess-&gt;plogi_ack_needed)</span>
<span class="p_add">+		qlt_send_notify_ack(vha, &amp;sess-&gt;tm_iocb,</span>
<span class="p_add">+				    0, 0, 0, 0, 0, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_del(&amp;sess-&gt;sess_list_entry);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
<span class="p_add">+</span>
 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf001,
 	    &quot;Unregistration of sess %p finished\n&quot;, sess);
 
<span class="p_chunk">@@ -409,9 +483,9 @@</span> <span class="p_context"> void qlt_unreg_sess(struct qla_tgt_sess *sess)</span>
 
 	vha-&gt;hw-&gt;tgt.tgt_ops-&gt;clear_nacl_from_fcport_map(sess);
 
<span class="p_del">-	list_del(&amp;sess-&gt;sess_list_entry);</span>
<span class="p_del">-	if (sess-&gt;deleted)</span>
<span class="p_del">-		list_del(&amp;sess-&gt;del_list_entry);</span>
<span class="p_add">+	if (!list_empty(&amp;sess-&gt;del_list_entry))</span>
<span class="p_add">+		list_del_init(&amp;sess-&gt;del_list_entry);</span>
<span class="p_add">+	sess-&gt;deleted = QLA_SESS_DELETION_IN_PROGRESS;</span>
 
 	INIT_WORK(&amp;sess-&gt;free_work, qlt_free_session_done);
 	schedule_work(&amp;sess-&gt;free_work);
<span class="p_chunk">@@ -431,10 +505,10 @@</span> <span class="p_context"> static int qlt_reset(struct scsi_qla_host *vha, void *iocb, int mcmd)</span>
 
 	loop_id = le16_to_cpu(n-&gt;u.isp24.nport_handle);
 	if (loop_id == 0xFFFF) {
<span class="p_del">-#if 0 /* FIXME: Re-enable Global event handling.. */</span>
 		/* Global event */
<span class="p_del">-		atomic_inc(&amp;ha-&gt;tgt.qla_tgt-&gt;tgt_global_resets_count);</span>
<span class="p_del">-		qlt_clear_tgt_db(ha-&gt;tgt.qla_tgt);</span>
<span class="p_add">+		atomic_inc(&amp;vha-&gt;vha_tgt.qla_tgt-&gt;tgt_global_resets_count);</span>
<span class="p_add">+		qlt_clear_tgt_db(vha-&gt;vha_tgt.qla_tgt);</span>
<span class="p_add">+#if 0 /* FIXME: do we need to choose a session here? */</span>
 		if (!list_empty(&amp;ha-&gt;tgt.qla_tgt-&gt;sess_list)) {
 			sess = list_entry(ha-&gt;tgt.qla_tgt-&gt;sess_list.next,
 			    typeof(*sess), sess_list_entry);
<span class="p_chunk">@@ -489,27 +563,38 @@</span> <span class="p_context"> static void qlt_schedule_sess_for_deletion(struct qla_tgt_sess *sess,</span>
 	struct qla_tgt *tgt = sess-&gt;tgt;
 	uint32_t dev_loss_tmo = tgt-&gt;ha-&gt;port_down_retry_count + 5;
 
<span class="p_del">-	if (sess-&gt;deleted)</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	if (sess-&gt;deleted) {</span>
<span class="p_add">+		/* Upgrade to unconditional deletion in case it was temporary */</span>
<span class="p_add">+		if (immediate &amp;&amp; sess-&gt;deleted == QLA_SESS_DELETION_PENDING)</span>
<span class="p_add">+			list_del(&amp;sess-&gt;del_list_entry);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
 
 	ql_dbg(ql_dbg_tgt, sess-&gt;vha, 0xe001,
 	    &quot;Scheduling sess %p for deletion\n&quot;, sess);
<span class="p_del">-	list_add_tail(&amp;sess-&gt;del_list_entry, &amp;tgt-&gt;del_sess_list);</span>
<span class="p_del">-	sess-&gt;deleted = 1;</span>
 
<span class="p_del">-	if (immediate)</span>
<span class="p_add">+	if (immediate) {</span>
 		dev_loss_tmo = 0;
<span class="p_add">+		sess-&gt;deleted = QLA_SESS_DELETION_IN_PROGRESS;</span>
<span class="p_add">+		list_add(&amp;sess-&gt;del_list_entry, &amp;tgt-&gt;del_sess_list);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		sess-&gt;deleted = QLA_SESS_DELETION_PENDING;</span>
<span class="p_add">+		list_add_tail(&amp;sess-&gt;del_list_entry, &amp;tgt-&gt;del_sess_list);</span>
<span class="p_add">+	}</span>
 
 	sess-&gt;expires = jiffies + dev_loss_tmo * HZ;
 
 	ql_dbg(ql_dbg_tgt, sess-&gt;vha, 0xe048,
<span class="p_del">-	    &quot;qla_target(%d): session for port %8phC (loop ID %d) scheduled for &quot;</span>
<span class="p_del">-	    &quot;deletion in %u secs (expires: %lu) immed: %d\n&quot;,</span>
<span class="p_del">-	    sess-&gt;vha-&gt;vp_idx, sess-&gt;port_name, sess-&gt;loop_id, dev_loss_tmo,</span>
<span class="p_del">-	    sess-&gt;expires, immediate);</span>
<span class="p_add">+	    &quot;qla_target(%d): session for port %8phC (loop ID %d s_id %02x:%02x:%02x)&quot;</span>
<span class="p_add">+	    &quot; scheduled for deletion in %u secs (expires: %lu) immed: %d, logout: %d, gen: %#x\n&quot;,</span>
<span class="p_add">+	    sess-&gt;vha-&gt;vp_idx, sess-&gt;port_name, sess-&gt;loop_id,</span>
<span class="p_add">+	    sess-&gt;s_id.b.domain, sess-&gt;s_id.b.area, sess-&gt;s_id.b.al_pa,</span>
<span class="p_add">+	    dev_loss_tmo, sess-&gt;expires, immediate, sess-&gt;logout_on_delete,</span>
<span class="p_add">+	    sess-&gt;generation);</span>
 
 	if (immediate)
<span class="p_del">-		schedule_delayed_work(&amp;tgt-&gt;sess_del_work, 0);</span>
<span class="p_add">+		mod_delayed_work(system_wq, &amp;tgt-&gt;sess_del_work, 0);</span>
 	else
 		schedule_delayed_work(&amp;tgt-&gt;sess_del_work,
 		    sess-&gt;expires - jiffies);
<span class="p_chunk">@@ -578,9 +663,9 @@</span> <span class="p_context"> out_free_id_list:</span>
 /* ha-&gt;hardware_lock supposed to be held on entry */
 static void qlt_undelete_sess(struct qla_tgt_sess *sess)
 {
<span class="p_del">-	BUG_ON(!sess-&gt;deleted);</span>
<span class="p_add">+	BUG_ON(sess-&gt;deleted != QLA_SESS_DELETION_PENDING);</span>
 
<span class="p_del">-	list_del(&amp;sess-&gt;del_list_entry);</span>
<span class="p_add">+	list_del_init(&amp;sess-&gt;del_list_entry);</span>
 	sess-&gt;deleted = 0;
 }
 
<span class="p_chunk">@@ -599,7 +684,9 @@</span> <span class="p_context"> static void qlt_del_sess_work_fn(struct delayed_work *work)</span>
 		    del_list_entry);
 		elapsed = jiffies;
 		if (time_after_eq(elapsed, sess-&gt;expires)) {
<span class="p_del">-			qlt_undelete_sess(sess);</span>
<span class="p_add">+			/* No turning back */</span>
<span class="p_add">+			list_del_init(&amp;sess-&gt;del_list_entry);</span>
<span class="p_add">+			sess-&gt;deleted = QLA_SESS_DELETION_IN_PROGRESS;</span>
 
 			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf004,
 			    &quot;Timeout: sess %p about to be deleted\n&quot;,
<span class="p_chunk">@@ -643,6 +730,13 @@</span> <span class="p_context"> static struct qla_tgt_sess *qlt_create_sess(</span>
 			    fcport-&gt;d_id.b.al_pa, fcport-&gt;d_id.b.area,
 			    fcport-&gt;loop_id);
 
<span class="p_add">+			/* Cannot undelete at this point */</span>
<span class="p_add">+			if (sess-&gt;deleted == QLA_SESS_DELETION_IN_PROGRESS) {</span>
<span class="p_add">+				spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock,</span>
<span class="p_add">+				    flags);</span>
<span class="p_add">+				return NULL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (sess-&gt;deleted)
 				qlt_undelete_sess(sess);
 
<span class="p_chunk">@@ -652,6 +746,9 @@</span> <span class="p_context"> static struct qla_tgt_sess *qlt_create_sess(</span>
 
 			if (sess-&gt;local &amp;&amp; !local)
 				sess-&gt;local = 0;
<span class="p_add">+</span>
<span class="p_add">+			qlt_do_generation_tick(vha, &amp;sess-&gt;generation);</span>
<span class="p_add">+</span>
 			spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);
 
 			return sess;
<span class="p_chunk">@@ -673,6 +770,14 @@</span> <span class="p_context"> static struct qla_tgt_sess *qlt_create_sess(</span>
 	sess-&gt;s_id = fcport-&gt;d_id;
 	sess-&gt;loop_id = fcport-&gt;loop_id;
 	sess-&gt;local = local;
<span class="p_add">+	INIT_LIST_HEAD(&amp;sess-&gt;del_list_entry);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Under normal circumstances we want to logout from firmware when</span>
<span class="p_add">+	 * session eventually ends and release corresponding nport handle.</span>
<span class="p_add">+	 * In the exception cases (e.g. when new PLOGI is waiting) corresponding</span>
<span class="p_add">+	 * code will adjust these flags as necessary. */</span>
<span class="p_add">+	sess-&gt;logout_on_delete = 1;</span>
<span class="p_add">+	sess-&gt;keep_nport_handle = 0;</span>
 
 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf006,
 	    &quot;Adding sess %p to tgt %p via -&gt;check_initiator_node_acl()\n&quot;,
<span class="p_chunk">@@ -705,6 +810,7 @@</span> <span class="p_context"> static struct qla_tgt_sess *qlt_create_sess(</span>
 	spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);
 	list_add_tail(&amp;sess-&gt;sess_list_entry, &amp;vha-&gt;vha_tgt.qla_tgt-&gt;sess_list);
 	vha-&gt;vha_tgt.qla_tgt-&gt;sess_count++;
<span class="p_add">+	qlt_do_generation_tick(vha, &amp;sess-&gt;generation);</span>
 	spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);
 
 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf04b,
<span class="p_chunk">@@ -718,7 +824,7 @@</span> <span class="p_context"> static struct qla_tgt_sess *qlt_create_sess(</span>
 }
 
 /*
<span class="p_del">- * Called from drivers/scsi/qla2xxx/qla_init.c:qla2x00_reg_remote_port()</span>
<span class="p_add">+ * Called from qla2x00_reg_remote_port()</span>
  */
 void qlt_fc_port_added(struct scsi_qla_host *vha, fc_port_t *fcport)
 {
<span class="p_chunk">@@ -750,6 +856,10 @@</span> <span class="p_context"> void qlt_fc_port_added(struct scsi_qla_host *vha, fc_port_t *fcport)</span>
 		mutex_unlock(&amp;vha-&gt;vha_tgt.tgt_mutex);
 
 		spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);
<span class="p_add">+	} else if (sess-&gt;deleted == QLA_SESS_DELETION_IN_PROGRESS) {</span>
<span class="p_add">+		/* Point of no return */</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
<span class="p_add">+		return;</span>
 	} else {
 		kref_get(&amp;sess-&gt;se_sess-&gt;sess_kref);
 
<span class="p_chunk">@@ -780,27 +890,36 @@</span> <span class="p_context"> void qlt_fc_port_added(struct scsi_qla_host *vha, fc_port_t *fcport)</span>
 	spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);
 }
 
<span class="p_del">-void qlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * max_gen - specifies maximum session generation</span>
<span class="p_add">+ * at which this deletion requestion is still valid</span>
<span class="p_add">+ */</span>
<span class="p_add">+void</span>
<span class="p_add">+qlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport, int max_gen)</span>
 {
<span class="p_del">-	struct qla_hw_data *ha = vha-&gt;hw;</span>
 	struct qla_tgt *tgt = vha-&gt;vha_tgt.qla_tgt;
 	struct qla_tgt_sess *sess;
<span class="p_del">-	unsigned long flags;</span>
 
 	if (!vha-&gt;hw-&gt;tgt.tgt_ops)
 		return;
 
<span class="p_del">-	if (!tgt || (fcport-&gt;port_type != FCT_INITIATOR))</span>
<span class="p_add">+	if (!tgt)</span>
 		return;
 
<span class="p_del">-	spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);</span>
 	if (tgt-&gt;tgt_stop) {
<span class="p_del">-		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
 		return;
 	}
 	sess = qlt_find_sess_by_port_name(tgt, fcport-&gt;port_name);
 	if (!sess) {
<span class="p_del">-		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (max_gen - sess-&gt;generation &lt; 0) {</span>
<span class="p_add">+		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf092,</span>
<span class="p_add">+		    &quot;Ignoring stale deletion request for se_sess %p / sess %p&quot;</span>
<span class="p_add">+		    &quot; for port %8phC, req_gen %d, sess_gen %d\n&quot;,</span>
<span class="p_add">+		    sess-&gt;se_sess, sess, sess-&gt;port_name, max_gen,</span>
<span class="p_add">+		    sess-&gt;generation);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -808,7 +927,6 @@</span> <span class="p_context"> void qlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport)</span>
 
 	sess-&gt;local = 1;
 	qlt_schedule_sess_for_deletion(sess, false);
<span class="p_del">-	spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
 }
 
 static inline int test_tgt_sess_count(struct qla_tgt *tgt)
<span class="p_chunk">@@ -1175,6 +1293,70 @@</span> <span class="p_context"> static void qlt_24xx_retry_term_exchange(struct scsi_qla_host *vha,</span>
 	    FCP_TMF_CMPL, true);
 }
 
<span class="p_add">+static int abort_cmd_for_tag(struct scsi_qla_host *vha, uint32_t tag)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct qla_tgt_sess_op *op;</span>
<span class="p_add">+	struct qla_tgt_cmd *cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(op, &amp;vha-&gt;qla_sess_op_cmd_list, cmd_list) {</span>
<span class="p_add">+		if (tag == op-&gt;atio.u.isp24.exchange_addr) {</span>
<span class="p_add">+			op-&gt;aborted = true;</span>
<span class="p_add">+			spin_unlock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(cmd, &amp;vha-&gt;qla_cmd_list, cmd_list) {</span>
<span class="p_add">+		if (tag == cmd-&gt;atio.u.isp24.exchange_addr) {</span>
<span class="p_add">+			cmd-&gt;state = QLA_TGT_STATE_ABORTED;</span>
<span class="p_add">+			spin_unlock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* drop cmds for the given lun</span>
<span class="p_add">+ * XXX only looks for cmds on the port through which lun reset was recieved</span>
<span class="p_add">+ * XXX does not go through the list of other port (which may have cmds</span>
<span class="p_add">+ *     for the same lun)</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void abort_cmds_for_lun(struct scsi_qla_host *vha,</span>
<span class="p_add">+				uint32_t lun, uint8_t *s_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct qla_tgt_sess_op *op;</span>
<span class="p_add">+	struct qla_tgt_cmd *cmd;</span>
<span class="p_add">+	uint32_t key;</span>
<span class="p_add">+</span>
<span class="p_add">+	key = sid_to_key(s_id);</span>
<span class="p_add">+	spin_lock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+	list_for_each_entry(op, &amp;vha-&gt;qla_sess_op_cmd_list, cmd_list) {</span>
<span class="p_add">+		uint32_t op_key;</span>
<span class="p_add">+		uint32_t op_lun;</span>
<span class="p_add">+</span>
<span class="p_add">+		op_key = sid_to_key(op-&gt;atio.u.isp24.fcp_hdr.s_id);</span>
<span class="p_add">+		op_lun = scsilun_to_int(</span>
<span class="p_add">+			(struct scsi_lun *)&amp;op-&gt;atio.u.isp24.fcp_cmnd.lun);</span>
<span class="p_add">+		if (op_key == key &amp;&amp; op_lun == lun)</span>
<span class="p_add">+			op-&gt;aborted = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	list_for_each_entry(cmd, &amp;vha-&gt;qla_cmd_list, cmd_list) {</span>
<span class="p_add">+		uint32_t cmd_key;</span>
<span class="p_add">+		uint32_t cmd_lun;</span>
<span class="p_add">+</span>
<span class="p_add">+		cmd_key = sid_to_key(cmd-&gt;atio.u.isp24.fcp_hdr.s_id);</span>
<span class="p_add">+		cmd_lun = scsilun_to_int(</span>
<span class="p_add">+			(struct scsi_lun *)&amp;cmd-&gt;atio.u.isp24.fcp_cmnd.lun);</span>
<span class="p_add">+		if (cmd_key == key &amp;&amp; cmd_lun == lun)</span>
<span class="p_add">+			cmd-&gt;state = QLA_TGT_STATE_ABORTED;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* ha-&gt;hardware_lock supposed to be held on entry */
 static int __qlt_24xx_handle_abts(struct scsi_qla_host *vha,
 	struct abts_recv_from_24xx *abts, struct qla_tgt_sess *sess)
<span class="p_chunk">@@ -1199,8 +1381,19 @@</span> <span class="p_context"> static int __qlt_24xx_handle_abts(struct scsi_qla_host *vha,</span>
 	}
 	spin_unlock(&amp;se_sess-&gt;sess_cmd_lock);
 
<span class="p_del">-	if (!found_lun)</span>
<span class="p_del">-		return -ENOENT;</span>
<span class="p_add">+	/* cmd not in LIO lists, look in qla list */</span>
<span class="p_add">+	if (!found_lun) {</span>
<span class="p_add">+		if (abort_cmd_for_tag(vha, abts-&gt;exchange_addr_to_abort)) {</span>
<span class="p_add">+			/* send TASK_ABORT response immediately */</span>
<span class="p_add">+			qlt_24xx_send_abts_resp(vha, abts, FCP_TMF_CMPL, false);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf081,</span>
<span class="p_add">+			    &quot;unable to find cmd in driver or LIO for tag 0x%x\n&quot;,</span>
<span class="p_add">+			    abts-&gt;exchange_addr_to_abort);</span>
<span class="p_add">+			return -ENOENT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf00f,
 	    &quot;qla_target(%d): task abort (tag=%d)\n&quot;,
<span class="p_chunk">@@ -1284,6 +1477,11 @@</span> <span class="p_context"> static void qlt_24xx_handle_abts(struct scsi_qla_host *vha,</span>
 		return;
 	}
 
<span class="p_add">+	if (sess-&gt;deleted == QLA_SESS_DELETION_IN_PROGRESS) {</span>
<span class="p_add">+		qlt_24xx_send_abts_resp(vha, abts, FCP_TMF_REJECTED, false);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	rc = __qlt_24xx_handle_abts(vha, abts, sess);
 	if (rc != 0) {
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf054,
<span class="p_chunk">@@ -1726,21 +1924,6 @@</span> <span class="p_context"> static int qlt_pre_xmit_response(struct qla_tgt_cmd *cmd,</span>
 	struct qla_hw_data *ha = vha-&gt;hw;
 	struct se_cmd *se_cmd = &amp;cmd-&gt;se_cmd;
 
<span class="p_del">-	if (unlikely(cmd-&gt;aborted)) {</span>
<span class="p_del">-		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,</span>
<span class="p_del">-		    &quot;qla_target(%d): terminating exchange &quot;</span>
<span class="p_del">-		    &quot;for aborted cmd=%p (se_cmd=%p, tag=%d)&quot;, vha-&gt;vp_idx, cmd,</span>
<span class="p_del">-		    se_cmd, cmd-&gt;tag);</span>
<span class="p_del">-</span>
<span class="p_del">-		cmd-&gt;state = QLA_TGT_STATE_ABORTED;</span>
<span class="p_del">-		cmd-&gt;cmd_flags |= BIT_6;</span>
<span class="p_del">-</span>
<span class="p_del">-		qlt_send_term_exchange(vha, cmd, &amp;cmd-&gt;atio, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* !! At this point cmd could be already freed !! */</span>
<span class="p_del">-		return QLA_TGT_PRE_XMIT_RESP_CMD_ABORTED;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	prm-&gt;cmd = cmd;
 	prm-&gt;tgt = tgt;
 	prm-&gt;rq_result = scsi_status;
<span class="p_chunk">@@ -2303,6 +2486,19 @@</span> <span class="p_context"> int qlt_xmit_response(struct qla_tgt_cmd *cmd, int xmit_type,</span>
 	unsigned long flags = 0;
 	int res;
 
<span class="p_add">+	spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);</span>
<span class="p_add">+	if (cmd-&gt;sess &amp;&amp; cmd-&gt;sess-&gt;deleted == QLA_SESS_DELETION_IN_PROGRESS) {</span>
<span class="p_add">+		cmd-&gt;state = QLA_TGT_STATE_PROCESSED;</span>
<span class="p_add">+		if (cmd-&gt;sess-&gt;logout_completed)</span>
<span class="p_add">+			/* no need to terminate. FW already freed exchange. */</span>
<span class="p_add">+			qlt_abort_cmd_on_host_reset(cmd-&gt;vha, cmd);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			qlt_send_term_exchange(vha, cmd, &amp;cmd-&gt;atio, 1);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</span>
<span class="p_add">+</span>
 	memset(&amp;prm, 0, sizeof(prm));
 	qlt_check_srr_debug(cmd, &amp;xmit_type);
 
<span class="p_chunk">@@ -2315,9 +2511,6 @@</span> <span class="p_context"> int qlt_xmit_response(struct qla_tgt_cmd *cmd, int xmit_type,</span>
 	res = qlt_pre_xmit_response(cmd, &amp;prm, xmit_type, scsi_status,
 	    &amp;full_req_cnt);
 	if (unlikely(res != 0)) {
<span class="p_del">-		if (res == QLA_TGT_PRE_XMIT_RESP_CMD_ABORTED)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-</span>
 		return res;
 	}
 
<span class="p_chunk">@@ -2347,9 +2540,10 @@</span> <span class="p_context"> int qlt_xmit_response(struct qla_tgt_cmd *cmd, int xmit_type,</span>
 		res = qlt_build_ctio_crc2_pkt(&amp;prm, vha);
 	else
 		res = qlt_24xx_build_ctio_pkt(&amp;prm, vha);
<span class="p_del">-	if (unlikely(res != 0))</span>
<span class="p_add">+	if (unlikely(res != 0)) {</span>
<span class="p_add">+		vha-&gt;req-&gt;cnt += full_req_cnt;</span>
 		goto out_unmap_unlock;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
 
 	pkt = (struct ctio7_to_24xx *)prm.pkt;
 
<span class="p_chunk">@@ -2463,7 +2657,8 @@</span> <span class="p_context"> int qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd)</span>
 
 	spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);
 
<span class="p_del">-	if (qla2x00_reset_active(vha) || cmd-&gt;reset_count != ha-&gt;chip_reset) {</span>
<span class="p_add">+	if (qla2x00_reset_active(vha) || (cmd-&gt;reset_count != ha-&gt;chip_reset) ||</span>
<span class="p_add">+	    (cmd-&gt;sess &amp;&amp; cmd-&gt;sess-&gt;deleted == QLA_SESS_DELETION_IN_PROGRESS)) {</span>
 		/*
 		 * Either a chip reset is active or this request was from
 		 * previous life, just abort the processing.
<span class="p_chunk">@@ -2487,8 +2682,11 @@</span> <span class="p_context"> int qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd)</span>
 	else
 		res = qlt_24xx_build_ctio_pkt(&amp;prm, vha);
 
<span class="p_del">-	if (unlikely(res != 0))</span>
<span class="p_add">+	if (unlikely(res != 0)) {</span>
<span class="p_add">+		vha-&gt;req-&gt;cnt += prm.req_cnt;</span>
 		goto out_unlock_free_unmap;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pkt = (struct ctio7_to_24xx *)prm.pkt;
 	pkt-&gt;u.status0.flags |= __constant_cpu_to_le16(CTIO7_FLAGS_DATA_OUT |
 	    CTIO7_FLAGS_STATUS_MODE_0);
<span class="p_chunk">@@ -2653,6 +2851,89 @@</span> <span class="p_context"> out:</span>
 
 /* If hardware_lock held on entry, might drop it, then reaquire */
 /* This function sends the appropriate CTIO to ISP 2xxx or 24xx */
<span class="p_add">+static int __qlt_send_term_imm_notif(struct scsi_qla_host *vha,</span>
<span class="p_add">+	struct imm_ntfy_from_isp *ntfy)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nack_to_isp *nack;</span>
<span class="p_add">+	struct qla_hw_data *ha = vha-&gt;hw;</span>
<span class="p_add">+	request_t *pkt;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ql_dbg(ql_dbg_tgt_tmr, vha, 0xe01c,</span>
<span class="p_add">+	    &quot;Sending TERM ELS CTIO (ha=%p)\n&quot;, ha);</span>
<span class="p_add">+</span>
<span class="p_add">+	pkt = (request_t *)qla2x00_alloc_iocbs_ready(vha, NULL);</span>
<span class="p_add">+	if (pkt == NULL) {</span>
<span class="p_add">+		ql_dbg(ql_dbg_tgt, vha, 0xe080,</span>
<span class="p_add">+		    &quot;qla_target(%d): %s failed: unable to allocate &quot;</span>
<span class="p_add">+		    &quot;request packet\n&quot;, vha-&gt;vp_idx, __func__);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pkt-&gt;entry_type = NOTIFY_ACK_TYPE;</span>
<span class="p_add">+	pkt-&gt;entry_count = 1;</span>
<span class="p_add">+	pkt-&gt;handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;</span>
<span class="p_add">+</span>
<span class="p_add">+	nack = (struct nack_to_isp *)pkt;</span>
<span class="p_add">+	nack-&gt;ox_id = ntfy-&gt;ox_id;</span>
<span class="p_add">+</span>
<span class="p_add">+	nack-&gt;u.isp24.nport_handle = ntfy-&gt;u.isp24.nport_handle;</span>
<span class="p_add">+	if (le16_to_cpu(ntfy-&gt;u.isp24.status) == IMM_NTFY_ELS) {</span>
<span class="p_add">+		nack-&gt;u.isp24.flags = ntfy-&gt;u.isp24.flags &amp;</span>
<span class="p_add">+			__constant_cpu_to_le32(NOTIFY24XX_FLAGS_PUREX_IOCB);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* terminate */</span>
<span class="p_add">+	nack-&gt;u.isp24.flags |=</span>
<span class="p_add">+		__constant_cpu_to_le16(NOTIFY_ACK_FLAGS_TERMINATE);</span>
<span class="p_add">+</span>
<span class="p_add">+	nack-&gt;u.isp24.srr_rx_id = ntfy-&gt;u.isp24.srr_rx_id;</span>
<span class="p_add">+	nack-&gt;u.isp24.status = ntfy-&gt;u.isp24.status;</span>
<span class="p_add">+	nack-&gt;u.isp24.status_subcode = ntfy-&gt;u.isp24.status_subcode;</span>
<span class="p_add">+	nack-&gt;u.isp24.fw_handle = ntfy-&gt;u.isp24.fw_handle;</span>
<span class="p_add">+	nack-&gt;u.isp24.exchange_address = ntfy-&gt;u.isp24.exchange_address;</span>
<span class="p_add">+	nack-&gt;u.isp24.srr_rel_offs = ntfy-&gt;u.isp24.srr_rel_offs;</span>
<span class="p_add">+	nack-&gt;u.isp24.srr_ui = ntfy-&gt;u.isp24.srr_ui;</span>
<span class="p_add">+	nack-&gt;u.isp24.vp_index = ntfy-&gt;u.isp24.vp_index;</span>
<span class="p_add">+</span>
<span class="p_add">+	qla2x00_start_iocbs(vha, vha-&gt;req);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void qlt_send_term_imm_notif(struct scsi_qla_host *vha,</span>
<span class="p_add">+	struct imm_ntfy_from_isp *imm, int ha_locked)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags = 0;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (qlt_issue_marker(vha, ha_locked) &lt; 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ha_locked) {</span>
<span class="p_add">+		rc = __qlt_send_term_imm_notif(vha, imm);</span>
<span class="p_add">+</span>
<span class="p_add">+#if 0	/* Todo  */</span>
<span class="p_add">+		if (rc == -ENOMEM)</span>
<span class="p_add">+			qlt_alloc_qfull_cmd(vha, imm, 0, 0);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;vha-&gt;hw-&gt;hardware_lock, flags);</span>
<span class="p_add">+	rc = __qlt_send_term_imm_notif(vha, imm);</span>
<span class="p_add">+</span>
<span class="p_add">+#if 0	/* Todo */</span>
<span class="p_add">+	if (rc == -ENOMEM)</span>
<span class="p_add">+		qlt_alloc_qfull_cmd(vha, imm, 0, 0);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+done:</span>
<span class="p_add">+	if (!ha_locked)</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;vha-&gt;hw-&gt;hardware_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* If hardware_lock held on entry, might drop it, then reaquire */</span>
<span class="p_add">+/* This function sends the appropriate CTIO to ISP 2xxx or 24xx */</span>
 static int __qlt_send_term_exchange(struct scsi_qla_host *vha,
 	struct qla_tgt_cmd *cmd,
 	struct atio_from_isp *atio)
<span class="p_chunk">@@ -2717,7 +2998,7 @@</span> <span class="p_context"> static int __qlt_send_term_exchange(struct scsi_qla_host *vha,</span>
 static void qlt_send_term_exchange(struct scsi_qla_host *vha,
 	struct qla_tgt_cmd *cmd, struct atio_from_isp *atio, int ha_locked)
 {
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	unsigned long flags = 0;</span>
 	int rc;
 
 	if (qlt_issue_marker(vha, ha_locked) &lt; 0)
<span class="p_chunk">@@ -2733,17 +3014,18 @@</span> <span class="p_context"> static void qlt_send_term_exchange(struct scsi_qla_host *vha,</span>
 	rc = __qlt_send_term_exchange(vha, cmd, atio);
 	if (rc == -ENOMEM)
 		qlt_alloc_qfull_cmd(vha, atio, 0, 0);
<span class="p_del">-	spin_unlock_irqrestore(&amp;vha-&gt;hw-&gt;hardware_lock, flags);</span>
 
 done:
 	if (cmd &amp;&amp; ((cmd-&gt;state != QLA_TGT_STATE_ABORTED) ||
 	    !cmd-&gt;cmd_sent_to_fw)) {
<span class="p_del">-		if (!ha_locked &amp;&amp; !in_interrupt())</span>
<span class="p_del">-			msleep(250); /* just in case */</span>
<span class="p_del">-</span>
<span class="p_del">-		qlt_unmap_sg(vha, cmd);</span>
<span class="p_add">+		if (cmd-&gt;sg_mapped)</span>
<span class="p_add">+			qlt_unmap_sg(vha, cmd);</span>
 		vha-&gt;hw-&gt;tgt.tgt_ops-&gt;free_cmd(cmd);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!ha_locked)</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;vha-&gt;hw-&gt;hardware_lock, flags);</span>
<span class="p_add">+</span>
 	return;
 }
 
<span class="p_chunk">@@ -2794,6 +3076,22 @@</span> <span class="p_context"> static void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha)</span>
 
 }
 
<span class="p_add">+void qlt_abort_cmd(struct qla_tgt_cmd *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct qla_tgt *tgt = cmd-&gt;tgt;</span>
<span class="p_add">+	struct scsi_qla_host *vha = tgt-&gt;vha;</span>
<span class="p_add">+</span>
<span class="p_add">+	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,</span>
<span class="p_add">+	    &quot;qla_target(%d): terminating exchange for aborted cmd=%p &quot;</span>
<span class="p_add">+	    &quot;(se_cmd=%p, tag=%d)&quot;, vha-&gt;vp_idx, cmd, &amp;cmd-&gt;se_cmd, cmd-&gt;tag);</span>
<span class="p_add">+</span>
<span class="p_add">+	cmd-&gt;state = QLA_TGT_STATE_ABORTED;</span>
<span class="p_add">+	cmd-&gt;cmd_flags |= BIT_6;</span>
<span class="p_add">+</span>
<span class="p_add">+	qlt_send_term_exchange(vha, cmd, &amp;cmd-&gt;atio, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(qlt_abort_cmd);</span>
<span class="p_add">+</span>
 void qlt_free_cmd(struct qla_tgt_cmd *cmd)
 {
 	struct qla_tgt_sess *sess = cmd-&gt;sess;
<span class="p_chunk">@@ -3265,6 +3563,13 @@</span> <span class="p_context"> static void __qlt_do_work(struct qla_tgt_cmd *cmd)</span>
 	if (tgt-&gt;tgt_stop)
 		goto out_term;
 
<span class="p_add">+	if (cmd-&gt;state == QLA_TGT_STATE_ABORTED) {</span>
<span class="p_add">+		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf082,</span>
<span class="p_add">+		    &quot;cmd with tag %u is aborted\n&quot;,</span>
<span class="p_add">+		    cmd-&gt;atio.u.isp24.exchange_addr);</span>
<span class="p_add">+		goto out_term;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	cdb = &amp;atio-&gt;u.isp24.fcp_cmnd.cdb[0];
 	cmd-&gt;tag = atio-&gt;u.isp24.exchange_addr;
 	cmd-&gt;unpacked_lun = scsilun_to_int(
<span class="p_chunk">@@ -3318,6 +3623,12 @@</span> <span class="p_context"> out_term:</span>
 static void qlt_do_work(struct work_struct *work)
 {
 	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
<span class="p_add">+	scsi_qla_host_t *vha = cmd-&gt;vha;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;vha-&gt;cmd_list_lock, flags);</span>
<span class="p_add">+	list_del(&amp;cmd-&gt;cmd_list);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;vha-&gt;cmd_list_lock, flags);</span>
 
 	__qlt_do_work(cmd);
 }
<span class="p_chunk">@@ -3347,6 +3658,11 @@</span> <span class="p_context"> static struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,</span>
 	cmd-&gt;loop_id = sess-&gt;loop_id;
 	cmd-&gt;conf_compl_supported = sess-&gt;conf_compl_supported;
 
<span class="p_add">+	cmd-&gt;cmd_flags = 0;</span>
<span class="p_add">+	cmd-&gt;jiffies_at_alloc = get_jiffies_64();</span>
<span class="p_add">+</span>
<span class="p_add">+	cmd-&gt;reset_count = vha-&gt;hw-&gt;chip_reset;</span>
<span class="p_add">+</span>
 	return cmd;
 }
 
<span class="p_chunk">@@ -3364,14 +3680,25 @@</span> <span class="p_context"> static void qlt_create_sess_from_atio(struct work_struct *work)</span>
 	unsigned long flags;
 	uint8_t *s_id = op-&gt;atio.u.isp24.fcp_hdr.s_id;
 
<span class="p_add">+	spin_lock_irqsave(&amp;vha-&gt;cmd_list_lock, flags);</span>
<span class="p_add">+	list_del(&amp;op-&gt;cmd_list);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;vha-&gt;cmd_list_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (op-&gt;aborted) {</span>
<span class="p_add">+		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf083,</span>
<span class="p_add">+		    &quot;sess_op with tag %u is aborted\n&quot;,</span>
<span class="p_add">+		    op-&gt;atio.u.isp24.exchange_addr);</span>
<span class="p_add">+		goto out_term;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,
<span class="p_del">-		&quot;qla_target(%d): Unable to find wwn login&quot;</span>
<span class="p_del">-		&quot; (s_id %x:%x:%x), trying to create it manually\n&quot;,</span>
<span class="p_del">-		vha-&gt;vp_idx, s_id[0], s_id[1], s_id[2]);</span>
<span class="p_add">+	    &quot;qla_target(%d): Unable to find wwn login&quot;</span>
<span class="p_add">+	    &quot; (s_id %x:%x:%x), trying to create it manually\n&quot;,</span>
<span class="p_add">+	    vha-&gt;vp_idx, s_id[0], s_id[1], s_id[2]);</span>
 
 	if (op-&gt;atio.u.raw.entry_count &gt; 1) {
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,
<span class="p_del">-		        &quot;Dropping multy entry atio %p\n&quot;, &amp;op-&gt;atio);</span>
<span class="p_add">+		    &quot;Dropping multy entry atio %p\n&quot;, &amp;op-&gt;atio);</span>
 		goto out_term;
 	}
 
<span class="p_chunk">@@ -3436,10 +3763,25 @@</span> <span class="p_context"> static int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha,</span>
 
 		memcpy(&amp;op-&gt;atio, atio, sizeof(*atio));
 		op-&gt;vha = vha;
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+		list_add_tail(&amp;op-&gt;cmd_list, &amp;vha-&gt;qla_sess_op_cmd_list);</span>
<span class="p_add">+		spin_unlock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+</span>
 		INIT_WORK(&amp;op-&gt;work, qlt_create_sess_from_atio);
 		queue_work(qla_tgt_wq, &amp;op-&gt;work);
 		return 0;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* Another WWN used to have our s_id. Our PLOGI scheduled its</span>
<span class="p_add">+	 * session deletion, but it&#39;s still in sess_del_work wq */</span>
<span class="p_add">+	if (sess-&gt;deleted == QLA_SESS_DELETION_IN_PROGRESS) {</span>
<span class="p_add">+		ql_dbg(ql_dbg_io, vha, 0x3061,</span>
<span class="p_add">+		    &quot;New command while old session %p is being deleted\n&quot;,</span>
<span class="p_add">+		    sess);</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Do kref_get() before returning + dropping qla_hw_data-&gt;hardware_lock.
 	 */
<span class="p_chunk">@@ -3453,13 +3795,13 @@</span> <span class="p_context"> static int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha,</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	cmd-&gt;cmd_flags = 0;</span>
<span class="p_del">-	cmd-&gt;jiffies_at_alloc = get_jiffies_64();</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;reset_count = vha-&gt;hw-&gt;chip_reset;</span>
<span class="p_del">-</span>
 	cmd-&gt;cmd_in_wq = 1;
 	cmd-&gt;cmd_flags |= BIT_0;
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+	list_add_tail(&amp;cmd-&gt;cmd_list, &amp;vha-&gt;qla_cmd_list);</span>
<span class="p_add">+	spin_unlock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+</span>
 	INIT_WORK(&amp;cmd-&gt;work, qlt_do_work);
 	queue_work(qla_tgt_wq, &amp;cmd-&gt;work);
 	return 0;
<span class="p_chunk">@@ -3473,6 +3815,7 @@</span> <span class="p_context"> static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess, uint32_t lun,</span>
 	struct scsi_qla_host *vha = sess-&gt;vha;
 	struct qla_hw_data *ha = vha-&gt;hw;
 	struct qla_tgt_mgmt_cmd *mcmd;
<span class="p_add">+	struct atio_from_isp *a = (struct atio_from_isp *)iocb;</span>
 	int res;
 	uint8_t tmr_func;
 
<span class="p_chunk">@@ -3513,6 +3856,7 @@</span> <span class="p_context"> static int qlt_issue_task_mgmt(struct qla_tgt_sess *sess, uint32_t lun,</span>
 		ql_dbg(ql_dbg_tgt_tmr, vha, 0x10002,
 		    &quot;qla_target(%d): LUN_RESET received\n&quot;, sess-&gt;vha-&gt;vp_idx);
 		tmr_func = TMR_LUN_RESET;
<span class="p_add">+		abort_cmds_for_lun(vha, lun, a-&gt;u.isp24.fcp_hdr.s_id);</span>
 		break;
 
 	case QLA_TGT_CLEAR_TS:
<span class="p_chunk">@@ -3601,6 +3945,9 @@</span> <span class="p_context"> static int qlt_handle_task_mgmt(struct scsi_qla_host *vha, void *iocb)</span>
 		    sizeof(struct atio_from_isp));
 	}
 
<span class="p_add">+	if (sess-&gt;deleted == QLA_SESS_DELETION_IN_PROGRESS)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
 	return qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);
 }
 
<span class="p_chunk">@@ -3666,22 +4013,280 @@</span> <span class="p_context"> static int qlt_abort_task(struct scsi_qla_host *vha,</span>
 	return __qlt_abort_task(vha, iocb, sess);
 }
 
<span class="p_add">+void qlt_logo_completion_handler(fc_port_t *fcport, int rc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (fcport-&gt;tgt_session) {</span>
<span class="p_add">+		if (rc != MBS_COMMAND_COMPLETE) {</span>
<span class="p_add">+			ql_dbg(ql_dbg_tgt_mgt, fcport-&gt;vha, 0xf093,</span>
<span class="p_add">+				&quot;%s: se_sess %p / sess %p from&quot;</span>
<span class="p_add">+				&quot; port %8phC loop_id %#04x s_id %02x:%02x:%02x&quot;</span>
<span class="p_add">+				&quot; LOGO failed: %#x\n&quot;,</span>
<span class="p_add">+				__func__,</span>
<span class="p_add">+				fcport-&gt;tgt_session-&gt;se_sess,</span>
<span class="p_add">+				fcport-&gt;tgt_session,</span>
<span class="p_add">+				fcport-&gt;port_name, fcport-&gt;loop_id,</span>
<span class="p_add">+				fcport-&gt;d_id.b.domain, fcport-&gt;d_id.b.area,</span>
<span class="p_add">+				fcport-&gt;d_id.b.al_pa, rc);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		fcport-&gt;tgt_session-&gt;logout_completed = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void qlt_swap_imm_ntfy_iocb(struct imm_ntfy_from_isp *a,</span>
<span class="p_add">+    struct imm_ntfy_from_isp *b)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imm_ntfy_from_isp tmp;</span>
<span class="p_add">+	memcpy(&amp;tmp, a, sizeof(struct imm_ntfy_from_isp));</span>
<span class="p_add">+	memcpy(a, b, sizeof(struct imm_ntfy_from_isp));</span>
<span class="p_add">+	memcpy(b, &amp;tmp, sizeof(struct imm_ntfy_from_isp));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+* ha-&gt;hardware_lock supposed to be held on entry (to protect tgt-&gt;sess_list)</span>
<span class="p_add">+*</span>
<span class="p_add">+* Schedules sessions with matching port_id/loop_id but different wwn for</span>
<span class="p_add">+* deletion. Returns existing session with matching wwn if present.</span>
<span class="p_add">+* Null otherwise.</span>
<span class="p_add">+*/</span>
<span class="p_add">+static struct qla_tgt_sess *</span>
<span class="p_add">+qlt_find_sess_invalidate_other(struct qla_tgt *tgt, uint64_t wwn,</span>
<span class="p_add">+    port_id_t port_id, uint16_t loop_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct qla_tgt_sess *sess = NULL, *other_sess;</span>
<span class="p_add">+	uint64_t other_wwn;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(other_sess, &amp;tgt-&gt;sess_list, sess_list_entry) {</span>
<span class="p_add">+</span>
<span class="p_add">+		other_wwn = wwn_to_u64(other_sess-&gt;port_name);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (wwn == other_wwn) {</span>
<span class="p_add">+			WARN_ON(sess);</span>
<span class="p_add">+			sess = other_sess;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* find other sess with nport_id collision */</span>
<span class="p_add">+		if (port_id.b24 == other_sess-&gt;s_id.b24) {</span>
<span class="p_add">+			if (loop_id != other_sess-&gt;loop_id) {</span>
<span class="p_add">+				ql_dbg(ql_dbg_tgt_tmr, tgt-&gt;vha, 0x1000c,</span>
<span class="p_add">+				    &quot;Invalidating sess %p loop_id %d wwn %llx.\n&quot;,</span>
<span class="p_add">+				    other_sess, other_sess-&gt;loop_id, other_wwn);</span>
<span class="p_add">+</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * logout_on_delete is set by default, but another</span>
<span class="p_add">+				 * session that has the same s_id/loop_id combo</span>
<span class="p_add">+				 * might have cleared it when requested this session</span>
<span class="p_add">+				 * deletion, so don&#39;t touch it</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				qlt_schedule_sess_for_deletion(other_sess, true);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Another wwn used to have our s_id/loop_id</span>
<span class="p_add">+				 * combo - kill the session, but don&#39;t log out</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				sess-&gt;logout_on_delete = 0;</span>
<span class="p_add">+				qlt_schedule_sess_for_deletion(other_sess,</span>
<span class="p_add">+				    true);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* find other sess with nport handle collision */</span>
<span class="p_add">+		if (loop_id == other_sess-&gt;loop_id) {</span>
<span class="p_add">+			ql_dbg(ql_dbg_tgt_tmr, tgt-&gt;vha, 0x1000d,</span>
<span class="p_add">+			       &quot;Invalidating sess %p loop_id %d wwn %llx.\n&quot;,</span>
<span class="p_add">+			       other_sess, other_sess-&gt;loop_id, other_wwn);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Same loop_id but different s_id</span>
<span class="p_add">+			 * Ok to kill and logout */</span>
<span class="p_add">+			qlt_schedule_sess_for_deletion(other_sess, true);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return sess;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Abort any commands for this s_id waiting on qla_tgt_wq workqueue */</span>
<span class="p_add">+static int abort_cmds_for_s_id(struct scsi_qla_host *vha, port_id_t *s_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct qla_tgt_sess_op *op;</span>
<span class="p_add">+	struct qla_tgt_cmd *cmd;</span>
<span class="p_add">+	uint32_t key;</span>
<span class="p_add">+	int count = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	key = (((u32)s_id-&gt;b.domain &lt;&lt; 16) |</span>
<span class="p_add">+	       ((u32)s_id-&gt;b.area   &lt;&lt;  8) |</span>
<span class="p_add">+	       ((u32)s_id-&gt;b.al_pa));</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+	list_for_each_entry(op, &amp;vha-&gt;qla_sess_op_cmd_list, cmd_list) {</span>
<span class="p_add">+		uint32_t op_key = sid_to_key(op-&gt;atio.u.isp24.fcp_hdr.s_id);</span>
<span class="p_add">+		if (op_key == key) {</span>
<span class="p_add">+			op-&gt;aborted = true;</span>
<span class="p_add">+			count++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	list_for_each_entry(cmd, &amp;vha-&gt;qla_cmd_list, cmd_list) {</span>
<span class="p_add">+		uint32_t cmd_key = sid_to_key(cmd-&gt;atio.u.isp24.fcp_hdr.s_id);</span>
<span class="p_add">+		if (cmd_key == key) {</span>
<span class="p_add">+			cmd-&gt;state = QLA_TGT_STATE_ABORTED;</span>
<span class="p_add">+			count++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock(&amp;vha-&gt;cmd_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return count;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * ha-&gt;hardware_lock supposed to be held on entry. Might drop it, then reaquire
  */
 static int qlt_24xx_handle_els(struct scsi_qla_host *vha,
 	struct imm_ntfy_from_isp *iocb)
 {
<span class="p_add">+	struct qla_tgt *tgt = vha-&gt;vha_tgt.qla_tgt;</span>
<span class="p_add">+	struct qla_hw_data *ha = vha-&gt;hw;</span>
<span class="p_add">+	struct qla_tgt_sess *sess = NULL;</span>
<span class="p_add">+	uint64_t wwn;</span>
<span class="p_add">+	port_id_t port_id;</span>
<span class="p_add">+	uint16_t loop_id;</span>
<span class="p_add">+	uint16_t wd3_lo;</span>
 	int res = 0;
 
<span class="p_add">+	wwn = wwn_to_u64(iocb-&gt;u.isp24.port_name);</span>
<span class="p_add">+</span>
<span class="p_add">+	port_id.b.domain = iocb-&gt;u.isp24.port_id[2];</span>
<span class="p_add">+	port_id.b.area   = iocb-&gt;u.isp24.port_id[1];</span>
<span class="p_add">+	port_id.b.al_pa  = iocb-&gt;u.isp24.port_id[0];</span>
<span class="p_add">+	port_id.b.rsvd_1 = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	loop_id = le16_to_cpu(iocb-&gt;u.isp24.nport_handle);</span>
<span class="p_add">+</span>
 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf026,
 	    &quot;qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n&quot;,
 	    vha-&gt;vp_idx, iocb-&gt;u.isp24.port_id, iocb-&gt;u.isp24.status_subcode);
 
<span class="p_add">+	/* res = 1 means ack at the end of thread</span>
<span class="p_add">+	 * res = 0 means ack async/later.</span>
<span class="p_add">+	 */</span>
 	switch (iocb-&gt;u.isp24.status_subcode) {
 	case ELS_PLOGI:
<span class="p_del">-	case ELS_FLOGI:</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Mark all stale commands in qla_tgt_wq for deletion */</span>
<span class="p_add">+		abort_cmds_for_s_id(vha, &amp;port_id);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (wwn)</span>
<span class="p_add">+			sess = qlt_find_sess_invalidate_other(tgt, wwn,</span>
<span class="p_add">+			    port_id, loop_id);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!sess || IS_SW_RESV_ADDR(sess-&gt;s_id)) {</span>
<span class="p_add">+			res = 1;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sess-&gt;plogi_ack_needed) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Initiator sent another PLOGI before last PLOGI could</span>
<span class="p_add">+			 * finish. Swap plogi iocbs and terminate old one</span>
<span class="p_add">+			 * without acking, new one will get acked when session</span>
<span class="p_add">+			 * deletion completes.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ql_log(ql_log_warn, sess-&gt;vha, 0xf094,</span>
<span class="p_add">+			    &quot;sess %p received double plogi.\n&quot;, sess);</span>
<span class="p_add">+</span>
<span class="p_add">+			qlt_swap_imm_ntfy_iocb(iocb, &amp;sess-&gt;tm_iocb);</span>
<span class="p_add">+</span>
<span class="p_add">+			qlt_send_term_imm_notif(vha, iocb, 1);</span>
<span class="p_add">+</span>
<span class="p_add">+			res = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		res = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Save immediate Notif IOCB for Ack when sess is done</span>
<span class="p_add">+		 * and being deleted.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		memcpy(&amp;sess-&gt;tm_iocb, iocb, sizeof(sess-&gt;tm_iocb));</span>
<span class="p_add">+		sess-&gt;plogi_ack_needed  = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		 /*</span>
<span class="p_add">+		  * Under normal circumstances we want to release nport handle</span>
<span class="p_add">+		  * during LOGO process to avoid nport handle leaks inside FW.</span>
<span class="p_add">+		  * The exception is when LOGO is done while another PLOGI with</span>
<span class="p_add">+		  * the same nport handle is waiting as might be the case here.</span>
<span class="p_add">+		  * Note: there is always a possibily of a race where session</span>
<span class="p_add">+		  * deletion has already started for other reasons (e.g. ACL</span>
<span class="p_add">+		  * removal) and now PLOGI arrives:</span>
<span class="p_add">+		  * 1. if PLOGI arrived in FW after nport handle has been freed,</span>
<span class="p_add">+		  *    FW must have assigned this PLOGI a new/same handle and we</span>
<span class="p_add">+		  *    can proceed ACK&#39;ing it as usual when session deletion</span>
<span class="p_add">+		  *    completes.</span>
<span class="p_add">+		  * 2. if PLOGI arrived in FW before LOGO with LCF_FREE_NPORT</span>
<span class="p_add">+		  *    bit reached it, the handle has now been released. We&#39;ll</span>
<span class="p_add">+		  *    get an error when we ACK this PLOGI. Nothing will be sent</span>
<span class="p_add">+		  *    back to initiator. Initiator should eventually retry</span>
<span class="p_add">+		  *    PLOGI and situation will correct itself.</span>
<span class="p_add">+		  */</span>
<span class="p_add">+		sess-&gt;keep_nport_handle = ((sess-&gt;loop_id == loop_id) &amp;&amp;</span>
<span class="p_add">+					   (sess-&gt;s_id.b24 == port_id.b24));</span>
<span class="p_add">+		qlt_schedule_sess_for_deletion(sess, true);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	case ELS_PRLI:
<span class="p_add">+		wd3_lo = le16_to_cpu(iocb-&gt;u.isp24.u.prli.wd3_lo);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (wwn)</span>
<span class="p_add">+			sess = qlt_find_sess_invalidate_other(tgt, wwn, port_id,</span>
<span class="p_add">+			    loop_id);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sess != NULL) {</span>
<span class="p_add">+			if (sess-&gt;deleted) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Impatient initiator sent PRLI before last</span>
<span class="p_add">+				 * PLOGI could finish. Will force him to re-try,</span>
<span class="p_add">+				 * while last one finishes.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				ql_log(ql_log_warn, sess-&gt;vha, 0xf095,</span>
<span class="p_add">+				    &quot;sess %p PRLI received, before plogi ack.\n&quot;,</span>
<span class="p_add">+				    sess);</span>
<span class="p_add">+				qlt_send_term_imm_notif(vha, iocb, 1);</span>
<span class="p_add">+				res = 0;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * This shouldn&#39;t happen under normal circumstances,</span>
<span class="p_add">+			 * since we have deleted the old session during PLOGI</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf096,</span>
<span class="p_add">+			    &quot;PRLI (loop_id %#04x) for existing sess %p (loop_id %#04x)\n&quot;,</span>
<span class="p_add">+			    sess-&gt;loop_id, sess, iocb-&gt;u.isp24.nport_handle);</span>
<span class="p_add">+</span>
<span class="p_add">+			sess-&gt;local = 0;</span>
<span class="p_add">+			sess-&gt;loop_id = loop_id;</span>
<span class="p_add">+			sess-&gt;s_id = port_id;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (wd3_lo &amp; BIT_7)</span>
<span class="p_add">+				sess-&gt;conf_compl_supported = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		}</span>
<span class="p_add">+		res = 1; /* send notify ack */</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Make session global (not used in fabric mode) */</span>
<span class="p_add">+		if (ha-&gt;current_topology != ISP_CFG_F) {</span>
<span class="p_add">+			set_bit(LOOP_RESYNC_NEEDED, &amp;vha-&gt;dpc_flags);</span>
<span class="p_add">+			set_bit(LOCAL_LOOP_UPDATE, &amp;vha-&gt;dpc_flags);</span>
<span class="p_add">+			qla2xxx_wake_dpc(vha);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* todo: else - create sess here. */</span>
<span class="p_add">+			res = 1; /* send notify ack */</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	case ELS_LOGO:
 	case ELS_PRLO:
 		res = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);
<span class="p_chunk">@@ -3699,6 +4304,7 @@</span> <span class="p_context"> static int qlt_24xx_handle_els(struct scsi_qla_host *vha,</span>
 		break;
 	}
 
<span class="p_add">+	case ELS_FLOGI:	/* should never happen */</span>
 	default:
 		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf061,
 		    &quot;qla_target(%d): Unsupported ELS command %x &quot;
<span class="p_chunk">@@ -5016,6 +5622,11 @@</span> <span class="p_context"> static void qlt_abort_work(struct qla_tgt *tgt,</span>
 		if (!sess)
 			goto out_term;
 	} else {
<span class="p_add">+		if (sess-&gt;deleted == QLA_SESS_DELETION_IN_PROGRESS) {</span>
<span class="p_add">+			sess = NULL;</span>
<span class="p_add">+			goto out_term;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		kref_get(&amp;sess-&gt;se_sess-&gt;sess_kref);
 	}
 
<span class="p_chunk">@@ -5070,6 +5681,11 @@</span> <span class="p_context"> static void qlt_tmr_work(struct qla_tgt *tgt,</span>
 		if (!sess)
 			goto out_term;
 	} else {
<span class="p_add">+		if (sess-&gt;deleted == QLA_SESS_DELETION_IN_PROGRESS) {</span>
<span class="p_add">+			sess = NULL;</span>
<span class="p_add">+			goto out_term;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		kref_get(&amp;sess-&gt;se_sess-&gt;sess_kref);
 	}
 
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.h b/drivers/scsi/qla2xxx/qla_target.h</span>
<span class="p_header">index 3320867..d30c60a 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.h</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.h</span>
<span class="p_chunk">@@ -167,7 +167,24 @@</span> <span class="p_context"> struct imm_ntfy_from_isp {</span>
 			uint32_t srr_rel_offs;
 			uint16_t srr_ui;
 			uint16_t srr_ox_id;
<span class="p_del">-			uint8_t  reserved_4[19];</span>
<span class="p_add">+			union {</span>
<span class="p_add">+				struct {</span>
<span class="p_add">+					uint8_t node_name[8];</span>
<span class="p_add">+				} plogi; /* PLOGI/ADISC/PDISC */</span>
<span class="p_add">+				struct {</span>
<span class="p_add">+					/* PRLI word 3 bit 0-15 */</span>
<span class="p_add">+					uint16_t wd3_lo;</span>
<span class="p_add">+					uint8_t resv0[6];</span>
<span class="p_add">+				} prli;</span>
<span class="p_add">+				struct {</span>
<span class="p_add">+					uint8_t port_id[3];</span>
<span class="p_add">+					uint8_t resv1;</span>
<span class="p_add">+					uint16_t nport_handle;</span>
<span class="p_add">+					uint16_t resv2;</span>
<span class="p_add">+				} req_els;</span>
<span class="p_add">+			} u;</span>
<span class="p_add">+			uint8_t port_name[8];</span>
<span class="p_add">+			uint8_t resv3[3];</span>
 			uint8_t  vp_index;
 			uint32_t reserved_5;
 			uint8_t  port_id[3];
<span class="p_chunk">@@ -234,6 +251,7 @@</span> <span class="p_context"> struct nack_to_isp {</span>
 	uint8_t  reserved[2];
 	uint16_t ox_id;
 } __packed;
<span class="p_add">+#define NOTIFY_ACK_FLAGS_TERMINATE	BIT_3</span>
 #define NOTIFY_ACK_SRR_FLAGS_ACCEPT	0
 #define NOTIFY_ACK_SRR_FLAGS_REJECT	1
 
<span class="p_chunk">@@ -790,13 +808,6 @@</span> <span class="p_context"> int qla2x00_wait_for_hba_online(struct scsi_qla_host *);</span>
 #define	FC_TM_REJECT                4
 #define FC_TM_FAILED                5
 
<span class="p_del">-/*</span>
<span class="p_del">- * Error code of qlt_pre_xmit_response() meaning that cmd&#39;s exchange was</span>
<span class="p_del">- * terminated, so no more actions is needed and success should be returned</span>
<span class="p_del">- * to target.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define QLA_TGT_PRE_XMIT_RESP_CMD_ABORTED	0x1717</span>
<span class="p_del">-</span>
 #if (BITS_PER_LONG &gt; 32) || defined(CONFIG_HIGHMEM64G)
 #define pci_dma_lo32(a) (a &amp; 0xffffffff)
 #define pci_dma_hi32(a) ((((a) &gt;&gt; 16)&gt;&gt;16) &amp; 0xffffffff)
<span class="p_chunk">@@ -874,6 +885,15 @@</span> <span class="p_context"> struct qla_tgt_sess_op {</span>
 	struct scsi_qla_host *vha;
 	struct atio_from_isp atio;
 	struct work_struct work;
<span class="p_add">+	struct list_head cmd_list;</span>
<span class="p_add">+	bool aborted;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+enum qla_sess_deletion {</span>
<span class="p_add">+	QLA_SESS_DELETION_NONE		= 0,</span>
<span class="p_add">+	QLA_SESS_DELETION_PENDING	= 1, /* hopefully we can get rid of</span>
<span class="p_add">+					      * this one */</span>
<span class="p_add">+	QLA_SESS_DELETION_IN_PROGRESS	= 2,</span>
 };
 
 /*
<span class="p_chunk">@@ -884,8 +904,15 @@</span> <span class="p_context"> struct qla_tgt_sess {</span>
 	port_id_t s_id;
 
 	unsigned int conf_compl_supported:1;
<span class="p_del">-	unsigned int deleted:1;</span>
<span class="p_add">+	unsigned int deleted:2;</span>
 	unsigned int local:1;
<span class="p_add">+	unsigned int logout_on_delete:1;</span>
<span class="p_add">+	unsigned int plogi_ack_needed:1;</span>
<span class="p_add">+	unsigned int keep_nport_handle:1;</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned char logout_completed;</span>
<span class="p_add">+</span>
<span class="p_add">+	int generation;</span>
 
 	struct se_session *se_sess;
 	struct scsi_qla_host *vha;
<span class="p_chunk">@@ -897,6 +924,10 @@</span> <span class="p_context"> struct qla_tgt_sess {</span>
 
 	uint8_t port_name[WWN_SIZE];
 	struct work_struct free_work;
<span class="p_add">+</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		struct imm_ntfy_from_isp tm_iocb;</span>
<span class="p_add">+	};</span>
 };
 
 struct qla_tgt_cmd {
<span class="p_chunk">@@ -912,7 +943,6 @@</span> <span class="p_context"> struct qla_tgt_cmd {</span>
 	unsigned int conf_compl_supported:1;
 	unsigned int sg_mapped:1;
 	unsigned int free_sg:1;
<span class="p_del">-	unsigned int aborted:1; /* Needed in case of SRR */</span>
 	unsigned int write_data_transferred:1;
 	unsigned int ctx_dsd_alloced:1;
 	unsigned int q_full:1;
<span class="p_chunk">@@ -1027,6 +1057,10 @@</span> <span class="p_context"> struct qla_tgt_srr_ctio {</span>
 	struct qla_tgt_cmd *cmd;
 };
 
<span class="p_add">+/* Check for Switch reserved address */</span>
<span class="p_add">+#define IS_SW_RESV_ADDR(_s_id) \</span>
<span class="p_add">+	((_s_id.b.domain == 0xff) &amp;&amp; (_s_id.b.area == 0xfc))</span>
<span class="p_add">+</span>
 #define QLA_TGT_XMIT_DATA		1
 #define QLA_TGT_XMIT_STATUS		2
 #define QLA_TGT_XMIT_ALL		(QLA_TGT_XMIT_STATUS|QLA_TGT_XMIT_DATA)
<span class="p_chunk">@@ -1044,7 +1078,7 @@</span> <span class="p_context"> extern int qlt_lport_register(void *, u64, u64, u64,</span>
 extern void qlt_lport_deregister(struct scsi_qla_host *);
 extern void qlt_unreg_sess(struct qla_tgt_sess *);
 extern void qlt_fc_port_added(struct scsi_qla_host *, fc_port_t *);
<span class="p_del">-extern void qlt_fc_port_deleted(struct scsi_qla_host *, fc_port_t *);</span>
<span class="p_add">+extern void qlt_fc_port_deleted(struct scsi_qla_host *, fc_port_t *, int);</span>
 extern int __init qlt_init(void);
 extern void qlt_exit(void);
 extern void qlt_update_vp_map(struct scsi_qla_host *, int);
<span class="p_chunk">@@ -1074,12 +1108,23 @@</span> <span class="p_context"> static inline void qla_reverse_ini_mode(struct scsi_qla_host *ha)</span>
 		ha-&gt;host-&gt;active_mode |= MODE_INITIATOR;
 }
 
<span class="p_add">+static inline uint32_t sid_to_key(const uint8_t *s_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t key;</span>
<span class="p_add">+</span>
<span class="p_add">+	key = (((unsigned long)s_id[0] &lt;&lt; 16) |</span>
<span class="p_add">+	       ((unsigned long)s_id[1] &lt;&lt; 8) |</span>
<span class="p_add">+	       (unsigned long)s_id[2]);</span>
<span class="p_add">+	return key;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Exported symbols from qla_target.c LLD logic used by qla2xxx code..
  */
 extern void qlt_response_pkt_all_vps(struct scsi_qla_host *, response_t *);
 extern int qlt_rdy_to_xfer(struct qla_tgt_cmd *);
 extern int qlt_xmit_response(struct qla_tgt_cmd *, int, uint8_t);
<span class="p_add">+extern void qlt_abort_cmd(struct qla_tgt_cmd *);</span>
 extern void qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *);
 extern void qlt_free_mcmd(struct qla_tgt_mgmt_cmd *);
 extern void qlt_free_cmd(struct qla_tgt_cmd *cmd);
<span class="p_chunk">@@ -1110,5 +1155,7 @@</span> <span class="p_context"> extern void qlt_stop_phase2(struct qla_tgt *);</span>
 extern irqreturn_t qla83xx_msix_atio_q(int, void *);
 extern void qlt_83xx_iospace_config(struct qla_hw_data *);
 extern int qlt_free_qfull_cmds(struct scsi_qla_host *);
<span class="p_add">+extern void qlt_logo_completion_handler(fc_port_t *, int);</span>
<span class="p_add">+extern void qlt_do_generation_tick(struct scsi_qla_host *, int *);</span>
 
 #endif /* __QLA_TARGET_H */
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/tcm_qla2xxx.c b/drivers/scsi/qla2xxx/tcm_qla2xxx.c</span>
<span class="p_header">index 272a264..a82db70 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c</span>
<span class="p_chunk">@@ -662,7 +662,6 @@</span> <span class="p_context"> static int tcm_qla2xxx_queue_data_in(struct se_cmd *se_cmd)</span>
 	cmd-&gt;cmd_flags |= BIT_4;
 	cmd-&gt;bufflen = se_cmd-&gt;data_length;
 	cmd-&gt;dma_data_direction = target_reverse_dma_direction(se_cmd);
<span class="p_del">-	cmd-&gt;aborted = (se_cmd-&gt;transport_state &amp; CMD_T_ABORTED);</span>
 
 	cmd-&gt;sg_cnt = se_cmd-&gt;t_data_nents;
 	cmd-&gt;sg = se_cmd-&gt;t_data_sg;
<span class="p_chunk">@@ -692,7 +691,6 @@</span> <span class="p_context"> static int tcm_qla2xxx_queue_status(struct se_cmd *se_cmd)</span>
 	cmd-&gt;sg_cnt = 0;
 	cmd-&gt;offset = 0;
 	cmd-&gt;dma_data_direction = target_reverse_dma_direction(se_cmd);
<span class="p_del">-	cmd-&gt;aborted = (se_cmd-&gt;transport_state &amp; CMD_T_ABORTED);</span>
 	if (cmd-&gt;cmd_flags &amp;  BIT_5) {
 		pr_crit(&quot;Bit_5 already set for cmd = %p.\n&quot;, cmd);
 		dump_stack();
<span class="p_chunk">@@ -757,14 +755,7 @@</span> <span class="p_context"> static void tcm_qla2xxx_aborted_task(struct se_cmd *se_cmd)</span>
 {
 	struct qla_tgt_cmd *cmd = container_of(se_cmd,
 				struct qla_tgt_cmd, se_cmd);
<span class="p_del">-	struct scsi_qla_host *vha = cmd-&gt;vha;</span>
<span class="p_del">-	struct qla_hw_data *ha = vha-&gt;hw;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!cmd-&gt;sg_mapped)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	pci_unmap_sg(ha-&gt;pdev, cmd-&gt;sg, cmd-&gt;sg_cnt, cmd-&gt;dma_data_direction);</span>
<span class="p_del">-	cmd-&gt;sg_mapped = 0;</span>
<span class="p_add">+	qlt_abort_cmd(cmd);</span>
 }
 
 static void tcm_qla2xxx_clear_sess_lookup(struct tcm_qla2xxx_lport *,
<span class="p_chunk">@@ -1273,9 +1264,7 @@</span> <span class="p_context"> static struct qla_tgt_sess *tcm_qla2xxx_find_sess_by_s_id(</span>
 		return NULL;
 	}
 
<span class="p_del">-	key = (((unsigned long)s_id[0] &lt;&lt; 16) |</span>
<span class="p_del">-	       ((unsigned long)s_id[1] &lt;&lt; 8) |</span>
<span class="p_del">-	       (unsigned long)s_id[2]);</span>
<span class="p_add">+	key = sid_to_key(s_id);</span>
 	pr_debug(&quot;find_sess_by_s_id: 0x%06x\n&quot;, key);
 
 	se_nacl = btree_lookup32(&amp;lport-&gt;lport_fcport_map, key);
<span class="p_chunk">@@ -1310,9 +1299,7 @@</span> <span class="p_context"> static void tcm_qla2xxx_set_sess_by_s_id(</span>
 	void *slot;
 	int rc;
 
<span class="p_del">-	key = (((unsigned long)s_id[0] &lt;&lt; 16) |</span>
<span class="p_del">-	       ((unsigned long)s_id[1] &lt;&lt; 8) |</span>
<span class="p_del">-	       (unsigned long)s_id[2]);</span>
<span class="p_add">+	key = sid_to_key(s_id);</span>
 	pr_debug(&quot;set_sess_by_s_id: %06x\n&quot;, key);
 
 	slot = btree_lookup32(&amp;lport-&gt;lport_fcport_map, key);
<span class="p_chunk">@@ -1670,6 +1657,10 @@</span> <span class="p_context"> static void tcm_qla2xxx_update_sess(struct qla_tgt_sess *sess, port_id_t s_id,</span>
 	}
 
 	sess-&gt;conf_compl_supported = conf_compl_supported;
<span class="p_add">+</span>
<span class="p_add">+	/* Reset logout parameters to default */</span>
<span class="p_add">+	sess-&gt;logout_on_delete = 1;</span>
<span class="p_add">+	sess-&gt;keep_nport_handle = 0;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c</span>
<span class="p_header">index 8afb016..9e3d16f 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_error.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_error.c</span>
<span class="p_chunk">@@ -950,7 +950,7 @@</span> <span class="p_context"> void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,</span>
 			    scmd-&gt;sdb.length);
 		scmd-&gt;sdb.table.sgl = &amp;ses-&gt;sense_sgl;
 		scmd-&gt;sc_data_direction = DMA_FROM_DEVICE;
<span class="p_del">-		scmd-&gt;sdb.table.nents = 1;</span>
<span class="p_add">+		scmd-&gt;sdb.table.nents = scmd-&gt;sdb.table.orig_nents = 1;</span>
 		scmd-&gt;cmnd[0] = REQUEST_SENSE;
 		scmd-&gt;cmnd[4] = scmd-&gt;sdb.length;
 		scmd-&gt;cmd_len = COMMAND_SIZE(scmd-&gt;cmnd[0]);
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index 7129701..397644d 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -583,7 +583,7 @@</span> <span class="p_context"> static struct scatterlist *scsi_sg_alloc(unsigned int nents, gfp_t gfp_mask)</span>
 
 static void scsi_free_sgtable(struct scsi_data_buffer *sdb, bool mq)
 {
<span class="p_del">-	if (mq &amp;&amp; sdb-&gt;table.nents &lt;= SCSI_MAX_SG_SEGMENTS)</span>
<span class="p_add">+	if (mq &amp;&amp; sdb-&gt;table.orig_nents &lt;= SCSI_MAX_SG_SEGMENTS)</span>
 		return;
 	__sg_free_table(&amp;sdb-&gt;table, SCSI_MAX_SG_SEGMENTS, mq, scsi_sg_free);
 }
<span class="p_chunk">@@ -597,8 +597,8 @@</span> <span class="p_context"> static int scsi_alloc_sgtable(struct scsi_data_buffer *sdb, int nents, bool mq)</span>
 
 	if (mq) {
 		if (nents &lt;= SCSI_MAX_SG_SEGMENTS) {
<span class="p_del">-			sdb-&gt;table.nents = nents;</span>
<span class="p_del">-			sg_init_table(sdb-&gt;table.sgl, sdb-&gt;table.nents);</span>
<span class="p_add">+			sdb-&gt;table.nents = sdb-&gt;table.orig_nents = nents;</span>
<span class="p_add">+			sg_init_table(sdb-&gt;table.sgl, nents);</span>
 			return 0;
 		}
 		first_chunk = sdb-&gt;table.sgl;
<span class="p_header">diff --git a/drivers/spi/spi-imx.c b/drivers/spi/spi-imx.c</span>
<span class="p_header">index 308c2d3..b9046f7 100644</span>
<span class="p_header">--- a/drivers/spi/spi-imx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-imx.c</span>
<span class="p_chunk">@@ -202,8 +202,9 @@</span> <span class="p_context"> static bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,</span>
 {
 	struct spi_imx_data *spi_imx = spi_master_get_devdata(master);
 
<span class="p_del">-	if (spi_imx-&gt;dma_is_inited &amp;&amp; (transfer-&gt;len &gt; spi_imx-&gt;rx_wml)</span>
<span class="p_del">-	    &amp;&amp; (transfer-&gt;len &gt; spi_imx-&gt;tx_wml))</span>
<span class="p_add">+	if (spi_imx-&gt;dma_is_inited</span>
<span class="p_add">+	    &amp;&amp; transfer-&gt;len &gt; spi_imx-&gt;rx_wml * sizeof(u32)</span>
<span class="p_add">+	    &amp;&amp; transfer-&gt;len &gt; spi_imx-&gt;tx_wml * sizeof(u32))</span>
 		return true;
 	return false;
 }
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 22d67c0..4e08d63 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -537,7 +537,7 @@</span> <span class="p_context"> static struct iscsit_transport iscsi_target_transport = {</span>
 
 static int __init iscsi_target_init_module(void)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = 0, size;</span>
 
 	pr_debug(&quot;iSCSI-Target &quot;ISCSIT_VERSION&quot;\n&quot;);
 
<span class="p_chunk">@@ -546,6 +546,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 		pr_err(&quot;Unable to allocate memory for iscsit_global\n&quot;);
 		return -1;
 	}
<span class="p_add">+	spin_lock_init(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 	mutex_init(&amp;auth_id_lock);
 	spin_lock_init(&amp;sess_idr_lock);
 	idr_init(&amp;tiqn_idr);
<span class="p_chunk">@@ -555,15 +556,11 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (ret &lt; 0)
 		goto out;
 
<span class="p_del">-	ret = iscsi_thread_set_init();</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	size = BITS_TO_LONGS(ISCSIT_BITMAP_BITS) * sizeof(long);</span>
<span class="p_add">+	iscsit_global-&gt;ts_bitmap = vzalloc(size);</span>
<span class="p_add">+	if (!iscsit_global-&gt;ts_bitmap) {</span>
<span class="p_add">+		pr_err(&quot;Unable to allocate iscsit_global-&gt;ts_bitmap\n&quot;);</span>
 		goto configfs_out;
<span class="p_del">-</span>
<span class="p_del">-	if (iscsi_allocate_thread_sets(TARGET_THREAD_SET_COUNT) !=</span>
<span class="p_del">-			TARGET_THREAD_SET_COUNT) {</span>
<span class="p_del">-		pr_err(&quot;iscsi_allocate_thread_sets() returned&quot;</span>
<span class="p_del">-			&quot; unexpected value!\n&quot;);</span>
<span class="p_del">-		goto ts_out1;</span>
 	}
 
 	lio_qr_cache = kmem_cache_create(&quot;lio_qr_cache&quot;,
<span class="p_chunk">@@ -572,7 +569,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (!lio_qr_cache) {
 		pr_err(&quot;nable to kmem_cache_create() for&quot;
 				&quot; lio_qr_cache\n&quot;);
<span class="p_del">-		goto ts_out2;</span>
<span class="p_add">+		goto bitmap_out;</span>
 	}
 
 	lio_dr_cache = kmem_cache_create(&quot;lio_dr_cache&quot;,
<span class="p_chunk">@@ -617,10 +614,8 @@</span> <span class="p_context"> dr_out:</span>
 	kmem_cache_destroy(lio_dr_cache);
 qr_out:
 	kmem_cache_destroy(lio_qr_cache);
<span class="p_del">-ts_out2:</span>
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-ts_out1:</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
<span class="p_add">+bitmap_out:</span>
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 configfs_out:
 	iscsi_target_deregister_configfs();
 out:
<span class="p_chunk">@@ -630,8 +625,6 @@</span> <span class="p_context"> out:</span>
 
 static void __exit iscsi_target_cleanup_module(void)
 {
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
 	iscsit_release_discovery_tpg();
 	iscsit_unregister_transport(&amp;iscsi_target_transport);
 	kmem_cache_destroy(lio_qr_cache);
<span class="p_chunk">@@ -641,6 +634,7 @@</span> <span class="p_context"> static void __exit iscsi_target_cleanup_module(void)</span>
 
 	iscsi_target_deregister_configfs();
 
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 	kfree(iscsit_global);
 }
 
<span class="p_chunk">@@ -3681,17 +3675,16 @@</span> <span class="p_context"> static int iscsit_send_reject(</span>
 
 void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
 {
<span class="p_del">-	struct iscsi_thread_set *ts = conn-&gt;thread_set;</span>
 	int ord, cpu;
 	/*
<span class="p_del">-	 * thread_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_del">-	 * within iscsi_thread_set.c:iscsi_allocate_thread_sets()</span>
<span class="p_add">+	 * bitmap_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_add">+	 * within iscsit_start_kthreads()</span>
 	 *
<span class="p_del">-	 * Here we use thread_id to determine which CPU that this</span>
<span class="p_del">-	 * iSCSI connection&#39;s iscsi_thread_set will be scheduled to</span>
<span class="p_add">+	 * Here we use bitmap_id to determine which CPU that this</span>
<span class="p_add">+	 * iSCSI connection&#39;s RX/TX threads will be scheduled to</span>
 	 * execute upon.
 	 */
<span class="p_del">-	ord = ts-&gt;thread_id % cpumask_weight(cpu_online_mask);</span>
<span class="p_add">+	ord = conn-&gt;bitmap_id % cpumask_weight(cpu_online_mask);</span>
 	for_each_online_cpu(cpu) {
 		if (ord-- == 0) {
 			cpumask_set_cpu(cpu, conn-&gt;conn_cpumask);
<span class="p_chunk">@@ -3880,7 +3873,7 @@</span> <span class="p_context"> check_rsp_state:</span>
 	switch (state) {
 	case ISTATE_SEND_LOGOUTRSP:
 		if (!iscsit_logout_post_handler(cmd, conn))
<span class="p_del">-			goto restart;</span>
<span class="p_add">+			return -ECONNRESET;</span>
 		/* fall through */
 	case ISTATE_SEND_STATUS:
 	case ISTATE_SEND_ASYNCMSG:
<span class="p_chunk">@@ -3908,8 +3901,6 @@</span> <span class="p_context"> check_rsp_state:</span>
 
 err:
 	return -1;
<span class="p_del">-restart:</span>
<span class="p_del">-	return -EAGAIN;</span>
 }
 
 static int iscsit_handle_response_queue(struct iscsi_conn *conn)
<span class="p_chunk">@@ -3936,21 +3927,13 @@</span> <span class="p_context"> static int iscsit_handle_response_queue(struct iscsi_conn *conn)</span>
 int iscsi_target_tx_thread(void *arg)
 {
 	int ret = 0;
<span class="p_del">-	struct iscsi_conn *conn;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
 
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_tx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-</span>
 	while (!kthread_should_stop()) {
 		/*
 		 * Ensure that both TX and RX per connection kthreads
<span class="p_chunk">@@ -3959,11 +3942,9 @@</span> <span class="p_context"> restart:</span>
 		iscsit_thread_check_cpumask(conn, current, 1);
 
 		wait_event_interruptible(conn-&gt;queues_wq,
<span class="p_del">-					 !iscsit_conn_all_queues_empty(conn) ||</span>
<span class="p_del">-					 ts-&gt;status == ISCSI_THREAD_SET_RESET);</span>
<span class="p_add">+					 !iscsit_conn_all_queues_empty(conn));</span>
 
<span class="p_del">-		if ((ts-&gt;status == ISCSI_THREAD_SET_RESET) ||</span>
<span class="p_del">-		     signal_pending(current))</span>
<span class="p_add">+		if (signal_pending(current))</span>
 			goto transport_err;
 
 get_immediate:
<span class="p_chunk">@@ -3974,15 +3955,20 @@</span> <span class="p_context"> get_immediate:</span>
 		ret = iscsit_handle_response_queue(conn);
 		if (ret == 1)
 			goto get_immediate;
<span class="p_del">-		else if (ret == -EAGAIN)</span>
<span class="p_del">-			goto restart;</span>
<span class="p_add">+		else if (ret == -ECONNRESET)</span>
<span class="p_add">+			goto out;</span>
 		else if (ret &lt; 0)
 			goto transport_err;
 	}
 
 transport_err:
<span class="p_del">-	iscsit_take_action_for_connection_exit(conn);</span>
<span class="p_del">-	goto restart;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Avoid the normal connection failure code-path if this connection</span>
<span class="p_add">+	 * is still within LOGIN mode, and iscsi_np process context is</span>
<span class="p_add">+	 * responsible for cleaning up the early connection failure.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (conn-&gt;conn_state != TARG_CONN_STATE_IN_LOGIN)</span>
<span class="p_add">+		iscsit_take_action_for_connection_exit(conn);</span>
 out:
 	return 0;
 }
<span class="p_chunk">@@ -4068,33 +4054,33 @@</span> <span class="p_context"> reject:</span>
 
 int iscsi_target_rx_thread(void *arg)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, rc;</span>
 	u8 buffer[ISCSI_HDR_LEN], opcode;
 	u32 checksum = 0, digest = 0;
<span class="p_del">-	struct iscsi_conn *conn = NULL;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	struct kvec iov;
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
<span class="p_del">-</span>
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_rx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait for iscsi_post_login_handler() to complete before allowing</span>
<span class="p_add">+	 * incoming iscsi/tcp socket I/O, and/or failing the connection.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rc = wait_for_completion_interruptible(&amp;conn-&gt;rx_login_comp);</span>
<span class="p_add">+	if (rc &lt; 0)</span>
<span class="p_add">+		return 0;</span>
 
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
<span class="p_del">-		int rc;</span>
 
 		init_completion(&amp;comp);
 		rc = wait_for_completion_interruptible(&amp;comp);
 		if (rc &lt; 0)
 			goto transport_err;
 
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto transport_err;</span>
 	}
 
 	while (!kthread_should_stop()) {
<span class="p_chunk">@@ -4170,8 +4156,6 @@</span> <span class="p_context"> transport_err:</span>
 	if (!signal_pending(current))
 		atomic_set(&amp;conn-&gt;transport_failed, 1);
 	iscsit_take_action_for_connection_exit(conn);
<span class="p_del">-	goto restart;</span>
<span class="p_del">-out:</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4233,7 +4217,24 @@</span> <span class="p_context"> int iscsit_close_connection(</span>
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)
 		complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsi_release_thread_set(conn);</span>
<span class="p_add">+	if (!strcmp(current-&gt;comm, ISCSI_RX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;tx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;tx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (!strcmp(current-&gt;comm, ISCSI_TX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;rx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;rx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;rx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 
 	iscsit_stop_timers_for_cmds(conn);
 	iscsit_stop_nopin_response_timer(conn);
<span class="p_chunk">@@ -4511,15 +4512,24 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 	struct iscsi_conn *conn)
 {
 	struct iscsi_session *sess = conn-&gt;sess;
<span class="p_del">-</span>
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = 1;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Traditional iscsi/tcp will invoke this logic from TX thread</span>
<span class="p_add">+	 * context during session logout, so clear tx_thread_active and</span>
<span class="p_add">+	 * sleep if iscsit_close_connection() has not already occured.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Since iser-target invokes this logic from it&#39;s own workqueue,</span>
<span class="p_add">+	 * always sleep waiting for RX/TX thread shutdown to complete</span>
<span class="p_add">+	 * within iscsit_close_connection().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)</span>
<span class="p_add">+		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
 	iscsit_dec_conn_usage_count(conn);
<span class="p_del">-	iscsit_stop_session(sess, 1, 1);</span>
<span class="p_add">+	iscsit_stop_session(sess, sleep, sleep);</span>
 	iscsit_dec_session_usage_count(sess);
 	target_put_session(sess-&gt;se_sess);
 }
<span class="p_chunk">@@ -4527,13 +4537,15 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 static void iscsit_logout_post_handler_samecid(
 	struct iscsi_conn *conn)
 {
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)</span>
<span class="p_add">+		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsit_cause_connection_reinstatement(conn, 1);</span>
<span class="p_add">+	iscsit_cause_connection_reinstatement(conn, sleep);</span>
 	iscsit_dec_conn_usage_count(conn);
 }
 
<span class="p_chunk">@@ -4747,6 +4759,7 @@</span> <span class="p_context"> int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)</span>
 	struct iscsi_session *sess;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
 	struct se_session *se_sess, *se_sess_tmp;
<span class="p_add">+	LIST_HEAD(free_list);</span>
 	int session_count = 0;
 
 	spin_lock_bh(&amp;se_tpg-&gt;session_lock);
<span class="p_chunk">@@ -4768,14 +4781,17 @@</span> <span class="p_context"> int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)</span>
 		}
 		atomic_set(&amp;sess-&gt;session_reinstatement, 1);
 		spin_unlock(&amp;sess-&gt;conn_lock);
<span class="p_del">-		spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
<span class="p_del">-		iscsit_free_session(sess);</span>
<span class="p_del">-		spin_lock_bh(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+		list_move_tail(&amp;se_sess-&gt;sess_list, &amp;free_list);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
<span class="p_add">+	list_for_each_entry_safe(se_sess, se_sess_tmp, &amp;free_list, sess_list) {</span>
<span class="p_add">+		sess = (struct iscsi_session *)se_sess-&gt;fabric_sess_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+		iscsit_free_session(sess);</span>
 		session_count++;
 	}
<span class="p_del">-	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);</span>
 
 	pr_debug(&quot;Released %d iSCSI Session(s) from Target Portal&quot;
 			&quot; Group: %hu\n&quot;, session_count, tpg-&gt;tpgt);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index cbcff38..fa4eb75 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -602,6 +602,12 @@</span> <span class="p_context"> struct iscsi_conn {</span>
 	struct iscsi_session	*sess;
 	/* Pointer to thread_set in use for this conn&#39;s threads */
 	struct iscsi_thread_set	*thread_set;
<span class="p_add">+	int			bitmap_id;</span>
<span class="p_add">+	int			rx_thread_active;</span>
<span class="p_add">+	struct task_struct	*rx_thread;</span>
<span class="p_add">+	struct completion	rx_login_comp;</span>
<span class="p_add">+	int			tx_thread_active;</span>
<span class="p_add">+	struct task_struct	*tx_thread;</span>
 	/* list_head for session connection list */
 	struct list_head	conn_list;
 } ____cacheline_aligned;
<span class="p_chunk">@@ -871,10 +877,12 @@</span> <span class="p_context"> struct iscsit_global {</span>
 	/* Unique identifier used for the authentication daemon */
 	u32			auth_id;
 	u32			inactive_ts;
<span class="p_add">+#define ISCSIT_BITMAP_BITS	262144</span>
 	/* Thread Set bitmap count */
 	int			ts_bitmap_count;
 	/* Thread Set bitmap pointer */
 	unsigned long		*ts_bitmap;
<span class="p_add">+	spinlock_t		ts_bitmap_lock;</span>
 	/* Used for iSCSI discovery session authentication */
 	struct iscsi_node_acl	discovery_acl;
 	struct iscsi_portal_group	*discovery_tpg;
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_erl0.c b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">index a0ae5fc..87f6872 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_chunk">@@ -860,7 +860,10 @@</span> <span class="p_context"> void iscsit_connection_reinstatement_rcfr(struct iscsi_conn *conn)</span>
 	}
 	spin_unlock_bh(&amp;conn-&gt;state_lock);
 
<span class="p_del">-	iscsi_thread_set_force_reinstatement(conn);</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 sleep:
 	wait_for_completion(&amp;conn-&gt;conn_wait_rcfr_comp);
<span class="p_chunk">@@ -885,10 +888,10 @@</span> <span class="p_context"> void iscsit_cause_connection_reinstatement(struct iscsi_conn *conn, int sleep)</span>
 		return;
 	}
 
<span class="p_del">-	if (iscsi_thread_set_force_reinstatement(conn) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_bh(&amp;conn-&gt;state_lock);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 	atomic_set(&amp;conn-&gt;connection_reinstatement, 1);
 	if (!sleep) {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index 713c0c1..7451251 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -83,6 +83,7 @@</span> <span class="p_context"> static struct iscsi_login *iscsi_login_init_conn(struct iscsi_conn *conn)</span>
 	init_completion(&amp;conn-&gt;conn_logout_comp);
 	init_completion(&amp;conn-&gt;rx_half_close_comp);
 	init_completion(&amp;conn-&gt;tx_half_close_comp);
<span class="p_add">+	init_completion(&amp;conn-&gt;rx_login_comp);</span>
 	spin_lock_init(&amp;conn-&gt;cmd_lock);
 	spin_lock_init(&amp;conn-&gt;conn_usage_lock);
 	spin_lock_init(&amp;conn-&gt;immed_queue_lock);
<span class="p_chunk">@@ -699,7 +700,53 @@</span> <span class="p_context"> static void iscsi_post_login_start_timers(struct iscsi_conn *conn)</span>
 		iscsit_start_nopin_timer(conn);
 }
 
<span class="p_del">-int iscsi_post_login_handler(</span>
<span class="p_add">+int iscsit_start_kthreads(struct iscsi_conn *conn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	conn-&gt;bitmap_id = bitmap_find_free_region(iscsit_global-&gt;ts_bitmap,</span>
<span class="p_add">+					ISCSIT_BITMAP_BITS, get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;bitmap_id &lt; 0) {</span>
<span class="p_add">+		pr_err(&quot;bitmap_find_free_region() failed for&quot;</span>
<span class="p_add">+		       &quot; iscsit_start_kthreads()\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;tx_thread = kthread_run(iscsi_target_tx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_TX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;tx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_tx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;tx_thread);</span>
<span class="p_add">+		goto out_bitmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;tx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;rx_thread = kthread_run(iscsi_target_rx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_RX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;rx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_rx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;rx_thread);</span>
<span class="p_add">+		goto out_tx;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;rx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+out_tx:</span>
<span class="p_add">+	send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+	conn-&gt;tx_thread_active = false;</span>
<span class="p_add">+out_bitmap:</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void iscsi_post_login_handler(</span>
 	struct iscsi_np *np,
 	struct iscsi_conn *conn,
 	u8 zero_tsih)
<span class="p_chunk">@@ -709,7 +756,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	struct se_session *se_sess = sess-&gt;se_sess;
 	struct iscsi_portal_group *tpg = sess-&gt;tpg;
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
<span class="p_del">-	struct iscsi_thread_set *ts;</span>
 
 	iscsit_inc_conn_usage_count(conn);
 
<span class="p_chunk">@@ -724,7 +770,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	/*
 	 * SCSI Initiator -&gt; SCSI Target Port Mapping
 	 */
<span class="p_del">-	ts = iscsi_get_thread_set();</span>
 	if (!zero_tsih) {
 		iscsi_set_session_parameters(sess-&gt;sess_ops,
 				conn-&gt;param_list, 0);
<span class="p_chunk">@@ -752,8 +797,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 		spin_unlock_bh(&amp;sess-&gt;conn_lock);
 
 		iscsi_post_login_start_timers(conn);
<span class="p_del">-</span>
<span class="p_del">-		iscsi_activate_thread_set(conn, ts);</span>
 		/*
 		 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 		 * are scheduled on the same CPU.
<span class="p_chunk">@@ -761,15 +804,20 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 		iscsit_thread_get_cpumask(conn);
 		conn-&gt;conn_rx_reset_cpumask = 1;
 		conn-&gt;conn_tx_reset_cpumask = 1;
<span class="p_del">-</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Wakeup the sleeping iscsi_target_rx_thread() now that</span>
<span class="p_add">+		 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		complete(&amp;conn-&gt;rx_login_comp);</span>
 		iscsit_dec_conn_usage_count(conn);
<span class="p_add">+</span>
 		if (stop_timer) {
 			spin_lock_bh(&amp;se_tpg-&gt;session_lock);
 			iscsit_stop_time2retain_timer(sess);
 			spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 		}
 		iscsit_dec_session_usage_count(sess);
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return;</span>
 	}
 
 	iscsi_set_session_parameters(sess-&gt;sess_ops, conn-&gt;param_list, 1);
<span class="p_chunk">@@ -811,7 +859,6 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 
 	iscsi_post_login_start_timers(conn);
<span class="p_del">-	iscsi_activate_thread_set(conn, ts);</span>
 	/*
 	 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 	 * are scheduled on the same CPU.
<span class="p_chunk">@@ -819,10 +866,12 @@</span> <span class="p_context"> int iscsi_post_login_handler(</span>
 	iscsit_thread_get_cpumask(conn);
 	conn-&gt;conn_rx_reset_cpumask = 1;
 	conn-&gt;conn_tx_reset_cpumask = 1;
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wakeup the sleeping iscsi_target_rx_thread() now that</span>
<span class="p_add">+	 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	complete(&amp;conn-&gt;rx_login_comp);</span>
 	iscsit_dec_conn_usage_count(conn);
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
 
 static void iscsi_handle_login_thread_timeout(unsigned long data)
<span class="p_chunk">@@ -1387,23 +1436,12 @@</span> <span class="p_context"> static int __iscsi_target_login_thread(struct iscsi_np *np)</span>
 	if (ret &lt; 0)
 		goto new_sess_out;
 
<span class="p_del">-	if (!conn-&gt;sess) {</span>
<span class="p_del">-		pr_err(&quot;struct iscsi_conn session pointer is NULL!\n&quot;);</span>
<span class="p_del">-		goto new_sess_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	iscsi_stop_login_thread_timer(np);
 
<span class="p_del">-	if (signal_pending(current))</span>
<span class="p_del">-		goto new_sess_out;</span>
<span class="p_del">-</span>
 	if (ret == 1) {
 		tpg_np = conn-&gt;tpg_np;
 
<span class="p_del">-		ret = iscsi_post_login_handler(np, conn, zero_tsih);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			goto new_sess_out;</span>
<span class="p_del">-</span>
<span class="p_add">+		iscsi_post_login_handler(np, conn, zero_tsih);</span>
 		iscsit_deaccess_np(np, tpg, tpg_np);
 	}
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.h b/drivers/target/iscsi/iscsi_target_login.h</span>
<span class="p_header">index 29d0983..55cbf45 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.h</span>
<span class="p_chunk">@@ -12,7 +12,8 @@</span> <span class="p_context"> extern int iscsit_accept_np(struct iscsi_np *, struct iscsi_conn *);</span>
 extern int iscsit_get_login_rx(struct iscsi_conn *, struct iscsi_login *);
 extern int iscsit_put_login_tx(struct iscsi_conn *, struct iscsi_login *, u32);
 extern void iscsit_free_conn(struct iscsi_np *, struct iscsi_conn *);
<span class="p_del">-extern int iscsi_post_login_handler(struct iscsi_np *, struct iscsi_conn *, u8);</span>
<span class="p_add">+extern int iscsit_start_kthreads(struct iscsi_conn *);</span>
<span class="p_add">+extern void iscsi_post_login_handler(struct iscsi_np *, struct iscsi_conn *, u8);</span>
 extern void iscsi_target_login_sess_out(struct iscsi_conn *, struct iscsi_np *,
 				bool, bool);
 extern int iscsi_target_login_thread(void *);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">index 62a095f..092112e 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
  ******************************************************************************/
 
 #include &lt;linux/ctype.h&gt;
<span class="p_add">+#include &lt;linux/kthread.h&gt;</span>
 #include &lt;scsi/iscsi_proto.h&gt;
 #include &lt;target/target_core_base.h&gt;
 #include &lt;target/target_core_fabric.h&gt;
<span class="p_chunk">@@ -361,10 +362,24 @@</span> <span class="p_context"> static int iscsi_target_do_tx_login_io(struct iscsi_conn *conn, struct iscsi_log</span>
 		ntohl(login_rsp-&gt;statsn), login-&gt;rsp_length);
 
 	padding = ((-login-&gt;rsp_length) &amp; 3);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Before sending the last login response containing the transition</span>
<span class="p_add">+	 * bit for full-feature-phase, go ahead and start up TX/RX threads</span>
<span class="p_add">+	 * now to avoid potential resource allocation failures after the</span>
<span class="p_add">+	 * final login response has been sent.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (login-&gt;login_complete) {</span>
<span class="p_add">+		int rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,</span>
<span class="p_add">+					    ISCSI_LOGIN_STATUS_NO_RESOURCES);</span>
<span class="p_add">+			return -1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	if (conn-&gt;conn_transport-&gt;iscsit_put_login_tx(conn, login,
 					login-&gt;rsp_length + padding) &lt; 0)
<span class="p_del">-		return -1;</span>
<span class="p_add">+		goto err;</span>
 
 	login-&gt;rsp_length		= 0;
 	mutex_lock(&amp;sess-&gt;cmdsn_mutex);
<span class="p_chunk">@@ -373,6 +388,23 @@</span> <span class="p_context"> static int iscsi_target_do_tx_login_io(struct iscsi_conn *conn, struct iscsi_log</span>
 	mutex_unlock(&amp;sess-&gt;cmdsn_mutex);
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	if (login-&gt;login_complete) {</span>
<span class="p_add">+		if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;rx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+		bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+				      get_order(1));</span>
<span class="p_add">+		spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return -1;</span>
 }
 
 static void iscsi_target_sk_data_ready(struct sock *sk)
<span class="p_header">diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c</span>
<span class="p_header">index 984605b..86f6d8b 100644</span>
<span class="p_header">--- a/drivers/tty/serial/serial_core.c</span>
<span class="p_header">+++ b/drivers/tty/serial/serial_core.c</span>
<span class="p_chunk">@@ -1429,7 +1429,7 @@</span> <span class="p_context"> static void uart_close(struct tty_struct *tty, struct file *filp)</span>
 	mutex_lock(&amp;port-&gt;mutex);
 	uart_shutdown(tty, state);
 	tty_port_tty_set(port, NULL);
<span class="p_del">-	tty-&gt;closing = 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;port-&gt;lock, flags);
 
 	if (port-&gt;blocked_open) {
<span class="p_chunk">@@ -1455,6 +1455,7 @@</span> <span class="p_context"> static void uart_close(struct tty_struct *tty, struct file *filp)</span>
 	mutex_unlock(&amp;port-&gt;mutex);
 
 	tty_ldisc_flush(tty);
<span class="p_add">+	tty-&gt;closing = 0;</span>
 }
 
 static void uart_wait_until_sent(struct tty_struct *tty, int timeout)
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 45a915c..1c1385e 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -1022,9 +1022,12 @@</span> <span class="p_context"> static int register_root_hub(struct usb_hcd *hcd)</span>
 				dev_name(&amp;usb_dev-&gt;dev), retval);
 		return (retval &lt; 0) ? retval : -EMSGSIZE;
 	}
<span class="p_del">-	if (usb_dev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+</span>
<span class="p_add">+	if (le16_to_cpu(usb_dev-&gt;descriptor.bcdUSB) &gt;= 0x0201) {</span>
 		retval = usb_get_bos_descriptor(usb_dev);
<span class="p_del">-		if (retval &lt; 0) {</span>
<span class="p_add">+		if (!retval) {</span>
<span class="p_add">+			usb_dev-&gt;lpm_capable = usb_device_supports_lpm(usb_dev);</span>
<span class="p_add">+		} else if (usb_dev-&gt;speed == USB_SPEED_SUPER) {</span>
 			mutex_unlock(&amp;usb_bus_list_lock);
 			dev_dbg(parent_dev, &quot;can&#39;t read %s bos descriptor %d\n&quot;,
 					dev_name(&amp;usb_dev-&gt;dev), retval);
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 79d50b9..3445773 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)</span>
 	return usb_get_intfdata(hdev-&gt;actconfig-&gt;interface[0]);
 }
 
<span class="p_del">-static int usb_device_supports_lpm(struct usb_device *udev)</span>
<span class="p_add">+int usb_device_supports_lpm(struct usb_device *udev)</span>
 {
 	/* USB 2.1 (and greater) devices indicate LPM support through
 	 * their USB 2.0 Extended Capabilities BOS descriptor.
<span class="p_header">diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h</span>
<span class="p_header">index 7eb1e26..457255a 100644</span>
<span class="p_header">--- a/drivers/usb/core/usb.h</span>
<span class="p_header">+++ b/drivers/usb/core/usb.h</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"> extern int  usb_hub_init(void);</span>
 extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);
 extern void usb_major_cleanup(void);
<span class="p_add">+extern int usb_device_supports_lpm(struct usb_device *udev);</span>
 
 #ifdef	CONFIG_PM
 
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index 1bc77a3..98f3605 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -727,6 +727,10 @@</span> <span class="p_context"> static int dwc3_ep0_std_request(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)</span>
 		dwc3_trace(trace_dwc3_ep0, &quot;USB_REQ_SET_ISOCH_DELAY&quot;);
 		ret = dwc3_ep0_set_isoch_delay(dwc, ctrl);
 		break;
<span class="p_add">+	case USB_REQ_SET_INTERFACE:</span>
<span class="p_add">+		dwc3_trace(trace_dwc3_ep0, &quot;USB_REQ_SET_INTERFACE&quot;);</span>
<span class="p_add">+		dwc-&gt;start_config_issued = false;</span>
<span class="p_add">+		/* Fall through */</span>
 	default:
 		dwc3_trace(trace_dwc3_ep0, &quot;Forwarding to gadget driver&quot;);
 		ret = dwc3_ep0_delegate_req(dwc, ctrl);
<span class="p_header">diff --git a/drivers/usb/gadget/udc/mv_udc_core.c b/drivers/usb/gadget/udc/mv_udc_core.c</span>
<span class="p_header">index 253f3df..3778580 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/mv_udc_core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/mv_udc_core.c</span>
<span class="p_chunk">@@ -2170,7 +2170,7 @@</span> <span class="p_context"> static int mv_udc_probe(struct platform_device *pdev)</span>
 		return -ENODEV;
 	}
 
<span class="p_del">-	udc-&gt;phy_regs = ioremap(r-&gt;start, resource_size(r));</span>
<span class="p_add">+	udc-&gt;phy_regs = devm_ioremap(&amp;pdev-&gt;dev, r-&gt;start, resource_size(r));</span>
 	if (udc-&gt;phy_regs == NULL) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to map phy I/O memory\n&quot;);
 		return -EBUSY;
<span class="p_header">diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c</span>
<span class="p_header">index 1463c39..fe1d5fc 100644</span>
<span class="p_header">--- a/drivers/usb/host/ohci-q.c</span>
<span class="p_header">+++ b/drivers/usb/host/ohci-q.c</span>
<span class="p_chunk">@@ -980,10 +980,6 @@</span> <span class="p_context"> rescan_all:</span>
 		int			completed, modified;
 		__hc32			*prev;
 
<span class="p_del">-		/* Is this ED already invisible to the hardware? */</span>
<span class="p_del">-		if (ed-&gt;state == ED_IDLE)</span>
<span class="p_del">-			goto ed_idle;</span>
<span class="p_del">-</span>
 		/* only take off EDs that the HC isn&#39;t using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
<span class="p_chunk">@@ -1011,12 +1007,10 @@</span> <span class="p_context"> skip_ed:</span>
 		}
 
 		/* ED&#39;s now officially unlinked, hc doesn&#39;t see */
<span class="p_del">-		ed-&gt;state = ED_IDLE;</span>
 		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
 		ed-&gt;hwNextED = 0;
 		wmb();
 		ed-&gt;hwINFO &amp;= ~cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE);
<span class="p_del">-ed_idle:</span>
 
 		/* reentrancy:  if we drop the schedule lock, someone might
 		 * have modified this list.  normally it&#39;s just prepending
<span class="p_chunk">@@ -1087,6 +1081,7 @@</span> <span class="p_context"> rescan_this:</span>
 		if (list_empty(&amp;ed-&gt;td_list)) {
 			*last = ed-&gt;ed_next;
 			ed-&gt;ed_next = NULL;
<span class="p_add">+			ed-&gt;state = ED_IDLE;</span>
 			list_del(&amp;ed-&gt;in_use_list);
 		} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 			*last = ed-&gt;ed_next;
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 0827d7c..ee07ba4 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -484,10 +484,13 @@</span> <span class="p_context"> static void xhci_hub_report_usb3_link_state(struct xhci_hcd *xhci,</span>
 	u32 pls = status_reg &amp; PORT_PLS_MASK;
 
 	/* resume state is a xHCI internal state.
<span class="p_del">-	 * Do not report it to usb core.</span>
<span class="p_add">+	 * Do not report it to usb core, instead, pretend to be U3,</span>
<span class="p_add">+	 * thus usb core knows it&#39;s not ready for transfer</span>
 	 */
<span class="p_del">-	if (pls == XDEV_RESUME)</span>
<span class="p_add">+	if (pls == XDEV_RESUME) {</span>
<span class="p_add">+		*status |= USB_SS_PORT_LS_U3;</span>
 		return;
<span class="p_add">+	}</span>
 
 	/* When the CAS bit is set then warm reset
 	 * should be performed on port
<span class="p_chunk">@@ -588,7 +591,14 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 		status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 	/* USB3.0 only */
 	if (hcd-&gt;speed == HCD_USB3) {
<span class="p_del">-		if ((raw_port_status &amp; PORT_PLC))</span>
<span class="p_add">+		/* Port link change with port in resume state should not be</span>
<span class="p_add">+		 * reported to usbcore, as this is an internal state to be</span>
<span class="p_add">+		 * handled by xhci driver. Reporting PLC to usbcore may</span>
<span class="p_add">+		 * cause usbcore clearing PLC first and port change event</span>
<span class="p_add">+		 * irq won&#39;t be generated.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((raw_port_status &amp; PORT_PLC) &amp;&amp;</span>
<span class="p_add">+			(raw_port_status &amp; PORT_PLS_MASK) != XDEV_RESUME)</span>
 			status |= USB_PORT_STAT_C_LINK_STATE &lt;&lt; 16;
 		if ((raw_port_status &amp; PORT_WRC))
 			status |= USB_PORT_STAT_C_BH_RESET &lt;&lt; 16;
<span class="p_chunk">@@ -1120,10 +1130,10 @@</span> <span class="p_context"> int xhci_bus_suspend(struct usb_hcd *hcd)</span>
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 
 	if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
<span class="p_del">-		if (bus_state-&gt;resuming_ports) {</span>
<span class="p_add">+		if (bus_state-&gt;resuming_ports ||	/* USB2 */</span>
<span class="p_add">+		    bus_state-&gt;port_remote_wakeup) {	/* USB3 */</span>
 			spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_del">-			xhci_dbg(xhci, &quot;suspend failed because &quot;</span>
<span class="p_del">-						&quot;a port is resuming\n&quot;);</span>
<span class="p_add">+			xhci_dbg(xhci, &quot;suspend failed because a port is resuming\n&quot;);</span>
 			return -EBUSY;
 		}
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 5cb3d7a..a67018e 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1431,10 +1431,10 @@</span> <span class="p_context"> int xhci_endpoint_init(struct xhci_hcd *xhci,</span>
 		/* Attempt to use the ring cache */
 		if (virt_dev-&gt;num_rings_cached == 0)
 			return -ENOMEM;
<span class="p_add">+		virt_dev-&gt;num_rings_cached--;</span>
 		virt_dev-&gt;eps[ep_index].new_ring =
 			virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached];
 		virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached] = NULL;
<span class="p_del">-		virt_dev-&gt;num_rings_cached--;</span>
 		xhci_reinit_cached_ring(xhci, virt_dev-&gt;eps[ep_index].new_ring,
 					1, type);
 	}
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 861a810..ea19ba3 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1546,6 +1546,9 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 		usb_hcd_resume_root_hub(hcd);
 	}
 
<span class="p_add">+	if (hcd-&gt;speed == HCD_USB3 &amp;&amp; (temp &amp; PORT_PLS_MASK) == XDEV_INACTIVE)</span>
<span class="p_add">+		bus_state-&gt;port_remote_wakeup &amp;= ~(1 &lt;&lt; faked_port_index);</span>
<span class="p_add">+</span>
 	if ((temp &amp; PORT_PLC) &amp;&amp; (temp &amp; PORT_PLS_MASK) == XDEV_RESUME) {
 		xhci_dbg(xhci, &quot;port resume event for port %d\n&quot;, port_id);
 
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index ee1cc0f..f2194a0 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -3457,6 +3457,9 @@</span> <span class="p_context"> int xhci_discover_or_reset_device(struct usb_hcd *hcd, struct usb_device *udev)</span>
 			return -EINVAL;
 	}
 
<span class="p_add">+	if (virt_dev-&gt;tt_info)</span>
<span class="p_add">+		old_active_eps = virt_dev-&gt;tt_info-&gt;active_eps;</span>
<span class="p_add">+</span>
 	if (virt_dev-&gt;udev != udev) {
 		/* If the virt_dev and the udev does not match, this virt_dev
 		 * may belong to another udev.
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 35a1eaf..75281ba 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -285,6 +285,7 @@</span> <span class="p_context"> struct xhci_op_regs {</span>
 #define XDEV_U0		(0x0 &lt;&lt; 5)
 #define XDEV_U2		(0x2 &lt;&lt; 5)
 #define XDEV_U3		(0x3 &lt;&lt; 5)
<span class="p_add">+#define XDEV_INACTIVE	(0x6 &lt;&lt; 5)</span>
 #define XDEV_RESUME	(0xf &lt;&lt; 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 &lt;&lt; 9)
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index caf1888..87898ca 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -2065,6 +2065,18 @@</span> <span class="p_context"> UNUSUAL_DEV( 0x1908, 0x3335, 0x0200, 0x0200,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_NO_READ_DISC_INFO ),
 
<span class="p_add">+/* Reported by Oliver Neukum &lt;oneukum@suse.com&gt;</span>
<span class="p_add">+ * This device morphes spontaneously into another device if the access</span>
<span class="p_add">+ * pattern of Windows isn&#39;t followed. Thus writable media would be dirty</span>
<span class="p_add">+ * if the initial instance is used. So the device is limited to its</span>
<span class="p_add">+ * virtual CD.</span>
<span class="p_add">+ * And yes, the concept that BCD goes up to 9 is not heeded */</span>
<span class="p_add">+UNUSUAL_DEV( 0x19d2, 0x1225, 0x0000, 0xffff,</span>
<span class="p_add">+		&quot;ZTE,Incorporated&quot;,</span>
<span class="p_add">+		&quot;ZTE WCDMA Technologies MSM&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_SINGLE_LUN ),</span>
<span class="p_add">+</span>
 /* Reported by Sven Geggus &lt;sven-usbst@geggus.net&gt;
  * This encrypted pen drive returns bogus data for the initial READ(10).
  */
<span class="p_header">diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c</span>
<span class="p_header">index cb807d0..5d326ed 100644</span>
<span class="p_header">--- a/drivers/vhost/vhost.c</span>
<span class="p_header">+++ b/drivers/vhost/vhost.c</span>
<span class="p_chunk">@@ -886,6 +886,7 @@</span> <span class="p_context"> long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)</span>
 		}
 		if (eventfp != d-&gt;log_file) {
 			filep = d-&gt;log_file;
<span class="p_add">+			d-&gt;log_file = eventfp;</span>
 			ctx = d-&gt;log_ctx;
 			d-&gt;log_ctx = eventfp ?
 				eventfd_ctx_fileget(eventfp) : NULL;
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index 2211f6b..53e269e 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -1194,9 +1194,11 @@</span> <span class="p_context"> static int nfs_check_inode_attributes(struct inode *inode, struct nfs_fattr *fat</span>
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_SIZE) {
 		cur_size = i_size_read(inode);
 		new_isize = nfs_size_to_loff_t(fattr-&gt;size);
<span class="p_del">-		if (cur_size != new_isize &amp;&amp; nfsi-&gt;nrequests == 0)</span>
<span class="p_add">+		if (cur_size != new_isize)</span>
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;
 	}
<span class="p_add">+	if (nfsi-&gt;nrequests != 0)</span>
<span class="p_add">+		invalid &amp;= ~NFS_INO_REVAL_PAGECACHE;</span>
 
 	/* Have any file permissions changed? */
 	if ((fattr-&gt;valid &amp; NFS_ATTR_FATTR_MODE) &amp;&amp; (inode-&gt;i_mode &amp; S_IALLUGO) != (fattr-&gt;mode &amp; S_IALLUGO))
<span class="p_chunk">@@ -1591,8 +1593,7 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			invalid |= NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_DATA
 				| NFS_INO_INVALID_ACCESS
<span class="p_del">-				| NFS_INO_INVALID_ACL</span>
<span class="p_del">-				| NFS_INO_REVAL_PAGECACHE;</span>
<span class="p_add">+				| NFS_INO_INVALID_ACL;</span>
 			if (S_ISDIR(inode-&gt;i_mode))
 				nfs_force_lookup_revalidate(inode);
 			inode-&gt;i_version = fattr-&gt;change_attr;
<span class="p_chunk">@@ -1624,7 +1625,6 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			if ((nfsi-&gt;nrequests == 0) || new_isize &gt; cur_isize) {
 				i_size_write(inode, new_isize);
 				invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA;
<span class="p_del">-				invalid &amp;= ~NFS_INO_REVAL_PAGECACHE;</span>
 			}
 			dprintk(&quot;NFS: isize change on server for file %s/%ld &quot;
 					&quot;(%Ld to %Ld)\n&quot;,
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_attr_remote.c b/fs/xfs/libxfs/xfs_attr_remote.c</span>
<span class="p_header">index 20de88d..dd71403 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_attr_remote.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_attr_remote.c</span>
<span class="p_chunk">@@ -159,11 +159,10 @@</span> <span class="p_context"> xfs_attr3_rmt_write_verify(</span>
 	struct xfs_buf	*bp)
 {
 	struct xfs_mount *mp = bp-&gt;b_target-&gt;bt_mount;
<span class="p_del">-	struct xfs_buf_log_item	*bip = bp-&gt;b_fspriv;</span>
<span class="p_add">+	int		blksize = mp-&gt;m_attr_geo-&gt;blksize;</span>
 	char		*ptr;
 	int		len;
 	xfs_daddr_t	bno;
<span class="p_del">-	int		blksize = mp-&gt;m_attr_geo-&gt;blksize;</span>
 
 	/* no verification of non-crc buffers */
 	if (!xfs_sb_version_hascrc(&amp;mp-&gt;m_sb))
<span class="p_chunk">@@ -175,16 +174,22 @@</span> <span class="p_context"> xfs_attr3_rmt_write_verify(</span>
 	ASSERT(len &gt;= blksize);
 
 	while (len &gt; 0) {
<span class="p_add">+		struct xfs_attr3_rmt_hdr *rmt = (struct xfs_attr3_rmt_hdr *)ptr;</span>
<span class="p_add">+</span>
 		if (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
 			xfs_buf_ioerror(bp, -EFSCORRUPTED);
 			xfs_verifier_error(bp);
 			return;
 		}
<span class="p_del">-		if (bip) {</span>
<span class="p_del">-			struct xfs_attr3_rmt_hdr *rmt;</span>
 
<span class="p_del">-			rmt = (struct xfs_attr3_rmt_hdr *)ptr;</span>
<span class="p_del">-			rmt-&gt;rm_lsn = cpu_to_be64(bip-&gt;bli_item.li_lsn);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Ensure we aren&#39;t writing bogus LSNs to disk. See</span>
<span class="p_add">+		 * xfs_attr3_rmt_hdr_set() for the explanation.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (rmt-&gt;rm_lsn != cpu_to_be64(NULLCOMMITLSN)) {</span>
<span class="p_add">+			xfs_buf_ioerror(bp, -EFSCORRUPTED);</span>
<span class="p_add">+			xfs_verifier_error(bp);</span>
<span class="p_add">+			return;</span>
 		}
 		xfs_update_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF);
 
<span class="p_chunk">@@ -221,6 +226,18 @@</span> <span class="p_context"> xfs_attr3_rmt_hdr_set(</span>
 	rmt-&gt;rm_owner = cpu_to_be64(ino);
 	rmt-&gt;rm_blkno = cpu_to_be64(bno);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Remote attribute blocks are written synchronously, so we don&#39;t</span>
<span class="p_add">+	 * have an LSN that we can stamp in them that makes any sense to log</span>
<span class="p_add">+	 * recovery. To ensure that log recovery handles overwrites of these</span>
<span class="p_add">+	 * blocks sanely (i.e. once they&#39;ve been freed and reallocated as some</span>
<span class="p_add">+	 * other type of metadata) we need to ensure that the LSN has a value</span>
<span class="p_add">+	 * that tells log recovery to ignore the LSN and overwrite the buffer</span>
<span class="p_add">+	 * with whatever is in it&#39;s log. To do this, we use the magic</span>
<span class="p_add">+	 * NULLCOMMITLSN to indicate that the LSN is invalid.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rmt-&gt;rm_lsn = cpu_to_be64(NULLCOMMITLSN);</span>
<span class="p_add">+</span>
 	return sizeof(struct xfs_attr3_rmt_hdr);
 }
 
<span class="p_chunk">@@ -434,14 +451,21 @@</span> <span class="p_context"> xfs_attr_rmtval_set(</span>
 
 		/*
 		 * Allocate a single extent, up to the size of the value.
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Note that we have to consider this a data allocation as we</span>
<span class="p_add">+		 * write the remote attribute without logging the contents.</span>
<span class="p_add">+		 * Hence we must ensure that we aren&#39;t using blocks that are on</span>
<span class="p_add">+		 * the busy list so that we don&#39;t overwrite blocks which have</span>
<span class="p_add">+		 * recently been freed but their transactions are not yet</span>
<span class="p_add">+		 * committed to disk. If we overwrite the contents of a busy</span>
<span class="p_add">+		 * extent and then crash then the block may not contain the</span>
<span class="p_add">+		 * correct metadata after log recovery occurs.</span>
 		 */
 		xfs_bmap_init(args-&gt;flist, args-&gt;firstblock);
 		nmap = 1;
 		error = xfs_bmapi_write(args-&gt;trans, dp, (xfs_fileoff_t)lblkno,
<span class="p_del">-				  blkcnt,</span>
<span class="p_del">-				  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,</span>
<span class="p_del">-				  args-&gt;firstblock, args-&gt;total, &amp;map, &amp;nmap,</span>
<span class="p_del">-				  args-&gt;flist);</span>
<span class="p_add">+				  blkcnt, XFS_BMAPI_ATTRFORK, args-&gt;firstblock,</span>
<span class="p_add">+				  args-&gt;total, &amp;map, &amp;nmap, args-&gt;flist);</span>
 		if (!error) {
 			error = xfs_bmap_finish(&amp;args-&gt;trans, args-&gt;flist,
 						&amp;committed);
<span class="p_header">diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">index a5a945f..2a19a61 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_log_recover.c</span>
<span class="p_chunk">@@ -1887,9 +1887,14 @@</span> <span class="p_context"> xlog_recover_get_buf_lsn(</span>
 		uuid = &amp;((struct xfs_dir3_blk_hdr *)blk)-&gt;uuid;
 		break;
 	case XFS_ATTR3_RMT_MAGIC:
<span class="p_del">-		lsn = be64_to_cpu(((struct xfs_attr3_rmt_hdr *)blk)-&gt;rm_lsn);</span>
<span class="p_del">-		uuid = &amp;((struct xfs_attr3_rmt_hdr *)blk)-&gt;rm_uuid;</span>
<span class="p_del">-		break;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Remote attr blocks are written synchronously, rather than</span>
<span class="p_add">+		 * being logged. That means they do not contain a valid LSN</span>
<span class="p_add">+		 * (i.e. transactionally ordered) in them, and hence any time we</span>
<span class="p_add">+		 * see a buffer to replay over the top of a remote attribute</span>
<span class="p_add">+		 * block we should simply do so.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		goto recover_immediately;</span>
 	case XFS_SB_MAGIC:
 		lsn = be64_to_cpu(((struct xfs_dsb *)blk)-&gt;sb_lsn);
 		uuid = &amp;((struct xfs_dsb *)blk)-&gt;sb_uuid;
<span class="p_header">diff --git a/include/linux/ata.h b/include/linux/ata.h</span>
<span class="p_header">index f2f4d8d..3c35318 100644</span>
<span class="p_header">--- a/include/linux/ata.h</span>
<span class="p_header">+++ b/include/linux/ata.h</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> enum {</span>
 	ATA_SECT_SIZE		= 512,
 	ATA_MAX_SECTORS_128	= 128,
 	ATA_MAX_SECTORS		= 256,
<span class="p_add">+	ATA_MAX_SECTORS_1024    = 1024,</span>
 	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
 	ATA_MAX_SECTORS_TAPE	= 65535,
 
<span class="p_header">diff --git a/include/linux/cper.h b/include/linux/cper.h</span>
<span class="p_header">index 76abba4..dcacb1a 100644</span>
<span class="p_header">--- a/include/linux/cper.h</span>
<span class="p_header">+++ b/include/linux/cper.h</span>
<span class="p_chunk">@@ -340,7 +340,27 @@</span> <span class="p_context"> struct cper_ia_proc_ctx {</span>
 	__u64	mm_reg_addr;
 };
 
<span class="p_del">-/* Memory Error Section */</span>
<span class="p_add">+/* Old Memory Error Section UEFI 2.1, 2.2 */</span>
<span class="p_add">+struct cper_sec_mem_err_old {</span>
<span class="p_add">+	__u64	validation_bits;</span>
<span class="p_add">+	__u64	error_status;</span>
<span class="p_add">+	__u64	physical_addr;</span>
<span class="p_add">+	__u64	physical_addr_mask;</span>
<span class="p_add">+	__u16	node;</span>
<span class="p_add">+	__u16	card;</span>
<span class="p_add">+	__u16	module;</span>
<span class="p_add">+	__u16	bank;</span>
<span class="p_add">+	__u16	device;</span>
<span class="p_add">+	__u16	row;</span>
<span class="p_add">+	__u16	column;</span>
<span class="p_add">+	__u16	bit_pos;</span>
<span class="p_add">+	__u64	requestor_id;</span>
<span class="p_add">+	__u64	responder_id;</span>
<span class="p_add">+	__u64	target_id;</span>
<span class="p_add">+	__u8	error_type;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Memory Error Section UEFI &gt;= 2.3 */</span>
 struct cper_sec_mem_err {
 	__u64	validation_bits;
 	__u64	error_status;
<span class="p_header">diff --git a/include/linux/ftrace.h b/include/linux/ftrace.h</span>
<span class="p_header">index 1da6029..6cd8c0e 100644</span>
<span class="p_header">--- a/include/linux/ftrace.h</span>
<span class="p_header">+++ b/include/linux/ftrace.h</span>
<span class="p_chunk">@@ -116,6 +116,7 @@</span> <span class="p_context"> ftrace_func_t ftrace_ops_get_func(struct ftrace_ops *ops);</span>
  *            SAVE_REGS. If another ops with this flag set is already registered
  *            for any of the functions that this ops will be registered for, then
  *            this ops will fail to register or set_filter_ip.
<span class="p_add">+ * PID     - Is affected by set_ftrace_pid (allows filtering on those pids)</span>
  */
 enum {
 	FTRACE_OPS_FL_ENABLED			= 1 &lt;&lt; 0,
<span class="p_chunk">@@ -132,6 +133,7 @@</span> <span class="p_context"> enum {</span>
 	FTRACE_OPS_FL_MODIFYING			= 1 &lt;&lt; 11,
 	FTRACE_OPS_FL_ALLOC_TRAMP		= 1 &lt;&lt; 12,
 	FTRACE_OPS_FL_IPMODIFY			= 1 &lt;&lt; 13,
<span class="p_add">+	FTRACE_OPS_FL_PID			= 1 &lt;&lt; 14,</span>
 };
 
 #ifdef CONFIG_DYNAMIC_FTRACE
<span class="p_chunk">@@ -159,6 +161,7 @@</span> <span class="p_context"> struct ftrace_ops {</span>
 	struct ftrace_ops		*next;
 	unsigned long			flags;
 	void				*private;
<span class="p_add">+	ftrace_func_t			saved_func;</span>
 	int __percpu			*disabled;
 #ifdef CONFIG_DYNAMIC_FTRACE
 	int				nr_trampolines;
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 29284b6..e67edef 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -431,6 +431,8 @@</span> <span class="p_context"> enum {</span>
 	ATA_HORKAGE_NOLPM	= (1 &lt;&lt; 20),	/* don&#39;t use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 &lt;&lt; 21),	/* some WDs have broken LPM */
 	ATA_HORKAGE_ZERO_AFTER_TRIM = (1 &lt;&lt; 22),/* guarantees zero after trim */
<span class="p_add">+	ATA_HORKAGE_NOTRIM	= (1 &lt;&lt; 24),	/* don&#39;t use TRIM */</span>
<span class="p_add">+	ATA_HORKAGE_MAX_SEC_1024 = (1 &lt;&lt; 25),	/* Limit max sects to 1024 */</span>
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */
<span class="p_header">diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h</span>
<span class="p_header">index 3d4ea7e..12b75f3 100644</span>
<span class="p_header">--- a/include/linux/mtd/nand.h</span>
<span class="p_header">+++ b/include/linux/mtd/nand.h</span>
<span class="p_chunk">@@ -176,17 +176,17 @@</span> <span class="p_context"> typedef enum {</span>
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00040000
 /*
<span class="p_del">- * This option could be defined by controller drivers to protect against</span>
<span class="p_del">- * kmap&#39;ed, vmalloc&#39;ed highmem buffers being passed from upper layers</span>
<span class="p_del">- */</span>
<span class="p_del">-#define NAND_USE_BOUNCE_BUFFER	0x00080000</span>
<span class="p_del">-/*</span>
  * Autodetect nand buswidth with readid/onfi.
  * This suppose the driver will configure the hardware in 8 bits mode
  * when calling nand_scan_ident, and update its configuration
  * before calling nand_scan_tail.
  */
 #define NAND_BUSWIDTH_AUTO      0x00080000
<span class="p_add">+/*</span>
<span class="p_add">+ * This option could be defined by controller drivers to protect against</span>
<span class="p_add">+ * kmap&#39;ed, vmalloc&#39;ed highmem buffers being passed from upper layers</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define NAND_USE_BOUNCE_BUFFER	0x00100000</span>
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
<span class="p_header">diff --git a/include/net/act_api.h b/include/net/act_api.h</span>
<span class="p_header">index 3ee4c92..931738b 100644</span>
<span class="p_header">--- a/include/net/act_api.h</span>
<span class="p_header">+++ b/include/net/act_api.h</span>
<span class="p_chunk">@@ -99,7 +99,6 @@</span> <span class="p_context"> struct tc_action_ops {</span>
 
 int tcf_hash_search(struct tc_action *a, u32 index);
 void tcf_hash_destroy(struct tc_action *a);
<span class="p_del">-int tcf_hash_release(struct tc_action *a, int bind);</span>
 u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo);
 int tcf_hash_check(u32 index, struct tc_action *a, int bind);
 int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
<span class="p_chunk">@@ -107,6 +106,13 @@</span> <span class="p_context"> int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,</span>
 void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
 void tcf_hash_insert(struct tc_action *a);
 
<span class="p_add">+int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int tcf_hash_release(struct tc_action *a, bool bind)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __tcf_hash_release(a, bind, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int tcf_register_action(struct tc_action_ops *a, unsigned int mask);
 int tcf_unregister_action(struct tc_action_ops *a);
 int tcf_action_destroy(struct list_head *actions, int bind);
<span class="p_header">diff --git a/include/net/inet_frag.h b/include/net/inet_frag.h</span>
<span class="p_header">index 8d17655..3242bfd 100644</span>
<span class="p_header">--- a/include/net/inet_frag.h</span>
<span class="p_header">+++ b/include/net/inet_frag.h</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> enum {</span>
  * @flags: fragment queue flags
  * @max_size: (ipv4 only) maximum received fragment size with IP_DF set
  * @net: namespace that this frag belongs to
<span class="p_add">+ * @list_evictor: list of queues to forcefully evict (e.g. due to low memory)</span>
  */
 struct inet_frag_queue {
 	spinlock_t		lock;
<span class="p_chunk">@@ -59,6 +60,7 @@</span> <span class="p_context"> struct inet_frag_queue {</span>
 	__u8			flags;
 	u16			max_size;
 	struct netns_frags	*net;
<span class="p_add">+	struct hlist_node	list_evictor;</span>
 };
 
 #define INETFRAGS_HASHSZ	1024
<span class="p_header">diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h</span>
<span class="p_header">index 2502622..1c7dcc6 100644</span>
<span class="p_header">--- a/include/uapi/drm/i915_drm.h</span>
<span class="p_header">+++ b/include/uapi/drm/i915_drm.h</span>
<span class="p_chunk">@@ -1042,6 +1042,14 @@</span> <span class="p_context"> struct drm_i915_reg_read {</span>
 	__u64 offset;
 	__u64 val; /* Return value */
 };
<span class="p_add">+/* Known registers:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Render engine timestamp - 0x2358 + 64bit - gen7+</span>
<span class="p_add">+ * - Note this register returns an invalid value if using the default</span>
<span class="p_add">+ *   single instruction 8byte read, in order to workaround that use</span>
<span class="p_add">+ *   offset (0x2538 | 1) instead.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
 
 struct drm_i915_reset_stats {
 	__u32 ctx_id;
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index af5bffd..ac9516c 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -98,6 +98,13 @@</span> <span class="p_context"> struct ftrace_pid {</span>
 	struct pid *pid;
 };
 
<span class="p_add">+static bool ftrace_pids_enabled(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !list_empty(&amp;ftrace_pids);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void ftrace_update_trampoline(struct ftrace_ops *ops);</span>
<span class="p_add">+</span>
 /*
  * ftrace_disabled is set when an anomaly is discovered.
  * ftrace_disabled is much stronger than ftrace_enabled.
<span class="p_chunk">@@ -109,7 +116,6 @@</span> <span class="p_context"> static DEFINE_MUTEX(ftrace_lock);</span>
 static struct ftrace_ops *ftrace_control_list __read_mostly = &amp;ftrace_list_end;
 static struct ftrace_ops *ftrace_ops_list __read_mostly = &amp;ftrace_list_end;
 ftrace_func_t ftrace_trace_function __read_mostly = ftrace_stub;
<span class="p_del">-ftrace_func_t ftrace_pid_function __read_mostly = ftrace_stub;</span>
 static struct ftrace_ops global_ops;
 static struct ftrace_ops control_ops;
 
<span class="p_chunk">@@ -183,14 +189,7 @@</span> <span class="p_context"> static void ftrace_pid_func(unsigned long ip, unsigned long parent_ip,</span>
 	if (!test_tsk_trace_trace(current))
 		return;
 
<span class="p_del">-	ftrace_pid_function(ip, parent_ip, op, regs);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void set_ftrace_pid_function(ftrace_func_t func)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* do not set ftrace_pid_function to itself! */</span>
<span class="p_del">-	if (func != ftrace_pid_func)</span>
<span class="p_del">-		ftrace_pid_function = func;</span>
<span class="p_add">+	op-&gt;saved_func(ip, parent_ip, op, regs);</span>
 }
 
 /**
<span class="p_chunk">@@ -202,7 +201,6 @@</span> <span class="p_context"> static void set_ftrace_pid_function(ftrace_func_t func)</span>
 void clear_ftrace_function(void)
 {
 	ftrace_trace_function = ftrace_stub;
<span class="p_del">-	ftrace_pid_function = ftrace_stub;</span>
 }
 
 static void control_ops_disable_all(struct ftrace_ops *ops)
<span class="p_chunk">@@ -423,6 +421,12 @@</span> <span class="p_context"> static int __register_ftrace_function(struct ftrace_ops *ops)</span>
 	} else
 		add_ftrace_ops(&amp;ftrace_ops_list, ops);
 
<span class="p_add">+	/* Always save the function, and reset at unregistering */</span>
<span class="p_add">+	ops-&gt;saved_func = ops-&gt;func;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ops-&gt;flags &amp; FTRACE_OPS_FL_PID &amp;&amp; ftrace_pids_enabled())</span>
<span class="p_add">+		ops-&gt;func = ftrace_pid_func;</span>
<span class="p_add">+</span>
 	ftrace_update_trampoline(ops);
 
 	if (ftrace_enabled)
<span class="p_chunk">@@ -450,15 +454,28 @@</span> <span class="p_context"> static int __unregister_ftrace_function(struct ftrace_ops *ops)</span>
 	if (ftrace_enabled)
 		update_ftrace_function();
 
<span class="p_add">+	ops-&gt;func = ops-&gt;saved_func;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
 static void ftrace_update_pid_func(void)
 {
<span class="p_add">+	bool enabled = ftrace_pids_enabled();</span>
<span class="p_add">+	struct ftrace_ops *op;</span>
<span class="p_add">+</span>
 	/* Only do something if we are tracing something */
 	if (ftrace_trace_function == ftrace_stub)
 		return;
 
<span class="p_add">+	do_for_each_ftrace_op(op, ftrace_ops_list) {</span>
<span class="p_add">+		if (op-&gt;flags &amp; FTRACE_OPS_FL_PID) {</span>
<span class="p_add">+			op-&gt;func = enabled ? ftrace_pid_func :</span>
<span class="p_add">+				op-&gt;saved_func;</span>
<span class="p_add">+			ftrace_update_trampoline(op);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while_for_each_ftrace_op(op);</span>
<span class="p_add">+</span>
 	update_ftrace_function();
 }
 
<span class="p_chunk">@@ -1120,7 +1137,8 @@</span> <span class="p_context"> static struct ftrace_ops global_ops = {</span>
 	.local_hash.filter_hash		= EMPTY_HASH,
 	INIT_OPS_HASH(global_ops)
 	.flags				= FTRACE_OPS_FL_RECURSION_SAFE |
<span class="p_del">-					  FTRACE_OPS_FL_INITIALIZED,</span>
<span class="p_add">+					  FTRACE_OPS_FL_INITIALIZED |</span>
<span class="p_add">+					  FTRACE_OPS_FL_PID,</span>
 };
 
 /*
<span class="p_chunk">@@ -5010,7 +5028,9 @@</span> <span class="p_context"> static void ftrace_update_trampoline(struct ftrace_ops *ops)</span>
 
 static struct ftrace_ops global_ops = {
 	.func			= ftrace_stub,
<span class="p_del">-	.flags			= FTRACE_OPS_FL_RECURSION_SAFE | FTRACE_OPS_FL_INITIALIZED,</span>
<span class="p_add">+	.flags			= FTRACE_OPS_FL_RECURSION_SAFE |</span>
<span class="p_add">+				  FTRACE_OPS_FL_INITIALIZED |</span>
<span class="p_add">+				  FTRACE_OPS_FL_PID,</span>
 };
 
 static int __init ftrace_nodyn_init(void)
<span class="p_chunk">@@ -5067,11 +5087,6 @@</span> <span class="p_context"> void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)</span>
 		if (WARN_ON(tr-&gt;ops-&gt;func != ftrace_stub))
 			printk(&quot;ftrace ops had %pS for function\n&quot;,
 			       tr-&gt;ops-&gt;func);
<span class="p_del">-		/* Only the top level instance does pid tracing */</span>
<span class="p_del">-		if (!list_empty(&amp;ftrace_pids)) {</span>
<span class="p_del">-			set_ftrace_pid_function(func);</span>
<span class="p_del">-			func = ftrace_pid_func;</span>
<span class="p_del">-		}</span>
 	}
 	tr-&gt;ops-&gt;func = func;
 	tr-&gt;ops-&gt;private = tr;
<span class="p_chunk">@@ -5365,7 +5380,7 @@</span> <span class="p_context"> static void *fpid_start(struct seq_file *m, loff_t *pos)</span>
 {
 	mutex_lock(&amp;ftrace_lock);
 
<span class="p_del">-	if (list_empty(&amp;ftrace_pids) &amp;&amp; (!*pos))</span>
<span class="p_add">+	if (!ftrace_pids_enabled() &amp;&amp; (!*pos))</span>
 		return (void *) 1;
 
 	return seq_list_start(&amp;ftrace_pids, *pos);
<span class="p_chunk">@@ -5604,6 +5619,7 @@</span> <span class="p_context"> static struct ftrace_ops graph_ops = {</span>
 	.func			= ftrace_stub,
 	.flags			= FTRACE_OPS_FL_RECURSION_SAFE |
 				   FTRACE_OPS_FL_INITIALIZED |
<span class="p_add">+				   FTRACE_OPS_FL_PID |</span>
 				   FTRACE_OPS_FL_STUB,
 #ifdef FTRACE_GRAPH_TRAMP_ADDR
 	.trampoline		= FTRACE_GRAPH_TRAMP_ADDR,
<span class="p_header">diff --git a/net/bridge/br_mdb.c b/net/bridge/br_mdb.c</span>
<span class="p_header">index 4754f2d..568c441 100644</span>
<span class="p_header">--- a/net/bridge/br_mdb.c</span>
<span class="p_header">+++ b/net/bridge/br_mdb.c</span>
<span class="p_chunk">@@ -350,7 +350,6 @@</span> <span class="p_context"> static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,</span>
 	if (state == MDB_TEMPORARY)
 		mod_timer(&amp;p-&gt;timer, now + br-&gt;multicast_membership_interval);
 
<span class="p_del">-	br_mdb_notify(br-&gt;dev, port, group, RTM_NEWMDB);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -452,6 +451,7 @@</span> <span class="p_context"> static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)</span>
 		if (p-&gt;port-&gt;state == BR_STATE_DISABLED)
 			goto unlock;
 
<span class="p_add">+		entry-&gt;state = p-&gt;state;</span>
 		rcu_assign_pointer(*pp, p-&gt;next);
 		hlist_del_init(&amp;p-&gt;mglist);
 		del_timer(&amp;p-&gt;timer);
<span class="p_header">diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c</span>
<span class="p_header">index 9f5eb55..36e56a9 100644</span>
<span class="p_header">--- a/net/bridge/br_netlink.c</span>
<span class="p_header">+++ b/net/bridge/br_netlink.c</span>
<span class="p_chunk">@@ -466,9 +466,17 @@</span> <span class="p_context"> static int br_port_slave_changelink(struct net_device *brdev,</span>
 				    struct nlattr *tb[],
 				    struct nlattr *data[])
 {
<span class="p_add">+	struct net_bridge *br = netdev_priv(brdev);</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	if (!data)
 		return 0;
<span class="p_del">-	return br_setport(br_port_get_rtnl(dev), data);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;br-&gt;lock);</span>
<span class="p_add">+	ret = br_setport(br_port_get_rtnl(dev), data);</span>
<span class="p_add">+	spin_unlock_bh(&amp;br-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int br_port_fill_slave_info(struct sk_buff *skb,
<span class="p_header">diff --git a/net/core/datagram.c b/net/core/datagram.c</span>
<span class="p_header">index df493d6..91dbcfa 100644</span>
<span class="p_header">--- a/net/core/datagram.c</span>
<span class="p_header">+++ b/net/core/datagram.c</span>
<span class="p_chunk">@@ -131,6 +131,35 @@</span> <span class="p_context"> out_noerr:</span>
 	goto out;
 }
 
<span class="p_add">+static int skb_set_peeked(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *nskb;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (skb-&gt;peeked)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We have to unshare an skb before modifying it. */</span>
<span class="p_add">+	if (!skb_shared(skb))</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	nskb = skb_clone(skb, GFP_ATOMIC);</span>
<span class="p_add">+	if (!nskb)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb-&gt;prev-&gt;next = nskb;</span>
<span class="p_add">+	skb-&gt;next-&gt;prev = nskb;</span>
<span class="p_add">+	nskb-&gt;prev = skb-&gt;prev;</span>
<span class="p_add">+	nskb-&gt;next = skb-&gt;next;</span>
<span class="p_add">+</span>
<span class="p_add">+	consume_skb(skb);</span>
<span class="p_add">+	skb = nskb;</span>
<span class="p_add">+</span>
<span class="p_add">+done:</span>
<span class="p_add">+	skb-&gt;peeked = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	__skb_recv_datagram - Receive a datagram skbuff
  *	@sk: socket
<span class="p_chunk">@@ -165,7 +194,9 @@</span> <span class="p_context"> out_noerr:</span>
 struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,
 				    int *peeked, int *off, int *err)
 {
<span class="p_add">+	struct sk_buff_head *queue = &amp;sk-&gt;sk_receive_queue;</span>
 	struct sk_buff *skb, *last;
<span class="p_add">+	unsigned long cpu_flags;</span>
 	long timeo;
 	/*
 	 * Caller is allowed not to check sk-&gt;sk_err before skb_recv_datagram()
<span class="p_chunk">@@ -184,8 +215,6 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,</span>
 		 * Look at current nfs client by the way...
 		 * However, this function was correct in any case. 8)
 		 */
<span class="p_del">-		unsigned long cpu_flags;</span>
<span class="p_del">-		struct sk_buff_head *queue = &amp;sk-&gt;sk_receive_queue;</span>
 		int _off = *off;
 
 		last = (struct sk_buff *)queue;
<span class="p_chunk">@@ -199,7 +228,11 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,</span>
 					_off -= skb-&gt;len;
 					continue;
 				}
<span class="p_del">-				skb-&gt;peeked = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+				error = skb_set_peeked(skb);</span>
<span class="p_add">+				if (error)</span>
<span class="p_add">+					goto unlock_err;</span>
<span class="p_add">+</span>
 				atomic_inc(&amp;skb-&gt;users);
 			} else
 				__skb_unlink(skb, queue);
<span class="p_chunk">@@ -223,6 +256,8 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,</span>
 
 	return NULL;
 
<span class="p_add">+unlock_err:</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;queue-&gt;lock, cpu_flags);</span>
 no_packet:
 	*err = error;
 	return NULL;
<span class="p_header">diff --git a/net/ipv4/inet_fragment.c b/net/ipv4/inet_fragment.c</span>
<span class="p_header">index e792035..edc17b9 100644</span>
<span class="p_header">--- a/net/ipv4/inet_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/inet_fragment.c</span>
<span class="p_chunk">@@ -151,14 +151,13 @@</span> <span class="p_context"> evict_again:</span>
 		}
 
 		fq-&gt;flags |= INET_FRAG_EVICTED;
<span class="p_del">-		hlist_del(&amp;fq-&gt;list);</span>
<span class="p_del">-		hlist_add_head(&amp;fq-&gt;list, &amp;expired);</span>
<span class="p_add">+		hlist_add_head(&amp;fq-&gt;list_evictor, &amp;expired);</span>
 		++evicted;
 	}
 
 	spin_unlock(&amp;hb-&gt;chain_lock);
 
<span class="p_del">-	hlist_for_each_entry_safe(fq, n, &amp;expired, list)</span>
<span class="p_add">+	hlist_for_each_entry_safe(fq, n, &amp;expired, list_evictor)</span>
 		f-&gt;frag_expire((unsigned long) fq);
 
 	return evicted;
<span class="p_chunk">@@ -284,8 +283,7 @@</span> <span class="p_context"> static inline void fq_unlink(struct inet_frag_queue *fq, struct inet_frags *f)</span>
 	struct inet_frag_bucket *hb;
 
 	hb = get_frag_bucket_locked(fq, f);
<span class="p_del">-	if (!(fq-&gt;flags &amp; INET_FRAG_EVICTED))</span>
<span class="p_del">-		hlist_del(&amp;fq-&gt;list);</span>
<span class="p_add">+	hlist_del(&amp;fq-&gt;list);</span>
 	spin_unlock(&amp;hb-&gt;chain_lock);
 }
 
<span class="p_header">diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c</span>
<span class="p_header">index 145a50c..0f128f8 100644</span>
<span class="p_header">--- a/net/ipv4/ip_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/ip_fragment.c</span>
<span class="p_chunk">@@ -342,7 +342,7 @@</span> <span class="p_context"> static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)</span>
 	ihl = ip_hdrlen(skb);
 
 	/* Determine the position of this fragment. */
<span class="p_del">-	end = offset + skb-&gt;len - ihl;</span>
<span class="p_add">+	end = offset + skb-&gt;len - skb_network_offset(skb) - ihl;</span>
 	err = -EINVAL;
 
 	/* Is this the final fragment? */
<span class="p_chunk">@@ -372,7 +372,7 @@</span> <span class="p_context"> static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)</span>
 		goto err;
 
 	err = -ENOMEM;
<span class="p_del">-	if (pskb_pull(skb, ihl) == NULL)</span>
<span class="p_add">+	if (!pskb_pull(skb, skb_network_offset(skb) + ihl))</span>
 		goto err;
 
 	err = pskb_trim_rcsum(skb, end - offset);
<span class="p_chunk">@@ -612,6 +612,9 @@</span> <span class="p_context"> static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,</span>
 	iph-&gt;frag_off = qp-&gt;q.max_size ? htons(IP_DF) : 0;
 	iph-&gt;tot_len = htons(len);
 	iph-&gt;tos |= ecn;
<span class="p_add">+</span>
<span class="p_add">+	ip_send_check(iph);</span>
<span class="p_add">+</span>
 	IP_INC_STATS_BH(net, IPSTATS_MIB_REASMOKS);
 	qp-&gt;q.fragments = NULL;
 	qp-&gt;q.fragments_tail = NULL;
<span class="p_header">diff --git a/net/mac80211/debugfs_netdev.c b/net/mac80211/debugfs_netdev.c</span>
<span class="p_header">index c68896a..2d19963 100644</span>
<span class="p_header">--- a/net/mac80211/debugfs_netdev.c</span>
<span class="p_header">+++ b/net/mac80211/debugfs_netdev.c</span>
<span class="p_chunk">@@ -725,6 +725,7 @@</span> <span class="p_context"> void ieee80211_debugfs_remove_netdev(struct ieee80211_sub_if_data *sdata)</span>
 
 	debugfs_remove_recursive(sdata-&gt;vif.debugfs_dir);
 	sdata-&gt;vif.debugfs_dir = NULL;
<span class="p_add">+	sdata-&gt;debugfs.subdir_stations = NULL;</span>
 }
 
 void ieee80211_debugfs_rename_netdev(struct ieee80211_sub_if_data *sdata)
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_core.c b/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_header">index b87ca32..8f9e9cc 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_chunk">@@ -313,7 +313,13 @@</span> <span class="p_context"> ip_vs_sched_persist(struct ip_vs_service *svc,</span>
 		 * return *ignored=0 i.e. ICMP and NF_DROP
 		 */
 		sched = rcu_dereference(svc-&gt;scheduler);
<span class="p_del">-		dest = sched-&gt;schedule(svc, skb, iph);</span>
<span class="p_add">+		if (sched) {</span>
<span class="p_add">+			/* read svc-&gt;sched_data after svc-&gt;scheduler */</span>
<span class="p_add">+			smp_rmb();</span>
<span class="p_add">+			dest = sched-&gt;schedule(svc, skb, iph);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			dest = NULL;</span>
<span class="p_add">+		}</span>
 		if (!dest) {
 			IP_VS_DBG(1, &quot;p-schedule: no dest found.\n&quot;);
 			kfree(param.pe_data);
<span class="p_chunk">@@ -461,7 +467,13 @@</span> <span class="p_context"> ip_vs_schedule(struct ip_vs_service *svc, struct sk_buff *skb,</span>
 	}
 
 	sched = rcu_dereference(svc-&gt;scheduler);
<span class="p_del">-	dest = sched-&gt;schedule(svc, skb, iph);</span>
<span class="p_add">+	if (sched) {</span>
<span class="p_add">+		/* read svc-&gt;sched_data after svc-&gt;scheduler */</span>
<span class="p_add">+		smp_rmb();</span>
<span class="p_add">+		dest = sched-&gt;schedule(svc, skb, iph);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dest = NULL;</span>
<span class="p_add">+	}</span>
 	if (dest == NULL) {
 		IP_VS_DBG(1, &quot;Schedule: no dest found.\n&quot;);
 		return NULL;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_ctl.c b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">index 7f91fbd..16c0afd 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_chunk">@@ -827,15 +827,16 @@</span> <span class="p_context"> __ip_vs_update_dest(struct ip_vs_service *svc, struct ip_vs_dest *dest,</span>
 	__ip_vs_dst_cache_reset(dest);
 	spin_unlock_bh(&amp;dest-&gt;dst_lock);
 
<span class="p_del">-	sched = rcu_dereference_protected(svc-&gt;scheduler, 1);</span>
 	if (add) {
 		ip_vs_start_estimator(svc-&gt;net, &amp;dest-&gt;stats);
 		list_add_rcu(&amp;dest-&gt;n_list, &amp;svc-&gt;destinations);
 		svc-&gt;num_dests++;
<span class="p_del">-		if (sched-&gt;add_dest)</span>
<span class="p_add">+		sched = rcu_dereference_protected(svc-&gt;scheduler, 1);</span>
<span class="p_add">+		if (sched &amp;&amp; sched-&gt;add_dest)</span>
 			sched-&gt;add_dest(svc, dest);
 	} else {
<span class="p_del">-		if (sched-&gt;upd_dest)</span>
<span class="p_add">+		sched = rcu_dereference_protected(svc-&gt;scheduler, 1);</span>
<span class="p_add">+		if (sched &amp;&amp; sched-&gt;upd_dest)</span>
 			sched-&gt;upd_dest(svc, dest);
 	}
 }
<span class="p_chunk">@@ -1069,7 +1070,7 @@</span> <span class="p_context"> static void __ip_vs_unlink_dest(struct ip_vs_service *svc,</span>
 		struct ip_vs_scheduler *sched;
 
 		sched = rcu_dereference_protected(svc-&gt;scheduler, 1);
<span class="p_del">-		if (sched-&gt;del_dest)</span>
<span class="p_add">+		if (sched &amp;&amp; sched-&gt;del_dest)</span>
 			sched-&gt;del_dest(svc, dest);
 	}
 }
<span class="p_chunk">@@ -1160,11 +1161,14 @@</span> <span class="p_context"> ip_vs_add_service(struct net *net, struct ip_vs_service_user_kern *u,</span>
 	ip_vs_use_count_inc();
 
 	/* Lookup the scheduler by &#39;u-&gt;sched_name&#39; */
<span class="p_del">-	sched = ip_vs_scheduler_get(u-&gt;sched_name);</span>
<span class="p_del">-	if (sched == NULL) {</span>
<span class="p_del">-		pr_info(&quot;Scheduler module ip_vs_%s not found\n&quot;, u-&gt;sched_name);</span>
<span class="p_del">-		ret = -ENOENT;</span>
<span class="p_del">-		goto out_err;</span>
<span class="p_add">+	if (strcmp(u-&gt;sched_name, &quot;none&quot;)) {</span>
<span class="p_add">+		sched = ip_vs_scheduler_get(u-&gt;sched_name);</span>
<span class="p_add">+		if (!sched) {</span>
<span class="p_add">+			pr_info(&quot;Scheduler module ip_vs_%s not found\n&quot;,</span>
<span class="p_add">+				u-&gt;sched_name);</span>
<span class="p_add">+			ret = -ENOENT;</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+		}</span>
 	}
 
 	if (u-&gt;pe_name &amp;&amp; *u-&gt;pe_name) {
<span class="p_chunk">@@ -1225,10 +1229,12 @@</span> <span class="p_context"> ip_vs_add_service(struct net *net, struct ip_vs_service_user_kern *u,</span>
 	spin_lock_init(&amp;svc-&gt;stats.lock);
 
 	/* Bind the scheduler */
<span class="p_del">-	ret = ip_vs_bind_scheduler(svc, sched);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto out_err;</span>
<span class="p_del">-	sched = NULL;</span>
<span class="p_add">+	if (sched) {</span>
<span class="p_add">+		ret = ip_vs_bind_scheduler(svc, sched);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+		sched = NULL;</span>
<span class="p_add">+	}</span>
 
 	/* Bind the ct retriever */
 	RCU_INIT_POINTER(svc-&gt;pe, pe);
<span class="p_chunk">@@ -1276,17 +1282,20 @@</span> <span class="p_context"> ip_vs_add_service(struct net *net, struct ip_vs_service_user_kern *u,</span>
 static int
 ip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)
 {
<span class="p_del">-	struct ip_vs_scheduler *sched, *old_sched;</span>
<span class="p_add">+	struct ip_vs_scheduler *sched = NULL, *old_sched;</span>
 	struct ip_vs_pe *pe = NULL, *old_pe = NULL;
 	int ret = 0;
 
 	/*
 	 * Lookup the scheduler, by &#39;u-&gt;sched_name&#39;
 	 */
<span class="p_del">-	sched = ip_vs_scheduler_get(u-&gt;sched_name);</span>
<span class="p_del">-	if (sched == NULL) {</span>
<span class="p_del">-		pr_info(&quot;Scheduler module ip_vs_%s not found\n&quot;, u-&gt;sched_name);</span>
<span class="p_del">-		return -ENOENT;</span>
<span class="p_add">+	if (strcmp(u-&gt;sched_name, &quot;none&quot;)) {</span>
<span class="p_add">+		sched = ip_vs_scheduler_get(u-&gt;sched_name);</span>
<span class="p_add">+		if (!sched) {</span>
<span class="p_add">+			pr_info(&quot;Scheduler module ip_vs_%s not found\n&quot;,</span>
<span class="p_add">+				u-&gt;sched_name);</span>
<span class="p_add">+			return -ENOENT;</span>
<span class="p_add">+		}</span>
 	}
 	old_sched = sched;
 
<span class="p_chunk">@@ -1314,14 +1323,20 @@</span> <span class="p_context"> ip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)</span>
 
 	old_sched = rcu_dereference_protected(svc-&gt;scheduler, 1);
 	if (sched != old_sched) {
<span class="p_add">+		if (old_sched) {</span>
<span class="p_add">+			ip_vs_unbind_scheduler(svc, old_sched);</span>
<span class="p_add">+			RCU_INIT_POINTER(svc-&gt;scheduler, NULL);</span>
<span class="p_add">+			/* Wait all svc-&gt;sched_data users */</span>
<span class="p_add">+			synchronize_rcu();</span>
<span class="p_add">+		}</span>
 		/* Bind the new scheduler */
<span class="p_del">-		ret = ip_vs_bind_scheduler(svc, sched);</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			old_sched = sched;</span>
<span class="p_del">-			goto out;</span>
<span class="p_add">+		if (sched) {</span>
<span class="p_add">+			ret = ip_vs_bind_scheduler(svc, sched);</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				ip_vs_scheduler_put(sched);</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
 		}
<span class="p_del">-		/* Unbind the old scheduler on success */</span>
<span class="p_del">-		ip_vs_unbind_scheduler(svc, old_sched);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -1961,6 +1976,7 @@</span> <span class="p_context"> static int ip_vs_info_seq_show(struct seq_file *seq, void *v)</span>
 		const struct ip_vs_iter *iter = seq-&gt;private;
 		const struct ip_vs_dest *dest;
 		struct ip_vs_scheduler *sched = rcu_dereference(svc-&gt;scheduler);
<span class="p_add">+		char *sched_name = sched ? sched-&gt;name : &quot;none&quot;;</span>
 
 		if (iter-&gt;table == ip_vs_svc_table) {
 #ifdef CONFIG_IP_VS_IPV6
<span class="p_chunk">@@ -1969,18 +1985,18 @@</span> <span class="p_context"> static int ip_vs_info_seq_show(struct seq_file *seq, void *v)</span>
 					   ip_vs_proto_name(svc-&gt;protocol),
 					   &amp;svc-&gt;addr.in6,
 					   ntohs(svc-&gt;port),
<span class="p_del">-					   sched-&gt;name);</span>
<span class="p_add">+					   sched_name);</span>
 			else
 #endif
 				seq_printf(seq, &quot;%s  %08X:%04X %s %s &quot;,
 					   ip_vs_proto_name(svc-&gt;protocol),
 					   ntohl(svc-&gt;addr.ip),
 					   ntohs(svc-&gt;port),
<span class="p_del">-					   sched-&gt;name,</span>
<span class="p_add">+					   sched_name,</span>
 					   (svc-&gt;flags &amp; IP_VS_SVC_F_ONEPACKET)?&quot;ops &quot;:&quot;&quot;);
 		} else {
 			seq_printf(seq, &quot;FWM  %08X %s %s&quot;,
<span class="p_del">-				   svc-&gt;fwmark, sched-&gt;name,</span>
<span class="p_add">+				   svc-&gt;fwmark, sched_name,</span>
 				   (svc-&gt;flags &amp; IP_VS_SVC_F_ONEPACKET)?&quot;ops &quot;:&quot;&quot;);
 		}
 
<span class="p_chunk">@@ -2400,13 +2416,15 @@</span> <span class="p_context"> static void</span>
 ip_vs_copy_service(struct ip_vs_service_entry *dst, struct ip_vs_service *src)
 {
 	struct ip_vs_scheduler *sched;
<span class="p_add">+	char *sched_name;</span>
 
 	sched = rcu_dereference_protected(src-&gt;scheduler, 1);
<span class="p_add">+	sched_name = sched ? sched-&gt;name : &quot;none&quot;;</span>
 	dst-&gt;protocol = src-&gt;protocol;
 	dst-&gt;addr = src-&gt;addr.ip;
 	dst-&gt;port = src-&gt;port;
 	dst-&gt;fwmark = src-&gt;fwmark;
<span class="p_del">-	strlcpy(dst-&gt;sched_name, sched-&gt;name, sizeof(dst-&gt;sched_name));</span>
<span class="p_add">+	strlcpy(dst-&gt;sched_name, sched_name, sizeof(dst-&gt;sched_name));</span>
 	dst-&gt;flags = src-&gt;flags;
 	dst-&gt;timeout = src-&gt;timeout / HZ;
 	dst-&gt;netmask = src-&gt;netmask;
<span class="p_chunk">@@ -2835,6 +2853,7 @@</span> <span class="p_context"> static int ip_vs_genl_fill_service(struct sk_buff *skb,</span>
 	struct nlattr *nl_service;
 	struct ip_vs_flags flags = { .flags = svc-&gt;flags,
 				     .mask = ~0 };
<span class="p_add">+	char *sched_name;</span>
 
 	nl_service = nla_nest_start(skb, IPVS_CMD_ATTR_SERVICE);
 	if (!nl_service)
<span class="p_chunk">@@ -2853,8 +2872,9 @@</span> <span class="p_context"> static int ip_vs_genl_fill_service(struct sk_buff *skb,</span>
 	}
 
 	sched = rcu_dereference_protected(svc-&gt;scheduler, 1);
<span class="p_add">+	sched_name = sched ? sched-&gt;name : &quot;none&quot;;</span>
 	pe = rcu_dereference_protected(svc-&gt;pe, 1);
<span class="p_del">-	if (nla_put_string(skb, IPVS_SVC_ATTR_SCHED_NAME, sched-&gt;name) ||</span>
<span class="p_add">+	if (nla_put_string(skb, IPVS_SVC_ATTR_SCHED_NAME, sched_name) ||</span>
 	    (pe &amp;&amp; nla_put_string(skb, IPVS_SVC_ATTR_PE_NAME, pe-&gt;name)) ||
 	    nla_put(skb, IPVS_SVC_ATTR_FLAGS, sizeof(flags), &amp;flags) ||
 	    nla_put_u32(skb, IPVS_SVC_ATTR_TIMEOUT, svc-&gt;timeout / HZ) ||
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_sched.c b/net/netfilter/ipvs/ip_vs_sched.c</span>
<span class="p_header">index 199760c..7e81416 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_sched.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_sched.c</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> void ip_vs_unbind_scheduler(struct ip_vs_service *svc,</span>
 
 	if (sched-&gt;done_service)
 		sched-&gt;done_service(svc);
<span class="p_del">-	/* svc-&gt;scheduler can not be set to NULL */</span>
<span class="p_add">+	/* svc-&gt;scheduler can be set to NULL only by caller */</span>
 }
 
 
<span class="p_chunk">@@ -147,21 +147,21 @@</span> <span class="p_context"> void ip_vs_scheduler_put(struct ip_vs_scheduler *scheduler)</span>
 
 void ip_vs_scheduler_err(struct ip_vs_service *svc, const char *msg)
 {
<span class="p_del">-	struct ip_vs_scheduler *sched;</span>
<span class="p_add">+	struct ip_vs_scheduler *sched = rcu_dereference(svc-&gt;scheduler);</span>
<span class="p_add">+	char *sched_name = sched ? sched-&gt;name : &quot;none&quot;;</span>
 
<span class="p_del">-	sched = rcu_dereference(svc-&gt;scheduler);</span>
 	if (svc-&gt;fwmark) {
 		IP_VS_ERR_RL(&quot;%s: FWM %u 0x%08X - %s\n&quot;,
<span class="p_del">-			     sched-&gt;name, svc-&gt;fwmark, svc-&gt;fwmark, msg);</span>
<span class="p_add">+			     sched_name, svc-&gt;fwmark, svc-&gt;fwmark, msg);</span>
 #ifdef CONFIG_IP_VS_IPV6
 	} else if (svc-&gt;af == AF_INET6) {
 		IP_VS_ERR_RL(&quot;%s: %s [%pI6c]:%d - %s\n&quot;,
<span class="p_del">-			     sched-&gt;name, ip_vs_proto_name(svc-&gt;protocol),</span>
<span class="p_add">+			     sched_name, ip_vs_proto_name(svc-&gt;protocol),</span>
 			     &amp;svc-&gt;addr.in6, ntohs(svc-&gt;port), msg);
 #endif
 	} else {
 		IP_VS_ERR_RL(&quot;%s: %s %pI4:%d - %s\n&quot;,
<span class="p_del">-			     sched-&gt;name, ip_vs_proto_name(svc-&gt;protocol),</span>
<span class="p_add">+			     sched_name, ip_vs_proto_name(svc-&gt;protocol),</span>
 			     &amp;svc-&gt;addr.ip, ntohs(svc-&gt;port), msg);
 	}
 }
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_sync.c b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">index d93ceeb..7a06b38 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_chunk">@@ -612,7 +612,7 @@</span> <span class="p_context"> static void ip_vs_sync_conn_v0(struct net *net, struct ip_vs_conn *cp,</span>
 			pkts = atomic_add_return(1, &amp;cp-&gt;in_pkts);
 		else
 			pkts = sysctl_sync_threshold(ipvs);
<span class="p_del">-		ip_vs_sync_conn(net, cp-&gt;control, pkts);</span>
<span class="p_add">+		ip_vs_sync_conn(net, cp, pkts);</span>
 	}
 }
 
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_xmit.c b/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_header">index 3aedbda..e7fbb80 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_chunk">@@ -130,7 +130,6 @@</span> <span class="p_context"> static struct rtable *do_output_route4(struct net *net, __be32 daddr,</span>
 
 	memset(&amp;fl4, 0, sizeof(fl4));
 	fl4.daddr = daddr;
<span class="p_del">-	fl4.saddr = (rt_mode &amp; IP_VS_RT_MODE_CONNECT) ? *saddr : 0;</span>
 	fl4.flowi4_flags = (rt_mode &amp; IP_VS_RT_MODE_KNOWN_NH) ?
 			   FLOWI_FLAG_KNOWN_NH : 0;
 
<span class="p_chunk">@@ -523,6 +522,21 @@</span> <span class="p_context"> static inline int ip_vs_tunnel_xmit_prepare(struct sk_buff *skb,</span>
 	return ret;
 }
 
<span class="p_add">+/* In the event of a remote destination, it&#39;s possible that we would have</span>
<span class="p_add">+ * matches against an old socket (particularly a TIME-WAIT socket). This</span>
<span class="p_add">+ * causes havoc down the line (ip_local_out et. al. expect regular sockets</span>
<span class="p_add">+ * and invalid memory accesses will happen) so simply drop the association</span>
<span class="p_add">+ * in this case.</span>
<span class="p_add">+*/</span>
<span class="p_add">+static inline void ip_vs_drop_early_demux_sk(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* If dev is set, the packet came from the LOCAL_IN callback and</span>
<span class="p_add">+	 * not from a local TCP socket.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (skb-&gt;dev)</span>
<span class="p_add">+		skb_orphan(skb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* return NF_STOLEN (sent) or NF_ACCEPT if local=1 (not sent) */
 static inline int ip_vs_nat_send_or_cont(int pf, struct sk_buff *skb,
 					 struct ip_vs_conn *cp, int local)
<span class="p_chunk">@@ -534,12 +548,21 @@</span> <span class="p_context"> static inline int ip_vs_nat_send_or_cont(int pf, struct sk_buff *skb,</span>
 		ip_vs_notrack(skb);
 	else
 		ip_vs_update_conntrack(skb, cp, 1);
<span class="p_add">+</span>
<span class="p_add">+	/* Remove the early_demux association unless it&#39;s bound for the</span>
<span class="p_add">+	 * exact same port and address on this host after translation.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!local || cp-&gt;vport != cp-&gt;dport ||</span>
<span class="p_add">+	    !ip_vs_addr_equal(cp-&gt;af, &amp;cp-&gt;vaddr, &amp;cp-&gt;daddr))</span>
<span class="p_add">+		ip_vs_drop_early_demux_sk(skb);</span>
<span class="p_add">+</span>
 	if (!local) {
 		skb_forward_csum(skb);
 		NF_HOOK(pf, NF_INET_LOCAL_OUT, skb, NULL, skb_dst(skb)-&gt;dev,
 			dst_output);
 	} else
 		ret = NF_ACCEPT;
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -553,6 +576,7 @@</span> <span class="p_context"> static inline int ip_vs_send_or_cont(int pf, struct sk_buff *skb,</span>
 	if (likely(!(cp-&gt;flags &amp; IP_VS_CONN_F_NFCT)))
 		ip_vs_notrack(skb);
 	if (!local) {
<span class="p_add">+		ip_vs_drop_early_demux_sk(skb);</span>
 		skb_forward_csum(skb);
 		NF_HOOK(pf, NF_INET_LOCAL_OUT, skb, NULL, skb_dst(skb)-&gt;dev,
 			dst_output);
<span class="p_chunk">@@ -841,6 +865,8 @@</span> <span class="p_context"> ip_vs_prepare_tunneled_skb(struct sk_buff *skb, int skb_af,</span>
 	struct ipv6hdr *old_ipv6h = NULL;
 #endif
 
<span class="p_add">+	ip_vs_drop_early_demux_sk(skb);</span>
<span class="p_add">+</span>
 	if (skb_headroom(skb) &lt; max_headroom || skb_cloned(skb)) {
 		new_skb = skb_realloc_headroom(skb, max_headroom);
 		if (!new_skb)
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_expect.c b/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_header">index 91a1837..26af451 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_expect.c</span>
<span class="p_chunk">@@ -219,7 +219,8 @@</span> <span class="p_context"> static inline int expect_clash(const struct nf_conntrack_expect *a,</span>
 			a-&gt;mask.src.u3.all[count] &amp; b-&gt;mask.src.u3.all[count];
 	}
 
<span class="p_del">-	return nf_ct_tuple_mask_cmp(&amp;a-&gt;tuple, &amp;b-&gt;tuple, &amp;intersect_mask);</span>
<span class="p_add">+	return nf_ct_tuple_mask_cmp(&amp;a-&gt;tuple, &amp;b-&gt;tuple, &amp;intersect_mask) &amp;&amp;</span>
<span class="p_add">+	       nf_ct_zone(a-&gt;master) == nf_ct_zone(b-&gt;master);</span>
 }
 
 static inline int expect_matches(const struct nf_conntrack_expect *a,
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">index 1bd9ed9..d3ea299 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_chunk">@@ -2956,11 +2956,6 @@</span> <span class="p_context"> ctnetlink_create_expect(struct net *net, u16 zone,</span>
 	}
 
 	err = nf_ct_expect_related_report(exp, portid, report);
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		goto err_exp;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-err_exp:</span>
 	nf_ct_expect_put(exp);
 err_ct:
 	nf_ct_put(ct);
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index b215289..8da43cb 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -2285,7 +2285,8 @@</span> <span class="p_context"> static int tpacket_snd(struct packet_sock *po, struct msghdr *msg)</span>
 
 		tp_len = tpacket_fill_skb(po, skb, ph, dev, size_max, proto,
 					  addr, hlen);
<span class="p_del">-		if (tp_len &gt; dev-&gt;mtu + dev-&gt;hard_header_len) {</span>
<span class="p_add">+		if (likely(tp_len &gt;= 0) &amp;&amp;</span>
<span class="p_add">+		    tp_len &gt; dev-&gt;mtu + dev-&gt;hard_header_len) {</span>
 			struct ethhdr *ehdr;
 			/* Earlier code assumed this would be a VLAN pkt,
 			 * double-check this now that we have the actual
<span class="p_chunk">@@ -2667,7 +2668,7 @@</span> <span class="p_context"> static int packet_release(struct socket *sock)</span>
 static int packet_do_bind(struct sock *sk, struct net_device *dev, __be16 proto)
 {
 	struct packet_sock *po = pkt_sk(sk);
<span class="p_del">-	const struct net_device *dev_curr;</span>
<span class="p_add">+	struct net_device *dev_curr;</span>
 	__be16 proto_curr;
 	bool need_rehook;
 
<span class="p_chunk">@@ -2691,15 +2692,13 @@</span> <span class="p_context"> static int packet_do_bind(struct sock *sk, struct net_device *dev, __be16 proto)</span>
 
 		po-&gt;num = proto;
 		po-&gt;prot_hook.type = proto;
<span class="p_del">-</span>
<span class="p_del">-		if (po-&gt;prot_hook.dev)</span>
<span class="p_del">-			dev_put(po-&gt;prot_hook.dev);</span>
<span class="p_del">-</span>
 		po-&gt;prot_hook.dev = dev;
 
 		po-&gt;ifindex = dev ? dev-&gt;ifindex : 0;
 		packet_cached_dev_assign(po, dev);
 	}
<span class="p_add">+	if (dev_curr)</span>
<span class="p_add">+		dev_put(dev_curr);</span>
 
 	if (proto == 0 || !need_rehook)
 		goto out_unlock;
<span class="p_header">diff --git a/net/sched/act_api.c b/net/sched/act_api.c</span>
<span class="p_header">index 3d43e49..f8d9c2a 100644</span>
<span class="p_header">--- a/net/sched/act_api.c</span>
<span class="p_header">+++ b/net/sched/act_api.c</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> void tcf_hash_destroy(struct tc_action *a)</span>
 }
 EXPORT_SYMBOL(tcf_hash_destroy);
 
<span class="p_del">-int tcf_hash_release(struct tc_action *a, int bind)</span>
<span class="p_add">+int __tcf_hash_release(struct tc_action *a, bool bind, bool strict)</span>
 {
 	struct tcf_common *p = a-&gt;priv;
 	int ret = 0;
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> int tcf_hash_release(struct tc_action *a, int bind)</span>
 	if (p) {
 		if (bind)
 			p-&gt;tcfc_bindcnt--;
<span class="p_del">-		else if (p-&gt;tcfc_bindcnt &gt; 0)</span>
<span class="p_add">+		else if (strict &amp;&amp; p-&gt;tcfc_bindcnt &gt; 0)</span>
 			return -EPERM;
 
 		p-&gt;tcfc_refcnt--;
<span class="p_chunk">@@ -64,9 +64,10 @@</span> <span class="p_context"> int tcf_hash_release(struct tc_action *a, int bind)</span>
 			ret = 1;
 		}
 	}
<span class="p_add">+</span>
 	return ret;
 }
<span class="p_del">-EXPORT_SYMBOL(tcf_hash_release);</span>
<span class="p_add">+EXPORT_SYMBOL(__tcf_hash_release);</span>
 
 static int tcf_dump_walker(struct sk_buff *skb, struct netlink_callback *cb,
 			   struct tc_action *a)
<span class="p_chunk">@@ -136,7 +137,7 @@</span> <span class="p_context"> static int tcf_del_walker(struct sk_buff *skb, struct tc_action *a)</span>
 		head = &amp;hinfo-&gt;htab[tcf_hash(i, hinfo-&gt;hmask)];
 		hlist_for_each_entry_safe(p, n, head, tcfc_head) {
 			a-&gt;priv = p;
<span class="p_del">-			ret = tcf_hash_release(a, 0);</span>
<span class="p_add">+			ret = __tcf_hash_release(a, false, true);</span>
 			if (ret == ACT_P_DELETED) {
 				module_put(a-&gt;ops-&gt;owner);
 				n_i++;
<span class="p_chunk">@@ -413,7 +414,7 @@</span> <span class="p_context"> int tcf_action_destroy(struct list_head *actions, int bind)</span>
 	int ret = 0;
 
 	list_for_each_entry_safe(a, tmp, actions, list) {
<span class="p_del">-		ret = tcf_hash_release(a, bind);</span>
<span class="p_add">+		ret = __tcf_hash_release(a, bind, true);</span>
 		if (ret == ACT_P_DELETED)
 			module_put(a-&gt;ops-&gt;owner);
 		else if (ret &lt; 0)
<span class="p_header">diff --git a/net/sched/act_pedit.c b/net/sched/act_pedit.c</span>
<span class="p_header">index 59649d5..4298e8d 100644</span>
<span class="p_header">--- a/net/sched/act_pedit.c</span>
<span class="p_header">+++ b/net/sched/act_pedit.c</span>
<span class="p_chunk">@@ -68,13 +68,12 @@</span> <span class="p_context"> static int tcf_pedit_init(struct net *net, struct nlattr *nla,</span>
 		}
 		ret = ACT_P_CREATED;
 	} else {
<span class="p_del">-		p = to_pedit(a);</span>
<span class="p_del">-		tcf_hash_release(a, bind);</span>
 		if (bind)
 			return 0;
<span class="p_add">+		tcf_hash_release(a, bind);</span>
 		if (!ovr)
 			return -EEXIST;
<span class="p_del">-</span>
<span class="p_add">+		p = to_pedit(a);</span>
 		if (p-&gt;tcfp_nkeys &amp;&amp; p-&gt;tcfp_nkeys != parm-&gt;nkeys) {
 			keys = kmalloc(ksize, GFP_KERNEL);
 			if (keys == NULL)
<span class="p_header">diff --git a/net/sched/cls_bpf.c b/net/sched/cls_bpf.c</span>
<span class="p_header">index f59adf8..7ef71a2 100644</span>
<span class="p_header">--- a/net/sched/cls_bpf.c</span>
<span class="p_header">+++ b/net/sched/cls_bpf.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static int cls_bpf_change(struct net *net, struct sk_buff *in_skb,</span>
 		goto errout;
 
 	if (oldprog) {
<span class="p_del">-		list_replace_rcu(&amp;prog-&gt;link, &amp;oldprog-&gt;link);</span>
<span class="p_add">+		list_replace_rcu(&amp;oldprog-&gt;link, &amp;prog-&gt;link);</span>
 		tcf_unbind_filter(tp, &amp;oldprog-&gt;res);
 		call_rcu(&amp;oldprog-&gt;rcu, __cls_bpf_delete_prog);
 	} else {
<span class="p_header">diff --git a/net/sched/cls_flow.c b/net/sched/cls_flow.c</span>
<span class="p_header">index 15d68f2..bca348a 100644</span>
<span class="p_header">--- a/net/sched/cls_flow.c</span>
<span class="p_header">+++ b/net/sched/cls_flow.c</span>
<span class="p_chunk">@@ -419,6 +419,8 @@</span> <span class="p_context"> static int flow_change(struct net *net, struct sk_buff *in_skb,</span>
 	if (!fnew)
 		goto err2;
 
<span class="p_add">+	tcf_exts_init(&amp;fnew-&gt;exts, TCA_FLOW_ACT, TCA_FLOW_POLICE);</span>
<span class="p_add">+</span>
 	fold = (struct flow_filter *)*arg;
 	if (fold) {
 		err = -EINVAL;
<span class="p_chunk">@@ -480,7 +482,6 @@</span> <span class="p_context"> static int flow_change(struct net *net, struct sk_buff *in_skb,</span>
 		fnew-&gt;mask  = ~0U;
 		fnew-&gt;tp = tp;
 		get_random_bytes(&amp;fnew-&gt;hashrnd, 4);
<span class="p_del">-		tcf_exts_init(&amp;fnew-&gt;exts, TCA_FLOW_ACT, TCA_FLOW_POLICE);</span>
 	}
 
 	fnew-&gt;perturb_timer.function = flow_perturbation;
<span class="p_chunk">@@ -520,7 +521,7 @@</span> <span class="p_context"> static int flow_change(struct net *net, struct sk_buff *in_skb,</span>
 	if (*arg == 0)
 		list_add_tail_rcu(&amp;fnew-&gt;list, &amp;head-&gt;filters);
 	else
<span class="p_del">-		list_replace_rcu(&amp;fnew-&gt;list, &amp;fold-&gt;list);</span>
<span class="p_add">+		list_replace_rcu(&amp;fold-&gt;list, &amp;fnew-&gt;list);</span>
 
 	*arg = (unsigned long)fnew;
 
<span class="p_header">diff --git a/net/sched/sch_fq_codel.c b/net/sched/sch_fq_codel.c</span>
<span class="p_header">index 1e52dec..b61fd84 100644</span>
<span class="p_header">--- a/net/sched/sch_fq_codel.c</span>
<span class="p_header">+++ b/net/sched/sch_fq_codel.c</span>
<span class="p_chunk">@@ -162,10 +162,10 @@</span> <span class="p_context"> static unsigned int fq_codel_drop(struct Qdisc *sch)</span>
 	skb = dequeue_head(flow);
 	len = qdisc_pkt_len(skb);
 	q-&gt;backlogs[idx] -= len;
<span class="p_del">-	kfree_skb(skb);</span>
 	sch-&gt;q.qlen--;
 	qdisc_qstats_drop(sch);
 	qdisc_qstats_backlog_dec(sch, skb);
<span class="p_add">+	kfree_skb(skb);</span>
 	flow-&gt;dropped++;
 	return idx;
 }
<span class="p_header">diff --git a/net/sched/sch_sfq.c b/net/sched/sch_sfq.c</span>
<span class="p_header">index b877140..0f65ba4 100644</span>
<span class="p_header">--- a/net/sched/sch_sfq.c</span>
<span class="p_header">+++ b/net/sched/sch_sfq.c</span>
<span class="p_chunk">@@ -329,10 +329,10 @@</span> <span class="p_context"> drop:</span>
 		len = qdisc_pkt_len(skb);
 		slot-&gt;backlog -= len;
 		sfq_dec(q, x);
<span class="p_del">-		kfree_skb(skb);</span>
 		sch-&gt;q.qlen--;
 		qdisc_qstats_drop(sch);
 		qdisc_qstats_backlog_dec(sch, skb);
<span class="p_add">+		kfree_skb(skb);</span>
 		return len;
 	}
 
<span class="p_header">diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c</span>
<span class="p_header">index 64d9863..3f2ac8d 100644</span>
<span class="p_header">--- a/sound/core/pcm_native.c</span>
<span class="p_header">+++ b/sound/core/pcm_native.c</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static DECLARE_RWSEM(snd_pcm_link_rwsem);</span>
 void snd_pcm_stream_lock(struct snd_pcm_substream *substream)
 {
 	if (substream-&gt;pcm-&gt;nonatomic) {
<span class="p_del">-		down_read(&amp;snd_pcm_link_rwsem);</span>
<span class="p_add">+		down_read_nested(&amp;snd_pcm_link_rwsem, SINGLE_DEPTH_NESTING);</span>
 		mutex_lock(&amp;substream-&gt;self_group.mutex);
 	} else {
 		read_lock(&amp;snd_pcm_link_rwlock);
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 158ec63..a4e6e2f 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2096,6 +2096,8 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	/* ATI HDMI */
 	{ PCI_DEVICE(0x1002, 0x1308),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0x157a),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	{ PCI_DEVICE(0x1002, 0x793b),
 	  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },
 	{ PCI_DEVICE(0x1002, 0x7919),
<span class="p_chunk">@@ -2150,8 +2152,14 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
 	{ PCI_DEVICE(0x1002, 0xaab0),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0xaac0),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	{ PCI_DEVICE(0x1002, 0xaac8),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0xaad8),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0xaae8),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	/* VIA VT8251/VT8237A */
 	{ PCI_DEVICE(0x1106, 0x3288),
 	  .driver_data = AZX_DRIVER_VIA | AZX_DCAPS_POSFIX_VIA },
<span class="p_header">diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">index dd2b3d9..e5dac8e 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_chunk">@@ -1001,9 +1001,7 @@</span> <span class="p_context"> static void cs4210_spdif_automute(struct hda_codec *codec,</span>
 
 	spec-&gt;spdif_present = spdif_present;
 	/* SPDIF TX on/off */
<span class="p_del">-	if (spdif_present)</span>
<span class="p_del">-		snd_hda_set_pin_ctl(codec, spdif_pin,</span>
<span class="p_del">-				    spdif_present ? PIN_OUT : 0);</span>
<span class="p_add">+	snd_hda_set_pin_ctl(codec, spdif_pin, spdif_present ? PIN_OUT : 0);</span>
 
 	cs_automute(codec);
 }
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index b422e40..cfdc5a7 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -3354,6 +3354,7 @@</span> <span class="p_context"> static const struct hda_codec_preset snd_hda_preset_hdmi[] = {</span>
 { .id = 0x10de0070, .name = &quot;GPU 70 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de0071, .name = &quot;GPU 71 HDMI/DP&quot;,	.patch = patch_nvhdmi },
 { .id = 0x10de0072, .name = &quot;GPU 72 HDMI/DP&quot;,	.patch = patch_nvhdmi },
<span class="p_add">+{ .id = 0x10de007d, .name = &quot;GPU 7d HDMI/DP&quot;,	.patch = patch_nvhdmi },</span>
 { .id = 0x10de8001, .name = &quot;MCP73 HDMI&quot;,	.patch = patch_nvhdmi_2ch },
 { .id = 0x11069f80, .name = &quot;VX900 HDMI/DP&quot;,	.patch = patch_via_hdmi },
 { .id = 0x11069f81, .name = &quot;VX900 HDMI/DP&quot;,	.patch = patch_via_hdmi },
<span class="p_chunk">@@ -3415,6 +3416,7 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;snd-hda-codec-id:10de0067&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de0070&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de0071&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de0072&quot;);
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:10de007d&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:10de8001&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:11069f80&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:11069f81&quot;);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 652e6a8..ac7c8d0 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -2221,7 +2221,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x106b, 0x4300, &quot;iMac 9,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4600, &quot;MacbookPro 5,2&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4900, &quot;iMac 9,1 Aluminum&quot;, ALC889_FIXUP_IMAC91_VREF),
<span class="p_del">-	SND_PCI_QUIRK(0x106b, 0x4a00, &quot;Macbook 5,2&quot;, ALC889_FIXUP_IMAC91_VREF),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x106b, 0x4a00, &quot;Macbook 5,2&quot;, ALC889_FIXUP_MBA11_VREF),</span>
 
 	SND_PCI_QUIRK(0x1071, 0x8258, &quot;Evesham Voyaeger&quot;, ALC882_FIXUP_EAPD),
 	SND_PCI_QUIRK(0x1462, 0x7350, &quot;MSI-7350&quot;, ALC889_FIXUP_CD),
<span class="p_chunk">@@ -4836,7 +4836,7 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{ 0x14, 0x90170110 },
 			{ 0x17, 0x40000008 },
 			{ 0x18, 0x411111f0 },
<span class="p_del">-			{ 0x19, 0x411111f0 },</span>
<span class="p_add">+			{ 0x19, 0x01a1913c },</span>
 			{ 0x1a, 0x411111f0 },
 			{ 0x1b, 0x411111f0 },
 			{ 0x1d, 0x40f89b2d },
<span class="p_chunk">@@ -4876,6 +4876,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x0638, &quot;Dell Inspiron 5439&quot;, ALC290_FIXUP_MONO_SPEAKERS_HSJACK),
 	SND_PCI_QUIRK(0x1028, 0x064a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x064b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x069a, &quot;Dell Vostro 5480&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),</span>
 	SND_PCI_QUIRK(0x1028, 0x06c7, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06d9, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06da, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_chunk">@@ -5134,6 +5135,17 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x1d, 0x40700001},
 		{0x21, 0x02211030}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x12, 0x40000000},</span>
<span class="p_add">+		{0x14, 0x90170130},</span>
<span class="p_add">+		{0x17, 0x411111f0},</span>
<span class="p_add">+		{0x18, 0x411111f0},</span>
<span class="p_add">+		{0x19, 0x411111f0},</span>
<span class="p_add">+		{0x1a, 0x411111f0},</span>
<span class="p_add">+		{0x1b, 0x01014020},</span>
<span class="p_add">+		{0x1d, 0x4054c029},</span>
<span class="p_add">+		{0x1e, 0x411111f0},</span>
<span class="p_add">+		{0x21, 0x0221103f}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x12, 0x90a60160},
 		{0x14, 0x90170120},
 		{0x17, 0x90170140},
<span class="p_header">diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">index 60b3100..4469f3e 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_chunk">@@ -2919,7 +2919,8 @@</span> <span class="p_context"> static const struct snd_pci_quirk stac92hd83xxx_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(PCI_VENDOR_ID_HP, 0x148a,
 		      &quot;HP Mini&quot;, STAC_92HD83XXX_HP_LED),
 	SND_PCI_QUIRK_VENDOR(PCI_VENDOR_ID_HP, &quot;HP&quot;, STAC_92HD83XXX_HP),
<span class="p_del">-	SND_PCI_QUIRK(PCI_VENDOR_ID_TOSHIBA, 0xfa91,</span>
<span class="p_add">+	/* match both for 0xfa91 and 0xfa93 */</span>
<span class="p_add">+	SND_PCI_QUIRK_MASK(PCI_VENDOR_ID_TOSHIBA, 0xfffd, 0xfa91,</span>
 		      &quot;Toshiba Satellite S50D&quot;, STAC_92HD83XXX_GPIO10_EAPD),
 	{} /* terminator */
 };
<span class="p_header">diff --git a/sound/soc/codecs/pcm1681.c b/sound/soc/codecs/pcm1681.c</span>
<span class="p_header">index 477e13d..e7ba557 100644</span>
<span class="p_header">--- a/sound/soc/codecs/pcm1681.c</span>
<span class="p_header">+++ b/sound/soc/codecs/pcm1681.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static int pcm1681_set_deemph(struct snd_soc_codec *codec)</span>
 
 	if (val != -1) {
 		regmap_update_bits(priv-&gt;regmap, PCM1681_DEEMPH_CONTROL,
<span class="p_del">-					PCM1681_DEEMPH_RATE_MASK, val);</span>
<span class="p_add">+				   PCM1681_DEEMPH_RATE_MASK, val &lt;&lt; 3);</span>
 		enable = 1;
 	} else
 		enable = 0;
<span class="p_header">diff --git a/sound/soc/codecs/ssm4567.c b/sound/soc/codecs/ssm4567.c</span>
<span class="p_header">index a984485..f7549cc 100644</span>
<span class="p_header">--- a/sound/soc/codecs/ssm4567.c</span>
<span class="p_header">+++ b/sound/soc/codecs/ssm4567.c</span>
<span class="p_chunk">@@ -315,7 +315,13 @@</span> <span class="p_context"> static int ssm4567_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)</span>
 	if (invert_fclk)
 		ctrl1 |= SSM4567_SAI_CTRL_1_FSYNC;
 
<span class="p_del">-	return regmap_write(ssm4567-&gt;regmap, SSM4567_REG_SAI_CTRL_1, ctrl1);</span>
<span class="p_add">+	return regmap_update_bits(ssm4567-&gt;regmap, SSM4567_REG_SAI_CTRL_1,</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_BCLK |</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_FSYNC |</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_LJ |</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_TDM |</span>
<span class="p_add">+			SSM4567_SAI_CTRL_1_PDM,</span>
<span class="p_add">+			ctrl1);</span>
 }
 
 static int ssm4567_set_power(struct ssm4567 *ssm4567, bool enable)
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index 9d56b0b..ec3cc88 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -1791,6 +1791,7 @@</span> <span class="p_context"> static ssize_t dapm_widget_power_read_file(struct file *file,</span>
 					   size_t count, loff_t *ppos)
 {
 	struct snd_soc_dapm_widget *w = file-&gt;private_data;
<span class="p_add">+	struct snd_soc_card *card = w-&gt;dapm-&gt;card;</span>
 	char *buf;
 	int in, out;
 	ssize_t ret;
<span class="p_chunk">@@ -1800,6 +1801,8 @@</span> <span class="p_context"> static ssize_t dapm_widget_power_read_file(struct file *file,</span>
 	if (!buf)
 		return -ENOMEM;
 
<span class="p_add">+	mutex_lock(&amp;card-&gt;dapm_mutex);</span>
<span class="p_add">+</span>
 	/* Supply widgets are not handled by is_connected_{input,output}_ep() */
 	if (w-&gt;is_supply) {
 		in = 0;
<span class="p_chunk">@@ -1846,6 +1849,8 @@</span> <span class="p_context"> static ssize_t dapm_widget_power_read_file(struct file *file,</span>
 					p-&gt;sink-&gt;name);
 	}
 
<span class="p_add">+	mutex_unlock(&amp;card-&gt;dapm_mutex);</span>
<span class="p_add">+</span>
 	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
 	kfree(buf);
<span class="p_chunk">@@ -2117,11 +2122,15 @@</span> <span class="p_context"> static ssize_t dapm_widget_show(struct device *dev,</span>
 	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
 	int i, count = 0;
 
<span class="p_add">+	mutex_lock(&amp;rtd-&gt;card-&gt;dapm_mutex);</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; rtd-&gt;num_codecs; i++) {
 		struct snd_soc_codec *codec = rtd-&gt;codec_dais[i]-&gt;codec;
 		count += dapm_widget_show_codec(codec, buf + count);
 	}
 
<span class="p_add">+	mutex_unlock(&amp;rtd-&gt;card-&gt;dapm_mutex);</span>
<span class="p_add">+</span>
 	return count;
 }
 
<span class="p_chunk">@@ -3073,16 +3082,10 @@</span> <span class="p_context"> snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,</span>
 	}
 
 	prefix = soc_dapm_prefix(dapm);
<span class="p_del">-	if (prefix) {</span>
<span class="p_add">+	if (prefix)</span>
 		w-&gt;name = kasprintf(GFP_KERNEL, &quot;%s %s&quot;, prefix, widget-&gt;name);
<span class="p_del">-		if (widget-&gt;sname)</span>
<span class="p_del">-			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s %s&quot;, prefix,</span>
<span class="p_del">-					     widget-&gt;sname);</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	else</span>
 		w-&gt;name = kasprintf(GFP_KERNEL, &quot;%s&quot;, widget-&gt;name);
<span class="p_del">-		if (widget-&gt;sname)</span>
<span class="p_del">-			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s&quot;, widget-&gt;sname);</span>
<span class="p_del">-	}</span>
 	if (w-&gt;name == NULL) {
 		kfree(w);
 		return NULL;
<span class="p_chunk">@@ -3408,7 +3411,7 @@</span> <span class="p_context"> int snd_soc_dapm_link_dai_widgets(struct snd_soc_card *card)</span>
 				break;
 			}
 
<span class="p_del">-			if (!w-&gt;sname || !strstr(w-&gt;sname, dai_w-&gt;name))</span>
<span class="p_add">+			if (!w-&gt;sname || !strstr(w-&gt;sname, dai_w-&gt;sname))</span>
 				continue;
 
 			if (dai_w-&gt;id == snd_soc_dapm_dai_in) {
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index e5000da..6a803ef 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -341,6 +341,20 @@</span> <span class="p_context"> static const struct usbmix_name_map scms_usb3318_map[] = {</span>
 	{ 0 }
 };
 
<span class="p_add">+/* Bose companion 5, the dB conversion factor is 16 instead of 256 */</span>
<span class="p_add">+static struct usbmix_dB_map bose_companion5_dB = {-5006, -6};</span>
<span class="p_add">+static struct usbmix_name_map bose_companion5_map[] = {</span>
<span class="p_add">+	{ 3, NULL, .dB = &amp;bose_companion5_dB },</span>
<span class="p_add">+	{ 0 }	/* terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Dragonfly DAC 1.2, the dB conversion factor is 1 instead of 256 */</span>
<span class="p_add">+static struct usbmix_dB_map dragonfly_1_2_dB = {0, 5000};</span>
<span class="p_add">+static struct usbmix_name_map dragonfly_1_2_map[] = {</span>
<span class="p_add">+	{ 7, NULL, .dB = &amp;dragonfly_1_2_dB },</span>
<span class="p_add">+	{ 0 }	/* terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Control map entries
  */
<span class="p_chunk">@@ -451,6 +465,16 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.id = USB_ID(0x25c4, 0x0003),
 		.map = scms_usb3318_map,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Bose Companion 5 */</span>
<span class="p_add">+		.id = USB_ID(0x05a7, 0x1020),</span>
<span class="p_add">+		.map = bose_companion5_map,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Dragonfly DAC 1.2 */</span>
<span class="p_add">+		.id = USB_ID(0x21b4, 0x0081),</span>
<span class="p_add">+		.map = dragonfly_1_2_map,</span>
<span class="p_add">+	},</span>
 	{ 0 } /* terminator */
 };
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



