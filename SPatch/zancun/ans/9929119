
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.46 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.46</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 30, 2017, 9:26 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170830092640.GB14620@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9929119/mbox/"
   >mbox</a>
|
   <a href="/patch/9929119/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9929119/">/patch/9929119/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	BE62B60380 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 30 Aug 2017 09:26:51 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A1FF628415
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 30 Aug 2017 09:26:51 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 9668A2841C; Wed, 30 Aug 2017 09:26:51 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9BDA528415
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 30 Aug 2017 09:26:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751844AbdH3J0o (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 30 Aug 2017 05:26:44 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:48584 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751823AbdH3J0h (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 30 Aug 2017 05:26:37 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 6C0F2955;
	Wed, 30 Aug 2017 09:26:35 +0000 (UTC)
Date: Wed, 30 Aug 2017 11:26:40 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.46
Message-ID: &lt;20170830092640.GB14620@kroah.com&gt;
References: &lt;20170830092636.GA14620@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170830092636.GA14620@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 30, 2017, 9:26 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index ccd6d91f616e..846ef1b57a02 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 45</span>
<span class="p_add">+SUBLEVEL = 46</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arc/include/asm/cache.h b/arch/arc/include/asm/cache.h</span>
<span class="p_header">index b3410ff6a62d..4fd6272e6c01 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/cache.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/cache.h</span>
<span class="p_chunk">@@ -89,7 +89,9 @@</span> <span class="p_context"> extern unsigned long perip_base, perip_end;</span>
 #define ARC_REG_SLC_FLUSH	0x904
 #define ARC_REG_SLC_INVALIDATE	0x905
 #define ARC_REG_SLC_RGN_START	0x914
<span class="p_add">+#define ARC_REG_SLC_RGN_START1	0x915</span>
 #define ARC_REG_SLC_RGN_END	0x916
<span class="p_add">+#define ARC_REG_SLC_RGN_END1	0x917</span>
 
 /* Bit val in SLC_CONTROL */
 #define SLC_CTRL_IM		0x040
<span class="p_header">diff --git a/arch/arc/mm/cache.c b/arch/arc/mm/cache.c</span>
<span class="p_header">index 8147583c4434..bbdfeb31dee6 100644</span>
<span class="p_header">--- a/arch/arc/mm/cache.c</span>
<span class="p_header">+++ b/arch/arc/mm/cache.c</span>
<span class="p_chunk">@@ -562,6 +562,7 @@</span> <span class="p_context"> noinline void slc_op(phys_addr_t paddr, unsigned long sz, const int op)</span>
 	static DEFINE_SPINLOCK(lock);
 	unsigned long flags;
 	unsigned int ctrl;
<span class="p_add">+	phys_addr_t end;</span>
 
 	spin_lock_irqsave(&amp;lock, flags);
 
<span class="p_chunk">@@ -591,8 +592,16 @@</span> <span class="p_context"> noinline void slc_op(phys_addr_t paddr, unsigned long sz, const int op)</span>
 	 * END needs to be setup before START (latter triggers the operation)
 	 * END can&#39;t be same as START, so add (l2_line_sz - 1) to sz
 	 */
<span class="p_del">-	write_aux_reg(ARC_REG_SLC_RGN_END, (paddr + sz + l2_line_sz - 1));</span>
<span class="p_del">-	write_aux_reg(ARC_REG_SLC_RGN_START, paddr);</span>
<span class="p_add">+	end = paddr + sz + l2_line_sz - 1;</span>
<span class="p_add">+	if (is_pae40_enabled())</span>
<span class="p_add">+		write_aux_reg(ARC_REG_SLC_RGN_END1, upper_32_bits(end));</span>
<span class="p_add">+</span>
<span class="p_add">+	write_aux_reg(ARC_REG_SLC_RGN_END, lower_32_bits(end));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_pae40_enabled())</span>
<span class="p_add">+		write_aux_reg(ARC_REG_SLC_RGN_START1, upper_32_bits(paddr));</span>
<span class="p_add">+</span>
<span class="p_add">+	write_aux_reg(ARC_REG_SLC_RGN_START, lower_32_bits(paddr));</span>
 
 	while (read_aux_reg(ARC_REG_SLC_CTRL) &amp; SLC_CTRL_BUSY);
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/mmu_context.h b/arch/powerpc/include/asm/mmu_context.h</span>
<span class="p_header">index 0012f0353fd6..fe208b70b8b1 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -75,9 +75,27 @@</span> <span class="p_context"> static inline void switch_mm_irqs_off(struct mm_struct *prev,</span>
 				      struct task_struct *tsk)
 {
 	/* Mark this context has been used on the new CPU */
<span class="p_del">-	if (!cpumask_test_cpu(smp_processor_id(), mm_cpumask(next)))</span>
<span class="p_add">+	if (!cpumask_test_cpu(smp_processor_id(), mm_cpumask(next))) {</span>
 		cpumask_set_cpu(smp_processor_id(), mm_cpumask(next));
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This full barrier orders the store to the cpumask above vs</span>
<span class="p_add">+		 * a subsequent operation which allows this CPU to begin loading</span>
<span class="p_add">+		 * translations for next.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * When using the radix MMU that operation is the load of the</span>
<span class="p_add">+		 * MMU context id, which is then moved to SPRN_PID.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * For the hash MMU it is either the first load from slb_cache</span>
<span class="p_add">+		 * in switch_slb(), and/or the store of paca-&gt;mm_ctx_id in</span>
<span class="p_add">+		 * copy_mm_to_paca().</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * On the read side the barrier is in pte_xchg(), which orders</span>
<span class="p_add">+		 * the store to the PTE vs the load of mm_cpumask.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* 32-bit keeps track of the current PGDIR in the thread struct */
 #ifdef CONFIG_PPC32
 	tsk-&gt;thread.pgdir = next-&gt;pgd;
<span class="p_header">diff --git a/arch/powerpc/include/asm/pgtable-be-types.h b/arch/powerpc/include/asm/pgtable-be-types.h</span>
<span class="p_header">index 49c0a5a80efa..68e087e807f8 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/pgtable-be-types.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/pgtable-be-types.h</span>
<span class="p_chunk">@@ -87,6 +87,7 @@</span> <span class="p_context"> static inline bool pte_xchg(pte_t *ptep, pte_t old, pte_t new)</span>
 	unsigned long *p = (unsigned long *)ptep;
 	__be64 prev;
 
<span class="p_add">+	/* See comment in switch_mm_irqs_off() */</span>
 	prev = (__force __be64)__cmpxchg_u64(p, (__force unsigned long)pte_raw(old),
 					     (__force unsigned long)pte_raw(new));
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/pgtable-types.h b/arch/powerpc/include/asm/pgtable-types.h</span>
<span class="p_header">index e7f4f3e0fcde..41e9d0a6cbeb 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/pgtable-types.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/pgtable-types.h</span>
<span class="p_chunk">@@ -62,6 +62,7 @@</span> <span class="p_context"> static inline bool pte_xchg(pte_t *ptep, pte_t old, pte_t new)</span>
 {
 	unsigned long *p = (unsigned long *)ptep;
 
<span class="p_add">+	/* See comment in switch_mm_irqs_off() */</span>
 	return pte_val(old) == __cmpxchg_u64(p, pte_val(old), pte_val(new));
 }
 #endif
<span class="p_header">diff --git a/arch/s390/kvm/sthyi.c b/arch/s390/kvm/sthyi.c</span>
<span class="p_header">index 05c98bb853cf..2f04ad1ea01c 100644</span>
<span class="p_header">--- a/arch/s390/kvm/sthyi.c</span>
<span class="p_header">+++ b/arch/s390/kvm/sthyi.c</span>
<span class="p_chunk">@@ -394,7 +394,7 @@</span> <span class="p_context"> static int sthyi(u64 vaddr)</span>
 		&quot;srl     %[cc],28\n&quot;
 		: [cc] &quot;=d&quot; (cc)
 		: [code] &quot;d&quot; (code), [addr] &quot;a&quot; (addr)
<span class="p_del">-		: &quot;memory&quot;, &quot;cc&quot;);</span>
<span class="p_add">+		: &quot;3&quot;, &quot;memory&quot;, &quot;cc&quot;);</span>
 	return cc;
 }
 
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> int handle_sthyi(struct kvm_vcpu *vcpu)</span>
 	VCPU_EVENT(vcpu, 3, &quot;STHYI: fc: %llu addr: 0x%016llx&quot;, code, addr);
 	trace_kvm_s390_handle_sthyi(vcpu, code, addr);
 
<span class="p_del">-	if (reg1 == reg2 || reg1 &amp; 1 || reg2 &amp; 1 || addr &amp; ~PAGE_MASK)</span>
<span class="p_add">+	if (reg1 == reg2 || reg1 &amp; 1 || reg2 &amp; 1)</span>
 		return kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);
 
 	if (code &amp; 0xffff) {
<span class="p_chunk">@@ -430,6 +430,9 @@</span> <span class="p_context"> int handle_sthyi(struct kvm_vcpu *vcpu)</span>
 		goto out;
 	}
 
<span class="p_add">+	if (addr &amp; ~PAGE_MASK)</span>
<span class="p_add">+		return kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);</span>
<span class="p_add">+</span>
 	/*
 	 * If the page has not yet been faulted in, we want to do that
 	 * now and not after all the expensive calculations.
<span class="p_header">diff --git a/arch/sparc/kernel/pci_sun4v.c b/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_header">index 06981cc716b6..d04111a5c615 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_chunk">@@ -1240,8 +1240,6 @@</span> <span class="p_context"> static int pci_sun4v_probe(struct platform_device *op)</span>
 			 * ATU group, but ATU hcalls won&#39;t be available.
 			 */
 			hv_atu = false;
<span class="p_del">-			pr_err(PFX &quot;Could not register hvapi ATU err=%d\n&quot;,</span>
<span class="p_del">-			       err);</span>
 		} else {
 			pr_info(PFX &quot;Registered hvapi ATU major[%lu] minor[%lu]\n&quot;,
 				vatu_major, vatu_minor);
<span class="p_header">diff --git a/arch/x86/events/intel/rapl.c b/arch/x86/events/intel/rapl.c</span>
<span class="p_header">index 970c1de3b86e..4c1b7ea18541 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/rapl.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/rapl.c</span>
<span class="p_chunk">@@ -161,7 +161,13 @@</span> <span class="p_context"> static u64 rapl_timer_ms;</span>
 
 static inline struct rapl_pmu *cpu_to_rapl_pmu(unsigned int cpu)
 {
<span class="p_del">-	return rapl_pmus-&gt;pmus[topology_logical_package_id(cpu)];</span>
<span class="p_add">+	unsigned int pkgid = topology_logical_package_id(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The unsigned check also catches the &#39;-1&#39; return value for non</span>
<span class="p_add">+	 * existent mappings in the topology map.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return pkgid &lt; rapl_pmus-&gt;maxpkg ? rapl_pmus-&gt;pmus[pkgid] : NULL;</span>
 }
 
 static inline u64 rapl_read_counter(struct perf_event *event)
<span class="p_chunk">@@ -402,6 +408,8 @@</span> <span class="p_context"> static int rapl_pmu_event_init(struct perf_event *event)</span>
 
 	/* must be done before validate_group */
 	pmu = cpu_to_rapl_pmu(event-&gt;cpu);
<span class="p_add">+	if (!pmu)</span>
<span class="p_add">+		return -EINVAL;</span>
 	event-&gt;cpu = pmu-&gt;cpu;
 	event-&gt;pmu_private = pmu;
 	event-&gt;hw.event_base = msr;
<span class="p_chunk">@@ -585,6 +593,19 @@</span> <span class="p_context"> static int rapl_cpu_online(unsigned int cpu)</span>
 	struct rapl_pmu *pmu = cpu_to_rapl_pmu(cpu);
 	int target;
 
<span class="p_add">+	if (!pmu) {</span>
<span class="p_add">+		pmu = kzalloc_node(sizeof(*pmu), GFP_KERNEL, cpu_to_node(cpu));</span>
<span class="p_add">+		if (!pmu)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		raw_spin_lock_init(&amp;pmu-&gt;lock);</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;pmu-&gt;active_list);</span>
<span class="p_add">+		pmu-&gt;pmu = &amp;rapl_pmus-&gt;pmu;</span>
<span class="p_add">+		pmu-&gt;timer_interval = ms_to_ktime(rapl_timer_ms);</span>
<span class="p_add">+		rapl_hrtimer_init(pmu);</span>
<span class="p_add">+</span>
<span class="p_add">+		rapl_pmus-&gt;pmus[topology_logical_package_id(cpu)] = pmu;</span>
<span class="p_add">+	}</span>
 	/*
 	 * Check if there is an online cpu in the package which collects rapl
 	 * events already.
<span class="p_chunk">@@ -598,27 +619,6 @@</span> <span class="p_context"> static int rapl_cpu_online(unsigned int cpu)</span>
 	return 0;
 }
 
<span class="p_del">-static int rapl_cpu_prepare(unsigned int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rapl_pmu *pmu = cpu_to_rapl_pmu(cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pmu)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	pmu = kzalloc_node(sizeof(*pmu), GFP_KERNEL, cpu_to_node(cpu));</span>
<span class="p_del">-	if (!pmu)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	raw_spin_lock_init(&amp;pmu-&gt;lock);</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;pmu-&gt;active_list);</span>
<span class="p_del">-	pmu-&gt;pmu = &amp;rapl_pmus-&gt;pmu;</span>
<span class="p_del">-	pmu-&gt;timer_interval = ms_to_ktime(rapl_timer_ms);</span>
<span class="p_del">-	pmu-&gt;cpu = -1;</span>
<span class="p_del">-	rapl_hrtimer_init(pmu);</span>
<span class="p_del">-	rapl_pmus-&gt;pmus[topology_logical_package_id(cpu)] = pmu;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int rapl_check_hw_unit(bool apply_quirk)
 {
 	u64 msr_rapl_power_unit_bits;
<span class="p_chunk">@@ -804,28 +804,21 @@</span> <span class="p_context"> static int __init rapl_pmu_init(void)</span>
 	 * Install callbacks. Core will call them for each online cpu.
 	 */
 
<span class="p_del">-	ret = cpuhp_setup_state(CPUHP_PERF_X86_RAPL_PREP, &quot;PERF_X86_RAPL_PREP&quot;,</span>
<span class="p_del">-				rapl_cpu_prepare, NULL);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	ret = cpuhp_setup_state(CPUHP_AP_PERF_X86_RAPL_ONLINE,
 				&quot;AP_PERF_X86_RAPL_ONLINE&quot;,
 				rapl_cpu_online, rapl_cpu_offline);
 	if (ret)
<span class="p_del">-		goto out1;</span>
<span class="p_add">+		goto out;</span>
 
 	ret = perf_pmu_register(&amp;rapl_pmus-&gt;pmu, &quot;power&quot;, -1);
 	if (ret)
<span class="p_del">-		goto out2;</span>
<span class="p_add">+		goto out1;</span>
 
 	rapl_advertise();
 	return 0;
 
<span class="p_del">-out2:</span>
<span class="p_del">-	cpuhp_remove_state(CPUHP_AP_PERF_X86_RAPL_ONLINE);</span>
 out1:
<span class="p_del">-	cpuhp_remove_state(CPUHP_PERF_X86_RAPL_PREP);</span>
<span class="p_add">+	cpuhp_remove_state(CPUHP_AP_PERF_X86_RAPL_ONLINE);</span>
 out:
 	pr_warn(&quot;Initialization failed (%d), disabled\n&quot;, ret);
 	cleanup_rapl_pmus();
<span class="p_chunk">@@ -836,7 +829,6 @@</span> <span class="p_context"> module_init(rapl_pmu_init);</span>
 static void __exit intel_rapl_exit(void)
 {
 	cpuhp_remove_state_nocalls(CPUHP_AP_PERF_X86_RAPL_ONLINE);
<span class="p_del">-	cpuhp_remove_state_nocalls(CPUHP_PERF_X86_RAPL_PREP);</span>
 	perf_pmu_unregister(&amp;rapl_pmus-&gt;pmu);
 	cleanup_rapl_pmus();
 }
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index 8e0a9fe86de4..f9dd22469388 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -116,9 +116,7 @@</span> <span class="p_context"> static inline int init_new_context(struct task_struct *tsk,</span>
 		mm-&gt;context.execute_only_pkey = -1;
 	}
 	#endif
<span class="p_del">-	init_new_context_ldt(tsk, mm);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return init_new_context_ldt(tsk, mm);</span>
 }
 static inline void destroy_context(struct mm_struct *mm)
 {
<span class="p_header">diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c</span>
<span class="p_header">index 649d8f2c1e40..91af75e37306 100644</span>
<span class="p_header">--- a/arch/x86/kvm/cpuid.c</span>
<span class="p_header">+++ b/arch/x86/kvm/cpuid.c</span>
<span class="p_chunk">@@ -456,7 +456,7 @@</span> <span class="p_context"> static inline int __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,</span>
 			entry-&gt;ecx &amp;= kvm_cpuid_7_0_ecx_x86_features;
 			cpuid_mask(&amp;entry-&gt;ecx, CPUID_7_ECX);
 			/* PKU is not yet implemented for shadow paging. */
<span class="p_del">-			if (!tdp_enabled)</span>
<span class="p_add">+			if (!tdp_enabled || !boot_cpu_has(X86_FEATURE_OSPKE))</span>
 				entry-&gt;ecx &amp;= ~F(PKU);
 		} else {
 			entry-&gt;ebx = 0;
<span class="p_header">diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c</span>
<span class="p_header">index e53bef6cf53c..0375c6024062 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/ghes.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/ghes.c</span>
<span class="p_chunk">@@ -1072,6 +1072,7 @@</span> <span class="p_context"> static int ghes_remove(struct platform_device *ghes_dev)</span>
 		if (list_empty(&amp;ghes_sci))
 			unregister_acpi_hed_notifier(&amp;ghes_notifier_sci);
 		mutex_unlock(&amp;ghes_list_mutex);
<span class="p_add">+		synchronize_rcu();</span>
 		break;
 	case ACPI_HEST_NOTIFY_NMI:
 		ghes_nmi_remove(ghes);
<span class="p_header">diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c</span>
<span class="p_header">index 79152dbc5528..51874695a730 100644</span>
<span class="p_header">--- a/drivers/acpi/ec.c</span>
<span class="p_header">+++ b/drivers/acpi/ec.c</span>
<span class="p_chunk">@@ -1728,7 +1728,7 @@</span> <span class="p_context"> int __init acpi_ec_dsdt_probe(void)</span>
  * functioning ECDT EC first in order to handle the events.
  * https://bugzilla.kernel.org/show_bug.cgi?id=115021
  */
<span class="p_del">-int __init acpi_ec_ecdt_start(void)</span>
<span class="p_add">+static int __init acpi_ec_ecdt_start(void)</span>
 {
 	acpi_handle handle;
 
<span class="p_chunk">@@ -1959,20 +1959,17 @@</span> <span class="p_context"> static inline void acpi_ec_query_exit(void)</span>
 int __init acpi_ec_init(void)
 {
 	int result;
<span class="p_add">+	int ecdt_fail, dsdt_fail;</span>
 
 	/* register workqueue for _Qxx evaluations */
 	result = acpi_ec_query_init();
 	if (result)
<span class="p_del">-		goto err_exit;</span>
<span class="p_del">-	/* Now register the driver for the EC */</span>
<span class="p_del">-	result = acpi_bus_register_driver(&amp;acpi_ec_driver);</span>
<span class="p_del">-	if (result)</span>
<span class="p_del">-		goto err_exit;</span>
<span class="p_add">+		return result;</span>
 
<span class="p_del">-err_exit:</span>
<span class="p_del">-	if (result)</span>
<span class="p_del">-		acpi_ec_query_exit();</span>
<span class="p_del">-	return result;</span>
<span class="p_add">+	/* Drivers must be started after acpi_ec_query_init() */</span>
<span class="p_add">+	ecdt_fail = acpi_ec_ecdt_start();</span>
<span class="p_add">+	dsdt_fail = acpi_bus_register_driver(&amp;acpi_ec_driver);</span>
<span class="p_add">+	return ecdt_fail &amp;&amp; dsdt_fail ? -ENODEV : 0;</span>
 }
 
 /* EC driver currently not unloadable */
<span class="p_header">diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h</span>
<span class="p_header">index 219b90bc0922..08b3ca0ead69 100644</span>
<span class="p_header">--- a/drivers/acpi/internal.h</span>
<span class="p_header">+++ b/drivers/acpi/internal.h</span>
<span class="p_chunk">@@ -185,7 +185,6 @@</span> <span class="p_context"> typedef int (*acpi_ec_query_func) (void *data);</span>
 int acpi_ec_init(void);
 int acpi_ec_ecdt_probe(void);
 int acpi_ec_dsdt_probe(void);
<span class="p_del">-int acpi_ec_ecdt_start(void);</span>
 void acpi_ec_block_transactions(void);
 void acpi_ec_unblock_transactions(void);
 int acpi_ec_add_query_handler(struct acpi_ec *ec, u8 query_bit,
<span class="p_header">diff --git a/drivers/acpi/ioapic.c b/drivers/acpi/ioapic.c</span>
<span class="p_header">index 6d7ce6e12aaa..5e18ccf5ab57 100644</span>
<span class="p_header">--- a/drivers/acpi/ioapic.c</span>
<span class="p_header">+++ b/drivers/acpi/ioapic.c</span>
<span class="p_chunk">@@ -45,6 +45,12 @@</span> <span class="p_context"> static acpi_status setup_res(struct acpi_resource *acpi_res, void *data)</span>
 	struct resource *res = data;
 	struct resource_win win;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We might assign this to &#39;res&#39; later, make sure all pointers are</span>
<span class="p_add">+	 * cleared before the resource is added to the global list</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memset(&amp;win, 0, sizeof(win));</span>
<span class="p_add">+</span>
 	res-&gt;flags = 0;
 	if (acpi_dev_filter_resource_type(acpi_res, IORESOURCE_MEM))
 		return AE_OK;
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index dd3786acba89..cf725d581cae 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -2051,7 +2051,6 @@</span> <span class="p_context"> int __init acpi_scan_init(void)</span>
 
 	acpi_gpe_apply_masked_gpes();
 	acpi_update_all_gpes();
<span class="p_del">-	acpi_ec_ecdt_start();</span>
 
 	acpi_scan_initialized = true;
 
<span class="p_header">diff --git a/drivers/android/binder.c b/drivers/android/binder.c</span>
<span class="p_header">index 3c71b982bf2a..15009b2b33c7 100644</span>
<span class="p_header">--- a/drivers/android/binder.c</span>
<span class="p_header">+++ b/drivers/android/binder.c</span>
<span class="p_chunk">@@ -1724,8 +1724,12 @@</span> <span class="p_context"> static void binder_transaction(struct binder_proc *proc,</span>
 	list_add_tail(&amp;t-&gt;work.entry, target_list);
 	tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
 	list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
<span class="p_del">-	if (target_wait)</span>
<span class="p_del">-		wake_up_interruptible(target_wait);</span>
<span class="p_add">+	if (target_wait) {</span>
<span class="p_add">+		if (reply || !(t-&gt;flags &amp; TF_ONE_WAY))</span>
<span class="p_add">+			wake_up_interruptible_sync(target_wait);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			wake_up_interruptible(target_wait);</span>
<span class="p_add">+	}</span>
 	return;
 
 err_get_unused_fd_failed:
<span class="p_chunk">@@ -2760,10 +2764,6 @@</span> <span class="p_context"> static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span>
 	/*pr_info(&quot;binder_ioctl: %d:%d %x %lx\n&quot;,
 			proc-&gt;pid, current-&gt;pid, cmd, arg);*/
 
<span class="p_del">-	if (unlikely(current-&gt;mm != proc-&gt;vma_vm_mm)) {</span>
<span class="p_del">-		pr_err(&quot;current mm mismatch proc mm\n&quot;);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
 	trace_binder_ioctl(cmd, arg);
 
 	ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
<span class="p_chunk">@@ -2875,7 +2875,7 @@</span> <span class="p_context"> static int binder_mmap(struct file *filp, struct vm_area_struct *vma)</span>
 	const char *failure_string;
 	struct binder_buffer *buffer;
 
<span class="p_del">-	if (proc-&gt;tsk != current)</span>
<span class="p_add">+	if (proc-&gt;tsk != current-&gt;group_leader)</span>
 		return -EINVAL;
 
 	if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)
<span class="p_chunk">@@ -2976,9 +2976,8 @@</span> <span class="p_context"> static int binder_open(struct inode *nodp, struct file *filp)</span>
 	proc = kzalloc(sizeof(*proc), GFP_KERNEL);
 	if (proc == NULL)
 		return -ENOMEM;
<span class="p_del">-	get_task_struct(current);</span>
<span class="p_del">-	proc-&gt;tsk = current;</span>
<span class="p_del">-	proc-&gt;vma_vm_mm = current-&gt;mm;</span>
<span class="p_add">+	get_task_struct(current-&gt;group_leader);</span>
<span class="p_add">+	proc-&gt;tsk = current-&gt;group_leader;</span>
 	INIT_LIST_HEAD(&amp;proc-&gt;todo);
 	init_waitqueue_head(&amp;proc-&gt;wait);
 	proc-&gt;default_priority = task_nice(current);
<span class="p_header">diff --git a/drivers/gpu/drm/drm_atomic.c b/drivers/gpu/drm/drm_atomic.c</span>
<span class="p_header">index 4e19bde4bbff..34adde169a78 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_atomic.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_atomic.c</span>
<span class="p_chunk">@@ -1386,6 +1386,9 @@</span> <span class="p_context"> int drm_atomic_check_only(struct drm_atomic_state *state)</span>
 	if (config-&gt;funcs-&gt;atomic_check)
 		ret = config-&gt;funcs-&gt;atomic_check(state-&gt;dev, state);
 
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	if (!state-&gt;allow_modeset) {
 		for_each_crtc_in_state(state, crtc, crtc_state, i) {
 			if (drm_atomic_crtc_needs_modeset(crtc_state)) {
<span class="p_chunk">@@ -1396,7 +1399,7 @@</span> <span class="p_context"> int drm_atomic_check_only(struct drm_atomic_state *state)</span>
 		}
 	}
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 EXPORT_SYMBOL(drm_atomic_check_only);
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_gem.c b/drivers/gpu/drm/drm_gem.c</span>
<span class="p_header">index 465bacd0a630..48e99ab525c3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_gem.c</span>
<span class="p_chunk">@@ -255,13 +255,13 @@</span> <span class="p_context"> drm_gem_object_release_handle(int id, void *ptr, void *data)</span>
 	struct drm_gem_object *obj = ptr;
 	struct drm_device *dev = obj-&gt;dev;
 
<span class="p_add">+	if (dev-&gt;driver-&gt;gem_close_object)</span>
<span class="p_add">+		dev-&gt;driver-&gt;gem_close_object(obj, file_priv);</span>
<span class="p_add">+</span>
 	if (drm_core_check_feature(dev, DRIVER_PRIME))
 		drm_gem_remove_prime_handles(obj, file_priv);
 	drm_vma_node_revoke(&amp;obj-&gt;vma_node, file_priv);
 
<span class="p_del">-	if (dev-&gt;driver-&gt;gem_close_object)</span>
<span class="p_del">-		dev-&gt;driver-&gt;gem_close_object(obj, file_priv);</span>
<span class="p_del">-</span>
 	drm_gem_object_handle_unreference_unlocked(obj);
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c</span>
<span class="p_header">index 7316fc7fa0bd..a2ec6d8796a0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c</span>
<span class="p_chunk">@@ -149,8 +149,8 @@</span> <span class="p_context"> static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)</span>
 	rcar_du_group_write(rcrtc-&gt;group, rcrtc-&gt;index % 2 ? OTAR2 : OTAR, 0);
 
 	/* Signal polarities */
<span class="p_del">-	value = ((mode-&gt;flags &amp; DRM_MODE_FLAG_PVSYNC) ? 0 : DSMR_VSL)</span>
<span class="p_del">-	      | ((mode-&gt;flags &amp; DRM_MODE_FLAG_PHSYNC) ? 0 : DSMR_HSL)</span>
<span class="p_add">+	value = ((mode-&gt;flags &amp; DRM_MODE_FLAG_PVSYNC) ? DSMR_VSL : 0)</span>
<span class="p_add">+	      | ((mode-&gt;flags &amp; DRM_MODE_FLAG_PHSYNC) ? DSMR_HSL : 0)</span>
 	      | DSMR_DIPM_DISP | DSMR_CSPM;
 	rcar_du_crtc_write(rcrtc, DSMR, value);
 
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)</span>
 					mode-&gt;crtc_vsync_start - 1);
 	rcar_du_crtc_write(rcrtc, VCR,  mode-&gt;crtc_vtotal - 1);
 
<span class="p_del">-	rcar_du_crtc_write(rcrtc, DESR,  mode-&gt;htotal - mode-&gt;hsync_start);</span>
<span class="p_add">+	rcar_du_crtc_write(rcrtc, DESR,  mode-&gt;htotal - mode-&gt;hsync_start - 1);</span>
 	rcar_du_crtc_write(rcrtc, DEWR,  mode-&gt;hdisplay);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/rcar-du/rcar_du_kms.c b/drivers/gpu/drm/rcar-du/rcar_du_kms.c</span>
<span class="p_header">index cfc302c65b0b..c58602b638e4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/rcar-du/rcar_du_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/rcar-du/rcar_du_kms.c</span>
<span class="p_chunk">@@ -453,13 +453,13 @@</span> <span class="p_context"> static int rcar_du_encoders_init_one(struct rcar_du_device *rcdu,</span>
 	}
 
 	ret = rcar_du_encoder_init(rcdu, enc_type, output, encoder, connector);
<span class="p_del">-	of_node_put(encoder);</span>
<span class="p_del">-	of_node_put(connector);</span>
<span class="p_del">-</span>
 	if (ret &amp;&amp; ret != -EPROBE_DEFER)
 		dev_warn(rcdu-&gt;dev,
<span class="p_del">-			 &quot;failed to initialize encoder %s (%d), skipping\n&quot;,</span>
<span class="p_del">-			 encoder-&gt;full_name, ret);</span>
<span class="p_add">+			 &quot;failed to initialize encoder %s on output %u (%d), skipping\n&quot;,</span>
<span class="p_add">+			 of_node_full_name(encoder), output, ret);</span>
<span class="p_add">+</span>
<span class="p_add">+	of_node_put(encoder);</span>
<span class="p_add">+	of_node_put(connector);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c</span>
<span class="p_header">index 0b42a12171f3..b42d95f09c68 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-designware-platdrv.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-designware-platdrv.c</span>
<span class="p_chunk">@@ -319,7 +319,7 @@</span> <span class="p_context"> static void dw_i2c_plat_complete(struct device *dev)</span>
 #endif
 
 #ifdef CONFIG_PM
<span class="p_del">-static int dw_i2c_plat_suspend(struct device *dev)</span>
<span class="p_add">+static int dw_i2c_plat_runtime_suspend(struct device *dev)</span>
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
<span class="p_chunk">@@ -343,11 +343,21 @@</span> <span class="p_context"> static int dw_i2c_plat_resume(struct device *dev)</span>
 	return 0;
 }
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+static int dw_i2c_plat_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pm_runtime_resume(dev);</span>
<span class="p_add">+	return dw_i2c_plat_runtime_suspend(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static const struct dev_pm_ops dw_i2c_dev_pm_ops = {
 	.prepare = dw_i2c_plat_prepare,
 	.complete = dw_i2c_plat_complete,
 	SET_SYSTEM_SLEEP_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume)
<span class="p_del">-	SET_RUNTIME_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume, NULL)</span>
<span class="p_add">+	SET_RUNTIME_PM_OPS(dw_i2c_plat_runtime_suspend,</span>
<span class="p_add">+			   dw_i2c_plat_resume,</span>
<span class="p_add">+			   NULL)</span>
 };
 
 #define DW_I2C_DEV_PMOPS (&amp;dw_i2c_dev_pm_ops)
<span class="p_header">diff --git a/drivers/iio/common/hid-sensors/hid-sensor-trigger.c b/drivers/iio/common/hid-sensors/hid-sensor-trigger.c</span>
<span class="p_header">index 60829340a82e..b60e5d87c257 100644</span>
<span class="p_header">--- a/drivers/iio/common/hid-sensors/hid-sensor-trigger.c</span>
<span class="p_header">+++ b/drivers/iio/common/hid-sensors/hid-sensor-trigger.c</span>
<span class="p_chunk">@@ -36,8 +36,6 @@</span> <span class="p_context"> static int _hid_sensor_power_state(struct hid_sensor_common *st, bool state)</span>
 	s32 poll_value = 0;
 
 	if (state) {
<span class="p_del">-		if (!atomic_read(&amp;st-&gt;user_requested_state))</span>
<span class="p_del">-			return 0;</span>
 		if (sensor_hub_device_open(st-&gt;hsdev))
 			return -EIO;
 
<span class="p_chunk">@@ -86,6 +84,9 @@</span> <span class="p_context"> static int _hid_sensor_power_state(struct hid_sensor_common *st, bool state)</span>
 				       &amp;report_val);
 	}
 
<span class="p_add">+	pr_debug(&quot;HID_SENSOR %s set power_state %d report_state %d\n&quot;,</span>
<span class="p_add">+		 st-&gt;pdev-&gt;name, state_val, report_val);</span>
<span class="p_add">+</span>
 	sensor_hub_get_feature(st-&gt;hsdev, st-&gt;power_state.report_id,
 			       st-&gt;power_state.index,
 			       sizeof(state_val), &amp;state_val);
<span class="p_chunk">@@ -107,6 +108,7 @@</span> <span class="p_context"> int hid_sensor_power_state(struct hid_sensor_common *st, bool state)</span>
 		ret = pm_runtime_get_sync(&amp;st-&gt;pdev-&gt;dev);
 	else {
 		pm_runtime_mark_last_busy(&amp;st-&gt;pdev-&gt;dev);
<span class="p_add">+		pm_runtime_use_autosuspend(&amp;st-&gt;pdev-&gt;dev);</span>
 		ret = pm_runtime_put_autosuspend(&amp;st-&gt;pdev-&gt;dev);
 	}
 	if (ret &lt; 0) {
<span class="p_chunk">@@ -201,8 +203,6 @@</span> <span class="p_context"> int hid_sensor_setup_trigger(struct iio_dev *indio_dev, const char *name,</span>
 	/* Default to 3 seconds, but can be changed from sysfs */
 	pm_runtime_set_autosuspend_delay(&amp;attrb-&gt;pdev-&gt;dev,
 					 3000);
<span class="p_del">-	pm_runtime_use_autosuspend(&amp;attrb-&gt;pdev-&gt;dev);</span>
<span class="p_del">-</span>
 	return ret;
 error_unreg_trigger:
 	iio_trigger_unregister(trig);
<span class="p_header">diff --git a/drivers/iio/imu/adis16480.c b/drivers/iio/imu/adis16480.c</span>
<span class="p_header">index 8cf84d3488b2..12898424d838 100644</span>
<span class="p_header">--- a/drivers/iio/imu/adis16480.c</span>
<span class="p_header">+++ b/drivers/iio/imu/adis16480.c</span>
<span class="p_chunk">@@ -696,7 +696,7 @@</span> <span class="p_context"> static const struct adis16480_chip_info adis16480_chip_info[] = {</span>
 		.gyro_max_val = IIO_RAD_TO_DEGREE(22500),
 		.gyro_max_scale = 450,
 		.accel_max_val = IIO_M_S_2_TO_G(12500),
<span class="p_del">-		.accel_max_scale = 5,</span>
<span class="p_add">+		.accel_max_scale = 10,</span>
 	},
 	[ADIS16485] = {
 		.channels = adis16485_channels,
<span class="p_header">diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c</span>
<span class="p_header">index 518e8a7bd5f9..f26807c75be4 100644</span>
<span class="p_header">--- a/drivers/input/mouse/alps.c</span>
<span class="p_header">+++ b/drivers/input/mouse/alps.c</span>
<span class="p_chunk">@@ -1212,14 +1212,24 @@</span> <span class="p_context"> static int alps_decode_ss4_v2(struct alps_fields *f,</span>
 
 	case SS4_PACKET_ID_TWO:
 		if (priv-&gt;flags &amp; ALPS_BUTTONPAD) {
<span class="p_del">-			f-&gt;mt[0].x = SS4_BTL_MF_X_V2(p, 0);</span>
<span class="p_add">+			if (IS_SS4PLUS_DEV(priv-&gt;dev_id)) {</span>
<span class="p_add">+				f-&gt;mt[0].x = SS4_PLUS_BTL_MF_X_V2(p, 0);</span>
<span class="p_add">+				f-&gt;mt[1].x = SS4_PLUS_BTL_MF_X_V2(p, 1);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				f-&gt;mt[0].x = SS4_BTL_MF_X_V2(p, 0);</span>
<span class="p_add">+				f-&gt;mt[1].x = SS4_BTL_MF_X_V2(p, 1);</span>
<span class="p_add">+			}</span>
 			f-&gt;mt[0].y = SS4_BTL_MF_Y_V2(p, 0);
<span class="p_del">-			f-&gt;mt[1].x = SS4_BTL_MF_X_V2(p, 1);</span>
 			f-&gt;mt[1].y = SS4_BTL_MF_Y_V2(p, 1);
 		} else {
<span class="p_del">-			f-&gt;mt[0].x = SS4_STD_MF_X_V2(p, 0);</span>
<span class="p_add">+			if (IS_SS4PLUS_DEV(priv-&gt;dev_id)) {</span>
<span class="p_add">+				f-&gt;mt[0].x = SS4_PLUS_STD_MF_X_V2(p, 0);</span>
<span class="p_add">+				f-&gt;mt[1].x = SS4_PLUS_STD_MF_X_V2(p, 1);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				f-&gt;mt[0].x = SS4_STD_MF_X_V2(p, 0);</span>
<span class="p_add">+				f-&gt;mt[1].x = SS4_STD_MF_X_V2(p, 1);</span>
<span class="p_add">+			}</span>
 			f-&gt;mt[0].y = SS4_STD_MF_Y_V2(p, 0);
<span class="p_del">-			f-&gt;mt[1].x = SS4_STD_MF_X_V2(p, 1);</span>
 			f-&gt;mt[1].y = SS4_STD_MF_Y_V2(p, 1);
 		}
 		f-&gt;pressure = SS4_MF_Z_V2(p, 0) ? 0x30 : 0;
<span class="p_chunk">@@ -1236,16 +1246,27 @@</span> <span class="p_context"> static int alps_decode_ss4_v2(struct alps_fields *f,</span>
 
 	case SS4_PACKET_ID_MULTI:
 		if (priv-&gt;flags &amp; ALPS_BUTTONPAD) {
<span class="p_del">-			f-&gt;mt[2].x = SS4_BTL_MF_X_V2(p, 0);</span>
<span class="p_add">+			if (IS_SS4PLUS_DEV(priv-&gt;dev_id)) {</span>
<span class="p_add">+				f-&gt;mt[0].x = SS4_PLUS_BTL_MF_X_V2(p, 0);</span>
<span class="p_add">+				f-&gt;mt[1].x = SS4_PLUS_BTL_MF_X_V2(p, 1);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				f-&gt;mt[2].x = SS4_BTL_MF_X_V2(p, 0);</span>
<span class="p_add">+				f-&gt;mt[3].x = SS4_BTL_MF_X_V2(p, 1);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			f-&gt;mt[2].y = SS4_BTL_MF_Y_V2(p, 0);
<span class="p_del">-			f-&gt;mt[3].x = SS4_BTL_MF_X_V2(p, 1);</span>
 			f-&gt;mt[3].y = SS4_BTL_MF_Y_V2(p, 1);
 			no_data_x = SS4_MFPACKET_NO_AX_BL;
 			no_data_y = SS4_MFPACKET_NO_AY_BL;
 		} else {
<span class="p_del">-			f-&gt;mt[2].x = SS4_STD_MF_X_V2(p, 0);</span>
<span class="p_add">+			if (IS_SS4PLUS_DEV(priv-&gt;dev_id)) {</span>
<span class="p_add">+				f-&gt;mt[0].x = SS4_PLUS_STD_MF_X_V2(p, 0);</span>
<span class="p_add">+				f-&gt;mt[1].x = SS4_PLUS_STD_MF_X_V2(p, 1);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				f-&gt;mt[0].x = SS4_STD_MF_X_V2(p, 0);</span>
<span class="p_add">+				f-&gt;mt[1].x = SS4_STD_MF_X_V2(p, 1);</span>
<span class="p_add">+			}</span>
 			f-&gt;mt[2].y = SS4_STD_MF_Y_V2(p, 0);
<span class="p_del">-			f-&gt;mt[3].x = SS4_STD_MF_X_V2(p, 1);</span>
 			f-&gt;mt[3].y = SS4_STD_MF_Y_V2(p, 1);
 			no_data_x = SS4_MFPACKET_NO_AX;
 			no_data_y = SS4_MFPACKET_NO_AY;
<span class="p_chunk">@@ -2535,8 +2556,8 @@</span> <span class="p_context"> static int alps_set_defaults_ss4_v2(struct psmouse *psmouse,</span>
 
 	memset(otp, 0, sizeof(otp));
 
<span class="p_del">-	if (alps_get_otp_values_ss4_v2(psmouse, 0, &amp;otp[0][0]) ||</span>
<span class="p_del">-	    alps_get_otp_values_ss4_v2(psmouse, 1, &amp;otp[1][0]))</span>
<span class="p_add">+	if (alps_get_otp_values_ss4_v2(psmouse, 1, &amp;otp[1][0]) ||</span>
<span class="p_add">+	    alps_get_otp_values_ss4_v2(psmouse, 0, &amp;otp[0][0]))</span>
 		return -1;
 
 	alps_update_device_area_ss4_v2(otp, priv);
<span class="p_header">diff --git a/drivers/input/mouse/alps.h b/drivers/input/mouse/alps.h</span>
<span class="p_header">index dbfd26073e1a..793123717145 100644</span>
<span class="p_header">--- a/drivers/input/mouse/alps.h</span>
<span class="p_header">+++ b/drivers/input/mouse/alps.h</span>
<span class="p_chunk">@@ -91,6 +91,10 @@</span> <span class="p_context"> enum SS4_PACKET_ID {</span>
 				 ((_b[1 + _i * 3]  &lt;&lt; 5) &amp; 0x1F00)	\
 				)
 
<span class="p_add">+#define SS4_PLUS_STD_MF_X_V2(_b, _i) (((_b[0 + (_i) * 3] &lt;&lt; 4) &amp; 0x0070) | \</span>
<span class="p_add">+				 ((_b[1 + (_i) * 3]  &lt;&lt; 4) &amp; 0x0F80)	\</span>
<span class="p_add">+				)</span>
<span class="p_add">+</span>
 #define SS4_STD_MF_Y_V2(_b, _i)	(((_b[1 + (_i) * 3] &lt;&lt; 3) &amp; 0x0010) |	\
 				 ((_b[2 + (_i) * 3] &lt;&lt; 5) &amp; 0x01E0) |	\
 				 ((_b[2 + (_i) * 3] &lt;&lt; 4) &amp; 0x0E00)	\
<span class="p_chunk">@@ -100,6 +104,10 @@</span> <span class="p_context"> enum SS4_PACKET_ID {</span>
 				 ((_b[0 + (_i) * 3] &gt;&gt; 3) &amp; 0x0010)	\
 				)
 
<span class="p_add">+#define SS4_PLUS_BTL_MF_X_V2(_b, _i) (SS4_PLUS_STD_MF_X_V2(_b, _i) |	\</span>
<span class="p_add">+				 ((_b[0 + (_i) * 3] &gt;&gt; 4) &amp; 0x0008)	\</span>
<span class="p_add">+				)</span>
<span class="p_add">+</span>
 #define SS4_BTL_MF_Y_V2(_b, _i)	(SS4_STD_MF_Y_V2(_b, _i) | \
 				 ((_b[0 + (_i) * 3] &gt;&gt; 3) &amp; 0x0008)	\
 				)
<span class="p_header">diff --git a/drivers/input/mouse/elan_i2c_core.c b/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_header">index 98d4e515587a..681dce15fbc8 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_chunk">@@ -1234,6 +1234,7 @@</span> <span class="p_context"> static const struct acpi_device_id elan_acpi_id[] = {</span>
 	{ &quot;ELAN0000&quot;, 0 },
 	{ &quot;ELAN0100&quot;, 0 },
 	{ &quot;ELAN0600&quot;, 0 },
<span class="p_add">+	{ &quot;ELAN0602&quot;, 0 },</span>
 	{ &quot;ELAN0605&quot;, 0 },
 	{ &quot;ELAN0608&quot;, 0 },
 	{ &quot;ELAN0605&quot;, 0 },
<span class="p_header">diff --git a/drivers/input/mouse/trackpoint.c b/drivers/input/mouse/trackpoint.c</span>
<span class="p_header">index 354d47ecd66a..ce6ff9b301bb 100644</span>
<span class="p_header">--- a/drivers/input/mouse/trackpoint.c</span>
<span class="p_header">+++ b/drivers/input/mouse/trackpoint.c</span>
<span class="p_chunk">@@ -265,7 +265,8 @@</span> <span class="p_context"> static int trackpoint_start_protocol(struct psmouse *psmouse, unsigned char *fir</span>
 	if (ps2_command(&amp;psmouse-&gt;ps2dev, param, MAKE_PS2_CMD(0, 2, TP_READ_ID)))
 		return -1;
 
<span class="p_del">-	if (param[0] != TP_MAGIC_IDENT)</span>
<span class="p_add">+	/* add new TP ID. */</span>
<span class="p_add">+	if (!(param[0] &amp; TP_MAGIC_IDENT))</span>
 		return -1;
 
 	if (firmware_id)
<span class="p_header">diff --git a/drivers/input/mouse/trackpoint.h b/drivers/input/mouse/trackpoint.h</span>
<span class="p_header">index 5617ed3a7d7a..88055755f82e 100644</span>
<span class="p_header">--- a/drivers/input/mouse/trackpoint.h</span>
<span class="p_header">+++ b/drivers/input/mouse/trackpoint.h</span>
<span class="p_chunk">@@ -21,8 +21,9 @@</span> <span class="p_context"></span>
 #define TP_COMMAND		0xE2	/* Commands start with this */
 
 #define TP_READ_ID		0xE1	/* Sent for device identification */
<span class="p_del">-#define TP_MAGIC_IDENT		0x01	/* Sent after a TP_READ_ID followed */</span>
<span class="p_add">+#define TP_MAGIC_IDENT		0x03	/* Sent after a TP_READ_ID followed */</span>
 					/* by the firmware ID */
<span class="p_add">+					/* Firmware ID includes 0x1, 0x2, 0x3 */</span>
 
 
 /*
<span class="p_header">diff --git a/drivers/leds/trigger/ledtrig-heartbeat.c b/drivers/leds/trigger/ledtrig-heartbeat.c</span>
<span class="p_header">index c9f386213e9e..410c39c62dc7 100644</span>
<span class="p_header">--- a/drivers/leds/trigger/ledtrig-heartbeat.c</span>
<span class="p_header">+++ b/drivers/leds/trigger/ledtrig-heartbeat.c</span>
<span class="p_chunk">@@ -19,7 +19,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/leds.h&gt;
 #include &lt;linux/reboot.h&gt;
<span class="p_del">-#include &lt;linux/suspend.h&gt;</span>
 #include &quot;../leds.h&quot;
 
 static int panic_heartbeats;
<span class="p_chunk">@@ -155,30 +154,6 @@</span> <span class="p_context"> static struct led_trigger heartbeat_led_trigger = {</span>
 	.deactivate = heartbeat_trig_deactivate,
 };
 
<span class="p_del">-static int heartbeat_pm_notifier(struct notifier_block *nb,</span>
<span class="p_del">-				 unsigned long pm_event, void *unused)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (pm_event) {</span>
<span class="p_del">-	case PM_SUSPEND_PREPARE:</span>
<span class="p_del">-	case PM_HIBERNATION_PREPARE:</span>
<span class="p_del">-	case PM_RESTORE_PREPARE:</span>
<span class="p_del">-		led_trigger_unregister(&amp;heartbeat_led_trigger);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case PM_POST_SUSPEND:</span>
<span class="p_del">-	case PM_POST_HIBERNATION:</span>
<span class="p_del">-	case PM_POST_RESTORE:</span>
<span class="p_del">-		rc = led_trigger_register(&amp;heartbeat_led_trigger);</span>
<span class="p_del">-		if (rc)</span>
<span class="p_del">-			pr_err(&quot;could not re-register heartbeat trigger\n&quot;);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return NOTIFY_DONE;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int heartbeat_reboot_notifier(struct notifier_block *nb,
 				     unsigned long code, void *unused)
 {
<span class="p_chunk">@@ -193,10 +168,6 @@</span> <span class="p_context"> static int heartbeat_panic_notifier(struct notifier_block *nb,</span>
 	return NOTIFY_DONE;
 }
 
<span class="p_del">-static struct notifier_block heartbeat_pm_nb = {</span>
<span class="p_del">-	.notifier_call = heartbeat_pm_notifier,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static struct notifier_block heartbeat_reboot_nb = {
 	.notifier_call = heartbeat_reboot_notifier,
 };
<span class="p_chunk">@@ -213,14 +184,12 @@</span> <span class="p_context"> static int __init heartbeat_trig_init(void)</span>
 		atomic_notifier_chain_register(&amp;panic_notifier_list,
 					       &amp;heartbeat_panic_nb);
 		register_reboot_notifier(&amp;heartbeat_reboot_nb);
<span class="p_del">-		register_pm_notifier(&amp;heartbeat_pm_nb);</span>
 	}
 	return rc;
 }
 
 static void __exit heartbeat_trig_exit(void)
 {
<span class="p_del">-	unregister_pm_notifier(&amp;heartbeat_pm_nb);</span>
 	unregister_reboot_notifier(&amp;heartbeat_reboot_nb);
 	atomic_notifier_chain_unregister(&amp;panic_notifier_list,
 					 &amp;heartbeat_panic_nb);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">index 551786f58e59..ba652d8a2b93 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_chunk">@@ -430,7 +430,7 @@</span> <span class="p_context"> static int mlx4_dev_cap(struct mlx4_dev *dev, struct mlx4_dev_cap *dev_cap)</span>
 		/* Virtual PCI function needs to determine UAR page size from
 		 * firmware. Only master PCI function can set the uar page size
 		 */
<span class="p_del">-		if (enable_4k_uar)</span>
<span class="p_add">+		if (enable_4k_uar || !dev-&gt;persist-&gt;num_vfs)</span>
 			dev-&gt;uar_page_shift = DEFAULT_UAR_PAGE_SHIFT;
 		else
 			dev-&gt;uar_page_shift = PAGE_SHIFT;
<span class="p_chunk">@@ -2269,7 +2269,7 @@</span> <span class="p_context"> static int mlx4_init_hca(struct mlx4_dev *dev)</span>
 
 		dev-&gt;caps.max_fmr_maps = (1 &lt;&lt; (32 - ilog2(dev-&gt;caps.num_mpts))) - 1;
 
<span class="p_del">-		if (enable_4k_uar) {</span>
<span class="p_add">+		if (enable_4k_uar || !dev-&gt;persist-&gt;num_vfs) {</span>
 			init_hca.log_uar_sz = ilog2(dev-&gt;caps.num_uars) +
 						    PAGE_SHIFT - DEFAULT_UAR_PAGE_SHIFT;
 			init_hca.uar_page_sz = DEFAULT_UAR_PAGE_SHIFT - 12;
<span class="p_header">diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c</span>
<span class="p_header">index aee3fd2b6538..4ca82bd8c4f0 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c</span>
<span class="p_chunk">@@ -871,8 +871,7 @@</span> <span class="p_context"> static int nfp_net_tx(struct sk_buff *skb, struct net_device *netdev)</span>
 	return NETDEV_TX_OK;
 
 err_unmap:
<span class="p_del">-	--f;</span>
<span class="p_del">-	while (f &gt;= 0) {</span>
<span class="p_add">+	while (--f &gt;= 0) {</span>
 		frag = &amp;skb_shinfo(skb)-&gt;frags[f];
 		dma_unmap_page(&amp;nn-&gt;pdev-&gt;dev,
 			       tx_ring-&gt;txbufs[wr_idx].dma_addr,
<span class="p_header">diff --git a/drivers/ntb/ntb_transport.c b/drivers/ntb/ntb_transport.c</span>
<span class="p_header">index c234ee43b6ef..24222a5d8df2 100644</span>
<span class="p_header">--- a/drivers/ntb/ntb_transport.c</span>
<span class="p_header">+++ b/drivers/ntb/ntb_transport.c</span>
<span class="p_chunk">@@ -176,14 +176,12 @@</span> <span class="p_context"> struct ntb_transport_qp {</span>
 	u64 rx_err_ver;
 	u64 rx_memcpy;
 	u64 rx_async;
<span class="p_del">-	u64 dma_rx_prep_err;</span>
 	u64 tx_bytes;
 	u64 tx_pkts;
 	u64 tx_ring_full;
 	u64 tx_err_no_buf;
 	u64 tx_memcpy;
 	u64 tx_async;
<span class="p_del">-	u64 dma_tx_prep_err;</span>
 };
 
 struct ntb_transport_mw {
<span class="p_chunk">@@ -256,8 +254,6 @@</span> <span class="p_context"> enum {</span>
 #define QP_TO_MW(nt, qp)	((qp) % nt-&gt;mw_count)
 #define NTB_QP_DEF_NUM_ENTRIES	100
 #define NTB_LINK_DOWN_TIMEOUT	10
<span class="p_del">-#define DMA_RETRIES		20</span>
<span class="p_del">-#define DMA_OUT_RESOURCE_TO	msecs_to_jiffies(50)</span>
 
 static void ntb_transport_rxc_db(unsigned long data);
 static const struct ntb_ctx_ops ntb_transport_ops;
<span class="p_chunk">@@ -518,12 +514,6 @@</span> <span class="p_context"> static ssize_t debugfs_read(struct file *filp, char __user *ubuf, size_t count,</span>
 	out_offset += snprintf(buf + out_offset, out_count - out_offset,
 			       &quot;free tx - \t%u\n&quot;,
 			       ntb_transport_tx_free_entry(qp));
<span class="p_del">-	out_offset += snprintf(buf + out_offset, out_count - out_offset,</span>
<span class="p_del">-			       &quot;DMA tx prep err - \t%llu\n&quot;,</span>
<span class="p_del">-			       qp-&gt;dma_tx_prep_err);</span>
<span class="p_del">-	out_offset += snprintf(buf + out_offset, out_count - out_offset,</span>
<span class="p_del">-			       &quot;DMA rx prep err - \t%llu\n&quot;,</span>
<span class="p_del">-			       qp-&gt;dma_rx_prep_err);</span>
 
 	out_offset += snprintf(buf + out_offset, out_count - out_offset,
 			       &quot;\n&quot;);
<span class="p_chunk">@@ -625,7 +615,7 @@</span> <span class="p_context"> static int ntb_transport_setup_qp_mw(struct ntb_transport_ctx *nt,</span>
 	if (!mw-&gt;virt_addr)
 		return -ENOMEM;
 
<span class="p_del">-	if (qp_count % mw_count &amp;&amp; mw_num + 1 &lt; qp_count / mw_count)</span>
<span class="p_add">+	if (mw_num &lt; qp_count % mw_count)</span>
 		num_qps_mw = qp_count / mw_count + 1;
 	else
 		num_qps_mw = qp_count / mw_count;
<span class="p_chunk">@@ -770,8 +760,6 @@</span> <span class="p_context"> static void ntb_qp_link_down_reset(struct ntb_transport_qp *qp)</span>
 	qp-&gt;tx_err_no_buf = 0;
 	qp-&gt;tx_memcpy = 0;
 	qp-&gt;tx_async = 0;
<span class="p_del">-	qp-&gt;dma_tx_prep_err = 0;</span>
<span class="p_del">-	qp-&gt;dma_rx_prep_err = 0;</span>
 }
 
 static void ntb_qp_link_cleanup(struct ntb_transport_qp *qp)
<span class="p_chunk">@@ -933,10 +921,8 @@</span> <span class="p_context"> static void ntb_transport_link_work(struct work_struct *work)</span>
 		ntb_free_mw(nt, i);
 
 	/* if there&#39;s an actual failure, we should just bail */
<span class="p_del">-	if (rc &lt; 0) {</span>
<span class="p_del">-		ntb_link_disable(ndev);</span>
<span class="p_add">+	if (rc &lt; 0)</span>
 		return;
<span class="p_del">-	}</span>
 
 out:
 	if (ntb_link_is_up(ndev, NULL, NULL) == 1)
<span class="p_chunk">@@ -1002,7 +988,7 @@</span> <span class="p_context"> static int ntb_transport_init_queue(struct ntb_transport_ctx *nt,</span>
 	qp-&gt;event_handler = NULL;
 	ntb_qp_link_down_reset(qp);
 
<span class="p_del">-	if (qp_count % mw_count &amp;&amp; mw_num + 1 &lt; qp_count / mw_count)</span>
<span class="p_add">+	if (mw_num &lt; qp_count % mw_count)</span>
 		num_qps_mw = qp_count / mw_count + 1;
 	else
 		num_qps_mw = qp_count / mw_count;
<span class="p_chunk">@@ -1125,8 +1111,8 @@</span> <span class="p_context"> static int ntb_transport_probe(struct ntb_client *self, struct ntb_dev *ndev)</span>
 	qp_count = ilog2(qp_bitmap);
 	if (max_num_clients &amp;&amp; max_num_clients &lt; qp_count)
 		qp_count = max_num_clients;
<span class="p_del">-	else if (mw_count &lt; qp_count)</span>
<span class="p_del">-		qp_count = mw_count;</span>
<span class="p_add">+	else if (nt-&gt;mw_count &lt; qp_count)</span>
<span class="p_add">+		qp_count = nt-&gt;mw_count;</span>
 
 	qp_bitmap &amp;= BIT_ULL(qp_count) - 1;
 
<span class="p_chunk">@@ -1314,7 +1300,6 @@</span> <span class="p_context"> static int ntb_async_rx_submit(struct ntb_queue_entry *entry, void *offset)</span>
 	struct dmaengine_unmap_data *unmap;
 	dma_cookie_t cookie;
 	void *buf = entry-&gt;buf;
<span class="p_del">-	int retries = 0;</span>
 
 	len = entry-&gt;len;
 	device = chan-&gt;device;
<span class="p_chunk">@@ -1343,22 +1328,11 @@</span> <span class="p_context"> static int ntb_async_rx_submit(struct ntb_queue_entry *entry, void *offset)</span>
 
 	unmap-&gt;from_cnt = 1;
 
<span class="p_del">-	for (retries = 0; retries &lt; DMA_RETRIES; retries++) {</span>
<span class="p_del">-		txd = device-&gt;device_prep_dma_memcpy(chan,</span>
<span class="p_del">-						     unmap-&gt;addr[1],</span>
<span class="p_del">-						     unmap-&gt;addr[0], len,</span>
<span class="p_del">-						     DMA_PREP_INTERRUPT);</span>
<span class="p_del">-		if (txd)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="p_del">-		schedule_timeout(DMA_OUT_RESOURCE_TO);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!txd) {</span>
<span class="p_del">-		qp-&gt;dma_rx_prep_err++;</span>
<span class="p_add">+	txd = device-&gt;device_prep_dma_memcpy(chan, unmap-&gt;addr[1],</span>
<span class="p_add">+					     unmap-&gt;addr[0], len,</span>
<span class="p_add">+					     DMA_PREP_INTERRUPT);</span>
<span class="p_add">+	if (!txd)</span>
 		goto err_get_unmap;
<span class="p_del">-	}</span>
 
 	txd-&gt;callback_result = ntb_rx_copy_callback;
 	txd-&gt;callback_param = entry;
<span class="p_chunk">@@ -1603,7 +1577,6 @@</span> <span class="p_context"> static int ntb_async_tx_submit(struct ntb_transport_qp *qp,</span>
 	struct dmaengine_unmap_data *unmap;
 	dma_addr_t dest;
 	dma_cookie_t cookie;
<span class="p_del">-	int retries = 0;</span>
 
 	device = chan-&gt;device;
 	dest = qp-&gt;tx_mw_phys + qp-&gt;tx_max_frame * entry-&gt;tx_index;
<span class="p_chunk">@@ -1625,21 +1598,10 @@</span> <span class="p_context"> static int ntb_async_tx_submit(struct ntb_transport_qp *qp,</span>
 
 	unmap-&gt;to_cnt = 1;
 
<span class="p_del">-	for (retries = 0; retries &lt; DMA_RETRIES; retries++) {</span>
<span class="p_del">-		txd = device-&gt;device_prep_dma_memcpy(chan, dest,</span>
<span class="p_del">-						     unmap-&gt;addr[0], len,</span>
<span class="p_del">-						     DMA_PREP_INTERRUPT);</span>
<span class="p_del">-		if (txd)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="p_del">-		schedule_timeout(DMA_OUT_RESOURCE_TO);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!txd) {</span>
<span class="p_del">-		qp-&gt;dma_tx_prep_err++;</span>
<span class="p_add">+	txd = device-&gt;device_prep_dma_memcpy(chan, dest, unmap-&gt;addr[0], len,</span>
<span class="p_add">+					     DMA_PREP_INTERRUPT);</span>
<span class="p_add">+	if (!txd)</span>
 		goto err_get_unmap;
<span class="p_del">-	}</span>
 
 	txd-&gt;callback_result = ntb_tx_copy_callback;
 	txd-&gt;callback_param = entry;
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/os_dep/usb_intf.c b/drivers/staging/rtl8188eu/os_dep/usb_intf.c</span>
<span class="p_header">index b432153a6c5a..0f63a36a519e 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/os_dep/usb_intf.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/os_dep/usb_intf.c</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> static struct usb_device_id rtw_usb_id_tbl[] = {</span>
 	{USB_DEVICE(0x2001, 0x3311)}, /* DLink GO-USB-N150 REV B1 */
 	{USB_DEVICE(0x2357, 0x010c)}, /* TP-Link TL-WN722N v2 */
 	{USB_DEVICE(0x0df6, 0x0076)}, /* Sitecom N150 v2 */
<span class="p_add">+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0xffef)}, /* Rosewill RNX-N150NUB */</span>
 	{}	/* Terminating entry */
 };
 
<span class="p_header">diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c</span>
<span class="p_header">index 789ff1df2d8d..581712534c93 100644</span>
<span class="p_header">--- a/fs/cifs/dir.c</span>
<span class="p_header">+++ b/fs/cifs/dir.c</span>
<span class="p_chunk">@@ -183,15 +183,20 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 }
 
 /*
<span class="p_add">+ * Don&#39;t allow path components longer than the server max.</span>
  * Don&#39;t allow the separator character in a path component.
  * The VFS will not allow &quot;/&quot;, but &quot;\&quot; is allowed by posix.
  */
 static int
<span class="p_del">-check_name(struct dentry *direntry)</span>
<span class="p_add">+check_name(struct dentry *direntry, struct cifs_tcon *tcon)</span>
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(direntry-&gt;d_sb);
 	int i;
 
<span class="p_add">+	if (unlikely(direntry-&gt;d_name.len &gt;</span>
<span class="p_add">+		     tcon-&gt;fsAttrInfo.MaxPathNameComponentLength))</span>
<span class="p_add">+		return -ENAMETOOLONG;</span>
<span class="p_add">+</span>
 	if (!(cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_POSIX_PATHS)) {
 		for (i = 0; i &lt; direntry-&gt;d_name.len; i++) {
 			if (direntry-&gt;d_name.name[i] == &#39;\\&#39;) {
<span class="p_chunk">@@ -489,10 +494,6 @@</span> <span class="p_context"> cifs_atomic_open(struct inode *inode, struct dentry *direntry,</span>
 		return finish_no_open(file, res);
 	}
 
<span class="p_del">-	rc = check_name(direntry);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
 	xid = get_xid();
 
 	cifs_dbg(FYI, &quot;parent inode = 0x%p name is: %pd and dentry = 0x%p\n&quot;,
<span class="p_chunk">@@ -505,6 +506,11 @@</span> <span class="p_context"> cifs_atomic_open(struct inode *inode, struct dentry *direntry,</span>
 	}
 
 	tcon = tlink_tcon(tlink);
<span class="p_add">+</span>
<span class="p_add">+	rc = check_name(direntry, tcon);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		goto out_free_xid;</span>
<span class="p_add">+</span>
 	server = tcon-&gt;ses-&gt;server;
 
 	if (server-&gt;ops-&gt;new_lease_key)
<span class="p_chunk">@@ -765,7 +771,7 @@</span> <span class="p_context"> cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,</span>
 	}
 	pTcon = tlink_tcon(tlink);
 
<span class="p_del">-	rc = check_name(direntry);</span>
<span class="p_add">+	rc = check_name(direntry, pTcon);</span>
 	if (rc)
 		goto lookup_out;
 
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 7c1c6c39d582..0437e5fdba56 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -2930,8 +2930,8 @@</span> <span class="p_context"> copy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,</span>
 	kst-&gt;f_bsize = le32_to_cpu(pfs_inf-&gt;BytesPerSector) *
 			  le32_to_cpu(pfs_inf-&gt;SectorsPerAllocationUnit);
 	kst-&gt;f_blocks = le64_to_cpu(pfs_inf-&gt;TotalAllocationUnits);
<span class="p_del">-	kst-&gt;f_bfree  = le64_to_cpu(pfs_inf-&gt;ActualAvailableAllocationUnits);</span>
<span class="p_del">-	kst-&gt;f_bavail = le64_to_cpu(pfs_inf-&gt;CallerAvailableAllocationUnits);</span>
<span class="p_add">+	kst-&gt;f_bfree  = kst-&gt;f_bavail =</span>
<span class="p_add">+			le64_to_cpu(pfs_inf-&gt;CallerAvailableAllocationUnits);</span>
 	return;
 }
 
<span class="p_header">diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">index 4e7a56a0a9b6..2c4f7a22e128 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4xdr.c</span>
<span class="p_chunk">@@ -129,7 +129,7 @@</span> <span class="p_context"> static void next_decode_page(struct nfsd4_compoundargs *argp)</span>
 	argp-&gt;p = page_address(argp-&gt;pagelist[0]);
 	argp-&gt;pagelist++;
 	if (argp-&gt;pagelen &lt; PAGE_SIZE) {
<span class="p_del">-		argp-&gt;end = argp-&gt;p + (argp-&gt;pagelen&gt;&gt;2);</span>
<span class="p_add">+		argp-&gt;end = argp-&gt;p + XDR_QUADLEN(argp-&gt;pagelen);</span>
 		argp-&gt;pagelen = 0;
 	} else {
 		argp-&gt;end = argp-&gt;p + (PAGE_SIZE&gt;&gt;2);
<span class="p_chunk">@@ -1246,9 +1246,7 @@</span> <span class="p_context"> nfsd4_decode_write(struct nfsd4_compoundargs *argp, struct nfsd4_write *write)</span>
 		argp-&gt;pagelen -= pages * PAGE_SIZE;
 		len -= pages * PAGE_SIZE;
 
<span class="p_del">-		argp-&gt;p = (__be32 *)page_address(argp-&gt;pagelist[0]);</span>
<span class="p_del">-		argp-&gt;pagelist++;</span>
<span class="p_del">-		argp-&gt;end = argp-&gt;p + XDR_QUADLEN(PAGE_SIZE);</span>
<span class="p_add">+		next_decode_page(argp);</span>
 	}
 	argp-&gt;p += XDR_QUADLEN(len);
 
<span class="p_header">diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h</span>
<span class="p_header">index 31e1d639abed..dc81e5287ebf 100644</span>
<span class="p_header">--- a/include/asm-generic/vmlinux.lds.h</span>
<span class="p_header">+++ b/include/asm-generic/vmlinux.lds.h</span>
<span class="p_chunk">@@ -59,6 +59,22 @@</span> <span class="p_context"></span>
 /* Align . to a 8 byte boundary equals to maximum function alignment. */
 #define ALIGN_FUNCTION()  . = ALIGN(8)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * LD_DEAD_CODE_DATA_ELIMINATION option enables -fdata-sections, which</span>
<span class="p_add">+ * generates .data.identifier sections, which need to be pulled in with</span>
<span class="p_add">+ * .data. We don&#39;t want to pull in .data..other sections, which Linux</span>
<span class="p_add">+ * has defined. Same for text and bss.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifdef CONFIG_LD_DEAD_CODE_DATA_ELIMINATION</span>
<span class="p_add">+#define TEXT_MAIN .text .text.[0-9a-zA-Z_]*</span>
<span class="p_add">+#define DATA_MAIN .data .data.[0-9a-zA-Z_]*</span>
<span class="p_add">+#define BSS_MAIN .bss .bss.[0-9a-zA-Z_]*</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define TEXT_MAIN .text</span>
<span class="p_add">+#define DATA_MAIN .data</span>
<span class="p_add">+#define BSS_MAIN .bss</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * Align to a 32 byte boundary equal to the
  * alignment gcc 4.5 uses for a struct
<span class="p_chunk">@@ -198,12 +214,9 @@</span> <span class="p_context"></span>
 
 /*
  * .data section
<span class="p_del">- * LD_DEAD_CODE_DATA_ELIMINATION option enables -fdata-sections generates</span>
<span class="p_del">- * .data.identifier which needs to be pulled in with .data, but don&#39;t want to</span>
<span class="p_del">- * pull in .data..stuff which has its own requirements. Same for bss.</span>
  */
 #define DATA_DATA							\
<span class="p_del">-	*(.data .data.[0-9a-zA-Z_]*)					\</span>
<span class="p_add">+	*(DATA_MAIN)							\</span>
 	*(.ref.data)							\
 	*(.data..shared_aligned) /* percpu related */			\
 	MEM_KEEP(init.data)						\
<span class="p_chunk">@@ -436,16 +449,17 @@</span> <span class="p_context"></span>
 		VMLINUX_SYMBOL(__security_initcall_end) = .;		\
 	}
 
<span class="p_del">-/* .text section. Map to function alignment to avoid address changes</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * .text section. Map to function alignment to avoid address changes</span>
  * during second ld run in second ld pass when generating System.map
<span class="p_del">- * LD_DEAD_CODE_DATA_ELIMINATION option enables -ffunction-sections generates</span>
<span class="p_del">- * .text.identifier which needs to be pulled in with .text , but some</span>
<span class="p_del">- * architectures define .text.foo which is not intended to be pulled in here.</span>
<span class="p_del">- * Those enabling LD_DEAD_CODE_DATA_ELIMINATION must ensure they don&#39;t have</span>
<span class="p_del">- * conflicting section names, and must pull in .text.[0-9a-zA-Z_]* */</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * TEXT_MAIN here will match .text.fixup and .text.unlikely if dead</span>
<span class="p_add">+ * code elimination is enabled, so these sections should be converted</span>
<span class="p_add">+ * to use &quot;..&quot; first.</span>
<span class="p_add">+ */</span>
 #define TEXT_TEXT							\
 		ALIGN_FUNCTION();					\
<span class="p_del">-		*(.text.hot .text .text.fixup .text.unlikely)		\</span>
<span class="p_add">+		*(.text.hot TEXT_MAIN .text.fixup .text.unlikely)	\</span>
 		*(.ref.text)						\
 	MEM_KEEP(init.text)						\
 	MEM_KEEP(exit.text)						\
<span class="p_chunk">@@ -613,7 +627,7 @@</span> <span class="p_context"></span>
 		BSS_FIRST_SECTIONS					\
 		*(.bss..page_aligned)					\
 		*(.dynbss)						\
<span class="p_del">-		*(.bss .bss.[0-9a-zA-Z_]*)				\</span>
<span class="p_add">+		*(BSS_MAIN)						\</span>
 		*(COMMON)						\
 	}
 
<span class="p_header">diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h</span>
<span class="p_header">index a13b031dc6b8..3101141661a1 100644</span>
<span class="p_header">--- a/include/linux/bpf_verifier.h</span>
<span class="p_header">+++ b/include/linux/bpf_verifier.h</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"> struct bpf_reg_state {</span>
 	 */
 	s64 min_value;
 	u64 max_value;
<span class="p_add">+	bool value_from_signed;</span>
 };
 
 enum bpf_stack_slot_type {
<span class="p_header">diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h</span>
<span class="p_header">index ba1cad7b97cf..965cc5693a46 100644</span>
<span class="p_header">--- a/include/linux/cpuhotplug.h</span>
<span class="p_header">+++ b/include/linux/cpuhotplug.h</span>
<span class="p_chunk">@@ -10,7 +10,6 @@</span> <span class="p_context"> enum cpuhp_state {</span>
 	CPUHP_PERF_X86_PREPARE,
 	CPUHP_PERF_X86_UNCORE_PREP,
 	CPUHP_PERF_X86_AMD_UNCORE_PREP,
<span class="p_del">-	CPUHP_PERF_X86_RAPL_PREP,</span>
 	CPUHP_PERF_BFIN,
 	CPUHP_PERF_POWER,
 	CPUHP_PERF_SUPERH,
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index 2f63d44368bd..dd88ded27fc8 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -941,9 +941,9 @@</span> <span class="p_context"> static inline struct file *get_file(struct file *f)</span>
 /* Page cache limit. The filesystems should put that into their s_maxbytes 
    limits, otherwise bad things can happen in VM. */ 
 #if BITS_PER_LONG==32
<span class="p_del">-#define MAX_LFS_FILESIZE	(((loff_t)PAGE_SIZE &lt;&lt; (BITS_PER_LONG-1))-1)</span>
<span class="p_add">+#define MAX_LFS_FILESIZE	((loff_t)ULONG_MAX &lt;&lt; PAGE_SHIFT)</span>
 #elif BITS_PER_LONG==64
<span class="p_del">-#define MAX_LFS_FILESIZE 	((loff_t)0x7fffffffffffffffLL)</span>
<span class="p_add">+#define MAX_LFS_FILESIZE 	((loff_t)LLONG_MAX)</span>
 #endif
 
 #define FL_POSIX	1
<span class="p_header">diff --git a/include/linux/ptr_ring.h b/include/linux/ptr_ring.h</span>
<span class="p_header">index 6c70444da3b9..b83507c0640c 100644</span>
<span class="p_header">--- a/include/linux/ptr_ring.h</span>
<span class="p_header">+++ b/include/linux/ptr_ring.h</span>
<span class="p_chunk">@@ -340,9 +340,9 @@</span> <span class="p_context"> static inline void *ptr_ring_consume_bh(struct ptr_ring *r)</span>
 	__PTR_RING_PEEK_CALL_v; \
 })
 
<span class="p_del">-static inline void **__ptr_ring_init_queue_alloc(int size, gfp_t gfp)</span>
<span class="p_add">+static inline void **__ptr_ring_init_queue_alloc(unsigned int size, gfp_t gfp)</span>
 {
<span class="p_del">-	return kzalloc(ALIGN(size * sizeof(void *), SMP_CACHE_BYTES), gfp);</span>
<span class="p_add">+	return kcalloc(size, sizeof(void *), gfp);</span>
 }
 
 static inline int ptr_ring_init(struct ptr_ring *r, int size, gfp_t gfp)
<span class="p_chunk">@@ -417,7 +417,8 @@</span> <span class="p_context"> static inline int ptr_ring_resize(struct ptr_ring *r, int size, gfp_t gfp,</span>
  * In particular if you consume ring in interrupt or BH context, you must
  * disable interrupts/BH when doing so.
  */
<span class="p_del">-static inline int ptr_ring_resize_multiple(struct ptr_ring **rings, int nrings,</span>
<span class="p_add">+static inline int ptr_ring_resize_multiple(struct ptr_ring **rings,</span>
<span class="p_add">+					   unsigned int nrings,</span>
 					   int size,
 					   gfp_t gfp, void (*destroy)(void *))
 {
<span class="p_chunk">@@ -425,7 +426,7 @@</span> <span class="p_context"> static inline int ptr_ring_resize_multiple(struct ptr_ring **rings, int nrings,</span>
 	void ***queues;
 	int i;
 
<span class="p_del">-	queues = kmalloc(nrings * sizeof *queues, gfp);</span>
<span class="p_add">+	queues = kmalloc_array(nrings, sizeof(*queues), gfp);</span>
 	if (!queues)
 		goto noqueues;
 
<span class="p_header">diff --git a/include/linux/skb_array.h b/include/linux/skb_array.h</span>
<span class="p_header">index f4dfade428f0..be8b902b5845 100644</span>
<span class="p_header">--- a/include/linux/skb_array.h</span>
<span class="p_header">+++ b/include/linux/skb_array.h</span>
<span class="p_chunk">@@ -162,7 +162,8 @@</span> <span class="p_context"> static inline int skb_array_resize(struct skb_array *a, int size, gfp_t gfp)</span>
 }
 
 static inline int skb_array_resize_multiple(struct skb_array **rings,
<span class="p_del">-					    int nrings, int size, gfp_t gfp)</span>
<span class="p_add">+					    int nrings, unsigned int size,</span>
<span class="p_add">+					    gfp_t gfp)</span>
 {
 	BUILD_BUG_ON(offsetof(struct skb_array, ring));
 	return ptr_ring_resize_multiple((struct ptr_ring **)rings,
<span class="p_header">diff --git a/include/net/ip.h b/include/net/ip.h</span>
<span class="p_header">index d3a107850a41..51c6b9786c46 100644</span>
<span class="p_header">--- a/include/net/ip.h</span>
<span class="p_header">+++ b/include/net/ip.h</span>
<span class="p_chunk">@@ -339,7 +339,7 @@</span> <span class="p_context"> static inline unsigned int ip_dst_mtu_maybe_forward(const struct dst_entry *dst,</span>
 	    !forwarding)
 		return dst_mtu(dst);
 
<span class="p_del">-	return min(dst-&gt;dev-&gt;mtu, IP_MAX_MTU);</span>
<span class="p_add">+	return min(READ_ONCE(dst-&gt;dev-&gt;mtu), IP_MAX_MTU);</span>
 }
 
 static inline unsigned int ip_skb_dst_mtu(struct sock *sk,
<span class="p_chunk">@@ -351,7 +351,7 @@</span> <span class="p_context"> static inline unsigned int ip_skb_dst_mtu(struct sock *sk,</span>
 		return ip_dst_mtu_maybe_forward(skb_dst(skb), forwarding);
 	}
 
<span class="p_del">-	return min(skb_dst(skb)-&gt;dev-&gt;mtu, IP_MAX_MTU);</span>
<span class="p_add">+	return min(READ_ONCE(skb_dst(skb)-&gt;dev-&gt;mtu), IP_MAX_MTU);</span>
 }
 
 u32 ip_idents_reserve(u32 hash, int segs);
<span class="p_header">diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h</span>
<span class="p_header">index e6aa0a249672..f18fc1a0321f 100644</span>
<span class="p_header">--- a/include/net/sch_generic.h</span>
<span class="p_header">+++ b/include/net/sch_generic.h</span>
<span class="p_chunk">@@ -768,8 +768,11 @@</span> <span class="p_context"> static inline struct Qdisc *qdisc_replace(struct Qdisc *sch, struct Qdisc *new,</span>
 	old = *pold;
 	*pold = new;
 	if (old != NULL) {
<span class="p_del">-		qdisc_tree_reduce_backlog(old, old-&gt;q.qlen, old-&gt;qstats.backlog);</span>
<span class="p_add">+		unsigned int qlen = old-&gt;q.qlen;</span>
<span class="p_add">+		unsigned int backlog = old-&gt;qstats.backlog;</span>
<span class="p_add">+</span>
 		qdisc_reset(old);
<span class="p_add">+		qdisc_tree_reduce_backlog(old, qlen, backlog);</span>
 	}
 	sch_tree_unlock(sch);
 
<span class="p_header">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span>
<span class="p_header">index 8ce679d36c58..779c871c5dcd 100644</span>
<span class="p_header">--- a/kernel/bpf/verifier.c</span>
<span class="p_header">+++ b/kernel/bpf/verifier.c</span>
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"> struct bpf_verifier_stack_elem {</span>
 	struct bpf_verifier_stack_elem *next;
 };
 
<span class="p_del">-#define BPF_COMPLEXITY_LIMIT_INSNS	65536</span>
<span class="p_add">+#define BPF_COMPLEXITY_LIMIT_INSNS	98304</span>
 #define BPF_COMPLEXITY_LIMIT_STACK	1024
 
 struct bpf_call_arg_meta {
<span class="p_chunk">@@ -682,12 +682,13 @@</span> <span class="p_context"> static int check_ctx_access(struct bpf_verifier_env *env, int off, int size,</span>
 	return -EACCES;
 }
 
<span class="p_del">-static bool is_pointer_value(struct bpf_verifier_env *env, int regno)</span>
<span class="p_add">+static bool __is_pointer_value(bool allow_ptr_leaks,</span>
<span class="p_add">+			       const struct bpf_reg_state *reg)</span>
 {
<span class="p_del">-	if (env-&gt;allow_ptr_leaks)</span>
<span class="p_add">+	if (allow_ptr_leaks)</span>
 		return false;
 
<span class="p_del">-	switch (env-&gt;cur_state.regs[regno].type) {</span>
<span class="p_add">+	switch (reg-&gt;type) {</span>
 	case UNKNOWN_VALUE:
 	case CONST_IMM:
 		return false;
<span class="p_chunk">@@ -696,6 +697,11 @@</span> <span class="p_context"> static bool is_pointer_value(struct bpf_verifier_env *env, int regno)</span>
 	}
 }
 
<span class="p_add">+static bool is_pointer_value(struct bpf_verifier_env *env, int regno)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __is_pointer_value(env-&gt;allow_ptr_leaks, &amp;env-&gt;cur_state.regs[regno]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int check_ptr_alignment(struct bpf_verifier_env *env,
 			       struct bpf_reg_state *reg, int off, int size)
 {
<span class="p_chunk">@@ -1467,6 +1473,65 @@</span> <span class="p_context"> static int evaluate_reg_alu(struct bpf_verifier_env *env, struct bpf_insn *insn)</span>
 	return 0;
 }
 
<span class="p_add">+static int evaluate_reg_imm_alu_unknown(struct bpf_verifier_env *env,</span>
<span class="p_add">+					struct bpf_insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct bpf_reg_state *regs = env-&gt;cur_state.regs;</span>
<span class="p_add">+	struct bpf_reg_state *dst_reg = &amp;regs[insn-&gt;dst_reg];</span>
<span class="p_add">+	struct bpf_reg_state *src_reg = &amp;regs[insn-&gt;src_reg];</span>
<span class="p_add">+	u8 opcode = BPF_OP(insn-&gt;code);</span>
<span class="p_add">+	s64 imm_log2 = __ilog2_u64((long long)dst_reg-&gt;imm);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* BPF_X code with src_reg-&gt;type UNKNOWN_VALUE here. */</span>
<span class="p_add">+	if (src_reg-&gt;imm &gt; 0 &amp;&amp; dst_reg-&gt;imm) {</span>
<span class="p_add">+		switch (opcode) {</span>
<span class="p_add">+		case BPF_ADD:</span>
<span class="p_add">+			/* dreg += sreg</span>
<span class="p_add">+			 * where both have zero upper bits. Adding them</span>
<span class="p_add">+			 * can only result making one more bit non-zero</span>
<span class="p_add">+			 * in the larger value.</span>
<span class="p_add">+			 * Ex. 0xffff (imm=48) + 1 (imm=63) = 0x10000 (imm=47)</span>
<span class="p_add">+			 *     0xffff (imm=48) + 0xffff = 0x1fffe (imm=47)</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			dst_reg-&gt;imm = min(src_reg-&gt;imm, 63 - imm_log2);</span>
<span class="p_add">+			dst_reg-&gt;imm--;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case BPF_AND:</span>
<span class="p_add">+			/* dreg &amp;= sreg</span>
<span class="p_add">+			 * AND can not extend zero bits only shrink</span>
<span class="p_add">+			 * Ex.  0x00..00ffffff</span>
<span class="p_add">+			 *    &amp; 0x0f..ffffffff</span>
<span class="p_add">+			 *     ----------------</span>
<span class="p_add">+			 *      0x00..00ffffff</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			dst_reg-&gt;imm = max(src_reg-&gt;imm, 63 - imm_log2);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case BPF_OR:</span>
<span class="p_add">+			/* dreg |= sreg</span>
<span class="p_add">+			 * OR can only extend zero bits</span>
<span class="p_add">+			 * Ex.  0x00..00ffffff</span>
<span class="p_add">+			 *    | 0x0f..ffffffff</span>
<span class="p_add">+			 *     ----------------</span>
<span class="p_add">+			 *      0x0f..00ffffff</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			dst_reg-&gt;imm = min(src_reg-&gt;imm, 63 - imm_log2);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case BPF_SUB:</span>
<span class="p_add">+		case BPF_MUL:</span>
<span class="p_add">+		case BPF_RSH:</span>
<span class="p_add">+		case BPF_LSH:</span>
<span class="p_add">+			/* These may be flushed out later */</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			mark_reg_unknown_value(regs, insn-&gt;dst_reg);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		mark_reg_unknown_value(regs, insn-&gt;dst_reg);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dst_reg-&gt;type = UNKNOWN_VALUE;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int evaluate_reg_imm_alu(struct bpf_verifier_env *env,
 				struct bpf_insn *insn)
 {
<span class="p_chunk">@@ -1475,6 +1540,9 @@</span> <span class="p_context"> static int evaluate_reg_imm_alu(struct bpf_verifier_env *env,</span>
 	struct bpf_reg_state *src_reg = &amp;regs[insn-&gt;src_reg];
 	u8 opcode = BPF_OP(insn-&gt;code);
 
<span class="p_add">+	if (BPF_SRC(insn-&gt;code) == BPF_X &amp;&amp; src_reg-&gt;type == UNKNOWN_VALUE)</span>
<span class="p_add">+		return evaluate_reg_imm_alu_unknown(env, insn);</span>
<span class="p_add">+</span>
 	/* dst_reg-&gt;type == CONST_IMM here, simulate execution of &#39;add&#39; insn.
 	 * Don&#39;t care about overflow or negative values, just add them
 	 */
<span class="p_chunk">@@ -1530,10 +1598,24 @@</span> <span class="p_context"> static void adjust_reg_min_max_vals(struct bpf_verifier_env *env,</span>
 	}
 
 	/* We don&#39;t know anything about what was done to this register, mark it
<span class="p_del">-	 * as unknown.</span>
<span class="p_add">+	 * as unknown. Also, if both derived bounds came from signed/unsigned</span>
<span class="p_add">+	 * mixed compares and one side is unbounded, we cannot really do anything</span>
<span class="p_add">+	 * with them as boundaries cannot be trusted. Thus, arithmetic of two</span>
<span class="p_add">+	 * regs of such kind will get invalidated bounds on the dst side.</span>
 	 */
<span class="p_del">-	if (min_val == BPF_REGISTER_MIN_RANGE &amp;&amp;</span>
<span class="p_del">-	    max_val == BPF_REGISTER_MAX_RANGE) {</span>
<span class="p_add">+	if ((min_val == BPF_REGISTER_MIN_RANGE &amp;&amp;</span>
<span class="p_add">+	     max_val == BPF_REGISTER_MAX_RANGE) ||</span>
<span class="p_add">+	    (BPF_SRC(insn-&gt;code) == BPF_X &amp;&amp;</span>
<span class="p_add">+	     ((min_val != BPF_REGISTER_MIN_RANGE &amp;&amp;</span>
<span class="p_add">+	       max_val == BPF_REGISTER_MAX_RANGE) ||</span>
<span class="p_add">+	      (min_val == BPF_REGISTER_MIN_RANGE &amp;&amp;</span>
<span class="p_add">+	       max_val != BPF_REGISTER_MAX_RANGE) ||</span>
<span class="p_add">+	      (dst_reg-&gt;min_value != BPF_REGISTER_MIN_RANGE &amp;&amp;</span>
<span class="p_add">+	       dst_reg-&gt;max_value == BPF_REGISTER_MAX_RANGE) ||</span>
<span class="p_add">+	      (dst_reg-&gt;min_value == BPF_REGISTER_MIN_RANGE &amp;&amp;</span>
<span class="p_add">+	       dst_reg-&gt;max_value != BPF_REGISTER_MAX_RANGE)) &amp;&amp;</span>
<span class="p_add">+	     regs[insn-&gt;dst_reg].value_from_signed !=</span>
<span class="p_add">+	     regs[insn-&gt;src_reg].value_from_signed)) {</span>
 		reset_reg_range_values(regs, insn-&gt;dst_reg);
 		return;
 	}
<span class="p_chunk">@@ -1542,10 +1624,12 @@</span> <span class="p_context"> static void adjust_reg_min_max_vals(struct bpf_verifier_env *env,</span>
 	 * do our normal operations to the register, we need to set the values
 	 * to the min/max since they are undefined.
 	 */
<span class="p_del">-	if (min_val == BPF_REGISTER_MIN_RANGE)</span>
<span class="p_del">-		dst_reg-&gt;min_value = BPF_REGISTER_MIN_RANGE;</span>
<span class="p_del">-	if (max_val == BPF_REGISTER_MAX_RANGE)</span>
<span class="p_del">-		dst_reg-&gt;max_value = BPF_REGISTER_MAX_RANGE;</span>
<span class="p_add">+	if (opcode != BPF_SUB) {</span>
<span class="p_add">+		if (min_val == BPF_REGISTER_MIN_RANGE)</span>
<span class="p_add">+			dst_reg-&gt;min_value = BPF_REGISTER_MIN_RANGE;</span>
<span class="p_add">+		if (max_val == BPF_REGISTER_MAX_RANGE)</span>
<span class="p_add">+			dst_reg-&gt;max_value = BPF_REGISTER_MAX_RANGE;</span>
<span class="p_add">+	}</span>
 
 	switch (opcode) {
 	case BPF_ADD:
<span class="p_chunk">@@ -1555,10 +1639,17 @@</span> <span class="p_context"> static void adjust_reg_min_max_vals(struct bpf_verifier_env *env,</span>
 			dst_reg-&gt;max_value += max_val;
 		break;
 	case BPF_SUB:
<span class="p_add">+		/* If one of our values was at the end of our ranges, then the</span>
<span class="p_add">+		 * _opposite_ value in the dst_reg goes to the end of our range.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (min_val == BPF_REGISTER_MIN_RANGE)</span>
<span class="p_add">+			dst_reg-&gt;max_value = BPF_REGISTER_MAX_RANGE;</span>
<span class="p_add">+		if (max_val == BPF_REGISTER_MAX_RANGE)</span>
<span class="p_add">+			dst_reg-&gt;min_value = BPF_REGISTER_MIN_RANGE;</span>
 		if (dst_reg-&gt;min_value != BPF_REGISTER_MIN_RANGE)
<span class="p_del">-			dst_reg-&gt;min_value -= min_val;</span>
<span class="p_add">+			dst_reg-&gt;min_value -= max_val;</span>
 		if (dst_reg-&gt;max_value != BPF_REGISTER_MAX_RANGE)
<span class="p_del">-			dst_reg-&gt;max_value -= max_val;</span>
<span class="p_add">+			dst_reg-&gt;max_value -= min_val;</span>
 		break;
 	case BPF_MUL:
 		if (dst_reg-&gt;min_value != BPF_REGISTER_MIN_RANGE)
<span class="p_chunk">@@ -1808,6 +1899,7 @@</span> <span class="p_context"> static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)</span>
 		 * register as unknown.
 		 */
 		if (env-&gt;allow_ptr_leaks &amp;&amp;
<span class="p_add">+		    BPF_CLASS(insn-&gt;code) == BPF_ALU64 &amp;&amp; opcode == BPF_ADD &amp;&amp;</span>
 		    (dst_reg-&gt;type == PTR_TO_MAP_VALUE ||
 		     dst_reg-&gt;type == PTR_TO_MAP_VALUE_ADJ))
 			dst_reg-&gt;type = PTR_TO_MAP_VALUE_ADJ;
<span class="p_chunk">@@ -1876,38 +1968,63 @@</span> <span class="p_context"> static void reg_set_min_max(struct bpf_reg_state *true_reg,</span>
 			    struct bpf_reg_state *false_reg, u64 val,
 			    u8 opcode)
 {
<span class="p_add">+	bool value_from_signed = true;</span>
<span class="p_add">+	bool is_range = true;</span>
<span class="p_add">+</span>
 	switch (opcode) {
 	case BPF_JEQ:
 		/* If this is false then we know nothing Jon Snow, but if it is
 		 * true then we know for sure.
 		 */
 		true_reg-&gt;max_value = true_reg-&gt;min_value = val;
<span class="p_add">+		is_range = false;</span>
 		break;
 	case BPF_JNE:
 		/* If this is true we know nothing Jon Snow, but if it is false
 		 * we know the value for sure;
 		 */
 		false_reg-&gt;max_value = false_reg-&gt;min_value = val;
<span class="p_add">+		is_range = false;</span>
 		break;
 	case BPF_JGT:
<span class="p_del">-		/* Unsigned comparison, the minimum value is 0. */</span>
<span class="p_del">-		false_reg-&gt;min_value = 0;</span>
<span class="p_add">+		value_from_signed = false;</span>
<span class="p_add">+		/* fallthrough */</span>
 	case BPF_JSGT:
<span class="p_add">+		if (true_reg-&gt;value_from_signed != value_from_signed)</span>
<span class="p_add">+			reset_reg_range_values(true_reg, 0);</span>
<span class="p_add">+		if (false_reg-&gt;value_from_signed != value_from_signed)</span>
<span class="p_add">+			reset_reg_range_values(false_reg, 0);</span>
<span class="p_add">+		if (opcode == BPF_JGT) {</span>
<span class="p_add">+			/* Unsigned comparison, the minimum value is 0. */</span>
<span class="p_add">+			false_reg-&gt;min_value = 0;</span>
<span class="p_add">+		}</span>
 		/* If this is false then we know the maximum val is val,
 		 * otherwise we know the min val is val+1.
 		 */
 		false_reg-&gt;max_value = val;
<span class="p_add">+		false_reg-&gt;value_from_signed = value_from_signed;</span>
 		true_reg-&gt;min_value = val + 1;
<span class="p_add">+		true_reg-&gt;value_from_signed = value_from_signed;</span>
 		break;
 	case BPF_JGE:
<span class="p_del">-		/* Unsigned comparison, the minimum value is 0. */</span>
<span class="p_del">-		false_reg-&gt;min_value = 0;</span>
<span class="p_add">+		value_from_signed = false;</span>
<span class="p_add">+		/* fallthrough */</span>
 	case BPF_JSGE:
<span class="p_add">+		if (true_reg-&gt;value_from_signed != value_from_signed)</span>
<span class="p_add">+			reset_reg_range_values(true_reg, 0);</span>
<span class="p_add">+		if (false_reg-&gt;value_from_signed != value_from_signed)</span>
<span class="p_add">+			reset_reg_range_values(false_reg, 0);</span>
<span class="p_add">+		if (opcode == BPF_JGE) {</span>
<span class="p_add">+			/* Unsigned comparison, the minimum value is 0. */</span>
<span class="p_add">+			false_reg-&gt;min_value = 0;</span>
<span class="p_add">+		}</span>
 		/* If this is false then we know the maximum value is val - 1,
 		 * otherwise we know the mimimum value is val.
 		 */
 		false_reg-&gt;max_value = val - 1;
<span class="p_add">+		false_reg-&gt;value_from_signed = value_from_signed;</span>
 		true_reg-&gt;min_value = val;
<span class="p_add">+		true_reg-&gt;value_from_signed = value_from_signed;</span>
 		break;
 	default:
 		break;
<span class="p_chunk">@@ -1915,6 +2032,12 @@</span> <span class="p_context"> static void reg_set_min_max(struct bpf_reg_state *true_reg,</span>
 
 	check_reg_overflow(false_reg);
 	check_reg_overflow(true_reg);
<span class="p_add">+	if (is_range) {</span>
<span class="p_add">+		if (__is_pointer_value(false, false_reg))</span>
<span class="p_add">+			reset_reg_range_values(false_reg, 0);</span>
<span class="p_add">+		if (__is_pointer_value(false, true_reg))</span>
<span class="p_add">+			reset_reg_range_values(true_reg, 0);</span>
<span class="p_add">+	}</span>
 }
 
 /* Same as above, but for the case that dst_reg is a CONST_IMM reg and src_reg
<span class="p_chunk">@@ -1924,39 +2047,64 @@</span> <span class="p_context"> static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,</span>
 				struct bpf_reg_state *false_reg, u64 val,
 				u8 opcode)
 {
<span class="p_add">+	bool value_from_signed = true;</span>
<span class="p_add">+	bool is_range = true;</span>
<span class="p_add">+</span>
 	switch (opcode) {
 	case BPF_JEQ:
 		/* If this is false then we know nothing Jon Snow, but if it is
 		 * true then we know for sure.
 		 */
 		true_reg-&gt;max_value = true_reg-&gt;min_value = val;
<span class="p_add">+		is_range = false;</span>
 		break;
 	case BPF_JNE:
 		/* If this is true we know nothing Jon Snow, but if it is false
 		 * we know the value for sure;
 		 */
 		false_reg-&gt;max_value = false_reg-&gt;min_value = val;
<span class="p_add">+		is_range = false;</span>
 		break;
 	case BPF_JGT:
<span class="p_del">-		/* Unsigned comparison, the minimum value is 0. */</span>
<span class="p_del">-		true_reg-&gt;min_value = 0;</span>
<span class="p_add">+		value_from_signed = false;</span>
<span class="p_add">+		/* fallthrough */</span>
 	case BPF_JSGT:
<span class="p_add">+		if (true_reg-&gt;value_from_signed != value_from_signed)</span>
<span class="p_add">+			reset_reg_range_values(true_reg, 0);</span>
<span class="p_add">+		if (false_reg-&gt;value_from_signed != value_from_signed)</span>
<span class="p_add">+			reset_reg_range_values(false_reg, 0);</span>
<span class="p_add">+		if (opcode == BPF_JGT) {</span>
<span class="p_add">+			/* Unsigned comparison, the minimum value is 0. */</span>
<span class="p_add">+			true_reg-&gt;min_value = 0;</span>
<span class="p_add">+		}</span>
 		/*
 		 * If this is false, then the val is &lt;= the register, if it is
 		 * true the register &lt;= to the val.
 		 */
 		false_reg-&gt;min_value = val;
<span class="p_add">+		false_reg-&gt;value_from_signed = value_from_signed;</span>
 		true_reg-&gt;max_value = val - 1;
<span class="p_add">+		true_reg-&gt;value_from_signed = value_from_signed;</span>
 		break;
 	case BPF_JGE:
<span class="p_del">-		/* Unsigned comparison, the minimum value is 0. */</span>
<span class="p_del">-		true_reg-&gt;min_value = 0;</span>
<span class="p_add">+		value_from_signed = false;</span>
<span class="p_add">+		/* fallthrough */</span>
 	case BPF_JSGE:
<span class="p_add">+		if (true_reg-&gt;value_from_signed != value_from_signed)</span>
<span class="p_add">+			reset_reg_range_values(true_reg, 0);</span>
<span class="p_add">+		if (false_reg-&gt;value_from_signed != value_from_signed)</span>
<span class="p_add">+			reset_reg_range_values(false_reg, 0);</span>
<span class="p_add">+		if (opcode == BPF_JGE) {</span>
<span class="p_add">+			/* Unsigned comparison, the minimum value is 0. */</span>
<span class="p_add">+			true_reg-&gt;min_value = 0;</span>
<span class="p_add">+		}</span>
 		/* If this is false then constant &lt; register, if it is true then
 		 * the register &lt; constant.
 		 */
 		false_reg-&gt;min_value = val + 1;
<span class="p_add">+		false_reg-&gt;value_from_signed = value_from_signed;</span>
 		true_reg-&gt;max_value = val;
<span class="p_add">+		true_reg-&gt;value_from_signed = value_from_signed;</span>
 		break;
 	default:
 		break;
<span class="p_chunk">@@ -1964,6 +2112,12 @@</span> <span class="p_context"> static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,</span>
 
 	check_reg_overflow(false_reg);
 	check_reg_overflow(true_reg);
<span class="p_add">+	if (is_range) {</span>
<span class="p_add">+		if (__is_pointer_value(false, false_reg))</span>
<span class="p_add">+			reset_reg_range_values(false_reg, 0);</span>
<span class="p_add">+		if (__is_pointer_value(false, true_reg))</span>
<span class="p_add">+			reset_reg_range_values(true_reg, 0);</span>
<span class="p_add">+	}</span>
 }
 
 static void mark_map_reg(struct bpf_reg_state *regs, u32 regno, u32 id,
<span class="p_chunk">@@ -2390,6 +2544,7 @@</span> <span class="p_context"> static int check_cfg(struct bpf_verifier_env *env)</span>
 				env-&gt;explored_states[t + 1] = STATE_LIST_MARK;
 		} else {
 			/* conditional jump with two edges */
<span class="p_add">+			env-&gt;explored_states[t] = STATE_LIST_MARK;</span>
 			ret = push_insn(t, t + 1, FALLTHROUGH, env);
 			if (ret == 1)
 				goto peek_stack;
<span class="p_chunk">@@ -2548,6 +2703,12 @@</span> <span class="p_context"> static bool states_equal(struct bpf_verifier_env *env,</span>
 		     rcur-&gt;type != NOT_INIT))
 			continue;
 
<span class="p_add">+		/* Don&#39;t care about the reg-&gt;id in this case. */</span>
<span class="p_add">+		if (rold-&gt;type == PTR_TO_MAP_VALUE_OR_NULL &amp;&amp;</span>
<span class="p_add">+		    rcur-&gt;type == PTR_TO_MAP_VALUE_OR_NULL &amp;&amp;</span>
<span class="p_add">+		    rold-&gt;map_ptr == rcur-&gt;map_ptr)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		if (rold-&gt;type == PTR_TO_PACKET &amp;&amp; rcur-&gt;type == PTR_TO_PACKET &amp;&amp;
 		    compare_ptrs_to_packet(rold, rcur))
 			continue;
<span class="p_chunk">@@ -2682,6 +2843,9 @@</span> <span class="p_context"> static int do_check(struct bpf_verifier_env *env)</span>
 			goto process_bpf_exit;
 		}
 
<span class="p_add">+		if (need_resched())</span>
<span class="p_add">+			cond_resched();</span>
<span class="p_add">+</span>
 		if (log_level &amp;&amp; do_print_state) {
 			verbose(&quot;\nfrom %d to %d:&quot;, prev_insn_idx, insn_idx);
 			print_verifier_state(&amp;env-&gt;cur_state);
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index f5a693589d66..c774773ac3a4 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -9786,28 +9786,27 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 			goto err_context;
 
 		/*
<span class="p_del">-		 * Do not allow to attach to a group in a different</span>
<span class="p_del">-		 * task or CPU context:</span>
<span class="p_add">+		 * Make sure we&#39;re both events for the same CPU;</span>
<span class="p_add">+		 * grouping events for different CPUs is broken; since</span>
<span class="p_add">+		 * you can never concurrently schedule them anyhow.</span>
 		 */
<span class="p_del">-		if (move_group) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Make sure we&#39;re both on the same task, or both</span>
<span class="p_del">-			 * per-cpu events.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (group_leader-&gt;ctx-&gt;task != ctx-&gt;task)</span>
<span class="p_del">-				goto err_context;</span>
<span class="p_add">+		if (group_leader-&gt;cpu != event-&gt;cpu)</span>
<span class="p_add">+			goto err_context;</span>
 
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Make sure we&#39;re both events for the same CPU;</span>
<span class="p_del">-			 * grouping events for different CPUs is broken; since</span>
<span class="p_del">-			 * you can never concurrently schedule them anyhow.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (group_leader-&gt;cpu != event-&gt;cpu)</span>
<span class="p_del">-				goto err_context;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			if (group_leader-&gt;ctx != ctx)</span>
<span class="p_del">-				goto err_context;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Make sure we&#39;re both on the same task, or both</span>
<span class="p_add">+		 * per-CPU events.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (group_leader-&gt;ctx-&gt;task != ctx-&gt;task)</span>
<span class="p_add">+			goto err_context;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Do not allow to attach to a group in a different task</span>
<span class="p_add">+		 * or CPU context. If we&#39;re moving SW events, we&#39;ll fix</span>
<span class="p_add">+		 * this up later, so allow that.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!move_group &amp;&amp; group_leader-&gt;ctx != ctx)</span>
<span class="p_add">+			goto err_context;</span>
 
 		/*
 		 * Only a group leader can be exclusive or pinned
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index 59faac4de181..50bf262cc427 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -766,6 +766,7 @@</span> <span class="p_context"> static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,</span>
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
<span class="p_add">+	RCU_INIT_POINTER(mm-&gt;exe_file, NULL);</span>
 	mmu_notifier_mm_init(mm);
 	clear_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; !USE_SPLIT_PMD_PTLOCKS
<span class="p_header">diff --git a/kernel/time/timer.c b/kernel/time/timer.c</span>
<span class="p_header">index 944ad64277a6..df445cde8a1e 100644</span>
<span class="p_header">--- a/kernel/time/timer.c</span>
<span class="p_header">+++ b/kernel/time/timer.c</span>
<span class="p_chunk">@@ -201,6 +201,7 @@</span> <span class="p_context"> struct timer_base {</span>
 	bool			migration_enabled;
 	bool			nohz_active;
 	bool			is_idle;
<span class="p_add">+	bool			must_forward_clk;</span>
 	DECLARE_BITMAP(pending_map, WHEEL_SIZE);
 	struct hlist_head	vectors[WHEEL_SIZE];
 } ____cacheline_aligned;
<span class="p_chunk">@@ -891,13 +892,19 @@</span> <span class="p_context"> get_target_base(struct timer_base *base, unsigned tflags)</span>
 
 static inline void forward_timer_base(struct timer_base *base)
 {
<span class="p_del">-	unsigned long jnow = READ_ONCE(jiffies);</span>
<span class="p_add">+	unsigned long jnow;</span>
 
 	/*
<span class="p_del">-	 * We only forward the base when it&#39;s idle and we have a delta between</span>
<span class="p_del">-	 * base clock and jiffies.</span>
<span class="p_add">+	 * We only forward the base when we are idle or have just come out of</span>
<span class="p_add">+	 * idle (must_forward_clk logic), and have a delta between base clock</span>
<span class="p_add">+	 * and jiffies. In the common case, run_timers will take care of it.</span>
 	 */
<span class="p_del">-	if (!base-&gt;is_idle || (long) (jnow - base-&gt;clk) &lt; 2)</span>
<span class="p_add">+	if (likely(!base-&gt;must_forward_clk))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	jnow = READ_ONCE(jiffies);</span>
<span class="p_add">+	base-&gt;must_forward_clk = base-&gt;is_idle;</span>
<span class="p_add">+	if ((long)(jnow - base-&gt;clk) &lt; 2)</span>
 		return;
 
 	/*
<span class="p_chunk">@@ -973,6 +980,11 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 	 * same array bucket then just return:
 	 */
 	if (timer_pending(timer)) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The downside of this optimization is that it can result in</span>
<span class="p_add">+		 * larger granularity than you would get from adding a new</span>
<span class="p_add">+		 * timer with this expiry.</span>
<span class="p_add">+		 */</span>
 		if (timer-&gt;expires == expires)
 			return 1;
 
<span class="p_chunk">@@ -983,6 +995,7 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 		 * dequeue/enqueue dance.
 		 */
 		base = lock_timer_base(timer, &amp;flags);
<span class="p_add">+		forward_timer_base(base);</span>
 
 		clk = base-&gt;clk;
 		idx = calc_wheel_index(expires, clk);
<span class="p_chunk">@@ -999,6 +1012,7 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 		}
 	} else {
 		base = lock_timer_base(timer, &amp;flags);
<span class="p_add">+		forward_timer_base(base);</span>
 	}
 
 	timer_stats_timer_set_start_info(timer);
<span class="p_chunk">@@ -1028,12 +1042,10 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 			spin_lock(&amp;base-&gt;lock);
 			WRITE_ONCE(timer-&gt;flags,
 				   (timer-&gt;flags &amp; ~TIMER_BASEMASK) | base-&gt;cpu);
<span class="p_add">+			forward_timer_base(base);</span>
 		}
 	}
 
<span class="p_del">-	/* Try to forward a stale timer base clock */</span>
<span class="p_del">-	forward_timer_base(base);</span>
<span class="p_del">-</span>
 	timer-&gt;expires = expires;
 	/*
 	 * If &#39;idx&#39; was calculated above and the base time did not advance
<span class="p_chunk">@@ -1150,6 +1162,7 @@</span> <span class="p_context"> void add_timer_on(struct timer_list *timer, int cpu)</span>
 		WRITE_ONCE(timer-&gt;flags,
 			   (timer-&gt;flags &amp; ~TIMER_BASEMASK) | cpu);
 	}
<span class="p_add">+	forward_timer_base(base);</span>
 
 	debug_activate(timer, timer-&gt;expires);
 	internal_add_timer(base, timer);
<span class="p_chunk">@@ -1538,10 +1551,16 @@</span> <span class="p_context"> u64 get_next_timer_interrupt(unsigned long basej, u64 basem)</span>
 		if (!is_max_delta)
 			expires = basem + (u64)(nextevt - basej) * TICK_NSEC;
 		/*
<span class="p_del">-		 * If we expect to sleep more than a tick, mark the base idle:</span>
<span class="p_add">+		 * If we expect to sleep more than a tick, mark the base idle.</span>
<span class="p_add">+		 * Also the tick is stopped so any added timer must forward</span>
<span class="p_add">+		 * the base clk itself to keep granularity small. This idle</span>
<span class="p_add">+		 * logic is only maintained for the BASE_STD base, deferrable</span>
<span class="p_add">+		 * timers may still see large granularity skew (by design).</span>
 		 */
<span class="p_del">-		if ((expires - basem) &gt; TICK_NSEC)</span>
<span class="p_add">+		if ((expires - basem) &gt; TICK_NSEC) {</span>
<span class="p_add">+			base-&gt;must_forward_clk = true;</span>
 			base-&gt;is_idle = true;
<span class="p_add">+		}</span>
 	}
 	spin_unlock(&amp;base-&gt;lock);
 
<span class="p_chunk">@@ -1651,6 +1670,19 @@</span> <span class="p_context"> static __latent_entropy void run_timer_softirq(struct softirq_action *h)</span>
 {
 	struct timer_base *base = this_cpu_ptr(&amp;timer_bases[BASE_STD]);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * must_forward_clk must be cleared before running timers so that any</span>
<span class="p_add">+	 * timer functions that call mod_timer will not try to forward the</span>
<span class="p_add">+	 * base. idle trcking / clock forwarding logic is only used with</span>
<span class="p_add">+	 * BASE_STD timers.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The deferrable base does not do idle tracking at all, so we do</span>
<span class="p_add">+	 * not forward it. This can result in very large variations in</span>
<span class="p_add">+	 * granularity for deferrable timers, but they can be deferred for</span>
<span class="p_add">+	 * long periods due to idle.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	base-&gt;must_forward_clk = false;</span>
<span class="p_add">+</span>
 	__run_timers(base);
 	if (IS_ENABLED(CONFIG_NO_HZ_COMMON) &amp;&amp; base-&gt;nohz_active)
 		__run_timers(this_cpu_ptr(&amp;timer_bases[BASE_DEF]));
<span class="p_header">diff --git a/kernel/trace/bpf_trace.c b/kernel/trace/bpf_trace.c</span>
<span class="p_header">index 5dcb99281259..41805fb3c661 100644</span>
<span class="p_header">--- a/kernel/trace/bpf_trace.c</span>
<span class="p_header">+++ b/kernel/trace/bpf_trace.c</span>
<span class="p_chunk">@@ -203,10 +203,36 @@</span> <span class="p_context"> BPF_CALL_5(bpf_trace_printk, char *, fmt, u32, fmt_size, u64, arg1,</span>
 		fmt_cnt++;
 	}
 
<span class="p_del">-	return __trace_printk(1/* fake ip will not be printed */, fmt,</span>
<span class="p_del">-			      mod[0] == 2 ? arg1 : mod[0] == 1 ? (long) arg1 : (u32) arg1,</span>
<span class="p_del">-			      mod[1] == 2 ? arg2 : mod[1] == 1 ? (long) arg2 : (u32) arg2,</span>
<span class="p_del">-			      mod[2] == 2 ? arg3 : mod[2] == 1 ? (long) arg3 : (u32) arg3);</span>
<span class="p_add">+/* Horrid workaround for getting va_list handling working with different</span>
<span class="p_add">+ * argument type combinations generically for 32 and 64 bit archs.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define __BPF_TP_EMIT()	__BPF_ARG3_TP()</span>
<span class="p_add">+#define __BPF_TP(...)							\</span>
<span class="p_add">+	__trace_printk(1 /* Fake ip will not be printed. */,		\</span>
<span class="p_add">+		       fmt, ##__VA_ARGS__)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __BPF_ARG1_TP(...)						\</span>
<span class="p_add">+	((mod[0] == 2 || (mod[0] == 1 &amp;&amp; __BITS_PER_LONG == 64))	\</span>
<span class="p_add">+	  ? __BPF_TP(arg1, ##__VA_ARGS__)				\</span>
<span class="p_add">+	  : ((mod[0] == 1 || (mod[0] == 0 &amp;&amp; __BITS_PER_LONG == 32))	\</span>
<span class="p_add">+	      ? __BPF_TP((long)arg1, ##__VA_ARGS__)			\</span>
<span class="p_add">+	      : __BPF_TP((u32)arg1, ##__VA_ARGS__)))</span>
<span class="p_add">+</span>
<span class="p_add">+#define __BPF_ARG2_TP(...)						\</span>
<span class="p_add">+	((mod[1] == 2 || (mod[1] == 1 &amp;&amp; __BITS_PER_LONG == 64))	\</span>
<span class="p_add">+	  ? __BPF_ARG1_TP(arg2, ##__VA_ARGS__)				\</span>
<span class="p_add">+	  : ((mod[1] == 1 || (mod[1] == 0 &amp;&amp; __BITS_PER_LONG == 32))	\</span>
<span class="p_add">+	      ? __BPF_ARG1_TP((long)arg2, ##__VA_ARGS__)		\</span>
<span class="p_add">+	      : __BPF_ARG1_TP((u32)arg2, ##__VA_ARGS__)))</span>
<span class="p_add">+</span>
<span class="p_add">+#define __BPF_ARG3_TP(...)						\</span>
<span class="p_add">+	((mod[2] == 2 || (mod[2] == 1 &amp;&amp; __BITS_PER_LONG == 64))	\</span>
<span class="p_add">+	  ? __BPF_ARG2_TP(arg3, ##__VA_ARGS__)				\</span>
<span class="p_add">+	  : ((mod[2] == 1 || (mod[2] == 0 &amp;&amp; __BITS_PER_LONG == 32))	\</span>
<span class="p_add">+	      ? __BPF_ARG2_TP((long)arg3, ##__VA_ARGS__)		\</span>
<span class="p_add">+	      : __BPF_ARG2_TP((u32)arg3, ##__VA_ARGS__)))</span>
<span class="p_add">+</span>
<span class="p_add">+	return __BPF_TP_EMIT();</span>
 }
 
 static const struct bpf_func_proto bpf_trace_printk_proto = {
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index 4f7ea8446bb5..6e432ed7d0fe 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -876,6 +876,10 @@</span> <span class="p_context"> static int profile_graph_entry(struct ftrace_graph_ent *trace)</span>
 
 	function_profile_call(trace-&gt;func, 0, NULL, NULL);
 
<span class="p_add">+	/* If function graph is shutting down, ret_stack can be NULL */</span>
<span class="p_add">+	if (!current-&gt;ret_stack)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (index &gt;= 0 &amp;&amp; index &lt; FTRACE_RETFUNC_DEPTH)
 		current-&gt;ret_stack[index].subtime = 0;
 
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 53c308068e39..7379f735a9f4 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -7767,4 +7767,4 @@</span> <span class="p_context"> __init static int clear_boot_tracer(void)</span>
 }
 
 fs_initcall(tracer_init_tracefs);
<span class="p_del">-late_initcall(clear_boot_tracer);</span>
<span class="p_add">+late_initcall_sync(clear_boot_tracer);</span>
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index 9daa9b3bc6d9..0193f58c45f0 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1926,6 +1926,10 @@</span> <span class="p_context"> static int create_filter(struct trace_event_call *call,</span>
 		if (err &amp;&amp; set_str)
 			append_filter_err(ps, filter);
 	}
<span class="p_add">+	if (err &amp;&amp; !set_str) {</span>
<span class="p_add">+		free_event_filter(filter);</span>
<span class="p_add">+		filter = NULL;</span>
<span class="p_add">+	}</span>
 	create_filter_finish(ps);
 
 	*filterp = filter;
<span class="p_header">diff --git a/kernel/trace/tracing_map.c b/kernel/trace/tracing_map.c</span>
<span class="p_header">index 0a689bbb78ef..305039b122fa 100644</span>
<span class="p_header">--- a/kernel/trace/tracing_map.c</span>
<span class="p_header">+++ b/kernel/trace/tracing_map.c</span>
<span class="p_chunk">@@ -221,16 +221,19 @@</span> <span class="p_context"> void tracing_map_array_free(struct tracing_map_array *a)</span>
 	if (!a)
 		return;
 
<span class="p_del">-	if (!a-&gt;pages) {</span>
<span class="p_del">-		kfree(a);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!a-&gt;pages)</span>
<span class="p_add">+		goto free;</span>
 
 	for (i = 0; i &lt; a-&gt;n_pages; i++) {
 		if (!a-&gt;pages[i])
 			break;
 		free_page((unsigned long)a-&gt;pages[i]);
 	}
<span class="p_add">+</span>
<span class="p_add">+	kfree(a-&gt;pages);</span>
<span class="p_add">+</span>
<span class="p_add">+ free:</span>
<span class="p_add">+	kfree(a);</span>
 }
 
 struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,
<span class="p_header">diff --git a/mm/madvise.c b/mm/madvise.c</span>
<span class="p_header">index 253b1533fba5..63a12162f4c6 100644</span>
<span class="p_header">--- a/mm/madvise.c</span>
<span class="p_header">+++ b/mm/madvise.c</span>
<span class="p_chunk">@@ -331,8 +331,8 @@</span> <span class="p_context"> static int madvise_free_pte_range(pmd_t *pmd, unsigned long addr,</span>
 				pte_offset_map_lock(mm, pmd, addr, &amp;ptl);
 				goto out;
 			}
<span class="p_del">-			put_page(page);</span>
 			unlock_page(page);
<span class="p_add">+			put_page(page);</span>
 			pte = pte_offset_map_lock(mm, pmd, addr, &amp;ptl);
 			pte--;
 			addr -= PAGE_SIZE;
<span class="p_header">diff --git a/mm/memblock.c b/mm/memblock.c</span>
<span class="p_header">index ccec42c12ba8..42b98af6a415 100644</span>
<span class="p_header">--- a/mm/memblock.c</span>
<span class="p_header">+++ b/mm/memblock.c</span>
<span class="p_chunk">@@ -311,7 +311,7 @@</span> <span class="p_context"> void __init memblock_discard(void)</span>
 		__memblock_free_late(addr, size);
 	}
 
<span class="p_del">-	if (memblock.memory.regions == memblock_memory_init_regions) {</span>
<span class="p_add">+	if (memblock.memory.regions != memblock_memory_init_regions) {</span>
 		addr = __pa(memblock.memory.regions);
 		size = PAGE_ALIGN(sizeof(struct memblock_region) *
 				  memblock.memory.max);
<span class="p_header">diff --git a/mm/shmem.c b/mm/shmem.c</span>
<span class="p_header">index 7ee5444ffb6d..004e0f87e8a8 100644</span>
<span class="p_header">--- a/mm/shmem.c</span>
<span class="p_header">+++ b/mm/shmem.c</span>
<span class="p_chunk">@@ -3810,7 +3810,7 @@</span> <span class="p_context"> int __init shmem_init(void)</span>
 	}
 
 #ifdef CONFIG_TRANSPARENT_HUGE_PAGECACHE
<span class="p_del">-	if (has_transparent_hugepage() &amp;&amp; shmem_huge &lt; SHMEM_HUGE_DENY)</span>
<span class="p_add">+	if (has_transparent_hugepage() &amp;&amp; shmem_huge &gt; SHMEM_HUGE_DENY)</span>
 		SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;
 	else
 		shmem_huge = 0; /* just in case it was patched */
<span class="p_chunk">@@ -3871,7 +3871,7 @@</span> <span class="p_context"> static ssize_t shmem_enabled_store(struct kobject *kobj,</span>
 		return -EINVAL;
 
 	shmem_huge = huge;
<span class="p_del">-	if (shmem_huge &lt; SHMEM_HUGE_DENY)</span>
<span class="p_add">+	if (shmem_huge &gt; SHMEM_HUGE_DENY)</span>
 		SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;
 	return count;
 }
<span class="p_header">diff --git a/net/bluetooth/bnep/core.c b/net/bluetooth/bnep/core.c</span>
<span class="p_header">index fbf251fef70f..4d6b94d7ce5f 100644</span>
<span class="p_header">--- a/net/bluetooth/bnep/core.c</span>
<span class="p_header">+++ b/net/bluetooth/bnep/core.c</span>
<span class="p_chunk">@@ -484,16 +484,16 @@</span> <span class="p_context"> static int bnep_session(void *arg)</span>
 	struct net_device *dev = s-&gt;dev;
 	struct sock *sk = s-&gt;sock-&gt;sk;
 	struct sk_buff *skb;
<span class="p_del">-	wait_queue_t wait;</span>
<span class="p_add">+	DEFINE_WAIT_FUNC(wait, woken_wake_function);</span>
 
 	BT_DBG(&quot;&quot;);
 
 	set_user_nice(current, -15);
 
<span class="p_del">-	init_waitqueue_entry(&amp;wait, current);</span>
 	add_wait_queue(sk_sleep(sk), &amp;wait);
 	while (1) {
<span class="p_del">-		set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="p_add">+		/* Ensure session-&gt;terminate is updated */</span>
<span class="p_add">+		smp_mb__before_atomic();</span>
 
 		if (atomic_read(&amp;s-&gt;terminate))
 			break;
<span class="p_chunk">@@ -515,9 +515,8 @@</span> <span class="p_context"> static int bnep_session(void *arg)</span>
 				break;
 		netif_wake_queue(dev);
 
<span class="p_del">-		schedule();</span>
<span class="p_add">+		wait_woken(&amp;wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span>
 	}
<span class="p_del">-	__set_current_state(TASK_RUNNING);</span>
 	remove_wait_queue(sk_sleep(sk), &amp;wait);
 
 	/* Cleanup session */
<span class="p_chunk">@@ -666,7 +665,7 @@</span> <span class="p_context"> int bnep_del_connection(struct bnep_conndel_req *req)</span>
 	s = __bnep_get_session(req-&gt;dst);
 	if (s) {
 		atomic_inc(&amp;s-&gt;terminate);
<span class="p_del">-		wake_up_process(s-&gt;task);</span>
<span class="p_add">+		wake_up_interruptible(sk_sleep(s-&gt;sock-&gt;sk));</span>
 	} else
 		err = -ENOENT;
 
<span class="p_header">diff --git a/net/bluetooth/cmtp/core.c b/net/bluetooth/cmtp/core.c</span>
<span class="p_header">index 9e59b6654126..1152ce34dad4 100644</span>
<span class="p_header">--- a/net/bluetooth/cmtp/core.c</span>
<span class="p_header">+++ b/net/bluetooth/cmtp/core.c</span>
<span class="p_chunk">@@ -280,16 +280,16 @@</span> <span class="p_context"> static int cmtp_session(void *arg)</span>
 	struct cmtp_session *session = arg;
 	struct sock *sk = session-&gt;sock-&gt;sk;
 	struct sk_buff *skb;
<span class="p_del">-	wait_queue_t wait;</span>
<span class="p_add">+	DEFINE_WAIT_FUNC(wait, woken_wake_function);</span>
 
 	BT_DBG(&quot;session %p&quot;, session);
 
 	set_user_nice(current, -15);
 
<span class="p_del">-	init_waitqueue_entry(&amp;wait, current);</span>
 	add_wait_queue(sk_sleep(sk), &amp;wait);
 	while (1) {
<span class="p_del">-		set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="p_add">+		/* Ensure session-&gt;terminate is updated */</span>
<span class="p_add">+		smp_mb__before_atomic();</span>
 
 		if (atomic_read(&amp;session-&gt;terminate))
 			break;
<span class="p_chunk">@@ -306,9 +306,8 @@</span> <span class="p_context"> static int cmtp_session(void *arg)</span>
 
 		cmtp_process_transmit(session);
 
<span class="p_del">-		schedule();</span>
<span class="p_add">+		wait_woken(&amp;wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span>
 	}
<span class="p_del">-	__set_current_state(TASK_RUNNING);</span>
 	remove_wait_queue(sk_sleep(sk), &amp;wait);
 
 	down_write(&amp;cmtp_session_sem);
<span class="p_chunk">@@ -393,7 +392,7 @@</span> <span class="p_context"> int cmtp_add_connection(struct cmtp_connadd_req *req, struct socket *sock)</span>
 		err = cmtp_attach_device(session);
 		if (err &lt; 0) {
 			atomic_inc(&amp;session-&gt;terminate);
<span class="p_del">-			wake_up_process(session-&gt;task);</span>
<span class="p_add">+			wake_up_interruptible(sk_sleep(session-&gt;sock-&gt;sk));</span>
 			up_write(&amp;cmtp_session_sem);
 			return err;
 		}
<span class="p_chunk">@@ -431,7 +430,11 @@</span> <span class="p_context"> int cmtp_del_connection(struct cmtp_conndel_req *req)</span>
 
 		/* Stop session thread */
 		atomic_inc(&amp;session-&gt;terminate);
<span class="p_del">-		wake_up_process(session-&gt;task);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Ensure session-&gt;terminate is updated */</span>
<span class="p_add">+		smp_mb__after_atomic();</span>
<span class="p_add">+</span>
<span class="p_add">+		wake_up_interruptible(sk_sleep(session-&gt;sock-&gt;sk));</span>
 	} else
 		err = -ENOENT;
 
<span class="p_header">diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c</span>
<span class="p_header">index 0bec4588c3c8..1fc076420d1e 100644</span>
<span class="p_header">--- a/net/bluetooth/hidp/core.c</span>
<span class="p_header">+++ b/net/bluetooth/hidp/core.c</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #define VERSION &quot;1.2&quot;
 
 static DECLARE_RWSEM(hidp_session_sem);
<span class="p_add">+static DECLARE_WAIT_QUEUE_HEAD(hidp_session_wq);</span>
 static LIST_HEAD(hidp_session_list);
 
 static unsigned char hidp_keycode[256] = {
<span class="p_chunk">@@ -1068,12 +1069,12 @@</span> <span class="p_context"> static int hidp_session_start_sync(struct hidp_session *session)</span>
  * Wake up session thread and notify it to stop. This is asynchronous and
  * returns immediately. Call this whenever a runtime error occurs and you want
  * the session to stop.
<span class="p_del">- * Note: wake_up_process() performs any necessary memory-barriers for us.</span>
<span class="p_add">+ * Note: wake_up_interruptible() performs any necessary memory-barriers for us.</span>
  */
 static void hidp_session_terminate(struct hidp_session *session)
 {
 	atomic_inc(&amp;session-&gt;terminate);
<span class="p_del">-	wake_up_process(session-&gt;task);</span>
<span class="p_add">+	wake_up_interruptible(&amp;hidp_session_wq);</span>
 }
 
 /*
<span class="p_chunk">@@ -1180,7 +1181,9 @@</span> <span class="p_context"> static void hidp_session_run(struct hidp_session *session)</span>
 	struct sock *ctrl_sk = session-&gt;ctrl_sock-&gt;sk;
 	struct sock *intr_sk = session-&gt;intr_sock-&gt;sk;
 	struct sk_buff *skb;
<span class="p_add">+	DEFINE_WAIT_FUNC(wait, woken_wake_function);</span>
 
<span class="p_add">+	add_wait_queue(&amp;hidp_session_wq, &amp;wait);</span>
 	for (;;) {
 		/*
 		 * This thread can be woken up two ways:
<span class="p_chunk">@@ -1188,12 +1191,10 @@</span> <span class="p_context"> static void hidp_session_run(struct hidp_session *session)</span>
 		 *    session-&gt;terminate flag and wakes this thread up.
 		 *  - Via modifying the socket state of ctrl/intr_sock. This
 		 *    thread is woken up by -&gt;sk_state_changed().
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Note: set_current_state() performs any necessary</span>
<span class="p_del">-		 * memory-barriers for us.</span>
 		 */
<span class="p_del">-		set_current_state(TASK_INTERRUPTIBLE);</span>
 
<span class="p_add">+		/* Ensure session-&gt;terminate is updated */</span>
<span class="p_add">+		smp_mb__before_atomic();</span>
 		if (atomic_read(&amp;session-&gt;terminate))
 			break;
 
<span class="p_chunk">@@ -1227,11 +1228,22 @@</span> <span class="p_context"> static void hidp_session_run(struct hidp_session *session)</span>
 		hidp_process_transmit(session, &amp;session-&gt;ctrl_transmit,
 				      session-&gt;ctrl_sock);
 
<span class="p_del">-		schedule();</span>
<span class="p_add">+		wait_woken(&amp;wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span>
 	}
<span class="p_add">+	remove_wait_queue(&amp;hidp_session_wq, &amp;wait);</span>
 
 	atomic_inc(&amp;session-&gt;terminate);
<span class="p_del">-	set_current_state(TASK_RUNNING);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Ensure session-&gt;terminate is updated */</span>
<span class="p_add">+	smp_mb__after_atomic();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hidp_session_wake_function(wait_queue_t *wait,</span>
<span class="p_add">+				      unsigned int mode,</span>
<span class="p_add">+				      int sync, void *key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	wake_up_interruptible(&amp;hidp_session_wq);</span>
<span class="p_add">+	return false;</span>
 }
 
 /*
<span class="p_chunk">@@ -1244,7 +1256,8 @@</span> <span class="p_context"> static void hidp_session_run(struct hidp_session *session)</span>
 static int hidp_session_thread(void *arg)
 {
 	struct hidp_session *session = arg;
<span class="p_del">-	wait_queue_t ctrl_wait, intr_wait;</span>
<span class="p_add">+	DEFINE_WAIT_FUNC(ctrl_wait, hidp_session_wake_function);</span>
<span class="p_add">+	DEFINE_WAIT_FUNC(intr_wait, hidp_session_wake_function);</span>
 
 	BT_DBG(&quot;session %p&quot;, session);
 
<span class="p_chunk">@@ -1254,8 +1267,6 @@</span> <span class="p_context"> static int hidp_session_thread(void *arg)</span>
 	set_user_nice(current, -15);
 	hidp_set_timer(session);
 
<span class="p_del">-	init_waitqueue_entry(&amp;ctrl_wait, current);</span>
<span class="p_del">-	init_waitqueue_entry(&amp;intr_wait, current);</span>
 	add_wait_queue(sk_sleep(session-&gt;ctrl_sock-&gt;sk), &amp;ctrl_wait);
 	add_wait_queue(sk_sleep(session-&gt;intr_sock-&gt;sk), &amp;intr_wait);
 	/* This memory barrier is paired with wq_has_sleeper(). See
<span class="p_header">diff --git a/net/dccp/proto.c b/net/dccp/proto.c</span>
<span class="p_header">index 9fe25bf63296..b68168fcc06a 100644</span>
<span class="p_header">--- a/net/dccp/proto.c</span>
<span class="p_header">+++ b/net/dccp/proto.c</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;net/checksum.h&gt;
 
 #include &lt;net/inet_sock.h&gt;
<span class="p_add">+#include &lt;net/inet_common.h&gt;</span>
 #include &lt;net/sock.h&gt;
 #include &lt;net/xfrm.h&gt;
 
<span class="p_chunk">@@ -170,6 +171,15 @@</span> <span class="p_context"> const char *dccp_packet_name(const int type)</span>
 
 EXPORT_SYMBOL_GPL(dccp_packet_name);
 
<span class="p_add">+static void dccp_sk_destruct(struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dccp_sock *dp = dccp_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ccid_hc_tx_delete(dp-&gt;dccps_hc_tx_ccid, sk);</span>
<span class="p_add">+	dp-&gt;dccps_hc_tx_ccid = NULL;</span>
<span class="p_add">+	inet_sock_destruct(sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized)
 {
 	struct dccp_sock *dp = dccp_sk(sk);
<span class="p_chunk">@@ -179,6 +189,7 @@</span> <span class="p_context"> int dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized)</span>
 	icsk-&gt;icsk_syn_retries	= sysctl_dccp_request_retries;
 	sk-&gt;sk_state		= DCCP_CLOSED;
 	sk-&gt;sk_write_space	= dccp_write_space;
<span class="p_add">+	sk-&gt;sk_destruct		= dccp_sk_destruct;</span>
 	icsk-&gt;icsk_sync_mss	= dccp_sync_mss;
 	dp-&gt;dccps_mss_cache	= 536;
 	dp-&gt;dccps_rate_last	= jiffies;
<span class="p_chunk">@@ -201,10 +212,7 @@</span> <span class="p_context"> void dccp_destroy_sock(struct sock *sk)</span>
 {
 	struct dccp_sock *dp = dccp_sk(sk);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * DCCP doesn&#39;t use sk_write_queue, just sk_send_head</span>
<span class="p_del">-	 * for retransmissions</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	__skb_queue_purge(&amp;sk-&gt;sk_write_queue);</span>
 	if (sk-&gt;sk_send_head != NULL) {
 		kfree_skb(sk-&gt;sk_send_head);
 		sk-&gt;sk_send_head = NULL;
<span class="p_chunk">@@ -222,8 +230,7 @@</span> <span class="p_context"> void dccp_destroy_sock(struct sock *sk)</span>
 		dp-&gt;dccps_hc_rx_ackvec = NULL;
 	}
 	ccid_hc_rx_delete(dp-&gt;dccps_hc_rx_ccid, sk);
<span class="p_del">-	ccid_hc_tx_delete(dp-&gt;dccps_hc_tx_ccid, sk);</span>
<span class="p_del">-	dp-&gt;dccps_hc_rx_ccid = dp-&gt;dccps_hc_tx_ccid = NULL;</span>
<span class="p_add">+	dp-&gt;dccps_hc_rx_ccid = NULL;</span>
 
 	/* clean up feature negotiation state */
 	dccp_feat_list_purge(&amp;dp-&gt;dccps_featneg);
<span class="p_header">diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c</span>
<span class="p_header">index 7563831fa432..38c1c979ecb1 100644</span>
<span class="p_header">--- a/net/ipv4/fib_semantics.c</span>
<span class="p_header">+++ b/net/ipv4/fib_semantics.c</span>
<span class="p_chunk">@@ -1044,15 +1044,17 @@</span> <span class="p_context"> struct fib_info *fib_create_info(struct fib_config *cfg)</span>
 	fi = kzalloc(sizeof(*fi)+nhs*sizeof(struct fib_nh), GFP_KERNEL);
 	if (!fi)
 		goto failure;
<span class="p_del">-	fib_info_cnt++;</span>
 	if (cfg-&gt;fc_mx) {
 		fi-&gt;fib_metrics = kzalloc(sizeof(*fi-&gt;fib_metrics), GFP_KERNEL);
<span class="p_del">-		if (!fi-&gt;fib_metrics)</span>
<span class="p_del">-			goto failure;</span>
<span class="p_add">+		if (unlikely(!fi-&gt;fib_metrics)) {</span>
<span class="p_add">+			kfree(fi);</span>
<span class="p_add">+			return ERR_PTR(err);</span>
<span class="p_add">+		}</span>
 		atomic_set(&amp;fi-&gt;fib_metrics-&gt;refcnt, 1);
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		fi-&gt;fib_metrics = (struct dst_metrics *)&amp;dst_default_metrics;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
<span class="p_add">+	fib_info_cnt++;</span>
 	fi-&gt;fib_net = net;
 	fi-&gt;fib_protocol = cfg-&gt;fc_protocol;
 	fi-&gt;fib_scope = cfg-&gt;fc_scope;
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 6cd49fd17ac0..6a5b7783932e 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -1247,7 +1247,7 @@</span> <span class="p_context"> static unsigned int ipv4_mtu(const struct dst_entry *dst)</span>
 	if (mtu)
 		return mtu;
 
<span class="p_del">-	mtu = dst-&gt;dev-&gt;mtu;</span>
<span class="p_add">+	mtu = READ_ONCE(dst-&gt;dev-&gt;mtu);</span>
 
 	if (unlikely(dst_metric_locked(dst, RTAX_MTU))) {
 		if (rt-&gt;rt_uses_gateway &amp;&amp; mtu &gt; 576)
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 32c540145c17..c03850771a4e 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -3036,8 +3036,7 @@</span> <span class="p_context"> void tcp_rearm_rto(struct sock *sk)</span>
 			/* delta may not be positive if the socket is locked
 			 * when the retrans timer fires and is rescheduled.
 			 */
<span class="p_del">-			if (delta &gt; 0)</span>
<span class="p_del">-				rto = delta;</span>
<span class="p_add">+			rto = max(delta, 1);</span>
 		}
 		inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, rto,
 					  TCP_RTO_MAX);
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index 4345ee39f180..ff389591a340 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -897,6 +897,8 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 		}
 		nsiblings = iter-&gt;rt6i_nsiblings;
 		fib6_purge_rt(iter, fn, info-&gt;nl_net);
<span class="p_add">+		if (fn-&gt;rr_ptr == iter)</span>
<span class="p_add">+			fn-&gt;rr_ptr = NULL;</span>
 		rt6_release(iter);
 
 		if (nsiblings) {
<span class="p_chunk">@@ -909,6 +911,8 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 				if (rt6_qualify_for_ecmp(iter)) {
 					*ins = iter-&gt;dst.rt6_next;
 					fib6_purge_rt(iter, fn, info-&gt;nl_net);
<span class="p_add">+					if (fn-&gt;rr_ptr == iter)</span>
<span class="p_add">+						fn-&gt;rr_ptr = NULL;</span>
 					rt6_release(iter);
 					nsiblings--;
 				} else {
<span class="p_chunk">@@ -997,7 +1001,7 @@</span> <span class="p_context"> int fib6_add(struct fib6_node *root, struct rt6_info *rt,</span>
 			/* Create subtree root node */
 			sfn = node_alloc();
 			if (!sfn)
<span class="p_del">-				goto st_failure;</span>
<span class="p_add">+				goto failure;</span>
 
 			sfn-&gt;leaf = info-&gt;nl_net-&gt;ipv6.ip6_null_entry;
 			atomic_inc(&amp;info-&gt;nl_net-&gt;ipv6.ip6_null_entry-&gt;rt6i_ref);
<span class="p_chunk">@@ -1013,12 +1017,12 @@</span> <span class="p_context"> int fib6_add(struct fib6_node *root, struct rt6_info *rt,</span>
 
 			if (IS_ERR(sn)) {
 				/* If it is failed, discard just allocated
<span class="p_del">-				   root, and then (in st_failure) stale node</span>
<span class="p_add">+				   root, and then (in failure) stale node</span>
 				   in main tree.
 				 */
 				node_free(sfn);
 				err = PTR_ERR(sn);
<span class="p_del">-				goto st_failure;</span>
<span class="p_add">+				goto failure;</span>
 			}
 
 			/* Now link new subtree to main tree */
<span class="p_chunk">@@ -1032,7 +1036,7 @@</span> <span class="p_context"> int fib6_add(struct fib6_node *root, struct rt6_info *rt,</span>
 
 			if (IS_ERR(sn)) {
 				err = PTR_ERR(sn);
<span class="p_del">-				goto st_failure;</span>
<span class="p_add">+				goto failure;</span>
 			}
 		}
 
<span class="p_chunk">@@ -1074,22 +1078,22 @@</span> <span class="p_context"> int fib6_add(struct fib6_node *root, struct rt6_info *rt,</span>
 			atomic_inc(&amp;pn-&gt;leaf-&gt;rt6i_ref);
 		}
 #endif
<span class="p_del">-		if (!(rt-&gt;dst.flags &amp; DST_NOCACHE))</span>
<span class="p_del">-			dst_free(&amp;rt-&gt;dst);</span>
<span class="p_add">+		goto failure;</span>
 	}
 	return err;
 
<span class="p_del">-#ifdef CONFIG_IPV6_SUBTREES</span>
<span class="p_del">-	/* Subtree creation failed, probably main tree node</span>
<span class="p_del">-	   is orphan. If it is, shoot it.</span>
<span class="p_add">+failure:</span>
<span class="p_add">+	/* fn-&gt;leaf could be NULL if fn is an intermediate node and we</span>
<span class="p_add">+	 * failed to add the new route to it in both subtree creation</span>
<span class="p_add">+	 * failure and fib6_add_rt2node() failure case.</span>
<span class="p_add">+	 * In both cases, fib6_repair_tree() should be called to fix</span>
<span class="p_add">+	 * fn-&gt;leaf.</span>
 	 */
<span class="p_del">-st_failure:</span>
 	if (fn &amp;&amp; !(fn-&gt;fn_flags &amp; (RTN_RTINFO|RTN_ROOT)))
 		fib6_repair_tree(info-&gt;nl_net, fn);
 	if (!(rt-&gt;dst.flags &amp; DST_NOCACHE))
 		dst_free(&amp;rt-&gt;dst);
 	return err;
<span class="p_del">-#endif</span>
 }
 
 /*
<span class="p_header">diff --git a/net/irda/af_irda.c b/net/irda/af_irda.c</span>
<span class="p_header">index 391c3cbd2eed..101ed6c42808 100644</span>
<span class="p_header">--- a/net/irda/af_irda.c</span>
<span class="p_header">+++ b/net/irda/af_irda.c</span>
<span class="p_chunk">@@ -2223,7 +2223,7 @@</span> <span class="p_context"> static int irda_getsockopt(struct socket *sock, int level, int optname,</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	struct irda_sock *self = irda_sk(sk);
<span class="p_del">-	struct irda_device_list list;</span>
<span class="p_add">+	struct irda_device_list list = { 0 };</span>
 	struct irda_device_info *discoveries;
 	struct irda_ias_set *	ias_opt;	/* IAS get/query params */
 	struct ias_object *	ias_obj;	/* Object in IAS */
<span class="p_header">diff --git a/net/key/af_key.c b/net/key/af_key.c</span>
<span class="p_header">index 2e1050ec2cf0..94bf810ad242 100644</span>
<span class="p_header">--- a/net/key/af_key.c</span>
<span class="p_header">+++ b/net/key/af_key.c</span>
<span class="p_chunk">@@ -228,7 +228,7 @@</span> <span class="p_context"> static int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,</span>
 #define BROADCAST_ONE		1
 #define BROADCAST_REGISTERED	2
 #define BROADCAST_PROMISC_ONLY	4
<span class="p_del">-static int pfkey_broadcast(struct sk_buff *skb,</span>
<span class="p_add">+static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
 			   int broadcast_flags, struct sock *one_sk,
 			   struct net *net)
 {
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> static int pfkey_broadcast(struct sk_buff *skb,</span>
 	rcu_read_unlock();
 
 	if (one_sk != NULL)
<span class="p_del">-		err = pfkey_broadcast_one(skb, &amp;skb2, GFP_KERNEL, one_sk);</span>
<span class="p_add">+		err = pfkey_broadcast_one(skb, &amp;skb2, allocation, one_sk);</span>
 
 	kfree_skb(skb2);
 	kfree_skb(skb);
<span class="p_chunk">@@ -311,7 +311,7 @@</span> <span class="p_context"> static int pfkey_do_dump(struct pfkey_sock *pfk)</span>
 		hdr = (struct sadb_msg *) pfk-&gt;dump.skb-&gt;data;
 		hdr-&gt;sadb_msg_seq = 0;
 		hdr-&gt;sadb_msg_errno = rc;
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 		pfk-&gt;dump.skb = NULL;
 	}
<span class="p_chunk">@@ -355,7 +355,7 @@</span> <span class="p_context"> static int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) /
 			     sizeof(uint64_t));
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1396,7 +1396,7 @@</span> <span class="p_context"> static int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_</span>
 
 	xfrm_state_put(x);
 
<span class="p_del">-	pfkey_broadcast(resp_skb, BROADCAST_ONE, sk, net);</span>
<span class="p_add">+	pfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1483,7 +1483,7 @@</span> <span class="p_context"> static int key_notify_sa(struct xfrm_state *x, const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	hdr-&gt;sadb_msg_pid = c-&gt;portid;
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1596,7 +1596,7 @@</span> <span class="p_context"> static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg</span>
 	out_hdr-&gt;sadb_msg_reserved = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1701,8 +1701,8 @@</span> <span class="p_context"> static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sad</span>
 		return -ENOBUFS;
 	}
 
<span class="p_del">-	pfkey_broadcast(supp_skb, BROADCAST_REGISTERED, sk, sock_net(sk));</span>
<span class="p_del">-</span>
<span class="p_add">+	pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,</span>
<span class="p_add">+			sock_net(sk));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1720,7 +1720,8 @@</span> <span class="p_context"> static int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)</span>
 	hdr-&gt;sadb_msg_errno = (uint8_t) 0;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 
<span class="p_del">-	return pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk,</span>
<span class="p_add">+			       sock_net(sk));</span>
 }
 
 static int key_notify_sa_flush(const struct km_event *c)
<span class="p_chunk">@@ -1741,7 +1742,7 @@</span> <span class="p_context"> static int key_notify_sa_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1798,7 +1799,7 @@</span> <span class="p_context"> static int dump_sa(struct xfrm_state *x, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_portid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -1886,7 +1887,7 @@</span> <span class="p_context"> static int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 		new_hdr-&gt;sadb_msg_errno = 0;
 	}
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2219,7 +2220,7 @@</span> <span class="p_context"> static int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_ev</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	out_hdr-&gt;sadb_msg_pid = c-&gt;portid;
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_ALL, NULL, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2439,7 +2440,7 @@</span> <span class="p_context"> static int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struc</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));</span>
 	err = 0;
 
 out:
<span class="p_chunk">@@ -2695,7 +2696,7 @@</span> <span class="p_context"> static int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_portid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -2752,7 +2753,7 @@</span> <span class="p_context"> static int key_notify_policy_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_satype = SADB_SATYPE_UNSPEC;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
<span class="p_del">-	pfkey_broadcast(skb_out, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2814,7 +2815,7 @@</span> <span class="p_context"> static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 	void *ext_hdrs[SADB_EXT_MAX];
 	int err;
 
<span class="p_del">-	pfkey_broadcast(skb_clone(skb, GFP_KERNEL),</span>
<span class="p_add">+	pfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,</span>
 			BROADCAST_PROMISC_ONLY, NULL, sock_net(sk));
 
 	memset(ext_hdrs, 0, sizeof(ext_hdrs));
<span class="p_chunk">@@ -3036,7 +3037,8 @@</span> <span class="p_context"> static int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)</span>
 	out_hdr-&gt;sadb_msg_seq = 0;
 	out_hdr-&gt;sadb_msg_pid = 0;
 
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,</span>
<span class="p_add">+			xs_net(x));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3226,7 +3228,8 @@</span> <span class="p_context"> static int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct</span>
 		       xfrm_ctx-&gt;ctx_len);
 	}
 
<span class="p_del">-	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,</span>
<span class="p_add">+			       xs_net(x));</span>
 }
 
 static struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,
<span class="p_chunk">@@ -3424,7 +3427,8 @@</span> <span class="p_context"> static int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,</span>
 	n_port-&gt;sadb_x_nat_t_port_port = sport;
 	n_port-&gt;sadb_x_nat_t_port_reserved = 0;
 
<span class="p_del">-	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,</span>
<span class="p_add">+			       xs_net(x));</span>
 }
 
 #ifdef CONFIG_NET_KEY_MIGRATE
<span class="p_chunk">@@ -3616,7 +3620,7 @@</span> <span class="p_context"> static int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,</span>
 	}
 
 	/* broadcast migrate message to sockets */
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, &amp;init_net);</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &amp;init_net);</span>
 
 	return 0;
 
<span class="p_header">diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c</span>
<span class="p_header">index 5b9c884a452e..dde64c4565d2 100644</span>
<span class="p_header">--- a/net/netfilter/nf_nat_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_nat_core.c</span>
<span class="p_chunk">@@ -225,20 +225,21 @@</span> <span class="p_context"> find_appropriate_src(struct net *net,</span>
 		.tuple = tuple,
 		.zone = zone
 	};
<span class="p_del">-	struct rhlist_head *hl;</span>
<span class="p_add">+	struct rhlist_head *hl, *h;</span>
 
 	hl = rhltable_lookup(&amp;nf_nat_bysource_table, &amp;key,
 			     nf_nat_bysource_params);
<span class="p_del">-	if (!hl)</span>
<span class="p_del">-		return 0;</span>
 
<span class="p_del">-	ct = container_of(hl, typeof(*ct), nat_bysource);</span>
<span class="p_add">+	rhl_for_each_entry_rcu(ct, h, hl, nat_bysource) {</span>
<span class="p_add">+		nf_ct_invert_tuplepr(result,</span>
<span class="p_add">+				     &amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span>
<span class="p_add">+		result-&gt;dst = tuple-&gt;dst;</span>
 
<span class="p_del">-	nf_ct_invert_tuplepr(result,</span>
<span class="p_del">-			     &amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span>
<span class="p_del">-	result-&gt;dst = tuple-&gt;dst;</span>
<span class="p_add">+		if (in_range(l3proto, l4proto, result, range))</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	return in_range(l3proto, l4proto, result, range);</span>
<span class="p_add">+	return 0;</span>
 }
 
 /* For [FUTURE] fragmentation handling, we want the least-used
<span class="p_header">diff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c</span>
<span class="p_header">index 4e03f64709bc..05d9f42fc309 100644</span>
<span class="p_header">--- a/net/openvswitch/actions.c</span>
<span class="p_header">+++ b/net/openvswitch/actions.c</span>
<span class="p_chunk">@@ -1240,6 +1240,7 @@</span> <span class="p_context"> int ovs_execute_actions(struct datapath *dp, struct sk_buff *skb,</span>
 		goto out;
 	}
 
<span class="p_add">+	OVS_CB(skb)-&gt;acts_origlen = acts-&gt;orig_len;</span>
 	err = do_execute_actions(dp, skb, key,
 				 acts-&gt;actions, acts-&gt;actions_len);
 
<span class="p_header">diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c</span>
<span class="p_header">index 4d67ea856067..453f806afe6e 100644</span>
<span class="p_header">--- a/net/openvswitch/datapath.c</span>
<span class="p_header">+++ b/net/openvswitch/datapath.c</span>
<span class="p_chunk">@@ -383,7 +383,7 @@</span> <span class="p_context"> static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,</span>
 }
 
 static size_t upcall_msg_size(const struct dp_upcall_info *upcall_info,
<span class="p_del">-			      unsigned int hdrlen)</span>
<span class="p_add">+			      unsigned int hdrlen, int actions_attrlen)</span>
 {
 	size_t size = NLMSG_ALIGN(sizeof(struct ovs_header))
 		+ nla_total_size(hdrlen) /* OVS_PACKET_ATTR_PACKET */
<span class="p_chunk">@@ -400,7 +400,7 @@</span> <span class="p_context"> static size_t upcall_msg_size(const struct dp_upcall_info *upcall_info,</span>
 
 	/* OVS_PACKET_ATTR_ACTIONS */
 	if (upcall_info-&gt;actions_len)
<span class="p_del">-		size += nla_total_size(upcall_info-&gt;actions_len);</span>
<span class="p_add">+		size += nla_total_size(actions_attrlen);</span>
 
 	/* OVS_PACKET_ATTR_MRU */
 	if (upcall_info-&gt;mru)
<span class="p_chunk">@@ -467,7 +467,8 @@</span> <span class="p_context"> static int queue_userspace_packet(struct datapath *dp, struct sk_buff *skb,</span>
 	else
 		hlen = skb-&gt;len;
 
<span class="p_del">-	len = upcall_msg_size(upcall_info, hlen - cutlen);</span>
<span class="p_add">+	len = upcall_msg_size(upcall_info, hlen - cutlen,</span>
<span class="p_add">+			      OVS_CB(skb)-&gt;acts_origlen);</span>
 	user_skb = genlmsg_new(len, GFP_ATOMIC);
 	if (!user_skb) {
 		err = -ENOMEM;
<span class="p_header">diff --git a/net/openvswitch/datapath.h b/net/openvswitch/datapath.h</span>
<span class="p_header">index ab85c1cae255..e19ace428e38 100644</span>
<span class="p_header">--- a/net/openvswitch/datapath.h</span>
<span class="p_header">+++ b/net/openvswitch/datapath.h</span>
<span class="p_chunk">@@ -100,12 +100,14 @@</span> <span class="p_context"> struct datapath {</span>
  * @input_vport: The original vport packet came in on. This value is cached
  * when a packet is received by OVS.
  * @mru: The maximum received fragement size; 0 if the packet is not
<span class="p_add">+ * @acts_origlen: The netlink size of the flow actions applied to this skb.</span>
  * @cutlen: The number of bytes from the packet end to be removed.
  * fragmented.
  */
 struct ovs_skb_cb {
 	struct vport		*input_vport;
 	u16			mru;
<span class="p_add">+	u16			acts_origlen;</span>
 	u32			cutlen;
 };
 #define OVS_CB(skb) ((struct ovs_skb_cb *)(skb)-&gt;cb)
<span class="p_header">diff --git a/net/sched/act_ipt.c b/net/sched/act_ipt.c</span>
<span class="p_header">index a1aec0a6c789..50030519a89b 100644</span>
<span class="p_header">--- a/net/sched/act_ipt.c</span>
<span class="p_header">+++ b/net/sched/act_ipt.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"> static int ipt_init_target(struct xt_entry_target *t, char *table,</span>
 {
 	struct xt_tgchk_param par;
 	struct xt_target *target;
<span class="p_add">+	struct ipt_entry e = {};</span>
 	int ret = 0;
 
 	target = xt_request_find_target(AF_INET, t-&gt;u.user.name,
<span class="p_chunk">@@ -51,6 +52,7 @@</span> <span class="p_context"> static int ipt_init_target(struct xt_entry_target *t, char *table,</span>
 	t-&gt;u.kernel.target = target;
 	memset(&amp;par, 0, sizeof(par));
 	par.table     = table;
<span class="p_add">+	par.entryinfo = &amp;e;</span>
 	par.target    = target;
 	par.targinfo  = t-&gt;data;
 	par.hook_mask = hook;
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index ff27a85a71a9..195a3b2d9afc 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -277,9 +277,6 @@</span> <span class="p_context"> static struct Qdisc *qdisc_match_from_root(struct Qdisc *root, u32 handle)</span>
 void qdisc_hash_add(struct Qdisc *q)
 {
 	if ((q-&gt;parent != TC_H_ROOT) &amp;&amp; !(q-&gt;flags &amp; TCQ_F_INGRESS)) {
<span class="p_del">-		struct Qdisc *root = qdisc_dev(q)-&gt;qdisc;</span>
<span class="p_del">-</span>
<span class="p_del">-		WARN_ON_ONCE(root == &amp;noop_qdisc);</span>
 		ASSERT_RTNL();
 		hash_add_rcu(qdisc_dev(q)-&gt;qdisc_hash, &amp;q-&gt;hash, q-&gt;handle);
 	}
<span class="p_header">diff --git a/net/sched/sch_sfq.c b/net/sched/sch_sfq.c</span>
<span class="p_header">index bc5e99584e41..ea8a56f76b32 100644</span>
<span class="p_header">--- a/net/sched/sch_sfq.c</span>
<span class="p_header">+++ b/net/sched/sch_sfq.c</span>
<span class="p_chunk">@@ -434,6 +434,7 @@</span> <span class="p_context"> sfq_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)</span>
 		qdisc_drop(head, sch, to_free);
 
 		slot_queue_add(slot, skb);
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, 0, delta);</span>
 		return NET_XMIT_CN;
 	}
 
<span class="p_chunk">@@ -465,8 +466,10 @@</span> <span class="p_context"> sfq_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)</span>
 	/* Return Congestion Notification only if we dropped a packet
 	 * from this flow.
 	 */
<span class="p_del">-	if (qlen != slot-&gt;qlen)</span>
<span class="p_add">+	if (qlen != slot-&gt;qlen) {</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, 0, dropped - qdisc_pkt_len(skb));</span>
 		return NET_XMIT_CN;
<span class="p_add">+	}</span>
 
 	/* As we dropped a packet, better let upper stack know this */
 	qdisc_tree_reduce_backlog(sch, 1, dropped);
<span class="p_header">diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c</span>
<span class="p_header">index 0c090600f377..ca4a63e3eadd 100644</span>
<span class="p_header">--- a/net/sctp/ipv6.c</span>
<span class="p_header">+++ b/net/sctp/ipv6.c</span>
<span class="p_chunk">@@ -512,7 +512,9 @@</span> <span class="p_context"> static void sctp_v6_to_addr(union sctp_addr *addr, struct in6_addr *saddr,</span>
 {
 	addr-&gt;sa.sa_family = AF_INET6;
 	addr-&gt;v6.sin6_port = port;
<span class="p_add">+	addr-&gt;v6.sin6_flowinfo = 0;</span>
 	addr-&gt;v6.sin6_addr = *saddr;
<span class="p_add">+	addr-&gt;v6.sin6_scope_id = 0;</span>
 }
 
 /* Compare addresses exactly.
<span class="p_header">diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c</span>
<span class="p_header">index a4bc98265d88..266a30c8b88b 100644</span>
<span class="p_header">--- a/net/sunrpc/svcsock.c</span>
<span class="p_header">+++ b/net/sunrpc/svcsock.c</span>
<span class="p_chunk">@@ -408,6 +408,9 @@</span> <span class="p_context"> static void svc_data_ready(struct sock *sk)</span>
 		dprintk(&quot;svc: socket %p(inet %p), busy=%d\n&quot;,
 			svsk, sk,
 			test_bit(XPT_BUSY, &amp;svsk-&gt;sk_xprt.xpt_flags));
<span class="p_add">+</span>
<span class="p_add">+		/* Refer to svc_setup_socket() for details. */</span>
<span class="p_add">+		rmb();</span>
 		svsk-&gt;sk_odata(sk);
 		if (!test_and_set_bit(XPT_DATA, &amp;svsk-&gt;sk_xprt.xpt_flags))
 			svc_xprt_enqueue(&amp;svsk-&gt;sk_xprt);
<span class="p_chunk">@@ -424,6 +427,9 @@</span> <span class="p_context"> static void svc_write_space(struct sock *sk)</span>
 	if (svsk) {
 		dprintk(&quot;svc: socket %p(inet %p), write_space busy=%d\n&quot;,
 			svsk, sk, test_bit(XPT_BUSY, &amp;svsk-&gt;sk_xprt.xpt_flags));
<span class="p_add">+</span>
<span class="p_add">+		/* Refer to svc_setup_socket() for details. */</span>
<span class="p_add">+		rmb();</span>
 		svsk-&gt;sk_owspace(sk);
 		svc_xprt_enqueue(&amp;svsk-&gt;sk_xprt);
 	}
<span class="p_chunk">@@ -748,8 +754,12 @@</span> <span class="p_context"> static void svc_tcp_listen_data_ready(struct sock *sk)</span>
 	dprintk(&quot;svc: socket %p TCP (listen) state change %d\n&quot;,
 		sk, sk-&gt;sk_state);
 
<span class="p_del">-	if (svsk)</span>
<span class="p_add">+	if (svsk) {</span>
<span class="p_add">+		/* Refer to svc_setup_socket() for details. */</span>
<span class="p_add">+		rmb();</span>
 		svsk-&gt;sk_odata(sk);
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * This callback may called twice when a new connection
 	 * is established as a child socket inherits everything
<span class="p_chunk">@@ -782,6 +792,8 @@</span> <span class="p_context"> static void svc_tcp_state_change(struct sock *sk)</span>
 	if (!svsk)
 		printk(&quot;svc: socket %p: no user data\n&quot;, sk);
 	else {
<span class="p_add">+		/* Refer to svc_setup_socket() for details. */</span>
<span class="p_add">+		rmb();</span>
 		svsk-&gt;sk_ostate(sk);
 		if (sk-&gt;sk_state != TCP_ESTABLISHED) {
 			set_bit(XPT_CLOSE, &amp;svsk-&gt;sk_xprt.xpt_flags);
<span class="p_chunk">@@ -1368,12 +1380,18 @@</span> <span class="p_context"> static struct svc_sock *svc_setup_socket(struct svc_serv *serv,</span>
 		return ERR_PTR(err);
 	}
 
<span class="p_del">-	inet-&gt;sk_user_data = svsk;</span>
 	svsk-&gt;sk_sock = sock;
 	svsk-&gt;sk_sk = inet;
 	svsk-&gt;sk_ostate = inet-&gt;sk_state_change;
 	svsk-&gt;sk_odata = inet-&gt;sk_data_ready;
 	svsk-&gt;sk_owspace = inet-&gt;sk_write_space;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This barrier is necessary in order to prevent race condition</span>
<span class="p_add">+	 * with svc_data_ready(), svc_listen_data_ready() and others</span>
<span class="p_add">+	 * when calling callbacks above.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	wmb();</span>
<span class="p_add">+	inet-&gt;sk_user_data = svsk;</span>
 
 	/* Initialize the socket */
 	if (sock-&gt;type == SOCK_DGRAM)
<span class="p_header">diff --git a/net/tipc/netlink_compat.c b/net/tipc/netlink_compat.c</span>
<span class="p_header">index 1fd464764765..aedc476fac02 100644</span>
<span class="p_header">--- a/net/tipc/netlink_compat.c</span>
<span class="p_header">+++ b/net/tipc/netlink_compat.c</span>
<span class="p_chunk">@@ -258,13 +258,15 @@</span> <span class="p_context"> static int tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump *cmd,</span>
 	arg = nlmsg_new(0, GFP_KERNEL);
 	if (!arg) {
 		kfree_skb(msg-&gt;rep);
<span class="p_add">+		msg-&gt;rep = NULL;</span>
 		return -ENOMEM;
 	}
 
 	err = __tipc_nl_compat_dumpit(cmd, msg, arg);
<span class="p_del">-	if (err)</span>
<span class="p_add">+	if (err) {</span>
 		kfree_skb(msg-&gt;rep);
<span class="p_del">-</span>
<span class="p_add">+		msg-&gt;rep = NULL;</span>
<span class="p_add">+	}</span>
 	kfree_skb(arg);
 
 	return err;
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index fb096cb20a80..995cde48c1be 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -1156,7 +1156,7 @@</span> <span class="p_context"> static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,</span>
 		mutex_lock(&amp;ue-&gt;card-&gt;user_ctl_lock);
 		change = ue-&gt;tlv_data_size != size;
 		if (!change)
<span class="p_del">-			change = memcmp(ue-&gt;tlv_data, new_data, size);</span>
<span class="p_add">+			change = memcmp(ue-&gt;tlv_data, new_data, size) != 0;</span>
 		kfree(ue-&gt;tlv_data);
 		ue-&gt;tlv_data = new_data;
 		ue-&gt;tlv_data_size = size;
<span class="p_header">diff --git a/sound/firewire/iso-resources.c b/sound/firewire/iso-resources.c</span>
<span class="p_header">index f0e4d502d604..066b5df666f4 100644</span>
<span class="p_header">--- a/sound/firewire/iso-resources.c</span>
<span class="p_header">+++ b/sound/firewire/iso-resources.c</span>
<span class="p_chunk">@@ -210,9 +210,14 @@</span> <span class="p_context"> EXPORT_SYMBOL(fw_iso_resources_update);</span>
  */
 void fw_iso_resources_free(struct fw_iso_resources *r)
 {
<span class="p_del">-	struct fw_card *card = fw_parent_device(r-&gt;unit)-&gt;card;</span>
<span class="p_add">+	struct fw_card *card;</span>
 	int bandwidth, channel;
 
<span class="p_add">+	/* Not initialized. */</span>
<span class="p_add">+	if (r-&gt;unit == NULL)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	card = fw_parent_device(r-&gt;unit)-&gt;card;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;r-&gt;mutex);
 
 	if (r-&gt;allocated) {
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index c15c51bea26d..f2e4e99ce651 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -854,6 +854,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x390b, &quot;Lenovo G50-80&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x3975, &quot;Lenovo U300s&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;Lenovo IdeaPad U310&quot;, CXT_FIXUP_STEREO_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;Lenovo G50-70&quot;, CXT_FIXUP_STEREO_DMIC),</span>
 	SND_PCI_QUIRK(0x17aa, 0x397b, &quot;Lenovo S205&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK_VENDOR(0x17aa, &quot;Thinkpad&quot;, CXT_FIXUP_THINKPAD_ACPI),
 	SND_PCI_QUIRK(0x1c06, 0x2011, &quot;Lemote A1004&quot;, CXT_PINCFG_LEMOTE_A1004),
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 95c2749ac8a3..286efc3a6116 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1309,10 +1309,13 @@</span> <span class="p_context"> void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,</span>
 	    &amp;&amp; (requesttype &amp; USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
<span class="p_del">-	/* Zoom R16/24 needs a tiny delay here, otherwise requests like</span>
<span class="p_del">-	 * get/set frequency return as failed despite actually succeeding.</span>
<span class="p_add">+	/* Zoom R16/24, Logitech H650e, Jabra 550a needs a tiny delay here,</span>
<span class="p_add">+	 * otherwise requests like get/set frequency return as failed despite</span>
<span class="p_add">+	 * actually succeeding.</span>
 	 */
<span class="p_del">-	if (chip-&gt;usb_id == USB_ID(0x1686, 0x00dd) &amp;&amp;</span>
<span class="p_add">+	if ((chip-&gt;usb_id == USB_ID(0x1686, 0x00dd) ||</span>
<span class="p_add">+	     chip-&gt;usb_id == USB_ID(0x046d, 0x0a46) ||</span>
<span class="p_add">+	     chip-&gt;usb_id == USB_ID(0x0b0e, 0x0349)) &amp;&amp;</span>
 	    (requesttype &amp; USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(1);
 }
<span class="p_header">diff --git a/tools/perf/util/probe-event.c b/tools/perf/util/probe-event.c</span>
<span class="p_header">index 6c50d9f8e210..6a6f44dd594b 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-event.c</span>
<span class="p_header">+++ b/tools/perf/util/probe-event.c</span>
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> static struct map *kernel_get_module_map(const char *module)</span>
 
 	/* A file path -- this is an offline module */
 	if (module &amp;&amp; strchr(module, &#39;/&#39;))
<span class="p_del">-		return machine__findnew_module_map(host_machine, 0, module);</span>
<span class="p_add">+		return dso__new_map(module);</span>
 
 	if (!module)
 		module = &quot;kernel&quot;;
<span class="p_chunk">@@ -173,6 +173,7 @@</span> <span class="p_context"> static struct map *kernel_get_module_map(const char *module)</span>
 		if (strncmp(pos-&gt;dso-&gt;short_name + 1, module,
 			    pos-&gt;dso-&gt;short_name_len - 2) == 0 &amp;&amp;
 		    module[pos-&gt;dso-&gt;short_name_len - 2] == &#39;\0&#39;) {
<span class="p_add">+			map__get(pos);</span>
 			return pos;
 		}
 	}
<span class="p_chunk">@@ -188,15 +189,6 @@</span> <span class="p_context"> struct map *get_target_map(const char *target, bool user)</span>
 		return kernel_get_module_map(target);
 }
 
<span class="p_del">-static void put_target_map(struct map *map, bool user)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (map &amp;&amp; user) {</span>
<span class="p_del">-		/* Only the user map needs to be released */</span>
<span class="p_del">-		map__put(map);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 static int convert_exec_to_group(const char *exec, char **result)
 {
 	char *ptr1, *ptr2, *exec_copy;
<span class="p_chunk">@@ -412,7 +404,7 @@</span> <span class="p_context"> static int find_alternative_probe_point(struct debuginfo *dinfo,</span>
 	}
 
 out:
<span class="p_del">-	put_target_map(map, uprobes);</span>
<span class="p_add">+	map__put(map);</span>
 	return ret;
 
 }
<span class="p_chunk">@@ -2944,7 +2936,7 @@</span> <span class="p_context"> static int find_probe_trace_events_from_map(struct perf_probe_event *pev,</span>
 	}
 
 out:
<span class="p_del">-	put_target_map(map, pev-&gt;uprobes);</span>
<span class="p_add">+	map__put(map);</span>
 	free(syms);
 	return ret;
 
<span class="p_chunk">@@ -3437,10 +3429,7 @@</span> <span class="p_context"> int show_available_funcs(const char *target, struct strfilter *_filter,</span>
 		return ret;
 
 	/* Get a symbol map */
<span class="p_del">-	if (user)</span>
<span class="p_del">-		map = dso__new_map(target);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		map = kernel_get_module_map(target);</span>
<span class="p_add">+	map = get_target_map(target, user);</span>
 	if (!map) {
 		pr_err(&quot;Failed to get a map for %s\n&quot;, (target) ? : &quot;kernel&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -3472,9 +3461,7 @@</span> <span class="p_context"> int show_available_funcs(const char *target, struct strfilter *_filter,</span>
         }
 
 end:
<span class="p_del">-	if (user) {</span>
<span class="p_del">-		map__put(map);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	map__put(map);</span>
 	exit_probe_symbol_maps();
 
 	return ret;
<span class="p_header">diff --git a/tools/testing/selftests/ntb/ntb_test.sh b/tools/testing/selftests/ntb/ntb_test.sh</span>
<span class="p_header">index a676d3eefefb..b3c48fc6ea4b 100755</span>
<span class="p_header">--- a/tools/testing/selftests/ntb/ntb_test.sh</span>
<span class="p_header">+++ b/tools/testing/selftests/ntb/ntb_test.sh</span>
<span class="p_chunk">@@ -305,7 +305,7 @@</span> <span class="p_context"> function perf_test()</span>
 	echo &quot;Running remote perf test $WITH DMA&quot;
 	write_file &quot;&quot; $REMOTE_PERF/run
 	echo -n &quot;  &quot;
<span class="p_del">-	read_file $LOCAL_PERF/run</span>
<span class="p_add">+	read_file $REMOTE_PERF/run</span>
 	echo &quot;  Passed&quot;
 
 	_modprobe -r ntb_perf
<span class="p_chunk">@@ -326,6 +326,10 @@</span> <span class="p_context"> function ntb_tool_tests()</span>
 	link_test $LOCAL_TOOL $REMOTE_TOOL
 	link_test $REMOTE_TOOL $LOCAL_TOOL
 
<span class="p_add">+	#Ensure the link is up on both sides before continuing</span>
<span class="p_add">+	write_file Y $LOCAL_TOOL/link_event</span>
<span class="p_add">+	write_file Y $REMOTE_TOOL/link_event</span>
<span class="p_add">+</span>
 	for PEER_TRANS in $(ls $LOCAL_TOOL/peer_trans*); do
 		PT=$(basename $PEER_TRANS)
 		write_file $MW_SIZE $LOCAL_TOOL/$PT

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



