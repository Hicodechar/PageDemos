
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>No check of the size passed to unmap_single in swiotlb - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    No check of the size passed to unmap_single in swiotlb</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=177439">Eric Yang</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 20, 2017, 8:17 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;VI1PR04MB30715EA7212DC661481041438C220@VI1PR04MB3071.eurprd04.prod.outlook.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10066149/mbox/"
   >mbox</a>
|
   <a href="/patch/10066149/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10066149/">/patch/10066149/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	EB4DD602B7 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Nov 2017 08:17:34 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D759228E87
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Nov 2017 08:17:34 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id CB78B28EDD; Mon, 20 Nov 2017 08:17:34 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2E57928E87
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Nov 2017 08:17:34 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751027AbdKTIRS (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 20 Nov 2017 03:17:18 -0500
Received: from mail-he1eur01on0046.outbound.protection.outlook.com
	([104.47.0.46]:53959
	&quot;EHLO EUR01-HE1-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1750764AbdKTIRR (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 20 Nov 2017 03:17:17 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=nxp.com; s=selector1;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version;
	bh=/zi/GOk0T/R2n9uT7rjMSd20Z9CHTJjjqTM2k6DTHYc=;
	b=IfJQwztRwm4xPEiLCDxzK8xSG0cWxkX0TPgrwlYatxsEUA4AgwAB+JLpfQWpLjECPN6j6u7/cNli+AqPLaMB4OlmhZMrOMirAshTnn9ZFCO8TcPwUggOcQGbZZo83HO7Ti4p51raMvd1P8w8IIyLnw4rttvMtikLDulkvCtR2B0=
Received: from VI1PR04MB3071.eurprd04.prod.outlook.com (10.170.228.157) by
	VI1PR04MB3070.eurprd04.prod.outlook.com (10.170.228.156) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256) id
	15.20.239.5; Mon, 20 Nov 2017 08:17:14 +0000
Received: from VI1PR04MB3071.eurprd04.prod.outlook.com
	([fe80::29dc:fa09:1c1e:ddda]) by
	VI1PR04MB3071.eurprd04.prod.outlook.com
	([fe80::29dc:fa09:1c1e:ddda%13]) with mapi id 15.20.0239.009;
	Mon, 20 Nov 2017 08:17:14 +0000
From: Eric Yang &lt;yu.yang_3@nxp.com&gt;
To: Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;,
	&quot;linux-kernel@vger.kernel.org&quot; &lt;linux-kernel@vger.kernel.org&gt;
CC: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;,
	&quot;David Miller&quot; &lt;davem@davemloft.net&gt;, Ingo Molnar &lt;mingo@kernel.org&gt;,
	&quot;Geert Uytterhoeven&quot; &lt;geert+renesas@glider.be&gt;,
	Al Viro &lt;viro@zeniv.linux.org.uk&gt;, Kees Cook &lt;keescook@chromium.org&gt;,
	Daniel Borkmann &lt;daniel@iogearbox.net&gt;
Subject: No check of the size passed to unmap_single in  swiotlb
Thread-Topic: No check of the size passed to unmap_single in  swiotlb
Thread-Index: AdNh05mpL3q0b1UiSnuB7T/tq+hwNw==
Date: Mon, 20 Nov 2017 08:17:14 +0000
Message-ID: &lt;VI1PR04MB30715EA7212DC661481041438C220@VI1PR04MB3071.eurprd04.prod.outlook.com&gt;
Accept-Language: zh-CN, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
authentication-results: spf=none (sender IP is )
	smtp.mailfrom=yu.yang_3@nxp.com; 
x-originating-ip: [199.59.231.64]
x-ms-publictraffictype: Email
x-microsoft-exchange-diagnostics: 1; VI1PR04MB3070;
	6:54si35exFwVlNOjHbg5UCWRS7hNrz+V/y4LpnP+CpBZfySinrGmgxUz+IHwN6hcMh7GpAMrUKpY+jTRINrWZ8q3z45IJzRklT0F1wqV46yy2Imedom5aDAA6MZ2aWFPeWm+Q4J1fzLAfYTZ9t5DqLLJudJdXs/GpwXH55NdKjpMWKrsvPTSI4GVmfq69s2LWZBI41by4t3jNrZE+jnoH/BRlQ2XqmiJ1OecAvTjAZDzzYwghTkUb/2dNhawG6dCdXqg/WQXPsAFs554lgvonE7DwHGljbEXZKRoQg2rEa4UxNIoioZZ9Mt3HA598RXg0MuuyAFazUjHKjd0Je69WCeYvZH6nN6DvPRvHmcgiHXQ=;
	5:xJqNU29NHdgbKxNXY4z2PuWdcJ8H5tgI3uR/VJfGNald01OBN+4umzUfKqo7V2ys3aB9E6P6+sI1U7Zp3BCCBqjnJdFazwWfMPBv9k6A54Kfft/klNAtYG0yvPSXBZCBHO+/NrPvV8LaKLQmtixMzKMm0WKmpxMO36/RLwOwvlw=;
	24:gAth2iEas93w4iIiFuCyvbZ3zO2DGDGrHz4hSFrLtjjyc3KNXiBOhEJvyKy83XociJ2yh9txG+WFH0lBJNm7Wriwgg7nExvj3VGBpNBkqcM=;
	7:Pa7X42vbB7FKXVyTQJZs+QO4r/BRmNrMnK1VWY8YK38LNQ2eeE1vMv+sdVLFKw2uNH5ZCqJiM6IgjsOBNL2EUTwfroakw0SbDwBjnnFEJMjVjkriyrtA1pyuELiwZcVbNsN4hm45+NK4H94HgLuiGjYod4yXJUE4O7NkeksPNEBRo1XfpXZnj4g+FIjOpCFFzAHjKCx/NfdVc9XLPQYy17tvt/z9A9WLh3NoedTInxKWKgETzFNPP+U9trlW/ggq
x-ms-exchange-antispam-srfa-diagnostics: SSOS;
x-ms-office365-filtering-correlation-id: 78c2ffba-422e-4665-1e03-08d52fef1b29
x-ms-office365-filtering-ht: Tenant
x-microsoft-antispam: UriScan:; BCL:0; PCL:0;
	RULEID:(22001)(4534020)(4602075)(4627115)(201703031133081)(201702281549075)(48565401081)(2017052603258);
	SRVR:VI1PR04MB3070; 
x-ms-traffictypediagnostic: VI1PR04MB3070:
x-microsoft-antispam-prvs: &lt;VI1PR04MB30700BE8DC6140002F7424558C220@VI1PR04MB3070.eurprd04.prod.outlook.com&gt;
x-exchange-antispam-report-test: UriScan:;
x-exchange-antispam-report-cfa-test: BCL:0; PCL:0;
	RULEID:(100000700101)(100105000095)(100000701101)(100105300095)(100000702101)(100105100095)(6040450)(2401047)(8121501046)(5005006)(3231022)(93006095)(93001095)(10201501046)(3002001)(100000703101)(100105400095)(6055026)(6041248)(20161123558100)(20161123560025)(201703131423075)(201702281528075)(201703061421075)(201703061406153)(20161123555025)(20161123564025)(20161123562025)(6072148)(201708071742011)(100000704101)(100105200095)(100000705101)(100105500095);
	SRVR:VI1PR04MB3070; BCL:0; PCL:0;
	RULEID:(100000800101)(100110000095)(100000801101)(100110300095)(100000802101)(100110100095)(100000803101)(100110400095)(100000804101)(100110200095)(100000805101)(100110500095);
	SRVR:VI1PR04MB3070; 
x-forefront-prvs: 04976078F0
x-forefront-antispam-report: SFV:NSPM;
	SFS:(10009020)(6009001)(346002)(376002)(39860400002)(53754006)(189002)(199003)(3660700001)(54356999)(50986999)(3280700002)(2906002)(7736002)(305945005)(99286004)(3846002)(102836003)(6116002)(2501003)(316002)(74316002)(81156014)(81166006)(54906003)(7416002)(33656002)(66066001)(101416001)(8676002)(106356001)(105586002)(7696004)(5660300001)(6506006)(97736004)(5250100002)(6436002)(9686003)(478600001)(14454004)(189998001)(86362001)(53936002)(68736007)(8936002)(55016002)(25786009)(4326008)(2900100001)(110136005);
	DIR:OUT; SFP:1101; SCL:1; SRVR:VI1PR04MB3070;
	H:VI1PR04MB3071.eurprd04.prod.outlook.com; FPR:; SPF:None;
	PTR:InfoNoRecords; MX:1; A:1; LANG:en; 
received-spf: None (protection.outlook.com: nxp.com does not designate
	permitted sender hosts)
spamdiagnosticoutput: 1:99
spamdiagnosticmetadata: NSPM
Content-Type: text/plain; charset=&quot;us-ascii&quot;
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-OriginatorOrg: nxp.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 78c2ffba-422e-4665-1e03-08d52fef1b29
X-MS-Exchange-CrossTenant-originalarrivaltime: 20 Nov 2017 08:17:14.0755
	(UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: 686ea1d3-bc2b-4c6f-a92c-d99c5c301635
X-MS-Exchange-Transport-CrossTenantHeadersStamped: VI1PR04MB3070
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=177439">Eric Yang</a> - Nov. 20, 2017, 8:17 a.m.</div>
<pre class="content">
Hi all,

During debug a  device only support 32bits DMA(Qualcomm Atheros AP) in our LS1043A 64bits ARM  SOC, we found that the invoke of dma_unmap_single --&gt; swiotlb_tbl_unmap_single  will unmap the passed &quot;size&quot; anyway even when the &quot;size&quot; is incorrect.

If the size is larger than it should, the extra entries in io_tlb_orig_addr array will be refilled by INVALID_PHYS_ADDR, and it will cause the bounce buffer copy not happen when the one who really used the mis-freed entries doing  DMA data transfers, and this will cause further unknow behaviors.

Here we just fix it temporarily by adding a judge of the &quot;size&quot; in the swiotlb_tbl_unmap_single, if it is larger than it deserves, just unmap the right size only. Like the code:

[yangyu@titan dash-lts]$ git diff ./lib/swiotlb.c

Although pass a right size of DMA buffer is the responsibility of  the drivers, but Is it useful to add some size check code to prevent  real damage happen? 

Regards,
Eric
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=3407">Konrad Rzeszutek Wilk</a> - Nov. 20, 2017, 4:26 p.m.</div>
<pre class="content">
On Mon, Nov 20, 2017 at 08:17:14AM +0000, Eric Yang wrote:
<span class="quote">&gt; Hi all,</span>

Hi!
<span class="quote">&gt; </span>
<span class="quote">&gt; During debug a  device only support 32bits DMA(Qualcomm Atheros AP) in our LS1043A 64bits ARM  SOC, we found that the invoke of dma_unmap_single --&gt; swiotlb_tbl_unmap_single  will unmap the passed &quot;size&quot; anyway even when the &quot;size&quot; is incorrect.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If the size is larger than it should, the extra entries in io_tlb_orig_addr array will be refilled by INVALID_PHYS_ADDR, and it will cause the bounce buffer copy not happen when the one who really used the mis-freed entries doing  DMA data transfers, and this will cause further unknow behaviors.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Here we just fix it temporarily by adding a judge of the &quot;size&quot; in the swiotlb_tbl_unmap_single, if it is larger than it deserves, just unmap the right size only. Like the code:</span>

Did the DMA debug API (CONFIG_DMA_API_DEBUG) help in figuring this issue as well?
<span class="quote">
&gt; </span>
<span class="quote">&gt; [yangyu@titan dash-lts]$ git diff ./lib/swiotlb.c</span>
<span class="quote">&gt; diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="quote">&gt; index ad1d2962d129..58c97ede9d78 100644</span>
<span class="quote">&gt; --- a/lib/swiotlb.c</span>
<span class="quote">&gt; +++ b/lib/swiotlb.c</span>
<span class="quote">&gt; @@ -591,7 +591,10 @@ void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,</span>
<span class="quote">&gt;                  */</span>
<span class="quote">&gt;                 for (i = index + nslots - 1; i &gt;= index; i--) {</span>
<span class="quote">&gt;                         io_tlb_list[i] = ++count;</span>
<span class="quote">&gt; -                       io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt; +                      if(io_tlb_orig_addr[i]  != orig_addr)</span>
<span class="quote">&gt; +                          printk(&quot;======size wrong, ally down ally down!===\n&quot;);</span>
<span class="quote">&gt; +                      else</span>
<span class="quote">&gt; +                         io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt;                 }</span>
<span class="quote">&gt;                 /*</span>
<span class="quote">&gt;                  * Step 2: merge the returned slots with the preceding slots,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Although pass a right size of DMA buffer is the responsibility of  the drivers, but Is it useful to add some size check code to prevent  real damage happen? </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Regards,</span>
<span class="quote">&gt; Eric</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - Nov. 20, 2017, 4:50 p.m.</div>
<pre class="content">
On 20/11/17 16:26, Konrad Rzeszutek Wilk wrote:
<span class="quote">&gt; On Mon, Nov 20, 2017 at 08:17:14AM +0000, Eric Yang wrote:</span>
<span class="quote">&gt;&gt; Hi all,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi!</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; During debug a  device only support 32bits DMA(Qualcomm Atheros AP) in our LS1043A 64bits ARM  SOC, we found that the invoke of dma_unmap_single --&gt; swiotlb_tbl_unmap_single  will unmap the passed &quot;size&quot; anyway even when the &quot;size&quot; is incorrect.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; If the size is larger than it should, the extra entries in io_tlb_orig_addr array will be refilled by INVALID_PHYS_ADDR, and it will cause the bounce buffer copy not happen when the one who really used the mis-freed entries doing  DMA data transfers, and this will cause further unknow behaviors.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Here we just fix it temporarily by adding a judge of the &quot;size&quot; in the swiotlb_tbl_unmap_single, if it is larger than it deserves, just unmap the right size only. Like the code:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Did the DMA debug API (CONFIG_DMA_API_DEBUG) help in figuring this issue as well?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; [yangyu@titan dash-lts]$ git diff ./lib/swiotlb.c</span>
<span class="quote">&gt;&gt; diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="quote">&gt;&gt; index ad1d2962d129..58c97ede9d78 100644</span>
<span class="quote">&gt;&gt; --- a/lib/swiotlb.c</span>
<span class="quote">&gt;&gt; +++ b/lib/swiotlb.c</span>
<span class="quote">&gt;&gt; @@ -591,7 +591,10 @@ void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,</span>
<span class="quote">&gt;&gt;                   */</span>
<span class="quote">&gt;&gt;                  for (i = index + nslots - 1; i &gt;= index; i--) {</span>
<span class="quote">&gt;&gt;                          io_tlb_list[i] = ++count;</span>
<span class="quote">&gt;&gt; -                       io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt;&gt; +                      if(io_tlb_orig_addr[i]  != orig_addr)</span>
<span class="quote">&gt;&gt; +                          printk(&quot;======size wrong, ally down ally down!===\n&quot;);</span>
<span class="quote">&gt;&gt; +                      else</span>
<span class="quote">&gt;&gt; +                         io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt;&gt;                  }</span>
<span class="quote">&gt;&gt;                  /*</span>
<span class="quote">&gt;&gt;                   * Step 2: merge the returned slots with the preceding slots,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Although pass a right size of DMA buffer is the responsibility of  the drivers, but Is it useful to add some size check code to prevent  real damage happen?</span>

There doesn&#39;t seem to be much good reason for SWIOTLB to be more special 
than other DMA API backends, and not all of them have enough internal 
state to be able to make such a check. It&#39;s also not necessarily 
possible to &quot;prevent damage&quot; anyway - if a driver does pass a bogus size 
for dma_unmap_single(..., DMA_FROM_DEVICE), SWIOTLB might be able to 
keep itself internally consistent, but it still can&#39;t prevent the arch 
code in the middle from invalidating the wrong cache lines and 
potentially corrupting adjacent memory.

In short, trying to work around broken drivers is a much worse idea than 
just fixing those drivers, and that&#39;s what we already have dma-debug for.

Robin.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=177439">Eric Yang</a> - Nov. 22, 2017, 3:23 a.m.</div>
<pre class="content">
<span class="quote">&gt; -----Original Message-----</span>
<span class="quote">&gt; From: Konrad Rzeszutek Wilk [mailto:konrad.wilk@oracle.com]</span>
<span class="quote">&gt; Sent: Tuesday, November 21, 2017 12:27 AM</span>
<span class="quote">&gt; To: Eric Yang &lt;yu.yang_3@nxp.com&gt;; iommu@lists.linux-foundation.org</span>
<span class="quote">&gt; Cc: linux-kernel@vger.kernel.org; Greg Kroah-Hartman</span>
<span class="quote">&gt; &lt;gregkh@linuxfoundation.org&gt;; Andrew Morton &lt;akpm@linux-foundation.org&gt;;</span>
<span class="quote">&gt; Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;; David Miller</span>
<span class="quote">&gt; &lt;davem@davemloft.net&gt;; Ingo Molnar &lt;mingo@kernel.org&gt;; Geert</span>
<span class="quote">&gt; Uytterhoeven &lt;geert+renesas@glider.be&gt;; Al Viro &lt;viro@zeniv.linux.org.uk&gt;;</span>
<span class="quote">&gt; Kees Cook &lt;keescook@chromium.org&gt;; Daniel Borkmann</span>
<span class="quote">&gt; &lt;daniel@iogearbox.net&gt;</span>
<span class="quote">&gt; Subject: Re: No check of the size passed to unmap_single in swiotlb</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Mon, Nov 20, 2017 at 08:17:14AM +0000, Eric Yang wrote:</span>
<span class="quote">&gt; &gt; Hi all,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi!</span>

Hi  Konrad,
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; During debug a  device only support 32bits DMA(Qualcomm Atheros AP) in our</span>
<span class="quote">&gt; LS1043A 64bits ARM  SOC, we found that the invoke of dma_unmap_single --&gt;</span>
<span class="quote">&gt; swiotlb_tbl_unmap_single  will unmap the passed &quot;size&quot; anyway even when the</span>
<span class="quote">&gt; &quot;size&quot; is incorrect.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; If the size is larger than it should, the extra entries in io_tlb_orig_addr array</span>
<span class="quote">&gt; will be refilled by INVALID_PHYS_ADDR, and it will cause the bounce buffer copy</span>
<span class="quote">&gt; not happen when the one who really used the mis-freed entries doing  DMA data</span>
<span class="quote">&gt; transfers, and this will cause further unknow behaviors.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Here we just fix it temporarily by adding a judge of the &quot;size&quot; in the</span>
<span class="quote">&gt; swiotlb_tbl_unmap_single, if it is larger than it deserves, just unmap the right</span>
<span class="quote">&gt; size only. Like the code:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Did the DMA debug API (CONFIG_DMA_API_DEBUG) help in figuring this issue as</span>
<span class="quote">&gt; well?</span>
<span class="quote">&gt; </span>

I have just enabled this config and move off the kernel fix and test, there seems the debug API 
has no output for this size incorrect issue. For I only enable the config and no other operations 
and my kernel is 4.9, do I missed something?

I confirm that the debug API is working, for there are other drivers triggered its warning output 
like:
 
caam_jr 1710000.jr: DMA-API: device driver tries to free DMA memory it has not allocated 
[device address=0x6800458400000000]
<span class="quote">
&gt; &gt;</span>
<span class="quote">&gt; &gt; [yangyu@titan dash-lts]$ git diff ./lib/swiotlb.c diff --git</span>
<span class="quote">&gt; &gt; a/lib/swiotlb.c b/lib/swiotlb.c index ad1d2962d129..58c97ede9d78</span>
<span class="quote">&gt; &gt; 100644</span>
<span class="quote">&gt; &gt; --- a/lib/swiotlb.c</span>
<span class="quote">&gt; &gt; +++ b/lib/swiotlb.c</span>
<span class="quote">&gt; &gt; @@ -591,7 +591,10 @@ void swiotlb_tbl_unmap_single(struct device *hwdev,</span>
<span class="quote">&gt; phys_addr_t tlb_addr,</span>
<span class="quote">&gt; &gt;                  */</span>
<span class="quote">&gt; &gt;                 for (i = index + nslots - 1; i &gt;= index; i--) {</span>
<span class="quote">&gt; &gt;                         io_tlb_list[i] = ++count;</span>
<span class="quote">&gt; &gt; -                       io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt; &gt; +                      if(io_tlb_orig_addr[i]  != orig_addr)</span>
<span class="quote">&gt; &gt; +                          printk(&quot;======size wrong, ally down ally down!===\n&quot;);</span>
<span class="quote">&gt; &gt; +                      else</span>
<span class="quote">&gt; &gt; +                         io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt; &gt;                 }</span>
<span class="quote">&gt; &gt;                 /*</span>
<span class="quote">&gt; &gt;                  * Step 2: merge the returned slots with the preceding</span>
<span class="quote">&gt; &gt; slots,</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Although pass a right size of DMA buffer is the responsibility of  the drivers, but</span>
<span class="quote">&gt; Is it useful to add some size check code to prevent  real damage happen?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Regards,</span>
<span class="quote">&gt; &gt; Eric</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - Nov. 22, 2017, 1:15 p.m.</div>
<pre class="content">
On 22/11/17 03:23, Eric Yang wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; -----Original Message-----</span>
<span class="quote">&gt;&gt; From: Konrad Rzeszutek Wilk [mailto:konrad.wilk@oracle.com]</span>
<span class="quote">&gt;&gt; Sent: Tuesday, November 21, 2017 12:27 AM</span>
<span class="quote">&gt;&gt; To: Eric Yang &lt;yu.yang_3@nxp.com&gt;; iommu@lists.linux-foundation.org</span>
<span class="quote">&gt;&gt; Cc: linux-kernel@vger.kernel.org; Greg Kroah-Hartman</span>
<span class="quote">&gt;&gt; &lt;gregkh@linuxfoundation.org&gt;; Andrew Morton &lt;akpm@linux-foundation.org&gt;;</span>
<span class="quote">&gt;&gt; Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;; David Miller</span>
<span class="quote">&gt;&gt; &lt;davem@davemloft.net&gt;; Ingo Molnar &lt;mingo@kernel.org&gt;; Geert</span>
<span class="quote">&gt;&gt; Uytterhoeven &lt;geert+renesas@glider.be&gt;; Al Viro &lt;viro@zeniv.linux.org.uk&gt;;</span>
<span class="quote">&gt;&gt; Kees Cook &lt;keescook@chromium.org&gt;; Daniel Borkmann</span>
<span class="quote">&gt;&gt; &lt;daniel@iogearbox.net&gt;</span>
<span class="quote">&gt;&gt; Subject: Re: No check of the size passed to unmap_single in swiotlb</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Mon, Nov 20, 2017 at 08:17:14AM +0000, Eric Yang wrote:</span>
<span class="quote">&gt;&gt;&gt; Hi all,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hi!</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi  Konrad,</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; During debug a  device only support 32bits DMA(Qualcomm Atheros AP) in our</span>
<span class="quote">&gt;&gt; LS1043A 64bits ARM  SOC, we found that the invoke of dma_unmap_single --&gt;</span>
<span class="quote">&gt;&gt; swiotlb_tbl_unmap_single  will unmap the passed &quot;size&quot; anyway even when the</span>
<span class="quote">&gt;&gt; &quot;size&quot; is incorrect.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; If the size is larger than it should, the extra entries in io_tlb_orig_addr array</span>
<span class="quote">&gt;&gt; will be refilled by INVALID_PHYS_ADDR, and it will cause the bounce buffer copy</span>
<span class="quote">&gt;&gt; not happen when the one who really used the mis-freed entries doing  DMA data</span>
<span class="quote">&gt;&gt; transfers, and this will cause further unknow behaviors.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Here we just fix it temporarily by adding a judge of the &quot;size&quot; in the</span>
<span class="quote">&gt;&gt; swiotlb_tbl_unmap_single, if it is larger than it deserves, just unmap the right</span>
<span class="quote">&gt;&gt; size only. Like the code:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Did the DMA debug API (CONFIG_DMA_API_DEBUG) help in figuring this issue as</span>
<span class="quote">&gt;&gt; well?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I have just enabled this config and move off the kernel fix and test, there seems the debug API</span>
<span class="quote">&gt; has no output for this size incorrect issue. For I only enable the config and no other operations</span>
<span class="quote">&gt; and my kernel is 4.9, do I missed something?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I confirm that the debug API is working, for there are other drivers triggered its warning output</span>
<span class="quote">&gt; like:</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; caam_jr 1710000.jr: DMA-API: device driver tries to free DMA memory it has not allocated</span>
<span class="quote">&gt; [device address=0x6800458400000000]</span>

By default, dma-debug will only log the first error it sees - you can 
adjust this with the &quot;num_errors&quot; or &quot;all_errors&quot; sysfs controls, and 
use the driver filter to hide errors from other drivers if necessary.

Robin.
<span class="quote">
&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; [yangyu@titan dash-lts]$ git diff ./lib/swiotlb.c diff --git</span>
<span class="quote">&gt;&gt;&gt; a/lib/swiotlb.c b/lib/swiotlb.c index ad1d2962d129..58c97ede9d78</span>
<span class="quote">&gt;&gt;&gt; 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/lib/swiotlb.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/lib/swiotlb.c</span>
<span class="quote">&gt;&gt;&gt; @@ -591,7 +591,10 @@ void swiotlb_tbl_unmap_single(struct device *hwdev,</span>
<span class="quote">&gt;&gt; phys_addr_t tlb_addr,</span>
<span class="quote">&gt;&gt;&gt;                   */</span>
<span class="quote">&gt;&gt;&gt;                  for (i = index + nslots - 1; i &gt;= index; i--) {</span>
<span class="quote">&gt;&gt;&gt;                          io_tlb_list[i] = ++count;</span>
<span class="quote">&gt;&gt;&gt; -                       io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt;&gt;&gt; +                      if(io_tlb_orig_addr[i]  != orig_addr)</span>
<span class="quote">&gt;&gt;&gt; +                          printk(&quot;======size wrong, ally down ally down!===\n&quot;);</span>
<span class="quote">&gt;&gt;&gt; +                      else</span>
<span class="quote">&gt;&gt;&gt; +                         io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt;&gt;&gt;                  }</span>
<span class="quote">&gt;&gt;&gt;                  /*</span>
<span class="quote">&gt;&gt;&gt;                   * Step 2: merge the returned slots with the preceding</span>
<span class="quote">&gt;&gt;&gt; slots,</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Although pass a right size of DMA buffer is the responsibility of  the drivers, but</span>
<span class="quote">&gt;&gt; Is it useful to add some size check code to prevent  real damage happen?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Regards,</span>
<span class="quote">&gt;&gt;&gt; Eric</span>
<span class="quote">&gt; _______________________________________________</span>
<span class="quote">&gt; iommu mailing list</span>
<span class="quote">&gt; iommu@lists.linux-foundation.org</span>
<span class="quote">&gt; https://lists.linuxfoundation.org/mailman/listinfo/iommu</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=177439">Eric Yang</a> - Nov. 23, 2017, 7:47 a.m.</div>
<pre class="content">
<span class="quote">&gt; -----Original Message-----</span>
<span class="quote">&gt; From: Robin Murphy [mailto:robin.murphy@arm.com]</span>
<span class="quote">&gt; Sent: Wednesday, November 22, 2017 9:15 PM</span>
<span class="quote">&gt; To: Eric Yang &lt;yu.yang_3@nxp.com&gt;; Konrad Rzeszutek Wilk</span>
<span class="quote">&gt; &lt;konrad.wilk@oracle.com&gt;; iommu@lists.linux-foundation.org</span>
<span class="quote">&gt; Cc: Daniel Borkmann &lt;daniel@iogearbox.net&gt;; Kees Cook</span>
<span class="quote">&gt; &lt;keescook@chromium.org&gt;; Geert Uytterhoeven &lt;geert+renesas@glider.be&gt;;</span>
<span class="quote">&gt; Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;; linux-</span>
<span class="quote">&gt; kernel@vger.kernel.org; David Miller &lt;davem@davemloft.net&gt;; Al Viro</span>
<span class="quote">&gt; &lt;viro@zeniv.linux.org.uk&gt;; Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;;</span>
<span class="quote">&gt; Andrew Morton &lt;akpm@linux-foundation.org&gt;; Ingo Molnar</span>
<span class="quote">&gt; &lt;mingo@kernel.org&gt;</span>
<span class="quote">&gt; Subject: Re: No check of the size passed to unmap_single in swiotlb</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 22/11/17 03:23, Eric Yang wrote:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; -----Original Message-----</span>
<span class="quote">&gt; &gt;&gt; From: Konrad Rzeszutek Wilk [mailto:konrad.wilk@oracle.com]</span>
<span class="quote">&gt; &gt;&gt; Sent: Tuesday, November 21, 2017 12:27 AM</span>
<span class="quote">&gt; &gt;&gt; To: Eric Yang &lt;yu.yang_3@nxp.com&gt;; iommu@lists.linux-foundation.org</span>
<span class="quote">&gt; &gt;&gt; Cc: linux-kernel@vger.kernel.org; Greg Kroah-Hartman</span>
<span class="quote">&gt; &gt;&gt; &lt;gregkh@linuxfoundation.org&gt;; Andrew Morton</span>
<span class="quote">&gt; &gt;&gt; &lt;akpm@linux-foundation.org&gt;; Andrey Ryabinin</span>
<span class="quote">&gt; &gt;&gt; &lt;aryabinin@virtuozzo.com&gt;; David Miller &lt;davem@davemloft.net&gt;; Ingo</span>
<span class="quote">&gt; &gt;&gt; Molnar &lt;mingo@kernel.org&gt;; Geert Uytterhoeven</span>
<span class="quote">&gt; &gt;&gt; &lt;geert+renesas@glider.be&gt;; Al Viro &lt;viro@zeniv.linux.org.uk&gt;; Kees</span>
<span class="quote">&gt; &gt;&gt; Cook &lt;keescook@chromium.org&gt;; Daniel Borkmann &lt;daniel@iogearbox.net&gt;</span>
<span class="quote">&gt; &gt;&gt; Subject: Re: No check of the size passed to unmap_single in swiotlb</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; On Mon, Nov 20, 2017 at 08:17:14AM +0000, Eric Yang wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; Hi all,</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Hi!</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Hi  Konrad,</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; During debug a  device only support 32bits DMA(Qualcomm Atheros AP)</span>
<span class="quote">&gt; &gt;&gt;&gt; in our</span>
<span class="quote">&gt; &gt;&gt; LS1043A 64bits ARM  SOC, we found that the invoke of dma_unmap_single</span>
<span class="quote">&gt; &gt;&gt; --&gt; swiotlb_tbl_unmap_single  will unmap the passed &quot;size&quot; anyway</span>
<span class="quote">&gt; &gt;&gt; even when the &quot;size&quot; is incorrect.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; If the size is larger than it should, the extra entries in</span>
<span class="quote">&gt; &gt;&gt;&gt; io_tlb_orig_addr array</span>
<span class="quote">&gt; &gt;&gt; will be refilled by INVALID_PHYS_ADDR, and it will cause the bounce</span>
<span class="quote">&gt; &gt;&gt; buffer copy not happen when the one who really used the mis-freed</span>
<span class="quote">&gt; &gt;&gt; entries doing  DMA data transfers, and this will cause further unknow</span>
<span class="quote">&gt; behaviors.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Here we just fix it temporarily by adding a judge of the &quot;size&quot; in</span>
<span class="quote">&gt; &gt;&gt;&gt; the</span>
<span class="quote">&gt; &gt;&gt; swiotlb_tbl_unmap_single, if it is larger than it deserves, just</span>
<span class="quote">&gt; &gt;&gt; unmap the right size only. Like the code:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Did the DMA debug API (CONFIG_DMA_API_DEBUG) help in figuring this</span>
<span class="quote">&gt; &gt;&gt; issue as well?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I have just enabled this config and move off the kernel fix and test,</span>
<span class="quote">&gt; &gt; there seems the debug API has no output for this size incorrect issue.</span>
<span class="quote">&gt; &gt; For I only enable the config and no other operations and my kernel is 4.9, do I</span>
<span class="quote">&gt; missed something?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I confirm that the debug API is working, for there are other drivers</span>
<span class="quote">&gt; &gt; triggered its warning output</span>
<span class="quote">&gt; &gt; like:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; caam_jr 1710000.jr: DMA-API: device driver tries to free DMA memory it</span>
<span class="quote">&gt; &gt; has not allocated [device address=0x6800458400000000]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; By default, dma-debug will only log the first error it sees - you can adjust this</span>
<span class="quote">&gt; with the &quot;num_errors&quot; or &quot;all_errors&quot; sysfs controls, and use the driver filter to</span>
<span class="quote">&gt; hide errors from other drivers if necessary.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Robin.</span>
<span class="quote">&gt; </span>
Hi Robin,

I&#39;ve caught the size mismatch warning with the debug API, thanks a lot for the help.

Regards,
Eric
<span class="quote">
&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; [yangyu@titan dash-lts]$ git diff ./lib/swiotlb.c diff --git</span>
<span class="quote">&gt; &gt;&gt;&gt; a/lib/swiotlb.c b/lib/swiotlb.c index ad1d2962d129..58c97ede9d78</span>
<span class="quote">&gt; &gt;&gt;&gt; 100644</span>
<span class="quote">&gt; &gt;&gt;&gt; --- a/lib/swiotlb.c</span>
<span class="quote">&gt; &gt;&gt;&gt; +++ b/lib/swiotlb.c</span>
<span class="quote">&gt; &gt;&gt;&gt; @@ -591,7 +591,10 @@ void swiotlb_tbl_unmap_single(struct device</span>
<span class="quote">&gt; &gt;&gt;&gt; *hwdev,</span>
<span class="quote">&gt; &gt;&gt; phys_addr_t tlb_addr,</span>
<span class="quote">&gt; &gt;&gt;&gt;                   */</span>
<span class="quote">&gt; &gt;&gt;&gt;                  for (i = index + nslots - 1; i &gt;= index; i--) {</span>
<span class="quote">&gt; &gt;&gt;&gt;                          io_tlb_list[i] = ++count;</span>
<span class="quote">&gt; &gt;&gt;&gt; -                       io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt; &gt;&gt;&gt; +                      if(io_tlb_orig_addr[i]  != orig_addr)</span>
<span class="quote">&gt; &gt;&gt;&gt; +                          printk(&quot;======size wrong, ally down ally down!===\n&quot;);</span>
<span class="quote">&gt; &gt;&gt;&gt; +                      else</span>
<span class="quote">&gt; &gt;&gt;&gt; +                         io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt; &gt;&gt;&gt;                  }</span>
<span class="quote">&gt; &gt;&gt;&gt;                  /*</span>
<span class="quote">&gt; &gt;&gt;&gt;                   * Step 2: merge the returned slots with the</span>
<span class="quote">&gt; &gt;&gt;&gt; preceding slots,</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Although pass a right size of DMA buffer is the responsibility of</span>
<span class="quote">&gt; &gt;&gt;&gt; the drivers, but</span>
<span class="quote">&gt; &gt;&gt; Is it useful to add some size check code to prevent  real damage happen?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Regards,</span>
<span class="quote">&gt; &gt;&gt;&gt; Eric</span>
<span class="quote">&gt; &gt; _______________________________________________</span>
<span class="quote">&gt; &gt; iommu mailing list</span>
<span class="quote">&gt; &gt; iommu@lists.linux-foundation.org</span>
<span class="quote">&gt; &gt; https://emea01.safelinks.protection.outlook.com/?url=https%3A%2F%2Flis</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; ts.linuxfoundation.org%2Fmailman%2Flistinfo%2Fiommu&amp;data=02%7C01%7Cyu.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; yang_3%40nxp.com%7Cf3851e3c8ae24f341b3608d531ab1165%7C686ea1d3bc</span>
<span class="quote">&gt; 2b4c6f</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; a92cd99c5c301635%7C0%7C0%7C636469533155971955&amp;sdata=7PnqUlgRlJq2H</span>
<span class="quote">&gt; sXmTf</span>
<span class="quote">&gt; &gt; CmEUuWaBfUhzSd33UoK4li1Ro%3D&amp;reserved=0</span>
<span class="quote">&gt; &gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=177439">Eric Yang</a> - Nov. 23, 2017, 9:08 a.m.</div>
<pre class="content">
<span class="quote">&gt; -----Original Message-----</span>
<span class="quote">&gt; From: Robin Murphy [mailto:robin.murphy@arm.com]</span>
<span class="quote">&gt; Sent: Tuesday, November 21, 2017 12:50 AM</span>
<span class="quote">&gt; To: Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;; Eric Yang</span>
<span class="quote">&gt; &lt;yu.yang_3@nxp.com&gt;; iommu@lists.linux-foundation.org</span>
<span class="quote">&gt; Cc: Daniel Borkmann &lt;daniel@iogearbox.net&gt;; Kees Cook</span>
<span class="quote">&gt; &lt;keescook@chromium.org&gt;; Geert Uytterhoeven &lt;geert+renesas@glider.be&gt;;</span>
<span class="quote">&gt; Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;; linux-</span>
<span class="quote">&gt; kernel@vger.kernel.org; David Miller &lt;davem@davemloft.net&gt;; Al Viro</span>
<span class="quote">&gt; &lt;viro@zeniv.linux.org.uk&gt;; Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;;</span>
<span class="quote">&gt; Andrew Morton &lt;akpm@linux-foundation.org&gt;; Ingo Molnar</span>
<span class="quote">&gt; &lt;mingo@kernel.org&gt;</span>
<span class="quote">&gt; Subject: Re: No check of the size passed to unmap_single in swiotlb</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 20/11/17 16:26, Konrad Rzeszutek Wilk wrote:</span>
<span class="quote">&gt; &gt; On Mon, Nov 20, 2017 at 08:17:14AM +0000, Eric Yang wrote:</span>
<span class="quote">&gt; &gt;&gt; Hi all,</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Hi!</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; During debug a  device only support 32bits DMA(Qualcomm Atheros AP) in</span>
<span class="quote">&gt; our LS1043A 64bits ARM  SOC, we found that the invoke of dma_unmap_single -</span>
<span class="quote">&gt; -&gt; swiotlb_tbl_unmap_single  will unmap the passed &quot;size&quot; anyway even when</span>
<span class="quote">&gt; the &quot;size&quot; is incorrect.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; If the size is larger than it should, the extra entries in io_tlb_orig_addr array</span>
<span class="quote">&gt; will be refilled by INVALID_PHYS_ADDR, and it will cause the bounce buffer copy</span>
<span class="quote">&gt; not happen when the one who really used the mis-freed entries doing  DMA data</span>
<span class="quote">&gt; transfers, and this will cause further unknow behaviors.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Here we just fix it temporarily by adding a judge of the &quot;size&quot; in the</span>
<span class="quote">&gt; swiotlb_tbl_unmap_single, if it is larger than it deserves, just unmap the right</span>
<span class="quote">&gt; size only. Like the code:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Did the DMA debug API (CONFIG_DMA_API_DEBUG) help in figuring this issue</span>
<span class="quote">&gt; as well?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; [yangyu@titan dash-lts]$ git diff ./lib/swiotlb.c diff --git</span>
<span class="quote">&gt; &gt;&gt; a/lib/swiotlb.c b/lib/swiotlb.c index ad1d2962d129..58c97ede9d78</span>
<span class="quote">&gt; &gt;&gt; 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/lib/swiotlb.c</span>
<span class="quote">&gt; &gt;&gt; +++ b/lib/swiotlb.c</span>
<span class="quote">&gt; &gt;&gt; @@ -591,7 +591,10 @@ void swiotlb_tbl_unmap_single(struct device</span>
<span class="quote">&gt; *hwdev, phys_addr_t tlb_addr,</span>
<span class="quote">&gt; &gt;&gt;                   */</span>
<span class="quote">&gt; &gt;&gt;                  for (i = index + nslots - 1; i &gt;= index; i--) {</span>
<span class="quote">&gt; &gt;&gt;                          io_tlb_list[i] = ++count;</span>
<span class="quote">&gt; &gt;&gt; -                       io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt; &gt;&gt; +                      if(io_tlb_orig_addr[i]  != orig_addr)</span>
<span class="quote">&gt; &gt;&gt; +                          printk(&quot;======size wrong, ally down ally down!===\n&quot;);</span>
<span class="quote">&gt; &gt;&gt; +                      else</span>
<span class="quote">&gt; &gt;&gt; +                         io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="quote">&gt; &gt;&gt;                  }</span>
<span class="quote">&gt; &gt;&gt;                  /*</span>
<span class="quote">&gt; &gt;&gt;                   * Step 2: merge the returned slots with the</span>
<span class="quote">&gt; &gt;&gt; preceding slots,</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Although pass a right size of DMA buffer is the responsibility of  the drivers,</span>
<span class="quote">&gt; but Is it useful to add some size check code to prevent  real damage happen?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There doesn&#39;t seem to be much good reason for SWIOTLB to be more special</span>
<span class="quote">&gt; than other DMA API backends, and not all of them have enough internal state to</span>
<span class="quote">&gt; be able to make such a check. It&#39;s also not necessarily possible to &quot;prevent</span>
<span class="quote">&gt; damage&quot; anyway - if a driver does pass a bogus size for dma_unmap_single(...,</span>
<span class="quote">&gt; DMA_FROM_DEVICE), SWIOTLB might be able to keep itself internally consistent,</span>
<span class="quote">&gt; but it still can&#39;t prevent the arch code in the middle from invalidating the wrong</span>
<span class="quote">&gt; cache lines and potentially corrupting adjacent memory.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In short, trying to work around broken drivers is a much worse idea than just</span>
<span class="quote">&gt; fixing those drivers, and that&#39;s what we already have dma-debug for.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Robin.</span>

Hi Robin,

I agree that hacking kernel to fix broken drivers is not acceptable, actually we spent days to fight driver supplier with  this, they do not want to change their code and want fix it directly in kernel. 

I tried Dma-debug yesterday, it works very well,  but I think only the size mismatch check may not be enough for the map entry corrupt situation, some run-time warning may be better when the real corruption happen.

For most of the dma-api backend, the size mismatch may do no harm at all, and even in SWIOTLB itself when the bounce buffer is not used, the size mismatch do no harm either. In our case, the same buggy driver works well when board has 2G DDR, but panic frequently in 4G DDR because of the use of bounce buffer and these corrupted map entries. it is hard to catch this kind of bugs, for when the corruption happen, the kernel has all kind of reasons to panic, but not even one may directly point to the real source.  

Add the warning messages is a big convenience for figure this kind of issues, at least to me and the AP driver supplier, such warnings may save weeks of hard debug time.

Regards,
Eric
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=3565">Konrad Rzeszutek</a> - Nov. 24, 2017, 1:33 p.m.</div>
<pre class="content">
..snip..
<span class="quote">&gt; &gt; There doesn&#39;t seem to be much good reason for SWIOTLB to be more special</span>
<span class="quote">&gt; &gt; than other DMA API backends, and not all of them have enough internal state to</span>
<span class="quote">&gt; &gt; be able to make such a check. It&#39;s also not necessarily possible to &quot;prevent</span>
<span class="quote">&gt; &gt; damage&quot; anyway - if a driver does pass a bogus size for dma_unmap_single(...,</span>
<span class="quote">&gt; &gt; DMA_FROM_DEVICE), SWIOTLB might be able to keep itself internally consistent,</span>
<span class="quote">&gt; &gt; but it still can&#39;t prevent the arch code in the middle from invalidating the wrong</span>
<span class="quote">&gt; &gt; cache lines and potentially corrupting adjacent memory.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; In short, trying to work around broken drivers is a much worse idea than just</span>
<span class="quote">&gt; &gt; fixing those drivers, and that&#39;s what we already have dma-debug for.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Robin.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi Robin,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I agree that hacking kernel to fix broken drivers is not acceptable, actually we spent days to fight driver supplier with  this, they do not want to change their code and want fix it directly in kernel. </span>

You could upstream the driver? That way it will be fixed.

I am not sure if you are aware but there is a staging directory
as well in Linux.
<span class="quote">&gt; </span>
<span class="quote">&gt; I tried Dma-debug yesterday, it works very well,  but I think only the size mismatch check may not be enough for the map entry corrupt situation, some run-time warning may be better when the real corruption happen.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For most of the dma-api backend, the size mismatch may do no harm at all, and even in SWIOTLB itself when the bounce buffer is not used, the size mismatch do no harm either. In our case, the same buggy driver works well when board has 2G DDR, but panic frequently in 4G DDR because of the use of bounce buffer and these corrupted map entries. it is hard to catch this kind of bugs, for when the corruption happen, the kernel has all kind of reasons to panic, but not even one may directly point to the real source.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Add the warning messages is a big convenience for figure this kind of issues, at least to me and the AP driver supplier, such warnings may save weeks of hard debug time.</span>

I would prefer that all of those warning messages go in the DMA debug
API - as you can have multiple DMA different backends.

In other words, instead of being in one implementation it would make
much more sense to be in the generic API layer.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - Nov. 28, 2017, 2:18 p.m.</div>
<pre class="content">
Hi Eric,

On 23/11/17 09:08, Eric Yang wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; -----Original Message----- From: Robin Murphy</span>
<span class="quote">&gt;&gt; [mailto:robin.murphy@arm.com] Sent: Tuesday, November 21, 2017</span>
<span class="quote">&gt;&gt; 12:50 AM To: Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;; Eric</span>
<span class="quote">&gt;&gt; Yang &lt;yu.yang_3@nxp.com&gt;; iommu@lists.linux-foundation.org Cc:</span>
<span class="quote">&gt;&gt; Daniel Borkmann &lt;daniel@iogearbox.net&gt;; Kees Cook </span>
<span class="quote">&gt;&gt; &lt;keescook@chromium.org&gt;; Geert Uytterhoeven</span>
<span class="quote">&gt;&gt; &lt;geert+renesas@glider.be&gt;; Greg Kroah-Hartman</span>
<span class="quote">&gt;&gt; &lt;gregkh@linuxfoundation.org&gt;; linux- kernel@vger.kernel.org; David</span>
<span class="quote">&gt;&gt; Miller &lt;davem@davemloft.net&gt;; Al Viro &lt;viro@zeniv.linux.org.uk&gt;;</span>
<span class="quote">&gt;&gt; Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;; Andrew Morton</span>
<span class="quote">&gt;&gt; &lt;akpm@linux-foundation.org&gt;; Ingo Molnar &lt;mingo@kernel.org&gt; </span>
<span class="quote">&gt;&gt; Subject: Re: No check of the size passed to unmap_single in</span>
<span class="quote">&gt;&gt; swiotlb</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt; On 20/11/17 16:26, Konrad Rzeszutek Wilk wrote:</span>
<span class="quote">&gt;&gt;&gt; On Mon, Nov 20, 2017 at 08:17:14AM +0000, Eric Yang wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; Hi all,</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; Hi!</span>
<span class="quote">&gt;&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; During debug a  device only support 32bits DMA(Qualcomm Atheros</span>
<span class="quote">&gt;&gt;&gt;&gt; AP) in</span>
<span class="quote">&gt;&gt; our LS1043A 64bits ARM  SOC, we found that the invoke of</span>
<span class="quote">&gt;&gt; dma_unmap_single - -&gt; swiotlb_tbl_unmap_single  will unmap the</span>
<span class="quote">&gt;&gt; passed &quot;size&quot; anyway even when the &quot;size&quot; is incorrect.</span>
<span class="quote">&gt;&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; If the size is larger than it should, the extra entries in</span>
<span class="quote">&gt;&gt;&gt;&gt; io_tlb_orig_addr array</span>
<span class="quote">&gt;&gt; will be refilled by INVALID_PHYS_ADDR, and it will cause the bounce</span>
<span class="quote">&gt;&gt; buffer copy not happen when the one who really used the mis-freed</span>
<span class="quote">&gt;&gt; entries doing  DMA data transfers, and this will cause further</span>
<span class="quote">&gt;&gt; unknow behaviors.</span>
<span class="quote">&gt;&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; Here we just fix it temporarily by adding a judge of the &quot;size&quot;</span>
<span class="quote">&gt;&gt;&gt;&gt; in the</span>
<span class="quote">&gt;&gt; swiotlb_tbl_unmap_single, if it is larger than it deserves, just</span>
<span class="quote">&gt;&gt; unmap the right size only. Like the code:</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; Did the DMA debug API (CONFIG_DMA_API_DEBUG) help in figuring</span>
<span class="quote">&gt;&gt;&gt; this issue</span>
<span class="quote">&gt;&gt; as well?</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; [yangyu@titan dash-lts]$ git diff ./lib/swiotlb.c diff --git </span>
<span class="quote">&gt;&gt;&gt;&gt; a/lib/swiotlb.c b/lib/swiotlb.c index</span>
<span class="quote">&gt;&gt;&gt;&gt; ad1d2962d129..58c97ede9d78 100644 --- a/lib/swiotlb.c +++</span>
<span class="quote">&gt;&gt;&gt;&gt; b/lib/swiotlb.c @@ -591,7 +591,10 @@ void</span>
<span class="quote">&gt;&gt;&gt;&gt; swiotlb_tbl_unmap_single(struct device</span>
<span class="quote">&gt;&gt; *hwdev, phys_addr_t tlb_addr,</span>
<span class="quote">&gt;&gt;&gt;&gt; */ for (i = index + nslots - 1; i &gt;= index; i--) { </span>
<span class="quote">&gt;&gt;&gt;&gt; io_tlb_list[i] = ++count; -</span>
<span class="quote">&gt;&gt;&gt;&gt; io_tlb_orig_addr[i] = INVALID_PHYS_ADDR; +</span>
<span class="quote">&gt;&gt;&gt;&gt; if(io_tlb_orig_addr[i]  != orig_addr) +</span>
<span class="quote">&gt;&gt;&gt;&gt; printk(&quot;======size wrong, ally down ally down!===\n&quot;); +</span>
<span class="quote">&gt;&gt;&gt;&gt; else +                         io_tlb_orig_addr[i] =</span>
<span class="quote">&gt;&gt;&gt;&gt; INVALID_PHYS_ADDR; } /* * Step 2: merge the returned slots with</span>
<span class="quote">&gt;&gt;&gt;&gt; the preceding slots,</span>
<span class="quote">&gt;&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; Although pass a right size of DMA buffer is the responsibility</span>
<span class="quote">&gt;&gt;&gt;&gt; of  the drivers,</span>
<span class="quote">&gt;&gt; but Is it useful to add some size check code to prevent  real</span>
<span class="quote">&gt;&gt; damage happen?</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt; There doesn&#39;t seem to be much good reason for SWIOTLB to be more</span>
<span class="quote">&gt;&gt; special than other DMA API backends, and not all of them have</span>
<span class="quote">&gt;&gt; enough internal state to be able to make such a check. It&#39;s also</span>
<span class="quote">&gt;&gt; not necessarily possible to &quot;prevent damage&quot; anyway - if a driver</span>
<span class="quote">&gt;&gt; does pass a bogus size for dma_unmap_single(..., DMA_FROM_DEVICE),</span>
<span class="quote">&gt;&gt; SWIOTLB might be able to keep itself internally consistent, but it</span>
<span class="quote">&gt;&gt; still can&#39;t prevent the arch code in the middle from invalidating</span>
<span class="quote">&gt;&gt; the wrong cache lines and potentially corrupting adjacent memory.</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt; In short, trying to work around broken drivers is a much worse idea</span>
<span class="quote">&gt;&gt; than just fixing those drivers, and that&#39;s what we already have</span>
<span class="quote">&gt;&gt; dma-debug for.</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt; Robin.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi Robin,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I agree that hacking kernel to fix broken drivers is not acceptable,</span>
<span class="quote">&gt; actually we spent days to fight driver supplier with  this, they do</span>
<span class="quote">&gt; not want to change their code and want fix it directly in kernel.</span>

So their code misuses an API in a manner which has never been correct, 
and is *impossible* for many common implementations of that API to 
validate, and they think it&#39;s upstream&#39;s job to work around it? Wow... 
you have my sympathy :)
<span class="quote">
&gt; I tried Dma-debug yesterday, it works very well,  but I think only</span>
<span class="quote">&gt; the size mismatch check may not be enough for the map entry corrupt</span>
<span class="quote">&gt; situation, some run-time warning may be better when the real</span>
<span class="quote">&gt; corruption happen.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For most of the dma-api backend, the size mismatch may do no harm at</span>
<span class="quote">&gt; all, and even in SWIOTLB itself when the bounce buffer is not used,</span>
<span class="quote">&gt; the size mismatch do no harm either. In our case, the same buggy</span>
<span class="quote">&gt; driver works well when board has 2G DDR, but panic frequently in 4G</span>
<span class="quote">&gt; DDR because of the use of bounce buffer and these corrupted map</span>
<span class="quote">&gt; entries. it is hard to catch this kind of bugs, for when the</span>
<span class="quote">&gt; corruption happen, the kernel has all kind of reasons to panic, but</span>
<span class="quote">&gt; not even one may directly point to the real source.</span>

As I said, just because things appear to work for your test cases on 
your system in the non-bounced case doesn&#39;t mean it&#39;s universally fine. 
If this device can be integrated into non-cache-coherent systems, then 
over-unmapping of device-writable buffers will eventually cause random 
corruption and data loss to somebody, somewhere, by invalidating dirty 
cache lines in the wrong place. If this device can be integrated behind 
an IOMMU (and if it&#39;s available with a PCI/PCIe interface, assume that 
it will be), then any over-unmapping will remove other devices&#39; 
translations and cause random DMA problems which can be even less 
obvious to debug, and cannot be &#39;worked around&#39; at all (certainly on the 
arm64 and x86 implementations).
<span class="quote">
&gt; Add the warning messages is a big convenience for figure this kind of</span>
<span class="quote">&gt; issues, at least to me and the AP driver supplier, such warnings may</span>
<span class="quote">&gt; save weeks of hard debug time.</span>

I don&#39;t get it - if driver developers are writing buggy drivers and not 
testing with basic well-established features like dma-debug, that&#39;s on 
the driver developers. Optimising for the case where BSP developers 
happen to get lucky with a particular configuration in which they might 
see driver bugs tickle warnings elsewhere doesn&#39;t seem sensible. Yes, it 
wouldn&#39;t be utterly unacceptable for SWIOTLB to print a warning when it 
detects some (address,size) combination that looks like it may have gone 
out-of-bounds, but at that point swiotlb_bounce() has presumably already 
done the damage of overwriting something it shouldn&#39;t have with who 
knows what, and it&#39;s still only one specific case - for instance, you 
wouldn&#39;t detect if the size is too small and you haven&#39;t bounced 
*enough* data, but that would still make your I/O misbehave.

In the end, it comes down to the difference between a) I/O going wrong 
and the system crashing, and b) the user *possibly* getting a warning 
they can&#39;t do anything about before I/O going wrong and the system 
crashing. Ultimately the driver developer still has to fix their bug, so 
why add code to occasionally antagonise the user when a developer 
feature tailor-made for catching such bugs immediately has existed for 
nearly 9 years?

Robin.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=177439">Eric Yang</a> - Nov. 30, 2017, 3:05 a.m.</div>
<pre class="content">
Hi Robin,
<span class="quote">
&gt; -----Original Message-----</span>
<span class="quote">&gt; From: Robin Murphy [mailto:robin.murphy@arm.com]</span>
<span class="quote">&gt; Sent: Tuesday, November 28, 2017 10:18 PM</span>
<span class="quote">&gt; To: Eric Yang &lt;yu.yang_3@nxp.com&gt;; Konrad Rzeszutek Wilk</span>
<span class="quote">&gt; &lt;konrad.wilk@oracle.com&gt;; iommu@lists.linux-foundation.org</span>
<span class="quote">&gt; Cc: Daniel Borkmann &lt;daniel@iogearbox.net&gt;; Kees Cook</span>
<span class="quote">&gt; &lt;keescook@chromium.org&gt;; Geert Uytterhoeven &lt;geert+renesas@glider.be&gt;;</span>
<span class="quote">&gt; Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;; linux-</span>
<span class="quote">&gt; kernel@vger.kernel.org; David Miller &lt;davem@davemloft.net&gt;; Al Viro</span>
<span class="quote">&gt; &lt;viro@zeniv.linux.org.uk&gt;; Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;;</span>
<span class="quote">&gt; Andrew Morton &lt;akpm@linux-foundation.org&gt;; Ingo Molnar</span>
<span class="quote">&gt; &lt;mingo@kernel.org&gt;</span>
<span class="quote">&gt; Subject: Re: No check of the size passed to unmap_single in swiotlb</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi Eric,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 23/11/17 09:08, Eric Yang wrote:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; -----Original Message----- From: Robin Murphy</span>
<span class="quote">&gt; &gt;&gt; [mailto:robin.murphy@arm.com] Sent: Tuesday, November 21, 2017</span>
<span class="quote">&gt; &gt;&gt; 12:50 AM To: Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;; Eric</span>
<span class="quote">&gt; &gt;&gt; Yang &lt;yu.yang_3@nxp.com&gt;; iommu@lists.linux-foundation.org Cc:</span>
<span class="quote">&gt; &gt;&gt; Daniel Borkmann &lt;daniel@iogearbox.net&gt;; Kees Cook</span>
<span class="quote">&gt; &gt;&gt; &lt;keescook@chromium.org&gt;; Geert Uytterhoeven</span>
<span class="quote">&gt; &gt;&gt; &lt;geert+renesas@glider.be&gt;; Greg Kroah-Hartman</span>
<span class="quote">&gt; &gt;&gt; &lt;gregkh@linuxfoundation.org&gt;; linux- kernel@vger.kernel.org; David</span>
<span class="quote">&gt; &gt;&gt; Miller &lt;davem@davemloft.net&gt;; Al Viro &lt;viro@zeniv.linux.org.uk&gt;;</span>
<span class="quote">&gt; &gt;&gt; Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;; Andrew Morton</span>
<span class="quote">&gt; &gt;&gt; &lt;akpm@linux-foundation.org&gt;; Ingo Molnar &lt;mingo@kernel.org&gt;</span>
<span class="quote">&gt; &gt;&gt; Subject: Re: No check of the size passed to unmap_single in swiotlb</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; On 20/11/17 16:26, Konrad Rzeszutek Wilk wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; On Mon, Nov 20, 2017 at 08:17:14AM +0000, Eric Yang wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Hi all,</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Hi!</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; During debug a  device only support 32bits DMA(Qualcomm Atheros</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; AP) in</span>
<span class="quote">&gt; &gt;&gt; our LS1043A 64bits ARM  SOC, we found that the invoke of</span>
<span class="quote">&gt; &gt;&gt; dma_unmap_single - -&gt; swiotlb_tbl_unmap_single  will unmap the passed</span>
<span class="quote">&gt; &gt;&gt; &quot;size&quot; anyway even when the &quot;size&quot; is incorrect.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; If the size is larger than it should, the extra entries in</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; io_tlb_orig_addr array</span>
<span class="quote">&gt; &gt;&gt; will be refilled by INVALID_PHYS_ADDR, and it will cause the bounce</span>
<span class="quote">&gt; &gt;&gt; buffer copy not happen when the one who really used the mis-freed</span>
<span class="quote">&gt; &gt;&gt; entries doing  DMA data transfers, and this will cause further unknow</span>
<span class="quote">&gt; &gt;&gt; behaviors.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Here we just fix it temporarily by adding a judge of the &quot;size&quot;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; in the</span>
<span class="quote">&gt; &gt;&gt; swiotlb_tbl_unmap_single, if it is larger than it deserves, just</span>
<span class="quote">&gt; &gt;&gt; unmap the right size only. Like the code:</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Did the DMA debug API (CONFIG_DMA_API_DEBUG) help in figuring this</span>
<span class="quote">&gt; &gt;&gt;&gt; issue</span>
<span class="quote">&gt; &gt;&gt; as well?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; [yangyu@titan dash-lts]$ git diff ./lib/swiotlb.c diff --git</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; a/lib/swiotlb.c b/lib/swiotlb.c index</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; ad1d2962d129..58c97ede9d78 100644 --- a/lib/swiotlb.c +++</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; b/lib/swiotlb.c @@ -591,7 +591,10 @@ void</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; swiotlb_tbl_unmap_single(struct device</span>
<span class="quote">&gt; &gt;&gt; *hwdev, phys_addr_t tlb_addr,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; */ for (i = index + nslots - 1; i &gt;= index; i--) { io_tlb_list[i] =</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; ++count; - io_tlb_orig_addr[i] = INVALID_PHYS_ADDR; +</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; if(io_tlb_orig_addr[i]  != orig_addr) + printk(&quot;======size wrong,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; ally down ally down!===\n&quot;); +</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; else +                         io_tlb_orig_addr[i] =</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; INVALID_PHYS_ADDR; } /* * Step 2: merge the returned slots with the</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; preceding slots,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Although pass a right size of DMA buffer is the responsibility of</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; the drivers,</span>
<span class="quote">&gt; &gt;&gt; but Is it useful to add some size check code to prevent  real damage</span>
<span class="quote">&gt; &gt;&gt; happen?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; There doesn&#39;t seem to be much good reason for SWIOTLB to be more</span>
<span class="quote">&gt; &gt;&gt; special than other DMA API backends, and not all of them have enough</span>
<span class="quote">&gt; &gt;&gt; internal state to be able to make such a check. It&#39;s also not</span>
<span class="quote">&gt; &gt;&gt; necessarily possible to &quot;prevent damage&quot; anyway - if a driver does</span>
<span class="quote">&gt; &gt;&gt; pass a bogus size for dma_unmap_single(..., DMA_FROM_DEVICE), SWIOTLB</span>
<span class="quote">&gt; &gt;&gt; might be able to keep itself internally consistent, but it still</span>
<span class="quote">&gt; &gt;&gt; can&#39;t prevent the arch code in the middle from invalidating the wrong</span>
<span class="quote">&gt; &gt;&gt; cache lines and potentially corrupting adjacent memory.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; In short, trying to work around broken drivers is a much worse idea</span>
<span class="quote">&gt; &gt;&gt; than just fixing those drivers, and that&#39;s what we already have</span>
<span class="quote">&gt; &gt;&gt; dma-debug for.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Robin.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Hi Robin,</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I agree that hacking kernel to fix broken drivers is not acceptable,</span>
<span class="quote">&gt; &gt; actually we spent days to fight driver supplier with  this, they do</span>
<span class="quote">&gt; &gt; not want to change their code and want fix it directly in kernel.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So their code misuses an API in a manner which has never been correct, and is</span>
<span class="quote">&gt; *impossible* for many common implementations of that API to validate, and</span>
<span class="quote">&gt; they think it&#39;s upstream&#39;s job to work around it? Wow...</span>
<span class="quote">&gt; you have my sympathy :)</span>
<span class="quote">&gt; </span>

Yeah, as a BSP supplier we are always the first suspect when anything happen :)
<span class="quote">

&gt; &gt; I tried Dma-debug yesterday, it works very well,  but I think only the</span>
<span class="quote">&gt; &gt; size mismatch check may not be enough for the map entry corrupt</span>
<span class="quote">&gt; &gt; situation, some run-time warning may be better when the real</span>
<span class="quote">&gt; &gt; corruption happen.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; For most of the dma-api backend, the size mismatch may do no harm at</span>
<span class="quote">&gt; &gt; all, and even in SWIOTLB itself when the bounce buffer is not used,</span>
<span class="quote">&gt; &gt; the size mismatch do no harm either. In our case, the same buggy</span>
<span class="quote">&gt; &gt; driver works well when board has 2G DDR, but panic frequently in 4G</span>
<span class="quote">&gt; &gt; DDR because of the use of bounce buffer and these corrupted map</span>
<span class="quote">&gt; &gt; entries. it is hard to catch this kind of bugs, for when the</span>
<span class="quote">&gt; &gt; corruption happen, the kernel has all kind of reasons to panic, but</span>
<span class="quote">&gt; &gt; not even one may directly point to the real source.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As I said, just because things appear to work for your test cases on your system</span>
<span class="quote">&gt; in the non-bounced case doesn&#39;t mean it&#39;s universally fine.</span>
<span class="quote">&gt; If this device can be integrated into non-cache-coherent systems, then over-</span>
<span class="quote">&gt; unmapping of device-writable buffers will eventually cause random corruption</span>
<span class="quote">&gt; and data loss to somebody, somewhere, by invalidating dirty cache lines in the</span>
<span class="quote">&gt; wrong place. If this device can be integrated behind an IOMMU (and if it&#39;s</span>
<span class="quote">&gt; available with a PCI/PCIe interface, assume that it will be), then any over-</span>
<span class="quote">&gt; unmapping will remove other devices&#39;</span>
<span class="quote">&gt; translations and cause random DMA problems which can be even less obvious to</span>
<span class="quote">&gt; debug, and cannot be &#39;worked around&#39; at all (certainly on the</span>
<span class="quote">&gt; arm64 and x86 implementations).</span>
<span class="quote">&gt; </span>

Yes, for the performance issue of swiotlb, we may be forced to enable SMMU, as you said the broken driver may not  workaround at all by kernel hack.
<span class="quote">
&gt; &gt; Add the warning messages is a big convenience for figure this kind of</span>
<span class="quote">&gt; &gt; issues, at least to me and the AP driver supplier, such warnings may</span>
<span class="quote">&gt; &gt; save weeks of hard debug time.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t get it - if driver developers are writing buggy drivers and not testing with</span>
<span class="quote">&gt; basic well-established features like dma-debug, that&#39;s on the driver developers.</span>
<span class="quote">&gt; Optimising for the case where BSP developers happen to get lucky with a</span>
<span class="quote">&gt; particular configuration in which they might see driver bugs tickle warnings</span>
<span class="quote">&gt; elsewhere doesn&#39;t seem sensible. Yes, it wouldn&#39;t be utterly unacceptable for</span>
<span class="quote">&gt; SWIOTLB to print a warning when it detects some (address,size) combination</span>
<span class="quote">&gt; that looks like it may have gone out-of-bounds, but at that point</span>
<span class="quote">&gt; swiotlb_bounce() has presumably already done the damage of overwriting</span>
<span class="quote">&gt; something it shouldn&#39;t have with who knows what, and it&#39;s still only one specific</span>
<span class="quote">&gt; case - for instance, you wouldn&#39;t detect if the size is too small and you haven&#39;t</span>
<span class="quote">&gt; bounced</span>
<span class="quote">&gt; *enough* data, but that would still make your I/O misbehave.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In the end, it comes down to the difference between a) I/O going wrong and the</span>
<span class="quote">&gt; system crashing, and b) the user *possibly* getting a warning they can&#39;t do</span>
<span class="quote">&gt; anything about before I/O going wrong and the system crashing. Ultimately the</span>
<span class="quote">&gt; driver developer still has to fix their bug, so why add code to occasionally</span>
<span class="quote">&gt; antagonise the user when a developer feature tailor-made for catching such</span>
<span class="quote">&gt; bugs immediately has existed for nearly 9 years?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Robin.</span>

You are right. Thanks a lot for all the information and the time spent and also the patience.

Regards,
Eric
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="p_header">index ad1d2962d129..58c97ede9d78 100644</span>
<span class="p_header">--- a/lib/swiotlb.c</span>
<span class="p_header">+++ b/lib/swiotlb.c</span>
<span class="p_chunk">@@ -591,7 +591,10 @@</span> <span class="p_context"> void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,</span>
                 */
                for (i = index + nslots - 1; i &gt;= index; i--) {
                        io_tlb_list[i] = ++count;
<span class="p_del">-                       io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
<span class="p_add">+                      if(io_tlb_orig_addr[i]  != orig_addr)</span>
<span class="p_add">+                          printk(&quot;======size wrong, ally down ally down!===\n&quot;);</span>
<span class="p_add">+                      else</span>
<span class="p_add">+                         io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;</span>
                }
                /*
                 * Step 2: merge the returned slots with the preceding slots,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



