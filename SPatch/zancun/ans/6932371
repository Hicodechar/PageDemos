
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.10.85 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.10.85</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 3, 2015, 6:04 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150803180400.GB4538@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6932371/mbox/"
   >mbox</a>
|
   <a href="/patch/6932371/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6932371/">/patch/6932371/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 443A59F373
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 18:04:36 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id BD56F2063B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 18:04:30 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id F33B120606
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 18:04:24 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754259AbbHCSEI (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 3 Aug 2015 14:04:08 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:37285 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1754212AbbHCSEB (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 3 Aug 2015 14:04:01 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 598044D3;
	Mon,  3 Aug 2015 18:04:00 +0000 (UTC)
Date: Mon, 3 Aug 2015 11:04:00 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.10.85
Message-ID: &lt;20150803180400.GB4538@kroah.com&gt;
References: &lt;20150803180343.GA4538@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150803180343.GA4538@kroah.com&gt;
User-Agent: Mutt/1.5.23+102 (2ca89bed6448) (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 3, 2015, 6:04 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">index 01ef408e205f..8faff12e7014 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_chunk">@@ -91,5 +91,5 @@</span> <span class="p_context"> mpp61         61       gpo, dev(wen1), uart1(txd), audio(rclk)</span>
 mpp62         62       gpio, dev(a2), uart1(cts), tdm(drx), pcie(clkreq0),
                        audio(mclk), uart0(cts)
 mpp63         63       gpo, spi0(sck), tclk
<span class="p_del">-mpp64         64       gpio, spi0(miso), spi0-1(cs1)</span>
<span class="p_del">-mpp65         65       gpio, spi0(mosi), spi0-1(cs2)</span>
<span class="p_add">+mpp64         64       gpio, spi0(miso), spi0(cs1)</span>
<span class="p_add">+mpp65         65       gpio, spi0(mosi), spi0(cs2)</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">index bfa0a2e5e0cb..86dec67e5450 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_chunk">@@ -41,15 +41,15 @@</span> <span class="p_context"> mpp20         20       gpio, ge0(rxd4), ge1(rxd2), lcd(d20), ptp(clk)</span>
 mpp21         21       gpio, ge0(rxd5), ge1(rxd3), lcd(d21), mem(bat)
 mpp22         22       gpio, ge0(rxd6), ge1(rxctl), lcd(d22), sata0(prsnt)
 mpp23         23       gpio, ge0(rxd7), ge1(rxclk), lcd(d23), sata1(prsnt)
<span class="p_del">-mpp24         24       gpio, lcd(hsync), sata1(prsnt), nf(bootcs-re), tdm(rst)</span>
<span class="p_del">-mpp25         25       gpio, lcd(vsync), sata0(prsnt), nf(bootcs-we), tdm(pclk)</span>
<span class="p_del">-mpp26         26       gpio, lcd(clk), tdm(fsync), vdd(cpu1-pd)</span>
<span class="p_add">+mpp24         24       gpio, lcd(hsync), sata1(prsnt), tdm(rst)</span>
<span class="p_add">+mpp25         25       gpio, lcd(vsync), sata0(prsnt), tdm(pclk)</span>
<span class="p_add">+mpp26         26       gpio, lcd(clk), tdm(fsync)</span>
 mpp27         27       gpio, lcd(e), tdm(dtx), ptp(trig)
 mpp28         28       gpio, lcd(pwm), tdm(drx), ptp(evreq)
<span class="p_del">-mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk), vdd(cpu0-pd)</span>
<span class="p_add">+mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk)</span>
 mpp30         30       gpio, tdm(int1), sd0(clk)
<span class="p_del">-mpp31         31       gpio, tdm(int2), sd0(cmd), vdd(cpu0-pd)</span>
<span class="p_del">-mpp32         32       gpio, tdm(int3), sd0(d0), vdd(cpu1-pd)</span>
<span class="p_add">+mpp31         31       gpio, tdm(int2), sd0(cmd)</span>
<span class="p_add">+mpp32         32       gpio, tdm(int3), sd0(d0)</span>
 mpp33         33       gpio, tdm(int4), sd0(d1), mem(bat)
 mpp34         34       gpio, tdm(int5), sd0(d2), sata0(prsnt)
 mpp35         35       gpio, tdm(int6), sd0(d3), sata1(prsnt)
<span class="p_chunk">@@ -57,21 +57,18 @@</span> <span class="p_context"> mpp36         36       gpio, spi(mosi)</span>
 mpp37         37       gpio, spi(miso)
 mpp38         38       gpio, spi(sck)
 mpp39         39       gpio, spi(cs0)
<span class="p_del">-mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), vdd(cpu1-pd),</span>
<span class="p_del">-                       pcie(clkreq0)</span>
<span class="p_add">+mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), pcie(clkreq0)</span>
 mpp41         41       gpio, spi(cs2), uart2(rts), lcd(vga-vsync), sata1(prsnt),
                        pcie(clkreq1)
<span class="p_del">-mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer),</span>
<span class="p_del">-                       vdd(cpu0-pd)</span>
<span class="p_del">-mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout),</span>
<span class="p_del">-                       vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer)</span>
<span class="p_add">+mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout)</span>
 mpp44         44       gpio, uart2(cts), uart3(rxd), spi(cs4), pcie(clkreq2),
                        mem(bat)
 mpp45         45       gpio, uart2(rts), uart3(txd), spi(cs5), sata1(prsnt)
 mpp46         46       gpio, uart3(rts), uart1(rts), spi(cs6), sata0(prsnt)
 mpp47         47       gpio, uart3(cts), uart1(cts), spi(cs7), pcie(clkreq3),
                        ref(clkout)
<span class="p_del">-mpp48         48       gpio, tclk, dev(burst/last)</span>
<span class="p_add">+mpp48         48       gpio, dev(clkout), dev(burst/last)</span>
 
 * Marvell Armada XP (mv78260 and mv78460 only)
 
<span class="p_chunk">@@ -83,9 +80,9 @@</span> <span class="p_context"> mpp51         51       gpio, dev(ad16)</span>
 mpp52         52       gpio, dev(ad17)
 mpp53         53       gpio, dev(ad18)
 mpp54         54       gpio, dev(ad19)
<span class="p_del">-mpp55         55       gpio, dev(ad20), vdd(cpu0-pd)</span>
<span class="p_del">-mpp56         56       gpio, dev(ad21), vdd(cpu1-pd)</span>
<span class="p_del">-mpp57         57       gpio, dev(ad22), vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp55         55       gpio, dev(ad20)</span>
<span class="p_add">+mpp56         56       gpio, dev(ad21)</span>
<span class="p_add">+mpp57         57       gpio, dev(ad22)</span>
 mpp58         58       gpio, dev(ad23)
 mpp59         59       gpio, dev(ad24)
 mpp60         60       gpio, dev(ad25)
<span class="p_chunk">@@ -95,6 +92,3 @@</span> <span class="p_context"> mpp63         63       gpio, dev(ad28)</span>
 mpp64         64       gpio, dev(ad29)
 mpp65         65       gpio, dev(ad30)
 mpp66         66       gpio, dev(ad31)
<span class="p_del">-</span>
<span class="p_del">-Notes:</span>
<span class="p_del">-* {1} vdd(cpu2-3-pd) only available on mv78460.</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/spi/spi_pl022.txt b/Documentation/devicetree/bindings/spi/spi_pl022.txt</span>
<span class="p_header">index 22ed6797216d..4d1673ca8cf8 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/spi/spi_pl022.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/spi/spi_pl022.txt</span>
<span class="p_chunk">@@ -4,9 +4,9 @@</span> <span class="p_context"> Required properties:</span>
 - compatible : &quot;arm,pl022&quot;, &quot;arm,primecell&quot;
 - reg : Offset and length of the register set for the device
 - interrupts : Should contain SPI controller interrupt
<span class="p_add">+- num-cs : total number of chipselects</span>
 
 Optional properties:
<span class="p_del">-- num-cs : total number of chipselects</span>
 - cs-gpios : should specify GPIOs used for chipselects.
   The gpios will be referred to as reg = &lt;index&gt; in the SPI child nodes.
   If unspecified, a single SPI device without a chip select can be used.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f7b10bb56737..11a7e7bc31f2 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 10
<span class="p_del">-SUBLEVEL = 84</span>
<span class="p_add">+SUBLEVEL = 85</span>
 EXTRAVERSION =
 NAME = TOSSUG Baby Fish
 
<span class="p_header">diff --git a/arch/arc/include/asm/cmpxchg.h b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">index 03cd6894855d..90de5c528da2 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_chunk">@@ -25,10 +25,11 @@</span> <span class="p_context"> __cmpxchg(volatile void *ptr, unsigned long expected, unsigned long new)</span>
 	&quot;	scond   %3, [%1]	\n&quot;
 	&quot;	bnz     1b		\n&quot;
 	&quot;2:				\n&quot;
<span class="p_del">-	: &quot;=&amp;r&quot;(prev)</span>
<span class="p_del">-	: &quot;r&quot;(ptr), &quot;ir&quot;(expected),</span>
<span class="p_del">-	  &quot;r&quot;(new) /* can&#39;t be &quot;ir&quot;. scond can&#39;t take limm for &quot;b&quot; */</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_add">+	: &quot;=&amp;r&quot;(prev)	/* Early clobber, to prevent reg reuse */</span>
<span class="p_add">+	: &quot;r&quot;(ptr),	/* Not &quot;m&quot;: llock only supports reg direct addr mode */</span>
<span class="p_add">+	  &quot;ir&quot;(expected),</span>
<span class="p_add">+	  &quot;r&quot;(new)	/* can&#39;t be &quot;ir&quot;. scond can&#39;t take LIMM for &quot;b&quot; */</span>
<span class="p_add">+	: &quot;cc&quot;, &quot;memory&quot;); /* so that gcc knows memory is being written here */</span>
 
 	return prev;
 }
<span class="p_header">diff --git a/arch/arm64/kernel/vdso/Makefile b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">index 6d20b7d162d8..fdda6dd71ac6 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_chunk">@@ -15,6 +15,10 @@</span> <span class="p_context"> ccflags-y := -shared -fno-common -fno-builtin</span>
 ccflags-y += -nostdlib -Wl,-soname=linux-vdso.so.1 \
 		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
 
<span class="p_add">+# Workaround for bare-metal (ELF) toolchains that neglect to pass -shared</span>
<span class="p_add">+# down to collect2, resulting in silent corruption of the vDSO image.</span>
<span class="p_add">+ccflags-y += -Wl,-shared</span>
<span class="p_add">+</span>
 obj-y += vdso.o
 extra-y += vdso.lds vdso-offsets.h
 CPPFLAGS_vdso.lds += -P -C -U$(ARCH)
<span class="p_header">diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c</span>
<span class="p_header">index baa758d37021..76c1e6cd36fc 100644</span>
<span class="p_header">--- a/arch/arm64/mm/context.c</span>
<span class="p_header">+++ b/arch/arm64/mm/context.c</span>
<span class="p_chunk">@@ -92,6 +92,14 @@</span> <span class="p_context"> static void reset_context(void *info)</span>
 	unsigned int cpu = smp_processor_id();
 	struct mm_struct *mm = current-&gt;active_mm;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * current-&gt;active_mm could be init_mm for the idle thread immediately</span>
<span class="p_add">+	 * after secondary CPU boot or hotplug. TTBR0_EL1 is already set to</span>
<span class="p_add">+	 * the reserved value, so no need to reset any context.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mm == &amp;init_mm)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	smp_rmb();
 	asid = cpu_last_asid + cpu;
 
<span class="p_header">diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c</span>
<span class="p_header">index f497ca77925a..5c5516611b5e 100644</span>
<span class="p_header">--- a/arch/arm64/mm/init.c</span>
<span class="p_header">+++ b/arch/arm64/mm/init.c</span>
<span class="p_chunk">@@ -262,7 +262,7 @@</span> <span class="p_context"> static void __init free_unused_memmap(void)</span>
 		 * memmap entries are valid from the bank end aligned to
 		 * MAX_ORDER_NR_PAGES.
 		 */
<span class="p_del">-		prev_end = ALIGN(start + __phys_to_pfn(reg-&gt;size),</span>
<span class="p_add">+		prev_end = ALIGN(__phys_to_pfn(reg-&gt;base + reg-&gt;size),</span>
 				 MAX_ORDER_NR_PAGES);
 	}
 
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">index e75ef8219caf..c76f297b7149 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_chunk">@@ -1626,7 +1626,7 @@</span> <span class="p_context"> kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 		if (vcpu-&gt;mmio_needed == 2)
 			*gpr = *(int16_t *) run-&gt;mmio.data;
 		else
<span class="p_del">-			*gpr = *(int16_t *) run-&gt;mmio.data;</span>
<span class="p_add">+			*gpr = *(uint16_t *)run-&gt;mmio.data;</span>
 
 		break;
 	case 1:
<span class="p_header">diff --git a/drivers/acpi/acpica/utxfinit.c b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">index 41ebaaf8bb1a..ee58a62443bd 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_chunk">@@ -165,10 +165,12 @@</span> <span class="p_context"> acpi_status acpi_enable_subsystem(u32 flags)</span>
 	 * Obtain a permanent mapping for the FACS. This is required for the
 	 * Global Lock and the Firmware Waking Vector
 	 */
<span class="p_del">-	status = acpi_tb_initialize_facs();</span>
<span class="p_del">-	if (ACPI_FAILURE(status)) {</span>
<span class="p_del">-		ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_del">-		return_ACPI_STATUS(status);</span>
<span class="p_add">+	if (!(flags &amp; ACPI_NO_FACS_INIT)) {</span>
<span class="p_add">+		status = acpi_tb_initialize_facs();</span>
<span class="p_add">+		if (ACPI_FAILURE(status)) {</span>
<span class="p_add">+			ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_add">+			return_ACPI_STATUS(status);</span>
<span class="p_add">+		}</span>
 	}
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index 5d47a040129a..53d35b6fd8bb 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4150,9 +4150,10 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;ST3320[68]13AS&quot;,	&quot;SD1[5-9]&quot;,	ATA_HORKAGE_NONCQ |
 						ATA_HORKAGE_FIRMWARE_WARN },
 
<span class="p_del">-	/* Seagate Momentus SpinPoint M8 seem to have FPMDA_AA issues */</span>
<span class="p_add">+	/* drives which fail FPDMA_AA activation (some may freeze afterwards) */</span>
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2AR10001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2BA30001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
<span class="p_add">+	{ &quot;VB0250EAVER&quot;,	&quot;HPG7&quot;,		ATA_HORKAGE_BROKEN_FPDMA_AA },</span>
 
 	/* Blacklist entries taken from Silicon Image 3124/3132
 	   Windows driver .inf file - also several Linux problem reports */
<span class="p_chunk">@@ -4200,6 +4201,9 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;PIONEER DVD-RW  DVR-212D&quot;,	NULL,	ATA_HORKAGE_NOSETXFER },
 	{ &quot;PIONEER DVD-RW  DVR-216D&quot;,	NULL,	ATA_HORKAGE_NOSETXFER },
 
<span class="p_add">+	/* devices that don&#39;t properly handle TRIM commands */</span>
<span class="p_add">+	{ &quot;SuperSSpeed S238*&quot;,		NULL,	ATA_HORKAGE_NOTRIM, },</span>
<span class="p_add">+</span>
 	/*
 	 * Some WD SATA-I drives spin up and down erratically when the link
 	 * is put into the slumber mode.  We don&#39;t have full list of the
<span class="p_chunk">@@ -4504,7 +4508,8 @@</span> <span class="p_context"> static unsigned int ata_dev_set_xfermode(struct ata_device *dev)</span>
 	else /* In the ancient relic department - skip all of this */
 		return 0;
 
<span class="p_del">-	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 0);</span>
<span class="p_add">+	/* On some disks, this command causes spin-up, so we need longer timeout */</span>
<span class="p_add">+	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 15000);</span>
 
 	DPRINTK(&quot;EXIT, err_mask=%x\n&quot;, err_mask);
 	return err_mask;
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index 9933b4db7caf..04e7db668362 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -2512,7 +2512,8 @@</span> <span class="p_context"> static unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)</span>
 		rbuf[14] = (lowest_aligned &gt;&gt; 8) &amp; 0x3f;
 		rbuf[15] = lowest_aligned;
 
<span class="p_del">-		if (ata_id_has_trim(args-&gt;id)) {</span>
<span class="p_add">+		if (ata_id_has_trim(args-&gt;id) &amp;&amp;</span>
<span class="p_add">+		    !(dev-&gt;horkage &amp; ATA_HORKAGE_NOTRIM)) {</span>
 			rbuf[14] |= 0x80; /* TPE */
 
 			if (ata_id_has_zero_after_trim(args-&gt;id))
<span class="p_header">diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c</span>
<span class="p_header">index 00a565676583..8e08fab0ed2e 100644</span>
<span class="p_header">--- a/drivers/base/firmware_class.c</span>
<span class="p_header">+++ b/drivers/base/firmware_class.c</span>
<span class="p_chunk">@@ -513,10 +513,8 @@</span> <span class="p_context"> static void fw_dev_release(struct device *dev)</span>
 	module_put(THIS_MODULE);
 }
 
<span class="p_del">-static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+static int do_firmware_uevent(struct firmware_priv *fw_priv, struct kobj_uevent_env *env)</span>
 {
<span class="p_del">-	struct firmware_priv *fw_priv = to_firmware_priv(dev);</span>
<span class="p_del">-</span>
 	if (add_uevent_var(env, &quot;FIRMWARE=%s&quot;, fw_priv-&gt;buf-&gt;fw_id))
 		return -ENOMEM;
 	if (add_uevent_var(env, &quot;TIMEOUT=%i&quot;, loading_timeout))
<span class="p_chunk">@@ -527,6 +525,18 @@</span> <span class="p_context"> static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
 	return 0;
 }
 
<span class="p_add">+static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct firmware_priv *fw_priv = to_firmware_priv(dev);</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;fw_lock);</span>
<span class="p_add">+	if (fw_priv-&gt;buf)</span>
<span class="p_add">+		err = do_firmware_uevent(fw_priv, env);</span>
<span class="p_add">+	mutex_unlock(&amp;fw_lock);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct class firmware_class = {
 	.name		= &quot;firmware&quot;,
 	.class_attrs	= firmware_class_attrs,
<span class="p_header">diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c</span>
<span class="p_header">index 6a66f0b7d3d4..4f3d70a9d721 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regmap.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regmap.c</span>
<span class="p_chunk">@@ -1586,7 +1586,7 @@</span> <span class="p_context"> int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val,</span>
 					  &amp;ival);
 			if (ret != 0)
 				return ret;
<span class="p_del">-			memcpy(val + (i * val_bytes), &amp;ival, val_bytes);</span>
<span class="p_add">+			map-&gt;format.format_val(val + (i * val_bytes), ival, 0);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index dd297099c99d..f78cbbb88bd4 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -1851,11 +1851,11 @@</span> <span class="p_context"> static struct rbd_obj_request *rbd_obj_request_create(const char *object_name,</span>
 	rbd_assert(obj_request_type_valid(type));
 
 	size = strlen(object_name) + 1;
<span class="p_del">-	name = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+	name = kmalloc(size, GFP_NOIO);</span>
 	if (!name)
 		return NULL;
 
<span class="p_del">-	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_KERNEL);</span>
<span class="p_add">+	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_NOIO);</span>
 	if (!obj_request) {
 		kfree(name);
 		return NULL;
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 92b985317770..537ad6897784 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -1234,6 +1234,8 @@</span> <span class="p_context"> static int btusb_setup_intel(struct hci_dev *hdev)</span>
 	}
 	fw_ptr = fw-&gt;data;
 
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+</span>
 	/* This Intel specific command enables the manufacturer mode of the
 	 * controller.
 	 *
<span class="p_header">diff --git a/drivers/char/agp/intel-gtt.c b/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">index b8e2014cb9cb..051aadb75e2c 100644</span>
<span class="p_header">--- a/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">+++ b/drivers/char/agp/intel-gtt.c</span>
<span class="p_chunk">@@ -583,7 +583,7 @@</span> <span class="p_context"> static inline int needs_ilk_vtd_wa(void)</span>
 	/* Query intel_iommu to see if we need the workaround. Presumably that
 	 * was loaded first.
 	 */
<span class="p_del">-	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_HB ||</span>
<span class="p_add">+	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_D_IG ||</span>
 	     gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_IG) &amp;&amp;
 	     intel_iommu_gfx_mapped)
 		return 1;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">index 09df26f9621d..a6524c3efdf7 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_chunk">@@ -618,6 +618,9 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	ibmvtpm-&gt;dev = dev;</span>
<span class="p_add">+	ibmvtpm-&gt;vdev = vio_dev;</span>
<span class="p_add">+</span>
 	crq_q = &amp;ibmvtpm-&gt;crq_queue;
 	crq_q-&gt;crq_addr = (struct ibmvtpm_crq *)get_zeroed_page(GFP_KERNEL);
 	if (!crq_q-&gt;crq_addr) {
<span class="p_chunk">@@ -662,8 +665,6 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 
 	crq_q-&gt;index = 0;
 
<span class="p_del">-	ibmvtpm-&gt;dev = dev;</span>
<span class="p_del">-	ibmvtpm-&gt;vdev = vio_dev;</span>
 	TPM_VPRIV(chip) = (void *)ibmvtpm;
 
 	spin_lock_init(&amp;ibmvtpm-&gt;rtce_lock);
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">index c3a93fece819..5b11022d7745 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle.c</span>
<span class="p_chunk">@@ -135,6 +135,9 @@</span> <span class="p_context"> int cpuidle_idle_call(void)</span>
 
 	/* ask the governor for the next state */
 	next_state = cpuidle_curr_governor-&gt;select(drv, dev);
<span class="p_add">+	if (next_state &lt; 0)</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
 	if (need_resched()) {
 		dev-&gt;last_residency = 0;
 		/* give the governor an opportunity to reflect on the outcome */
<span class="p_header">diff --git a/drivers/cpuidle/governors/menu.c b/drivers/cpuidle/governors/menu.c</span>
<span class="p_header">index bc580b67a652..67fd901f6fc9 100644</span>
<span class="p_header">--- a/drivers/cpuidle/governors/menu.c</span>
<span class="p_header">+++ b/drivers/cpuidle/governors/menu.c</span>
<span class="p_chunk">@@ -269,7 +269,7 @@</span> <span class="p_context"> static int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev)</span>
 		data-&gt;needs_update = 0;
 	}
 
<span class="p_del">-	data-&gt;last_state_idx = 0;</span>
<span class="p_add">+	data-&gt;last_state_idx = CPUIDLE_DRIVER_STATE_START - 1;</span>
 	data-&gt;exit_us = 0;
 
 	/* Special case when user has set very strict latency requirement */
<span class="p_header">diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c</span>
<span class="p_header">index d64ae14f2706..43092c317897 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.c</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.c</span>
<span class="p_chunk">@@ -393,7 +393,8 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 	dma_cookie_t cookie = 0;
 	int busy = mv_chan_is_busy(mv_chan);
 	u32 current_desc = mv_chan_get_current_desc(mv_chan);
<span class="p_del">-	int seen_current = 0;</span>
<span class="p_add">+	int current_cleaned = 0;</span>
<span class="p_add">+	struct mv_xor_desc *hw_desc;</span>
 
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;%s %d\n&quot;, __func__, __LINE__);
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;current_desc %x\n&quot;, current_desc);
<span class="p_chunk">@@ -405,38 +406,57 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 
 	list_for_each_entry_safe(iter, _iter, &amp;mv_chan-&gt;chain,
 					chain_node) {
<span class="p_del">-		prefetch(_iter);</span>
<span class="p_del">-		prefetch(&amp;_iter-&gt;async_tx);</span>
 
<span class="p_del">-		/* do not advance past the current descriptor loaded into the</span>
<span class="p_del">-		 * hardware channel, subsequent descriptors are either in</span>
<span class="p_del">-		 * process or have not been submitted</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (seen_current)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		/* clean finished descriptors */</span>
<span class="p_add">+		hw_desc = iter-&gt;hw_desc;</span>
<span class="p_add">+		if (hw_desc-&gt;status &amp; XOR_DESC_SUCCESS) {</span>
<span class="p_add">+			cookie = mv_xor_run_tx_complete_actions(iter, mv_chan,</span>
<span class="p_add">+								cookie);</span>
 
<span class="p_del">-		/* stop the search if we reach the current descriptor and the</span>
<span class="p_del">-		 * channel is busy</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_del">-			seen_current = 1;</span>
<span class="p_del">-			if (busy)</span>
<span class="p_add">+			/* done processing desc, clean slot */</span>
<span class="p_add">+			mv_xor_clean_slot(iter, mv_chan);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* break if we did cleaned the current */</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 0;</span>
 				break;
<span class="p_add">+			}</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		cookie = mv_xor_run_tx_complete_actions(iter, mv_chan, cookie);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mv_xor_clean_slot(iter, mv_chan))</span>
<span class="p_del">-			break;</span>
 	}
 
 	if ((busy == 0) &amp;&amp; !list_empty(&amp;mv_chan-&gt;chain)) {
<span class="p_del">-		struct mv_xor_desc_slot *chain_head;</span>
<span class="p_del">-		chain_head = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_del">-					struct mv_xor_desc_slot,</span>
<span class="p_del">-					chain_node);</span>
<span class="p_del">-</span>
<span class="p_del">-		mv_xor_start_new_chain(mv_chan, chain_head);</span>
<span class="p_add">+		if (current_cleaned) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * current descriptor cleaned and removed, run</span>
<span class="p_add">+			 * from list head</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			iter = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_add">+					  struct mv_xor_desc_slot,</span>
<span class="p_add">+					  chain_node);</span>
<span class="p_add">+			mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (!list_is_last(&amp;iter-&gt;chain_node, &amp;mv_chan-&gt;chain)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * descriptors are still waiting after</span>
<span class="p_add">+				 * current, trigger them</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				iter = list_entry(iter-&gt;chain_node.next,</span>
<span class="p_add">+						  struct mv_xor_desc_slot,</span>
<span class="p_add">+						  chain_node);</span>
<span class="p_add">+				mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * some descriptors are still waiting</span>
<span class="p_add">+				 * to be cleaned</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				tasklet_schedule(&amp;mv_chan-&gt;irq_tasklet);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cookie &gt; 0)
<span class="p_header">diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h</span>
<span class="p_header">index c632a4761fcf..e003851cd4e5 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.h</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.h</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"></span>
 #define XOR_OPERATION_MODE_XOR		0
 #define XOR_OPERATION_MODE_MEMCPY	2
 #define XOR_OPERATION_MODE_MEMSET	4
<span class="p_add">+#define XOR_DESC_SUCCESS		0x40000000</span>
 
 #define XOR_CURR_DESC(chan)	(chan-&gt;mmr_base + 0x210 + (chan-&gt;idx * 4))
 #define XOR_NEXT_DESC(chan)	(chan-&gt;mmr_base + 0x200 + (chan-&gt;idx * 4))
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index 8759d699bd8e..c24c35606836 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -1955,8 +1955,11 @@</span> <span class="p_context"> int drm_mode_setcrtc(struct drm_device *dev, void *data,</span>
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EINVAL;
 
<span class="p_del">-	/* For some reason crtc x/y offsets are signed internally. */</span>
<span class="p_del">-	if (crtc_req-&gt;x &gt; INT_MAX || crtc_req-&gt;y &gt; INT_MAX)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Universal plane src offsets are only 16.16, prevent havoc for</span>
<span class="p_add">+	 * drivers using universal plane code internally.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (crtc_req-&gt;x &amp; 0xffff0000 || crtc_req-&gt;y &amp; 0xffff0000)</span>
 		return -ERANGE;
 
 	drm_modeset_lock_all(dev);
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_cmd.c b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">index f86771481317..5a48d7419baf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_chunk">@@ -500,6 +500,7 @@</span> <span class="p_context"> int qxl_hw_surface_alloc(struct qxl_device *qdev,</span>
 
 	cmd = (struct qxl_surface_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_SURFACE_CMD_CREATE;
<span class="p_add">+	cmd-&gt;flags = QXL_SURF_FLAG_KEEP_DATA;</span>
 	cmd-&gt;u.surface_create.format = surf-&gt;surf.format;
 	cmd-&gt;u.surface_create.width = surf-&gt;surf.width;
 	cmd-&gt;u.surface_create.height = surf-&gt;surf.height;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_gart.c b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">index 2915a1c56934..c4bb0bc2a1d9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_chunk">@@ -251,8 +251,10 @@</span> <span class="p_context"> void radeon_gart_unbind(struct radeon_device *rdev, unsigned offset,</span>
 			}
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -294,8 +296,10 @@</span> <span class="p_context"> int radeon_gart_bind(struct radeon_device *rdev, unsigned offset,</span>
 			}
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index 1fe12ab5c5ea..db83d075606e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -73,10 +73,12 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	mutex_lock(&amp;mode_config-&gt;mutex);</span>
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
 			radeon_connector_hotplug(connector);
 	}
<span class="p_add">+	mutex_unlock(&amp;mode_config-&gt;mutex);</span>
 	/* Just fire off a uevent and let userspace tell us what to do */
 	drm_helper_hpd_irq_event(dev);
 }
<span class="p_header">diff --git a/drivers/hwmon/mcp3021.c b/drivers/hwmon/mcp3021.c</span>
<span class="p_header">index eedb32292d6d..f712cc785ef2 100644</span>
<span class="p_header">--- a/drivers/hwmon/mcp3021.c</span>
<span class="p_header">+++ b/drivers/hwmon/mcp3021.c</span>
<span class="p_chunk">@@ -31,14 +31,11 @@</span> <span class="p_context"></span>
 /* output format */
 #define MCP3021_SAR_SHIFT	2
 #define MCP3021_SAR_MASK	0x3ff
<span class="p_del">-</span>
 #define MCP3021_OUTPUT_RES	10	/* 10-bit resolution */
<span class="p_del">-#define MCP3021_OUTPUT_SCALE	4</span>
 
 #define MCP3221_SAR_SHIFT	0
 #define MCP3221_SAR_MASK	0xfff
 #define MCP3221_OUTPUT_RES	12	/* 12-bit resolution */
<span class="p_del">-#define MCP3221_OUTPUT_SCALE	1</span>
 
 enum chips {
 	mcp3021,
<span class="p_chunk">@@ -54,7 +51,6 @@</span> <span class="p_context"> struct mcp3021_data {</span>
 	u16 sar_shift;
 	u16 sar_mask;
 	u8 output_res;
<span class="p_del">-	u8 output_scale;</span>
 };
 
 static int mcp3021_read16(struct i2c_client *client)
<span class="p_chunk">@@ -84,13 +80,7 @@</span> <span class="p_context"> static int mcp3021_read16(struct i2c_client *client)</span>
 
 static inline u16 volts_from_reg(struct mcp3021_data *data, u16 val)
 {
<span class="p_del">-	if (val == 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	val = val * data-&gt;output_scale - data-&gt;output_scale / 2;</span>
<span class="p_del">-</span>
<span class="p_del">-	return val * DIV_ROUND_CLOSEST(data-&gt;vdd,</span>
<span class="p_del">-			(1 &lt;&lt; data-&gt;output_res) * data-&gt;output_scale);</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(data-&gt;vdd * val, 1 &lt;&lt; data-&gt;output_res);</span>
 }
 
 static ssize_t show_in_input(struct device *dev, struct device_attribute *attr,
<span class="p_chunk">@@ -132,14 +122,12 @@</span> <span class="p_context"> static int mcp3021_probe(struct i2c_client *client,</span>
 		data-&gt;sar_shift = MCP3021_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3021_SAR_MASK;
 		data-&gt;output_res = MCP3021_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3021_OUTPUT_SCALE;</span>
 		break;
 
 	case mcp3221:
 		data-&gt;sar_shift = MCP3221_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3221_SAR_MASK;
 		data-&gt;output_res = MCP3221_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3221_OUTPUT_SCALE;</span>
 		break;
 	}
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">index 09324d0178d5..ceabcfeb587c 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_chunk">@@ -63,6 +63,9 @@</span> <span class="p_context"></span>
 #define	AT91_TWI_UNRE		0x0080	/* Underrun Error */
 #define	AT91_TWI_NACK		0x0100	/* Not Acknowledged */
 
<span class="p_add">+#define	AT91_TWI_INT_MASK \</span>
<span class="p_add">+	(AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY | AT91_TWI_NACK)</span>
<span class="p_add">+</span>
 #define	AT91_TWI_IER		0x0024	/* Interrupt Enable Register */
 #define	AT91_TWI_IDR		0x0028	/* Interrupt Disable Register */
 #define	AT91_TWI_IMR		0x002c	/* Interrupt Mask Register */
<span class="p_chunk">@@ -118,13 +121,12 @@</span> <span class="p_context"> static void at91_twi_write(struct at91_twi_dev *dev, unsigned reg, unsigned val)</span>
 
 static void at91_disable_twi_interrupts(struct at91_twi_dev *dev)
 {
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IDR,</span>
<span class="p_del">-		       AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_INT_MASK);</span>
 }
 
 static void at91_twi_irq_save(struct at91_twi_dev *dev)
 {
<span class="p_del">-	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; 0x7;</span>
<span class="p_add">+	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; AT91_TWI_INT_MASK;</span>
 	at91_disable_twi_interrupts(dev);
 }
 
<span class="p_chunk">@@ -214,6 +216,14 @@</span> <span class="p_context"> static void at91_twi_write_data_dma_callback(void *data)</span>
 	dma_unmap_single(dev-&gt;dev, sg_dma_address(&amp;dev-&gt;dma.sg),
 			 dev-&gt;buf_len, DMA_TO_DEVICE);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When this callback is called, THR/TX FIFO is likely not to be empty</span>
<span class="p_add">+	 * yet. So we have to wait for TXCOMP or NACK bits to be set into the</span>
<span class="p_add">+	 * Status Register to be sure that the STOP bit has been sent and the</span>
<span class="p_add">+	 * transfer is completed. The NACK interrupt has already been enabled,</span>
<span class="p_add">+	 * we just have to enable TXCOMP one.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);
 }
 
<span class="p_chunk">@@ -308,7 +318,7 @@</span> <span class="p_context"> static void at91_twi_read_data_dma_callback(void *data)</span>
 	/* The last two bytes have to be read without using dma */
 	dev-&gt;buf += dev-&gt;buf_len - 2;
 	dev-&gt;buf_len = 2;
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY | AT91_TWI_TXCOMP);</span>
 }
 
 static void at91_twi_read_data_dma(struct at91_twi_dev *dev)
<span class="p_chunk">@@ -369,7 +379,7 @@</span> <span class="p_context"> static irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)</span>
 	/* catch error flags */
 	dev-&gt;transfer_status |= status;
 
<span class="p_del">-	if (irqstatus &amp; AT91_TWI_TXCOMP) {</span>
<span class="p_add">+	if (irqstatus &amp; (AT91_TWI_TXCOMP | AT91_TWI_NACK)) {</span>
 		at91_disable_twi_interrupts(dev);
 		complete(&amp;dev-&gt;cmd_complete);
 	}
<span class="p_chunk">@@ -382,6 +392,34 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 	int ret;
 	bool has_unre_flag = dev-&gt;pdata-&gt;has_unre_flag;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * WARNING: the TXCOMP bit in the Status Register is NOT a clear on</span>
<span class="p_add">+	 * read flag but shows the state of the transmission at the time the</span>
<span class="p_add">+	 * Status Register is read. According to the programmer datasheet,</span>
<span class="p_add">+	 * TXCOMP is set when both holding register and internal shifter are</span>
<span class="p_add">+	 * empty and STOP condition has been sent.</span>
<span class="p_add">+	 * Consequently, we should enable NACK interrupt rather than TXCOMP to</span>
<span class="p_add">+	 * detect transmission failure.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Besides, the TXCOMP bit is already set before the i2c transaction</span>
<span class="p_add">+	 * has been started. For read transactions, this bit is cleared when</span>
<span class="p_add">+	 * writing the START bit into the Control Register. So the</span>
<span class="p_add">+	 * corresponding interrupt can safely be enabled just after.</span>
<span class="p_add">+	 * However for write transactions managed by the CPU, we first write</span>
<span class="p_add">+	 * into THR, so TXCOMP is cleared. Then we can safely enable TXCOMP</span>
<span class="p_add">+	 * interrupt. If TXCOMP interrupt were enabled before writing into THR,</span>
<span class="p_add">+	 * the interrupt handler would be called immediately and the i2c command</span>
<span class="p_add">+	 * would be reported as completed.</span>
<span class="p_add">+	 * Also when a write transaction is managed by the DMA controller,</span>
<span class="p_add">+	 * enabling the TXCOMP interrupt in this function may lead to a race</span>
<span class="p_add">+	 * condition since we don&#39;t know whether the TXCOMP interrupt is enabled</span>
<span class="p_add">+	 * before or after the DMA has started to write into THR. So the TXCOMP</span>
<span class="p_add">+	 * interrupt is enabled later by at91_twi_write_data_dma_callback().</span>
<span class="p_add">+	 * Immediately after in that DMA callback, we still need to send the</span>
<span class="p_add">+	 * STOP condition manually writing the corresponding bit into the</span>
<span class="p_add">+	 * Control Register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	dev_dbg(dev-&gt;dev, &quot;transfer: %s %d bytes.\n&quot;,
 		(dev-&gt;msg-&gt;flags &amp; I2C_M_RD) ? &quot;read&quot; : &quot;write&quot;, dev-&gt;buf_len);
 
<span class="p_chunk">@@ -412,26 +450,24 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 		 * seems to be the best solution.
 		 */
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_read_data_dma(dev);
<span class="p_del">-			/*</span>
<span class="p_del">-			 * It is important to enable TXCOMP irq here because</span>
<span class="p_del">-			 * doing it only when transferring the last two bytes</span>
<span class="p_del">-			 * will mask NACK errors since TXCOMP is set when a</span>
<span class="p_del">-			 * NACK occurs.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER,</span>
<span class="p_del">-			       AT91_TWI_TXCOMP);</span>
<span class="p_del">-		} else</span>
<span class="p_add">+		} else {</span>
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-			       AT91_TWI_TXCOMP | AT91_TWI_RXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_RXRDY);</span>
<span class="p_add">+		}</span>
 	} else {
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_write_data_dma(dev);
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 		} else {
 			at91_twi_write_next_byte(dev);
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-				AT91_TWI_TXCOMP | AT91_TWI_TXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_TXRDY);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/iio/dac/ad5624r_spi.c b/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_header">index bb298aaff321..6deac5af1cfd 100644</span>
<span class="p_header">--- a/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_header">+++ b/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_chunk">@@ -22,7 +22,7 @@</span> <span class="p_context"></span>
 #include &quot;ad5624r.h&quot;
 
 static int ad5624r_spi_write(struct spi_device *spi,
<span class="p_del">-			     u8 cmd, u8 addr, u16 val, u8 len)</span>
<span class="p_add">+			     u8 cmd, u8 addr, u16 val, u8 shift)</span>
 {
 	u32 data;
 	u8 msg[3];
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> static int ad5624r_spi_write(struct spi_device *spi,</span>
 	 * 14-, 12-bit input code followed by 0, 2, or 4 don&#39;t care bits,
 	 * for the AD5664R, AD5644R, and AD5624R, respectively.
 	 */
<span class="p_del">-	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; (16 - len));</span>
<span class="p_add">+	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; shift);</span>
 	msg[0] = data &gt;&gt; 16;
 	msg[1] = data &gt;&gt; 8;
 	msg[2] = data;
<span class="p_header">diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">index 8019e642d2f5..43aa807d78bd 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_chunk">@@ -49,6 +49,8 @@</span> <span class="p_context"> static int</span>
 isert_rdma_accept(struct isert_conn *isert_conn);
 struct rdma_cm_id *isert_setup_id(struct isert_np *isert_np);
 
<span class="p_add">+static void isert_release_work(struct work_struct *work);</span>
<span class="p_add">+</span>
 static void
 isert_qp_event_callback(struct ib_event *e, void *context)
 {
<span class="p_chunk">@@ -202,7 +204,7 @@</span> <span class="p_context"> fail:</span>
 static void
 isert_free_rx_descriptors(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
<span class="p_add">+	struct ib_device *ib_dev = isert_conn-&gt;conn_device-&gt;ib_device;</span>
 	struct iser_rx_desc *rx_desc;
 	int i;
 
<span class="p_chunk">@@ -432,6 +434,7 @@</span> <span class="p_context"> isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)</span>
 	init_completion(&amp;isert_conn-&gt;conn_wait_comp_err);
 	kref_init(&amp;isert_conn-&gt;conn_kref);
 	mutex_init(&amp;isert_conn-&gt;conn_mutex);
<span class="p_add">+	INIT_WORK(&amp;isert_conn-&gt;release_work, isert_release_work);</span>
 
 	isert_conn-&gt;conn_cm_id = cma_id;
 	isert_conn-&gt;responder_resources = event-&gt;param.conn.responder_resources;
<span class="p_chunk">@@ -527,14 +530,15 @@</span> <span class="p_context"> out:</span>
 static void
 isert_connect_release(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
 	struct isert_device *device = isert_conn-&gt;conn_device;
 	int cq_index;
<span class="p_add">+	struct ib_device *ib_dev = device-&gt;ib_device;</span>
 
 	pr_debug(&quot;Entering isert_connect_release(): &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;);
 
 	isert_free_rx_descriptors(isert_conn);
<span class="p_del">-	rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
<span class="p_add">+	if (isert_conn-&gt;conn_cm_id)</span>
<span class="p_add">+		rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
 
 	if (isert_conn-&gt;conn_qp) {
 		cq_index = ((struct isert_cq_desc *)
<span class="p_chunk">@@ -673,6 +677,7 @@</span> <span class="p_context"> isert_disconnected_handler(struct rdma_cm_id *cma_id,</span>
 {
 	struct isert_np *isert_np = cma_id-&gt;context;
 	struct isert_conn *isert_conn;
<span class="p_add">+	bool terminating = false;</span>
 
 	if (isert_np-&gt;np_cm_id == cma_id)
 		return isert_np_cma_handler(cma_id-&gt;context, event);
<span class="p_chunk">@@ -680,21 +685,37 @@</span> <span class="p_context"> isert_disconnected_handler(struct rdma_cm_id *cma_id,</span>
 	isert_conn = cma_id-&gt;qp-&gt;qp_context;
 
 	mutex_lock(&amp;isert_conn-&gt;conn_mutex);
<span class="p_add">+	terminating = (isert_conn-&gt;state == ISER_CONN_TERMINATING);</span>
 	isert_conn_terminate(isert_conn);
 	mutex_unlock(&amp;isert_conn-&gt;conn_mutex);
 
 	pr_info(&quot;conn %p completing conn_wait\n&quot;, isert_conn);
 	complete(&amp;isert_conn-&gt;conn_wait);
 
<span class="p_add">+	if (terminating)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;isert_np-&gt;np_accept_mutex);</span>
<span class="p_add">+	if (!list_empty(&amp;isert_conn-&gt;conn_accept_node)) {</span>
<span class="p_add">+		list_del_init(&amp;isert_conn-&gt;conn_accept_node);</span>
<span class="p_add">+		isert_put_conn(isert_conn);</span>
<span class="p_add">+		queue_work(isert_release_wq, &amp;isert_conn-&gt;release_work);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_unlock(&amp;isert_np-&gt;np_accept_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
 	return 0;
 }
 
<span class="p_del">-static void</span>
<span class="p_add">+static int</span>
 isert_connect_error(struct rdma_cm_id *cma_id)
 {
 	struct isert_conn *isert_conn = cma_id-&gt;qp-&gt;qp_context;
 
<span class="p_add">+	isert_conn-&gt;conn_cm_id = NULL;</span>
 	isert_put_conn(isert_conn);
<span class="p_add">+</span>
<span class="p_add">+	return -1;</span>
 }
 
 static int
<span class="p_chunk">@@ -724,7 +745,7 @@</span> <span class="p_context"> isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)</span>
 	case RDMA_CM_EVENT_REJECTED:       /* FALLTHRU */
 	case RDMA_CM_EVENT_UNREACHABLE:    /* FALLTHRU */
 	case RDMA_CM_EVENT_CONNECT_ERROR:
<span class="p_del">-		isert_connect_error(cma_id);</span>
<span class="p_add">+		ret = isert_connect_error(cma_id);</span>
 		break;
 	default:
 		pr_err(&quot;Unhandled RDMA CMA event: %d\n&quot;, event-&gt;event);
<span class="p_chunk">@@ -2418,7 +2439,6 @@</span> <span class="p_context"> static void isert_wait_conn(struct iscsi_conn *conn)</span>
 
 	wait_for_completion(&amp;isert_conn-&gt;conn_wait_comp_err);
 
<span class="p_del">-	INIT_WORK(&amp;isert_conn-&gt;release_work, isert_release_work);</span>
 	queue_work(isert_release_wq, &amp;isert_conn-&gt;release_work);
 }
 
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index aaf77b07bb72..631fe3e9c6e5 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -6221,7 +6221,7 @@</span> <span class="p_context"> static int update_array_info(struct mddev *mddev, mdu_array_info_t *info)</span>
 	    mddev-&gt;ctime         != info-&gt;ctime         ||
 	    mddev-&gt;level         != info-&gt;level         ||
 /*	    mddev-&gt;layout        != info-&gt;layout        || */
<span class="p_del">-	    !mddev-&gt;persistent	 != info-&gt;not_persistent||</span>
<span class="p_add">+	    mddev-&gt;persistent	 != !info-&gt;not_persistent ||</span>
 	    mddev-&gt;chunk_sectors != info-&gt;chunk_size &gt;&gt; 9 ||
 	    /* ignore bottom 8 bits of state, and allow SB_BITMAP_PRESENT to change */
 	    ((state^info-&gt;state) &amp; 0xfffffe00)
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">index b88757cd0d1d..a03178e91a79 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_chunk">@@ -309,8 +309,8 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 
 		if (s &lt; 0 &amp;&amp; nr_center &lt; -s) {
 			/* not enough in central node */
<span class="p_del">-			shift(left, center, nr_center);</span>
<span class="p_del">-			s = nr_center - target;</span>
<span class="p_add">+			shift(left, center, -nr_center);</span>
<span class="p_add">+			s += nr_center;</span>
 			shift(left, right, s);
 			nr_right += s;
 		} else
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 		if (s &gt; 0 &amp;&amp; nr_center &lt; s) {
 			/* not enough in central node */
 			shift(center, right, nr_center);
<span class="p_del">-			s = target - nr_center;</span>
<span class="p_add">+			s -= nr_center;</span>
 			shift(left, right, s);
 			nr_left -= s;
 		} else
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 0a7592e88811..e3ecb0b824b5 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -240,7 +240,7 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 	int r;
 	struct del_stack *s;
 
<span class="p_del">-	s = kmalloc(sizeof(*s), GFP_KERNEL);</span>
<span class="p_add">+	s = kmalloc(sizeof(*s), GFP_NOIO);</span>
 	if (!s)
 		return -ENOMEM;
 	s-&gt;tm = info-&gt;tm;
<span class="p_header">diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">index fb504f1e9125..5930aee6b5d0 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_chunk">@@ -606,6 +606,10 @@</span> <span class="p_context"> static int af9013_set_frontend(struct dvb_frontend *fe)</span>
 			}
 		}
 
<span class="p_add">+		/* Return an error if can&#39;t find bandwidth or the right clock */</span>
<span class="p_add">+		if (i == ARRAY_SIZE(coeff_lut))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
 			sizeof(coeff_lut[i].val));
 	}
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24116.c b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">index 2916d7c74a1d..7bc68b355c0b 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_chunk">@@ -963,6 +963,10 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	struct cx24116_state *state = fe-&gt;demodulator_priv;
 	int i, ret;
 
<span class="p_add">+	/* Validate length */</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
<span class="p_add">+                return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Dump DiSEqC message */
 	if (debug) {
 		printk(KERN_INFO &quot;cx24116: %s(&quot;, __func__);
<span class="p_chunk">@@ -974,10 +978,6 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 		printk(&quot;) toneburst=%d\n&quot;, toneburst);
 	}
 
<span class="p_del">-	/* Validate length */</span>
<span class="p_del">-	if (d-&gt;msg_len &gt; (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	/* DiSEqC message */
 	for (i = 0; i &lt; d-&gt;msg_len; i++)
 		state-&gt;dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d-&gt;msg[i];
<span class="p_header">diff --git a/drivers/media/dvb-frontends/s5h1420.c b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">index 93eeaf7118fd..0b4f8fe6bf99 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static int s5h1420_send_master_cmd (struct dvb_frontend* fe,</span>
 	int result = 0;
 
 	dprintk(&quot;enter %s\n&quot;, __func__);
<span class="p_del">-	if (cmd-&gt;msg_len &gt; 8)</span>
<span class="p_add">+	if (cmd-&gt;msg_len &gt; sizeof(cmd-&gt;msg))</span>
 		return -EINVAL;
 
 	/* setup for DISEQC */
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 56998eca1a8d..885ba4a19a6c 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -202,6 +202,8 @@</span> <span class="p_context"> static ssize_t power_ro_lock_show(struct device *dev,</span>
 
 	ret = snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, locked);
 
<span class="p_add">+	mmc_blk_put(md);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1833,9 +1835,11 @@</span> <span class="p_context"> static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)</span>
 			break;
 		case MMC_BLK_CMD_ERR:
 			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
<span class="p_del">-			if (!mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			goto cmd_abort;</span>
<span class="p_add">+			if (mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_add">+				goto cmd_abort;</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				goto start_new_req;</span>
<span class="p_add">+			break;</span>
 		case MMC_BLK_RETRY:
 			if (retry++ &lt; 5)
 				break;
<span class="p_header">diff --git a/drivers/mtd/maps/dc21285.c b/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">index f8a7dd14cee0..70a3db3ab856 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/dc21285.c</span>
<span class="p_chunk">@@ -38,9 +38,9 @@</span> <span class="p_context"> static void nw_en_write(void)</span>
 	 * we want to write a bit pattern XXX1 to Xilinx to enable
 	 * the write gate, which will be open for about the next 2ms.
 	 */
<span class="p_del">-	spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
 	nw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);
<span class="p_del">-	spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
 
 	/*
 	 * let the ISA bus to catch on...
<span class="p_header">diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">index 5073cbc796d8..32d5e40c6863 100644</span>
<span class="p_header">--- a/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">+++ b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_chunk">@@ -199,6 +199,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 		return -ERESTARTSYS; /* FIXME: busy loop! -arnd*/
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -222,6 +223,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 
 unlock:
 	dev-&gt;open++;
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -232,6 +234,7 @@</span> <span class="p_context"> error_release:</span>
 error_put:
 	module_put(dev-&gt;tr-&gt;owner);
 	kref_put(&amp;dev-&gt;ref, blktrans_dev_release);
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -245,6 +248,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		return;
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (--dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -258,6 +262,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		__put_mtd_device(dev-&gt;mtd);
 	}
 unlock:
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 }
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">index 82a1b5b16b62..c7f23d271058 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_chunk">@@ -195,11 +195,13 @@</span> <span class="p_context"> static bool ath_prepare_reset(struct ath_softc *sc)</span>
 	ath9k_debug_samp_bb_mac(sc);
 	ath9k_hw_disable_interrupts(ah);
 
<span class="p_del">-	if (!ath_drain_all_txq(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ath_stoprecv(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_add">+	if (AR_SREV_9300_20_OR_LATER(ah)) {</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+	}</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/pcmcia/topic.h b/drivers/pcmcia/topic.h</span>
<span class="p_header">index 615a45a8fe86..582688fe7505 100644</span>
<span class="p_header">--- a/drivers/pcmcia/topic.h</span>
<span class="p_header">+++ b/drivers/pcmcia/topic.h</span>
<span class="p_chunk">@@ -104,6 +104,9 @@</span> <span class="p_context"></span>
 #define TOPIC_EXCA_IF_CONTROL		0x3e	/* 8 bit */
 #define TOPIC_EXCA_IFC_33V_ENA		0x01
 
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN		0x3e	/* 16-bit */</span>
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN_WBEN	0x0400</span>
<span class="p_add">+</span>
 static void topic97_zoom_video(struct pcmcia_socket *sock, int onoff)
 {
 	struct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);
<span class="p_chunk">@@ -138,6 +141,7 @@</span> <span class="p_context"> static int topic97_override(struct yenta_socket *socket)</span>
 static int topic95_override(struct yenta_socket *socket)
 {
 	u8 fctrl;
<span class="p_add">+	u16 ppbcn;</span>
 
 	/* enable 3.3V support for 16bit cards */
 	fctrl = exca_readb(socket, TOPIC_EXCA_IF_CONTROL);
<span class="p_chunk">@@ -146,6 +150,18 @@</span> <span class="p_context"> static int topic95_override(struct yenta_socket *socket)</span>
 	/* tell yenta to use exca registers to power 16bit cards */
 	socket-&gt;flags |= YENTA_16BIT_POWER_EXCA | YENTA_16BIT_POWER_DF;
 
<span class="p_add">+	/* Disable write buffers to prevent lockups under load with numerous</span>
<span class="p_add">+	   Cardbus cards, observed on Tecra 500CDT and reported elsewhere on the</span>
<span class="p_add">+	   net.  This is not a power-on default according to the datasheet</span>
<span class="p_add">+	   but some BIOSes seem to set it. */</span>
<span class="p_add">+	if (pci_read_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, &amp;ppbcn) == 0</span>
<span class="p_add">+	    &amp;&amp; socket-&gt;dev-&gt;revision &lt;= 7</span>
<span class="p_add">+	    &amp;&amp; (ppbcn &amp; TOPIC_PCI_CFG_PPBCN_WBEN)) {</span>
<span class="p_add">+		ppbcn &amp;= ~TOPIC_PCI_CFG_PPBCN_WBEN;</span>
<span class="p_add">+		pci_write_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, ppbcn);</span>
<span class="p_add">+		dev_info(&amp;socket-&gt;dev-&gt;dev, &quot;Disabled ToPIC95 Cardbus write buffers.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-370.c b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">index 48e21a229483..c99e64ac8e08 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_chunk">@@ -358,11 +358,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode mv88f6710_mpp_modes[] = {</span>
 	MPP_MODE(64,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;miso&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs1&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs1&quot;)),</span>
 	MPP_MODE(65,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;mosi&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs2&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs2&quot;)),</span>
 };
 
 static struct mvebu_pinctrl_soc_info armada_370_pinctrl_info;
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">index ab5dc04b3e8a..5923a9ef70cc 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_chunk">@@ -14,10 +14,7 @@</span> <span class="p_context"></span>
  * available: mv78230, mv78260 and mv78460. From a pin muxing
  * perspective, the mv78230 has 49 MPP pins. The mv78260 and mv78460
  * both have 67 MPP pins (more GPIOs and address lines for the memory
<span class="p_del">- * bus mainly). The only difference between the mv78260 and the</span>
<span class="p_del">- * mv78460 in terms of pin muxing is the addition of two functions on</span>
<span class="p_del">- * pins 43 and 56 to access the VDD of the CPU2 and 3 (mv78260 has two</span>
<span class="p_del">- * cores, mv78460 has four cores).</span>
<span class="p_add">+ * bus mainly).</span>
  */
 
 #include &lt;linux/err.h&gt;
<span class="p_chunk">@@ -159,20 +156,17 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(24,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata1&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-re&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;rst&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;hsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(25,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata0&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-we&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;pclk&quot;,       V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(26,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;fsync&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS)),</span>
 	MPP_MODE(27,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;trig&quot;,       V_MV78230_PLUS),
<span class="p_chunk">@@ -187,8 +181,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int0&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(30,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
<span class="p_chunk">@@ -196,13 +189,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(31,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;cmd&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(32,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d0&quot;,         V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(33,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d1&quot;,         V_MV78230_PLUS),
<span class="p_chunk">@@ -234,7 +225,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;spi&quot;, &quot;cs1&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vga-hsync&quot;,  V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq0&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(41,
<span class="p_chunk">@@ -249,15 +239,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;rxd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int7&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(43,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;txd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;rts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;spi&quot;, &quot;cs3&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_chunk">@@ -286,7 +274,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq3&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;tclk&quot;, NULL,        V_MV78230_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;clkout&quot;,     V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x2, &quot;dev&quot;, &quot;burst/last&quot;, V_MV78230_PLUS)),
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_chunk">@@ -308,16 +296,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad19&quot;,       V_MV78260_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(56,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(57,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(58,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad23&quot;,       V_MV78260_PLUS)),
<span class="p_header">diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c</span>
<span class="p_header">index 283212aa103c..70ccc2010054 100644</span>
<span class="p_header">--- a/drivers/regulator/core.c</span>
<span class="p_header">+++ b/drivers/regulator/core.c</span>
<span class="p_chunk">@@ -769,7 +769,7 @@</span> <span class="p_context"> static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)</span>
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev-&gt;constraints;
<span class="p_del">-	char buf[80] = &quot;&quot;;</span>
<span class="p_add">+	char buf[160] = &quot;&quot;;</span>
 	int count = 0;
 	int ret;
 
<span class="p_header">diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h</span>
<span class="p_header">index 535f57328a72..c19911554036 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.h</span>
<span class="p_header">+++ b/drivers/scsi/ipr.h</span>
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"></span>
 #define IPR_RUNTIME_RESET				0x40000000
 
 #define IPR_IPL_INIT_MIN_STAGE_TIME			5
<span class="p_del">-#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 15</span>
<span class="p_add">+#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 30</span>
 #define IPR_IPL_INIT_STAGE_UNKNOWN			0x0
 #define IPR_IPL_INIT_STAGE_TRANSOP			0xB0000000
 #define IPR_IPL_INIT_STAGE_MASK				0xff000000
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">index d2a4c75e5b8f..813e9d8ba351 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_chunk">@@ -523,8 +523,9 @@</span> <span class="p_context"> qla2x00_async_event(scsi_qla_host_t *vha, struct rsp_que *rsp, uint16_t *mb)</span>
 	struct device_reg_2xxx __iomem *reg = &amp;ha-&gt;iobase-&gt;isp;
 	struct device_reg_24xx __iomem *reg24 = &amp;ha-&gt;iobase-&gt;isp24;
 	struct device_reg_82xx __iomem *reg82 = &amp;ha-&gt;iobase-&gt;isp82;
<span class="p_del">-	uint32_t	rscn_entry, host_pid;</span>
<span class="p_add">+	uint32_t	rscn_entry, host_pid, tmp_pid;</span>
 	unsigned long	flags;
<span class="p_add">+	fc_port_t	*fcport = NULL;</span>
 
 	/* Setup to process RIO completion. */
 	handle_cnt = 0;
<span class="p_chunk">@@ -918,6 +919,20 @@</span> <span class="p_context"> skip_rio:</span>
 		if (qla2x00_is_a_vp_did(vha, rscn_entry))
 			break;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Search for the rport related to this RSCN entry and mark it</span>
<span class="p_add">+		 * as lost.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		list_for_each_entry(fcport, &amp;vha-&gt;vp_fcports, list) {</span>
<span class="p_add">+			if (atomic_read(&amp;fcport-&gt;state) != FCS_ONLINE)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			tmp_pid = fcport-&gt;d_id.b24;</span>
<span class="p_add">+			if (fcport-&gt;d_id.b24 == rscn_entry) {</span>
<span class="p_add">+				qla2x00_mark_device_lost(vha, fcport, 0, 0);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		atomic_set(&amp;vha-&gt;loop_down_timer, 0);
 		vha-&gt;flags.management_server_logged_in = 0;
 
<span class="p_header">diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">index d59a74aa3048..4b25f3afb8dc 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_chunk">@@ -1075,7 +1075,8 @@</span> <span class="p_context"> static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)</span>
 		/* for first fragment packet, driver need allocate 1536 +
 		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
 		if ((mf == 1) &amp;&amp; (frag == 0))
<span class="p_del">-			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			alloc_sz = max_t(u16, tmp_len, 1658);</span>
 		else
 			alloc_sz = tmp_len;
 		/* 2 is for IP header 4 bytes alignment in QoS packet case.
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 5a3ea20e9cb5..3c293ad6ae70 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -518,7 +518,7 @@</span> <span class="p_context"> static struct iscsit_transport iscsi_target_transport = {</span>
 
 static int __init iscsi_target_init_module(void)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = 0, size;</span>
 
 	pr_debug(&quot;iSCSI-Target &quot;ISCSIT_VERSION&quot;\n&quot;);
 
<span class="p_chunk">@@ -527,6 +527,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 		pr_err(&quot;Unable to allocate memory for iscsit_global\n&quot;);
 		return -1;
 	}
<span class="p_add">+	spin_lock_init(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 	mutex_init(&amp;auth_id_lock);
 	spin_lock_init(&amp;sess_idr_lock);
 	idr_init(&amp;tiqn_idr);
<span class="p_chunk">@@ -536,15 +537,11 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (ret &lt; 0)
 		goto out;
 
<span class="p_del">-	ret = iscsi_thread_set_init();</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	size = BITS_TO_LONGS(ISCSIT_BITMAP_BITS) * sizeof(long);</span>
<span class="p_add">+	iscsit_global-&gt;ts_bitmap = vzalloc(size);</span>
<span class="p_add">+	if (!iscsit_global-&gt;ts_bitmap) {</span>
<span class="p_add">+		pr_err(&quot;Unable to allocate iscsit_global-&gt;ts_bitmap\n&quot;);</span>
 		goto configfs_out;
<span class="p_del">-</span>
<span class="p_del">-	if (iscsi_allocate_thread_sets(TARGET_THREAD_SET_COUNT) !=</span>
<span class="p_del">-			TARGET_THREAD_SET_COUNT) {</span>
<span class="p_del">-		pr_err(&quot;iscsi_allocate_thread_sets() returned&quot;</span>
<span class="p_del">-			&quot; unexpected value!\n&quot;);</span>
<span class="p_del">-		goto ts_out1;</span>
 	}
 
 	lio_cmd_cache = kmem_cache_create(&quot;lio_cmd_cache&quot;,
<span class="p_chunk">@@ -553,7 +550,7 @@</span> <span class="p_context"> static int __init iscsi_target_init_module(void)</span>
 	if (!lio_cmd_cache) {
 		pr_err(&quot;Unable to kmem_cache_create() for&quot;
 				&quot; lio_cmd_cache\n&quot;);
<span class="p_del">-		goto ts_out2;</span>
<span class="p_add">+		goto bitmap_out;</span>
 	}
 
 	lio_qr_cache = kmem_cache_create(&quot;lio_qr_cache&quot;,
<span class="p_chunk">@@ -608,10 +605,8 @@</span> <span class="p_context"> qr_out:</span>
 	kmem_cache_destroy(lio_qr_cache);
 cmd_out:
 	kmem_cache_destroy(lio_cmd_cache);
<span class="p_del">-ts_out2:</span>
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-ts_out1:</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
<span class="p_add">+bitmap_out:</span>
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 configfs_out:
 	iscsi_target_deregister_configfs();
 out:
<span class="p_chunk">@@ -621,8 +616,6 @@</span> <span class="p_context"> out:</span>
 
 static void __exit iscsi_target_cleanup_module(void)
 {
<span class="p_del">-	iscsi_deallocate_thread_sets();</span>
<span class="p_del">-	iscsi_thread_set_free();</span>
 	iscsit_release_discovery_tpg();
 	iscsit_unregister_transport(&amp;iscsi_target_transport);
 	kmem_cache_destroy(lio_cmd_cache);
<span class="p_chunk">@@ -633,6 +626,7 @@</span> <span class="p_context"> static void __exit iscsi_target_cleanup_module(void)</span>
 
 	iscsi_target_deregister_configfs();
 
<span class="p_add">+	vfree(iscsit_global-&gt;ts_bitmap);</span>
 	kfree(iscsit_global);
 }
 
<span class="p_chunk">@@ -3590,17 +3584,16 @@</span> <span class="p_context"> static int iscsit_send_reject(</span>
 
 void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
 {
<span class="p_del">-	struct iscsi_thread_set *ts = conn-&gt;thread_set;</span>
 	int ord, cpu;
 	/*
<span class="p_del">-	 * thread_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_del">-	 * within iscsi_thread_set.c:iscsi_allocate_thread_sets()</span>
<span class="p_add">+	 * bitmap_id is assigned from iscsit_global-&gt;ts_bitmap from</span>
<span class="p_add">+	 * within iscsit_start_kthreads()</span>
 	 *
<span class="p_del">-	 * Here we use thread_id to determine which CPU that this</span>
<span class="p_del">-	 * iSCSI connection&#39;s iscsi_thread_set will be scheduled to</span>
<span class="p_add">+	 * Here we use bitmap_id to determine which CPU that this</span>
<span class="p_add">+	 * iSCSI connection&#39;s RX/TX threads will be scheduled to</span>
 	 * execute upon.
 	 */
<span class="p_del">-	ord = ts-&gt;thread_id % cpumask_weight(cpu_online_mask);</span>
<span class="p_add">+	ord = conn-&gt;bitmap_id % cpumask_weight(cpu_online_mask);</span>
 	for_each_online_cpu(cpu) {
 		if (ord-- == 0) {
 			cpumask_set_cpu(cpu, conn-&gt;conn_cpumask);
<span class="p_chunk">@@ -3792,7 +3785,7 @@</span> <span class="p_context"> check_rsp_state:</span>
 	switch (state) {
 	case ISTATE_SEND_LOGOUTRSP:
 		if (!iscsit_logout_post_handler(cmd, conn))
<span class="p_del">-			goto restart;</span>
<span class="p_add">+			return -ECONNRESET;</span>
 		/* fall through */
 	case ISTATE_SEND_STATUS:
 	case ISTATE_SEND_ASYNCMSG:
<span class="p_chunk">@@ -3820,8 +3813,6 @@</span> <span class="p_context"> check_rsp_state:</span>
 
 err:
 	return -1;
<span class="p_del">-restart:</span>
<span class="p_del">-	return -EAGAIN;</span>
 }
 
 static int iscsit_handle_response_queue(struct iscsi_conn *conn)
<span class="p_chunk">@@ -3848,21 +3839,13 @@</span> <span class="p_context"> static int iscsit_handle_response_queue(struct iscsi_conn *conn)</span>
 int iscsi_target_tx_thread(void *arg)
 {
 	int ret = 0;
<span class="p_del">-	struct iscsi_conn *conn;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
 
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_tx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-</span>
 	while (!kthread_should_stop()) {
 		/*
 		 * Ensure that both TX and RX per connection kthreads
<span class="p_chunk">@@ -3871,11 +3854,9 @@</span> <span class="p_context"> restart:</span>
 		iscsit_thread_check_cpumask(conn, current, 1);
 
 		wait_event_interruptible(conn-&gt;queues_wq,
<span class="p_del">-					 !iscsit_conn_all_queues_empty(conn) ||</span>
<span class="p_del">-					 ts-&gt;status == ISCSI_THREAD_SET_RESET);</span>
<span class="p_add">+					 !iscsit_conn_all_queues_empty(conn));</span>
 
<span class="p_del">-		if ((ts-&gt;status == ISCSI_THREAD_SET_RESET) ||</span>
<span class="p_del">-		     signal_pending(current))</span>
<span class="p_add">+		if (signal_pending(current))</span>
 			goto transport_err;
 
 get_immediate:
<span class="p_chunk">@@ -3886,15 +3867,14 @@</span> <span class="p_context"> get_immediate:</span>
 		ret = iscsit_handle_response_queue(conn);
 		if (ret == 1)
 			goto get_immediate;
<span class="p_del">-		else if (ret == -EAGAIN)</span>
<span class="p_del">-			goto restart;</span>
<span class="p_add">+		else if (ret == -ECONNRESET)</span>
<span class="p_add">+			goto out;</span>
 		else if (ret &lt; 0)
 			goto transport_err;
 	}
 
 transport_err:
 	iscsit_take_action_for_connection_exit(conn);
<span class="p_del">-	goto restart;</span>
 out:
 	return 0;
 }
<span class="p_chunk">@@ -3979,8 +3959,7 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	int ret;
 	u8 buffer[ISCSI_HDR_LEN], opcode;
 	u32 checksum = 0, digest = 0;
<span class="p_del">-	struct iscsi_conn *conn = NULL;</span>
<span class="p_del">-	struct iscsi_thread_set *ts = arg;</span>
<span class="p_add">+	struct iscsi_conn *conn = arg;</span>
 	struct kvec iov;
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
<span class="p_chunk">@@ -3988,11 +3967,6 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	 */
 	allow_signal(SIGINT);
 
<span class="p_del">-restart:</span>
<span class="p_del">-	conn = iscsi_rx_thread_pre_handler(ts);</span>
<span class="p_del">-	if (!conn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
 		int rc;
<span class="p_chunk">@@ -4002,7 +3976,7 @@</span> <span class="p_context"> restart:</span>
 		if (rc &lt; 0)
 			goto transport_err;
 
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto transport_err;</span>
 	}
 
 	while (!kthread_should_stop()) {
<span class="p_chunk">@@ -4085,8 +4059,6 @@</span> <span class="p_context"> transport_err:</span>
 	if (!signal_pending(current))
 		atomic_set(&amp;conn-&gt;transport_failed, 1);
 	iscsit_take_action_for_connection_exit(conn);
<span class="p_del">-	goto restart;</span>
<span class="p_del">-out:</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4148,7 +4120,24 @@</span> <span class="p_context"> int iscsit_close_connection(</span>
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)
 		complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsi_release_thread_set(conn);</span>
<span class="p_add">+	if (!strcmp(current-&gt;comm, ISCSI_RX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;tx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;tx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (!strcmp(current-&gt;comm, ISCSI_TX_THREAD_NAME)) {</span>
<span class="p_add">+		if (conn-&gt;rx_thread &amp;&amp;</span>
<span class="p_add">+		    cmpxchg(&amp;conn-&gt;rx_thread_active, true, false)) {</span>
<span class="p_add">+			send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
<span class="p_add">+			kthread_stop(conn-&gt;rx_thread);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
 
 	iscsit_stop_timers_for_cmds(conn);
 	iscsit_stop_nopin_response_timer(conn);
<span class="p_chunk">@@ -4427,15 +4416,13 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 	struct iscsi_conn *conn)
 {
 	struct iscsi_session *sess = conn-&gt;sess;
<span class="p_del">-</span>
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
 	iscsit_dec_conn_usage_count(conn);
<span class="p_del">-	iscsit_stop_session(sess, 1, 1);</span>
<span class="p_add">+	iscsit_stop_session(sess, sleep, sleep);</span>
 	iscsit_dec_session_usage_count(sess);
 	target_put_session(sess-&gt;se_sess);
 }
<span class="p_chunk">@@ -4443,13 +4430,12 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 static void iscsit_logout_post_handler_samecid(
 	struct iscsi_conn *conn)
 {
<span class="p_del">-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);</span>
<span class="p_del">-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);</span>
<span class="p_add">+	int sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
 
<span class="p_del">-	iscsit_cause_connection_reinstatement(conn, 1);</span>
<span class="p_add">+	iscsit_cause_connection_reinstatement(conn, sleep);</span>
 	iscsit_dec_conn_usage_count(conn);
 }
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index e117870eb445..815bf5b1a4ae 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -586,6 +586,11 @@</span> <span class="p_context"> struct iscsi_conn {</span>
 	struct iscsi_session	*sess;
 	/* Pointer to thread_set in use for this conn&#39;s threads */
 	struct iscsi_thread_set	*thread_set;
<span class="p_add">+	int			bitmap_id;</span>
<span class="p_add">+	int			rx_thread_active;</span>
<span class="p_add">+	struct task_struct	*rx_thread;</span>
<span class="p_add">+	int			tx_thread_active;</span>
<span class="p_add">+	struct task_struct	*tx_thread;</span>
 	/* list_head for session connection list */
 	struct list_head	conn_list;
 } ____cacheline_aligned;
<span class="p_chunk">@@ -862,10 +867,12 @@</span> <span class="p_context"> struct iscsit_global {</span>
 	/* Unique identifier used for the authentication daemon */
 	u32			auth_id;
 	u32			inactive_ts;
<span class="p_add">+#define ISCSIT_BITMAP_BITS	262144</span>
 	/* Thread Set bitmap count */
 	int			ts_bitmap_count;
 	/* Thread Set bitmap pointer */
 	unsigned long		*ts_bitmap;
<span class="p_add">+	spinlock_t		ts_bitmap_lock;</span>
 	/* Used for iSCSI discovery session authentication */
 	struct iscsi_node_acl	discovery_acl;
 	struct iscsi_portal_group	*discovery_tpg;
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_erl0.c b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">index 08bd87833321..fab67eea54c0 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_chunk">@@ -866,7 +866,10 @@</span> <span class="p_context"> void iscsit_connection_reinstatement_rcfr(struct iscsi_conn *conn)</span>
 	}
 	spin_unlock_bh(&amp;conn-&gt;state_lock);
 
<span class="p_del">-	iscsi_thread_set_force_reinstatement(conn);</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 sleep:
 	wait_for_completion(&amp;conn-&gt;conn_wait_rcfr_comp);
<span class="p_chunk">@@ -891,10 +894,10 @@</span> <span class="p_context"> void iscsit_cause_connection_reinstatement(struct iscsi_conn *conn, int sleep)</span>
 		return;
 	}
 
<span class="p_del">-	if (iscsi_thread_set_force_reinstatement(conn) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_bh(&amp;conn-&gt;state_lock);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;tx_thread, 1);</span>
<span class="p_add">+	if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active)</span>
<span class="p_add">+		send_sig(SIGINT, conn-&gt;rx_thread, 1);</span>
 
 	atomic_set(&amp;conn-&gt;connection_reinstatement, 1);
 	if (!sleep) {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index 0493e8b1ba8f..797b2e2acc35 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -683,7 +683,52 @@</span> <span class="p_context"> static void iscsi_post_login_start_timers(struct iscsi_conn *conn)</span>
 		iscsit_start_nopin_timer(conn);
 }
 
<span class="p_del">-static int iscsi_post_login_handler(</span>
<span class="p_add">+int iscsit_start_kthreads(struct iscsi_conn *conn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	conn-&gt;bitmap_id = bitmap_find_free_region(iscsit_global-&gt;ts_bitmap,</span>
<span class="p_add">+					ISCSIT_BITMAP_BITS, get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;bitmap_id &lt; 0) {</span>
<span class="p_add">+		pr_err(&quot;bitmap_find_free_region() failed for&quot;</span>
<span class="p_add">+		       &quot; iscsit_start_kthreads()\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;tx_thread = kthread_run(iscsi_target_tx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_TX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;tx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_tx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;tx_thread);</span>
<span class="p_add">+		goto out_bitmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;tx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	conn-&gt;rx_thread = kthread_run(iscsi_target_rx_thread, conn,</span>
<span class="p_add">+				      &quot;%s&quot;, ISCSI_RX_THREAD_NAME);</span>
<span class="p_add">+	if (IS_ERR(conn-&gt;rx_thread)) {</span>
<span class="p_add">+		pr_err(&quot;Unable to start iscsi_target_rx_thread\n&quot;);</span>
<span class="p_add">+		ret = PTR_ERR(conn-&gt;rx_thread);</span>
<span class="p_add">+		goto out_tx;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	conn-&gt;rx_thread_active = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+out_tx:</span>
<span class="p_add">+	kthread_stop(conn-&gt;tx_thread);</span>
<span class="p_add">+	conn-&gt;tx_thread_active = false;</span>
<span class="p_add">+out_bitmap:</span>
<span class="p_add">+	spin_lock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	bitmap_release_region(iscsit_global-&gt;ts_bitmap, conn-&gt;bitmap_id,</span>
<span class="p_add">+			      get_order(1));</span>
<span class="p_add">+	spin_unlock(&amp;iscsit_global-&gt;ts_bitmap_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int iscsi_post_login_handler(</span>
 	struct iscsi_np *np,
 	struct iscsi_conn *conn,
 	u8 zero_tsih)
<span class="p_chunk">@@ -693,7 +738,7 @@</span> <span class="p_context"> static int iscsi_post_login_handler(</span>
 	struct se_session *se_sess = sess-&gt;se_sess;
 	struct iscsi_portal_group *tpg = ISCSI_TPG_S(sess);
 	struct se_portal_group *se_tpg = &amp;tpg-&gt;tpg_se_tpg;
<span class="p_del">-	struct iscsi_thread_set *ts;</span>
<span class="p_add">+	int rc;</span>
 
 	iscsit_inc_conn_usage_count(conn);
 
<span class="p_chunk">@@ -708,7 +753,6 @@</span> <span class="p_context"> static int iscsi_post_login_handler(</span>
 	/*
 	 * SCSI Initiator -&gt; SCSI Target Port Mapping
 	 */
<span class="p_del">-	ts = iscsi_get_thread_set();</span>
 	if (!zero_tsih) {
 		iscsi_set_session_parameters(sess-&gt;sess_ops,
 				conn-&gt;param_list, 0);
<span class="p_chunk">@@ -735,9 +779,11 @@</span> <span class="p_context"> static int iscsi_post_login_handler(</span>
 			sess-&gt;sess_ops-&gt;InitiatorName);
 		spin_unlock_bh(&amp;sess-&gt;conn_lock);
 
<span class="p_del">-		iscsi_post_login_start_timers(conn);</span>
<span class="p_add">+		rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+		if (rc)</span>
<span class="p_add">+			return rc;</span>
 
<span class="p_del">-		iscsi_activate_thread_set(conn, ts);</span>
<span class="p_add">+		iscsi_post_login_start_timers(conn);</span>
 		/*
 		 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 		 * are scheduled on the same CPU.
<span class="p_chunk">@@ -794,8 +840,11 @@</span> <span class="p_context"> static int iscsi_post_login_handler(</span>
 		&quot; iSCSI Target Portal Group: %hu\n&quot;, tpg-&gt;nsessions, tpg-&gt;tpgt);
 	spin_unlock_bh(&amp;se_tpg-&gt;session_lock);
 
<span class="p_add">+	rc = iscsit_start_kthreads(conn);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
 	iscsi_post_login_start_timers(conn);
<span class="p_del">-	iscsi_activate_thread_set(conn, ts);</span>
 	/*
 	 * Determine CPU mask to ensure connection&#39;s RX and TX kthreads
 	 * are scheduled on the same CPU.
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 78ddfb43750a..62e532fb82ad 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 	snoop(&amp;urb-&gt;dev-&gt;dev, &quot;urb complete\n&quot;);
 	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
 			as-&gt;status, COMPLETE, NULL, 0);
<span class="p_del">-	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == USB_DIR_IN)</span>
<span class="p_add">+	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_IN)</span>
 		snoop_urb_data(urb, urb-&gt;actual_length);
 
 	if (as-&gt;status &lt; 0 &amp;&amp; as-&gt;bulk_addr &amp;&amp; as-&gt;status != -ECONNRESET &amp;&amp;
<span class="p_chunk">@@ -1593,7 +1593,7 @@</span> <span class="p_context"> static struct async *reap_as(struct dev_state *ps)</span>
 	for (;;) {
 		__set_current_state(TASK_INTERRUPTIBLE);
 		as = async_getcompleted(ps);
<span class="p_del">-		if (as)</span>
<span class="p_add">+		if (as || !connected(ps))</span>
 			break;
 		if (signal_pending(current))
 			break;
<span class="p_chunk">@@ -1616,7 +1616,7 @@</span> <span class="p_context"> static int proc_reapurb(struct dev_state *ps, void __user *arg)</span>
 	}
 	if (signal_pending(current))
 		return -EINTR;
<span class="p_del">-	return -EIO;</span>
<span class="p_add">+	return -ENODEV;</span>
 }
 
 static int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)
<span class="p_chunk">@@ -1625,10 +1625,11 @@</span> <span class="p_context"> static int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)</span>
 	struct async *as;
 
 	as = async_getcompleted(ps);
<span class="p_del">-	retval = -EAGAIN;</span>
 	if (as) {
 		retval = processcompl(as, (void __user * __user *)arg);
 		free_async(as);
<span class="p_add">+	} else {</span>
<span class="p_add">+		retval = (connected(ps) ? -EAGAIN : -ENODEV);</span>
 	}
 	return retval;
 }
<span class="p_chunk">@@ -1758,7 +1759,7 @@</span> <span class="p_context"> static int proc_reapurb_compat(struct dev_state *ps, void __user *arg)</span>
 	}
 	if (signal_pending(current))
 		return -EINTR;
<span class="p_del">-	return -EIO;</span>
<span class="p_add">+	return -ENODEV;</span>
 }
 
 static int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)
<span class="p_chunk">@@ -1766,11 +1767,12 @@</span> <span class="p_context"> static int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)</span>
 	int retval;
 	struct async *as;
 
<span class="p_del">-	retval = -EAGAIN;</span>
 	as = async_getcompleted(ps);
 	if (as) {
 		retval = processcompl_compat(as, (void __user * __user *)arg);
 		free_async(as);
<span class="p_add">+	} else {</span>
<span class="p_add">+		retval = (connected(ps) ? -EAGAIN : -ENODEV);</span>
 	}
 	return retval;
 }
<span class="p_chunk">@@ -1941,7 +1943,8 @@</span> <span class="p_context"> static int proc_get_capabilities(struct dev_state *ps, void __user *arg)</span>
 {
 	__u32 caps;
 
<span class="p_del">-	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM;</span>
<span class="p_add">+	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM |</span>
<span class="p_add">+			USBDEVFS_CAP_REAP_AFTER_DISCONNECT;</span>
 	if (!ps-&gt;dev-&gt;bus-&gt;no_stop_on_short)
 		caps |= USBDEVFS_CAP_BULK_CONTINUATION;
 	if (ps-&gt;dev-&gt;bus-&gt;sg_tablesize)
<span class="p_chunk">@@ -2002,6 +2005,32 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 		return -EPERM;
 
 	usb_lock_device(dev);
<span class="p_add">+</span>
<span class="p_add">+	/* Reap operations are allowed even after disconnection */</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case USBDEVFS_REAPURB:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurb(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	case USBDEVFS_REAPURBNDELAY:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurbnonblock(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+	case USBDEVFS_REAPURB32:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB32\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurb_compat(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	case USBDEVFS_REAPURBNDELAY32:</span>
<span class="p_add">+		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY32\n&quot;, __func__);</span>
<span class="p_add">+		ret = proc_reapurbnonblock_compat(ps, p);</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!connected(ps)) {
 		usb_unlock_device(dev);
 		return -ENODEV;
<span class="p_chunk">@@ -2095,16 +2124,6 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 			inode-&gt;i_mtime = CURRENT_TIME;
 		break;
 
<span class="p_del">-	case USBDEVFS_REAPURB32:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB32\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurb_compat(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case USBDEVFS_REAPURBNDELAY32:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY32\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurbnonblock_compat(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
 	case USBDEVFS_IOCTL32:
 		snoop(&amp;dev-&gt;dev, &quot;%s: IOCTL32\n&quot;, __func__);
 		ret = proc_ioctl_compat(ps, ptr_to_compat(p));
<span class="p_chunk">@@ -2116,16 +2135,6 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 		ret = proc_unlinkurb(ps, p);
 		break;
 
<span class="p_del">-	case USBDEVFS_REAPURB:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURB\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurb(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	case USBDEVFS_REAPURBNDELAY:</span>
<span class="p_del">-		snoop(&amp;dev-&gt;dev, &quot;%s: REAPURBNDELAY\n&quot;, __func__);</span>
<span class="p_del">-		ret = proc_reapurbnonblock(ps, p);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
 	case USBDEVFS_DISCSIGNAL:
 		snoop(&amp;dev-&gt;dev, &quot;%s: DISCSIGNAL\n&quot;, __func__);
 		ret = proc_disconnectsignal(ps, p);
<span class="p_chunk">@@ -2162,6 +2171,8 @@</span> <span class="p_context"> static long usbdev_do_ioctl(struct file *file, unsigned int cmd,</span>
 		ret = proc_disconnect_claim(ps, p);
 		break;
 	}
<span class="p_add">+</span>
<span class="p_add">+ done:</span>
 	usb_unlock_device(dev);
 	if (ret &gt;= 0)
 		inode-&gt;i_atime = CURRENT_TIME;
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index 6cd418f6ac07..57d7ec6c8090 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -718,6 +718,10 @@</span> <span class="p_context"> static int dwc3_ep0_std_request(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)</span>
 		dev_vdbg(dwc-&gt;dev, &quot;USB_REQ_SET_ISOCH_DELAY\n&quot;);
 		ret = dwc3_ep0_set_isoch_delay(dwc, ctrl);
 		break;
<span class="p_add">+	case USB_REQ_SET_INTERFACE:</span>
<span class="p_add">+		dev_vdbg(dwc-&gt;dev, &quot;USB_REQ_SET_INTERFACE\n&quot;);</span>
<span class="p_add">+		dwc-&gt;start_config_issued = false;</span>
<span class="p_add">+		/* Fall through */</span>
 	default:
 		dev_vdbg(dwc-&gt;dev, &quot;Forwarding to gadget driver\n&quot;);
 		ret = dwc3_ep0_delegate_req(dwc, ctrl);
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 87f8fc63b3e1..6e70c88b25fb 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -319,6 +319,8 @@</span> <span class="p_context"> int dwc3_send_gadget_generic_command(struct dwc3 *dwc, int cmd, u32 param)</span>
 		if (!(reg &amp; DWC3_DGCMD_CMDACT)) {
 			dev_vdbg(dwc-&gt;dev, &quot;Command Complete --&gt; %d\n&quot;,
 					DWC3_DGCMD_STATUS(reg));
<span class="p_add">+			if (DWC3_DGCMD_STATUS(reg))</span>
<span class="p_add">+				return -EINVAL;</span>
 			return 0;
 		}
 
<span class="p_chunk">@@ -355,6 +357,8 @@</span> <span class="p_context"> int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,</span>
 		if (!(reg &amp; DWC3_DEPCMD_CMDACT)) {
 			dev_vdbg(dwc-&gt;dev, &quot;Command Complete --&gt; %d\n&quot;,
 					DWC3_DEPCMD_STATUS(reg));
<span class="p_add">+			if (DWC3_DEPCMD_STATUS(reg))</span>
<span class="p_add">+				return -EINVAL;</span>
 			return 0;
 		}
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 677f032482f7..31bed5f7d0eb 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1400,10 +1400,10 @@</span> <span class="p_context"> int xhci_endpoint_init(struct xhci_hcd *xhci,</span>
 		/* Attempt to use the ring cache */
 		if (virt_dev-&gt;num_rings_cached == 0)
 			return -ENOMEM;
<span class="p_add">+		virt_dev-&gt;num_rings_cached--;</span>
 		virt_dev-&gt;eps[ep_index].new_ring =
 			virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached];
 		virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached] = NULL;
<span class="p_del">-		virt_dev-&gt;num_rings_cached--;</span>
 		xhci_reinit_cached_ring(xhci, virt_dev-&gt;eps[ep_index].new_ring,
 					1, type);
 	}
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index ab1c5e8ac27f..dd84416a23cd 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -187,6 +187,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1FB9, 0x0602) }, /* Lake Shore Model 648 Magnet Power Supply */
 	{ USB_DEVICE(0x1FB9, 0x0700) }, /* Lake Shore Model 737 VSM Controller */
 	{ USB_DEVICE(0x1FB9, 0x0701) }, /* Lake Shore Model 776 Hall Matrix */
<span class="p_add">+	{ USB_DEVICE(0x2626, 0xEA60) }, /* Aruba Networks 7xxx USB Serial Console */</span>
 	{ USB_DEVICE(0x3195, 0xF190) }, /* Link Instruments MSO-19 */
 	{ USB_DEVICE(0x3195, 0xF280) }, /* Link Instruments MSO-28 */
 	{ USB_DEVICE(0x3195, 0xF281) }, /* Link Instruments MSO-28 */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 8b3484134ab0..096438e4fb0c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -1755,6 +1755,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */</span>
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
 	{ } /* Terminating entry */
<span class="p_header">diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">index af88ffd1068f..2b7e073f5e36 100644</span>
<span class="p_header">--- a/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/omap_wdt.c</span>
<span class="p_chunk">@@ -134,6 +134,13 @@</span> <span class="p_context"> static int omap_wdt_start(struct watchdog_device *wdog)</span>
 
 	pm_runtime_get_sync(wdev-&gt;dev);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure the watchdog is disabled. This is unfortunately required</span>
<span class="p_add">+	 * because writing to various registers with the watchdog running has no</span>
<span class="p_add">+	 * effect.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	omap_wdt_disable(wdev);</span>
<span class="p_add">+</span>
 	/* initialize prescaler */
 	while (__raw_readl(base + OMAP_WATCHDOG_WPS) &amp; 0x01)
 		cpu_relax();
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index d86edc8d3fd0..4c7d309e4aa6 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -537,8 +537,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">index 53687bbf2296..65b21a24841e 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_chunk">@@ -151,8 +151,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c</span>
<span class="p_header">index 2c66ddbbe670..0389e90eec33 100644</span>
<span class="p_header">--- a/fs/btrfs/inode-map.c</span>
<span class="p_header">+++ b/fs/btrfs/inode-map.c</span>
<span class="p_chunk">@@ -283,7 +283,7 @@</span> <span class="p_context"> void btrfs_unpin_free_ino(struct btrfs_root *root)</span>
 		__btrfs_add_free_space(ctl, info-&gt;offset, count);
 free:
 		rb_erase(&amp;info-&gt;offset_index, rbroot);
<span class="p_del">-		kfree(info);</span>
<span class="p_add">+		kmem_cache_free(btrfs_free_space_cachep, info);</span>
 	}
 }
 
<span class="p_header">diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c</span>
<span class="p_header">index 589061469687..b07a221c3138 100644</span>
<span class="p_header">--- a/fs/ext4/indirect.c</span>
<span class="p_header">+++ b/fs/ext4/indirect.c</span>
<span class="p_chunk">@@ -577,7 +577,7 @@</span> <span class="p_context"> int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {
 		EXT4_ERROR_INODE(inode, &quot;Can&#39;t allocate blocks for &quot;
 				 &quot;non-extent mapped inodes with bigalloc&quot;);
<span class="p_del">-		return -ENOSPC;</span>
<span class="p_add">+		return -EUCLEAN;</span>
 	}
 
 	goal = ext4_find_goal(inode, map-&gt;m_lblk, partial);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 8a277505a3be..10b71e4029a0 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1412,7 +1412,7 @@</span> <span class="p_context"> static void ext4_da_release_space(struct inode *inode, int to_free)</span>
 static void ext4_da_page_release_reservation(struct page *page,
 					     unsigned long offset)
 {
<span class="p_del">-	int to_release = 0;</span>
<span class="p_add">+	int to_release = 0, contiguous_blks = 0;</span>
 	struct buffer_head *head, *bh;
 	unsigned int curr_off = 0;
 	struct inode *inode = page-&gt;mapping-&gt;host;
<span class="p_chunk">@@ -1427,14 +1427,23 @@</span> <span class="p_context"> static void ext4_da_page_release_reservation(struct page *page,</span>
 
 		if ((offset &lt;= curr_off) &amp;&amp; (buffer_delay(bh))) {
 			to_release++;
<span class="p_add">+			contiguous_blks++;</span>
 			clear_buffer_delay(bh);
<span class="p_add">+		} else if (contiguous_blks) {</span>
<span class="p_add">+			lblk = page-&gt;index &lt;&lt;</span>
<span class="p_add">+			       (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);</span>
<span class="p_add">+			lblk += (curr_off &gt;&gt; inode-&gt;i_blkbits) -</span>
<span class="p_add">+				contiguous_blks;</span>
<span class="p_add">+			ext4_es_remove_extent(inode, lblk, contiguous_blks);</span>
<span class="p_add">+			contiguous_blks = 0;</span>
 		}
 		curr_off = next_off;
 	} while ((bh = bh-&gt;b_this_page) != head);
 
<span class="p_del">-	if (to_release) {</span>
<span class="p_add">+	if (contiguous_blks) {</span>
 		lblk = page-&gt;index &lt;&lt; (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);
<span class="p_del">-		ext4_es_remove_extent(inode, lblk, to_release);</span>
<span class="p_add">+		lblk += (curr_off &gt;&gt; inode-&gt;i_blkbits) - contiguous_blks;</span>
<span class="p_add">+		ext4_es_remove_extent(inode, lblk, contiguous_blks);</span>
 	}
 
 	/* If we have released all the blocks belonging to a cluster, then we
<span class="p_chunk">@@ -2099,19 +2108,32 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 		ext4_walk_page_buffers(handle, page_bufs, 0, len,
 				       NULL, bget_one);
 	}
<span class="p_del">-	/* As soon as we unlock the page, it can go away, but we have</span>
<span class="p_del">-	 * references to buffers so we are safe */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to release the page lock before we start the</span>
<span class="p_add">+	 * journal, so grab a reference so the page won&#39;t disappear</span>
<span class="p_add">+	 * out from under us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	get_page(page);</span>
 	unlock_page(page);
 
 	handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,
 				    ext4_writepage_trans_blocks(inode));
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		put_page(page);</span>
<span class="p_add">+		goto out_no_pagelock;</span>
 	}
<span class="p_del">-</span>
 	BUG_ON(!ext4_handle_valid(handle));
 
<span class="p_add">+	lock_page(page);</span>
<span class="p_add">+	put_page(page);</span>
<span class="p_add">+	if (page-&gt;mapping != mapping) {</span>
<span class="p_add">+		/* The page got truncated from under us */</span>
<span class="p_add">+		ext4_journal_stop(handle);</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (inline_data) {
 		ret = ext4_journal_get_write_access(handle, inode_bh);
 
<span class="p_chunk">@@ -2136,6 +2158,8 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 				       NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:
<span class="p_add">+	unlock_page(page);</span>
<span class="p_add">+out_no_pagelock:</span>
 	brelse(inode_bh);
 	return ret;
 }
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index df5050f9080b..61ee01603940 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -4764,18 +4764,12 @@</span> <span class="p_context"> do_more:</span>
 		/*
 		 * blocks being freed are metadata. these blocks shouldn&#39;t
 		 * be used until this transaction is committed
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed</span>
<span class="p_add">+		 * to fail.</span>
 		 */
<span class="p_del">-	retry:</span>
<span class="p_del">-		new_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);</span>
<span class="p_del">-		if (!new_entry) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We use a retry loop because</span>
<span class="p_del">-			 * ext4_free_blocks() is not allowed to fail.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			cond_resched();</span>
<span class="p_del">-			congestion_wait(BLK_RW_ASYNC, HZ/50);</span>
<span class="p_del">-			goto retry;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		new_entry = kmem_cache_alloc(ext4_free_data_cachep,</span>
<span class="p_add">+				GFP_NOFS|__GFP_NOFAIL);</span>
 		new_entry-&gt;efd_start_cluster = bit;
 		new_entry-&gt;efd_group = block_group;
 		new_entry-&gt;efd_count = count_clusters;
<span class="p_header">diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c</span>
<span class="p_header">index 49e8bdff9163..d19efab66cb6 100644</span>
<span class="p_header">--- a/fs/ext4/migrate.c</span>
<span class="p_header">+++ b/fs/ext4/migrate.c</span>
<span class="p_chunk">@@ -616,6 +616,7 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 	struct ext4_inode_info		*ei = EXT4_I(inode);
 	struct ext4_extent		*ex;
 	unsigned int			i, len;
<span class="p_add">+	ext4_lblk_t			start, end;</span>
 	ext4_fsblk_t			blk;
 	handle_t			*handle;
 	int				ret;
<span class="p_chunk">@@ -629,6 +630,14 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC))
 		return -EOPNOTSUPP;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In order to get correct extent info, force all delayed allocation</span>
<span class="p_add">+	 * blocks to be allocated, otherwise delayed allocation blocks may not</span>
<span class="p_add">+	 * be reflected and bypass the checks on extent header.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (test_opt(inode-&gt;i_sb, DELALLOC))</span>
<span class="p_add">+		ext4_alloc_da_blocks(inode);</span>
<span class="p_add">+</span>
 	handle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
<span class="p_chunk">@@ -646,11 +655,13 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 		goto errout;
 	}
 	if (eh-&gt;eh_entries == 0)
<span class="p_del">-		blk = len = 0;</span>
<span class="p_add">+		blk = len = start = end = 0;</span>
 	else {
 		len = le16_to_cpu(ex-&gt;ee_len);
 		blk = ext4_ext_pblock(ex);
<span class="p_del">-		if (len &gt; EXT4_NDIR_BLOCKS) {</span>
<span class="p_add">+		start = le32_to_cpu(ex-&gt;ee_block);</span>
<span class="p_add">+		end = start + len - 1;</span>
<span class="p_add">+		if (end &gt;= EXT4_NDIR_BLOCKS) {</span>
 			ret = -EOPNOTSUPP;
 			goto errout;
 		}
<span class="p_chunk">@@ -658,7 +669,7 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 
 	ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);
 	memset(ei-&gt;i_data, 0, sizeof(ei-&gt;i_data));
<span class="p_del">-	for (i=0; i &lt; len; i++)</span>
<span class="p_add">+	for (i = start; i &lt;= end; i++)</span>
 		ei-&gt;i_data[i] = cpu_to_le32(blk++);
 	ext4_mark_inode_dirty(handle, inode);
 errout:
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 21a0b43a7d31..af1eaed96a91 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -803,6 +803,7 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 		dump_orphan_list(sb, sbi);
 	J_ASSERT(list_empty(&amp;sbi-&gt;s_orphan));
 
<span class="p_add">+	sync_blockdev(sb-&gt;s_bdev);</span>
 	invalidate_bdev(sb-&gt;s_bdev);
 	if (sbi-&gt;journal_bdev &amp;&amp; sbi-&gt;journal_bdev != sb-&gt;s_bdev) {
 		/*
<span class="p_header">diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c</span>
<span class="p_header">index 39a986e1da9e..4d371f3b9a45 100644</span>
<span class="p_header">--- a/fs/fuse/inode.c</span>
<span class="p_header">+++ b/fs/fuse/inode.c</span>
<span class="p_chunk">@@ -1028,6 +1028,7 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		goto err_fput;
 
 	fuse_conn_init(fc);
<span class="p_add">+	fc-&gt;release = fuse_free_conn;</span>
 
 	fc-&gt;dev = sb-&gt;s_dev;
 	fc-&gt;sb = sb;
<span class="p_chunk">@@ -1042,7 +1043,6 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		fc-&gt;dont_mask = 1;
 	sb-&gt;s_flags |= MS_POSIXACL;
 
<span class="p_del">-	fc-&gt;release = fuse_free_conn;</span>
 	fc-&gt;flags = d.flags;
 	fc-&gt;user_id = d.user_id;
 	fc-&gt;group_id = d.group_id;
<span class="p_header">diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c</span>
<span class="p_header">index 962e90c37aec..2c1ce192af8b 100644</span>
<span class="p_header">--- a/fs/hpfs/super.c</span>
<span class="p_header">+++ b/fs/hpfs/super.c</span>
<span class="p_chunk">@@ -52,17 +52,20 @@</span> <span class="p_context"> static void unmark_dirty(struct super_block *s)</span>
 }
 
 /* Filesystem error... */
<span class="p_del">-static char err_buf[1024];</span>
<span class="p_del">-</span>
 void hpfs_error(struct super_block *s, const char *fmt, ...)
 {
<span class="p_add">+	struct va_format vaf;</span>
 	va_list args;
 
 	va_start(args, fmt);
<span class="p_del">-	vsnprintf(err_buf, sizeof(err_buf), fmt, args);</span>
<span class="p_add">+</span>
<span class="p_add">+	vaf.fmt = fmt;</span>
<span class="p_add">+	vaf.va = &amp;args;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_err(&quot;filesystem error: %pV&quot;, &amp;vaf);</span>
<span class="p_add">+</span>
 	va_end(args);
 
<span class="p_del">-	printk(&quot;HPFS: filesystem error: %s&quot;, err_buf);</span>
 	if (!hpfs_sb(s)-&gt;sb_was_error) {
 		if (hpfs_sb(s)-&gt;sb_err == 2) {
 			printk(&quot;; crashing the system because you wanted it\n&quot;);
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index c78841ee81cf..6bb52859cb86 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -440,7 +440,7 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	unsigned long	blocknr;
 
 	if (is_journal_aborted(journal))
<span class="p_del">-		return 1;</span>
<span class="p_add">+		return -EIO;</span>
 
 	if (!jbd2_journal_get_log_tail(journal, &amp;first_tid, &amp;blocknr))
 		return 1;
<span class="p_chunk">@@ -455,10 +455,9 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	 * jbd2_cleanup_journal_tail() doesn&#39;t get called all that often.
 	 */
 	if (journal-&gt;j_flags &amp; JBD2_BARRIER)
<span class="p_del">-		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_KERNEL, NULL);</span>
<span class="p_add">+		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_NOFS, NULL);</span>
 
<span class="p_del">-	__jbd2_update_log_tail(journal, first_tid, blocknr);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return __jbd2_update_log_tail(journal, first_tid, blocknr);</span>
 }
 
 
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index aaa1a3f33b0e..3e7ef8874ffb 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -869,9 +869,10 @@</span> <span class="p_context"> int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,</span>
  *
  * Requires j_checkpoint_mutex
  */
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 {
 	unsigned long freed;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 
<span class="p_chunk">@@ -881,7 +882,10 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	 * space and if we lose sb update during power failure we&#39;d replay
 	 * old transaction with possibly newly overwritten data.
 	 */
<span class="p_del">-	jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	ret = jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	write_lock(&amp;journal-&gt;j_state_lock);
 	freed = block - journal-&gt;j_tail;
 	if (block &lt; journal-&gt;j_tail)
<span class="p_chunk">@@ -897,6 +901,9 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	journal-&gt;j_tail_sequence = tid;
 	journal-&gt;j_tail = block;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_chunk">@@ -1315,7 +1322,7 @@</span> <span class="p_context"> static int journal_reset(journal_t *journal)</span>
 	return jbd2_journal_start_thread(journal);
 }
 
<span class="p_del">-static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
<span class="p_add">+static int jbd2_write_superblock(journal_t *journal, int write_op)</span>
 {
 	struct buffer_head *bh = journal-&gt;j_sb_buffer;
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_chunk">@@ -1354,7 +1361,10 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
 		printk(KERN_ERR &quot;JBD2: Error %d detected when updating &quot;
 		       &quot;journal superblock for %s.\n&quot;, ret,
 		       journal-&gt;j_devname);
<span class="p_add">+		jbd2_journal_abort(journal, ret);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1367,10 +1377,11 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
  * Update a journal&#39;s superblock information about log tail and write it to
  * disk, waiting for the IO to complete.
  */
<span class="p_del">-void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
<span class="p_add">+int jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 				     unsigned long tail_block, int write_op)
 {
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 	jbd_debug(1, &quot;JBD2: updating superblock (start %lu, seq %u)\n&quot;,
<span class="p_chunk">@@ -1379,13 +1390,18 @@</span> <span class="p_context"> void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 	sb-&gt;s_sequence = cpu_to_be32(tail_tid);
 	sb-&gt;s_start    = cpu_to_be32(tail_block);
 
<span class="p_del">-	jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	ret = jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
 
 	/* Log is no longer empty */
 	write_lock(&amp;journal-&gt;j_state_lock);
 	WARN_ON(!sb-&gt;s_sequence);
 	journal-&gt;j_flags &amp;= ~JBD2_FLUSHED;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1922,7 +1938,14 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 		return -EIO;
 
 	mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-	jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		err = jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+	}</span>
 
 	/* Finally, mark the journal as really needing no recovery.
 	 * This sets s_start==0 in the underlying superblock, which is
<span class="p_chunk">@@ -1938,7 +1961,8 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	J_ASSERT(journal-&gt;j_head == journal-&gt;j_tail);
 	J_ASSERT(journal-&gt;j_tail_sequence == journal-&gt;j_transaction_sequence);
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	return 0;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return err;</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c</span>
<span class="p_header">index fa6d72131c19..4495cad189c3 100644</span>
<span class="p_header">--- a/fs/nfs/nfs3xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs3xdr.c</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> static void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,</span>
 	if (args-&gt;npages != 0)
 		xdr_write_pages(xdr, args-&gt;pages, 0, args-&gt;len);
 	else
<span class="p_del">-		xdr_reserve_space(xdr, NFS_ACL_INLINE_BUFSIZE);</span>
<span class="p_add">+		xdr_reserve_space(xdr, args-&gt;len);</span>
 
 	error = nfsacl_encode(xdr-&gt;buf, base, args-&gt;inode,
 			    (args-&gt;mask &amp; NFS_ACL) ?
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index d482b86d0e0b..cfa9163b3bb7 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1452,6 +1452,8 @@</span> <span class="p_context"> restart:</span>
 				}
 				spin_unlock(&amp;state-&gt;state_lock);
 				nfs4_put_open_state(state);
<span class="p_add">+				clear_bit(NFS4CLNT_RECLAIM_NOGRACE,</span>
<span class="p_add">+					&amp;state-&gt;flags);</span>
 				spin_lock(&amp;sp-&gt;so_lock);
 				goto restart;
 			}
<span class="p_header">diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c</span>
<span class="p_header">index 195a403e1522..61dbe1958a30 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_symlink.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_symlink.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> xfs_readlink_bmap(</span>
 			cur_chunk += sizeof(struct xfs_dsymlink_hdr);
 		}
 
<span class="p_del">-		memcpy(link + offset, bp-&gt;b_addr, byte_cnt);</span>
<span class="p_add">+		memcpy(link + offset, cur_chunk, byte_cnt);</span>
 
 		pathlen -= byte_cnt;
 		offset += byte_cnt;
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index f819e813c8ac..4407354c7d6a 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -511,6 +511,7 @@</span> <span class="p_context"> typedef u64 acpi_integer;</span>
 #define ACPI_NO_ACPI_ENABLE             0x10
 #define ACPI_NO_DEVICE_INIT             0x20
 #define ACPI_NO_OBJECT_INIT             0x40
<span class="p_add">+#define ACPI_NO_FACS_INIT               0x80</span>
 
 /*
  * Initialization state
<span class="p_header">diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h</span>
<span class="p_header">index 6e051f472edb..0c67c1f2a890 100644</span>
<span class="p_header">--- a/include/linux/jbd2.h</span>
<span class="p_header">+++ b/include/linux/jbd2.h</span>
<span class="p_chunk">@@ -997,7 +997,7 @@</span> <span class="p_context"> extern struct journal_head * jbd2_journal_get_descriptor_buffer(journal_t *);</span>
 int jbd2_journal_next_log_block(journal_t *, unsigned long long *);
 int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,
 			      unsigned long *block);
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
 void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);
 
 /* Commit management */
<span class="p_chunk">@@ -1116,7 +1116,7 @@</span> <span class="p_context"> extern int	   jbd2_journal_recover    (journal_t *journal);</span>
 extern int	   jbd2_journal_wipe       (journal_t *, int);
 extern int	   jbd2_journal_skip_recovery	(journal_t *);
 extern void	   jbd2_journal_update_sb_errno(journal_t *);
<span class="p_del">-extern void	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
<span class="p_add">+extern int	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
 				unsigned long, int);
 extern void	   __jbd2_journal_abort_hard	(journal_t *);
 extern void	   jbd2_journal_abort      (journal_t *, int);
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 8e5d45fa83cf..8ad0771b88ab 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -409,6 +409,7 @@</span> <span class="p_context"> enum {</span>
 	ATA_HORKAGE_ATAPI_DMADIR = (1 &lt;&lt; 18),	/* device requires dmadir */
 	ATA_HORKAGE_NOLPM	= (1 &lt;&lt; 20),	/* don&#39;t use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 &lt;&lt; 21),	/* some WDs have broken LPM */
<span class="p_add">+	ATA_HORKAGE_NOTRIM = (1 &lt;&lt; 24),		/* don&#39;t use TRIM */</span>
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */
<span class="p_header">diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h</span>
<span class="p_header">index 54e351aa4d2e..a9e5134c2936 100644</span>
<span class="p_header">--- a/include/linux/nfs_xdr.h</span>
<span class="p_header">+++ b/include/linux/nfs_xdr.h</span>
<span class="p_chunk">@@ -1094,7 +1094,7 @@</span> <span class="p_context"> struct pnfs_ds_commit_info {</span>
 	struct pnfs_commit_bucket *buckets;
 };
 
<span class="p_del">-#define NFS4_EXCHANGE_ID_LEN	(48)</span>
<span class="p_add">+#define NFS4_EXCHANGE_ID_LEN	(127)</span>
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;
<span class="p_header">diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h</span>
<span class="p_header">index 0c65e4b12617..ef29266ef77a 100644</span>
<span class="p_header">--- a/include/uapi/linux/usbdevice_fs.h</span>
<span class="p_header">+++ b/include/uapi/linux/usbdevice_fs.h</span>
<span class="p_chunk">@@ -125,11 +125,12 @@</span> <span class="p_context"> struct usbdevfs_hub_portinfo {</span>
 	char port [127];	/* e.g. port 3 connects to device 27 */
 };
 
<span class="p_del">-/* Device capability flags */</span>
<span class="p_add">+/* System and bus capability flags */</span>
 #define USBDEVFS_CAP_ZERO_PACKET		0x01
 #define USBDEVFS_CAP_BULK_CONTINUATION		0x02
 #define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
 #define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
<span class="p_add">+#define USBDEVFS_CAP_REAP_AFTER_DISCONNECT	0x10</span>
 
 /* USBDEVFS_DISCONNECT_CLAIM flags &amp; struct */
 
<span class="p_header">diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h</span>
<span class="p_header">index aa0e736b72ac..fe576073580a 100644</span>
<span class="p_header">--- a/kernel/trace/trace.h</span>
<span class="p_header">+++ b/kernel/trace/trace.h</span>
<span class="p_chunk">@@ -428,6 +428,7 @@</span> <span class="p_context"> enum {</span>
 
 	TRACE_CONTROL_BIT,
 
<span class="p_add">+	TRACE_BRANCH_BIT,</span>
 /*
  * Abuse of the trace_recursion.
  * As we need a way to maintain state if we are tracing the function
<span class="p_header">diff --git a/kernel/trace/trace_branch.c b/kernel/trace/trace_branch.c</span>
<span class="p_header">index d594da0dc03c..cb89197adf5c 100644</span>
<span class="p_header">--- a/kernel/trace/trace_branch.c</span>
<span class="p_header">+++ b/kernel/trace/trace_branch.c</span>
<span class="p_chunk">@@ -37,9 +37,12 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 	struct trace_branch *entry;
 	struct ring_buffer *buffer;
 	unsigned long flags;
<span class="p_del">-	int cpu, pc;</span>
<span class="p_add">+	int pc;</span>
 	const char *p;
 
<span class="p_add">+	if (current-&gt;trace_recursion &amp; TRACE_BRANCH_BIT)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/*
 	 * I would love to save just the ftrace_likely_data pointer, but
 	 * this code can also be used by modules. Ugly things can happen
<span class="p_chunk">@@ -50,10 +53,10 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 	if (unlikely(!tr))
 		return;
 
<span class="p_del">-	local_irq_save(flags);</span>
<span class="p_del">-	cpu = raw_smp_processor_id();</span>
<span class="p_del">-	data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);</span>
<span class="p_del">-	if (atomic_inc_return(&amp;data-&gt;disabled) != 1)</span>
<span class="p_add">+	raw_local_irq_save(flags);</span>
<span class="p_add">+	current-&gt;trace_recursion |= TRACE_BRANCH_BIT;</span>
<span class="p_add">+	data = this_cpu_ptr(tr-&gt;trace_buffer.data);</span>
<span class="p_add">+	if (atomic_read(&amp;data-&gt;disabled))</span>
 		goto out;
 
 	pc = preempt_count();
<span class="p_chunk">@@ -82,8 +85,8 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 		__buffer_unlock_commit(buffer, event);
 
  out:
<span class="p_del">-	atomic_dec(&amp;data-&gt;disabled);</span>
<span class="p_del">-	local_irq_restore(flags);</span>
<span class="p_add">+	current-&gt;trace_recursion &amp;= ~TRACE_BRANCH_BIT;</span>
<span class="p_add">+	raw_local_irq_restore(flags);</span>
 }
 
 static inline
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index fe3e086d38e9..67654bb5bc2f 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1015,6 +1015,9 @@</span> <span class="p_context"> static void parse_init(struct filter_parse_state *ps,</span>
 
 static char infix_next(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 
 	return ps-&gt;infix.string[ps-&gt;infix.tail++];
<span class="p_chunk">@@ -1030,6 +1033,9 @@</span> <span class="p_context"> static char infix_peek(struct filter_parse_state *ps)</span>
 
 static void infix_advance(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 	ps-&gt;infix.tail++;
 }
<span class="p_chunk">@@ -1342,7 +1348,9 @@</span> <span class="p_context"> static int check_preds(struct filter_parse_state *ps)</span>
 			continue;
 		}
 		n_normal_preds++;
<span class="p_del">-		WARN_ON_ONCE(cnt &lt; 0);</span>
<span class="p_add">+		/* all ops should have operands */</span>
<span class="p_add">+		if (cnt &lt; 0)</span>
<span class="p_add">+			break;</span>
 	}
 
 	if (cnt != 1 || !n_normal_preds || n_logical_preds &gt;= n_normal_preds) {
<span class="p_header">diff --git a/lib/bitmap.c b/lib/bitmap.c</span>
<span class="p_header">index e5c4ebe586ba..c0634aa923a6 100644</span>
<span class="p_header">--- a/lib/bitmap.c</span>
<span class="p_header">+++ b/lib/bitmap.c</span>
<span class="p_chunk">@@ -603,12 +603,12 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 	unsigned a, b;
 	int c, old_c, totaldigits;
 	const char __user __force *ubuf = (const char __user __force *)buf;
<span class="p_del">-	int exp_digit, in_range;</span>
<span class="p_add">+	int at_start, in_range;</span>
 
 	totaldigits = c = 0;
 	bitmap_zero(maskp, nmaskbits);
 	do {
<span class="p_del">-		exp_digit = 1;</span>
<span class="p_add">+		at_start = 1;</span>
 		in_range = 0;
 		a = b = 0;
 
<span class="p_chunk">@@ -637,11 +637,10 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 				break;
 
 			if (c == &#39;-&#39;) {
<span class="p_del">-				if (exp_digit || in_range)</span>
<span class="p_add">+				if (at_start || in_range)</span>
 					return -EINVAL;
 				b = 0;
 				in_range = 1;
<span class="p_del">-				exp_digit = 1;</span>
 				continue;
 			}
 
<span class="p_chunk">@@ -651,16 +650,18 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 			b = b * 10 + (c - &#39;0&#39;);
 			if (!in_range)
 				a = b;
<span class="p_del">-			exp_digit = 0;</span>
<span class="p_add">+			at_start = 0;</span>
 			totaldigits++;
 		}
 		if (!(a &lt;= b))
 			return -EINVAL;
 		if (b &gt;= nmaskbits)
 			return -ERANGE;
<span class="p_del">-		while (a &lt;= b) {</span>
<span class="p_del">-			set_bit(a, maskp);</span>
<span class="p_del">-			a++;</span>
<span class="p_add">+		if (!at_start) {</span>
<span class="p_add">+			while (a &lt;= b) {</span>
<span class="p_add">+				set_bit(a, maskp);</span>
<span class="p_add">+				a++;</span>
<span class="p_add">+			}</span>
 		}
 	} while (buflen &amp;&amp; c == &#39;,&#39;);
 	return 0;
<span class="p_header">diff --git a/net/9p/client.c b/net/9p/client.c</span>
<span class="p_header">index addc116cecf0..853d62327a58 100644</span>
<span class="p_header">--- a/net/9p/client.c</span>
<span class="p_header">+++ b/net/9p/client.c</span>
<span class="p_chunk">@@ -828,7 +828,8 @@</span> <span class="p_context"> static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,</span>
 	if (err &lt; 0) {
 		if (err == -EIO)
 			c-&gt;status = Disconnected;
<span class="p_del">-		goto reterr;</span>
<span class="p_add">+		if (err != -ERESTARTSYS)</span>
<span class="p_add">+			goto reterr;</span>
 	}
 	if (req-&gt;status == REQ_STATUS_ERROR) {
 		p9_debug(P9_DEBUG_ERROR, &quot;req_status error %d\n&quot;, req-&gt;t_err);
<span class="p_header">diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c</span>
<span class="p_header">index dbd9a4792427..7ec4e0522215 100644</span>
<span class="p_header">--- a/net/ceph/osdmap.c</span>
<span class="p_header">+++ b/net/ceph/osdmap.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> static int crush_decode_tree_bucket(void **p, void *end,</span>
 {
 	int j;
 	dout(&quot;crush_decode_tree_bucket %p to %p\n&quot;, *p, end);
<span class="p_del">-	ceph_decode_32_safe(p, end, b-&gt;num_nodes, bad);</span>
<span class="p_add">+	ceph_decode_8_safe(p, end, b-&gt;num_nodes, bad);</span>
 	b-&gt;node_weights = kcalloc(b-&gt;num_nodes, sizeof(u32), GFP_NOFS);
 	if (b-&gt;node_weights == NULL)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/mac80211/main.c b/net/mac80211/main.c</span>
<span class="p_header">index 6658c5809353..dd6ca36c34c1 100644</span>
<span class="p_header">--- a/net/mac80211/main.c</span>
<span class="p_header">+++ b/net/mac80211/main.c</span>
<span class="p_chunk">@@ -257,6 +257,7 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 {
 	struct ieee80211_local *local =
 		container_of(work, struct ieee80211_local, restart_work);
<span class="p_add">+	struct ieee80211_sub_if_data *sdata;</span>
 
 	/* wait for scan work complete */
 	flush_workqueue(local-&gt;workqueue);
<span class="p_chunk">@@ -269,6 +270,8 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 	mutex_unlock(&amp;local-&gt;mtx);
 
 	rtnl_lock();
<span class="p_add">+	list_for_each_entry(sdata, &amp;local-&gt;interfaces, list)</span>
<span class="p_add">+		flush_delayed_work(&amp;sdata-&gt;dec_tailroom_needed_wk);</span>
 	ieee80211_scan_cancel(local);
 	ieee80211_reconfig(local);
 	rtnl_unlock();
<span class="p_header">diff --git a/net/sunrpc/backchannel_rqst.c b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">index 890a29912d5a..d29c119ecd9c 100644</span>
<span class="p_header">--- a/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">+++ b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> static void xprt_free_allocation(struct rpc_rqst *req)</span>
 
 	dprintk(&quot;RPC:        free allocations for req= %p\n&quot;, req);
 	WARN_ON_ONCE(test_bit(RPC_BC_PA_IN_USE, &amp;req-&gt;rq_bc_pa_state));
<span class="p_del">-	xbufp = &amp;req-&gt;rq_private_buf;</span>
<span class="p_add">+	xbufp = &amp;req-&gt;rq_rcv_buf;</span>
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
 	xbufp = &amp;req-&gt;rq_snd_buf;
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index ca2094c914a1..a82d6576fe0f 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -3365,6 +3365,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_LIFEBOOK,
 	ALC269_FIXUP_LIFEBOOK_EXTMIC,
 	ALC269_FIXUP_LIFEBOOK_HP_PIN,
<span class="p_add">+	ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT,</span>
 	ALC269_FIXUP_AMIC,
 	ALC269_FIXUP_DMIC,
 	ALC269VB_FIXUP_AMIC,
<span class="p_chunk">@@ -3383,6 +3384,7 @@</span> <span class="p_context"> enum {</span>
 	ALC290_FIXUP_MONO_SPEAKERS,
 	ALC269_FIXUP_HEADSET_MODE,
 	ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC,
<span class="p_add">+	ALC269_FIXUP_ASPIRE_HEADSET_MIC,</span>
 	ALC269_FIXUP_ASUS_X101_FUNC,
 	ALC269_FIXUP_ASUS_X101_VERB,
 	ALC269_FIXUP_ASUS_X101,
<span class="p_chunk">@@ -3486,6 +3488,10 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{ }
 		},
 	},
<span class="p_add">+	[ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc269_fixup_pincfg_no_hp_to_lineout,</span>
<span class="p_add">+	},</span>
 	[ALC269_FIXUP_AMIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -3598,6 +3604,15 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_headset_mode_no_hp_mic,
 	},
<span class="p_add">+	[ALC269_FIXUP_ASPIRE_HEADSET_MIC] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x19, 0x01a1913c }, /* headset mic w/o jack detect */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_HEADSET_MODE,</span>
<span class="p_add">+	},</span>
 	[ALC286_FIXUP_SONY_MIC_NO_PRESENCE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -3732,10 +3747,13 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK_VENDOR(0x104d, &quot;Sony VAIO&quot;, ALC269_FIXUP_SONY_VAIO),
 	SND_PCI_QUIRK(0x1028, 0x0470, &quot;Dell M101z&quot;, ALC269_FIXUP_DELL_M101Z),
 	SND_PCI_QUIRK(0x1025, 0x047c, &quot;Acer AC700&quot;, ALC269_FIXUP_ACER_AC700),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x072d, &quot;Acer Aspire V5-571G&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x080d, &quot;Acer Aspire V5-122P&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
 	SND_PCI_QUIRK(0x1025, 0x0740, &quot;Acer AO725&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0742, &quot;Acer AO756&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK_VENDOR(0x1025, &quot;Acer Aspire&quot;, ALC271_FIXUP_DMIC),
 	SND_PCI_QUIRK(0x10cf, 0x1475, &quot;Lifebook&quot;, ALC269_FIXUP_LIFEBOOK),
<span class="p_add">+	SND_PCI_QUIRK(0x10cf, 0x159f, &quot;Lifebook E780&quot;, ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT),</span>
 	SND_PCI_QUIRK(0x10cf, 0x15dc, &quot;Lifebook T731&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1757, &quot;Lifebook E752&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1845, &quot;Lifebook U904&quot;, ALC269_FIXUP_LIFEBOOK_EXTMIC),
<span class="p_header">diff --git a/sound/soc/codecs/wm8737.c b/sound/soc/codecs/wm8737.c</span>
<span class="p_header">index 2f167a8ca01b..62bacb8536e6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8737.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8737.c</span>
<span class="p_chunk">@@ -494,7 +494,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 			/* Fast VMID ramp at 2*2.5k */
 			snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-					    WM8737_VMIDSEL_MASK, 0x4);</span>
<span class="p_add">+					    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+					    2 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 			/* Bring VMID up */
 			snd_soc_update_bits(codec, WM8737_POWER_MANAGEMENT,
<span class="p_chunk">@@ -508,7 +509,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 		/* VMID at 2*300k */
 		snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-				    WM8737_VMIDSEL_MASK, 2);</span>
<span class="p_add">+				    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+				    1 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 		break;
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8903.h b/sound/soc/codecs/wm8903.h</span>
<span class="p_header">index db949311c0f2..0bb4a647755d 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8903.h</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8903.h</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> extern int wm8903_mic_detect(struct snd_soc_codec *codec,</span>
 #define WM8903_VMID_BUF_ENA_WIDTH                    1  /* VMID_BUF_ENA */
 
 #define WM8903_VMID_RES_50K                          2
<span class="p_del">-#define WM8903_VMID_RES_250K                         3</span>
<span class="p_add">+#define WM8903_VMID_RES_250K                         4</span>
 #define WM8903_VMID_RES_5K                           6
 
 /*
<span class="p_header">diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c</span>
<span class="p_header">index 1c1fc6119758..475fc24c8ff6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8955.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8955.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> static int wm8955_configure_clocking(struct snd_soc_codec *codec)</span>
 		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_17_9_MASK,
 				    (pll.k &gt;&gt; 9) &amp; WM8955_K_17_9_MASK);
<span class="p_del">-		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_3,</span>
 				    WM8955_K_8_0_MASK,
 				    pll.k &amp; WM8955_K_8_0_MASK);
 		if (pll.k)
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index 39f65bc9de56..ae5bb95df862 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> SOC_SINGLE(&quot;PCM Playback -6dB Switch&quot;, WM8960_DACCTL1, 7, 1, 0),</span>
 SOC_ENUM(&quot;ADC Polarity&quot;, wm8960_enum[0]),
 SOC_SINGLE(&quot;ADC High Pass Filter Switch&quot;, WM8960_DACCTL1, 0, 1, 0),
 
<span class="p_del">-SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[2]),</span>
<span class="p_add">+SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[1]),</span>
 SOC_SINGLE_BOOL_EXT(&quot;DAC Deemphasis Switch&quot;, 0,
 		    wm8960_get_deemph, wm8960_put_deemph),
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



