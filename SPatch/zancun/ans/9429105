
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.32 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.32</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 15, 2016, 7:35 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161115073533.GB28908@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9429105/mbox/"
   >mbox</a>
|
   <a href="/patch/9429105/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9429105/">/patch/9429105/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	3D52160484 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 15 Nov 2016 07:35:41 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1895727FB3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 15 Nov 2016 07:35:41 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 0C81728607; Tue, 15 Nov 2016 07:35:41 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id AEA2C28375
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 15 Nov 2016 07:35:38 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S965829AbcKOHfd (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 15 Nov 2016 02:35:33 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:49286 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752200AbcKOHfY (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 15 Nov 2016 02:35:24 -0500
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 2EA40415;
	Tue, 15 Nov 2016 07:35:22 +0000 (UTC)
Date: Tue, 15 Nov 2016 08:35:33 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.32
Message-ID: &lt;20161115073533.GB28908@kroah.com&gt;
References: &lt;20161115073528.GA28908@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161115073528.GA28908@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Nov. 15, 2016, 7:35 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 7c6f28e7a2f6..fba9b09a1330 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 31</span>
<span class="p_add">+SUBLEVEL = 32</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index bbe56871245c..4298aeb1e20f 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -822,7 +822,7 @@</span> <span class="p_context"> static void kvm_mips_invalidate_guest_tlb(struct kvm_vcpu *vcpu,</span>
 	bool user;
 
 	/* No need to flush for entries which are already invalid */
<span class="p_del">-	if (!((tlb-&gt;tlb_lo[0] | tlb-&gt;tlb_lo[1]) &amp; ENTRYLO_V))</span>
<span class="p_add">+	if (!((tlb-&gt;tlb_lo0 | tlb-&gt;tlb_lo1) &amp; MIPS3_PG_V))</span>
 		return;
 	/* User address space doesn&#39;t need flushing for KSeg2/3 changes */
 	user = tlb-&gt;tlb_hi &lt; KVM_GUEST_KSEG0;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c</span>
<span class="p_header">index 21aacc1f45c1..7f85c2c1d681 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c</span>
<span class="p_chunk">@@ -265,15 +265,27 @@</span> <span class="p_context"> static int amdgpu_atombios_dp_get_dp_link_config(struct drm_connector *connector</span>
 	unsigned max_lane_num = drm_dp_max_lane_count(dpcd);
 	unsigned lane_num, i, max_pix_clock;
 
<span class="p_del">-	for (lane_num = 1; lane_num &lt;= max_lane_num; lane_num &lt;&lt;= 1) {</span>
<span class="p_del">-		for (i = 0; i &lt; ARRAY_SIZE(link_rates) &amp;&amp; link_rates[i] &lt;= max_link_rate; i++) {</span>
<span class="p_del">-			max_pix_clock = (lane_num * link_rates[i] * 8) / bpp;</span>
<span class="p_add">+	if (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) ==</span>
<span class="p_add">+	    ENCODER_OBJECT_ID_NUTMEG) {</span>
<span class="p_add">+		for (lane_num = 1; lane_num &lt;= max_lane_num; lane_num &lt;&lt;= 1) {</span>
<span class="p_add">+			max_pix_clock = (lane_num * 270000 * 8) / bpp;</span>
 			if (max_pix_clock &gt;= pix_clock) {
 				*dp_lanes = lane_num;
<span class="p_del">-				*dp_rate = link_rates[i];</span>
<span class="p_add">+				*dp_rate = 270000;</span>
 				return 0;
 			}
 		}
<span class="p_add">+	} else {</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(link_rates) &amp;&amp; link_rates[i] &lt;= max_link_rate; i++) {</span>
<span class="p_add">+			for (lane_num = 1; lane_num &lt;= max_lane_num; lane_num &lt;&lt;= 1) {</span>
<span class="p_add">+				max_pix_clock = (lane_num * link_rates[i] * 8) / bpp;</span>
<span class="p_add">+				if (max_pix_clock &gt;= pix_clock) {</span>
<span class="p_add">+					*dp_lanes = lane_num;</span>
<span class="p_add">+					*dp_rate = link_rates[i];</span>
<span class="p_add">+					return 0;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	return -EINVAL;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index 44ee72e04df9..b5760851195c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -315,15 +315,27 @@</span> <span class="p_context"> int radeon_dp_get_dp_link_config(struct drm_connector *connector,</span>
 	unsigned max_lane_num = drm_dp_max_lane_count(dpcd);
 	unsigned lane_num, i, max_pix_clock;
 
<span class="p_del">-	for (lane_num = 1; lane_num &lt;= max_lane_num; lane_num &lt;&lt;= 1) {</span>
<span class="p_del">-		for (i = 0; i &lt; ARRAY_SIZE(link_rates) &amp;&amp; link_rates[i] &lt;= max_link_rate; i++) {</span>
<span class="p_del">-			max_pix_clock = (lane_num * link_rates[i] * 8) / bpp;</span>
<span class="p_add">+	if (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) ==</span>
<span class="p_add">+	    ENCODER_OBJECT_ID_NUTMEG) {</span>
<span class="p_add">+		for (lane_num = 1; lane_num &lt;= max_lane_num; lane_num &lt;&lt;= 1) {</span>
<span class="p_add">+			max_pix_clock = (lane_num * 270000 * 8) / bpp;</span>
 			if (max_pix_clock &gt;= pix_clock) {
 				*dp_lanes = lane_num;
<span class="p_del">-				*dp_rate = link_rates[i];</span>
<span class="p_add">+				*dp_rate = 270000;</span>
 				return 0;
 			}
 		}
<span class="p_add">+	} else {</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(link_rates) &amp;&amp; link_rates[i] &lt;= max_link_rate; i++) {</span>
<span class="p_add">+			for (lane_num = 1; lane_num &lt;= max_lane_num; lane_num &lt;&lt;= 1) {</span>
<span class="p_add">+				max_pix_clock = (lane_num * link_rates[i] * 8) / bpp;</span>
<span class="p_add">+				if (max_pix_clock &gt;= pix_clock) {</span>
<span class="p_add">+					*dp_lanes = lane_num;</span>
<span class="p_add">+					*dp_rate = link_rates[i];</span>
<span class="p_add">+					return 0;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	return -EINVAL;
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">index ca5ac5d6f4e6..49056c33be74 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_chunk">@@ -18142,14 +18142,14 @@</span> <span class="p_context"> static pci_ers_result_t tg3_io_error_detected(struct pci_dev *pdev,</span>
 
 	rtnl_lock();
 
<span class="p_del">-	/* We needn&#39;t recover from permanent error */</span>
<span class="p_del">-	if (state == pci_channel_io_frozen)</span>
<span class="p_del">-		tp-&gt;pcierr_recovery = true;</span>
<span class="p_del">-</span>
 	/* We probably don&#39;t have netdev yet */
 	if (!netdev || !netif_running(netdev))
 		goto done;
 
<span class="p_add">+	/* We needn&#39;t recover from permanent error */</span>
<span class="p_add">+	if (state == pci_channel_io_frozen)</span>
<span class="p_add">+		tp-&gt;pcierr_recovery = true;</span>
<span class="p_add">+</span>
 	tg3_phy_stop(tp);
 
 	tg3_netif_stop(tp);
<span class="p_chunk">@@ -18246,7 +18246,7 @@</span> <span class="p_context"> static void tg3_io_resume(struct pci_dev *pdev)</span>
 
 	rtnl_lock();
 
<span class="p_del">-	if (!netif_running(netdev))</span>
<span class="p_add">+	if (!netdev || !netif_running(netdev))</span>
 		goto done;
 
 	tg3_full_lock(tp, 0);
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_header">index f6147ffc7fbc..ab716042bdd2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_chunk">@@ -944,11 +944,11 @@</span> <span class="p_context"> fec_restart(struct net_device *ndev)</span>
 	 * enet-mac reset will reset mac address registers too,
 	 * so need to reconfigure it.
 	 */
<span class="p_del">-	if (fep-&gt;quirks &amp; FEC_QUIRK_ENET_MAC) {</span>
<span class="p_del">-		memcpy(&amp;temp_mac, ndev-&gt;dev_addr, ETH_ALEN);</span>
<span class="p_del">-		writel(cpu_to_be32(temp_mac[0]), fep-&gt;hwp + FEC_ADDR_LOW);</span>
<span class="p_del">-		writel(cpu_to_be32(temp_mac[1]), fep-&gt;hwp + FEC_ADDR_HIGH);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	memcpy(&amp;temp_mac, ndev-&gt;dev_addr, ETH_ALEN);</span>
<span class="p_add">+	writel((__force u32)cpu_to_be32(temp_mac[0]),</span>
<span class="p_add">+	       fep-&gt;hwp + FEC_ADDR_LOW);</span>
<span class="p_add">+	writel((__force u32)cpu_to_be32(temp_mac[1]),</span>
<span class="p_add">+	       fep-&gt;hwp + FEC_ADDR_HIGH);</span>
 
 	/* Clear any outstanding interrupt. */
 	writel(0xffffffff, fep-&gt;hwp + FEC_IEVENT);
<span class="p_header">diff --git a/drivers/net/geneve.c b/drivers/net/geneve.c</span>
<span class="p_header">index 69e31e2a68fc..4827c6987ac3 100644</span>
<span class="p_header">--- a/drivers/net/geneve.c</span>
<span class="p_header">+++ b/drivers/net/geneve.c</span>
<span class="p_chunk">@@ -440,7 +440,7 @@</span> <span class="p_context"> static struct sk_buff **geneve_gro_receive(struct sk_buff **head,</span>
 
 	skb_gro_pull(skb, gh_len);
 	skb_gro_postpull_rcsum(skb, gh, gh_len);
<span class="p_del">-	pp = ptype-&gt;callbacks.gro_receive(head, skb);</span>
<span class="p_add">+	pp = call_gro_receive(ptype-&gt;callbacks.gro_receive, head, skb);</span>
 
 out_unlock:
 	rcu_read_unlock();
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index 003780901628..6fa8e165878e 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -593,7 +593,7 @@</span> <span class="p_context"> static struct sk_buff **vxlan_gro_receive(struct sk_buff **head,</span>
 		}
 	}
 
<span class="p_del">-	pp = eth_gro_receive(head, skb);</span>
<span class="p_add">+	pp = call_gro_receive(eth_gro_receive, head, skb);</span>
 
 out:
 	skb_gro_remcsum_cleanup(skb, &amp;grc);
<span class="p_header">diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c</span>
<span class="p_header">index ed01c0172e4a..07dd81586c52 100644</span>
<span class="p_header">--- a/drivers/of/of_reserved_mem.c</span>
<span class="p_header">+++ b/drivers/of/of_reserved_mem.c</span>
<span class="p_chunk">@@ -127,8 +127,12 @@</span> <span class="p_context"> static int __init __reserved_mem_alloc_size(unsigned long node,</span>
 	}
 
 	/* Need adjust the alignment to satisfy the CMA requirement */
<span class="p_del">-	if (IS_ENABLED(CONFIG_CMA) &amp;&amp; of_flat_dt_is_compatible(node, &quot;shared-dma-pool&quot;))</span>
<span class="p_del">-		align = max(align, (phys_addr_t)PAGE_SIZE &lt;&lt; max(MAX_ORDER - 1, pageblock_order));</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_CMA) &amp;&amp; of_flat_dt_is_compatible(node, &quot;shared-dma-pool&quot;)) {</span>
<span class="p_add">+		unsigned long order =</span>
<span class="p_add">+			max_t(unsigned long, MAX_ORDER - 1, pageblock_order);</span>
<span class="p_add">+</span>
<span class="p_add">+		align = max(align, (phys_addr_t)PAGE_SIZE &lt;&lt; order);</span>
<span class="p_add">+	}</span>
 
 	prop = of_get_flat_dt_prop(node, &quot;alloc-ranges&quot;, &amp;len);
 	if (prop) {
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">index ef4ff03242ea..aaf7da07a358 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_chunk">@@ -1923,7 +1923,7 @@</span> <span class="p_context"> struct megasas_instance_template {</span>
 };
 
 #define MEGASAS_IS_LOGICAL(scp)						\
<span class="p_del">-	(scp-&gt;device-&gt;channel &lt; MEGASAS_MAX_PD_CHANNELS) ? 0 : 1</span>
<span class="p_add">+	((scp-&gt;device-&gt;channel &lt; MEGASAS_MAX_PD_CHANNELS) ? 0 : 1)</span>
 
 #define MEGASAS_DEV_INDEX(scp)						\
 	(((scp-&gt;device-&gt;channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL) +	\
<span class="p_header">diff --git a/include/linux/mroute.h b/include/linux/mroute.h</span>
<span class="p_header">index 79aaa9fc1a15..d5277fc3ce2e 100644</span>
<span class="p_header">--- a/include/linux/mroute.h</span>
<span class="p_header">+++ b/include/linux/mroute.h</span>
<span class="p_chunk">@@ -103,5 +103,5 @@</span> <span class="p_context"> struct mfc_cache {</span>
 struct rtmsg;
 extern int ipmr_get_route(struct net *net, struct sk_buff *skb,
 			  __be32 saddr, __be32 daddr,
<span class="p_del">-			  struct rtmsg *rtm, int nowait);</span>
<span class="p_add">+			  struct rtmsg *rtm, int nowait, u32 portid);</span>
 #endif
<span class="p_header">diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h</span>
<span class="p_header">index 66982e764051..f831155dc7d1 100644</span>
<span class="p_header">--- a/include/linux/mroute6.h</span>
<span class="p_header">+++ b/include/linux/mroute6.h</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> struct mfc6_cache {</span>
 
 struct rtmsg;
 extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
<span class="p_del">-			   struct rtmsg *rtm, int nowait);</span>
<span class="p_add">+			   struct rtmsg *rtm, int nowait, u32 portid);</span>
 
 #ifdef CONFIG_IPV6_MROUTE
 extern struct sock *mroute6_socket(struct net *net, struct sk_buff *skb);
<span class="p_header">diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h</span>
<span class="p_header">index 12b4d54a8ffa..9d6025703f73 100644</span>
<span class="p_header">--- a/include/linux/netdevice.h</span>
<span class="p_header">+++ b/include/linux/netdevice.h</span>
<span class="p_chunk">@@ -2003,7 +2003,10 @@</span> <span class="p_context"> struct napi_gro_cb {</span>
 	/* Used in foo-over-udp, set in udp[46]_gro_receive */
 	u8	is_ipv6:1;
 
<span class="p_del">-	/* 7 bit hole */</span>
<span class="p_add">+	/* Number of gro_receive callbacks this packet already went through */</span>
<span class="p_add">+	u8 recursion_counter:4;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 3 bit hole */</span>
 
 	/* used to support CHECKSUM_COMPLETE for tunneling protocols */
 	__wsum	csum;
<span class="p_chunk">@@ -2014,6 +2017,25 @@</span> <span class="p_context"> struct napi_gro_cb {</span>
 
 #define NAPI_GRO_CB(skb) ((struct napi_gro_cb *)(skb)-&gt;cb)
 
<span class="p_add">+#define GRO_RECURSION_LIMIT 15</span>
<span class="p_add">+static inline int gro_recursion_inc_test(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ++NAPI_GRO_CB(skb)-&gt;recursion_counter == GRO_RECURSION_LIMIT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+typedef struct sk_buff **(*gro_receive_t)(struct sk_buff **, struct sk_buff *);</span>
<span class="p_add">+static inline struct sk_buff **call_gro_receive(gro_receive_t cb,</span>
<span class="p_add">+						struct sk_buff **head,</span>
<span class="p_add">+						struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(gro_recursion_inc_test(skb))) {</span>
<span class="p_add">+		NAPI_GRO_CB(skb)-&gt;flush |= 1;</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return cb(head, skb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct packet_type {
 	__be16			type;	/* This is really htons(ether_type). */
 	struct net_device	*dev;	/* NULL is wildcarded here	     */
<span class="p_chunk">@@ -2059,6 +2081,22 @@</span> <span class="p_context"> struct udp_offload {</span>
 	struct udp_offload_callbacks callbacks;
 };
 
<span class="p_add">+typedef struct sk_buff **(*gro_receive_udp_t)(struct sk_buff **,</span>
<span class="p_add">+					      struct sk_buff *,</span>
<span class="p_add">+					      struct udp_offload *);</span>
<span class="p_add">+static inline struct sk_buff **call_gro_receive_udp(gro_receive_udp_t cb,</span>
<span class="p_add">+						    struct sk_buff **head,</span>
<span class="p_add">+						    struct sk_buff *skb,</span>
<span class="p_add">+						    struct udp_offload *uoff)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(gro_recursion_inc_test(skb))) {</span>
<span class="p_add">+		NAPI_GRO_CB(skb)-&gt;flush |= 1;</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return cb(head, skb, uoff);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* often modified stats are per cpu, other are shared (netdev-&gt;stats) */
 struct pcpu_sw_netstats {
 	u64     rx_packets;
<span class="p_header">diff --git a/include/net/ip.h b/include/net/ip.h</span>
<span class="p_header">index 1a98f1ca1638..b450d8653b30 100644</span>
<span class="p_header">--- a/include/net/ip.h</span>
<span class="p_header">+++ b/include/net/ip.h</span>
<span class="p_chunk">@@ -553,7 +553,7 @@</span> <span class="p_context"> int ip_options_rcv_srr(struct sk_buff *skb);</span>
  */
 
 void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb);
<span class="p_del">-void ip_cmsg_recv_offset(struct msghdr *msg, struct sk_buff *skb, int offset);</span>
<span class="p_add">+void ip_cmsg_recv_offset(struct msghdr *msg, struct sk_buff *skb, int tlen, int offset);</span>
 int ip_cmsg_send(struct net *net, struct msghdr *msg,
 		 struct ipcm_cookie *ipc, bool allow_ipv6);
 int ip_setsockopt(struct sock *sk, int level, int optname, char __user *optval,
<span class="p_chunk">@@ -575,7 +575,7 @@</span> <span class="p_context"> void ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 dport,</span>
 
 static inline void ip_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)
 {
<span class="p_del">-	ip_cmsg_recv_offset(msg, skb, 0);</span>
<span class="p_add">+	ip_cmsg_recv_offset(msg, skb, 0, 0);</span>
 }
 
 bool icmp_global_allow(void);
<span class="p_header">diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h</span>
<span class="p_header">index 86df0835f6b5..e5bba897d206 100644</span>
<span class="p_header">--- a/include/net/sch_generic.h</span>
<span class="p_header">+++ b/include/net/sch_generic.h</span>
<span class="p_chunk">@@ -408,6 +408,15 @@</span> <span class="p_context"> bool tcf_destroy(struct tcf_proto *tp, bool force);</span>
 void tcf_destroy_chain(struct tcf_proto __rcu **fl);
 int skb_do_redirect(struct sk_buff *);
 
<span class="p_add">+static inline bool skb_at_tc_ingress(const struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_NET_CLS_ACT</span>
<span class="p_add">+	return G_TC_AT(skb-&gt;tc_verd) &amp; AT_INGRESS;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Reset all TX qdiscs greater then index of a device.  */
 static inline void qdisc_reset_all_tx_gt(struct net_device *dev, unsigned int i)
 {
<span class="p_header">diff --git a/include/net/sock.h b/include/net/sock.h</span>
<span class="p_header">index 14d3c0734007..3d5ff7436f41 100644</span>
<span class="p_header">--- a/include/net/sock.h</span>
<span class="p_header">+++ b/include/net/sock.h</span>
<span class="p_chunk">@@ -1425,6 +1425,16 @@</span> <span class="p_context"> static inline void sk_mem_uncharge(struct sock *sk, int size)</span>
 	if (!sk_has_account(sk))
 		return;
 	sk-&gt;sk_forward_alloc += size;
<span class="p_add">+</span>
<span class="p_add">+	/* Avoid a possible overflow.</span>
<span class="p_add">+	 * TCP send queues can make this happen, if sk_mem_reclaim()</span>
<span class="p_add">+	 * is not called and more than 2 GBytes are released at once.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If we reach 2 MBytes, reclaim 1 MBytes right now, there is</span>
<span class="p_add">+	 * no need to hold that much forward allocation anyway.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(sk-&gt;sk_forward_alloc &gt;= 1 &lt;&lt; 21))</span>
<span class="p_add">+		__sk_mem_reclaim(sk, 1 &lt;&lt; 20);</span>
 }
 
 static inline void sk_wmem_free_skb(struct sock *sk, struct sk_buff *skb)
<span class="p_header">diff --git a/include/uapi/linux/rtnetlink.h b/include/uapi/linux/rtnetlink.h</span>
<span class="p_header">index 123a5af4e8bb..fa3b34365560 100644</span>
<span class="p_header">--- a/include/uapi/linux/rtnetlink.h</span>
<span class="p_header">+++ b/include/uapi/linux/rtnetlink.h</span>
<span class="p_chunk">@@ -343,7 +343,7 @@</span> <span class="p_context"> struct rtnexthop {</span>
 #define RTNH_F_OFFLOAD		8	/* offloaded route */
 #define RTNH_F_LINKDOWN		16	/* carrier-down on nexthop */
 
<span class="p_del">-#define RTNH_COMPARE_MASK	(RTNH_F_DEAD | RTNH_F_LINKDOWN)</span>
<span class="p_add">+#define RTNH_COMPARE_MASK	(RTNH_F_DEAD | RTNH_F_LINKDOWN | RTNH_F_OFFLOAD)</span>
 
 /* Macros to handle hexthops */
 
<span class="p_header">diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c</span>
<span class="p_header">index d2cd9de4b724..ad8d6e6b87ca 100644</span>
<span class="p_header">--- a/net/8021q/vlan.c</span>
<span class="p_header">+++ b/net/8021q/vlan.c</span>
<span class="p_chunk">@@ -659,7 +659,7 @@</span> <span class="p_context"> static struct sk_buff **vlan_gro_receive(struct sk_buff **head,</span>
 
 	skb_gro_pull(skb, sizeof(*vhdr));
 	skb_gro_postpull_rcsum(skb, vhdr, sizeof(*vhdr));
<span class="p_del">-	pp = ptype-&gt;callbacks.gro_receive(head, skb);</span>
<span class="p_add">+	pp = call_gro_receive(ptype-&gt;callbacks.gro_receive, head, skb);</span>
 
 out_unlock:
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 9542e84a9455..d80c15d028fe 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -951,13 +951,12 @@</span> <span class="p_context"> static void br_multicast_enable(struct bridge_mcast_own_query *query)</span>
 		mod_timer(&amp;query-&gt;timer, jiffies);
 }
 
<span class="p_del">-void br_multicast_enable_port(struct net_bridge_port *port)</span>
<span class="p_add">+static void __br_multicast_enable_port(struct net_bridge_port *port)</span>
 {
 	struct net_bridge *br = port-&gt;br;
 
<span class="p_del">-	spin_lock(&amp;br-&gt;multicast_lock);</span>
 	if (br-&gt;multicast_disabled || !netif_running(br-&gt;dev))
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return;</span>
 
 	br_multicast_enable(&amp;port-&gt;ip4_own_query);
 #if IS_ENABLED(CONFIG_IPV6)
<span class="p_chunk">@@ -965,8 +964,14 @@</span> <span class="p_context"> void br_multicast_enable_port(struct net_bridge_port *port)</span>
 #endif
 	if (port-&gt;multicast_router == 2 &amp;&amp; hlist_unhashed(&amp;port-&gt;rlist))
 		br_multicast_add_router(br, port);
<span class="p_add">+}</span>
 
<span class="p_del">-out:</span>
<span class="p_add">+void br_multicast_enable_port(struct net_bridge_port *port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct net_bridge *br = port-&gt;br;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;br-&gt;multicast_lock);</span>
<span class="p_add">+	__br_multicast_enable_port(port);</span>
 	spin_unlock(&amp;br-&gt;multicast_lock);
 }
 
<span class="p_chunk">@@ -1905,8 +1910,9 @@</span> <span class="p_context"> static void br_multicast_start_querier(struct net_bridge *br,</span>
 
 int br_multicast_toggle(struct net_bridge *br, unsigned long val)
 {
<span class="p_del">-	int err = 0;</span>
 	struct net_bridge_mdb_htable *mdb;
<span class="p_add">+	struct net_bridge_port *port;</span>
<span class="p_add">+	int err = 0;</span>
 
 	spin_lock_bh(&amp;br-&gt;multicast_lock);
 	if (br-&gt;multicast_disabled == !val)
<span class="p_chunk">@@ -1934,10 +1940,9 @@</span> <span class="p_context"> rollback:</span>
 			goto rollback;
 	}
 
<span class="p_del">-	br_multicast_start_querier(br, &amp;br-&gt;ip4_own_query);</span>
<span class="p_del">-#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="p_del">-	br_multicast_start_querier(br, &amp;br-&gt;ip6_own_query);</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	br_multicast_open(br);</span>
<span class="p_add">+	list_for_each_entry(port, &amp;br-&gt;port_list, list)</span>
<span class="p_add">+		__br_multicast_enable_port(port);</span>
 
 unlock:
 	spin_unlock_bh(&amp;br-&gt;multicast_lock);
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 0989fea88c44..b3fa4b86ab4c 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2836,6 +2836,7 @@</span> <span class="p_context"> struct sk_buff *validate_xmit_skb_list(struct sk_buff *skb, struct net_device *d</span>
 	}
 	return head;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(validate_xmit_skb_list);</span>
 
 static void qdisc_pkt_len_init(struct sk_buff *skb)
 {
<span class="p_chunk">@@ -4240,6 +4241,7 @@</span> <span class="p_context"> static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff</span>
 		NAPI_GRO_CB(skb)-&gt;flush = 0;
 		NAPI_GRO_CB(skb)-&gt;free = 0;
 		NAPI_GRO_CB(skb)-&gt;encap_mark = 0;
<span class="p_add">+		NAPI_GRO_CB(skb)-&gt;recursion_counter = 0;</span>
 		NAPI_GRO_CB(skb)-&gt;gro_remcsum_start = 0;
 
 		/* Setup for GRO checksum validation */
<span class="p_chunk">@@ -5204,6 +5206,7 @@</span> <span class="p_context"> static inline bool netdev_adjacent_is_neigh_list(struct net_device *dev,</span>
 
 static int __netdev_adjacent_dev_insert(struct net_device *dev,
 					struct net_device *adj_dev,
<span class="p_add">+					u16 ref_nr,</span>
 					struct list_head *dev_list,
 					void *private, bool master)
 {
<span class="p_chunk">@@ -5213,7 +5216,7 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_insert(struct net_device *dev,</span>
 	adj = __netdev_find_adj(adj_dev, dev_list);
 
 	if (adj) {
<span class="p_del">-		adj-&gt;ref_nr++;</span>
<span class="p_add">+		adj-&gt;ref_nr += ref_nr;</span>
 		return 0;
 	}
 
<span class="p_chunk">@@ -5223,7 +5226,7 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_insert(struct net_device *dev,</span>
 
 	adj-&gt;dev = adj_dev;
 	adj-&gt;master = master;
<span class="p_del">-	adj-&gt;ref_nr = 1;</span>
<span class="p_add">+	adj-&gt;ref_nr = ref_nr;</span>
 	adj-&gt;private = private;
 	dev_hold(adj_dev);
 
<span class="p_chunk">@@ -5262,6 +5265,7 @@</span> <span class="p_context"> free_adj:</span>
 
 static void __netdev_adjacent_dev_remove(struct net_device *dev,
 					 struct net_device *adj_dev,
<span class="p_add">+					 u16 ref_nr,</span>
 					 struct list_head *dev_list)
 {
 	struct netdev_adjacent *adj;
<span class="p_chunk">@@ -5274,10 +5278,10 @@</span> <span class="p_context"> static void __netdev_adjacent_dev_remove(struct net_device *dev,</span>
 		BUG();
 	}
 
<span class="p_del">-	if (adj-&gt;ref_nr &gt; 1) {</span>
<span class="p_del">-		pr_debug(&quot;%s to %s ref_nr-- = %d\n&quot;, dev-&gt;name, adj_dev-&gt;name,</span>
<span class="p_del">-			 adj-&gt;ref_nr-1);</span>
<span class="p_del">-		adj-&gt;ref_nr--;</span>
<span class="p_add">+	if (adj-&gt;ref_nr &gt; ref_nr) {</span>
<span class="p_add">+		pr_debug(&quot;%s to %s ref_nr-%d = %d\n&quot;, dev-&gt;name, adj_dev-&gt;name,</span>
<span class="p_add">+			 ref_nr, adj-&gt;ref_nr-ref_nr);</span>
<span class="p_add">+		adj-&gt;ref_nr -= ref_nr;</span>
 		return;
 	}
 
<span class="p_chunk">@@ -5296,21 +5300,22 @@</span> <span class="p_context"> static void __netdev_adjacent_dev_remove(struct net_device *dev,</span>
 
 static int __netdev_adjacent_dev_link_lists(struct net_device *dev,
 					    struct net_device *upper_dev,
<span class="p_add">+					    u16 ref_nr,</span>
 					    struct list_head *up_list,
 					    struct list_head *down_list,
 					    void *private, bool master)
 {
 	int ret;
 
<span class="p_del">-	ret = __netdev_adjacent_dev_insert(dev, upper_dev, up_list, private,</span>
<span class="p_del">-					   master);</span>
<span class="p_add">+	ret = __netdev_adjacent_dev_insert(dev, upper_dev, ref_nr, up_list,</span>
<span class="p_add">+					   private, master);</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	ret = __netdev_adjacent_dev_insert(upper_dev, dev, down_list, private,</span>
<span class="p_del">-					   false);</span>
<span class="p_add">+	ret = __netdev_adjacent_dev_insert(upper_dev, dev, ref_nr, down_list,</span>
<span class="p_add">+					   private, false);</span>
 	if (ret) {
<span class="p_del">-		__netdev_adjacent_dev_remove(dev, upper_dev, up_list);</span>
<span class="p_add">+		__netdev_adjacent_dev_remove(dev, upper_dev, ref_nr, up_list);</span>
 		return ret;
 	}
 
<span class="p_chunk">@@ -5318,9 +5323,10 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_link_lists(struct net_device *dev,</span>
 }
 
 static int __netdev_adjacent_dev_link(struct net_device *dev,
<span class="p_del">-				      struct net_device *upper_dev)</span>
<span class="p_add">+				      struct net_device *upper_dev,</span>
<span class="p_add">+				      u16 ref_nr)</span>
 {
<span class="p_del">-	return __netdev_adjacent_dev_link_lists(dev, upper_dev,</span>
<span class="p_add">+	return __netdev_adjacent_dev_link_lists(dev, upper_dev, ref_nr,</span>
 						&amp;dev-&gt;all_adj_list.upper,
 						&amp;upper_dev-&gt;all_adj_list.lower,
 						NULL, false);
<span class="p_chunk">@@ -5328,17 +5334,19 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_link(struct net_device *dev,</span>
 
 static void __netdev_adjacent_dev_unlink_lists(struct net_device *dev,
 					       struct net_device *upper_dev,
<span class="p_add">+					       u16 ref_nr,</span>
 					       struct list_head *up_list,
 					       struct list_head *down_list)
 {
<span class="p_del">-	__netdev_adjacent_dev_remove(dev, upper_dev, up_list);</span>
<span class="p_del">-	__netdev_adjacent_dev_remove(upper_dev, dev, down_list);</span>
<span class="p_add">+	__netdev_adjacent_dev_remove(dev, upper_dev, ref_nr, up_list);</span>
<span class="p_add">+	__netdev_adjacent_dev_remove(upper_dev, dev, ref_nr, down_list);</span>
 }
 
 static void __netdev_adjacent_dev_unlink(struct net_device *dev,
<span class="p_del">-					 struct net_device *upper_dev)</span>
<span class="p_add">+					 struct net_device *upper_dev,</span>
<span class="p_add">+					 u16 ref_nr)</span>
 {
<span class="p_del">-	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,</span>
<span class="p_add">+	__netdev_adjacent_dev_unlink_lists(dev, upper_dev, ref_nr,</span>
 					   &amp;dev-&gt;all_adj_list.upper,
 					   &amp;upper_dev-&gt;all_adj_list.lower);
 }
<span class="p_chunk">@@ -5347,17 +5355,17 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_link_neighbour(struct net_device *dev,</span>
 						struct net_device *upper_dev,
 						void *private, bool master)
 {
<span class="p_del">-	int ret = __netdev_adjacent_dev_link(dev, upper_dev);</span>
<span class="p_add">+	int ret = __netdev_adjacent_dev_link(dev, upper_dev, 1);</span>
 
 	if (ret)
 		return ret;
 
<span class="p_del">-	ret = __netdev_adjacent_dev_link_lists(dev, upper_dev,</span>
<span class="p_add">+	ret = __netdev_adjacent_dev_link_lists(dev, upper_dev, 1,</span>
 					       &amp;dev-&gt;adj_list.upper,
 					       &amp;upper_dev-&gt;adj_list.lower,
 					       private, master);
 	if (ret) {
<span class="p_del">-		__netdev_adjacent_dev_unlink(dev, upper_dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(dev, upper_dev, 1);</span>
 		return ret;
 	}
 
<span class="p_chunk">@@ -5367,8 +5375,8 @@</span> <span class="p_context"> static int __netdev_adjacent_dev_link_neighbour(struct net_device *dev,</span>
 static void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,
 						   struct net_device *upper_dev)
 {
<span class="p_del">-	__netdev_adjacent_dev_unlink(dev, upper_dev);</span>
<span class="p_del">-	__netdev_adjacent_dev_unlink_lists(dev, upper_dev,</span>
<span class="p_add">+	__netdev_adjacent_dev_unlink(dev, upper_dev, 1);</span>
<span class="p_add">+	__netdev_adjacent_dev_unlink_lists(dev, upper_dev, 1,</span>
 					   &amp;dev-&gt;adj_list.upper,
 					   &amp;upper_dev-&gt;adj_list.lower);
 }
<span class="p_chunk">@@ -5420,7 +5428,7 @@</span> <span class="p_context"> static int __netdev_upper_dev_link(struct net_device *dev,</span>
 		list_for_each_entry(j, &amp;upper_dev-&gt;all_adj_list.upper, list) {
 			pr_debug(&quot;Interlinking %s with %s, non-neighbour\n&quot;,
 				 i-&gt;dev-&gt;name, j-&gt;dev-&gt;name);
<span class="p_del">-			ret = __netdev_adjacent_dev_link(i-&gt;dev, j-&gt;dev);</span>
<span class="p_add">+			ret = __netdev_adjacent_dev_link(i-&gt;dev, j-&gt;dev, i-&gt;ref_nr);</span>
 			if (ret)
 				goto rollback_mesh;
 		}
<span class="p_chunk">@@ -5430,7 +5438,7 @@</span> <span class="p_context"> static int __netdev_upper_dev_link(struct net_device *dev,</span>
 	list_for_each_entry(i, &amp;upper_dev-&gt;all_adj_list.upper, list) {
 		pr_debug(&quot;linking %s&#39;s upper device %s with %s\n&quot;,
 			 upper_dev-&gt;name, i-&gt;dev-&gt;name, dev-&gt;name);
<span class="p_del">-		ret = __netdev_adjacent_dev_link(dev, i-&gt;dev);</span>
<span class="p_add">+		ret = __netdev_adjacent_dev_link(dev, i-&gt;dev, i-&gt;ref_nr);</span>
 		if (ret)
 			goto rollback_upper_mesh;
 	}
<span class="p_chunk">@@ -5439,7 +5447,7 @@</span> <span class="p_context"> static int __netdev_upper_dev_link(struct net_device *dev,</span>
 	list_for_each_entry(i, &amp;dev-&gt;all_adj_list.lower, list) {
 		pr_debug(&quot;linking %s&#39;s lower device %s with %s\n&quot;, dev-&gt;name,
 			 i-&gt;dev-&gt;name, upper_dev-&gt;name);
<span class="p_del">-		ret = __netdev_adjacent_dev_link(i-&gt;dev, upper_dev);</span>
<span class="p_add">+		ret = __netdev_adjacent_dev_link(i-&gt;dev, upper_dev, i-&gt;ref_nr);</span>
 		if (ret)
 			goto rollback_lower_mesh;
 	}
<span class="p_chunk">@@ -5453,7 +5461,7 @@</span> <span class="p_context"> rollback_lower_mesh:</span>
 	list_for_each_entry(i, &amp;dev-&gt;all_adj_list.lower, list) {
 		if (i == to_i)
 			break;
<span class="p_del">-		__netdev_adjacent_dev_unlink(i-&gt;dev, upper_dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(i-&gt;dev, upper_dev, i-&gt;ref_nr);</span>
 	}
 
 	i = NULL;
<span class="p_chunk">@@ -5463,7 +5471,7 @@</span> <span class="p_context"> rollback_upper_mesh:</span>
 	list_for_each_entry(i, &amp;upper_dev-&gt;all_adj_list.upper, list) {
 		if (i == to_i)
 			break;
<span class="p_del">-		__netdev_adjacent_dev_unlink(dev, i-&gt;dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(dev, i-&gt;dev, i-&gt;ref_nr);</span>
 	}
 
 	i = j = NULL;
<span class="p_chunk">@@ -5475,7 +5483,7 @@</span> <span class="p_context"> rollback_mesh:</span>
 		list_for_each_entry(j, &amp;upper_dev-&gt;all_adj_list.upper, list) {
 			if (i == to_i &amp;&amp; j == to_j)
 				break;
<span class="p_del">-			__netdev_adjacent_dev_unlink(i-&gt;dev, j-&gt;dev);</span>
<span class="p_add">+			__netdev_adjacent_dev_unlink(i-&gt;dev, j-&gt;dev, i-&gt;ref_nr);</span>
 		}
 		if (i == to_i)
 			break;
<span class="p_chunk">@@ -5559,16 +5567,16 @@</span> <span class="p_context"> void netdev_upper_dev_unlink(struct net_device *dev,</span>
 	 */
 	list_for_each_entry(i, &amp;dev-&gt;all_adj_list.lower, list)
 		list_for_each_entry(j, &amp;upper_dev-&gt;all_adj_list.upper, list)
<span class="p_del">-			__netdev_adjacent_dev_unlink(i-&gt;dev, j-&gt;dev);</span>
<span class="p_add">+			__netdev_adjacent_dev_unlink(i-&gt;dev, j-&gt;dev, i-&gt;ref_nr);</span>
 
 	/* remove also the devices itself from lower/upper device
 	 * list
 	 */
 	list_for_each_entry(i, &amp;dev-&gt;all_adj_list.lower, list)
<span class="p_del">-		__netdev_adjacent_dev_unlink(i-&gt;dev, upper_dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(i-&gt;dev, upper_dev, i-&gt;ref_nr);</span>
 
 	list_for_each_entry(i, &amp;upper_dev-&gt;all_adj_list.upper, list)
<span class="p_del">-		__netdev_adjacent_dev_unlink(dev, i-&gt;dev);</span>
<span class="p_add">+		__netdev_adjacent_dev_unlink(dev, i-&gt;dev, i-&gt;ref_nr);</span>
 
 	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER, dev,
 				      &amp;changeupper_info.info);
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index 4da4d51a2ccf..b6327601f979 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -215,8 +215,8 @@</span> <span class="p_context"></span>
 #define M_NETIF_RECEIVE 	1	/* Inject packets into stack */
 
 /* If lock -- protects updating of if_list */
<span class="p_del">-#define   if_lock(t)           spin_lock(&amp;(t-&gt;if_lock));</span>
<span class="p_del">-#define   if_unlock(t)           spin_unlock(&amp;(t-&gt;if_lock));</span>
<span class="p_add">+#define   if_lock(t)           mutex_lock(&amp;(t-&gt;if_lock));</span>
<span class="p_add">+#define   if_unlock(t)           mutex_unlock(&amp;(t-&gt;if_lock));</span>
 
 /* Used to help with determining the pkts on receive */
 #define PKTGEN_MAGIC 0xbe9be955
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> struct pktgen_net {</span>
 };
 
 struct pktgen_thread {
<span class="p_del">-	spinlock_t if_lock;		/* for list of devices */</span>
<span class="p_add">+	struct mutex if_lock;		/* for list of devices */</span>
 	struct list_head if_list;	/* All device here */
 	struct list_head th_list;
 	struct task_struct *tsk;
<span class="p_chunk">@@ -2002,11 +2002,13 @@</span> <span class="p_context"> static void pktgen_change_name(const struct pktgen_net *pn, struct net_device *d</span>
 {
 	struct pktgen_thread *t;
 
<span class="p_add">+	mutex_lock(&amp;pktgen_thread_lock);</span>
<span class="p_add">+</span>
 	list_for_each_entry(t, &amp;pn-&gt;pktgen_threads, th_list) {
 		struct pktgen_dev *pkt_dev;
 
<span class="p_del">-		rcu_read_lock();</span>
<span class="p_del">-		list_for_each_entry_rcu(pkt_dev, &amp;t-&gt;if_list, list) {</span>
<span class="p_add">+		if_lock(t);</span>
<span class="p_add">+		list_for_each_entry(pkt_dev, &amp;t-&gt;if_list, list) {</span>
 			if (pkt_dev-&gt;odev != dev)
 				continue;
 
<span class="p_chunk">@@ -2021,8 +2023,9 @@</span> <span class="p_context"> static void pktgen_change_name(const struct pktgen_net *pn, struct net_device *d</span>
 				       dev-&gt;name);
 			break;
 		}
<span class="p_del">-		rcu_read_unlock();</span>
<span class="p_add">+		if_unlock(t);</span>
 	}
<span class="p_add">+	mutex_unlock(&amp;pktgen_thread_lock);</span>
 }
 
 static int pktgen_device_event(struct notifier_block *unused,
<span class="p_chunk">@@ -2278,7 +2281,7 @@</span> <span class="p_context"> static void spin(struct pktgen_dev *pkt_dev, ktime_t spin_until)</span>
 
 static inline void set_pkt_overhead(struct pktgen_dev *pkt_dev)
 {
<span class="p_del">-	pkt_dev-&gt;pkt_overhead = LL_RESERVED_SPACE(pkt_dev-&gt;odev);</span>
<span class="p_add">+	pkt_dev-&gt;pkt_overhead = 0;</span>
 	pkt_dev-&gt;pkt_overhead += pkt_dev-&gt;nr_labels*sizeof(u32);
 	pkt_dev-&gt;pkt_overhead += VLAN_TAG_SIZE(pkt_dev);
 	pkt_dev-&gt;pkt_overhead += SVLAN_TAG_SIZE(pkt_dev);
<span class="p_chunk">@@ -2769,13 +2772,13 @@</span> <span class="p_context"> static void pktgen_finalize_skb(struct pktgen_dev *pkt_dev, struct sk_buff *skb,</span>
 }
 
 static struct sk_buff *pktgen_alloc_skb(struct net_device *dev,
<span class="p_del">-					struct pktgen_dev *pkt_dev,</span>
<span class="p_del">-					unsigned int extralen)</span>
<span class="p_add">+					struct pktgen_dev *pkt_dev)</span>
 {
<span class="p_add">+	unsigned int extralen = LL_RESERVED_SPACE(dev);</span>
 	struct sk_buff *skb = NULL;
<span class="p_del">-	unsigned int size = pkt_dev-&gt;cur_pkt_size + 64 + extralen +</span>
<span class="p_del">-			    pkt_dev-&gt;pkt_overhead;</span>
<span class="p_add">+	unsigned int size;</span>
 
<span class="p_add">+	size = pkt_dev-&gt;cur_pkt_size + 64 + extralen + pkt_dev-&gt;pkt_overhead;</span>
 	if (pkt_dev-&gt;flags &amp; F_NODE) {
 		int node = pkt_dev-&gt;node &gt;= 0 ? pkt_dev-&gt;node : numa_node_id();
 
<span class="p_chunk">@@ -2788,8 +2791,9 @@</span> <span class="p_context"> static struct sk_buff *pktgen_alloc_skb(struct net_device *dev,</span>
 		 skb = __netdev_alloc_skb(dev, size, GFP_NOWAIT);
 	}
 
<span class="p_add">+	/* the caller pre-fetches from skb-&gt;data and reserves for the mac hdr */</span>
 	if (likely(skb))
<span class="p_del">-		skb_reserve(skb, LL_RESERVED_SPACE(dev));</span>
<span class="p_add">+		skb_reserve(skb, extralen - 16);</span>
 
 	return skb;
 }
<span class="p_chunk">@@ -2822,16 +2826,14 @@</span> <span class="p_context"> static struct sk_buff *fill_packet_ipv4(struct net_device *odev,</span>
 	mod_cur_headers(pkt_dev);
 	queue_map = pkt_dev-&gt;cur_queue_map;
 
<span class="p_del">-	datalen = (odev-&gt;hard_header_len + 16) &amp; ~0xf;</span>
<span class="p_del">-</span>
<span class="p_del">-	skb = pktgen_alloc_skb(odev, pkt_dev, datalen);</span>
<span class="p_add">+	skb = pktgen_alloc_skb(odev, pkt_dev);</span>
 	if (!skb) {
 		sprintf(pkt_dev-&gt;result, &quot;No memory&quot;);
 		return NULL;
 	}
 
 	prefetchw(skb-&gt;data);
<span class="p_del">-	skb_reserve(skb, datalen);</span>
<span class="p_add">+	skb_reserve(skb, 16);</span>
 
 	/*  Reserve for ethernet and IP header  */
 	eth = (__u8 *) skb_push(skb, 14);
<span class="p_chunk">@@ -2951,7 +2953,7 @@</span> <span class="p_context"> static struct sk_buff *fill_packet_ipv6(struct net_device *odev,</span>
 	mod_cur_headers(pkt_dev);
 	queue_map = pkt_dev-&gt;cur_queue_map;
 
<span class="p_del">-	skb = pktgen_alloc_skb(odev, pkt_dev, 16);</span>
<span class="p_add">+	skb = pktgen_alloc_skb(odev, pkt_dev);</span>
 	if (!skb) {
 		sprintf(pkt_dev-&gt;result, &quot;No memory&quot;);
 		return NULL;
<span class="p_chunk">@@ -3727,7 +3729,7 @@</span> <span class="p_context"> static int __net_init pktgen_create_thread(int cpu, struct pktgen_net *pn)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	spin_lock_init(&amp;t-&gt;if_lock);</span>
<span class="p_add">+	mutex_init(&amp;t-&gt;if_lock);</span>
 	t-&gt;cpu = cpu;
 
 	INIT_LIST_HEAD(&amp;t-&gt;if_list);
<span class="p_header">diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c</span>
<span class="p_header">index 9e63f252a89e..de85d4e1cf43 100644</span>
<span class="p_header">--- a/net/ethernet/eth.c</span>
<span class="p_header">+++ b/net/ethernet/eth.c</span>
<span class="p_chunk">@@ -436,7 +436,7 @@</span> <span class="p_context"> struct sk_buff **eth_gro_receive(struct sk_buff **head,</span>
 
 	skb_gro_pull(skb, sizeof(*eh));
 	skb_gro_postpull_rcsum(skb, eh, sizeof(*eh));
<span class="p_del">-	pp = ptype-&gt;callbacks.gro_receive(head, skb);</span>
<span class="p_add">+	pp = call_gro_receive(ptype-&gt;callbacks.gro_receive, head, skb);</span>
 
 out_unlock:
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c</span>
<span class="p_header">index 1a5c1ca3ad3c..afc18e9ca94a 100644</span>
<span class="p_header">--- a/net/ipv4/af_inet.c</span>
<span class="p_header">+++ b/net/ipv4/af_inet.c</span>
<span class="p_chunk">@@ -1372,7 +1372,7 @@</span> <span class="p_context"> static struct sk_buff **inet_gro_receive(struct sk_buff **head,</span>
 	skb_gro_pull(skb, sizeof(*iph));
 	skb_set_transport_header(skb, skb_gro_offset(skb));
 
<span class="p_del">-	pp = ops-&gt;callbacks.gro_receive(head, skb);</span>
<span class="p_add">+	pp = call_gro_receive(ops-&gt;callbacks.gro_receive, head, skb);</span>
 
 out_unlock:
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/ipv4/fou.c b/net/ipv4/fou.c</span>
<span class="p_header">index 08d7de55e57e..08d8ee124538 100644</span>
<span class="p_header">--- a/net/ipv4/fou.c</span>
<span class="p_header">+++ b/net/ipv4/fou.c</span>
<span class="p_chunk">@@ -201,7 +201,7 @@</span> <span class="p_context"> static struct sk_buff **fou_gro_receive(struct sk_buff **head,</span>
 	if (!ops || !ops-&gt;callbacks.gro_receive)
 		goto out_unlock;
 
<span class="p_del">-	pp = ops-&gt;callbacks.gro_receive(head, skb);</span>
<span class="p_add">+	pp = call_gro_receive(ops-&gt;callbacks.gro_receive, head, skb);</span>
 
 out_unlock:
 	rcu_read_unlock();
<span class="p_chunk">@@ -360,7 +360,7 @@</span> <span class="p_context"> static struct sk_buff **gue_gro_receive(struct sk_buff **head,</span>
 	if (WARN_ON_ONCE(!ops || !ops-&gt;callbacks.gro_receive))
 		goto out_unlock;
 
<span class="p_del">-	pp = ops-&gt;callbacks.gro_receive(head, skb);</span>
<span class="p_add">+	pp = call_gro_receive(ops-&gt;callbacks.gro_receive, head, skb);</span>
 
 out_unlock:
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/ipv4/gre_offload.c b/net/ipv4/gre_offload.c</span>
<span class="p_header">index e603004c1af8..79ae0d7becbf 100644</span>
<span class="p_header">--- a/net/ipv4/gre_offload.c</span>
<span class="p_header">+++ b/net/ipv4/gre_offload.c</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> static struct sk_buff **gre_gro_receive(struct sk_buff **head,</span>
 	/* Adjusted NAPI_GRO_CB(skb)-&gt;csum after skb_gro_pull()*/
 	skb_gro_postpull_rcsum(skb, greh, grehlen);
 
<span class="p_del">-	pp = ptype-&gt;callbacks.gro_receive(head, skb);</span>
<span class="p_add">+	pp = call_gro_receive(ptype-&gt;callbacks.gro_receive, head, skb);</span>
 
 out_unlock:
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c</span>
<span class="p_header">index a50124260f5a..9ce202549e7a 100644</span>
<span class="p_header">--- a/net/ipv4/ip_sockglue.c</span>
<span class="p_header">+++ b/net/ipv4/ip_sockglue.c</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> static void ip_cmsg_recv_retopts(struct msghdr *msg, struct sk_buff *skb)</span>
 }
 
 static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,
<span class="p_del">-				  int offset)</span>
<span class="p_add">+				  int tlen, int offset)</span>
 {
 	__wsum csum = skb-&gt;csum;
 
<span class="p_chunk">@@ -106,7 +106,9 @@</span> <span class="p_context"> static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,</span>
 		return;
 
 	if (offset != 0)
<span class="p_del">-		csum = csum_sub(csum, csum_partial(skb-&gt;data, offset, 0));</span>
<span class="p_add">+		csum = csum_sub(csum,</span>
<span class="p_add">+				csum_partial(skb-&gt;data + tlen,</span>
<span class="p_add">+					     offset, 0));</span>
 
 	put_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &amp;csum);
 }
<span class="p_chunk">@@ -152,7 +154,7 @@</span> <span class="p_context"> static void ip_cmsg_recv_dstaddr(struct msghdr *msg, struct sk_buff *skb)</span>
 }
 
 void ip_cmsg_recv_offset(struct msghdr *msg, struct sk_buff *skb,
<span class="p_del">-			 int offset)</span>
<span class="p_add">+			 int tlen, int offset)</span>
 {
 	struct inet_sock *inet = inet_sk(skb-&gt;sk);
 	unsigned int flags = inet-&gt;cmsg_flags;
<span class="p_chunk">@@ -215,7 +217,7 @@</span> <span class="p_context"> void ip_cmsg_recv_offset(struct msghdr *msg, struct sk_buff *skb,</span>
 	}
 
 	if (flags &amp; IP_CMSG_CHECKSUM)
<span class="p_del">-		ip_cmsg_recv_checksum(msg, skb, offset);</span>
<span class="p_add">+		ip_cmsg_recv_checksum(msg, skb, tlen, offset);</span>
 }
 EXPORT_SYMBOL(ip_cmsg_recv_offset);
 
<span class="p_header">diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c</span>
<span class="p_header">index 9d1e555496e3..8e77786549c6 100644</span>
<span class="p_header">--- a/net/ipv4/ipmr.c</span>
<span class="p_header">+++ b/net/ipv4/ipmr.c</span>
<span class="p_chunk">@@ -2192,7 +2192,7 @@</span> <span class="p_context"> static int __ipmr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,</span>
 
 int ipmr_get_route(struct net *net, struct sk_buff *skb,
 		   __be32 saddr, __be32 daddr,
<span class="p_del">-		   struct rtmsg *rtm, int nowait)</span>
<span class="p_add">+		   struct rtmsg *rtm, int nowait, u32 portid)</span>
 {
 	struct mfc_cache *cache;
 	struct mr_table *mrt;
<span class="p_chunk">@@ -2237,6 +2237,7 @@</span> <span class="p_context"> int ipmr_get_route(struct net *net, struct sk_buff *skb,</span>
 			return -ENOMEM;
 		}
 
<span class="p_add">+		NETLINK_CB(skb2).portid = portid;</span>
 		skb_push(skb2, sizeof(struct iphdr));
 		skb_reset_network_header(skb2);
 		iph = ip_hdr(skb2);
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index b050cf980a57..8533a75a9328 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -2492,7 +2492,8 @@</span> <span class="p_context"> static int rt_fill_info(struct net *net,  __be32 dst, __be32 src, u32 table_id,</span>
 		    IPV4_DEVCONF_ALL(net, MC_FORWARDING)) {
 			int err = ipmr_get_route(net, skb,
 						 fl4-&gt;saddr, fl4-&gt;daddr,
<span class="p_del">-						 r, nowait);</span>
<span class="p_add">+						 r, nowait, portid);</span>
<span class="p_add">+</span>
 			if (err &lt;= 0) {
 				if (!nowait) {
 					if (err == 0)
<span class="p_header">diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c</span>
<span class="p_header">index a0bd7a55193e..70fb352e317f 100644</span>
<span class="p_header">--- a/net/ipv4/sysctl_net_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/sysctl_net_ipv4.c</span>
<span class="p_chunk">@@ -97,11 +97,11 @@</span> <span class="p_context"> static void inet_get_ping_group_range_table(struct ctl_table *table, kgid_t *low</span>
 		container_of(table-&gt;data, struct net, ipv4.ping_group_range.range);
 	unsigned int seq;
 	do {
<span class="p_del">-		seq = read_seqbegin(&amp;net-&gt;ipv4.ip_local_ports.lock);</span>
<span class="p_add">+		seq = read_seqbegin(&amp;net-&gt;ipv4.ping_group_range.lock);</span>
 
 		*low = data[0];
 		*high = data[1];
<span class="p_del">-	} while (read_seqretry(&amp;net-&gt;ipv4.ip_local_ports.lock, seq));</span>
<span class="p_add">+	} while (read_seqretry(&amp;net-&gt;ipv4.ping_group_range.lock, seq));</span>
 }
 
 /* Update system visible IP port range */
<span class="p_chunk">@@ -110,10 +110,10 @@</span> <span class="p_context"> static void set_ping_group_range(struct ctl_table *table, kgid_t low, kgid_t hig</span>
 	kgid_t *data = table-&gt;data;
 	struct net *net =
 		container_of(table-&gt;data, struct net, ipv4.ping_group_range.range);
<span class="p_del">-	write_seqlock(&amp;net-&gt;ipv4.ip_local_ports.lock);</span>
<span class="p_add">+	write_seqlock(&amp;net-&gt;ipv4.ping_group_range.lock);</span>
 	data[0] = low;
 	data[1] = high;
<span class="p_del">-	write_sequnlock(&amp;net-&gt;ipv4.ip_local_ports.lock);</span>
<span class="p_add">+	write_sequnlock(&amp;net-&gt;ipv4.ping_group_range.lock);</span>
 }
 
 /* Validate changes from /proc interface. */
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 12b98e257c5f..7cc0f8aac28f 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -2324,10 +2324,9 @@</span> <span class="p_context"> static void DBGUNDO(struct sock *sk, const char *msg)</span>
 	}
 #if IS_ENABLED(CONFIG_IPV6)
 	else if (sk-&gt;sk_family == AF_INET6) {
<span class="p_del">-		struct ipv6_pinfo *np = inet6_sk(sk);</span>
 		pr_debug(&quot;Undo %s %pI6/%u c%u l%u ss%u/%u p%u\n&quot;,
 			 msg,
<span class="p_del">-			 &amp;np-&gt;daddr, ntohs(inet-&gt;inet_dport),</span>
<span class="p_add">+			 &amp;sk-&gt;sk_v6_daddr, ntohs(inet-&gt;inet_dport),</span>
 			 tp-&gt;snd_cwnd, tcp_left_out(tp),
 			 tp-&gt;snd_ssthresh, tp-&gt;prior_ssthresh,
 			 tp-&gt;packets_out);
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 660c967ba84a..0795647e94c6 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -1950,12 +1950,14 @@</span> <span class="p_context"> static int tcp_mtu_probe(struct sock *sk)</span>
 	len = 0;
 	tcp_for_write_queue_from_safe(skb, next, sk) {
 		copy = min_t(int, skb-&gt;len, probe_size - len);
<span class="p_del">-		if (nskb-&gt;ip_summed)</span>
<span class="p_add">+		if (nskb-&gt;ip_summed) {</span>
 			skb_copy_bits(skb, 0, skb_put(nskb, copy), copy);
<span class="p_del">-		else</span>
<span class="p_del">-			nskb-&gt;csum = skb_copy_and_csum_bits(skb, 0,</span>
<span class="p_del">-							    skb_put(nskb, copy),</span>
<span class="p_del">-							    copy, nskb-&gt;csum);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			__wsum csum = skb_copy_and_csum_bits(skb, 0,</span>
<span class="p_add">+							     skb_put(nskb, copy),</span>
<span class="p_add">+							     copy, 0);</span>
<span class="p_add">+			nskb-&gt;csum = csum_block_add(nskb-&gt;csum, csum, len);</span>
<span class="p_add">+		}</span>
 
 		if (skb-&gt;len &lt;= copy) {
 			/* We&#39;ve eaten all the data from this skb.
<span class="p_chunk">@@ -2569,7 +2571,8 @@</span> <span class="p_context"> int __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb)</span>
 	 * copying overhead: fragmentation, tunneling, mangling etc.
 	 */
 	if (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &gt;
<span class="p_del">-	    min(sk-&gt;sk_wmem_queued + (sk-&gt;sk_wmem_queued &gt;&gt; 2), sk-&gt;sk_sndbuf))</span>
<span class="p_add">+	    min_t(u32, sk-&gt;sk_wmem_queued + (sk-&gt;sk_wmem_queued &gt;&gt; 2),</span>
<span class="p_add">+		  sk-&gt;sk_sndbuf))</span>
 		return -EAGAIN;
 
 	if (skb_still_in_host_queue(sk, skb))
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 0b1ea5abcc04..e9513e397c4f 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> try_again:</span>
 		*addr_len = sizeof(*sin);
 	}
 	if (inet-&gt;cmsg_flags)
<span class="p_del">-		ip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr));</span>
<span class="p_add">+		ip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr), off);</span>
 
 	err = copied;
 	if (flags &amp; MSG_TRUNC)
<span class="p_header">diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c</span>
<span class="p_header">index 0e36e56dfd22..6396f1c80ae9 100644</span>
<span class="p_header">--- a/net/ipv4/udp_offload.c</span>
<span class="p_header">+++ b/net/ipv4/udp_offload.c</span>
<span class="p_chunk">@@ -339,8 +339,8 @@</span> <span class="p_context"> unflush:</span>
 	skb_gro_pull(skb, sizeof(struct udphdr)); /* pull encapsulating udp header */
 	skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));
 	NAPI_GRO_CB(skb)-&gt;proto = uo_priv-&gt;offload-&gt;ipproto;
<span class="p_del">-	pp = uo_priv-&gt;offload-&gt;callbacks.gro_receive(head, skb,</span>
<span class="p_del">-						     uo_priv-&gt;offload);</span>
<span class="p_add">+	pp = call_gro_receive_udp(uo_priv-&gt;offload-&gt;callbacks.gro_receive,</span>
<span class="p_add">+				  head, skb, uo_priv-&gt;offload);</span>
 
 out_unlock:
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 036b39eb1220..cb8bb5988c03 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -2916,7 +2916,7 @@</span> <span class="p_context"> static void init_loopback(struct net_device *dev)</span>
 				 * lo device down, release this obsolete dst and
 				 * reallocate a new router for ifa.
 				 */
<span class="p_del">-				if (sp_ifa-&gt;rt-&gt;dst.obsolete &gt; 0) {</span>
<span class="p_add">+				if (!atomic_read(&amp;sp_ifa-&gt;rt-&gt;rt6i_ref)) {</span>
 					ip6_rt_put(sp_ifa-&gt;rt);
 					sp_ifa-&gt;rt = NULL;
 				} else {
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index 4650c6824783..17430f341073 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -886,7 +886,6 @@</span> <span class="p_context"> static int ip6gre_xmit_other(struct sk_buff *skb, struct net_device *dev)</span>
 		encap_limit = t-&gt;parms.encap_limit;
 
 	memcpy(&amp;fl6, &amp;t-&gt;fl.u.ip6, sizeof(fl6));
<span class="p_del">-	fl6.flowi6_proto = skb-&gt;protocol;</span>
 
 	err = ip6gre_xmit2(skb, dev, 0, &amp;fl6, encap_limit, &amp;mtu);
 
<span class="p_header">diff --git a/net/ipv6/ip6_offload.c b/net/ipv6/ip6_offload.c</span>
<span class="p_header">index 82e9f3076028..efe6268b8bc3 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_offload.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_offload.c</span>
<span class="p_chunk">@@ -247,7 +247,7 @@</span> <span class="p_context"> static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,</span>
 
 	skb_gro_postpull_rcsum(skb, iph, nlen);
 
<span class="p_del">-	pp = ops-&gt;callbacks.gro_receive(head, skb);</span>
<span class="p_add">+	pp = call_gro_receive(ops-&gt;callbacks.gro_receive, head, skb);</span>
 
 out_unlock:
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index 3991b21e24ad..e8878886eba4 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -246,6 +246,7 @@</span> <span class="p_context"> ip6_tnl_lookup(struct net *net, const struct in6_addr *remote, const struct in6_</span>
 	hash = HASH(&amp;any, local);
 	for_each_ip6_tunnel_rcu(ip6n-&gt;tnls_r_l[hash]) {
 		if (ipv6_addr_equal(local, &amp;t-&gt;parms.laddr) &amp;&amp;
<span class="p_add">+		    ipv6_addr_any(&amp;t-&gt;parms.raddr) &amp;&amp;</span>
 		    (t-&gt;dev-&gt;flags &amp; IFF_UP))
 			return t;
 	}
<span class="p_chunk">@@ -253,6 +254,7 @@</span> <span class="p_context"> ip6_tnl_lookup(struct net *net, const struct in6_addr *remote, const struct in6_</span>
 	hash = HASH(remote, &amp;any);
 	for_each_ip6_tunnel_rcu(ip6n-&gt;tnls_r_l[hash]) {
 		if (ipv6_addr_equal(remote, &amp;t-&gt;parms.raddr) &amp;&amp;
<span class="p_add">+		    ipv6_addr_any(&amp;t-&gt;parms.laddr) &amp;&amp;</span>
 		    (t-&gt;dev-&gt;flags &amp; IFF_UP))
 			return t;
 	}
<span class="p_header">diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c</span>
<span class="p_header">index e207cb2468da..d9843e5a667f 100644</span>
<span class="p_header">--- a/net/ipv6/ip6mr.c</span>
<span class="p_header">+++ b/net/ipv6/ip6mr.c</span>
<span class="p_chunk">@@ -2276,8 +2276,8 @@</span> <span class="p_context"> static int __ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,</span>
 	return 1;
 }
 
<span class="p_del">-int ip6mr_get_route(struct net *net,</span>
<span class="p_del">-		    struct sk_buff *skb, struct rtmsg *rtm, int nowait)</span>
<span class="p_add">+int ip6mr_get_route(struct net *net, struct sk_buff *skb, struct rtmsg *rtm,</span>
<span class="p_add">+		    int nowait, u32 portid)</span>
 {
 	int err;
 	struct mr6_table *mrt;
<span class="p_chunk">@@ -2322,6 +2322,7 @@</span> <span class="p_context"> int ip6mr_get_route(struct net *net,</span>
 			return -ENOMEM;
 		}
 
<span class="p_add">+		NETLINK_CB(skb2).portid = portid;</span>
 		skb_reset_transport_header(skb2);
 
 		skb_put(skb2, sizeof(struct ipv6hdr));
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 5af2cca0a46d..dbffc9de184b 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -3140,7 +3140,9 @@</span> <span class="p_context"> static int rt6_fill_node(struct net *net,</span>
 	if (iif) {
 #ifdef CONFIG_IPV6_MROUTE
 		if (ipv6_addr_is_multicast(&amp;rt-&gt;rt6i_dst.addr)) {
<span class="p_del">-			int err = ip6mr_get_route(net, skb, rtm, nowait);</span>
<span class="p_add">+			int err = ip6mr_get_route(net, skb, rtm, nowait,</span>
<span class="p_add">+						  portid);</span>
<span class="p_add">+</span>
 			if (err &lt;= 0) {
 				if (!nowait) {
 					if (err == 0)
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 2d81e2f33ef2..fbd521fdae53 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -1179,6 +1179,16 @@</span> <span class="p_context"> out:</span>
 	return NULL;
 }
 
<span class="p_add">+static void tcp_v6_restore_cb(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* We need to move header back to the beginning if xfrm6_policy_check()</span>
<span class="p_add">+	 * and tcp_v6_fill_cb() are going to be called again.</span>
<span class="p_add">+	 * ip6_datagram_recv_specific_ctl() also expects IP6CB to be there.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memmove(IP6CB(skb), &amp;TCP_SKB_CB(skb)-&gt;header.h6,</span>
<span class="p_add">+		sizeof(struct inet6_skb_parm));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* The socket must have it&#39;s spinlock held when we get
  * here, unless it is a TCP_LISTEN socket.
  *
<span class="p_chunk">@@ -1308,6 +1318,7 @@</span> <span class="p_context"> ipv6_pktoptions:</span>
 			np-&gt;flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));
 		if (ipv6_opt_accepted(sk, opt_skb, &amp;TCP_SKB_CB(opt_skb)-&gt;header.h6)) {
 			skb_set_owner_r(opt_skb, sk);
<span class="p_add">+			tcp_v6_restore_cb(opt_skb);</span>
 			opt_skb = xchg(&amp;np-&gt;pktoptions, opt_skb);
 		} else {
 			__kfree_skb(opt_skb);
<span class="p_chunk">@@ -1341,15 +1352,6 @@</span> <span class="p_context"> static void tcp_v6_fill_cb(struct sk_buff *skb, const struct ipv6hdr *hdr,</span>
 	TCP_SKB_CB(skb)-&gt;sacked = 0;
 }
 
<span class="p_del">-static void tcp_v6_restore_cb(struct sk_buff *skb)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* We need to move header back to the beginning if xfrm6_policy_check()</span>
<span class="p_del">-	 * and tcp_v6_fill_cb() are going to be called again.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	memmove(IP6CB(skb), &amp;TCP_SKB_CB(skb)-&gt;header.h6,</span>
<span class="p_del">-		sizeof(struct inet6_skb_parm));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int tcp_v6_rcv(struct sk_buff *skb)
 {
 	const struct tcphdr *th;
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index e6092bd72ee2..dfa85e7264df 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -498,7 +498,8 @@</span> <span class="p_context"> try_again:</span>
 
 	if (is_udp4) {
 		if (inet-&gt;cmsg_flags)
<span class="p_del">-			ip_cmsg_recv(msg, skb);</span>
<span class="p_add">+			ip_cmsg_recv_offset(msg, skb,</span>
<span class="p_add">+					    sizeof(struct udphdr), off);</span>
 	} else {
 		if (np-&gt;rxopt.all)
 			ip6_datagram_recv_specific_ctl(sk, msg, skb);
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 7a5fa0c98377..28fc283c1ec1 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2557,7 +2557,7 @@</span> <span class="p_context"> static int netlink_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,</span>
 	/* Record the max length of recvmsg() calls for future allocations */
 	nlk-&gt;max_recvmsg_len = max(nlk-&gt;max_recvmsg_len, len);
 	nlk-&gt;max_recvmsg_len = min_t(size_t, nlk-&gt;max_recvmsg_len,
<span class="p_del">-				     16384);</span>
<span class="p_add">+				     SKB_WITH_OVERHEAD(32768));</span>
 
 	copied = data_skb-&gt;len;
 	if (len &lt; copied) {
<span class="p_chunk">@@ -2810,14 +2810,13 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 	if (alloc_min_size &lt; nlk-&gt;max_recvmsg_len) {
 		alloc_size = nlk-&gt;max_recvmsg_len;
 		skb = netlink_alloc_skb(sk, alloc_size, nlk-&gt;portid,
<span class="p_del">-					GFP_KERNEL |</span>
<span class="p_del">-					__GFP_NOWARN |</span>
<span class="p_del">-					__GFP_NORETRY);</span>
<span class="p_add">+					(GFP_KERNEL &amp; ~__GFP_DIRECT_RECLAIM) |</span>
<span class="p_add">+					__GFP_NOWARN | __GFP_NORETRY);</span>
 	}
 	if (!skb) {
 		alloc_size = alloc_min_size;
 		skb = netlink_alloc_skb(sk, alloc_size, nlk-&gt;portid,
<span class="p_del">-					GFP_KERNEL);</span>
<span class="p_add">+					(GFP_KERNEL &amp; ~__GFP_DIRECT_RECLAIM));</span>
 	}
 	if (!skb)
 		goto errout_skb;
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index a86f26d05bc2..34e4fcfd240b 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -249,7 +249,7 @@</span> <span class="p_context"> static void __fanout_link(struct sock *sk, struct packet_sock *po);</span>
 static int packet_direct_xmit(struct sk_buff *skb)
 {
 	struct net_device *dev = skb-&gt;dev;
<span class="p_del">-	netdev_features_t features;</span>
<span class="p_add">+	struct sk_buff *orig_skb = skb;</span>
 	struct netdev_queue *txq;
 	int ret = NETDEV_TX_BUSY;
 
<span class="p_chunk">@@ -257,9 +257,8 @@</span> <span class="p_context"> static int packet_direct_xmit(struct sk_buff *skb)</span>
 		     !netif_carrier_ok(dev)))
 		goto drop;
 
<span class="p_del">-	features = netif_skb_features(skb);</span>
<span class="p_del">-	if (skb_needs_linearize(skb, features) &amp;&amp;</span>
<span class="p_del">-	    __skb_linearize(skb))</span>
<span class="p_add">+	skb = validate_xmit_skb_list(skb, dev);</span>
<span class="p_add">+	if (skb != orig_skb)</span>
 		goto drop;
 
 	txq = skb_get_tx_queue(dev, skb);
<span class="p_chunk">@@ -279,7 +278,7 @@</span> <span class="p_context"> static int packet_direct_xmit(struct sk_buff *skb)</span>
 	return ret;
 drop:
 	atomic_long_inc(&amp;dev-&gt;tx_dropped);
<span class="p_del">-	kfree_skb(skb);</span>
<span class="p_add">+	kfree_skb_list(skb);</span>
 	return NET_XMIT_DROP;
 }
 
<span class="p_chunk">@@ -3855,6 +3854,7 @@</span> <span class="p_context"> static int packet_notifier(struct notifier_block *this,</span>
 				}
 				if (msg == NETDEV_UNREGISTER) {
 					packet_cached_dev_reset(po);
<span class="p_add">+					fanout_release(sk);</span>
 					po-&gt;ifindex = -1;
 					if (po-&gt;prot_hook.dev)
 						dev_put(po-&gt;prot_hook.dev);
<span class="p_header">diff --git a/net/sched/act_vlan.c b/net/sched/act_vlan.c</span>
<span class="p_header">index 796785e0bf96..d7edba4536bd 100644</span>
<span class="p_header">--- a/net/sched/act_vlan.c</span>
<span class="p_header">+++ b/net/sched/act_vlan.c</span>
<span class="p_chunk">@@ -33,6 +33,12 @@</span> <span class="p_context"> static int tcf_vlan(struct sk_buff *skb, const struct tc_action *a,</span>
 	bstats_update(&amp;v-&gt;tcf_bstats, skb);
 	action = v-&gt;tcf_action;
 
<span class="p_add">+	/* Ensure &#39;data&#39; points at mac_header prior calling vlan manipulating</span>
<span class="p_add">+	 * functions.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (skb_at_tc_ingress(skb))</span>
<span class="p_add">+		skb_push_rcsum(skb, skb-&gt;mac_len);</span>
<span class="p_add">+</span>
 	switch (v-&gt;tcfv_action) {
 	case TCA_VLAN_ACT_POP:
 		err = skb_vlan_pop(skb);
<span class="p_chunk">@@ -54,6 +60,9 @@</span> <span class="p_context"> drop:</span>
 	action = TC_ACT_SHOT;
 	v-&gt;tcf_qstats.drops++;
 unlock:
<span class="p_add">+	if (skb_at_tc_ingress(skb))</span>
<span class="p_add">+		skb_pull_rcsum(skb, skb-&gt;mac_len);</span>
<span class="p_add">+</span>
 	spin_unlock(&amp;v-&gt;tcf_lock);
 	return action;
 }
<span class="p_header">diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c</span>
<span class="p_header">index a75864d93142..ecc1904e454f 100644</span>
<span class="p_header">--- a/net/sched/cls_api.c</span>
<span class="p_header">+++ b/net/sched/cls_api.c</span>
<span class="p_chunk">@@ -315,7 +315,8 @@</span> <span class="p_context"> replay:</span>
 			if (err == 0) {
 				struct tcf_proto *next = rtnl_dereference(tp-&gt;next);
 
<span class="p_del">-				tfilter_notify(net, skb, n, tp, fh, RTM_DELTFILTER);</span>
<span class="p_add">+				tfilter_notify(net, skb, n, tp,</span>
<span class="p_add">+					       t-&gt;tcm_handle, RTM_DELTFILTER);</span>
 				if (tcf_destroy(tp, false))
 					RCU_INIT_POINTER(*back, next);
 			}
<span class="p_header">diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c</span>
<span class="p_header">index 22c2bf367d7e..29c7c43de108 100644</span>
<span class="p_header">--- a/net/sctp/sm_statefuns.c</span>
<span class="p_header">+++ b/net/sctp/sm_statefuns.c</span>
<span class="p_chunk">@@ -3426,6 +3426,12 @@</span> <span class="p_context"> sctp_disposition_t sctp_sf_ootb(struct net *net,</span>
 			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
 						  commands);
 
<span class="p_add">+		/* Report violation if chunk len overflows */</span>
<span class="p_add">+		ch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch-&gt;length));</span>
<span class="p_add">+		if (ch_end &gt; skb_tail_pointer(skb))</span>
<span class="p_add">+			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,</span>
<span class="p_add">+						  commands);</span>
<span class="p_add">+</span>
 		/* Now that we know we at least have a chunk header,
 		 * do things that are type appropriate.
 		 */
<span class="p_chunk">@@ -3457,12 +3463,6 @@</span> <span class="p_context"> sctp_disposition_t sctp_sf_ootb(struct net *net,</span>
 			}
 		}
 
<span class="p_del">-		/* Report violation if chunk len overflows */</span>
<span class="p_del">-		ch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch-&gt;length));</span>
<span class="p_del">-		if (ch_end &gt; skb_tail_pointer(skb))</span>
<span class="p_del">-			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,</span>
<span class="p_del">-						  commands);</span>
<span class="p_del">-</span>
 		ch = (sctp_chunkhdr_t *) ch_end;
 	} while (ch_end &lt; skb_tail_pointer(skb));
 
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index be1489fc3234..402817be3873 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -4371,7 +4371,7 @@</span> <span class="p_context"> static int sctp_getsockopt_disable_fragments(struct sock *sk, int len,</span>
 static int sctp_getsockopt_events(struct sock *sk, int len, char __user *optval,
 				  int __user *optlen)
 {
<span class="p_del">-	if (len &lt;= 0)</span>
<span class="p_add">+	if (len == 0)</span>
 		return -EINVAL;
 	if (len &gt; sizeof(struct sctp_event_subscribe))
 		len = sizeof(struct sctp_event_subscribe);
<span class="p_chunk">@@ -5972,6 +5972,9 @@</span> <span class="p_context"> static int sctp_getsockopt(struct sock *sk, int level, int optname,</span>
 	if (get_user(len, optlen))
 		return -EFAULT;
 
<span class="p_add">+	if (len &lt; 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	lock_sock(sk);
 
 	switch (optname) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



