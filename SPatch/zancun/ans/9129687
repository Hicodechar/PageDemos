
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v6,02/12] mm: migrate: support non-lru movable page migration - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v6,02/12] mm: migrate: support non-lru movable page migration</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=36811">Minchan Kim</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 20, 2016, 2:23 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1463754225-31311-3-git-send-email-minchan@kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9129687/mbox/"
   >mbox</a>
|
   <a href="/patch/9129687/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9129687/">/patch/9129687/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	84A686048B for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 May 2016 14:24:25 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7247521BED
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 May 2016 14:24:25 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 66C2927B90; Fri, 20 May 2016 14:24:25 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 85E4427BF0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 May 2016 14:24:23 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755526AbcETOYL (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 20 May 2016 10:24:11 -0400
Received: from LGEAMRELO13.lge.com ([156.147.23.53]:47046 &quot;EHLO
	lgeamrelo13.lge.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755167AbcETOYH (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 20 May 2016 10:24:07 -0400
Received: from unknown (HELO lgeamrelo02.lge.com) (156.147.1.126)
	by 156.147.23.53 with ESMTP; 20 May 2016 23:24:04 +0900
X-Original-SENDERIP: 156.147.1.126
X-Original-MAILFROM: minchan@kernel.org
Received: from unknown (HELO localhost.localdomain) (10.177.223.161)
	by 156.147.1.126 with ESMTP; 20 May 2016 23:24:04 +0900
X-Original-SENDERIP: 10.177.223.161
X-Original-MAILFROM: minchan@kernel.org
From: Minchan Kim &lt;minchan@kernel.org&gt;
To: Andrew Morton &lt;akpm@linux-foundation.org&gt;
Cc: linux-mm@kvack.org, linux-kernel@vger.kernel.org,
	Minchan Kim &lt;minchan@kernel.org&gt;, Rik van Riel &lt;riel@redhat.com&gt;,
	Vlastimil Babka &lt;vbabka@suse.cz&gt;, Joonsoo Kim &lt;iamjoonsoo.kim@lge.com&gt;,
	Mel Gorman &lt;mgorman@suse.de&gt;, Hugh Dickins &lt;hughd@google.com&gt;,
	Rafael Aquini &lt;aquini@redhat.com&gt;,
	virtualization@lists.linux-foundation.org,
	Jonathan Corbet &lt;corbet@lwn.net&gt;,
	John Einar Reitan &lt;john.reitan@foss.arm.com&gt;,
	dri-devel@lists.freedesktop.org,
	Sergey Senozhatsky &lt;sergey.senozhatsky@gmail.com&gt;,
	Gioh Kim &lt;gi-oh.kim@profitbricks.com&gt;
Subject: [PATCH v6 02/12] mm: migrate: support non-lru movable page migration
Date: Fri, 20 May 2016 23:23:35 +0900
Message-Id: &lt;1463754225-31311-3-git-send-email-minchan@kernel.org&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1463754225-31311-1-git-send-email-minchan@kernel.org&gt;
References: &lt;1463754225-31311-1-git-send-email-minchan@kernel.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=36811">Minchan Kim</a> - May 20, 2016, 2:23 p.m.</div>
<pre class="content">
We have allowed migration for only LRU pages until now and it was
enough to make high-order pages. But recently, embedded system(e.g.,
webOS, android) uses lots of non-movable pages(e.g., zram, GPU memory)
so we have seen several reports about troubles of small high-order
allocation. For fixing the problem, there were several efforts
(e,g,. enhance compaction algorithm, SLUB fallback to 0-order page,
reserved memory, vmalloc and so on) but if there are lots of
non-movable pages in system, their solutions are void in the long run.

So, this patch is to support facility to change non-movable pages
with movable. For the feature, this patch introduces functions related
to migration to address_space_operations as well as some page flags.

If a driver want to make own pages movable, it should define three functions
which are function pointers of struct address_space_operations.

1. bool (*isolate_page) (struct page *page, isolate_mode_t mode);

What VM expects on isolate_page function of driver is to return *true*
if driver isolates page successfully. On returing true, VM marks the page
as PG_isolated so concurrent isolation in several CPUs skip the page
for isolation. If a driver cannot isolate the page, it should return *false*.

Once page is successfully isolated, VM uses page.lru fields so driver
shouldn&#39;t expect to preserve values in that fields.

2. int (*migratepage) (struct address_space *mapping,
		struct page *newpage, struct page *oldpage, enum migrate_mode);

After isolation, VM calls migratepage of driver with isolated page.
The function of migratepage is to move content of the old page to new page
and set up fields of struct page newpage. Keep in mind that you should
clear PG_movable of oldpage via __ClearPageMovable under page_lock if you
migrated the oldpage successfully and returns 0.
If driver cannot migrate the page at the moment, driver can return -EAGAIN.
On -EAGAIN, VM will retry page migration in a short time because VM interprets
-EAGAIN as &quot;temporal migration failure&quot;. On returning any error except -EAGAIN,
VM will give up the page migration without retrying in this time.

Driver shouldn&#39;t touch page.lru field VM using in the functions.

3. void (*putback_page)(struct page *);

If migration fails on isolated page, VM should return the isolated page
to the driver so VM calls driver&#39;s putback_page with migration failed page.
In this function, driver should put the isolated page back to the own data
structure.

4. non-lru movable page flags

There are two page flags for supporting non-lru movable page.

* PG_movable

Driver should use the below function to make page movable under page_lock.

	void __SetPageMovable(struct page *page, struct address_space *mapping)

It needs argument of address_space for registering migration family functions
which will be called by VM. Exactly speaking, PG_movable is not a real flag of
struct page. Rather than, VM reuses page-&gt;mapping&#39;s lower bits to represent it.

	#define PAGE_MAPPING_MOVABLE 0x2
	page-&gt;mapping = page-&gt;mapping | PAGE_MAPPING_MOVABLE;

so driver shouldn&#39;t access page-&gt;mapping directly. Instead, driver should
use page_mapping which mask off the low two bits of page-&gt;mapping so it can get
right struct address_space.

For testing of non-lru movable page, VM supports __PageMovable function.
However, it doesn&#39;t guarantee to identify non-lru movable page because
page-&gt;mapping field is unified with other variables in struct page.
As well, if driver releases the page after isolation by VM, page-&gt;mapping
doesn&#39;t have stable value although it has PAGE_MAPPING_MOVABLE
(Look at __ClearPageMovable). But __PageMovable is cheap to catch whether
page is LRU or non-lru movable once the page has been isolated. Because
LRU pages never can have PAGE_MAPPING_MOVABLE in page-&gt;mapping. It is also
good for just peeking to test non-lru movable pages before more expensive
checking with lock_page in pfn scanning to select victim.

For guaranteeing non-lru movable page, VM provides PageMovable function.
Unlike __PageMovable, PageMovable functions validates page-&gt;mapping and
mapping-&gt;a_ops-&gt;isolate_page under lock_page. The lock_page prevents sudden
destroying of page-&gt;mapping.

Driver using __SetPageMovable should clear the flag via __ClearMovablePage
under page_lock before the releasing the page.

* PG_isolated

To prevent concurrent isolation among several CPUs, VM marks isolated page
as PG_isolated under lock_page. So if a CPU encounters PG_isolated non-lru
movable page, it can skip it. Driver doesn&#39;t need to manipulate the flag
because VM will set/clear it automatically. Keep in mind that if driver
sees PG_isolated page, it means the page have been isolated by VM so it
shouldn&#39;t touch page.lru field.
PG_isolated is alias with PG_reclaim flag so driver shouldn&#39;t use the flag
for own purpose.

Cc: Rik van Riel &lt;riel@redhat.com&gt;
Cc: Vlastimil Babka &lt;vbabka@suse.cz&gt;
Cc: Joonsoo Kim &lt;iamjoonsoo.kim@lge.com&gt;
Cc: Mel Gorman &lt;mgorman@suse.de&gt;
Cc: Hugh Dickins &lt;hughd@google.com&gt;
Cc: Rafael Aquini &lt;aquini@redhat.com&gt;
Cc: virtualization@lists.linux-foundation.org
Cc: Jonathan Corbet &lt;corbet@lwn.net&gt;
Cc: John Einar Reitan &lt;john.reitan@foss.arm.com&gt;
Cc: dri-devel@lists.freedesktop.org
Cc: Sergey Senozhatsky &lt;sergey.senozhatsky@gmail.com&gt;
<span class="signed-off-by">Signed-off-by: Gioh Kim &lt;gi-oh.kim@profitbricks.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Minchan Kim &lt;minchan@kernel.org&gt;</span>
---
 Documentation/filesystems/Locking |   4 +
 Documentation/filesystems/vfs.txt |  11 +++
 Documentation/vm/page_migration   | 107 ++++++++++++++++++++-
 include/linux/compaction.h        |  17 ++++
 include/linux/fs.h                |   2 +
 include/linux/ksm.h               |   3 +-
 include/linux/migrate.h           |   2 +
 include/linux/mm.h                |   1 +
 include/linux/page-flags.h        |  33 +++++--
 mm/compaction.c                   |  82 ++++++++++++----
 mm/ksm.c                          |   4 +-
 mm/migrate.c                      | 191 ++++++++++++++++++++++++++++++++++----
 mm/page_alloc.c                   |   2 +-
 mm/util.c                         |   6 +-
 14 files changed, 411 insertions(+), 54 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=72672">Vlastimil Babka</a> - May 27, 2016, 2:26 p.m.</div>
<pre class="content">
On 05/20/2016 04:23 PM, Minchan Kim wrote:
<span class="quote">&gt; We have allowed migration for only LRU pages until now and it was</span>
<span class="quote">&gt; enough to make high-order pages. But recently, embedded system(e.g.,</span>
<span class="quote">&gt; webOS, android) uses lots of non-movable pages(e.g., zram, GPU memory)</span>
<span class="quote">&gt; so we have seen several reports about troubles of small high-order</span>
<span class="quote">&gt; allocation. For fixing the problem, there were several efforts</span>
<span class="quote">&gt; (e,g,. enhance compaction algorithm, SLUB fallback to 0-order page,</span>
<span class="quote">&gt; reserved memory, vmalloc and so on) but if there are lots of</span>
<span class="quote">&gt; non-movable pages in system, their solutions are void in the long run.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; So, this patch is to support facility to change non-movable pages</span>
<span class="quote">&gt; with movable. For the feature, this patch introduces functions related</span>
<span class="quote">&gt; to migration to address_space_operations as well as some page flags.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If a driver want to make own pages movable, it should define three functions</span>
<span class="quote">&gt; which are function pointers of struct address_space_operations.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 1. bool (*isolate_page) (struct page *page, isolate_mode_t mode);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; What VM expects on isolate_page function of driver is to return *true*</span>
<span class="quote">&gt; if driver isolates page successfully. On returing true, VM marks the page</span>
<span class="quote">&gt; as PG_isolated so concurrent isolation in several CPUs skip the page</span>
<span class="quote">&gt; for isolation. If a driver cannot isolate the page, it should return *false*.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Once page is successfully isolated, VM uses page.lru fields so driver</span>
<span class="quote">&gt; shouldn&#39;t expect to preserve values in that fields.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 2. int (*migratepage) (struct address_space *mapping,</span>
<span class="quote">&gt; 		struct page *newpage, struct page *oldpage, enum migrate_mode);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; After isolation, VM calls migratepage of driver with isolated page.</span>
<span class="quote">&gt; The function of migratepage is to move content of the old page to new page</span>
<span class="quote">&gt; and set up fields of struct page newpage. Keep in mind that you should</span>
<span class="quote">&gt; clear PG_movable of oldpage via __ClearPageMovable under page_lock if you</span>
<span class="quote">&gt; migrated the oldpage successfully and returns 0.</span>
<span class="quote">&gt; If driver cannot migrate the page at the moment, driver can return -EAGAIN.</span>
<span class="quote">&gt; On -EAGAIN, VM will retry page migration in a short time because VM interprets</span>
<span class="quote">&gt; -EAGAIN as &quot;temporal migration failure&quot;. On returning any error except -EAGAIN,</span>
<span class="quote">&gt; VM will give up the page migration without retrying in this time.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Driver shouldn&#39;t touch page.lru field VM using in the functions.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 3. void (*putback_page)(struct page *);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If migration fails on isolated page, VM should return the isolated page</span>
<span class="quote">&gt; to the driver so VM calls driver&#39;s putback_page with migration failed page.</span>
<span class="quote">&gt; In this function, driver should put the isolated page back to the own data</span>
<span class="quote">&gt; structure.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 4. non-lru movable page flags</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; There are two page flags for supporting non-lru movable page.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; * PG_movable</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Driver should use the below function to make page movable under page_lock.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 	void __SetPageMovable(struct page *page, struct address_space *mapping)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; It needs argument of address_space for registering migration family functions</span>
<span class="quote">&gt; which will be called by VM. Exactly speaking, PG_movable is not a real flag of</span>
<span class="quote">&gt; struct page. Rather than, VM reuses page-&gt;mapping&#39;s lower bits to represent it.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 	#define PAGE_MAPPING_MOVABLE 0x2</span>
<span class="quote">&gt; 	page-&gt;mapping = page-&gt;mapping | PAGE_MAPPING_MOVABLE;</span>

Interesting, let&#39;s see how that works out...

Overal this looks much better than the last version I checked!

[...]
<span class="quote">
&gt; @@ -357,29 +360,37 @@ PAGEFLAG(Idle, idle, PF_ANY)</span>
<span class="quote">&gt;   * with the PAGE_MAPPING_ANON bit set to distinguish it.  See rmap.h.</span>
<span class="quote">&gt;   *</span>
<span class="quote">&gt;   * On an anonymous page in a VM_MERGEABLE area, if CONFIG_KSM is enabled,</span>
<span class="quote">&gt; - * the PAGE_MAPPING_KSM bit may be set along with the PAGE_MAPPING_ANON bit;</span>
<span class="quote">&gt; - * and then page-&gt;mapping points, not to an anon_vma, but to a private</span>
<span class="quote">&gt; + * the PAGE_MAPPING_MOVABLE bit may be set along with the PAGE_MAPPING_ANON</span>
<span class="quote">&gt; + * bit; and then page-&gt;mapping points, not to an anon_vma, but to a private</span>
<span class="quote">&gt;   * structure which KSM associates with that merged page.  See ksm.h.</span>
<span class="quote">&gt;   *</span>
<span class="quote">&gt; - * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is currently never used.</span>
<span class="quote">&gt; + * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is used for non-lru movable</span>
<span class="quote">&gt; + * page and then page-&gt;mapping points a struct address_space.</span>
<span class="quote">&gt;   *</span>
<span class="quote">&gt;   * Please note that, confusingly, &quot;page_mapping&quot; refers to the inode</span>
<span class="quote">&gt;   * address_space which maps the page from disk; whereas &quot;page_mapped&quot;</span>
<span class="quote">&gt;   * refers to user virtual address space into which the page is mapped.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt; -#define PAGE_MAPPING_ANON	1</span>
<span class="quote">&gt; -#define PAGE_MAPPING_KSM	2</span>
<span class="quote">&gt; -#define PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM)</span>
<span class="quote">&gt; +#define PAGE_MAPPING_ANON	0x1</span>
<span class="quote">&gt; +#define PAGE_MAPPING_MOVABLE	0x2</span>
<span class="quote">&gt; +#define PAGE_MAPPING_KSM	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span>
<span class="quote">&gt; +#define PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -static __always_inline int PageAnonHead(struct page *page)</span>
<span class="quote">&gt; +static __always_inline int PageMappingFlag(struct page *page)</span>

PageMappingFlags()?

[...]
<span class="quote">
&gt; diff --git a/mm/compaction.c b/mm/compaction.c</span>
<span class="quote">&gt; index 1427366ad673..2d6862d0df60 100644</span>
<span class="quote">&gt; --- a/mm/compaction.c</span>
<span class="quote">&gt; +++ b/mm/compaction.c</span>
<span class="quote">&gt; @@ -81,6 +81,41 @@ static inline bool migrate_async_suitable(int migratetype)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  #ifdef CONFIG_COMPACTION</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +int PageMovable(struct page *page)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct address_space *mapping;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	WARN_ON(!PageLocked(page));</span>

Why not VM_BUG_ON_PAGE as elsewhere?
<span class="quote">
&gt; +	if (!__PageMovable(page))</span>
<span class="quote">&gt; +		goto out;</span>

Just return 0.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	mapping = page_mapping(page);</span>
<span class="quote">&gt; +	if (mapping &amp;&amp; mapping-&gt;a_ops &amp;&amp; mapping-&gt;a_ops-&gt;isolate_page)</span>
<span class="quote">&gt; +		return 1;</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL(PageMovable);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void __SetPageMovable(struct page *page, struct address_space *mapping)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="quote">&gt; +	VM_BUG_ON_PAGE((unsigned long)mapping &amp; PAGE_MAPPING_MOVABLE, page);</span>
<span class="quote">&gt; +	page-&gt;mapping = (void *)((unsigned long)mapping | PAGE_MAPPING_MOVABLE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL(__SetPageMovable);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void __ClearPageMovable(struct page *page)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="quote">&gt; +	VM_BUG_ON_PAGE(!PageMovable(page), page);</span>
<span class="quote">&gt; +	VM_BUG_ON_PAGE(!((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_MOVABLE),</span>
<span class="quote">&gt; +				page);</span>

The last line sounds redundant, PageMovable() already checked this via 
__PageMovable()
<span class="quote">

&gt; +	page-&gt;mapping = (void *)((unsigned long)page-&gt;mapping &amp;</span>
<span class="quote">&gt; +				PAGE_MAPPING_MOVABLE);</span>

This should be negated to clear... use ~PAGE_MAPPING_MOVABLE ?
<span class="quote">
&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL(__ClearPageMovable);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /* Do not skip compaction more than 64 times */</span>
<span class="quote">&gt;  #define COMPACT_MAX_DEFER_SHIFT 6</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; @@ -735,21 +770,6 @@ isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  		/*</span>
<span class="quote">&gt; -		 * Check may be lockless but that&#39;s ok as we recheck later.</span>
<span class="quote">&gt; -		 * It&#39;s possible to migrate LRU pages and balloon pages</span>
<span class="quote">&gt; -		 * Skip any other type of page</span>
<span class="quote">&gt; -		 */</span>
<span class="quote">&gt; -		is_lru = PageLRU(page);</span>
<span class="quote">&gt; -		if (!is_lru) {</span>
<span class="quote">&gt; -			if (unlikely(balloon_page_movable(page))) {</span>
<span class="quote">&gt; -				if (balloon_page_isolate(page)) {</span>
<span class="quote">&gt; -					/* Successfully isolated */</span>
<span class="quote">&gt; -					goto isolate_success;</span>
<span class="quote">&gt; -				}</span>
<span class="quote">&gt; -			}</span>
<span class="quote">&gt; -		}</span>

So this effectively prevents movable compound pages from being migrated. Are you 
sure no users of this functionality are going to have compound pages? I assumed 
that they could, and so made the code like this, with the is_lru variable (which 
is redundant after your change).
<span class="quote">
&gt; -		/*</span>
<span class="quote">&gt;  		 * Regardless of being on LRU, compound pages such as THP and</span>
<span class="quote">&gt;  		 * hugetlbfs are not to be compacted. We can potentially save</span>
<span class="quote">&gt;  		 * a lot of iterations if we skip them at once. The check is</span>
<span class="quote">&gt; @@ -765,8 +785,38 @@ isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,</span>
<span class="quote">&gt;  			goto isolate_fail;</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -		if (!is_lru)</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * Check may be lockless but that&#39;s ok as we recheck later.</span>
<span class="quote">&gt; +		 * It&#39;s possible to migrate LRU and non-lru movable pages.</span>
<span class="quote">&gt; +		 * Skip any other type of page</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		is_lru = PageLRU(page);</span>
<span class="quote">&gt; +		if (!is_lru) {</span>
<span class="quote">&gt; +			if (unlikely(balloon_page_movable(page))) {</span>
<span class="quote">&gt; +				if (balloon_page_isolate(page)) {</span>
<span class="quote">&gt; +					/* Successfully isolated */</span>
<span class="quote">&gt; +					goto isolate_success;</span>
<span class="quote">&gt; +				}</span>
<span class="quote">&gt; +			}</span>

[...]
<span class="quote">
&gt; +bool isolate_movable_page(struct page *page, isolate_mode_t mode)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct address_space *mapping;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Avoid burning cycles with pages that are yet under __free_pages(),</span>
<span class="quote">&gt; +	 * or just got freed under us.</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * In case we &#39;win&#39; a race for a movable page being freed under us and</span>
<span class="quote">&gt; +	 * raise its refcount preventing __free_pages() from doing its job</span>
<span class="quote">&gt; +	 * the put_page() at the end of this block will take care of</span>
<span class="quote">&gt; +	 * release this page, thus avoiding a nasty leakage.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (unlikely(!get_page_unless_zero(page)))</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Check PageMovable before holding a PG_lock because page&#39;s owner</span>
<span class="quote">&gt; +	 * assumes anybody doesn&#39;t touch PG_lock of newly allocated page</span>
<span class="quote">&gt; +	 * so unconditionally grapping the lock ruins page&#39;s owner side.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (unlikely(!__PageMovable(page)))</span>
<span class="quote">&gt; +		goto out_putpage;</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * As movable pages are not isolated from LRU lists, concurrent</span>
<span class="quote">&gt; +	 * compaction threads can race against page migration functions</span>
<span class="quote">&gt; +	 * as well as race against the releasing a page.</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * In order to avoid having an already isolated movable page</span>
<span class="quote">&gt; +	 * being (wrongly) re-isolated while it is under migration,</span>
<span class="quote">&gt; +	 * or to avoid attempting to isolate pages being released,</span>
<span class="quote">&gt; +	 * lets be sure we have the page lock</span>
<span class="quote">&gt; +	 * before proceeding with the movable page isolation steps.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (unlikely(!trylock_page(page)))</span>
<span class="quote">&gt; +		goto out_putpage;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!PageMovable(page) || PageIsolated(page))</span>
<span class="quote">&gt; +		goto out_no_isolated;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mapping = page_mapping(page);</span>

Hmm so on first tail page of a THP compound page, page-&gt;mapping will alias with 
compound_mapcount. That can easily have a value matching PageMovable flags and 
we&#39;ll proceed and start inspecting the compound head in page_mapping()... maybe 
it&#39;s not a big deal, or we better check and skip PageTail first, must think 
about it more...

[...]
<span class="quote">
&gt; @@ -755,33 +844,69 @@ static int move_to_new_page(struct page *newpage, struct page *page,</span>
<span class="quote">&gt;  				enum migrate_mode mode)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct address_space *mapping;</span>
<span class="quote">&gt; -	int rc;</span>
<span class="quote">&gt; +	int rc = -EAGAIN;</span>
<span class="quote">&gt; +	bool is_lru = !__PageMovable(page);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="quote">&gt;  	VM_BUG_ON_PAGE(!PageLocked(newpage), newpage);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	mapping = page_mapping(page);</span>
<span class="quote">&gt; -	if (!mapping)</span>
<span class="quote">&gt; -		rc = migrate_page(mapping, newpage, page, mode);</span>
<span class="quote">&gt; -	else if (mapping-&gt;a_ops-&gt;migratepage)</span>
<span class="quote">&gt; -		/*</span>
<span class="quote">&gt; -		 * Most pages have a mapping and most filesystems provide a</span>
<span class="quote">&gt; -		 * migratepage callback. Anonymous pages are part of swap</span>
<span class="quote">&gt; -		 * space which also has its own migratepage callback. This</span>
<span class="quote">&gt; -		 * is the most common path for page migration.</span>
<span class="quote">&gt; -		 */</span>
<span class="quote">&gt; -		rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage, page, mode);</span>
<span class="quote">&gt; -	else</span>
<span class="quote">&gt; -		rc = fallback_migrate_page(mapping, newpage, page, mode);</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * In case of non-lru page, it could be released after</span>
<span class="quote">&gt; +	 * isolation step. In that case, we shouldn&#39;t try</span>
<span class="quote">&gt; +	 * fallback migration which is designed for LRU pages.</span>
<span class="quote">&gt; +	 */</span>

Hmm but is_lru was determined from !__PageMovable() above, also well after the 
isolation step. So if the driver already released it, we wouldn&#39;t detect it? And 
this function is all under same page lock, so if __PageMovable was true above, 
so will be PageMovable below?
<span class="quote">
&gt; +	if (unlikely(!is_lru)) {</span>
<span class="quote">&gt; +		VM_BUG_ON_PAGE(!PageIsolated(page), page);</span>
<span class="quote">&gt; +		if (!PageMovable(page)) {</span>
<span class="quote">&gt; +			rc = MIGRATEPAGE_SUCCESS;</span>
<span class="quote">&gt; +			__ClearPageIsolated(page);</span>
<span class="quote">&gt; +			goto out;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (likely(is_lru)) {</span>
<span class="quote">&gt; +		if (!mapping)</span>
<span class="quote">&gt; +			rc = migrate_page(mapping, newpage, page, mode);</span>
<span class="quote">&gt; +		else if (mapping-&gt;a_ops-&gt;migratepage)</span>
<span class="quote">&gt; +			/*</span>
<span class="quote">&gt; +			 * Most pages have a mapping and most filesystems</span>
<span class="quote">&gt; +			 * provide a migratepage callback. Anonymous pages</span>
<span class="quote">&gt; +			 * are part of swap space which also has its own</span>
<span class="quote">&gt; +			 * migratepage callback. This is the most common path</span>
<span class="quote">&gt; +			 * for page migration.</span>
<span class="quote">&gt; +			 */</span>
<span class="quote">&gt; +			rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage,</span>
<span class="quote">&gt; +							page, mode);</span>
<span class="quote">&gt; +		else</span>
<span class="quote">&gt; +			rc = fallback_migrate_page(mapping, newpage,</span>
<span class="quote">&gt; +							page, mode);</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage,</span>
<span class="quote">&gt; +						page, mode);</span>
<span class="quote">&gt; +		WARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &amp;&amp;</span>
<span class="quote">&gt; +			!PageIsolated(page));</span>
<span class="quote">&gt; +	}</span>

Why split the !is_lru handling in two places?
<span class="quote">
&gt;</span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * When successful, old pagecache page-&gt;mapping must be cleared before</span>
<span class="quote">&gt;  	 * page is freed; but stats require that PageAnon be left as PageAnon.</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt;  	if (rc == MIGRATEPAGE_SUCCESS) {</span>
<span class="quote">&gt; -		if (!PageAnon(page))</span>
<span class="quote">&gt; +		if (__PageMovable(page)) {</span>
<span class="quote">&gt; +			VM_BUG_ON_PAGE(!PageIsolated(page), page);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			/*</span>
<span class="quote">&gt; +			 * We clear PG_movable under page_lock so any compactor</span>
<span class="quote">&gt; +			 * cannot try to migrate this page.</span>
<span class="quote">&gt; +			 */</span>
<span class="quote">&gt; +			__ClearPageIsolated(page);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (!((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS))</span>
<span class="quote">&gt;  			page-&gt;mapping = NULL;</span>

The two lines above make little sense to me without a comment. Should the 
condition be negated, even?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=36811">Minchan Kim</a> - May 30, 2016, 1:33 a.m.</div>
<pre class="content">
On Fri, May 27, 2016 at 04:26:21PM +0200, Vlastimil Babka wrote:
<span class="quote">&gt; On 05/20/2016 04:23 PM, Minchan Kim wrote:</span>
<span class="quote">&gt; &gt;We have allowed migration for only LRU pages until now and it was</span>
<span class="quote">&gt; &gt;enough to make high-order pages. But recently, embedded system(e.g.,</span>
<span class="quote">&gt; &gt;webOS, android) uses lots of non-movable pages(e.g., zram, GPU memory)</span>
<span class="quote">&gt; &gt;so we have seen several reports about troubles of small high-order</span>
<span class="quote">&gt; &gt;allocation. For fixing the problem, there were several efforts</span>
<span class="quote">&gt; &gt;(e,g,. enhance compaction algorithm, SLUB fallback to 0-order page,</span>
<span class="quote">&gt; &gt;reserved memory, vmalloc and so on) but if there are lots of</span>
<span class="quote">&gt; &gt;non-movable pages in system, their solutions are void in the long run.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;So, this patch is to support facility to change non-movable pages</span>
<span class="quote">&gt; &gt;with movable. For the feature, this patch introduces functions related</span>
<span class="quote">&gt; &gt;to migration to address_space_operations as well as some page flags.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;If a driver want to make own pages movable, it should define three functions</span>
<span class="quote">&gt; &gt;which are function pointers of struct address_space_operations.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;1. bool (*isolate_page) (struct page *page, isolate_mode_t mode);</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;What VM expects on isolate_page function of driver is to return *true*</span>
<span class="quote">&gt; &gt;if driver isolates page successfully. On returing true, VM marks the page</span>
<span class="quote">&gt; &gt;as PG_isolated so concurrent isolation in several CPUs skip the page</span>
<span class="quote">&gt; &gt;for isolation. If a driver cannot isolate the page, it should return *false*.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Once page is successfully isolated, VM uses page.lru fields so driver</span>
<span class="quote">&gt; &gt;shouldn&#39;t expect to preserve values in that fields.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;2. int (*migratepage) (struct address_space *mapping,</span>
<span class="quote">&gt; &gt;		struct page *newpage, struct page *oldpage, enum migrate_mode);</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;After isolation, VM calls migratepage of driver with isolated page.</span>
<span class="quote">&gt; &gt;The function of migratepage is to move content of the old page to new page</span>
<span class="quote">&gt; &gt;and set up fields of struct page newpage. Keep in mind that you should</span>
<span class="quote">&gt; &gt;clear PG_movable of oldpage via __ClearPageMovable under page_lock if you</span>
<span class="quote">&gt; &gt;migrated the oldpage successfully and returns 0.</span>
<span class="quote">&gt; &gt;If driver cannot migrate the page at the moment, driver can return -EAGAIN.</span>
<span class="quote">&gt; &gt;On -EAGAIN, VM will retry page migration in a short time because VM interprets</span>
<span class="quote">&gt; &gt;-EAGAIN as &quot;temporal migration failure&quot;. On returning any error except -EAGAIN,</span>
<span class="quote">&gt; &gt;VM will give up the page migration without retrying in this time.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Driver shouldn&#39;t touch page.lru field VM using in the functions.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;3. void (*putback_page)(struct page *);</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;If migration fails on isolated page, VM should return the isolated page</span>
<span class="quote">&gt; &gt;to the driver so VM calls driver&#39;s putback_page with migration failed page.</span>
<span class="quote">&gt; &gt;In this function, driver should put the isolated page back to the own data</span>
<span class="quote">&gt; &gt;structure.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;4. non-lru movable page flags</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;There are two page flags for supporting non-lru movable page.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;* PG_movable</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Driver should use the below function to make page movable under page_lock.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;	void __SetPageMovable(struct page *page, struct address_space *mapping)</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;It needs argument of address_space for registering migration family functions</span>
<span class="quote">&gt; &gt;which will be called by VM. Exactly speaking, PG_movable is not a real flag of</span>
<span class="quote">&gt; &gt;struct page. Rather than, VM reuses page-&gt;mapping&#39;s lower bits to represent it.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;	#define PAGE_MAPPING_MOVABLE 0x2</span>
<span class="quote">&gt; &gt;	page-&gt;mapping = page-&gt;mapping | PAGE_MAPPING_MOVABLE;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Interesting, let&#39;s see how that works out...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Overal this looks much better than the last version I checked!</span>

Thanks.
<span class="quote">
&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;@@ -357,29 +360,37 @@ PAGEFLAG(Idle, idle, PF_ANY)</span>
<span class="quote">&gt; &gt;  * with the PAGE_MAPPING_ANON bit set to distinguish it.  See rmap.h.</span>
<span class="quote">&gt; &gt;  *</span>
<span class="quote">&gt; &gt;  * On an anonymous page in a VM_MERGEABLE area, if CONFIG_KSM is enabled,</span>
<span class="quote">&gt; &gt;- * the PAGE_MAPPING_KSM bit may be set along with the PAGE_MAPPING_ANON bit;</span>
<span class="quote">&gt; &gt;- * and then page-&gt;mapping points, not to an anon_vma, but to a private</span>
<span class="quote">&gt; &gt;+ * the PAGE_MAPPING_MOVABLE bit may be set along with the PAGE_MAPPING_ANON</span>
<span class="quote">&gt; &gt;+ * bit; and then page-&gt;mapping points, not to an anon_vma, but to a private</span>
<span class="quote">&gt; &gt;  * structure which KSM associates with that merged page.  See ksm.h.</span>
<span class="quote">&gt; &gt;  *</span>
<span class="quote">&gt; &gt;- * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is currently never used.</span>
<span class="quote">&gt; &gt;+ * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is used for non-lru movable</span>
<span class="quote">&gt; &gt;+ * page and then page-&gt;mapping points a struct address_space.</span>
<span class="quote">&gt; &gt;  *</span>
<span class="quote">&gt; &gt;  * Please note that, confusingly, &quot;page_mapping&quot; refers to the inode</span>
<span class="quote">&gt; &gt;  * address_space which maps the page from disk; whereas &quot;page_mapped&quot;</span>
<span class="quote">&gt; &gt;  * refers to user virtual address space into which the page is mapped.</span>
<span class="quote">&gt; &gt;  */</span>
<span class="quote">&gt; &gt;-#define PAGE_MAPPING_ANON	1</span>
<span class="quote">&gt; &gt;-#define PAGE_MAPPING_KSM	2</span>
<span class="quote">&gt; &gt;-#define PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM)</span>
<span class="quote">&gt; &gt;+#define PAGE_MAPPING_ANON	0x1</span>
<span class="quote">&gt; &gt;+#define PAGE_MAPPING_MOVABLE	0x2</span>
<span class="quote">&gt; &gt;+#define PAGE_MAPPING_KSM	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span>
<span class="quote">&gt; &gt;+#define PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;-static __always_inline int PageAnonHead(struct page *page)</span>
<span class="quote">&gt; &gt;+static __always_inline int PageMappingFlag(struct page *page)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; PageMappingFlags()?</span>

Yeb.
<span class="quote">
&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;diff --git a/mm/compaction.c b/mm/compaction.c</span>
<span class="quote">&gt; &gt;index 1427366ad673..2d6862d0df60 100644</span>
<span class="quote">&gt; &gt;--- a/mm/compaction.c</span>
<span class="quote">&gt; &gt;+++ b/mm/compaction.c</span>
<span class="quote">&gt; &gt;@@ -81,6 +81,41 @@ static inline bool migrate_async_suitable(int migratetype)</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; #ifdef CONFIG_COMPACTION</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;+int PageMovable(struct page *page)</span>
<span class="quote">&gt; &gt;+{</span>
<span class="quote">&gt; &gt;+	struct address_space *mapping;</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+	WARN_ON(!PageLocked(page));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why not VM_BUG_ON_PAGE as elsewhere?</span>

I have backported this patchset to huge old kernel which doesn&#39;t have
VM_BUG_ON_PAGE and forgot to correct it beforre sending mainline.

Thanks.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;+	if (!__PageMovable(page))</span>
<span class="quote">&gt; &gt;+		goto out;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Just return 0.</span>

Maybe I love goto. You realized me. I will split up will her.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+	mapping = page_mapping(page);</span>
<span class="quote">&gt; &gt;+	if (mapping &amp;&amp; mapping-&gt;a_ops &amp;&amp; mapping-&gt;a_ops-&gt;isolate_page)</span>
<span class="quote">&gt; &gt;+		return 1;</span>
<span class="quote">&gt; &gt;+out:</span>
<span class="quote">&gt; &gt;+	return 0;</span>
<span class="quote">&gt; &gt;+}</span>
<span class="quote">&gt; &gt;+EXPORT_SYMBOL(PageMovable);</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+void __SetPageMovable(struct page *page, struct address_space *mapping)</span>
<span class="quote">&gt; &gt;+{</span>
<span class="quote">&gt; &gt;+	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="quote">&gt; &gt;+	VM_BUG_ON_PAGE((unsigned long)mapping &amp; PAGE_MAPPING_MOVABLE, page);</span>
<span class="quote">&gt; &gt;+	page-&gt;mapping = (void *)((unsigned long)mapping | PAGE_MAPPING_MOVABLE);</span>
<span class="quote">&gt; &gt;+}</span>
<span class="quote">&gt; &gt;+EXPORT_SYMBOL(__SetPageMovable);</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+void __ClearPageMovable(struct page *page)</span>
<span class="quote">&gt; &gt;+{</span>
<span class="quote">&gt; &gt;+	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="quote">&gt; &gt;+	VM_BUG_ON_PAGE(!PageMovable(page), page);</span>
<span class="quote">&gt; &gt;+	VM_BUG_ON_PAGE(!((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_MOVABLE),</span>
<span class="quote">&gt; &gt;+				page);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The last line sounds redundant, PageMovable() already checked this</span>
<span class="quote">&gt; via __PageMovable()</span>

Yeb.
<span class="quote">
&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;+	page-&gt;mapping = (void *)((unsigned long)page-&gt;mapping &amp;</span>
<span class="quote">&gt; &gt;+				PAGE_MAPPING_MOVABLE);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This should be negated to clear... use ~PAGE_MAPPING_MOVABLE ?</span>

No.

The intention is to clear only mapping value but PAGE_MAPPING_MOVABLE
flag. So, any new migration trial will be failed because PageMovable
checks page&#39;s mapping value but ongoing migraion handling can catch
whether it&#39;s movable page or not with the type bit.

For example, we need to keep the type bit to handle putback the page.
With parallel freeing(e.g., __ClearPageMovable) from the owner after
isolating the page, migration will be failed and put it back. Then,
we need to identify movable to clear PG_isolate and shouldn&#39;t call
mapping-&gt;a_ops-&gt;putback_page. For that, we need to keep the type bit
until the page is return to buddy.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;+}</span>
<span class="quote">&gt; &gt;+EXPORT_SYMBOL(__ClearPageMovable);</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt; /* Do not skip compaction more than 64 times */</span>
<span class="quote">&gt; &gt; #define COMPACT_MAX_DEFER_SHIFT 6</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;@@ -735,21 +770,6 @@ isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,</span>
<span class="quote">&gt; &gt; 		}</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; 		/*</span>
<span class="quote">&gt; &gt;-		 * Check may be lockless but that&#39;s ok as we recheck later.</span>
<span class="quote">&gt; &gt;-		 * It&#39;s possible to migrate LRU pages and balloon pages</span>
<span class="quote">&gt; &gt;-		 * Skip any other type of page</span>
<span class="quote">&gt; &gt;-		 */</span>
<span class="quote">&gt; &gt;-		is_lru = PageLRU(page);</span>
<span class="quote">&gt; &gt;-		if (!is_lru) {</span>
<span class="quote">&gt; &gt;-			if (unlikely(balloon_page_movable(page))) {</span>
<span class="quote">&gt; &gt;-				if (balloon_page_isolate(page)) {</span>
<span class="quote">&gt; &gt;-					/* Successfully isolated */</span>
<span class="quote">&gt; &gt;-					goto isolate_success;</span>
<span class="quote">&gt; &gt;-				}</span>
<span class="quote">&gt; &gt;-			}</span>
<span class="quote">&gt; &gt;-		}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So this effectively prevents movable compound pages from being</span>
<span class="quote">&gt; migrated. Are you sure no users of this functionality are going to</span>
<span class="quote">&gt; have compound pages? I assumed that they could, and so made the code</span>
<span class="quote">&gt; like this, with the is_lru variable (which is redundant after your</span>
<span class="quote">&gt; change).</span>

This implementation at the moment disables effectively non-lru compound
page migration but I&#39;m not a god so I can&#39;t make sure no one doesn&#39;t want
it in future. If someone want it, we can support it then because this work
doesn&#39;t prevent it by design.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;-		/*</span>
<span class="quote">&gt; &gt; 		 * Regardless of being on LRU, compound pages such as THP and</span>
<span class="quote">&gt; &gt; 		 * hugetlbfs are not to be compacted. We can potentially save</span>
<span class="quote">&gt; &gt; 		 * a lot of iterations if we skip them at once. The check is</span>
<span class="quote">&gt; &gt;@@ -765,8 +785,38 @@ isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,</span>
<span class="quote">&gt; &gt; 			goto isolate_fail;</span>
<span class="quote">&gt; &gt; 		}</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;-		if (!is_lru)</span>
<span class="quote">&gt; &gt;+		/*</span>
<span class="quote">&gt; &gt;+		 * Check may be lockless but that&#39;s ok as we recheck later.</span>
<span class="quote">&gt; &gt;+		 * It&#39;s possible to migrate LRU and non-lru movable pages.</span>
<span class="quote">&gt; &gt;+		 * Skip any other type of page</span>
<span class="quote">&gt; &gt;+		 */</span>
<span class="quote">&gt; &gt;+		is_lru = PageLRU(page);</span>
<span class="quote">&gt; &gt;+		if (!is_lru) {</span>
<span class="quote">&gt; &gt;+			if (unlikely(balloon_page_movable(page))) {</span>
<span class="quote">&gt; &gt;+				if (balloon_page_isolate(page)) {</span>
<span class="quote">&gt; &gt;+					/* Successfully isolated */</span>
<span class="quote">&gt; &gt;+					goto isolate_success;</span>
<span class="quote">&gt; &gt;+				}</span>
<span class="quote">&gt; &gt;+			}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;+bool isolate_movable_page(struct page *page, isolate_mode_t mode)</span>
<span class="quote">&gt; &gt;+{</span>
<span class="quote">&gt; &gt;+	struct address_space *mapping;</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+	/*</span>
<span class="quote">&gt; &gt;+	 * Avoid burning cycles with pages that are yet under __free_pages(),</span>
<span class="quote">&gt; &gt;+	 * or just got freed under us.</span>
<span class="quote">&gt; &gt;+	 *</span>
<span class="quote">&gt; &gt;+	 * In case we &#39;win&#39; a race for a movable page being freed under us and</span>
<span class="quote">&gt; &gt;+	 * raise its refcount preventing __free_pages() from doing its job</span>
<span class="quote">&gt; &gt;+	 * the put_page() at the end of this block will take care of</span>
<span class="quote">&gt; &gt;+	 * release this page, thus avoiding a nasty leakage.</span>
<span class="quote">&gt; &gt;+	 */</span>
<span class="quote">&gt; &gt;+	if (unlikely(!get_page_unless_zero(page)))</span>
<span class="quote">&gt; &gt;+		goto out;</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+	/*</span>
<span class="quote">&gt; &gt;+	 * Check PageMovable before holding a PG_lock because page&#39;s owner</span>
<span class="quote">&gt; &gt;+	 * assumes anybody doesn&#39;t touch PG_lock of newly allocated page</span>
<span class="quote">&gt; &gt;+	 * so unconditionally grapping the lock ruins page&#39;s owner side.</span>
<span class="quote">&gt; &gt;+	 */</span>
<span class="quote">&gt; &gt;+	if (unlikely(!__PageMovable(page)))</span>
<span class="quote">&gt; &gt;+		goto out_putpage;</span>
<span class="quote">&gt; &gt;+	/*</span>
<span class="quote">&gt; &gt;+	 * As movable pages are not isolated from LRU lists, concurrent</span>
<span class="quote">&gt; &gt;+	 * compaction threads can race against page migration functions</span>
<span class="quote">&gt; &gt;+	 * as well as race against the releasing a page.</span>
<span class="quote">&gt; &gt;+	 *</span>
<span class="quote">&gt; &gt;+	 * In order to avoid having an already isolated movable page</span>
<span class="quote">&gt; &gt;+	 * being (wrongly) re-isolated while it is under migration,</span>
<span class="quote">&gt; &gt;+	 * or to avoid attempting to isolate pages being released,</span>
<span class="quote">&gt; &gt;+	 * lets be sure we have the page lock</span>
<span class="quote">&gt; &gt;+	 * before proceeding with the movable page isolation steps.</span>
<span class="quote">&gt; &gt;+	 */</span>
<span class="quote">&gt; &gt;+	if (unlikely(!trylock_page(page)))</span>
<span class="quote">&gt; &gt;+		goto out_putpage;</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+	if (!PageMovable(page) || PageIsolated(page))</span>
<span class="quote">&gt; &gt;+		goto out_no_isolated;</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+	mapping = page_mapping(page);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm so on first tail page of a THP compound page, page-&gt;mapping will</span>
<span class="quote">&gt; alias with compound_mapcount. That can easily have a value matching</span>
<span class="quote">&gt; PageMovable flags and we&#39;ll proceed and start inspecting the</span>
<span class="quote">&gt; compound head in page_mapping()... maybe it&#39;s not a big deal, or we</span>
<span class="quote">&gt; better check and skip PageTail first, must think about it more...</span>

I thouht PageCompound check right before isolate_movable_page in
isolate_migratepages_block will filter it out mostly but yeah
it is racy without zone-&gt;lru_lock so it could reach to isolate_movable_page.
However, PageMovable check in there investigates mapping, mapping-&gt;a_ops,
and a_ops-&gt;isolate_page to verify whether it&#39;s movable page or not.

I thought it&#39;s sufficient to filter THP page.
<span class="quote">
&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;@@ -755,33 +844,69 @@ static int move_to_new_page(struct page *newpage, struct page *page,</span>
<span class="quote">&gt; &gt; 				enum migrate_mode mode)</span>
<span class="quote">&gt; &gt; {</span>
<span class="quote">&gt; &gt; 	struct address_space *mapping;</span>
<span class="quote">&gt; &gt;-	int rc;</span>
<span class="quote">&gt; &gt;+	int rc = -EAGAIN;</span>
<span class="quote">&gt; &gt;+	bool is_lru = !__PageMovable(page);</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; 	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="quote">&gt; &gt; 	VM_BUG_ON_PAGE(!PageLocked(newpage), newpage);</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; 	mapping = page_mapping(page);</span>
<span class="quote">&gt; &gt;-	if (!mapping)</span>
<span class="quote">&gt; &gt;-		rc = migrate_page(mapping, newpage, page, mode);</span>
<span class="quote">&gt; &gt;-	else if (mapping-&gt;a_ops-&gt;migratepage)</span>
<span class="quote">&gt; &gt;-		/*</span>
<span class="quote">&gt; &gt;-		 * Most pages have a mapping and most filesystems provide a</span>
<span class="quote">&gt; &gt;-		 * migratepage callback. Anonymous pages are part of swap</span>
<span class="quote">&gt; &gt;-		 * space which also has its own migratepage callback. This</span>
<span class="quote">&gt; &gt;-		 * is the most common path for page migration.</span>
<span class="quote">&gt; &gt;-		 */</span>
<span class="quote">&gt; &gt;-		rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage, page, mode);</span>
<span class="quote">&gt; &gt;-	else</span>
<span class="quote">&gt; &gt;-		rc = fallback_migrate_page(mapping, newpage, page, mode);</span>
<span class="quote">&gt; &gt;+	/*</span>
<span class="quote">&gt; &gt;+	 * In case of non-lru page, it could be released after</span>
<span class="quote">&gt; &gt;+	 * isolation step. In that case, we shouldn&#39;t try</span>
<span class="quote">&gt; &gt;+	 * fallback migration which is designed for LRU pages.</span>
<span class="quote">&gt; &gt;+	 */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm but is_lru was determined from !__PageMovable() above, also well</span>
<span class="quote">&gt; after the isolation step. So if the driver already released it, we</span>
<span class="quote">&gt; wouldn&#39;t detect it? And this function is all under same page lock,</span>
<span class="quote">&gt; so if __PageMovable was true above, so will be PageMovable below?</span>

You are missing what I mentioned above.
We should keep the type bit to catch what you are saying(i.e., driver
already released).

__PageMovable just checks PAGE_MAPPING_MOVABLE flag and PageMovable
checks page-&gt;mapping valid while __ClearPageMovable reset only
valid vaule of mapping, not PAGE_MAPPING_MOVABLE flag.

I wrote it down in Documentation/vm/page_migration.

&quot;For testing of non-lru movable page, VM supports __PageMovable function.
However, it doesn&#39;t guarantee to identify non-lru movable page because
page-&gt;mapping field is unified with other variables in struct page.
As well, if driver releases the page after isolation by VM, page-&gt;mapping
doesn&#39;t have stable value although it has PAGE_MAPPING_MOVABLE
(Look at __ClearPageMovable). But __PageMovable is cheap to catch whether
page is LRU or non-lru movable once the page has been isolated. Because
LRU pages never can have PAGE_MAPPING_MOVABLE in page-&gt;mapping. It is also
good for just peeking to test non-lru movable pages before more expensive
checking with lock_page in pfn scanning to select victim.

For guaranteeing non-lru movable page, VM provides PageMovable function.
Unlike __PageMovable, PageMovable functions validates page-&gt;mapping and 
mapping-&gt;a_ops-&gt;isolate_page under lock_page. The lock_page prevents sudden
destroying of page-&gt;mapping.

Driver using __SetPageMovable should clear the flag via __ClearMovablePage
under page_lock before the releasing the page.&quot;
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;+	if (unlikely(!is_lru)) {</span>
<span class="quote">&gt; &gt;+		VM_BUG_ON_PAGE(!PageIsolated(page), page);</span>
<span class="quote">&gt; &gt;+		if (!PageMovable(page)) {</span>
<span class="quote">&gt; &gt;+			rc = MIGRATEPAGE_SUCCESS;</span>
<span class="quote">&gt; &gt;+			__ClearPageIsolated(page);</span>
<span class="quote">&gt; &gt;+			goto out;</span>
<span class="quote">&gt; &gt;+		}</span>
<span class="quote">&gt; &gt;+	}</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+	if (likely(is_lru)) {</span>
<span class="quote">&gt; &gt;+		if (!mapping)</span>
<span class="quote">&gt; &gt;+			rc = migrate_page(mapping, newpage, page, mode);</span>
<span class="quote">&gt; &gt;+		else if (mapping-&gt;a_ops-&gt;migratepage)</span>
<span class="quote">&gt; &gt;+			/*</span>
<span class="quote">&gt; &gt;+			 * Most pages have a mapping and most filesystems</span>
<span class="quote">&gt; &gt;+			 * provide a migratepage callback. Anonymous pages</span>
<span class="quote">&gt; &gt;+			 * are part of swap space which also has its own</span>
<span class="quote">&gt; &gt;+			 * migratepage callback. This is the most common path</span>
<span class="quote">&gt; &gt;+			 * for page migration.</span>
<span class="quote">&gt; &gt;+			 */</span>
<span class="quote">&gt; &gt;+			rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage,</span>
<span class="quote">&gt; &gt;+							page, mode);</span>
<span class="quote">&gt; &gt;+		else</span>
<span class="quote">&gt; &gt;+			rc = fallback_migrate_page(mapping, newpage,</span>
<span class="quote">&gt; &gt;+							page, mode);</span>
<span class="quote">&gt; &gt;+	} else {</span>
<span class="quote">&gt; &gt;+		rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage,</span>
<span class="quote">&gt; &gt;+						page, mode);</span>
<span class="quote">&gt; &gt;+		WARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &amp;&amp;</span>
<span class="quote">&gt; &gt;+			!PageIsolated(page));</span>
<span class="quote">&gt; &gt;+	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why split the !is_lru handling in two places?</span>

Fixed.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; 	/*</span>
<span class="quote">&gt; &gt; 	 * When successful, old pagecache page-&gt;mapping must be cleared before</span>
<span class="quote">&gt; &gt; 	 * page is freed; but stats require that PageAnon be left as PageAnon.</span>
<span class="quote">&gt; &gt; 	 */</span>
<span class="quote">&gt; &gt; 	if (rc == MIGRATEPAGE_SUCCESS) {</span>
<span class="quote">&gt; &gt;-		if (!PageAnon(page))</span>
<span class="quote">&gt; &gt;+		if (__PageMovable(page)) {</span>
<span class="quote">&gt; &gt;+			VM_BUG_ON_PAGE(!PageIsolated(page), page);</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+			/*</span>
<span class="quote">&gt; &gt;+			 * We clear PG_movable under page_lock so any compactor</span>
<span class="quote">&gt; &gt;+			 * cannot try to migrate this page.</span>
<span class="quote">&gt; &gt;+			 */</span>
<span class="quote">&gt; &gt;+			__ClearPageIsolated(page);</span>
<span class="quote">&gt; &gt;+		}</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+		if (!((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS))</span>
<span class="quote">&gt; &gt; 			page-&gt;mapping = NULL;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The two lines above make little sense to me without a comment.</span>

I folded this.

@@ -901,7 +901,12 @@ static int move_to_new_page(struct page *newpage, struct page *page,
                        __ClearPageIsolated(page);
                }
 
-               if (!((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS))
+               /*
+                * Anonymous and movable page-&gt;mapping will be cleard by
+                * free_pages_prepare so don&#39;t reset it here for keeping
+                * the type to work PageAnon, for example.
+                */
+               if (!PageMappingFlags(page))
                        page-&gt;mapping = NULL;
        }
 out:
<span class="quote">

&gt; Should the condition be negated, even?</span>

No.
<span class="quote">
&gt; </span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=72672">Vlastimil Babka</a> - May 30, 2016, 9:01 a.m.</div>
<pre class="content">
On 05/30/2016 03:33 AM, Minchan Kim wrote:
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +	page-&gt;mapping = (void *)((unsigned long)page-&gt;mapping &amp;</span>
<span class="quote">&gt;&gt;&gt; +				PAGE_MAPPING_MOVABLE);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This should be negated to clear... use ~PAGE_MAPPING_MOVABLE ?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; No.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The intention is to clear only mapping value but PAGE_MAPPING_MOVABLE</span>
<span class="quote">&gt; flag. So, any new migration trial will be failed because PageMovable</span>
<span class="quote">&gt; checks page&#39;s mapping value but ongoing migraion handling can catch</span>
<span class="quote">&gt; whether it&#39;s movable page or not with the type bit.</span>

Oh, OK, I got that wrong. I&#39;ll point out in the reply to the v6v2 what 
misled me :)
<span class="quote">
&gt;&gt;</span>
<span class="quote">&gt;&gt; So this effectively prevents movable compound pages from being</span>
<span class="quote">&gt;&gt; migrated. Are you sure no users of this functionality are going to</span>
<span class="quote">&gt;&gt; have compound pages? I assumed that they could, and so made the code</span>
<span class="quote">&gt;&gt; like this, with the is_lru variable (which is redundant after your</span>
<span class="quote">&gt;&gt; change).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This implementation at the moment disables effectively non-lru compound</span>
<span class="quote">&gt; page migration but I&#39;m not a god so I can&#39;t make sure no one doesn&#39;t want</span>
<span class="quote">&gt; it in future. If someone want it, we can support it then because this work</span>
<span class="quote">&gt; doesn&#39;t prevent it by design.</span>

Oh well. As long as the balloon pages or zsmalloc don&#39;t already use 
compound pages...
<span class="quote">
&gt;</span>
<span class="quote">&gt; I thouht PageCompound check right before isolate_movable_page in</span>
<span class="quote">&gt; isolate_migratepages_block will filter it out mostly but yeah</span>
<span class="quote">&gt; it is racy without zone-&gt;lru_lock so it could reach to isolate_movable_page.</span>
<span class="quote">&gt; However, PageMovable check in there investigates mapping, mapping-&gt;a_ops,</span>
<span class="quote">&gt; and a_ops-&gt;isolate_page to verify whether it&#39;s movable page or not.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I thought it&#39;s sufficient to filter THP page.</span>

I guess, yeah.
<span class="quote">
&gt;&gt;</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; @@ -755,33 +844,69 @@ static int move_to_new_page(struct page *newpage, struct page *page,</span>
<span class="quote">&gt;&gt;&gt; 				enum migrate_mode mode)</span>
<span class="quote">&gt;&gt;&gt; {</span>
<span class="quote">&gt;&gt;&gt; 	struct address_space *mapping;</span>
<span class="quote">&gt;&gt;&gt; -	int rc;</span>
<span class="quote">&gt;&gt;&gt; +	int rc = -EAGAIN;</span>
<span class="quote">&gt;&gt;&gt; +	bool is_lru = !__PageMovable(page);</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; 	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="quote">&gt;&gt;&gt; 	VM_BUG_ON_PAGE(!PageLocked(newpage), newpage);</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; 	mapping = page_mapping(page);</span>
<span class="quote">&gt;&gt;&gt; -	if (!mapping)</span>
<span class="quote">&gt;&gt;&gt; -		rc = migrate_page(mapping, newpage, page, mode);</span>
<span class="quote">&gt;&gt;&gt; -	else if (mapping-&gt;a_ops-&gt;migratepage)</span>
<span class="quote">&gt;&gt;&gt; -		/*</span>
<span class="quote">&gt;&gt;&gt; -		 * Most pages have a mapping and most filesystems provide a</span>
<span class="quote">&gt;&gt;&gt; -		 * migratepage callback. Anonymous pages are part of swap</span>
<span class="quote">&gt;&gt;&gt; -		 * space which also has its own migratepage callback. This</span>
<span class="quote">&gt;&gt;&gt; -		 * is the most common path for page migration.</span>
<span class="quote">&gt;&gt;&gt; -		 */</span>
<span class="quote">&gt;&gt;&gt; -		rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage, page, mode);</span>
<span class="quote">&gt;&gt;&gt; -	else</span>
<span class="quote">&gt;&gt;&gt; -		rc = fallback_migrate_page(mapping, newpage, page, mode);</span>
<span class="quote">&gt;&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt;&gt; +	 * In case of non-lru page, it could be released after</span>
<span class="quote">&gt;&gt;&gt; +	 * isolation step. In that case, we shouldn&#39;t try</span>
<span class="quote">&gt;&gt;&gt; +	 * fallback migration which is designed for LRU pages.</span>
<span class="quote">&gt;&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hmm but is_lru was determined from !__PageMovable() above, also well</span>
<span class="quote">&gt;&gt; after the isolation step. So if the driver already released it, we</span>
<span class="quote">&gt;&gt; wouldn&#39;t detect it? And this function is all under same page lock,</span>
<span class="quote">&gt;&gt; so if __PageMovable was true above, so will be PageMovable below?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; You are missing what I mentioned above.</span>
<span class="quote">&gt; We should keep the type bit to catch what you are saying(i.e., driver</span>
<span class="quote">&gt; already released).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; __PageMovable just checks PAGE_MAPPING_MOVABLE flag and PageMovable</span>
<span class="quote">&gt; checks page-&gt;mapping valid while __ClearPageMovable reset only</span>
<span class="quote">&gt; valid vaule of mapping, not PAGE_MAPPING_MOVABLE flag.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I wrote it down in Documentation/vm/page_migration.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; &quot;For testing of non-lru movable page, VM supports __PageMovable function.</span>
<span class="quote">&gt; However, it doesn&#39;t guarantee to identify non-lru movable page because</span>
<span class="quote">&gt; page-&gt;mapping field is unified with other variables in struct page.</span>
<span class="quote">&gt; As well, if driver releases the page after isolation by VM, page-&gt;mapping</span>
<span class="quote">&gt; doesn&#39;t have stable value although it has PAGE_MAPPING_MOVABLE</span>
<span class="quote">&gt; (Look at __ClearPageMovable). But __PageMovable is cheap to catch whether</span>
<span class="quote">&gt; page is LRU or non-lru movable once the page has been isolated. Because</span>
<span class="quote">&gt; LRU pages never can have PAGE_MAPPING_MOVABLE in page-&gt;mapping. It is also</span>
<span class="quote">&gt; good for just peeking to test non-lru movable pages before more expensive</span>
<span class="quote">&gt; checking with lock_page in pfn scanning to select victim.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; For guaranteeing non-lru movable page, VM provides PageMovable function.</span>
<span class="quote">&gt; Unlike __PageMovable, PageMovable functions validates page-&gt;mapping and</span>
<span class="quote">&gt; mapping-&gt;a_ops-&gt;isolate_page under lock_page. The lock_page prevents sudden</span>
<span class="quote">&gt; destroying of page-&gt;mapping.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Driver using __SetPageMovable should clear the flag via __ClearMovablePage</span>
<span class="quote">&gt; under page_lock before the releasing the page.&quot;</span>

Right, I get it now.
<span class="quote">

&gt;&gt;&gt; +		if (!((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS))</span>
<span class="quote">&gt;&gt;&gt; 			page-&gt;mapping = NULL;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The two lines above make little sense to me without a comment.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I folded this.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; @@ -901,7 +901,12 @@ static int move_to_new_page(struct page *newpage, struct page *page,</span>
<span class="quote">&gt;                         __ClearPageIsolated(page);</span>
<span class="quote">&gt;                 }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -               if (!((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS))</span>
<span class="quote">&gt; +               /*</span>
<span class="quote">&gt; +                * Anonymous and movable page-&gt;mapping will be cleard by</span>
<span class="quote">&gt; +                * free_pages_prepare so don&#39;t reset it here for keeping</span>
<span class="quote">&gt; +                * the type to work PageAnon, for example.</span>
<span class="quote">&gt; +                */</span>
<span class="quote">&gt; +               if (!PageMappingFlags(page))</span>
<span class="quote">&gt;                         page-&gt;mapping = NULL;</span>
<span class="quote">&gt;         }</span>

Thanks.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/filesystems/Locking b/Documentation/filesystems/Locking</span>
<span class="p_header">index 75eea7ce3d7c..dda6e3f8e203 100644</span>
<span class="p_header">--- a/Documentation/filesystems/Locking</span>
<span class="p_header">+++ b/Documentation/filesystems/Locking</span>
<span class="p_chunk">@@ -195,7 +195,9 @@</span> <span class="p_context"> unlocks and drops the reference.</span>
 	int (*releasepage) (struct page *, int);
 	void (*freepage)(struct page *);
 	int (*direct_IO)(struct kiocb *, struct iov_iter *iter);
<span class="p_add">+	bool (*isolate_page) (struct page *, isolate_mode_t);</span>
 	int (*migratepage)(struct address_space *, struct page *, struct page *);
<span class="p_add">+	void (*putback_page) (struct page *);</span>
 	int (*launder_page)(struct page *);
 	int (*is_partially_uptodate)(struct page *, unsigned long, unsigned long);
 	int (*error_remove_page)(struct address_space *, struct page *);
<span class="p_chunk">@@ -219,7 +221,9 @@</span> <span class="p_context"> invalidatepage:		yes</span>
 releasepage:		yes
 freepage:		yes
 direct_IO:
<span class="p_add">+isolate_page:		yes</span>
 migratepage:		yes (both)
<span class="p_add">+putback_page:		yes</span>
 launder_page:		yes
 is_partially_uptodate:	yes
 error_remove_page:	yes
<span class="p_header">diff --git a/Documentation/filesystems/vfs.txt b/Documentation/filesystems/vfs.txt</span>
<span class="p_header">index c61a223ef3ff..900360cbcdae 100644</span>
<span class="p_header">--- a/Documentation/filesystems/vfs.txt</span>
<span class="p_header">+++ b/Documentation/filesystems/vfs.txt</span>
<span class="p_chunk">@@ -592,9 +592,14 @@</span> <span class="p_context"> struct address_space_operations {</span>
 	int (*releasepage) (struct page *, int);
 	void (*freepage)(struct page *);
 	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);
<span class="p_add">+	/* isolate a page for migration */</span>
<span class="p_add">+	bool (*isolate_page) (struct page *, isolate_mode_t);</span>
 	/* migrate the contents of a page to the specified target */
 	int (*migratepage) (struct page *, struct page *);
<span class="p_add">+	/* put migration-failed page back to right list */</span>
<span class="p_add">+	void (*putback_page) (struct page *);</span>
 	int (*launder_page) (struct page *);
<span class="p_add">+</span>
 	int (*is_partially_uptodate) (struct page *, unsigned long,
 					unsigned long);
 	void (*is_dirty_writeback) (struct page *, bool *, bool *);
<span class="p_chunk">@@ -747,6 +752,10 @@</span> <span class="p_context"> struct address_space_operations {</span>
         and transfer data directly between the storage and the
         application&#39;s address space.
 
<span class="p_add">+  isolate_page: Called by the VM when isolating a movable non-lru page.</span>
<span class="p_add">+	If page is successfully isolated, VM marks the page as PG_isolated</span>
<span class="p_add">+	via __SetPageIsolated.</span>
<span class="p_add">+</span>
   migrate_page:  This is used to compact the physical memory usage.
         If the VM wants to relocate a page (maybe off a memory card
         that is signalling imminent failure) it will pass a new page
<span class="p_chunk">@@ -754,6 +763,8 @@</span> <span class="p_context"> struct address_space_operations {</span>
 	transfer any private data across and update any references
         that it has to the page.
 
<span class="p_add">+  putback_page: Called by the VM when isolated page&#39;s migration fails.</span>
<span class="p_add">+</span>
   launder_page: Called before freeing a page - it writes back the dirty page. To
   	prevent redirtying the page, it is kept locked during the whole
 	operation.
<span class="p_header">diff --git a/Documentation/vm/page_migration b/Documentation/vm/page_migration</span>
<span class="p_header">index fea5c0864170..80e98af46e95 100644</span>
<span class="p_header">--- a/Documentation/vm/page_migration</span>
<span class="p_header">+++ b/Documentation/vm/page_migration</span>
<span class="p_chunk">@@ -142,5 +142,110 @@</span> <span class="p_context"> is increased so that the page cannot be freed while page migration occurs.</span>
 20. The new page is moved to the LRU and can be scanned by the swapper
     etc again.
 
<span class="p_del">-Christoph Lameter, May 8, 2006.</span>
<span class="p_add">+C. Non-LRU page migration</span>
<span class="p_add">+-------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+Although original migration aimed for reducing the latency of memory access</span>
<span class="p_add">+for NUMA, compaction who want to create high-order page is also main customer.</span>
<span class="p_add">+</span>
<span class="p_add">+Current problem of the implementation is that it is designed to migrate only</span>
<span class="p_add">+*LRU* pages. However, there are potential non-lru pages which can be migrated</span>
<span class="p_add">+in drivers, for example, zsmalloc, virtio-balloon pages.</span>
<span class="p_add">+</span>
<span class="p_add">+For virtio-balloon pages, some parts of migration code path have been hooked</span>
<span class="p_add">+up and added virtio-balloon specific functions to intercept migration logics.</span>
<span class="p_add">+It&#39;s too specific to a driver so other drivers who want to make their pages</span>
<span class="p_add">+movable would have to add own specific hooks in migration path.</span>
<span class="p_add">+</span>
<span class="p_add">+To overclome the problem, VM supports non-LRU page migration which provides</span>
<span class="p_add">+generic functions for non-LRU movable pages without driver specific hooks</span>
<span class="p_add">+migration path.</span>
<span class="p_add">+</span>
<span class="p_add">+If a driver want to make own pages movable, it should define three functions</span>
<span class="p_add">+which are function pointers of struct address_space_operations.</span>
<span class="p_add">+</span>
<span class="p_add">+1. bool (*isolate_page) (struct page *page, isolate_mode_t mode);</span>
<span class="p_add">+</span>
<span class="p_add">+What VM expects on isolate_page function of driver is to return *true*</span>
<span class="p_add">+if driver isolates page successfully. On returing true, VM marks the page</span>
<span class="p_add">+as PG_isolated so concurrent isolation in several CPUs skip the page</span>
<span class="p_add">+for isolation. If a driver cannot isolate the page, it should return *false*.</span>
<span class="p_add">+</span>
<span class="p_add">+Once page is successfully isolated, VM uses page.lru fields so driver</span>
<span class="p_add">+shouldn&#39;t expect to preserve values in that fields.</span>
<span class="p_add">+</span>
<span class="p_add">+2. int (*migratepage) (struct address_space *mapping,</span>
<span class="p_add">+		struct page *newpage, struct page *oldpage, enum migrate_mode);</span>
<span class="p_add">+</span>
<span class="p_add">+After isolation, VM calls migratepage of driver with isolated page.</span>
<span class="p_add">+The function of migratepage is to move content of the old page to new page</span>
<span class="p_add">+and set up fields of struct page newpage. Keep in mind that you should</span>
<span class="p_add">+clear PG_movable of oldpage via __ClearPageMovable under page_lock if you</span>
<span class="p_add">+migrated the oldpage successfully and returns 0.</span>
<span class="p_add">+If driver cannot migrate the page at the moment, driver can return -EAGAIN.</span>
<span class="p_add">+On -EAGAIN, VM will retry page migration in a short time because VM interprets</span>
<span class="p_add">+-EAGAIN as &quot;temporal migration failure&quot;. On returning any error except -EAGAIN,</span>
<span class="p_add">+VM will give up the page migration without retrying in this time.</span>
<span class="p_add">+</span>
<span class="p_add">+Driver shouldn&#39;t touch page.lru field VM using in the functions.</span>
<span class="p_add">+</span>
<span class="p_add">+3. void (*putback_page)(struct page *);</span>
<span class="p_add">+</span>
<span class="p_add">+If migration fails on isolated page, VM should return the isolated page</span>
<span class="p_add">+to the driver so VM calls driver&#39;s putback_page with migration failed page.</span>
<span class="p_add">+In this function, driver should put the isolated page back to the own data</span>
<span class="p_add">+structure.</span>
 
<span class="p_add">+4. non-lru movable page flags</span>
<span class="p_add">+</span>
<span class="p_add">+There are two page flags for supporting non-lru movable page.</span>
<span class="p_add">+</span>
<span class="p_add">+* PG_movable</span>
<span class="p_add">+</span>
<span class="p_add">+Driver should use the below function to make page movable under page_lock.</span>
<span class="p_add">+</span>
<span class="p_add">+	void __SetPageMovable(struct page *page, struct address_space *mapping)</span>
<span class="p_add">+</span>
<span class="p_add">+It needs argument of address_space for registering migration family functions</span>
<span class="p_add">+which will be called by VM. Exactly speaking, PG_movable is not a real flag of</span>
<span class="p_add">+struct page. Rather than, VM reuses page-&gt;mapping&#39;s lower bits to represent it.</span>
<span class="p_add">+</span>
<span class="p_add">+	#define PAGE_MAPPING_MOVABLE 0x2</span>
<span class="p_add">+	page-&gt;mapping = page-&gt;mapping | PAGE_MAPPING_MOVABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+so driver shouldn&#39;t access page-&gt;mapping directly. Instead, driver should</span>
<span class="p_add">+use page_mapping which mask off the low two bits of page-&gt;mapping so it can get</span>
<span class="p_add">+right struct address_space.</span>
<span class="p_add">+</span>
<span class="p_add">+For testing of non-lru movable page, VM supports __PageMovable function.</span>
<span class="p_add">+However, it doesn&#39;t guarantee to identify non-lru movable page because</span>
<span class="p_add">+page-&gt;mapping field is unified with other variables in struct page.</span>
<span class="p_add">+As well, if driver releases the page after isolation by VM, page-&gt;mapping</span>
<span class="p_add">+doesn&#39;t have stable value although it has PAGE_MAPPING_MOVABLE</span>
<span class="p_add">+(Look at __ClearPageMovable). But __PageMovable is cheap to catch whether</span>
<span class="p_add">+page is LRU or non-lru movable once the page has been isolated. Because</span>
<span class="p_add">+LRU pages never can have PAGE_MAPPING_MOVABLE in page-&gt;mapping. It is also</span>
<span class="p_add">+good for just peeking to test non-lru movable pages before more expensive</span>
<span class="p_add">+checking with lock_page in pfn scanning to select victim.</span>
<span class="p_add">+</span>
<span class="p_add">+For guaranteeing non-lru movable page, VM provides PageMovable function.</span>
<span class="p_add">+Unlike __PageMovable, PageMovable functions validates page-&gt;mapping and</span>
<span class="p_add">+mapping-&gt;a_ops-&gt;isolate_page under lock_page. The lock_page prevents sudden</span>
<span class="p_add">+destroying of page-&gt;mapping.</span>
<span class="p_add">+</span>
<span class="p_add">+Driver using __SetPageMovable should clear the flag via __ClearMovablePage</span>
<span class="p_add">+under page_lock before the releasing the page.</span>
<span class="p_add">+</span>
<span class="p_add">+* PG_isolated</span>
<span class="p_add">+</span>
<span class="p_add">+To prevent concurrent isolation among several CPUs, VM marks isolated page</span>
<span class="p_add">+as PG_isolated under lock_page. So if a CPU encounters PG_isolated non-lru</span>
<span class="p_add">+movable page, it can skip it. Driver doesn&#39;t need to manipulate the flag</span>
<span class="p_add">+because VM will set/clear it automatically. Keep in mind that if driver</span>
<span class="p_add">+sees PG_isolated page, it means the page have been isolated by VM so it</span>
<span class="p_add">+shouldn&#39;t touch page.lru field.</span>
<span class="p_add">+PG_isolated is alias with PG_reclaim flag so driver shouldn&#39;t use the flag</span>
<span class="p_add">+for own purpose.</span>
<span class="p_add">+</span>
<span class="p_add">+Christoph Lameter, May 8, 2006.</span>
<span class="p_add">+Minchan Kim, Mar 28, 2016.</span>
<span class="p_header">diff --git a/include/linux/compaction.h b/include/linux/compaction.h</span>
<span class="p_header">index a58c852a268f..c6b47c861cea 100644</span>
<span class="p_header">--- a/include/linux/compaction.h</span>
<span class="p_header">+++ b/include/linux/compaction.h</span>
<span class="p_chunk">@@ -54,6 +54,9 @@</span> <span class="p_context"> enum compact_result {</span>
 struct alloc_context; /* in mm/internal.h */
 
 #ifdef CONFIG_COMPACTION
<span class="p_add">+extern int PageMovable(struct page *page);</span>
<span class="p_add">+extern void __SetPageMovable(struct page *page, struct address_space *mapping);</span>
<span class="p_add">+extern void __ClearPageMovable(struct page *page);</span>
 extern int sysctl_compact_memory;
 extern int sysctl_compaction_handler(struct ctl_table *table, int write,
 			void __user *buffer, size_t *length, loff_t *ppos);
<span class="p_chunk">@@ -151,6 +154,19 @@</span> <span class="p_context"> extern void kcompactd_stop(int nid);</span>
 extern void wakeup_kcompactd(pg_data_t *pgdat, int order, int classzone_idx);
 
 #else
<span class="p_add">+static inline int PageMovable(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void __SetPageMovable(struct page *page,</span>
<span class="p_add">+			struct address_space *mapping)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __ClearPageMovable(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline enum compact_result try_to_compact_pages(gfp_t gfp_mask,
 			unsigned int order, int alloc_flags,
 			const struct alloc_context *ac,
<span class="p_chunk">@@ -212,6 +228,7 @@</span> <span class="p_context"> static inline void wakeup_kcompactd(pg_data_t *pgdat, int order, int classzone_i</span>
 #endif /* CONFIG_COMPACTION */
 
 #if defined(CONFIG_COMPACTION) &amp;&amp; defined(CONFIG_SYSFS) &amp;&amp; defined(CONFIG_NUMA)
<span class="p_add">+struct node;</span>
 extern int compaction_register_node(struct node *node);
 extern void compaction_unregister_node(struct node *node);
 
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index c9cc1f699dc1..6a2ce439ea42 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -402,6 +402,8 @@</span> <span class="p_context"> struct address_space_operations {</span>
 	 */
 	int (*migratepage) (struct address_space *,
 			struct page *, struct page *, enum migrate_mode);
<span class="p_add">+	bool (*isolate_page)(struct page *, isolate_mode_t);</span>
<span class="p_add">+	void (*putback_page)(struct page *);</span>
 	int (*launder_page) (struct page *);
 	int (*is_partially_uptodate) (struct page *, unsigned long,
 					unsigned long);
<span class="p_header">diff --git a/include/linux/ksm.h b/include/linux/ksm.h</span>
<span class="p_header">index 7ae216a39c9e..481c8c4627ca 100644</span>
<span class="p_header">--- a/include/linux/ksm.h</span>
<span class="p_header">+++ b/include/linux/ksm.h</span>
<span class="p_chunk">@@ -43,8 +43,7 @@</span> <span class="p_context"> static inline struct stable_node *page_stable_node(struct page *page)</span>
 static inline void set_page_stable_node(struct page *page,
 					struct stable_node *stable_node)
 {
<span class="p_del">-	page-&gt;mapping = (void *)stable_node +</span>
<span class="p_del">-				(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM);</span>
<span class="p_add">+	page-&gt;mapping = (void *)((unsigned long)stable_node | PAGE_MAPPING_KSM);</span>
 }
 
 /*
<span class="p_header">diff --git a/include/linux/migrate.h b/include/linux/migrate.h</span>
<span class="p_header">index 9b50325e4ddf..404fbfefeb33 100644</span>
<span class="p_header">--- a/include/linux/migrate.h</span>
<span class="p_header">+++ b/include/linux/migrate.h</span>
<span class="p_chunk">@@ -37,6 +37,8 @@</span> <span class="p_context"> extern int migrate_page(struct address_space *,</span>
 			struct page *, struct page *, enum migrate_mode);
 extern int migrate_pages(struct list_head *l, new_page_t new, free_page_t free,
 		unsigned long private, enum migrate_mode mode, int reason);
<span class="p_add">+extern bool isolate_movable_page(struct page *page, isolate_mode_t mode);</span>
<span class="p_add">+extern void putback_movable_page(struct page *page);</span>
 
 extern int migrate_prep(void);
 extern int migrate_prep_local(void);
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index a00ec816233a..33eaec57e997 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1035,6 +1035,7 @@</span> <span class="p_context"> static inline pgoff_t page_file_index(struct page *page)</span>
 }
 
 bool page_mapped(struct page *page);
<span class="p_add">+struct address_space *page_mapping(struct page *page);</span>
 
 /*
  * Return true only if the page has been allocated with
<span class="p_header">diff --git a/include/linux/page-flags.h b/include/linux/page-flags.h</span>
<span class="p_header">index e5a32445f930..f8a2c4881608 100644</span>
<span class="p_header">--- a/include/linux/page-flags.h</span>
<span class="p_header">+++ b/include/linux/page-flags.h</span>
<span class="p_chunk">@@ -129,6 +129,9 @@</span> <span class="p_context"> enum pageflags {</span>
 
 	/* Compound pages. Stored in first tail page&#39;s flags */
 	PG_double_map = PG_private_2,
<span class="p_add">+</span>
<span class="p_add">+	/* non-lru isolated movable page */</span>
<span class="p_add">+	PG_isolated = PG_reclaim,</span>
 };
 
 #ifndef __GENERATING_BOUNDS_H
<span class="p_chunk">@@ -357,29 +360,37 @@</span> <span class="p_context"> PAGEFLAG(Idle, idle, PF_ANY)</span>
  * with the PAGE_MAPPING_ANON bit set to distinguish it.  See rmap.h.
  *
  * On an anonymous page in a VM_MERGEABLE area, if CONFIG_KSM is enabled,
<span class="p_del">- * the PAGE_MAPPING_KSM bit may be set along with the PAGE_MAPPING_ANON bit;</span>
<span class="p_del">- * and then page-&gt;mapping points, not to an anon_vma, but to a private</span>
<span class="p_add">+ * the PAGE_MAPPING_MOVABLE bit may be set along with the PAGE_MAPPING_ANON</span>
<span class="p_add">+ * bit; and then page-&gt;mapping points, not to an anon_vma, but to a private</span>
  * structure which KSM associates with that merged page.  See ksm.h.
  *
<span class="p_del">- * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is currently never used.</span>
<span class="p_add">+ * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is used for non-lru movable</span>
<span class="p_add">+ * page and then page-&gt;mapping points a struct address_space.</span>
  *
  * Please note that, confusingly, &quot;page_mapping&quot; refers to the inode
  * address_space which maps the page from disk; whereas &quot;page_mapped&quot;
  * refers to user virtual address space into which the page is mapped.
  */
<span class="p_del">-#define PAGE_MAPPING_ANON	1</span>
<span class="p_del">-#define PAGE_MAPPING_KSM	2</span>
<span class="p_del">-#define PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM)</span>
<span class="p_add">+#define PAGE_MAPPING_ANON	0x1</span>
<span class="p_add">+#define PAGE_MAPPING_MOVABLE	0x2</span>
<span class="p_add">+#define PAGE_MAPPING_KSM	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span>
<span class="p_add">+#define PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)</span>
 
<span class="p_del">-static __always_inline int PageAnonHead(struct page *page)</span>
<span class="p_add">+static __always_inline int PageMappingFlag(struct page *page)</span>
 {
<span class="p_del">-	return ((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_ANON) != 0;</span>
<span class="p_add">+	return ((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS) != 0;</span>
 }
 
 static __always_inline int PageAnon(struct page *page)
 {
 	page = compound_head(page);
<span class="p_del">-	return PageAnonHead(page);</span>
<span class="p_add">+	return ((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_ANON) != 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static __always_inline int __PageMovable(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS) ==</span>
<span class="p_add">+				PAGE_MAPPING_MOVABLE;</span>
 }
 
 #ifdef CONFIG_KSM
<span class="p_chunk">@@ -393,7 +404,7 @@</span> <span class="p_context"> static __always_inline int PageKsm(struct page *page)</span>
 {
 	page = compound_head(page);
 	return ((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS) ==
<span class="p_del">-				(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM);</span>
<span class="p_add">+				PAGE_MAPPING_KSM;</span>
 }
 #else
 TESTPAGEFLAG_FALSE(Ksm)
<span class="p_chunk">@@ -641,6 +652,8 @@</span> <span class="p_context"> static inline void __ClearPageBalloon(struct page *page)</span>
 	atomic_set(&amp;page-&gt;_mapcount, -1);
 }
 
<span class="p_add">+__PAGEFLAG(Isolated, isolated, PF_ANY);</span>
<span class="p_add">+</span>
 /*
  * If network-based swap is enabled, sl*b must keep track of whether pages
  * were allocated from pfmemalloc reserves.
<span class="p_header">diff --git a/mm/compaction.c b/mm/compaction.c</span>
<span class="p_header">index 1427366ad673..2d6862d0df60 100644</span>
<span class="p_header">--- a/mm/compaction.c</span>
<span class="p_header">+++ b/mm/compaction.c</span>
<span class="p_chunk">@@ -81,6 +81,41 @@</span> <span class="p_context"> static inline bool migrate_async_suitable(int migratetype)</span>
 
 #ifdef CONFIG_COMPACTION
 
<span class="p_add">+int PageMovable(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct address_space *mapping;</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(!PageLocked(page));</span>
<span class="p_add">+	if (!__PageMovable(page))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	mapping = page_mapping(page);</span>
<span class="p_add">+	if (mapping &amp;&amp; mapping-&gt;a_ops &amp;&amp; mapping-&gt;a_ops-&gt;isolate_page)</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(PageMovable);</span>
<span class="p_add">+</span>
<span class="p_add">+void __SetPageMovable(struct page *page, struct address_space *mapping)</span>
<span class="p_add">+{</span>
<span class="p_add">+	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="p_add">+	VM_BUG_ON_PAGE((unsigned long)mapping &amp; PAGE_MAPPING_MOVABLE, page);</span>
<span class="p_add">+	page-&gt;mapping = (void *)((unsigned long)mapping | PAGE_MAPPING_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(__SetPageMovable);</span>
<span class="p_add">+</span>
<span class="p_add">+void __ClearPageMovable(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="p_add">+	VM_BUG_ON_PAGE(!PageMovable(page), page);</span>
<span class="p_add">+	VM_BUG_ON_PAGE(!((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_MOVABLE),</span>
<span class="p_add">+				page);</span>
<span class="p_add">+	page-&gt;mapping = (void *)((unsigned long)page-&gt;mapping &amp;</span>
<span class="p_add">+				PAGE_MAPPING_MOVABLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(__ClearPageMovable);</span>
<span class="p_add">+</span>
 /* Do not skip compaction more than 64 times */
 #define COMPACT_MAX_DEFER_SHIFT 6
 
<span class="p_chunk">@@ -735,21 +770,6 @@</span> <span class="p_context"> isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,</span>
 		}
 
 		/*
<span class="p_del">-		 * Check may be lockless but that&#39;s ok as we recheck later.</span>
<span class="p_del">-		 * It&#39;s possible to migrate LRU pages and balloon pages</span>
<span class="p_del">-		 * Skip any other type of page</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		is_lru = PageLRU(page);</span>
<span class="p_del">-		if (!is_lru) {</span>
<span class="p_del">-			if (unlikely(balloon_page_movable(page))) {</span>
<span class="p_del">-				if (balloon_page_isolate(page)) {</span>
<span class="p_del">-					/* Successfully isolated */</span>
<span class="p_del">-					goto isolate_success;</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
 		 * Regardless of being on LRU, compound pages such as THP and
 		 * hugetlbfs are not to be compacted. We can potentially save
 		 * a lot of iterations if we skip them at once. The check is
<span class="p_chunk">@@ -765,8 +785,38 @@</span> <span class="p_context"> isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,</span>
 			goto isolate_fail;
 		}
 
<span class="p_del">-		if (!is_lru)</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Check may be lockless but that&#39;s ok as we recheck later.</span>
<span class="p_add">+		 * It&#39;s possible to migrate LRU and non-lru movable pages.</span>
<span class="p_add">+		 * Skip any other type of page</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		is_lru = PageLRU(page);</span>
<span class="p_add">+		if (!is_lru) {</span>
<span class="p_add">+			if (unlikely(balloon_page_movable(page))) {</span>
<span class="p_add">+				if (balloon_page_isolate(page)) {</span>
<span class="p_add">+					/* Successfully isolated */</span>
<span class="p_add">+					goto isolate_success;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * __PageMovable can return false positive so we need</span>
<span class="p_add">+			 * to verify it under page_lock.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (unlikely(__PageMovable(page)) &amp;&amp;</span>
<span class="p_add">+					!PageIsolated(page)) {</span>
<span class="p_add">+				if (locked) {</span>
<span class="p_add">+					spin_unlock_irqrestore(&amp;zone-&gt;lru_lock,</span>
<span class="p_add">+									flags);</span>
<span class="p_add">+					locked = false;</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				if (isolate_movable_page(page, isolate_mode))</span>
<span class="p_add">+					goto isolate_success;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			goto isolate_fail;
<span class="p_add">+		}</span>
 
 		/*
 		 * Migration will fail if an anonymous page is pinned in memory,
<span class="p_header">diff --git a/mm/ksm.c b/mm/ksm.c</span>
<span class="p_header">index 4786b4150f62..35b8aef867a9 100644</span>
<span class="p_header">--- a/mm/ksm.c</span>
<span class="p_header">+++ b/mm/ksm.c</span>
<span class="p_chunk">@@ -532,8 +532,8 @@</span> <span class="p_context"> static struct page *get_ksm_page(struct stable_node *stable_node, bool lock_it)</span>
 	void *expected_mapping;
 	unsigned long kpfn;
 
<span class="p_del">-	expected_mapping = (void *)stable_node +</span>
<span class="p_del">-				(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM);</span>
<span class="p_add">+	expected_mapping = (void *)((unsigned long)stable_node |</span>
<span class="p_add">+					PAGE_MAPPING_KSM);</span>
 again:
 	kpfn = READ_ONCE(stable_node-&gt;kpfn);
 	page = pfn_to_page(kpfn);
<span class="p_header">diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="p_header">index 2666f28b5236..57559ca7c904 100644</span>
<span class="p_header">--- a/mm/migrate.c</span>
<span class="p_header">+++ b/mm/migrate.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/security.h&gt;
 #include &lt;linux/backing-dev.h&gt;
<span class="p_add">+#include &lt;linux/compaction.h&gt;</span>
 #include &lt;linux/syscalls.h&gt;
 #include &lt;linux/hugetlb.h&gt;
 #include &lt;linux/hugetlb_cgroup.h&gt;
<span class="p_chunk">@@ -73,6 +74,79 @@</span> <span class="p_context"> int migrate_prep_local(void)</span>
 	return 0;
 }
 
<span class="p_add">+bool isolate_movable_page(struct page *page, isolate_mode_t mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct address_space *mapping;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Avoid burning cycles with pages that are yet under __free_pages(),</span>
<span class="p_add">+	 * or just got freed under us.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * In case we &#39;win&#39; a race for a movable page being freed under us and</span>
<span class="p_add">+	 * raise its refcount preventing __free_pages() from doing its job</span>
<span class="p_add">+	 * the put_page() at the end of this block will take care of</span>
<span class="p_add">+	 * release this page, thus avoiding a nasty leakage.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(!get_page_unless_zero(page)))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check PageMovable before holding a PG_lock because page&#39;s owner</span>
<span class="p_add">+	 * assumes anybody doesn&#39;t touch PG_lock of newly allocated page</span>
<span class="p_add">+	 * so unconditionally grapping the lock ruins page&#39;s owner side.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(!__PageMovable(page)))</span>
<span class="p_add">+		goto out_putpage;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * As movable pages are not isolated from LRU lists, concurrent</span>
<span class="p_add">+	 * compaction threads can race against page migration functions</span>
<span class="p_add">+	 * as well as race against the releasing a page.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * In order to avoid having an already isolated movable page</span>
<span class="p_add">+	 * being (wrongly) re-isolated while it is under migration,</span>
<span class="p_add">+	 * or to avoid attempting to isolate pages being released,</span>
<span class="p_add">+	 * lets be sure we have the page lock</span>
<span class="p_add">+	 * before proceeding with the movable page isolation steps.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(!trylock_page(page)))</span>
<span class="p_add">+		goto out_putpage;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!PageMovable(page) || PageIsolated(page))</span>
<span class="p_add">+		goto out_no_isolated;</span>
<span class="p_add">+</span>
<span class="p_add">+	mapping = page_mapping(page);</span>
<span class="p_add">+	if (!mapping-&gt;a_ops-&gt;isolate_page(page, mode))</span>
<span class="p_add">+		goto out_no_isolated;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Driver shouldn&#39;t use PG_isolated bit of page-&gt;flags */</span>
<span class="p_add">+	WARN_ON_ONCE(PageIsolated(page));</span>
<span class="p_add">+	__SetPageIsolated(page);</span>
<span class="p_add">+	unlock_page(page);</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+</span>
<span class="p_add">+out_no_isolated:</span>
<span class="p_add">+	unlock_page(page);</span>
<span class="p_add">+out_putpage:</span>
<span class="p_add">+	put_page(page);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* It should be called on page which is PG_movable */</span>
<span class="p_add">+void putback_movable_page(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct address_space *mapping;</span>
<span class="p_add">+</span>
<span class="p_add">+	VM_BUG_ON_PAGE(!PageLocked(page), page);</span>
<span class="p_add">+	VM_BUG_ON_PAGE(!PageMovable(page), page);</span>
<span class="p_add">+	VM_BUG_ON_PAGE(!PageIsolated(page), page);</span>
<span class="p_add">+</span>
<span class="p_add">+	mapping = page_mapping(page);</span>
<span class="p_add">+	mapping-&gt;a_ops-&gt;putback_page(page);</span>
<span class="p_add">+	__ClearPageIsolated(page);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Put previously isolated pages back onto the appropriate lists
  * from where they were once taken off for compaction/migration.
<span class="p_chunk">@@ -94,10 +168,25 @@</span> <span class="p_context"> void putback_movable_pages(struct list_head *l)</span>
 		list_del(&amp;page-&gt;lru);
 		dec_zone_page_state(page, NR_ISOLATED_ANON +
 				page_is_file_cache(page));
<span class="p_del">-		if (unlikely(isolated_balloon_page(page)))</span>
<span class="p_add">+		if (unlikely(isolated_balloon_page(page))) {</span>
 			balloon_page_putback(page);
<span class="p_del">-		else</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We isolated non-lru movable page so here we can use</span>
<span class="p_add">+		 * __PageMovable because LRU page&#39;s mapping cannot have</span>
<span class="p_add">+		 * PAGE_MAPPING_MOVABLE.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		} else if (unlikely(__PageMovable(page))) {</span>
<span class="p_add">+			VM_BUG_ON_PAGE(!PageIsolated(page), page);</span>
<span class="p_add">+			lock_page(page);</span>
<span class="p_add">+			if (PageMovable(page))</span>
<span class="p_add">+				putback_movable_page(page);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				__ClearPageIsolated(page);</span>
<span class="p_add">+			unlock_page(page);</span>
<span class="p_add">+			put_page(page);</span>
<span class="p_add">+		} else {</span>
 			putback_lru_page(page);
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -592,7 +681,7 @@</span> <span class="p_context"> void migrate_page_copy(struct page *newpage, struct page *page)</span>
  ***********************************************************/
 
 /*
<span class="p_del">- * Common logic to directly migrate a single page suitable for</span>
<span class="p_add">+ * Common logic to directly migrate a single LRU page suitable for</span>
  * pages that do not use PagePrivate/PagePrivate2.
  *
  * Pages are locked upon entry and exit.
<span class="p_chunk">@@ -755,33 +844,69 @@</span> <span class="p_context"> static int move_to_new_page(struct page *newpage, struct page *page,</span>
 				enum migrate_mode mode)
 {
 	struct address_space *mapping;
<span class="p_del">-	int rc;</span>
<span class="p_add">+	int rc = -EAGAIN;</span>
<span class="p_add">+	bool is_lru = !__PageMovable(page);</span>
 
 	VM_BUG_ON_PAGE(!PageLocked(page), page);
 	VM_BUG_ON_PAGE(!PageLocked(newpage), newpage);
 
 	mapping = page_mapping(page);
<span class="p_del">-	if (!mapping)</span>
<span class="p_del">-		rc = migrate_page(mapping, newpage, page, mode);</span>
<span class="p_del">-	else if (mapping-&gt;a_ops-&gt;migratepage)</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Most pages have a mapping and most filesystems provide a</span>
<span class="p_del">-		 * migratepage callback. Anonymous pages are part of swap</span>
<span class="p_del">-		 * space which also has its own migratepage callback. This</span>
<span class="p_del">-		 * is the most common path for page migration.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage, page, mode);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		rc = fallback_migrate_page(mapping, newpage, page, mode);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case of non-lru page, it could be released after</span>
<span class="p_add">+	 * isolation step. In that case, we shouldn&#39;t try</span>
<span class="p_add">+	 * fallback migration which is designed for LRU pages.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(!is_lru)) {</span>
<span class="p_add">+		VM_BUG_ON_PAGE(!PageIsolated(page), page);</span>
<span class="p_add">+		if (!PageMovable(page)) {</span>
<span class="p_add">+			rc = MIGRATEPAGE_SUCCESS;</span>
<span class="p_add">+			__ClearPageIsolated(page);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(is_lru)) {</span>
<span class="p_add">+		if (!mapping)</span>
<span class="p_add">+			rc = migrate_page(mapping, newpage, page, mode);</span>
<span class="p_add">+		else if (mapping-&gt;a_ops-&gt;migratepage)</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Most pages have a mapping and most filesystems</span>
<span class="p_add">+			 * provide a migratepage callback. Anonymous pages</span>
<span class="p_add">+			 * are part of swap space which also has its own</span>
<span class="p_add">+			 * migratepage callback. This is the most common path</span>
<span class="p_add">+			 * for page migration.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage,</span>
<span class="p_add">+							page, mode);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			rc = fallback_migrate_page(mapping, newpage,</span>
<span class="p_add">+							page, mode);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		rc = mapping-&gt;a_ops-&gt;migratepage(mapping, newpage,</span>
<span class="p_add">+						page, mode);</span>
<span class="p_add">+		WARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &amp;&amp;</span>
<span class="p_add">+			!PageIsolated(page));</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * When successful, old pagecache page-&gt;mapping must be cleared before
 	 * page is freed; but stats require that PageAnon be left as PageAnon.
 	 */
 	if (rc == MIGRATEPAGE_SUCCESS) {
<span class="p_del">-		if (!PageAnon(page))</span>
<span class="p_add">+		if (__PageMovable(page)) {</span>
<span class="p_add">+			VM_BUG_ON_PAGE(!PageIsolated(page), page);</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We clear PG_movable under page_lock so any compactor</span>
<span class="p_add">+			 * cannot try to migrate this page.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			__ClearPageIsolated(page);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!((unsigned long)page-&gt;mapping &amp; PAGE_MAPPING_FLAGS))</span>
 			page-&gt;mapping = NULL;
 	}
<span class="p_add">+out:</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -791,6 +916,7 @@</span> <span class="p_context"> static int __unmap_and_move(struct page *page, struct page *newpage,</span>
 	int rc = -EAGAIN;
 	int page_was_mapped = 0;
 	struct anon_vma *anon_vma = NULL;
<span class="p_add">+	bool is_lru = !__PageMovable(page);</span>
 
 	if (!trylock_page(page)) {
 		if (!force || mode == MIGRATE_ASYNC)
<span class="p_chunk">@@ -871,6 +997,11 @@</span> <span class="p_context"> static int __unmap_and_move(struct page *page, struct page *newpage,</span>
 		goto out_unlock_both;
 	}
 
<span class="p_add">+	if (unlikely(!is_lru)) {</span>
<span class="p_add">+		rc = move_to_new_page(newpage, page, mode);</span>
<span class="p_add">+		goto out_unlock_both;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Corner case handling:
 	 * 1. When a new swap-cache page is read into, it is added to the LRU
<span class="p_chunk">@@ -920,7 +1051,8 @@</span> <span class="p_context"> static int __unmap_and_move(struct page *page, struct page *newpage,</span>
 	 * list in here.
 	 */
 	if (rc == MIGRATEPAGE_SUCCESS) {
<span class="p_del">-		if (unlikely(__is_movable_balloon_page(newpage)))</span>
<span class="p_add">+		if (unlikely(__is_movable_balloon_page(newpage) ||</span>
<span class="p_add">+				__PageMovable(newpage)))</span>
 			put_page(newpage);
 		else
 			putback_lru_page(newpage);
<span class="p_chunk">@@ -961,6 +1093,12 @@</span> <span class="p_context"> static ICE_noinline int unmap_and_move(new_page_t get_new_page,</span>
 		/* page was freed from under us. So we are done. */
 		ClearPageActive(page);
 		ClearPageUnevictable(page);
<span class="p_add">+		if (unlikely(__PageMovable(page))) {</span>
<span class="p_add">+			lock_page(page);</span>
<span class="p_add">+			if (!PageMovable(page))</span>
<span class="p_add">+				__ClearPageIsolated(page);</span>
<span class="p_add">+			unlock_page(page);</span>
<span class="p_add">+		}</span>
 		if (put_new_page)
 			put_new_page(newpage, private);
 		else
<span class="p_chunk">@@ -1010,8 +1148,21 @@</span> <span class="p_context"> static ICE_noinline int unmap_and_move(new_page_t get_new_page,</span>
 				num_poisoned_pages_inc();
 		}
 	} else {
<span class="p_del">-		if (rc != -EAGAIN)</span>
<span class="p_del">-			putback_lru_page(page);</span>
<span class="p_add">+		if (rc != -EAGAIN) {</span>
<span class="p_add">+			if (likely(!__PageMovable(page))) {</span>
<span class="p_add">+				putback_lru_page(page);</span>
<span class="p_add">+				goto put_new;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			lock_page(page);</span>
<span class="p_add">+			if (PageMovable(page))</span>
<span class="p_add">+				putback_movable_page(page);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				__ClearPageIsolated(page);</span>
<span class="p_add">+			unlock_page(page);</span>
<span class="p_add">+			put_page(page);</span>
<span class="p_add">+		}</span>
<span class="p_add">+put_new:</span>
 		if (put_new_page)
 			put_new_page(newpage, private);
 		else
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index f8f3bfc435ee..26868bbaecce 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -1008,7 +1008,7 @@</span> <span class="p_context"> static __always_inline bool free_pages_prepare(struct page *page,</span>
 			(page + i)-&gt;flags &amp;= ~PAGE_FLAGS_CHECK_AT_PREP;
 		}
 	}
<span class="p_del">-	if (PageAnonHead(page))</span>
<span class="p_add">+	if (PageMappingFlag(page))</span>
 		page-&gt;mapping = NULL;
 	if (check_free)
 		bad += free_pages_check(page);
<span class="p_header">diff --git a/mm/util.c b/mm/util.c</span>
<span class="p_header">index 224d36e43a94..a04ccff7cc17 100644</span>
<span class="p_header">--- a/mm/util.c</span>
<span class="p_header">+++ b/mm/util.c</span>
<span class="p_chunk">@@ -399,10 +399,12 @@</span> <span class="p_context"> struct address_space *page_mapping(struct page *page)</span>
 	}
 
 	mapping = page-&gt;mapping;
<span class="p_del">-	if ((unsigned long)mapping &amp; PAGE_MAPPING_FLAGS)</span>
<span class="p_add">+	if ((unsigned long)mapping &amp; PAGE_MAPPING_ANON)</span>
 		return NULL;
<span class="p_del">-	return mapping;</span>
<span class="p_add">+</span>
<span class="p_add">+	return (void *)((unsigned long)mapping &amp; ~PAGE_MAPPING_FLAGS);</span>
 }
<span class="p_add">+EXPORT_SYMBOL(page_mapping);</span>
 
 /* Slow path of page_mapcount() for compound pages */
 int __page_mapcount(struct page *page)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



