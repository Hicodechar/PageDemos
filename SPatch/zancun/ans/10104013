
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.68 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.68</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 10, 2017, 9:28 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171210212850.GB19111@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10104013/mbox/"
   >mbox</a>
|
   <a href="/patch/10104013/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10104013/">/patch/10104013/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	56EDA602D8 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 10 Dec 2017 21:29:11 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2A8B12928E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 10 Dec 2017 21:29:11 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1AEDF29298; Sun, 10 Dec 2017 21:29:11 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8C2612928E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 10 Dec 2017 21:29:05 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752605AbdLJV3A (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 10 Dec 2017 16:29:00 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:36418 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751137AbdLJV2o (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 10 Dec 2017 16:28:44 -0500
Received: from localhost (LFbn-1-714-204.w86-246.abo.wanadoo.fr
	[86.246.189.204])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 622E0927;
	Sun, 10 Dec 2017 21:28:43 +0000 (UTC)
Date: Sun, 10 Dec 2017 22:28:50 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.68
Message-ID: &lt;20171210212850.GB19111@kroah.com&gt;
References: &lt;20171210212845.GA19111@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171210212845.GA19111@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 10, 2017, 9:28 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 70546af61a0a..dfe17af517b2 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 67</span>
<span class="p_add">+SUBLEVEL = 68</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/mach-omap1/dma.c b/arch/arm/mach-omap1/dma.c</span>
<span class="p_header">index f6ba589cd312..c821c1d5610e 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap1/dma.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap1/dma.c</span>
<span class="p_chunk">@@ -32,7 +32,6 @@</span> <span class="p_context"></span>
 #include &quot;soc.h&quot;
 
 #define OMAP1_DMA_BASE			(0xfffed800)
<span class="p_del">-#define OMAP1_LOGICAL_DMA_CH_COUNT	17</span>
 
 static u32 enable_1510_mode;
 
<span class="p_chunk">@@ -348,8 +347,6 @@</span> <span class="p_context"> static int __init omap1_system_dma_init(void)</span>
 		goto exit_iounmap;
 	}
 
<span class="p_del">-	d-&gt;lch_count		= OMAP1_LOGICAL_DMA_CH_COUNT;</span>
<span class="p_del">-</span>
 	/* Valid attributes for omap1 plus processors */
 	if (cpu_is_omap15xx())
 		d-&gt;dev_caps = ENABLE_1510_MODE;
<span class="p_chunk">@@ -366,13 +363,14 @@</span> <span class="p_context"> static int __init omap1_system_dma_init(void)</span>
 	d-&gt;dev_caps		|= CLEAR_CSR_ON_READ;
 	d-&gt;dev_caps		|= IS_WORD_16;
 
<span class="p_del">-	if (cpu_is_omap15xx())</span>
<span class="p_del">-		d-&gt;chan_count = 9;</span>
<span class="p_del">-	else if (cpu_is_omap16xx() || cpu_is_omap7xx()) {</span>
<span class="p_del">-		if (!(d-&gt;dev_caps &amp; ENABLE_1510_MODE))</span>
<span class="p_del">-			d-&gt;chan_count = 16;</span>
<span class="p_add">+	/* available logical channels */</span>
<span class="p_add">+	if (cpu_is_omap15xx()) {</span>
<span class="p_add">+		d-&gt;lch_count = 9;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (d-&gt;dev_caps &amp; ENABLE_1510_MODE)</span>
<span class="p_add">+			d-&gt;lch_count = 9;</span>
 		else
<span class="p_del">-			d-&gt;chan_count = 9;</span>
<span class="p_add">+			d-&gt;lch_count = 16;</span>
 	}
 
 	p = dma_plat_info;
<span class="p_header">diff --git a/arch/arm/mach-omap2/pdata-quirks.c b/arch/arm/mach-omap2/pdata-quirks.c</span>
<span class="p_header">index da310bb779b9..88676fe9b119 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/pdata-quirks.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/pdata-quirks.c</span>
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> static struct ti_st_plat_data wilink_pdata = {</span>
 	.nshutdown_gpio = 137,
 	.dev_name = &quot;/dev/ttyO1&quot;,
 	.flow_cntrl = 1,
<span class="p_del">-	.baud_rate = 300000,</span>
<span class="p_add">+	.baud_rate = 3000000,</span>
 };
 
 static struct platform_device wl18xx_device = {
<span class="p_header">diff --git a/arch/m68k/mm/mcfmmu.c b/arch/m68k/mm/mcfmmu.c</span>
<span class="p_header">index 87131cd3bc8f..6d3a50446b21 100644</span>
<span class="p_header">--- a/arch/m68k/mm/mcfmmu.c</span>
<span class="p_header">+++ b/arch/m68k/mm/mcfmmu.c</span>
<span class="p_chunk">@@ -169,7 +169,7 @@</span> <span class="p_context"> void __init cf_bootmem_alloc(void)</span>
 	max_pfn = max_low_pfn = PFN_DOWN(_ramend);
 	high_memory = (void *)_ramend;
 
<span class="p_del">-	m68k_virt_to_node_shift = fls(_ramend - _rambase - 1) - 6;</span>
<span class="p_add">+	m68k_virt_to_node_shift = fls(_ramend - 1) - 6;</span>
 	module_fixup(NULL, __start_fixup, __stop_fixup);
 
 	/* setup bootmem data */
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/64/hash.h b/arch/powerpc/include/asm/book3s/64/hash.h</span>
<span class="p_header">index f61cad3de4e6..4c935f7504f7 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/64/hash.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/64/hash.h</span>
<span class="p_chunk">@@ -201,6 +201,10 @@</span> <span class="p_context"> extern int __meminit hash__vmemmap_create_mapping(unsigned long start,</span>
 					      unsigned long phys);
 extern void hash__vmemmap_remove_mapping(unsigned long start,
 				     unsigned long page_size);
<span class="p_add">+</span>
<span class="p_add">+int hash__create_section_mapping(unsigned long start, unsigned long end);</span>
<span class="p_add">+int hash__remove_section_mapping(unsigned long start, unsigned long end);</span>
<span class="p_add">+</span>
 #endif /* !__ASSEMBLY__ */
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_BOOK3S_64_HASH_H */
<span class="p_header">diff --git a/arch/powerpc/mm/hash_utils_64.c b/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_header">index 78dabf065ba9..bd666287c5ed 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_chunk">@@ -747,7 +747,7 @@</span> <span class="p_context"> static unsigned long __init htab_get_table_size(void)</span>
 }
 
 #ifdef CONFIG_MEMORY_HOTPLUG
<span class="p_del">-int create_section_mapping(unsigned long start, unsigned long end)</span>
<span class="p_add">+int hash__create_section_mapping(unsigned long start, unsigned long end)</span>
 {
 	int rc = htab_bolt_mapping(start, end, __pa(start),
 				   pgprot_val(PAGE_KERNEL), mmu_linear_psize,
<span class="p_chunk">@@ -761,7 +761,7 @@</span> <span class="p_context"> int create_section_mapping(unsigned long start, unsigned long end)</span>
 	return rc;
 }
 
<span class="p_del">-int remove_section_mapping(unsigned long start, unsigned long end)</span>
<span class="p_add">+int hash__remove_section_mapping(unsigned long start, unsigned long end)</span>
 {
 	int rc = htab_remove_mapping(start, end, mmu_linear_psize,
 				     mmu_kernel_ssize);
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable-book3s64.c b/arch/powerpc/mm/pgtable-book3s64.c</span>
<span class="p_header">index f4f437cbabf1..0fad7f6742ff 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable-book3s64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable-book3s64.c</span>
<span class="p_chunk">@@ -125,3 +125,21 @@</span> <span class="p_context"> void mmu_cleanup_all(void)</span>
 	else if (mmu_hash_ops.hpte_clear_all)
 		mmu_hash_ops.hpte_clear_all();
 }
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_MEMORY_HOTPLUG</span>
<span class="p_add">+int create_section_mapping(unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (radix_enabled())</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash__create_section_mapping(start, end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int remove_section_mapping(unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (radix_enabled())</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash__remove_section_mapping(start, end);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_MEMORY_HOTPLUG */</span>
<span class="p_header">diff --git a/arch/s390/include/asm/pci_insn.h b/arch/s390/include/asm/pci_insn.h</span>
<span class="p_header">index 649eb62c52b3..9e02cb7955c1 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pci_insn.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pci_insn.h</span>
<span class="p_chunk">@@ -81,6 +81,6 @@</span> <span class="p_context"> int zpci_refresh_trans(u64 fn, u64 addr, u64 range);</span>
 int zpci_load(u64 *data, u64 req, u64 offset);
 int zpci_store(u64 data, u64 req, u64 offset);
 int zpci_store_block(const u64 *data, u64 req, u64 offset);
<span class="p_del">-void zpci_set_irq_ctrl(u16 ctl, char *unused, u8 isc);</span>
<span class="p_add">+int zpci_set_irq_ctrl(u16 ctl, char *unused, u8 isc);</span>
 
 #endif
<span class="p_header">diff --git a/arch/s390/include/asm/runtime_instr.h b/arch/s390/include/asm/runtime_instr.h</span>
<span class="p_header">index 402ad6df4897..c54a9310d814 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/runtime_instr.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/runtime_instr.h</span>
<span class="p_chunk">@@ -85,6 +85,8 @@</span> <span class="p_context"> static inline void restore_ri_cb(struct runtime_instr_cb *cb_next,</span>
 		load_runtime_instr_cb(&amp;runtime_instr_empty_cb);
 }
 
<span class="p_del">-void exit_thread_runtime_instr(void);</span>
<span class="p_add">+struct task_struct;</span>
<span class="p_add">+</span>
<span class="p_add">+void runtime_instr_release(struct task_struct *tsk);</span>
 
 #endif /* _RUNTIME_INSTR_H */
<span class="p_header">diff --git a/arch/s390/kernel/process.c b/arch/s390/kernel/process.c</span>
<span class="p_header">index 172fe1121d99..8382fc62cde6 100644</span>
<span class="p_header">--- a/arch/s390/kernel/process.c</span>
<span class="p_header">+++ b/arch/s390/kernel/process.c</span>
<span class="p_chunk">@@ -70,8 +70,6 @@</span> <span class="p_context"> extern void kernel_thread_starter(void);</span>
  */
 void exit_thread(struct task_struct *tsk)
 {
<span class="p_del">-	if (tsk == current)</span>
<span class="p_del">-		exit_thread_runtime_instr();</span>
 }
 
 void flush_thread(void)
<span class="p_chunk">@@ -84,6 +82,7 @@</span> <span class="p_context"> void release_thread(struct task_struct *dead_task)</span>
 
 void arch_release_task_struct(struct task_struct *tsk)
 {
<span class="p_add">+	runtime_instr_release(tsk);</span>
 }
 
 int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
<span class="p_header">diff --git a/arch/s390/kernel/runtime_instr.c b/arch/s390/kernel/runtime_instr.c</span>
<span class="p_header">index 70cdb03d4acd..fd03a7569e10 100644</span>
<span class="p_header">--- a/arch/s390/kernel/runtime_instr.c</span>
<span class="p_header">+++ b/arch/s390/kernel/runtime_instr.c</span>
<span class="p_chunk">@@ -18,11 +18,24 @@</span> <span class="p_context"></span>
 /* empty control block to disable RI by loading it */
 struct runtime_instr_cb runtime_instr_empty_cb;
 
<span class="p_add">+void runtime_instr_release(struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kfree(tsk-&gt;thread.ri_cb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void disable_runtime_instr(void)
 {
<span class="p_del">-	struct pt_regs *regs = task_pt_regs(current);</span>
<span class="p_add">+	struct task_struct *task = current;</span>
<span class="p_add">+	struct pt_regs *regs;</span>
 
<span class="p_add">+	if (!task-&gt;thread.ri_cb)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	regs = task_pt_regs(task);</span>
<span class="p_add">+	preempt_disable();</span>
 	load_runtime_instr_cb(&amp;runtime_instr_empty_cb);
<span class="p_add">+	kfree(task-&gt;thread.ri_cb);</span>
<span class="p_add">+	task-&gt;thread.ri_cb = NULL;</span>
<span class="p_add">+	preempt_enable();</span>
 
 	/*
 	 * Make sure the RI bit is deleted from the PSW. If the user did not
<span class="p_chunk">@@ -43,19 +56,6 @@</span> <span class="p_context"> static void init_runtime_instr_cb(struct runtime_instr_cb *cb)</span>
 	cb-&gt;valid = 1;
 }
 
<span class="p_del">-void exit_thread_runtime_instr(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct task_struct *task = current;</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-	if (!task-&gt;thread.ri_cb)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	disable_runtime_instr();</span>
<span class="p_del">-	kfree(task-&gt;thread.ri_cb);</span>
<span class="p_del">-	task-&gt;thread.ri_cb = NULL;</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 SYSCALL_DEFINE1(s390_runtime_instr, int, command)
 {
 	struct runtime_instr_cb *cb;
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> SYSCALL_DEFINE1(s390_runtime_instr, int, command)</span>
 		return -EOPNOTSUPP;
 
 	if (command == S390_RUNTIME_INSTR_STOP) {
<span class="p_del">-		exit_thread_runtime_instr();</span>
<span class="p_add">+		disable_runtime_instr();</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.c</span>
<span class="p_header">index 15ffc19c8c0c..03a1d5976ff5 100644</span>
<span class="p_header">--- a/arch/s390/pci/pci.c</span>
<span class="p_header">+++ b/arch/s390/pci/pci.c</span>
<span class="p_chunk">@@ -354,7 +354,8 @@</span> <span class="p_context"> static void zpci_irq_handler(struct airq_struct *airq)</span>
 				/* End of second scan with interrupts on. */
 				break;
 			/* First scan complete, reenable interrupts. */
<span class="p_del">-			zpci_set_irq_ctrl(SIC_IRQ_MODE_SINGLE, NULL, PCI_ISC);</span>
<span class="p_add">+			if (zpci_set_irq_ctrl(SIC_IRQ_MODE_SINGLE, NULL, PCI_ISC))</span>
<span class="p_add">+				break;</span>
 			si = 0;
 			continue;
 		}
<span class="p_chunk">@@ -928,7 +929,7 @@</span> <span class="p_context"> static int __init pci_base_init(void)</span>
 	if (!s390_pci_probe)
 		return 0;
 
<span class="p_del">-	if (!test_facility(69) || !test_facility(71) || !test_facility(72))</span>
<span class="p_add">+	if (!test_facility(69) || !test_facility(71))</span>
 		return 0;
 
 	rc = zpci_debug_init();
<span class="p_header">diff --git a/arch/s390/pci/pci_insn.c b/arch/s390/pci/pci_insn.c</span>
<span class="p_header">index fa8d7d4b9751..248146dcfce3 100644</span>
<span class="p_header">--- a/arch/s390/pci/pci_insn.c</span>
<span class="p_header">+++ b/arch/s390/pci/pci_insn.c</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/export.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/delay.h&gt;
<span class="p_add">+#include &lt;asm/facility.h&gt;</span>
 #include &lt;asm/pci_insn.h&gt;
 #include &lt;asm/pci_debug.h&gt;
 #include &lt;asm/processor.h&gt;
<span class="p_chunk">@@ -91,11 +92,14 @@</span> <span class="p_context"> int zpci_refresh_trans(u64 fn, u64 addr, u64 range)</span>
 }
 
 /* Set Interruption Controls */
<span class="p_del">-void zpci_set_irq_ctrl(u16 ctl, char *unused, u8 isc)</span>
<span class="p_add">+int zpci_set_irq_ctrl(u16 ctl, char *unused, u8 isc)</span>
 {
<span class="p_add">+	if (!test_facility(72))</span>
<span class="p_add">+		return -EIO;</span>
 	asm volatile (
 		&quot;	.insn	rsy,0xeb00000000d1,%[ctl],%[isc],%[u]\n&quot;
 		: : [ctl] &quot;d&quot; (ctl), [isc] &quot;d&quot; (isc &lt;&lt; 27), [u] &quot;Q&quot; (*unused));
<span class="p_add">+	return 0;</span>
 }
 
 /* PCI Load */
<span class="p_header">diff --git a/arch/x86/events/intel/ds.c b/arch/x86/events/intel/ds.c</span>
<span class="p_header">index be202390bbd3..9dfeeeca0ea8 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/ds.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/ds.c</span>
<span class="p_chunk">@@ -1389,9 +1389,13 @@</span> <span class="p_context"> static void intel_pmu_drain_pebs_nhm(struct pt_regs *iregs)</span>
 			continue;
 
 		/* log dropped samples number */
<span class="p_del">-		if (error[bit])</span>
<span class="p_add">+		if (error[bit]) {</span>
 			perf_log_lost_samples(event, error[bit]);
 
<span class="p_add">+			if (perf_event_account_interrupt(event))</span>
<span class="p_add">+				x86_pmu_stop(event, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (counts[bit]) {
 			__intel_pmu_pebs_event(event, iregs, base,
 					       top, bit, counts[bit]);
<span class="p_header">diff --git a/arch/x86/include/asm/syscalls.h b/arch/x86/include/asm/syscalls.h</span>
<span class="p_header">index 91dfcafe27a6..bad25bb80679 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/syscalls.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/syscalls.h</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"> asmlinkage long sys_ioperm(unsigned long, unsigned long, int);</span>
 asmlinkage long sys_iopl(unsigned int);
 
 /* kernel/ldt.c */
<span class="p_del">-asmlinkage int sys_modify_ldt(int, void __user *, unsigned long);</span>
<span class="p_add">+asmlinkage long sys_modify_ldt(int, void __user *, unsigned long);</span>
 
 /* kernel/signal.c */
 asmlinkage long sys_rt_sigreturn(void);
<span class="p_header">diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c</span>
<span class="p_header">index 095ef7ddd6ae..abfbb61b18b8 100644</span>
<span class="p_header">--- a/arch/x86/kernel/fpu/xstate.c</span>
<span class="p_header">+++ b/arch/x86/kernel/fpu/xstate.c</span>
<span class="p_chunk">@@ -1077,6 +1077,7 @@</span> <span class="p_context"> int copyin_to_xsaves(const void *kbuf, const void __user *ubuf,</span>
 	 * Add back in the features that came in from userspace:
 	 */
 	xsave-&gt;header.xfeatures |= xfeatures;
<span class="p_add">+	xsave-&gt;header.xcomp_bv = XCOMP_BV_COMPACTED_FORMAT | xsave-&gt;header.xfeatures;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/x86/kernel/kprobes/ftrace.c b/arch/x86/kernel/kprobes/ftrace.c</span>
<span class="p_header">index 5f8f0b3cc674..2c0b0b645a74 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kprobes/ftrace.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kprobes/ftrace.c</span>
<span class="p_chunk">@@ -26,7 +26,7 @@</span> <span class="p_context"></span>
 #include &quot;common.h&quot;
 
 static nokprobe_inline
<span class="p_del">-int __skip_singlestep(struct kprobe *p, struct pt_regs *regs,</span>
<span class="p_add">+void __skip_singlestep(struct kprobe *p, struct pt_regs *regs,</span>
 		      struct kprobe_ctlblk *kcb, unsigned long orig_ip)
 {
 	/*
<span class="p_chunk">@@ -41,20 +41,21 @@</span> <span class="p_context"> int __skip_singlestep(struct kprobe *p, struct pt_regs *regs,</span>
 	__this_cpu_write(current_kprobe, NULL);
 	if (orig_ip)
 		regs-&gt;ip = orig_ip;
<span class="p_del">-	return 1;</span>
 }
 
 int skip_singlestep(struct kprobe *p, struct pt_regs *regs,
 		    struct kprobe_ctlblk *kcb)
 {
<span class="p_del">-	if (kprobe_ftrace(p))</span>
<span class="p_del">-		return __skip_singlestep(p, regs, kcb, 0);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	if (kprobe_ftrace(p)) {</span>
<span class="p_add">+		__skip_singlestep(p, regs, kcb, 0);</span>
<span class="p_add">+		preempt_enable_no_resched();</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
 }
 NOKPROBE_SYMBOL(skip_singlestep);
 
<span class="p_del">-/* Ftrace callback handler for kprobes */</span>
<span class="p_add">+/* Ftrace callback handler for kprobes -- called under preepmt disabed */</span>
 void kprobe_ftrace_handler(unsigned long ip, unsigned long parent_ip,
 			   struct ftrace_ops *ops, struct pt_regs *regs)
 {
<span class="p_chunk">@@ -77,13 +78,17 @@</span> <span class="p_context"> void kprobe_ftrace_handler(unsigned long ip, unsigned long parent_ip,</span>
 		/* Kprobe handler expects regs-&gt;ip = ip + 1 as breakpoint hit */
 		regs-&gt;ip = ip + sizeof(kprobe_opcode_t);
 
<span class="p_add">+		/* To emulate trap based kprobes, preempt_disable here */</span>
<span class="p_add">+		preempt_disable();</span>
 		__this_cpu_write(current_kprobe, p);
 		kcb-&gt;kprobe_status = KPROBE_HIT_ACTIVE;
<span class="p_del">-		if (!p-&gt;pre_handler || !p-&gt;pre_handler(p, regs))</span>
<span class="p_add">+		if (!p-&gt;pre_handler || !p-&gt;pre_handler(p, regs)) {</span>
 			__skip_singlestep(p, regs, kcb, orig_ip);
<span class="p_add">+			preempt_enable_no_resched();</span>
<span class="p_add">+		}</span>
 		/*
 		 * If pre_handler returns !0, it sets regs-&gt;ip and
<span class="p_del">-		 * resets current kprobe.</span>
<span class="p_add">+		 * resets current kprobe, and keep preempt count +1.</span>
 		 */
 	}
 end:
<span class="p_header">diff --git a/arch/x86/kernel/ldt.c b/arch/x86/kernel/ldt.c</span>
<span class="p_header">index 6707039b9032..5f70014ca602 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ldt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ldt.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/string.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/smp.h&gt;
<span class="p_add">+#include &lt;linux/syscalls.h&gt;</span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/uaccess.h&gt;
<span class="p_chunk">@@ -271,8 +272,8 @@</span> <span class="p_context"> static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)</span>
 	return error;
 }
 
<span class="p_del">-asmlinkage int sys_modify_ldt(int func, void __user *ptr,</span>
<span class="p_del">-			      unsigned long bytecount)</span>
<span class="p_add">+SYSCALL_DEFINE3(modify_ldt, int , func , void __user * , ptr ,</span>
<span class="p_add">+		unsigned long , bytecount)</span>
 {
 	int ret = -ENOSYS;
 
<span class="p_chunk">@@ -290,5 +291,14 @@</span> <span class="p_context"> asmlinkage int sys_modify_ldt(int func, void __user *ptr,</span>
 		ret = write_ldt(ptr, bytecount, 0);
 		break;
 	}
<span class="p_del">-	return ret;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The SYSCALL_DEFINE() macros give us an &#39;unsigned long&#39;</span>
<span class="p_add">+	 * return type, but tht ABI for sys_modify_ldt() expects</span>
<span class="p_add">+	 * &#39;int&#39;.  This cast gives us an int-sized value in %rax</span>
<span class="p_add">+	 * for the return code.  The &#39;unsigned&#39; is necessary so</span>
<span class="p_add">+	 * the compiler does not try to sign-extend the negative</span>
<span class="p_add">+	 * return codes into the high half of the register when</span>
<span class="p_add">+	 * taking the value from int-&gt;long.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return (unsigned int)ret;</span>
 }
<span class="p_header">diff --git a/arch/x86/um/ldt.c b/arch/x86/um/ldt.c</span>
<span class="p_header">index 836a1eb5df43..3ee234b6234d 100644</span>
<span class="p_header">--- a/arch/x86/um/ldt.c</span>
<span class="p_header">+++ b/arch/x86/um/ldt.c</span>
<span class="p_chunk">@@ -6,6 +6,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/syscalls.h&gt;</span>
 #include &lt;linux/uaccess.h&gt;
 #include &lt;asm/unistd.h&gt;
 #include &lt;os.h&gt;
<span class="p_chunk">@@ -369,7 +370,9 @@</span> <span class="p_context"> void free_ldt(struct mm_context *mm)</span>
 	mm-&gt;arch.ldt.entry_count = 0;
 }
 
<span class="p_del">-int sys_modify_ldt(int func, void __user *ptr, unsigned long bytecount)</span>
<span class="p_add">+SYSCALL_DEFINE3(modify_ldt, int , func , void __user * , ptr ,</span>
<span class="p_add">+		unsigned long , bytecount)</span>
 {
<span class="p_del">-	return do_modify_ldt_skas(func, ptr, bytecount);</span>
<span class="p_add">+	/* See non-um modify_ldt() for why we do this cast */</span>
<span class="p_add">+	return (unsigned int)do_modify_ldt_skas(func, ptr, bytecount);</span>
 }
<span class="p_header">diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h</span>
<span class="p_header">index 5d4c05074a5c..e2bcacc1a921 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/intern.h</span>
<span class="p_header">+++ b/drivers/crypto/caam/intern.h</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"> struct caam_drv_private_jr {</span>
 	struct device		*dev;
 	int ridx;
 	struct caam_job_ring __iomem *rregs;	/* JobR&#39;s register space */
<span class="p_add">+	struct tasklet_struct irqtask;</span>
 	int irq;			/* One per queue */
 
 	/* Number of scatterlist crypt transforms active on the JobR */
<span class="p_header">diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c</span>
<span class="p_header">index 757c27f9953d..9e7f28122bb7 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/jr.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/jr.c</span>
<span class="p_chunk">@@ -73,6 +73,8 @@</span> <span class="p_context"> static int caam_jr_shutdown(struct device *dev)</span>
 
 	ret = caam_reset_hw_jr(dev);
 
<span class="p_add">+	tasklet_kill(&amp;jrp-&gt;irqtask);</span>
<span class="p_add">+</span>
 	/* Release interrupt */
 	free_irq(jrp-&gt;irq, dev);
 
<span class="p_chunk">@@ -128,7 +130,7 @@</span> <span class="p_context"> static irqreturn_t caam_jr_interrupt(int irq, void *st_dev)</span>
 
 	/*
 	 * Check the output ring for ready responses, kick
<span class="p_del">-	 * the threaded irq if jobs done.</span>
<span class="p_add">+	 * tasklet if jobs done.</span>
 	 */
 	irqstate = rd_reg32(&amp;jrp-&gt;rregs-&gt;jrintstatus);
 	if (!irqstate)
<span class="p_chunk">@@ -150,13 +152,18 @@</span> <span class="p_context"> static irqreturn_t caam_jr_interrupt(int irq, void *st_dev)</span>
 	/* Have valid interrupt at this point, just ACK and trigger */
 	wr_reg32(&amp;jrp-&gt;rregs-&gt;jrintstatus, irqstate);
 
<span class="p_del">-	return IRQ_WAKE_THREAD;</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+	tasklet_schedule(&amp;jrp-&gt;irqtask);</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
 }
 
<span class="p_del">-static irqreturn_t caam_jr_threadirq(int irq, void *st_dev)</span>
<span class="p_add">+/* Deferred service handler, run as interrupt-fired tasklet */</span>
<span class="p_add">+static void caam_jr_dequeue(unsigned long devarg)</span>
 {
 	int hw_idx, sw_idx, i, head, tail;
<span class="p_del">-	struct device *dev = st_dev;</span>
<span class="p_add">+	struct device *dev = (struct device *)devarg;</span>
 	struct caam_drv_private_jr *jrp = dev_get_drvdata(dev);
 	void (*usercall)(struct device *dev, u32 *desc, u32 status, void *arg);
 	u32 *userdesc, userstatus;
<span class="p_chunk">@@ -230,8 +237,6 @@</span> <span class="p_context"> static irqreturn_t caam_jr_threadirq(int irq, void *st_dev)</span>
 
 	/* reenable / unmask IRQs */
 	clrsetbits_32(&amp;jrp-&gt;rregs-&gt;rconfig_lo, JRCFG_IMSK, 0);
<span class="p_del">-</span>
<span class="p_del">-	return IRQ_HANDLED;</span>
 }
 
 /**
<span class="p_chunk">@@ -389,10 +394,11 @@</span> <span class="p_context"> static int caam_jr_init(struct device *dev)</span>
 
 	jrp = dev_get_drvdata(dev);
 
<span class="p_add">+	tasklet_init(&amp;jrp-&gt;irqtask, caam_jr_dequeue, (unsigned long)dev);</span>
<span class="p_add">+</span>
 	/* Connect job ring interrupt handler. */
<span class="p_del">-	error = request_threaded_irq(jrp-&gt;irq, caam_jr_interrupt,</span>
<span class="p_del">-				     caam_jr_threadirq, IRQF_SHARED,</span>
<span class="p_del">-				     dev_name(dev), dev);</span>
<span class="p_add">+	error = request_irq(jrp-&gt;irq, caam_jr_interrupt, IRQF_SHARED,</span>
<span class="p_add">+			    dev_name(dev), dev);</span>
 	if (error) {
 		dev_err(dev, &quot;can&#39;t connect JobR %d interrupt (%d)\n&quot;,
 			jrp-&gt;ridx, jrp-&gt;irq);
<span class="p_chunk">@@ -454,6 +460,7 @@</span> <span class="p_context"> static int caam_jr_init(struct device *dev)</span>
 out_free_irq:
 	free_irq(jrp-&gt;irq, dev);
 out_kill_deq:
<span class="p_add">+	tasklet_kill(&amp;jrp-&gt;irqtask);</span>
 	return error;
 }
 
<span class="p_header">diff --git a/drivers/dma-buf/fence.c b/drivers/dma-buf/fence.c</span>
<span class="p_header">index 4d51f9e83fa8..04bf29808200 100644</span>
<span class="p_header">--- a/drivers/dma-buf/fence.c</span>
<span class="p_header">+++ b/drivers/dma-buf/fence.c</span>
<span class="p_chunk">@@ -280,6 +280,31 @@</span> <span class="p_context"> int fence_add_callback(struct fence *fence, struct fence_cb *cb,</span>
 }
 EXPORT_SYMBOL(fence_add_callback);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * fence_get_status - returns the status upon completion</span>
<span class="p_add">+ * @fence: [in]	the fence to query</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This wraps fence_get_status_locked() to return the error status</span>
<span class="p_add">+ * condition on a signaled fence. See fence_get_status_locked() for more</span>
<span class="p_add">+ * details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns 0 if the fence has not yet been signaled, 1 if the fence has</span>
<span class="p_add">+ * been signaled without an error condition, or a negative error code</span>
<span class="p_add">+ * if the fence has been completed in err.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int fence_get_status(struct fence *fence)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(fence-&gt;lock, flags);</span>
<span class="p_add">+	status = fence_get_status_locked(fence);</span>
<span class="p_add">+	spin_unlock_irqrestore(fence-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(fence_get_status);</span>
<span class="p_add">+</span>
 /**
  * fence_remove_callback - remove a callback from the signaling list
  * @fence:	[in]	the fence to wait on
<span class="p_chunk">@@ -526,6 +551,7 @@</span> <span class="p_context"> fence_init(struct fence *fence, const struct fence_ops *ops,</span>
 	fence-&gt;context = context;
 	fence-&gt;seqno = seqno;
 	fence-&gt;flags = 0UL;
<span class="p_add">+	fence-&gt;error = 0;</span>
 
 	trace_fence_init(fence);
 }
<span class="p_header">diff --git a/drivers/dma-buf/sw_sync.c b/drivers/dma-buf/sw_sync.c</span>
<span class="p_header">index 62e8e6dc7953..4f3511415b29 100644</span>
<span class="p_header">--- a/drivers/dma-buf/sw_sync.c</span>
<span class="p_header">+++ b/drivers/dma-buf/sw_sync.c</span>
<span class="p_chunk">@@ -96,9 +96,9 @@</span> <span class="p_context"> struct sync_timeline *sync_timeline_create(const char *name)</span>
 	obj-&gt;context = fence_context_alloc(1);
 	strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));
 
<span class="p_del">-	INIT_LIST_HEAD(&amp;obj-&gt;child_list_head);</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;obj-&gt;active_list_head);</span>
<span class="p_del">-	spin_lock_init(&amp;obj-&gt;child_list_lock);</span>
<span class="p_add">+	obj-&gt;pt_tree = RB_ROOT;</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;obj-&gt;pt_list);</span>
<span class="p_add">+	spin_lock_init(&amp;obj-&gt;lock);</span>
 
 	sync_timeline_debug_add(obj);
 
<span class="p_chunk">@@ -125,68 +125,6 @@</span> <span class="p_context"> static void sync_timeline_put(struct sync_timeline *obj)</span>
 	kref_put(&amp;obj-&gt;kref, sync_timeline_free);
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * sync_timeline_signal() - signal a status change on a sync_timeline</span>
<span class="p_del">- * @obj:	sync_timeline to signal</span>
<span class="p_del">- * @inc:	num to increment on timeline-&gt;value</span>
<span class="p_del">- *</span>
<span class="p_del">- * A sync implementation should call this any time one of it&#39;s fences</span>
<span class="p_del">- * has signaled or has an error condition.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void sync_timeline_signal(struct sync_timeline *obj, unsigned int inc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-	struct sync_pt *pt, *next;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_sync_timeline(obj);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;obj-&gt;child_list_lock, flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	obj-&gt;value += inc;</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry_safe(pt, next, &amp;obj-&gt;active_list_head,</span>
<span class="p_del">-				 active_list) {</span>
<span class="p_del">-		if (fence_is_signaled_locked(&amp;pt-&gt;base))</span>
<span class="p_del">-			list_del_init(&amp;pt-&gt;active_list);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;obj-&gt;child_list_lock, flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * sync_pt_create() - creates a sync pt</span>
<span class="p_del">- * @parent:	fence&#39;s parent sync_timeline</span>
<span class="p_del">- * @size:	size to allocate for this pt</span>
<span class="p_del">- * @inc:	value of the fence</span>
<span class="p_del">- *</span>
<span class="p_del">- * Creates a new sync_pt as a child of @parent.  @size bytes will be</span>
<span class="p_del">- * allocated allowing for implementation specific data to be kept after</span>
<span class="p_del">- * the generic sync_timeline struct. Returns the sync_pt object or</span>
<span class="p_del">- * NULL in case of error.</span>
<span class="p_del">- */</span>
<span class="p_del">-static struct sync_pt *sync_pt_create(struct sync_timeline *obj, int size,</span>
<span class="p_del">-			     unsigned int value)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-	struct sync_pt *pt;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (size &lt; sizeof(*pt))</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	pt = kzalloc(size, GFP_KERNEL);</span>
<span class="p_del">-	if (!pt)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;obj-&gt;child_list_lock, flags);</span>
<span class="p_del">-	sync_timeline_get(obj);</span>
<span class="p_del">-	fence_init(&amp;pt-&gt;base, &amp;timeline_fence_ops, &amp;obj-&gt;child_list_lock,</span>
<span class="p_del">-		   obj-&gt;context, value);</span>
<span class="p_del">-	list_add_tail(&amp;pt-&gt;child_list, &amp;obj-&gt;child_list_head);</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;pt-&gt;active_list);</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;obj-&gt;child_list_lock, flags);</span>
<span class="p_del">-	return pt;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static const char *timeline_fence_get_driver_name(struct fence *fence)
 {
 	return &quot;sw_sync&quot;;
<span class="p_chunk">@@ -203,13 +141,17 @@</span> <span class="p_context"> static void timeline_fence_release(struct fence *fence)</span>
 {
 	struct sync_pt *pt = fence_to_sync_pt(fence);
 	struct sync_timeline *parent = fence_parent(fence);
<span class="p_del">-	unsigned long flags;</span>
 
<span class="p_del">-	spin_lock_irqsave(fence-&gt;lock, flags);</span>
<span class="p_del">-	list_del(&amp;pt-&gt;child_list);</span>
<span class="p_del">-	if (!list_empty(&amp;pt-&gt;active_list))</span>
<span class="p_del">-		list_del(&amp;pt-&gt;active_list);</span>
<span class="p_del">-	spin_unlock_irqrestore(fence-&gt;lock, flags);</span>
<span class="p_add">+	if (!list_empty(&amp;pt-&gt;link)) {</span>
<span class="p_add">+		unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_irqsave(fence-&gt;lock, flags);</span>
<span class="p_add">+		if (!list_empty(&amp;pt-&gt;link)) {</span>
<span class="p_add">+			list_del(&amp;pt-&gt;link);</span>
<span class="p_add">+			rb_erase(&amp;pt-&gt;node, &amp;parent-&gt;pt_tree);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		spin_unlock_irqrestore(fence-&gt;lock, flags);</span>
<span class="p_add">+	}</span>
 
 	sync_timeline_put(parent);
 	fence_free(fence);
<span class="p_chunk">@@ -219,18 +161,11 @@</span> <span class="p_context"> static bool timeline_fence_signaled(struct fence *fence)</span>
 {
 	struct sync_timeline *parent = fence_parent(fence);
 
<span class="p_del">-	return (fence-&gt;seqno &gt; parent-&gt;value) ? false : true;</span>
<span class="p_add">+	return !__fence_is_later(fence-&gt;seqno, parent-&gt;value);</span>
 }
 
 static bool timeline_fence_enable_signaling(struct fence *fence)
 {
<span class="p_del">-	struct sync_pt *pt = fence_to_sync_pt(fence);</span>
<span class="p_del">-	struct sync_timeline *parent = fence_parent(fence);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (timeline_fence_signaled(fence))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	list_add_tail(&amp;pt-&gt;active_list, &amp;parent-&gt;active_list_head);</span>
 	return true;
 }
 
<span class="p_chunk">@@ -259,6 +194,107 @@</span> <span class="p_context"> static const struct fence_ops timeline_fence_ops = {</span>
 	.timeline_value_str = timeline_fence_timeline_value_str,
 };
 
<span class="p_add">+/**</span>
<span class="p_add">+ * sync_timeline_signal() - signal a status change on a sync_timeline</span>
<span class="p_add">+ * @obj:	sync_timeline to signal</span>
<span class="p_add">+ * @inc:	num to increment on timeline-&gt;value</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * A sync implementation should call this any time one of it&#39;s fences</span>
<span class="p_add">+ * has signaled or has an error condition.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void sync_timeline_signal(struct sync_timeline *obj, unsigned int inc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sync_pt *pt, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_sync_timeline(obj);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;obj-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	obj-&gt;value += inc;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(pt, next, &amp;obj-&gt;pt_list, link) {</span>
<span class="p_add">+		if (!timeline_fence_signaled(&amp;pt-&gt;base))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		list_del_init(&amp;pt-&gt;link);</span>
<span class="p_add">+		rb_erase(&amp;pt-&gt;node, &amp;obj-&gt;pt_tree);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * A signal callback may release the last reference to this</span>
<span class="p_add">+		 * fence, causing it to be freed. That operation has to be</span>
<span class="p_add">+		 * last to avoid a use after free inside this loop, and must</span>
<span class="p_add">+		 * be after we remove the fence from the timeline in order to</span>
<span class="p_add">+		 * prevent deadlocking on timeline-&gt;lock inside</span>
<span class="p_add">+		 * timeline_fence_release().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		fence_signal_locked(&amp;pt-&gt;base);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irq(&amp;obj-&gt;lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * sync_pt_create() - creates a sync pt</span>
<span class="p_add">+ * @parent:	fence&#39;s parent sync_timeline</span>
<span class="p_add">+ * @inc:	value of the fence</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Creates a new sync_pt as a child of @parent.  @size bytes will be</span>
<span class="p_add">+ * allocated allowing for implementation specific data to be kept after</span>
<span class="p_add">+ * the generic sync_timeline struct. Returns the sync_pt object or</span>
<span class="p_add">+ * NULL in case of error.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct sync_pt *sync_pt_create(struct sync_timeline *obj,</span>
<span class="p_add">+				      unsigned int value)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sync_pt *pt;</span>
<span class="p_add">+</span>
<span class="p_add">+	pt = kzalloc(sizeof(*pt), GFP_KERNEL);</span>
<span class="p_add">+	if (!pt)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	sync_timeline_get(obj);</span>
<span class="p_add">+	fence_init(&amp;pt-&gt;base, &amp;timeline_fence_ops, &amp;obj-&gt;lock,</span>
<span class="p_add">+		   obj-&gt;context, value);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;pt-&gt;link);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;obj-&gt;lock);</span>
<span class="p_add">+	if (!fence_is_signaled_locked(&amp;pt-&gt;base)) {</span>
<span class="p_add">+		struct rb_node **p = &amp;obj-&gt;pt_tree.rb_node;</span>
<span class="p_add">+		struct rb_node *parent = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		while (*p) {</span>
<span class="p_add">+			struct sync_pt *other;</span>
<span class="p_add">+			int cmp;</span>
<span class="p_add">+</span>
<span class="p_add">+			parent = *p;</span>
<span class="p_add">+			other = rb_entry(parent, typeof(*pt), node);</span>
<span class="p_add">+			cmp = value - other-&gt;base.seqno;</span>
<span class="p_add">+			if (cmp &gt; 0) {</span>
<span class="p_add">+				p = &amp;parent-&gt;rb_right;</span>
<span class="p_add">+			} else if (cmp &lt; 0) {</span>
<span class="p_add">+				p = &amp;parent-&gt;rb_left;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if (fence_get_rcu(&amp;other-&gt;base)) {</span>
<span class="p_add">+					fence_put(&amp;pt-&gt;base);</span>
<span class="p_add">+					pt = other;</span>
<span class="p_add">+					goto unlock;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				p = &amp;parent-&gt;rb_left;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		rb_link_node(&amp;pt-&gt;node, parent, p);</span>
<span class="p_add">+		rb_insert_color(&amp;pt-&gt;node, &amp;obj-&gt;pt_tree);</span>
<span class="p_add">+</span>
<span class="p_add">+		parent = rb_next(&amp;pt-&gt;node);</span>
<span class="p_add">+		list_add_tail(&amp;pt-&gt;link,</span>
<span class="p_add">+			      parent ? &amp;rb_entry(parent, typeof(*pt), node)-&gt;link : &amp;obj-&gt;pt_list);</span>
<span class="p_add">+	}</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	spin_unlock_irq(&amp;obj-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pt;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * *WARNING*
  *
<span class="p_chunk">@@ -285,8 +321,16 @@</span> <span class="p_context"> static int sw_sync_debugfs_open(struct inode *inode, struct file *file)</span>
 static int sw_sync_debugfs_release(struct inode *inode, struct file *file)
 {
 	struct sync_timeline *obj = file-&gt;private_data;
<span class="p_add">+	struct sync_pt *pt, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;obj-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(pt, next, &amp;obj-&gt;pt_list, link) {</span>
<span class="p_add">+		fence_set_error(&amp;pt-&gt;base, -ENOENT);</span>
<span class="p_add">+		fence_signal_locked(&amp;pt-&gt;base);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	smp_wmb();</span>
<span class="p_add">+	spin_unlock_irq(&amp;obj-&gt;lock);</span>
 
 	sync_timeline_put(obj);
 	return 0;
<span class="p_chunk">@@ -309,7 +353,7 @@</span> <span class="p_context"> static long sw_sync_ioctl_create_fence(struct sync_timeline *obj,</span>
 		goto err;
 	}
 
<span class="p_del">-	pt = sync_pt_create(obj, sizeof(*pt), data.value);</span>
<span class="p_add">+	pt = sync_pt_create(obj, data.value);</span>
 	if (!pt) {
 		err = -ENOMEM;
 		goto err;
<span class="p_chunk">@@ -345,6 +389,11 @@</span> <span class="p_context"> static long sw_sync_ioctl_inc(struct sync_timeline *obj, unsigned long arg)</span>
 	if (copy_from_user(&amp;value, (void __user *)arg, sizeof(value)))
 		return -EFAULT;
 
<span class="p_add">+	while (value &gt; INT_MAX)  {</span>
<span class="p_add">+		sync_timeline_signal(obj, INT_MAX);</span>
<span class="p_add">+		value -= INT_MAX;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sync_timeline_signal(obj, value);
 
 	return 0;
<span class="p_header">diff --git a/drivers/dma-buf/sync_debug.c b/drivers/dma-buf/sync_debug.c</span>
<span class="p_header">index 2dd4c3db6caa..858263dbecd4 100644</span>
<span class="p_header">--- a/drivers/dma-buf/sync_debug.c</span>
<span class="p_header">+++ b/drivers/dma-buf/sync_debug.c</span>
<span class="p_chunk">@@ -62,29 +62,29 @@</span> <span class="p_context"> void sync_file_debug_remove(struct sync_file *sync_file)</span>
 
 static const char *sync_status_str(int status)
 {
<span class="p_del">-	if (status == 0)</span>
<span class="p_del">-		return &quot;signaled&quot;;</span>
<span class="p_add">+	if (status &lt; 0)</span>
<span class="p_add">+		return &quot;error&quot;;</span>
 
 	if (status &gt; 0)
<span class="p_del">-		return &quot;active&quot;;</span>
<span class="p_add">+		return &quot;signaled&quot;;</span>
 
<span class="p_del">-	return &quot;error&quot;;</span>
<span class="p_add">+	return &quot;active&quot;;</span>
 }
 
<span class="p_del">-static void sync_print_fence(struct seq_file *s, struct fence *fence, bool show)</span>
<span class="p_add">+static void sync_print_fence(struct seq_file *s,</span>
<span class="p_add">+			     struct fence *fence, bool show)</span>
 {
<span class="p_del">-	int status = 1;</span>
 	struct sync_timeline *parent = fence_parent(fence);
<span class="p_add">+	int status;</span>
 
<span class="p_del">-	if (fence_is_signaled_locked(fence))</span>
<span class="p_del">-		status = fence-&gt;status;</span>
<span class="p_add">+	status = fence_get_status_locked(fence);</span>
 
 	seq_printf(s, &quot;  %s%sfence %s&quot;,
 		   show ? parent-&gt;name : &quot;&quot;,
 		   show ? &quot;_&quot; : &quot;&quot;,
 		   sync_status_str(status));
 
<span class="p_del">-	if (status &lt;= 0) {</span>
<span class="p_add">+	if (status) {</span>
 		struct timespec64 ts64 =
 			ktime_to_timespec64(fence-&gt;timestamp);
 
<span class="p_chunk">@@ -116,17 +116,15 @@</span> <span class="p_context"> static void sync_print_fence(struct seq_file *s, struct fence *fence, bool show)</span>
 static void sync_print_obj(struct seq_file *s, struct sync_timeline *obj)
 {
 	struct list_head *pos;
<span class="p_del">-	unsigned long flags;</span>
 
 	seq_printf(s, &quot;%s: %d\n&quot;, obj-&gt;name, obj-&gt;value);
 
<span class="p_del">-	spin_lock_irqsave(&amp;obj-&gt;child_list_lock, flags);</span>
<span class="p_del">-	list_for_each(pos, &amp;obj-&gt;child_list_head) {</span>
<span class="p_del">-		struct sync_pt *pt =</span>
<span class="p_del">-			container_of(pos, struct sync_pt, child_list);</span>
<span class="p_add">+	spin_lock_irq(&amp;obj-&gt;lock);</span>
<span class="p_add">+	list_for_each(pos, &amp;obj-&gt;pt_list) {</span>
<span class="p_add">+		struct sync_pt *pt = container_of(pos, struct sync_pt, link);</span>
 		sync_print_fence(s, &amp;pt-&gt;base, false);
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;obj-&gt;child_list_lock, flags);</span>
<span class="p_add">+	spin_unlock_irq(&amp;obj-&gt;lock);</span>
 }
 
 static void sync_print_sync_file(struct seq_file *s,
<span class="p_chunk">@@ -135,7 +133,7 @@</span> <span class="p_context"> static void sync_print_sync_file(struct seq_file *s,</span>
 	int i;
 
 	seq_printf(s, &quot;[%p] %s: %s\n&quot;, sync_file, sync_file-&gt;name,
<span class="p_del">-		   sync_status_str(!fence_is_signaled(sync_file-&gt;fence)));</span>
<span class="p_add">+		   sync_status_str(fence_get_status(sync_file-&gt;fence)));</span>
 
 	if (fence_is_array(sync_file-&gt;fence)) {
 		struct fence_array *array = to_fence_array(sync_file-&gt;fence);
<span class="p_chunk">@@ -149,12 +147,11 @@</span> <span class="p_context"> static void sync_print_sync_file(struct seq_file *s,</span>
 
 static int sync_debugfs_show(struct seq_file *s, void *unused)
 {
<span class="p_del">-	unsigned long flags;</span>
 	struct list_head *pos;
 
 	seq_puts(s, &quot;objs:\n--------------\n&quot;);
 
<span class="p_del">-	spin_lock_irqsave(&amp;sync_timeline_list_lock, flags);</span>
<span class="p_add">+	spin_lock_irq(&amp;sync_timeline_list_lock);</span>
 	list_for_each(pos, &amp;sync_timeline_list_head) {
 		struct sync_timeline *obj =
 			container_of(pos, struct sync_timeline,
<span class="p_chunk">@@ -163,11 +160,11 @@</span> <span class="p_context"> static int sync_debugfs_show(struct seq_file *s, void *unused)</span>
 		sync_print_obj(s, obj);
 		seq_puts(s, &quot;\n&quot;);
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;sync_timeline_list_lock, flags);</span>
<span class="p_add">+	spin_unlock_irq(&amp;sync_timeline_list_lock);</span>
 
 	seq_puts(s, &quot;fences:\n--------------\n&quot;);
 
<span class="p_del">-	spin_lock_irqsave(&amp;sync_file_list_lock, flags);</span>
<span class="p_add">+	spin_lock_irq(&amp;sync_file_list_lock);</span>
 	list_for_each(pos, &amp;sync_file_list_head) {
 		struct sync_file *sync_file =
 			container_of(pos, struct sync_file, sync_file_list);
<span class="p_chunk">@@ -175,7 +172,7 @@</span> <span class="p_context"> static int sync_debugfs_show(struct seq_file *s, void *unused)</span>
 		sync_print_sync_file(s, sync_file);
 		seq_puts(s, &quot;\n&quot;);
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;sync_file_list_lock, flags);</span>
<span class="p_add">+	spin_unlock_irq(&amp;sync_file_list_lock);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/dma-buf/sync_debug.h b/drivers/dma-buf/sync_debug.h</span>
<span class="p_header">index d269aa6783aa..9615dc0385b5 100644</span>
<span class="p_header">--- a/drivers/dma-buf/sync_debug.h</span>
<span class="p_header">+++ b/drivers/dma-buf/sync_debug.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #define _LINUX_SYNC_H
 
 #include &lt;linux/list.h&gt;
<span class="p_add">+#include &lt;linux/rbtree.h&gt;</span>
 #include &lt;linux/spinlock.h&gt;
 #include &lt;linux/fence.h&gt;
 
<span class="p_chunk">@@ -24,43 +25,41 @@</span> <span class="p_context"></span>
  * struct sync_timeline - sync object
  * @kref:		reference count on fence.
  * @name:		name of the sync_timeline. Useful for debugging
<span class="p_del">- * @child_list_head:	list of children sync_pts for this sync_timeline</span>
<span class="p_del">- * @child_list_lock:	lock protecting @child_list_head and fence.status</span>
<span class="p_del">- * @active_list_head:	list of active (unsignaled/errored) sync_pts</span>
<span class="p_add">+ * @lock:		lock protecting @pt_list and @value</span>
<span class="p_add">+ * @pt_tree:		rbtree of active (unsignaled/errored) sync_pts</span>
<span class="p_add">+ * @pt_list:		list of active (unsignaled/errored) sync_pts</span>
  * @sync_timeline_list:	membership in global sync_timeline_list
  */
 struct sync_timeline {
 	struct kref		kref;
 	char			name[32];
 
<span class="p_del">-	/* protected by child_list_lock */</span>
<span class="p_add">+	/* protected by lock */</span>
 	u64			context;
 	int			value;
 
<span class="p_del">-	struct list_head	child_list_head;</span>
<span class="p_del">-	spinlock_t		child_list_lock;</span>
<span class="p_del">-</span>
<span class="p_del">-	struct list_head	active_list_head;</span>
<span class="p_add">+	struct rb_root		pt_tree;</span>
<span class="p_add">+	struct list_head	pt_list;</span>
<span class="p_add">+	spinlock_t		lock;</span>
 
 	struct list_head	sync_timeline_list;
 };
 
 static inline struct sync_timeline *fence_parent(struct fence *fence)
 {
<span class="p_del">-	return container_of(fence-&gt;lock, struct sync_timeline,</span>
<span class="p_del">-			    child_list_lock);</span>
<span class="p_add">+	return container_of(fence-&gt;lock, struct sync_timeline, lock);</span>
 }
 
 /**
  * struct sync_pt - sync_pt object
  * @base: base fence object
<span class="p_del">- * @child_list: sync timeline child&#39;s list</span>
<span class="p_del">- * @active_list: sync timeline active child&#39;s list</span>
<span class="p_add">+ * @link: link on the sync timeline&#39;s list</span>
<span class="p_add">+ * @node: node in the sync timeline&#39;s tree</span>
  */
 struct sync_pt {
 	struct fence base;
<span class="p_del">-	struct list_head child_list;</span>
<span class="p_del">-	struct list_head active_list;</span>
<span class="p_add">+	struct list_head link;</span>
<span class="p_add">+	struct rb_node node;</span>
 };
 
 #ifdef CONFIG_SW_SYNC
<span class="p_header">diff --git a/drivers/dma-buf/sync_file.c b/drivers/dma-buf/sync_file.c</span>
<span class="p_header">index b29a9e817320..f0c374d6ab40 100644</span>
<span class="p_header">--- a/drivers/dma-buf/sync_file.c</span>
<span class="p_header">+++ b/drivers/dma-buf/sync_file.c</span>
<span class="p_chunk">@@ -67,9 +67,10 @@</span> <span class="p_context"> static void fence_check_cb_func(struct fence *f, struct fence_cb *cb)</span>
  * sync_file_create() - creates a sync file
  * @fence:	fence to add to the sync_fence
  *
<span class="p_del">- * Creates a sync_file containg @fence. Once this is called, the sync_file</span>
<span class="p_del">- * takes ownership of @fence. The sync_file can be released with</span>
<span class="p_del">- * fput(sync_file-&gt;file). Returns the sync_file or NULL in case of error.</span>
<span class="p_add">+ * Creates a sync_file containg @fence. This function acquires and additional</span>
<span class="p_add">+ * reference of @fence for the newly-created &amp;sync_file, if it succeeds. The</span>
<span class="p_add">+ * sync_file can be released with fput(sync_file-&gt;file). Returns the</span>
<span class="p_add">+ * sync_file or NULL in case of error.</span>
  */
 struct sync_file *sync_file_create(struct fence *fence)
 {
<span class="p_chunk">@@ -79,7 +80,7 @@</span> <span class="p_context"> struct sync_file *sync_file_create(struct fence *fence)</span>
 	if (!sync_file)
 		return NULL;
 
<span class="p_del">-	sync_file-&gt;fence = fence;</span>
<span class="p_add">+	sync_file-&gt;fence = fence_get(fence);</span>
 
 	snprintf(sync_file-&gt;name, sizeof(sync_file-&gt;name), &quot;%s-%s%llu-%d&quot;,
 		 fence-&gt;ops-&gt;get_driver_name(fence),
<span class="p_chunk">@@ -90,13 +91,6 @@</span> <span class="p_context"> struct sync_file *sync_file_create(struct fence *fence)</span>
 }
 EXPORT_SYMBOL(sync_file_create);
 
<span class="p_del">-/**</span>
<span class="p_del">- * sync_file_fdget() - get a sync_file from an fd</span>
<span class="p_del">- * @fd:		fd referencing a fence</span>
<span class="p_del">- *</span>
<span class="p_del">- * Ensures @fd references a valid sync_file, increments the refcount of the</span>
<span class="p_del">- * backing file. Returns the sync_file or NULL in case of error.</span>
<span class="p_del">- */</span>
 static struct sync_file *sync_file_fdget(int fd)
 {
 	struct file *file = fget(fd);
<span class="p_chunk">@@ -377,10 +371,8 @@</span> <span class="p_context"> static void sync_fill_fence_info(struct fence *fence,</span>
 		sizeof(info-&gt;obj_name));
 	strlcpy(info-&gt;driver_name, fence-&gt;ops-&gt;get_driver_name(fence),
 		sizeof(info-&gt;driver_name));
<span class="p_del">-	if (fence_is_signaled(fence))</span>
<span class="p_del">-		info-&gt;status = fence-&gt;status &gt;= 0 ? 1 : fence-&gt;status;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		info-&gt;status = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	info-&gt;status = fence_get_status(fence);</span>
 	info-&gt;timestamp_ns = ktime_to_ns(fence-&gt;timestamp);
 }
 
<span class="p_header">diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.c</span>
<span class="p_header">index 9f3dbc8c63d2..fb2e7476d96b 100644</span>
<span class="p_header">--- a/drivers/dma/pl330.c</span>
<span class="p_header">+++ b/drivers/dma/pl330.c</span>
<span class="p_chunk">@@ -1694,7 +1694,6 @@</span> <span class="p_context"> static bool _chan_ns(const struct pl330_dmac *pl330, int i)</span>
 static struct pl330_thread *pl330_request_channel(struct pl330_dmac *pl330)
 {
 	struct pl330_thread *thrd = NULL;
<span class="p_del">-	unsigned long flags;</span>
 	int chans, i;
 
 	if (pl330-&gt;state == DYING)
<span class="p_chunk">@@ -1702,8 +1701,6 @@</span> <span class="p_context"> static struct pl330_thread *pl330_request_channel(struct pl330_dmac *pl330)</span>
 
 	chans = pl330-&gt;pcfg.num_chan;
 
<span class="p_del">-	spin_lock_irqsave(&amp;pl330-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; chans; i++) {
 		thrd = &amp;pl330-&gt;channels[i];
 		if ((thrd-&gt;free) &amp;&amp; (!_manager_ns(thrd) ||
<span class="p_chunk">@@ -1721,8 +1718,6 @@</span> <span class="p_context"> static struct pl330_thread *pl330_request_channel(struct pl330_dmac *pl330)</span>
 		thrd = NULL;
 	}
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	return thrd;
 }
 
<span class="p_chunk">@@ -1740,7 +1735,6 @@</span> <span class="p_context"> static inline void _free_event(struct pl330_thread *thrd, int ev)</span>
 static void pl330_release_channel(struct pl330_thread *thrd)
 {
 	struct pl330_dmac *pl330;
<span class="p_del">-	unsigned long flags;</span>
 
 	if (!thrd || thrd-&gt;free)
 		return;
<span class="p_chunk">@@ -1752,10 +1746,8 @@</span> <span class="p_context"> static void pl330_release_channel(struct pl330_thread *thrd)</span>
 
 	pl330 = thrd-&gt;dmac;
 
<span class="p_del">-	spin_lock_irqsave(&amp;pl330-&gt;lock, flags);</span>
 	_free_event(thrd, thrd-&gt;ev);
 	thrd-&gt;free = true;
<span class="p_del">-	spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags);</span>
 }
 
 /* Initialize the structure for PL330 configuration, that can be used
<span class="p_chunk">@@ -2120,20 +2112,20 @@</span> <span class="p_context"> static int pl330_alloc_chan_resources(struct dma_chan *chan)</span>
 	struct pl330_dmac *pl330 = pch-&gt;dmac;
 	unsigned long flags;
 
<span class="p_del">-	spin_lock_irqsave(&amp;pch-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;pl330-&gt;lock, flags);</span>
 
 	dma_cookie_init(chan);
 	pch-&gt;cyclic = false;
 
 	pch-&gt;thread = pl330_request_channel(pl330);
 	if (!pch-&gt;thread) {
<span class="p_del">-		spin_unlock_irqrestore(&amp;pch-&gt;lock, flags);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags);</span>
 		return -ENOMEM;
 	}
 
 	tasklet_init(&amp;pch-&gt;task, pl330_tasklet, (unsigned long) pch);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;pch-&gt;lock, flags);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags);</span>
 
 	return 1;
 }
<span class="p_chunk">@@ -2236,12 +2228,13 @@</span> <span class="p_context"> static int pl330_pause(struct dma_chan *chan)</span>
 static void pl330_free_chan_resources(struct dma_chan *chan)
 {
 	struct dma_pl330_chan *pch = to_pchan(chan);
<span class="p_add">+	struct pl330_dmac *pl330 = pch-&gt;dmac;</span>
 	unsigned long flags;
 
 	tasklet_kill(&amp;pch-&gt;task);
 
 	pm_runtime_get_sync(pch-&gt;dmac-&gt;ddma.dev);
<span class="p_del">-	spin_lock_irqsave(&amp;pch-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;pl330-&gt;lock, flags);</span>
 
 	pl330_release_channel(pch-&gt;thread);
 	pch-&gt;thread = NULL;
<span class="p_chunk">@@ -2249,7 +2242,7 @@</span> <span class="p_context"> static void pl330_free_chan_resources(struct dma_chan *chan)</span>
 	if (pch-&gt;cyclic)
 		list_splice_tail_init(&amp;pch-&gt;work_list, &amp;pch-&gt;dmac-&gt;desc_pool);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;pch-&gt;lock, flags);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags);</span>
 	pm_runtime_mark_last_busy(pch-&gt;dmac-&gt;ddma.dev);
 	pm_runtime_put_autosuspend(pch-&gt;dmac-&gt;ddma.dev);
 }
<span class="p_header">diff --git a/drivers/dma/stm32-dma.c b/drivers/dma/stm32-dma.c</span>
<span class="p_header">index 307547f4848d..ae3f60be7759 100644</span>
<span class="p_header">--- a/drivers/dma/stm32-dma.c</span>
<span class="p_header">+++ b/drivers/dma/stm32-dma.c</span>
<span class="p_chunk">@@ -884,7 +884,7 @@</span> <span class="p_context"> static enum dma_status stm32_dma_tx_status(struct dma_chan *c,</span>
 	struct virt_dma_desc *vdesc;
 	enum dma_status status;
 	unsigned long flags;
<span class="p_del">-	u32 residue;</span>
<span class="p_add">+	u32 residue = 0;</span>
 
 	status = dma_cookie_status(c, cookie, state);
 	if ((status == DMA_COMPLETE) || (!state))
<span class="p_chunk">@@ -892,16 +892,12 @@</span> <span class="p_context"> static enum dma_status stm32_dma_tx_status(struct dma_chan *c,</span>
 
 	spin_lock_irqsave(&amp;chan-&gt;vchan.lock, flags);
 	vdesc = vchan_find_desc(&amp;chan-&gt;vchan, cookie);
<span class="p_del">-	if (cookie == chan-&gt;desc-&gt;vdesc.tx.cookie) {</span>
<span class="p_add">+	if (chan-&gt;desc &amp;&amp; cookie == chan-&gt;desc-&gt;vdesc.tx.cookie)</span>
 		residue = stm32_dma_desc_residue(chan, chan-&gt;desc,
 						 chan-&gt;next_sg);
<span class="p_del">-	} else if (vdesc) {</span>
<span class="p_add">+	else if (vdesc)</span>
 		residue = stm32_dma_desc_residue(chan,
 						 to_stm32_dma_desc(vdesc), 0);
<span class="p_del">-	} else {</span>
<span class="p_del">-		residue = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	dma_set_residue(state, residue);
 
 	spin_unlock_irqrestore(&amp;chan-&gt;vchan.lock, flags);
<span class="p_chunk">@@ -976,21 +972,18 @@</span> <span class="p_context"> static struct dma_chan *stm32_dma_of_xlate(struct of_phandle_args *dma_spec,</span>
 	struct stm32_dma_chan *chan;
 	struct dma_chan *c;
 
<span class="p_del">-	if (dma_spec-&gt;args_count &lt; 3)</span>
<span class="p_add">+	if (dma_spec-&gt;args_count &lt; 4)</span>
 		return NULL;
 
 	cfg.channel_id = dma_spec-&gt;args[0];
 	cfg.request_line = dma_spec-&gt;args[1];
 	cfg.stream_config = dma_spec-&gt;args[2];
<span class="p_del">-	cfg.threshold = 0;</span>
<span class="p_add">+	cfg.threshold = dma_spec-&gt;args[3];</span>
 
 	if ((cfg.channel_id &gt;= STM32_DMA_MAX_CHANNELS) || (cfg.request_line &gt;=
 				STM32_DMA_MAX_REQUEST_ID))
 		return NULL;
 
<span class="p_del">-	if (dma_spec-&gt;args_count &gt; 3)</span>
<span class="p_del">-		cfg.threshold = dma_spec-&gt;args[3];</span>
<span class="p_del">-</span>
 	chan = &amp;dmadev-&gt;chan[cfg.channel_id];
 
 	c = dma_get_slave_channel(&amp;chan-&gt;vchan.chan);
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index 54775221a01f..3c47e6361d81 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -2510,6 +2510,7 @@</span> <span class="p_context"> static int ibridge_mci_bind_devs(struct mem_ctl_info *mci,</span>
 			break;
 		case PCI_DEVICE_ID_INTEL_IBRIDGE_IMC_HA0_TA:
 			pvt-&gt;pci_ta = pdev;
<span class="p_add">+			break;</span>
 		case PCI_DEVICE_ID_INTEL_IBRIDGE_IMC_HA0_RAS:
 			pvt-&gt;pci_ras = pdev;
 			break;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c</span>
<span class="p_header">index c2bd9f045532..6d75fd0e3105 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c</span>
<span class="p_chunk">@@ -565,11 +565,8 @@</span> <span class="p_context"> static const struct drm_encoder_helper_funcs dce_virtual_encoder_helper_funcs =</span>
 
 static void dce_virtual_encoder_destroy(struct drm_encoder *encoder)
 {
<span class="p_del">-	struct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(amdgpu_encoder-&gt;enc_priv);</span>
 	drm_encoder_cleanup(encoder);
<span class="p_del">-	kfree(amdgpu_encoder);</span>
<span class="p_add">+	kfree(encoder);</span>
 }
 
 static const struct drm_encoder_funcs dce_virtual_encoder_funcs = {
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c</span>
<span class="p_header">index 50f0cf2788b7..7522f796f19b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> static void vce_v3_0_set_vce_sw_clock_gating(struct amdgpu_device *adev,</span>
 		WREG32(mmVCE_UENC_CLOCK_GATING_2, data);
 
 		data = RREG32(mmVCE_UENC_REG_CLOCK_GATING);
<span class="p_del">-		data &amp;= ~0xffc00000;</span>
<span class="p_add">+		data &amp;= ~0x3ff;</span>
 		WREG32(mmVCE_UENC_REG_CLOCK_GATING, data);
 
 		data = RREG32(mmVCE_UENC_DMA_DCLK_CTRL);
<span class="p_header">diff --git a/drivers/gpu/drm/exynos/exynos5433_drm_decon.c b/drivers/gpu/drm/exynos/exynos5433_drm_decon.c</span>
<span class="p_header">index 6ca1f3117fe8..6dd09c306bc1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/exynos/exynos5433_drm_decon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/exynos/exynos5433_drm_decon.c</span>
<span class="p_chunk">@@ -46,7 +46,8 @@</span> <span class="p_context"> enum decon_flag_bits {</span>
 	BIT_CLKS_ENABLED,
 	BIT_IRQS_ENABLED,
 	BIT_WIN_UPDATED,
<span class="p_del">-	BIT_SUSPENDED</span>
<span class="p_add">+	BIT_SUSPENDED,</span>
<span class="p_add">+	BIT_REQUEST_UPDATE</span>
 };
 
 struct decon_context {
<span class="p_chunk">@@ -315,6 +316,7 @@</span> <span class="p_context"> static void decon_update_plane(struct exynos_drm_crtc *crtc,</span>
 
 	/* window enable */
 	decon_set_bits(ctx, DECON_WINCONx(win), WINCONx_ENWIN_F, ~0);
<span class="p_add">+	set_bit(BIT_REQUEST_UPDATE, &amp;ctx-&gt;flags);</span>
 }
 
 static void decon_disable_plane(struct exynos_drm_crtc *crtc,
<span class="p_chunk">@@ -327,6 +329,7 @@</span> <span class="p_context"> static void decon_disable_plane(struct exynos_drm_crtc *crtc,</span>
 		return;
 
 	decon_set_bits(ctx, DECON_WINCONx(win), WINCONx_ENWIN_F, 0);
<span class="p_add">+	set_bit(BIT_REQUEST_UPDATE, &amp;ctx-&gt;flags);</span>
 }
 
 static void decon_atomic_flush(struct exynos_drm_crtc *crtc)
<span class="p_chunk">@@ -340,8 +343,8 @@</span> <span class="p_context"> static void decon_atomic_flush(struct exynos_drm_crtc *crtc)</span>
 	for (i = ctx-&gt;first_win; i &lt; WINDOWS_NR; i++)
 		decon_shadow_protect_win(ctx, i, false);
 
<span class="p_del">-	/* standalone update */</span>
<span class="p_del">-	decon_set_bits(ctx, DECON_UPDATE, STANDALONE_UPDATE_F, ~0);</span>
<span class="p_add">+	if (test_and_clear_bit(BIT_REQUEST_UPDATE, &amp;ctx-&gt;flags))</span>
<span class="p_add">+		decon_set_bits(ctx, DECON_UPDATE, STANDALONE_UPDATE_F, ~0);</span>
 
 	if (ctx-&gt;out_type &amp; IFTYPE_I80)
 		set_bit(BIT_WIN_UPDATED, &amp;ctx-&gt;flags);
<span class="p_header">diff --git a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c</span>
<span class="p_header">index cc2fde2ae5ef..c9eef0f51d31 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c</span>
<span class="p_chunk">@@ -243,7 +243,6 @@</span> <span class="p_context"> static int fsl_dcu_drm_pm_suspend(struct device *dev)</span>
 		return PTR_ERR(fsl_dev-&gt;state);
 	}
 
<span class="p_del">-	clk_disable_unprepare(fsl_dev-&gt;pix_clk);</span>
 	clk_disable_unprepare(fsl_dev-&gt;clk);
 
 	return 0;
<span class="p_chunk">@@ -266,6 +265,7 @@</span> <span class="p_context"> static int fsl_dcu_drm_pm_resume(struct device *dev)</span>
 	if (fsl_dev-&gt;tcon)
 		fsl_tcon_bypass_enable(fsl_dev-&gt;tcon);
 	fsl_dcu_drm_init_planes(fsl_dev-&gt;drm);
<span class="p_add">+	enable_irq(fsl_dev-&gt;irq);</span>
 	drm_atomic_helper_resume(fsl_dev-&gt;drm, fsl_dev-&gt;state);
 
 	console_lock();
<span class="p_chunk">@@ -273,7 +273,6 @@</span> <span class="p_context"> static int fsl_dcu_drm_pm_resume(struct device *dev)</span>
 	console_unlock();
 
 	drm_kms_helper_poll_enable(fsl_dev-&gt;drm);
<span class="p_del">-	enable_irq(fsl_dev-&gt;irq);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-cadence.c b/drivers/i2c/busses/i2c-cadence.c</span>
<span class="p_header">index 686971263bef..45d6771fac8c 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-cadence.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-cadence.c</span>
<span class="p_chunk">@@ -962,10 +962,6 @@</span> <span class="p_context"> static int cdns_i2c_probe(struct platform_device *pdev)</span>
 		goto err_clk_dis;
 	}
 
<span class="p_del">-	ret = i2c_add_adapter(&amp;id-&gt;adap);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		goto err_clk_dis;</span>
<span class="p_del">-</span>
 	/*
 	 * Cadence I2C controller has a bug wherein it generates
 	 * invalid read transaction after HW timeout in master receiver mode.
<span class="p_chunk">@@ -975,6 +971,10 @@</span> <span class="p_context"> static int cdns_i2c_probe(struct platform_device *pdev)</span>
 	 */
 	cdns_i2c_writereg(CDNS_I2C_TIMEOUT_MAX, CDNS_I2C_TIME_OUT_OFFSET);
 
<span class="p_add">+	ret = i2c_add_adapter(&amp;id-&gt;adap);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto err_clk_dis;</span>
<span class="p_add">+</span>
 	dev_info(&amp;pdev-&gt;dev, &quot;%u kHz mmio %08lx irq %d\n&quot;,
 		 id-&gt;i2c_clk / 1000, (unsigned long)r_mem-&gt;start, id-&gt;irq);
 
<span class="p_header">diff --git a/drivers/iio/adc/ti-ads1015.c b/drivers/iio/adc/ti-ads1015.c</span>
<span class="p_header">index 472641fc890c..af05e20c986b 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ti-ads1015.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ti-ads1015.c</span>
<span class="p_chunk">@@ -269,6 +269,7 @@</span> <span class="p_context"> int ads1015_get_adc_result(struct ads1015_data *data, int chan, int *val)</span>
 
 		conv_time = DIV_ROUND_UP(USEC_PER_SEC, data-&gt;data_rate[dr_old]);
 		conv_time += DIV_ROUND_UP(USEC_PER_SEC, data-&gt;data_rate[dr]);
<span class="p_add">+		conv_time += conv_time / 10; /* 10% internal clock inaccuracy */</span>
 		usleep_range(conv_time, conv_time + 1);
 		data-&gt;conv_invalid = false;
 	}
<span class="p_header">diff --git a/drivers/infiniband/hw/qedr/qedr_cm.c b/drivers/infiniband/hw/qedr/qedr_cm.c</span>
<span class="p_header">index 63890ebb72bd..eccf7039aaca 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qedr/qedr_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qedr/qedr_cm.c</span>
<span class="p_chunk">@@ -404,9 +404,9 @@</span> <span class="p_context"> static inline int qedr_gsi_build_packet(struct qedr_dev *dev,</span>
 	}
 
 	if (ether_addr_equal(udh.eth.smac_h, udh.eth.dmac_h))
<span class="p_del">-		packet-&gt;tx_dest = QED_ROCE_LL2_TX_DEST_NW;</span>
<span class="p_del">-	else</span>
 		packet-&gt;tx_dest = QED_ROCE_LL2_TX_DEST_LB;
<span class="p_add">+	else</span>
<span class="p_add">+		packet-&gt;tx_dest = QED_ROCE_LL2_TX_DEST_NW;</span>
 
 	packet-&gt;roce_mode = roce_mode;
 	memcpy(packet-&gt;header.vaddr, ud_header_buffer, header_size);
<span class="p_header">diff --git a/drivers/infiniband/hw/qedr/verbs.c b/drivers/infiniband/hw/qedr/verbs.c</span>
<span class="p_header">index 4ba019e3dc56..35d5b89decb4 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qedr/verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qedr/verbs.c</span>
<span class="p_chunk">@@ -1653,7 +1653,7 @@</span> <span class="p_context"> static int qedr_update_qp_state(struct qedr_dev *dev,</span>
 	int status = 0;
 
 	if (new_state == qp-&gt;state)
<span class="p_del">-		return 1;</span>
<span class="p_add">+		return 0;</span>
 
 	switch (qp-&gt;state) {
 	case QED_ROCE_QP_STATE_RESET:
<span class="p_header">diff --git a/drivers/md/bcache/request.c b/drivers/md/bcache/request.c</span>
<span class="p_header">index e0f1c6d534fe..ab8a1b36af21 100644</span>
<span class="p_header">--- a/drivers/md/bcache/request.c</span>
<span class="p_header">+++ b/drivers/md/bcache/request.c</span>
<span class="p_chunk">@@ -703,7 +703,14 @@</span> <span class="p_context"> static void cached_dev_read_error(struct closure *cl)</span>
 	struct search *s = container_of(cl, struct search, cl);
 	struct bio *bio = &amp;s-&gt;bio.bio;
 
<span class="p_del">-	if (s-&gt;recoverable) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If read request hit dirty data (s-&gt;read_dirty_data is true),</span>
<span class="p_add">+	 * then recovery a failed read request from cached device may</span>
<span class="p_add">+	 * get a stale data back. So read failure recovery is only</span>
<span class="p_add">+	 * permitted when read request hit clean data in cache device,</span>
<span class="p_add">+	 * or when cache read race happened.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (s-&gt;recoverable &amp;&amp; !s-&gt;read_dirty_data) {</span>
 		/* Retry from the backing device: */
 		trace_bcache_read_retry(s-&gt;orig_bio);
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-msm.c b/drivers/mmc/host/sdhci-msm.c</span>
<span class="p_header">index 90ed2e12d345..80c89a31d790 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-msm.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-msm.c</span>
<span class="p_chunk">@@ -642,6 +642,21 @@</span> <span class="p_context"> static int sdhci_msm_probe(struct platform_device *pdev)</span>
 			       CORE_VENDOR_SPEC_CAPABILITIES0);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Power on reset state may trigger power irq if previous status of</span>
<span class="p_add">+	 * PWRCTL was either BUS_ON or IO_HIGH_V. So before enabling pwr irq</span>
<span class="p_add">+	 * interrupt in GIC, any pending power irq interrupt should be</span>
<span class="p_add">+	 * acknowledged. Otherwise power irq interrupt handler would be</span>
<span class="p_add">+	 * fired prematurely.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sdhci_msm_voltage_switch(host);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ensure that above writes are propogated before interrupt enablement</span>
<span class="p_add">+	 * in GIC.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+</span>
 	/* Setup IRQ for handling power/voltage tasks with PMIC */
 	msm_host-&gt;pwr_irq = platform_get_irq_byname(pdev, &quot;pwr_irq&quot;);
 	if (msm_host-&gt;pwr_irq &lt; 0) {
<span class="p_chunk">@@ -651,6 +666,9 @@</span> <span class="p_context"> static int sdhci_msm_probe(struct platform_device *pdev)</span>
 		goto clk_disable;
 	}
 
<span class="p_add">+	/* Enable pwr irq interrupts */</span>
<span class="p_add">+	writel_relaxed(INT_MASK, msm_host-&gt;core_mem + CORE_PWRCTL_MASK);</span>
<span class="p_add">+</span>
 	ret = devm_request_threaded_irq(&amp;pdev-&gt;dev, msm_host-&gt;pwr_irq, NULL,
 					sdhci_msm_pwr_irq, IRQF_ONESHOT,
 					dev_name(&amp;pdev-&gt;dev), host);
<span class="p_header">diff --git a/drivers/net/appletalk/ipddp.c b/drivers/net/appletalk/ipddp.c</span>
<span class="p_header">index e90c6a7333d7..2e4649655181 100644</span>
<span class="p_header">--- a/drivers/net/appletalk/ipddp.c</span>
<span class="p_header">+++ b/drivers/net/appletalk/ipddp.c</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> static netdev_tx_t ipddp_xmit(struct sk_buff *skb, struct net_device *dev)</span>
  */
 static int ipddp_create(struct ipddp_route *new_rt)
 {
<span class="p_del">-        struct ipddp_route *rt = kmalloc(sizeof(*rt), GFP_KERNEL);</span>
<span class="p_add">+        struct ipddp_route *rt = kzalloc(sizeof(*rt), GFP_KERNEL);</span>
 
         if (rt == NULL)
                 return -ENOMEM;
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bcmsysport.c b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">index be7ec5a76a54..744ed6ddaf37 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_chunk">@@ -1023,15 +1023,6 @@</span> <span class="p_context"> static netdev_tx_t bcm_sysport_xmit(struct sk_buff *skb,</span>
 		goto out;
 	}
 
<span class="p_del">-	/* Insert TSB and checksum infos */</span>
<span class="p_del">-	if (priv-&gt;tsb_en) {</span>
<span class="p_del">-		skb = bcm_sysport_insert_tsb(skb, dev);</span>
<span class="p_del">-		if (!skb) {</span>
<span class="p_del">-			ret = NETDEV_TX_OK;</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* The Ethernet switch we are interfaced with needs packets to be at
 	 * least 64 bytes (including FCS) otherwise they will be discarded when
 	 * they enter the switch port logic. When Broadcom tags are enabled, we
<span class="p_chunk">@@ -1039,13 +1030,21 @@</span> <span class="p_context"> static netdev_tx_t bcm_sysport_xmit(struct sk_buff *skb,</span>
 	 * (including FCS and tag) because the length verification is done after
 	 * the Broadcom tag is stripped off the ingress packet.
 	 */
<span class="p_del">-	if (skb_padto(skb, ETH_ZLEN + ENET_BRCM_TAG_LEN)) {</span>
<span class="p_add">+	if (skb_put_padto(skb, ETH_ZLEN + ENET_BRCM_TAG_LEN)) {</span>
 		ret = NETDEV_TX_OK;
 		goto out;
 	}
 
<span class="p_del">-	skb_len = skb-&gt;len &lt; ETH_ZLEN + ENET_BRCM_TAG_LEN ?</span>
<span class="p_del">-			ETH_ZLEN + ENET_BRCM_TAG_LEN : skb-&gt;len;</span>
<span class="p_add">+	/* Insert TSB and checksum infos */</span>
<span class="p_add">+	if (priv-&gt;tsb_en) {</span>
<span class="p_add">+		skb = bcm_sysport_insert_tsb(skb, dev);</span>
<span class="p_add">+		if (!skb) {</span>
<span class="p_add">+			ret = NETDEV_TX_OK;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	skb_len = skb-&gt;len;</span>
 
 	mapping = dma_map_single(kdev, skb-&gt;data, skb_len, DMA_TO_DEVICE);
 	if (dma_mapping_error(kdev, mapping)) {
<span class="p_header">diff --git a/drivers/net/ethernet/cavium/thunder/thunder_xcv.c b/drivers/net/ethernet/cavium/thunder/thunder_xcv.c</span>
<span class="p_header">index 67befedef709..578c7f8f11bf 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/cavium/thunder/thunder_xcv.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/cavium/thunder/thunder_xcv.c</span>
<span class="p_chunk">@@ -116,8 +116,7 @@</span> <span class="p_context"> void xcv_setup_link(bool link_up, int link_speed)</span>
 	int speed = 2;
 
 	if (!xcv) {
<span class="p_del">-		dev_err(&amp;xcv-&gt;pdev-&gt;dev,</span>
<span class="p_del">-			&quot;XCV init not done, probe may have failed\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;XCV init not done, probe may have failed\n&quot;);</span>
 		return;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.c b/drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.c</span>
<span class="p_header">index 0f0de5b63622..d04a6c163445 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.c</span>
<span class="p_chunk">@@ -133,17 +133,15 @@</span> <span class="p_context"> cxgb_find_route6(struct cxgb4_lld_info *lldi,</span>
 		if (ipv6_addr_type(&amp;fl6.daddr) &amp; IPV6_ADDR_LINKLOCAL)
 			fl6.flowi6_oif = sin6_scope_id;
 		dst = ip6_route_output(&amp;init_net, NULL, &amp;fl6);
<span class="p_del">-		if (!dst)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		if (!cxgb_our_interface(lldi, get_real_dev,</span>
<span class="p_del">-					ip6_dst_idev(dst)-&gt;dev) &amp;&amp;</span>
<span class="p_del">-		    !(ip6_dst_idev(dst)-&gt;dev-&gt;flags &amp; IFF_LOOPBACK)) {</span>
<span class="p_add">+		if (dst-&gt;error ||</span>
<span class="p_add">+		    (!cxgb_our_interface(lldi, get_real_dev,</span>
<span class="p_add">+					 ip6_dst_idev(dst)-&gt;dev) &amp;&amp;</span>
<span class="p_add">+		     !(ip6_dst_idev(dst)-&gt;dev-&gt;flags &amp; IFF_LOOPBACK))) {</span>
 			dst_release(dst);
<span class="p_del">-			dst = NULL;</span>
<span class="p_add">+			return NULL;</span>
 		}
 	}
 
<span class="p_del">-out:</span>
 	return dst;
 }
 EXPORT_SYMBOL(cxgb_find_route6);
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">index 5626908f3f7a..1644896568c4 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_chunk">@@ -275,8 +275,7 @@</span> <span class="p_context"> static int be_dev_mac_add(struct be_adapter *adapter, u8 *mac)</span>
 
 	/* Check if mac has already been added as part of uc-list */
 	for (i = 0; i &lt; adapter-&gt;uc_macs; i++) {
<span class="p_del">-		if (ether_addr_equal((u8 *)&amp;adapter-&gt;uc_list[i * ETH_ALEN],</span>
<span class="p_del">-				     mac)) {</span>
<span class="p_add">+		if (ether_addr_equal(adapter-&gt;uc_list[i].mac, mac)) {</span>
 			/* mac already added, skip addition */
 			adapter-&gt;pmac_id[0] = adapter-&gt;pmac_id[i + 1];
 			return 0;
<span class="p_chunk">@@ -363,8 +362,10 @@</span> <span class="p_context"> static int be_mac_addr_set(struct net_device *netdev, void *p)</span>
 		status = -EPERM;
 		goto err;
 	}
<span class="p_del">-done:</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Remember currently programmed MAC */</span>
 	ether_addr_copy(adapter-&gt;dev_mac, addr-&gt;sa_data);
<span class="p_add">+done:</span>
 	ether_addr_copy(netdev-&gt;dev_addr, addr-&gt;sa_data);
 	dev_info(dev, &quot;MAC address changed to %pM\n&quot;, addr-&gt;sa_data);
 	return 0;
<span class="p_chunk">@@ -1679,14 +1680,12 @@</span> <span class="p_context"> static void be_clear_mc_list(struct be_adapter *adapter)</span>
 
 static int be_uc_mac_add(struct be_adapter *adapter, int uc_idx)
 {
<span class="p_del">-	if (ether_addr_equal((u8 *)&amp;adapter-&gt;uc_list[uc_idx * ETH_ALEN],</span>
<span class="p_del">-			     adapter-&gt;dev_mac)) {</span>
<span class="p_add">+	if (ether_addr_equal(adapter-&gt;uc_list[uc_idx].mac, adapter-&gt;dev_mac)) {</span>
 		adapter-&gt;pmac_id[uc_idx + 1] = adapter-&gt;pmac_id[0];
 		return 0;
 	}
 
<span class="p_del">-	return be_cmd_pmac_add(adapter,</span>
<span class="p_del">-			       (u8 *)&amp;adapter-&gt;uc_list[uc_idx * ETH_ALEN],</span>
<span class="p_add">+	return be_cmd_pmac_add(adapter, adapter-&gt;uc_list[uc_idx].mac,</span>
 			       adapter-&gt;if_handle,
 			       &amp;adapter-&gt;pmac_id[uc_idx + 1], 0);
 }
<span class="p_chunk">@@ -1722,9 +1721,8 @@</span> <span class="p_context"> static void be_set_uc_list(struct be_adapter *adapter)</span>
 	}
 
 	if (adapter-&gt;update_uc_list) {
<span class="p_del">-		i = 1; /* First slot is claimed by the Primary MAC */</span>
<span class="p_del">-</span>
 		/* cache the uc-list in adapter array */
<span class="p_add">+		i = 0;</span>
 		netdev_for_each_uc_addr(ha, netdev) {
 			ether_addr_copy(adapter-&gt;uc_list[i].mac, ha-&gt;addr);
 			i++;
<span class="p_chunk">@@ -3639,8 +3637,10 @@</span> <span class="p_context"> static void be_disable_if_filters(struct be_adapter *adapter)</span>
 {
 	/* Don&#39;t delete MAC on BE3 VFs without FILTMGMT privilege  */
 	if (!BEx_chip(adapter) || !be_virtfn(adapter) ||
<span class="p_del">-	    check_privilege(adapter, BE_PRIV_FILTMGMT))</span>
<span class="p_add">+	    check_privilege(adapter, BE_PRIV_FILTMGMT)) {</span>
 		be_dev_mac_del(adapter, adapter-&gt;pmac_id[0]);
<span class="p_add">+		eth_zero_addr(adapter-&gt;dev_mac);</span>
<span class="p_add">+	}</span>
 
 	be_clear_uc_list(adapter);
 	be_clear_mc_list(adapter);
<span class="p_chunk">@@ -3794,12 +3794,27 @@</span> <span class="p_context"> static int be_enable_if_filters(struct be_adapter *adapter)</span>
 	if (status)
 		return status;
 
<span class="p_del">-	/* Don&#39;t add MAC on BE3 VFs without FILTMGMT privilege */</span>
<span class="p_del">-	if (!BEx_chip(adapter) || !be_virtfn(adapter) ||</span>
<span class="p_del">-	    check_privilege(adapter, BE_PRIV_FILTMGMT)) {</span>
<span class="p_add">+	/* Normally this condition usually true as the -&gt;dev_mac is zeroed.</span>
<span class="p_add">+	 * But on BE3 VFs the initial MAC is pre-programmed by PF and</span>
<span class="p_add">+	 * subsequent be_dev_mac_add() can fail (after fresh boot)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ether_addr_equal(adapter-&gt;dev_mac, adapter-&gt;netdev-&gt;dev_addr)) {</span>
<span class="p_add">+		int old_pmac_id = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Remember old programmed MAC if any - can happen on BE3 VF */</span>
<span class="p_add">+		if (!is_zero_ether_addr(adapter-&gt;dev_mac))</span>
<span class="p_add">+			old_pmac_id = adapter-&gt;pmac_id[0];</span>
<span class="p_add">+</span>
 		status = be_dev_mac_add(adapter, adapter-&gt;netdev-&gt;dev_addr);
 		if (status)
 			return status;
<span class="p_add">+</span>
<span class="p_add">+		/* Delete the old programmed MAC as we successfully programmed</span>
<span class="p_add">+		 * a new MAC</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (old_pmac_id &gt;= 0 &amp;&amp; old_pmac_id != adapter-&gt;pmac_id[0])</span>
<span class="p_add">+			be_dev_mac_del(adapter, old_pmac_id);</span>
<span class="p_add">+</span>
 		ether_addr_copy(adapter-&gt;dev_mac, adapter-&gt;netdev-&gt;dev_addr);
 	}
 
<span class="p_chunk">@@ -4573,6 +4588,10 @@</span> <span class="p_context"> static int be_mac_setup(struct be_adapter *adapter)</span>
 
 		memcpy(adapter-&gt;netdev-&gt;dev_addr, mac, ETH_ALEN);
 		memcpy(adapter-&gt;netdev-&gt;perm_addr, mac, ETH_ALEN);
<span class="p_add">+</span>
<span class="p_add">+		/* Initial MAC for BE3 VFs is already programmed by PF */</span>
<span class="p_add">+		if (BEx_chip(adapter) &amp;&amp; be_virtfn(adapter))</span>
<span class="p_add">+			memcpy(adapter-&gt;dev_mac, mac, ETH_ALEN);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_header">index 12aef1b15356..849b8712ec81 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_chunk">@@ -2923,6 +2923,7 @@</span> <span class="p_context"> static void set_multicast_list(struct net_device *ndev)</span>
 	struct netdev_hw_addr *ha;
 	unsigned int i, bit, data, crc, tmp;
 	unsigned char hash;
<span class="p_add">+	unsigned int hash_high = 0, hash_low = 0;</span>
 
 	if (ndev-&gt;flags &amp; IFF_PROMISC) {
 		tmp = readl(fep-&gt;hwp + FEC_R_CNTRL);
<span class="p_chunk">@@ -2945,11 +2946,7 @@</span> <span class="p_context"> static void set_multicast_list(struct net_device *ndev)</span>
 		return;
 	}
 
<span class="p_del">-	/* Clear filter and add the addresses in hash register</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	writel(0, fep-&gt;hwp + FEC_GRP_HASH_TABLE_HIGH);</span>
<span class="p_del">-	writel(0, fep-&gt;hwp + FEC_GRP_HASH_TABLE_LOW);</span>
<span class="p_del">-</span>
<span class="p_add">+	/* Add the addresses in hash register */</span>
 	netdev_for_each_mc_addr(ha, ndev) {
 		/* calculate crc32 value of mac address */
 		crc = 0xffffffff;
<span class="p_chunk">@@ -2967,16 +2964,14 @@</span> <span class="p_context"> static void set_multicast_list(struct net_device *ndev)</span>
 		 */
 		hash = (crc &gt;&gt; (32 - FEC_HASH_BITS)) &amp; 0x3f;
 
<span class="p_del">-		if (hash &gt; 31) {</span>
<span class="p_del">-			tmp = readl(fep-&gt;hwp + FEC_GRP_HASH_TABLE_HIGH);</span>
<span class="p_del">-			tmp |= 1 &lt;&lt; (hash - 32);</span>
<span class="p_del">-			writel(tmp, fep-&gt;hwp + FEC_GRP_HASH_TABLE_HIGH);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			tmp = readl(fep-&gt;hwp + FEC_GRP_HASH_TABLE_LOW);</span>
<span class="p_del">-			tmp |= 1 &lt;&lt; hash;</span>
<span class="p_del">-			writel(tmp, fep-&gt;hwp + FEC_GRP_HASH_TABLE_LOW);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (hash &gt; 31)</span>
<span class="p_add">+			hash_high |= 1 &lt;&lt; (hash - 32);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			hash_low |= 1 &lt;&lt; hash;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	writel(hash_high, fep-&gt;hwp + FEC_GRP_HASH_TABLE_HIGH);</span>
<span class="p_add">+	writel(hash_low, fep-&gt;hwp + FEC_GRP_HASH_TABLE_LOW);</span>
 }
 
 /* Set a MAC change in hardware. */
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_clock.c b/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_header">index d4d97ca12e83..f9897d17f01d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_chunk">@@ -251,13 +251,9 @@</span> <span class="p_context"> static u32 freq_to_shift(u16 freq)</span>
 {
 	u32 freq_khz = freq * 1000;
 	u64 max_val_cycles = freq_khz * 1000 * MLX4_EN_WRAP_AROUND_SEC;
<span class="p_del">-	u64 tmp_rounded =</span>
<span class="p_del">-		roundup_pow_of_two(max_val_cycles) &gt; max_val_cycles ?</span>
<span class="p_del">-		roundup_pow_of_two(max_val_cycles) - 1 : UINT_MAX;</span>
<span class="p_del">-	u64 max_val_cycles_rounded = is_power_of_2(max_val_cycles + 1) ?</span>
<span class="p_del">-		max_val_cycles : tmp_rounded;</span>
<span class="p_add">+	u64 max_val_cycles_rounded = 1ULL &lt;&lt; fls64(max_val_cycles - 1);</span>
 	/* calculate max possible multiplier in order to fit in 64bit */
<span class="p_del">-	u64 max_mul = div_u64(0xffffffffffffffffULL, max_val_cycles_rounded);</span>
<span class="p_add">+	u64 max_mul = div64_u64(ULLONG_MAX, max_val_cycles_rounded);</span>
 
 	/* This comes from the reverse of clocksource_khz2mult */
 	return ilog2(div_u64(max_mul * freq_khz, 1000000));
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/ravb_main.c b/drivers/net/ethernet/renesas/ravb_main.c</span>
<span class="p_header">index 11623aad0e8e..10d3a9f6349e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/ravb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/ravb_main.c</span>
<span class="p_chunk">@@ -941,14 +941,10 @@</span> <span class="p_context"> static int ravb_poll(struct napi_struct *napi, int budget)</span>
 	/* Receive error message handling */
 	priv-&gt;rx_over_errors =  priv-&gt;stats[RAVB_BE].rx_over_errors;
 	priv-&gt;rx_over_errors += priv-&gt;stats[RAVB_NC].rx_over_errors;
<span class="p_del">-	if (priv-&gt;rx_over_errors != ndev-&gt;stats.rx_over_errors) {</span>
<span class="p_add">+	if (priv-&gt;rx_over_errors != ndev-&gt;stats.rx_over_errors)</span>
 		ndev-&gt;stats.rx_over_errors = priv-&gt;rx_over_errors;
<span class="p_del">-		netif_err(priv, rx_err, ndev, &quot;Receive Descriptor Empty\n&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (priv-&gt;rx_fifo_errors != ndev-&gt;stats.rx_fifo_errors) {</span>
<span class="p_add">+	if (priv-&gt;rx_fifo_errors != ndev-&gt;stats.rx_fifo_errors)</span>
 		ndev-&gt;stats.rx_fifo_errors = priv-&gt;rx_fifo_errors;
<span class="p_del">-		netif_err(priv, rx_err, ndev, &quot;Receive FIFO Overflow\n&quot;);</span>
<span class="p_del">-	}</span>
 out:
 	return budget - quota;
 }
<span class="p_header">diff --git a/drivers/net/gtp.c b/drivers/net/gtp.c</span>
<span class="p_header">index cebde074d196..cb206e5526c4 100644</span>
<span class="p_header">--- a/drivers/net/gtp.c</span>
<span class="p_header">+++ b/drivers/net/gtp.c</span>
<span class="p_chunk">@@ -69,7 +69,6 @@</span> <span class="p_context"> struct gtp_dev {</span>
 	struct socket		*sock0;
 	struct socket		*sock1u;
 
<span class="p_del">-	struct net		*net;</span>
 	struct net_device	*dev;
 
 	unsigned int		hash_size;
<span class="p_chunk">@@ -316,7 +315,7 @@</span> <span class="p_context"> static int gtp_encap_recv(struct sock *sk, struct sk_buff *skb)</span>
 
 	netdev_dbg(gtp-&gt;dev, &quot;encap_recv sk=%p\n&quot;, sk);
 
<span class="p_del">-	xnet = !net_eq(gtp-&gt;net, dev_net(gtp-&gt;dev));</span>
<span class="p_add">+	xnet = !net_eq(sock_net(sk), dev_net(gtp-&gt;dev));</span>
 
 	switch (udp_sk(sk)-&gt;encap_type) {
 	case UDP_ENCAP_GTP0:
<span class="p_chunk">@@ -612,7 +611,7 @@</span> <span class="p_context"> static netdev_tx_t gtp_dev_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 				    pktinfo.fl4.saddr, pktinfo.fl4.daddr,
 				    pktinfo.iph-&gt;tos,
 				    ip4_dst_hoplimit(&amp;pktinfo.rt-&gt;dst),
<span class="p_del">-				    htons(IP_DF),</span>
<span class="p_add">+				    0,</span>
 				    pktinfo.gtph_port, pktinfo.gtph_port,
 				    true, false);
 		break;
<span class="p_chunk">@@ -658,7 +657,7 @@</span> <span class="p_context"> static void gtp_link_setup(struct net_device *dev)</span>
 static int gtp_hashtable_new(struct gtp_dev *gtp, int hsize);
 static void gtp_hashtable_free(struct gtp_dev *gtp);
 static int gtp_encap_enable(struct net_device *dev, struct gtp_dev *gtp,
<span class="p_del">-			    int fd_gtp0, int fd_gtp1, struct net *src_net);</span>
<span class="p_add">+			    int fd_gtp0, int fd_gtp1);</span>
 
 static int gtp_newlink(struct net *src_net, struct net_device *dev,
 			struct nlattr *tb[], struct nlattr *data[])
<span class="p_chunk">@@ -675,7 +674,7 @@</span> <span class="p_context"> static int gtp_newlink(struct net *src_net, struct net_device *dev,</span>
 	fd0 = nla_get_u32(data[IFLA_GTP_FD0]);
 	fd1 = nla_get_u32(data[IFLA_GTP_FD1]);
 
<span class="p_del">-	err = gtp_encap_enable(dev, gtp, fd0, fd1, src_net);</span>
<span class="p_add">+	err = gtp_encap_enable(dev, gtp, fd0, fd1);</span>
 	if (err &lt; 0)
 		goto out_err;
 
<span class="p_chunk">@@ -821,7 +820,7 @@</span> <span class="p_context"> static void gtp_hashtable_free(struct gtp_dev *gtp)</span>
 }
 
 static int gtp_encap_enable(struct net_device *dev, struct gtp_dev *gtp,
<span class="p_del">-			    int fd_gtp0, int fd_gtp1, struct net *src_net)</span>
<span class="p_add">+			    int fd_gtp0, int fd_gtp1)</span>
 {
 	struct udp_tunnel_sock_cfg tuncfg = {NULL};
 	struct socket *sock0, *sock1u;
<span class="p_chunk">@@ -858,7 +857,6 @@</span> <span class="p_context"> static int gtp_encap_enable(struct net_device *dev, struct gtp_dev *gtp,</span>
 
 	gtp-&gt;sock0 = sock0;
 	gtp-&gt;sock1u = sock1u;
<span class="p_del">-	gtp-&gt;net = src_net;</span>
 
 	tuncfg.sk_user_data = gtp;
 	tuncfg.encap_rcv = gtp_encap_recv;
<span class="p_header">diff --git a/drivers/net/phy/micrel.c b/drivers/net/phy/micrel.c</span>
<span class="p_header">index 222918828655..fbf5945ce00d 100644</span>
<span class="p_header">--- a/drivers/net/phy/micrel.c</span>
<span class="p_header">+++ b/drivers/net/phy/micrel.c</span>
<span class="p_chunk">@@ -1020,7 +1020,7 @@</span> <span class="p_context"> static struct phy_driver ksphy_driver[] = {</span>
 	.phy_id		= PHY_ID_KSZ8795,
 	.phy_id_mask	= MICREL_PHY_ID_MASK,
 	.name		= &quot;Micrel KSZ8795&quot;,
<span class="p_del">-	.features	= (SUPPORTED_Pause | SUPPORTED_Asym_Pause),</span>
<span class="p_add">+	.features	= PHY_BASIC_FEATURES,</span>
 	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
 	.config_init	= kszphy_config_init,
 	.config_aneg	= ksz8873mll_config_aneg,
<span class="p_header">diff --git a/drivers/net/xen-netback/common.h b/drivers/net/xen-netback/common.h</span>
<span class="p_header">index cb7365bdf6e0..5b1d2e8402d9 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/common.h</span>
<span class="p_header">+++ b/drivers/net/xen-netback/common.h</span>
<span class="p_chunk">@@ -113,10 +113,10 @@</span> <span class="p_context"> struct xenvif_stats {</span>
 	 * A subset of struct net_device_stats that contains only the
 	 * fields that are updated in netback.c for each queue.
 	 */
<span class="p_del">-	unsigned int rx_bytes;</span>
<span class="p_del">-	unsigned int rx_packets;</span>
<span class="p_del">-	unsigned int tx_bytes;</span>
<span class="p_del">-	unsigned int tx_packets;</span>
<span class="p_add">+	u64 rx_bytes;</span>
<span class="p_add">+	u64 rx_packets;</span>
<span class="p_add">+	u64 tx_bytes;</span>
<span class="p_add">+	u64 tx_packets;</span>
 
 	/* Additional stats used by xenvif */
 	unsigned long rx_gso_checksum_fixup;
<span class="p_header">diff --git a/drivers/net/xen-netback/interface.c b/drivers/net/xen-netback/interface.c</span>
<span class="p_header">index 5bfaf5578810..618013e7f87b 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/interface.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/interface.c</span>
<span class="p_chunk">@@ -225,10 +225,10 @@</span> <span class="p_context"> static struct net_device_stats *xenvif_get_stats(struct net_device *dev)</span>
 {
 	struct xenvif *vif = netdev_priv(dev);
 	struct xenvif_queue *queue = NULL;
<span class="p_del">-	unsigned long rx_bytes = 0;</span>
<span class="p_del">-	unsigned long rx_packets = 0;</span>
<span class="p_del">-	unsigned long tx_bytes = 0;</span>
<span class="p_del">-	unsigned long tx_packets = 0;</span>
<span class="p_add">+	u64 rx_bytes = 0;</span>
<span class="p_add">+	u64 rx_packets = 0;</span>
<span class="p_add">+	u64 tx_bytes = 0;</span>
<span class="p_add">+	u64 tx_packets = 0;</span>
 	unsigned int index;
 
 	spin_lock(&amp;vif-&gt;lock);
<span class="p_header">diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c</span>
<span class="p_header">index cd442e46afb4..8d498a997e25 100644</span>
<span class="p_header">--- a/drivers/net/xen-netfront.c</span>
<span class="p_header">+++ b/drivers/net/xen-netfront.c</span>
<span class="p_chunk">@@ -1854,27 +1854,19 @@</span> <span class="p_context"> static int talk_to_netback(struct xenbus_device *dev,</span>
 		xennet_destroy_queues(info);
 
 	err = xennet_create_queues(info, &amp;num_queues);
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		goto destroy_ring;</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		xenbus_dev_fatal(dev, err, &quot;creating queues&quot;);</span>
<span class="p_add">+		kfree(info-&gt;queues);</span>
<span class="p_add">+		info-&gt;queues = NULL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	/* Create shared ring, alloc event channel -- for each queue */
 	for (i = 0; i &lt; num_queues; ++i) {
 		queue = &amp;info-&gt;queues[i];
 		err = setup_netfront(dev, queue, feature_split_evtchn);
<span class="p_del">-		if (err) {</span>
<span class="p_del">-			/* setup_netfront() will tidy up the current</span>
<span class="p_del">-			 * queue on error, but we need to clean up</span>
<span class="p_del">-			 * those already allocated.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (i &gt; 0) {</span>
<span class="p_del">-				rtnl_lock();</span>
<span class="p_del">-				netif_set_real_num_tx_queues(info-&gt;netdev, i);</span>
<span class="p_del">-				rtnl_unlock();</span>
<span class="p_del">-				goto destroy_ring;</span>
<span class="p_del">-			} else {</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto destroy_ring;</span>
 	}
 
 again:
<span class="p_chunk">@@ -1964,9 +1956,9 @@</span> <span class="p_context"> static int talk_to_netback(struct xenbus_device *dev,</span>
 	xenbus_transaction_end(xbt, 1);
  destroy_ring:
 	xennet_disconnect_backend(info);
<span class="p_del">-	kfree(info-&gt;queues);</span>
<span class="p_del">-	info-&gt;queues = NULL;</span>
<span class="p_add">+	xennet_destroy_queues(info);</span>
  out:
<span class="p_add">+	device_unregister(&amp;dev-&gt;dev);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/nvme/target/core.c b/drivers/nvme/target/core.c</span>
<span class="p_header">index 55ce769cecee..fbd6d487103f 100644</span>
<span class="p_header">--- a/drivers/nvme/target/core.c</span>
<span class="p_header">+++ b/drivers/nvme/target/core.c</span>
<span class="p_chunk">@@ -816,6 +816,9 @@</span> <span class="p_context"> static void nvmet_ctrl_free(struct kref *ref)</span>
 	list_del(&amp;ctrl-&gt;subsys_entry);
 	mutex_unlock(&amp;subsys-&gt;lock);
 
<span class="p_add">+	flush_work(&amp;ctrl-&gt;async_event_work);</span>
<span class="p_add">+	cancel_work_sync(&amp;ctrl-&gt;fatal_err_work);</span>
<span class="p_add">+</span>
 	ida_simple_remove(&amp;subsys-&gt;cntlid_ida, ctrl-&gt;cntlid);
 	nvmet_subsys_put(subsys);
 
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">index 91f5f55a8a9b..59059ffbb98c 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_chunk">@@ -668,11 +668,9 @@</span> <span class="p_context"> static int qlt_reset(struct scsi_qla_host *vha, void *iocb, int mcmd)</span>
 {
 	struct qla_hw_data *ha = vha-&gt;hw;
 	struct qla_tgt_sess *sess = NULL;
<span class="p_del">-	uint32_t unpacked_lun, lun = 0;</span>
 	uint16_t loop_id;
 	int res = 0;
 	struct imm_ntfy_from_isp *n = (struct imm_ntfy_from_isp *)iocb;
<span class="p_del">-	struct atio_from_isp *a = (struct atio_from_isp *)iocb;</span>
 	unsigned long flags;
 
 	loop_id = le16_to_cpu(n-&gt;u.isp24.nport_handle);
<span class="p_chunk">@@ -725,11 +723,7 @@</span> <span class="p_context"> static int qlt_reset(struct scsi_qla_host *vha, void *iocb, int mcmd)</span>
 	    &quot;loop_id %d)\n&quot;, vha-&gt;host_no, sess, sess-&gt;port_name,
 	    mcmd, loop_id);
 
<span class="p_del">-	lun = a-&gt;u.isp24.fcp_cmnd.lun;</span>
<span class="p_del">-	unpacked_lun = scsilun_to_int((struct scsi_lun *)&amp;lun);</span>
<span class="p_del">-</span>
<span class="p_del">-	return qlt_issue_task_mgmt(sess, unpacked_lun, mcmd,</span>
<span class="p_del">-	    iocb, QLA24XX_MGMT_SEND_NACK);</span>
<span class="p_add">+	return qlt_issue_task_mgmt(sess, 0, mcmd, iocb, QLA24XX_MGMT_SEND_NACK);</span>
 }
 
 /* ha-&gt;tgt.sess_lock supposed to be held on entry */
<span class="p_header">diff --git a/drivers/spi/spi-axi-spi-engine.c b/drivers/spi/spi-axi-spi-engine.c</span>
<span class="p_header">index c1eafbd7610a..da51fed143cd 100644</span>
<span class="p_header">--- a/drivers/spi/spi-axi-spi-engine.c</span>
<span class="p_header">+++ b/drivers/spi/spi-axi-spi-engine.c</span>
<span class="p_chunk">@@ -553,7 +553,7 @@</span> <span class="p_context"> static int spi_engine_probe(struct platform_device *pdev)</span>
 
 static int spi_engine_remove(struct platform_device *pdev)
 {
<span class="p_del">-	struct spi_master *master = platform_get_drvdata(pdev);</span>
<span class="p_add">+	struct spi_master *master = spi_master_get(platform_get_drvdata(pdev));</span>
 	struct spi_engine *spi_engine = spi_master_get_devdata(master);
 	int irq = platform_get_irq(pdev, 0);
 
<span class="p_chunk">@@ -561,6 +561,8 @@</span> <span class="p_context"> static int spi_engine_remove(struct platform_device *pdev)</span>
 
 	free_irq(irq, master);
 
<span class="p_add">+	spi_master_put(master);</span>
<span class="p_add">+</span>
 	writel_relaxed(0xff, spi_engine-&gt;base + SPI_ENGINE_REG_INT_PENDING);
 	writel_relaxed(0x00, spi_engine-&gt;base + SPI_ENGINE_REG_INT_ENABLE);
 	writel_relaxed(0x01, spi_engine-&gt;base + SPI_ENGINE_REG_RESET);
<span class="p_header">diff --git a/drivers/spi/spi-sh-msiof.c b/drivers/spi/spi-sh-msiof.c</span>
<span class="p_header">index 1de3a772eb7d..cbf02ebb30a2 100644</span>
<span class="p_header">--- a/drivers/spi/spi-sh-msiof.c</span>
<span class="p_header">+++ b/drivers/spi/spi-sh-msiof.c</span>
<span class="p_chunk">@@ -862,7 +862,7 @@</span> <span class="p_context"> static int sh_msiof_transfer_one(struct spi_master *master,</span>
 				break;
 			copy32 = copy_bswap32;
 		} else if (bits &lt;= 16) {
<span class="p_del">-			if (l &amp; 1)</span>
<span class="p_add">+			if (l &amp; 3)</span>
 				break;
 			copy32 = copy_wswap32;
 		} else {
<span class="p_header">diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c</span>
<span class="p_header">index 29dc249b0c74..3c2c233c2e49 100644</span>
<span class="p_header">--- a/drivers/staging/greybus/loopback.c</span>
<span class="p_header">+++ b/drivers/staging/greybus/loopback.c</span>
<span class="p_chunk">@@ -1034,8 +1034,10 @@</span> <span class="p_context"> static int gb_loopback_fn(void *data)</span>
 				error = gb_loopback_async_sink(gb, size);
 			}
 
<span class="p_del">-			if (error)</span>
<span class="p_add">+			if (error) {</span>
 				gb-&gt;error++;
<span class="p_add">+				gb-&gt;iteration_count++;</span>
<span class="p_add">+			}</span>
 		} else {
 			/* We are effectively single threaded here */
 			if (type == GB_LOOPBACK_TYPE_PING)
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/llite/llite_mmap.c b/drivers/staging/lustre/lustre/llite/llite_mmap.c</span>
<span class="p_header">index 436691814a5e..27333d973bcd 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/llite/llite_mmap.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/llite/llite_mmap.c</span>
<span class="p_chunk">@@ -401,15 +401,13 @@</span> <span class="p_context"> static int ll_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)</span>
 		result = VM_FAULT_LOCKED;
 		break;
 	case -ENODATA:
<span class="p_add">+	case -EAGAIN:</span>
 	case -EFAULT:
 		result = VM_FAULT_NOPAGE;
 		break;
 	case -ENOMEM:
 		result = VM_FAULT_OOM;
 		break;
<span class="p_del">-	case -EAGAIN:</span>
<span class="p_del">-		result = VM_FAULT_RETRY;</span>
<span class="p_del">-		break;</span>
 	default:
 		result = VM_FAULT_SIGBUS;
 		break;
<span class="p_header">diff --git a/drivers/staging/media/cec/cec-adap.c b/drivers/staging/media/cec/cec-adap.c</span>
<span class="p_header">index 499d7bfe7147..75e6d5e0504f 100644</span>
<span class="p_header">--- a/drivers/staging/media/cec/cec-adap.c</span>
<span class="p_header">+++ b/drivers/staging/media/cec/cec-adap.c</span>
<span class="p_chunk">@@ -608,8 +608,7 @@</span> <span class="p_context"> int cec_transmit_msg_fh(struct cec_adapter *adap, struct cec_msg *msg,</span>
 	}
 	memset(msg-&gt;msg + msg-&gt;len, 0, sizeof(msg-&gt;msg) - msg-&gt;len);
 	if (msg-&gt;len == 1) {
<span class="p_del">-		if (cec_msg_initiator(msg) != 0xf ||</span>
<span class="p_del">-		    cec_msg_destination(msg) == 0xf) {</span>
<span class="p_add">+		if (cec_msg_destination(msg) == 0xf) {</span>
 			dprintk(1, &quot;cec_transmit_msg: invalid poll message\n&quot;);
 			return -EINVAL;
 		}
<span class="p_chunk">@@ -634,7 +633,7 @@</span> <span class="p_context"> int cec_transmit_msg_fh(struct cec_adapter *adap, struct cec_msg *msg,</span>
 		dprintk(1, &quot;cec_transmit_msg: destination is the adapter itself\n&quot;);
 		return -EINVAL;
 	}
<span class="p_del">-	if (cec_msg_initiator(msg) != 0xf &amp;&amp;</span>
<span class="p_add">+	if (msg-&gt;len &gt; 1 &amp;&amp; adap-&gt;is_configured &amp;&amp;</span>
 	    !cec_has_log_addr(adap, cec_msg_initiator(msg))) {
 		dprintk(1, &quot;cec_transmit_msg: initiator has unknown logical address %d\n&quot;,
 			cec_msg_initiator(msg));
<span class="p_chunk">@@ -883,7 +882,7 @@</span> <span class="p_context"> static int cec_config_log_addr(struct cec_adapter *adap,</span>
 
 	/* Send poll message */
 	msg.len = 1;
<span class="p_del">-	msg.msg[0] = 0xf0 | log_addr;</span>
<span class="p_add">+	msg.msg[0] = (log_addr &lt;&lt; 4) | log_addr;</span>
 	err = cec_transmit_msg_fh(adap, &amp;msg, NULL, true);
 
 	/*
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_mlme.c b/drivers/staging/rtl8188eu/core/rtw_mlme.c</span>
<span class="p_header">index ee2dcd05010f..0b60d1e0333e 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_mlme.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_mlme.c</span>
<span class="p_chunk">@@ -107,10 +107,10 @@</span> <span class="p_context"> void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)</span>
 
 void rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)
 {
<span class="p_del">-	rtw_free_mlme_priv_ie_data(pmlmepriv);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pmlmepriv)</span>
<span class="p_add">+	if (pmlmepriv) {</span>
<span class="p_add">+		rtw_free_mlme_priv_ie_data(pmlmepriv);</span>
 		vfree(pmlmepriv-&gt;free_bss_buf);
<span class="p_add">+	}</span>
 }
 
 struct wlan_network *_rtw_alloc_network(struct mlme_priv *pmlmepriv)
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c</span>
<span class="p_header">index f8c31070a337..2ffebb7e5ff8 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_fintek.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_fintek.c</span>
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"> static int fintek_8250_rs485_config(struct uart_port *port,</span>
 
 	if ((!!(rs485-&gt;flags &amp; SER_RS485_RTS_ON_SEND)) ==
 			(!!(rs485-&gt;flags &amp; SER_RS485_RTS_AFTER_SEND)))
<span class="p_del">-		rs485-&gt;flags &amp;= SER_RS485_ENABLED;</span>
<span class="p_add">+		rs485-&gt;flags &amp;= ~SER_RS485_ENABLED;</span>
 	else
 		config |= RS485_URA;
 
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index 22d32d295c5b..b80ea872b039 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -5568,6 +5568,9 @@</span> <span class="p_context"> static struct pci_device_id serial_pci_tbl[] = {</span>
 	{ PCI_DEVICE(0x1601, 0x0800), .driver_data = pbn_b0_4_1250000 },
 	{ PCI_DEVICE(0x1601, 0xa801), .driver_data = pbn_b0_4_1250000 },
 
<span class="p_add">+	/* Amazon PCI serial device */</span>
<span class="p_add">+	{ PCI_DEVICE(0x1d0f, 0x8250), .driver_data = pbn_b0_1_115200 },</span>
<span class="p_add">+</span>
 	/*
 	 * These entries match devices with class COMMUNICATION_SERIAL,
 	 * COMMUNICATION_MODEM or COMMUNICATION_MULTISERIAL
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">index 1ef31e3ee4a1..f6e4373a8850 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_chunk">@@ -2526,8 +2526,11 @@</span> <span class="p_context"> static void serial8250_set_divisor(struct uart_port *port, unsigned int baud,</span>
 	serial_dl_write(up, quot);
 
 	/* XR17V35x UARTs have an extra fractional divisor register (DLD) */
<span class="p_del">-	if (up-&gt;port.type == PORT_XR17V35X)</span>
<span class="p_add">+	if (up-&gt;port.type == PORT_XR17V35X) {</span>
<span class="p_add">+		/* Preserve bits not related to baudrate; DLD[7:4]. */</span>
<span class="p_add">+		quot_frac |= serial_port_in(port, 0x2) &amp; 0xf0;</span>
 		serial_port_out(port, 0x2, quot_frac);
<span class="p_add">+	}</span>
 }
 
 static unsigned int serial8250_get_baud_rate(struct uart_port *port,
<span class="p_header">diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c</span>
<span class="p_header">index 701c085bb19b..53cbf4ebef10 100644</span>
<span class="p_header">--- a/drivers/tty/sysrq.c</span>
<span class="p_header">+++ b/drivers/tty/sysrq.c</span>
<span class="p_chunk">@@ -243,8 +243,10 @@</span> <span class="p_context"> static void sysrq_handle_showallcpus(int key)</span>
 	 * architecture has no support for it:
 	 */
 	if (!trigger_all_cpu_backtrace()) {
<span class="p_del">-		struct pt_regs *regs = get_irq_regs();</span>
<span class="p_add">+		struct pt_regs *regs = NULL;</span>
 
<span class="p_add">+		if (in_irq())</span>
<span class="p_add">+			regs = get_irq_regs();</span>
 		if (regs) {
 			pr_info(&quot;CPU%d:\n&quot;, smp_processor_id());
 			show_regs(regs);
<span class="p_chunk">@@ -263,7 +265,10 @@</span> <span class="p_context"> static struct sysrq_key_op sysrq_showallcpus_op = {</span>
 
 static void sysrq_handle_showregs(int key)
 {
<span class="p_del">-	struct pt_regs *regs = get_irq_regs();</span>
<span class="p_add">+	struct pt_regs *regs = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (in_irq())</span>
<span class="p_add">+		regs = get_irq_regs();</span>
 	if (regs)
 		show_regs(regs);
 	perf_event_print_debug();
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 5008f71fb08d..5ebe04d3598b 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -900,14 +900,25 @@</span> <span class="p_context"> void usb_release_bos_descriptor(struct usb_device *dev)</span>
 	}
 }
 
<span class="p_add">+static const __u8 bos_desc_len[256] = {</span>
<span class="p_add">+	[USB_CAP_TYPE_WIRELESS_USB] = USB_DT_USB_WIRELESS_CAP_SIZE,</span>
<span class="p_add">+	[USB_CAP_TYPE_EXT]          = USB_DT_USB_EXT_CAP_SIZE,</span>
<span class="p_add">+	[USB_SS_CAP_TYPE]           = USB_DT_USB_SS_CAP_SIZE,</span>
<span class="p_add">+	[USB_SSP_CAP_TYPE]          = USB_DT_USB_SSP_CAP_SIZE(1),</span>
<span class="p_add">+	[CONTAINER_ID_TYPE]         = USB_DT_USB_SS_CONTN_ID_SIZE,</span>
<span class="p_add">+	[USB_PTM_CAP_TYPE]          = USB_DT_USB_PTM_ID_SIZE,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /* Get BOS descriptor set */
 int usb_get_bos_descriptor(struct usb_device *dev)
 {
 	struct device *ddev = &amp;dev-&gt;dev;
 	struct usb_bos_descriptor *bos;
 	struct usb_dev_cap_header *cap;
<span class="p_add">+	struct usb_ssp_cap_descriptor *ssp_cap;</span>
 	unsigned char *buffer;
<span class="p_del">-	int length, total_len, num, i;</span>
<span class="p_add">+	int length, total_len, num, i, ssac;</span>
<span class="p_add">+	__u8 cap_type;</span>
 	int ret;
 
 	bos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);
<span class="p_chunk">@@ -960,7 +971,13 @@</span> <span class="p_context"> int usb_get_bos_descriptor(struct usb_device *dev)</span>
 			dev-&gt;bos-&gt;desc-&gt;bNumDeviceCaps = i;
 			break;
 		}
<span class="p_add">+		cap_type = cap-&gt;bDevCapabilityType;</span>
 		length = cap-&gt;bLength;
<span class="p_add">+		if (bos_desc_len[cap_type] &amp;&amp; length &lt; bos_desc_len[cap_type]) {</span>
<span class="p_add">+			dev-&gt;bos-&gt;desc-&gt;bNumDeviceCaps = i;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		total_len -= length;
 
 		if (cap-&gt;bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
<span class="p_chunk">@@ -968,7 +985,7 @@</span> <span class="p_context"> int usb_get_bos_descriptor(struct usb_device *dev)</span>
 			continue;
 		}
 
<span class="p_del">-		switch (cap-&gt;bDevCapabilityType) {</span>
<span class="p_add">+		switch (cap_type) {</span>
 		case USB_CAP_TYPE_WIRELESS_USB:
 			/* Wireless USB cap descriptor is handled by wusb */
 			break;
<span class="p_chunk">@@ -981,8 +998,11 @@</span> <span class="p_context"> int usb_get_bos_descriptor(struct usb_device *dev)</span>
 				(struct usb_ss_cap_descriptor *)buffer;
 			break;
 		case USB_SSP_CAP_TYPE:
<span class="p_del">-			dev-&gt;bos-&gt;ssp_cap =</span>
<span class="p_del">-				(struct usb_ssp_cap_descriptor *)buffer;</span>
<span class="p_add">+			ssp_cap = (struct usb_ssp_cap_descriptor *)buffer;</span>
<span class="p_add">+			ssac = (le32_to_cpu(ssp_cap-&gt;bmAttributes) &amp;</span>
<span class="p_add">+				USB_SSP_SUBLINK_SPEED_ATTRIBS) + 1;</span>
<span class="p_add">+			if (length &gt;= USB_DT_USB_SSP_CAP_SIZE(ssac))</span>
<span class="p_add">+				dev-&gt;bos-&gt;ssp_cap = ssp_cap;</span>
 			break;
 		case CONTAINER_ID_TYPE:
 			dev-&gt;bos-&gt;ss_id =
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index fa619354c5c5..893ebae51029 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -134,42 +134,38 @@</span> <span class="p_context"> enum snoop_when {</span>
 #define USB_DEVICE_DEV		MKDEV(USB_DEVICE_MAJOR, 0)
 
 /* Limit on the total amount of memory we can allocate for transfers */
<span class="p_del">-static unsigned usbfs_memory_mb = 16;</span>
<span class="p_add">+static u32 usbfs_memory_mb = 16;</span>
 module_param(usbfs_memory_mb, uint, 0644);
 MODULE_PARM_DESC(usbfs_memory_mb,
 		&quot;maximum MB allowed for usbfs buffers (0 = no limit)&quot;);
 
 /* Hard limit, necessary to avoid arithmetic overflow */
<span class="p_del">-#define USBFS_XFER_MAX		(UINT_MAX / 2 - 1000000)</span>
<span class="p_add">+#define USBFS_XFER_MAX         (UINT_MAX / 2 - 1000000)</span>
 
<span class="p_del">-static atomic_t usbfs_memory_usage;	/* Total memory currently allocated */</span>
<span class="p_add">+static atomic64_t usbfs_memory_usage;	/* Total memory currently allocated */</span>
 
 /* Check whether it&#39;s okay to allocate more memory for a transfer */
<span class="p_del">-static int usbfs_increase_memory_usage(unsigned amount)</span>
<span class="p_add">+static int usbfs_increase_memory_usage(u64 amount)</span>
 {
<span class="p_del">-	unsigned lim;</span>
<span class="p_add">+	u64 lim;</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Convert usbfs_memory_mb to bytes, avoiding overflows.</span>
<span class="p_del">-	 * 0 means use the hard limit (effectively unlimited).</span>
<span class="p_del">-	 */</span>
 	lim = ACCESS_ONCE(usbfs_memory_mb);
<span class="p_del">-	if (lim == 0 || lim &gt; (USBFS_XFER_MAX &gt;&gt; 20))</span>
<span class="p_del">-		lim = USBFS_XFER_MAX;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		lim &lt;&lt;= 20;</span>
<span class="p_add">+	lim &lt;&lt;= 20;</span>
 
<span class="p_del">-	atomic_add(amount, &amp;usbfs_memory_usage);</span>
<span class="p_del">-	if (atomic_read(&amp;usbfs_memory_usage) &lt;= lim)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	atomic_sub(amount, &amp;usbfs_memory_usage);</span>
<span class="p_del">-	return -ENOMEM;</span>
<span class="p_add">+	atomic64_add(amount, &amp;usbfs_memory_usage);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (lim &gt; 0 &amp;&amp; atomic64_read(&amp;usbfs_memory_usage) &gt; lim) {</span>
<span class="p_add">+		atomic64_sub(amount, &amp;usbfs_memory_usage);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 /* Memory for a transfer is being deallocated */
<span class="p_del">-static void usbfs_decrease_memory_usage(unsigned amount)</span>
<span class="p_add">+static void usbfs_decrease_memory_usage(u64 amount)</span>
 {
<span class="p_del">-	atomic_sub(amount, &amp;usbfs_memory_usage);</span>
<span class="p_add">+	atomic64_sub(amount, &amp;usbfs_memory_usage);</span>
 }
 
 static int connected(struct usb_dev_state *ps)
<span class="p_chunk">@@ -1191,7 +1187,7 @@</span> <span class="p_context"> static int proc_bulk(struct usb_dev_state *ps, void __user *arg)</span>
 	if (!usb_maxpacket(dev, pipe, !(bulk.ep &amp; USB_DIR_IN)))
 		return -EINVAL;
 	len1 = bulk.len;
<span class="p_del">-	if (len1 &gt;= USBFS_XFER_MAX)</span>
<span class="p_add">+	if (len1 &gt;= (INT_MAX - sizeof(struct urb)))</span>
 		return -EINVAL;
 	ret = usbfs_increase_memory_usage(len1 + sizeof(struct urb));
 	if (ret)
<span class="p_chunk">@@ -1458,13 +1454,19 @@</span> <span class="p_context"> static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb</span>
 	int number_of_packets = 0;
 	unsigned int stream_id = 0;
 	void *buf;
<span class="p_del">-</span>
<span class="p_del">-	if (uurb-&gt;flags &amp; ~(USBDEVFS_URB_ISO_ASAP |</span>
<span class="p_del">-				USBDEVFS_URB_SHORT_NOT_OK |</span>
<span class="p_add">+	unsigned long mask =	USBDEVFS_URB_SHORT_NOT_OK |</span>
 				USBDEVFS_URB_BULK_CONTINUATION |
 				USBDEVFS_URB_NO_FSBR |
 				USBDEVFS_URB_ZERO_PACKET |
<span class="p_del">-				USBDEVFS_URB_NO_INTERRUPT))</span>
<span class="p_add">+				USBDEVFS_URB_NO_INTERRUPT;</span>
<span class="p_add">+	/* USBDEVFS_URB_ISO_ASAP is a special case */</span>
<span class="p_add">+	if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO)</span>
<span class="p_add">+		mask |= USBDEVFS_URB_ISO_ASAP;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (uurb-&gt;flags &amp; ~mask)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((unsigned int)uurb-&gt;buffer_length &gt;= USBFS_XFER_MAX)</span>
 		return -EINVAL;
 	if (uurb-&gt;buffer_length &gt; 0 &amp;&amp; !uurb-&gt;buffer)
 		return -EINVAL;
<span class="p_chunk">@@ -1584,10 +1586,6 @@</span> <span class="p_context"> static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (uurb-&gt;buffer_length &gt;= USBFS_XFER_MAX) {</span>
<span class="p_del">-		ret = -EINVAL;</span>
<span class="p_del">-		goto error;</span>
<span class="p_del">-	}</span>
 	if (uurb-&gt;buffer_length &gt; 0 &amp;&amp;
 			!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
 				uurb-&gt;buffer, uurb-&gt;buffer_length)) {
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 706b3d6a7614..d0d3f9ef9f10 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -4925,6 +4925,15 @@</span> <span class="p_context"> static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,</span>
 		usb_put_dev(udev);
 		if ((status == -ENOTCONN) || (status == -ENOTSUPP))
 			break;
<span class="p_add">+</span>
<span class="p_add">+		/* When halfway through our retry count, power-cycle the port */</span>
<span class="p_add">+		if (i == (SET_CONFIG_TRIES / 2) - 1) {</span>
<span class="p_add">+			dev_info(&amp;port_dev-&gt;dev, &quot;attempt power cycle\n&quot;);</span>
<span class="p_add">+			usb_hub_set_port_power(hdev, hub, port1, false);</span>
<span class="p_add">+			msleep(2 * hub_power_on_good_delay(hub));</span>
<span class="p_add">+			usb_hub_set_port_power(hdev, hub, port1, true);</span>
<span class="p_add">+			msleep(hub_power_on_good_delay(hub));</span>
<span class="p_add">+		}</span>
 	}
 	if (hub-&gt;hdev-&gt;parent ||
 			!hcd-&gt;driver-&gt;port_handed_over ||
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 37c418e581fb..50010282c010 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -151,6 +151,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* appletouch */
 	{ USB_DEVICE(0x05ac, 0x021a), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_add">+	/* Genesys Logic hub, internally used by KY-688 USB 3.1 Type-C Hub */</span>
<span class="p_add">+	{ USB_DEVICE(0x05e3, 0x0612), .driver_info = USB_QUIRK_NO_LPM },</span>
<span class="p_add">+</span>
 	/* Genesys Logic hub, internally used by Moshi USB to Ethernet Adapter */
 	{ USB_DEVICE(0x05e3, 0x0616), .driver_info = USB_QUIRK_NO_LPM },
 
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index 273320fa30ae..4fce83266926 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -2263,7 +2263,7 @@</span> <span class="p_context"> static int __ffs_data_do_os_desc(enum ffs_os_desc_type type,</span>
 
 		if (len &lt; sizeof(*d) ||
 		    d-&gt;bFirstInterfaceNumber &gt;= ffs-&gt;interfaces_count ||
<span class="p_del">-		    !d-&gt;Reserved1)</span>
<span class="p_add">+		    d-&gt;Reserved1)</span>
 			return -EINVAL;
 		for (i = 0; i &lt; ARRAY_SIZE(d-&gt;Reserved2); ++i)
 			if (d-&gt;Reserved2[i])
<span class="p_header">diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c</span>
<span class="p_header">index 1a2614aae42c..3ff6468a1f5f 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-dbg.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-dbg.c</span>
<span class="p_chunk">@@ -837,7 +837,7 @@</span> <span class="p_context"> static ssize_t fill_registers_buffer(struct debug_buffer *buf)</span>
 			default:		/* unknown */
 				break;
 			}
<span class="p_del">-			temp = (cap &gt;&gt; 8) &amp; 0xff;</span>
<span class="p_add">+			offset = (cap &gt;&gt; 8) &amp; 0xff;</span>
 		}
 	}
 #endif
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index b7114c3f52aa..a3ecd8bd5324 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -996,6 +996,12 @@</span> <span class="p_context"> void xhci_free_virt_devices_depth_first(struct xhci_hcd *xhci, int slot_id)</span>
 	if (!vdev)
 		return;
 
<span class="p_add">+	if (vdev-&gt;real_port == 0 ||</span>
<span class="p_add">+			vdev-&gt;real_port &gt; HCS_MAX_PORTS(xhci-&gt;hcs_params1)) {</span>
<span class="p_add">+		xhci_dbg(xhci, &quot;Bad vdev-&gt;real_port.\n&quot;);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	tt_list_head = &amp;(xhci-&gt;rh_bw[vdev-&gt;real_port - 1].tts);
 	list_for_each_entry_safe(tt_info, next, tt_list_head, tt_list) {
 		/* is this a hub device that added a tt_info to the tts list */
<span class="p_chunk">@@ -1009,6 +1015,7 @@</span> <span class="p_context"> void xhci_free_virt_devices_depth_first(struct xhci_hcd *xhci, int slot_id)</span>
 			}
 		}
 	}
<span class="p_add">+out:</span>
 	/* we are now at a leaf device */
 	xhci_free_virt_device(xhci, slot_id);
 }
<span class="p_header">diff --git a/drivers/usb/phy/phy-tahvo.c b/drivers/usb/phy/phy-tahvo.c</span>
<span class="p_header">index ab5d364f6e8c..335a1ef35224 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy-tahvo.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy-tahvo.c</span>
<span class="p_chunk">@@ -368,7 +368,8 @@</span> <span class="p_context"> static int tahvo_usb_probe(struct platform_device *pdev)</span>
 	tu-&gt;extcon = devm_extcon_dev_allocate(&amp;pdev-&gt;dev, tahvo_cable);
 	if (IS_ERR(tu-&gt;extcon)) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to allocate memory for extcon\n&quot;);
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		ret = PTR_ERR(tu-&gt;extcon);</span>
<span class="p_add">+		goto err_disable_clk;</span>
 	}
 
 	ret = devm_extcon_dev_register(&amp;pdev-&gt;dev, tu-&gt;extcon);
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index db3d34c2c82e..ffa8ec917ff5 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -241,6 +241,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 /* These Quectel products use Quectel&#39;s vendor ID */
 #define QUECTEL_PRODUCT_EC21			0x0121
 #define QUECTEL_PRODUCT_EC25			0x0125
<span class="p_add">+#define QUECTEL_PRODUCT_BG96			0x0296</span>
 
 #define CMOTECH_VENDOR_ID			0x16d8
 #define CMOTECH_PRODUCT_6001			0x6001
<span class="p_chunk">@@ -1185,6 +1186,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC25),
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_add">+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_CMU_300) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6003),
<span class="p_header">diff --git a/drivers/usb/storage/uas-detect.h b/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">index a155cd02bce2..ecc83c405a8b 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">+++ b/drivers/usb/storage/uas-detect.h</span>
<span class="p_chunk">@@ -111,6 +111,10 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 		}
 	}
 
<span class="p_add">+	/* All Seagate disk enclosures have broken ATA pass-through support */</span>
<span class="p_add">+	if (le16_to_cpu(udev-&gt;descriptor.idVendor) == 0x0bc2)</span>
<span class="p_add">+		flags |= US_FL_NO_ATA_1X;</span>
<span class="p_add">+</span>
 	usb_stor_adjust_quirks(udev, &amp;flags);
 
 	if (flags &amp; US_FL_IGNORE_UAS) {
<span class="p_header">diff --git a/drivers/vfio/vfio_iommu_spapr_tce.c b/drivers/vfio/vfio_iommu_spapr_tce.c</span>
<span class="p_header">index 85d3e648bdea..59b3f62a2d64 100644</span>
<span class="p_header">--- a/drivers/vfio/vfio_iommu_spapr_tce.c</span>
<span class="p_header">+++ b/drivers/vfio/vfio_iommu_spapr_tce.c</span>
<span class="p_chunk">@@ -1123,12 +1123,11 @@</span> <span class="p_context"> static long tce_iommu_ioctl(void *iommu_data,</span>
 		mutex_lock(&amp;container-&gt;lock);
 
 		ret = tce_iommu_create_default_window(container);
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = tce_iommu_create_window(container, create.page_shift,</span>
<span class="p_del">-				create.window_size, create.levels,</span>
<span class="p_del">-				&amp;create.start_addr);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			ret = tce_iommu_create_window(container,</span>
<span class="p_add">+					create.page_shift,</span>
<span class="p_add">+					create.window_size, create.levels,</span>
<span class="p_add">+					&amp;create.start_addr);</span>
 
 		mutex_unlock(&amp;container-&gt;lock);
 
<span class="p_header">diff --git a/fs/dax.c b/fs/dax.c</span>
<span class="p_header">index bf6218da7928..800748f10b3d 100644</span>
<span class="p_header">--- a/fs/dax.c</span>
<span class="p_header">+++ b/fs/dax.c</span>
<span class="p_chunk">@@ -1265,6 +1265,17 @@</span> <span class="p_context"> iomap_dax_actor(struct inode *inode, loff_t pos, loff_t length, void *data,</span>
 	if (WARN_ON_ONCE(iomap-&gt;type != IOMAP_MAPPED))
 		return -EIO;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Write can allocate block for an area which has a hole page mapped</span>
<span class="p_add">+	 * into page tables. We have to tear down these mappings so that data</span>
<span class="p_add">+	 * written by write(2) is visible in mmap.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((iomap-&gt;flags &amp; IOMAP_F_NEW) &amp;&amp; inode-&gt;i_mapping-&gt;nrpages) {</span>
<span class="p_add">+		invalidate_inode_pages2_range(inode-&gt;i_mapping,</span>
<span class="p_add">+					      pos &gt;&gt; PAGE_SHIFT,</span>
<span class="p_add">+					      (end - 1) &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	while (pos &lt; end) {
 		unsigned offset = pos &amp; (PAGE_SIZE - 1);
 		struct blk_dax_ctl dax = { 0 };
<span class="p_chunk">@@ -1329,23 +1340,6 @@</span> <span class="p_context"> iomap_dax_rw(struct kiocb *iocb, struct iov_iter *iter,</span>
 	if (iov_iter_rw(iter) == WRITE)
 		flags |= IOMAP_WRITE;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Yes, even DAX files can have page cache attached to them:  A zeroed</span>
<span class="p_del">-	 * page is inserted into the pagecache when we have to serve a write</span>
<span class="p_del">-	 * fault on a hole.  It should never be dirtied and can simply be</span>
<span class="p_del">-	 * dropped from the pagecache once we get real data for the page.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * XXX: This is racy against mmap, and there&#39;s nothing we can do about</span>
<span class="p_del">-	 * it. We&#39;ll eventually need to shift this down even further so that</span>
<span class="p_del">-	 * we can check if we allocated blocks over a hole first.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mapping-&gt;nrpages) {</span>
<span class="p_del">-		ret = invalidate_inode_pages2_range(mapping,</span>
<span class="p_del">-				pos &gt;&gt; PAGE_SHIFT,</span>
<span class="p_del">-				(pos + iov_iter_count(iter) - 1) &gt;&gt; PAGE_SHIFT);</span>
<span class="p_del">-		WARN_ON_ONCE(ret);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	while (iov_iter_count(iter)) {
 		ret = iomap_apply(inode, pos, iov_iter_count(iter), flags, ops,
 				iter, iomap_dax_actor);
<span class="p_header">diff --git a/fs/libfs.c b/fs/libfs.c</span>
<span class="p_header">index 48826d4da189..9588780ad43e 100644</span>
<span class="p_header">--- a/fs/libfs.c</span>
<span class="p_header">+++ b/fs/libfs.c</span>
<span class="p_chunk">@@ -245,7 +245,8 @@</span> <span class="p_context"> struct dentry *mount_pseudo_xattr(struct file_system_type *fs_type, char *name,</span>
 	struct inode *root;
 	struct qstr d_name = QSTR_INIT(name, strlen(name));
 
<span class="p_del">-	s = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);</span>
<span class="p_add">+	s = sget_userns(fs_type, NULL, set_anon_super, MS_KERNMOUNT|MS_NOUSER,</span>
<span class="p_add">+			&amp;init_user_ns, NULL);</span>
 	if (IS_ERR(s))
 		return ERR_CAST(s);
 
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 67845220fc27..4638654e26f3 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -38,7 +38,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/errno.h&gt;
<span class="p_del">-#include &lt;linux/file.h&gt;</span>
 #include &lt;linux/string.h&gt;
 #include &lt;linux/ratelimit.h&gt;
 #include &lt;linux/printk.h&gt;
<span class="p_chunk">@@ -6006,7 +6005,6 @@</span> <span class="p_context"> static struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,</span>
 	p-&gt;server = server;
 	atomic_inc(&amp;lsp-&gt;ls_count);
 	p-&gt;ctx = get_nfs_open_context(ctx);
<span class="p_del">-	get_file(fl-&gt;fl_file);</span>
 	memcpy(&amp;p-&gt;fl, fl, sizeof(p-&gt;fl));
 	return p;
 out_free_seqid:
<span class="p_chunk">@@ -6119,7 +6117,6 @@</span> <span class="p_context"> static void nfs4_lock_release(void *calldata)</span>
 		nfs_free_seqid(data-&gt;arg.lock_seqid);
 	nfs4_put_lock_state(data-&gt;lsp);
 	put_nfs_open_context(data-&gt;ctx);
<span class="p_del">-	fput(data-&gt;fl.fl_file);</span>
 	kfree(data);
 	dprintk(&quot;%s: done!\n&quot;, __func__);
 }
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index 92671914067f..71deeae6eefd 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1718,7 +1718,6 @@</span> <span class="p_context"> static int nfs4_recovery_handle_error(struct nfs_client *clp, int error)</span>
 			break;
 		case -NFS4ERR_STALE_CLIENTID:
 			set_bit(NFS4CLNT_LEASE_EXPIRED, &amp;clp-&gt;cl_state);
<span class="p_del">-			nfs4_state_clear_reclaim_reboot(clp);</span>
 			nfs4_state_start_reclaim_reboot(clp);
 			break;
 		case -NFS4ERR_EXPIRED:
<span class="p_header">diff --git a/include/linux/buffer_head.h b/include/linux/buffer_head.h</span>
<span class="p_header">index 447a915db25d..4431ea2c8802 100644</span>
<span class="p_header">--- a/include/linux/buffer_head.h</span>
<span class="p_header">+++ b/include/linux/buffer_head.h</span>
<span class="p_chunk">@@ -239,12 +239,10 @@</span> <span class="p_context"> static inline int block_page_mkwrite_return(int err)</span>
 {
 	if (err == 0)
 		return VM_FAULT_LOCKED;
<span class="p_del">-	if (err == -EFAULT)</span>
<span class="p_add">+	if (err == -EFAULT || err == -EAGAIN)</span>
 		return VM_FAULT_NOPAGE;
 	if (err == -ENOMEM)
 		return VM_FAULT_OOM;
<span class="p_del">-	if (err == -EAGAIN)</span>
<span class="p_del">-		return VM_FAULT_RETRY;</span>
 	/* -ENOSPC, -EDQUOT, -EIO ... */
 	return VM_FAULT_SIGBUS;
 }
<span class="p_header">diff --git a/include/linux/fence.h b/include/linux/fence.h</span>
<span class="p_header">index 0d763053f97a..9bb2c0c97a21 100644</span>
<span class="p_header">--- a/include/linux/fence.h</span>
<span class="p_header">+++ b/include/linux/fence.h</span>
<span class="p_chunk">@@ -47,7 +47,7 @@</span> <span class="p_context"> struct fence_cb;</span>
  * can be compared to decide which fence would be signaled later.
  * @flags: A mask of FENCE_FLAG_* defined below
  * @timestamp: Timestamp when the fence was signaled.
<span class="p_del">- * @status: Optional, only valid if &lt; 0, must be set before calling</span>
<span class="p_add">+ * @error: Optional, only valid if &lt; 0, must be set before calling</span>
  * fence_signal, indicates that the fence has completed with an error.
  *
  * the flags member must be manipulated and read using the appropriate
<span class="p_chunk">@@ -79,7 +79,7 @@</span> <span class="p_context"> struct fence {</span>
 	unsigned seqno;
 	unsigned long flags;
 	ktime_t timestamp;
<span class="p_del">-	int status;</span>
<span class="p_add">+	int error;</span>
 };
 
 enum fence_flag_bits {
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> struct fence_cb {</span>
  * or some failure occurred that made it impossible to enable
  * signaling. True indicates successful enabling.
  *
<span class="p_del">- * fence-&gt;status may be set in enable_signaling, but only when false is</span>
<span class="p_add">+ * fence-&gt;error may be set in enable_signaling, but only when false is</span>
  * returned.
  *
  * Calling fence_signal before enable_signaling is called allows
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> struct fence_cb {</span>
  * the second time will be a noop since it was already signaled.
  *
  * Notes on signaled:
<span class="p_del">- * May set fence-&gt;status if returning true.</span>
<span class="p_add">+ * May set fence-&gt;error if returning true.</span>
  *
  * Notes on wait:
  * Must not be NULL, set to fence_default_wait for default implementation.
<span class="p_chunk">@@ -280,6 +280,19 @@</span> <span class="p_context"> fence_is_signaled(struct fence *fence)</span>
 	return false;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * __fence_is_later - return if f1 is chronologically later than f2</span>
<span class="p_add">+ * @f1:	[in]	the first fence&#39;s seqno</span>
<span class="p_add">+ * @f2:	[in]	the second fence&#39;s seqno from the same context</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns true if f1 is chronologically later than f2. Both fences must be</span>
<span class="p_add">+ * from the same context, since a seqno is not common across contexts.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool __fence_is_later(u32 f1, u32 f2)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (int)(f1 - f2) &gt; 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * fence_is_later - return if f1 is chronologically later than f2
  * @f1:	[in]	the first fence from the same context
<span class="p_chunk">@@ -293,7 +306,7 @@</span> <span class="p_context"> static inline bool fence_is_later(struct fence *f1, struct fence *f2)</span>
 	if (WARN_ON(f1-&gt;context != f2-&gt;context))
 		return false;
 
<span class="p_del">-	return (int)(f1-&gt;seqno - f2-&gt;seqno) &gt; 0;</span>
<span class="p_add">+	return __fence_is_later(f1-&gt;seqno, f2-&gt;seqno);</span>
 }
 
 /**
<span class="p_chunk">@@ -321,6 +334,50 @@</span> <span class="p_context"> static inline struct fence *fence_later(struct fence *f1, struct fence *f2)</span>
 		return fence_is_signaled(f2) ? NULL : f2;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * fence_get_status_locked - returns the status upon completion</span>
<span class="p_add">+ * @fence: [in]	the fence to query</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Drivers can supply an optional error status condition before they signal</span>
<span class="p_add">+ * the fence (to indicate whether the fence was completed due to an error</span>
<span class="p_add">+ * rather than success). The value of the status condition is only valid</span>
<span class="p_add">+ * if the fence has been signaled, fence_get_status_locked() first checks</span>
<span class="p_add">+ * the signal state before reporting the error status.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns 0 if the fence has not yet been signaled, 1 if the fence has</span>
<span class="p_add">+ * been signaled without an error condition, or a negative error code</span>
<span class="p_add">+ * if the fence has been completed in err.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int fence_get_status_locked(struct fence *fence)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (fence_is_signaled_locked(fence))</span>
<span class="p_add">+		return fence-&gt;error ?: 1;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int fence_get_status(struct fence *fence);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * fence_set_error - flag an error condition on the fence</span>
<span class="p_add">+ * @fence: [in]	the fence</span>
<span class="p_add">+ * @error: [in]	the error to store</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Drivers can supply an optional error status condition before they signal</span>
<span class="p_add">+ * the fence, to indicate that the fence was completed due to an error</span>
<span class="p_add">+ * rather than success. This must be set before signaling (so that the value</span>
<span class="p_add">+ * is visible before any waiters on the signal callback are woken). This</span>
<span class="p_add">+ * helper exists to help catching erroneous setting of #fence.error.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void fence_set_error(struct fence *fence,</span>
<span class="p_add">+				       int error)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(test_bit(FENCE_FLAG_SIGNALED_BIT, &amp;fence-&gt;flags));</span>
<span class="p_add">+	BUG_ON(error &gt;= 0 || error &lt; -MAX_ERRNO);</span>
<span class="p_add">+</span>
<span class="p_add">+	fence-&gt;error = error;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 signed long fence_wait_timeout(struct fence *, bool intr, signed long timeout);
 signed long fence_wait_any_timeout(struct fence **fences, uint32_t count,
 				   bool intr, signed long timeout);
<span class="p_header">diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h</span>
<span class="p_header">index 4741ecdb9817..78ed8105e64d 100644</span>
<span class="p_header">--- a/include/linux/perf_event.h</span>
<span class="p_header">+++ b/include/linux/perf_event.h</span>
<span class="p_chunk">@@ -1259,6 +1259,7 @@</span> <span class="p_context"> extern void perf_event_disable(struct perf_event *event);</span>
 extern void perf_event_disable_local(struct perf_event *event);
 extern void perf_event_disable_inatomic(struct perf_event *event);
 extern void perf_event_task_tick(void);
<span class="p_add">+extern int perf_event_account_interrupt(struct perf_event *event);</span>
 #else /* !CONFIG_PERF_EVENTS: */
 static inline void *
 perf_aux_output_begin(struct perf_output_handle *handle,
<span class="p_header">diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">index 5e64a86989a5..ab1dadba9923 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch9.h</span>
<span class="p_chunk">@@ -854,6 +854,8 @@</span> <span class="p_context"> struct usb_wireless_cap_descriptor {	/* Ultra Wide Band */</span>
 	__u8  bReserved;
 } __attribute__((packed));
 
<span class="p_add">+#define USB_DT_USB_WIRELESS_CAP_SIZE	11</span>
<span class="p_add">+</span>
 /* USB 2.0 Extension descriptor */
 #define	USB_CAP_TYPE_EXT		2
 
<span class="p_chunk">@@ -1046,6 +1048,7 @@</span> <span class="p_context"> struct usb_ptm_cap_descriptor {</span>
 	__u8  bDevCapabilityType;
 } __attribute__((packed));
 
<span class="p_add">+#define USB_DT_USB_PTM_ID_SIZE		3</span>
 /*
  * The size of the descriptor for the Sublink Speed Attribute Count
  * (SSAC) specified in bmAttributes[4:0].
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 36ff2d93f222..13b9784427b0 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -7088,25 +7088,12 @@</span> <span class="p_context"> static void perf_log_itrace_start(struct perf_event *event)</span>
 	perf_output_end(&amp;handle);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Generic event overflow handling, sampling.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-static int __perf_event_overflow(struct perf_event *event,</span>
<span class="p_del">-				   int throttle, struct perf_sample_data *data,</span>
<span class="p_del">-				   struct pt_regs *regs)</span>
<span class="p_add">+static int</span>
<span class="p_add">+__perf_event_account_interrupt(struct perf_event *event, int throttle)</span>
 {
<span class="p_del">-	int events = atomic_read(&amp;event-&gt;event_limit);</span>
 	struct hw_perf_event *hwc = &amp;event-&gt;hw;
<span class="p_del">-	u64 seq;</span>
 	int ret = 0;
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Non-sampling counters might still use the PMI to fold short</span>
<span class="p_del">-	 * hardware counters, ignore those.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (unlikely(!is_sampling_event(event)))</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	u64 seq;</span>
 
 	seq = __this_cpu_read(perf_throttled_seq);
 	if (seq != hwc-&gt;interrupts_seq) {
<span class="p_chunk">@@ -7134,6 +7121,34 @@</span> <span class="p_context"> static int __perf_event_overflow(struct perf_event *event,</span>
 			perf_adjust_period(event, delta, hwc-&gt;last_period, true);
 	}
 
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int perf_event_account_interrupt(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __perf_event_account_interrupt(event, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Generic event overflow handling, sampling.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static int __perf_event_overflow(struct perf_event *event,</span>
<span class="p_add">+				   int throttle, struct perf_sample_data *data,</span>
<span class="p_add">+				   struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int events = atomic_read(&amp;event-&gt;event_limit);</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Non-sampling counters might still use the PMI to fold short</span>
<span class="p_add">+	 * hardware counters, ignore those.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(!is_sampling_event(event)))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = __perf_event_account_interrupt(event, throttle);</span>
<span class="p_add">+</span>
 	/*
 	 * XXX event_limit might not quite work as expected on inherited
 	 * events
<span class="p_header">diff --git a/mm/oom_kill.c b/mm/oom_kill.c</span>
<span class="p_header">index d631d251c150..4a184157cc3d 100644</span>
<span class="p_header">--- a/mm/oom_kill.c</span>
<span class="p_header">+++ b/mm/oom_kill.c</span>
<span class="p_chunk">@@ -524,7 +524,6 @@</span> <span class="p_context"> static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)</span>
 	 */
 	set_bit(MMF_UNSTABLE, &amp;mm-&gt;flags);
 
<span class="p_del">-	tlb_gather_mmu(&amp;tlb, mm, 0, -1);</span>
 	for (vma = mm-&gt;mmap ; vma; vma = vma-&gt;vm_next) {
 		if (is_vm_hugetlb_page(vma))
 			continue;
<span class="p_chunk">@@ -546,11 +545,13 @@</span> <span class="p_context"> static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)</span>
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
<span class="p_del">-		if (vma_is_anonymous(vma) || !(vma-&gt;vm_flags &amp; VM_SHARED))</span>
<span class="p_add">+		if (vma_is_anonymous(vma) || !(vma-&gt;vm_flags &amp; VM_SHARED)) {</span>
<span class="p_add">+			tlb_gather_mmu(&amp;tlb, mm, vma-&gt;vm_start, vma-&gt;vm_end);</span>
 			unmap_page_range(&amp;tlb, vma, vma-&gt;vm_start, vma-&gt;vm_end,
 					 &amp;details);
<span class="p_add">+			tlb_finish_mmu(&amp;tlb, vma-&gt;vm_start, vma-&gt;vm_end);</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-	tlb_finish_mmu(&amp;tlb, 0, -1);</span>
 	pr_info(&quot;oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n&quot;,
 			task_pid_nr(tsk), tsk-&gt;comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index ef5ee56095e8..fbc38888252b 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -2592,30 +2592,23 @@</span> <span class="p_context"> int __isolate_free_page(struct page *page, unsigned int order)</span>
  * Update NUMA hit/miss statistics
  *
  * Must be called with interrupts disabled.
<span class="p_del">- *</span>
<span class="p_del">- * When __GFP_OTHER_NODE is set assume the node of the preferred</span>
<span class="p_del">- * zone is the local node. This is useful for daemons who allocate</span>
<span class="p_del">- * memory on behalf of other processes.</span>
  */
 static inline void zone_statistics(struct zone *preferred_zone, struct zone *z,
 								gfp_t flags)
 {
 #ifdef CONFIG_NUMA
<span class="p_del">-	int local_nid = numa_node_id();</span>
 	enum zone_stat_item local_stat = NUMA_LOCAL;
 
<span class="p_del">-	if (unlikely(flags &amp; __GFP_OTHER_NODE)) {</span>
<span class="p_add">+	if (z-&gt;node != numa_node_id())</span>
 		local_stat = NUMA_OTHER;
<span class="p_del">-		local_nid = preferred_zone-&gt;node;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	if (z-&gt;node == local_nid) {</span>
<span class="p_add">+	if (z-&gt;node == preferred_zone-&gt;node)</span>
 		__inc_zone_state(z, NUMA_HIT);
<span class="p_del">-		__inc_zone_state(z, local_stat);</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	else {</span>
 		__inc_zone_state(z, NUMA_MISS);
 		__inc_zone_state(preferred_zone, NUMA_FOREIGN);
 	}
<span class="p_add">+	__inc_zone_state(z, local_stat);</span>
 #endif
 }
 
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 8fcd0c642742..05255a286888 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -5081,7 +5081,7 @@</span> <span class="p_context"> static void tcp_check_space(struct sock *sk)</span>
 	if (sock_flag(sk, SOCK_QUEUE_SHRUNK)) {
 		sock_reset_flag(sk, SOCK_QUEUE_SHRUNK);
 		/* pairs with tcp_poll() */
<span class="p_del">-		smp_mb__after_atomic();</span>
<span class="p_add">+		smp_mb();</span>
 		if (sk-&gt;sk_socket &amp;&amp;
 		    test_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags))
 			tcp_new_space(sk);
<span class="p_header">diff --git a/net/ipv6/ip6_vti.c b/net/ipv6/ip6_vti.c</span>
<span class="p_header">index 816f79d1a8a3..67e882d49195 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_vti.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_vti.c</span>
<span class="p_chunk">@@ -189,12 +189,12 @@</span> <span class="p_context"> static int vti6_tnl_create2(struct net_device *dev)</span>
 	struct vti6_net *ip6n = net_generic(net, vti6_net_id);
 	int err;
 
<span class="p_add">+	dev-&gt;rtnl_link_ops = &amp;vti6_link_ops;</span>
 	err = register_netdevice(dev);
 	if (err &lt; 0)
 		goto out;
 
 	strcpy(t-&gt;parms.name, dev-&gt;name);
<span class="p_del">-	dev-&gt;rtnl_link_ops = &amp;vti6_link_ops;</span>
 
 	dev_hold(dev);
 	vti6_tnl_link(ip6n, t);
<span class="p_header">diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c</span>
<span class="p_header">index 3468d5635d0a..9d77a54e8854 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip.c</span>
<span class="p_chunk">@@ -48,7 +48,8 @@</span> <span class="p_context"> static inline struct l2tp_ip_sock *l2tp_ip_sk(const struct sock *sk)</span>
 	return (struct l2tp_ip_sock *)sk;
 }
 
<span class="p_del">-static struct sock *__l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif, u32 tunnel_id)</span>
<span class="p_add">+static struct sock *__l2tp_ip_bind_lookup(const struct net *net, __be32 laddr,</span>
<span class="p_add">+					  __be32 raddr, int dif, u32 tunnel_id)</span>
 {
 	struct sock *sk;
 
<span class="p_chunk">@@ -62,6 +63,7 @@</span> <span class="p_context"> static struct sock *__l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif</span>
 		if ((l2tp-&gt;conn_id == tunnel_id) &amp;&amp;
 		    net_eq(sock_net(sk), net) &amp;&amp;
 		    !(inet-&gt;inet_rcv_saddr &amp;&amp; inet-&gt;inet_rcv_saddr != laddr) &amp;&amp;
<span class="p_add">+		    (!inet-&gt;inet_daddr || !raddr || inet-&gt;inet_daddr == raddr) &amp;&amp;</span>
 		    (!sk-&gt;sk_bound_dev_if || !dif ||
 		     sk-&gt;sk_bound_dev_if == dif))
 			goto found;
<span class="p_chunk">@@ -72,15 +74,6 @@</span> <span class="p_context"> static struct sock *__l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif</span>
 	return sk;
 }
 
<span class="p_del">-static inline struct sock *l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif, u32 tunnel_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct sock *sk = __l2tp_ip_bind_lookup(net, laddr, dif, tunnel_id);</span>
<span class="p_del">-	if (sk)</span>
<span class="p_del">-		sock_hold(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	return sk;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* When processing receive frames, there are two cases to
  * consider. Data frames consist of a non-zero session-id and an
  * optional cookie. Control frames consist of a regular L2TP header
<span class="p_chunk">@@ -186,8 +179,8 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 		struct iphdr *iph = (struct iphdr *) skb_network_header(skb);
 
 		read_lock_bh(&amp;l2tp_ip_lock);
<span class="p_del">-		sk = __l2tp_ip_bind_lookup(net, iph-&gt;daddr, inet_iif(skb),</span>
<span class="p_del">-					   tunnel_id);</span>
<span class="p_add">+		sk = __l2tp_ip_bind_lookup(net, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_add">+					   inet_iif(skb), tunnel_id);</span>
 		if (!sk) {
 			read_unlock_bh(&amp;l2tp_ip_lock);
 			goto discard;
<span class="p_chunk">@@ -289,7 +282,7 @@</span> <span class="p_context"> static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 		inet-&gt;inet_saddr = 0;  /* Use device */
 
 	write_lock_bh(&amp;l2tp_ip_lock);
<span class="p_del">-	if (__l2tp_ip_bind_lookup(net, addr-&gt;l2tp_addr.s_addr,</span>
<span class="p_add">+	if (__l2tp_ip_bind_lookup(net, addr-&gt;l2tp_addr.s_addr, 0,</span>
 				  sk-&gt;sk_bound_dev_if, addr-&gt;l2tp_conn_id)) {
 		write_unlock_bh(&amp;l2tp_ip_lock);
 		ret = -EADDRINUSE;
<span class="p_header">diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">index 1d522ce833e6..247097289fd0 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip6.c</span>
<span class="p_chunk">@@ -59,12 +59,14 @@</span> <span class="p_context"> static inline struct l2tp_ip6_sock *l2tp_ip6_sk(const struct sock *sk)</span>
 
 static struct sock *__l2tp_ip6_bind_lookup(struct net *net,
 					   struct in6_addr *laddr,
<span class="p_add">+					   const struct in6_addr *raddr,</span>
 					   int dif, u32 tunnel_id)
 {
 	struct sock *sk;
 
 	sk_for_each_bound(sk, &amp;l2tp_ip6_bind_table) {
 		const struct in6_addr *sk_laddr = inet6_rcv_saddr(sk);
<span class="p_add">+		const struct in6_addr *sk_raddr = &amp;sk-&gt;sk_v6_daddr;</span>
 		struct l2tp_ip6_sock *l2tp = l2tp_ip6_sk(sk);
 
 		if (l2tp == NULL)
<span class="p_chunk">@@ -73,6 +75,7 @@</span> <span class="p_context"> static struct sock *__l2tp_ip6_bind_lookup(struct net *net,</span>
 		if ((l2tp-&gt;conn_id == tunnel_id) &amp;&amp;
 		    net_eq(sock_net(sk), net) &amp;&amp;
 		    (!sk_laddr || ipv6_addr_any(sk_laddr) || ipv6_addr_equal(sk_laddr, laddr)) &amp;&amp;
<span class="p_add">+		    (!raddr || ipv6_addr_any(sk_raddr) || ipv6_addr_equal(sk_raddr, raddr)) &amp;&amp;</span>
 		    (!sk-&gt;sk_bound_dev_if || !dif ||
 		     sk-&gt;sk_bound_dev_if == dif))
 			goto found;
<span class="p_chunk">@@ -83,17 +86,6 @@</span> <span class="p_context"> static struct sock *__l2tp_ip6_bind_lookup(struct net *net,</span>
 	return sk;
 }
 
<span class="p_del">-static inline struct sock *l2tp_ip6_bind_lookup(struct net *net,</span>
<span class="p_del">-						struct in6_addr *laddr,</span>
<span class="p_del">-						int dif, u32 tunnel_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct sock *sk = __l2tp_ip6_bind_lookup(net, laddr, dif, tunnel_id);</span>
<span class="p_del">-	if (sk)</span>
<span class="p_del">-		sock_hold(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	return sk;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* When processing receive frames, there are two cases to
  * consider. Data frames consist of a non-zero session-id and an
  * optional cookie. Control frames consist of a regular L2TP header
<span class="p_chunk">@@ -200,8 +192,8 @@</span> <span class="p_context"> static int l2tp_ip6_recv(struct sk_buff *skb)</span>
 		struct ipv6hdr *iph = ipv6_hdr(skb);
 
 		read_lock_bh(&amp;l2tp_ip6_lock);
<span class="p_del">-		sk = __l2tp_ip6_bind_lookup(net, &amp;iph-&gt;daddr, inet6_iif(skb),</span>
<span class="p_del">-					    tunnel_id);</span>
<span class="p_add">+		sk = __l2tp_ip6_bind_lookup(net, &amp;iph-&gt;daddr, &amp;iph-&gt;saddr,</span>
<span class="p_add">+					    inet6_iif(skb), tunnel_id);</span>
 		if (!sk) {
 			read_unlock_bh(&amp;l2tp_ip6_lock);
 			goto discard;
<span class="p_chunk">@@ -339,7 +331,7 @@</span> <span class="p_context"> static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	rcu_read_unlock();
 
 	write_lock_bh(&amp;l2tp_ip6_lock);
<span class="p_del">-	if (__l2tp_ip6_bind_lookup(net, &amp;addr-&gt;l2tp_addr, bound_dev_if,</span>
<span class="p_add">+	if (__l2tp_ip6_bind_lookup(net, &amp;addr-&gt;l2tp_addr, NULL, bound_dev_if,</span>
 				   addr-&gt;l2tp_conn_id)) {
 		write_unlock_bh(&amp;l2tp_ip6_lock);
 		err = -EADDRINUSE;
<span class="p_header">diff --git a/net/mac80211/chan.c b/net/mac80211/chan.c</span>
<span class="p_header">index e75cbf6ecc26..a0d901d8992e 100644</span>
<span class="p_header">--- a/net/mac80211/chan.c</span>
<span class="p_header">+++ b/net/mac80211/chan.c</span>
<span class="p_chunk">@@ -231,9 +231,6 @@</span> <span class="p_context"> ieee80211_get_max_required_bw(struct ieee80211_sub_if_data *sdata)</span>
 		    !(sta-&gt;sdata-&gt;bss &amp;&amp; sta-&gt;sdata-&gt;bss == sdata-&gt;bss))
 			continue;
 
<span class="p_del">-		if (!sta-&gt;uploaded || !test_sta_flag(sta, WLAN_STA_ASSOC))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
 		max_bw = max(max_bw, ieee80211_get_sta_bw(&amp;sta-&gt;sta));
 	}
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index 274c564bd9af..1ffd1e145c13 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -1244,7 +1244,7 @@</span> <span class="p_context"> ieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,</span>
 
 static struct txq_info *ieee80211_get_txq(struct ieee80211_local *local,
 					  struct ieee80211_vif *vif,
<span class="p_del">-					  struct ieee80211_sta *pubsta,</span>
<span class="p_add">+					  struct sta_info *sta,</span>
 					  struct sk_buff *skb)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb-&gt;data;
<span class="p_chunk">@@ -1258,10 +1258,13 @@</span> <span class="p_context"> static struct txq_info *ieee80211_get_txq(struct ieee80211_local *local,</span>
 	if (!ieee80211_is_data(hdr-&gt;frame_control))
 		return NULL;
 
<span class="p_del">-	if (pubsta) {</span>
<span class="p_add">+	if (sta) {</span>
 		u8 tid = skb-&gt;priority &amp; IEEE80211_QOS_CTL_TID_MASK;
 
<span class="p_del">-		txq = pubsta-&gt;txq[tid];</span>
<span class="p_add">+		if (!sta-&gt;uploaded)</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		txq = sta-&gt;sta.txq[tid];</span>
 	} else if (vif) {
 		txq = vif-&gt;txq;
 	}
<span class="p_chunk">@@ -1499,23 +1502,17 @@</span> <span class="p_context"> static bool ieee80211_queue_skb(struct ieee80211_local *local,</span>
 	struct fq *fq = &amp;local-&gt;fq;
 	struct ieee80211_vif *vif;
 	struct txq_info *txqi;
<span class="p_del">-	struct ieee80211_sta *pubsta;</span>
 
 	if (!local-&gt;ops-&gt;wake_tx_queue ||
 	    sdata-&gt;vif.type == NL80211_IFTYPE_MONITOR)
 		return false;
 
<span class="p_del">-	if (sta &amp;&amp; sta-&gt;uploaded)</span>
<span class="p_del">-		pubsta = &amp;sta-&gt;sta;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		pubsta = NULL;</span>
<span class="p_del">-</span>
 	if (sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN)
 		sdata = container_of(sdata-&gt;bss,
 				     struct ieee80211_sub_if_data, u.ap);
 
 	vif = &amp;sdata-&gt;vif;
<span class="p_del">-	txqi = ieee80211_get_txq(local, vif, pubsta, skb);</span>
<span class="p_add">+	txqi = ieee80211_get_txq(local, vif, sta, skb);</span>
 
 	if (!txqi)
 		return false;
<span class="p_header">diff --git a/net/qrtr/qrtr.c b/net/qrtr/qrtr.c</span>
<span class="p_header">index c985ecbe9bd6..ae5ac175b2be 100644</span>
<span class="p_header">--- a/net/qrtr/qrtr.c</span>
<span class="p_header">+++ b/net/qrtr/qrtr.c</span>
<span class="p_chunk">@@ -252,7 +252,7 @@</span> <span class="p_context"> static struct sk_buff *qrtr_alloc_resume_tx(u32 src_node,</span>
 	const int pkt_len = 20;
 	struct qrtr_hdr *hdr;
 	struct sk_buff *skb;
<span class="p_del">-	u32 *buf;</span>
<span class="p_add">+	__le32 *buf;</span>
 
 	skb = alloc_skb(QRTR_HDR_SIZE + pkt_len, GFP_KERNEL);
 	if (!skb)
<span class="p_chunk">@@ -269,7 +269,7 @@</span> <span class="p_context"> static struct sk_buff *qrtr_alloc_resume_tx(u32 src_node,</span>
 	hdr-&gt;dst_node_id = cpu_to_le32(dst_node);
 	hdr-&gt;dst_port_id = cpu_to_le32(QRTR_PORT_CTRL);
 
<span class="p_del">-	buf = (u32 *)skb_put(skb, pkt_len);</span>
<span class="p_add">+	buf = (__le32 *)skb_put(skb, pkt_len);</span>
 	memset(buf, 0, pkt_len);
 	buf[0] = cpu_to_le32(QRTR_TYPE_RESUME_TX);
 	buf[1] = cpu_to_le32(src_node);
<span class="p_header">diff --git a/net/sctp/debug.c b/net/sctp/debug.c</span>
<span class="p_header">index 95d7b15dad21..e371a0d90068 100644</span>
<span class="p_header">--- a/net/sctp/debug.c</span>
<span class="p_header">+++ b/net/sctp/debug.c</span>
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> static const char *const sctp_timer_tbl[] = {</span>
 /* Lookup timer debug name. */
 const char *sctp_tname(const sctp_subtype_t id)
 {
<span class="p_del">-	if (id.timeout &lt;= SCTP_EVENT_TIMEOUT_MAX)</span>
<span class="p_add">+	if (id.timeout &lt; ARRAY_SIZE(sctp_timer_tbl))</span>
 		return sctp_timer_tbl[id.timeout];
 	return &quot;unknown_timer&quot;;
 }
<span class="p_header">diff --git a/net/tipc/server.c b/net/tipc/server.c</span>
<span class="p_header">index f89c0c2e8c16..3cd6402e812c 100644</span>
<span class="p_header">--- a/net/tipc/server.c</span>
<span class="p_header">+++ b/net/tipc/server.c</span>
<span class="p_chunk">@@ -86,7 +86,6 @@</span> <span class="p_context"> struct outqueue_entry {</span>
 static void tipc_recv_work(struct work_struct *work);
 static void tipc_send_work(struct work_struct *work);
 static void tipc_clean_outqueues(struct tipc_conn *con);
<span class="p_del">-static void tipc_sock_release(struct tipc_conn *con);</span>
 
 static void tipc_conn_kref_release(struct kref *kref)
 {
<span class="p_chunk">@@ -104,7 +103,6 @@</span> <span class="p_context"> static void tipc_conn_kref_release(struct kref *kref)</span>
 		}
 		saddr-&gt;scope = -TIPC_NODE_SCOPE;
 		kernel_bind(sock, (struct sockaddr *)saddr, sizeof(*saddr));
<span class="p_del">-		tipc_sock_release(con);</span>
 		sock_release(sock);
 		con-&gt;sock = NULL;
 
<span class="p_chunk">@@ -194,19 +192,15 @@</span> <span class="p_context"> static void tipc_unregister_callbacks(struct tipc_conn *con)</span>
 	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
 }
 
<span class="p_del">-static void tipc_sock_release(struct tipc_conn *con)</span>
<span class="p_add">+static void tipc_close_conn(struct tipc_conn *con)</span>
 {
 	struct tipc_server *s = con-&gt;server;
 
<span class="p_del">-	if (con-&gt;conid)</span>
<span class="p_del">-		s-&gt;tipc_conn_release(con-&gt;conid, con-&gt;usr_data);</span>
<span class="p_del">-</span>
<span class="p_del">-	tipc_unregister_callbacks(con);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void tipc_close_conn(struct tipc_conn *con)</span>
<span class="p_del">-{</span>
 	if (test_and_clear_bit(CF_CONNECTED, &amp;con-&gt;flags)) {
<span class="p_add">+		tipc_unregister_callbacks(con);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (con-&gt;conid)</span>
<span class="p_add">+			s-&gt;tipc_conn_release(con-&gt;conid, con-&gt;usr_data);</span>
 
 		/* We shouldn&#39;t flush pending works as we may be in the
 		 * thread. In fact the races with pending rx/tx work structs
<span class="p_chunk">@@ -625,14 +619,12 @@</span> <span class="p_context"> int tipc_server_start(struct tipc_server *s)</span>
 void tipc_server_stop(struct tipc_server *s)
 {
 	struct tipc_conn *con;
<span class="p_del">-	int total = 0;</span>
 	int id;
 
 	spin_lock_bh(&amp;s-&gt;idr_lock);
<span class="p_del">-	for (id = 0; total &lt; s-&gt;idr_in_use; id++) {</span>
<span class="p_add">+	for (id = 0; s-&gt;idr_in_use; id++) {</span>
 		con = idr_find(&amp;s-&gt;conn_idr, id);
 		if (con) {
<span class="p_del">-			total++;</span>
 			spin_unlock_bh(&amp;s-&gt;idr_lock);
 			tipc_close_conn(con);
 			spin_lock_bh(&amp;s-&gt;idr_lock);
<span class="p_header">diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c</span>
<span class="p_header">index 0e8762945e79..2b3def14b4fb 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_main.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_main.c</span>
<span class="p_chunk">@@ -51,6 +51,8 @@</span> <span class="p_context"> static int __init hash_setup(char *str)</span>
 			ima_hash_algo = HASH_ALGO_SHA1;
 		else if (strncmp(str, &quot;md5&quot;, 3) == 0)
 			ima_hash_algo = HASH_ALGO_MD5;
<span class="p_add">+		else</span>
<span class="p_add">+			return 1;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -60,6 +62,8 @@</span> <span class="p_context"> static int __init hash_setup(char *str)</span>
 			break;
 		}
 	}
<span class="p_add">+	if (i == HASH_ALGO__LAST)</span>
<span class="p_add">+		return 1;</span>
 out:
 	hash_setup_done = 1;
 	return 1;
<span class="p_header">diff --git a/tools/include/linux/poison.h b/tools/include/linux/poison.h</span>
<span class="p_header">index 51334edec506..f306a7642509 100644</span>
<span class="p_header">--- a/tools/include/linux/poison.h</span>
<span class="p_header">+++ b/tools/include/linux/poison.h</span>
<span class="p_chunk">@@ -14,6 +14,10 @@</span> <span class="p_context"></span>
 # define POISON_POINTER_DELTA 0
 #endif
 
<span class="p_add">+#ifdef __cplusplus</span>
<span class="p_add">+#define LIST_POISON1  NULL</span>
<span class="p_add">+#define LIST_POISON2  NULL</span>
<span class="p_add">+#else</span>
 /*
  * These are non-NULL pointers that will result in page faults
  * under normal circumstances, used to verify that nobody uses
<span class="p_chunk">@@ -21,6 +25,7 @@</span> <span class="p_context"></span>
  */
 #define LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)
 #define LIST_POISON2  ((void *) 0x200 + POISON_POINTER_DELTA)
<span class="p_add">+#endif</span>
 
 /********** include/linux/timer.h **********/
 /*
<span class="p_header">diff --git a/tools/perf/tests/attr.c b/tools/perf/tests/attr.c</span>
<span class="p_header">index 28d1605b0338..b60a6fd66517 100644</span>
<span class="p_header">--- a/tools/perf/tests/attr.c</span>
<span class="p_header">+++ b/tools/perf/tests/attr.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static int run_dir(const char *d, const char *perf)</span>
 	snprintf(cmd, 3*PATH_MAX, PYTHON &quot; %s/attr.py -d %s/attr/ -p %s %.*s&quot;,
 		 d, d, perf, vcnt, v);
 
<span class="p_del">-	return system(cmd);</span>
<span class="p_add">+	return system(cmd) ? TEST_FAIL : TEST_OK;</span>
 }
 
 int test__attr(int subtest __maybe_unused)
<span class="p_header">diff --git a/tools/testing/selftests/x86/ldt_gdt.c b/tools/testing/selftests/x86/ldt_gdt.c</span>
<span class="p_header">index e717fed80219..f936a3cd3e35 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/ldt_gdt.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/ldt_gdt.c</span>
<span class="p_chunk">@@ -360,9 +360,24 @@</span> <span class="p_context"> static void do_simple_tests(void)</span>
 	install_invalid(&amp;desc, false);
 
 	desc.seg_not_present = 0;
<span class="p_del">-	desc.read_exec_only = 0;</span>
 	desc.seg_32bit = 1;
<span class="p_add">+	desc.read_exec_only = 0;</span>
<span class="p_add">+	desc.limit = 0xfffff;</span>
<span class="p_add">+</span>
 	install_valid(&amp;desc, AR_DPL3 | AR_TYPE_RWDATA | AR_S | AR_P | AR_DB);
<span class="p_add">+</span>
<span class="p_add">+	desc.limit_in_pages = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	install_valid(&amp;desc, AR_DPL3 | AR_TYPE_RWDATA | AR_S | AR_P | AR_DB | AR_G);</span>
<span class="p_add">+	desc.read_exec_only = 1;</span>
<span class="p_add">+	install_valid(&amp;desc, AR_DPL3 | AR_TYPE_RODATA | AR_S | AR_P | AR_DB | AR_G);</span>
<span class="p_add">+	desc.contents = 1;</span>
<span class="p_add">+	desc.read_exec_only = 0;</span>
<span class="p_add">+	install_valid(&amp;desc, AR_DPL3 | AR_TYPE_RWDATA_EXPDOWN | AR_S | AR_P | AR_DB | AR_G);</span>
<span class="p_add">+	desc.read_exec_only = 1;</span>
<span class="p_add">+	install_valid(&amp;desc, AR_DPL3 | AR_TYPE_RODATA_EXPDOWN | AR_S | AR_P | AR_DB | AR_G);</span>
<span class="p_add">+</span>
<span class="p_add">+	desc.limit = 0;</span>
 	install_invalid(&amp;desc, true);
 }
 
<span class="p_header">diff --git a/tools/usb/usbip/Makefile.am b/tools/usb/usbip/Makefile.am</span>
<span class="p_header">index 66f8bf038c9f..45eaa70a71e0 100644</span>
<span class="p_header">--- a/tools/usb/usbip/Makefile.am</span>
<span class="p_header">+++ b/tools/usb/usbip/Makefile.am</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 SUBDIRS := libsrc src
 includedir = @includedir@/usbip
 include_HEADERS := $(addprefix libsrc/, \
<span class="p_del">-		     usbip_common.h vhci_driver.h usbip_host_driver.h)</span>
<span class="p_add">+		     usbip_common.h vhci_driver.h usbip_host_driver.h \</span>
<span class="p_add">+		     list.h sysfs_utils.h usbip_host_common.h)</span>
 
 dist_man_MANS := $(addprefix doc/, usbip.8 usbipd.8)
<span class="p_header">diff --git a/virt/kvm/arm/arch_timer.c b/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">index 27a1f6341d41..7b49a1378c90 100644</span>
<span class="p_header">--- a/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">+++ b/virt/kvm/arm/arch_timer.c</span>
<span class="p_chunk">@@ -89,9 +89,6 @@</span> <span class="p_context"> static void kvm_timer_inject_irq_work(struct work_struct *work)</span>
 	struct kvm_vcpu *vcpu;
 
 	vcpu = container_of(work, struct kvm_vcpu, arch.timer_cpu.expired);
<span class="p_del">-	vcpu-&gt;arch.timer_cpu.armed = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	WARN_ON(!kvm_timer_should_fire(vcpu));</span>
 
 	/*
 	 * If the vcpu is blocked we want to wake it up so that it will see

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



