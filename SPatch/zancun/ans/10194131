
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.79 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.79</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 31, 2018, 3:26 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180131152618.GB16110@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10194131/mbox/"
   >mbox</a>
|
   <a href="/patch/10194131/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10194131/">/patch/10194131/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	1B072601A0 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 31 Jan 2018 15:26:52 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E2A67283BD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 31 Jan 2018 15:26:51 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D23DF28703; Wed, 31 Jan 2018 15:26:51 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 08470283BD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 31 Jan 2018 15:26:48 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753383AbeAaP0l (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 31 Jan 2018 10:26:41 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:53044 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932081AbeAaP0W (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 31 Jan 2018 10:26:22 -0500
Received: from localhost (LFbn-1-12258-90.w90-92.abo.wanadoo.fr
	[90.92.71.90])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 6DAA1F59;
	Wed, 31 Jan 2018 15:26:20 +0000 (UTC)
Date: Wed, 31 Jan 2018 16:26:18 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.79
Message-ID: &lt;20180131152618.GB16110@kroah.com&gt;
References: &lt;20180131152613.GA16110@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20180131152613.GA16110@kroah.com&gt;
User-Agent: Mutt/1.9.3 (2018-01-21)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 31, 2018, 3:26 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 8a6f158a1176..4a7e6dff1c2e 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 78</span>
<span class="p_add">+SUBLEVEL = 79</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 2206e0e00934..2a35c1963f6d 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -1284,7 +1284,7 @@</span> <span class="p_context"> static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,</span>
 		return -EFAULT;
 	}
 
<span class="p_del">-	if (is_vm_hugetlb_page(vma) &amp;&amp; !logging_active) {</span>
<span class="p_add">+	if (vma_kernel_pagesize(vma) &amp;&amp; !logging_active) {</span>
 		hugetlb = true;
 		gfn = (fault_ipa &amp; PMD_MASK) &gt;&gt; PAGE_SHIFT;
 	} else {
<span class="p_header">diff --git a/arch/um/Makefile b/arch/um/Makefile</span>
<span class="p_header">index 0ca46ededfc7..9c150ccb35d2 100644</span>
<span class="p_header">--- a/arch/um/Makefile</span>
<span class="p_header">+++ b/arch/um/Makefile</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> archheaders:</span>
 archprepare: include/generated/user_constants.h
 
 LINK-$(CONFIG_LD_SCRIPT_STATIC) += -static
<span class="p_del">-LINK-$(CONFIG_LD_SCRIPT_DYN) += -Wl,-rpath,/lib</span>
<span class="p_add">+LINK-$(CONFIG_LD_SCRIPT_DYN) += -Wl,-rpath,/lib $(call cc-option, -no-pie)</span>
 
 CFLAGS_NO_HARDENING := $(call cc-option, -fno-PIC,) $(call cc-option, -fno-pic,) \
 	$(call cc-option, -fno-stack-protector,) \
<span class="p_header">diff --git a/arch/x86/entry/vsyscall/vsyscall_64.c b/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_header">index 6bb7e92c6d50..0174290b2857 100644</span>
<span class="p_header">--- a/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_header">+++ b/arch/x86/entry/vsyscall/vsyscall_64.c</span>
<span class="p_chunk">@@ -46,6 +46,7 @@</span> <span class="p_context"> static enum { EMULATE, NATIVE, NONE } vsyscall_mode =</span>
 #else
 	EMULATE;
 #endif
<span class="p_add">+unsigned long vsyscall_pgprot = __PAGE_KERNEL_VSYSCALL;</span>
 
 static int __init vsyscall_setup(char *str)
 {
<span class="p_chunk">@@ -336,11 +337,11 @@</span> <span class="p_context"> void __init map_vsyscall(void)</span>
 	extern char __vsyscall_page;
 	unsigned long physaddr_vsyscall = __pa_symbol(&amp;__vsyscall_page);
 
<span class="p_add">+	if (vsyscall_mode != NATIVE)</span>
<span class="p_add">+		vsyscall_pgprot = __PAGE_KERNEL_VVAR;</span>
 	if (vsyscall_mode != NONE)
 		__set_fixmap(VSYSCALL_PAGE, physaddr_vsyscall,
<span class="p_del">-			     vsyscall_mode == NATIVE</span>
<span class="p_del">-			     ? PAGE_KERNEL_VSYSCALL</span>
<span class="p_del">-			     : PAGE_KERNEL_VVAR);</span>
<span class="p_add">+			     __pgprot(vsyscall_pgprot));</span>
 
 	BUILD_BUG_ON((unsigned long)__fix_to_virt(VSYSCALL_PAGE) !=
 		     (unsigned long)VSYSCALL_ADDR);
<span class="p_header">diff --git a/arch/x86/events/amd/power.c b/arch/x86/events/amd/power.c</span>
<span class="p_header">index 9842270ed2f2..21a4e4127f43 100644</span>
<span class="p_header">--- a/arch/x86/events/amd/power.c</span>
<span class="p_header">+++ b/arch/x86/events/amd/power.c</span>
<span class="p_chunk">@@ -277,7 +277,7 @@</span> <span class="p_context"> static int __init amd_power_pmu_init(void)</span>
 	int ret;
 
 	if (!x86_match_cpu(cpu_match))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	if (!boot_cpu_has(X86_FEATURE_ACC_POWER))
 		return -ENODEV;
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index e40b19ca486e..353f038ec645 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -596,7 +596,7 @@</span> <span class="p_context"> static inline void sync_core(void)</span>
 {
 	int tmp;
 
<span class="p_del">-#ifdef CONFIG_M486</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
 	/*
 	 * Do a CPUID if available, otherwise do a jump.  The jump
 	 * can conveniently enough be the jump around CPUID.
<span class="p_header">diff --git a/arch/x86/include/asm/vsyscall.h b/arch/x86/include/asm/vsyscall.h</span>
<span class="p_header">index 4865e10dbb55..9ee85066f407 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/vsyscall.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/vsyscall.h</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"> extern void map_vsyscall(void);</span>
  */
 extern bool emulate_vsyscall(struct pt_regs *regs, unsigned long address);
 extern bool vsyscall_enabled(void);
<span class="p_add">+extern unsigned long vsyscall_pgprot;</span>
 #else
 static inline void map_vsyscall(void) {}
 static inline bool emulate_vsyscall(struct pt_regs *regs, unsigned long address)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/intel_cacheinfo.c b/arch/x86/kernel/cpu/intel_cacheinfo.c</span>
<span class="p_header">index de6626c18e42..be6337156502 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/intel_cacheinfo.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/intel_cacheinfo.c</span>
<span class="p_chunk">@@ -934,6 +934,8 @@</span> <span class="p_context"> static int __populate_cache_leaves(unsigned int cpu)</span>
 		ci_leaf_init(this_leaf++, &amp;id4_regs);
 		__cache_cpumap_setup(cpu, idx, &amp;id4_regs);
 	}
<span class="p_add">+	this_cpu_ci-&gt;cpu_map_populated = true;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">index ac3e636ad586..f90f17610f62 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_chunk">@@ -40,6 +40,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/msr.h&gt;
 
<span class="p_add">+/* last level cache size per core */</span>
<span class="p_add">+static int llc_size_per_core;</span>
<span class="p_add">+</span>
 /*
  * Temporary microcode blobs pointers storage. We note here during early load
  * the pointers to microcode blobs we&#39;ve got from whatever storage (detached
<span class="p_chunk">@@ -1053,12 +1056,14 @@</span> <span class="p_context"> static bool is_blacklisted(unsigned int cpu)</span>
 
 	/*
 	 * Late loading on model 79 with microcode revision less than 0x0b000021
<span class="p_del">-	 * may result in a system hang. This behavior is documented in item</span>
<span class="p_del">-	 * BDF90, #334165 (Intel Xeon Processor E7-8800/4800 v4 Product Family).</span>
<span class="p_add">+	 * and LLC size per core bigger than 2.5MB may result in a system hang.</span>
<span class="p_add">+	 * This behavior is documented in item BDF90, #334165 (Intel Xeon</span>
<span class="p_add">+	 * Processor E7-8800/4800 v4 Product Family).</span>
 	 */
 	if (c-&gt;x86 == 6 &amp;&amp;
 	    c-&gt;x86_model == INTEL_FAM6_BROADWELL_X &amp;&amp;
 	    c-&gt;x86_mask == 0x01 &amp;&amp;
<span class="p_add">+	    llc_size_per_core &gt; 2621440 &amp;&amp;</span>
 	    c-&gt;microcode &lt; 0x0b000021) {
 		pr_err_once(&quot;Erratum BDF90: late loading with revision &lt; 0x0b000021 (0x%x) disabled.\n&quot;, c-&gt;microcode);
 		pr_err_once(&quot;Please consider either early loading through initrd/built-in or a potential BIOS update.\n&quot;);
<span class="p_chunk">@@ -1125,6 +1130,15 @@</span> <span class="p_context"> static struct microcode_ops microcode_intel_ops = {</span>
 	.microcode_fini_cpu               = microcode_fini_cpu,
 };
 
<span class="p_add">+static int __init calc_llc_size_per_core(struct cpuinfo_x86 *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 llc_size = c-&gt;x86_cache_size * 1024;</span>
<span class="p_add">+</span>
<span class="p_add">+	do_div(llc_size, c-&gt;x86_max_cores);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (int)llc_size;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct microcode_ops * __init init_intel_microcode(void)
 {
 	struct cpuinfo_x86 *c = &amp;boot_cpu_data;
<span class="p_chunk">@@ -1135,6 +1149,8 @@</span> <span class="p_context"> struct microcode_ops * __init init_intel_microcode(void)</span>
 		return NULL;
 	}
 
<span class="p_add">+	llc_size_per_core = calc_llc_size_per_core(c);</span>
<span class="p_add">+</span>
 	return &amp;microcode_intel_ops;
 }
 
<span class="p_header">diff --git a/arch/x86/lib/delay.c b/arch/x86/lib/delay.c</span>
<span class="p_header">index 073d1f1a620b..9758524ee99f 100644</span>
<span class="p_header">--- a/arch/x86/lib/delay.c</span>
<span class="p_header">+++ b/arch/x86/lib/delay.c</span>
<span class="p_chunk">@@ -93,6 +93,13 @@</span> <span class="p_context"> static void delay_mwaitx(unsigned long __loops)</span>
 {
 	u64 start, end, delay, loops = __loops;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Timer value of 0 causes MWAITX to wait indefinitely, unless there</span>
<span class="p_add">+	 * is a store on the memory monitored by MONITORX.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (loops == 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	start = rdtsc_ordered();
 
 	for (;;) {
<span class="p_header">diff --git a/arch/x86/mm/kaiser.c b/arch/x86/mm/kaiser.c</span>
<span class="p_header">index a8ade08a9bf5..ec678aafa3f8 100644</span>
<span class="p_header">--- a/arch/x86/mm/kaiser.c</span>
<span class="p_header">+++ b/arch/x86/mm/kaiser.c</span>
<span class="p_chunk">@@ -344,7 +344,7 @@</span> <span class="p_context"> void __init kaiser_init(void)</span>
 	if (vsyscall_enabled())
 		kaiser_add_user_map_early((void *)VSYSCALL_ADDR,
 					  PAGE_SIZE,
<span class="p_del">-					   __PAGE_KERNEL_VSYSCALL);</span>
<span class="p_add">+					  vsyscall_pgprot);</span>
 
 	for_each_possible_cpu(cpu) {
 		void *percpu_vaddr = __per_cpu_user_mapped_start +
<span class="p_header">diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">index 15f743615923..7840331d3056 100644</span>
<span class="p_header">--- a/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -278,10 +278,10 @@</span> <span class="p_context"> static void emit_bpf_tail_call(u8 **pprog)</span>
 	/* if (index &gt;= array-&gt;map.max_entries)
 	 *   goto out;
 	 */
<span class="p_del">-	EMIT4(0x48, 0x8B, 0x46,                   /* mov rax, qword ptr [rsi + 16] */</span>
<span class="p_add">+	EMIT2(0x89, 0xD2);                        /* mov edx, edx */</span>
<span class="p_add">+	EMIT3(0x39, 0x56,                         /* cmp dword ptr [rsi + 16], edx */</span>
 	      offsetof(struct bpf_array, map.max_entries));
<span class="p_del">-	EMIT3(0x48, 0x39, 0xD0);                  /* cmp rax, rdx */</span>
<span class="p_del">-#define OFFSET1 47 /* number of bytes to jump */</span>
<span class="p_add">+#define OFFSET1 43 /* number of bytes to jump */</span>
 	EMIT2(X86_JBE, OFFSET1);                  /* jbe out */
 	label1 = cnt;
 
<span class="p_chunk">@@ -290,21 +290,20 @@</span> <span class="p_context"> static void emit_bpf_tail_call(u8 **pprog)</span>
 	 */
 	EMIT2_off32(0x8B, 0x85, -STACKSIZE + 36); /* mov eax, dword ptr [rbp - 516] */
 	EMIT3(0x83, 0xF8, MAX_TAIL_CALL_CNT);     /* cmp eax, MAX_TAIL_CALL_CNT */
<span class="p_del">-#define OFFSET2 36</span>
<span class="p_add">+#define OFFSET2 32</span>
 	EMIT2(X86_JA, OFFSET2);                   /* ja out */
 	label2 = cnt;
 	EMIT3(0x83, 0xC0, 0x01);                  /* add eax, 1 */
 	EMIT2_off32(0x89, 0x85, -STACKSIZE + 36); /* mov dword ptr [rbp - 516], eax */
 
 	/* prog = array-&gt;ptrs[index]; */
<span class="p_del">-	EMIT4_off32(0x48, 0x8D, 0x84, 0xD6,       /* lea rax, [rsi + rdx * 8 + offsetof(...)] */</span>
<span class="p_add">+	EMIT4_off32(0x48, 0x8B, 0x84, 0xD6,       /* mov rax, [rsi + rdx * 8 + offsetof(...)] */</span>
 		    offsetof(struct bpf_array, ptrs));
<span class="p_del">-	EMIT3(0x48, 0x8B, 0x00);                  /* mov rax, qword ptr [rax] */</span>
 
 	/* if (prog == NULL)
 	 *   goto out;
 	 */
<span class="p_del">-	EMIT4(0x48, 0x83, 0xF8, 0x00);            /* cmp rax, 0 */</span>
<span class="p_add">+	EMIT3(0x48, 0x85, 0xC0);		  /* test rax,rax */</span>
 #define OFFSET3 10
 	EMIT2(X86_JE, OFFSET3);                   /* je out */
 	label3 = cnt;
<span class="p_header">diff --git a/drivers/acpi/acpica/nsutils.c b/drivers/acpi/acpica/nsutils.c</span>
<span class="p_header">index 691814dfed31..943702dd9517 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/nsutils.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/nsutils.c</span>
<span class="p_chunk">@@ -594,25 +594,20 @@</span> <span class="p_context"> struct acpi_namespace_node *acpi_ns_validate_handle(acpi_handle handle)</span>
 void acpi_ns_terminate(void)
 {
 	acpi_status status;
<span class="p_add">+	union acpi_operand_object *prev;</span>
<span class="p_add">+	union acpi_operand_object *next;</span>
 
 	ACPI_FUNCTION_TRACE(ns_terminate);
 
<span class="p_del">-#ifdef ACPI_EXEC_APP</span>
<span class="p_del">-	{</span>
<span class="p_del">-		union acpi_operand_object *prev;</span>
<span class="p_del">-		union acpi_operand_object *next;</span>
<span class="p_add">+	/* Delete any module-level code blocks */</span>
 
<span class="p_del">-		/* Delete any module-level code blocks */</span>
<span class="p_del">-</span>
<span class="p_del">-		next = acpi_gbl_module_code_list;</span>
<span class="p_del">-		while (next) {</span>
<span class="p_del">-			prev = next;</span>
<span class="p_del">-			next = next-&gt;method.mutex;</span>
<span class="p_del">-			prev-&gt;method.mutex = NULL;	/* Clear the Mutex (cheated) field */</span>
<span class="p_del">-			acpi_ut_remove_reference(prev);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	next = acpi_gbl_module_code_list;</span>
<span class="p_add">+	while (next) {</span>
<span class="p_add">+		prev = next;</span>
<span class="p_add">+		next = next-&gt;method.mutex;</span>
<span class="p_add">+		prev-&gt;method.mutex = NULL;	/* Clear the Mutex (cheated) field */</span>
<span class="p_add">+		acpi_ut_remove_reference(prev);</span>
 	}
<span class="p_del">-#endif</span>
 
 	/*
 	 * Free the entire namespace -- all nodes and all objects
<span class="p_header">diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c</span>
<span class="p_header">index 73c9c7fa9001..f06317d6fc38 100644</span>
<span class="p_header">--- a/drivers/acpi/glue.c</span>
<span class="p_header">+++ b/drivers/acpi/glue.c</span>
<span class="p_chunk">@@ -99,13 +99,13 @@</span> <span class="p_context"> static int find_child_checks(struct acpi_device *adev, bool check_children)</span>
 		return -ENODEV;
 
 	/*
<span class="p_del">-	 * If the device has a _HID (or _CID) returning a valid ACPI/PNP</span>
<span class="p_del">-	 * device ID, it is better to make it look less attractive here, so that</span>
<span class="p_del">-	 * the other device with the same _ADR value (that may not have a valid</span>
<span class="p_del">-	 * device ID) can be matched going forward.  [This means a second spec</span>
<span class="p_del">-	 * violation in a row, so whatever we do here is best effort anyway.]</span>
<span class="p_add">+	 * If the device has a _HID returning a valid ACPI/PNP device ID, it is</span>
<span class="p_add">+	 * better to make it look less attractive here, so that the other device</span>
<span class="p_add">+	 * with the same _ADR value (that may not have a valid device ID) can be</span>
<span class="p_add">+	 * matched going forward.  [This means a second spec violation in a row,</span>
<span class="p_add">+	 * so whatever we do here is best effort anyway.]</span>
 	 */
<span class="p_del">-	return sta_present &amp;&amp; list_empty(&amp;adev-&gt;pnp.ids) ?</span>
<span class="p_add">+	return sta_present &amp;&amp; !adev-&gt;pnp.type.platform_id ?</span>
 			FIND_CHILD_MAX_SCORE : FIND_CHILD_MIN_SCORE;
 }
 
<span class="p_header">diff --git a/drivers/base/cacheinfo.c b/drivers/base/cacheinfo.c</span>
<span class="p_header">index e9fd32e91668..70e13cf06ed0 100644</span>
<span class="p_header">--- a/drivers/base/cacheinfo.c</span>
<span class="p_header">+++ b/drivers/base/cacheinfo.c</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
  */
<span class="p_add">+#include &lt;linux/acpi.h&gt;</span>
 #include &lt;linux/bitops.h&gt;
 #include &lt;linux/cacheinfo.h&gt;
 #include &lt;linux/compiler.h&gt;
<span class="p_chunk">@@ -104,9 +105,16 @@</span> <span class="p_context"> static int cache_shared_cpu_map_setup(unsigned int cpu)</span>
 	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
 	struct cacheinfo *this_leaf, *sib_leaf;
 	unsigned int index;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (this_cpu_ci-&gt;cpu_map_populated)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-	ret = cache_setup_of_node(cpu);</span>
<span class="p_add">+	if (of_have_populated_dt())</span>
<span class="p_add">+		ret = cache_setup_of_node(cpu);</span>
<span class="p_add">+	else if (!acpi_disabled)</span>
<span class="p_add">+		/* No cache property/hierarchy support yet in ACPI */</span>
<span class="p_add">+		ret = -ENOTSUPP;</span>
 	if (ret)
 		return ret;
 
<span class="p_chunk">@@ -203,8 +211,7 @@</span> <span class="p_context"> static int detect_cache_attributes(unsigned int cpu)</span>
 	 */
 	ret = cache_shared_cpu_map_setup(cpu);
 	if (ret) {
<span class="p_del">-		pr_warn(&quot;Unable to detect cache hierarchy from DT for CPU %d\n&quot;,</span>
<span class="p_del">-			cpu);</span>
<span class="p_add">+		pr_warn(&quot;Unable to detect cache hierarchy for CPU %d\n&quot;, cpu);</span>
 		goto free_ci;
 	}
 	return 0;
<span class="p_header">diff --git a/drivers/input/mouse/trackpoint.c b/drivers/input/mouse/trackpoint.c</span>
<span class="p_header">index 7e2dc5e56632..0b49f29bf0da 100644</span>
<span class="p_header">--- a/drivers/input/mouse/trackpoint.c</span>
<span class="p_header">+++ b/drivers/input/mouse/trackpoint.c</span>
<span class="p_chunk">@@ -383,6 +383,9 @@</span> <span class="p_context"> int trackpoint_detect(struct psmouse *psmouse, bool set_properties)</span>
 	if (trackpoint_read(&amp;psmouse-&gt;ps2dev, TP_EXT_BTN, &amp;button_info)) {
 		psmouse_warn(psmouse, &quot;failed to get extended button data, assuming 3 buttons\n&quot;);
 		button_info = 0x33;
<span class="p_add">+	} else if (!button_info) {</span>
<span class="p_add">+		psmouse_warn(psmouse, &quot;got 0 in extended button data, assuming 3 buttons\n&quot;);</span>
<span class="p_add">+		button_info = 0x33;</span>
 	}
 
 	psmouse-&gt;private = kzalloc(sizeof(struct trackpoint_data), GFP_KERNEL);
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">index 1644896568c4..b2eeecb26939 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_chunk">@@ -4733,6 +4733,15 @@</span> <span class="p_context"> int be_update_queues(struct be_adapter *adapter)</span>
 
 	be_schedule_worker(adapter);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The IF was destroyed and re-created. We need to clear</span>
<span class="p_add">+	 * all promiscuous flags valid for the destroyed IF.</span>
<span class="p_add">+	 * Without this promisc mode is not restored during</span>
<span class="p_add">+	 * be_open() because the driver thinks that it is</span>
<span class="p_add">+	 * already enabled in HW.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	adapter-&gt;if_flags &amp;= ~BE_IF_FLAGS_ALL_PROMISCUOUS;</span>
<span class="p_add">+</span>
 	if (netif_running(netdev))
 		status = be_open(netdev);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c</span>
<span class="p_header">index 8aa91ddff287..16556011d571 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c</span>
<span class="p_chunk">@@ -765,11 +765,8 @@</span> <span class="p_context"> static void mlxsw_sp_router_neigh_ent_ipv4_process(struct mlxsw_sp *mlxsw_sp,</span>
 	dipn = htonl(dip);
 	dev = mlxsw_sp-&gt;rifs[rif]-&gt;dev;
 	n = neigh_lookup(&amp;arp_tbl, &amp;dipn, dev);
<span class="p_del">-	if (!n) {</span>
<span class="p_del">-		netdev_err(dev, &quot;Failed to find matching neighbour for IP=%pI4h\n&quot;,</span>
<span class="p_del">-			   &amp;dip);</span>
<span class="p_add">+	if (!n)</span>
 		return;
<span class="p_del">-	}</span>
 
 	netdev_dbg(dev, &quot;Updating neighbour with IP=%pI4h\n&quot;, &amp;dip);
 	neigh_event_send(n, NULL);
<span class="p_header">diff --git a/drivers/net/ethernet/realtek/r8169.c b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">index 2c4350a1c629..298b74ebc1e9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_chunk">@@ -2222,19 +2222,14 @@</span> <span class="p_context"> static bool rtl8169_do_counters(struct net_device *dev, u32 counter_cmd)</span>
 	void __iomem *ioaddr = tp-&gt;mmio_addr;
 	dma_addr_t paddr = tp-&gt;counters_phys_addr;
 	u32 cmd;
<span class="p_del">-	bool ret;</span>
 
 	RTL_W32(CounterAddrHigh, (u64)paddr &gt;&gt; 32);
<span class="p_add">+	RTL_R32(CounterAddrHigh);</span>
 	cmd = (u64)paddr &amp; DMA_BIT_MASK(32);
 	RTL_W32(CounterAddrLow, cmd);
 	RTL_W32(CounterAddrLow, cmd | counter_cmd);
 
<span class="p_del">-	ret = rtl_udelay_loop_wait_low(tp, &amp;rtl_counters_cond, 10, 1000);</span>
<span class="p_del">-</span>
<span class="p_del">-	RTL_W32(CounterAddrLow, 0);</span>
<span class="p_del">-	RTL_W32(CounterAddrHigh, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return rtl_udelay_loop_wait_low(tp, &amp;rtl_counters_cond, 10, 1000);</span>
 }
 
 static bool rtl8169_reset_counters(struct net_device *dev)
<span class="p_header">diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">index b883af93929c..fc4c2ccc3d22 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_chunk">@@ -1002,17 +1002,18 @@</span> <span class="p_context"> static int ppp_unit_register(struct ppp *ppp, int unit, bool ifname_is_set)</span>
 	if (!ifname_is_set)
 		snprintf(ppp-&gt;dev-&gt;name, IFNAMSIZ, &quot;ppp%i&quot;, ppp-&gt;file.index);
 
<span class="p_add">+	mutex_unlock(&amp;pn-&gt;all_ppp_mutex);</span>
<span class="p_add">+</span>
 	ret = register_netdevice(ppp-&gt;dev);
 	if (ret &lt; 0)
 		goto err_unit;
 
 	atomic_inc(&amp;ppp_unit_count);
 
<span class="p_del">-	mutex_unlock(&amp;pn-&gt;all_ppp_mutex);</span>
<span class="p_del">-</span>
 	return 0;
 
 err_unit:
<span class="p_add">+	mutex_lock(&amp;pn-&gt;all_ppp_mutex);</span>
 	unit_put(&amp;pn-&gt;units_idr, ppp-&gt;file.index);
 err:
 	mutex_unlock(&amp;pn-&gt;all_ppp_mutex);
<span class="p_header">diff --git a/drivers/net/ppp/pppoe.c b/drivers/net/ppp/pppoe.c</span>
<span class="p_header">index 4ddae8118c85..dc36c2ec1d10 100644</span>
<span class="p_header">--- a/drivers/net/ppp/pppoe.c</span>
<span class="p_header">+++ b/drivers/net/ppp/pppoe.c</span>
<span class="p_chunk">@@ -842,6 +842,7 @@</span> <span class="p_context"> static int pppoe_sendmsg(struct socket *sock, struct msghdr *m,</span>
 	struct pppoe_hdr *ph;
 	struct net_device *dev;
 	char *start;
<span class="p_add">+	int hlen;</span>
 
 	lock_sock(sk);
 	if (sock_flag(sk, SOCK_DEAD) || !(sk-&gt;sk_state &amp; PPPOX_CONNECTED)) {
<span class="p_chunk">@@ -860,16 +861,16 @@</span> <span class="p_context"> static int pppoe_sendmsg(struct socket *sock, struct msghdr *m,</span>
 	if (total_len &gt; (dev-&gt;mtu + dev-&gt;hard_header_len))
 		goto end;
 
<span class="p_del">-</span>
<span class="p_del">-	skb = sock_wmalloc(sk, total_len + dev-&gt;hard_header_len + 32,</span>
<span class="p_del">-			   0, GFP_KERNEL);</span>
<span class="p_add">+	hlen = LL_RESERVED_SPACE(dev);</span>
<span class="p_add">+	skb = sock_wmalloc(sk, hlen + sizeof(*ph) + total_len +</span>
<span class="p_add">+			   dev-&gt;needed_tailroom, 0, GFP_KERNEL);</span>
 	if (!skb) {
 		error = -ENOMEM;
 		goto end;
 	}
 
 	/* Reserve space for headers. */
<span class="p_del">-	skb_reserve(skb, dev-&gt;hard_header_len);</span>
<span class="p_add">+	skb_reserve(skb, hlen);</span>
 	skb_reset_network_header(skb);
 
 	skb-&gt;dev = dev;
<span class="p_chunk">@@ -930,7 +931,7 @@</span> <span class="p_context"> static int __pppoe_xmit(struct sock *sk, struct sk_buff *skb)</span>
 	/* Copy the data if there is no space for the header or if it&#39;s
 	 * read-only.
 	 */
<span class="p_del">-	if (skb_cow_head(skb, sizeof(*ph) + dev-&gt;hard_header_len))</span>
<span class="p_add">+	if (skb_cow_head(skb, LL_RESERVED_SPACE(dev) + sizeof(*ph)))</span>
 		goto abort;
 
 	__skb_push(skb, sizeof(*ph));
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 518cbfbc8b65..eb6dc28e5e52 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -525,6 +525,14 @@</span> <span class="p_context"> static void tun_queue_purge(struct tun_file *tfile)</span>
 	skb_queue_purge(&amp;tfile-&gt;sk.sk_error_queue);
 }
 
<span class="p_add">+static void tun_cleanup_tx_array(struct tun_file *tfile)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (tfile-&gt;tx_array.ring.queue) {</span>
<span class="p_add">+		skb_array_cleanup(&amp;tfile-&gt;tx_array);</span>
<span class="p_add">+		memset(&amp;tfile-&gt;tx_array, 0, sizeof(tfile-&gt;tx_array));</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __tun_detach(struct tun_file *tfile, bool clean)
 {
 	struct tun_file *ntfile;
<span class="p_chunk">@@ -566,8 +574,7 @@</span> <span class="p_context"> static void __tun_detach(struct tun_file *tfile, bool clean)</span>
 			    tun-&gt;dev-&gt;reg_state == NETREG_REGISTERED)
 				unregister_netdevice(tun-&gt;dev);
 		}
<span class="p_del">-		if (tun)</span>
<span class="p_del">-			skb_array_cleanup(&amp;tfile-&gt;tx_array);</span>
<span class="p_add">+		tun_cleanup_tx_array(tfile);</span>
 		sock_put(&amp;tfile-&gt;sk);
 	}
 }
<span class="p_chunk">@@ -606,11 +613,13 @@</span> <span class="p_context"> static void tun_detach_all(struct net_device *dev)</span>
 		/* Drop read queue */
 		tun_queue_purge(tfile);
 		sock_put(&amp;tfile-&gt;sk);
<span class="p_add">+		tun_cleanup_tx_array(tfile);</span>
 	}
 	list_for_each_entry_safe(tfile, tmp, &amp;tun-&gt;disabled, next) {
 		tun_enable_queue(tfile);
 		tun_queue_purge(tfile);
 		sock_put(&amp;tfile-&gt;sk);
<span class="p_add">+		tun_cleanup_tx_array(tfile);</span>
 	}
 	BUG_ON(tun-&gt;numdisabled != 0);
 
<span class="p_chunk">@@ -2363,6 +2372,8 @@</span> <span class="p_context"> static int tun_chr_open(struct inode *inode, struct file * file)</span>
 
 	sock_set_flag(&amp;tfile-&gt;sk, SOCK_ZEROCOPY);
 
<span class="p_add">+	memset(&amp;tfile-&gt;tx_array, 0, sizeof(tfile-&gt;tx_array));</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/net/usb/lan78xx.c b/drivers/net/usb/lan78xx.c</span>
<span class="p_header">index 9c257ffedb15..c53385a0052f 100644</span>
<span class="p_header">--- a/drivers/net/usb/lan78xx.c</span>
<span class="p_header">+++ b/drivers/net/usb/lan78xx.c</span>
<span class="p_chunk">@@ -2197,6 +2197,7 @@</span> <span class="p_context"> static int lan78xx_reset(struct lan78xx_net *dev)</span>
 		buf = DEFAULT_BURST_CAP_SIZE / FS_USB_PKT_SIZE;
 		dev-&gt;rx_urb_size = DEFAULT_BURST_CAP_SIZE;
 		dev-&gt;rx_qlen = 4;
<span class="p_add">+		dev-&gt;tx_qlen = 4;</span>
 	}
 
 	ret = lan78xx_write_reg(dev, BURST_CAP, buf);
<span class="p_header">diff --git a/drivers/net/vmxnet3/vmxnet3_drv.c b/drivers/net/vmxnet3/vmxnet3_drv.c</span>
<span class="p_header">index ef83ae3b0a44..4afba17e2403 100644</span>
<span class="p_header">--- a/drivers/net/vmxnet3/vmxnet3_drv.c</span>
<span class="p_header">+++ b/drivers/net/vmxnet3/vmxnet3_drv.c</span>
<span class="p_chunk">@@ -1616,7 +1616,6 @@</span> <span class="p_context"> static void vmxnet3_rq_destroy(struct vmxnet3_rx_queue *rq,</span>
 					  rq-&gt;rx_ring[i].basePA);
 			rq-&gt;rx_ring[i].base = NULL;
 		}
<span class="p_del">-		rq-&gt;buf_info[i] = NULL;</span>
 	}
 
 	if (rq-&gt;data_ring.base) {
<span class="p_chunk">@@ -1638,6 +1637,7 @@</span> <span class="p_context"> static void vmxnet3_rq_destroy(struct vmxnet3_rx_queue *rq,</span>
 			(rq-&gt;rx_ring[0].size + rq-&gt;rx_ring[1].size);
 		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, sz, rq-&gt;buf_info[0],
 				  rq-&gt;buf_info_pa);
<span class="p_add">+		rq-&gt;buf_info[0] = rq-&gt;buf_info[1] = NULL;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c</span>
<span class="p_header">index a530f08592cd..4abd3fce5ab6 100644</span>
<span class="p_header">--- a/drivers/scsi/libiscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/libiscsi.c</span>
<span class="p_chunk">@@ -1727,7 +1727,7 @@</span> <span class="p_context"> int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc)</span>
 
 	if (test_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx)) {
 		reason = FAILURE_SESSION_IN_RECOVERY;
<span class="p_del">-		sc-&gt;result = DID_REQUEUE;</span>
<span class="p_add">+		sc-&gt;result = DID_REQUEUE &lt;&lt; 16;</span>
 		goto fault;
 	}
 
<span class="p_header">diff --git a/drivers/usb/usbip/usbip_common.h b/drivers/usb/usbip/usbip_common.h</span>
<span class="p_header">index 9f490375ac92..f0b955f8504e 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/usbip_common.h</span>
<span class="p_header">+++ b/drivers/usb/usbip/usbip_common.h</span>
<span class="p_chunk">@@ -271,6 +271,7 @@</span> <span class="p_context"> struct usbip_device {</span>
 	/* lock for status */
 	spinlock_t lock;
 
<span class="p_add">+	int sockfd;</span>
 	struct socket *tcp_socket;
 
 	struct task_struct *tcp_rx;
<span class="p_header">diff --git a/drivers/usb/usbip/vhci_sysfs.c b/drivers/usb/usbip/vhci_sysfs.c</span>
<span class="p_header">index b96e5b189269..c287ccc78fde 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vhci_sysfs.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vhci_sysfs.c</span>
<span class="p_chunk">@@ -49,13 +49,17 @@</span> <span class="p_context"> static ssize_t status_show_vhci(int pdev_nr, char *out)</span>
 
 	/*
 	 * output example:
<span class="p_del">-	 * port sta spd dev      socket           local_busid</span>
<span class="p_del">-	 * 0000 004 000 00000000         c5a7bb80 1-2.3</span>
<span class="p_del">-	 * 0001 004 000 00000000         d8cee980 2-3.4</span>
<span class="p_add">+	 * port sta spd dev      sockfd local_busid</span>
<span class="p_add">+	 * 0000 004 000 00000000 000003 1-2.3</span>
<span class="p_add">+	 * 0001 004 000 00000000 000004 2-3.4</span>
 	 *
<span class="p_del">-	 * IP address can be retrieved from a socket pointer address by looking</span>
<span class="p_del">-	 * up /proc/net/{tcp,tcp6}. Also, a userland program may remember a</span>
<span class="p_del">-	 * port number and its peer IP address.</span>
<span class="p_add">+	 * Output includes socket fd instead of socket pointer address to</span>
<span class="p_add">+	 * avoid leaking kernel memory address in:</span>
<span class="p_add">+	 *	/sys/devices/platform/vhci_hcd.0/status and in debug output.</span>
<span class="p_add">+	 * The socket pointer address is not used at the moment and it was</span>
<span class="p_add">+	 * made visible as a convenient way to find IP address from socket</span>
<span class="p_add">+	 * pointer address by looking up /proc/net/{tcp,tcp6}. As this opens</span>
<span class="p_add">+	 * a security hole, the change is made to use sockfd instead.</span>
 	 */
 	for (i = 0; i &lt; VHCI_HC_PORTS; i++) {
 		struct vhci_device *vdev = &amp;vhci-&gt;vdev[i];
<span class="p_chunk">@@ -68,13 +72,13 @@</span> <span class="p_context"> static ssize_t status_show_vhci(int pdev_nr, char *out)</span>
 		if (vdev-&gt;ud.status == VDEV_ST_USED) {
 			out += sprintf(out, &quot;%03u %08x &quot;,
 					    vdev-&gt;speed, vdev-&gt;devid);
<span class="p_del">-			out += sprintf(out, &quot;%16p %s&quot;,</span>
<span class="p_del">-					    vdev-&gt;ud.tcp_socket,</span>
<span class="p_add">+			out += sprintf(out, &quot;%06u %s&quot;,</span>
<span class="p_add">+					    vdev-&gt;ud.sockfd,</span>
 					    dev_name(&amp;vdev-&gt;udev-&gt;dev));
 
 		} else {
 			out += sprintf(out, &quot;000 00000000 &quot;);
<span class="p_del">-			out += sprintf(out, &quot;0000000000000000 0-0&quot;);</span>
<span class="p_add">+			out += sprintf(out, &quot;000000 0-0&quot;);</span>
 		}
 
 		out += sprintf(out, &quot;\n&quot;);
<span class="p_chunk">@@ -125,7 +129,7 @@</span> <span class="p_context"> static ssize_t status_show(struct device *dev,</span>
 	int pdev_nr;
 
 	out += sprintf(out,
<span class="p_del">-		       &quot;port sta spd dev      socket           local_busid\n&quot;);</span>
<span class="p_add">+		       &quot;port sta spd dev      sockfd local_busid\n&quot;);</span>
 
 	pdev_nr = status_name_to_id(attr-&gt;attr.name);
 	if (pdev_nr &lt; 0)
<span class="p_chunk">@@ -324,6 +328,7 @@</span> <span class="p_context"> static ssize_t store_attach(struct device *dev, struct device_attribute *attr,</span>
 
 	vdev-&gt;devid         = devid;
 	vdev-&gt;speed         = speed;
<span class="p_add">+	vdev-&gt;ud.sockfd     = sockfd;</span>
 	vdev-&gt;ud.tcp_socket = socket;
 	vdev-&gt;ud.status     = VDEV_ST_NOTASSIGNED;
 
<span class="p_header">diff --git a/fs/fcntl.c b/fs/fcntl.c</span>
<span class="p_header">index 1493ceb0477d..ec03cf620fd7 100644</span>
<span class="p_header">--- a/fs/fcntl.c</span>
<span class="p_header">+++ b/fs/fcntl.c</span>
<span class="p_chunk">@@ -114,6 +114,10 @@</span> <span class="p_context"> void f_setown(struct file *filp, unsigned long arg, int force)</span>
 	int who = arg;
 	type = PIDTYPE_PID;
 	if (who &lt; 0) {
<span class="p_add">+		/* avoid overflow below */</span>
<span class="p_add">+		if (who == INT_MIN)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
 		type = PIDTYPE_PGID;
 		who = -who;
 	}
<span class="p_header">diff --git a/fs/nfsd/auth.c b/fs/nfsd/auth.c</span>
<span class="p_header">index 75f942ae5176..81c018e5c31e 100644</span>
<span class="p_header">--- a/fs/nfsd/auth.c</span>
<span class="p_header">+++ b/fs/nfsd/auth.c</span>
<span class="p_chunk">@@ -59,10 +59,10 @@</span> <span class="p_context"> int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)</span>
 				gi-&gt;gid[i] = exp-&gt;ex_anon_gid;
 			else
 				gi-&gt;gid[i] = rqgi-&gt;gid[i];
<span class="p_del">-</span>
<span class="p_del">-			/* Each thread allocates its own gi, no race */</span>
<span class="p_del">-			groups_sort(gi);</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* Each thread allocates its own gi, no race */</span>
<span class="p_add">+		groups_sort(gi);</span>
 	} else {
 		gi = get_group_info(rqgi);
 	}
<span class="p_header">diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c</span>
<span class="p_header">index fe2cbeb90772..939aa066e1ca 100644</span>
<span class="p_header">--- a/fs/orangefs/devorangefs-req.c</span>
<span class="p_header">+++ b/fs/orangefs/devorangefs-req.c</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> static ssize_t orangefs_devreq_read(struct file *file,</span>
 	struct orangefs_kernel_op_s *op, *temp;
 	__s32 proto_ver = ORANGEFS_KERNEL_PROTO_VERSION;
 	static __s32 magic = ORANGEFS_DEVREQ_MAGIC;
<span class="p_del">-	struct orangefs_kernel_op_s *cur_op = NULL;</span>
<span class="p_add">+	struct orangefs_kernel_op_s *cur_op;</span>
 	unsigned long ret;
 
 	/* We do not support blocking IO. */
<span class="p_chunk">@@ -181,6 +181,7 @@</span> <span class="p_context"> static ssize_t orangefs_devreq_read(struct file *file,</span>
 	}
 
 restart:
<span class="p_add">+	cur_op = NULL;</span>
 	/* Get next op (if any) from top of list. */
 	spin_lock(&amp;orangefs_request_list_lock);
 	list_for_each_entry_safe(op, temp, &amp;orangefs_request_list, list) {
<span class="p_header">diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c</span>
<span class="p_header">index 02cc6139ec90..5b2cbe567365 100644</span>
<span class="p_header">--- a/fs/orangefs/file.c</span>
<span class="p_header">+++ b/fs/orangefs/file.c</span>
<span class="p_chunk">@@ -446,7 +446,7 @@</span> <span class="p_context"> ssize_t orangefs_inode_read(struct inode *inode,</span>
 static ssize_t orangefs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 {
 	struct file *file = iocb-&gt;ki_filp;
<span class="p_del">-	loff_t pos = *(&amp;iocb-&gt;ki_pos);</span>
<span class="p_add">+	loff_t pos = iocb-&gt;ki_pos;</span>
 	ssize_t rc = 0;
 
 	BUG_ON(iocb-&gt;private);
<span class="p_chunk">@@ -485,9 +485,6 @@</span> <span class="p_context"> static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite</span>
 		}
 	}
 
<span class="p_del">-	if (file-&gt;f_pos &gt; i_size_read(file-&gt;f_mapping-&gt;host))</span>
<span class="p_del">-		orangefs_i_size_write(file-&gt;f_mapping-&gt;host, file-&gt;f_pos);</span>
<span class="p_del">-</span>
 	rc = generic_write_checks(iocb, iter);
 
 	if (rc &lt;= 0) {
<span class="p_chunk">@@ -501,7 +498,7 @@</span> <span class="p_context"> static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *ite</span>
 	 * pos to the end of the file, so we will wait till now to set
 	 * pos...
 	 */
<span class="p_del">-	pos = *(&amp;iocb-&gt;ki_pos);</span>
<span class="p_add">+	pos = iocb-&gt;ki_pos;</span>
 
 	rc = do_readv_writev(ORANGEFS_IO_WRITE,
 			     file,
<span class="p_header">diff --git a/fs/orangefs/orangefs-kernel.h b/fs/orangefs/orangefs-kernel.h</span>
<span class="p_header">index 45dd8f27b2ac..f28381a7cd12 100644</span>
<span class="p_header">--- a/fs/orangefs/orangefs-kernel.h</span>
<span class="p_header">+++ b/fs/orangefs/orangefs-kernel.h</span>
<span class="p_chunk">@@ -570,17 +570,6 @@</span> <span class="p_context"> do {									\</span>
 	sys_attr.mask = ORANGEFS_ATTR_SYS_ALL_SETABLE;			\
 } while (0)
 
<span class="p_del">-static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)</span>
<span class="p_del">-{</span>
<span class="p_del">-#if BITS_PER_LONG == 32 &amp;&amp; defined(CONFIG_SMP)</span>
<span class="p_del">-	inode_lock(inode);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	i_size_write(inode, i_size);</span>
<span class="p_del">-#if BITS_PER_LONG == 32 &amp;&amp; defined(CONFIG_SMP)</span>
<span class="p_del">-	inode_unlock(inode);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void orangefs_set_timeout(struct dentry *dentry)
 {
 	unsigned long time = jiffies + orangefs_dcache_timeout_msecs*HZ/1000;
<span class="p_header">diff --git a/fs/orangefs/waitqueue.c b/fs/orangefs/waitqueue.c</span>
<span class="p_header">index abcfa3fa9992..f61b00887481 100644</span>
<span class="p_header">--- a/fs/orangefs/waitqueue.c</span>
<span class="p_header">+++ b/fs/orangefs/waitqueue.c</span>
<span class="p_chunk">@@ -28,10 +28,10 @@</span> <span class="p_context"> static void orangefs_clean_up_interrupted_operation(struct orangefs_kernel_op_s</span>
  */
 void purge_waiting_ops(void)
 {
<span class="p_del">-	struct orangefs_kernel_op_s *op;</span>
<span class="p_add">+	struct orangefs_kernel_op_s *op, *tmp;</span>
 
 	spin_lock(&amp;orangefs_request_list_lock);
<span class="p_del">-	list_for_each_entry(op, &amp;orangefs_request_list, list) {</span>
<span class="p_add">+	list_for_each_entry_safe(op, tmp, &amp;orangefs_request_list, list) {</span>
 		gossip_debug(GOSSIP_WAIT_DEBUG,
 			     &quot;pvfs2-client-core: purging op tag %llu %s\n&quot;,
 			     llu(op-&gt;tag),
<span class="p_header">diff --git a/fs/reiserfs/bitmap.c b/fs/reiserfs/bitmap.c</span>
<span class="p_header">index dc198bc64c61..edc8ef78b63f 100644</span>
<span class="p_header">--- a/fs/reiserfs/bitmap.c</span>
<span class="p_header">+++ b/fs/reiserfs/bitmap.c</span>
<span class="p_chunk">@@ -513,9 +513,17 @@</span> <span class="p_context"> static void __discard_prealloc(struct reiserfs_transaction_handle *th,</span>
 			       &quot;inode has negative prealloc blocks count.&quot;);
 #endif
 	while (ei-&gt;i_prealloc_count &gt; 0) {
<span class="p_del">-		reiserfs_free_prealloc_block(th, inode, ei-&gt;i_prealloc_block);</span>
<span class="p_del">-		ei-&gt;i_prealloc_block++;</span>
<span class="p_add">+		b_blocknr_t block_to_free;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * reiserfs_free_prealloc_block can drop the write lock,</span>
<span class="p_add">+		 * which could allow another caller to free the same block.</span>
<span class="p_add">+		 * We can protect against it by modifying the prealloc</span>
<span class="p_add">+		 * state before calling it.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		block_to_free = ei-&gt;i_prealloc_block++;</span>
 		ei-&gt;i_prealloc_count--;
<span class="p_add">+		reiserfs_free_prealloc_block(th, inode, block_to_free);</span>
 		dirty = 1;
 	}
 	if (dirty)
<span class="p_chunk">@@ -1128,7 +1136,7 @@</span> <span class="p_context"> static int determine_prealloc_size(reiserfs_blocknr_hint_t * hint)</span>
 	hint-&gt;prealloc_size = 0;
 
 	if (!hint-&gt;formatted_node &amp;&amp; hint-&gt;preallocate) {
<span class="p_del">-		if (S_ISREG(hint-&gt;inode-&gt;i_mode)</span>
<span class="p_add">+		if (S_ISREG(hint-&gt;inode-&gt;i_mode) &amp;&amp; !IS_PRIVATE(hint-&gt;inode)</span>
 		    &amp;&amp; hint-&gt;inode-&gt;i_size &gt;=
 		    REISERFS_SB(hint-&gt;th-&gt;t_super)-&gt;s_alloc_options.
 		    preallocmin * hint-&gt;inode-&gt;i_sb-&gt;s_blocksize)
<span class="p_header">diff --git a/include/linux/bpf.h b/include/linux/bpf.h</span>
<span class="p_header">index 75ffd3b2149e..7995940d4187 100644</span>
<span class="p_header">--- a/include/linux/bpf.h</span>
<span class="p_header">+++ b/include/linux/bpf.h</span>
<span class="p_chunk">@@ -36,7 +36,10 @@</span> <span class="p_context"> struct bpf_map_ops {</span>
 };
 
 struct bpf_map {
<span class="p_del">-	atomic_t refcnt;</span>
<span class="p_add">+	/* 1st cacheline with read-mostly members of which some</span>
<span class="p_add">+	 * are also accessed in fast-path (e.g. ops, max_entries).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	const struct bpf_map_ops *ops ____cacheline_aligned;</span>
 	enum bpf_map_type map_type;
 	u32 key_size;
 	u32 value_size;
<span class="p_chunk">@@ -44,10 +47,15 @@</span> <span class="p_context"> struct bpf_map {</span>
 	u32 map_flags;
 	u32 pages;
 	bool unpriv_array;
<span class="p_del">-	struct user_struct *user;</span>
<span class="p_del">-	const struct bpf_map_ops *ops;</span>
<span class="p_del">-	struct work_struct work;</span>
<span class="p_add">+	/* 7 bytes hole */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 2nd cacheline with misc members to avoid false sharing</span>
<span class="p_add">+	 * particularly with refcounting.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct user_struct *user ____cacheline_aligned;</span>
<span class="p_add">+	atomic_t refcnt;</span>
 	atomic_t usercnt;
<span class="p_add">+	struct work_struct work;</span>
 };
 
 struct bpf_map_type_list {
<span class="p_header">diff --git a/include/linux/cacheinfo.h b/include/linux/cacheinfo.h</span>
<span class="p_header">index 2189935075b4..a951fd10aaaa 100644</span>
<span class="p_header">--- a/include/linux/cacheinfo.h</span>
<span class="p_header">+++ b/include/linux/cacheinfo.h</span>
<span class="p_chunk">@@ -71,6 +71,7 @@</span> <span class="p_context"> struct cpu_cacheinfo {</span>
 	struct cacheinfo *info_list;
 	unsigned int num_levels;
 	unsigned int num_leaves;
<span class="p_add">+	bool cpu_map_populated;</span>
 };
 
 /*
<span class="p_header">diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h</span>
<span class="p_header">index 490f5a83f947..e3d7754f25f0 100644</span>
<span class="p_header">--- a/include/linux/mmzone.h</span>
<span class="p_header">+++ b/include/linux/mmzone.h</span>
<span class="p_chunk">@@ -633,6 +633,8 @@</span> <span class="p_context"> typedef struct pglist_data {</span>
 	int kswapd_order;
 	enum zone_type kswapd_classzone_idx;
 
<span class="p_add">+	int kswapd_failures;		/* Number of &#39;reclaimed == 0&#39; runs */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_COMPACTION
 	int kcompactd_max_order;
 	enum zone_type kcompactd_classzone_idx;
<span class="p_header">diff --git a/include/linux/vermagic.h b/include/linux/vermagic.h</span>
<span class="p_header">index a3d04934aa96..6f8fbcf10dfb 100644</span>
<span class="p_header">--- a/include/linux/vermagic.h</span>
<span class="p_header">+++ b/include/linux/vermagic.h</span>
<span class="p_chunk">@@ -24,16 +24,10 @@</span> <span class="p_context"></span>
 #ifndef MODULE_ARCH_VERMAGIC
 #define MODULE_ARCH_VERMAGIC &quot;&quot;
 #endif
<span class="p_del">-#ifdef RETPOLINE</span>
<span class="p_del">-#define MODULE_VERMAGIC_RETPOLINE &quot;retpoline &quot;</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define MODULE_VERMAGIC_RETPOLINE &quot;&quot;</span>
<span class="p_del">-#endif</span>
 
 #define VERMAGIC_STRING 						\
 	UTS_RELEASE &quot; &quot;							\
 	MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT 			\
 	MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS	\
<span class="p_del">-	MODULE_ARCH_VERMAGIC						\</span>
<span class="p_del">-	MODULE_VERMAGIC_RETPOLINE</span>
<span class="p_add">+	MODULE_ARCH_VERMAGIC</span>
 
<span class="p_header">diff --git a/include/net/arp.h b/include/net/arp.h</span>
<span class="p_header">index 5e0f891d476c..1b3f86981757 100644</span>
<span class="p_header">--- a/include/net/arp.h</span>
<span class="p_header">+++ b/include/net/arp.h</span>
<span class="p_chunk">@@ -19,6 +19,9 @@</span> <span class="p_context"> static inline u32 arp_hashfn(const void *pkey, const struct net_device *dev, u32</span>
 
 static inline struct neighbour *__ipv4_neigh_lookup_noref(struct net_device *dev, u32 key)
 {
<span class="p_add">+	if (dev-&gt;flags &amp; (IFF_LOOPBACK | IFF_POINTOPOINT))</span>
<span class="p_add">+		key = INADDR_ANY;</span>
<span class="p_add">+</span>
 	return ___neigh_lookup_noref(&amp;arp_tbl, neigh_key_eq32, arp_hashfn, &amp;key, dev);
 }
 
<span class="p_header">diff --git a/include/net/ipv6.h b/include/net/ipv6.h</span>
<span class="p_header">index 615ce0abba9c..e64210c98c2b 100644</span>
<span class="p_header">--- a/include/net/ipv6.h</span>
<span class="p_header">+++ b/include/net/ipv6.h</span>
<span class="p_chunk">@@ -290,6 +290,7 @@</span> <span class="p_context"> int ipv6_flowlabel_opt_get(struct sock *sk, struct in6_flowlabel_req *freq,</span>
 			   int flags);
 int ip6_flowlabel_init(void);
 void ip6_flowlabel_cleanup(void);
<span class="p_add">+bool ip6_autoflowlabel(struct net *net, const struct ipv6_pinfo *np);</span>
 
 static inline void fl6_sock_release(struct ip6_flowlabel *fl)
 {
<span class="p_header">diff --git a/include/net/net_namespace.h b/include/net/net_namespace.h</span>
<span class="p_header">index 0940598c002f..23102da24dd9 100644</span>
<span class="p_header">--- a/include/net/net_namespace.h</span>
<span class="p_header">+++ b/include/net/net_namespace.h</span>
<span class="p_chunk">@@ -213,6 +213,11 @@</span> <span class="p_context"> int net_eq(const struct net *net1, const struct net *net2)</span>
 	return net1 == net2;
 }
 
<span class="p_add">+static inline int check_net(const struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return atomic_read(&amp;net-&gt;count) != 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void net_drop_ns(void *);
 
 #else
<span class="p_chunk">@@ -237,6 +242,11 @@</span> <span class="p_context"> int net_eq(const struct net *net1, const struct net *net2)</span>
 	return 1;
 }
 
<span class="p_add">+static inline int check_net(const struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define net_drop_ns NULL
 #endif
 
<span class="p_header">diff --git a/include/uapi/linux/eventpoll.h b/include/uapi/linux/eventpoll.h</span>
<span class="p_header">index 1c3154913a39..bc96b14dfb2c 100644</span>
<span class="p_header">--- a/include/uapi/linux/eventpoll.h</span>
<span class="p_header">+++ b/include/uapi/linux/eventpoll.h</span>
<span class="p_chunk">@@ -26,6 +26,19 @@</span> <span class="p_context"></span>
 #define EPOLL_CTL_DEL 2
 #define EPOLL_CTL_MOD 3
 
<span class="p_add">+/* Epoll event masks */</span>
<span class="p_add">+#define EPOLLIN		0x00000001</span>
<span class="p_add">+#define EPOLLPRI	0x00000002</span>
<span class="p_add">+#define EPOLLOUT	0x00000004</span>
<span class="p_add">+#define EPOLLERR	0x00000008</span>
<span class="p_add">+#define EPOLLHUP	0x00000010</span>
<span class="p_add">+#define EPOLLRDNORM	0x00000040</span>
<span class="p_add">+#define EPOLLRDBAND	0x00000080</span>
<span class="p_add">+#define EPOLLWRNORM	0x00000100</span>
<span class="p_add">+#define EPOLLWRBAND	0x00000200</span>
<span class="p_add">+#define EPOLLMSG	0x00000400</span>
<span class="p_add">+#define EPOLLRDHUP	0x00002000</span>
<span class="p_add">+</span>
 /* Set exclusive wakeup mode for the target file descriptor */
 #define EPOLLEXCLUSIVE (1 &lt;&lt; 28)
 
<span class="p_header">diff --git a/init/Kconfig b/init/Kconfig</span>
<span class="p_header">index 34407f15e6d3..b331feeabda4 100644</span>
<span class="p_header">--- a/init/Kconfig</span>
<span class="p_header">+++ b/init/Kconfig</span>
<span class="p_chunk">@@ -1609,6 +1609,13 @@</span> <span class="p_context"> config BPF_SYSCALL</span>
 	  Enable the bpf() system call that allows to manipulate eBPF
 	  programs and maps via file descriptors.
 
<span class="p_add">+config BPF_JIT_ALWAYS_ON</span>
<span class="p_add">+	bool &quot;Permanently enable BPF JIT and remove BPF interpreter&quot;</span>
<span class="p_add">+	depends on BPF_SYSCALL &amp;&amp; HAVE_EBPF_JIT &amp;&amp; BPF_JIT</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Enables BPF JIT and removes BPF interpreter to avoid</span>
<span class="p_add">+	  speculative execution of BPF instructions by the interpreter</span>
<span class="p_add">+</span>
 config SHMEM
 	bool &quot;Use full shmem filesystem&quot; if EXPERT
 	default y
<span class="p_header">diff --git a/ipc/msg.c b/ipc/msg.c</span>
<span class="p_header">index e12307d0c920..ff10d43b5184 100644</span>
<span class="p_header">--- a/ipc/msg.c</span>
<span class="p_header">+++ b/ipc/msg.c</span>
<span class="p_chunk">@@ -763,7 +763,10 @@</span> <span class="p_context"> static inline int convert_mode(long *msgtyp, int msgflg)</span>
 	if (*msgtyp == 0)
 		return SEARCH_ANY;
 	if (*msgtyp &lt; 0) {
<span class="p_del">-		*msgtyp = -*msgtyp;</span>
<span class="p_add">+		if (*msgtyp == LONG_MIN) /* -LONG_MIN is undefined */</span>
<span class="p_add">+			*msgtyp = LONG_MAX;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			*msgtyp = -*msgtyp;</span>
 		return SEARCH_LESSEQUAL;
 	}
 	if (msgflg &amp; MSG_EXCEPT)
<span class="p_header">diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c</span>
<span class="p_header">index aa6d98154106..879ca844ba1d 100644</span>
<span class="p_header">--- a/kernel/bpf/core.c</span>
<span class="p_header">+++ b/kernel/bpf/core.c</span>
<span class="p_chunk">@@ -458,6 +458,7 @@</span> <span class="p_context"> noinline u64 __bpf_call_base(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)</span>
 }
 EXPORT_SYMBOL_GPL(__bpf_call_base);
 
<span class="p_add">+#ifndef CONFIG_BPF_JIT_ALWAYS_ON</span>
 /**
  *	__bpf_prog_run - run eBPF program on a given context
  *	@ctx: is the data we are operating on
<span class="p_chunk">@@ -641,7 +642,7 @@</span> <span class="p_context"> static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)</span>
 		DST = tmp;
 		CONT;
 	ALU_MOD_X:
<span class="p_del">-		if (unlikely(SRC == 0))</span>
<span class="p_add">+		if (unlikely((u32)SRC == 0))</span>
 			return 0;
 		tmp = (u32) DST;
 		DST = do_div(tmp, (u32) SRC);
<span class="p_chunk">@@ -660,7 +661,7 @@</span> <span class="p_context"> static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)</span>
 		DST = div64_u64(DST, SRC);
 		CONT;
 	ALU_DIV_X:
<span class="p_del">-		if (unlikely(SRC == 0))</span>
<span class="p_add">+		if (unlikely((u32)SRC == 0))</span>
 			return 0;
 		tmp = (u32) DST;
 		do_div(tmp, (u32) SRC);
<span class="p_chunk">@@ -715,7 +716,7 @@</span> <span class="p_context"> static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)</span>
 		struct bpf_map *map = (struct bpf_map *) (unsigned long) BPF_R2;
 		struct bpf_array *array = container_of(map, struct bpf_array, map);
 		struct bpf_prog *prog;
<span class="p_del">-		u64 index = BPF_R3;</span>
<span class="p_add">+		u32 index = BPF_R3;</span>
 
 		if (unlikely(index &gt;= array-&gt;map.max_entries))
 			goto out;
<span class="p_chunk">@@ -923,6 +924,13 @@</span> <span class="p_context"> static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)</span>
 }
 STACK_FRAME_NON_STANDARD(__bpf_prog_run); /* jump table */
 
<span class="p_add">+#else</span>
<span class="p_add">+static unsigned int __bpf_prog_ret0(void *ctx, const struct bpf_insn *insn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 bool bpf_prog_array_compatible(struct bpf_array *array,
 			       const struct bpf_prog *fp)
 {
<span class="p_chunk">@@ -970,7 +978,11 @@</span> <span class="p_context"> static int bpf_check_tail_call(const struct bpf_prog *fp)</span>
  */
 struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)
 {
<span class="p_add">+#ifndef CONFIG_BPF_JIT_ALWAYS_ON</span>
 	fp-&gt;bpf_func = (void *) __bpf_prog_run;
<span class="p_add">+#else</span>
<span class="p_add">+	fp-&gt;bpf_func = (void *) __bpf_prog_ret0;</span>
<span class="p_add">+#endif</span>
 
 	/* eBPF JITs can rewrite the program in case constant
 	 * blinding is active. However, in case of error during
<span class="p_chunk">@@ -979,6 +991,12 @@</span> <span class="p_context"> struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)</span>
 	 * be JITed, but falls back to the interpreter.
 	 */
 	fp = bpf_int_jit_compile(fp);
<span class="p_add">+#ifdef CONFIG_BPF_JIT_ALWAYS_ON</span>
<span class="p_add">+	if (!fp-&gt;jited) {</span>
<span class="p_add">+		*err = -ENOTSUPP;</span>
<span class="p_add">+		return fp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
 	bpf_prog_lock_ro(fp);
 
 	/* The tail call compatibility check can only be done at
<span class="p_header">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span>
<span class="p_header">index 19c44cf59bb2..076e4a0ff95e 100644</span>
<span class="p_header">--- a/kernel/bpf/verifier.c</span>
<span class="p_header">+++ b/kernel/bpf/verifier.c</span>
<span class="p_chunk">@@ -702,6 +702,13 @@</span> <span class="p_context"> static bool is_pointer_value(struct bpf_verifier_env *env, int regno)</span>
 	return __is_pointer_value(env-&gt;allow_ptr_leaks, &amp;env-&gt;cur_state.regs[regno]);
 }
 
<span class="p_add">+static bool is_ctx_reg(struct bpf_verifier_env *env, int regno)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct bpf_reg_state *reg = &amp;env-&gt;cur_state.regs[regno];</span>
<span class="p_add">+</span>
<span class="p_add">+	return reg-&gt;type == PTR_TO_CTX;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int check_ptr_alignment(struct bpf_verifier_env *env,
 			       struct bpf_reg_state *reg, int off, int size)
 {
<span class="p_chunk">@@ -896,6 +903,12 @@</span> <span class="p_context"> static int check_xadd(struct bpf_verifier_env *env, struct bpf_insn *insn)</span>
 		return -EACCES;
 	}
 
<span class="p_add">+	if (is_ctx_reg(env, insn-&gt;dst_reg)) {</span>
<span class="p_add">+		verbose(&quot;BPF_XADD stores into R%d context is not allowed\n&quot;,</span>
<span class="p_add">+			insn-&gt;dst_reg);</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* check whether atomic_add can read the memory */
 	err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,
 			       BPF_SIZE(insn-&gt;code), BPF_READ, -1);
<span class="p_chunk">@@ -1843,6 +1856,11 @@</span> <span class="p_context"> static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)</span>
 			return -EINVAL;
 		}
 
<span class="p_add">+		if (opcode == BPF_ARSH &amp;&amp; BPF_CLASS(insn-&gt;code) != BPF_ALU64) {</span>
<span class="p_add">+			verbose(&quot;BPF_ARSH not supported for 32 bit ALU\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if ((opcode == BPF_LSH || opcode == BPF_RSH ||
 		     opcode == BPF_ARSH) &amp;&amp; BPF_SRC(insn-&gt;code) == BPF_K) {
 			int size = BPF_CLASS(insn-&gt;code) == BPF_ALU64 ? 64 : 32;
<span class="p_chunk">@@ -3007,6 +3025,12 @@</span> <span class="p_context"> static int do_check(struct bpf_verifier_env *env)</span>
 			if (err)
 				return err;
 
<span class="p_add">+			if (is_ctx_reg(env, insn-&gt;dst_reg)) {</span>
<span class="p_add">+				verbose(&quot;BPF_ST stores into R%d context is not allowed\n&quot;,</span>
<span class="p_add">+					insn-&gt;dst_reg);</span>
<span class="p_add">+				return -EACCES;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			/* check that memory (dst_reg + off) is writeable */
 			err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,
 					       BPF_SIZE(insn-&gt;code), BPF_WRITE,
<span class="p_chunk">@@ -3386,6 +3410,24 @@</span> <span class="p_context"> static int fixup_bpf_calls(struct bpf_verifier_env *env)</span>
 
 
 	for (i = 0; i &lt; insn_cnt; i++, insn++) {
<span class="p_add">+		if (insn-&gt;code == (BPF_ALU | BPF_MOD | BPF_X) ||</span>
<span class="p_add">+		    insn-&gt;code == (BPF_ALU | BPF_DIV | BPF_X)) {</span>
<span class="p_add">+			/* due to JIT bugs clear upper 32-bits of src register</span>
<span class="p_add">+			 * before div/mod operation</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			insn_buf[0] = BPF_MOV32_REG(insn-&gt;src_reg, insn-&gt;src_reg);</span>
<span class="p_add">+			insn_buf[1] = *insn;</span>
<span class="p_add">+			cnt = 2;</span>
<span class="p_add">+			new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);</span>
<span class="p_add">+			if (!new_prog)</span>
<span class="p_add">+				return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+			delta    += cnt - 1;</span>
<span class="p_add">+			env-&gt;prog = prog = new_prog;</span>
<span class="p_add">+			insn      = new_prog-&gt;insnsi + i + delta;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (insn-&gt;code != (BPF_JMP | BPF_CALL))
 			continue;
 
<span class="p_header">diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c</span>
<span class="p_header">index eeb7f2f5698d..54fd2fed36e9 100644</span>
<span class="p_header">--- a/kernel/time/hrtimer.c</span>
<span class="p_header">+++ b/kernel/time/hrtimer.c</span>
<span class="p_chunk">@@ -652,7 +652,9 @@</span> <span class="p_context"> static void hrtimer_reprogram(struct hrtimer *timer,</span>
 static inline void hrtimer_init_hres(struct hrtimer_cpu_base *base)
 {
 	base-&gt;expires_next.tv64 = KTIME_MAX;
<span class="p_add">+	base-&gt;hang_detected = 0;</span>
 	base-&gt;hres_active = 0;
<span class="p_add">+	base-&gt;next_timer = NULL;</span>
 }
 
 /*
<span class="p_chunk">@@ -1610,6 +1612,7 @@</span> <span class="p_context"> int hrtimers_prepare_cpu(unsigned int cpu)</span>
 		timerqueue_init_head(&amp;cpu_base-&gt;clock_base[i].active);
 	}
 
<span class="p_add">+	cpu_base-&gt;active_bases = 0;</span>
 	cpu_base-&gt;cpu = cpu;
 	hrtimer_init_hres(cpu_base);
 	return 0;
<span class="p_header">diff --git a/lib/test_bpf.c b/lib/test_bpf.c</span>
<span class="p_header">index 2e385026915c..98da7520a6aa 100644</span>
<span class="p_header">--- a/lib/test_bpf.c</span>
<span class="p_header">+++ b/lib/test_bpf.c</span>
<span class="p_chunk">@@ -5646,9 +5646,8 @@</span> <span class="p_context"> static struct bpf_prog *generate_filter(int which, int *err)</span>
 				return NULL;
 			}
 		}
<span class="p_del">-		/* We don&#39;t expect to fail. */</span>
 		if (*err) {
<span class="p_del">-			pr_cont(&quot;FAIL to attach err=%d len=%d\n&quot;,</span>
<span class="p_add">+			pr_cont(&quot;FAIL to prog_create err=%d len=%d\n&quot;,</span>
 				*err, fprog.len);
 			return NULL;
 		}
<span class="p_chunk">@@ -5671,6 +5670,10 @@</span> <span class="p_context"> static struct bpf_prog *generate_filter(int which, int *err)</span>
 		 * checks.
 		 */
 		fp = bpf_prog_select_runtime(fp, err);
<span class="p_add">+		if (*err) {</span>
<span class="p_add">+			pr_cont(&quot;FAIL to select_runtime err=%d\n&quot;, *err);</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+		}</span>
 		break;
 	}
 
<span class="p_chunk">@@ -5856,8 +5859,8 @@</span> <span class="p_context"> static __init int test_bpf(void)</span>
 				pass_cnt++;
 				continue;
 			}
<span class="p_del">-</span>
<span class="p_del">-			return err;</span>
<span class="p_add">+			err_cnt++;</span>
<span class="p_add">+			continue;</span>
 		}
 
 		pr_cont(&quot;jited:%u &quot;, fp-&gt;jited);
<span class="p_header">diff --git a/mm/cma.c b/mm/cma.c</span>
<span class="p_header">index c960459eda7e..397687fc51f9 100644</span>
<span class="p_header">--- a/mm/cma.c</span>
<span class="p_header">+++ b/mm/cma.c</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> unsigned long cma_get_size(const struct cma *cma)</span>
 }
 
 static unsigned long cma_bitmap_aligned_mask(const struct cma *cma,
<span class="p_del">-					     int align_order)</span>
<span class="p_add">+					     unsigned int align_order)</span>
 {
 	if (align_order &lt;= cma-&gt;order_per_bit)
 		return 0;
<span class="p_chunk">@@ -62,17 +62,14 @@</span> <span class="p_context"> static unsigned long cma_bitmap_aligned_mask(const struct cma *cma,</span>
 }
 
 /*
<span class="p_del">- * Find a PFN aligned to the specified order and return an offset represented in</span>
<span class="p_del">- * order_per_bits.</span>
<span class="p_add">+ * Find the offset of the base PFN from the specified align_order.</span>
<span class="p_add">+ * The value returned is represented in order_per_bits.</span>
  */
 static unsigned long cma_bitmap_aligned_offset(const struct cma *cma,
<span class="p_del">-					       int align_order)</span>
<span class="p_add">+					       unsigned int align_order)</span>
 {
<span class="p_del">-	if (align_order &lt;= cma-&gt;order_per_bit)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return (ALIGN(cma-&gt;base_pfn, (1UL &lt;&lt; align_order))</span>
<span class="p_del">-		- cma-&gt;base_pfn) &gt;&gt; cma-&gt;order_per_bit;</span>
<span class="p_add">+	return (cma-&gt;base_pfn &amp; ((1UL &lt;&lt; align_order) - 1))</span>
<span class="p_add">+		&gt;&gt; cma-&gt;order_per_bit;</span>
 }
 
 static unsigned long cma_bitmap_pages_to_bits(const struct cma *cma,
<span class="p_header">diff --git a/mm/internal.h b/mm/internal.h</span>
<span class="p_header">index 34a5459e5989..3e2d01694747 100644</span>
<span class="p_header">--- a/mm/internal.h</span>
<span class="p_header">+++ b/mm/internal.h</span>
<span class="p_chunk">@@ -73,6 +73,12 @@</span> <span class="p_context"> static inline void set_page_refcounted(struct page *page)</span>
 
 extern unsigned long highest_memmap_pfn;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Maximum number of reclaim retries without progress before the OOM</span>
<span class="p_add">+ * killer is consider the only way forward.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MAX_RECLAIM_RETRIES 16</span>
<span class="p_add">+</span>
 /*
  * in mm/vmscan.c:
  */
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 2a800c4a39bd..50088150fc17 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -5531,7 +5531,7 @@</span> <span class="p_context"> static void uncharge_list(struct list_head *page_list)</span>
 		next = page-&gt;lru.next;
 
 		VM_BUG_ON_PAGE(PageLRU(page), page);
<span class="p_del">-		VM_BUG_ON_PAGE(page_count(page), page);</span>
<span class="p_add">+		VM_BUG_ON_PAGE(!PageHWPoison(page) &amp;&amp; page_count(page), page);</span>
 
 		if (!page-&gt;mem_cgroup)
 			continue;
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index ce7d416edab7..5aa71a82ca73 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -535,6 +535,13 @@</span> <span class="p_context"> static int delete_from_lru_cache(struct page *p)</span>
 		 */
 		ClearPageActive(p);
 		ClearPageUnevictable(p);
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Poisoned page might never drop its ref count to 0 so we have</span>
<span class="p_add">+		 * to uncharge it manually from its memcg.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mem_cgroup_uncharge(p);</span>
<span class="p_add">+</span>
 		/*
 		 * drop the page count elevated by isolate_lru_page()
 		 */
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index 5b48adb4aa56..45ac5b973459 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -2240,7 +2240,8 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 		gap_addr = TASK_SIZE;
 
 	next = vma-&gt;vm_next;
<span class="p_del">-	if (next &amp;&amp; next-&gt;vm_start &lt; gap_addr) {</span>
<span class="p_add">+	if (next &amp;&amp; next-&gt;vm_start &lt; gap_addr &amp;&amp;</span>
<span class="p_add">+			(next-&gt;vm_flags &amp; (VM_WRITE|VM_READ|VM_EXEC))) {</span>
 		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))
 			return -ENOMEM;
 		/* Check that both stack segments have the same anon_vma? */
<span class="p_chunk">@@ -2324,7 +2325,8 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	if (gap_addr &gt; address)
 		return -ENOMEM;
 	prev = vma-&gt;vm_prev;
<span class="p_del">-	if (prev &amp;&amp; prev-&gt;vm_end &gt; gap_addr) {</span>
<span class="p_add">+	if (prev &amp;&amp; prev-&gt;vm_end &gt; gap_addr &amp;&amp;</span>
<span class="p_add">+			(prev-&gt;vm_flags &amp; (VM_WRITE|VM_READ|VM_EXEC))) {</span>
 		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))
 			return -ENOMEM;
 		/* Check that both stack segments have the same anon_vma? */
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index fbc38888252b..94018ea5f935 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -2821,9 +2821,6 @@</span> <span class="p_context"> bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,</span>
 		if (!area-&gt;nr_free)
 			continue;
 
<span class="p_del">-		if (alloc_harder)</span>
<span class="p_del">-			return true;</span>
<span class="p_del">-</span>
 		for (mt = 0; mt &lt; MIGRATE_PCPTYPES; mt++) {
 			if (!list_empty(&amp;area-&gt;free_list[mt]))
 				return true;
<span class="p_chunk">@@ -2835,6 +2832,9 @@</span> <span class="p_context"> bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,</span>
 			return true;
 		}
 #endif
<span class="p_add">+		if (alloc_harder &amp;&amp;</span>
<span class="p_add">+			!list_empty(&amp;area-&gt;free_list[MIGRATE_HIGHATOMIC]))</span>
<span class="p_add">+			return true;</span>
 	}
 	return false;
 }
<span class="p_chunk">@@ -3421,12 +3421,6 @@</span> <span class="p_context"> bool gfp_pfmemalloc_allowed(gfp_t gfp_mask)</span>
 	return false;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Maximum number of reclaim retries without any progress before OOM killer</span>
<span class="p_del">- * is consider as the only way to move forward.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define MAX_RECLAIM_RETRIES 16</span>
<span class="p_del">-</span>
 /*
  * Checks whether it makes sense to retry the reclaim to make a forward progress
  * for the given allocation request.
<span class="p_chunk">@@ -4385,7 +4379,8 @@</span> <span class="p_context"> void show_free_areas(unsigned int filter)</span>
 			K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),
 			K(node_page_state(pgdat, NR_UNSTABLE_NFS)),
 			node_page_state(pgdat, NR_PAGES_SCANNED),
<span class="p_del">-			!pgdat_reclaimable(pgdat) ? &quot;yes&quot; : &quot;no&quot;);</span>
<span class="p_add">+			pgdat-&gt;kswapd_failures &gt;= MAX_RECLAIM_RETRIES ?</span>
<span class="p_add">+				&quot;yes&quot; : &quot;no&quot;);</span>
 	}
 
 	for_each_populated_zone(zone) {
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index 30a88b945a44..f118dc23f662 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -2606,6 +2606,15 @@</span> <span class="p_context"> static bool shrink_node(pg_data_t *pgdat, struct scan_control *sc)</span>
 	} while (should_continue_reclaim(pgdat, sc-&gt;nr_reclaimed - nr_reclaimed,
 					 sc-&gt;nr_scanned - nr_scanned, sc));
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Kswapd gives up on balancing particular nodes after too</span>
<span class="p_add">+	 * many failures to reclaim anything from them and goes to</span>
<span class="p_add">+	 * sleep. On reclaim progress, reset the failure counter. A</span>
<span class="p_add">+	 * successful direct reclaim run will revive a dormant kswapd.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (reclaimable)</span>
<span class="p_add">+		pgdat-&gt;kswapd_failures = 0;</span>
<span class="p_add">+</span>
 	return reclaimable;
 }
 
<span class="p_chunk">@@ -2680,10 +2689,6 @@</span> <span class="p_context"> static void shrink_zones(struct zonelist *zonelist, struct scan_control *sc)</span>
 						 GFP_KERNEL | __GFP_HARDWALL))
 				continue;
 
<span class="p_del">-			if (sc-&gt;priority != DEF_PRIORITY &amp;&amp;</span>
<span class="p_del">-			    !pgdat_reclaimable(zone-&gt;zone_pgdat))</span>
<span class="p_del">-				continue;	/* Let kswapd poll it */</span>
<span class="p_del">-</span>
 			/*
 			 * If we already have plenty of memory free for
 			 * compaction in this zone, don&#39;t free any more.
<span class="p_chunk">@@ -2820,7 +2825,7 @@</span> <span class="p_context"> static unsigned long do_try_to_free_pages(struct zonelist *zonelist,</span>
 	return 0;
 }
 
<span class="p_del">-static bool pfmemalloc_watermark_ok(pg_data_t *pgdat)</span>
<span class="p_add">+static bool allow_direct_reclaim(pg_data_t *pgdat)</span>
 {
 	struct zone *zone;
 	unsigned long pfmemalloc_reserve = 0;
<span class="p_chunk">@@ -2828,6 +2833,9 @@</span> <span class="p_context"> static bool pfmemalloc_watermark_ok(pg_data_t *pgdat)</span>
 	int i;
 	bool wmark_ok;
 
<span class="p_add">+	if (pgdat-&gt;kswapd_failures &gt;= MAX_RECLAIM_RETRIES)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt;= ZONE_NORMAL; i++) {
 		zone = &amp;pgdat-&gt;node_zones[i];
 		if (!managed_zone(zone) ||
<span class="p_chunk">@@ -2908,7 +2916,7 @@</span> <span class="p_context"> static bool throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,</span>
 
 		/* Throttle based on the first usable node */
 		pgdat = zone-&gt;zone_pgdat;
<span class="p_del">-		if (pfmemalloc_watermark_ok(pgdat))</span>
<span class="p_add">+		if (allow_direct_reclaim(pgdat))</span>
 			goto out;
 		break;
 	}
<span class="p_chunk">@@ -2930,14 +2938,14 @@</span> <span class="p_context"> static bool throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,</span>
 	 */
 	if (!(gfp_mask &amp; __GFP_FS)) {
 		wait_event_interruptible_timeout(pgdat-&gt;pfmemalloc_wait,
<span class="p_del">-			pfmemalloc_watermark_ok(pgdat), HZ);</span>
<span class="p_add">+			allow_direct_reclaim(pgdat), HZ);</span>
 
 		goto check_pending;
 	}
 
 	/* Throttle until kswapd wakes the process */
 	wait_event_killable(zone-&gt;zone_pgdat-&gt;pfmemalloc_wait,
<span class="p_del">-		pfmemalloc_watermark_ok(pgdat));</span>
<span class="p_add">+		allow_direct_reclaim(pgdat));</span>
 
 check_pending:
 	if (fatal_signal_pending(current))
<span class="p_chunk">@@ -3116,7 +3124,7 @@</span> <span class="p_context"> static bool prepare_kswapd_sleep(pg_data_t *pgdat, int order, int classzone_idx)</span>
 
 	/*
 	 * The throttled processes are normally woken up in balance_pgdat() as
<span class="p_del">-	 * soon as pfmemalloc_watermark_ok() is true. But there is a potential</span>
<span class="p_add">+	 * soon as allow_direct_reclaim() is true. But there is a potential</span>
 	 * race between when kswapd checks the watermarks and a process gets
 	 * throttled. There is also a potential race if processes get
 	 * throttled, kswapd wakes, a large process exits thereby balancing the
<span class="p_chunk">@@ -3130,6 +3138,10 @@</span> <span class="p_context"> static bool prepare_kswapd_sleep(pg_data_t *pgdat, int order, int classzone_idx)</span>
 	if (waitqueue_active(&amp;pgdat-&gt;pfmemalloc_wait))
 		wake_up_all(&amp;pgdat-&gt;pfmemalloc_wait);
 
<span class="p_add">+	/* Hopeless node, leave it to direct reclaim */</span>
<span class="p_add">+	if (pgdat-&gt;kswapd_failures &gt;= MAX_RECLAIM_RETRIES)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt;= classzone_idx; i++) {
 		struct zone *zone = pgdat-&gt;node_zones + i;
 
<span class="p_chunk">@@ -3216,9 +3228,9 @@</span> <span class="p_context"> static int balance_pgdat(pg_data_t *pgdat, int order, int classzone_idx)</span>
 	count_vm_event(PAGEOUTRUN);
 
 	do {
<span class="p_add">+		unsigned long nr_reclaimed = sc.nr_reclaimed;</span>
 		bool raise_priority = true;
 
<span class="p_del">-		sc.nr_reclaimed = 0;</span>
 		sc.reclaim_idx = classzone_idx;
 
 		/*
<span class="p_chunk">@@ -3297,7 +3309,7 @@</span> <span class="p_context"> static int balance_pgdat(pg_data_t *pgdat, int order, int classzone_idx)</span>
 		 * able to safely make forward progress. Wake them
 		 */
 		if (waitqueue_active(&amp;pgdat-&gt;pfmemalloc_wait) &amp;&amp;
<span class="p_del">-				pfmemalloc_watermark_ok(pgdat))</span>
<span class="p_add">+				allow_direct_reclaim(pgdat))</span>
 			wake_up_all(&amp;pgdat-&gt;pfmemalloc_wait);
 
 		/* Check if kswapd should be suspending */
<span class="p_chunk">@@ -3308,10 +3320,14 @@</span> <span class="p_context"> static int balance_pgdat(pg_data_t *pgdat, int order, int classzone_idx)</span>
 		 * Raise priority if scanning rate is too low or there was no
 		 * progress in reclaiming pages
 		 */
<span class="p_del">-		if (raise_priority || !sc.nr_reclaimed)</span>
<span class="p_add">+		nr_reclaimed = sc.nr_reclaimed - nr_reclaimed;</span>
<span class="p_add">+		if (raise_priority || !nr_reclaimed)</span>
 			sc.priority--;
 	} while (sc.priority &gt;= 1);
 
<span class="p_add">+	if (!sc.nr_reclaimed)</span>
<span class="p_add">+		pgdat-&gt;kswapd_failures++;</span>
<span class="p_add">+</span>
 out:
 	/*
 	 * Return the order kswapd stopped reclaiming at as
<span class="p_chunk">@@ -3511,6 +3527,10 @@</span> <span class="p_context"> void wakeup_kswapd(struct zone *zone, int order, enum zone_type classzone_idx)</span>
 	if (!waitqueue_active(&amp;pgdat-&gt;kswapd_wait))
 		return;
 
<span class="p_add">+	/* Hopeless node, leave it to direct reclaim */</span>
<span class="p_add">+	if (pgdat-&gt;kswapd_failures &gt;= MAX_RECLAIM_RETRIES)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* Only wake kswapd if all zones are unbalanced */
 	for (z = 0; z &lt;= classzone_idx; z++) {
 		zone = pgdat-&gt;node_zones + z;
<span class="p_chunk">@@ -3781,9 +3801,6 @@</span> <span class="p_context"> int node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned int order)</span>
 	    sum_zone_node_page_state(pgdat-&gt;node_id, NR_SLAB_RECLAIMABLE) &lt;= pgdat-&gt;min_slab_pages)
 		return NODE_RECLAIM_FULL;
 
<span class="p_del">-	if (!pgdat_reclaimable(pgdat))</span>
<span class="p_del">-		return NODE_RECLAIM_FULL;</span>
<span class="p_del">-</span>
 	/*
 	 * Do not scan if the allocation should not be delayed.
 	 */
<span class="p_header">diff --git a/mm/vmstat.c b/mm/vmstat.c</span>
<span class="p_header">index 6a088df04b29..3863b5d6d598 100644</span>
<span class="p_header">--- a/mm/vmstat.c</span>
<span class="p_header">+++ b/mm/vmstat.c</span>
<span class="p_chunk">@@ -1421,7 +1421,7 @@</span> <span class="p_context"> static void zoneinfo_show_print(struct seq_file *m, pg_data_t *pgdat,</span>
 		   &quot;\n  node_unreclaimable:  %u&quot;
 		   &quot;\n  start_pfn:           %lu&quot;
 		   &quot;\n  node_inactive_ratio: %u&quot;,
<span class="p_del">-		   !pgdat_reclaimable(zone-&gt;zone_pgdat),</span>
<span class="p_add">+		   pgdat-&gt;kswapd_failures &gt;= MAX_RECLAIM_RETRIES,</span>
 		   zone-&gt;zone_start_pfn,
 		   zone-&gt;zone_pgdat-&gt;inactive_ratio);
 	seq_putc(m, &#39;\n&#39;);
<span class="p_header">diff --git a/net/can/af_can.c b/net/can/af_can.c</span>
<span class="p_header">index 5488e4a6ccd0..ac1552d8b4ad 100644</span>
<span class="p_header">--- a/net/can/af_can.c</span>
<span class="p_header">+++ b/net/can/af_can.c</span>
<span class="p_chunk">@@ -722,13 +722,12 @@</span> <span class="p_context"> static int can_rcv(struct sk_buff *skb, struct net_device *dev,</span>
 	if (unlikely(!net_eq(dev_net(dev), &amp;init_net)))
 		goto drop;
 
<span class="p_del">-	if (WARN_ONCE(dev-&gt;type != ARPHRD_CAN ||</span>
<span class="p_del">-		      skb-&gt;len != CAN_MTU ||</span>
<span class="p_del">-		      cfd-&gt;len &gt; CAN_MAX_DLEN,</span>
<span class="p_del">-		      &quot;PF_CAN: dropped non conform CAN skbuf: &quot;</span>
<span class="p_del">-		      &quot;dev type %d, len %d, datalen %d\n&quot;,</span>
<span class="p_del">-		      dev-&gt;type, skb-&gt;len, cfd-&gt;len))</span>
<span class="p_add">+	if (unlikely(dev-&gt;type != ARPHRD_CAN || skb-&gt;len != CAN_MTU ||</span>
<span class="p_add">+		     cfd-&gt;len &gt; CAN_MAX_DLEN)) {</span>
<span class="p_add">+		pr_warn_once(&quot;PF_CAN: dropped non conform CAN skbuf: dev type %d, len %d, datalen %d\n&quot;,</span>
<span class="p_add">+			     dev-&gt;type, skb-&gt;len, cfd-&gt;len);</span>
 		goto drop;
<span class="p_add">+	}</span>
 
 	can_receive(skb, dev);
 	return NET_RX_SUCCESS;
<span class="p_chunk">@@ -746,13 +745,12 @@</span> <span class="p_context"> static int canfd_rcv(struct sk_buff *skb, struct net_device *dev,</span>
 	if (unlikely(!net_eq(dev_net(dev), &amp;init_net)))
 		goto drop;
 
<span class="p_del">-	if (WARN_ONCE(dev-&gt;type != ARPHRD_CAN ||</span>
<span class="p_del">-		      skb-&gt;len != CANFD_MTU ||</span>
<span class="p_del">-		      cfd-&gt;len &gt; CANFD_MAX_DLEN,</span>
<span class="p_del">-		      &quot;PF_CAN: dropped non conform CAN FD skbuf: &quot;</span>
<span class="p_del">-		      &quot;dev type %d, len %d, datalen %d\n&quot;,</span>
<span class="p_del">-		      dev-&gt;type, skb-&gt;len, cfd-&gt;len))</span>
<span class="p_add">+	if (unlikely(dev-&gt;type != ARPHRD_CAN || skb-&gt;len != CANFD_MTU ||</span>
<span class="p_add">+		     cfd-&gt;len &gt; CANFD_MAX_DLEN)) {</span>
<span class="p_add">+		pr_warn_once(&quot;PF_CAN: dropped non conform CAN FD skbuf: dev type %d, len %d, datalen %d\n&quot;,</span>
<span class="p_add">+			     dev-&gt;type, skb-&gt;len, cfd-&gt;len);</span>
 		goto drop;
<span class="p_add">+	}</span>
 
 	can_receive(skb, dev);
 	return NET_RX_SUCCESS;
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 09007a71c8dd..67b5d4d8acb1 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -3083,10 +3083,21 @@</span> <span class="p_context"> static void qdisc_pkt_len_init(struct sk_buff *skb)</span>
 		hdr_len = skb_transport_header(skb) - skb_mac_header(skb);
 
 		/* + transport layer */
<span class="p_del">-		if (likely(shinfo-&gt;gso_type &amp; (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))</span>
<span class="p_del">-			hdr_len += tcp_hdrlen(skb);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			hdr_len += sizeof(struct udphdr);</span>
<span class="p_add">+		if (likely(shinfo-&gt;gso_type &amp; (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {</span>
<span class="p_add">+			const struct tcphdr *th;</span>
<span class="p_add">+			struct tcphdr _tcphdr;</span>
<span class="p_add">+</span>
<span class="p_add">+			th = skb_header_pointer(skb, skb_transport_offset(skb),</span>
<span class="p_add">+						sizeof(_tcphdr), &amp;_tcphdr);</span>
<span class="p_add">+			if (likely(th))</span>
<span class="p_add">+				hdr_len += __tcp_hdrlen(th);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			struct udphdr _udphdr;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (skb_header_pointer(skb, skb_transport_offset(skb),</span>
<span class="p_add">+					       sizeof(_udphdr), &amp;_udphdr))</span>
<span class="p_add">+				hdr_len += sizeof(struct udphdr);</span>
<span class="p_add">+		}</span>
 
 		if (shinfo-&gt;gso_type &amp; SKB_GSO_DODGY)
 			gso_segs = DIV_ROUND_UP(skb-&gt;len - hdr_len,
<span class="p_header">diff --git a/net/core/filter.c b/net/core/filter.c</span>
<span class="p_header">index 4eb4ce0aeef4..e8c89d2d2bc0 100644</span>
<span class="p_header">--- a/net/core/filter.c</span>
<span class="p_header">+++ b/net/core/filter.c</span>
<span class="p_chunk">@@ -441,6 +441,10 @@</span> <span class="p_context"> static int bpf_convert_filter(struct sock_filter *prog, int len,</span>
 			    convert_bpf_extensions(fp, &amp;insn))
 				break;
 
<span class="p_add">+			if (fp-&gt;code == (BPF_ALU | BPF_DIV | BPF_X) ||</span>
<span class="p_add">+			    fp-&gt;code == (BPF_ALU | BPF_MOD | BPF_X))</span>
<span class="p_add">+				*insn++ = BPF_MOV32_REG(BPF_REG_X, BPF_REG_X);</span>
<span class="p_add">+</span>
 			*insn = BPF_RAW_INSN(fp-&gt;code, BPF_REG_A, BPF_REG_X, 0, fp-&gt;k);
 			break;
 
<span class="p_chunk">@@ -1005,11 +1009,9 @@</span> <span class="p_context"> static struct bpf_prog *bpf_migrate_filter(struct bpf_prog *fp)</span>
 		 */
 		goto out_err_free;
 
<span class="p_del">-	/* We are guaranteed to never error here with cBPF to eBPF</span>
<span class="p_del">-	 * transitions, since there&#39;s no issue with type compatibility</span>
<span class="p_del">-	 * checks on program arrays.</span>
<span class="p_del">-	 */</span>
 	fp = bpf_prog_select_runtime(fp, &amp;err);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out_err_free;</span>
 
 	kfree(old_prog);
 	return fp;
<span class="p_header">diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c</span>
<span class="p_header">index 32e4e0158846..862d63ec56e4 100644</span>
<span class="p_header">--- a/net/core/flow_dissector.c</span>
<span class="p_header">+++ b/net/core/flow_dissector.c</span>
<span class="p_chunk">@@ -550,8 +550,8 @@</span> <span class="p_context"> bool __skb_flow_dissect(const struct sk_buff *skb,</span>
 out_good:
 	ret = true;
 
<span class="p_del">-	key_control-&gt;thoff = (u16)nhoff;</span>
 out:
<span class="p_add">+	key_control-&gt;thoff = min_t(u16, nhoff, skb ? skb-&gt;len : hlen);</span>
 	key_basic-&gt;n_proto = proto;
 	key_basic-&gt;ip_proto = ip_proto;
 
<span class="p_chunk">@@ -559,7 +559,6 @@</span> <span class="p_context"> bool __skb_flow_dissect(const struct sk_buff *skb,</span>
 
 out_bad:
 	ret = false;
<span class="p_del">-	key_control-&gt;thoff = min_t(u16, nhoff, skb ? skb-&gt;len : hlen);</span>
 	goto out;
 }
 EXPORT_SYMBOL(__skb_flow_dissect);
<span class="p_header">diff --git a/net/core/neighbour.c b/net/core/neighbour.c</span>
<span class="p_header">index f45f6198851f..7b315663f840 100644</span>
<span class="p_header">--- a/net/core/neighbour.c</span>
<span class="p_header">+++ b/net/core/neighbour.c</span>
<span class="p_chunk">@@ -496,7 +496,7 @@</span> <span class="p_context"> struct neighbour *__neigh_create(struct neigh_table *tbl, const void *pkey,</span>
 	if (atomic_read(&amp;tbl-&gt;entries) &gt; (1 &lt;&lt; nht-&gt;hash_shift))
 		nht = neigh_hash_grow(tbl, nht-&gt;hash_shift + 1);
 
<span class="p_del">-	hash_val = tbl-&gt;hash(pkey, dev, nht-&gt;hash_rnd) &gt;&gt; (32 - nht-&gt;hash_shift);</span>
<span class="p_add">+	hash_val = tbl-&gt;hash(n-&gt;primary_key, dev, nht-&gt;hash_rnd) &gt;&gt; (32 - nht-&gt;hash_shift);</span>
 
 	if (n-&gt;parms-&gt;dead) {
 		rc = ERR_PTR(-EINVAL);
<span class="p_chunk">@@ -508,7 +508,7 @@</span> <span class="p_context"> struct neighbour *__neigh_create(struct neigh_table *tbl, const void *pkey,</span>
 	     n1 != NULL;
 	     n1 = rcu_dereference_protected(n1-&gt;next,
 			lockdep_is_held(&amp;tbl-&gt;lock))) {
<span class="p_del">-		if (dev == n1-&gt;dev &amp;&amp; !memcmp(n1-&gt;primary_key, pkey, key_len)) {</span>
<span class="p_add">+		if (dev == n1-&gt;dev &amp;&amp; !memcmp(n1-&gt;primary_key, n-&gt;primary_key, key_len)) {</span>
 			if (want_ref)
 				neigh_hold(n1);
 			rc = n1;
<span class="p_header">diff --git a/net/core/sysctl_net_core.c b/net/core/sysctl_net_core.c</span>
<span class="p_header">index a7f05f0130e8..1b4619008c4e 100644</span>
<span class="p_header">--- a/net/core/sysctl_net_core.c</span>
<span class="p_header">+++ b/net/core/sysctl_net_core.c</span>
<span class="p_chunk">@@ -292,7 +292,13 @@</span> <span class="p_context"> static struct ctl_table net_core_table[] = {</span>
 		.data		= &amp;bpf_jit_enable,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
<span class="p_add">+#ifndef CONFIG_BPF_JIT_ALWAYS_ON</span>
 		.proc_handler	= proc_dointvec
<span class="p_add">+#else</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;one,</span>
<span class="p_add">+		.extra2		= &amp;one,</span>
<span class="p_add">+#endif</span>
 	},
 # ifdef CONFIG_HAVE_EBPF_JIT
 	{
<span class="p_header">diff --git a/net/dccp/ccids/ccid2.c b/net/dccp/ccids/ccid2.c</span>
<span class="p_header">index 5e3a7302f774..7753681195c1 100644</span>
<span class="p_header">--- a/net/dccp/ccids/ccid2.c</span>
<span class="p_header">+++ b/net/dccp/ccids/ccid2.c</span>
<span class="p_chunk">@@ -140,6 +140,9 @@</span> <span class="p_context"> static void ccid2_hc_tx_rto_expire(unsigned long data)</span>
 
 	ccid2_pr_debug(&quot;RTO_EXPIRE\n&quot;);
 
<span class="p_add">+	if (sk-&gt;sk_state == DCCP_CLOSED)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	/* back-off timer */
 	hc-&gt;tx_rto &lt;&lt;= 1;
 	if (hc-&gt;tx_rto &gt; DCCP_RTO_MAX)
<span class="p_header">diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c</span>
<span class="p_header">index 51b27ae09fbd..e60517eb1c3a 100644</span>
<span class="p_header">--- a/net/ipv4/arp.c</span>
<span class="p_header">+++ b/net/ipv4/arp.c</span>
<span class="p_chunk">@@ -223,11 +223,16 @@</span> <span class="p_context"> static bool arp_key_eq(const struct neighbour *neigh, const void *pkey)</span>
 
 static int arp_constructor(struct neighbour *neigh)
 {
<span class="p_del">-	__be32 addr = *(__be32 *)neigh-&gt;primary_key;</span>
<span class="p_add">+	__be32 addr;</span>
 	struct net_device *dev = neigh-&gt;dev;
 	struct in_device *in_dev;
 	struct neigh_parms *parms;
<span class="p_add">+	u32 inaddr_any = INADDR_ANY;</span>
 
<span class="p_add">+	if (dev-&gt;flags &amp; (IFF_LOOPBACK | IFF_POINTOPOINT))</span>
<span class="p_add">+		memcpy(neigh-&gt;primary_key, &amp;inaddr_any, arp_tbl.key_len);</span>
<span class="p_add">+</span>
<span class="p_add">+	addr = *(__be32 *)neigh-&gt;primary_key;</span>
 	rcu_read_lock();
 	in_dev = __in_dev_get_rcu(dev);
 	if (!in_dev) {
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 7bff0c65046f..9c7a4cea1628 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -332,7 +332,7 @@</span> <span class="p_context"> static __be32 igmpv3_get_srcaddr(struct net_device *dev,</span>
 		return htonl(INADDR_ANY);
 
 	for_ifa(in_dev) {
<span class="p_del">-		if (inet_ifa_match(fl4-&gt;saddr, ifa))</span>
<span class="p_add">+		if (fl4-&gt;saddr == ifa-&gt;ifa_local)</span>
 			return fl4-&gt;saddr;
 	} endfor_ifa(in_dev);
 
<span class="p_header">diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c</span>
<span class="p_header">index 05d2bde00864..7efa6b062049 100644</span>
<span class="p_header">--- a/net/ipv4/tcp.c</span>
<span class="p_header">+++ b/net/ipv4/tcp.c</span>
<span class="p_chunk">@@ -2215,6 +2215,9 @@</span> <span class="p_context"> void tcp_close(struct sock *sk, long timeout)</span>
 			tcp_send_active_reset(sk, GFP_ATOMIC);
 			__NET_INC_STATS(sock_net(sk),
 					LINUX_MIB_TCPABORTONMEMORY);
<span class="p_add">+		} else if (!check_net(sock_net(sk))) {</span>
<span class="p_add">+			/* Not possible to send reset; just close */</span>
<span class="p_add">+			tcp_set_state(sk, TCP_CLOSE);</span>
 		}
 	}
 
<span class="p_header">diff --git a/net/ipv4/tcp_offload.c b/net/ipv4/tcp_offload.c</span>
<span class="p_header">index bc68da38ea86..366b1becff9d 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_offload.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_offload.c</span>
<span class="p_chunk">@@ -32,6 +32,9 @@</span> <span class="p_context"> static void tcp_gso_tstamp(struct sk_buff *skb, unsigned int ts_seq,</span>
 static struct sk_buff *tcp4_gso_segment(struct sk_buff *skb,
 					netdev_features_t features)
 {
<span class="p_add">+	if (!(skb_shinfo(skb)-&gt;gso_type &amp; SKB_GSO_TCPV4))</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
 		return ERR_PTR(-EINVAL);
 
<span class="p_header">diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c</span>
<span class="p_header">index 74db43b47917..69523389f067 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_timer.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_timer.c</span>
<span class="p_chunk">@@ -50,11 +50,19 @@</span> <span class="p_context"> static void tcp_write_err(struct sock *sk)</span>
  *  to prevent DoS attacks. It is called when a retransmission timeout
  *  or zero probe timeout occurs on orphaned socket.
  *
<span class="p_add">+ *  Also close if our net namespace is exiting; in that case there is no</span>
<span class="p_add">+ *  hope of ever communicating again since all netns interfaces are already</span>
<span class="p_add">+ *  down (or about to be down), and we need to release our dst references,</span>
<span class="p_add">+ *  which have been moved to the netns loopback interface, so the namespace</span>
<span class="p_add">+ *  can finish exiting.  This condition is only possible if we are a kernel</span>
<span class="p_add">+ *  socket, as those do not hold references to the namespace.</span>
<span class="p_add">+ *</span>
  *  Criteria is still not confirmed experimentally and may change.
  *  We kill the socket, if:
  *  1. If number of orphaned sockets exceeds an administratively configured
  *     limit.
  *  2. If we have strong memory pressure.
<span class="p_add">+ *  3. If our net namespace is exiting.</span>
  */
 static int tcp_out_of_resources(struct sock *sk, bool do_reset)
 {
<span class="p_chunk">@@ -83,6 +91,13 @@</span> <span class="p_context"> static int tcp_out_of_resources(struct sock *sk, bool do_reset)</span>
 		__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONMEMORY);
 		return 1;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!check_net(sock_net(sk))) {</span>
<span class="p_add">+		/* Not possible to send reset; just close */</span>
<span class="p_add">+		tcp_done(sk);</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c</span>
<span class="p_header">index 6401574cd638..f4f616eaaeb8 100644</span>
<span class="p_header">--- a/net/ipv4/udp_offload.c</span>
<span class="p_header">+++ b/net/ipv4/udp_offload.c</span>
<span class="p_chunk">@@ -205,6 +205,9 @@</span> <span class="p_context"> static struct sk_buff *udp4_ufo_fragment(struct sk_buff *skb,</span>
 		goto out;
 	}
 
<span class="p_add">+	if (!(skb_shinfo(skb)-&gt;gso_type &amp; SKB_GSO_UDP))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (!pskb_may_pull(skb, sizeof(struct udphdr)))
 		goto out;
 
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index c46066c5dc27..db2613b4a049 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -337,11 +337,12 @@</span> <span class="p_context"> static struct ip6_tnl *ip6gre_tunnel_locate(struct net *net,</span>
 
 	nt-&gt;dev = dev;
 	nt-&gt;net = dev_net(dev);
<span class="p_del">-	ip6gre_tnl_link_config(nt, 1);</span>
 
 	if (register_netdevice(dev) &lt; 0)
 		goto failed_free;
 
<span class="p_add">+	ip6gre_tnl_link_config(nt, 1);</span>
<span class="p_add">+</span>
 	/* Can use a lockless transmit, unless we generate output sequences */
 	if (!(nt-&gt;parms.o_flags &amp; TUNNEL_SEQ))
 		dev-&gt;features |= NETIF_F_LLTX;
<span class="p_chunk">@@ -1263,7 +1264,6 @@</span> <span class="p_context"> static void ip6gre_netlink_parms(struct nlattr *data[],</span>
 
 static int ip6gre_tap_init(struct net_device *dev)
 {
<span class="p_del">-	struct ip6_tnl *tunnel;</span>
 	int ret;
 
 	ret = ip6gre_tunnel_init_common(dev);
<span class="p_chunk">@@ -1272,10 +1272,6 @@</span> <span class="p_context"> static int ip6gre_tap_init(struct net_device *dev)</span>
 
 	dev-&gt;priv_flags |= IFF_LIVE_ADDR_CHANGE;
 
<span class="p_del">-	tunnel = netdev_priv(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	ip6gre_tnl_link_config(tunnel, 1);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1370,7 +1366,6 @@</span> <span class="p_context"> static int ip6gre_newlink(struct net *src_net, struct net_device *dev,</span>
 
 	nt-&gt;dev = dev;
 	nt-&gt;net = dev_net(dev);
<span class="p_del">-	ip6gre_tnl_link_config(nt, !tb[IFLA_MTU]);</span>
 
 	dev-&gt;features		|= GRE6_FEATURES;
 	dev-&gt;hw_features	|= GRE6_FEATURES;
<span class="p_chunk">@@ -1396,6 +1391,11 @@</span> <span class="p_context"> static int ip6gre_newlink(struct net *src_net, struct net_device *dev,</span>
 	if (err)
 		goto out;
 
<span class="p_add">+	ip6gre_tnl_link_config(nt, !tb[IFLA_MTU]);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_MTU])</span>
<span class="p_add">+		ip6_tnl_change_mtu(dev, nla_get_u32(tb[IFLA_MTU]));</span>
<span class="p_add">+</span>
 	dev_hold(dev);
 	ip6gre_tunnel_link(ign, nt);
 
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 388584b8ff31..2e3db3619858 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> int ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb)</span>
 			    !(IP6CB(skb)-&gt;flags &amp; IP6SKB_REROUTED));
 }
 
<span class="p_del">-static bool ip6_autoflowlabel(struct net *net, const struct ipv6_pinfo *np)</span>
<span class="p_add">+bool ip6_autoflowlabel(struct net *net, const struct ipv6_pinfo *np)</span>
 {
 	if (!np-&gt;autoflowlabel_set)
 		return ip6_default_np_autolabel(net);
<span class="p_chunk">@@ -1260,14 +1260,16 @@</span> <span class="p_context"> static int ip6_setup_cork(struct sock *sk, struct inet_cork_full *cork,</span>
 	v6_cork-&gt;tclass = ipc6-&gt;tclass;
 	if (rt-&gt;dst.flags &amp; DST_XFRM_TUNNEL)
 		mtu = np-&gt;pmtudisc &gt;= IPV6_PMTUDISC_PROBE ?
<span class="p_del">-		      rt-&gt;dst.dev-&gt;mtu : dst_mtu(&amp;rt-&gt;dst);</span>
<span class="p_add">+		      READ_ONCE(rt-&gt;dst.dev-&gt;mtu) : dst_mtu(&amp;rt-&gt;dst);</span>
 	else
 		mtu = np-&gt;pmtudisc &gt;= IPV6_PMTUDISC_PROBE ?
<span class="p_del">-		      rt-&gt;dst.dev-&gt;mtu : dst_mtu(rt-&gt;dst.path);</span>
<span class="p_add">+		      READ_ONCE(rt-&gt;dst.dev-&gt;mtu) : dst_mtu(rt-&gt;dst.path);</span>
 	if (np-&gt;frag_size &lt; mtu) {
 		if (np-&gt;frag_size)
 			mtu = np-&gt;frag_size;
 	}
<span class="p_add">+	if (mtu &lt; IPV6_MIN_MTU)</span>
<span class="p_add">+		return -EINVAL;</span>
 	cork-&gt;base.fragsize = mtu;
 	if (dst_allfrag(rt-&gt;dst.path))
 		cork-&gt;base.flags |= IPCORK_ALLFRAG;
<span class="p_chunk">@@ -1798,6 +1800,7 @@</span> <span class="p_context"> struct sk_buff *ip6_make_skb(struct sock *sk,</span>
 	cork.base.flags = 0;
 	cork.base.addr = 0;
 	cork.base.opt = NULL;
<span class="p_add">+	cork.base.dst = NULL;</span>
 	v6_cork.opt = NULL;
 	err = ip6_setup_cork(sk, &amp;cork, &amp;v6_cork, ipc6, rt, fl6);
 	if (err) {
<span class="p_header">diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">index 6e3871c7f8f7..bcea985dd76b 100644</span>
<span class="p_header">--- a/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">+++ b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_chunk">@@ -1316,7 +1316,7 @@</span> <span class="p_context"> static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,</span>
 		break;
 
 	case IPV6_AUTOFLOWLABEL:
<span class="p_del">-		val = np-&gt;autoflowlabel;</span>
<span class="p_add">+		val = ip6_autoflowlabel(sock_net(sk), np);</span>
 		break;
 
 	default:
<span class="p_header">diff --git a/net/ipv6/tcpv6_offload.c b/net/ipv6/tcpv6_offload.c</span>
<span class="p_header">index d883c9204c01..278e49cd67d4 100644</span>
<span class="p_header">--- a/net/ipv6/tcpv6_offload.c</span>
<span class="p_header">+++ b/net/ipv6/tcpv6_offload.c</span>
<span class="p_chunk">@@ -46,6 +46,9 @@</span> <span class="p_context"> static struct sk_buff *tcp6_gso_segment(struct sk_buff *skb,</span>
 {
 	struct tcphdr *th;
 
<span class="p_add">+	if (!(skb_shinfo(skb)-&gt;gso_type &amp; SKB_GSO_TCPV6))</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	if (!pskb_may_pull(skb, sizeof(*th)))
 		return ERR_PTR(-EINVAL);
 
<span class="p_header">diff --git a/net/ipv6/udp_offload.c b/net/ipv6/udp_offload.c</span>
<span class="p_header">index e7d378c032cb..2bd2087bd105 100644</span>
<span class="p_header">--- a/net/ipv6/udp_offload.c</span>
<span class="p_header">+++ b/net/ipv6/udp_offload.c</span>
<span class="p_chunk">@@ -55,6 +55,9 @@</span> <span class="p_context"> static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,</span>
 		const struct ipv6hdr *ipv6h;
 		struct udphdr *uh;
 
<span class="p_add">+		if (!(skb_shinfo(skb)-&gt;gso_type &amp; SKB_GSO_UDP))</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 		if (!pskb_may_pull(skb, sizeof(struct udphdr)))
 			goto out;
 
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">index 28d065394c09..3f499126727c 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/types.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/errno.h&gt;
<span class="p_add">+#include &lt;linux/capability.h&gt;</span>
 #include &lt;net/netlink.h&gt;
 #include &lt;net/sock.h&gt;
 
<span class="p_chunk">@@ -392,6 +393,9 @@</span> <span class="p_context"> static int nfnl_cthelper_new(struct net *net, struct sock *nfnl,</span>
 	struct nfnl_cthelper *nlcth;
 	int ret = 0;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (!tb[NFCTH_NAME] || !tb[NFCTH_TUPLE])
 		return -EINVAL;
 
<span class="p_chunk">@@ -595,6 +599,9 @@</span> <span class="p_context"> static int nfnl_cthelper_get(struct net *net, struct sock *nfnl,</span>
 	struct nfnl_cthelper *nlcth;
 	bool tuple_set = false;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP) {
 		struct netlink_dump_control c = {
 			.dump = nfnl_cthelper_dump_table,
<span class="p_chunk">@@ -661,6 +668,9 @@</span> <span class="p_context"> static int nfnl_cthelper_del(struct net *net, struct sock *nfnl,</span>
 	struct nfnl_cthelper *nlcth, *n;
 	int j = 0, ret;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (tb[NFCTH_NAME])
 		helper_name = nla_data(tb[NFCTH_NAME]);
 
<span class="p_header">diff --git a/net/netfilter/xt_osf.c b/net/netfilter/xt_osf.c</span>
<span class="p_header">index 2455b69b5810..b589a62e68a2 100644</span>
<span class="p_header">--- a/net/netfilter/xt_osf.c</span>
<span class="p_header">+++ b/net/netfilter/xt_osf.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
 
<span class="p_add">+#include &lt;linux/capability.h&gt;</span>
 #include &lt;linux/if.h&gt;
 #include &lt;linux/inetdevice.h&gt;
 #include &lt;linux/ip.h&gt;
<span class="p_chunk">@@ -69,6 +70,9 @@</span> <span class="p_context"> static int xt_osf_add_callback(struct net *net, struct sock *ctnl,</span>
 	struct xt_osf_finger *kf = NULL, *sf;
 	int err = 0;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (!osf_attrs[OSF_ATTR_FINGER])
 		return -EINVAL;
 
<span class="p_chunk">@@ -113,6 +117,9 @@</span> <span class="p_context"> static int xt_osf_remove_callback(struct net *net, struct sock *ctnl,</span>
 	struct xt_osf_finger *sf;
 	int err = -ENOENT;
 
<span class="p_add">+	if (!capable(CAP_NET_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (!osf_attrs[OSF_ATTR_FINGER])
 		return -EINVAL;
 
<span class="p_header">diff --git a/net/sctp/offload.c b/net/sctp/offload.c</span>
<span class="p_header">index 4f5a2b580aa5..6300f28c9588 100644</span>
<span class="p_header">--- a/net/sctp/offload.c</span>
<span class="p_header">+++ b/net/sctp/offload.c</span>
<span class="p_chunk">@@ -44,6 +44,9 @@</span> <span class="p_context"> static struct sk_buff *sctp_gso_segment(struct sk_buff *skb,</span>
 	struct sk_buff *segs = ERR_PTR(-EINVAL);
 	struct sctphdr *sh;
 
<span class="p_add">+	if (!(skb_shinfo(skb)-&gt;gso_type &amp; SKB_GSO_SCTP))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	sh = sctp_hdr(skb);
 	if (!pskb_may_pull(skb, sizeof(*sh)))
 		goto out;
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 7181ce6c62bf..c472b8391dde 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -83,7 +83,7 @@</span> <span class="p_context"></span>
 static int sctp_writeable(struct sock *sk);
 static void sctp_wfree(struct sk_buff *skb);
 static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
<span class="p_del">-				size_t msg_len, struct sock **orig_sk);</span>
<span class="p_add">+				size_t msg_len);</span>
 static int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p);
 static int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);
 static int sctp_wait_for_accept(struct sock *sk, long timeo);
<span class="p_chunk">@@ -332,16 +332,14 @@</span> <span class="p_context"> static struct sctp_af *sctp_sockaddr_af(struct sctp_sock *opt,</span>
 	if (len &lt; sizeof (struct sockaddr))
 		return NULL;
 
<span class="p_add">+	if (!opt-&gt;pf-&gt;af_supported(addr-&gt;sa.sa_family, opt))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
 	/* V4 mapped address are really of AF_INET family */
 	if (addr-&gt;sa.sa_family == AF_INET6 &amp;&amp;
<span class="p_del">-	    ipv6_addr_v4mapped(&amp;addr-&gt;v6.sin6_addr)) {</span>
<span class="p_del">-		if (!opt-&gt;pf-&gt;af_supported(AF_INET, opt))</span>
<span class="p_del">-			return NULL;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* Does this PF support this AF? */</span>
<span class="p_del">-		if (!opt-&gt;pf-&gt;af_supported(addr-&gt;sa.sa_family, opt))</span>
<span class="p_del">-			return NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	    ipv6_addr_v4mapped(&amp;addr-&gt;v6.sin6_addr) &amp;&amp;</span>
<span class="p_add">+	    !opt-&gt;pf-&gt;af_supported(AF_INET, opt))</span>
<span class="p_add">+		return NULL;</span>
 
 	/* If we get this far, af is valid. */
 	af = sctp_get_af_specific(addr-&gt;sa.sa_family);
<span class="p_chunk">@@ -1958,7 +1956,7 @@</span> <span class="p_context"> static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)</span>
 	timeo = sock_sndtimeo(sk, msg-&gt;msg_flags &amp; MSG_DONTWAIT);
 	if (!sctp_wspace(asoc)) {
 		/* sk can be changed by peel off when waiting for buf. */
<span class="p_del">-		err = sctp_wait_for_sndbuf(asoc, &amp;timeo, msg_len, &amp;sk);</span>
<span class="p_add">+		err = sctp_wait_for_sndbuf(asoc, &amp;timeo, msg_len);</span>
 		if (err) {
 			if (err == -ESRCH) {
 				/* asoc is already dead. */
<span class="p_chunk">@@ -7441,12 +7439,12 @@</span> <span class="p_context"> void sctp_sock_rfree(struct sk_buff *skb)</span>
 
 /* Helper function to wait for space in the sndbuf.  */
 static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
<span class="p_del">-				size_t msg_len, struct sock **orig_sk)</span>
<span class="p_add">+				size_t msg_len)</span>
 {
 	struct sock *sk = asoc-&gt;base.sk;
<span class="p_del">-	int err = 0;</span>
 	long current_timeo = *timeo_p;
 	DEFINE_WAIT(wait);
<span class="p_add">+	int err = 0;</span>
 
 	pr_debug(&quot;%s: asoc:%p, timeo:%ld, msg_len:%zu\n&quot;, __func__, asoc,
 		 *timeo_p, msg_len);
<span class="p_chunk">@@ -7475,17 +7473,13 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
 		lock_sock(sk);
<span class="p_del">-		if (sk != asoc-&gt;base.sk) {</span>
<span class="p_del">-			release_sock(sk);</span>
<span class="p_del">-			sk = asoc-&gt;base.sk;</span>
<span class="p_del">-			lock_sock(sk);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (sk != asoc-&gt;base.sk)</span>
<span class="p_add">+			goto do_error;</span>
 
 		*timeo_p = current_timeo;
 	}
 
 out:
<span class="p_del">-	*orig_sk = sk;</span>
 	finish_wait(&amp;asoc-&gt;wait, &amp;wait);
 
 	/* Release the association&#39;s refcnt.  */
<span class="p_header">diff --git a/net/socket.c b/net/socket.c</span>
<span class="p_header">index 05f13b24572c..bd3b33988ee0 100644</span>
<span class="p_header">--- a/net/socket.c</span>
<span class="p_header">+++ b/net/socket.c</span>
<span class="p_chunk">@@ -2548,6 +2548,15 @@</span> <span class="p_context"> static int __init sock_init(void)</span>
 
 core_initcall(sock_init);	/* early initcall */
 
<span class="p_add">+static int __init jit_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_BPF_JIT_ALWAYS_ON</span>
<span class="p_add">+	bpf_jit_enable = 1;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+pure_initcall(jit_init);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PROC_FS
 void socket_seq_show(struct seq_file *seq)
 {
<span class="p_header">diff --git a/net/tipc/node.c b/net/tipc/node.c</span>
<span class="p_header">index 27753325e06e..5b3e1ea37b6d 100644</span>
<span class="p_header">--- a/net/tipc/node.c</span>
<span class="p_header">+++ b/net/tipc/node.c</span>
<span class="p_chunk">@@ -1848,36 +1848,38 @@</span> <span class="p_context"> int tipc_nl_node_get_link(struct sk_buff *skb, struct genl_info *info)</span>
 
 	if (strcmp(name, tipc_bclink_name) == 0) {
 		err = tipc_nl_add_bc_link(net, &amp;msg);
<span class="p_del">-		if (err) {</span>
<span class="p_del">-			nlmsg_free(msg.skb);</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto err_free;</span>
 	} else {
 		int bearer_id;
 		struct tipc_node *node;
 		struct tipc_link *link;
 
 		node = tipc_node_find_by_name(net, name, &amp;bearer_id);
<span class="p_del">-		if (!node)</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+		if (!node) {</span>
<span class="p_add">+			err = -EINVAL;</span>
<span class="p_add">+			goto err_free;</span>
<span class="p_add">+		}</span>
 
 		tipc_node_read_lock(node);
 		link = node-&gt;links[bearer_id].link;
 		if (!link) {
 			tipc_node_read_unlock(node);
<span class="p_del">-			nlmsg_free(msg.skb);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			err = -EINVAL;</span>
<span class="p_add">+			goto err_free;</span>
 		}
 
 		err = __tipc_nl_add_link(net, &amp;msg, link, 0);
 		tipc_node_read_unlock(node);
<span class="p_del">-		if (err) {</span>
<span class="p_del">-			nlmsg_free(msg.skb);</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto err_free;</span>
 	}
 
 	return genlmsg_reply(msg.skb, info);
<span class="p_add">+</span>
<span class="p_add">+err_free:</span>
<span class="p_add">+	nlmsg_free(msg.skb);</span>
<span class="p_add">+	return err;</span>
 }
 
 int tipc_nl_node_reset_link_stats(struct sk_buff *skb, struct genl_info *info)
<span class="p_header">diff --git a/tools/usb/usbip/libsrc/usbip_common.c b/tools/usb/usbip/libsrc/usbip_common.c</span>
<span class="p_header">index ac73710473de..1517a232ab18 100644</span>
<span class="p_header">--- a/tools/usb/usbip/libsrc/usbip_common.c</span>
<span class="p_header">+++ b/tools/usb/usbip/libsrc/usbip_common.c</span>
<span class="p_chunk">@@ -215,9 +215,16 @@</span> <span class="p_context"> int read_usb_interface(struct usbip_usb_device *udev, int i,</span>
 		       struct usbip_usb_interface *uinf)
 {
 	char busid[SYSFS_BUS_ID_SIZE];
<span class="p_add">+	int size;</span>
 	struct udev_device *sif;
 
<span class="p_del">-	sprintf(busid, &quot;%s:%d.%d&quot;, udev-&gt;busid, udev-&gt;bConfigurationValue, i);</span>
<span class="p_add">+	size = snprintf(busid, sizeof(busid), &quot;%s:%d.%d&quot;,</span>
<span class="p_add">+			udev-&gt;busid, udev-&gt;bConfigurationValue, i);</span>
<span class="p_add">+	if (size &lt; 0 || (unsigned int)size &gt;= sizeof(busid)) {</span>
<span class="p_add">+		err(&quot;busid length %i &gt;= %lu or &lt; 0&quot;, size,</span>
<span class="p_add">+		    (long unsigned)sizeof(busid));</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
 
 	sif = udev_device_new_from_subsystem_sysname(udev_context, &quot;usb&quot;, busid);
 	if (!sif) {
<span class="p_header">diff --git a/tools/usb/usbip/libsrc/usbip_host_common.c b/tools/usb/usbip/libsrc/usbip_host_common.c</span>
<span class="p_header">index 9d415228883d..6ff7b601f854 100644</span>
<span class="p_header">--- a/tools/usb/usbip/libsrc/usbip_host_common.c</span>
<span class="p_header">+++ b/tools/usb/usbip/libsrc/usbip_host_common.c</span>
<span class="p_chunk">@@ -40,13 +40,20 @@</span> <span class="p_context"> struct udev *udev_context;</span>
 static int32_t read_attr_usbip_status(struct usbip_usb_device *udev)
 {
 	char status_attr_path[SYSFS_PATH_MAX];
<span class="p_add">+	int size;</span>
 	int fd;
 	int length;
 	char status;
 	int value = 0;
 
<span class="p_del">-	snprintf(status_attr_path, SYSFS_PATH_MAX, &quot;%s/usbip_status&quot;,</span>
<span class="p_del">-		 udev-&gt;path);</span>
<span class="p_add">+	size = snprintf(status_attr_path, sizeof(status_attr_path),</span>
<span class="p_add">+			&quot;%s/usbip_status&quot;, udev-&gt;path);</span>
<span class="p_add">+	if (size &lt; 0 || (unsigned int)size &gt;= sizeof(status_attr_path)) {</span>
<span class="p_add">+		err(&quot;usbip_status path length %i &gt;= %lu or &lt; 0&quot;, size,</span>
<span class="p_add">+		    (long unsigned)sizeof(status_attr_path));</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 
 	fd = open(status_attr_path, O_RDONLY);
 	if (fd &lt; 0) {
<span class="p_chunk">@@ -218,6 +225,7 @@</span> <span class="p_context"> int usbip_export_device(struct usbip_exported_device *edev, int sockfd)</span>
 {
 	char attr_name[] = &quot;usbip_sockfd&quot;;
 	char sockfd_attr_path[SYSFS_PATH_MAX];
<span class="p_add">+	int size;</span>
 	char sockfd_buff[30];
 	int ret;
 
<span class="p_chunk">@@ -237,10 +245,20 @@</span> <span class="p_context"> int usbip_export_device(struct usbip_exported_device *edev, int sockfd)</span>
 	}
 
 	/* only the first interface is true */
<span class="p_del">-	snprintf(sockfd_attr_path, sizeof(sockfd_attr_path), &quot;%s/%s&quot;,</span>
<span class="p_del">-		 edev-&gt;udev.path, attr_name);</span>
<span class="p_add">+	size = snprintf(sockfd_attr_path, sizeof(sockfd_attr_path), &quot;%s/%s&quot;,</span>
<span class="p_add">+			edev-&gt;udev.path, attr_name);</span>
<span class="p_add">+	if (size &lt; 0 || (unsigned int)size &gt;= sizeof(sockfd_attr_path)) {</span>
<span class="p_add">+		err(&quot;exported device path length %i &gt;= %lu or &lt; 0&quot;, size,</span>
<span class="p_add">+		    (long unsigned)sizeof(sockfd_attr_path));</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	snprintf(sockfd_buff, sizeof(sockfd_buff), &quot;%d\n&quot;, sockfd);</span>
<span class="p_add">+	size = snprintf(sockfd_buff, sizeof(sockfd_buff), &quot;%d\n&quot;, sockfd);</span>
<span class="p_add">+	if (size &lt; 0 || (unsigned int)size &gt;= sizeof(sockfd_buff)) {</span>
<span class="p_add">+		err(&quot;socket length %i &gt;= %lu or &lt; 0&quot;, size,</span>
<span class="p_add">+		    (long unsigned)sizeof(sockfd_buff));</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
 
 	ret = write_sysfs_attribute(sockfd_attr_path, sockfd_buff,
 				    strlen(sockfd_buff));
<span class="p_header">diff --git a/tools/usb/usbip/libsrc/vhci_driver.c b/tools/usb/usbip/libsrc/vhci_driver.c</span>
<span class="p_header">index ad9204773533..1274f326242c 100644</span>
<span class="p_header">--- a/tools/usb/usbip/libsrc/vhci_driver.c</span>
<span class="p_header">+++ b/tools/usb/usbip/libsrc/vhci_driver.c</span>
<span class="p_chunk">@@ -55,12 +55,12 @@</span> <span class="p_context"> static int parse_status(const char *value)</span>
 
 	while (*c != &#39;\0&#39;) {
 		int port, status, speed, devid;
<span class="p_del">-		unsigned long socket;</span>
<span class="p_add">+		int sockfd;</span>
 		char lbusid[SYSFS_BUS_ID_SIZE];
 
<span class="p_del">-		ret = sscanf(c, &quot;%d %d %d %x %lx %31s\n&quot;,</span>
<span class="p_add">+		ret = sscanf(c, &quot;%d %d %d %x %u %31s\n&quot;,</span>
 				&amp;port, &amp;status, &amp;speed,
<span class="p_del">-				&amp;devid, &amp;socket, lbusid);</span>
<span class="p_add">+				&amp;devid, &amp;sockfd, lbusid);</span>
 
 		if (ret &lt; 5) {
 			dbg(&quot;sscanf failed: %d&quot;, ret);
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> static int parse_status(const char *value)</span>
 
 		dbg(&quot;port %d status %d speed %d devid %x&quot;,
 				port, status, speed, devid);
<span class="p_del">-		dbg(&quot;socket %lx lbusid %s&quot;, socket, lbusid);</span>
<span class="p_add">+		dbg(&quot;sockfd %u lbusid %s&quot;, sockfd, lbusid);</span>
 
 
 		/* if a device is connected, look at it */
<span class="p_header">diff --git a/tools/usb/usbip/src/usbip.c b/tools/usb/usbip/src/usbip.c</span>
<span class="p_header">index d7599d943529..73d8eee8130b 100644</span>
<span class="p_header">--- a/tools/usb/usbip/src/usbip.c</span>
<span class="p_header">+++ b/tools/usb/usbip/src/usbip.c</span>
<span class="p_chunk">@@ -176,6 +176,8 @@</span> <span class="p_context"> int main(int argc, char *argv[])</span>
 			break;
 		case &#39;?&#39;:
 			printf(&quot;usbip: invalid option\n&quot;);
<span class="p_add">+			/* Terminate after printing error */</span>
<span class="p_add">+			/* FALLTHRU */</span>
 		default:
 			usbip_usage();
 			goto out;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



