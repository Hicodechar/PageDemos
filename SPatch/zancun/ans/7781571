
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[1/4] cpumask: Migrate &#39;alloc_cpumask_var()&#39; users to &#39;zalloc_cpumask_var()&#39; - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [1/4] cpumask: Migrate &#39;alloc_cpumask_var()&#39; users to &#39;zalloc_cpumask_var()&#39;</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 7, 2015, 8:49 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1449478184-27168-2-git-send-email-mingo@kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7781571/mbox/"
   >mbox</a>
|
   <a href="/patch/7781571/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7781571/">/patch/7781571/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id EFF09BEEE1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  7 Dec 2015 08:51:07 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 8DBF3203FB
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  7 Dec 2015 08:51:05 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 82C8C20421
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  7 Dec 2015 08:51:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755263AbbLGIu5 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 7 Dec 2015 03:50:57 -0500
Received: from mail-wm0-f41.google.com ([74.125.82.41]:35509 &quot;EHLO
	mail-wm0-f41.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753953AbbLGIuJ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 7 Dec 2015 03:50:09 -0500
Received: by wmuu63 with SMTP id u63so130932832wmu.0
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 07 Dec 2015 00:50:07 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=sender:from:to:cc:subject:date:message-id:in-reply-to:references;
	bh=NEOCUvcWEXvpFBaFIFf82iyEw+YEcHVXNUI2PjBXh/A=;
	b=BlFNZZK/QnJV8QxrLtMAefdVd1Wl9cI23GtbNBC+bYnLpYqFLiUjAWPsLFR79LjTLD
	etEJjS/iPXq3RY9UUMrXRh8pHNYGq7Em4IwA133gBtSkkUFP9oVrHk+7bqDr4BY3B6JM
	Dfux+Tq/qIgfWFjaNUc+3xfBEMkvdn4tlC3MZADvR/UB/UysQ6Li7nYCY3znQXt5sr5W
	Qy+zWjBPEimZO16fDckbBaxF1f4z3pMoAY9Ii+WMGB/obv7MGLEkhvZa8ClJJYnKIKGP
	Ifh3kDRsPcGA+gWjUYcqIDK8jcaWRyt6V88tyP/TgjtsQPvNEPdzdcQ4yUzudVlf+Ks7
	42cg==
X-Received: by 10.194.114.105 with SMTP id
	jf9mr30861904wjb.102.1449478207648; 
	Mon, 07 Dec 2015 00:50:07 -0800 (PST)
Received: from localhost.localdomain (54033495.catv.pool.telekom.hu.
	[84.3.52.149]) by smtp.gmail.com with ESMTPSA id
	az6sm2576718wjc.25.2015.12.07.00.50.06
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-SHA bits=128/128);
	Mon, 07 Dec 2015 00:50:07 -0800 (PST)
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: linux-kernel@vger.kernel.org
Cc: Rusty Russell &lt;rusty@rustcorp.com.au&gt;,
	Peter Zijlstra &lt;peterz@infradead.org&gt;,
	Sergey Senozhatsky &lt;sergey.senozhatsky@gmail.com&gt;,
	Xunlei Pang &lt;xlpang@redhat.com&gt;, Rik van Riel &lt;riel@redhat.com&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Linus Torvalds &lt;torvalds@linux-foundation.org&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;
Subject: [PATCH 1/4] cpumask: Migrate &#39;alloc_cpumask_var()&#39; users to
	&#39;zalloc_cpumask_var()&#39;
Date: Mon,  7 Dec 2015 09:49:41 +0100
Message-Id: &lt;1449478184-27168-2-git-send-email-mingo@kernel.org&gt;
X-Mailer: git-send-email 2.5.0
In-Reply-To: &lt;1449478184-27168-1-git-send-email-mingo@kernel.org&gt;
References: &lt;1449478184-27168-1-git-send-email-mingo@kernel.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.8 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,T_DKIM_INVALID,T_RP_MATCHES_RCVD,UNPARSEABLE_RELAY
	autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Dec. 7, 2015, 8:49 a.m.</div>
<pre class="content">
Xunlei Pang reported a scheduler bug in init_rootdomain(), which is
caused by improper use of alloc_cpumask_var(), which results in
uninitialized cpumasks being allocated.

No-one noticed this scheduler bug for a long time, probably because
alloc_cpumask_var() does result in initialized cpumasks in the
!CPUMASK_OFFSTACK case - which is the vast majority of systems
out there.

So migrate all alloc_cpumask_var() users over to zalloc_cpumask_var(),
to be on the safe side.

Reported-by: Xunlei Pang &lt;xlpang@redhat.com&gt;
<span class="signed-off-by">Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;</span>
---
 arch/ia64/kernel/smp.c                      |  2 +-
 arch/mips/kernel/mips-mt-fpaff.c            |  6 +++---
 arch/powerpc/kernel/irq.c                   |  2 +-
 arch/powerpc/kernel/rtas.c                  |  4 ++--
 arch/powerpc/kernel/smp.c                   |  2 +-
 arch/powerpc/platforms/powernv/subcore.c    |  2 +-
 arch/powerpc/platforms/pseries/suspend.c    |  2 +-
 arch/x86/kernel/apic/vector.c               |  4 ++--
 arch/x86/kernel/cpu/mcheck/mce-inject.c     |  2 +-
 arch/x86/kernel/smp.c                       |  2 +-
 arch/x86/mm/mmio-mod.c                      |  2 +-
 arch/x86/platform/uv/uv_nmi.c               |  2 +-
 arch/x86/xen/mmu.c                          |  2 +-
 arch/x86/xen/smp.c                          |  2 +-
 block/blk-mq-cpumap.c                       |  2 +-
 crypto/pcrypt.c                             |  4 ++--
 drivers/acpi/acpi_pad.c                     |  2 +-
 drivers/acpi/processor_throttling.c         |  2 +-
 drivers/base/cpu.c                          |  2 +-
 drivers/cpufreq/cpufreq.c                   |  2 +-
 drivers/crypto/n2_core.c                    |  2 +-
 drivers/firmware/dcdbas.c                   |  2 +-
 drivers/hwmon/dell-smm-hwmon.c              |  2 +-
 drivers/net/ethernet/intel/i40e/i40e_main.c |  2 +-
 drivers/pci/host/pci-xgene-msi.c            |  2 +-
 drivers/scsi/mpt3sas/mpt3sas_base.c         |  2 +-
 drivers/virtio/virtio_pci_common.c          |  2 +-
 include/linux/cpumask.h                     |  6 +++---
 kernel/compat.c                             |  4 ++--
 kernel/cpu.c                                |  2 +-
 kernel/cpuset.c                             | 16 ++++++++--------
 kernel/irq/irqdesc.c                        |  2 +-
 kernel/irq/manage.c                         |  6 +++---
 kernel/irq/proc.c                           |  4 ++--
 kernel/padata.c                             | 10 +++++-----
 kernel/profile.c                            |  4 ++--
 kernel/sched/core.c                         | 14 +++++++-------
 kernel/smpboot.c                            |  4 ++--
 kernel/taskstats.c                          |  4 ++--
 kernel/time/tick-sched.c                    |  4 ++--
 kernel/torture.c                            |  2 +-
 kernel/trace/ring_buffer.c                  |  2 +-
 kernel/trace/trace.c                        | 10 +++++-----
 kernel/workqueue.c                          |  4 ++--
 lib/cpumask.c                               |  2 +-
 mm/vmstat.c                                 |  2 +-
 net/core/flow.c                             |  2 +-
 net/core/net-sysfs.c                        |  4 ++--
 net/core/sysctl_net_core.c                  |  2 +-
 49 files changed, 87 insertions(+), 87 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77">Linus Torvalds</a> - Dec. 8, 2015, 1:28 a.m.</div>
<pre class="content">
On Mon, Dec 7, 2015 at 12:49 AM, Ingo Molnar &lt;mingo@kernel.org&gt; wrote:
<span class="quote">&gt; Xunlei Pang reported a scheduler bug in init_rootdomain(), which is</span>
<span class="quote">&gt; caused by improper use of alloc_cpumask_var(), which results in</span>
<span class="quote">&gt; uninitialized cpumasks being allocated.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; No-one noticed this scheduler bug for a long time, probably because</span>
<span class="quote">&gt; alloc_cpumask_var() does result in initialized cpumasks in the</span>
<span class="quote">&gt; !CPUMASK_OFFSTACK case - which is the vast majority of systems</span>
<span class="quote">&gt; out there.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; So migrate all alloc_cpumask_var() users over to zalloc_cpumask_var(),</span>
<span class="quote">&gt; to be on the safe side.</span>

Ugh. I&#39;d rather just see us say that &quot;allocating a cpumask always
returns a zeroed mask&quot;.

There really is no reason to ever not zero it (they aren&#39;t _that_ big
even on huge machines), so I&#39;d rather just get rid of the &quot;zalloc&quot;
version that is the less common one anyway.

                 Linus
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Dec. 8, 2015, 4:09 a.m.</div>
<pre class="content">
* Linus Torvalds &lt;torvalds@linux-foundation.org&gt; wrote:
<span class="quote">
&gt; On Mon, Dec 7, 2015 at 12:49 AM, Ingo Molnar &lt;mingo@kernel.org&gt; wrote:</span>
<span class="quote">&gt; &gt; Xunlei Pang reported a scheduler bug in init_rootdomain(), which is</span>
<span class="quote">&gt; &gt; caused by improper use of alloc_cpumask_var(), which results in</span>
<span class="quote">&gt; &gt; uninitialized cpumasks being allocated.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; No-one noticed this scheduler bug for a long time, probably because</span>
<span class="quote">&gt; &gt; alloc_cpumask_var() does result in initialized cpumasks in the</span>
<span class="quote">&gt; &gt; !CPUMASK_OFFSTACK case - which is the vast majority of systems</span>
<span class="quote">&gt; &gt; out there.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; So migrate all alloc_cpumask_var() users over to zalloc_cpumask_var(), to be </span>
<span class="quote">&gt; &gt; on the safe side.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ugh. I&#39;d rather just see us say that &quot;allocating a cpumask always returns a </span>
<span class="quote">&gt; zeroed mask&quot;.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There really is no reason to ever not zero it (they aren&#39;t _that_ big even on </span>
<span class="quote">&gt; huge machines), so I&#39;d rather just get rid of the &quot;zalloc&quot; version that is the </span>
<span class="quote">&gt; less common one anyway.</span>

Sure - that was my original suggestion, will reshape the series to do it like 
that.

Thanks,

	Ingo
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Dec. 8, 2015, 4:13 a.m.</div>
<pre class="content">
* Ingo Molnar &lt;mingo@kernel.org&gt; wrote:
<span class="quote">
&gt; * Linus Torvalds &lt;torvalds@linux-foundation.org&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; On Mon, Dec 7, 2015 at 12:49 AM, Ingo Molnar &lt;mingo@kernel.org&gt; wrote:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; Xunlei Pang reported a scheduler bug in init_rootdomain(), which is caused </span>
<span class="quote">&gt; &gt; &gt; by improper use of alloc_cpumask_var(), which results in uninitialized </span>
<span class="quote">&gt; &gt; &gt; cpumasks being allocated.</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; No-one noticed this scheduler bug for a long time, probably because </span>
<span class="quote">&gt; &gt; &gt; alloc_cpumask_var() does result in initialized cpumasks in the </span>
<span class="quote">&gt; &gt; &gt; !CPUMASK_OFFSTACK case - which is the vast majority of systems out there.</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; So migrate all alloc_cpumask_var() users over to zalloc_cpumask_var(), to be </span>
<span class="quote">&gt; &gt; &gt; on the safe side.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Ugh. I&#39;d rather just see us say that &quot;allocating a cpumask always returns a </span>
<span class="quote">&gt; &gt; zeroed mask&quot;.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; There really is no reason to ever not zero it (they aren&#39;t _that_ big even on </span>
<span class="quote">&gt; &gt; huge machines), so I&#39;d rather just get rid of the &quot;zalloc&quot; version that is the </span>
<span class="quote">&gt; &gt; less common one anyway.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Sure - that was my original suggestion, will reshape the series to do it like </span>
<span class="quote">&gt; that.</span>

One question: I&#39;ll remove all the non-zeroing variants, but would you be fine with 
keeping the &#39;zalloc&#39; naming? That&#39;s consistent with other allocation API patterns 
across the kernel. There won&#39;t be any unsafe API left.

Thanks,

	Ingo
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=5">Rusty Russell</a> - Dec. 16, 2015, 12:26 a.m.</div>
<pre class="content">
Linus Torvalds &lt;torvalds@linux-foundation.org&gt; writes:
<span class="quote">&gt; On Dec 7, 2015 8:13 PM, &quot;Ingo Molnar&quot; &lt;mingo@kernel.org&gt; wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; One question: I&#39;ll remove all the non-zeroing variants, but would you be</span>
<span class="quote">&gt; fine with</span>
<span class="quote">&gt;&gt; keeping the &#39;zalloc&#39; naming? That&#39;s consistent with other allocation API</span>
<span class="quote">&gt; patterns</span>
<span class="quote">&gt;&gt; across the kernel. There won&#39;t be any unsafe API left.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Sure, I guess that won&#39;t hurt, and we could quietly start deprecating the</span>
<span class="quote">&gt; zalloc pattern just to avoid the redundancy in the long run..</span>

I like the zalloc naming, it&#39;s clear.  But the series looks fine:
<span class="acked-by">
        Acked-by: Rusty Russell &lt;rusty@rustcorp.com.au&gt;</span>

Thanks,
Rusty.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/ia64/kernel/smp.c b/arch/ia64/kernel/smp.c</span>
<span class="p_header">index 7f706d4f84f7..d52b4d8de013 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/smp.c</span>
<span class="p_chunk">@@ -301,7 +301,7 @@</span> <span class="p_context"> smp_flush_tlb_mm (struct mm_struct *mm)</span>
 		preempt_enable();
 		return;
 	}
<span class="p_del">-	if (!alloc_cpumask_var(&amp;cpus, GFP_ATOMIC)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;cpus, GFP_ATOMIC)) {</span>
 		smp_call_function((void (*)(void *))local_finish_flush_tlb_mm,
 			mm, 1);
 	} else {
<span class="p_header">diff --git a/arch/mips/kernel/mips-mt-fpaff.c b/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_header">index 789d7bf4fef3..9b8241da4c4c 100644</span>
<span class="p_header">--- a/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_header">+++ b/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_chunk">@@ -87,15 +87,15 @@</span> <span class="p_context"> asmlinkage long mipsmt_sys_sched_setaffinity(pid_t pid, unsigned int len,</span>
 	get_task_struct(p);
 	rcu_read_unlock();
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;cpus_allowed, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;cpus_allowed, GFP_KERNEL)) {</span>
 		retval = -ENOMEM;
 		goto out_put_task;
 	}
<span class="p_del">-	if (!alloc_cpumask_var(&amp;new_mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;new_mask, GFP_KERNEL)) {</span>
 		retval = -ENOMEM;
 		goto out_free_cpus_allowed;
 	}
<span class="p_del">-	if (!alloc_cpumask_var(&amp;effective_mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;effective_mask, GFP_KERNEL)) {</span>
 		retval = -ENOMEM;
 		goto out_free_new_mask;
 	}
<span class="p_header">diff --git a/arch/powerpc/kernel/irq.c b/arch/powerpc/kernel/irq.c</span>
<span class="p_header">index 290559df1e8b..48558d1ae075 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/irq.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/irq.c</span>
<span class="p_chunk">@@ -429,7 +429,7 @@</span> <span class="p_context"> void migrate_irqs(void)</span>
 	cpumask_var_t mask;
 	const struct cpumask *map = cpu_online_mask;
 
<span class="p_del">-	alloc_cpumask_var(&amp;mask, GFP_KERNEL);</span>
<span class="p_add">+	zalloc_cpumask_var(&amp;mask, GFP_KERNEL);</span>
 
 	for_each_irq_desc(irq, desc) {
 		struct irq_data *data;
<span class="p_header">diff --git a/arch/powerpc/kernel/rtas.c b/arch/powerpc/kernel/rtas.c</span>
<span class="p_header">index 5a753fae8265..0631d6a1ea6f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/rtas.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/rtas.c</span>
<span class="p_chunk">@@ -897,7 +897,7 @@</span> <span class="p_context"> int rtas_online_cpus_mask(cpumask_var_t cpus)</span>
 	if (ret) {
 		cpumask_var_t tmp_mask;
 
<span class="p_del">-		if (!alloc_cpumask_var(&amp;tmp_mask, GFP_TEMPORARY))</span>
<span class="p_add">+		if (!zalloc_cpumask_var(&amp;tmp_mask, GFP_TEMPORARY))</span>
 			return ret;
 
 		/* Use tmp_mask to preserve cpus mask from first failure */
<span class="p_chunk">@@ -945,7 +945,7 @@</span> <span class="p_context"> int rtas_ibm_suspend_me(u64 handle)</span>
 		return -EIO;
 	}
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;offline_mask, GFP_TEMPORARY))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;offline_mask, GFP_TEMPORARY))</span>
 		return -ENOMEM;
 
 	atomic_set(&amp;data.working, 0);
<span class="p_header">diff --git a/arch/powerpc/kernel/smp.c b/arch/powerpc/kernel/smp.c</span>
<span class="p_header">index ec9ec2058d2d..62896a4eb825 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/smp.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/smp.c</span>
<span class="p_chunk">@@ -767,7 +767,7 @@</span> <span class="p_context"> void __init smp_cpus_done(unsigned int max_cpus)</span>
 	 * init thread may have been &quot;borrowed&quot; by another CPU in the meantime
 	 * se we pin us down to CPU 0 for a short while
 	 */
<span class="p_del">-	alloc_cpumask_var(&amp;old_mask, GFP_NOWAIT);</span>
<span class="p_add">+	zalloc_cpumask_var(&amp;old_mask, GFP_NOWAIT);</span>
 	cpumask_copy(old_mask, tsk_cpus_allowed(current));
 	set_cpus_allowed_ptr(current, cpumask_of(boot_cpuid));
 	
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/subcore.c b/arch/powerpc/platforms/powernv/subcore.c</span>
<span class="p_header">index 503a73f59359..49ab03d342f5 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/subcore.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/subcore.c</span>
<span class="p_chunk">@@ -417,7 +417,7 @@</span> <span class="p_context"> static int subcore_init(void)</span>
 	if (setup_max_cpus % threads_per_core)
 		return 0;
 
<span class="p_del">-	BUG_ON(!alloc_cpumask_var(&amp;cpu_offline_mask, GFP_KERNEL));</span>
<span class="p_add">+	BUG_ON(!zalloc_cpumask_var(&amp;cpu_offline_mask, GFP_KERNEL));</span>
 
 	set_subcores_per_core(1);
 
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/suspend.c b/arch/powerpc/platforms/pseries/suspend.c</span>
<span class="p_header">index e76aefae2aa2..1ae11002472f 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/suspend.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/suspend.c</span>
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> static ssize_t store_hibernate(struct device *dev,</span>
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;offline_mask, GFP_TEMPORARY))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;offline_mask, GFP_TEMPORARY))</span>
 		return -ENOMEM;
 
 	stream_id = simple_strtoul(buf, NULL, 16);
<span class="p_header">diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">index 861bc59c8f25..c7b5904276d5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/vector.c</span>
<span class="p_chunk">@@ -403,7 +403,7 @@</span> <span class="p_context"> int __init arch_early_irq_init(void)</span>
 	arch_init_msi_domain(x86_vector_domain);
 	arch_init_htirq_domain(x86_vector_domain);
 
<span class="p_del">-	BUG_ON(!alloc_cpumask_var(&amp;vector_cpumask, GFP_KERNEL));</span>
<span class="p_add">+	BUG_ON(!zalloc_cpumask_var(&amp;vector_cpumask, GFP_KERNEL));</span>
 
 	return arch_early_ioapic_init();
 }
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static void __send_cleanup_vector(struct apic_chip_data *data)</span>
 {
 	cpumask_var_t cleanup_mask;
 
<span class="p_del">-	if (unlikely(!alloc_cpumask_var(&amp;cleanup_mask, GFP_ATOMIC))) {</span>
<span class="p_add">+	if (unlikely(!zalloc_cpumask_var(&amp;cleanup_mask, GFP_ATOMIC))) {</span>
 		unsigned int i;
 
 		for_each_cpu_and(i, data-&gt;old_domain, cpu_online_mask)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce-inject.c b/arch/x86/kernel/cpu/mcheck/mce-inject.c</span>
<span class="p_header">index 4cfba4371a71..f81bcbc7044e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce-inject.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce-inject.c</span>
<span class="p_chunk">@@ -239,7 +239,7 @@</span> <span class="p_context"> static ssize_t mce_write(struct file *filp, const char __user *ubuf,</span>
 
 static int inject_init(void)
 {
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mce_inject_cpumask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mce_inject_cpumask, GFP_KERNEL))</span>
 		return -ENOMEM;
 	printk(KERN_INFO &quot;Machine check injector initialized\n&quot;);
 	register_mce_write_callback(mce_write);
<span class="p_header">diff --git a/arch/x86/kernel/smp.c b/arch/x86/kernel/smp.c</span>
<span class="p_header">index 658777cf3851..3f012b907209 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smp.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smp.c</span>
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> void native_send_call_func_ipi(const struct cpumask *mask)</span>
 {
 	cpumask_var_t allbutself;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;allbutself, GFP_ATOMIC)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;allbutself, GFP_ATOMIC)) {</span>
 		apic-&gt;send_IPI_mask(mask, CALL_FUNCTION_VECTOR);
 		return;
 	}
<span class="p_header">diff --git a/arch/x86/mm/mmio-mod.c b/arch/x86/mm/mmio-mod.c</span>
<span class="p_header">index 0057a7accfb1..9af43c2113bc 100644</span>
<span class="p_header">--- a/arch/x86/mm/mmio-mod.c</span>
<span class="p_header">+++ b/arch/x86/mm/mmio-mod.c</span>
<span class="p_chunk">@@ -386,7 +386,7 @@</span> <span class="p_context"> static void enter_uniprocessor(void)</span>
 	int err;
 
 	if (downed_cpus == NULL &amp;&amp;
<span class="p_del">-	    !alloc_cpumask_var(&amp;downed_cpus, GFP_KERNEL)) {</span>
<span class="p_add">+	    !zalloc_cpumask_var(&amp;downed_cpus, GFP_KERNEL)) {</span>
 		pr_notice(&quot;Failed to allocate mask\n&quot;);
 		goto out;
 	}
<span class="p_header">diff --git a/arch/x86/platform/uv/uv_nmi.c b/arch/x86/platform/uv/uv_nmi.c</span>
<span class="p_header">index 327f21c3bde1..327120da28e8 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/uv_nmi.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/uv_nmi.c</span>
<span class="p_chunk">@@ -718,6 +718,6 @@</span> <span class="p_context"> void uv_nmi_setup(void)</span>
 		}
 		uv_hub_nmi_per(cpu) = uv_hub_nmi_list[nid];
 	}
<span class="p_del">-	BUG_ON(!alloc_cpumask_var(&amp;uv_nmi_cpu_mask, GFP_KERNEL));</span>
<span class="p_add">+	BUG_ON(!zalloc_cpumask_var(&amp;uv_nmi_cpu_mask, GFP_KERNEL));</span>
 	uv_register_nmi_notifier();
 }
<span class="p_header">diff --git a/arch/x86/xen/mmu.c b/arch/x86/xen/mmu.c</span>
<span class="p_header">index 5e509d086d57..07e5e5133e5c 100644</span>
<span class="p_header">--- a/arch/x86/xen/mmu.c</span>
<span class="p_header">+++ b/arch/x86/xen/mmu.c</span>
<span class="p_chunk">@@ -1063,7 +1063,7 @@</span> <span class="p_context"> static void xen_drop_mm_ref(struct mm_struct *mm)</span>
 	}
 
 	/* Get the &quot;official&quot; set of cpus referring to our pagetable. */
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_ATOMIC)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_ATOMIC)) {</span>
 		for_each_online_cpu(cpu) {
 			if (!cpumask_test_cpu(cpu, mm_cpumask(mm))
 			    &amp;&amp; per_cpu(xen_current_cr3, cpu) != __pa(mm-&gt;pgd))
<span class="p_header">diff --git a/arch/x86/xen/smp.c b/arch/x86/xen/smp.c</span>
<span class="p_header">index 3f4ebf0261f2..e5196a77e1c2 100644</span>
<span class="p_header">--- a/arch/x86/xen/smp.c</span>
<span class="p_header">+++ b/arch/x86/xen/smp.c</span>
<span class="p_chunk">@@ -362,7 +362,7 @@</span> <span class="p_context"> static void __init xen_smp_prepare_cpus(unsigned int max_cpus)</span>
 	if (xen_smp_intr_init(0))
 		BUG();
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;xen_cpu_initialized_map, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;xen_cpu_initialized_map, GFP_KERNEL))</span>
 		panic(&quot;could not allocate xen_cpu_initialized_map\n&quot;);
 
 	cpumask_copy(xen_cpu_initialized_map, cpumask_of(0));
<span class="p_header">diff --git a/block/blk-mq-cpumap.c b/block/blk-mq-cpumap.c</span>
<span class="p_header">index 8764c241e5bb..bd84397e025c 100644</span>
<span class="p_header">--- a/block/blk-mq-cpumap.c</span>
<span class="p_header">+++ b/block/blk-mq-cpumap.c</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"> int blk_mq_update_queue_map(unsigned int *map, unsigned int nr_queues,</span>
 	unsigned int i, nr_cpus, nr_uniq_cpus, queue, first_sibling;
 	cpumask_var_t cpus;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;cpus, GFP_ATOMIC))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;cpus, GFP_ATOMIC))</span>
 		return 1;
 
 	cpumask_clear(cpus);
<span class="p_header">diff --git a/crypto/pcrypt.c b/crypto/pcrypt.c</span>
<span class="p_header">index ee9cfb99fe25..e2c433a740ce 100644</span>
<span class="p_header">--- a/crypto/pcrypt.c</span>
<span class="p_header">+++ b/crypto/pcrypt.c</span>
<span class="p_chunk">@@ -371,7 +371,7 @@</span> <span class="p_context"> static int pcrypt_cpumask_change_notify(struct notifier_block *self,</span>
 	new_mask = kmalloc(sizeof(*new_mask), GFP_KERNEL);
 	if (!new_mask)
 		return -ENOMEM;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;new_mask-&gt;mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;new_mask-&gt;mask, GFP_KERNEL)) {</span>
 		kfree(new_mask);
 		return -ENOMEM;
 	}
<span class="p_chunk">@@ -419,7 +419,7 @@</span> <span class="p_context"> static int pcrypt_init_padata(struct padata_pcrypt *pcrypt,</span>
 	mask = kmalloc(sizeof(*mask), GFP_KERNEL);
 	if (!mask)
 		goto err_free_padata;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask-&gt;mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask-&gt;mask, GFP_KERNEL)) {</span>
 		kfree(mask);
 		goto err_free_padata;
 	}
<span class="p_header">diff --git a/drivers/acpi/acpi_pad.c b/drivers/acpi/acpi_pad.c</span>
<span class="p_header">index 8ea8211b2d58..45f93d95d3c5 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_pad.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_pad.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> static void round_robin_cpu(unsigned int tsk_index)</span>
 	unsigned long min_weight = -1;
 	unsigned long uninitialized_var(preferred_cpu);
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;tmp, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;tmp, GFP_KERNEL))</span>
 		return;
 
 	mutex_lock(&amp;round_robin_lock);
<span class="p_header">diff --git a/drivers/acpi/processor_throttling.c b/drivers/acpi/processor_throttling.c</span>
<span class="p_header">index f170d746336d..a5d8e0a8bcf2 100644</span>
<span class="p_header">--- a/drivers/acpi/processor_throttling.c</span>
<span class="p_header">+++ b/drivers/acpi/processor_throttling.c</span>
<span class="p_chunk">@@ -903,7 +903,7 @@</span> <span class="p_context"> static int acpi_processor_get_throttling(struct acpi_processor *pr)</span>
 	if (!pr-&gt;flags.throttling)
 		return -ENODEV;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;saved_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;saved_mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	/*
<span class="p_header">diff --git a/drivers/base/cpu.c b/drivers/base/cpu.c</span>
<span class="p_header">index 91bbb1959d8d..6e7141400ddc 100644</span>
<span class="p_header">--- a/drivers/base/cpu.c</span>
<span class="p_header">+++ b/drivers/base/cpu.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static ssize_t print_cpus_offline(struct device *dev,</span>
 	cpumask_var_t offline;
 
 	/* display offline cpus &lt; nr_cpu_ids */
<span class="p_del">-	if (!alloc_cpumask_var(&amp;offline, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;offline, GFP_KERNEL))</span>
 		return -ENOMEM;
 	cpumask_andnot(offline, cpu_possible_mask, cpu_online_mask);
 	n = scnprintf(buf, len, &quot;%*pbl&quot;, cpumask_pr_args(offline));
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c</span>
<span class="p_header">index 8412ce5f93a7..2524b702897f 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq.c</span>
<span class="p_chunk">@@ -1034,7 +1034,7 @@</span> <span class="p_context"> static struct cpufreq_policy *cpufreq_policy_alloc(unsigned int cpu)</span>
 	if (!policy)
 		return NULL;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;policy-&gt;cpus, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;policy-&gt;cpus, GFP_KERNEL))</span>
 		goto err_free_policy;
 
 	if (!zalloc_cpumask_var(&amp;policy-&gt;related_cpus, GFP_KERNEL))
<span class="p_header">diff --git a/drivers/crypto/n2_core.c b/drivers/crypto/n2_core.c</span>
<span class="p_header">index 5450880abb7b..0c8a5160a334 100644</span>
<span class="p_header">--- a/drivers/crypto/n2_core.c</span>
<span class="p_header">+++ b/drivers/crypto/n2_core.c</span>
<span class="p_chunk">@@ -1660,7 +1660,7 @@</span> <span class="p_context"> static int spu_queue_register(struct spu_queue *p, unsigned long q_type)</span>
 	if (cpumask_empty(&amp;p-&gt;sharing))
 		return -EINVAL;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;old_allowed, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;old_allowed, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	cpumask_copy(old_allowed, &amp;current-&gt;cpus_allowed);
<span class="p_header">diff --git a/drivers/firmware/dcdbas.c b/drivers/firmware/dcdbas.c</span>
<span class="p_header">index 829eec8959f2..968d09476cb8 100644</span>
<span class="p_header">--- a/drivers/firmware/dcdbas.c</span>
<span class="p_header">+++ b/drivers/firmware/dcdbas.c</span>
<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> int dcdbas_smi_request(struct smi_cmd *smi_cmd)</span>
 	}
 
 	/* SMI requires CPU 0 */
<span class="p_del">-	if (!alloc_cpumask_var(&amp;old_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;old_mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	cpumask_copy(old_mask, &amp;current-&gt;cpus_allowed);
<span class="p_header">diff --git a/drivers/hwmon/dell-smm-hwmon.c b/drivers/hwmon/dell-smm-hwmon.c</span>
<span class="p_header">index c8487894b312..90903cea6d9c 100644</span>
<span class="p_header">--- a/drivers/hwmon/dell-smm-hwmon.c</span>
<span class="p_header">+++ b/drivers/hwmon/dell-smm-hwmon.c</span>
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> static int i8k_smm(struct smm_regs *regs)</span>
 	cpumask_var_t old_mask;
 
 	/* SMM requires CPU 0 */
<span class="p_del">-	if (!alloc_cpumask_var(&amp;old_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;old_mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 	cpumask_copy(old_mask, &amp;current-&gt;cpus_allowed);
 	rc = set_cpus_allowed_ptr(current, cpumask_of(0));
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">index b825f978d441..4e4126c95b27 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_chunk">@@ -2705,7 +2705,7 @@</span> <span class="p_context"> static void i40e_config_xps_tx_ring(struct i40e_ring *ring)</span>
 			netif_set_xps_queue(ring-&gt;netdev,
 					    &amp;ring-&gt;q_vector-&gt;affinity_mask,
 					    ring-&gt;queue_index);
<span class="p_del">-	} else if (alloc_cpumask_var(&amp;mask, GFP_KERNEL)) {</span>
<span class="p_add">+	} else if (zalloc_cpumask_var(&amp;mask, GFP_KERNEL)) {</span>
 		/* Disable XPS to allow selection based on TC */
 		bitmap_zero(cpumask_bits(mask), nr_cpumask_bits);
 		netif_set_xps_queue(ring-&gt;netdev, mask, ring-&gt;queue_index);
<span class="p_header">diff --git a/drivers/pci/host/pci-xgene-msi.c b/drivers/pci/host/pci-xgene-msi.c</span>
<span class="p_header">index a6456b578269..0f21851cc681 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-xgene-msi.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-xgene-msi.c</span>
<span class="p_chunk">@@ -405,7 +405,7 @@</span> <span class="p_context"> static int xgene_msi_hwirq_alloc(unsigned int cpu)</span>
 		 * With 8-core X-Gene v1, 2 MSI GIC IRQs are allocated
 		 * to each core.
 		 */
<span class="p_del">-		if (alloc_cpumask_var(&amp;mask, GFP_KERNEL)) {</span>
<span class="p_add">+		if (zalloc_cpumask_var(&amp;mask, GFP_KERNEL)) {</span>
 			cpumask_clear(mask);
 			cpumask_set_cpu(cpu, mask);
 			err = irq_set_affinity(msi_group-&gt;gic_irq, mask);
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">index 11393ebf1a68..fd2cd64f9430 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_chunk">@@ -1829,7 +1829,7 @@</span> <span class="p_context"> _base_request_irq(struct MPT3SAS_ADAPTER *ioc, u8 index, u32 vector)</span>
 	reply_q-&gt;msix_index = index;
 	reply_q-&gt;vector = vector;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;reply_q-&gt;affinity_hint, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;reply_q-&gt;affinity_hint, GFP_KERNEL))</span>
 		return -ENOMEM;
 	cpumask_clear(reply_q-&gt;affinity_hint);
 
<span class="p_header">diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c</span>
<span class="p_header">index 78f804af6c20..d123ed3c1660 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_pci_common.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_pci_common.c</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,</span>
 	if (!vp_dev-&gt;msix_affinity_masks)
 		goto error;
 	for (i = 0; i &lt; nvectors; ++i)
<span class="p_del">-		if (!alloc_cpumask_var(&amp;vp_dev-&gt;msix_affinity_masks[i],</span>
<span class="p_add">+		if (!zalloc_cpumask_var(&amp;vp_dev-&gt;msix_affinity_masks[i],</span>
 					GFP_KERNEL))
 			goto error;
 
<span class="p_header">diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h</span>
<span class="p_header">index 59915ea5373c..608beca04fc6 100644</span>
<span class="p_header">--- a/include/linux/cpumask.h</span>
<span class="p_header">+++ b/include/linux/cpumask.h</span>
<span class="p_chunk">@@ -620,7 +620,7 @@</span> <span class="p_context"> static inline size_t cpumask_size(void)</span>
  *
  * ie.
  *	cpumask_var_t tmpmask;
<span class="p_del">- *	if (!alloc_cpumask_var(&amp;tmpmask, GFP_KERNEL))</span>
<span class="p_add">+ *	if (!zalloc_cpumask_var(&amp;tmpmask, GFP_KERNEL))</span>
  *		return -ENOMEM;
  *
  *	  ... use &#39;tmpmask&#39; like a normal struct cpumask * ...
<span class="p_chunk">@@ -628,12 +628,12 @@</span> <span class="p_context"> static inline size_t cpumask_size(void)</span>
  *	free_cpumask_var(tmpmask);
  *
  *
<span class="p_del">- * However, one notable exception is there. alloc_cpumask_var() allocates</span>
<span class="p_add">+ * However, one notable exception is there. zalloc_cpumask_var() allocates</span>
  * only nr_cpumask_bits bits (in the other hand, real cpumask_t always has
  * NR_CPUS bits). Therefore you don&#39;t have to dereference cpumask_var_t.
  *
  *	cpumask_var_t tmpmask;
<span class="p_del">- *	if (!alloc_cpumask_var(&amp;tmpmask, GFP_KERNEL))</span>
<span class="p_add">+ *	if (!zalloc_cpumask_var(&amp;tmpmask, GFP_KERNEL))</span>
  *		return -ENOMEM;
  *
  *	var = *tmpmask;
<span class="p_header">diff --git a/kernel/compat.c b/kernel/compat.c</span>
<span class="p_header">index 333d364be29d..5b1d2236bbec 100644</span>
<span class="p_header">--- a/kernel/compat.c</span>
<span class="p_header">+++ b/kernel/compat.c</span>
<span class="p_chunk">@@ -620,7 +620,7 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE3(sched_setaffinity, compat_pid_t, pid,</span>
 	cpumask_var_t new_mask;
 	int retval;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;new_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;new_mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	retval = compat_get_user_cpu_mask(user_mask_ptr, len, new_mask);
<span class="p_chunk">@@ -644,7 +644,7 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE3(sched_getaffinity, compat_pid_t,  pid, unsigned int, len,</span>
 	if (len &amp; (sizeof(compat_ulong_t)-1))
 		return -EINVAL;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	ret = sched_getaffinity(pid, mask);
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index 85ff5e26e23b..ecde871f7c12 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -654,7 +654,7 @@</span> <span class="p_context"> void enable_nonboot_cpus(void)</span>
 
 static int __init alloc_frozen_cpus(void)
 {
<span class="p_del">-	if (!alloc_cpumask_var(&amp;frozen_cpus, GFP_KERNEL|__GFP_ZERO))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;frozen_cpus, GFP_KERNEL|__GFP_ZERO))</span>
 		return -ENOMEM;
 	return 0;
 }
<span class="p_header">diff --git a/kernel/cpuset.c b/kernel/cpuset.c</span>
<span class="p_header">index 10ae73611d80..7a53d7c40e95 100644</span>
<span class="p_header">--- a/kernel/cpuset.c</span>
<span class="p_header">+++ b/kernel/cpuset.c</span>
<span class="p_chunk">@@ -403,9 +403,9 @@</span> <span class="p_context"> static struct cpuset *alloc_trial_cpuset(struct cpuset *cs)</span>
 	if (!trial)
 		return NULL;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;trial-&gt;cpus_allowed, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;trial-&gt;cpus_allowed, GFP_KERNEL))</span>
 		goto free_cs;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;trial-&gt;effective_cpus, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;trial-&gt;effective_cpus, GFP_KERNEL))</span>
 		goto free_cpus;
 
 	cpumask_copy(trial-&gt;cpus_allowed, cs-&gt;cpus_allowed);
<span class="p_chunk">@@ -633,7 +633,7 @@</span> <span class="p_context"> static int generate_sched_domains(cpumask_var_t **domains,</span>
 	dattr = NULL;
 	csa = NULL;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;non_isolated_cpus, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;non_isolated_cpus, GFP_KERNEL))</span>
 		goto done;
 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map);
 
<span class="p_chunk">@@ -1909,9 +1909,9 @@</span> <span class="p_context"> cpuset_css_alloc(struct cgroup_subsys_state *parent_css)</span>
 	cs = kzalloc(sizeof(*cs), GFP_KERNEL);
 	if (!cs)
 		return ERR_PTR(-ENOMEM);
<span class="p_del">-	if (!alloc_cpumask_var(&amp;cs-&gt;cpus_allowed, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;cs-&gt;cpus_allowed, GFP_KERNEL))</span>
 		goto free_cs;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;cs-&gt;effective_cpus, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;cs-&gt;effective_cpus, GFP_KERNEL))</span>
 		goto free_cpus;
 
 	set_bit(CS_SCHED_LOAD_BALANCE, &amp;cs-&gt;flags);
<span class="p_chunk">@@ -2065,9 +2065,9 @@</span> <span class="p_context"> int __init cpuset_init(void)</span>
 {
 	int err = 0;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;top_cpuset.cpus_allowed, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;top_cpuset.cpus_allowed, GFP_KERNEL))</span>
 		BUG();
<span class="p_del">-	if (!alloc_cpumask_var(&amp;top_cpuset.effective_cpus, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;top_cpuset.effective_cpus, GFP_KERNEL))</span>
 		BUG();
 
 	cpumask_setall(top_cpuset.cpus_allowed);
<span class="p_chunk">@@ -2083,7 +2083,7 @@</span> <span class="p_context"> int __init cpuset_init(void)</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;cpus_attach, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;cpus_attach, GFP_KERNEL))</span>
 		BUG();
 
 	return 0;
<span class="p_header">diff --git a/kernel/irq/irqdesc.c b/kernel/irq/irqdesc.c</span>
<span class="p_header">index 239e2ae2c947..a09b4d5bf747 100644</span>
<span class="p_header">--- a/kernel/irq/irqdesc.c</span>
<span class="p_header">+++ b/kernel/irq/irqdesc.c</span>
<span class="p_chunk">@@ -26,7 +26,7 @@</span> <span class="p_context"> static struct lock_class_key irq_desc_lock_class;</span>
 #if defined(CONFIG_SMP)
 static void __init init_irq_default_affinity(void)
 {
<span class="p_del">-	alloc_cpumask_var(&amp;irq_default_affinity, GFP_NOWAIT);</span>
<span class="p_add">+	zalloc_cpumask_var(&amp;irq_default_affinity, GFP_NOWAIT);</span>
 	cpumask_setall(irq_default_affinity);
 }
 #else
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index 0eebaeef317b..93ec1f6aee23 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static void irq_affinity_notify(struct work_struct *work)</span>
 	cpumask_var_t cpumask;
 	unsigned long flags;
 
<span class="p_del">-	if (!desc || !alloc_cpumask_var(&amp;cpumask, GFP_KERNEL))</span>
<span class="p_add">+	if (!desc || !zalloc_cpumask_var(&amp;cpumask, GFP_KERNEL))</span>
 		goto out;
 
 	raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);
<span class="p_chunk">@@ -826,7 +826,7 @@</span> <span class="p_context"> irq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action)</span>
 	 * In case we are out of memory we set IRQTF_AFFINITY again and
 	 * try again next time
 	 */
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL)) {</span>
 		set_bit(IRQTF_AFFINITY, &amp;action-&gt;thread_flags);
 		return;
 	}
<span class="p_chunk">@@ -1158,7 +1158,7 @@</span> <span class="p_context"> __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)</span>
 		}
 	}
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL)) {</span>
 		ret = -ENOMEM;
 		goto out_thread;
 	}
<span class="p_header">diff --git a/kernel/irq/proc.c b/kernel/irq/proc.c</span>
<span class="p_header">index a2c02fd5d6d0..6cac4389af22 100644</span>
<span class="p_header">--- a/kernel/irq/proc.c</span>
<span class="p_header">+++ b/kernel/irq/proc.c</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> static ssize_t write_irq_affinity(int type, struct file *file,</span>
 	if (!irq_can_set_affinity(irq) || no_irq_affinity)
 		return -EIO;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;new_value, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;new_value, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	if (type)
<span class="p_chunk">@@ -195,7 +195,7 @@</span> <span class="p_context"> static ssize_t default_affinity_write(struct file *file,</span>
 	cpumask_var_t new_value;
 	int err;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;new_value, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;new_value, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	err = cpumask_parse_user(buffer, count, new_value);
<span class="p_header">diff --git a/kernel/padata.c b/kernel/padata.c</span>
<span class="p_header">index b38bea9c466a..c0e438e40f8a 100644</span>
<span class="p_header">--- a/kernel/padata.c</span>
<span class="p_header">+++ b/kernel/padata.c</span>
<span class="p_chunk">@@ -351,11 +351,11 @@</span> <span class="p_context"> static int padata_setup_cpumasks(struct parallel_data *pd,</span>
 				 const struct cpumask *pcpumask,
 				 const struct cpumask *cbcpumask)
 {
<span class="p_del">-	if (!alloc_cpumask_var(&amp;pd-&gt;cpumask.pcpu, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;pd-&gt;cpumask.pcpu, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	cpumask_and(pd-&gt;cpumask.pcpu, pcpumask, cpu_online_mask);
<span class="p_del">-	if (!alloc_cpumask_var(&amp;pd-&gt;cpumask.cbcpu, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;pd-&gt;cpumask.cbcpu, GFP_KERNEL)) {</span>
 		free_cpumask_var(pd-&gt;cpumask.cbcpu);
 		return -ENOMEM;
 	}
<span class="p_chunk">@@ -931,7 +931,7 @@</span> <span class="p_context"> static ssize_t store_cpumask(struct padata_instance *pinst,</span>
 	ssize_t ret;
 	int mask_type;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;new_cpumask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;new_cpumask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	ret = bitmap_parse(buf, count, cpumask_bits(new_cpumask),
<span class="p_chunk">@@ -1045,9 +1045,9 @@</span> <span class="p_context"> struct padata_instance *padata_alloc(struct workqueue_struct *wq,</span>
 		goto err;
 
 	get_online_cpus();
<span class="p_del">-	if (!alloc_cpumask_var(&amp;pinst-&gt;cpumask.pcpu, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;pinst-&gt;cpumask.pcpu, GFP_KERNEL))</span>
 		goto err_free_inst;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;pinst-&gt;cpumask.cbcpu, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;pinst-&gt;cpumask.cbcpu, GFP_KERNEL)) {</span>
 		free_cpumask_var(pinst-&gt;cpumask.pcpu);
 		goto err_free_inst;
 	}
<span class="p_header">diff --git a/kernel/profile.c b/kernel/profile.c</span>
<span class="p_header">index 99513e1160e5..ade1179de386 100644</span>
<span class="p_header">--- a/kernel/profile.c</span>
<span class="p_header">+++ b/kernel/profile.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> int __ref profile_init(void)</span>
 	prof_len = (_etext - _stext) &gt;&gt; prof_shift;
 	buffer_bytes = prof_len*sizeof(atomic_t);
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;prof_cpu_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;prof_cpu_mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	cpumask_copy(prof_cpu_mask, cpu_possible_mask);
<span class="p_chunk">@@ -437,7 +437,7 @@</span> <span class="p_context"> static ssize_t prof_cpu_mask_proc_write(struct file *file,</span>
 	cpumask_var_t new_value;
 	int err;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;new_value, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;new_value, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	err = cpumask_parse_user(buffer, count, new_value);
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index f33c94d974c9..aa7f8e965386 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -4518,11 +4518,11 @@</span> <span class="p_context"> long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)</span>
 		retval = -EINVAL;
 		goto out_put_task;
 	}
<span class="p_del">-	if (!alloc_cpumask_var(&amp;cpus_allowed, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;cpus_allowed, GFP_KERNEL)) {</span>
 		retval = -ENOMEM;
 		goto out_put_task;
 	}
<span class="p_del">-	if (!alloc_cpumask_var(&amp;new_mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;new_mask, GFP_KERNEL)) {</span>
 		retval = -ENOMEM;
 		goto out_free_cpus_allowed;
 	}
<span class="p_chunk">@@ -4610,7 +4610,7 @@</span> <span class="p_context"> SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len,</span>
 	cpumask_var_t new_mask;
 	int retval;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;new_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;new_mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask);
<span class="p_chunk">@@ -4666,7 +4666,7 @@</span> <span class="p_context"> SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len,</span>
 	if (len &amp; (sizeof(unsigned long)-1))
 		return -EINVAL;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	ret = sched_getaffinity(pid, mask);
<span class="p_chunk">@@ -7163,7 +7163,7 @@</span> <span class="p_context"> cpumask_var_t *alloc_sched_domains(unsigned int ndoms)</span>
 	if (!doms)
 		return NULL;
 	for (i = 0; i &lt; ndoms; i++) {
<span class="p_del">-		if (!alloc_cpumask_var(&amp;doms[i], GFP_KERNEL)) {</span>
<span class="p_add">+		if (!zalloc_cpumask_var(&amp;doms[i], GFP_KERNEL)) {</span>
 			free_sched_domains(doms, i);
 			return NULL;
 		}
<span class="p_chunk">@@ -7402,8 +7402,8 @@</span> <span class="p_context"> void __init sched_init_smp(void)</span>
 {
 	cpumask_var_t non_isolated_cpus;
 
<span class="p_del">-	alloc_cpumask_var(&amp;non_isolated_cpus, GFP_KERNEL);</span>
<span class="p_del">-	alloc_cpumask_var(&amp;fallback_doms, GFP_KERNEL);</span>
<span class="p_add">+	zalloc_cpumask_var(&amp;non_isolated_cpus, GFP_KERNEL);</span>
<span class="p_add">+	zalloc_cpumask_var(&amp;fallback_doms, GFP_KERNEL);</span>
 
 	sched_init_numa();
 
<span class="p_header">diff --git a/kernel/smpboot.c b/kernel/smpboot.c</span>
<span class="p_header">index d264f59bff56..54c80114727e 100644</span>
<span class="p_header">--- a/kernel/smpboot.c</span>
<span class="p_header">+++ b/kernel/smpboot.c</span>
<span class="p_chunk">@@ -285,7 +285,7 @@</span> <span class="p_context"> int smpboot_register_percpu_thread_cpumask(struct smp_hotplug_thread *plug_threa</span>
 	unsigned int cpu;
 	int ret = 0;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;plug_thread-&gt;cpumask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;plug_thread-&gt;cpumask, GFP_KERNEL))</span>
 		return -ENOMEM;
 	cpumask_copy(plug_thread-&gt;cpumask, cpumask);
 
<span class="p_chunk">@@ -343,7 +343,7 @@</span> <span class="p_context"> int smpboot_update_cpumask_percpu_thread(struct smp_hotplug_thread *plug_thread,</span>
 	cpumask_var_t tmp;
 	unsigned int cpu;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;tmp, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;tmp, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	get_online_cpus();
<span class="p_header">diff --git a/kernel/taskstats.c b/kernel/taskstats.c</span>
<span class="p_header">index 21f82c29c914..79bb1d4f259e 100644</span>
<span class="p_header">--- a/kernel/taskstats.c</span>
<span class="p_header">+++ b/kernel/taskstats.c</span>
<span class="p_chunk">@@ -468,7 +468,7 @@</span> <span class="p_context"> static int cmd_attr_register_cpumask(struct genl_info *info)</span>
 	cpumask_var_t mask;
 	int rc;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 	rc = parse(info-&gt;attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK], mask);
 	if (rc &lt; 0)
<span class="p_chunk">@@ -484,7 +484,7 @@</span> <span class="p_context"> static int cmd_attr_deregister_cpumask(struct genl_info *info)</span>
 	cpumask_var_t mask;
 	int rc;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 	rc = parse(info-&gt;attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK], mask);
 	if (rc &lt; 0)
<span class="p_header">diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c</span>
<span class="p_header">index 99ef0df12807..b6cf842440c8 100644</span>
<span class="p_header">--- a/kernel/time/tick-sched.c</span>
<span class="p_header">+++ b/kernel/time/tick-sched.c</span>
<span class="p_chunk">@@ -314,7 +314,7 @@</span> <span class="p_context"> static int tick_nohz_init_all(void)</span>
 	int err = -1;
 
 #ifdef CONFIG_NO_HZ_FULL_ALL
<span class="p_del">-	if (!alloc_cpumask_var(&amp;tick_nohz_full_mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;tick_nohz_full_mask, GFP_KERNEL)) {</span>
 		WARN(1, &quot;NO_HZ: Can&#39;t allocate full dynticks cpumask\n&quot;);
 		return err;
 	}
<span class="p_chunk">@@ -334,7 +334,7 @@</span> <span class="p_context"> void __init tick_nohz_init(void)</span>
 			return;
 	}
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;housekeeping_mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;housekeeping_mask, GFP_KERNEL)) {</span>
 		WARN(1, &quot;NO_HZ: Can&#39;t allocate not-full dynticks cpumask\n&quot;);
 		cpumask_clear(tick_nohz_full_mask);
 		tick_nohz_full_running = false;
<span class="p_header">diff --git a/kernel/torture.c b/kernel/torture.c</span>
<span class="p_header">index 44aa462d033f..82c02ac0f3f2 100644</span>
<span class="p_header">--- a/kernel/torture.c</span>
<span class="p_header">+++ b/kernel/torture.c</span>
<span class="p_chunk">@@ -369,7 +369,7 @@</span> <span class="p_context"> int torture_shuffle_init(long shuffint)</span>
 
 	shuffle_idle_cpu = -1;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;shuffle_tmp_mask, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;shuffle_tmp_mask, GFP_KERNEL)) {</span>
 		VERBOSE_TOROUT_ERRSTRING(&quot;Failed to alloc mask&quot;);
 		return -ENOMEM;
 	}
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 9c6045a27ba3..15dbf881ee17 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -1311,7 +1311,7 @@</span> <span class="p_context"> struct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,</span>
 	if (!buffer)
 		return NULL;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;buffer-&gt;cpumask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;buffer-&gt;cpumask, GFP_KERNEL))</span>
 		goto fail_free_buffer;
 
 	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 87fb9801bd9e..9295b7ef5338 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -3421,7 +3421,7 @@</span> <span class="p_context"> tracing_cpumask_write(struct file *filp, const char __user *ubuf,</span>
 	cpumask_var_t tracing_cpumask_new;
 	int err, cpu;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;tracing_cpumask_new, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;tracing_cpumask_new, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	err = cpumask_parse_user(ubuf, count, tracing_cpumask_new);
<span class="p_chunk">@@ -4591,7 +4591,7 @@</span> <span class="p_context"> static int tracing_open_pipe(struct inode *inode, struct file *filp)</span>
 	trace_seq_init(&amp;iter-&gt;seq);
 	iter-&gt;trace = tr-&gt;current_trace;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;iter-&gt;started, GFP_KERNEL)) {</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;iter-&gt;started, GFP_KERNEL)) {</span>
 		ret = -ENOMEM;
 		goto fail;
 	}
<span class="p_chunk">@@ -6641,7 +6641,7 @@</span> <span class="p_context"> static int instance_mkdir(const char *name)</span>
 	if (!tr-&gt;name)
 		goto out_free_tr;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;tr-&gt;tracing_cpumask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;tr-&gt;tracing_cpumask, GFP_KERNEL))</span>
 		goto out_free_tr;
 
 	tr-&gt;trace_flags = global_trace.trace_flags;
<span class="p_chunk">@@ -7205,10 +7205,10 @@</span> <span class="p_context"> __init static int tracer_alloc_buffers(void)</span>
 	 */
 	BUILD_BUG_ON(TRACE_ITER_LAST_BIT &gt; TRACE_FLAGS_MAX_SIZE);
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;tracing_buffer_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;tracing_buffer_mask, GFP_KERNEL))</span>
 		goto out;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;global_trace.tracing_cpumask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;global_trace.tracing_cpumask, GFP_KERNEL))</span>
 		goto out_free_buffer_mask;
 
 	/* Only allocate trace_printk buffers if a trace_printk exists */
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index c579dbab2e36..8bf8c72dd01a 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -3007,7 +3007,7 @@</span> <span class="p_context"> struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)</span>
 	attrs = kzalloc(sizeof(*attrs), gfp_mask);
 	if (!attrs)
 		goto fail;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;attrs-&gt;cpumask, gfp_mask))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;attrs-&gt;cpumask, gfp_mask))</span>
 		goto fail;
 
 	cpumask_copy(attrs-&gt;cpumask, cpu_possible_mask);
<span class="p_chunk">@@ -5216,7 +5216,7 @@</span> <span class="p_context"> static int __init init_workqueues(void)</span>
 
 	WARN_ON(__alignof__(struct pool_workqueue) &lt; __alignof__(long long));
 
<span class="p_del">-	BUG_ON(!alloc_cpumask_var(&amp;wq_unbound_cpumask, GFP_KERNEL));</span>
<span class="p_add">+	BUG_ON(!zalloc_cpumask_var(&amp;wq_unbound_cpumask, GFP_KERNEL));</span>
 	cpumask_copy(wq_unbound_cpumask, cpu_possible_mask);
 
 	pwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);
<span class="p_header">diff --git a/lib/cpumask.c b/lib/cpumask.c</span>
<span class="p_header">index 5a70f6196f57..7f93df07bce7 100644</span>
<span class="p_header">--- a/lib/cpumask.c</span>
<span class="p_header">+++ b/lib/cpumask.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node)</span>
 
 #ifdef CONFIG_DEBUG_PER_CPU_MAPS
 	if (!*mask) {
<span class="p_del">-		printk(KERN_ERR &quot;=&gt; alloc_cpumask_var: failed!\n&quot;);</span>
<span class="p_add">+		printk(KERN_ERR &quot;=&gt; zalloc_cpumask_var: failed!\n&quot;);</span>
 		dump_stack();
 	}
 #endif
<span class="p_header">diff --git a/mm/vmstat.c b/mm/vmstat.c</span>
<span class="p_header">index 879a2be23325..d57465284ea6 100644</span>
<span class="p_header">--- a/mm/vmstat.c</span>
<span class="p_header">+++ b/mm/vmstat.c</span>
<span class="p_chunk">@@ -1478,7 +1478,7 @@</span> <span class="p_context"> static void __init start_shepherd_timer(void)</span>
 		INIT_DELAYED_WORK(per_cpu_ptr(&amp;vmstat_work, cpu),
 			vmstat_update);
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;cpu_stat_off, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;cpu_stat_off, GFP_KERNEL))</span>
 		BUG();
 	cpumask_copy(cpu_stat_off, cpu_online_mask);
 
<span class="p_header">diff --git a/net/core/flow.c b/net/core/flow.c</span>
<span class="p_header">index 1033725be40b..af62e71507f6 100644</span>
<span class="p_header">--- a/net/core/flow.c</span>
<span class="p_header">+++ b/net/core/flow.c</span>
<span class="p_chunk">@@ -344,7 +344,7 @@</span> <span class="p_context"> void flow_cache_flush(struct net *net)</span>
 	int i, self;
 
 	/* Track which cpus need flushing to avoid disturbing all cores. */
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
 		return;
 	cpumask_clear(mask);
 
<span class="p_header">diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c</span>
<span class="p_header">index f88a62ab019d..0bc34c7bd91b 100644</span>
<span class="p_header">--- a/net/core/net-sysfs.c</span>
<span class="p_header">+++ b/net/core/net-sysfs.c</span>
<span class="p_chunk">@@ -693,7 +693,7 @@</span> <span class="p_context"> static ssize_t store_rps_map(struct netdev_rx_queue *queue,</span>
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	err = bitmap_parse(buf, len, cpumask_bits(mask), nr_cpumask_bits);
<span class="p_chunk">@@ -1217,7 +1217,7 @@</span> <span class="p_context"> static ssize_t store_xps_map(struct netdev_queue *queue,</span>
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	index = get_netdev_queue_index(queue);
<span class="p_header">diff --git a/net/core/sysctl_net_core.c b/net/core/sysctl_net_core.c</span>
<span class="p_header">index 95b6139d710c..74e858d3150e 100644</span>
<span class="p_header">--- a/net/core/sysctl_net_core.c</span>
<span class="p_header">+++ b/net/core/sysctl_net_core.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> static int flow_limit_cpu_sysctl(struct ctl_table *table, int write,</span>
 	cpumask_var_t mask;
 	int i, len, ret = 0;
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
 		return -ENOMEM;
 
 	if (write) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



