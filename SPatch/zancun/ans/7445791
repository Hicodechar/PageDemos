
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[2/6] x86/microcode: Merge early loader - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [2/6] x86/microcode: Merge early loader</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 20, 2015, 9:54 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1445334889-300-3-git-send-email-bp@alien8.de&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7445791/mbox/"
   >mbox</a>
|
   <a href="/patch/7445791/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7445791/">/patch/7445791/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 5B9D2BEEA4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 20 Oct 2015 09:56:19 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id D9CEC206BC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 20 Oct 2015 09:56:14 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 1CB9A2053A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 20 Oct 2015 09:56:10 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753973AbbJTJ4F (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 20 Oct 2015 05:56:05 -0400
Received: from mail.skyhub.de ([78.46.96.112]:44556 &quot;EHLO mail.skyhub.de&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1753326AbbJTJzD (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 20 Oct 2015 05:55:03 -0400
X-Virus-Scanned: Nedap ESD1 at mail.skyhub.de
Received: from mail.skyhub.de ([127.0.0.1])
	by localhost (door.skyhub.de [127.0.0.1]) (amavisd-new, port 10026)
	with ESMTP id TyRiae1gFGyw; Tue, 20 Oct 2015 11:54:59 +0200 (CEST)
Received: from pd.tnic (p5DDC5E3A.dip0.t-ipconnect.de [93.220.94.58])
	(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mail.skyhub.de (SuperMail on ZX Spectrum 128k) with ESMTPSA id
	5E45E1DA299; Tue, 20 Oct 2015 11:54:55 +0200 (CEST)
Received: by pd.tnic (Postfix, from userid 1000)
	id 7C93E161894; Tue, 20 Oct 2015 11:54:49 +0200 (CEST)
From: Borislav Petkov &lt;bp@alien8.de&gt;
To: X86 ML &lt;x86@kernel.org&gt;
Cc: LKML &lt;linux-kernel@vger.kernel.org&gt;
Subject: [PATCH 2/6] x86/microcode: Merge early loader
Date: Tue, 20 Oct 2015 11:54:45 +0200
Message-Id: &lt;1445334889-300-3-git-send-email-bp@alien8.de&gt;
X-Mailer: git-send-email 2.3.5
In-Reply-To: &lt;1445334889-300-1-git-send-email-bp@alien8.de&gt;
References: &lt;1445334889-300-1-git-send-email-bp@alien8.de&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - Oct. 20, 2015, 9:54 a.m.</div>
<pre class="content">
<span class="from">From: Borislav Petkov &lt;bp@suse.de&gt;</span>

Merge the early loader functionality into the driver proper. The diff
is huge but logically, it is simply moving code from the _early.c files
into the main driver.
<span class="signed-off-by">
Signed-off-by: Borislav Petkov &lt;bp@suse.de&gt;</span>
---
 arch/x86/Kconfig                            |  19 +-
 arch/x86/include/asm/microcode.h            |  19 +-
 arch/x86/include/asm/microcode_amd.h        |   2 +-
 arch/x86/include/asm/microcode_intel.h      |  10 +-
 arch/x86/kernel/cpu/microcode/Makefile      |   3 -
 arch/x86/kernel/cpu/microcode/amd.c         | 446 ++++++++++++++-
 arch/x86/kernel/cpu/microcode/amd_early.c   | 444 ---------------
 arch/x86/kernel/cpu/microcode/core.c        | 160 +++++-
 arch/x86/kernel/cpu/microcode/core_early.c  | 170 ------
 arch/x86/kernel/cpu/microcode/intel.c       | 788 ++++++++++++++++++++++++++-
 arch/x86/kernel/cpu/microcode/intel_early.c | 808 ----------------------------
 arch/x86/kernel/head_32.S                   |   5 +-
 arch/x86/mm/init.c                          |   2 -
 13 files changed, 1399 insertions(+), 1477 deletions(-)
 delete mode 100644 arch/x86/kernel/cpu/microcode/amd_early.c
 delete mode 100644 arch/x86/kernel/cpu/microcode/core_early.c
 delete mode 100644 arch/x86/kernel/cpu/microcode/intel_early.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=72767">Josh Boyer</a> - Nov. 6, 2015, 7:22 p.m.</div>
<pre class="content">
On Tue, Oct 20, 2015 at 5:54 AM, Borislav Petkov &lt;bp@alien8.de&gt; wrote:
<span class="quote">&gt; From: Borislav Petkov &lt;bp@suse.de&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Merge the early loader functionality into the driver proper. The diff</span>
<span class="quote">&gt; is huge but logically, it is simply moving code from the _early.c files</span>
<span class="quote">&gt; into the main driver.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Borislav Petkov &lt;bp@suse.de&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/Kconfig                            |  19 +-</span>
<span class="quote">&gt;  arch/x86/include/asm/microcode.h            |  19 +-</span>
<span class="quote">&gt;  arch/x86/include/asm/microcode_amd.h        |   2 +-</span>
<span class="quote">&gt;  arch/x86/include/asm/microcode_intel.h      |  10 +-</span>
<span class="quote">&gt;  arch/x86/kernel/cpu/microcode/Makefile      |   3 -</span>
<span class="quote">&gt;  arch/x86/kernel/cpu/microcode/amd.c         | 446 ++++++++++++++-</span>
<span class="quote">&gt;  arch/x86/kernel/cpu/microcode/amd_early.c   | 444 ---------------</span>
<span class="quote">&gt;  arch/x86/kernel/cpu/microcode/core.c        | 160 +++++-</span>
<span class="quote">&gt;  arch/x86/kernel/cpu/microcode/core_early.c  | 170 ------</span>
<span class="quote">&gt;  arch/x86/kernel/cpu/microcode/intel.c       | 788 ++++++++++++++++++++++++++-</span>
<span class="quote">&gt;  arch/x86/kernel/cpu/microcode/intel_early.c | 808 ----------------------------</span>
<span class="quote">&gt;  arch/x86/kernel/head_32.S                   |   5 +-</span>
<span class="quote">&gt;  arch/x86/mm/init.c                          |   2 -</span>
<span class="quote">&gt;  13 files changed, 1399 insertions(+), 1477 deletions(-)</span>
<span class="quote">&gt;  delete mode 100644 arch/x86/kernel/cpu/microcode/amd_early.c</span>
<span class="quote">&gt;  delete mode 100644 arch/x86/kernel/cpu/microcode/core_early.c</span>
<span class="quote">&gt;  delete mode 100644 arch/x86/kernel/cpu/microcode/intel_early.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="quote">&gt; index fdf1f0cdf6b6..255ea22ccbec 100644</span>
<span class="quote">&gt; --- a/arch/x86/Kconfig</span>
<span class="quote">&gt; +++ b/arch/x86/Kconfig</span>
<span class="quote">&gt; @@ -1126,6 +1126,7 @@ config MICROCODE</span>
<span class="quote">&gt;         bool &quot;CPU microcode loading support&quot;</span>
<span class="quote">&gt;         default y</span>
<span class="quote">&gt;         depends on CPU_SUP_AMD || CPU_SUP_INTEL</span>
<span class="quote">&gt; +       depends on BLK_DEV_INITRD</span>
<span class="quote">&gt;         select FW_LOADER</span>
<span class="quote">&gt;         ---help---</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; @@ -1167,24 +1168,6 @@ config MICROCODE_OLD_INTERFACE</span>
<span class="quote">&gt;         def_bool y</span>
<span class="quote">&gt;         depends on MICROCODE</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -config MICROCODE_INTEL_EARLY</span>
<span class="quote">&gt; -       bool</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -config MICROCODE_AMD_EARLY</span>
<span class="quote">&gt; -       bool</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -config MICROCODE_EARLY</span>
<span class="quote">&gt; -       bool &quot;Early load microcode&quot;</span>
<span class="quote">&gt; -       depends on MICROCODE &amp;&amp; BLK_DEV_INITRD</span>
<span class="quote">&gt; -       select MICROCODE_INTEL_EARLY if MICROCODE_INTEL</span>
<span class="quote">&gt; -       select MICROCODE_AMD_EARLY if MICROCODE_AMD</span>
<span class="quote">&gt; -       default y</span>
<span class="quote">&gt; -       help</span>
<span class="quote">&gt; -         This option provides functionality to read additional microcode data</span>
<span class="quote">&gt; -         at the beginning of initrd image. The data tells kernel to load</span>
<span class="quote">&gt; -         microcode to CPU&#39;s as early as possible. No functional change if no</span>
<span class="quote">&gt; -         microcode data is glued to the initrd, therefore it&#39;s safe to say Y.</span>
<span class="quote">&gt; -</span>

So this broke dracut.  Dracut will look at the config file for the
INTEL or AMD early config options being set.  If it does not find
them, it disables the creation of the early microcode part of the
initramfs.  Now that the options don&#39;t even exist, it fails.

Do we have suggestions on how to work this out going forward?  I
suppose we could assume the check should only be done on 4.3 or older
kernels, but I&#39;m not sure making assumptions about newer kernels is a
great idea either.

josh
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - Nov. 6, 2015, 7:31 p.m.</div>
<pre class="content">
On Fri, Nov 06, 2015 at 02:22:42PM -0500, Josh Boyer wrote:
<span class="quote">&gt; So this broke dracut.  Dracut will look at the config file for the</span>
<span class="quote">&gt; INTEL or AMD early config options being set.</span>

Nothing outside the kernel should depend on Kconfig symbols.
<span class="quote">
&gt; Do we have suggestions on how to work this out going forward?  I</span>
<span class="quote">&gt; suppose we could assume the check should only be done on 4.3 or older</span>
<span class="quote">&gt; kernels, but I&#39;m not sure making assumptions about newer kernels is a</span>
<span class="quote">&gt; great idea either.</span>

How about always adding AMD and Intel microcode always? Maybe with a
switch to disable adding any microcode for testing purposes only...
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1026">Harald Hoyer</a> - Nov. 9, 2015, 9:42 a.m.</div>
<pre class="content">
Am 06.11.2015 um 20:31 schrieb Borislav Petkov:
<span class="quote">&gt; On Fri, Nov 06, 2015 at 02:22:42PM -0500, Josh Boyer wrote:</span>
<span class="quote">&gt;&gt; So this broke dracut.  Dracut will look at the config file for the</span>
<span class="quote">&gt;&gt; INTEL or AMD early config options being set.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nothing outside the kernel should depend on Kconfig symbols.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; Do we have suggestions on how to work this out going forward?  I</span>
<span class="quote">&gt;&gt; suppose we could assume the check should only be done on 4.3 or older</span>
<span class="quote">&gt;&gt; kernels, but I&#39;m not sure making assumptions about newer kernels is a</span>
<span class="quote">&gt;&gt; great idea either.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; How about always adding AMD and Intel microcode always? Maybe with a</span>
<span class="quote">&gt; switch to disable adding any microcode for testing purposes only...</span>
<span class="quote">&gt; </span>

Will this work with kernels not supporting the microcode loading?
Theoretically the old kernels would just unpack all cpios one after the other,
right?
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - Nov. 9, 2015, 10:11 a.m.</div>
<pre class="content">
On Mon, Nov 09, 2015 at 10:42:13AM +0100, Harald Hoyer wrote:
<span class="quote">&gt; Will this work with kernels not supporting the microcode loading?</span>
<span class="quote">&gt; Theoretically the old kernels would just unpack all cpios one after</span>
<span class="quote">&gt; the other, right?</span>

Well, what we should be doing is adding two paths to the initrd:

for AMD:	kernel/x86/microcode/AuthenticAMD.bin
for Intel:	kernel/x86/microcode/GenuineIntel.bin

I.e., the microcode blobs become part of the initrd, see
Documentation/x86/early-microcode.txt. The loader goes and opens the one
it needs at boot time.

You could also add a switch for convenience, something like
--no-microcode or so, so that dracut doesn&#39;t add it but if one wants to
not add microcode, one could also move it away from, say, /lib/firmware/
so that dracut simply doesn&#39;t find it. The --no-microcode might be more
convenient though.

Kernels which don&#39;t support microcode loading would simply not look for
that path.

Let me know if this doesn&#39;t make sense and if I need to test/look at
patches.

Thanks.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index fdf1f0cdf6b6..255ea22ccbec 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -1126,6 +1126,7 @@</span> <span class="p_context"> config MICROCODE</span>
 	bool &quot;CPU microcode loading support&quot;
 	default y
 	depends on CPU_SUP_AMD || CPU_SUP_INTEL
<span class="p_add">+	depends on BLK_DEV_INITRD</span>
 	select FW_LOADER
 	---help---
 
<span class="p_chunk">@@ -1167,24 +1168,6 @@</span> <span class="p_context"> config MICROCODE_OLD_INTERFACE</span>
 	def_bool y
 	depends on MICROCODE
 
<span class="p_del">-config MICROCODE_INTEL_EARLY</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
<span class="p_del">-config MICROCODE_AMD_EARLY</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
<span class="p_del">-config MICROCODE_EARLY</span>
<span class="p_del">-	bool &quot;Early load microcode&quot;</span>
<span class="p_del">-	depends on MICROCODE &amp;&amp; BLK_DEV_INITRD</span>
<span class="p_del">-	select MICROCODE_INTEL_EARLY if MICROCODE_INTEL</span>
<span class="p_del">-	select MICROCODE_AMD_EARLY if MICROCODE_AMD</span>
<span class="p_del">-	default y</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  This option provides functionality to read additional microcode data</span>
<span class="p_del">-	  at the beginning of initrd image. The data tells kernel to load</span>
<span class="p_del">-	  microcode to CPU&#39;s as early as possible. No functional change if no</span>
<span class="p_del">-	  microcode data is glued to the initrd, therefore it&#39;s safe to say Y.</span>
<span class="p_del">-</span>
 config X86_MSR
 	tristate &quot;/dev/cpu/*/msr - Model-specific register support&quot;
 	---help---
<span class="p_header">diff --git a/arch/x86/include/asm/microcode.h b/arch/x86/include/asm/microcode.h</span>
<span class="p_header">index d1ff724f352b..9f953f7851bb 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode.h</span>
<span class="p_chunk">@@ -81,7 +81,6 @@</span> <span class="p_context"> static inline struct microcode_ops * __init init_amd_microcode(void)</span>
 static inline void __exit exit_amd_microcode(void) {}
 #endif
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_EARLY</span>
 #define MAX_UCODE_COUNT 128
 
 #define QCHAR(a, b, c, d) ((a) + ((b) &lt;&lt; 8) + ((c) &lt;&lt; 16) + ((d) &lt;&lt; 24))
<span class="p_chunk">@@ -156,22 +155,18 @@</span> <span class="p_context"> static inline unsigned int x86_model(unsigned int sig)</span>
 	return model;
 }
 
<span class="p_add">+#ifdef CONFIG_MICROCODE</span>
 extern void __init load_ucode_bsp(void);
 extern void load_ucode_ap(void);
 extern int __init save_microcode_in_initrd(void);
 void reload_early_microcode(void);
 extern bool get_builtin_firmware(struct cpio_data *cd, const char *name);
 #else
<span class="p_del">-static inline void __init load_ucode_bsp(void) {}</span>
<span class="p_del">-static inline void load_ucode_ap(void) {}</span>
<span class="p_del">-static inline int __init save_microcode_in_initrd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline void reload_early_microcode(void) {}</span>
<span class="p_del">-static inline bool get_builtin_firmware(struct cpio_data *cd, const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_add">+static inline void __init load_ucode_bsp(void)			{ }</span>
<span class="p_add">+static inline void load_ucode_ap(void)				{ }</span>
<span class="p_add">+static inline int __init save_microcode_in_initrd(void)		{ return 0; }</span>
<span class="p_add">+static inline void reload_early_microcode(void)			{ }</span>
<span class="p_add">+static inline bool</span>
<span class="p_add">+get_builtin_firmware(struct cpio_data *cd, const char *name)	{ return false; }</span>
 #endif
 #endif /* _ASM_X86_MICROCODE_H */
<span class="p_header">diff --git a/arch/x86/include/asm/microcode_amd.h b/arch/x86/include/asm/microcode_amd.h</span>
<span class="p_header">index d3e86cfd08fe..adfc847a395e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode_amd.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode_amd.h</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> extern enum ucode_state load_microcode_amd(int cpu, u8 family, const u8 *data, s</span>
 #define PATCH_MAX_SIZE PAGE_SIZE
 extern u8 amd_ucode_patch[PATCH_MAX_SIZE];
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_AMD_EARLY</span>
<span class="p_add">+#ifdef CONFIG_MICROCODE_AMD</span>
 extern void __init load_ucode_amd_bsp(unsigned int family);
 extern void load_ucode_amd_ap(void);
 extern int __init save_microcode_in_initrd_amd(void);
<span class="p_header">diff --git a/arch/x86/include/asm/microcode_intel.h b/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_header">index 7991c606125d..8559b0102ea1 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> extern int has_newer_microcode(void *mc, unsigned int csig, int cpf, int rev);</span>
 extern int microcode_sanity_check(void *mc, int print_err);
 extern int find_matching_signature(void *mc, unsigned int csig, int cpf);
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_INTEL_EARLY</span>
<span class="p_add">+#ifdef CONFIG_MICROCODE_INTEL</span>
 extern void __init load_ucode_intel_bsp(void);
 extern void load_ucode_intel_ap(void);
 extern void show_ucode_info_early(void);
<span class="p_chunk">@@ -71,13 +71,9 @@</span> <span class="p_context"> static inline int __init save_microcode_in_initrd_intel(void) { return -EINVAL;</span>
 static inline void reload_ucode_intel(void) {}
 #endif
 
<span class="p_del">-#if defined(CONFIG_MICROCODE_INTEL_EARLY) &amp;&amp; defined(CONFIG_HOTPLUG_CPU)</span>
<span class="p_add">+#ifdef CONFIG_HOTPLUG_CPU</span>
 extern int save_mc_for_early(u8 *mc);
 #else
<span class="p_del">-static inline int save_mc_for_early(u8 *mc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_add">+static inline int save_mc_for_early(u8 *mc) { return 0; }</span>
 #endif
<span class="p_del">-</span>
 #endif /* _ASM_X86_MICROCODE_INTEL_H */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/Makefile b/arch/x86/kernel/cpu/microcode/Makefile</span>
<span class="p_header">index 285c85427c32..220b1a508513 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/Makefile</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/Makefile</span>
<span class="p_chunk">@@ -2,6 +2,3 @@</span> <span class="p_context"> microcode-y				:= core.o</span>
 obj-$(CONFIG_MICROCODE)			+= microcode.o
 microcode-$(CONFIG_MICROCODE_INTEL)	+= intel.o intel_lib.o
 microcode-$(CONFIG_MICROCODE_AMD)	+= amd.o
<span class="p_del">-obj-$(CONFIG_MICROCODE_EARLY)		+= core_early.o</span>
<span class="p_del">-obj-$(CONFIG_MICROCODE_INTEL_EARLY)	+= intel_early.o</span>
<span class="p_del">-obj-$(CONFIG_MICROCODE_AMD_EARLY)	+= amd_early.o</span>
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/amd.c b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">index 5dcce5dc39b9..20297fbb7355 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_chunk">@@ -1,5 +1,9 @@</span> <span class="p_context"></span>
 /*
  *  AMD CPU Microcode Update Driver for Linux
<span class="p_add">+ *</span>
<span class="p_add">+ *  This driver allows to upgrade microcode on F10h AMD</span>
<span class="p_add">+ *  CPUs and later.</span>
<span class="p_add">+ *</span>
  *  Copyright (C) 2008-2011 Advanced Micro Devices Inc.
  *
  *  Author: Peter Oruba &lt;peter.oruba@amd.com&gt;
<span class="p_chunk">@@ -11,26 +15,32 @@</span> <span class="p_context"></span>
  *  Andreas Herrmann &lt;herrmann.der.user@googlemail.com&gt;
  *  Borislav Petkov &lt;bp@alien8.de&gt;
  *
<span class="p_del">- *  This driver allows to upgrade microcode on F10h AMD</span>
<span class="p_del">- *  CPUs and later.</span>
<span class="p_add">+ *  early loader:</span>
<span class="p_add">+ *  Copyright (C) 2013 Advanced Micro Devices, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Author: Jacob Shin &lt;jacob.shin@amd.com&gt;</span>
<span class="p_add">+ *  Fixes: Borislav Petkov &lt;bp@suse.de&gt;</span>
  *
  *  Licensed under the terms of the GNU General Public
  *  License version 2. See file COPYING for details.
  */
<span class="p_del">-</span>
 #define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt
 
<span class="p_add">+#include &lt;linux/earlycpio.h&gt;</span>
 #include &lt;linux/firmware.h&gt;
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/vmalloc.h&gt;
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/pci.h&gt;
 
<span class="p_add">+#include &lt;asm/microcode_amd.h&gt;</span>
 #include &lt;asm/microcode.h&gt;
 #include &lt;asm/processor.h&gt;
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+#include &lt;asm/cpu.h&gt;</span>
 #include &lt;asm/msr.h&gt;
<span class="p_del">-#include &lt;asm/microcode_amd.h&gt;</span>
 
 MODULE_DESCRIPTION(&quot;AMD Microcode Update Driver&quot;);
 MODULE_AUTHOR(&quot;Peter Oruba&quot;);
<span class="p_chunk">@@ -47,6 +57,432 @@</span> <span class="p_context"> struct ucode_patch {</span>
 
 static LIST_HEAD(pcache);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * This points to the current valid container of microcode patches which we will</span>
<span class="p_add">+ * save from the initrd before jettisoning its contents.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static u8 *container;</span>
<span class="p_add">+static size_t container_size;</span>
<span class="p_add">+</span>
<span class="p_add">+static u32 ucode_new_rev;</span>
<span class="p_add">+u8 amd_ucode_patch[PATCH_MAX_SIZE];</span>
<span class="p_add">+static u16 this_equiv_id;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct cpio_data ucode_cpio;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Microcode patch container file is prepended to the initrd in cpio format.</span>
<span class="p_add">+ * See Documentation/x86/early-microcode.txt</span>
<span class="p_add">+ */</span>
<span class="p_add">+static __initdata char ucode_path[] = &quot;kernel/x86/microcode/AuthenticAMD.bin&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct cpio_data __init find_ucode_in_initrd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long offset = 0;</span>
<span class="p_add">+	char *path;</span>
<span class="p_add">+	void *start;</span>
<span class="p_add">+	size_t size;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	struct boot_params *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On 32-bit, early load occurs before paging is turned on so we need</span>
<span class="p_add">+	 * to use physical addresses.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	p       = (struct boot_params *)__pa_nodebug(&amp;boot_params);</span>
<span class="p_add">+	path    = (char *)__pa_nodebug(ucode_path);</span>
<span class="p_add">+	start   = (void *)p-&gt;hdr.ramdisk_image;</span>
<span class="p_add">+	size    = p-&gt;hdr.ramdisk_size;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	path    = ucode_path;</span>
<span class="p_add">+	start   = (void *)(boot_params.hdr.ramdisk_image + PAGE_OFFSET);</span>
<span class="p_add">+	size    = boot_params.hdr.ramdisk_size;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	return find_cpio_data(path, start, size, &amp;offset);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static size_t compute_container_size(u8 *data, u32 total_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	size_t size = 0;</span>
<span class="p_add">+	u32 *header = (u32 *)data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (header[0] != UCODE_MAGIC ||</span>
<span class="p_add">+	    header[1] != UCODE_EQUIV_CPU_TABLE_TYPE || /* type */</span>
<span class="p_add">+	    header[2] == 0)                            /* size */</span>
<span class="p_add">+		return size;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = header[2] + CONTAINER_HDR_SZ;</span>
<span class="p_add">+	total_size -= size;</span>
<span class="p_add">+	data += size;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (total_size) {</span>
<span class="p_add">+		u16 patch_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		header = (u32 *)data;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (header[0] != UCODE_UCODE_TYPE)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Sanity-check patch size.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		patch_size = header[1];</span>
<span class="p_add">+		if (patch_size &gt; PATCH_MAX_SIZE)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		size	   += patch_size + SECTION_HDR_SIZE;</span>
<span class="p_add">+		data	   += patch_size + SECTION_HDR_SIZE;</span>
<span class="p_add">+		total_size -= patch_size + SECTION_HDR_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return size;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Early load occurs before we can vmalloc(). So we look for the microcode</span>
<span class="p_add">+ * patch container file in initrd, traverse equivalent cpu table, look for a</span>
<span class="p_add">+ * matching microcode patch, and update, all in initrd memory in place.</span>
<span class="p_add">+ * When vmalloc() is available for use later -- on 64-bit during first AP load,</span>
<span class="p_add">+ * and on 32-bit during save_microcode_in_initrd_amd() -- we can call</span>
<span class="p_add">+ * load_microcode_amd() to save equivalent cpu table and microcode patches in</span>
<span class="p_add">+ * kernel heap memory.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void apply_ucode_in_initrd(void *ucode, size_t size, bool save_patch)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct equiv_cpu_entry *eq;</span>
<span class="p_add">+	size_t *cont_sz;</span>
<span class="p_add">+	u32 *header;</span>
<span class="p_add">+	u8  *data, **cont;</span>
<span class="p_add">+	u8 (*patch)[PATCH_MAX_SIZE];</span>
<span class="p_add">+	u16 eq_id = 0;</span>
<span class="p_add">+	int offset, left;</span>
<span class="p_add">+	u32 rev, eax, ebx, ecx, edx;</span>
<span class="p_add">+	u32 *new_rev;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	new_rev = (u32 *)__pa_nodebug(&amp;ucode_new_rev);</span>
<span class="p_add">+	cont_sz = (size_t *)__pa_nodebug(&amp;container_size);</span>
<span class="p_add">+	cont	= (u8 **)__pa_nodebug(&amp;container);</span>
<span class="p_add">+	patch	= (u8 (*)[PATCH_MAX_SIZE])__pa_nodebug(&amp;amd_ucode_patch);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	new_rev = &amp;ucode_new_rev;</span>
<span class="p_add">+	cont_sz = &amp;container_size;</span>
<span class="p_add">+	cont	= &amp;container;</span>
<span class="p_add">+	patch	= &amp;amd_ucode_patch;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	data   = ucode;</span>
<span class="p_add">+	left   = size;</span>
<span class="p_add">+	header = (u32 *)data;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* find equiv cpu table */</span>
<span class="p_add">+	if (header[0] != UCODE_MAGIC ||</span>
<span class="p_add">+	    header[1] != UCODE_EQUIV_CPU_TABLE_TYPE || /* type */</span>
<span class="p_add">+	    header[2] == 0)                            /* size */</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	eax = 0x00000001;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (left &gt; 0) {</span>
<span class="p_add">+		eq = (struct equiv_cpu_entry *)(data + CONTAINER_HDR_SZ);</span>
<span class="p_add">+</span>
<span class="p_add">+		*cont = data;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Advance past the container header */</span>
<span class="p_add">+		offset = header[2] + CONTAINER_HDR_SZ;</span>
<span class="p_add">+		data  += offset;</span>
<span class="p_add">+		left  -= offset;</span>
<span class="p_add">+</span>
<span class="p_add">+		eq_id = find_equiv_id(eq, eax);</span>
<span class="p_add">+		if (eq_id) {</span>
<span class="p_add">+			this_equiv_id = eq_id;</span>
<span class="p_add">+			*cont_sz = compute_container_size(*cont, left + offset);</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * truncate how much we need to iterate over in the</span>
<span class="p_add">+			 * ucode update loop below</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			left = *cont_sz - offset;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * support multiple container files appended together. if this</span>
<span class="p_add">+		 * one does not have a matching equivalent cpu entry, we fast</span>
<span class="p_add">+		 * forward to the next container file.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		while (left &gt; 0) {</span>
<span class="p_add">+			header = (u32 *)data;</span>
<span class="p_add">+			if (header[0] == UCODE_MAGIC &amp;&amp;</span>
<span class="p_add">+			    header[1] == UCODE_EQUIV_CPU_TABLE_TYPE)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+</span>
<span class="p_add">+			offset = header[1] + SECTION_HDR_SIZE;</span>
<span class="p_add">+			data  += offset;</span>
<span class="p_add">+			left  -= offset;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* mark where the next microcode container file starts */</span>
<span class="p_add">+		offset    = data - (u8 *)ucode;</span>
<span class="p_add">+		ucode     = data;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!eq_id) {</span>
<span class="p_add">+		*cont = NULL;</span>
<span class="p_add">+		*cont_sz = 0;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (check_current_patch_level(&amp;rev, true))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (left &gt; 0) {</span>
<span class="p_add">+		struct microcode_amd *mc;</span>
<span class="p_add">+</span>
<span class="p_add">+		header = (u32 *)data;</span>
<span class="p_add">+		if (header[0] != UCODE_UCODE_TYPE || /* type */</span>
<span class="p_add">+		    header[1] == 0)                  /* size */</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		mc = (struct microcode_amd *)(data + SECTION_HDR_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (eq_id == mc-&gt;hdr.processor_rev_id &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!__apply_microcode_amd(mc)) {</span>
<span class="p_add">+				rev = mc-&gt;hdr.patch_id;</span>
<span class="p_add">+				*new_rev = rev;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (save_patch)</span>
<span class="p_add">+					memcpy(patch, mc,</span>
<span class="p_add">+					       min_t(u32, header[1], PATCH_MAX_SIZE));</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		offset  = header[1] + SECTION_HDR_SIZE;</span>
<span class="p_add">+		data   += offset;</span>
<span class="p_add">+		left   -= offset;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool __init load_builtin_amd_microcode(struct cpio_data *cp,</span>
<span class="p_add">+					      unsigned int family)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	char fw_name[36] = &quot;amd-ucode/microcode_amd.bin&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (family &gt;= 0x15)</span>
<span class="p_add">+		snprintf(fw_name, sizeof(fw_name),</span>
<span class="p_add">+			 &quot;amd-ucode/microcode_amd_fam%.2xh.bin&quot;, family);</span>
<span class="p_add">+</span>
<span class="p_add">+	return get_builtin_firmware(cp, fw_name);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init load_ucode_amd_bsp(unsigned int family)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpio_data cp;</span>
<span class="p_add">+	void **data;</span>
<span class="p_add">+	size_t *size;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	data =  (void **)__pa_nodebug(&amp;ucode_cpio.data);</span>
<span class="p_add">+	size = (size_t *)__pa_nodebug(&amp;ucode_cpio.size);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	data = &amp;ucode_cpio.data;</span>
<span class="p_add">+	size = &amp;ucode_cpio.size;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	cp = find_ucode_in_initrd();</span>
<span class="p_add">+	if (!cp.data) {</span>
<span class="p_add">+		if (!load_builtin_amd_microcode(&amp;cp, family))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	*data = cp.data;</span>
<span class="p_add">+	*size = cp.size;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_ucode_in_initrd(cp.data, cp.size, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * On 32-bit, since AP&#39;s early load occurs before paging is turned on, we</span>
<span class="p_add">+ * cannot traverse cpu_equiv_table and pcache in kernel heap memory. So during</span>
<span class="p_add">+ * cold boot, AP will apply_ucode_in_initrd() just like the BSP. During</span>
<span class="p_add">+ * save_microcode_in_initrd_amd() BSP&#39;s patch is copied to amd_ucode_patch,</span>
<span class="p_add">+ * which is used upon resume from suspend.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void load_ucode_amd_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_amd *mc;</span>
<span class="p_add">+	size_t *usize;</span>
<span class="p_add">+	void **ucode;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc = (struct microcode_amd *)__pa_nodebug(amd_ucode_patch);</span>
<span class="p_add">+	if (mc-&gt;hdr.patch_id &amp;&amp; mc-&gt;hdr.processor_rev_id) {</span>
<span class="p_add">+		__apply_microcode_amd(mc);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ucode = (void *)__pa_nodebug(&amp;container);</span>
<span class="p_add">+	usize = (size_t *)__pa_nodebug(&amp;container_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!*ucode || !*usize)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_ucode_in_initrd(*ucode, *usize, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init collect_cpu_sig_on_bsp(void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int cpu = smp_processor_id();</span>
<span class="p_add">+	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	uci-&gt;cpu_sig.sig = cpuid_eax(0x00000001);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init get_bsp_sig(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int bsp = boot_cpu_data.cpu_index;</span>
<span class="p_add">+	struct ucode_cpu_info *uci = ucode_cpu_info + bsp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!uci-&gt;cpu_sig.sig)</span>
<span class="p_add">+		smp_call_function_single(bsp, collect_cpu_sig_on_bsp, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+void load_ucode_amd_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int cpu = smp_processor_id();</span>
<span class="p_add">+	struct equiv_cpu_entry *eq;</span>
<span class="p_add">+	struct microcode_amd *mc;</span>
<span class="p_add">+	u32 rev, eax;</span>
<span class="p_add">+	u16 eq_id;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Exit if called on the BSP. */</span>
<span class="p_add">+	if (!cpu)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!container)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 64-bit runs with paging enabled, thus early==false.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (check_current_patch_level(&amp;rev, false))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	eax = cpuid_eax(0x00000001);</span>
<span class="p_add">+	eq  = (struct equiv_cpu_entry *)(container + CONTAINER_HDR_SZ);</span>
<span class="p_add">+</span>
<span class="p_add">+	eq_id = find_equiv_id(eq, eax);</span>
<span class="p_add">+	if (!eq_id)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (eq_id == this_equiv_id) {</span>
<span class="p_add">+		mc = (struct microcode_amd *)amd_ucode_patch;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (mc &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_add">+			if (!__apply_microcode_amd(mc))</span>
<span class="p_add">+				ucode_new_rev = mc-&gt;hdr.patch_id;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!ucode_cpio.data)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * AP has a different equivalence ID than BSP, looks like</span>
<span class="p_add">+		 * mixed-steppings silicon so go through the ucode blob anew.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		apply_ucode_in_initrd(ucode_cpio.data, ucode_cpio.size, false);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+int __init save_microcode_in_initrd_amd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long cont;</span>
<span class="p_add">+	int retval = 0;</span>
<span class="p_add">+	enum ucode_state ret;</span>
<span class="p_add">+	u8 *cont_va;</span>
<span class="p_add">+	u32 eax;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!container)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	get_bsp_sig();</span>
<span class="p_add">+	cont	= (unsigned long)container;</span>
<span class="p_add">+	cont_va = __va(container);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need the physical address of the container for both bitness since</span>
<span class="p_add">+	 * boot_params.hdr.ramdisk_image is a physical address.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cont    = __pa(container);</span>
<span class="p_add">+	cont_va = container;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Take into account the fact that the ramdisk might get relocated and</span>
<span class="p_add">+	 * therefore we need to recompute the container&#39;s position in virtual</span>
<span class="p_add">+	 * memory space.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (relocated_ramdisk)</span>
<span class="p_add">+		container = (u8 *)(__va(relocated_ramdisk) +</span>
<span class="p_add">+			     (cont - boot_params.hdr.ramdisk_image));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		container = cont_va;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ucode_new_rev)</span>
<span class="p_add">+		pr_info(&quot;microcode: updated early to new patch_level=0x%08x\n&quot;,</span>
<span class="p_add">+			ucode_new_rev);</span>
<span class="p_add">+</span>
<span class="p_add">+	eax   = cpuid_eax(0x00000001);</span>
<span class="p_add">+	eax   = ((eax &gt;&gt; 8) &amp; 0xf) + ((eax &gt;&gt; 20) &amp; 0xff);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = load_microcode_amd(smp_processor_id(), eax, container, container_size);</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		retval = -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This will be freed any msec now, stash patches for the current</span>
<span class="p_add">+	 * family and switch to patch cache for cpu hotplug, etc later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	container = NULL;</span>
<span class="p_add">+	container_size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return retval;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void reload_ucode_amd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_amd *mc;</span>
<span class="p_add">+	u32 rev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * early==false because this is a syscore -&gt;resume path and by</span>
<span class="p_add">+	 * that time paging is long enabled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (check_current_patch_level(&amp;rev, false))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc = (struct microcode_amd *)amd_ucode_patch;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mc &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_add">+		if (!__apply_microcode_amd(mc)) {</span>
<span class="p_add">+			ucode_new_rev = mc-&gt;hdr.patch_id;</span>
<span class="p_add">+			pr_info(&quot;microcode: reload patch_level=0x%08x\n&quot;,</span>
<span class="p_add">+				ucode_new_rev);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 static u16 __find_equiv_id(unsigned int cpu)
 {
 	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
<span class="p_chunk">@@ -435,7 +871,7 @@</span> <span class="p_context"> enum ucode_state load_microcode_amd(int cpu, u8 family, const u8 *data, size_t s</span>
 	if (ret != UCODE_OK)
 		cleanup();
 
<span class="p_del">-#if defined(CONFIG_MICROCODE_AMD_EARLY) &amp;&amp; defined(CONFIG_X86_32)</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
 	/* save BSP&#39;s matching patch for early load */
 	if (cpu_data(cpu).cpu_index == boot_cpu_data.cpu_index) {
 		struct ucode_patch *p = find_patch(cpu);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/amd_early.c b/arch/x86/kernel/cpu/microcode/amd_early.c</span>
deleted file mode 100644
<span class="p_header">index a54a47b9d8ea..000000000000</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/amd_early.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,444 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Copyright (C) 2013 Advanced Micro Devices, Inc.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Author: Jacob Shin &lt;jacob.shin@amd.com&gt;</span>
<span class="p_del">- * Fixes: Borislav Petkov &lt;bp@suse.de&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_del">- * published by the Free Software Foundation.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/earlycpio.h&gt;</span>
<span class="p_del">-#include &lt;linux/initrd.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/cpu.h&gt;</span>
<span class="p_del">-#include &lt;asm/setup.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode_amd.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This points to the current valid container of microcode patches which we will</span>
<span class="p_del">- * save from the initrd before jettisoning its contents.</span>
<span class="p_del">- */</span>
<span class="p_del">-static u8 *container;</span>
<span class="p_del">-static size_t container_size;</span>
<span class="p_del">-</span>
<span class="p_del">-static u32 ucode_new_rev;</span>
<span class="p_del">-u8 amd_ucode_patch[PATCH_MAX_SIZE];</span>
<span class="p_del">-static u16 this_equiv_id;</span>
<span class="p_del">-</span>
<span class="p_del">-static struct cpio_data ucode_cpio;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Microcode patch container file is prepended to the initrd in cpio format.</span>
<span class="p_del">- * See Documentation/x86/early-microcode.txt</span>
<span class="p_del">- */</span>
<span class="p_del">-static __initdata char ucode_path[] = &quot;kernel/x86/microcode/AuthenticAMD.bin&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-static struct cpio_data __init find_ucode_in_initrd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	long offset = 0;</span>
<span class="p_del">-	char *path;</span>
<span class="p_del">-	void *start;</span>
<span class="p_del">-	size_t size;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	struct boot_params *p;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * On 32-bit, early load occurs before paging is turned on so we need</span>
<span class="p_del">-	 * to use physical addresses.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	p       = (struct boot_params *)__pa_nodebug(&amp;boot_params);</span>
<span class="p_del">-	path    = (char *)__pa_nodebug(ucode_path);</span>
<span class="p_del">-	start   = (void *)p-&gt;hdr.ramdisk_image;</span>
<span class="p_del">-	size    = p-&gt;hdr.ramdisk_size;</span>
<span class="p_del">-#else</span>
<span class="p_del">-	path    = ucode_path;</span>
<span class="p_del">-	start   = (void *)(boot_params.hdr.ramdisk_image + PAGE_OFFSET);</span>
<span class="p_del">-	size    = boot_params.hdr.ramdisk_size;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	return find_cpio_data(path, start, size, &amp;offset);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static size_t compute_container_size(u8 *data, u32 total_size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	size_t size = 0;</span>
<span class="p_del">-	u32 *header = (u32 *)data;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (header[0] != UCODE_MAGIC ||</span>
<span class="p_del">-	    header[1] != UCODE_EQUIV_CPU_TABLE_TYPE || /* type */</span>
<span class="p_del">-	    header[2] == 0)                            /* size */</span>
<span class="p_del">-		return size;</span>
<span class="p_del">-</span>
<span class="p_del">-	size = header[2] + CONTAINER_HDR_SZ;</span>
<span class="p_del">-	total_size -= size;</span>
<span class="p_del">-	data += size;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (total_size) {</span>
<span class="p_del">-		u16 patch_size;</span>
<span class="p_del">-</span>
<span class="p_del">-		header = (u32 *)data;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (header[0] != UCODE_UCODE_TYPE)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Sanity-check patch size.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		patch_size = header[1];</span>
<span class="p_del">-		if (patch_size &gt; PATCH_MAX_SIZE)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		size	   += patch_size + SECTION_HDR_SIZE;</span>
<span class="p_del">-		data	   += patch_size + SECTION_HDR_SIZE;</span>
<span class="p_del">-		total_size -= patch_size + SECTION_HDR_SIZE;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return size;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Early load occurs before we can vmalloc(). So we look for the microcode</span>
<span class="p_del">- * patch container file in initrd, traverse equivalent cpu table, look for a</span>
<span class="p_del">- * matching microcode patch, and update, all in initrd memory in place.</span>
<span class="p_del">- * When vmalloc() is available for use later -- on 64-bit during first AP load,</span>
<span class="p_del">- * and on 32-bit during save_microcode_in_initrd_amd() -- we can call</span>
<span class="p_del">- * load_microcode_amd() to save equivalent cpu table and microcode patches in</span>
<span class="p_del">- * kernel heap memory.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void apply_ucode_in_initrd(void *ucode, size_t size, bool save_patch)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct equiv_cpu_entry *eq;</span>
<span class="p_del">-	size_t *cont_sz;</span>
<span class="p_del">-	u32 *header;</span>
<span class="p_del">-	u8  *data, **cont;</span>
<span class="p_del">-	u8 (*patch)[PATCH_MAX_SIZE];</span>
<span class="p_del">-	u16 eq_id = 0;</span>
<span class="p_del">-	int offset, left;</span>
<span class="p_del">-	u32 rev, eax, ebx, ecx, edx;</span>
<span class="p_del">-	u32 *new_rev;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	new_rev = (u32 *)__pa_nodebug(&amp;ucode_new_rev);</span>
<span class="p_del">-	cont_sz = (size_t *)__pa_nodebug(&amp;container_size);</span>
<span class="p_del">-	cont	= (u8 **)__pa_nodebug(&amp;container);</span>
<span class="p_del">-	patch	= (u8 (*)[PATCH_MAX_SIZE])__pa_nodebug(&amp;amd_ucode_patch);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	new_rev = &amp;ucode_new_rev;</span>
<span class="p_del">-	cont_sz = &amp;container_size;</span>
<span class="p_del">-	cont	= &amp;container;</span>
<span class="p_del">-	patch	= &amp;amd_ucode_patch;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	data   = ucode;</span>
<span class="p_del">-	left   = size;</span>
<span class="p_del">-	header = (u32 *)data;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* find equiv cpu table */</span>
<span class="p_del">-	if (header[0] != UCODE_MAGIC ||</span>
<span class="p_del">-	    header[1] != UCODE_EQUIV_CPU_TABLE_TYPE || /* type */</span>
<span class="p_del">-	    header[2] == 0)                            /* size */</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	eax = 0x00000001;</span>
<span class="p_del">-	ecx = 0;</span>
<span class="p_del">-	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-</span>
<span class="p_del">-	while (left &gt; 0) {</span>
<span class="p_del">-		eq = (struct equiv_cpu_entry *)(data + CONTAINER_HDR_SZ);</span>
<span class="p_del">-</span>
<span class="p_del">-		*cont = data;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Advance past the container header */</span>
<span class="p_del">-		offset = header[2] + CONTAINER_HDR_SZ;</span>
<span class="p_del">-		data  += offset;</span>
<span class="p_del">-		left  -= offset;</span>
<span class="p_del">-</span>
<span class="p_del">-		eq_id = find_equiv_id(eq, eax);</span>
<span class="p_del">-		if (eq_id) {</span>
<span class="p_del">-			this_equiv_id = eq_id;</span>
<span class="p_del">-			*cont_sz = compute_container_size(*cont, left + offset);</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * truncate how much we need to iterate over in the</span>
<span class="p_del">-			 * ucode update loop below</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			left = *cont_sz - offset;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * support multiple container files appended together. if this</span>
<span class="p_del">-		 * one does not have a matching equivalent cpu entry, we fast</span>
<span class="p_del">-		 * forward to the next container file.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		while (left &gt; 0) {</span>
<span class="p_del">-			header = (u32 *)data;</span>
<span class="p_del">-			if (header[0] == UCODE_MAGIC &amp;&amp;</span>
<span class="p_del">-			    header[1] == UCODE_EQUIV_CPU_TABLE_TYPE)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-</span>
<span class="p_del">-			offset = header[1] + SECTION_HDR_SIZE;</span>
<span class="p_del">-			data  += offset;</span>
<span class="p_del">-			left  -= offset;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* mark where the next microcode container file starts */</span>
<span class="p_del">-		offset    = data - (u8 *)ucode;</span>
<span class="p_del">-		ucode     = data;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!eq_id) {</span>
<span class="p_del">-		*cont = NULL;</span>
<span class="p_del">-		*cont_sz = 0;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (check_current_patch_level(&amp;rev, true))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (left &gt; 0) {</span>
<span class="p_del">-		struct microcode_amd *mc;</span>
<span class="p_del">-</span>
<span class="p_del">-		header = (u32 *)data;</span>
<span class="p_del">-		if (header[0] != UCODE_UCODE_TYPE || /* type */</span>
<span class="p_del">-		    header[1] == 0)                  /* size */</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		mc = (struct microcode_amd *)(data + SECTION_HDR_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (eq_id == mc-&gt;hdr.processor_rev_id &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!__apply_microcode_amd(mc)) {</span>
<span class="p_del">-				rev = mc-&gt;hdr.patch_id;</span>
<span class="p_del">-				*new_rev = rev;</span>
<span class="p_del">-</span>
<span class="p_del">-				if (save_patch)</span>
<span class="p_del">-					memcpy(patch, mc,</span>
<span class="p_del">-					       min_t(u32, header[1], PATCH_MAX_SIZE));</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		offset  = header[1] + SECTION_HDR_SIZE;</span>
<span class="p_del">-		data   += offset;</span>
<span class="p_del">-		left   -= offset;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool __init load_builtin_amd_microcode(struct cpio_data *cp,</span>
<span class="p_del">-					      unsigned int family)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	char fw_name[36] = &quot;amd-ucode/microcode_amd.bin&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (family &gt;= 0x15)</span>
<span class="p_del">-		snprintf(fw_name, sizeof(fw_name),</span>
<span class="p_del">-			 &quot;amd-ucode/microcode_amd_fam%.2xh.bin&quot;, family);</span>
<span class="p_del">-</span>
<span class="p_del">-	return get_builtin_firmware(cp, fw_name);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init load_ucode_amd_bsp(unsigned int family)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cpio_data cp;</span>
<span class="p_del">-	void **data;</span>
<span class="p_del">-	size_t *size;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	data =  (void **)__pa_nodebug(&amp;ucode_cpio.data);</span>
<span class="p_del">-	size = (size_t *)__pa_nodebug(&amp;ucode_cpio.size);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	data = &amp;ucode_cpio.data;</span>
<span class="p_del">-	size = &amp;ucode_cpio.size;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	cp = find_ucode_in_initrd();</span>
<span class="p_del">-	if (!cp.data) {</span>
<span class="p_del">-		if (!load_builtin_amd_microcode(&amp;cp, family))</span>
<span class="p_del">-			return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	*data = cp.data;</span>
<span class="p_del">-	*size = cp.size;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_ucode_in_initrd(cp.data, cp.size, true);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-/*</span>
<span class="p_del">- * On 32-bit, since AP&#39;s early load occurs before paging is turned on, we</span>
<span class="p_del">- * cannot traverse cpu_equiv_table and pcache in kernel heap memory. So during</span>
<span class="p_del">- * cold boot, AP will apply_ucode_in_initrd() just like the BSP. During</span>
<span class="p_del">- * save_microcode_in_initrd_amd() BSP&#39;s patch is copied to amd_ucode_patch,</span>
<span class="p_del">- * which is used upon resume from suspend.</span>
<span class="p_del">- */</span>
<span class="p_del">-void load_ucode_amd_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_amd *mc;</span>
<span class="p_del">-	size_t *usize;</span>
<span class="p_del">-	void **ucode;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc = (struct microcode_amd *)__pa_nodebug(amd_ucode_patch);</span>
<span class="p_del">-	if (mc-&gt;hdr.patch_id &amp;&amp; mc-&gt;hdr.processor_rev_id) {</span>
<span class="p_del">-		__apply_microcode_amd(mc);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ucode = (void *)__pa_nodebug(&amp;container);</span>
<span class="p_del">-	usize = (size_t *)__pa_nodebug(&amp;container_size);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!*ucode || !*usize)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_ucode_in_initrd(*ucode, *usize, false);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init collect_cpu_sig_on_bsp(void *arg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int cpu = smp_processor_id();</span>
<span class="p_del">-	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;</span>
<span class="p_del">-</span>
<span class="p_del">-	uci-&gt;cpu_sig.sig = cpuid_eax(0x00000001);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init get_bsp_sig(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int bsp = boot_cpu_data.cpu_index;</span>
<span class="p_del">-	struct ucode_cpu_info *uci = ucode_cpu_info + bsp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!uci-&gt;cpu_sig.sig)</span>
<span class="p_del">-		smp_call_function_single(bsp, collect_cpu_sig_on_bsp, NULL, 1);</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-void load_ucode_amd_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int cpu = smp_processor_id();</span>
<span class="p_del">-	struct equiv_cpu_entry *eq;</span>
<span class="p_del">-	struct microcode_amd *mc;</span>
<span class="p_del">-	u32 rev, eax;</span>
<span class="p_del">-	u16 eq_id;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Exit if called on the BSP. */</span>
<span class="p_del">-	if (!cpu)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!container)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 64-bit runs with paging enabled, thus early==false.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (check_current_patch_level(&amp;rev, false))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	eax = cpuid_eax(0x00000001);</span>
<span class="p_del">-	eq  = (struct equiv_cpu_entry *)(container + CONTAINER_HDR_SZ);</span>
<span class="p_del">-</span>
<span class="p_del">-	eq_id = find_equiv_id(eq, eax);</span>
<span class="p_del">-	if (!eq_id)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (eq_id == this_equiv_id) {</span>
<span class="p_del">-		mc = (struct microcode_amd *)amd_ucode_patch;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mc &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_del">-			if (!__apply_microcode_amd(mc))</span>
<span class="p_del">-				ucode_new_rev = mc-&gt;hdr.patch_id;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (!ucode_cpio.data)</span>
<span class="p_del">-			return;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * AP has a different equivalence ID than BSP, looks like</span>
<span class="p_del">-		 * mixed-steppings silicon so go through the ucode blob anew.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		apply_ucode_in_initrd(ucode_cpio.data, ucode_cpio.size, false);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-int __init save_microcode_in_initrd_amd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long cont;</span>
<span class="p_del">-	int retval = 0;</span>
<span class="p_del">-	enum ucode_state ret;</span>
<span class="p_del">-	u8 *cont_va;</span>
<span class="p_del">-	u32 eax;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!container)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	get_bsp_sig();</span>
<span class="p_del">-	cont	= (unsigned long)container;</span>
<span class="p_del">-	cont_va = __va(container);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need the physical address of the container for both bitness since</span>
<span class="p_del">-	 * boot_params.hdr.ramdisk_image is a physical address.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cont    = __pa(container);</span>
<span class="p_del">-	cont_va = container;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Take into account the fact that the ramdisk might get relocated and</span>
<span class="p_del">-	 * therefore we need to recompute the container&#39;s position in virtual</span>
<span class="p_del">-	 * memory space.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (relocated_ramdisk)</span>
<span class="p_del">-		container = (u8 *)(__va(relocated_ramdisk) +</span>
<span class="p_del">-			     (cont - boot_params.hdr.ramdisk_image));</span>
<span class="p_del">-	else</span>
<span class="p_del">-		container = cont_va;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ucode_new_rev)</span>
<span class="p_del">-		pr_info(&quot;microcode: updated early to new patch_level=0x%08x\n&quot;,</span>
<span class="p_del">-			ucode_new_rev);</span>
<span class="p_del">-</span>
<span class="p_del">-	eax   = cpuid_eax(0x00000001);</span>
<span class="p_del">-	eax   = ((eax &gt;&gt; 8) &amp; 0xf) + ((eax &gt;&gt; 20) &amp; 0xff);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = load_microcode_amd(smp_processor_id(), eax, container, container_size);</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		retval = -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This will be freed any msec now, stash patches for the current</span>
<span class="p_del">-	 * family and switch to patch cache for cpu hotplug, etc later.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	container = NULL;</span>
<span class="p_del">-	container_size = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return retval;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void reload_ucode_amd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_amd *mc;</span>
<span class="p_del">-	u32 rev;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * early==false because this is a syscore -&gt;resume path and by</span>
<span class="p_del">-	 * that time paging is long enabled.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (check_current_patch_level(&amp;rev, false))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc = (struct microcode_amd *)amd_ucode_patch;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mc &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_del">-		if (!__apply_microcode_amd(mc)) {</span>
<span class="p_del">-			ucode_new_rev = mc-&gt;hdr.patch_id;</span>
<span class="p_del">-			pr_info(&quot;microcode: reload patch_level=0x%08x\n&quot;,</span>
<span class="p_del">-				ucode_new_rev);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/core.c b/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_header">index 15491dd3131e..18848c7de058 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_chunk">@@ -5,6 +5,12 @@</span> <span class="p_context"></span>
  *	      2006	Shaohua Li &lt;shaohua.li@intel.com&gt;
  *	      2013-2015	Borislav Petkov &lt;bp@alien8.de&gt;
  *
<span class="p_add">+ * X86 CPU microcode early update for Linux:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Copyright (C) 2012 Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="p_add">+ *			   H Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="p_add">+ *		  (C) 2015 Borislav Petkov &lt;bp@alien8.de&gt;</span>
<span class="p_add">+ *</span>
  * This driver allows to upgrade microcode on x86 processors.
  *
  * This program is free software; you can redistribute it and/or
<span class="p_chunk">@@ -16,20 +22,24 @@</span> <span class="p_context"></span>
 #define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt
 
 #include &lt;linux/platform_device.h&gt;
<span class="p_add">+#include &lt;linux/syscore_ops.h&gt;</span>
 #include &lt;linux/miscdevice.h&gt;
 #include &lt;linux/capability.h&gt;
<span class="p_add">+#include &lt;linux/firmware.h&gt;</span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/cpu.h&gt;
 #include &lt;linux/fs.h&gt;
 #include &lt;linux/mm.h&gt;
<span class="p_del">-#include &lt;linux/syscore_ops.h&gt;</span>
 
<span class="p_del">-#include &lt;asm/microcode.h&gt;</span>
<span class="p_del">-#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/microcode_intel.h&gt;</span>
 #include &lt;asm/cpu_device_id.h&gt;
<span class="p_add">+#include &lt;asm/microcode_amd.h&gt;</span>
 #include &lt;asm/perf_event.h&gt;
<span class="p_add">+#include &lt;asm/microcode.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/cmdline.h&gt;</span>
 
 MODULE_DESCRIPTION(&quot;Microcode Update Driver&quot;);
 MODULE_AUTHOR(&quot;Tigran Aivazian &lt;tigran@aivazian.fsnet.co.uk&gt;&quot;);
<span class="p_chunk">@@ -68,6 +78,150 @@</span> <span class="p_context"> struct cpu_info_ctx {</span>
 	int			err;
 };
 
<span class="p_add">+static bool __init check_loader_disabled_bsp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	const char *cmdline = (const char *)__pa_nodebug(boot_command_line);</span>
<span class="p_add">+	const char *opt	    = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_add">+	const char *option  = (const char *)__pa_nodebug(opt);</span>
<span class="p_add">+	bool *res = (bool *)__pa_nodebug(&amp;dis_ucode_ldr);</span>
<span class="p_add">+</span>
<span class="p_add">+#else /* CONFIG_X86_64 */</span>
<span class="p_add">+	const char *cmdline = boot_command_line;</span>
<span class="p_add">+	const char *option  = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_add">+	bool *res = &amp;dis_ucode_ldr;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cmdline_find_option_bool(cmdline, option))</span>
<span class="p_add">+		*res = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return *res;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct builtin_fw __start_builtin_fw[];</span>
<span class="p_add">+extern struct builtin_fw __end_builtin_fw[];</span>
<span class="p_add">+</span>
<span class="p_add">+bool get_builtin_firmware(struct cpio_data *cd, const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_FW_LOADER</span>
<span class="p_add">+	struct builtin_fw *b_fw;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++) {</span>
<span class="p_add">+		if (!strcmp(name, b_fw-&gt;name)) {</span>
<span class="p_add">+			cd-&gt;size = b_fw-&gt;size;</span>
<span class="p_add">+			cd-&gt;data = b_fw-&gt;data;</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init load_ucode_bsp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int vendor;</span>
<span class="p_add">+	unsigned int family;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (check_loader_disabled_bsp())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!have_cpuid_p())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	vendor = x86_vendor();</span>
<span class="p_add">+	family = x86_family();</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (vendor) {</span>
<span class="p_add">+	case X86_VENDOR_INTEL:</span>
<span class="p_add">+		if (family &gt;= 6)</span>
<span class="p_add">+			load_ucode_intel_bsp();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case X86_VENDOR_AMD:</span>
<span class="p_add">+		if (family &gt;= 0x10)</span>
<span class="p_add">+			load_ucode_amd_bsp(family);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool check_loader_disabled_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	return *((bool *)__pa_nodebug(&amp;dis_ucode_ldr));</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return dis_ucode_ldr;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void load_ucode_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int vendor, family;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (check_loader_disabled_ap())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!have_cpuid_p())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	vendor = x86_vendor();</span>
<span class="p_add">+	family = x86_family();</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (vendor) {</span>
<span class="p_add">+	case X86_VENDOR_INTEL:</span>
<span class="p_add">+		if (family &gt;= 6)</span>
<span class="p_add">+			load_ucode_intel_ap();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case X86_VENDOR_AMD:</span>
<span class="p_add">+		if (family &gt;= 0x10)</span>
<span class="p_add">+			load_ucode_amd_ap();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int __init save_microcode_in_initrd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpuinfo_x86 *c = &amp;boot_cpu_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (c-&gt;x86_vendor) {</span>
<span class="p_add">+	case X86_VENDOR_INTEL:</span>
<span class="p_add">+		if (c-&gt;x86 &gt;= 6)</span>
<span class="p_add">+			save_microcode_in_initrd_intel();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case X86_VENDOR_AMD:</span>
<span class="p_add">+		if (c-&gt;x86 &gt;= 0x10)</span>
<span class="p_add">+			save_microcode_in_initrd_amd();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void reload_early_microcode(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int vendor, family;</span>
<span class="p_add">+</span>
<span class="p_add">+	vendor = x86_vendor();</span>
<span class="p_add">+	family = x86_family();</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (vendor) {</span>
<span class="p_add">+	case X86_VENDOR_INTEL:</span>
<span class="p_add">+		if (family &gt;= 6)</span>
<span class="p_add">+			reload_ucode_intel();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case X86_VENDOR_AMD:</span>
<span class="p_add">+		if (family &gt;= 0x10)</span>
<span class="p_add">+			reload_ucode_amd();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void collect_cpu_info_local(void *arg)
 {
 	struct cpu_info_ctx *ctx = arg;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/core_early.c b/arch/x86/kernel/cpu/microcode/core_early.c</span>
deleted file mode 100644
<span class="p_header">index 8ebc421d6299..000000000000</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/core_early.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,170 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- *	X86 CPU microcode early update for Linux</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Copyright (C) 2012 Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="p_del">- *			   H Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="p_del">- *		  (C) 2015 Borislav Petkov &lt;bp@alien8.de&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- *	This driver allows to early upgrade microcode on Intel processors</span>
<span class="p_del">- *	belonging to IA-32 family - PentiumPro, Pentium II,</span>
<span class="p_del">- *	Pentium III, Xeon, Pentium 4, etc.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Reference: Section 9.11 of Volume 3, IA-32 Intel Architecture</span>
<span class="p_del">- *	Software Developer&#39;s Manual.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	This program is free software; you can redistribute it and/or</span>
<span class="p_del">- *	modify it under the terms of the GNU General Public License</span>
<span class="p_del">- *	as published by the Free Software Foundation; either version</span>
<span class="p_del">- *	2 of the License, or (at your option) any later version.</span>
<span class="p_del">- */</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
<span class="p_del">-#include &lt;linux/firmware.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode_intel.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode_amd.h&gt;</span>
<span class="p_del">-#include &lt;asm/processor.h&gt;</span>
<span class="p_del">-#include &lt;asm/cmdline.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-static bool __init check_loader_disabled_bsp(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	const char *cmdline = (const char *)__pa_nodebug(boot_command_line);</span>
<span class="p_del">-	const char *opt	    = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_del">-	const char *option  = (const char *)__pa_nodebug(opt);</span>
<span class="p_del">-	bool *res = (bool *)__pa_nodebug(&amp;dis_ucode_ldr);</span>
<span class="p_del">-</span>
<span class="p_del">-#else /* CONFIG_X86_64 */</span>
<span class="p_del">-	const char *cmdline = boot_command_line;</span>
<span class="p_del">-	const char *option  = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_del">-	bool *res = &amp;dis_ucode_ldr;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmdline_find_option_bool(cmdline, option))</span>
<span class="p_del">-		*res = true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return *res;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-extern struct builtin_fw __start_builtin_fw[];</span>
<span class="p_del">-extern struct builtin_fw __end_builtin_fw[];</span>
<span class="p_del">-</span>
<span class="p_del">-bool get_builtin_firmware(struct cpio_data *cd, const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_FW_LOADER</span>
<span class="p_del">-	struct builtin_fw *b_fw;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++) {</span>
<span class="p_del">-		if (!strcmp(name, b_fw-&gt;name)) {</span>
<span class="p_del">-			cd-&gt;size = b_fw-&gt;size;</span>
<span class="p_del">-			cd-&gt;data = b_fw-&gt;data;</span>
<span class="p_del">-			return true;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init load_ucode_bsp(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int vendor;</span>
<span class="p_del">-	unsigned int family;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (check_loader_disabled_bsp())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!have_cpuid_p())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	vendor = x86_vendor();</span>
<span class="p_del">-	family = x86_family();</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (vendor) {</span>
<span class="p_del">-	case X86_VENDOR_INTEL:</span>
<span class="p_del">-		if (family &gt;= 6)</span>
<span class="p_del">-			load_ucode_intel_bsp();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case X86_VENDOR_AMD:</span>
<span class="p_del">-		if (family &gt;= 0x10)</span>
<span class="p_del">-			load_ucode_amd_bsp(family);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool check_loader_disabled_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	return *((bool *)__pa_nodebug(&amp;dis_ucode_ldr));</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return dis_ucode_ldr;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void load_ucode_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int vendor, family;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (check_loader_disabled_ap())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!have_cpuid_p())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	vendor = x86_vendor();</span>
<span class="p_del">-	family = x86_family();</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (vendor) {</span>
<span class="p_del">-	case X86_VENDOR_INTEL:</span>
<span class="p_del">-		if (family &gt;= 6)</span>
<span class="p_del">-			load_ucode_intel_ap();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case X86_VENDOR_AMD:</span>
<span class="p_del">-		if (family &gt;= 0x10)</span>
<span class="p_del">-			load_ucode_amd_ap();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int __init save_microcode_in_initrd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cpuinfo_x86 *c = &amp;boot_cpu_data;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (c-&gt;x86_vendor) {</span>
<span class="p_del">-	case X86_VENDOR_INTEL:</span>
<span class="p_del">-		if (c-&gt;x86 &gt;= 6)</span>
<span class="p_del">-			save_microcode_in_initrd_intel();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case X86_VENDOR_AMD:</span>
<span class="p_del">-		if (c-&gt;x86 &gt;= 0x10)</span>
<span class="p_del">-			save_microcode_in_initrd_amd();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void reload_early_microcode(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int vendor, family;</span>
<span class="p_del">-</span>
<span class="p_del">-	vendor = x86_vendor();</span>
<span class="p_del">-	family = x86_family();</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (vendor) {</span>
<span class="p_del">-	case X86_VENDOR_INTEL:</span>
<span class="p_del">-		if (family &gt;= 6)</span>
<span class="p_del">-			reload_ucode_intel();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case X86_VENDOR_AMD:</span>
<span class="p_del">-		if (family &gt;= 0x10)</span>
<span class="p_del">-			reload_ucode_amd();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">index bfd6fcd242ea..2e09171e5338 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_chunk">@@ -4,28 +4,814 @@</span> <span class="p_context"></span>
  * Copyright (C) 2000-2006 Tigran Aivazian &lt;tigran@aivazian.fsnet.co.uk&gt;
  *		 2006 Shaohua Li &lt;shaohua.li@intel.com&gt;
  *
<span class="p_add">+ * Intel CPU microcode early update for Linux</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="p_add">+ *		      H Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="p_add">+ *</span>
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
  */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * This needs to be before all headers so that pr_debug in printk.h doesn&#39;t turn</span>
<span class="p_add">+ * printk calls into no_printk().</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *#define DEBUG</span>
<span class="p_add">+ */</span>
 #define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt
 
<span class="p_add">+#include &lt;linux/earlycpio.h&gt;</span>
 #include &lt;linux/firmware.h&gt;
 #include &lt;linux/uaccess.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/module.h&gt;
<span class="p_del">-#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
 
 #include &lt;asm/microcode_intel.h&gt;
 #include &lt;asm/processor.h&gt;
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
 #include &lt;asm/msr.h&gt;
 
 MODULE_DESCRIPTION(&quot;Microcode Update Driver&quot;);
 MODULE_AUTHOR(&quot;Tigran Aivazian &lt;tigran@aivazian.fsnet.co.uk&gt;&quot;);
 MODULE_LICENSE(&quot;GPL&quot;);
 
<span class="p_add">+static unsigned long mc_saved_in_initrd[MAX_UCODE_COUNT];</span>
<span class="p_add">+static struct mc_saved_data {</span>
<span class="p_add">+	unsigned int mc_saved_count;</span>
<span class="p_add">+	struct microcode_intel **mc_saved;</span>
<span class="p_add">+} mc_saved_data;</span>
<span class="p_add">+</span>
<span class="p_add">+static enum ucode_state</span>
<span class="p_add">+load_microcode_early(struct microcode_intel **saved,</span>
<span class="p_add">+		     unsigned int num_saved, struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *ucode_ptr, *new_mc = NULL;</span>
<span class="p_add">+	struct microcode_header_intel *mc_hdr;</span>
<span class="p_add">+	int new_rev, ret, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_rev = uci-&gt;cpu_sig.rev;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_saved; i++) {</span>
<span class="p_add">+		ucode_ptr = saved[i];</span>
<span class="p_add">+		mc_hdr	  = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = has_newer_microcode(ucode_ptr,</span>
<span class="p_add">+					  uci-&gt;cpu_sig.sig,</span>
<span class="p_add">+					  uci-&gt;cpu_sig.pf,</span>
<span class="p_add">+					  new_rev);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		new_rev = mc_hdr-&gt;rev;</span>
<span class="p_add">+		new_mc  = ucode_ptr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!new_mc)</span>
<span class="p_add">+		return UCODE_NFOUND;</span>
<span class="p_add">+</span>
<span class="p_add">+	uci-&gt;mc = (struct microcode_intel *)new_mc;</span>
<span class="p_add">+	return UCODE_OK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+copy_initrd_ptrs(struct microcode_intel **mc_saved, unsigned long *initrd,</span>
<span class="p_add">+		  unsigned long off, int num_saved)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_saved; i++)</span>
<span class="p_add">+		mc_saved[i] = (struct microcode_intel *)(initrd[i] + off);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+static void</span>
<span class="p_add">+microcode_phys(struct microcode_intel **mc_saved_tmp,</span>
<span class="p_add">+	       struct mc_saved_data *mc_saved_data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	struct microcode_intel ***mc_saved;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_saved = (struct microcode_intel ***)</span>
<span class="p_add">+		   __pa_nodebug(&amp;mc_saved_data-&gt;mc_saved);</span>
<span class="p_add">+	for (i = 0; i &lt; mc_saved_data-&gt;mc_saved_count; i++) {</span>
<span class="p_add">+		struct microcode_intel *p;</span>
<span class="p_add">+</span>
<span class="p_add">+		p = *(struct microcode_intel **)</span>
<span class="p_add">+			__pa_nodebug(mc_saved_data-&gt;mc_saved + i);</span>
<span class="p_add">+		mc_saved_tmp[i] = (struct microcode_intel *)__pa_nodebug(p);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static enum ucode_state</span>
<span class="p_add">+load_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_add">+	       unsigned long initrd_start, struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_add">+	unsigned int count = mc_saved_data-&gt;mc_saved_count;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mc_saved_data-&gt;mc_saved) {</span>
<span class="p_add">+		copy_initrd_ptrs(mc_saved_tmp, initrd, initrd_start, count);</span>
<span class="p_add">+</span>
<span class="p_add">+		return load_microcode_early(mc_saved_tmp, count, uci);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+		microcode_phys(mc_saved_tmp, mc_saved_data);</span>
<span class="p_add">+		return load_microcode_early(mc_saved_tmp, count, uci);</span>
<span class="p_add">+#else</span>
<span class="p_add">+		return load_microcode_early(mc_saved_data-&gt;mc_saved,</span>
<span class="p_add">+						    count, uci);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Given CPU signature and a microcode patch, this function finds if the</span>
<span class="p_add">+ * microcode patch has matching family and model with the CPU.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static enum ucode_state</span>
<span class="p_add">+matching_model_microcode(struct microcode_header_intel *mc_header,</span>
<span class="p_add">+			unsigned long sig)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int fam, model;</span>
<span class="p_add">+	unsigned int fam_ucode, model_ucode;</span>
<span class="p_add">+	struct extended_sigtable *ext_header;</span>
<span class="p_add">+	unsigned long total_size = get_totalsize(mc_header);</span>
<span class="p_add">+	unsigned long data_size = get_datasize(mc_header);</span>
<span class="p_add">+	int ext_sigcount, i;</span>
<span class="p_add">+	struct extended_signature *ext_sig;</span>
<span class="p_add">+</span>
<span class="p_add">+	fam   = __x86_family(sig);</span>
<span class="p_add">+	model = x86_model(sig);</span>
<span class="p_add">+</span>
<span class="p_add">+	fam_ucode   = __x86_family(mc_header-&gt;sig);</span>
<span class="p_add">+	model_ucode = x86_model(mc_header-&gt;sig);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fam == fam_ucode &amp;&amp; model == model_ucode)</span>
<span class="p_add">+		return UCODE_OK;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Look for ext. headers: */</span>
<span class="p_add">+	if (total_size &lt;= data_size + MC_HEADER_SIZE)</span>
<span class="p_add">+		return UCODE_NFOUND;</span>
<span class="p_add">+</span>
<span class="p_add">+	ext_header   = (void *) mc_header + data_size + MC_HEADER_SIZE;</span>
<span class="p_add">+	ext_sig      = (void *)ext_header + EXT_HEADER_SIZE;</span>
<span class="p_add">+	ext_sigcount = ext_header-&gt;count;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ext_sigcount; i++) {</span>
<span class="p_add">+		fam_ucode   = __x86_family(ext_sig-&gt;sig);</span>
<span class="p_add">+		model_ucode = x86_model(ext_sig-&gt;sig);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (fam == fam_ucode &amp;&amp; model == model_ucode)</span>
<span class="p_add">+			return UCODE_OK;</span>
<span class="p_add">+</span>
<span class="p_add">+		ext_sig++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return UCODE_NFOUND;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+save_microcode(struct mc_saved_data *mc_saved_data,</span>
<span class="p_add">+	       struct microcode_intel **mc_saved_src,</span>
<span class="p_add">+	       unsigned int mc_saved_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i, j;</span>
<span class="p_add">+	struct microcode_intel **saved_ptr;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mc_saved_count)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Copy new microcode data.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	saved_ptr = kcalloc(mc_saved_count, sizeof(struct microcode_intel *), GFP_KERNEL);</span>
<span class="p_add">+	if (!saved_ptr)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; mc_saved_count; i++) {</span>
<span class="p_add">+		struct microcode_header_intel *mc_hdr;</span>
<span class="p_add">+		struct microcode_intel *mc;</span>
<span class="p_add">+		unsigned long size;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!mc_saved_src[i]) {</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mc     = mc_saved_src[i];</span>
<span class="p_add">+		mc_hdr = &amp;mc-&gt;hdr;</span>
<span class="p_add">+		size   = get_totalsize(mc_hdr);</span>
<span class="p_add">+</span>
<span class="p_add">+		saved_ptr[i] = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+		if (!saved_ptr[i]) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		memcpy(saved_ptr[i], mc, size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Point to newly saved microcode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mc_saved_data-&gt;mc_saved = saved_ptr;</span>
<span class="p_add">+	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	for (j = 0; j &lt;= i; j++)</span>
<span class="p_add">+		kfree(saved_ptr[j]);</span>
<span class="p_add">+	kfree(saved_ptr);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * A microcode patch in ucode_ptr is saved into mc_saved</span>
<span class="p_add">+ * - if it has matching signature and newer revision compared to an existing</span>
<span class="p_add">+ *   patch mc_saved.</span>
<span class="p_add">+ * - or if it is a newly discovered microcode patch.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The microcode patch should have matching model with CPU.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns: The updated number @num_saved of saved microcode patches.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned int _save_mc(struct microcode_intel **mc_saved,</span>
<span class="p_add">+			     u8 *ucode_ptr, unsigned int num_saved)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_header_intel *mc_hdr, *mc_saved_hdr;</span>
<span class="p_add">+	unsigned int sig, pf;</span>
<span class="p_add">+	int found = 0, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_hdr = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_saved; i++) {</span>
<span class="p_add">+		mc_saved_hdr = (struct microcode_header_intel *)mc_saved[i];</span>
<span class="p_add">+		sig	     = mc_saved_hdr-&gt;sig;</span>
<span class="p_add">+		pf	     = mc_saved_hdr-&gt;pf;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!find_matching_signature(ucode_ptr, sig, pf))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		found = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (mc_hdr-&gt;rev &lt;= mc_saved_hdr-&gt;rev)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Found an older ucode saved earlier. Replace it with</span>
<span class="p_add">+		 * this newer one.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mc_saved[i] = (struct microcode_intel *)ucode_ptr;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Newly detected microcode, save it to memory. */</span>
<span class="p_add">+	if (i &gt;= num_saved &amp;&amp; !found)</span>
<span class="p_add">+		mc_saved[num_saved++] = (struct microcode_intel *)ucode_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	return num_saved;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Get microcode matching with BSP&#39;s model. Only CPUs with the same model as</span>
<span class="p_add">+ * BSP can stay in the platform.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static enum ucode_state __init</span>
<span class="p_add">+get_matching_model_microcode(int cpu, unsigned long start,</span>
<span class="p_add">+			     void *data, size_t size,</span>
<span class="p_add">+			     struct mc_saved_data *mc_saved_data,</span>
<span class="p_add">+			     unsigned long *mc_saved_in_initrd,</span>
<span class="p_add">+			     struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *ucode_ptr = data;</span>
<span class="p_add">+	unsigned int leftover = size;</span>
<span class="p_add">+	enum ucode_state state = UCODE_OK;</span>
<span class="p_add">+	unsigned int mc_size;</span>
<span class="p_add">+	struct microcode_header_intel *mc_header;</span>
<span class="p_add">+	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_add">+	unsigned int mc_saved_count = mc_saved_data-&gt;mc_saved_count;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (leftover &amp;&amp; mc_saved_count &lt; ARRAY_SIZE(mc_saved_tmp)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (leftover &lt; sizeof(mc_header))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		mc_header = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+		mc_size = get_totalsize(mc_header);</span>
<span class="p_add">+		if (!mc_size || mc_size &gt; leftover ||</span>
<span class="p_add">+			microcode_sanity_check(ucode_ptr, 0) &lt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		leftover -= mc_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Since APs with same family and model as the BSP may boot in</span>
<span class="p_add">+		 * the platform, we need to find and save microcode patches</span>
<span class="p_add">+		 * with the same family and model as the BSP.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (matching_model_microcode(mc_header, uci-&gt;cpu_sig.sig) !=</span>
<span class="p_add">+			 UCODE_OK) {</span>
<span class="p_add">+			ucode_ptr += mc_size;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mc_saved_count = _save_mc(mc_saved_tmp, ucode_ptr, mc_saved_count);</span>
<span class="p_add">+</span>
<span class="p_add">+		ucode_ptr += mc_size;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (leftover) {</span>
<span class="p_add">+		state = UCODE_ERROR;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mc_saved_count == 0) {</span>
<span class="p_add">+		state = UCODE_NFOUND;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; mc_saved_count; i++)</span>
<span class="p_add">+		mc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return state;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int collect_cpu_info_early(struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int val[2];</span>
<span class="p_add">+	unsigned int family, model;</span>
<span class="p_add">+	struct cpu_signature csig;</span>
<span class="p_add">+	unsigned int eax, ebx, ecx, edx;</span>
<span class="p_add">+</span>
<span class="p_add">+	csig.sig = 0;</span>
<span class="p_add">+	csig.pf = 0;</span>
<span class="p_add">+	csig.rev = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(uci, 0, sizeof(*uci));</span>
<span class="p_add">+</span>
<span class="p_add">+	eax = 0x00000001;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	csig.sig = eax;</span>
<span class="p_add">+</span>
<span class="p_add">+	family = __x86_family(csig.sig);</span>
<span class="p_add">+	model  = x86_model(csig.sig);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((model &gt;= 5) || (family &gt; 6)) {</span>
<span class="p_add">+		/* get processor flags from MSR 0x17 */</span>
<span class="p_add">+		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);</span>
<span class="p_add">+		csig.pf = 1 &lt;&lt; ((val[1] &gt;&gt; 18) &amp; 7);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_add">+	sync_core();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get the current revision from MSR 0x8B */</span>
<span class="p_add">+	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_add">+</span>
<span class="p_add">+	csig.rev = val[1];</span>
<span class="p_add">+</span>
<span class="p_add">+	uci-&gt;cpu_sig = csig;</span>
<span class="p_add">+	uci-&gt;valid = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef DEBUG</span>
<span class="p_add">+static void show_saved_mc(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i, j;</span>
<span class="p_add">+	unsigned int sig, pf, rev, total_size, data_size, date;</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mc_saved_data.mc_saved_count == 0) {</span>
<span class="p_add">+		pr_debug(&quot;no microcode data saved.\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pr_debug(&quot;Total microcode saved: %d\n&quot;, mc_saved_data.mc_saved_count);</span>
<span class="p_add">+</span>
<span class="p_add">+	collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+</span>
<span class="p_add">+	sig = uci.cpu_sig.sig;</span>
<span class="p_add">+	pf = uci.cpu_sig.pf;</span>
<span class="p_add">+	rev = uci.cpu_sig.rev;</span>
<span class="p_add">+	pr_debug(&quot;CPU: sig=0x%x, pf=0x%x, rev=0x%x\n&quot;, sig, pf, rev);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; mc_saved_data.mc_saved_count; i++) {</span>
<span class="p_add">+		struct microcode_header_intel *mc_saved_header;</span>
<span class="p_add">+		struct extended_sigtable *ext_header;</span>
<span class="p_add">+		int ext_sigcount;</span>
<span class="p_add">+		struct extended_signature *ext_sig;</span>
<span class="p_add">+</span>
<span class="p_add">+		mc_saved_header = (struct microcode_header_intel *)</span>
<span class="p_add">+				  mc_saved_data.mc_saved[i];</span>
<span class="p_add">+		sig = mc_saved_header-&gt;sig;</span>
<span class="p_add">+		pf = mc_saved_header-&gt;pf;</span>
<span class="p_add">+		rev = mc_saved_header-&gt;rev;</span>
<span class="p_add">+		total_size = get_totalsize(mc_saved_header);</span>
<span class="p_add">+		data_size = get_datasize(mc_saved_header);</span>
<span class="p_add">+		date = mc_saved_header-&gt;date;</span>
<span class="p_add">+</span>
<span class="p_add">+		pr_debug(&quot;mc_saved[%d]: sig=0x%x, pf=0x%x, rev=0x%x, toal size=0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_add">+			 i, sig, pf, rev, total_size,</span>
<span class="p_add">+			 date &amp; 0xffff,</span>
<span class="p_add">+			 date &gt;&gt; 24,</span>
<span class="p_add">+			 (date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Look for ext. headers: */</span>
<span class="p_add">+		if (total_size &lt;= data_size + MC_HEADER_SIZE)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		ext_header = (void *) mc_saved_header + data_size + MC_HEADER_SIZE;</span>
<span class="p_add">+		ext_sigcount = ext_header-&gt;count;</span>
<span class="p_add">+		ext_sig = (void *)ext_header + EXT_HEADER_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (j = 0; j &lt; ext_sigcount; j++) {</span>
<span class="p_add">+			sig = ext_sig-&gt;sig;</span>
<span class="p_add">+			pf = ext_sig-&gt;pf;</span>
<span class="p_add">+</span>
<span class="p_add">+			pr_debug(&quot;\tExtended[%d]: sig=0x%x, pf=0x%x\n&quot;,</span>
<span class="p_add">+				 j, sig, pf);</span>
<span class="p_add">+</span>
<span class="p_add">+			ext_sig++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline void show_saved_mc(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="p_add">+static DEFINE_MUTEX(x86_cpu_microcode_mutex);</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Save this mc into mc_saved_data. So it will be loaded early when a CPU is</span>
<span class="p_add">+ * hot added or resumes.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Please make sure this mc should be a valid microcode patch before calling</span>
<span class="p_add">+ * this function.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int save_mc_for_early(u8 *mc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_add">+	unsigned int mc_saved_count_init;</span>
<span class="p_add">+	unsigned int mc_saved_count;</span>
<span class="p_add">+	struct microcode_intel **mc_saved;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Hold hotplug lock so mc_saved_data is not accessed by a CPU in</span>
<span class="p_add">+	 * hotplug.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock(&amp;x86_cpu_microcode_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_saved_count_init = mc_saved_data.mc_saved_count;</span>
<span class="p_add">+	mc_saved_count = mc_saved_data.mc_saved_count;</span>
<span class="p_add">+	mc_saved = mc_saved_data.mc_saved;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mc_saved &amp;&amp; mc_saved_count)</span>
<span class="p_add">+		memcpy(mc_saved_tmp, mc_saved,</span>
<span class="p_add">+		       mc_saved_count * sizeof(struct microcode_intel *));</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Save the microcode patch mc in mc_save_tmp structure if it&#39;s a newer</span>
<span class="p_add">+	 * version.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mc_saved_count = _save_mc(mc_saved_tmp, mc, mc_saved_count);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Save the mc_save_tmp in global mc_saved_data.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = save_microcode(&amp;mc_saved_data, mc_saved_tmp, mc_saved_count);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;Cannot save microcode patch.\n&quot;);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	show_saved_mc();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Free old saved microcode data.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mc_saved) {</span>
<span class="p_add">+		for (i = 0; i &lt; mc_saved_count_init; i++)</span>
<span class="p_add">+			kfree(mc_saved[i]);</span>
<span class="p_add">+		kfree(mc_saved);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;x86_cpu_microcode_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(save_mc_for_early);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static bool __init load_builtin_intel_microcode(struct cpio_data *cp)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	unsigned int eax = 0x00000001, ebx, ecx = 0, edx;</span>
<span class="p_add">+	unsigned int family, model, stepping;</span>
<span class="p_add">+	char name[30];</span>
<span class="p_add">+</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+</span>
<span class="p_add">+	family   = __x86_family(eax);</span>
<span class="p_add">+	model    = x86_model(eax);</span>
<span class="p_add">+	stepping = eax &amp; 0xf;</span>
<span class="p_add">+</span>
<span class="p_add">+	sprintf(name, &quot;intel-ucode/%02x-%02x-%02x&quot;, family, model, stepping);</span>
<span class="p_add">+</span>
<span class="p_add">+	return get_builtin_firmware(cp, name);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static __initdata char ucode_name[] = &quot;kernel/x86/microcode/GenuineIntel.bin&quot;;</span>
<span class="p_add">+static __init enum ucode_state</span>
<span class="p_add">+scan_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_add">+	       unsigned long start, unsigned long size,</span>
<span class="p_add">+	       struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpio_data cd;</span>
<span class="p_add">+	long offset = 0;</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	char *p = (char *)__pa_nodebug(ucode_name);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	char *p = ucode_name;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	cd.data = NULL;</span>
<span class="p_add">+	cd.size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	cd = find_cpio_data(p, (void *)start, size, &amp;offset);</span>
<span class="p_add">+	if (!cd.data) {</span>
<span class="p_add">+		if (!load_builtin_intel_microcode(&amp;cd))</span>
<span class="p_add">+			return UCODE_ERROR;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return get_matching_model_microcode(0, start, cd.data, cd.size,</span>
<span class="p_add">+					    mc_saved_data, initrd, uci);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Print ucode update info.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void</span>
<span class="p_add">+print_ucode_info(struct ucode_cpu_info *uci, unsigned int date)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu = smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;CPU%d microcode updated early to revision 0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_add">+		cpu,</span>
<span class="p_add">+		uci-&gt;cpu_sig.rev,</span>
<span class="p_add">+		date &amp; 0xffff,</span>
<span class="p_add">+		date &gt;&gt; 24,</span>
<span class="p_add">+		(date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+</span>
<span class="p_add">+static int delay_ucode_info;</span>
<span class="p_add">+static int current_mc_date;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Print early updated ucode info after printk works. This is delayed info dump.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void show_ucode_info_early(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (delay_ucode_info) {</span>
<span class="p_add">+		collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+		print_ucode_info(&amp;uci, current_mc_date);</span>
<span class="p_add">+		delay_ucode_info = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * At this point, we can not call printk() yet. Keep microcode patch number in</span>
<span class="p_add">+ * mc_saved_data.mc_saved and delay printing microcode info in</span>
<span class="p_add">+ * show_ucode_info_early() until printk() works.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void print_ucode(struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_intel;</span>
<span class="p_add">+	int *delay_ucode_info_p;</span>
<span class="p_add">+	int *current_mc_date_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_intel = uci-&gt;mc;</span>
<span class="p_add">+	if (mc_intel == NULL)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	delay_ucode_info_p = (int *)__pa_nodebug(&amp;delay_ucode_info);</span>
<span class="p_add">+	current_mc_date_p = (int *)__pa_nodebug(&amp;current_mc_date);</span>
<span class="p_add">+</span>
<span class="p_add">+	*delay_ucode_info_p = 1;</span>
<span class="p_add">+	*current_mc_date_p = mc_intel-&gt;hdr.date;</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Flush global tlb. We only do this in x86_64 where paging has been enabled</span>
<span class="p_add">+ * already and PGE should be enabled as well.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void flush_tlb_early(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__native_flush_tlb_global_irq_disabled();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void print_ucode(struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_intel;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_intel = uci-&gt;mc;</span>
<span class="p_add">+	if (mc_intel == NULL)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_microcode_early(struct ucode_cpu_info *uci, bool early)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_intel;</span>
<span class="p_add">+	unsigned int val[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_intel = uci-&gt;mc;</span>
<span class="p_add">+	if (mc_intel == NULL)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* write microcode via MSR 0x79 */</span>
<span class="p_add">+	native_wrmsr(MSR_IA32_UCODE_WRITE,</span>
<span class="p_add">+	      (unsigned long) mc_intel-&gt;bits,</span>
<span class="p_add">+	      (unsigned long) mc_intel-&gt;bits &gt;&gt; 16 &gt;&gt; 16);</span>
<span class="p_add">+	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_add">+	sync_core();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get the current revision from MSR 0x8B */</span>
<span class="p_add">+	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_add">+	if (val[1] != mc_intel-&gt;hdr.rev)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	/* Flush global tlb. This is precaution. */</span>
<span class="p_add">+	flush_tlb_early();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	uci-&gt;cpu_sig.rev = val[1];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (early)</span>
<span class="p_add">+		print_ucode(uci);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This function converts microcode patch offsets previously stored in</span>
<span class="p_add">+ * mc_saved_in_initrd to pointers and stores the pointers in mc_saved_data.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __init save_microcode_in_initrd_intel(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int count = mc_saved_data.mc_saved_count;</span>
<span class="p_add">+	struct microcode_intel *mc_saved[MAX_UCODE_COUNT];</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (count == 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	copy_initrd_ptrs(mc_saved, mc_saved_in_initrd, initrd_start, count);</span>
<span class="p_add">+	ret = save_microcode(&amp;mc_saved_data, mc_saved, count);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		pr_err(&quot;Cannot save microcode patches from initrd.\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	show_saved_mc();</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init</span>
<span class="p_add">+_load_ucode_intel_bsp(struct mc_saved_data *mc_saved_data,</span>
<span class="p_add">+		      unsigned long *initrd,</span>
<span class="p_add">+		      unsigned long start, unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+	enum ucode_state ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = scan_microcode(mc_saved_data, initrd, start, size, &amp;uci);</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = load_microcode(mc_saved_data, initrd, start, &amp;uci);</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_microcode_early(&amp;uci, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init load_ucode_intel_bsp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 start, size;</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	struct boot_params *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	p	= (struct boot_params *)__pa_nodebug(&amp;boot_params);</span>
<span class="p_add">+	start	= p-&gt;hdr.ramdisk_image;</span>
<span class="p_add">+	size	= p-&gt;hdr.ramdisk_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	_load_ucode_intel_bsp(</span>
<span class="p_add">+			(struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data),</span>
<span class="p_add">+			(unsigned long *)__pa_nodebug(&amp;mc_saved_in_initrd),</span>
<span class="p_add">+			start, size);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	start	= boot_params.hdr.ramdisk_image + PAGE_OFFSET;</span>
<span class="p_add">+	size	= boot_params.hdr.ramdisk_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	_load_ucode_intel_bsp(&amp;mc_saved_data, mc_saved_in_initrd, start, size);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void load_ucode_intel_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mc_saved_data *mc_saved_data_p;</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+	unsigned long *mc_saved_in_initrd_p;</span>
<span class="p_add">+	unsigned long initrd_start_addr;</span>
<span class="p_add">+	enum ucode_state ret;</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	unsigned long *initrd_start_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_saved_in_initrd_p =</span>
<span class="p_add">+		(unsigned long *)__pa_nodebug(mc_saved_in_initrd);</span>
<span class="p_add">+	mc_saved_data_p = (struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data);</span>
<span class="p_add">+	initrd_start_p = (unsigned long *)__pa_nodebug(&amp;initrd_start);</span>
<span class="p_add">+	initrd_start_addr = (unsigned long)__pa_nodebug(*initrd_start_p);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	mc_saved_data_p = &amp;mc_saved_data;</span>
<span class="p_add">+	mc_saved_in_initrd_p = mc_saved_in_initrd;</span>
<span class="p_add">+	initrd_start_addr = initrd_start;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If there is no valid ucode previously saved in memory, no need to</span>
<span class="p_add">+	 * update ucode on this AP.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mc_saved_data_p-&gt;mc_saved_count == 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+	ret = load_microcode(mc_saved_data_p, mc_saved_in_initrd_p,</span>
<span class="p_add">+			     initrd_start_addr, &amp;uci);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_microcode_early(&amp;uci, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void reload_ucode_intel(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+	enum ucode_state ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mc_saved_data.mc_saved_count)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = load_microcode_early(mc_saved_data.mc_saved,</span>
<span class="p_add">+				   mc_saved_data.mc_saved_count, &amp;uci);</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_microcode_early(&amp;uci, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int collect_cpu_info(int cpu_num, struct cpu_signature *csig)
 {
 	struct cpuinfo_x86 *c = &amp;cpu_data(cpu_num);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel_early.c b/arch/x86/kernel/cpu/microcode/intel_early.c</span>
deleted file mode 100644
<span class="p_header">index 37ea89c11520..000000000000</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel_early.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,808 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- *	Intel CPU microcode early update for Linux</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Copyright (C) 2012 Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="p_del">- *			   H Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- *	This allows to early upgrade microcode on Intel processors</span>
<span class="p_del">- *	belonging to IA-32 family - PentiumPro, Pentium II,</span>
<span class="p_del">- *	Pentium III, Xeon, Pentium 4, etc.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Reference: Section 9.11 of Volume 3, IA-32 Intel Architecture</span>
<span class="p_del">- *	Software Developer&#39;s Manual.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	This program is free software; you can redistribute it and/or</span>
<span class="p_del">- *	modify it under the terms of the GNU General Public License</span>
<span class="p_del">- *	as published by the Free Software Foundation; either version</span>
<span class="p_del">- *	2 of the License, or (at your option) any later version.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This needs to be before all headers so that pr_debug in printk.h doesn&#39;t turn</span>
<span class="p_del">- * printk calls into no_printk().</span>
<span class="p_del">- *</span>
<span class="p_del">- *#define DEBUG</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
<span class="p_del">-#include &lt;linux/mm.h&gt;</span>
<span class="p_del">-#include &lt;linux/slab.h&gt;</span>
<span class="p_del">-#include &lt;linux/earlycpio.h&gt;</span>
<span class="p_del">-#include &lt;linux/initrd.h&gt;</span>
<span class="p_del">-#include &lt;linux/cpu.h&gt;</span>
<span class="p_del">-#include &lt;asm/msr.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode_intel.h&gt;</span>
<span class="p_del">-#include &lt;asm/processor.h&gt;</span>
<span class="p_del">-#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_del">-#include &lt;asm/setup.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#undef pr_fmt</span>
<span class="p_del">-#define pr_fmt(fmt)	&quot;microcode: &quot; fmt</span>
<span class="p_del">-</span>
<span class="p_del">-static unsigned long mc_saved_in_initrd[MAX_UCODE_COUNT];</span>
<span class="p_del">-static struct mc_saved_data {</span>
<span class="p_del">-	unsigned int mc_saved_count;</span>
<span class="p_del">-	struct microcode_intel **mc_saved;</span>
<span class="p_del">-} mc_saved_data;</span>
<span class="p_del">-</span>
<span class="p_del">-static enum ucode_state</span>
<span class="p_del">-load_microcode_early(struct microcode_intel **saved,</span>
<span class="p_del">-		     unsigned int num_saved, struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *ucode_ptr, *new_mc = NULL;</span>
<span class="p_del">-	struct microcode_header_intel *mc_hdr;</span>
<span class="p_del">-	int new_rev, ret, i;</span>
<span class="p_del">-</span>
<span class="p_del">-	new_rev = uci-&gt;cpu_sig.rev;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; num_saved; i++) {</span>
<span class="p_del">-		ucode_ptr = saved[i];</span>
<span class="p_del">-		mc_hdr	  = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = has_newer_microcode(ucode_ptr,</span>
<span class="p_del">-					  uci-&gt;cpu_sig.sig,</span>
<span class="p_del">-					  uci-&gt;cpu_sig.pf,</span>
<span class="p_del">-					  new_rev);</span>
<span class="p_del">-		if (!ret)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		new_rev = mc_hdr-&gt;rev;</span>
<span class="p_del">-		new_mc  = ucode_ptr;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!new_mc)</span>
<span class="p_del">-		return UCODE_NFOUND;</span>
<span class="p_del">-</span>
<span class="p_del">-	uci-&gt;mc = (struct microcode_intel *)new_mc;</span>
<span class="p_del">-	return UCODE_OK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void</span>
<span class="p_del">-copy_initrd_ptrs(struct microcode_intel **mc_saved, unsigned long *initrd,</span>
<span class="p_del">-		  unsigned long off, int num_saved)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; num_saved; i++)</span>
<span class="p_del">-		mc_saved[i] = (struct microcode_intel *)(initrd[i] + off);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-static void</span>
<span class="p_del">-microcode_phys(struct microcode_intel **mc_saved_tmp,</span>
<span class="p_del">-	       struct mc_saved_data *mc_saved_data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-	struct microcode_intel ***mc_saved;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_saved = (struct microcode_intel ***)</span>
<span class="p_del">-		   __pa_nodebug(&amp;mc_saved_data-&gt;mc_saved);</span>
<span class="p_del">-	for (i = 0; i &lt; mc_saved_data-&gt;mc_saved_count; i++) {</span>
<span class="p_del">-		struct microcode_intel *p;</span>
<span class="p_del">-</span>
<span class="p_del">-		p = *(struct microcode_intel **)</span>
<span class="p_del">-			__pa_nodebug(mc_saved_data-&gt;mc_saved + i);</span>
<span class="p_del">-		mc_saved_tmp[i] = (struct microcode_intel *)__pa_nodebug(p);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static enum ucode_state</span>
<span class="p_del">-load_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_del">-	       unsigned long initrd_start, struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_del">-	unsigned int count = mc_saved_data-&gt;mc_saved_count;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!mc_saved_data-&gt;mc_saved) {</span>
<span class="p_del">-		copy_initrd_ptrs(mc_saved_tmp, initrd, initrd_start, count);</span>
<span class="p_del">-</span>
<span class="p_del">-		return load_microcode_early(mc_saved_tmp, count, uci);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-		microcode_phys(mc_saved_tmp, mc_saved_data);</span>
<span class="p_del">-		return load_microcode_early(mc_saved_tmp, count, uci);</span>
<span class="p_del">-#else</span>
<span class="p_del">-		return load_microcode_early(mc_saved_data-&gt;mc_saved,</span>
<span class="p_del">-						    count, uci);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Given CPU signature and a microcode patch, this function finds if the</span>
<span class="p_del">- * microcode patch has matching family and model with the CPU.</span>
<span class="p_del">- */</span>
<span class="p_del">-static enum ucode_state</span>
<span class="p_del">-matching_model_microcode(struct microcode_header_intel *mc_header,</span>
<span class="p_del">-			unsigned long sig)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int fam, model;</span>
<span class="p_del">-	unsigned int fam_ucode, model_ucode;</span>
<span class="p_del">-	struct extended_sigtable *ext_header;</span>
<span class="p_del">-	unsigned long total_size = get_totalsize(mc_header);</span>
<span class="p_del">-	unsigned long data_size = get_datasize(mc_header);</span>
<span class="p_del">-	int ext_sigcount, i;</span>
<span class="p_del">-	struct extended_signature *ext_sig;</span>
<span class="p_del">-</span>
<span class="p_del">-	fam   = __x86_family(sig);</span>
<span class="p_del">-	model = x86_model(sig);</span>
<span class="p_del">-</span>
<span class="p_del">-	fam_ucode   = __x86_family(mc_header-&gt;sig);</span>
<span class="p_del">-	model_ucode = x86_model(mc_header-&gt;sig);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (fam == fam_ucode &amp;&amp; model == model_ucode)</span>
<span class="p_del">-		return UCODE_OK;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Look for ext. headers: */</span>
<span class="p_del">-	if (total_size &lt;= data_size + MC_HEADER_SIZE)</span>
<span class="p_del">-		return UCODE_NFOUND;</span>
<span class="p_del">-</span>
<span class="p_del">-	ext_header   = (void *) mc_header + data_size + MC_HEADER_SIZE;</span>
<span class="p_del">-	ext_sig      = (void *)ext_header + EXT_HEADER_SIZE;</span>
<span class="p_del">-	ext_sigcount = ext_header-&gt;count;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; ext_sigcount; i++) {</span>
<span class="p_del">-		fam_ucode   = __x86_family(ext_sig-&gt;sig);</span>
<span class="p_del">-		model_ucode = x86_model(ext_sig-&gt;sig);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (fam == fam_ucode &amp;&amp; model == model_ucode)</span>
<span class="p_del">-			return UCODE_OK;</span>
<span class="p_del">-</span>
<span class="p_del">-		ext_sig++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return UCODE_NFOUND;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int</span>
<span class="p_del">-save_microcode(struct mc_saved_data *mc_saved_data,</span>
<span class="p_del">-	       struct microcode_intel **mc_saved_src,</span>
<span class="p_del">-	       unsigned int mc_saved_count)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i, j;</span>
<span class="p_del">-	struct microcode_intel **saved_ptr;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!mc_saved_count)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Copy new microcode data.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	saved_ptr = kcalloc(mc_saved_count, sizeof(struct microcode_intel *), GFP_KERNEL);</span>
<span class="p_del">-	if (!saved_ptr)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; mc_saved_count; i++) {</span>
<span class="p_del">-		struct microcode_header_intel *mc_hdr;</span>
<span class="p_del">-		struct microcode_intel *mc;</span>
<span class="p_del">-		unsigned long size;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!mc_saved_src[i]) {</span>
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			goto err;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		mc     = mc_saved_src[i];</span>
<span class="p_del">-		mc_hdr = &amp;mc-&gt;hdr;</span>
<span class="p_del">-		size   = get_totalsize(mc_hdr);</span>
<span class="p_del">-</span>
<span class="p_del">-		saved_ptr[i] = kmalloc(size, GFP_KERNEL);</span>
<span class="p_del">-		if (!saved_ptr[i]) {</span>
<span class="p_del">-			ret = -ENOMEM;</span>
<span class="p_del">-			goto err;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		memcpy(saved_ptr[i], mc, size);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Point to newly saved microcode.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mc_saved_data-&gt;mc_saved = saved_ptr;</span>
<span class="p_del">-	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-err:</span>
<span class="p_del">-	for (j = 0; j &lt;= i; j++)</span>
<span class="p_del">-		kfree(saved_ptr[j]);</span>
<span class="p_del">-	kfree(saved_ptr);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * A microcode patch in ucode_ptr is saved into mc_saved</span>
<span class="p_del">- * - if it has matching signature and newer revision compared to an existing</span>
<span class="p_del">- *   patch mc_saved.</span>
<span class="p_del">- * - or if it is a newly discovered microcode patch.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The microcode patch should have matching model with CPU.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Returns: The updated number @num_saved of saved microcode patches.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned int _save_mc(struct microcode_intel **mc_saved,</span>
<span class="p_del">-			     u8 *ucode_ptr, unsigned int num_saved)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_header_intel *mc_hdr, *mc_saved_hdr;</span>
<span class="p_del">-	unsigned int sig, pf;</span>
<span class="p_del">-	int found = 0, i;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_hdr = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; num_saved; i++) {</span>
<span class="p_del">-		mc_saved_hdr = (struct microcode_header_intel *)mc_saved[i];</span>
<span class="p_del">-		sig	     = mc_saved_hdr-&gt;sig;</span>
<span class="p_del">-		pf	     = mc_saved_hdr-&gt;pf;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!find_matching_signature(ucode_ptr, sig, pf))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		found = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mc_hdr-&gt;rev &lt;= mc_saved_hdr-&gt;rev)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Found an older ucode saved earlier. Replace it with</span>
<span class="p_del">-		 * this newer one.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		mc_saved[i] = (struct microcode_intel *)ucode_ptr;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Newly detected microcode, save it to memory. */</span>
<span class="p_del">-	if (i &gt;= num_saved &amp;&amp; !found)</span>
<span class="p_del">-		mc_saved[num_saved++] = (struct microcode_intel *)ucode_ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-	return num_saved;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Get microcode matching with BSP&#39;s model. Only CPUs with the same model as</span>
<span class="p_del">- * BSP can stay in the platform.</span>
<span class="p_del">- */</span>
<span class="p_del">-static enum ucode_state __init</span>
<span class="p_del">-get_matching_model_microcode(int cpu, unsigned long start,</span>
<span class="p_del">-			     void *data, size_t size,</span>
<span class="p_del">-			     struct mc_saved_data *mc_saved_data,</span>
<span class="p_del">-			     unsigned long *mc_saved_in_initrd,</span>
<span class="p_del">-			     struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 *ucode_ptr = data;</span>
<span class="p_del">-	unsigned int leftover = size;</span>
<span class="p_del">-	enum ucode_state state = UCODE_OK;</span>
<span class="p_del">-	unsigned int mc_size;</span>
<span class="p_del">-	struct microcode_header_intel *mc_header;</span>
<span class="p_del">-	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_del">-	unsigned int mc_saved_count = mc_saved_data-&gt;mc_saved_count;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (leftover &amp;&amp; mc_saved_count &lt; ARRAY_SIZE(mc_saved_tmp)) {</span>
<span class="p_del">-</span>
<span class="p_del">-		if (leftover &lt; sizeof(mc_header))</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		mc_header = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-		mc_size = get_totalsize(mc_header);</span>
<span class="p_del">-		if (!mc_size || mc_size &gt; leftover ||</span>
<span class="p_del">-			microcode_sanity_check(ucode_ptr, 0) &lt; 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		leftover -= mc_size;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Since APs with same family and model as the BSP may boot in</span>
<span class="p_del">-		 * the platform, we need to find and save microcode patches</span>
<span class="p_del">-		 * with the same family and model as the BSP.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (matching_model_microcode(mc_header, uci-&gt;cpu_sig.sig) !=</span>
<span class="p_del">-			 UCODE_OK) {</span>
<span class="p_del">-			ucode_ptr += mc_size;</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		mc_saved_count = _save_mc(mc_saved_tmp, ucode_ptr, mc_saved_count);</span>
<span class="p_del">-</span>
<span class="p_del">-		ucode_ptr += mc_size;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (leftover) {</span>
<span class="p_del">-		state = UCODE_ERROR;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mc_saved_count == 0) {</span>
<span class="p_del">-		state = UCODE_NFOUND;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; mc_saved_count; i++)</span>
<span class="p_del">-		mc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return state;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int collect_cpu_info_early(struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int val[2];</span>
<span class="p_del">-	unsigned int family, model;</span>
<span class="p_del">-	struct cpu_signature csig;</span>
<span class="p_del">-	unsigned int eax, ebx, ecx, edx;</span>
<span class="p_del">-</span>
<span class="p_del">-	csig.sig = 0;</span>
<span class="p_del">-	csig.pf = 0;</span>
<span class="p_del">-	csig.rev = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(uci, 0, sizeof(*uci));</span>
<span class="p_del">-</span>
<span class="p_del">-	eax = 0x00000001;</span>
<span class="p_del">-	ecx = 0;</span>
<span class="p_del">-	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-	csig.sig = eax;</span>
<span class="p_del">-</span>
<span class="p_del">-	family = __x86_family(csig.sig);</span>
<span class="p_del">-	model  = x86_model(csig.sig);</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((model &gt;= 5) || (family &gt; 6)) {</span>
<span class="p_del">-		/* get processor flags from MSR 0x17 */</span>
<span class="p_del">-		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);</span>
<span class="p_del">-		csig.pf = 1 &lt;&lt; ((val[1] &gt;&gt; 18) &amp; 7);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_del">-	sync_core();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* get the current revision from MSR 0x8B */</span>
<span class="p_del">-	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_del">-</span>
<span class="p_del">-	csig.rev = val[1];</span>
<span class="p_del">-</span>
<span class="p_del">-	uci-&gt;cpu_sig = csig;</span>
<span class="p_del">-	uci-&gt;valid = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef DEBUG</span>
<span class="p_del">-static void show_saved_mc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i, j;</span>
<span class="p_del">-	unsigned int sig, pf, rev, total_size, data_size, date;</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mc_saved_data.mc_saved_count == 0) {</span>
<span class="p_del">-		pr_debug(&quot;no microcode data saved.\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	pr_debug(&quot;Total microcode saved: %d\n&quot;, mc_saved_data.mc_saved_count);</span>
<span class="p_del">-</span>
<span class="p_del">-	collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-</span>
<span class="p_del">-	sig = uci.cpu_sig.sig;</span>
<span class="p_del">-	pf = uci.cpu_sig.pf;</span>
<span class="p_del">-	rev = uci.cpu_sig.rev;</span>
<span class="p_del">-	pr_debug(&quot;CPU: sig=0x%x, pf=0x%x, rev=0x%x\n&quot;, sig, pf, rev);</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; mc_saved_data.mc_saved_count; i++) {</span>
<span class="p_del">-		struct microcode_header_intel *mc_saved_header;</span>
<span class="p_del">-		struct extended_sigtable *ext_header;</span>
<span class="p_del">-		int ext_sigcount;</span>
<span class="p_del">-		struct extended_signature *ext_sig;</span>
<span class="p_del">-</span>
<span class="p_del">-		mc_saved_header = (struct microcode_header_intel *)</span>
<span class="p_del">-				  mc_saved_data.mc_saved[i];</span>
<span class="p_del">-		sig = mc_saved_header-&gt;sig;</span>
<span class="p_del">-		pf = mc_saved_header-&gt;pf;</span>
<span class="p_del">-		rev = mc_saved_header-&gt;rev;</span>
<span class="p_del">-		total_size = get_totalsize(mc_saved_header);</span>
<span class="p_del">-		data_size = get_datasize(mc_saved_header);</span>
<span class="p_del">-		date = mc_saved_header-&gt;date;</span>
<span class="p_del">-</span>
<span class="p_del">-		pr_debug(&quot;mc_saved[%d]: sig=0x%x, pf=0x%x, rev=0x%x, toal size=0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_del">-			 i, sig, pf, rev, total_size,</span>
<span class="p_del">-			 date &amp; 0xffff,</span>
<span class="p_del">-			 date &gt;&gt; 24,</span>
<span class="p_del">-			 (date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Look for ext. headers: */</span>
<span class="p_del">-		if (total_size &lt;= data_size + MC_HEADER_SIZE)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		ext_header = (void *) mc_saved_header + data_size + MC_HEADER_SIZE;</span>
<span class="p_del">-		ext_sigcount = ext_header-&gt;count;</span>
<span class="p_del">-		ext_sig = (void *)ext_header + EXT_HEADER_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-		for (j = 0; j &lt; ext_sigcount; j++) {</span>
<span class="p_del">-			sig = ext_sig-&gt;sig;</span>
<span class="p_del">-			pf = ext_sig-&gt;pf;</span>
<span class="p_del">-</span>
<span class="p_del">-			pr_debug(&quot;\tExtended[%d]: sig=0x%x, pf=0x%x\n&quot;,</span>
<span class="p_del">-				 j, sig, pf);</span>
<span class="p_del">-</span>
<span class="p_del">-			ext_sig++;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-static inline void show_saved_mc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-#if defined(CONFIG_MICROCODE_INTEL_EARLY) &amp;&amp; defined(CONFIG_HOTPLUG_CPU)</span>
<span class="p_del">-static DEFINE_MUTEX(x86_cpu_microcode_mutex);</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Save this mc into mc_saved_data. So it will be loaded early when a CPU is</span>
<span class="p_del">- * hot added or resumes.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Please make sure this mc should be a valid microcode patch before calling</span>
<span class="p_del">- * this function.</span>
<span class="p_del">- */</span>
<span class="p_del">-int save_mc_for_early(u8 *mc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_del">-	unsigned int mc_saved_count_init;</span>
<span class="p_del">-	unsigned int mc_saved_count;</span>
<span class="p_del">-	struct microcode_intel **mc_saved;</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Hold hotplug lock so mc_saved_data is not accessed by a CPU in</span>
<span class="p_del">-	 * hotplug.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mutex_lock(&amp;x86_cpu_microcode_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_saved_count_init = mc_saved_data.mc_saved_count;</span>
<span class="p_del">-	mc_saved_count = mc_saved_data.mc_saved_count;</span>
<span class="p_del">-	mc_saved = mc_saved_data.mc_saved;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mc_saved &amp;&amp; mc_saved_count)</span>
<span class="p_del">-		memcpy(mc_saved_tmp, mc_saved,</span>
<span class="p_del">-		       mc_saved_count * sizeof(struct microcode_intel *));</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Save the microcode patch mc in mc_save_tmp structure if it&#39;s a newer</span>
<span class="p_del">-	 * version.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mc_saved_count = _save_mc(mc_saved_tmp, mc, mc_saved_count);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Save the mc_save_tmp in global mc_saved_data.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = save_microcode(&amp;mc_saved_data, mc_saved_tmp, mc_saved_count);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		pr_err(&quot;Cannot save microcode patch.\n&quot;);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	show_saved_mc();</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Free old saved microcode data.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mc_saved) {</span>
<span class="p_del">-		for (i = 0; i &lt; mc_saved_count_init; i++)</span>
<span class="p_del">-			kfree(mc_saved[i]);</span>
<span class="p_del">-		kfree(mc_saved);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	mutex_unlock(&amp;x86_cpu_microcode_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(save_mc_for_early);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static bool __init load_builtin_intel_microcode(struct cpio_data *cp)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	unsigned int eax = 0x00000001, ebx, ecx = 0, edx;</span>
<span class="p_del">-	unsigned int family, model, stepping;</span>
<span class="p_del">-	char name[30];</span>
<span class="p_del">-</span>
<span class="p_del">-	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-</span>
<span class="p_del">-	family   = __x86_family(eax);</span>
<span class="p_del">-	model    = x86_model(eax);</span>
<span class="p_del">-	stepping = eax &amp; 0xf;</span>
<span class="p_del">-</span>
<span class="p_del">-	sprintf(name, &quot;intel-ucode/%02x-%02x-%02x&quot;, family, model, stepping);</span>
<span class="p_del">-</span>
<span class="p_del">-	return get_builtin_firmware(cp, name);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static __initdata char ucode_name[] = &quot;kernel/x86/microcode/GenuineIntel.bin&quot;;</span>
<span class="p_del">-static __init enum ucode_state</span>
<span class="p_del">-scan_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_del">-	       unsigned long start, unsigned long size,</span>
<span class="p_del">-	       struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cpio_data cd;</span>
<span class="p_del">-	long offset = 0;</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	char *p = (char *)__pa_nodebug(ucode_name);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	char *p = ucode_name;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	cd.data = NULL;</span>
<span class="p_del">-	cd.size = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	cd = find_cpio_data(p, (void *)start, size, &amp;offset);</span>
<span class="p_del">-	if (!cd.data) {</span>
<span class="p_del">-		if (!load_builtin_intel_microcode(&amp;cd))</span>
<span class="p_del">-			return UCODE_ERROR;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return get_matching_model_microcode(0, start, cd.data, cd.size,</span>
<span class="p_del">-					    mc_saved_data, initrd, uci);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Print ucode update info.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void</span>
<span class="p_del">-print_ucode_info(struct ucode_cpu_info *uci, unsigned int date)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int cpu = smp_processor_id();</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_info(&quot;CPU%d microcode updated early to revision 0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_del">-		cpu,</span>
<span class="p_del">-		uci-&gt;cpu_sig.rev,</span>
<span class="p_del">-		date &amp; 0xffff,</span>
<span class="p_del">-		date &gt;&gt; 24,</span>
<span class="p_del">-		(date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-</span>
<span class="p_del">-static int delay_ucode_info;</span>
<span class="p_del">-static int current_mc_date;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Print early updated ucode info after printk works. This is delayed info dump.</span>
<span class="p_del">- */</span>
<span class="p_del">-void show_ucode_info_early(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (delay_ucode_info) {</span>
<span class="p_del">-		collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-		print_ucode_info(&amp;uci, current_mc_date);</span>
<span class="p_del">-		delay_ucode_info = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * At this point, we can not call printk() yet. Keep microcode patch number in</span>
<span class="p_del">- * mc_saved_data.mc_saved and delay printing microcode info in</span>
<span class="p_del">- * show_ucode_info_early() until printk() works.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void print_ucode(struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_del">-	int *delay_ucode_info_p;</span>
<span class="p_del">-	int *current_mc_date_p;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	delay_ucode_info_p = (int *)__pa_nodebug(&amp;delay_ucode_info);</span>
<span class="p_del">-	current_mc_date_p = (int *)__pa_nodebug(&amp;current_mc_date);</span>
<span class="p_del">-</span>
<span class="p_del">-	*delay_ucode_info_p = 1;</span>
<span class="p_del">-	*current_mc_date_p = mc_intel-&gt;hdr.date;</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Flush global tlb. We only do this in x86_64 where paging has been enabled</span>
<span class="p_del">- * already and PGE should be enabled as well.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void flush_tlb_early(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__native_flush_tlb_global_irq_disabled();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void print_ucode(struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static int apply_microcode_early(struct ucode_cpu_info *uci, bool early)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_del">-	unsigned int val[2];</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* write microcode via MSR 0x79 */</span>
<span class="p_del">-	native_wrmsr(MSR_IA32_UCODE_WRITE,</span>
<span class="p_del">-	      (unsigned long) mc_intel-&gt;bits,</span>
<span class="p_del">-	      (unsigned long) mc_intel-&gt;bits &gt;&gt; 16 &gt;&gt; 16);</span>
<span class="p_del">-	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_del">-	sync_core();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* get the current revision from MSR 0x8B */</span>
<span class="p_del">-	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_del">-	if (val[1] != mc_intel-&gt;hdr.rev)</span>
<span class="p_del">-		return -1;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	/* Flush global tlb. This is precaution. */</span>
<span class="p_del">-	flush_tlb_early();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	uci-&gt;cpu_sig.rev = val[1];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (early)</span>
<span class="p_del">-		print_ucode(uci);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This function converts microcode patch offsets previously stored in</span>
<span class="p_del">- * mc_saved_in_initrd to pointers and stores the pointers in mc_saved_data.</span>
<span class="p_del">- */</span>
<span class="p_del">-int __init save_microcode_in_initrd_intel(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int count = mc_saved_data.mc_saved_count;</span>
<span class="p_del">-	struct microcode_intel *mc_saved[MAX_UCODE_COUNT];</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (count == 0)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	copy_initrd_ptrs(mc_saved, mc_saved_in_initrd, initrd_start, count);</span>
<span class="p_del">-	ret = save_microcode(&amp;mc_saved_data, mc_saved, count);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		pr_err(&quot;Cannot save microcode patches from initrd.\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	show_saved_mc();</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init</span>
<span class="p_del">-_load_ucode_intel_bsp(struct mc_saved_data *mc_saved_data,</span>
<span class="p_del">-		      unsigned long *initrd,</span>
<span class="p_del">-		      unsigned long start, unsigned long size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-	enum ucode_state ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = scan_microcode(mc_saved_data, initrd, start, size, &amp;uci);</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = load_microcode(mc_saved_data, initrd, start, &amp;uci);</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_microcode_early(&amp;uci, true);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init load_ucode_intel_bsp(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u64 start, size;</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	struct boot_params *p;</span>
<span class="p_del">-</span>
<span class="p_del">-	p	= (struct boot_params *)__pa_nodebug(&amp;boot_params);</span>
<span class="p_del">-	start	= p-&gt;hdr.ramdisk_image;</span>
<span class="p_del">-	size	= p-&gt;hdr.ramdisk_size;</span>
<span class="p_del">-</span>
<span class="p_del">-	_load_ucode_intel_bsp(</span>
<span class="p_del">-			(struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data),</span>
<span class="p_del">-			(unsigned long *)__pa_nodebug(&amp;mc_saved_in_initrd),</span>
<span class="p_del">-			start, size);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	start	= boot_params.hdr.ramdisk_image + PAGE_OFFSET;</span>
<span class="p_del">-	size	= boot_params.hdr.ramdisk_size;</span>
<span class="p_del">-</span>
<span class="p_del">-	_load_ucode_intel_bsp(&amp;mc_saved_data, mc_saved_in_initrd, start, size);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void load_ucode_intel_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mc_saved_data *mc_saved_data_p;</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-	unsigned long *mc_saved_in_initrd_p;</span>
<span class="p_del">-	unsigned long initrd_start_addr;</span>
<span class="p_del">-	enum ucode_state ret;</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	unsigned long *initrd_start_p;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_saved_in_initrd_p =</span>
<span class="p_del">-		(unsigned long *)__pa_nodebug(mc_saved_in_initrd);</span>
<span class="p_del">-	mc_saved_data_p = (struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data);</span>
<span class="p_del">-	initrd_start_p = (unsigned long *)__pa_nodebug(&amp;initrd_start);</span>
<span class="p_del">-	initrd_start_addr = (unsigned long)__pa_nodebug(*initrd_start_p);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	mc_saved_data_p = &amp;mc_saved_data;</span>
<span class="p_del">-	mc_saved_in_initrd_p = mc_saved_in_initrd;</span>
<span class="p_del">-	initrd_start_addr = initrd_start;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If there is no valid ucode previously saved in memory, no need to</span>
<span class="p_del">-	 * update ucode on this AP.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mc_saved_data_p-&gt;mc_saved_count == 0)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-	ret = load_microcode(mc_saved_data_p, mc_saved_in_initrd_p,</span>
<span class="p_del">-			     initrd_start_addr, &amp;uci);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_microcode_early(&amp;uci, true);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void reload_ucode_intel(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-	enum ucode_state ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!mc_saved_data.mc_saved_count)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = load_microcode_early(mc_saved_data.mc_saved,</span>
<span class="p_del">-				   mc_saved_data.mc_saved_count, &amp;uci);</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_microcode_early(&amp;uci, false);</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S</span>
<span class="p_header">index 0e2d96ffd158..6bc9ae24b6d2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head_32.S</span>
<span class="p_header">+++ b/arch/x86/kernel/head_32.S</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> ENTRY(startup_32)</span>
 	movl %eax, pa(olpc_ofw_pgd)
 #endif
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_EARLY</span>
<span class="p_add">+#ifdef CONFIG_MICROCODE</span>
 	/* Early load ucode on BSP. */
 	call load_ucode_bsp
 #endif
<span class="p_chunk">@@ -311,12 +311,11 @@</span> <span class="p_context"> ENTRY(startup_32_smp)</span>
 	movl %eax,%ss
 	leal -__PAGE_OFFSET(%ecx),%esp
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_EARLY</span>
<span class="p_add">+#ifdef CONFIG_MICROCODE</span>
 	/* Early load ucode on AP. */
 	call load_ucode_ap
 #endif
 
<span class="p_del">-</span>
 default_entry:
 #define CR0_STATE	(X86_CR0_PE | X86_CR0_MP | X86_CR0_ET | \
 			 X86_CR0_NE | X86_CR0_WP | X86_CR0_AM | \
<span class="p_header">diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c</span>
<span class="p_header">index 1d8a83df153a..1f37cb2b56a9 100644</span>
<span class="p_header">--- a/arch/x86/mm/init.c</span>
<span class="p_header">+++ b/arch/x86/mm/init.c</span>
<span class="p_chunk">@@ -693,14 +693,12 @@</span> <span class="p_context"> void free_initmem(void)</span>
 #ifdef CONFIG_BLK_DEV_INITRD
 void __init free_initrd_mem(unsigned long start, unsigned long end)
 {
<span class="p_del">-#ifdef CONFIG_MICROCODE_EARLY</span>
 	/*
 	 * Remember, initrd memory may contain microcode or other useful things.
 	 * Before we lose initrd mem, we need to find a place to hold them
 	 * now that normal virtual memory is enabled.
 	 */
 	save_microcode_in_initrd();
<span class="p_del">-#endif</span>
 
 	/*
 	 * end could be not aligned, and We can not align that,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



