
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.69 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.69</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 14, 2017, 9:29 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171214092940.GB25475@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10111719/mbox/"
   >mbox</a>
|
   <a href="/patch/10111719/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10111719/">/patch/10111719/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	7CB42602B3 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 09:30:03 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 48D8329BAF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 09:30:03 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 3C3BC29BAC; Thu, 14 Dec 2017 09:30:03 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id BD56329BAC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 09:29:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751438AbdLNJ3s (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 14 Dec 2017 04:29:48 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:36356 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751121AbdLNJ3i (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 14 Dec 2017 04:29:38 -0500
Received: from localhost (LFbn-1-12262-44.w90-92.abo.wanadoo.fr
	[90.92.75.44])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 7ECC6AA6;
	Thu, 14 Dec 2017 09:29:36 +0000 (UTC)
Date: Thu, 14 Dec 2017 10:29:40 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.69
Message-ID: &lt;20171214092940.GB25475@kroah.com&gt;
References: &lt;20171214092932.GA25475@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171214092932.GA25475@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 14, 2017, 9:29 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/usb/usb-device.txt b/Documentation/devicetree/bindings/usb/usb-device.txt</span>
<span class="p_header">index 1c35e7b665e1..03ab8f5eab40 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/usb/usb-device.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/usb/usb-device.txt</span>
<span class="p_chunk">@@ -11,7 +11,7 @@</span> <span class="p_context"> Required properties:</span>
   be used, but a device adhering to this binding may leave out all except
   for usbVID,PID.
 - reg: the port number which this device is connecting to, the range
<span class="p_del">-  is 1-31.</span>
<span class="p_add">+  is 1-255.</span>
 
 Example:
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index dfe17af517b2..8f2819bf8135 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 68</span>
<span class="p_add">+SUBLEVEL = 69</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/include/asm/assembler.h b/arch/arm/include/asm/assembler.h</span>
<span class="p_header">index 68b06f9c65de..12f99fd2e3b2 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/assembler.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/assembler.h</span>
<span class="p_chunk">@@ -516,4 +516,22 @@</span> <span class="p_context"> THUMB(	orr	\reg , \reg , #PSR_T_BIT	)</span>
 #endif
 	.endm
 
<span class="p_add">+	.macro	bug, msg, line</span>
<span class="p_add">+#ifdef CONFIG_THUMB2_KERNEL</span>
<span class="p_add">+1:	.inst	0xde02</span>
<span class="p_add">+#else</span>
<span class="p_add">+1:	.inst	0xe7f001f2</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_DEBUG_BUGVERBOSE</span>
<span class="p_add">+	.pushsection .rodata.str, &quot;aMS&quot;, %progbits, 1</span>
<span class="p_add">+2:	.asciz	&quot;\msg&quot;</span>
<span class="p_add">+	.popsection</span>
<span class="p_add">+	.pushsection __bug_table, &quot;aw&quot;</span>
<span class="p_add">+	.align	2</span>
<span class="p_add">+	.word	1b, 2b</span>
<span class="p_add">+	.hword	\line</span>
<span class="p_add">+	.popsection</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
 #endif /* __ASM_ASSEMBLER_H__ */
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_arm.h b/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_header">index e22089fb44dc..98d6de177b7a 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_arm.h</span>
<span class="p_chunk">@@ -161,8 +161,7 @@</span> <span class="p_context"></span>
 #else
 #define VTTBR_X		(5 - KVM_T0SZ)
 #endif
<span class="p_del">-#define VTTBR_BADDR_SHIFT (VTTBR_X - 1)</span>
<span class="p_del">-#define VTTBR_BADDR_MASK  (((_AC(1, ULL) &lt;&lt; (40 - VTTBR_X)) - 1) &lt;&lt; VTTBR_BADDR_SHIFT)</span>
<span class="p_add">+#define VTTBR_BADDR_MASK  (((_AC(1, ULL) &lt;&lt; (40 - VTTBR_X)) - 1) &lt;&lt; VTTBR_X)</span>
 #define VTTBR_VMID_SHIFT  _AC(48, ULL)
 #define VTTBR_VMID_MASK(size)	(_AT(u64, (1 &lt;&lt; size) - 1) &lt;&lt; VTTBR_VMID_SHIFT)
 
<span class="p_chunk">@@ -209,6 +208,7 @@</span> <span class="p_context"></span>
 #define HSR_EC_IABT_HYP	(0x21)
 #define HSR_EC_DABT	(0x24)
 #define HSR_EC_DABT_HYP	(0x25)
<span class="p_add">+#define HSR_EC_MAX	(0x3f)</span>
 
 #define HSR_WFI_IS_WFE		(_AC(1, UL) &lt;&lt; 0)
 
<span class="p_header">diff --git a/arch/arm/include/asm/uaccess.h b/arch/arm/include/asm/uaccess.h</span>
<span class="p_header">index 1f59ea051bab..b7e0125c0bbf 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -478,11 +478,10 @@</span> <span class="p_context"> extern unsigned long __must_check</span>
 arm_copy_from_user(void *to, const void __user *from, unsigned long n);
 
 static inline unsigned long __must_check
<span class="p_del">-__copy_from_user(void *to, const void __user *from, unsigned long n)</span>
<span class="p_add">+__arch_copy_from_user(void *to, const void __user *from, unsigned long n)</span>
 {
 	unsigned int __ua_flags;
 
<span class="p_del">-	check_object_size(to, n, false);</span>
 	__ua_flags = uaccess_save_and_enable();
 	n = arm_copy_from_user(to, from, n);
 	uaccess_restore(__ua_flags);
<span class="p_chunk">@@ -495,18 +494,15 @@</span> <span class="p_context"> extern unsigned long __must_check</span>
 __copy_to_user_std(void __user *to, const void *from, unsigned long n);
 
 static inline unsigned long __must_check
<span class="p_del">-__copy_to_user(void __user *to, const void *from, unsigned long n)</span>
<span class="p_add">+__arch_copy_to_user(void __user *to, const void *from, unsigned long n)</span>
 {
 #ifndef CONFIG_UACCESS_WITH_MEMCPY
 	unsigned int __ua_flags;
<span class="p_del">-</span>
<span class="p_del">-	check_object_size(from, n, true);</span>
 	__ua_flags = uaccess_save_and_enable();
 	n = arm_copy_to_user(to, from, n);
 	uaccess_restore(__ua_flags);
 	return n;
 #else
<span class="p_del">-	check_object_size(from, n, true);</span>
 	return arm_copy_to_user(to, from, n);
 #endif
 }
<span class="p_chunk">@@ -526,25 +522,49 @@</span> <span class="p_context"> __clear_user(void __user *addr, unsigned long n)</span>
 }
 
 #else
<span class="p_del">-#define __copy_from_user(to, from, n)	(memcpy(to, (void __force *)from, n), 0)</span>
<span class="p_del">-#define __copy_to_user(to, from, n)	(memcpy((void __force *)to, from, n), 0)</span>
<span class="p_add">+#define __arch_copy_from_user(to, from, n)	\</span>
<span class="p_add">+					(memcpy(to, (void __force *)from, n), 0)</span>
<span class="p_add">+#define __arch_copy_to_user(to, from, n)	\</span>
<span class="p_add">+					(memcpy((void __force *)to, from, n), 0)</span>
 #define __clear_user(addr, n)		(memset((void __force *)addr, 0, n), 0)
 #endif
 
<span class="p_del">-static inline unsigned long __must_check copy_from_user(void *to, const void __user *from, unsigned long n)</span>
<span class="p_add">+static inline unsigned long __must_check</span>
<span class="p_add">+__copy_from_user(void *to, const void __user *from, unsigned long n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	check_object_size(to, n, false);</span>
<span class="p_add">+	return __arch_copy_from_user(to, from, n);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long __must_check</span>
<span class="p_add">+copy_from_user(void *to, const void __user *from, unsigned long n)</span>
 {
 	unsigned long res = n;
<span class="p_add">+</span>
<span class="p_add">+	check_object_size(to, n, false);</span>
<span class="p_add">+</span>
 	if (likely(access_ok(VERIFY_READ, from, n)))
<span class="p_del">-		res = __copy_from_user(to, from, n);</span>
<span class="p_add">+		res = __arch_copy_from_user(to, from, n);</span>
 	if (unlikely(res))
 		memset(to + (n - res), 0, res);
 	return res;
 }
 
<span class="p_del">-static inline unsigned long __must_check copy_to_user(void __user *to, const void *from, unsigned long n)</span>
<span class="p_add">+static inline unsigned long __must_check</span>
<span class="p_add">+__copy_to_user(void __user *to, const void *from, unsigned long n)</span>
 {
<span class="p_add">+	check_object_size(from, n, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	return __arch_copy_to_user(to, from, n);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long __must_check</span>
<span class="p_add">+copy_to_user(void __user *to, const void *from, unsigned long n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	check_object_size(from, n, true);</span>
<span class="p_add">+</span>
 	if (access_ok(VERIFY_WRITE, to, n))
<span class="p_del">-		n = __copy_to_user(to, from, n);</span>
<span class="p_add">+		n = __arch_copy_to_user(to, from, n);</span>
 	return n;
 }
 
<span class="p_header">diff --git a/arch/arm/kernel/entry-header.S b/arch/arm/kernel/entry-header.S</span>
<span class="p_header">index 6391728c8f03..e056c9a9aa9d 100644</span>
<span class="p_header">--- a/arch/arm/kernel/entry-header.S</span>
<span class="p_header">+++ b/arch/arm/kernel/entry-header.S</span>
<span class="p_chunk">@@ -299,6 +299,8 @@</span> <span class="p_context"></span>
 	mov	r2, sp
 	ldr	r1, [r2, #\offset + S_PSR]	@ get calling cpsr
 	ldr	lr, [r2, #\offset + S_PC]!	@ get pc
<span class="p_add">+	tst	r1, #PSR_I_BIT | 0x0f</span>
<span class="p_add">+	bne	1f</span>
 	msr	spsr_cxsf, r1			@ save in spsr_svc
 #if defined(CONFIG_CPU_V6) || defined(CONFIG_CPU_32v6K)
 	@ We must avoid clrex due to Cortex-A15 erratum #830321
<span class="p_chunk">@@ -313,6 +315,7 @@</span> <span class="p_context"></span>
 						@ after ldm {}^
 	add	sp, sp, #\offset + PT_REGS_SIZE
 	movs	pc, lr				@ return &amp; move spsr_svc into cpsr
<span class="p_add">+1:	bug	&quot;Returning to usermode but unexpected PSR bits set?&quot;, \@</span>
 #elif defined(CONFIG_CPU_V7M)
 	@ V7M restore.
 	@ Note that we don&#39;t need to do clrex here as clearing the local
<span class="p_chunk">@@ -328,6 +331,8 @@</span> <span class="p_context"></span>
 	ldr	r1, [sp, #\offset + S_PSR]	@ get calling cpsr
 	ldr	lr, [sp, #\offset + S_PC]	@ get pc
 	add	sp, sp, #\offset + S_SP
<span class="p_add">+	tst	r1, #PSR_I_BIT | 0x0f</span>
<span class="p_add">+	bne	1f</span>
 	msr	spsr_cxsf, r1			@ save in spsr_svc
 
 	@ We must avoid clrex due to Cortex-A15 erratum #830321
<span class="p_chunk">@@ -340,6 +345,7 @@</span> <span class="p_context"></span>
 	.endif
 	add	sp, sp, #PT_REGS_SIZE - S_SP
 	movs	pc, lr				@ return &amp; move spsr_svc into cpsr
<span class="p_add">+1:	bug	&quot;Returning to usermode but unexpected PSR bits set?&quot;, \@</span>
 #endif	/* !CONFIG_THUMB2_KERNEL */
 	.endm
 
<span class="p_header">diff --git a/arch/arm/kvm/handle_exit.c b/arch/arm/kvm/handle_exit.c</span>
<span class="p_header">index 066b6d4508ce..42f5daf715d0 100644</span>
<span class="p_header">--- a/arch/arm/kvm/handle_exit.c</span>
<span class="p_header">+++ b/arch/arm/kvm/handle_exit.c</span>
<span class="p_chunk">@@ -79,7 +79,19 @@</span> <span class="p_context"> static int kvm_handle_wfx(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	return 1;
 }
 
<span class="p_add">+static int kvm_handle_unknown_ec(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 hsr = kvm_vcpu_get_hsr(vcpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_pr_unimpl(&quot;Unknown exception class: hsr: %#08x\n&quot;,</span>
<span class="p_add">+		      hsr);</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_inject_undefined(vcpu);</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static exit_handle_fn arm_exit_handlers[] = {
<span class="p_add">+	[0 ... HSR_EC_MAX]	= kvm_handle_unknown_ec,</span>
 	[HSR_EC_WFI]		= kvm_handle_wfx,
 	[HSR_EC_CP15_32]	= kvm_handle_cp15_32,
 	[HSR_EC_CP15_64]	= kvm_handle_cp15_64,
<span class="p_chunk">@@ -98,13 +110,6 @@</span> <span class="p_context"> static exit_handle_fn kvm_get_exit_handler(struct kvm_vcpu *vcpu)</span>
 {
 	u8 hsr_ec = kvm_vcpu_trap_get_class(vcpu);
 
<span class="p_del">-	if (hsr_ec &gt;= ARRAY_SIZE(arm_exit_handlers) ||</span>
<span class="p_del">-	    !arm_exit_handlers[hsr_ec]) {</span>
<span class="p_del">-		kvm_err(&quot;Unknown exception class: hsr: %#08x\n&quot;,</span>
<span class="p_del">-			(unsigned int)kvm_vcpu_get_hsr(vcpu));</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return arm_exit_handlers[hsr_ec];
 }
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/gpmc-onenand.c b/arch/arm/mach-omap2/gpmc-onenand.c</span>
<span class="p_header">index 8633c703546a..2944af820558 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/gpmc-onenand.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/gpmc-onenand.c</span>
<span class="p_chunk">@@ -367,7 +367,7 @@</span> <span class="p_context"> static int gpmc_onenand_setup(void __iomem *onenand_base, int *freq_ptr)</span>
 	return ret;
 }
 
<span class="p_del">-void gpmc_onenand_init(struct omap_onenand_platform_data *_onenand_data)</span>
<span class="p_add">+int gpmc_onenand_init(struct omap_onenand_platform_data *_onenand_data)</span>
 {
 	int err;
 	struct device *dev = &amp;gpmc_onenand_device.dev;
<span class="p_chunk">@@ -393,15 +393,17 @@</span> <span class="p_context"> void gpmc_onenand_init(struct omap_onenand_platform_data *_onenand_data)</span>
 	if (err &lt; 0) {
 		dev_err(dev, &quot;Cannot request GPMC CS %d, error %d\n&quot;,
 			gpmc_onenand_data-&gt;cs, err);
<span class="p_del">-		return;</span>
<span class="p_add">+		return err;</span>
 	}
 
 	gpmc_onenand_resource.end = gpmc_onenand_resource.start +
 							ONENAND_IO_SIZE - 1;
 
<span class="p_del">-	if (platform_device_register(&amp;gpmc_onenand_device) &lt; 0) {</span>
<span class="p_add">+	err = platform_device_register(&amp;gpmc_onenand_device);</span>
<span class="p_add">+	if (err) {</span>
 		dev_err(dev, &quot;Unable to register OneNAND device\n&quot;);
 		gpmc_cs_free(gpmc_onenand_data-&gt;cs);
<span class="p_del">-		return;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c b/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_header">index 1cc4a6f3954e..bca54154e14f 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_chunk">@@ -3828,16 +3828,20 @@</span> <span class="p_context"> static struct omap_hwmod_ocp_if *omap3xxx_dss_hwmod_ocp_ifs[] __initdata = {</span>
  * Return: 0 if device named @dev_name is not likely to be accessible,
  * or 1 if it is likely to be accessible.
  */
<span class="p_del">-static int __init omap3xxx_hwmod_is_hs_ip_block_usable(struct device_node *bus,</span>
<span class="p_del">-						       const char *dev_name)</span>
<span class="p_add">+static bool __init omap3xxx_hwmod_is_hs_ip_block_usable(struct device_node *bus,</span>
<span class="p_add">+							const char *dev_name)</span>
 {
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	bool available;</span>
<span class="p_add">+</span>
 	if (!bus)
<span class="p_del">-		return (omap_type() == OMAP2_DEVICE_TYPE_GP) ? 1 : 0;</span>
<span class="p_add">+		return omap_type() == OMAP2_DEVICE_TYPE_GP;</span>
 
<span class="p_del">-	if (of_device_is_available(of_find_node_by_name(bus, dev_name)))</span>
<span class="p_del">-		return 1;</span>
<span class="p_add">+	node = of_get_child_by_name(bus, dev_name);</span>
<span class="p_add">+	available = of_device_is_available(node);</span>
<span class="p_add">+	of_node_put(node);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return available;</span>
 }
 
 int __init omap3xxx_hwmod_init(void)
<span class="p_chunk">@@ -3906,15 +3910,20 @@</span> <span class="p_context"> int __init omap3xxx_hwmod_init(void)</span>
 
 	if (h_sham &amp;&amp; omap3xxx_hwmod_is_hs_ip_block_usable(bus, &quot;sham&quot;)) {
 		r = omap_hwmod_register_links(h_sham);
<span class="p_del">-		if (r &lt; 0)</span>
<span class="p_add">+		if (r &lt; 0) {</span>
<span class="p_add">+			of_node_put(bus);</span>
 			return r;
<span class="p_add">+		}</span>
 	}
 
 	if (h_aes &amp;&amp; omap3xxx_hwmod_is_hs_ip_block_usable(bus, &quot;aes&quot;)) {
 		r = omap_hwmod_register_links(h_aes);
<span class="p_del">-		if (r &lt; 0)</span>
<span class="p_add">+		if (r &lt; 0) {</span>
<span class="p_add">+			of_node_put(bus);</span>
 			return r;
<span class="p_add">+		}</span>
 	}
<span class="p_add">+	of_node_put(bus);</span>
 
 	/*
 	 * Register hwmod links specific to certain ES levels of a
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_arm.h b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">index 2a2752b5b6aa..0dbc1c6ab7dc 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_chunk">@@ -170,8 +170,7 @@</span> <span class="p_context"></span>
 #define VTCR_EL2_FLAGS			(VTCR_EL2_COMMON_BITS | VTCR_EL2_TGRAN_FLAGS)
 #define VTTBR_X				(VTTBR_X_TGRAN_MAGIC - VTCR_EL2_T0SZ_IPA)
 
<span class="p_del">-#define VTTBR_BADDR_SHIFT (VTTBR_X - 1)</span>
<span class="p_del">-#define VTTBR_BADDR_MASK  (((UL(1) &lt;&lt; (PHYS_MASK_SHIFT - VTTBR_X)) - 1) &lt;&lt; VTTBR_BADDR_SHIFT)</span>
<span class="p_add">+#define VTTBR_BADDR_MASK  (((UL(1) &lt;&lt; (PHYS_MASK_SHIFT - VTTBR_X)) - 1) &lt;&lt; VTTBR_X)</span>
 #define VTTBR_VMID_SHIFT  (UL(48))
 #define VTTBR_VMID_MASK(size) (_AT(u64, (1 &lt;&lt; size) - 1) &lt;&lt; VTTBR_VMID_SHIFT)
 
<span class="p_header">diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c</span>
<span class="p_header">index 01753cd7d3f0..0e7394915c70 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/process.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/process.c</span>
<span class="p_chunk">@@ -255,6 +255,15 @@</span> <span class="p_context"> int copy_thread(unsigned long clone_flags, unsigned long stack_start,</span>
 
 	memset(&amp;p-&gt;thread.cpu_context, 0, sizeof(struct cpu_context));
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case p was allocated the same task_struct pointer as some</span>
<span class="p_add">+	 * other recently-exited task, make sure p is disassociated from</span>
<span class="p_add">+	 * any cpu that may have run that now-exited task recently.</span>
<span class="p_add">+	 * Otherwise we could erroneously skip reloading the FPSIMD</span>
<span class="p_add">+	 * registers for p.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fpsimd_flush_task_state(p);</span>
<span class="p_add">+</span>
 	if (likely(!(p-&gt;flags &amp; PF_KTHREAD))) {
 		*childregs = *current_pt_regs();
 		childregs-&gt;regs[0] = 0;
<span class="p_header">diff --git a/arch/arm64/kvm/handle_exit.c b/arch/arm64/kvm/handle_exit.c</span>
<span class="p_header">index a204adf29f0a..85baadab02d3 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/handle_exit.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/handle_exit.c</span>
<span class="p_chunk">@@ -125,7 +125,19 @@</span> <span class="p_context"> static int kvm_handle_guest_debug(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	return ret;
 }
 
<span class="p_add">+static int kvm_handle_unknown_ec(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 hsr = kvm_vcpu_get_hsr(vcpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_pr_unimpl(&quot;Unknown exception class: hsr: %#08x -- %s\n&quot;,</span>
<span class="p_add">+		      hsr, esr_get_class_string(hsr));</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_inject_undefined(vcpu);</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static exit_handle_fn arm_exit_handlers[] = {
<span class="p_add">+	[0 ... ESR_ELx_EC_MAX]	= kvm_handle_unknown_ec,</span>
 	[ESR_ELx_EC_WFx]	= kvm_handle_wfx,
 	[ESR_ELx_EC_CP15_32]	= kvm_handle_cp15_32,
 	[ESR_ELx_EC_CP15_64]	= kvm_handle_cp15_64,
<span class="p_chunk">@@ -151,13 +163,6 @@</span> <span class="p_context"> static exit_handle_fn kvm_get_exit_handler(struct kvm_vcpu *vcpu)</span>
 	u32 hsr = kvm_vcpu_get_hsr(vcpu);
 	u8 hsr_ec = ESR_ELx_EC(hsr);
 
<span class="p_del">-	if (hsr_ec &gt;= ARRAY_SIZE(arm_exit_handlers) ||</span>
<span class="p_del">-	    !arm_exit_handlers[hsr_ec]) {</span>
<span class="p_del">-		kvm_err(&quot;Unknown exception class: hsr: %#08x -- %s\n&quot;,</span>
<span class="p_del">-			hsr, esr_get_class_string(hsr));</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return arm_exit_handlers[hsr_ec];
 }
 
<span class="p_header">diff --git a/arch/powerpc/Makefile b/arch/powerpc/Makefile</span>
<span class="p_header">index 617dece67924..a60c9c6e5cc1 100644</span>
<span class="p_header">--- a/arch/powerpc/Makefile</span>
<span class="p_header">+++ b/arch/powerpc/Makefile</span>
<span class="p_chunk">@@ -72,8 +72,15 @@</span> <span class="p_context"> GNUTARGET	:= powerpc</span>
 MULTIPLEWORD	:= -mmultiple
 endif
 
<span class="p_del">-cflags-$(CONFIG_CPU_BIG_ENDIAN)		+= $(call cc-option,-mbig-endian)</span>
<span class="p_add">+ifdef CONFIG_PPC64</span>
<span class="p_add">+cflags-$(CONFIG_CPU_BIG_ENDIAN)		+= $(call cc-option,-mabi=elfv1)</span>
<span class="p_add">+cflags-$(CONFIG_CPU_BIG_ENDIAN)		+= $(call cc-option,-mcall-aixdesc)</span>
<span class="p_add">+aflags-$(CONFIG_CPU_BIG_ENDIAN)		+= $(call cc-option,-mabi=elfv1)</span>
<span class="p_add">+aflags-$(CONFIG_CPU_LITTLE_ENDIAN)	+= -mabi=elfv2</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 cflags-$(CONFIG_CPU_LITTLE_ENDIAN)	+= -mlittle-endian
<span class="p_add">+cflags-$(CONFIG_CPU_BIG_ENDIAN)		+= $(call cc-option,-mbig-endian)</span>
 ifneq ($(cc-name),clang)
   cflags-$(CONFIG_CPU_LITTLE_ENDIAN)	+= -mno-strict-align
 endif
<span class="p_chunk">@@ -113,7 +120,9 @@</span> <span class="p_context"> ifeq ($(CONFIG_CPU_LITTLE_ENDIAN),y)</span>
 CFLAGS-$(CONFIG_PPC64)	+= $(call cc-option,-mabi=elfv2,$(call cc-option,-mcall-aixdesc))
 AFLAGS-$(CONFIG_PPC64)	+= $(call cc-option,-mabi=elfv2)
 else
<span class="p_add">+CFLAGS-$(CONFIG_PPC64)	+= $(call cc-option,-mabi=elfv1)</span>
 CFLAGS-$(CONFIG_PPC64)	+= $(call cc-option,-mcall-aixdesc)
<span class="p_add">+AFLAGS-$(CONFIG_PPC64)	+= $(call cc-option,-mabi=elfv1)</span>
 endif
 CFLAGS-$(CONFIG_PPC64)	+= $(call cc-option,-mcmodel=medium,$(call cc-option,-mminimal-toc))
 CFLAGS-$(CONFIG_PPC64)	+= $(call cc-option,-mno-pointers-to-nested-functions)
<span class="p_header">diff --git a/arch/powerpc/include/asm/checksum.h b/arch/powerpc/include/asm/checksum.h</span>
<span class="p_header">index 1e8fceb308a5..a67bb09585f4 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/checksum.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/checksum.h</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> static inline __wsum csum_add(__wsum csum, __wsum addend)</span>
 
 #ifdef __powerpc64__
 	res += (__force u64)addend;
<span class="p_del">-	return (__force __wsum)((u32)res + (res &gt;&gt; 32));</span>
<span class="p_add">+	return (__force __wsum) from64to32(res);</span>
 #else
 	asm(&quot;addc %0,%0,%1;&quot;
 	    &quot;addze %0,%0;&quot;
<span class="p_header">diff --git a/arch/powerpc/kernel/cpu_setup_power.S b/arch/powerpc/kernel/cpu_setup_power.S</span>
<span class="p_header">index 7803756998e2..9e05c8828ee2 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cpu_setup_power.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cpu_setup_power.S</span>
<span class="p_chunk">@@ -97,6 +97,7 @@</span> <span class="p_context"> _GLOBAL(__setup_cpu_power9)</span>
 	beqlr
 	li	r0,0
 	mtspr	SPRN_LPID,r0
<span class="p_add">+	mtspr	SPRN_PID,r0</span>
 	mfspr	r3,SPRN_LPCR
 	LOAD_REG_IMMEDIATE(r4, LPCR_PECEDH | LPCR_PECE_HVEE | LPCR_HVICE)
 	or	r3, r3, r4
<span class="p_chunk">@@ -119,6 +120,7 @@</span> <span class="p_context"> _GLOBAL(__restore_cpu_power9)</span>
 	beqlr
 	li	r0,0
 	mtspr	SPRN_LPID,r0
<span class="p_add">+	mtspr	SPRN_PID,r0</span>
 	mfspr   r3,SPRN_LPCR
 	LOAD_REG_IMMEDIATE(r4, LPCR_PECEDH | LPCR_PECE_HVEE | LPCR_HVICE)
 	or	r3, r3, r4
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable-radix.c b/arch/powerpc/mm/pgtable-radix.c</span>
<span class="p_header">index 9a25dce87875..44c33ee397a0 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable-radix.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable-radix.c</span>
<span class="p_chunk">@@ -173,6 +173,10 @@</span> <span class="p_context"> static void __init radix_init_pgtable(void)</span>
 	 */
 	register_process_table(__pa(process_tb), 0, PRTB_SIZE_SHIFT - 12);
 	pr_info(&quot;Process table %p and radix root for kernel: %p\n&quot;, process_tb, init_mm.pgd);
<span class="p_add">+	asm volatile(&quot;ptesync&quot; : : : &quot;memory&quot;);</span>
<span class="p_add">+	asm volatile(PPC_TLBIE_5(%0,%1,2,1,1) : :</span>
<span class="p_add">+		     &quot;r&quot; (TLBIEL_INVAL_SET_LPID), &quot;r&quot; (0));</span>
<span class="p_add">+	asm volatile(&quot;eieio; tlbsync; ptesync&quot; : : : &quot;memory&quot;);</span>
 }
 
 static void __init radix_init_partition_table(void)
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">index dcdfee0cd4f2..f602307a4386 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_chunk">@@ -2623,6 +2623,9 @@</span> <span class="p_context"> static long pnv_pci_ioda2_table_alloc_pages(int nid, __u64 bus_offset,</span>
 	level_shift = entries_shift + 3;
 	level_shift = max_t(unsigned, level_shift, PAGE_SHIFT);
 
<span class="p_add">+	if ((level_shift - 3) * levels + page_shift &gt;= 60)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Allocate TCE table */
 	addr = pnv_pci_ioda2_table_do_alloc_pages(nid, level_shift,
 			levels, tce_table_size, &amp;offset, &amp;total_allocated);
<span class="p_header">diff --git a/arch/powerpc/sysdev/axonram.c b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">index ada29eaed6e2..f523ac883150 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_chunk">@@ -274,7 +274,9 @@</span> <span class="p_context"> static int axon_ram_probe(struct platform_device *device)</span>
 			if (bank-&gt;disk-&gt;major &gt; 0)
 				unregister_blkdev(bank-&gt;disk-&gt;major,
 						bank-&gt;disk-&gt;disk_name);
<span class="p_del">-			del_gendisk(bank-&gt;disk);</span>
<span class="p_add">+			if (bank-&gt;disk-&gt;flags &amp; GENHD_FL_UP)</span>
<span class="p_add">+				del_gendisk(bank-&gt;disk);</span>
<span class="p_add">+			put_disk(bank-&gt;disk);</span>
 		}
 		device-&gt;dev.platform_data = NULL;
 		if (bank-&gt;io_addr != 0)
<span class="p_chunk">@@ -299,6 +301,7 @@</span> <span class="p_context"> axon_ram_remove(struct platform_device *device)</span>
 	device_remove_file(&amp;device-&gt;dev, &amp;dev_attr_ecc);
 	free_irq(bank-&gt;irq_id, device);
 	del_gendisk(bank-&gt;disk);
<span class="p_add">+	put_disk(bank-&gt;disk);</span>
 	iounmap((void __iomem *) bank-&gt;io_addr);
 	kfree(bank);
 
<span class="p_header">diff --git a/arch/s390/kernel/syscalls.S b/arch/s390/kernel/syscalls.S</span>
<span class="p_header">index 9b59e6212d8f..709da452413d 100644</span>
<span class="p_header">--- a/arch/s390/kernel/syscalls.S</span>
<span class="p_header">+++ b/arch/s390/kernel/syscalls.S</span>
<span class="p_chunk">@@ -369,10 +369,10 @@</span> <span class="p_context"> SYSCALL(sys_recvmmsg,compat_sys_recvmmsg)</span>
 SYSCALL(sys_sendmmsg,compat_sys_sendmmsg)
 SYSCALL(sys_socket,sys_socket)
 SYSCALL(sys_socketpair,compat_sys_socketpair)		/* 360 */
<span class="p_del">-SYSCALL(sys_bind,sys_bind)</span>
<span class="p_del">-SYSCALL(sys_connect,sys_connect)</span>
<span class="p_add">+SYSCALL(sys_bind,compat_sys_bind)</span>
<span class="p_add">+SYSCALL(sys_connect,compat_sys_connect)</span>
 SYSCALL(sys_listen,sys_listen)
<span class="p_del">-SYSCALL(sys_accept4,sys_accept4)</span>
<span class="p_add">+SYSCALL(sys_accept4,compat_sys_accept4)</span>
 SYSCALL(sys_getsockopt,compat_sys_getsockopt)		/* 365 */
 SYSCALL(sys_setsockopt,compat_sys_setsockopt)
 SYSCALL(sys_getsockname,compat_sys_getsockname)
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index e18435355c16..c2905a10cb37 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -197,8 +197,6 @@</span> <span class="p_context"> static int try_handle_skey(struct kvm_vcpu *vcpu)</span>
 		VCPU_EVENT(vcpu, 4, &quot;%s&quot;, &quot;retrying storage key operation&quot;);
 		return -EAGAIN;
 	}
<span class="p_del">-	if (vcpu-&gt;arch.sie_block-&gt;gpsw.mask &amp; PSW_MASK_PSTATE)</span>
<span class="p_del">-		return kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -209,6 +207,9 @@</span> <span class="p_context"> static int handle_iske(struct kvm_vcpu *vcpu)</span>
 	int reg1, reg2;
 	int rc;
 
<span class="p_add">+	if (vcpu-&gt;arch.sie_block-&gt;gpsw.mask &amp; PSW_MASK_PSTATE)</span>
<span class="p_add">+		return kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);</span>
<span class="p_add">+</span>
 	rc = try_handle_skey(vcpu);
 	if (rc)
 		return rc != -EAGAIN ? rc : 0;
<span class="p_chunk">@@ -238,6 +239,9 @@</span> <span class="p_context"> static int handle_rrbe(struct kvm_vcpu *vcpu)</span>
 	int reg1, reg2;
 	int rc;
 
<span class="p_add">+	if (vcpu-&gt;arch.sie_block-&gt;gpsw.mask &amp; PSW_MASK_PSTATE)</span>
<span class="p_add">+		return kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);</span>
<span class="p_add">+</span>
 	rc = try_handle_skey(vcpu);
 	if (rc)
 		return rc != -EAGAIN ? rc : 0;
<span class="p_chunk">@@ -273,6 +277,9 @@</span> <span class="p_context"> static int handle_sske(struct kvm_vcpu *vcpu)</span>
 	int reg1, reg2;
 	int rc;
 
<span class="p_add">+	if (vcpu-&gt;arch.sie_block-&gt;gpsw.mask &amp; PSW_MASK_PSTATE)</span>
<span class="p_add">+		return kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);</span>
<span class="p_add">+</span>
 	rc = try_handle_skey(vcpu);
 	if (rc)
 		return rc != -EAGAIN ? rc : 0;
<span class="p_header">diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c</span>
<span class="p_header">index 57154c638e71..0f183ffe3416 100644</span>
<span class="p_header">--- a/arch/sparc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/sparc/mm/init_64.c</span>
<span class="p_chunk">@@ -2391,9 +2391,16 @@</span> <span class="p_context"> void __init mem_init(void)</span>
 {
 	high_memory = __va(last_valid_pfn &lt;&lt; PAGE_SHIFT);
 
<span class="p_del">-	register_page_bootmem_info();</span>
 	free_all_bootmem();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Must be done after boot memory is put on freelist, because here we</span>
<span class="p_add">+	 * might set fields in deferred struct pages that have not yet been</span>
<span class="p_add">+	 * initialized, and free_all_bootmem() initializes all the reserved</span>
<span class="p_add">+	 * deferred pages for us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	register_page_bootmem_info();</span>
<span class="p_add">+</span>
 	/*
 	 * Set up the zero page, mark it reserved, so that page count
 	 * is not manipulated when freeing the page from user ptes.
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index bdde80731f49..cbd1d44da2d3 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -1397,4 +1397,7 @@</span> <span class="p_context"> static inline int kvm_cpu_get_apicid(int mps_cpu)</span>
 #endif
 }
 
<span class="p_add">+void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,</span>
<span class="p_add">+		unsigned long start, unsigned long end);</span>
<span class="p_add">+</span>
 #endif /* _ASM_X86_KVM_HOST_H */
<span class="p_header">diff --git a/arch/x86/kernel/hpet.c b/arch/x86/kernel/hpet.c</span>
<span class="p_header">index 932348fbb6ea..9512529e8eab 100644</span>
<span class="p_header">--- a/arch/x86/kernel/hpet.c</span>
<span class="p_header">+++ b/arch/x86/kernel/hpet.c</span>
<span class="p_chunk">@@ -354,7 +354,7 @@</span> <span class="p_context"> static int hpet_resume(struct clock_event_device *evt, int timer)</span>
 
 		irq_domain_deactivate_irq(irq_get_irq_data(hdev-&gt;irq));
 		irq_domain_activate_irq(irq_get_irq_data(hdev-&gt;irq));
<span class="p_del">-		disable_irq(hdev-&gt;irq);</span>
<span class="p_add">+		disable_hardirq(hdev-&gt;irq);</span>
 		irq_set_affinity(hdev-&gt;irq, cpumask_of(hdev-&gt;cpu));
 		enable_irq(hdev-&gt;irq);
 	}
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index f0d3de153e29..9aa62ab13ae8 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -6413,12 +6413,7 @@</span> <span class="p_context"> static __init int hardware_setup(void)</span>
 	memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);
 	memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Allow direct access to the PC debug port (it is often used for I/O</span>
<span class="p_del">-	 * delays, but the vmexits simply slow things down).</span>
<span class="p_del">-	 */</span>
 	memset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);
<span class="p_del">-	clear_bit(0x80, vmx_io_bitmap_a);</span>
 
 	memset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);
 
<span class="p_chunk">@@ -7208,9 +7203,8 @@</span> <span class="p_context"> static int handle_vmoff(struct kvm_vcpu *vcpu)</span>
 static int handle_vmclear(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
<span class="p_add">+	u32 zero = 0;</span>
 	gpa_t vmptr;
<span class="p_del">-	struct vmcs12 *vmcs12;</span>
<span class="p_del">-	struct page *page;</span>
 
 	if (!nested_vmx_check_permission(vcpu))
 		return 1;
<span class="p_chunk">@@ -7221,22 +7215,9 @@</span> <span class="p_context"> static int handle_vmclear(struct kvm_vcpu *vcpu)</span>
 	if (vmptr == vmx-&gt;nested.current_vmptr)
 		nested_release_vmcs12(vmx);
 
<span class="p_del">-	page = nested_get_page(vcpu, vmptr);</span>
<span class="p_del">-	if (page == NULL) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * For accurate processor emulation, VMCLEAR beyond available</span>
<span class="p_del">-		 * physical memory should do nothing at all. However, it is</span>
<span class="p_del">-		 * possible that a nested vmx bug, not a guest hypervisor bug,</span>
<span class="p_del">-		 * resulted in this case, so let&#39;s shut down before doing any</span>
<span class="p_del">-		 * more damage:</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	vmcs12 = kmap(page);</span>
<span class="p_del">-	vmcs12-&gt;launch_state = 0;</span>
<span class="p_del">-	kunmap(page);</span>
<span class="p_del">-	nested_release_page(page);</span>
<span class="p_add">+	kvm_vcpu_write_guest(vcpu,</span>
<span class="p_add">+			vmptr + offsetof(struct vmcs12, launch_state),</span>
<span class="p_add">+			&amp;zero, sizeof(zero));</span>
 
 	nested_free_vmcs02(vmx, vmptr);
 
<span class="p_chunk">@@ -10903,8 +10884,10 @@</span> <span class="p_context"> static void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,</span>
  */
 static void vmx_leave_nested(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	if (is_guest_mode(vcpu))</span>
<span class="p_add">+	if (is_guest_mode(vcpu)) {</span>
<span class="p_add">+		to_vmx(vcpu)-&gt;nested.nested_run_pending = 0;</span>
 		nested_vmx_vmexit(vcpu, -1, 0, 0);
<span class="p_add">+	}</span>
 	free_nested(to_vmx(vcpu));
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 02d45296a97c..26b580ad268f 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -6526,6 +6526,20 @@</span> <span class="p_context"> static void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)</span>
 	kvm_x86_ops-&gt;tlb_flush(vcpu);
 }
 
<span class="p_add">+void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,</span>
<span class="p_add">+		unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long apic_address;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The physical address of apic access page is stored in the VMCS.</span>
<span class="p_add">+	 * Update it when it becomes invalid.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	apic_address = gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+	if (start &lt;= apic_address &amp;&amp; apic_address &lt; end)</span>
<span class="p_add">+		kvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)
 {
 	struct page *page = NULL;
<span class="p_header">diff --git a/arch/x86/pci/broadcom_bus.c b/arch/x86/pci/broadcom_bus.c</span>
<span class="p_header">index bb461cfd01ab..526536c81ddc 100644</span>
<span class="p_header">--- a/arch/x86/pci/broadcom_bus.c</span>
<span class="p_header">+++ b/arch/x86/pci/broadcom_bus.c</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> static int __init broadcom_postcore_init(void)</span>
 	 * We should get host bridge information from ACPI unless the BIOS
 	 * doesn&#39;t support it.
 	 */
<span class="p_del">-	if (acpi_os_get_root_pointer())</span>
<span class="p_add">+	if (!acpi_disabled &amp;&amp; acpi_os_get_root_pointer())</span>
 		return 0;
 #endif
 
<span class="p_header">diff --git a/arch/x86/platform/uv/tlb_uv.c b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">index 9e42842e924a..0f0175186f1b 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_chunk">@@ -1848,7 +1848,6 @@</span> <span class="p_context"> static void pq_init(int node, int pnode)</span>
 
 	ops.write_payload_first(pnode, first);
 	ops.write_payload_last(pnode, last);
<span class="p_del">-	ops.write_g_sw_ack(pnode, 0xffffUL);</span>
 
 	/* in effect, all msg_type&#39;s are set to MSG_NOOP */
 	memset(pqp, 0, sizeof(struct bau_pq_entry) * DEST_Q_SIZE);
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index b1c76aa73492..23daf40be371 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -527,8 +527,8 @@</span> <span class="p_context"> void blk_set_queue_dying(struct request_queue *q)</span>
 
 		blk_queue_for_each_rl(rl, q) {
 			if (rl-&gt;rq_pool) {
<span class="p_del">-				wake_up(&amp;rl-&gt;wait[BLK_RW_SYNC]);</span>
<span class="p_del">-				wake_up(&amp;rl-&gt;wait[BLK_RW_ASYNC]);</span>
<span class="p_add">+				wake_up_all(&amp;rl-&gt;wait[BLK_RW_SYNC]);</span>
<span class="p_add">+				wake_up_all(&amp;rl-&gt;wait[BLK_RW_ASYNC]);</span>
 			}
 		}
 	}
<span class="p_header">diff --git a/block/blk-mq-sysfs.c b/block/blk-mq-sysfs.c</span>
<span class="p_header">index 01fb455d3377..8c0894e0713b 100644</span>
<span class="p_header">--- a/block/blk-mq-sysfs.c</span>
<span class="p_header">+++ b/block/blk-mq-sysfs.c</span>
<span class="p_chunk">@@ -429,7 +429,7 @@</span> <span class="p_context"> void blk_mq_hctx_kobj_init(struct blk_mq_hw_ctx *hctx)</span>
 	kobject_init(&amp;hctx-&gt;kobj, &amp;blk_mq_hw_ktype);
 }
 
<span class="p_del">-static void blk_mq_sysfs_init(struct request_queue *q)</span>
<span class="p_add">+void blk_mq_sysfs_init(struct request_queue *q)</span>
 {
 	struct blk_mq_ctx *ctx;
 	int cpu;
<span class="p_chunk">@@ -449,8 +449,6 @@</span> <span class="p_context"> int blk_mq_register_dev(struct device *dev, struct request_queue *q)</span>
 
 	blk_mq_disable_hotplug();
 
<span class="p_del">-	blk_mq_sysfs_init(q);</span>
<span class="p_del">-</span>
 	ret = kobject_add(&amp;q-&gt;mq_kobj, kobject_get(&amp;dev-&gt;kobj), &quot;%s&quot;, &quot;mq&quot;);
 	if (ret &lt; 0)
 		goto out;
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 7b597ec4e9c5..10f8f94b7f20 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -1707,7 +1707,6 @@</span> <span class="p_context"> static void blk_mq_init_cpu_queues(struct request_queue *q,</span>
 		struct blk_mq_ctx *__ctx = per_cpu_ptr(q-&gt;queue_ctx, i);
 		struct blk_mq_hw_ctx *hctx;
 
<span class="p_del">-		memset(__ctx, 0, sizeof(*__ctx));</span>
 		__ctx-&gt;cpu = i;
 		spin_lock_init(&amp;__ctx-&gt;lock);
 		INIT_LIST_HEAD(&amp;__ctx-&gt;rq_list);
<span class="p_chunk">@@ -1970,6 +1969,9 @@</span> <span class="p_context"> struct request_queue *blk_mq_init_allocated_queue(struct blk_mq_tag_set *set,</span>
 	if (!q-&gt;queue_ctx)
 		goto err_exit;
 
<span class="p_add">+	/* init q-&gt;mq_kobj and sw queues&#39; kobjects */</span>
<span class="p_add">+	blk_mq_sysfs_init(q);</span>
<span class="p_add">+</span>
 	q-&gt;queue_hw_ctx = kzalloc_node(nr_cpu_ids * sizeof(*(q-&gt;queue_hw_ctx)),
 						GFP_KERNEL, set-&gt;numa_node);
 	if (!q-&gt;queue_hw_ctx)
<span class="p_header">diff --git a/block/blk-mq.h b/block/blk-mq.h</span>
<span class="p_header">index e5d25249028c..c55bcf67b956 100644</span>
<span class="p_header">--- a/block/blk-mq.h</span>
<span class="p_header">+++ b/block/blk-mq.h</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> static inline struct blk_mq_hw_ctx *blk_mq_map_queue(struct request_queue *q,</span>
 /*
  * sysfs helpers
  */
<span class="p_add">+extern void blk_mq_sysfs_init(struct request_queue *q);</span>
 extern int blk_mq_sysfs_register(struct request_queue *q);
 extern void blk_mq_sysfs_unregister(struct request_queue *q);
 extern void blk_mq_hctx_kobj_init(struct blk_mq_hw_ctx *hctx);
<span class="p_header">diff --git a/crypto/asymmetric_keys/pkcs7_verify.c b/crypto/asymmetric_keys/pkcs7_verify.c</span>
<span class="p_header">index 2ffd69769466..5a37962d2199 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/pkcs7_verify.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/pkcs7_verify.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static int pkcs7_find_key(struct pkcs7_message *pkcs7,</span>
 		pr_devel(&quot;Sig %u: Found cert serial match X.509[%u]\n&quot;,
 			 sinfo-&gt;index, certix);
 
<span class="p_del">-		if (x509-&gt;pub-&gt;pkey_algo != sinfo-&gt;sig-&gt;pkey_algo) {</span>
<span class="p_add">+		if (strcmp(x509-&gt;pub-&gt;pkey_algo, sinfo-&gt;sig-&gt;pkey_algo) != 0) {</span>
 			pr_warn(&quot;Sig %u: X.509 algo and PKCS#7 sig algo don&#39;t match\n&quot;,
 				sinfo-&gt;index);
 			continue;
<span class="p_header">diff --git a/crypto/asymmetric_keys/x509_cert_parser.c b/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_header">index c80765b211cf..029f7051f2be 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_chunk">@@ -408,6 +408,8 @@</span> <span class="p_context"> int x509_extract_key_data(void *context, size_t hdrlen,</span>
 	ctx-&gt;cert-&gt;pub-&gt;pkey_algo = &quot;rsa&quot;;
 
 	/* Discard the BIT STRING metadata */
<span class="p_add">+	if (vlen &lt; 1 || *(const u8 *)value != 0)</span>
<span class="p_add">+		return -EBADMSG;</span>
 	ctx-&gt;key = value + 1;
 	ctx-&gt;key_size = vlen - 1;
 	return 0;
<span class="p_header">diff --git a/crypto/asymmetric_keys/x509_public_key.c b/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_header">index fb732296cd36..e16009a8da9c 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> int x509_check_for_self_signed(struct x509_certificate *cert)</span>
 	}
 
 	ret = -EKEYREJECTED;
<span class="p_del">-	if (cert-&gt;pub-&gt;pkey_algo != cert-&gt;sig-&gt;pkey_algo)</span>
<span class="p_add">+	if (strcmp(cert-&gt;pub-&gt;pkey_algo, cert-&gt;sig-&gt;pkey_algo) != 0)</span>
 		goto out;
 
 	ret = public_key_verify_signature(cert-&gt;pub, cert-&gt;sig);
<span class="p_header">diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c</span>
<span class="p_header">index 051b6158d1b7..8d22acdf90f0 100644</span>
<span class="p_header">--- a/drivers/ata/libata-sff.c</span>
<span class="p_header">+++ b/drivers/ata/libata-sff.c</span>
<span class="p_chunk">@@ -1481,7 +1481,6 @@</span> <span class="p_context"> unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc)</span>
 		break;
 
 	default:
<span class="p_del">-		WARN_ON_ONCE(1);</span>
 		return AC_ERR_SYSTEM;
 	}
 
<span class="p_header">diff --git a/drivers/atm/horizon.c b/drivers/atm/horizon.c</span>
<span class="p_header">index 5fc81e240c24..e55f418d6ab9 100644</span>
<span class="p_header">--- a/drivers/atm/horizon.c</span>
<span class="p_header">+++ b/drivers/atm/horizon.c</span>
<span class="p_chunk">@@ -2802,7 +2802,7 @@</span> <span class="p_context"> static int hrz_probe(struct pci_dev *pci_dev,</span>
 	return err;
 
 out_free_irq:
<span class="p_del">-	free_irq(dev-&gt;irq, dev);</span>
<span class="p_add">+	free_irq(irq, dev);</span>
 out_free:
 	kfree(dev);
 out_release:
<span class="p_header">diff --git a/drivers/base/isa.c b/drivers/base/isa.c</span>
<span class="p_header">index cd6ccdcf9df0..372d10af2600 100644</span>
<span class="p_header">--- a/drivers/base/isa.c</span>
<span class="p_header">+++ b/drivers/base/isa.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"> static int isa_bus_probe(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;probe)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;probe)</span>
 		return isa_driver-&gt;probe(dev, to_isa_dev(dev)-&gt;id);
 
 	return 0;
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> static int isa_bus_remove(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;remove)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;remove)</span>
 		return isa_driver-&gt;remove(dev, to_isa_dev(dev)-&gt;id);
 
 	return 0;
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> static void isa_bus_shutdown(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;shutdown)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;shutdown)</span>
 		isa_driver-&gt;shutdown(dev, to_isa_dev(dev)-&gt;id);
 }
 
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> static int isa_bus_suspend(struct device *dev, pm_message_t state)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;suspend)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;suspend)</span>
 		return isa_driver-&gt;suspend(dev, to_isa_dev(dev)-&gt;id, state);
 
 	return 0;
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> static int isa_bus_resume(struct device *dev)</span>
 {
 	struct isa_driver *isa_driver = dev-&gt;platform_data;
 
<span class="p_del">-	if (isa_driver-&gt;resume)</span>
<span class="p_add">+	if (isa_driver &amp;&amp; isa_driver-&gt;resume)</span>
 		return isa_driver-&gt;resume(dev, to_isa_dev(dev)-&gt;id);
 
 	return 0;
<span class="p_header">diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c</span>
<span class="p_header">index c9914d653968..b7c0b69a02f5 100644</span>
<span class="p_header">--- a/drivers/block/zram/zram_drv.c</span>
<span class="p_header">+++ b/drivers/block/zram/zram_drv.c</span>
<span class="p_chunk">@@ -1286,6 +1286,8 @@</span> <span class="p_context"> static int zram_add(void)</span>
 	blk_queue_io_min(zram-&gt;disk-&gt;queue, PAGE_SIZE);
 	blk_queue_io_opt(zram-&gt;disk-&gt;queue, PAGE_SIZE);
 	zram-&gt;disk-&gt;queue-&gt;limits.discard_granularity = PAGE_SIZE;
<span class="p_add">+	zram-&gt;disk-&gt;queue-&gt;limits.max_sectors = SECTORS_PER_PAGE;</span>
<span class="p_add">+	zram-&gt;disk-&gt;queue-&gt;limits.chunk_sectors = 0;</span>
 	blk_queue_max_discard_sectors(zram-&gt;disk-&gt;queue, UINT_MAX);
 	/*
 	 * zram_bio_discard() will clear all logical blocks if logical block
<span class="p_header">diff --git a/drivers/bus/arm-cci.c b/drivers/bus/arm-cci.c</span>
<span class="p_header">index 890082315054..10f56133b281 100644</span>
<span class="p_header">--- a/drivers/bus/arm-cci.c</span>
<span class="p_header">+++ b/drivers/bus/arm-cci.c</span>
<span class="p_chunk">@@ -1755,14 +1755,17 @@</span> <span class="p_context"> static int cci_pmu_probe(struct platform_device *pdev)</span>
 	raw_spin_lock_init(&amp;cci_pmu-&gt;hw_events.pmu_lock);
 	mutex_init(&amp;cci_pmu-&gt;reserve_mutex);
 	atomic_set(&amp;cci_pmu-&gt;active_events, 0);
<span class="p_del">-	cpumask_set_cpu(smp_processor_id(), &amp;cci_pmu-&gt;cpus);</span>
<span class="p_add">+	cpumask_set_cpu(get_cpu(), &amp;cci_pmu-&gt;cpus);</span>
 
 	ret = cci_pmu_init(cci_pmu, pdev);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		put_cpu();</span>
 		return ret;
<span class="p_add">+	}</span>
 
 	cpuhp_state_add_instance_nocalls(CPUHP_AP_PERF_ARM_CCI_ONLINE,
 					 &amp;cci_pmu-&gt;node);
<span class="p_add">+	put_cpu();</span>
 	pr_info(&quot;ARM %s PMU driver probed&quot;, cci_pmu-&gt;model-&gt;name);
 	return 0;
 }
<span class="p_header">diff --git a/drivers/bus/arm-ccn.c b/drivers/bus/arm-ccn.c</span>
<span class="p_header">index aee83462b796..f0249899fc96 100644</span>
<span class="p_header">--- a/drivers/bus/arm-ccn.c</span>
<span class="p_header">+++ b/drivers/bus/arm-ccn.c</span>
<span class="p_chunk">@@ -1271,6 +1271,10 @@</span> <span class="p_context"> static int arm_ccn_pmu_init(struct arm_ccn *ccn)</span>
 		int len = snprintf(NULL, 0, &quot;ccn_%d&quot;, ccn-&gt;dt.id);
 
 		name = devm_kzalloc(ccn-&gt;dev, len + 1, GFP_KERNEL);
<span class="p_add">+		if (!name) {</span>
<span class="p_add">+			err = -ENOMEM;</span>
<span class="p_add">+			goto error_choose_name;</span>
<span class="p_add">+		}</span>
 		snprintf(name, len + 1, &quot;ccn_%d&quot;, ccn-&gt;dt.id);
 	}
 
<span class="p_chunk">@@ -1297,7 +1301,7 @@</span> <span class="p_context"> static int arm_ccn_pmu_init(struct arm_ccn *ccn)</span>
 	}
 
 	/* Pick one CPU which we will use to collect data from CCN... */
<span class="p_del">-	cpumask_set_cpu(smp_processor_id(), &amp;ccn-&gt;dt.cpu);</span>
<span class="p_add">+	cpumask_set_cpu(get_cpu(), &amp;ccn-&gt;dt.cpu);</span>
 
 	/* Also make sure that the overflow interrupt is handled by this CPU */
 	if (ccn-&gt;irq) {
<span class="p_chunk">@@ -1314,10 +1318,13 @@</span> <span class="p_context"> static int arm_ccn_pmu_init(struct arm_ccn *ccn)</span>
 
 	cpuhp_state_add_instance_nocalls(CPUHP_AP_PERF_ARM_CCN_ONLINE,
 					 &amp;ccn-&gt;dt.node);
<span class="p_add">+	put_cpu();</span>
 	return 0;
 
 error_pmu_register:
 error_set_affinity:
<span class="p_add">+	put_cpu();</span>
<span class="p_add">+error_choose_name:</span>
 	ida_simple_remove(&amp;arm_ccn_pmu_ida, ccn-&gt;dt.id);
 	for (i = 0; i &lt; ccn-&gt;num_xps; i++)
 		writel(0, ccn-&gt;xp[i].base + CCN_XP_DT_CONTROL);
<span class="p_chunk">@@ -1578,8 +1585,8 @@</span> <span class="p_context"> static int __init arm_ccn_init(void)</span>
 
 static void __exit arm_ccn_exit(void)
 {
<span class="p_del">-	cpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_CCN_ONLINE);</span>
 	platform_driver_unregister(&amp;arm_ccn_driver);
<span class="p_add">+	cpuhp_remove_multi_state(CPUHP_AP_PERF_ARM_CCN_ONLINE);</span>
 }
 
 module_init(arm_ccn_init);
<span class="p_header">diff --git a/drivers/clk/uniphier/clk-uniphier-sys.c b/drivers/clk/uniphier/clk-uniphier-sys.c</span>
<span class="p_header">index 5d029991047d..481225adef87 100644</span>
<span class="p_header">--- a/drivers/clk/uniphier/clk-uniphier-sys.c</span>
<span class="p_header">+++ b/drivers/clk/uniphier/clk-uniphier-sys.c</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> const struct uniphier_clk_data uniphier_sld8_sys_clk_data[] = {</span>
 const struct uniphier_clk_data uniphier_pro5_sys_clk_data[] = {
 	UNIPHIER_CLK_FACTOR(&quot;spll&quot;, -1, &quot;ref&quot;, 120, 1),		/* 2400 MHz */
 	UNIPHIER_CLK_FACTOR(&quot;dapll1&quot;, -1, &quot;ref&quot;, 128, 1),	/* 2560 MHz */
<span class="p_del">-	UNIPHIER_CLK_FACTOR(&quot;dapll2&quot;, -1, &quot;ref&quot;, 144, 125),	/* 2949.12 MHz */</span>
<span class="p_add">+	UNIPHIER_CLK_FACTOR(&quot;dapll2&quot;, -1, &quot;dapll1&quot;, 144, 125),	/* 2949.12 MHz */</span>
 	UNIPHIER_CLK_FACTOR(&quot;uart&quot;, 0, &quot;dapll2&quot;, 1, 40),
 	UNIPHIER_CLK_FACTOR(&quot;i2c&quot;, 1, &quot;spll&quot;, 1, 48),
 	UNIPHIER_PRO5_SYS_CLK_SD,
<span class="p_header">diff --git a/drivers/crypto/s5p-sss.c b/drivers/crypto/s5p-sss.c</span>
<span class="p_header">index dce1af0ce85c..a668286d62cb 100644</span>
<span class="p_header">--- a/drivers/crypto/s5p-sss.c</span>
<span class="p_header">+++ b/drivers/crypto/s5p-sss.c</span>
<span class="p_chunk">@@ -805,8 +805,9 @@</span> <span class="p_context"> static int s5p_aes_probe(struct platform_device *pdev)</span>
 		dev_warn(dev, &quot;feed control interrupt is not available.\n&quot;);
 		goto err_irq;
 	}
<span class="p_del">-	err = devm_request_irq(dev, pdata-&gt;irq_fc, s5p_aes_interrupt,</span>
<span class="p_del">-			       IRQF_SHARED, pdev-&gt;name, pdev);</span>
<span class="p_add">+	err = devm_request_threaded_irq(dev, pdata-&gt;irq_fc, NULL,</span>
<span class="p_add">+					s5p_aes_interrupt, IRQF_ONESHOT,</span>
<span class="p_add">+					pdev-&gt;name, pdev);</span>
 	if (err &lt; 0) {
 		dev_warn(dev, &quot;feed control interrupt is not available.\n&quot;);
 		goto err_irq;
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index e2d323fa2437..1c8d79d93098 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -1232,12 +1232,11 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 			sg_link_tbl_len += authsize;
 	}
 
<span class="p_del">-	sg_count = talitos_sg_map(dev, areq-&gt;src, cryptlen, edesc,</span>
<span class="p_del">-				  &amp;desc-&gt;ptr[4], sg_count, areq-&gt;assoclen,</span>
<span class="p_del">-				  tbl_off);</span>
<span class="p_add">+	ret = talitos_sg_map(dev, areq-&gt;src, sg_link_tbl_len, edesc,</span>
<span class="p_add">+			     &amp;desc-&gt;ptr[4], sg_count, areq-&gt;assoclen, tbl_off);</span>
 
<span class="p_del">-	if (sg_count &gt; 1) {</span>
<span class="p_del">-		tbl_off += sg_count;</span>
<span class="p_add">+	if (ret &gt; 1) {</span>
<span class="p_add">+		tbl_off += ret;</span>
 		sync_needed = true;
 	}
 
<span class="p_chunk">@@ -1248,14 +1247,15 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 			dma_map_sg(dev, areq-&gt;dst, sg_count, DMA_FROM_DEVICE);
 	}
 
<span class="p_del">-	sg_count = talitos_sg_map(dev, areq-&gt;dst, cryptlen, edesc,</span>
<span class="p_del">-				  &amp;desc-&gt;ptr[5], sg_count, areq-&gt;assoclen,</span>
<span class="p_del">-				  tbl_off);</span>
<span class="p_add">+	ret = talitos_sg_map(dev, areq-&gt;dst, cryptlen, edesc, &amp;desc-&gt;ptr[5],</span>
<span class="p_add">+			     sg_count, areq-&gt;assoclen, tbl_off);</span>
 
 	if (desc-&gt;hdr &amp; DESC_HDR_TYPE_IPSEC_ESP)
 		to_talitos_ptr_ext_or(&amp;desc-&gt;ptr[5], authsize, is_sec1);
 
<span class="p_del">-	if (sg_count &gt; 1) {</span>
<span class="p_add">+	/* ICV data */</span>
<span class="p_add">+	if (ret &gt; 1) {</span>
<span class="p_add">+		tbl_off += ret;</span>
 		edesc-&gt;icv_ool = true;
 		sync_needed = true;
 
<span class="p_chunk">@@ -1265,9 +1265,7 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 				     sizeof(struct talitos_ptr) + authsize;
 
 			/* Add an entry to the link table for ICV data */
<span class="p_del">-			tbl_ptr += sg_count - 1;</span>
<span class="p_del">-			to_talitos_ptr_ext_set(tbl_ptr, 0, is_sec1);</span>
<span class="p_del">-			tbl_ptr++;</span>
<span class="p_add">+			to_talitos_ptr_ext_set(tbl_ptr - 1, 0, is_sec1);</span>
 			to_talitos_ptr_ext_set(tbl_ptr, DESC_PTR_LNKTBL_RETURN,
 					       is_sec1);
 			to_talitos_ptr_len(tbl_ptr, authsize, is_sec1);
<span class="p_chunk">@@ -1275,18 +1273,33 @@</span> <span class="p_context"> static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,</span>
 			/* icv data follows link tables */
 			to_talitos_ptr(tbl_ptr, edesc-&gt;dma_link_tbl + offset,
 				       is_sec1);
<span class="p_add">+		} else {</span>
<span class="p_add">+			dma_addr_t addr = edesc-&gt;dma_link_tbl;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (is_sec1)</span>
<span class="p_add">+				addr += areq-&gt;assoclen + cryptlen;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				addr += sizeof(struct talitos_ptr) * tbl_off;</span>
<span class="p_add">+</span>
<span class="p_add">+			to_talitos_ptr(&amp;desc-&gt;ptr[6], addr, is_sec1);</span>
<span class="p_add">+			to_talitos_ptr_len(&amp;desc-&gt;ptr[6], authsize, is_sec1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (!(desc-&gt;hdr &amp; DESC_HDR_TYPE_IPSEC_ESP)) {</span>
<span class="p_add">+		ret = talitos_sg_map(dev, areq-&gt;dst, authsize, edesc,</span>
<span class="p_add">+				     &amp;desc-&gt;ptr[6], sg_count, areq-&gt;assoclen +</span>
<span class="p_add">+							      cryptlen,</span>
<span class="p_add">+				     tbl_off);</span>
<span class="p_add">+		if (ret &gt; 1) {</span>
<span class="p_add">+			tbl_off += ret;</span>
<span class="p_add">+			edesc-&gt;icv_ool = true;</span>
<span class="p_add">+			sync_needed = true;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			edesc-&gt;icv_ool = false;</span>
 		}
 	} else {
 		edesc-&gt;icv_ool = false;
 	}
 
<span class="p_del">-	/* ICV data */</span>
<span class="p_del">-	if (!(desc-&gt;hdr &amp; DESC_HDR_TYPE_IPSEC_ESP)) {</span>
<span class="p_del">-		to_talitos_ptr_len(&amp;desc-&gt;ptr[6], authsize, is_sec1);</span>
<span class="p_del">-		to_talitos_ptr(&amp;desc-&gt;ptr[6], edesc-&gt;dma_link_tbl +</span>
<span class="p_del">-			       areq-&gt;assoclen + cryptlen, is_sec1);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* iv out */
 	if (desc-&gt;hdr &amp; DESC_HDR_TYPE_IPSEC_ESP)
 		map_single_talitos_ptr(dev, &amp;desc-&gt;ptr[6], ivsize, ctx-&gt;iv,
<span class="p_chunk">@@ -1494,12 +1507,20 @@</span> <span class="p_context"> static int ablkcipher_setkey(struct crypto_ablkcipher *cipher,</span>
 			     const u8 *key, unsigned int keylen)
 {
 	struct talitos_ctx *ctx = crypto_ablkcipher_ctx(cipher);
<span class="p_add">+	u32 tmp[DES_EXPKEY_WORDS];</span>
 
 	if (keylen &gt; TALITOS_MAX_KEY_SIZE) {
 		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
 		return -EINVAL;
 	}
 
<span class="p_add">+	if (unlikely(crypto_ablkcipher_get_flags(cipher) &amp;</span>
<span class="p_add">+		     CRYPTO_TFM_REQ_WEAK_KEY) &amp;&amp;</span>
<span class="p_add">+	    !des_ekey(tmp, key)) {</span>
<span class="p_add">+		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_WEAK_KEY);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	memcpy(&amp;ctx-&gt;key, key, keylen);
 	ctx-&gt;keylen = keylen;
 
<span class="p_chunk">@@ -2614,7 +2635,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 				.ivsize = AES_BLOCK_SIZE,
 			}
 		},
<span class="p_del">-		.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |</span>
<span class="p_add">+		.desc_hdr_template = DESC_HDR_TYPE_AESU_CTR_NONSNOOP |</span>
 				     DESC_HDR_SEL0_AESU |
 				     DESC_HDR_MODE0_AESU_CTR,
 	},
<span class="p_chunk">@@ -3047,6 +3068,11 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		t_alg-&gt;algt.alg.aead.setkey = aead_setkey;
 		t_alg-&gt;algt.alg.aead.encrypt = aead_encrypt;
 		t_alg-&gt;algt.alg.aead.decrypt = aead_decrypt;
<span class="p_add">+		if (!(priv-&gt;features &amp; TALITOS_FTR_SHA224_HWINIT) &amp;&amp;</span>
<span class="p_add">+		    !strncmp(alg-&gt;cra_name, &quot;authenc(hmac(sha224)&quot;, 20)) {</span>
<span class="p_add">+			kfree(t_alg);</span>
<span class="p_add">+			return ERR_PTR(-ENOTSUPP);</span>
<span class="p_add">+		}</span>
 		break;
 	case CRYPTO_ALG_TYPE_AHASH:
 		alg = &amp;t_alg-&gt;algt.alg.hash.halg.base;
<span class="p_header">diff --git a/drivers/edac/i5000_edac.c b/drivers/edac/i5000_edac.c</span>
<span class="p_header">index 72e07e3cf718..16e0eb523439 100644</span>
<span class="p_header">--- a/drivers/edac/i5000_edac.c</span>
<span class="p_header">+++ b/drivers/edac/i5000_edac.c</span>
<span class="p_chunk">@@ -227,7 +227,7 @@</span> <span class="p_context"></span>
 #define			NREC_RDWR(x)		(((x)&gt;&gt;11) &amp; 1)
 #define			NREC_RANK(x)		(((x)&gt;&gt;8) &amp; 0x7)
 #define		NRECMEMB		0xC0
<span class="p_del">-#define			NREC_CAS(x)		(((x)&gt;&gt;16) &amp; 0xFFFFFF)</span>
<span class="p_add">+#define			NREC_CAS(x)		(((x)&gt;&gt;16) &amp; 0xFFF)</span>
 #define			NREC_RAS(x)		((x) &amp; 0x7FFF)
 #define		NRECFGLOG		0xC4
 #define		NREEECFBDA		0xC8
<span class="p_chunk">@@ -371,7 +371,7 @@</span> <span class="p_context"> struct i5000_error_info {</span>
 	/* These registers are input ONLY if there was a
 	 * Non-Recoverable Error */
 	u16 nrecmema;		/* Non-Recoverable Mem log A */
<span class="p_del">-	u16 nrecmemb;		/* Non-Recoverable Mem log B */</span>
<span class="p_add">+	u32 nrecmemb;		/* Non-Recoverable Mem log B */</span>
 
 };
 
<span class="p_chunk">@@ -407,7 +407,7 @@</span> <span class="p_context"> static void i5000_get_error_info(struct mem_ctl_info *mci,</span>
 				NERR_FAT_FBD, &amp;info-&gt;nerr_fat_fbd);
 		pci_read_config_word(pvt-&gt;branchmap_werrors,
 				NRECMEMA, &amp;info-&gt;nrecmema);
<span class="p_del">-		pci_read_config_word(pvt-&gt;branchmap_werrors,</span>
<span class="p_add">+		pci_read_config_dword(pvt-&gt;branchmap_werrors,</span>
 				NRECMEMB, &amp;info-&gt;nrecmemb);
 
 		/* Clear the error bits, by writing them back */
<span class="p_chunk">@@ -1293,7 +1293,7 @@</span> <span class="p_context"> static int i5000_init_csrows(struct mem_ctl_info *mci)</span>
 			dimm-&gt;mtype = MEM_FB_DDR2;
 
 			/* ask what device type on this row */
<span class="p_del">-			if (MTR_DRAM_WIDTH(mtr))</span>
<span class="p_add">+			if (MTR_DRAM_WIDTH(mtr) == 8)</span>
 				dimm-&gt;dtype = DEV_X8;
 			else
 				dimm-&gt;dtype = DEV_X4;
<span class="p_header">diff --git a/drivers/edac/i5400_edac.c b/drivers/edac/i5400_edac.c</span>
<span class="p_header">index 6ef6ad1ba16e..2ea2f32e608b 100644</span>
<span class="p_header">--- a/drivers/edac/i5400_edac.c</span>
<span class="p_header">+++ b/drivers/edac/i5400_edac.c</span>
<span class="p_chunk">@@ -368,7 +368,7 @@</span> <span class="p_context"> struct i5400_error_info {</span>
 
 	/* These registers are input ONLY if there was a Non-Rec Error */
 	u16 nrecmema;		/* Non-Recoverable Mem log A */
<span class="p_del">-	u16 nrecmemb;		/* Non-Recoverable Mem log B */</span>
<span class="p_add">+	u32 nrecmemb;		/* Non-Recoverable Mem log B */</span>
 
 };
 
<span class="p_chunk">@@ -458,7 +458,7 @@</span> <span class="p_context"> static void i5400_get_error_info(struct mem_ctl_info *mci,</span>
 				NERR_FAT_FBD, &amp;info-&gt;nerr_fat_fbd);
 		pci_read_config_word(pvt-&gt;branchmap_werrors,
 				NRECMEMA, &amp;info-&gt;nrecmema);
<span class="p_del">-		pci_read_config_word(pvt-&gt;branchmap_werrors,</span>
<span class="p_add">+		pci_read_config_dword(pvt-&gt;branchmap_werrors,</span>
 				NRECMEMB, &amp;info-&gt;nrecmemb);
 
 		/* Clear the error bits, by writing them back */
<span class="p_chunk">@@ -1207,13 +1207,14 @@</span> <span class="p_context"> static int i5400_init_dimms(struct mem_ctl_info *mci)</span>
 
 			dimm-&gt;nr_pages = size_mb &lt;&lt; 8;
 			dimm-&gt;grain = 8;
<span class="p_del">-			dimm-&gt;dtype = MTR_DRAM_WIDTH(mtr) ? DEV_X8 : DEV_X4;</span>
<span class="p_add">+			dimm-&gt;dtype = MTR_DRAM_WIDTH(mtr) == 8 ?</span>
<span class="p_add">+				      DEV_X8 : DEV_X4;</span>
 			dimm-&gt;mtype = MEM_FB_DDR2;
 			/*
 			 * The eccc mechanism is SDDC (aka SECC), with
 			 * is similar to Chipkill.
 			 */
<span class="p_del">-			dimm-&gt;edac_mode = MTR_DRAM_WIDTH(mtr) ?</span>
<span class="p_add">+			dimm-&gt;edac_mode = MTR_DRAM_WIDTH(mtr) == 8 ?</span>
 					  EDAC_S8ECD8ED : EDAC_S4ECD4ED;
 			ndimms++;
 		}
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index a4944e22f294..2f48f848865f 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -120,8 +120,7 @@</span> <span class="p_context"> static ssize_t systab_show(struct kobject *kobj,</span>
 	return str - buf;
 }
 
<span class="p_del">-static struct kobj_attribute efi_attr_systab =</span>
<span class="p_del">-			__ATTR(systab, 0400, systab_show, NULL);</span>
<span class="p_add">+static struct kobj_attribute efi_attr_systab = __ATTR_RO_MODE(systab, 0400);</span>
 
 #define EFI_FIELD(var) efi.var
 
<span class="p_header">diff --git a/drivers/firmware/efi/esrt.c b/drivers/firmware/efi/esrt.c</span>
<span class="p_header">index 14914074f716..307ec1c11276 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/esrt.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/esrt.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> static const struct sysfs_ops esre_attr_ops = {</span>
 };
 
 /* Generic ESRT Entry (&quot;ESRE&quot;) support. */
<span class="p_del">-static ssize_t esre_fw_class_show(struct esre_entry *entry, char *buf)</span>
<span class="p_add">+static ssize_t fw_class_show(struct esre_entry *entry, char *buf)</span>
 {
 	char *str = buf;
 
<span class="p_chunk">@@ -117,18 +117,16 @@</span> <span class="p_context"> static ssize_t esre_fw_class_show(struct esre_entry *entry, char *buf)</span>
 	return str - buf;
 }
 
<span class="p_del">-static struct esre_attribute esre_fw_class = __ATTR(fw_class, 0400,</span>
<span class="p_del">-	esre_fw_class_show, NULL);</span>
<span class="p_add">+static struct esre_attribute esre_fw_class = __ATTR_RO_MODE(fw_class, 0400);</span>
 
 #define esre_attr_decl(name, size, fmt) \
<span class="p_del">-static ssize_t esre_##name##_show(struct esre_entry *entry, char *buf) \</span>
<span class="p_add">+static ssize_t name##_show(struct esre_entry *entry, char *buf) \</span>
 { \
 	return sprintf(buf, fmt &quot;\n&quot;, \
 		       le##size##_to_cpu(entry-&gt;esre.esre1-&gt;name)); \
 } \
 \
<span class="p_del">-static struct esre_attribute esre_##name = __ATTR(name, 0400, \</span>
<span class="p_del">-	esre_##name##_show, NULL)</span>
<span class="p_add">+static struct esre_attribute esre_##name = __ATTR_RO_MODE(name, 0400)</span>
 
 esre_attr_decl(fw_type, 32, &quot;%u&quot;);
 esre_attr_decl(fw_version, 32, &quot;%u&quot;);
<span class="p_chunk">@@ -193,14 +191,13 @@</span> <span class="p_context"> static int esre_create_sysfs_entry(void *esre, int entry_num)</span>
 
 /* support for displaying ESRT fields at the top level */
 #define esrt_attr_decl(name, size, fmt) \
<span class="p_del">-static ssize_t esrt_##name##_show(struct kobject *kobj, \</span>
<span class="p_add">+static ssize_t name##_show(struct kobject *kobj, \</span>
 				  struct kobj_attribute *attr, char *buf)\
 { \
 	return sprintf(buf, fmt &quot;\n&quot;, le##size##_to_cpu(esrt-&gt;name)); \
 } \
 \
<span class="p_del">-static struct kobj_attribute esrt_##name = __ATTR(name, 0400, \</span>
<span class="p_del">-	esrt_##name##_show, NULL)</span>
<span class="p_add">+static struct kobj_attribute esrt_##name = __ATTR_RO_MODE(name, 0400)</span>
 
 esrt_attr_decl(fw_resource_count, 32, &quot;%u&quot;);
 esrt_attr_decl(fw_resource_count_max, 32, &quot;%u&quot;);
<span class="p_chunk">@@ -431,7 +428,7 @@</span> <span class="p_context"> static int __init esrt_sysfs_init(void)</span>
 err_remove_esrt:
 	kobject_put(esrt_kobj);
 err:
<span class="p_del">-	kfree(esrt);</span>
<span class="p_add">+	memunmap(esrt);</span>
 	esrt = NULL;
 	return error;
 }
<span class="p_header">diff --git a/drivers/firmware/efi/runtime-map.c b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">index 8e64b77aeac9..f377609ff141 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_chunk">@@ -63,11 +63,11 @@</span> <span class="p_context"> static ssize_t map_attr_show(struct kobject *kobj, struct attribute *attr,</span>
 	return map_attr-&gt;show(entry, buf);
 }
 
<span class="p_del">-static struct map_attribute map_type_attr = __ATTR_RO(type);</span>
<span class="p_del">-static struct map_attribute map_phys_addr_attr   = __ATTR_RO(phys_addr);</span>
<span class="p_del">-static struct map_attribute map_virt_addr_attr  = __ATTR_RO(virt_addr);</span>
<span class="p_del">-static struct map_attribute map_num_pages_attr  = __ATTR_RO(num_pages);</span>
<span class="p_del">-static struct map_attribute map_attribute_attr  = __ATTR_RO(attribute);</span>
<span class="p_add">+static struct map_attribute map_type_attr = __ATTR_RO_MODE(type, 0400);</span>
<span class="p_add">+static struct map_attribute map_phys_addr_attr = __ATTR_RO_MODE(phys_addr, 0400);</span>
<span class="p_add">+static struct map_attribute map_virt_addr_attr = __ATTR_RO_MODE(virt_addr, 0400);</span>
<span class="p_add">+static struct map_attribute map_num_pages_attr = __ATTR_RO_MODE(num_pages, 0400);</span>
<span class="p_add">+static struct map_attribute map_attribute_attr = __ATTR_RO_MODE(attribute, 0400);</span>
 
 /*
  * These are default attributes that are added for every memmap entry.
<span class="p_header">diff --git a/drivers/gpio/gpio-altera.c b/drivers/gpio/gpio-altera.c</span>
<span class="p_header">index 5bddbd507ca9..3fe6a21e05a5 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-altera.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-altera.c</span>
<span class="p_chunk">@@ -90,21 +90,18 @@</span> <span class="p_context"> static int altera_gpio_irq_set_type(struct irq_data *d,</span>
 
 	altera_gc = gpiochip_get_data(irq_data_get_irq_chip_data(d));
 
<span class="p_del">-	if (type == IRQ_TYPE_NONE)</span>
<span class="p_add">+	if (type == IRQ_TYPE_NONE) {</span>
<span class="p_add">+		irq_set_handler_locked(d, handle_bad_irq);</span>
 		return 0;
<span class="p_del">-	if (type == IRQ_TYPE_LEVEL_HIGH &amp;&amp;</span>
<span class="p_del">-		altera_gc-&gt;interrupt_trigger == IRQ_TYPE_LEVEL_HIGH)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (type == IRQ_TYPE_EDGE_RISING &amp;&amp;</span>
<span class="p_del">-		altera_gc-&gt;interrupt_trigger == IRQ_TYPE_EDGE_RISING)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (type == IRQ_TYPE_EDGE_FALLING &amp;&amp;</span>
<span class="p_del">-		altera_gc-&gt;interrupt_trigger == IRQ_TYPE_EDGE_FALLING)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (type == IRQ_TYPE_EDGE_BOTH &amp;&amp;</span>
<span class="p_del">-		altera_gc-&gt;interrupt_trigger == IRQ_TYPE_EDGE_BOTH)</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (type == altera_gc-&gt;interrupt_trigger) {</span>
<span class="p_add">+		if (type == IRQ_TYPE_LEVEL_HIGH)</span>
<span class="p_add">+			irq_set_handler_locked(d, handle_level_irq);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			irq_set_handler_locked(d, handle_simple_irq);</span>
 		return 0;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
<span class="p_add">+	irq_set_handler_locked(d, handle_bad_irq);</span>
 	return -EINVAL;
 }
 
<span class="p_chunk">@@ -230,7 +227,6 @@</span> <span class="p_context"> static void altera_gpio_irq_edge_handler(struct irq_desc *desc)</span>
 	chained_irq_exit(chip, desc);
 }
 
<span class="p_del">-</span>
 static void altera_gpio_irq_leveL_high_handler(struct irq_desc *desc)
 {
 	struct altera_gpio_chip *altera_gc;
<span class="p_chunk">@@ -310,7 +306,7 @@</span> <span class="p_context"> static int altera_gpio_probe(struct platform_device *pdev)</span>
 	altera_gc-&gt;interrupt_trigger = reg;
 
 	ret = gpiochip_irqchip_add(&amp;altera_gc-&gt;mmchip.gc, &amp;altera_irq_chip, 0,
<span class="p_del">-		handle_simple_irq, IRQ_TYPE_NONE);</span>
<span class="p_add">+		handle_bad_irq, IRQ_TYPE_NONE);</span>
 
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;could not add irqchip\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">index e41d4baebf86..ce9797b6f9c7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_chunk">@@ -2020,8 +2020,11 @@</span> <span class="p_context"> int amdgpu_device_resume(struct drm_device *dev, bool resume, bool fbcon)</span>
 	}
 
 	r = amdgpu_late_init(adev);
<span class="p_del">-	if (r)</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		if (fbcon)</span>
<span class="p_add">+			console_unlock();</span>
 		return r;
<span class="p_add">+	}</span>
 
 	/* pin cursors */
 	list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
<span class="p_header">diff --git a/drivers/gpu/drm/armada/Makefile b/drivers/gpu/drm/armada/Makefile</span>
<span class="p_header">index 26412d2f8c98..ffd673615772 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/armada/Makefile</span>
<span class="p_header">+++ b/drivers/gpu/drm/armada/Makefile</span>
<span class="p_chunk">@@ -4,5 +4,3 @@</span> <span class="p_context"> armada-y	+= armada_510.o</span>
 armada-$(CONFIG_DEBUG_FS) += armada_debugfs.o
 
 obj-$(CONFIG_DRM_ARMADA) := armada.o
<span class="p_del">-</span>
<span class="p_del">-CFLAGS_armada_trace.o := -I$(src)</span>
<span class="p_header">diff --git a/drivers/gpu/drm/exynos/exynos_drm_gem.c b/drivers/gpu/drm/exynos/exynos_drm_gem.c</span>
<span class="p_header">index f2ae72ba7d5a..2abc47b554ab 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/exynos/exynos_drm_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/exynos/exynos_drm_gem.c</span>
<span class="p_chunk">@@ -246,6 +246,15 @@</span> <span class="p_context"> struct exynos_drm_gem *exynos_drm_gem_create(struct drm_device *dev,</span>
 	if (IS_ERR(exynos_gem))
 		return exynos_gem;
 
<span class="p_add">+	if (!is_drm_iommu_supported(dev) &amp;&amp; (flags &amp; EXYNOS_BO_NONCONTIG)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * when no IOMMU is available, all allocated buffers are</span>
<span class="p_add">+		 * contiguous anyway, so drop EXYNOS_BO_NONCONTIG flag</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		flags &amp;= ~EXYNOS_BO_NONCONTIG;</span>
<span class="p_add">+		DRM_WARN(&quot;Non-contiguous allocation is not supported without IOMMU, falling back to contiguous buffer\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* set memory type and cache attribute from user side. */
 	exynos_gem-&gt;flags = flags;
 
<span class="p_header">diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig</span>
<span class="p_header">index cd4599c0523b..db607d51ee2b 100644</span>
<span class="p_header">--- a/drivers/hid/Kconfig</span>
<span class="p_header">+++ b/drivers/hid/Kconfig</span>
<span class="p_chunk">@@ -175,11 +175,11 @@</span> <span class="p_context"> config HID_CHERRY</span>
 	Support for Cherry Cymotion keyboard.
 
 config HID_CHICONY
<span class="p_del">-	tristate &quot;Chicony Tactical pad&quot;</span>
<span class="p_add">+	tristate &quot;Chicony devices&quot;</span>
 	depends on HID
 	default !EXPERT
 	---help---
<span class="p_del">-	Support for Chicony Tactical pad.</span>
<span class="p_add">+	Support for Chicony Tactical pad and special keys on Chicony keyboards.</span>
 
 config HID_CORSAIR
 	tristate &quot;Corsair devices&quot;
<span class="p_header">diff --git a/drivers/hid/hid-chicony.c b/drivers/hid/hid-chicony.c</span>
<span class="p_header">index bc3cec199fee..f04ed9aabc3f 100644</span>
<span class="p_header">--- a/drivers/hid/hid-chicony.c</span>
<span class="p_header">+++ b/drivers/hid/hid-chicony.c</span>
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> static const struct hid_device_id ch_devices[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS2) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_AK1D) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_ACER_SWITCH12) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_JESS, USB_DEVICE_ID_JESS_ZEN_AIO_KBD) },</span>
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, ch_devices);
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index 4f3f5749b0c1..bdde8859e191 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -1906,6 +1906,7 @@</span> <span class="p_context"> static const struct hid_device_id hid_have_special_driver[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A081) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A0C2) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_HUION, USB_DEVICE_ID_HUION_TABLET) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_JESS, USB_DEVICE_ID_JESS_ZEN_AIO_KBD) },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_JESS2, USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD) },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ION, USB_DEVICE_ID_ICADE) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_KENSINGTON, USB_DEVICE_ID_KS_SLIMBLADE) },
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index 08fd3f831d62..433d5f675c03 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -558,6 +558,7 @@</span> <span class="p_context"></span>
 
 #define USB_VENDOR_ID_JESS		0x0c45
 #define USB_DEVICE_ID_JESS_YUREX	0x1010
<span class="p_add">+#define USB_DEVICE_ID_JESS_ZEN_AIO_KBD	0x5112</span>
 
 #define USB_VENDOR_ID_JESS2		0x0f30
 #define USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD 0x0111
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-riic.c b/drivers/i2c/busses/i2c-riic.c</span>
<span class="p_header">index 8f11d347b3ec..c811af4c8d81 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-riic.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-riic.c</span>
<span class="p_chunk">@@ -218,8 +218,12 @@</span> <span class="p_context"> static irqreturn_t riic_tend_isr(int irq, void *data)</span>
 	}
 
 	if (riic-&gt;is_last || riic-&gt;err) {
<span class="p_del">-		riic_clear_set_bit(riic, 0, ICIER_SPIE, RIIC_ICIER);</span>
<span class="p_add">+		riic_clear_set_bit(riic, ICIER_TEIE, ICIER_SPIE, RIIC_ICIER);</span>
 		writeb(ICCR2_SP, riic-&gt;base + RIIC_ICCR2);
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Transfer is complete, but do not send STOP */</span>
<span class="p_add">+		riic_clear_set_bit(riic, ICIER_TEIE, 0, RIIC_ICIER);</span>
<span class="p_add">+		complete(&amp;riic-&gt;msg_done);</span>
 	}
 
 	return IRQ_HANDLED;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index c22454383976..709d6491d243 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -1669,7 +1669,7 @@</span> <span class="p_context"> static int __mlx4_ib_modify_qp(struct ib_qp *ibqp,</span>
 			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) |
 					      ilog2(dev-&gt;dev-&gt;caps.max_gso_sz);
 		else
<span class="p_del">-			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) | 12;</span>
<span class="p_add">+			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) | 13;</span>
 	} else if (attr_mask &amp; IB_QP_PATH_MTU) {
 		if (attr-&gt;path_mtu &lt; IB_MTU_256 || attr-&gt;path_mtu &gt; IB_MTU_4096) {
 			pr_err(&quot;path MTU (%u) is invalid\n&quot;,
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index 786f640fc462..a2120ff0ef4c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -2514,6 +2514,8 @@</span> <span class="p_context"> static int create_umr_res(struct mlx5_ib_dev *dev)</span>
 	qp-&gt;real_qp    = qp;
 	qp-&gt;uobject    = NULL;
 	qp-&gt;qp_type    = MLX5_IB_QPT_REG_UMR;
<span class="p_add">+	qp-&gt;send_cq    = init_attr-&gt;send_cq;</span>
<span class="p_add">+	qp-&gt;recv_cq    = init_attr-&gt;recv_cq;</span>
 
 	attr-&gt;qp_state = IB_QPS_INIT;
 	attr-&gt;port_num = 1;
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 002f8a421efa..88bbc8ccc5e3 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -2245,10 +2245,12 @@</span> <span class="p_context"> static int __domain_mapping(struct dmar_domain *domain, unsigned long iov_pfn,</span>
 		uint64_t tmp;
 
 		if (!sg_res) {
<span class="p_add">+			unsigned int pgoff = sg-&gt;offset &amp; ~PAGE_MASK;</span>
<span class="p_add">+</span>
 			sg_res = aligned_nrpages(sg-&gt;offset, sg-&gt;length);
<span class="p_del">-			sg-&gt;dma_address = ((dma_addr_t)iov_pfn &lt;&lt; VTD_PAGE_SHIFT) + sg-&gt;offset;</span>
<span class="p_add">+			sg-&gt;dma_address = ((dma_addr_t)iov_pfn &lt;&lt; VTD_PAGE_SHIFT) + pgoff;</span>
 			sg-&gt;dma_length = sg-&gt;length;
<span class="p_del">-			pteval = page_to_phys(sg_page(sg)) | prot;</span>
<span class="p_add">+			pteval = (sg_phys(sg) - pgoff) | prot;</span>
 			phys_pfn = pteval &gt;&gt; VTD_PAGE_SHIFT;
 		}
 
<span class="p_chunk">@@ -3894,7 +3896,7 @@</span> <span class="p_context"> static int intel_nontranslate_map_sg(struct device *hddev,</span>
 
 	for_each_sg(sglist, sg, nelems, i) {
 		BUG_ON(!sg_page(sg));
<span class="p_del">-		sg-&gt;dma_address = page_to_phys(sg_page(sg)) + sg-&gt;offset;</span>
<span class="p_add">+		sg-&gt;dma_address = sg_phys(sg);</span>
 		sg-&gt;dma_length = sg-&gt;length;
 	}
 	return nelems;
<span class="p_header">diff --git a/drivers/irqchip/irq-crossbar.c b/drivers/irqchip/irq-crossbar.c</span>
<span class="p_header">index 05bbf171df37..1070b7b959f2 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-crossbar.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-crossbar.c</span>
<span class="p_chunk">@@ -199,7 +199,7 @@</span> <span class="p_context"> static const struct irq_domain_ops crossbar_domain_ops = {</span>
 static int __init crossbar_of_init(struct device_node *node)
 {
 	int i, size, reserved = 0;
<span class="p_del">-	u32 max = 0, entry;</span>
<span class="p_add">+	u32 max = 0, entry, reg_size;</span>
 	const __be32 *irqsr;
 	int ret = -ENOMEM;
 
<span class="p_chunk">@@ -276,9 +276,9 @@</span> <span class="p_context"> static int __init crossbar_of_init(struct device_node *node)</span>
 	if (!cb-&gt;register_offsets)
 		goto err_irq_map;
 
<span class="p_del">-	of_property_read_u32(node, &quot;ti,reg-size&quot;, &amp;size);</span>
<span class="p_add">+	of_property_read_u32(node, &quot;ti,reg-size&quot;, &amp;reg_size);</span>
 
<span class="p_del">-	switch (size) {</span>
<span class="p_add">+	switch (reg_size) {</span>
 	case 1:
 		cb-&gt;write = crossbar_writeb;
 		break;
<span class="p_chunk">@@ -304,7 +304,7 @@</span> <span class="p_context"> static int __init crossbar_of_init(struct device_node *node)</span>
 			continue;
 
 		cb-&gt;register_offsets[i] = reserved;
<span class="p_del">-		reserved += size;</span>
<span class="p_add">+		reserved += reg_size;</span>
 	}
 
 	of_property_read_u32(node, &quot;ti,irqs-safe-map&quot;, &amp;cb-&gt;safe_map);
<span class="p_header">diff --git a/drivers/media/rc/lirc_dev.c b/drivers/media/rc/lirc_dev.c</span>
<span class="p_header">index 6ebe89551961..f4509ef9922b 100644</span>
<span class="p_header">--- a/drivers/media/rc/lirc_dev.c</span>
<span class="p_header">+++ b/drivers/media/rc/lirc_dev.c</span>
<span class="p_chunk">@@ -446,6 +446,8 @@</span> <span class="p_context"> int lirc_dev_fop_open(struct inode *inode, struct file *file)</span>
 		return -ERESTARTSYS;
 
 	ir = irctls[iminor(inode)];
<span class="p_add">+	mutex_unlock(&amp;lirc_dev_lock);</span>
<span class="p_add">+</span>
 	if (!ir) {
 		retval = -ENODEV;
 		goto error;
<span class="p_chunk">@@ -486,8 +488,6 @@</span> <span class="p_context"> int lirc_dev_fop_open(struct inode *inode, struct file *file)</span>
 	}
 
 error:
<span class="p_del">-	mutex_unlock(&amp;lirc_dev_lock);</span>
<span class="p_del">-</span>
 	nonseekable_open(inode, file);
 
 	return retval;
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dibusb-common.c b/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_header">index 8207e6900656..bcacb0f22028 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_chunk">@@ -223,8 +223,20 @@</span> <span class="p_context"> EXPORT_SYMBOL(dibusb_i2c_algo);</span>
 
 int dibusb_read_eeprom_byte(struct dvb_usb_device *d, u8 offs, u8 *val)
 {
<span class="p_del">-	u8 wbuf[1] = { offs };</span>
<span class="p_del">-	return dibusb_i2c_msg(d, 0x50, wbuf, 1, val, 1);</span>
<span class="p_add">+	u8 *buf;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = kmalloc(2, GFP_KERNEL);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf[0] = offs;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = dibusb_i2c_msg(d, 0x50, &amp;buf[0], 1, &amp;buf[1], 1);</span>
<span class="p_add">+	*val = buf[1];</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
 }
 EXPORT_SYMBOL(dibusb_read_eeprom_byte);
 
<span class="p_header">diff --git a/drivers/memory/omap-gpmc.c b/drivers/memory/omap-gpmc.c</span>
<span class="p_header">index 5457c361ad58..bf0fe0137dfe 100644</span>
<span class="p_header">--- a/drivers/memory/omap-gpmc.c</span>
<span class="p_header">+++ b/drivers/memory/omap-gpmc.c</span>
<span class="p_chunk">@@ -1947,9 +1947,7 @@</span> <span class="p_context"> static int gpmc_probe_onenand_child(struct platform_device *pdev,</span>
 	if (!of_property_read_u32(child, &quot;dma-channel&quot;, &amp;val))
 		gpmc_onenand_data-&gt;dma_channel = val;
 
<span class="p_del">-	gpmc_onenand_init(gpmc_onenand_data);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return gpmc_onenand_init(gpmc_onenand_data);</span>
 }
 #else
 static int gpmc_probe_onenand_child(struct platform_device *pdev,
<span class="p_header">diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c</span>
<span class="p_header">index 6749b1829469..4d01d7bc24ef 100644</span>
<span class="p_header">--- a/drivers/net/can/ti_hecc.c</span>
<span class="p_header">+++ b/drivers/net/can/ti_hecc.c</span>
<span class="p_chunk">@@ -652,6 +652,9 @@</span> <span class="p_context"> static int ti_hecc_rx_poll(struct napi_struct *napi, int quota)</span>
 		mbx_mask = hecc_read(priv, HECC_CANMIM);
 		mbx_mask |= HECC_TX_MBOX_MASK;
 		hecc_write(priv, HECC_CANMIM, mbx_mask);
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* repoll is done only if whole budget is used */</span>
<span class="p_add">+		num_pkts = quota;</span>
 	}
 
 	return num_pkts;
<span class="p_header">diff --git a/drivers/net/can/usb/ems_usb.c b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">index b3d02759c226..b00358297424 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_chunk">@@ -288,6 +288,8 @@</span> <span class="p_context"> static void ems_usb_read_interrupt_callback(struct urb *urb)</span>
 
 	case -ECONNRESET: /* unlink */
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/can/usb/esd_usb2.c b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">index 9fdb0f0bfa06..c6dcf93675c0 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_chunk">@@ -393,6 +393,8 @@</span> <span class="p_context"> static void esd_usb2_read_bulk_callback(struct urb *urb)</span>
 		break;
 
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/can/usb/kvaser_usb.c b/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_header">index 4224e066cb16..c9d61a6dfb7a 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/kvaser_usb.c</span>
<span class="p_chunk">@@ -609,8 +609,8 @@</span> <span class="p_context"> static int kvaser_usb_wait_msg(const struct kvaser_usb *dev, u8 id,</span>
 			}
 
 			if (pos + tmp-&gt;len &gt; actual_len) {
<span class="p_del">-				dev_err(dev-&gt;udev-&gt;dev.parent,</span>
<span class="p_del">-					&quot;Format error\n&quot;);</span>
<span class="p_add">+				dev_err_ratelimited(dev-&gt;udev-&gt;dev.parent,</span>
<span class="p_add">+						    &quot;Format error\n&quot;);</span>
 				break;
 			}
 
<span class="p_chunk">@@ -813,6 +813,7 @@</span> <span class="p_context"> static int kvaser_usb_simple_msg_async(struct kvaser_usb_net_priv *priv,</span>
 	if (err) {
 		netdev_err(netdev, &quot;Error transmitting URB\n&quot;);
 		usb_unanchor_urb(urb);
<span class="p_add">+		kfree(buf);</span>
 		usb_free_urb(urb);
 		return err;
 	}
<span class="p_chunk">@@ -1325,6 +1326,8 @@</span> <span class="p_context"> static void kvaser_usb_read_bulk_callback(struct urb *urb)</span>
 	case 0:
 		break;
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 	default:
<span class="p_chunk">@@ -1333,7 +1336,7 @@</span> <span class="p_context"> static void kvaser_usb_read_bulk_callback(struct urb *urb)</span>
 		goto resubmit_urb;
 	}
 
<span class="p_del">-	while (pos &lt;= urb-&gt;actual_length - MSG_HEADER_LEN) {</span>
<span class="p_add">+	while (pos &lt;= (int)(urb-&gt;actual_length - MSG_HEADER_LEN)) {</span>
 		msg = urb-&gt;transfer_buffer + pos;
 
 		/* The Kvaser firmware can only read and write messages that
<span class="p_chunk">@@ -1352,7 +1355,8 @@</span> <span class="p_context"> static void kvaser_usb_read_bulk_callback(struct urb *urb)</span>
 		}
 
 		if (pos + msg-&gt;len &gt; urb-&gt;actual_length) {
<span class="p_del">-			dev_err(dev-&gt;udev-&gt;dev.parent, &quot;Format error\n&quot;);</span>
<span class="p_add">+			dev_err_ratelimited(dev-&gt;udev-&gt;dev.parent,</span>
<span class="p_add">+					    &quot;Format error\n&quot;);</span>
 			break;
 		}
 
<span class="p_chunk">@@ -1768,6 +1772,7 @@</span> <span class="p_context"> static netdev_tx_t kvaser_usb_start_xmit(struct sk_buff *skb,</span>
 		spin_unlock_irqrestore(&amp;priv-&gt;tx_contexts_lock, flags);
 
 		usb_unanchor_urb(urb);
<span class="p_add">+		kfree(buf);</span>
 
 		stats-&gt;tx_dropped++;
 
<span class="p_header">diff --git a/drivers/net/can/usb/usb_8dev.c b/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_header">index d000cb62d6ae..27861c417c94 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_chunk">@@ -524,6 +524,8 @@</span> <span class="p_context"> static void usb_8dev_read_bulk_callback(struct urb *urb)</span>
 		break;
 
 	case -ENOENT:
<span class="p_add">+	case -EPIPE:</span>
<span class="p_add">+	case -EPROTO:</span>
 	case -ESHUTDOWN:
 		return;
 
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">index 4febe60eadc2..5d958b5bb8b1 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_chunk">@@ -13293,17 +13293,15 @@</span> <span class="p_context"> static int bnx2x_init_dev(struct bnx2x *bp, struct pci_dev *pdev,</span>
 	dev-&gt;vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
 		NETIF_F_TSO | NETIF_F_TSO_ECN | NETIF_F_TSO6 | NETIF_F_HIGHDMA;
 
<span class="p_del">-	/* VF with OLD Hypervisor or old PF do not support filtering */</span>
 	if (IS_PF(bp)) {
 		if (chip_is_e1x)
 			bp-&gt;accept_any_vlan = true;
 		else
 			dev-&gt;hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;
<span class="p_del">-#ifdef CONFIG_BNX2X_SRIOV</span>
<span class="p_del">-	} else if (bp-&gt;acquire_resp.pfdev_info.pf_cap &amp; PFVF_CAP_VLAN_FILTER) {</span>
<span class="p_del">-		dev-&gt;hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;</span>
<span class="p_del">-#endif</span>
 	}
<span class="p_add">+	/* For VF we&#39;ll know whether to enable VLAN filtering after</span>
<span class="p_add">+	 * getting a response to CHANNEL_TLV_ACQUIRE from PF.</span>
<span class="p_add">+	 */</span>
 
 	dev-&gt;features |= dev-&gt;hw_features | NETIF_F_HW_VLAN_CTAG_RX;
 	dev-&gt;features |= NETIF_F_HIGHDMA;
<span class="p_chunk">@@ -13735,7 +13733,7 @@</span> <span class="p_context"> static int bnx2x_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)</span>
 	if (!netif_running(bp-&gt;dev)) {
 		DP(BNX2X_MSG_PTP,
 		   &quot;PTP adjfreq called while the interface is down\n&quot;);
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+		return -ENETDOWN;</span>
 	}
 
 	if (ppb &lt; 0) {
<span class="p_chunk">@@ -13794,6 +13792,12 @@</span> <span class="p_context"> static int bnx2x_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)</span>
 {
 	struct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);
 
<span class="p_add">+	if (!netif_running(bp-&gt;dev)) {</span>
<span class="p_add">+		DP(BNX2X_MSG_PTP,</span>
<span class="p_add">+		   &quot;PTP adjtime called while the interface is down\n&quot;);</span>
<span class="p_add">+		return -ENETDOWN;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	DP(BNX2X_MSG_PTP, &quot;PTP adjtime called, delta = %llx\n&quot;, delta);
 
 	timecounter_adjtime(&amp;bp-&gt;timecounter, delta);
<span class="p_chunk">@@ -13806,6 +13810,12 @@</span> <span class="p_context"> static int bnx2x_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)</span>
 	struct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);
 	u64 ns;
 
<span class="p_add">+	if (!netif_running(bp-&gt;dev)) {</span>
<span class="p_add">+		DP(BNX2X_MSG_PTP,</span>
<span class="p_add">+		   &quot;PTP gettime called while the interface is down\n&quot;);</span>
<span class="p_add">+		return -ENETDOWN;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ns = timecounter_read(&amp;bp-&gt;timecounter);
 
 	DP(BNX2X_MSG_PTP, &quot;PTP gettime called, ns = %llu\n&quot;, ns);
<span class="p_chunk">@@ -13821,6 +13831,12 @@</span> <span class="p_context"> static int bnx2x_ptp_settime(struct ptp_clock_info *ptp,</span>
 	struct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);
 	u64 ns;
 
<span class="p_add">+	if (!netif_running(bp-&gt;dev)) {</span>
<span class="p_add">+		DP(BNX2X_MSG_PTP,</span>
<span class="p_add">+		   &quot;PTP settime called while the interface is down\n&quot;);</span>
<span class="p_add">+		return -ENETDOWN;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ns = timespec64_to_ns(ts);
 
 	DP(BNX2X_MSG_PTP, &quot;PTP settime called, ns = %llu\n&quot;, ns);
<span class="p_chunk">@@ -13988,6 +14004,14 @@</span> <span class="p_context"> static int bnx2x_init_one(struct pci_dev *pdev,</span>
 		rc = bnx2x_vfpf_acquire(bp, tx_count, rx_count);
 		if (rc)
 			goto init_one_freemem;
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BNX2X_SRIOV</span>
<span class="p_add">+		/* VF with OLD Hypervisor or old PF do not support filtering */</span>
<span class="p_add">+		if (bp-&gt;acquire_resp.pfdev_info.pf_cap &amp; PFVF_CAP_VLAN_FILTER) {</span>
<span class="p_add">+			dev-&gt;hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;</span>
<span class="p_add">+			dev-&gt;features |= NETIF_F_HW_VLAN_CTAG_FILTER;</span>
<span class="p_add">+		}</span>
<span class="p_add">+#endif</span>
 	}
 
 	/* Enable SRIOV if capability found in configuration space */
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c</span>
<span class="p_header">index 3f77d0863543..c6e059119b22 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c</span>
<span class="p_chunk">@@ -434,7 +434,9 @@</span> <span class="p_context"> static int bnx2x_vf_mac_vlan_config(struct bnx2x *bp,</span>
 
 	/* Add/Remove the filter */
 	rc = bnx2x_config_vlan_mac(bp, &amp;ramrod);
<span class="p_del">-	if (rc &amp;&amp; rc != -EEXIST) {</span>
<span class="p_add">+	if (rc == -EEXIST)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (rc) {</span>
 		BNX2X_ERR(&quot;Failed to %s %s\n&quot;,
 			  filter-&gt;add ? &quot;add&quot; : &quot;delete&quot;,
 			  (filter-&gt;type == BNX2X_VF_FILTER_VLAN_MAC) ?
<span class="p_chunk">@@ -444,6 +446,8 @@</span> <span class="p_context"> static int bnx2x_vf_mac_vlan_config(struct bnx2x *bp,</span>
 		return rc;
 	}
 
<span class="p_add">+	filter-&gt;applied = true;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -471,6 +475,8 @@</span> <span class="p_context"> int bnx2x_vf_mac_vlan_config_list(struct bnx2x *bp, struct bnx2x_virtf *vf,</span>
 		BNX2X_ERR(&quot;Managed only %d/%d filters - rolling back\n&quot;,
 			  i, filters-&gt;count + 1);
 		while (--i &gt;= 0) {
<span class="p_add">+			if (!filters-&gt;filters[i].applied)</span>
<span class="p_add">+				continue;</span>
 			filters-&gt;filters[i].add = !filters-&gt;filters[i].add;
 			bnx2x_vf_mac_vlan_config(bp, vf, qid,
 						 &amp;filters-&gt;filters[i],
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h</span>
<span class="p_header">index 7a6d406f4c11..888d0b6632e8 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h</span>
<span class="p_chunk">@@ -114,6 +114,7 @@</span> <span class="p_context"> struct bnx2x_vf_mac_vlan_filter {</span>
 	(BNX2X_VF_FILTER_MAC | BNX2X_VF_FILTER_VLAN) /*shortcut*/
 
 	bool add;
<span class="p_add">+	bool applied;</span>
 	u8 *mac;
 	u16 vid;
 };
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c</span>
<span class="p_header">index bfae300cf25f..c2d327d9dff0 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c</span>
<span class="p_chunk">@@ -868,7 +868,7 @@</span> <span class="p_context"> int bnx2x_vfpf_set_mcast(struct net_device *dev)</span>
 	struct bnx2x *bp = netdev_priv(dev);
 	struct vfpf_set_q_filters_tlv *req = &amp;bp-&gt;vf2pf_mbox-&gt;req.set_q_filters;
 	struct pfvf_general_resp_tlv *resp = &amp;bp-&gt;vf2pf_mbox-&gt;resp.general_resp;
<span class="p_del">-	int rc, i = 0;</span>
<span class="p_add">+	int rc = 0, i = 0;</span>
 	struct netdev_hw_addr *ha;
 
 	if (bp-&gt;state != BNX2X_STATE_OPEN) {
<span class="p_chunk">@@ -883,6 +883,15 @@</span> <span class="p_context"> int bnx2x_vfpf_set_mcast(struct net_device *dev)</span>
 	/* Get Rx mode requested */
 	DP(NETIF_MSG_IFUP, &quot;dev-&gt;flags = %x\n&quot;, dev-&gt;flags);
 
<span class="p_add">+	/* We support PFVF_MAX_MULTICAST_PER_VF mcast addresses tops */</span>
<span class="p_add">+	if (netdev_mc_count(dev) &gt; PFVF_MAX_MULTICAST_PER_VF) {</span>
<span class="p_add">+		DP(NETIF_MSG_IFUP,</span>
<span class="p_add">+		   &quot;VF supports not more than %d multicast MAC addresses\n&quot;,</span>
<span class="p_add">+		   PFVF_MAX_MULTICAST_PER_VF);</span>
<span class="p_add">+		rc = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	netdev_for_each_mc_addr(ha, dev) {
 		DP(NETIF_MSG_IFUP, &quot;Adding mcast MAC: %pM\n&quot;,
 		   bnx2x_mc_addr(ha));
<span class="p_chunk">@@ -890,16 +899,6 @@</span> <span class="p_context"> int bnx2x_vfpf_set_mcast(struct net_device *dev)</span>
 		i++;
 	}
 
<span class="p_del">-	/* We support four PFVF_MAX_MULTICAST_PER_VF mcast</span>
<span class="p_del">-	  * addresses tops</span>
<span class="p_del">-	  */</span>
<span class="p_del">-	if (i &gt;= PFVF_MAX_MULTICAST_PER_VF) {</span>
<span class="p_del">-		DP(NETIF_MSG_IFUP,</span>
<span class="p_del">-		   &quot;VF supports not more than %d multicast MAC addresses\n&quot;,</span>
<span class="p_del">-		   PFVF_MAX_MULTICAST_PER_VF);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	req-&gt;n_multicast = i;
 	req-&gt;flags |= VFPF_SET_Q_FILTERS_MULTICAST_CHANGED;
 	req-&gt;vf_qid = 0;
<span class="p_chunk">@@ -924,7 +923,7 @@</span> <span class="p_context"> int bnx2x_vfpf_set_mcast(struct net_device *dev)</span>
 out:
 	bnx2x_vfpf_finalize(bp, &amp;req-&gt;first_tlv);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return rc;</span>
 }
 
 /* request pf to add a vlan for the vf */
<span class="p_header">diff --git a/drivers/net/ethernet/ibm/ibmvnic.c b/drivers/net/ethernet/ibm/ibmvnic.c</span>
<span class="p_header">index b8778e7b1f79..7c6c1468628b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ibm/ibmvnic.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ibm/ibmvnic.c</span>
<span class="p_chunk">@@ -404,7 +404,7 @@</span> <span class="p_context"> static int ibmvnic_open(struct net_device *netdev)</span>
 	send_map_query(adapter);
 	for (i = 0; i &lt; rxadd_subcrqs; i++) {
 		init_rx_pool(adapter, &amp;adapter-&gt;rx_pool[i],
<span class="p_del">-			     IBMVNIC_BUFFS_PER_POOL, i,</span>
<span class="p_add">+			     adapter-&gt;req_rx_add_entries_per_subcrq, i,</span>
 			     be64_to_cpu(size_array[i]), 1);
 		if (alloc_rx_pool(adapter, &amp;adapter-&gt;rx_pool[i])) {
 			dev_err(dev, &quot;Couldn&#39;t alloc rx pool\n&quot;);
<span class="p_chunk">@@ -419,23 +419,23 @@</span> <span class="p_context"> static int ibmvnic_open(struct net_device *netdev)</span>
 	for (i = 0; i &lt; tx_subcrqs; i++) {
 		tx_pool = &amp;adapter-&gt;tx_pool[i];
 		tx_pool-&gt;tx_buff =
<span class="p_del">-		    kcalloc(adapter-&gt;max_tx_entries_per_subcrq,</span>
<span class="p_add">+		    kcalloc(adapter-&gt;req_tx_entries_per_subcrq,</span>
 			    sizeof(struct ibmvnic_tx_buff), GFP_KERNEL);
 		if (!tx_pool-&gt;tx_buff)
 			goto tx_pool_alloc_failed;
 
 		if (alloc_long_term_buff(adapter, &amp;tx_pool-&gt;long_term_buff,
<span class="p_del">-					 adapter-&gt;max_tx_entries_per_subcrq *</span>
<span class="p_add">+					 adapter-&gt;req_tx_entries_per_subcrq *</span>
 					 adapter-&gt;req_mtu))
 			goto tx_ltb_alloc_failed;
 
 		tx_pool-&gt;free_map =
<span class="p_del">-		    kcalloc(adapter-&gt;max_tx_entries_per_subcrq,</span>
<span class="p_add">+		    kcalloc(adapter-&gt;req_tx_entries_per_subcrq,</span>
 			    sizeof(int), GFP_KERNEL);
 		if (!tx_pool-&gt;free_map)
 			goto tx_fm_alloc_failed;
 
<span class="p_del">-		for (j = 0; j &lt; adapter-&gt;max_tx_entries_per_subcrq; j++)</span>
<span class="p_add">+		for (j = 0; j &lt; adapter-&gt;req_tx_entries_per_subcrq; j++)</span>
 			tx_pool-&gt;free_map[j] = j;
 
 		tx_pool-&gt;consumer_index = 0;
<span class="p_chunk">@@ -705,6 +705,7 @@</span> <span class="p_context"> static int ibmvnic_xmit(struct sk_buff *skb, struct net_device *netdev)</span>
 	u8 *hdrs = (u8 *)&amp;adapter-&gt;tx_rx_desc_req;
 	struct device *dev = &amp;adapter-&gt;vdev-&gt;dev;
 	struct ibmvnic_tx_buff *tx_buff = NULL;
<span class="p_add">+	struct ibmvnic_sub_crq_queue *tx_scrq;</span>
 	struct ibmvnic_tx_pool *tx_pool;
 	unsigned int tx_send_failed = 0;
 	unsigned int tx_map_failed = 0;
<span class="p_chunk">@@ -724,6 +725,7 @@</span> <span class="p_context"> static int ibmvnic_xmit(struct sk_buff *skb, struct net_device *netdev)</span>
 	int ret = 0;
 
 	tx_pool = &amp;adapter-&gt;tx_pool[queue_num];
<span class="p_add">+	tx_scrq = adapter-&gt;tx_scrq[queue_num];</span>
 	txq = netdev_get_tx_queue(netdev, skb_get_queue_mapping(skb));
 	handle_array = (u64 *)((u8 *)(adapter-&gt;login_rsp_buf) +
 				   be32_to_cpu(adapter-&gt;login_rsp_buf-&gt;
<span class="p_chunk">@@ -744,7 +746,7 @@</span> <span class="p_context"> static int ibmvnic_xmit(struct sk_buff *skb, struct net_device *netdev)</span>
 
 	tx_pool-&gt;consumer_index =
 	    (tx_pool-&gt;consumer_index + 1) %
<span class="p_del">-		adapter-&gt;max_tx_entries_per_subcrq;</span>
<span class="p_add">+		adapter-&gt;req_tx_entries_per_subcrq;</span>
 
 	tx_buff = &amp;tx_pool-&gt;tx_buff[index];
 	tx_buff-&gt;skb = skb;
<span class="p_chunk">@@ -817,7 +819,7 @@</span> <span class="p_context"> static int ibmvnic_xmit(struct sk_buff *skb, struct net_device *netdev)</span>
 
 		if (tx_pool-&gt;consumer_index == 0)
 			tx_pool-&gt;consumer_index =
<span class="p_del">-				adapter-&gt;max_tx_entries_per_subcrq - 1;</span>
<span class="p_add">+				adapter-&gt;req_tx_entries_per_subcrq - 1;</span>
 		else
 			tx_pool-&gt;consumer_index--;
 
<span class="p_chunk">@@ -826,6 +828,14 @@</span> <span class="p_context"> static int ibmvnic_xmit(struct sk_buff *skb, struct net_device *netdev)</span>
 		ret = NETDEV_TX_BUSY;
 		goto out;
 	}
<span class="p_add">+</span>
<span class="p_add">+	atomic_inc(&amp;tx_scrq-&gt;used);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (atomic_read(&amp;tx_scrq-&gt;used) &gt;= adapter-&gt;req_tx_entries_per_subcrq) {</span>
<span class="p_add">+		netdev_info(netdev, &quot;Stopping queue %d\n&quot;, queue_num);</span>
<span class="p_add">+		netif_stop_subqueue(netdev, queue_num);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	tx_packets++;
 	tx_bytes += skb-&gt;len;
 	txq-&gt;trans_start = jiffies;
<span class="p_chunk">@@ -1220,6 +1230,7 @@</span> <span class="p_context"> static struct ibmvnic_sub_crq_queue *init_sub_crq_queue(struct ibmvnic_adapter</span>
 	scrq-&gt;adapter = adapter;
 	scrq-&gt;size = 4 * PAGE_SIZE / sizeof(*scrq-&gt;msgs);
 	scrq-&gt;cur = 0;
<span class="p_add">+	atomic_set(&amp;scrq-&gt;used, 0);</span>
 	scrq-&gt;rx_skb_top = NULL;
 	spin_lock_init(&amp;scrq-&gt;lock);
 
<span class="p_chunk">@@ -1368,14 +1379,28 @@</span> <span class="p_context"> static int ibmvnic_complete_tx(struct ibmvnic_adapter *adapter,</span>
 						 DMA_TO_DEVICE);
 			}
 
<span class="p_del">-			if (txbuff-&gt;last_frag)</span>
<span class="p_add">+			if (txbuff-&gt;last_frag) {</span>
<span class="p_add">+				atomic_dec(&amp;scrq-&gt;used);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (atomic_read(&amp;scrq-&gt;used) &lt;=</span>
<span class="p_add">+				    (adapter-&gt;req_tx_entries_per_subcrq / 2) &amp;&amp;</span>
<span class="p_add">+				    netif_subqueue_stopped(adapter-&gt;netdev,</span>
<span class="p_add">+							   txbuff-&gt;skb)) {</span>
<span class="p_add">+					netif_wake_subqueue(adapter-&gt;netdev,</span>
<span class="p_add">+							    scrq-&gt;pool_index);</span>
<span class="p_add">+					netdev_dbg(adapter-&gt;netdev,</span>
<span class="p_add">+						   &quot;Started queue %d\n&quot;,</span>
<span class="p_add">+						   scrq-&gt;pool_index);</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
 				dev_kfree_skb_any(txbuff-&gt;skb);
<span class="p_add">+			}</span>
 
 			adapter-&gt;tx_pool[pool].free_map[adapter-&gt;tx_pool[pool].
 						     producer_index] = index;
 			adapter-&gt;tx_pool[pool].producer_index =
 			    (adapter-&gt;tx_pool[pool].producer_index + 1) %
<span class="p_del">-			    adapter-&gt;max_tx_entries_per_subcrq;</span>
<span class="p_add">+			    adapter-&gt;req_tx_entries_per_subcrq;</span>
 		}
 		/* remove tx_comp scrq*/
 		next-&gt;tx_comp.first = 0;
<span class="p_header">diff --git a/drivers/net/ethernet/ibm/ibmvnic.h b/drivers/net/ethernet/ibm/ibmvnic.h</span>
<span class="p_header">index dd775d951b73..892eda346e54 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ibm/ibmvnic.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/ibm/ibmvnic.h</span>
<span class="p_chunk">@@ -863,6 +863,7 @@</span> <span class="p_context"> struct ibmvnic_sub_crq_queue {</span>
 	spinlock_t lock;
 	struct sk_buff *rx_skb_top;
 	struct ibmvnic_adapter *adapter;
<span class="p_add">+	atomic_t used;</span>
 };
 
 struct ibmvnic_long_term_buff {
<span class="p_header">diff --git a/drivers/net/phy/spi_ks8995.c b/drivers/net/phy/spi_ks8995.c</span>
<span class="p_header">index 93ffedfa2994..1e2d4f1179da 100644</span>
<span class="p_header">--- a/drivers/net/phy/spi_ks8995.c</span>
<span class="p_header">+++ b/drivers/net/phy/spi_ks8995.c</span>
<span class="p_chunk">@@ -491,13 +491,14 @@</span> <span class="p_context"> static int ks8995_probe(struct spi_device *spi)</span>
 	if (err)
 		return err;
 
<span class="p_del">-	ks-&gt;regs_attr.size = ks-&gt;chip-&gt;regs_size;</span>
 	memcpy(&amp;ks-&gt;regs_attr, &amp;ks8995_registers_attr, sizeof(ks-&gt;regs_attr));
<span class="p_add">+	ks-&gt;regs_attr.size = ks-&gt;chip-&gt;regs_size;</span>
 
 	err = ks8995_reset(ks);
 	if (err)
 		return err;
 
<span class="p_add">+	sysfs_attr_init(&amp;ks-&gt;regs_attr.attr);</span>
 	err = sysfs_create_bin_file(&amp;spi-&gt;dev.kobj, &amp;ks-&gt;regs_attr);
 	if (err) {
 		dev_err(&amp;spi-&gt;dev, &quot;unable to create sysfs file, err=%d\n&quot;,
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">index 8e3c6f4bdaa0..edffe5aeeeb1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_chunk">@@ -4080,8 +4080,8 @@</span> <span class="p_context"> static void brcmf_sdio_firmware_callback(struct device *dev, int err,</span>
 	sdio_release_host(sdiodev-&gt;func[1]);
 fail:
 	brcmf_dbg(TRACE, &quot;failed: dev=%s, err=%d\n&quot;, dev_name(dev), err);
<span class="p_del">-	device_release_driver(dev);</span>
 	device_release_driver(&amp;sdiodev-&gt;func[2]-&gt;dev);
<span class="p_add">+	device_release_driver(dev);</span>
 }
 
 struct brcmf_sdio *brcmf_sdio_probe(struct brcmf_sdio_dev *sdiodev)
<span class="p_header">diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">index d2a28a9d3209..4b462dc21c41 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_chunk">@@ -3047,6 +3047,7 @@</span> <span class="p_context"> static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)</span>
 {
 	struct hwsim_new_radio_params param = { 0 };
 	const char *hwname = NULL;
<span class="p_add">+	int ret;</span>
 
 	param.reg_strict = info-&gt;attrs[HWSIM_ATTR_REG_STRICT_REG];
 	param.p2p_device = info-&gt;attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];
<span class="p_chunk">@@ -3086,7 +3087,9 @@</span> <span class="p_context"> static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)</span>
 		param.regd = hwsim_world_regdom_custom[idx];
 	}
 
<span class="p_del">-	return mac80211_hwsim_new_radio(info, &amp;param);</span>
<span class="p_add">+	ret = mac80211_hwsim_new_radio(info, &amp;param);</span>
<span class="p_add">+	kfree(hwname);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int hwsim_del_radio_nl(struct sk_buff *msg, struct genl_info *info)
<span class="p_header">diff --git a/drivers/rapidio/devices/rio_mport_cdev.c b/drivers/rapidio/devices/rio_mport_cdev.c</span>
<span class="p_header">index 9013a585507e..f32fc704cb7e 100644</span>
<span class="p_header">--- a/drivers/rapidio/devices/rio_mport_cdev.c</span>
<span class="p_header">+++ b/drivers/rapidio/devices/rio_mport_cdev.c</span>
<span class="p_chunk">@@ -964,7 +964,8 @@</span> <span class="p_context"> rio_dma_transfer(struct file *filp, u32 transfer_mode,</span>
 			   req-&gt;sgt.sgl, req-&gt;sgt.nents, dir);
 	if (nents == -EFAULT) {
 		rmcd_error(&quot;Failed to map SG list&quot;);
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+		ret = -EFAULT;</span>
<span class="p_add">+		goto err_pg;</span>
 	}
 
 	ret = do_dma_request(req, xfer, sync, nents);
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">index 4df3cdcf88ce..9c9563312a3d 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_chunk">@@ -8185,11 +8185,17 @@</span> <span class="p_context"> lpfc_cmpl_reg_new_vport(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)</span>
 			spin_lock_irq(shost-&gt;host_lock);
 			vport-&gt;fc_flag |= FC_VPORT_NEEDS_REG_VPI;
 			spin_unlock_irq(shost-&gt;host_lock);
<span class="p_del">-			if (vport-&gt;port_type == LPFC_PHYSICAL_PORT</span>
<span class="p_del">-				&amp;&amp; !(vport-&gt;fc_flag &amp; FC_LOGO_RCVD_DID_CHNG))</span>
<span class="p_del">-				lpfc_issue_init_vfi(vport);</span>
<span class="p_del">-			else</span>
<span class="p_add">+			if (mb-&gt;mbxStatus == MBX_NOT_FINISHED)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			if ((vport-&gt;port_type == LPFC_PHYSICAL_PORT) &amp;&amp;</span>
<span class="p_add">+			    !(vport-&gt;fc_flag &amp; FC_LOGO_RCVD_DID_CHNG)) {</span>
<span class="p_add">+				if (phba-&gt;sli_rev == LPFC_SLI_REV4)</span>
<span class="p_add">+					lpfc_issue_init_vfi(vport);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					lpfc_initial_flogi(vport);</span>
<span class="p_add">+			} else {</span>
 				lpfc_initial_fdisc(vport);
<span class="p_add">+			}</span>
 			break;
 		}
 	} else {
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c</span>
<span class="p_header">index 658e4d15cb71..ce4ac769a9a2 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_dbg.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_dbg.c</span>
<span class="p_chunk">@@ -2707,13 +2707,9 @@</span> <span class="p_context"> ql_dump_buffer(uint32_t level, scsi_qla_host_t *vha, int32_t id,</span>
 	    &quot;%-+5d  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n&quot;, size);
 	ql_dbg(level, vha, id,
 	    &quot;----- -----------------------------------------------\n&quot;);
<span class="p_del">-	for (cnt = 0; cnt &lt; size; cnt++, buf++) {</span>
<span class="p_del">-		if (cnt % 16 == 0)</span>
<span class="p_del">-			ql_dbg(level, vha, id, &quot;%04x:&quot;, cnt &amp; ~0xFU);</span>
<span class="p_del">-		printk(&quot; %02x&quot;, *buf);</span>
<span class="p_del">-		if (cnt % 16 == 15)</span>
<span class="p_del">-			printk(&quot;\n&quot;);</span>
<span class="p_add">+	for (cnt = 0; cnt &lt; size; cnt += 16) {</span>
<span class="p_add">+		ql_dbg(level, vha, id, &quot;%04x: &quot;, cnt);</span>
<span class="p_add">+		print_hex_dump(KERN_CONT, &quot;&quot;, DUMP_PREFIX_NONE, 16, 1,</span>
<span class="p_add">+			       buf + cnt, min(16U, size - cnt), false);</span>
 	}
<span class="p_del">-	if (cnt % 16 != 0)</span>
<span class="p_del">-		printk(&quot;\n&quot;);</span>
 }
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index d8099c7cab00..c7b770075caa 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -2041,11 +2041,13 @@</span> <span class="p_context"> static void __scsi_init_queue(struct Scsi_Host *shost, struct request_queue *q)</span>
 		q-&gt;limits.cluster = 0;
 
 	/*
<span class="p_del">-	 * set a reasonable default alignment on word boundaries: the</span>
<span class="p_del">-	 * host and device may alter it using</span>
<span class="p_del">-	 * blk_queue_update_dma_alignment() later.</span>
<span class="p_add">+	 * Set a reasonable default alignment:  The larger of 32-byte (dword),</span>
<span class="p_add">+	 * which is a common minimum for HBAs, and the minimum DMA alignment,</span>
<span class="p_add">+	 * which is set by the platform.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Devices that require a bigger alignment can increase it later.</span>
 	 */
<span class="p_del">-	blk_queue_dma_alignment(q, 0x03);</span>
<span class="p_add">+	blk_queue_dma_alignment(q, max(4, dma_get_cache_alignment()) - 1);</span>
 }
 
 struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
<span class="p_header">diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig</span>
<span class="p_header">index 8e281e47afec..b7995474148c 100644</span>
<span class="p_header">--- a/drivers/spi/Kconfig</span>
<span class="p_header">+++ b/drivers/spi/Kconfig</span>
<span class="p_chunk">@@ -365,7 +365,6 @@</span> <span class="p_context"> config SPI_FSL_SPI</span>
 config SPI_FSL_DSPI
 	tristate &quot;Freescale DSPI controller&quot;
 	select REGMAP_MMIO
<span class="p_del">-	depends on HAS_DMA</span>
 	depends on SOC_VF610 || SOC_LS1021A || ARCH_LAYERSCAPE || COMPILE_TEST
 	help
 	  This enables support for the Freescale DSPI controller in master
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index c61ddbf94bc7..16c67120d72b 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -3092,15 +3092,10 @@</span> <span class="p_context"> void dwc3_gadget_exit(struct dwc3 *dwc)</span>
 
 int dwc3_gadget_suspend(struct dwc3 *dwc)
 {
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
 	if (!dwc-&gt;gadget_driver)
 		return 0;
 
<span class="p_del">-	ret = dwc3_gadget_run_stop(dwc, false, false);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_add">+	dwc3_gadget_run_stop(dwc, false, false);</span>
 	dwc3_disconnect_gadget(dwc);
 	__dwc3_gadget_stop(dwc);
 
<span class="p_header">diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c</span>
<span class="p_header">index 502a096fc380..a5ca409dc97e 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/configfs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/configfs.c</span>
<span class="p_chunk">@@ -269,6 +269,7 @@</span> <span class="p_context"> static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,</span>
 		ret = unregister_gadget(gi);
 		if (ret)
 			goto err;
<span class="p_add">+		kfree(name);</span>
 	} else {
 		if (gi-&gt;composite.gadget_driver.udc_name) {
 			ret = -EBUSY;
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index 4fce83266926..346a630cebd5 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -2262,9 +2262,18 @@</span> <span class="p_context"> static int __ffs_data_do_os_desc(enum ffs_os_desc_type type,</span>
 		int i;
 
 		if (len &lt; sizeof(*d) ||
<span class="p_del">-		    d-&gt;bFirstInterfaceNumber &gt;= ffs-&gt;interfaces_count ||</span>
<span class="p_del">-		    d-&gt;Reserved1)</span>
<span class="p_add">+		    d-&gt;bFirstInterfaceNumber &gt;= ffs-&gt;interfaces_count)</span>
 			return -EINVAL;
<span class="p_add">+		if (d-&gt;Reserved1 != 1) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * According to the spec, Reserved1 must be set to 1</span>
<span class="p_add">+			 * but older kernels incorrectly rejected non-zero</span>
<span class="p_add">+			 * values.  We fix it here to avoid returning EINVAL</span>
<span class="p_add">+			 * in response to values we used to accept.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			pr_debug(&quot;usb_ext_compat_desc::Reserved1 forced to 1\n&quot;);</span>
<span class="p_add">+			d-&gt;Reserved1 = 1;</span>
<span class="p_add">+		}</span>
 		for (i = 0; i &lt; ARRAY_SIZE(d-&gt;Reserved2); ++i)
 			if (d-&gt;Reserved2[i])
 				return -EINVAL;
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">index f69dbd4bcd18..b8534d3f8bb0 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_chunk">@@ -1819,8 +1819,10 @@</span> <span class="p_context"> dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 
 	spin_lock_irq (&amp;dev-&gt;lock);
 	value = -EINVAL;
<span class="p_del">-	if (dev-&gt;buf)</span>
<span class="p_add">+	if (dev-&gt;buf) {</span>
<span class="p_add">+		kfree(kbuf);</span>
 		goto fail;
<span class="p_add">+	}</span>
 	dev-&gt;buf = kbuf;
 
 	/* full or low speed config */
<span class="p_header">diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_header">index 33f3987218f7..d133252ef2c3 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_chunk">@@ -1146,15 +1146,15 @@</span> <span class="p_context"> static int scan_dma_completions(struct net2280_ep *ep)</span>
 	 */
 	while (!list_empty(&amp;ep-&gt;queue)) {
 		struct net2280_request	*req;
<span class="p_del">-		u32			tmp;</span>
<span class="p_add">+		u32 req_dma_count;</span>
 
 		req = list_entry(ep-&gt;queue.next,
 				struct net2280_request, queue);
 		if (!req-&gt;valid)
 			break;
 		rmb();
<span class="p_del">-		tmp = le32_to_cpup(&amp;req-&gt;td-&gt;dmacount);</span>
<span class="p_del">-		if ((tmp &amp; BIT(VALID_BIT)) != 0)</span>
<span class="p_add">+		req_dma_count = le32_to_cpup(&amp;req-&gt;td-&gt;dmacount);</span>
<span class="p_add">+		if ((req_dma_count &amp; BIT(VALID_BIT)) != 0)</span>
 			break;
 
 		/* SHORT_PACKET_TRANSFERRED_INTERRUPT handles &quot;usb-short&quot;
<span class="p_chunk">@@ -1163,40 +1163,41 @@</span> <span class="p_context"> static int scan_dma_completions(struct net2280_ep *ep)</span>
 		 */
 		if (unlikely(req-&gt;td-&gt;dmadesc == 0)) {
 			/* paranoia */
<span class="p_del">-			tmp = readl(&amp;ep-&gt;dma-&gt;dmacount);</span>
<span class="p_del">-			if (tmp &amp; DMA_BYTE_COUNT_MASK)</span>
<span class="p_add">+			u32 const ep_dmacount = readl(&amp;ep-&gt;dma-&gt;dmacount);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ep_dmacount &amp; DMA_BYTE_COUNT_MASK)</span>
 				break;
 			/* single transfer mode */
<span class="p_del">-			dma_done(ep, req, tmp, 0);</span>
<span class="p_add">+			dma_done(ep, req, req_dma_count, 0);</span>
 			num_completed++;
 			break;
 		} else if (!ep-&gt;is_in &amp;&amp;
 			   (req-&gt;req.length % ep-&gt;ep.maxpacket) &amp;&amp;
 			   !(ep-&gt;dev-&gt;quirks &amp; PLX_PCIE)) {
 
<span class="p_del">-			tmp = readl(&amp;ep-&gt;regs-&gt;ep_stat);</span>
<span class="p_add">+			u32 const ep_stat = readl(&amp;ep-&gt;regs-&gt;ep_stat);</span>
 			/* AVOID TROUBLE HERE by not issuing short reads from
 			 * your gadget driver.  That helps avoids errata 0121,
 			 * 0122, and 0124; not all cases trigger the warning.
 			 */
<span class="p_del">-			if ((tmp &amp; BIT(NAK_OUT_PACKETS)) == 0) {</span>
<span class="p_add">+			if ((ep_stat &amp; BIT(NAK_OUT_PACKETS)) == 0) {</span>
 				ep_warn(ep-&gt;dev, &quot;%s lost packet sync!\n&quot;,
 						ep-&gt;ep.name);
 				req-&gt;req.status = -EOVERFLOW;
 			} else {
<span class="p_del">-				tmp = readl(&amp;ep-&gt;regs-&gt;ep_avail);</span>
<span class="p_del">-				if (tmp) {</span>
<span class="p_add">+				u32 const ep_avail = readl(&amp;ep-&gt;regs-&gt;ep_avail);</span>
<span class="p_add">+				if (ep_avail) {</span>
 					/* fifo gets flushed later */
 					ep-&gt;out_overflow = 1;
 					ep_dbg(ep-&gt;dev,
 						&quot;%s dma, discard %d len %d\n&quot;,
<span class="p_del">-						ep-&gt;ep.name, tmp,</span>
<span class="p_add">+						ep-&gt;ep.name, ep_avail,</span>
 						req-&gt;req.length);
 					req-&gt;req.status = -EOVERFLOW;
 				}
 			}
 		}
<span class="p_del">-		dma_done(ep, req, tmp, 0);</span>
<span class="p_add">+		dma_done(ep, req, req_dma_count, 0);</span>
 		num_completed++;
 	}
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/pxa27x_udc.c b/drivers/usb/gadget/udc/pxa27x_udc.c</span>
<span class="p_header">index 7fa60f5b7ae4..afd6b86458c5 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/pxa27x_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/pxa27x_udc.c</span>
<span class="p_chunk">@@ -2534,9 +2534,10 @@</span> <span class="p_context"> static int pxa_udc_remove(struct platform_device *_dev)</span>
 	usb_del_gadget_udc(&amp;udc-&gt;gadget);
 	pxa_cleanup_debugfs(udc);
 
<span class="p_del">-	if (!IS_ERR_OR_NULL(udc-&gt;transceiver))</span>
<span class="p_add">+	if (!IS_ERR_OR_NULL(udc-&gt;transceiver)) {</span>
 		usb_unregister_notifier(udc-&gt;transceiver, &amp;pxa27x_udc_phy);
<span class="p_del">-	usb_put_phy(udc-&gt;transceiver);</span>
<span class="p_add">+		usb_put_phy(udc-&gt;transceiver);</span>
<span class="p_add">+	}</span>
 
 	udc-&gt;transceiver = NULL;
 	the_controller = NULL;
<span class="p_header">diff --git a/drivers/usb/gadget/udc/renesas_usb3.c b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">index bb89e24c48b4..2197a50ed2ab 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_chunk">@@ -222,7 +222,7 @@</span> <span class="p_context"></span>
 #define USB3_EP0_SS_MAX_PACKET_SIZE	512
 #define USB3_EP0_HSFS_MAX_PACKET_SIZE	64
 #define USB3_EP0_BUF_SIZE		8
<span class="p_del">-#define USB3_MAX_NUM_PIPES		30</span>
<span class="p_add">+#define USB3_MAX_NUM_PIPES		6	/* This includes PIPE 0 */</span>
 #define USB3_WAIT_US			3
 
 struct renesas_usb3;
<span class="p_header">diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c</span>
<span class="p_header">index 7062bb0975a5..462e183609b6 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio.c</span>
<span class="p_chunk">@@ -323,6 +323,8 @@</span> <span class="p_context"> int register_virtio_device(struct virtio_device *dev)</span>
 	/* device_register() causes the bus infrastructure to look for a
 	 * matching driver. */
 	err = device_register(&amp;dev-&gt;dev);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		ida_simple_remove(&amp;virtio_index_ida, dev-&gt;index);</span>
 out:
 	if (err)
 		add_status(dev, VIRTIO_CONFIG_S_FAILED);
<span class="p_header">diff --git a/fs/afs/cmservice.c b/fs/afs/cmservice.c</span>
<span class="p_header">index d764236072b1..8d2c5180e015 100644</span>
<span class="p_header">--- a/fs/afs/cmservice.c</span>
<span class="p_header">+++ b/fs/afs/cmservice.c</span>
<span class="p_chunk">@@ -106,6 +106,9 @@</span> <span class="p_context"> bool afs_cm_incoming_call(struct afs_call *call)</span>
 	case CBProbe:
 		call-&gt;type = &amp;afs_SRXCBProbe;
 		return true;
<span class="p_add">+	case CBProbeUuid:</span>
<span class="p_add">+		call-&gt;type = &amp;afs_SRXCBProbeUuid;</span>
<span class="p_add">+		return true;</span>
 	case CBTellMeAboutYourself:
 		call-&gt;type = &amp;afs_SRXCBTellMeAboutYourself;
 		return true;
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index c4cff5cc9c93..a29730c44850 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -9362,6 +9362,7 @@</span> <span class="p_context"> int btrfs_drop_snapshot(struct btrfs_root *root,</span>
 	ret = btrfs_del_root(trans, tree_root, &amp;root-&gt;root_key);
 	if (ret) {
 		btrfs_abort_transaction(trans, ret);
<span class="p_add">+		err = ret;</span>
 		goto out_end_trans;
 	}
 
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index 65566d5fcf39..1e5321d1ed22 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -2098,7 +2098,7 @@</span> <span class="p_context"> int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 		if (new_inode != NULL)
 			nfs_drop_nlink(new_inode);
 		d_move(old_dentry, new_dentry);
<span class="p_del">-		nfs_set_verifier(new_dentry,</span>
<span class="p_add">+		nfs_set_verifier(old_dentry,</span>
 					nfs_save_change_attribute(new_dir));
 	} else if (error == -ENOENT)
 		nfs_dentry_handle_enoent(old_dentry);
<span class="p_header">diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c</span>
<span class="p_header">index fe9a9a183b2d..98ca9f1b6a07 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.c</span>
<span class="p_chunk">@@ -2386,6 +2386,7 @@</span> <span class="p_context"> xfs_ifree_cluster(</span>
 				 */
 				if (ip-&gt;i_ino != inum + i) {
 					xfs_iunlock(ip, XFS_ILOCK_EXCL);
<span class="p_add">+					rcu_read_unlock();</span>
 					continue;
 				}
 			}
<span class="p_header">diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h</span>
<span class="p_header">index 08528afdf58b..704caae69c42 100644</span>
<span class="p_header">--- a/include/linux/dma-mapping.h</span>
<span class="p_header">+++ b/include/linux/dma-mapping.h</span>
<span class="p_chunk">@@ -659,7 +659,6 @@</span> <span class="p_context"> static inline void *dma_zalloc_coherent(struct device *dev, size_t size,</span>
 	return ret;
 }
 
<span class="p_del">-#ifdef CONFIG_HAS_DMA</span>
 static inline int dma_get_cache_alignment(void)
 {
 #ifdef ARCH_DMA_MINALIGN
<span class="p_chunk">@@ -667,7 +666,6 @@</span> <span class="p_context"> static inline int dma_get_cache_alignment(void)</span>
 #endif
 	return 1;
 }
<span class="p_del">-#endif</span>
 
 /* flags for the coherent memory api */
 #define	DMA_MEMORY_MAP			0x01
<span class="p_header">diff --git a/include/linux/genalloc.h b/include/linux/genalloc.h</span>
<span class="p_header">index 29d4385903d4..206fe3bccccc 100644</span>
<span class="p_header">--- a/include/linux/genalloc.h</span>
<span class="p_header">+++ b/include/linux/genalloc.h</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/types.h&gt;
 #include &lt;linux/spinlock_types.h&gt;
<span class="p_add">+#include &lt;linux/atomic.h&gt;</span>
 
 struct device;
 struct device_node;
<span class="p_chunk">@@ -70,7 +71,7 @@</span> <span class="p_context"> struct gen_pool {</span>
  */
 struct gen_pool_chunk {
 	struct list_head next_chunk;	/* next chunk in pool */
<span class="p_del">-	atomic_t avail;</span>
<span class="p_add">+	atomic_long_t avail;</span>
 	phys_addr_t phys_addr;		/* physical starting address of memory chunk */
 	unsigned long start_addr;	/* start address of memory chunk */
 	unsigned long end_addr;		/* end address of memory chunk (inclusive) */
<span class="p_header">diff --git a/include/linux/mmu_notifier.h b/include/linux/mmu_notifier.h</span>
<span class="p_header">index 25c0dc31f084..854dfa6fa6e3 100644</span>
<span class="p_header">--- a/include/linux/mmu_notifier.h</span>
<span class="p_header">+++ b/include/linux/mmu_notifier.h</span>
<span class="p_chunk">@@ -381,18 +381,6 @@</span> <span class="p_context"> static inline void mmu_notifier_mm_destroy(struct mm_struct *mm)</span>
 	___pmd;								\
 })
 
<span class="p_del">-#define pmdp_huge_get_and_clear_notify(__mm, __haddr, __pmd)		\</span>
<span class="p_del">-({									\</span>
<span class="p_del">-	unsigned long ___haddr = __haddr &amp; HPAGE_PMD_MASK;		\</span>
<span class="p_del">-	pmd_t ___pmd;							\</span>
<span class="p_del">-									\</span>
<span class="p_del">-	___pmd = pmdp_huge_get_and_clear(__mm, __haddr, __pmd);		\</span>
<span class="p_del">-	mmu_notifier_invalidate_range(__mm, ___haddr,			\</span>
<span class="p_del">-				      ___haddr + HPAGE_PMD_SIZE);	\</span>
<span class="p_del">-									\</span>
<span class="p_del">-	___pmd;								\</span>
<span class="p_del">-})</span>
<span class="p_del">-</span>
 /*
  * set_pte_at_notify() sets the pte _after_ running the notifier.
  * This is safe to start by updating the secondary MMUs, because the primary MMU
<span class="p_chunk">@@ -480,7 +468,6 @@</span> <span class="p_context"> static inline void mmu_notifier_mm_destroy(struct mm_struct *mm)</span>
 #define pmdp_clear_young_notify pmdp_test_and_clear_young
 #define	ptep_clear_flush_notify ptep_clear_flush
 #define pmdp_huge_clear_flush_notify pmdp_huge_clear_flush
<span class="p_del">-#define pmdp_huge_get_and_clear_notify pmdp_huge_get_and_clear</span>
 #define set_pte_at_notify set_pte_at
 
 #endif /* CONFIG_MMU_NOTIFIER */
<span class="p_header">diff --git a/include/linux/omap-gpmc.h b/include/linux/omap-gpmc.h</span>
<span class="p_header">index 35d0fd7a4948..e821a3132a3e 100644</span>
<span class="p_header">--- a/include/linux/omap-gpmc.h</span>
<span class="p_header">+++ b/include/linux/omap-gpmc.h</span>
<span class="p_chunk">@@ -88,10 +88,11 @@</span> <span class="p_context"> static inline int gpmc_nand_init(struct omap_nand_platform_data *d,</span>
 #endif
 
 #if IS_ENABLED(CONFIG_MTD_ONENAND_OMAP2)
<span class="p_del">-extern void gpmc_onenand_init(struct omap_onenand_platform_data *d);</span>
<span class="p_add">+extern int gpmc_onenand_init(struct omap_onenand_platform_data *d);</span>
 #else
 #define board_onenand_data	NULL
<span class="p_del">-static inline void gpmc_onenand_init(struct omap_onenand_platform_data *d)</span>
<span class="p_add">+static inline int gpmc_onenand_init(struct omap_onenand_platform_data *d)</span>
 {
<span class="p_add">+	return 0;</span>
 }
 #endif
<span class="p_header">diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h</span>
<span class="p_header">index c6f0f0d0e17e..00a1f330f93a 100644</span>
<span class="p_header">--- a/include/linux/sysfs.h</span>
<span class="p_header">+++ b/include/linux/sysfs.h</span>
<span class="p_chunk">@@ -116,6 +116,12 @@</span> <span class="p_context"> struct attribute_group {</span>
 	.show	= _name##_show,						\
 }
 
<span class="p_add">+#define __ATTR_RO_MODE(_name, _mode) {					\</span>
<span class="p_add">+	.attr	= { .name = __stringify(_name),				\</span>
<span class="p_add">+		    .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },		\</span>
<span class="p_add">+	.show	= _name##_show,						\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define __ATTR_WO(_name) {						\
 	.attr	= { .name = __stringify(_name), .mode = S_IWUSR },	\
 	.store	= _name##_store,					\
<span class="p_header">diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h</span>
<span class="p_header">index dae99d7d2bc0..706a7017885c 100644</span>
<span class="p_header">--- a/include/scsi/libsas.h</span>
<span class="p_header">+++ b/include/scsi/libsas.h</span>
<span class="p_chunk">@@ -165,11 +165,11 @@</span> <span class="p_context"> struct expander_device {</span>
 
 struct sata_device {
 	unsigned int class;
<span class="p_del">-	struct smp_resp        rps_resp; /* report_phy_sata_resp */</span>
 	u8     port_no;        /* port number, if this is a PM (Port) */
 
 	struct ata_port *ap;
 	struct ata_host ata_host;
<span class="p_add">+	struct smp_resp rps_resp ____cacheline_aligned; /* report_phy_sata_resp */</span>
 	u8     fis[ATA_RESP_FIS_SIZE];
 };
 
<span class="p_header">diff --git a/kernel/bpf/percpu_freelist.c b/kernel/bpf/percpu_freelist.c</span>
<span class="p_header">index 5c51d1985b51..673fa6fe2d73 100644</span>
<span class="p_header">--- a/kernel/bpf/percpu_freelist.c</span>
<span class="p_header">+++ b/kernel/bpf/percpu_freelist.c</span>
<span class="p_chunk">@@ -78,8 +78,10 @@</span> <span class="p_context"> struct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)</span>
 {
 	struct pcpu_freelist_head *head;
 	struct pcpu_freelist_node *node;
<span class="p_add">+	unsigned long flags;</span>
 	int orig_cpu, cpu;
 
<span class="p_add">+	local_irq_save(flags);</span>
 	orig_cpu = cpu = raw_smp_processor_id();
 	while (1) {
 		head = per_cpu_ptr(s-&gt;freelist, cpu);
<span class="p_chunk">@@ -87,14 +89,16 @@</span> <span class="p_context"> struct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)</span>
 		node = head-&gt;first;
 		if (node) {
 			head-&gt;first = node-&gt;next;
<span class="p_del">-			raw_spin_unlock(&amp;head-&gt;lock);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;head-&gt;lock, flags);</span>
 			return node;
 		}
 		raw_spin_unlock(&amp;head-&gt;lock);
 		cpu = cpumask_next(cpu, cpu_possible_mask);
 		if (cpu &gt;= nr_cpu_ids)
 			cpu = 0;
<span class="p_del">-		if (cpu == orig_cpu)</span>
<span class="p_add">+		if (cpu == orig_cpu) {</span>
<span class="p_add">+			local_irq_restore(flags);</span>
 			return NULL;
<span class="p_add">+		}</span>
 	}
 }
<span class="p_header">diff --git a/kernel/cpu.c b/kernel/cpu.c</span>
<span class="p_header">index 26a4f74bff83..e1436ca4aed0 100644</span>
<span class="p_header">--- a/kernel/cpu.c</span>
<span class="p_header">+++ b/kernel/cpu.c</span>
<span class="p_chunk">@@ -1321,11 +1321,6 @@</span> <span class="p_context"> static struct cpuhp_step cpuhp_bp_states[] = {</span>
 		.teardown.single	= NULL,
 		.cant_stop		= true,
 	},
<span class="p_del">-	[CPUHP_AP_SMPCFD_DYING] = {</span>
<span class="p_del">-		.name			= &quot;smpcfd:dying&quot;,</span>
<span class="p_del">-		.startup.single		= NULL,</span>
<span class="p_del">-		.teardown.single	= smpcfd_dying_cpu,</span>
<span class="p_del">-	},</span>
 	/*
 	 * Handled on controll processor until the plugged processor manages
 	 * this itself.
<span class="p_chunk">@@ -1367,6 +1362,11 @@</span> <span class="p_context"> static struct cpuhp_step cpuhp_ap_states[] = {</span>
 		.startup.single		= NULL,
 		.teardown.single	= rcutree_dying_cpu,
 	},
<span class="p_add">+	[CPUHP_AP_SMPCFD_DYING] = {</span>
<span class="p_add">+		.name			= &quot;smpcfd:dying&quot;,</span>
<span class="p_add">+		.startup.single		= NULL,</span>
<span class="p_add">+		.teardown.single	= smpcfd_dying_cpu,</span>
<span class="p_add">+	},</span>
 	/* Entry state on starting. Interrupts enabled from here on. Transient
 	 * state for synchronsization */
 	[CPUHP_AP_ONLINE] = {
<span class="p_header">diff --git a/kernel/debug/kdb/kdb_io.c b/kernel/debug/kdb/kdb_io.c</span>
<span class="p_header">index fc1ef736253c..77777d918676 100644</span>
<span class="p_header">--- a/kernel/debug/kdb/kdb_io.c</span>
<span class="p_header">+++ b/kernel/debug/kdb/kdb_io.c</span>
<span class="p_chunk">@@ -349,7 +349,7 @@</span> <span class="p_context"> static char *kdb_read(char *buffer, size_t bufsize)</span>
 			}
 			kdb_printf(&quot;\n&quot;);
 			for (i = 0; i &lt; count; i++) {
<span class="p_del">-				if (kallsyms_symbol_next(p_tmp, i) &lt; 0)</span>
<span class="p_add">+				if (WARN_ON(!kallsyms_symbol_next(p_tmp, i)))</span>
 					break;
 				kdb_printf(&quot;%s &quot;, p_tmp);
 				*(p_tmp + len) = &#39;\0&#39;;
<span class="p_header">diff --git a/kernel/jump_label.c b/kernel/jump_label.c</span>
<span class="p_header">index a9b8cf500591..def4548ea40c 100644</span>
<span class="p_header">--- a/kernel/jump_label.c</span>
<span class="p_header">+++ b/kernel/jump_label.c</span>
<span class="p_chunk">@@ -612,7 +612,7 @@</span> <span class="p_context"> static __init int jump_label_test(void)</span>
 
 	return 0;
 }
<span class="p_del">-late_initcall(jump_label_test);</span>
<span class="p_add">+early_initcall(jump_label_test);</span>
 #endif /* STATIC_KEYS_SELFTEST */
 
 #endif /* HAVE_JUMP_LABEL */
<span class="p_header">diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c</span>
<span class="p_header">index 7a68c631d5b5..3d862f5b0331 100644</span>
<span class="p_header">--- a/kernel/sched/fair.c</span>
<span class="p_header">+++ b/kernel/sched/fair.c</span>
<span class="p_chunk">@@ -5451,7 +5451,7 @@</span> <span class="p_context"> static int select_idle_cpu(struct task_struct *p, struct sched_domain *sd, int t</span>
 	 * Due to large variance we need a large fuzz factor; hackbench in
 	 * particularly is sensitive here.
 	 */
<span class="p_del">-	if ((avg_idle / 512) &lt; avg_cost)</span>
<span class="p_add">+	if (sched_feat(SIS_AVG_CPU) &amp;&amp; (avg_idle / 512) &lt; avg_cost)</span>
 		return -1;
 
 	time = local_clock();
<span class="p_header">diff --git a/kernel/sched/features.h b/kernel/sched/features.h</span>
<span class="p_header">index 69631fa46c2f..1b3c8189b286 100644</span>
<span class="p_header">--- a/kernel/sched/features.h</span>
<span class="p_header">+++ b/kernel/sched/features.h</span>
<span class="p_chunk">@@ -51,6 +51,11 @@</span> <span class="p_context"> SCHED_FEAT(NONTASK_CAPACITY, true)</span>
  */
 SCHED_FEAT(TTWU_QUEUE, true)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * When doing wakeups, attempt to limit superfluous scans of the LLC domain.</span>
<span class="p_add">+ */</span>
<span class="p_add">+SCHED_FEAT(SIS_AVG_CPU, false)</span>
<span class="p_add">+</span>
 #ifdef HAVE_RT_PUSH_IPI
 /*
  * In order to avoid a thundering herd attack of CPUs that are
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index 296dcca77f33..181c2ad0cb54 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -1506,6 +1506,7 @@</span> <span class="p_context"> static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,</span>
 	struct timer_list *timer = &amp;dwork-&gt;timer;
 	struct work_struct *work = &amp;dwork-&gt;work;
 
<span class="p_add">+	WARN_ON_ONCE(!wq);</span>
 	WARN_ON_ONCE(timer-&gt;function != delayed_work_timer_fn ||
 		     timer-&gt;data != (unsigned long)dwork);
 	WARN_ON_ONCE(timer_pending(timer));
<span class="p_header">diff --git a/lib/asn1_decoder.c b/lib/asn1_decoder.c</span>
<span class="p_header">index 1ef0cec38d78..dc14beae2c9a 100644</span>
<span class="p_header">--- a/lib/asn1_decoder.c</span>
<span class="p_header">+++ b/lib/asn1_decoder.c</span>
<span class="p_chunk">@@ -313,42 +313,47 @@</span> <span class="p_context"> int asn1_ber_decoder(const struct asn1_decoder *decoder,</span>
 
 	/* Decide how to handle the operation */
 	switch (op) {
<span class="p_del">-	case ASN1_OP_MATCH_ANY_ACT:</span>
<span class="p_del">-	case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:</span>
<span class="p_del">-	case ASN1_OP_COND_MATCH_ANY_ACT:</span>
<span class="p_del">-	case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:</span>
<span class="p_del">-		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		goto skip_data;</span>
<span class="p_del">-</span>
<span class="p_del">-	case ASN1_OP_MATCH_ACT:</span>
<span class="p_del">-	case ASN1_OP_MATCH_ACT_OR_SKIP:</span>
<span class="p_del">-	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:</span>
<span class="p_del">-		ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		goto skip_data;</span>
<span class="p_del">-</span>
 	case ASN1_OP_MATCH:
 	case ASN1_OP_MATCH_OR_SKIP:
<span class="p_add">+	case ASN1_OP_MATCH_ACT:</span>
<span class="p_add">+	case ASN1_OP_MATCH_ACT_OR_SKIP:</span>
 	case ASN1_OP_MATCH_ANY:
 	case ASN1_OP_MATCH_ANY_OR_SKIP:
<span class="p_add">+	case ASN1_OP_MATCH_ANY_ACT:</span>
<span class="p_add">+	case ASN1_OP_MATCH_ANY_ACT_OR_SKIP:</span>
 	case ASN1_OP_COND_MATCH_OR_SKIP:
<span class="p_add">+	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:</span>
 	case ASN1_OP_COND_MATCH_ANY:
 	case ASN1_OP_COND_MATCH_ANY_OR_SKIP:
<span class="p_del">-	skip_data:</span>
<span class="p_add">+	case ASN1_OP_COND_MATCH_ANY_ACT:</span>
<span class="p_add">+	case ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:</span>
<span class="p_add">+</span>
 		if (!(flags &amp; FLAG_CONS)) {
 			if (flags &amp; FLAG_INDEFINITE_LENGTH) {
<span class="p_add">+				size_t tmp = dp;</span>
<span class="p_add">+</span>
 				ret = asn1_find_indefinite_length(
<span class="p_del">-					data, datalen, &amp;dp, &amp;len, &amp;errmsg);</span>
<span class="p_add">+					data, datalen, &amp;tmp, &amp;len, &amp;errmsg);</span>
 				if (ret &lt; 0)
 					goto error;
<span class="p_del">-			} else {</span>
<span class="p_del">-				dp += len;</span>
 			}
 			pr_debug(&quot;- LEAF: %zu\n&quot;, len);
 		}
<span class="p_add">+</span>
<span class="p_add">+		if (op &amp; ASN1_OP_MATCH__ACT) {</span>
<span class="p_add">+			unsigned char act;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (op &amp; ASN1_OP_MATCH__ANY)</span>
<span class="p_add">+				act = machine[pc + 1];</span>
<span class="p_add">+			else</span>
<span class="p_add">+				act = machine[pc + 2];</span>
<span class="p_add">+			ret = actions[act](context, hdr, tag, data + dp, len);</span>
<span class="p_add">+			if (ret &lt; 0)</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!(flags &amp; FLAG_CONS))</span>
<span class="p_add">+			dp += len;</span>
 		pc += asn1_op_lengths[op];
 		goto next_op;
 
<span class="p_chunk">@@ -434,6 +439,8 @@</span> <span class="p_context"> int asn1_ber_decoder(const struct asn1_decoder *decoder,</span>
 			else
 				act = machine[pc + 1];
 			ret = actions[act](context, hdr, 0, data + tdp, len);
<span class="p_add">+			if (ret &lt; 0)</span>
<span class="p_add">+				return ret;</span>
 		}
 		pc += asn1_op_lengths[op];
 		goto next_op;
<span class="p_header">diff --git a/lib/dynamic_debug.c b/lib/dynamic_debug.c</span>
<span class="p_header">index da796e2dc4f5..c7c96bc7654a 100644</span>
<span class="p_header">--- a/lib/dynamic_debug.c</span>
<span class="p_header">+++ b/lib/dynamic_debug.c</span>
<span class="p_chunk">@@ -360,6 +360,10 @@</span> <span class="p_context"> static int ddebug_parse_query(char *words[], int nwords,</span>
 				if (parse_lineno(last, &amp;query-&gt;last_lineno) &lt; 0)
 					return -EINVAL;
 
<span class="p_add">+				/* special case for last lineno not specified */</span>
<span class="p_add">+				if (query-&gt;last_lineno == 0)</span>
<span class="p_add">+					query-&gt;last_lineno = UINT_MAX;</span>
<span class="p_add">+</span>
 				if (query-&gt;last_lineno &lt; query-&gt;first_lineno) {
 					pr_err(&quot;last-line:%d &lt; 1st-line:%d\n&quot;,
 						query-&gt;last_lineno,
<span class="p_header">diff --git a/lib/genalloc.c b/lib/genalloc.c</span>
<span class="p_header">index 144fe6b1a03e..ca06adc4f445 100644</span>
<span class="p_header">--- a/lib/genalloc.c</span>
<span class="p_header">+++ b/lib/genalloc.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> int gen_pool_add_virt(struct gen_pool *pool, unsigned long virt, phys_addr_t phy</span>
 	chunk-&gt;phys_addr = phys;
 	chunk-&gt;start_addr = virt;
 	chunk-&gt;end_addr = virt + size - 1;
<span class="p_del">-	atomic_set(&amp;chunk-&gt;avail, size);</span>
<span class="p_add">+	atomic_long_set(&amp;chunk-&gt;avail, size);</span>
 
 	spin_lock(&amp;pool-&gt;lock);
 	list_add_rcu(&amp;chunk-&gt;next_chunk, &amp;pool-&gt;chunks);
<span class="p_chunk">@@ -304,7 +304,7 @@</span> <span class="p_context"> unsigned long gen_pool_alloc_algo(struct gen_pool *pool, size_t size,</span>
 	nbits = (size + (1UL &lt;&lt; order) - 1) &gt;&gt; order;
 	rcu_read_lock();
 	list_for_each_entry_rcu(chunk, &amp;pool-&gt;chunks, next_chunk) {
<span class="p_del">-		if (size &gt; atomic_read(&amp;chunk-&gt;avail))</span>
<span class="p_add">+		if (size &gt; atomic_long_read(&amp;chunk-&gt;avail))</span>
 			continue;
 
 		start_bit = 0;
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> unsigned long gen_pool_alloc_algo(struct gen_pool *pool, size_t size,</span>
 
 		addr = chunk-&gt;start_addr + ((unsigned long)start_bit &lt;&lt; order);
 		size = nbits &lt;&lt; order;
<span class="p_del">-		atomic_sub(size, &amp;chunk-&gt;avail);</span>
<span class="p_add">+		atomic_long_sub(size, &amp;chunk-&gt;avail);</span>
 		break;
 	}
 	rcu_read_unlock();
<span class="p_chunk">@@ -390,7 +390,7 @@</span> <span class="p_context"> void gen_pool_free(struct gen_pool *pool, unsigned long addr, size_t size)</span>
 			remain = bitmap_clear_ll(chunk-&gt;bits, start_bit, nbits);
 			BUG_ON(remain);
 			size = nbits &lt;&lt; order;
<span class="p_del">-			atomic_add(size, &amp;chunk-&gt;avail);</span>
<span class="p_add">+			atomic_long_add(size, &amp;chunk-&gt;avail);</span>
 			rcu_read_unlock();
 			return;
 		}
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> size_t gen_pool_avail(struct gen_pool *pool)</span>
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(chunk, &amp;pool-&gt;chunks, next_chunk)
<span class="p_del">-		avail += atomic_read(&amp;chunk-&gt;avail);</span>
<span class="p_add">+		avail += atomic_long_read(&amp;chunk-&gt;avail);</span>
 	rcu_read_unlock();
 	return avail;
 }
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 3cae1dcf069c..c234c078693c 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1509,37 +1509,69 @@</span> <span class="p_context"> int change_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,</span>
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
 	spinlock_t *ptl;
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	pmd_t entry;</span>
<span class="p_add">+	bool preserve_write;</span>
<span class="p_add">+	int ret;</span>
 
 	ptl = __pmd_trans_huge_lock(pmd, vma);
<span class="p_del">-	if (ptl) {</span>
<span class="p_del">-		pmd_t entry;</span>
<span class="p_del">-		bool preserve_write = prot_numa &amp;&amp; pmd_write(*pmd);</span>
<span class="p_del">-		ret = 1;</span>
<span class="p_add">+	if (!ptl)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Avoid trapping faults against the zero page. The read-only</span>
<span class="p_del">-		 * data is likely to be read-cached on the local CPU and</span>
<span class="p_del">-		 * local/remote hits to the zero page are not interesting.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (prot_numa &amp;&amp; is_huge_zero_pmd(*pmd)) {</span>
<span class="p_del">-			spin_unlock(ptl);</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	preserve_write = prot_numa &amp;&amp; pmd_write(*pmd);</span>
<span class="p_add">+	ret = 1;</span>
 
<span class="p_del">-		if (!prot_numa || !pmd_protnone(*pmd)) {</span>
<span class="p_del">-			entry = pmdp_huge_get_and_clear_notify(mm, addr, pmd);</span>
<span class="p_del">-			entry = pmd_modify(entry, newprot);</span>
<span class="p_del">-			if (preserve_write)</span>
<span class="p_del">-				entry = pmd_mkwrite(entry);</span>
<span class="p_del">-			ret = HPAGE_PMD_NR;</span>
<span class="p_del">-			set_pmd_at(mm, addr, pmd, entry);</span>
<span class="p_del">-			BUG_ON(vma_is_anonymous(vma) &amp;&amp; !preserve_write &amp;&amp;</span>
<span class="p_del">-					pmd_write(entry));</span>
<span class="p_del">-		}</span>
<span class="p_del">-		spin_unlock(ptl);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Avoid trapping faults against the zero page. The read-only</span>
<span class="p_add">+	 * data is likely to be read-cached on the local CPU and</span>
<span class="p_add">+	 * local/remote hits to the zero page are not interesting.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (prot_numa &amp;&amp; is_huge_zero_pmd(*pmd))</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (prot_numa &amp;&amp; pmd_protnone(*pmd))</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case prot_numa, we are under down_read(mmap_sem). It&#39;s critical</span>
<span class="p_add">+	 * to not clear pmd intermittently to avoid race with MADV_DONTNEED</span>
<span class="p_add">+	 * which is also under down_read(mmap_sem):</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *	CPU0:				CPU1:</span>
<span class="p_add">+	 *				change_huge_pmd(prot_numa=1)</span>
<span class="p_add">+	 *				 pmdp_huge_get_and_clear_notify()</span>
<span class="p_add">+	 * madvise_dontneed()</span>
<span class="p_add">+	 *  zap_pmd_range()</span>
<span class="p_add">+	 *   pmd_trans_huge(*pmd) == 0 (without ptl)</span>
<span class="p_add">+	 *   // skip the pmd</span>
<span class="p_add">+	 *				 set_pmd_at();</span>
<span class="p_add">+	 *				 // pmd is re-established</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The race makes MADV_DONTNEED miss the huge pmd and don&#39;t clear it</span>
<span class="p_add">+	 * which may break userspace.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * pmdp_invalidate() is required to make sure we don&#39;t miss</span>
<span class="p_add">+	 * dirty/young flags set by hardware.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	entry = *pmd;</span>
<span class="p_add">+	pmdp_invalidate(vma, addr, pmd);</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Recover dirty/young flags.  It relies on pmdp_invalidate to not</span>
<span class="p_add">+	 * corrupt them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pmd_dirty(*pmd))</span>
<span class="p_add">+		entry = pmd_mkdirty(entry);</span>
<span class="p_add">+	if (pmd_young(*pmd))</span>
<span class="p_add">+		entry = pmd_mkyoung(entry);</span>
<span class="p_add">+</span>
<span class="p_add">+	entry = pmd_modify(entry, newprot);</span>
<span class="p_add">+	if (preserve_write)</span>
<span class="p_add">+		entry = pmd_mkwrite(entry);</span>
<span class="p_add">+	ret = HPAGE_PMD_NR;</span>
<span class="p_add">+	set_pmd_at(mm, addr, pmd, entry);</span>
<span class="p_add">+	BUG_ON(vma_is_anonymous(vma) &amp;&amp; !preserve_write &amp;&amp; pmd_write(entry));</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	spin_unlock(ptl);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/mm/zsmalloc.c b/mm/zsmalloc.c</span>
<span class="p_header">index 1689bb58e0d1..d3548c48369f 100644</span>
<span class="p_header">--- a/mm/zsmalloc.c</span>
<span class="p_header">+++ b/mm/zsmalloc.c</span>
<span class="p_chunk">@@ -1407,7 +1407,7 @@</span> <span class="p_context"> void *zs_map_object(struct zs_pool *pool, unsigned long handle,</span>
 	 * pools/users, we can&#39;t allow mapping in interrupt context
 	 * because it can corrupt another users mappings.
 	 */
<span class="p_del">-	WARN_ON_ONCE(in_interrupt());</span>
<span class="p_add">+	BUG_ON(in_interrupt());</span>
 
 	/* From now on, migration cannot move the object */
 	pin_tag(handle);
<span class="p_header">diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c</span>
<span class="p_header">index 713c09a74b90..0c9ded247ebb 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c</span>
<span class="p_chunk">@@ -158,6 +158,10 @@</span> <span class="p_context"> static unsigned int ipv4_conntrack_local(void *priv,</span>
 	if (skb-&gt;len &lt; sizeof(struct iphdr) ||
 	    ip_hdrlen(skb) &lt; sizeof(struct iphdr))
 		return NF_ACCEPT;
<span class="p_add">+</span>
<span class="p_add">+	if (ip_is_fragment(ip_hdr(skb))) /* IP_NODEFRAG setsockopt set */</span>
<span class="p_add">+		return NF_ACCEPT;</span>
<span class="p_add">+</span>
 	return nf_conntrack_in(state-&gt;net, PF_INET, state-&gt;hook, skb);
 }
 
<span class="p_header">diff --git a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c</span>
<span class="p_header">index f8aad03d674b..6f5e8d01b876 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c</span>
<span class="p_chunk">@@ -255,11 +255,6 @@</span> <span class="p_context"> nf_nat_ipv4_fn(void *priv, struct sk_buff *skb,</span>
 	/* maniptype == SRC for postrouting. */
 	enum nf_nat_manip_type maniptype = HOOK2MANIP(state-&gt;hook);
 
<span class="p_del">-	/* We never see fragments: conntrack defrags on pre-routing</span>
<span class="p_del">-	 * and local-out, and nf_nat_out protects post-routing.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	NF_CT_ASSERT(!ip_is_fragment(ip_hdr(skb)));</span>
<span class="p_del">-</span>
 	ct = nf_ct_get(skb, &amp;ctinfo);
 	/* Can&#39;t track?  It&#39;s not due to stress, or conntrack would
 	 * have dropped it.  Hence it&#39;s the user&#39;s responsibilty to
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 6a5b7783932e..7ac319222558 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -630,9 +630,12 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 	struct fnhe_hash_bucket *hash;
 	struct fib_nh_exception *fnhe;
 	struct rtable *rt;
<span class="p_add">+	u32 genid, hval;</span>
 	unsigned int i;
 	int depth;
<span class="p_del">-	u32 hval = fnhe_hashfun(daddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	genid = fnhe_genid(dev_net(nh-&gt;nh_dev));</span>
<span class="p_add">+	hval = fnhe_hashfun(daddr);</span>
 
 	spin_lock_bh(&amp;fnhe_lock);
 
<span class="p_chunk">@@ -655,12 +658,13 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 	}
 
 	if (fnhe) {
<span class="p_add">+		if (fnhe-&gt;fnhe_genid != genid)</span>
<span class="p_add">+			fnhe-&gt;fnhe_genid = genid;</span>
 		if (gw)
 			fnhe-&gt;fnhe_gw = gw;
<span class="p_del">-		if (pmtu) {</span>
<span class="p_add">+		if (pmtu)</span>
 			fnhe-&gt;fnhe_pmtu = pmtu;
<span class="p_del">-			fnhe-&gt;fnhe_expires = max(1UL, expires);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		fnhe-&gt;fnhe_expires = max(1UL, expires);</span>
 		/* Update all cached dsts too */
 		rt = rcu_dereference(fnhe-&gt;fnhe_rth_input);
 		if (rt)
<span class="p_chunk">@@ -679,7 +683,7 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 			fnhe-&gt;fnhe_next = hash-&gt;chain;
 			rcu_assign_pointer(hash-&gt;chain, fnhe);
 		}
<span class="p_del">-		fnhe-&gt;fnhe_genid = fnhe_genid(dev_net(nh-&gt;nh_dev));</span>
<span class="p_add">+		fnhe-&gt;fnhe_genid = genid;</span>
 		fnhe-&gt;fnhe_daddr = daddr;
 		fnhe-&gt;fnhe_gw = gw;
 		fnhe-&gt;fnhe_pmtu = pmtu;
<span class="p_header">diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c</span>
<span class="p_header">index 46ad699937fd..8285a1c108c9 100644</span>
<span class="p_header">--- a/net/ipv6/af_inet6.c</span>
<span class="p_header">+++ b/net/ipv6/af_inet6.c</span>
<span class="p_chunk">@@ -909,12 +909,12 @@</span> <span class="p_context"> static int __init inet6_init(void)</span>
 	err = register_pernet_subsys(&amp;inet6_net_ops);
 	if (err)
 		goto register_pernet_fail;
<span class="p_del">-	err = icmpv6_init();</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto icmp_fail;</span>
 	err = ip6_mr_init();
 	if (err)
 		goto ipmr_fail;
<span class="p_add">+	err = icmpv6_init();</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto icmp_fail;</span>
 	err = ndisc_init();
 	if (err)
 		goto ndisc_fail;
<span class="p_chunk">@@ -1044,10 +1044,10 @@</span> <span class="p_context"> static int __init inet6_init(void)</span>
 	ndisc_cleanup();
 ndisc_fail:
 	ip6_mr_cleanup();
<span class="p_del">-ipmr_fail:</span>
<span class="p_del">-	icmpv6_cleanup();</span>
 icmp_fail:
 	unregister_pernet_subsys(&amp;inet6_net_ops);
<span class="p_add">+ipmr_fail:</span>
<span class="p_add">+	icmpv6_cleanup();</span>
 register_pernet_fail:
 	sock_unregister(PF_INET6);
 	rtnl_unregister_all(PF_INET6);
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index e9b14e3493f2..c46066c5dc27 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -461,7 +461,7 @@</span> <span class="p_context"> static int ip6gre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi)</span>
 				      &amp;ipv6h-&gt;saddr, &amp;ipv6h-&gt;daddr, tpi-&gt;key,
 				      tpi-&gt;proto);
 	if (tunnel) {
<span class="p_del">-		ip6_tnl_rcv(tunnel, skb, tpi, NULL, false);</span>
<span class="p_add">+		ip6_tnl_rcv(tunnel, skb, tpi, NULL, log_ecn_error);</span>
 
 		return PACKET_RCVD;
 	}
<span class="p_header">diff --git a/net/ipv6/ip6_vti.c b/net/ipv6/ip6_vti.c</span>
<span class="p_header">index 67e882d49195..912333586de6 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_vti.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_vti.c</span>
<span class="p_chunk">@@ -485,11 +485,15 @@</span> <span class="p_context"> vti6_xmit(struct sk_buff *skb, struct net_device *dev, struct flowi *fl)</span>
 	if (!skb-&gt;ignore_df &amp;&amp; skb-&gt;len &gt; mtu) {
 		skb_dst(skb)-&gt;ops-&gt;update_pmtu(dst, NULL, skb, mtu);
 
<span class="p_del">-		if (skb-&gt;protocol == htons(ETH_P_IPV6))</span>
<span class="p_add">+		if (skb-&gt;protocol == htons(ETH_P_IPV6)) {</span>
<span class="p_add">+			if (mtu &lt; IPV6_MIN_MTU)</span>
<span class="p_add">+				mtu = IPV6_MIN_MTU;</span>
<span class="p_add">+</span>
 			icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
 				  htonl(mtu));
<span class="p_add">+		}</span>
 
 		return -EMSGSIZE;
 	}
<span class="p_header">diff --git a/net/rds/tcp.c b/net/rds/tcp.c</span>
<span class="p_header">index 20e2923dc827..78f976d32018 100644</span>
<span class="p_header">--- a/net/rds/tcp.c</span>
<span class="p_header">+++ b/net/rds/tcp.c</span>
<span class="p_chunk">@@ -478,9 +478,10 @@</span> <span class="p_context"> static void __net_exit rds_tcp_exit_net(struct net *net)</span>
 	 * we do need to clean up the listen socket here.
 	 */
 	if (rtn-&gt;rds_tcp_listen_sock) {
<span class="p_del">-		rds_tcp_listen_stop(rtn-&gt;rds_tcp_listen_sock);</span>
<span class="p_add">+		struct socket *lsock = rtn-&gt;rds_tcp_listen_sock;</span>
<span class="p_add">+</span>
 		rtn-&gt;rds_tcp_listen_sock = NULL;
<span class="p_del">-		flush_work(&amp;rtn-&gt;rds_tcp_accept_w);</span>
<span class="p_add">+		rds_tcp_listen_stop(lsock, &amp;rtn-&gt;rds_tcp_accept_w);</span>
 	}
 }
 
<span class="p_chunk">@@ -517,10 +518,10 @@</span> <span class="p_context"> static void rds_tcp_kill_sock(struct net *net)</span>
 	struct rds_tcp_connection *tc, *_tc;
 	LIST_HEAD(tmp_list);
 	struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);
<span class="p_add">+	struct socket *lsock = rtn-&gt;rds_tcp_listen_sock;</span>
 
<span class="p_del">-	rds_tcp_listen_stop(rtn-&gt;rds_tcp_listen_sock);</span>
 	rtn-&gt;rds_tcp_listen_sock = NULL;
<span class="p_del">-	flush_work(&amp;rtn-&gt;rds_tcp_accept_w);</span>
<span class="p_add">+	rds_tcp_listen_stop(lsock, &amp;rtn-&gt;rds_tcp_accept_w);</span>
 	spin_lock_irq(&amp;rds_tcp_conn_lock);
 	list_for_each_entry_safe(tc, _tc, &amp;rds_tcp_conn_list, t_tcp_node) {
 		struct net *c_net = read_pnet(&amp;tc-&gt;t_cpath-&gt;cp_conn-&gt;c_net);
<span class="p_chunk">@@ -540,8 +541,12 @@</span> <span class="p_context"> static void rds_tcp_kill_sock(struct net *net)</span>
 void *rds_tcp_listen_sock_def_readable(struct net *net)
 {
 	struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);
<span class="p_add">+	struct socket *lsock = rtn-&gt;rds_tcp_listen_sock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!lsock)</span>
<span class="p_add">+		return NULL;</span>
 
<span class="p_del">-	return rtn-&gt;rds_tcp_listen_sock-&gt;sk-&gt;sk_user_data;</span>
<span class="p_add">+	return lsock-&gt;sk-&gt;sk_user_data;</span>
 }
 
 static int rds_tcp_dev_event(struct notifier_block *this,
<span class="p_header">diff --git a/net/rds/tcp.h b/net/rds/tcp.h</span>
<span class="p_header">index 9a1cc8906576..56ea6620fcf9 100644</span>
<span class="p_header">--- a/net/rds/tcp.h</span>
<span class="p_header">+++ b/net/rds/tcp.h</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> void rds_tcp_state_change(struct sock *sk);</span>
 
 /* tcp_listen.c */
 struct socket *rds_tcp_listen_init(struct net *);
<span class="p_del">-void rds_tcp_listen_stop(struct socket *);</span>
<span class="p_add">+void rds_tcp_listen_stop(struct socket *sock, struct work_struct *acceptor);</span>
 void rds_tcp_listen_data_ready(struct sock *sk);
 int rds_tcp_accept_one(struct socket *sock);
 int rds_tcp_keepalive(struct socket *sock);
<span class="p_header">diff --git a/net/rds/tcp_listen.c b/net/rds/tcp_listen.c</span>
<span class="p_header">index 525b624fec8b..185a56b1e29c 100644</span>
<span class="p_header">--- a/net/rds/tcp_listen.c</span>
<span class="p_header">+++ b/net/rds/tcp_listen.c</span>
<span class="p_chunk">@@ -227,6 +227,9 @@</span> <span class="p_context"> void rds_tcp_listen_data_ready(struct sock *sk)</span>
 	 * before it has been accepted and the accepter has set up their
 	 * data_ready.. we only want to queue listen work for our listening
 	 * socket
<span class="p_add">+	 *</span>
<span class="p_add">+	 * (*ready)() may be null if we are racing with netns delete, and</span>
<span class="p_add">+	 * the listen socket is being torn down.</span>
 	 */
 	if (sk-&gt;sk_state == TCP_LISTEN)
 		rds_tcp_accept_work(sk);
<span class="p_chunk">@@ -235,7 +238,8 @@</span> <span class="p_context"> void rds_tcp_listen_data_ready(struct sock *sk)</span>
 
 out:
 	read_unlock_bh(&amp;sk-&gt;sk_callback_lock);
<span class="p_del">-	ready(sk);</span>
<span class="p_add">+	if (ready)</span>
<span class="p_add">+		ready(sk);</span>
 }
 
 struct socket *rds_tcp_listen_init(struct net *net)
<span class="p_chunk">@@ -275,7 +279,7 @@</span> <span class="p_context"> struct socket *rds_tcp_listen_init(struct net *net)</span>
 	return NULL;
 }
 
<span class="p_del">-void rds_tcp_listen_stop(struct socket *sock)</span>
<span class="p_add">+void rds_tcp_listen_stop(struct socket *sock, struct work_struct *acceptor)</span>
 {
 	struct sock *sk;
 
<span class="p_chunk">@@ -296,5 +300,6 @@</span> <span class="p_context"> void rds_tcp_listen_stop(struct socket *sock)</span>
 
 	/* wait for accepts to stop and close the socket */
 	flush_workqueue(rds_wq);
<span class="p_add">+	flush_work(acceptor);</span>
 	sock_release(sock);
 }
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index c062ceae19e6..c2ab864da50d 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -82,8 +82,8 @@</span> <span class="p_context"></span>
 /* Forward declarations for internal helper functions. */
 static int sctp_writeable(struct sock *sk);
 static void sctp_wfree(struct sk_buff *skb);
<span class="p_del">-static int sctp_wait_for_sndbuf(struct sctp_association *, long *timeo_p,</span>
<span class="p_del">-				size_t msg_len);</span>
<span class="p_add">+static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
<span class="p_add">+				size_t msg_len, struct sock **orig_sk);</span>
 static int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p);
 static int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);
 static int sctp_wait_for_accept(struct sock *sk, long timeo);
<span class="p_chunk">@@ -1957,9 +1957,16 @@</span> <span class="p_context"> static int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)</span>
 
 	timeo = sock_sndtimeo(sk, msg-&gt;msg_flags &amp; MSG_DONTWAIT);
 	if (!sctp_wspace(asoc)) {
<span class="p_del">-		err = sctp_wait_for_sndbuf(asoc, &amp;timeo, msg_len);</span>
<span class="p_del">-		if (err)</span>
<span class="p_add">+		/* sk can be changed by peel off when waiting for buf. */</span>
<span class="p_add">+		err = sctp_wait_for_sndbuf(asoc, &amp;timeo, msg_len, &amp;sk);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			if (err == -ESRCH) {</span>
<span class="p_add">+				/* asoc is already dead. */</span>
<span class="p_add">+				new_asoc = NULL;</span>
<span class="p_add">+				err = -EPIPE;</span>
<span class="p_add">+			}</span>
 			goto out_free;
<span class="p_add">+		}</span>
 	}
 
 	/* If an address is passed with the sendto/sendmsg call, it is used
<span class="p_chunk">@@ -4771,12 +4778,6 @@</span> <span class="p_context"> int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)</span>
 	if (!asoc)
 		return -EINVAL;
 
<span class="p_del">-	/* If there is a thread waiting on more sndbuf space for</span>
<span class="p_del">-	 * sending on this asoc, it cannot be peeled.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (waitqueue_active(&amp;asoc-&gt;wait))</span>
<span class="p_del">-		return -EBUSY;</span>
<span class="p_del">-</span>
 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
<span class="p_chunk">@@ -7440,7 +7441,7 @@</span> <span class="p_context"> void sctp_sock_rfree(struct sk_buff *skb)</span>
 
 /* Helper function to wait for space in the sndbuf.  */
 static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
<span class="p_del">-				size_t msg_len)</span>
<span class="p_add">+				size_t msg_len, struct sock **orig_sk)</span>
 {
 	struct sock *sk = asoc-&gt;base.sk;
 	int err = 0;
<span class="p_chunk">@@ -7457,10 +7458,11 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 	for (;;) {
 		prepare_to_wait_exclusive(&amp;asoc-&gt;wait, &amp;wait,
 					  TASK_INTERRUPTIBLE);
<span class="p_add">+		if (asoc-&gt;base.dead)</span>
<span class="p_add">+			goto do_dead;</span>
 		if (!*timeo_p)
 			goto do_nonblock;
<span class="p_del">-		if (sk-&gt;sk_err || asoc-&gt;state &gt;= SCTP_STATE_SHUTDOWN_PENDING ||</span>
<span class="p_del">-		    asoc-&gt;base.dead)</span>
<span class="p_add">+		if (sk-&gt;sk_err || asoc-&gt;state &gt;= SCTP_STATE_SHUTDOWN_PENDING)</span>
 			goto do_error;
 		if (signal_pending(current))
 			goto do_interrupted;
<span class="p_chunk">@@ -7473,11 +7475,17 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
 		lock_sock(sk);
<span class="p_add">+		if (sk != asoc-&gt;base.sk) {</span>
<span class="p_add">+			release_sock(sk);</span>
<span class="p_add">+			sk = asoc-&gt;base.sk;</span>
<span class="p_add">+			lock_sock(sk);</span>
<span class="p_add">+		}</span>
 
 		*timeo_p = current_timeo;
 	}
 
 out:
<span class="p_add">+	*orig_sk = sk;</span>
 	finish_wait(&amp;asoc-&gt;wait, &amp;wait);
 
 	/* Release the association&#39;s refcnt.  */
<span class="p_chunk">@@ -7485,6 +7493,10 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 
 	return err;
 
<span class="p_add">+do_dead:</span>
<span class="p_add">+	err = -ESRCH;</span>
<span class="p_add">+	goto out;</span>
<span class="p_add">+</span>
 do_error:
 	err = -EPIPE;
 	goto out;
<span class="p_header">diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c</span>
<span class="p_header">index 5db68b371db2..600eacce653a 100644</span>
<span class="p_header">--- a/net/sunrpc/sched.c</span>
<span class="p_header">+++ b/net/sunrpc/sched.c</span>
<span class="p_chunk">@@ -274,10 +274,9 @@</span> <span class="p_context"> static inline void rpc_task_set_debuginfo(struct rpc_task *task)</span>
 
 static void rpc_set_active(struct rpc_task *task)
 {
<span class="p_del">-	trace_rpc_task_begin(task-&gt;tk_client, task, NULL);</span>
<span class="p_del">-</span>
 	rpc_task_set_debuginfo(task);
 	set_bit(RPC_TASK_ACTIVE, &amp;task-&gt;tk_runstate);
<span class="p_add">+	trace_rpc_task_begin(task-&gt;tk_client, task, NULL);</span>
 }
 
 /*
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index 8ce5711ea21b..f19e6a57e118 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -1393,6 +1393,7 @@</span> <span class="p_context"> static struct xfrm_policy *clone_policy(const struct xfrm_policy *old, int dir)</span>
 		newp-&gt;xfrm_nr = old-&gt;xfrm_nr;
 		newp-&gt;index = old-&gt;index;
 		newp-&gt;type = old-&gt;type;
<span class="p_add">+		newp-&gt;family = old-&gt;family;</span>
 		memcpy(newp-&gt;xfrm_vec, old-&gt;xfrm_vec,
 		       newp-&gt;xfrm_nr*sizeof(struct xfrm_tmpl));
 		spin_lock_bh(&amp;net-&gt;xfrm.xfrm_policy_lock);
<span class="p_header">diff --git a/scripts/coccicheck b/scripts/coccicheck</span>
<span class="p_header">index ec487b8e7051..c36b04b41686 100755</span>
<span class="p_header">--- a/scripts/coccicheck</span>
<span class="p_header">+++ b/scripts/coccicheck</span>
<span class="p_chunk">@@ -29,12 +29,6 @@</span> <span class="p_context"> else</span>
 	VERBOSE=0
 fi
 
<span class="p_del">-if [ -z &quot;$J&quot; ]; then</span>
<span class="p_del">-	NPROC=$(getconf _NPROCESSORS_ONLN)</span>
<span class="p_del">-else</span>
<span class="p_del">-	NPROC=&quot;$J&quot;</span>
<span class="p_del">-fi</span>
<span class="p_del">-</span>
 FLAGS=&quot;--very-quiet&quot;
 
 # You can use SPFLAGS to append extra arguments to coccicheck or override any
<span class="p_chunk">@@ -69,6 +63,9 @@</span> <span class="p_context"> if [ &quot;$C&quot; = &quot;1&quot; -o &quot;$C&quot; = &quot;2&quot; ]; then</span>
     # Take only the last argument, which is the C file to test
     shift $(( $# - 1 ))
     OPTIONS=&quot;$COCCIINCLUDE $1&quot;
<span class="p_add">+</span>
<span class="p_add">+    # No need to parallelize Coccinelle since this mode takes one input file.</span>
<span class="p_add">+    NPROC=1</span>
 else
     ONLINE=0
     if [ &quot;$KBUILD_EXTMOD&quot; = &quot;&quot; ] ; then
<span class="p_chunk">@@ -76,6 +73,12 @@</span> <span class="p_context"> else</span>
     else
         OPTIONS=&quot;--dir $KBUILD_EXTMOD $COCCIINCLUDE&quot;
     fi
<span class="p_add">+</span>
<span class="p_add">+    if [ -z &quot;$J&quot; ]; then</span>
<span class="p_add">+        NPROC=$(getconf _NPROCESSORS_ONLN)</span>
<span class="p_add">+    else</span>
<span class="p_add">+        NPROC=&quot;$J&quot;</span>
<span class="p_add">+    fi</span>
 fi
 
 if [ &quot;$KBUILD_EXTMOD&quot; != &quot;&quot; ] ; then
<span class="p_header">diff --git a/scripts/module-common.lds b/scripts/module-common.lds</span>
<span class="p_header">index 73a2c7da0e55..53234e85192a 100644</span>
<span class="p_header">--- a/scripts/module-common.lds</span>
<span class="p_header">+++ b/scripts/module-common.lds</span>
<span class="p_chunk">@@ -19,4 +19,6 @@</span> <span class="p_context"> SECTIONS {</span>
 
 	. = ALIGN(8);
 	.init_array		0 : { *(SORT(.init_array.*)) *(.init_array) }
<span class="p_add">+</span>
<span class="p_add">+	__jump_table		0 : ALIGN(8) { KEEP(*(__jump_table)) }</span>
 }
<span class="p_header">diff --git a/scripts/package/Makefile b/scripts/package/Makefile</span>
<span class="p_header">index 71b4a8af9d4d..7badec3498b8 100644</span>
<span class="p_header">--- a/scripts/package/Makefile</span>
<span class="p_header">+++ b/scripts/package/Makefile</span>
<span class="p_chunk">@@ -39,10 +39,9 @@</span> <span class="p_context"> if test &quot;$(objtree)&quot; != &quot;$(srctree)&quot;; then \</span>
 	false; \
 fi ; \
 $(srctree)/scripts/setlocalversion --save-scmversion; \
<span class="p_del">-ln -sf $(srctree) $(2); \</span>
 tar -cz $(RCS_TAR_IGNORE) -f $(2).tar.gz \
<span class="p_del">-	$(addprefix $(2)/,$(TAR_CONTENT) $(3)); \</span>
<span class="p_del">-rm -f $(2) $(objtree)/.scmversion</span>
<span class="p_add">+	--transform &#39;s:^:$(2)/:S&#39; $(TAR_CONTENT) $(3); \</span>
<span class="p_add">+rm -f $(objtree)/.scmversion</span>
 
 # rpm-pkg
 # ---------------------------------------------------------------------------
<span class="p_header">diff --git a/security/keys/request_key.c b/security/keys/request_key.c</span>
<span class="p_header">index 5030fcf23681..cb7f8f730c6d 100644</span>
<span class="p_header">--- a/security/keys/request_key.c</span>
<span class="p_header">+++ b/security/keys/request_key.c</span>
<span class="p_chunk">@@ -250,11 +250,12 @@</span> <span class="p_context"> static int construct_key(struct key *key, const void *callout_info,</span>
  * The keyring selected is returned with an extra reference upon it which the
  * caller must release.
  */
<span class="p_del">-static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
<span class="p_add">+static int construct_get_dest_keyring(struct key **_dest_keyring)</span>
 {
 	struct request_key_auth *rka;
 	const struct cred *cred = current_cred();
 	struct key *dest_keyring = *_dest_keyring, *authkey;
<span class="p_add">+	int ret;</span>
 
 	kenter(&quot;%p&quot;, dest_keyring);
 
<span class="p_chunk">@@ -263,6 +264,8 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 		/* the caller supplied one */
 		key_get(dest_keyring);
 	} else {
<span class="p_add">+		bool do_perm_check = true;</span>
<span class="p_add">+</span>
 		/* use a default keyring; falling through the cases until we
 		 * find one that we actually have */
 		switch (cred-&gt;jit_keyring) {
<span class="p_chunk">@@ -277,8 +280,10 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 					dest_keyring =
 						key_get(rka-&gt;dest_keyring);
 				up_read(&amp;authkey-&gt;sem);
<span class="p_del">-				if (dest_keyring)</span>
<span class="p_add">+				if (dest_keyring) {</span>
<span class="p_add">+					do_perm_check = false;</span>
 					break;
<span class="p_add">+				}</span>
 			}
 
 		case KEY_REQKEY_DEFL_THREAD_KEYRING:
<span class="p_chunk">@@ -313,11 +318,29 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 		default:
 			BUG();
 		}
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Require Write permission on the keyring.  This is essential</span>
<span class="p_add">+		 * because the default keyring may be the session keyring, and</span>
<span class="p_add">+		 * joining a keyring only requires Search permission.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * However, this check is skipped for the &quot;requestor keyring&quot; so</span>
<span class="p_add">+		 * that /sbin/request-key can itself use request_key() to add</span>
<span class="p_add">+		 * keys to the original requestor&#39;s destination keyring.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (dest_keyring &amp;&amp; do_perm_check) {</span>
<span class="p_add">+			ret = key_permission(make_key_ref(dest_keyring, 1),</span>
<span class="p_add">+					     KEY_NEED_WRITE);</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				key_put(dest_keyring);</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	*_dest_keyring = dest_keyring;
 	kleave(&quot; [dk %d]&quot;, key_serial(dest_keyring));
<span class="p_del">-	return;</span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -443,11 +466,15 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct keyring_search_context *ctx,</span>
 	if (ctx-&gt;index_key.type == &amp;key_type_keyring)
 		return ERR_PTR(-EPERM);
 
<span class="p_del">-	user = key_user_lookup(current_fsuid());</span>
<span class="p_del">-	if (!user)</span>
<span class="p_del">-		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	ret = construct_get_dest_keyring(&amp;dest_keyring);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto error;</span>
 
<span class="p_del">-	construct_get_dest_keyring(&amp;dest_keyring);</span>
<span class="p_add">+	user = key_user_lookup(current_fsuid());</span>
<span class="p_add">+	if (!user) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto error_put_dest_keyring;</span>
<span class="p_add">+	}</span>
 
 	ret = construct_alloc_key(ctx, dest_keyring, flags, user, &amp;key);
 	key_user_put(user);
<span class="p_chunk">@@ -462,7 +489,7 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct keyring_search_context *ctx,</span>
 	} else if (ret == -EINPROGRESS) {
 		ret = 0;
 	} else {
<span class="p_del">-		goto couldnt_alloc_key;</span>
<span class="p_add">+		goto error_put_dest_keyring;</span>
 	}
 
 	key_put(dest_keyring);
<span class="p_chunk">@@ -472,8 +499,9 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct keyring_search_context *ctx,</span>
 construction_failed:
 	key_negate_and_link(key, key_negative_timeout, NULL, NULL);
 	key_put(key);
<span class="p_del">-couldnt_alloc_key:</span>
<span class="p_add">+error_put_dest_keyring:</span>
 	key_put(dest_keyring);
<span class="p_add">+error:</span>
 	kleave(&quot; = %d&quot;, ret);
 	return ERR_PTR(ret);
 }
<span class="p_header">diff --git a/sound/core/pcm.c b/sound/core/pcm.c</span>
<span class="p_header">index 8e980aa678d0..074363b63cc4 100644</span>
<span class="p_header">--- a/sound/core/pcm.c</span>
<span class="p_header">+++ b/sound/core/pcm.c</span>
<span class="p_chunk">@@ -149,7 +149,9 @@</span> <span class="p_context"> static int snd_pcm_control_ioctl(struct snd_card *card,</span>
 				err = -ENXIO;
 				goto _error;
 			}
<span class="p_add">+			mutex_lock(&amp;pcm-&gt;open_mutex);</span>
 			err = snd_pcm_info_user(substream, info);
<span class="p_add">+			mutex_unlock(&amp;pcm-&gt;open_mutex);</span>
 		_error:
 			mutex_unlock(&amp;register_mutex);
 			return err;
<span class="p_header">diff --git a/sound/core/seq/seq_timer.c b/sound/core/seq/seq_timer.c</span>
<span class="p_header">index 37d9cfbc29f9..b80985fbc334 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_timer.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_timer.c</span>
<span class="p_chunk">@@ -355,7 +355,7 @@</span> <span class="p_context"> static int initialize_timer(struct snd_seq_timer *tmr)</span>
 	unsigned long freq;
 
 	t = tmr-&gt;timeri-&gt;timer;
<span class="p_del">-	if (snd_BUG_ON(!t))</span>
<span class="p_add">+	if (!t)</span>
 		return -EINVAL;
 
 	freq = tmr-&gt;preferred_resolution;
<span class="p_header">diff --git a/sound/soc/sh/rcar/ssiu.c b/sound/soc/sh/rcar/ssiu.c</span>
<span class="p_header">index 6f9b388ec5a8..3f95d6b88f8c 100644</span>
<span class="p_header">--- a/sound/soc/sh/rcar/ssiu.c</span>
<span class="p_header">+++ b/sound/soc/sh/rcar/ssiu.c</span>
<span class="p_chunk">@@ -44,7 +44,11 @@</span> <span class="p_context"> static int rsnd_ssiu_init(struct rsnd_mod *mod,</span>
 	mask1 = (1 &lt;&lt; 4) | (1 &lt;&lt; 20);	/* mask sync bit */
 	mask2 = (1 &lt;&lt; 4);		/* mask sync bit */
 	val1  = val2  = 0;
<span class="p_del">-	if (rsnd_ssi_is_pin_sharing(io)) {</span>
<span class="p_add">+	if (id == 8) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * SSI8 pin is sharing with SSI7, nothing to do.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+	} else if (rsnd_ssi_is_pin_sharing(io)) {</span>
 		int shift = -1;
 
 		switch (id) {
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 9133d3e53d9d..24c897f0b571 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -204,6 +204,10 @@</span> <span class="p_context"> static int snd_usb_copy_string_desc(struct mixer_build *state,</span>
 				    int index, char *buf, int maxlen)
 {
 	int len = usb_string(state-&gt;chip-&gt;dev, index, buf, maxlen - 1);
<span class="p_add">+</span>
<span class="p_add">+	if (len &lt; 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	buf[len] = 0;
 	return len;
 }
<span class="p_chunk">@@ -2168,13 +2172,14 @@</span> <span class="p_context"> static int parse_audio_selector_unit(struct mixer_build *state, int unitid,</span>
 	if (len)
 		;
 	else if (nameid)
<span class="p_del">-		snd_usb_copy_string_desc(state, nameid, kctl-&gt;id.name,</span>
<span class="p_add">+		len = snd_usb_copy_string_desc(state, nameid, kctl-&gt;id.name,</span>
 					 sizeof(kctl-&gt;id.name));
<span class="p_del">-	else {</span>
<span class="p_add">+	else</span>
 		len = get_term_name(state, &amp;state-&gt;oterm,
 				    kctl-&gt;id.name, sizeof(kctl-&gt;id.name), 0);
<span class="p_del">-		if (!len)</span>
<span class="p_del">-			strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!len) {</span>
<span class="p_add">+		strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
 
 		if (desc-&gt;bDescriptorSubtype == UAC2_CLOCK_SELECTOR)
 			append_ctl_name(kctl, &quot; Clock Source&quot;);
<span class="p_header">diff --git a/tools/hv/hv_kvp_daemon.c b/tools/hv/hv_kvp_daemon.c</span>
<span class="p_header">index bc7adb84e679..60a94b3e532e 100644</span>
<span class="p_header">--- a/tools/hv/hv_kvp_daemon.c</span>
<span class="p_header">+++ b/tools/hv/hv_kvp_daemon.c</span>
<span class="p_chunk">@@ -193,11 +193,14 @@</span> <span class="p_context"> static void kvp_update_mem_state(int pool)</span>
 	for (;;) {
 		readp = &amp;record[records_read];
 		records_read += fread(readp, sizeof(struct kvp_record),
<span class="p_del">-					ENTRIES_PER_BLOCK * num_blocks,</span>
<span class="p_del">-					filep);</span>
<span class="p_add">+				ENTRIES_PER_BLOCK * num_blocks - records_read,</span>
<span class="p_add">+				filep);</span>
 
 		if (ferror(filep)) {
<span class="p_del">-			syslog(LOG_ERR, &quot;Failed to read file, pool: %d&quot;, pool);</span>
<span class="p_add">+			syslog(LOG_ERR,</span>
<span class="p_add">+				&quot;Failed to read file, pool: %d; error: %d %s&quot;,</span>
<span class="p_add">+				 pool, errno, strerror(errno));</span>
<span class="p_add">+			kvp_release_lock(pool);</span>
 			exit(EXIT_FAILURE);
 		}
 
<span class="p_chunk">@@ -210,6 +213,7 @@</span> <span class="p_context"> static void kvp_update_mem_state(int pool)</span>
 
 			if (record == NULL) {
 				syslog(LOG_ERR, &quot;malloc failed&quot;);
<span class="p_add">+				kvp_release_lock(pool);</span>
 				exit(EXIT_FAILURE);
 			}
 			continue;
<span class="p_chunk">@@ -224,15 +228,11 @@</span> <span class="p_context"> static void kvp_update_mem_state(int pool)</span>
 	fclose(filep);
 	kvp_release_lock(pool);
 }
<span class="p_add">+</span>
 static int kvp_file_init(void)
 {
 	int  fd;
<span class="p_del">-	FILE *filep;</span>
<span class="p_del">-	size_t records_read;</span>
 	char *fname;
<span class="p_del">-	struct kvp_record *record;</span>
<span class="p_del">-	struct kvp_record *readp;</span>
<span class="p_del">-	int num_blocks;</span>
 	int i;
 	int alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;
 
<span class="p_chunk">@@ -246,61 +246,19 @@</span> <span class="p_context"> static int kvp_file_init(void)</span>
 
 	for (i = 0; i &lt; KVP_POOL_COUNT; i++) {
 		fname = kvp_file_info[i].fname;
<span class="p_del">-		records_read = 0;</span>
<span class="p_del">-		num_blocks = 1;</span>
 		sprintf(fname, &quot;%s/.kvp_pool_%d&quot;, KVP_CONFIG_LOC, i);
 		fd = open(fname, O_RDWR | O_CREAT | O_CLOEXEC, 0644 /* rw-r--r-- */);
 
 		if (fd == -1)
 			return 1;
 
<span class="p_del">-</span>
<span class="p_del">-		filep = fopen(fname, &quot;re&quot;);</span>
<span class="p_del">-		if (!filep) {</span>
<span class="p_del">-			close(fd);</span>
<span class="p_del">-			return 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		record = malloc(alloc_unit * num_blocks);</span>
<span class="p_del">-		if (record == NULL) {</span>
<span class="p_del">-			fclose(filep);</span>
<span class="p_del">-			close(fd);</span>
<span class="p_del">-			return 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		for (;;) {</span>
<span class="p_del">-			readp = &amp;record[records_read];</span>
<span class="p_del">-			records_read += fread(readp, sizeof(struct kvp_record),</span>
<span class="p_del">-					ENTRIES_PER_BLOCK,</span>
<span class="p_del">-					filep);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (ferror(filep)) {</span>
<span class="p_del">-				syslog(LOG_ERR, &quot;Failed to read file, pool: %d&quot;,</span>
<span class="p_del">-				       i);</span>
<span class="p_del">-				exit(EXIT_FAILURE);</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!feof(filep)) {</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * We have more data to read.</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				num_blocks++;</span>
<span class="p_del">-				record = realloc(record, alloc_unit *</span>
<span class="p_del">-						num_blocks);</span>
<span class="p_del">-				if (record == NULL) {</span>
<span class="p_del">-					fclose(filep);</span>
<span class="p_del">-					close(fd);</span>
<span class="p_del">-					return 1;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 		kvp_file_info[i].fd = fd;
<span class="p_del">-		kvp_file_info[i].num_blocks = num_blocks;</span>
<span class="p_del">-		kvp_file_info[i].records = record;</span>
<span class="p_del">-		kvp_file_info[i].num_records = records_read;</span>
<span class="p_del">-		fclose(filep);</span>
<span class="p_del">-</span>
<span class="p_add">+		kvp_file_info[i].num_blocks = 1;</span>
<span class="p_add">+		kvp_file_info[i].records = malloc(alloc_unit);</span>
<span class="p_add">+		if (kvp_file_info[i].records == NULL)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		kvp_file_info[i].num_records = 0;</span>
<span class="p_add">+		kvp_update_mem_state(i);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/tools/testing/selftests/powerpc/harness.c b/tools/testing/selftests/powerpc/harness.c</span>
<span class="p_header">index 248a820048df..66d31de60b9a 100644</span>
<span class="p_header">--- a/tools/testing/selftests/powerpc/harness.c</span>
<span class="p_header">+++ b/tools/testing/selftests/powerpc/harness.c</span>
<span class="p_chunk">@@ -114,9 +114,11 @@</span> <span class="p_context"> int test_harness(int (test_function)(void), char *name)</span>
 
 	rc = run_test(test_function, name);
 
<span class="p_del">-	if (rc == MAGIC_SKIP_RETURN_VALUE)</span>
<span class="p_add">+	if (rc == MAGIC_SKIP_RETURN_VALUE) {</span>
 		test_skip(name);
<span class="p_del">-	else</span>
<span class="p_add">+		/* so that skipped test is not marked as failed */</span>
<span class="p_add">+		rc = 0;</span>
<span class="p_add">+	} else</span>
 		test_finish(name, rc);
 
 	return rc;
<span class="p_header">diff --git a/tools/testing/selftests/x86/fsgsbase.c b/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_header">index 9b4610c6d3fb..f249e042b3b5 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> void do_unexpected_base(void)</span>
 		long ret;
 		asm volatile (&quot;int $0x80&quot;
 			      : &quot;=a&quot; (ret) : &quot;a&quot; (243), &quot;b&quot; (low_desc)
<span class="p_del">-			      : &quot;flags&quot;);</span>
<span class="p_add">+			      : &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;);</span>
 		memcpy(&amp;desc, low_desc, sizeof(desc));
 		munmap(low_desc, sizeof(desc));
 
<span class="p_header">diff --git a/tools/testing/selftests/x86/ldt_gdt.c b/tools/testing/selftests/x86/ldt_gdt.c</span>
<span class="p_header">index f936a3cd3e35..ac1a7a3f87b2 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/ldt_gdt.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/ldt_gdt.c</span>
<span class="p_chunk">@@ -45,6 +45,12 @@</span> <span class="p_context"></span>
 #define AR_DB			(1 &lt;&lt; 22)
 #define AR_G			(1 &lt;&lt; 23)
 
<span class="p_add">+#ifdef __x86_64__</span>
<span class="p_add">+# define INT80_CLOBBERS &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;</span>
<span class="p_add">+#else</span>
<span class="p_add">+# define INT80_CLOBBERS</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static int nerrs;
 
 /* Points to an array of 1024 ints, each holding its own index. */
<span class="p_chunk">@@ -649,7 +655,7 @@</span> <span class="p_context"> static int invoke_set_thread_area(void)</span>
 	asm volatile (&quot;int $0x80&quot;
 		      : &quot;=a&quot; (ret), &quot;+m&quot; (low_user_desc) :
 			&quot;a&quot; (243), &quot;b&quot; (low_user_desc)
<span class="p_del">-		      : &quot;flags&quot;);</span>
<span class="p_add">+		      : INT80_CLOBBERS);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -718,7 +724,7 @@</span> <span class="p_context"> static void test_gdt_invalidation(void)</span>
 			&quot;+a&quot; (eax)
 		      : &quot;m&quot; (low_user_desc_clear),
 			[arg1] &quot;r&quot; ((unsigned int)(unsigned long)low_user_desc_clear)
<span class="p_del">-		      : &quot;flags&quot;);</span>
<span class="p_add">+		      : INT80_CLOBBERS);</span>
 
 	if (sel != 0) {
 		result = &quot;FAIL&quot;;
<span class="p_chunk">@@ -749,7 +755,7 @@</span> <span class="p_context"> static void test_gdt_invalidation(void)</span>
 			&quot;+a&quot; (eax)
 		      : &quot;m&quot; (low_user_desc_clear),
 			[arg1] &quot;r&quot; ((unsigned int)(unsigned long)low_user_desc_clear)
<span class="p_del">-		      : &quot;flags&quot;);</span>
<span class="p_add">+		      : INT80_CLOBBERS);</span>
 
 	if (sel != 0) {
 		result = &quot;FAIL&quot;;
<span class="p_chunk">@@ -782,7 +788,7 @@</span> <span class="p_context"> static void test_gdt_invalidation(void)</span>
 			&quot;+a&quot; (eax)
 		      : &quot;m&quot; (low_user_desc_clear),
 			[arg1] &quot;r&quot; ((unsigned int)(unsigned long)low_user_desc_clear)
<span class="p_del">-		      : &quot;flags&quot;);</span>
<span class="p_add">+		      : INT80_CLOBBERS);</span>
 
 #ifdef __x86_64__
 	syscall(SYS_arch_prctl, ARCH_GET_FS, &amp;new_base);
<span class="p_chunk">@@ -835,7 +841,7 @@</span> <span class="p_context"> static void test_gdt_invalidation(void)</span>
 			&quot;+a&quot; (eax)
 		      : &quot;m&quot; (low_user_desc_clear),
 			[arg1] &quot;r&quot; ((unsigned int)(unsigned long)low_user_desc_clear)
<span class="p_del">-		      : &quot;flags&quot;);</span>
<span class="p_add">+		      : INT80_CLOBBERS);</span>
 
 #ifdef __x86_64__
 	syscall(SYS_arch_prctl, ARCH_GET_GS, &amp;new_base);
<span class="p_header">diff --git a/tools/testing/selftests/x86/mpx-hw.h b/tools/testing/selftests/x86/mpx-hw.h</span>
<span class="p_header">index 093c190178a9..28b3c7c553a4 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/mpx-hw.h</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/mpx-hw.h</span>
<span class="p_chunk">@@ -51,14 +51,14 @@</span> <span class="p_context"></span>
 struct mpx_bd_entry {
 	union {
 		char x[MPX_BOUNDS_DIR_ENTRY_SIZE_BYTES];
<span class="p_del">-		void *contents[1];</span>
<span class="p_add">+		void *contents[0];</span>
 	};
 } __attribute__((packed));
 
 struct mpx_bt_entry {
 	union {
 		char x[MPX_BOUNDS_TABLE_ENTRY_SIZE_BYTES];
<span class="p_del">-		unsigned long contents[1];</span>
<span class="p_add">+		unsigned long contents[0];</span>
 	};
 } __attribute__((packed));
 
<span class="p_header">diff --git a/tools/testing/selftests/x86/ptrace_syscall.c b/tools/testing/selftests/x86/ptrace_syscall.c</span>
<span class="p_header">index b037ce9cf116..eaea92439708 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/ptrace_syscall.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/ptrace_syscall.c</span>
<span class="p_chunk">@@ -58,7 +58,8 @@</span> <span class="p_context"> static void do_full_int80(struct syscall_args32 *args)</span>
 	asm volatile (&quot;int $0x80&quot;
 		      : &quot;+a&quot; (args-&gt;nr),
 			&quot;+b&quot; (args-&gt;arg0), &quot;+c&quot; (args-&gt;arg1), &quot;+d&quot; (args-&gt;arg2),
<span class="p_del">-			&quot;+S&quot; (args-&gt;arg3), &quot;+D&quot; (args-&gt;arg4), &quot;+r&quot; (bp));</span>
<span class="p_add">+			&quot;+S&quot; (args-&gt;arg3), &quot;+D&quot; (args-&gt;arg4), &quot;+r&quot; (bp)</span>
<span class="p_add">+			: : &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;);</span>
 	args-&gt;arg5 = bp;
 #else
 	sys32_helper(args, int80_and_ret);
<span class="p_header">diff --git a/tools/testing/selftests/x86/single_step_syscall.c b/tools/testing/selftests/x86/single_step_syscall.c</span>
<span class="p_header">index 50c26358e8b7..a48da95c18fd 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/single_step_syscall.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/single_step_syscall.c</span>
<span class="p_chunk">@@ -56,9 +56,11 @@</span> <span class="p_context"> static volatile sig_atomic_t sig_traps;</span>
 #ifdef __x86_64__
 # define REG_IP REG_RIP
 # define WIDTH &quot;q&quot;
<span class="p_add">+# define INT80_CLOBBERS &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;</span>
 #else
 # define REG_IP REG_EIP
 # define WIDTH &quot;l&quot;
<span class="p_add">+# define INT80_CLOBBERS</span>
 #endif
 
 static unsigned long get_eflags(void)
<span class="p_chunk">@@ -140,7 +142,8 @@</span> <span class="p_context"> int main()</span>
 
 	printf(&quot;[RUN]\tSet TF and check int80\n&quot;);
 	set_eflags(get_eflags() | X86_EFLAGS_TF);
<span class="p_del">-	asm volatile (&quot;int $0x80&quot; : &quot;=a&quot; (tmp) : &quot;a&quot; (SYS_getpid));</span>
<span class="p_add">+	asm volatile (&quot;int $0x80&quot; : &quot;=a&quot; (tmp) : &quot;a&quot; (SYS_getpid)</span>
<span class="p_add">+			: INT80_CLOBBERS);</span>
 	check_result();
 
 	/*
<span class="p_header">diff --git a/virt/kvm/arm/hyp/vgic-v2-sr.c b/virt/kvm/arm/hyp/vgic-v2-sr.c</span>
<span class="p_header">index c8aeb7b91ec8..95021246ee26 100644</span>
<span class="p_header">--- a/virt/kvm/arm/hyp/vgic-v2-sr.c</span>
<span class="p_header">+++ b/virt/kvm/arm/hyp/vgic-v2-sr.c</span>
<span class="p_chunk">@@ -77,11 +77,7 @@</span> <span class="p_context"> static void __hyp_text save_elrsr(struct kvm_vcpu *vcpu, void __iomem *base)</span>
 	else
 		elrsr1 = 0;
 
<span class="p_del">-#ifdef CONFIG_CPU_BIG_ENDIAN</span>
<span class="p_del">-	cpu_if-&gt;vgic_elrsr = ((u64)elrsr0 &lt;&lt; 32) | elrsr1;</span>
<span class="p_del">-#else</span>
 	cpu_if-&gt;vgic_elrsr = ((u64)elrsr1 &lt;&lt; 32) | elrsr0;
<span class="p_del">-#endif</span>
 }
 
 static void __hyp_text save_lrs(struct kvm_vcpu *vcpu, void __iomem *base)
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic-irqfd.c b/virt/kvm/arm/vgic/vgic-irqfd.c</span>
<span class="p_header">index f138ed2e9c63..a26c6773d6df 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic-irqfd.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic-irqfd.c</span>
<span class="p_chunk">@@ -112,8 +112,7 @@</span> <span class="p_context"> int kvm_vgic_setup_default_irq_routing(struct kvm *kvm)</span>
 	u32 nr = dist-&gt;nr_spis;
 	int i, ret;
 
<span class="p_del">-	entries = kcalloc(nr, sizeof(struct kvm_kernel_irq_routing_entry),</span>
<span class="p_del">-			  GFP_KERNEL);</span>
<span class="p_add">+	entries = kcalloc(nr, sizeof(*entries), GFP_KERNEL);</span>
 	if (!entries)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic-its.c b/virt/kvm/arm/vgic/vgic-its.c</span>
<span class="p_header">index 4660a7d04eea..ebcaf4641d2b 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic-its.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic-its.c</span>
<span class="p_chunk">@@ -360,29 +360,6 @@</span> <span class="p_context"> static int its_sync_lpi_pending_table(struct kvm_vcpu *vcpu)</span>
 	return ret;
 }
 
<span class="p_del">-static unsigned long vgic_mmio_read_its_ctlr(struct kvm *vcpu,</span>
<span class="p_del">-					     struct vgic_its *its,</span>
<span class="p_del">-					     gpa_t addr, unsigned int len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 reg = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;its-&gt;cmd_lock);</span>
<span class="p_del">-	if (its-&gt;creadr == its-&gt;cwriter)</span>
<span class="p_del">-		reg |= GITS_CTLR_QUIESCENT;</span>
<span class="p_del">-	if (its-&gt;enabled)</span>
<span class="p_del">-		reg |= GITS_CTLR_ENABLE;</span>
<span class="p_del">-	mutex_unlock(&amp;its-&gt;cmd_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return reg;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void vgic_mmio_write_its_ctlr(struct kvm *kvm, struct vgic_its *its,</span>
<span class="p_del">-				     gpa_t addr, unsigned int len,</span>
<span class="p_del">-				     unsigned long val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	its-&gt;enabled = !!(val &amp; GITS_CTLR_ENABLE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static unsigned long vgic_mmio_read_its_typer(struct kvm *kvm,
 					      struct vgic_its *its,
 					      gpa_t addr, unsigned int len)
<span class="p_chunk">@@ -687,6 +664,8 @@</span> <span class="p_context"> static int vgic_its_alloc_collection(struct vgic_its *its,</span>
 		return E_ITS_MAPC_COLLECTION_OOR;
 
 	collection = kzalloc(sizeof(*collection), GFP_KERNEL);
<span class="p_add">+	if (!collection)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	collection-&gt;collection_id = coll_id;
 	collection-&gt;target_addr = COLLECTION_NOT_MAPPED;
<span class="p_chunk">@@ -1160,33 +1139,16 @@</span> <span class="p_context"> static void vgic_mmio_write_its_cbaser(struct kvm *kvm, struct vgic_its *its,</span>
 #define ITS_CMD_SIZE			32
 #define ITS_CMD_OFFSET(reg)		((reg) &amp; GENMASK(19, 5))
 
<span class="p_del">-/*</span>
<span class="p_del">- * By writing to CWRITER the guest announces new commands to be processed.</span>
<span class="p_del">- * To avoid any races in the first place, we take the its_cmd lock, which</span>
<span class="p_del">- * protects our ring buffer variables, so that there is only one user</span>
<span class="p_del">- * per ITS handling commands at a given time.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void vgic_mmio_write_its_cwriter(struct kvm *kvm, struct vgic_its *its,</span>
<span class="p_del">-					gpa_t addr, unsigned int len,</span>
<span class="p_del">-					unsigned long val)</span>
<span class="p_add">+/* Must be called with the cmd_lock held. */</span>
<span class="p_add">+static void vgic_its_process_commands(struct kvm *kvm, struct vgic_its *its)</span>
 {
 	gpa_t cbaser;
 	u64 cmd_buf[4];
<span class="p_del">-	u32 reg;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!its)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;its-&gt;cmd_lock);</span>
 
<span class="p_del">-	reg = update_64bit_reg(its-&gt;cwriter, addr &amp; 7, len, val);</span>
<span class="p_del">-	reg = ITS_CMD_OFFSET(reg);</span>
<span class="p_del">-	if (reg &gt;= ITS_CMD_BUFFER_SIZE(its-&gt;cbaser)) {</span>
<span class="p_del">-		mutex_unlock(&amp;its-&gt;cmd_lock);</span>
<span class="p_add">+	/* Commands are only processed when the ITS is enabled. */</span>
<span class="p_add">+	if (!its-&gt;enabled)</span>
 		return;
<span class="p_del">-	}</span>
 
<span class="p_del">-	its-&gt;cwriter = reg;</span>
 	cbaser = CBASER_ADDRESS(its-&gt;cbaser);
 
 	while (its-&gt;cwriter != its-&gt;creadr) {
<span class="p_chunk">@@ -1206,6 +1168,34 @@</span> <span class="p_context"> static void vgic_mmio_write_its_cwriter(struct kvm *kvm, struct vgic_its *its,</span>
 		if (its-&gt;creadr == ITS_CMD_BUFFER_SIZE(its-&gt;cbaser))
 			its-&gt;creadr = 0;
 	}
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * By writing to CWRITER the guest announces new commands to be processed.</span>
<span class="p_add">+ * To avoid any races in the first place, we take the its_cmd lock, which</span>
<span class="p_add">+ * protects our ring buffer variables, so that there is only one user</span>
<span class="p_add">+ * per ITS handling commands at a given time.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void vgic_mmio_write_its_cwriter(struct kvm *kvm, struct vgic_its *its,</span>
<span class="p_add">+					gpa_t addr, unsigned int len,</span>
<span class="p_add">+					unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 reg;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!its)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;its-&gt;cmd_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	reg = update_64bit_reg(its-&gt;cwriter, addr &amp; 7, len, val);</span>
<span class="p_add">+	reg = ITS_CMD_OFFSET(reg);</span>
<span class="p_add">+	if (reg &gt;= ITS_CMD_BUFFER_SIZE(its-&gt;cbaser)) {</span>
<span class="p_add">+		mutex_unlock(&amp;its-&gt;cmd_lock);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	its-&gt;cwriter = reg;</span>
<span class="p_add">+</span>
<span class="p_add">+	vgic_its_process_commands(kvm, its);</span>
 
 	mutex_unlock(&amp;its-&gt;cmd_lock);
 }
<span class="p_chunk">@@ -1286,6 +1276,39 @@</span> <span class="p_context"> static void vgic_mmio_write_its_baser(struct kvm *kvm,</span>
 	*regptr = reg;
 }
 
<span class="p_add">+static unsigned long vgic_mmio_read_its_ctlr(struct kvm *vcpu,</span>
<span class="p_add">+					     struct vgic_its *its,</span>
<span class="p_add">+					     gpa_t addr, unsigned int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 reg = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;its-&gt;cmd_lock);</span>
<span class="p_add">+	if (its-&gt;creadr == its-&gt;cwriter)</span>
<span class="p_add">+		reg |= GITS_CTLR_QUIESCENT;</span>
<span class="p_add">+	if (its-&gt;enabled)</span>
<span class="p_add">+		reg |= GITS_CTLR_ENABLE;</span>
<span class="p_add">+	mutex_unlock(&amp;its-&gt;cmd_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return reg;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void vgic_mmio_write_its_ctlr(struct kvm *kvm, struct vgic_its *its,</span>
<span class="p_add">+				     gpa_t addr, unsigned int len,</span>
<span class="p_add">+				     unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;its-&gt;cmd_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	its-&gt;enabled = !!(val &amp; GITS_CTLR_ENABLE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Try to process any pending commands. This function bails out early</span>
<span class="p_add">+	 * if the ITS is disabled or no commands have been queued.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	vgic_its_process_commands(kvm, its);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;its-&gt;cmd_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define REGISTER_ITS_DESC(off, rd, wr, length, acc)		\
 {								\
 	.reg_offset = off,					\
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index f4c6d4f6d2e8..4569fdcab701 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -125,6 +125,11 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(kvm_rebooting);</span>
 
 static bool largepages_enabled = true;
 
<span class="p_add">+__weak void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,</span>
<span class="p_add">+		unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 bool kvm_is_reserved_pfn(kvm_pfn_t pfn)
 {
 	if (pfn_valid(pfn))
<span class="p_chunk">@@ -361,6 +366,9 @@</span> <span class="p_context"> static void kvm_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,</span>
 		kvm_flush_remote_tlbs(kvm);
 
 	spin_unlock(&amp;kvm-&gt;mmu_lock);
<span class="p_add">+</span>
<span class="p_add">+	kvm_arch_mmu_notifier_invalidate_range(kvm, start, end);</span>
<span class="p_add">+</span>
 	srcu_read_unlock(&amp;kvm-&gt;srcu, idx);
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



