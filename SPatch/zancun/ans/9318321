
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.14.78 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.14.78</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 7, 2016, 7:16 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160907071601.GB32368@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9318321/mbox/"
   >mbox</a>
|
   <a href="/patch/9318321/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9318321/">/patch/9318321/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	092A4601C0 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  7 Sep 2016 07:16:14 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E4ED6290B1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  7 Sep 2016 07:16:13 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D991E290B6; Wed,  7 Sep 2016 07:16:13 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 26B55290B1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  7 Sep 2016 07:16:11 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755644AbcIGHQB (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 7 Sep 2016 03:16:01 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:46444 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755154AbcIGHP4 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 7 Sep 2016 03:15:56 -0400
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id A4A4D951;
	Wed,  7 Sep 2016 07:15:54 +0000 (UTC)
Date: Wed, 7 Sep 2016 09:16:01 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.14.78
Message-ID: &lt;20160907071601.GB32368@kroah.com&gt;
References: &lt;20160907071552.GA32368@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160907071552.GA32368@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 7, 2016, 7:16 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index fc4df99727c1..74346f0d89c1 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 77</span>
<span class="p_add">+SUBLEVEL = 78</span>
 EXTRAVERSION =
 NAME = Remembering Coco
 
<span class="p_header">diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h</span>
<span class="p_header">index 01d3aab64b79..cc0e347379b7 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/elf.h</span>
<span class="p_chunk">@@ -137,6 +137,7 @@</span> <span class="p_context"> extern unsigned long randomize_et_dyn(unsigned long base);</span>
 
 #define SET_PERSONALITY(ex)		clear_thread_flag(TIF_32BIT);
 
<span class="p_add">+/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
 #define ARCH_DLINFO							\
 do {									\
 	NEW_AUX_ENT(AT_SYSINFO_EHDR,					\
<span class="p_header">diff --git a/arch/arm64/include/uapi/asm/auxvec.h b/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_header">index 22d6d8885854..4cf0c17787a8 100644</span>
<span class="p_header">--- a/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -19,4 +19,6 @@</span> <span class="p_context"></span>
 /* vDSO location */
 #define AT_SYSINFO_EHDR	33
 
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH 1 /* entries in ARCH_DLINFO */</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_header">index c0ae62520d15..274d5bc6ecce 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_chunk">@@ -97,10 +97,10 @@</span> <span class="p_context"></span>
 #define	ENOTCONN	235	/* Transport endpoint is not connected */
 #define	ESHUTDOWN	236	/* Cannot send after transport endpoint shutdown */
 #define	ETOOMANYREFS	237	/* Too many references: cannot splice */
<span class="p_del">-#define EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
 #define	ETIMEDOUT	238	/* Connection timed out */
 #define	ECONNREFUSED	239	/* Connection refused */
<span class="p_del">-#define EREMOTERELEASE	240	/* Remote peer released connection */</span>
<span class="p_add">+#define	EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
<span class="p_add">+#define	EREMOTERELEASE	240	/* Remote peer released connection */</span>
 #define	EHOSTDOWN	241	/* Host is down */
 #define	EHOSTUNREACH	242	/* No route to host */
 
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 04905bfc508b..5e4b0cc54e43 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -17,7 +17,14 @@</span> <span class="p_context"></span>
 
 static inline void __native_flush_tlb(void)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If current-&gt;mm == NULL then we borrow a mm which may change during a</span>
<span class="p_add">+	 * task switch and therefore we must not be preempted while we write CR3</span>
<span class="p_add">+	 * back:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	preempt_disable();</span>
 	native_write_cr3(native_read_cr3());
<span class="p_add">+	preempt_enable();</span>
 }
 
 static inline void __native_flush_tlb_global_irq_disabled(void)
<span class="p_header">diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c</span>
<span class="p_header">index 91a32cefb11f..684baf937c7c 100644</span>
<span class="p_header">--- a/drivers/acpi/sysfs.c</span>
<span class="p_header">+++ b/drivers/acpi/sysfs.c</span>
<span class="p_chunk">@@ -494,23 +494,22 @@</span> <span class="p_context"> static void acpi_global_event_handler(u32 event_type, acpi_handle device,</span>
 static int get_status(u32 index, acpi_event_status *status,
 		      acpi_handle *handle)
 {
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	int result;</span>
 
 	if (index &gt;= num_gpes + ACPI_NUM_FIXED_EVENTS)
<span class="p_del">-		goto end;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (index &lt; num_gpes) {
 		result = acpi_get_gpe_device(index, handle);
 		if (result) {
 			ACPI_EXCEPTION((AE_INFO, AE_NOT_FOUND,
 					&quot;Invalid GPE 0x%x&quot;, index));
<span class="p_del">-			goto end;</span>
<span class="p_add">+			return result;</span>
 		}
 		result = acpi_get_gpe_status(*handle, index, status);
 	} else if (index &lt; (num_gpes + ACPI_NUM_FIXED_EVENTS))
 		result = acpi_get_event_status(index - num_gpes, status);
 
<span class="p_del">-end:</span>
 	return result;
 }
 
<span class="p_header">diff --git a/drivers/crypto/nx/nx.c b/drivers/crypto/nx/nx.c</span>
<span class="p_header">index 5533fe31c90d..433a7696bf0f 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx.c</span>
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> static void nx_of_update_msc(struct device   *dev,</span>
 		     ((bytes_so_far + sizeof(struct msc_triplet)) &lt;= lenp) &amp;&amp;
 		     i &lt; msc-&gt;triplets;
 		     i++) {
<span class="p_del">-			if (msc-&gt;fc &gt; NX_MAX_FC || msc-&gt;mode &gt; NX_MAX_MODE) {</span>
<span class="p_add">+			if (msc-&gt;fc &gt;= NX_MAX_FC || msc-&gt;mode &gt;= NX_MAX_MODE) {</span>
 				dev_err(dev, &quot;unknown function code/mode &quot;
 					&quot;combo: %d/%d (ignored)\n&quot;, msc-&gt;fc,
 					msc-&gt;mode);
<span class="p_header">diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c</span>
<span class="p_header">index 19dc0bc9b136..9530c5703bb7 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc.c</span>
<span class="p_chunk">@@ -962,7 +962,7 @@</span> <span class="p_context"> static void edac_inc_ue_error(struct mem_ctl_info *mci,</span>
 	mci-&gt;ue_mc += count;
 
 	if (!enable_per_layer_report) {
<span class="p_del">-		mci-&gt;ce_noinfo_count += count;</span>
<span class="p_add">+		mci-&gt;ue_noinfo_count += count;</span>
 		return;
 	}
 
<span class="p_header">diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig</span>
<span class="p_header">index 903f24d28ba0..7025562ede12 100644</span>
<span class="p_header">--- a/drivers/gpio/Kconfig</span>
<span class="p_header">+++ b/drivers/gpio/Kconfig</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> config GPIO_DEVRES</span>
 config OF_GPIO
 	def_bool y
 	depends on OF
<span class="p_add">+	depends on HAS_IOMEM</span>
 
 config GPIO_ACPI
 	def_bool y
<span class="p_header">diff --git a/drivers/input/keyboard/tegra-kbc.c b/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_header">index 9757a58bc897..5d39b966dd28 100644</span>
<span class="p_header">--- a/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_header">+++ b/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_chunk">@@ -376,7 +376,7 @@</span> <span class="p_context"> static int tegra_kbc_start(struct tegra_kbc *kbc)</span>
 	/* Reset the KBC controller to clear all previous status.*/
 	reset_control_assert(kbc-&gt;rst);
 	udelay(100);
<span class="p_del">-	reset_control_assert(kbc-&gt;rst);</span>
<span class="p_add">+	reset_control_deassert(kbc-&gt;rst);</span>
 	udelay(100);
 
 	tegra_kbc_config_pins(kbc);
<span class="p_header">diff --git a/drivers/input/serio/i8042.c b/drivers/input/serio/i8042.c</span>
<span class="p_header">index eb796fff9e62..9a0cc5b5561a 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042.c</span>
<span class="p_header">+++ b/drivers/input/serio/i8042.c</span>
<span class="p_chunk">@@ -1230,6 +1230,7 @@</span> <span class="p_context"> static int __init i8042_create_kbd_port(void)</span>
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
 	serio-&gt;close		= i8042_port_close;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	strlcpy(serio-&gt;name, &quot;i8042 KBD port&quot;, sizeof(serio-&gt;name));
<span class="p_chunk">@@ -1257,6 +1258,7 @@</span> <span class="p_context"> static int __init i8042_create_aux_port(int idx)</span>
 	serio-&gt;write		= i8042_aux_write;
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	if (idx &lt; 0) {
<span class="p_chunk">@@ -1321,21 +1323,6 @@</span> <span class="p_context"> static void i8042_unregister_ports(void)</span>
 	}
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Checks whether port belongs to i8042 controller.</span>
<span class="p_del">- */</span>
<span class="p_del">-bool i8042_check_port_owner(const struct serio *port)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; I8042_NUM_PORTS; i++)</span>
<span class="p_del">-		if (i8042_ports[i].serio == port)</span>
<span class="p_del">-			return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(i8042_check_port_owner);</span>
<span class="p_del">-</span>
 static void i8042_free_irqs(void)
 {
 	if (i8042_aux_irq_registered)
<span class="p_header">diff --git a/drivers/input/serio/libps2.c b/drivers/input/serio/libps2.c</span>
<span class="p_header">index 75516996db20..ded0c6f65c9f 100644</span>
<span class="p_header">--- a/drivers/input/serio/libps2.c</span>
<span class="p_header">+++ b/drivers/input/serio/libps2.c</span>
<span class="p_chunk">@@ -56,19 +56,17 @@</span> <span class="p_context"> EXPORT_SYMBOL(ps2_sendbyte);</span>
 
 void ps2_begin_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	mutex_lock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_lock_chip();</span>
<span class="p_add">+	mutex_lock(m);</span>
 }
 EXPORT_SYMBOL(ps2_begin_command);
 
 void ps2_end_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_unlock_chip();</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	mutex_unlock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	mutex_unlock(m);</span>
 }
 EXPORT_SYMBOL(ps2_end_command);
 
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index a943c6c0f206..3f29cf979c09 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -1349,10 +1349,10 @@</span> <span class="p_context"> int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)</span>
 	if (!sysfs_initialized)
 		return -EACCES;
 
<span class="p_del">-	if (pdev-&gt;cfg_size &lt; PCI_CFG_SPACE_EXP_SIZE)</span>
<span class="p_del">-		retval = sysfs_create_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (pdev-&gt;cfg_size &gt; PCI_CFG_SPACE_SIZE)</span>
 		retval = sysfs_create_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pcie_config_attr);
<span class="p_add">+	else</span>
<span class="p_add">+		retval = sysfs_create_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
 	if (retval)
 		goto err;
 
<span class="p_chunk">@@ -1409,10 +1409,10 @@</span> <span class="p_context"> err_rom_file:</span>
 err_resource_files:
 	pci_remove_resource_files(pdev);
 err_config_file:
<span class="p_del">-	if (pdev-&gt;cfg_size &lt; PCI_CFG_SPACE_EXP_SIZE)</span>
<span class="p_del">-		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (pdev-&gt;cfg_size &gt; PCI_CFG_SPACE_SIZE)</span>
 		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pcie_config_attr);
<span class="p_add">+	else</span>
<span class="p_add">+		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
 err:
 	return retval;
 }
<span class="p_chunk">@@ -1446,10 +1446,10 @@</span> <span class="p_context"> void pci_remove_sysfs_dev_files(struct pci_dev *pdev)</span>
 
 	pci_remove_capabilities_sysfs(pdev);
 
<span class="p_del">-	if (pdev-&gt;cfg_size &lt; PCI_CFG_SPACE_EXP_SIZE)</span>
<span class="p_del">-		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (pdev-&gt;cfg_size &gt; PCI_CFG_SPACE_SIZE)</span>
 		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pcie_config_attr);
<span class="p_add">+	else</span>
<span class="p_add">+		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
 
 	pci_remove_resource_files(pdev);
 
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 09208ac59415..ca53d484513c 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -288,6 +288,18 @@</span> <span class="p_context"> static void quirk_citrine(struct pci_dev *dev)</span>
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_IBM,	PCI_DEVICE_ID_IBM_CITRINE,	quirk_citrine);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * This chip can cause bus lockups if config addresses above 0x600</span>
<span class="p_add">+ * are read or written.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void quirk_nfp6000(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dev-&gt;cfg_size = 0x600;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP4000,	quirk_nfp6000);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP6000,	quirk_nfp6000);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP6000_VF,	quirk_nfp6000);</span>
<span class="p_add">+</span>
 /*  On IBM Crocodile ipr SAS adapters, expand BAR to system page size */
 static void quirk_extend_bar_to_page(struct pci_dev *dev)
 {
<span class="p_header">diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c</span>
<span class="p_header">index 1eef0f586950..cf0214005fca 100644</span>
<span class="p_header">--- a/drivers/s390/block/dasd.c</span>
<span class="p_header">+++ b/drivers/s390/block/dasd.c</span>
<span class="p_chunk">@@ -1613,9 +1613,18 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	unsigned long long now;
 	int expires;
 
<span class="p_add">+	cqr = (struct dasd_ccw_req *) intparm;</span>
 	if (IS_ERR(irb)) {
 		switch (PTR_ERR(irb)) {
 		case -EIO:
<span class="p_add">+			if (cqr &amp;&amp; cqr-&gt;status == DASD_CQR_CLEAR_PENDING) {</span>
<span class="p_add">+				device = (struct dasd_device *) cqr-&gt;startdev;</span>
<span class="p_add">+				cqr-&gt;status = DASD_CQR_CLEARED;</span>
<span class="p_add">+				dasd_device_clear_timer(device);</span>
<span class="p_add">+				wake_up(&amp;dasd_flush_wq);</span>
<span class="p_add">+				dasd_schedule_device_bh(device);</span>
<span class="p_add">+				return;</span>
<span class="p_add">+			}</span>
 			break;
 		case -ETIMEDOUT:
 			DBF_EVENT_DEVID(DBF_WARNING, cdev, &quot;%s: &quot;
<span class="p_chunk">@@ -1631,7 +1640,6 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	}
 
 	now = get_tod_clock();
<span class="p_del">-	cqr = (struct dasd_ccw_req *) intparm;</span>
 	/* check for conditions that should be handled immediately */
 	if (!cqr ||
 	    !(scsw_dstat(&amp;irb-&gt;scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &amp;&amp;
<span class="p_header">diff --git a/drivers/scsi/aacraid/commctrl.c b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">index fbcd48d0bfc3..16b2db3cd9f1 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	struct fib *fibptr;
 	struct hw_fib * hw_fib = (struct hw_fib *)0;
 	dma_addr_t hw_fib_pa = (dma_addr_t)0LL;
<span class="p_del">-	unsigned size;</span>
<span class="p_add">+	unsigned int size, osize;</span>
 	int retval;
 
 	if (dev-&gt;in_reset) {
<span class="p_chunk">@@ -87,7 +87,8 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	 *	will not overrun the buffer when we copy the memory. Return
 	 *	an error if we would.
 	 */
<span class="p_del">-	size = le16_to_cpu(kfib-&gt;header.Size) + sizeof(struct aac_fibhdr);</span>
<span class="p_add">+	osize = size = le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr);</span>
 	if (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))
 		size = le16_to_cpu(kfib-&gt;header.SenderSize);
 	if (size &gt; dev-&gt;max_fib_size) {
<span class="p_chunk">@@ -118,6 +119,14 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	/* Sanity check the second copy */</span>
<span class="p_add">+	if ((osize != le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr))</span>
<span class="p_add">+		|| (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))) {</span>
<span class="p_add">+		retval = -EINVAL;</span>
<span class="p_add">+		goto cleanup;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (kfib-&gt;header.Command == cpu_to_le16(TakeABreakPt)) {
 		aac_adapter_interrupt(dev);
 		/*
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 9f833f1504cc..5ff955524aaf 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -3624,7 +3624,7 @@</span> <span class="p_context"> static int megasas_init_fw(struct megasas_instance *instance)</span>
 	/* Find first memory bar */
 	bar_list = pci_select_bars(instance-&gt;pdev, IORESOURCE_MEM);
 	instance-&gt;bar = find_first_bit(&amp;bar_list, sizeof(unsigned long));
<span class="p_del">-	if (pci_request_selected_regions(instance-&gt;pdev, instance-&gt;bar,</span>
<span class="p_add">+	if (pci_request_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar,</span>
 					 &quot;megasas: LSI&quot;)) {
 		printk(KERN_DEBUG &quot;megasas: IO memory region busy!\n&quot;);
 		return -EBUSY;
<span class="p_chunk">@@ -3858,7 +3858,7 @@</span> <span class="p_context"> fail_ready_state:</span>
 	iounmap(instance-&gt;reg_set);
 
       fail_ioremap:
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 
 	return -EINVAL;
 }
<span class="p_chunk">@@ -3879,7 +3879,7 @@</span> <span class="p_context"> static void megasas_release_mfi(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index a1f04e3b2a8f..665131a0b616 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -2175,7 +2175,7 @@</span> <span class="p_context"> megasas_release_fusion(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/daqboard2000.c b/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_header">index ce153fcb8b2a..3c585b9de1b6 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_chunk">@@ -658,7 +658,7 @@</span> <span class="p_context"> static const void *daqboard2000_find_boardinfo(struct comedi_device *dev,</span>
 	const struct daq200_boardtype *board;
 	int i;
 
<span class="p_del">-	if (pcidev-&gt;subsystem_device != PCI_VENDOR_ID_IOTECH)</span>
<span class="p_add">+	if (pcidev-&gt;subsystem_vendor != PCI_VENDOR_ID_IOTECH)</span>
 		return NULL;
 
 	for (i = 0; i &lt; ARRAY_SIZE(boardtypes); i++) {
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index b6f5c7d3737b..18cb44d9cbd8 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1296,7 +1296,6 @@</span> <span class="p_context"> made_compressed_probe:</span>
 	spin_lock_init(&amp;acm-&gt;write_lock);
 	spin_lock_init(&amp;acm-&gt;read_lock);
 	mutex_init(&amp;acm-&gt;mutex);
<span class="p_del">-	acm-&gt;rx_endpoint = usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress);</span>
 	acm-&gt;is_int_ep = usb_endpoint_xfer_int(epread);
 	if (acm-&gt;is_int_ep)
 		acm-&gt;bInterval = epread-&gt;bInterval;
<span class="p_chunk">@@ -1345,14 +1344,14 @@</span> <span class="p_context"> made_compressed_probe:</span>
 		urb-&gt;transfer_dma = rb-&gt;dma;
 		if (acm-&gt;is_int_ep) {
 			usb_fill_int_urb(urb, acm-&gt;dev,
<span class="p_del">-					 acm-&gt;rx_endpoint,</span>
<span class="p_add">+					 usb_rcvintpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					 rb-&gt;base,
 					 acm-&gt;readsize,
 					 acm_read_bulk_callback, rb,
 					 acm-&gt;bInterval);
 		} else {
 			usb_fill_bulk_urb(urb, acm-&gt;dev,
<span class="p_del">-					  acm-&gt;rx_endpoint,</span>
<span class="p_add">+					  usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					  rb-&gt;base,
 					  acm-&gt;readsize,
 					  acm_read_bulk_callback, rb);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index 80826f843e04..82db3387ac6e 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -95,7 +95,6 @@</span> <span class="p_context"> struct acm {</span>
 	struct urb *read_urbs[ACM_NR];
 	struct acm_rb read_buffers[ACM_NR];
 	int rx_buflimit;
<span class="p_del">-	int rx_endpoint;</span>
 	spinlock_t read_lock;
 	int write_used;					/* number of non-empty write buffers */
 	int transmitting;
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 12d14f91c4d3..0e9530997119 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -143,6 +143,31 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 	}
 }
 
<span class="p_add">+static const unsigned short low_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 8,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 8,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short full_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1023,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 64,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short high_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short super_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
     int asnum, struct usb_host_interface *ifp, int num_ep,
     unsigned char *buffer, int size)
<span class="p_chunk">@@ -151,6 +176,8 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	struct usb_endpoint_descriptor *d;
 	struct usb_host_endpoint *endpoint;
 	int n, i, j, retval;
<span class="p_add">+	unsigned int maxp;</span>
<span class="p_add">+	const unsigned short *maxpacket_maxes;</span>
 
 	d = (struct usb_endpoint_descriptor *) buffer;
 	buffer += d-&gt;bLength;
<span class="p_chunk">@@ -192,6 +219,7 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	if (usb_endpoint_xfer_int(d)) {
 		i = 1;
 		switch (to_usb_device(ddev)-&gt;speed) {
<span class="p_add">+		case USB_SPEED_SUPER_PLUS:</span>
 		case USB_SPEED_SUPER:
 		case USB_SPEED_HIGH:
 			/* Many device manufacturers are using full-speed
<span class="p_chunk">@@ -246,6 +274,42 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 			endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
 	}
 
<span class="p_add">+	/* Validate the wMaxPacketSize field */</span>
<span class="p_add">+	maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the highest legal maxpacket size for this endpoint */</span>
<span class="p_add">+	i = 0;		/* additional transactions per microframe */</span>
<span class="p_add">+	switch (to_usb_device(ddev)-&gt;speed) {</span>
<span class="p_add">+	case USB_SPEED_LOW:</span>
<span class="p_add">+		maxpacket_maxes = low_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_FULL:</span>
<span class="p_add">+		maxpacket_maxes = full_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_HIGH:</span>
<span class="p_add">+		/* Bits 12..11 are allowed only for HS periodic endpoints */</span>
<span class="p_add">+		if (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {</span>
<span class="p_add">+			i = maxp &amp; (BIT(12) | BIT(11));</span>
<span class="p_add">+			maxp &amp;= ~i;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* fallthrough */</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		maxpacket_maxes = high_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_SUPER:</span>
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
<span class="p_add">+		maxpacket_maxes = super_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	j = maxpacket_maxes[usb_endpoint_type(&amp;endpoint-&gt;desc)];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (maxp &gt; j) {</span>
<span class="p_add">+		dev_warn(ddev, &quot;config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n&quot;,</span>
<span class="p_add">+		    cfgno, inum, asnum, d-&gt;bEndpointAddress, maxp, j);</span>
<span class="p_add">+		maxp = j;</span>
<span class="p_add">+		endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(i | maxp);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Some buggy high speed devices have bulk endpoints using
 	 * maxpacket sizes other than 512.  High speed HCDs may not
<span class="p_chunk">@@ -253,9 +317,6 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	 */
 	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_HIGH
 			&amp;&amp; usb_endpoint_xfer_bulk(d)) {
<span class="p_del">-		unsigned maxp;</span>
<span class="p_del">-</span>
<span class="p_del">-		maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc) &amp; 0x07ff;</span>
 		if (maxp != 512)
 			dev_warn(ddev, &quot;config %d interface %d altsetting %d &quot;
 				&quot;bulk endpoint 0x%X has invalid maxpacket %d\n&quot;,
<span class="p_chunk">@@ -264,7 +325,7 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	}
 
 	/* Parse a possible SuperSpeed endpoint companion descriptor */
<span class="p_del">-	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (to_usb_device(ddev)-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		usb_parse_ss_endpoint_companion(ddev, cfgno,
 				inum, asnum, endpoint, buffer, size);
 
<span class="p_header">diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c</span>
<span class="p_header">index 2a3bbdf7eb94..332ed277a06c 100644</span>
<span class="p_header">--- a/drivers/usb/core/devices.c</span>
<span class="p_header">+++ b/drivers/usb/core/devices.c</span>
<span class="p_chunk">@@ -221,7 +221,7 @@</span> <span class="p_context"> static char *usb_dump_endpoint_descriptor(int speed, char *start, char *end,</span>
 		break;
 	case USB_ENDPOINT_XFER_INT:
 		type = &quot;Int.&quot;;
<span class="p_del">-		if (speed == USB_SPEED_HIGH || speed == USB_SPEED_SUPER)</span>
<span class="p_add">+		if (speed == USB_SPEED_HIGH || speed &gt;= USB_SPEED_SUPER)</span>
 			interval = 1 &lt;&lt; (desc-&gt;bInterval - 1);
 		else
 			interval = desc-&gt;bInterval;
<span class="p_chunk">@@ -230,7 +230,7 @@</span> <span class="p_context"> static char *usb_dump_endpoint_descriptor(int speed, char *start, char *end,</span>
 		return start;
 	}
 	interval *= (speed == USB_SPEED_HIGH ||
<span class="p_del">-		     speed == USB_SPEED_SUPER) ? 125 : 1000;</span>
<span class="p_add">+		     speed &gt;= USB_SPEED_SUPER) ? 125 : 1000;</span>
 	if (interval % 1000)
 		unit = &#39;u&#39;;
 	else {
<span class="p_chunk">@@ -322,7 +322,7 @@</span> <span class="p_context"> static char *usb_dump_config_descriptor(char *start, char *end,</span>
 
 	if (start &gt; end)
 		return start;
<span class="p_del">-	if (speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (speed &gt;= USB_SPEED_SUPER)</span>
 		mul = 8;
 	else
 		mul = 2;
<span class="p_chunk">@@ -534,6 +534,8 @@</span> <span class="p_context"> static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes,</span>
 		speed = &quot;480&quot;; break;
 	case USB_SPEED_SUPER:
 		speed = &quot;5000&quot;; break;
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
<span class="p_add">+		speed = &quot;10000&quot;; break;</span>
 	default:
 		speed = &quot;??&quot;;
 	}
<span class="p_chunk">@@ -553,7 +555,7 @@</span> <span class="p_context"> static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes,</span>
 
 		/* super/high speed reserves 80%, full/low reserves 90% */
 		if (usbdev-&gt;speed == USB_SPEED_HIGH ||
<span class="p_del">-		    usbdev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+		    usbdev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 			max = 800;
 		else
 			max = FRAME_TIME_MAX_USECS_ALLOC;
<span class="p_header">diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">index ccdcc7063eee..a5ffceb50007 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd-pci.c</span>
<span class="p_chunk">@@ -207,7 +207,7 @@</span> <span class="p_context"> int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)</span>
 	 * The xHCI driver has its own irq management
 	 * make sure irq setup is not touched for xhci in generic hcd code
 	 */
<span class="p_del">-	if ((driver-&gt;flags &amp; HCD_MASK) != HCD_USB3) {</span>
<span class="p_add">+	if ((driver-&gt;flags &amp; HCD_MASK) &lt; HCD_USB3) {</span>
 		if (!dev-&gt;irq) {
 			dev_err(&amp;dev-&gt;dev,
 			&quot;Found HC with no IRQ. Check BIOS/PCI %s setup!\n&quot;,
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index ee6c5562d296..2e6ec875b1b7 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -1024,7 +1024,7 @@</span> <span class="p_context"> static int register_root_hub(struct usb_hcd *hcd)</span>
 				dev_name(&amp;usb_dev-&gt;dev), retval);
 		return (retval &lt; 0) ? retval : -EMSGSIZE;
 	}
<span class="p_del">-	if (usb_dev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+	if (usb_dev-&gt;speed &gt;= USB_SPEED_SUPER) {</span>
 		retval = usb_get_bos_descriptor(usb_dev);
 		if (retval &lt; 0) {
 			mutex_unlock(&amp;usb_bus_list_lock);
<span class="p_chunk">@@ -2055,7 +2055,7 @@</span> <span class="p_context"> int usb_alloc_streams(struct usb_interface *interface,</span>
 	hcd = bus_to_hcd(dev-&gt;bus);
 	if (!hcd-&gt;driver-&gt;alloc_streams || !hcd-&gt;driver-&gt;free_streams)
 		return -EINVAL;
<span class="p_del">-	if (dev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (dev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		return -EINVAL;
 	if (dev-&gt;state &lt; USB_STATE_CONFIGURED)
 		return -ENODEV;
<span class="p_chunk">@@ -2093,7 +2093,7 @@</span> <span class="p_context"> int usb_free_streams(struct usb_interface *interface,</span>
 
 	dev = interface_to_usbdev(interface);
 	hcd = bus_to_hcd(dev-&gt;bus);
<span class="p_del">-	if (dev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (dev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		return -EINVAL;
 
 	/* Streams only apply to bulk endpoints. */
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index f46ac929ef8a..a5f77367386d 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -297,7 +297,7 @@</span> <span class="p_context"> static void usb_set_lpm_parameters(struct usb_device *udev)</span>
 	unsigned int hub_u1_del;
 	unsigned int hub_u2_del;
 
<span class="p_del">-	if (!udev-&gt;lpm_capable || udev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (!udev-&gt;lpm_capable || udev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		return;
 
 	hub = usb_hub_to_struct_hub(udev-&gt;parent);
<span class="p_chunk">@@ -2559,7 +2559,7 @@</span> <span class="p_context"> static unsigned hub_is_wusb(struct usb_hub *hub)</span>
  */
 static bool use_new_scheme(struct usb_device *udev, int retry)
 {
<span class="p_del">-	if (udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		return false;
 
 	return USE_NEW_SCHEME(retry);
<span class="p_chunk">@@ -3812,7 +3812,7 @@</span> <span class="p_context"> int usb_disable_lpm(struct usb_device *udev)</span>
 	struct usb_hcd *hcd;
 
 	if (!udev || !udev-&gt;parent ||
<span class="p_del">-			udev-&gt;speed != USB_SPEED_SUPER ||</span>
<span class="p_add">+			udev-&gt;speed &lt; USB_SPEED_SUPER ||</span>
 			!udev-&gt;lpm_capable)
 		return 0;
 
<span class="p_chunk">@@ -3868,7 +3868,7 @@</span> <span class="p_context"> void usb_enable_lpm(struct usb_device *udev)</span>
 	struct usb_hcd *hcd;
 
 	if (!udev || !udev-&gt;parent ||
<span class="p_del">-			udev-&gt;speed != USB_SPEED_SUPER ||</span>
<span class="p_add">+			udev-&gt;speed &lt; USB_SPEED_SUPER ||</span>
 			!udev-&gt;lpm_capable)
 		return;
 
<span class="p_chunk">@@ -4127,7 +4127,9 @@</span> <span class="p_context"> hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 
 	retval = -ENODEV;
 
<span class="p_del">-	if (oldspeed != USB_SPEED_UNKNOWN &amp;&amp; oldspeed != udev-&gt;speed) {</span>
<span class="p_add">+	/* Don&#39;t allow speed changes at reset, except usb 3.0 to faster */</span>
<span class="p_add">+	if (oldspeed != USB_SPEED_UNKNOWN &amp;&amp; oldspeed != udev-&gt;speed &amp;&amp;</span>
<span class="p_add">+	    !(oldspeed == USB_SPEED_SUPER &amp;&amp; udev-&gt;speed &gt; oldspeed)) {</span>
 		dev_dbg(&amp;udev-&gt;dev, &quot;device reset changed speed!\n&quot;);
 		goto fail;
 	}
<span class="p_chunk">@@ -4139,6 +4141,7 @@</span> <span class="p_context"> hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	 * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].
 	 */
 	switch (udev-&gt;speed) {
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 	case USB_SPEED_WIRELESS:	/* fixed at 512 */
 		udev-&gt;ep0.desc.wMaxPacketSize = cpu_to_le16(512);
<span class="p_chunk">@@ -4165,7 +4168,7 @@</span> <span class="p_context"> hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	else
 		speed = usb_speed_string(udev-&gt;speed);
 
<span class="p_del">-	if (udev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (udev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		dev_info(&amp;udev-&gt;dev,
 				&quot;%s %s USB device number %d using %s\n&quot;,
 				(udev-&gt;config) ? &quot;reset&quot; : &quot;new&quot;, speed,
<span class="p_chunk">@@ -4291,11 +4294,12 @@</span> <span class="p_context"> hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 							devnum, retval);
 				goto fail;
 			}
<span class="p_del">-			if (udev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+			if (udev-&gt;speed &gt;= USB_SPEED_SUPER) {</span>
 				devnum = udev-&gt;devnum;
 				dev_info(&amp;udev-&gt;dev,
<span class="p_del">-						&quot;%s SuperSpeed USB device number %d using %s\n&quot;,</span>
<span class="p_add">+						&quot;%s SuperSpeed%s USB device number %d using %s\n&quot;,</span>
 						(udev-&gt;config) ? &quot;reset&quot; : &quot;new&quot;,
<span class="p_add">+					 (udev-&gt;speed == USB_SPEED_SUPER_PLUS) ? &quot;Plus&quot; : &quot;&quot;,</span>
 						devnum, udev-&gt;bus-&gt;controller-&gt;driver-&gt;name);
 			}
 
<span class="p_chunk">@@ -4337,7 +4341,7 @@</span> <span class="p_context"> hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	 * got from those devices show they aren&#39;t superspeed devices. Warm
 	 * reset the port attached by the devices can fix them.
 	 */
<span class="p_del">-	if ((udev-&gt;speed == USB_SPEED_SUPER) &amp;&amp;</span>
<span class="p_add">+	if ((udev-&gt;speed &gt;= USB_SPEED_SUPER) &amp;&amp;</span>
 			(le16_to_cpu(udev-&gt;descriptor.bcdUSB) &lt; 0x0300)) {
 		dev_err(&amp;udev-&gt;dev, &quot;got a wrong device descriptor, &quot;
 				&quot;warm reset device\n&quot;);
<span class="p_chunk">@@ -4348,7 +4352,7 @@</span> <span class="p_context"> hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	}
 
 	if (udev-&gt;descriptor.bMaxPacketSize0 == 0xff ||
<span class="p_del">-			udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+			udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		i = 512;
 	else
 		i = udev-&gt;descriptor.bMaxPacketSize0;
<span class="p_chunk">@@ -4607,7 +4611,7 @@</span> <span class="p_context"> static void hub_port_connect_change(struct usb_hub *hub, int port1,</span>
 		udev-&gt;level = hdev-&gt;level + 1;
 		udev-&gt;wusb = hub_is_wusb(hub);
 
<span class="p_del">-		/* Only USB 3.0 devices are connected to SuperSpeed hubs. */</span>
<span class="p_add">+		/* Devices connected to SuperSpeed hubs are USB 3.0 or later */</span>
 		if (hub_is_superspeed(hub-&gt;hdev))
 			udev-&gt;speed = USB_SPEED_SUPER;
 		else
<span class="p_header">diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c</span>
<span class="p_header">index 9ff665f1322f..a47d904b3f87 100644</span>
<span class="p_header">--- a/drivers/usb/core/urb.c</span>
<span class="p_header">+++ b/drivers/usb/core/urb.c</span>
<span class="p_chunk">@@ -402,7 +402,7 @@</span> <span class="p_context"> int usb_submit_urb(struct urb *urb, gfp_t mem_flags)</span>
 		/* SuperSpeed isoc endpoints have up to 16 bursts of up to
 		 * 3 packets each
 		 */
<span class="p_del">-		if (dev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+		if (dev-&gt;speed &gt;= USB_SPEED_SUPER) {</span>
 			int     burst = 1 + ep-&gt;ss_ep_comp.bMaxBurst;
 			int     mult = USB_SS_MULT(ep-&gt;ss_ep_comp.bmAttributes);
 			max *= burst;
<span class="p_chunk">@@ -499,6 +499,7 @@</span> <span class="p_context"> int usb_submit_urb(struct urb *urb, gfp_t mem_flags)</span>
 		}
 		/* too big? */
 		switch (dev-&gt;speed) {
<span class="p_add">+		case USB_SPEED_SUPER_PLUS:</span>
 		case USB_SPEED_SUPER:	/* units are 125us */
 			/* Handle up to 2^(16-1) microframes */
 			if (urb-&gt;interval &gt; (1 &lt;&lt; 15))
<span class="p_header">diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h</span>
<span class="p_header">index 0923add72b59..e9fad3d863a3 100644</span>
<span class="p_header">--- a/drivers/usb/core/usb.h</span>
<span class="p_header">+++ b/drivers/usb/core/usb.h</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> static inline unsigned usb_get_max_power(struct usb_device *udev,</span>
 		struct usb_host_config *c)
 {
 	/* SuperSpeed power is in 8 mA units; others are in 2 mA units */
<span class="p_del">-	unsigned mul = (udev-&gt;speed == USB_SPEED_SUPER ? 8 : 2);</span>
<span class="p_add">+	unsigned mul = (udev-&gt;speed &gt;= USB_SPEED_SUPER ? 8 : 2);</span>
 
 	return c-&gt;desc.bMaxPower * mul;
 }
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index a57ad1f52f79..48fa53ba354b 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -1799,14 +1799,6 @@</span> <span class="p_context"> static int __dwc3_cleanup_done_trbs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 			s_pkt = 1;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We assume here we will always receive the entire data block</span>
<span class="p_del">-	 * which we should receive. Meaning, if we program RX to</span>
<span class="p_del">-	 * receive 4K but we receive only 2K, we assume that&#39;s all we</span>
<span class="p_del">-	 * should receive and we simply bounce the request back to the</span>
<span class="p_del">-	 * gadget driver for further processing.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	req-&gt;request.actual += req-&gt;request.length - count;</span>
 	if (s_pkt)
 		return 1;
 	if ((event-&gt;status &amp; DEPEVT_STATUS_LST) &amp;&amp;
<span class="p_chunk">@@ -1826,6 +1818,7 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 	struct dwc3_trb		*trb;
 	unsigned int		slot;
 	unsigned int		i;
<span class="p_add">+	int			count = 0;</span>
 	int			ret;
 
 	do {
<span class="p_chunk">@@ -1842,6 +1835,8 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 				slot++;
 			slot %= DWC3_TRB_NUM;
 			trb = &amp;dep-&gt;trb_pool[slot];
<span class="p_add">+			count += trb-&gt;size &amp; DWC3_TRB_SIZE_MASK;</span>
<span class="p_add">+</span>
 
 			ret = __dwc3_cleanup_done_trbs(dwc, dep, req, trb,
 					event, status);
<span class="p_chunk">@@ -1849,6 +1844,14 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 				break;
 		}while (++i &lt; req-&gt;request.num_mapped_sgs);
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We assume here we will always receive the entire data block</span>
<span class="p_add">+		 * which we should receive. Meaning, if we program RX to</span>
<span class="p_add">+		 * receive 4K but we receive only 2K, we assume that&#39;s all we</span>
<span class="p_add">+		 * should receive and we simply bounce the request back to the</span>
<span class="p_add">+		 * gadget driver for further processing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		req-&gt;request.actual += req-&gt;request.length - count;</span>
 		dwc3_gadget_giveback(dep, req, status);
 
 		if (ret)
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 7f01f165e77b..69b28af70b7c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -276,6 +276,9 @@</span> <span class="p_context"> static int xhci_stop_device(struct xhci_hcd *xhci, int slot_id, int suspend)</span>
 
 	ret = 0;
 	virt_dev = xhci-&gt;devs[slot_id];
<span class="p_add">+	if (!virt_dev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	cmd = xhci_alloc_command(xhci, false, true, GFP_NOIO);
 	if (!cmd) {
 		xhci_dbg(xhci, &quot;Couldn&#39;t allocate command structure.\n&quot;);
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index b39d217310fe..831e28989181 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -974,7 +974,7 @@</span> <span class="p_context"> static u32 xhci_find_real_port_number(struct xhci_hcd *xhci,</span>
 	struct usb_device *top_dev;
 	struct usb_hcd *hcd;
 
<span class="p_del">-	if (udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		hcd = xhci-&gt;shared_hcd;
 	else
 		hcd = xhci-&gt;main_hcd;
<span class="p_chunk">@@ -1009,6 +1009,7 @@</span> <span class="p_context"> int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *ud</span>
 	/* 3) Only the control endpoint is valid - one endpoint context */
 	slot_ctx-&gt;dev_info |= cpu_to_le32(LAST_CTX(1) | udev-&gt;route);
 	switch (udev-&gt;speed) {
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 		slot_ctx-&gt;dev_info |= cpu_to_le32(SLOT_SPEED_SS);
 		max_packets = MAX_PACKET(512);
<span class="p_chunk">@@ -1196,6 +1197,7 @@</span> <span class="p_context"> static unsigned int xhci_get_endpoint_interval(struct usb_device *udev,</span>
 		}
 		/* Fall through - SS and HS isoc/int have same decoding */
 
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 		if (usb_endpoint_xfer_int(&amp;ep-&gt;desc) ||
 		    usb_endpoint_xfer_isoc(&amp;ep-&gt;desc)) {
<span class="p_chunk">@@ -1236,7 +1238,7 @@</span> <span class="p_context"> static unsigned int xhci_get_endpoint_interval(struct usb_device *udev,</span>
 static u32 xhci_get_endpoint_mult(struct usb_device *udev,
 		struct usb_host_endpoint *ep)
 {
<span class="p_del">-	if (udev-&gt;speed != USB_SPEED_SUPER ||</span>
<span class="p_add">+	if (udev-&gt;speed &lt; USB_SPEED_SUPER ||</span>
 			!usb_endpoint_xfer_isoc(&amp;ep-&gt;desc))
 		return 0;
 	return ep-&gt;ss_ep_comp.bmAttributes;
<span class="p_chunk">@@ -1288,7 +1290,7 @@</span> <span class="p_context"> static u32 xhci_get_max_esit_payload(struct xhci_hcd *xhci,</span>
 			usb_endpoint_xfer_bulk(&amp;ep-&gt;desc))
 		return 0;
 
<span class="p_del">-	if (udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		return le16_to_cpu(ep-&gt;ss_ep_comp.wBytesPerInterval);
 
 	max_packet = GET_MAX_PACKET(usb_endpoint_maxp(&amp;ep-&gt;desc));
<span class="p_chunk">@@ -1359,6 +1361,7 @@</span> <span class="p_context"> int xhci_endpoint_init(struct xhci_hcd *xhci,</span>
 	max_packet = GET_MAX_PACKET(usb_endpoint_maxp(&amp;ep-&gt;desc));
 	max_burst = 0;
 	switch (udev-&gt;speed) {
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 		/* dig out max burst from ep companion desc */
 		max_burst = ep-&gt;ss_ep_comp.bMaxBurst;
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 3bfe81c6229a..4025a57ffb98 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -3705,7 +3705,7 @@</span> <span class="p_context"> static unsigned int xhci_get_burst_count(struct xhci_hcd *xhci,</span>
 {
 	unsigned int max_burst;
 
<span class="p_del">-	if (xhci-&gt;hci_version &lt; 0x100 || udev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (xhci-&gt;hci_version &lt; 0x100 || udev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		return 0;
 
 	max_burst = urb-&gt;ep-&gt;ss_ep_comp.bMaxBurst;
<span class="p_chunk">@@ -3731,6 +3731,7 @@</span> <span class="p_context"> static unsigned int xhci_get_last_burst_packet_count(struct xhci_hcd *xhci,</span>
 		return 0;
 
 	switch (udev-&gt;speed) {
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 		/* bMaxBurst is zero based: 0 means 1 packet per burst */
 		max_burst = urb-&gt;ep-&gt;ss_ep_comp.bMaxBurst;
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index b63507bbf74b..648f8c4761ed 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -2054,6 +2054,7 @@</span> <span class="p_context"> static unsigned int xhci_get_block_size(struct usb_device *udev)</span>
 	case USB_SPEED_HIGH:
 		return HS_BLOCK;
 	case USB_SPEED_SUPER:
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 		return SS_BLOCK;
 	case USB_SPEED_UNKNOWN:
 	case USB_SPEED_WIRELESS:
<span class="p_chunk">@@ -2179,7 +2180,7 @@</span> <span class="p_context"> static int xhci_check_bw_table(struct xhci_hcd *xhci,</span>
 	unsigned int packets_remaining = 0;
 	unsigned int i;
 
<span class="p_del">-	if (virt_dev-&gt;udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (virt_dev-&gt;udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		return xhci_check_ss_bw(xhci, virt_dev);
 
 	if (virt_dev-&gt;udev-&gt;speed == USB_SPEED_HIGH) {
<span class="p_chunk">@@ -2380,7 +2381,7 @@</span> <span class="p_context"> void xhci_drop_ep_from_interval_table(struct xhci_hcd *xhci,</span>
 	if (xhci_is_async_ep(ep_bw-&gt;type))
 		return;
 
<span class="p_del">-	if (udev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+	if (udev-&gt;speed &gt;= USB_SPEED_SUPER) {</span>
 		if (xhci_is_sync_in_ep(ep_bw-&gt;type))
 			xhci-&gt;devs[udev-&gt;slot_id]-&gt;bw_table-&gt;ss_bw_in -=
 				xhci_get_ss_bw_consumed(ep_bw);
<span class="p_chunk">@@ -2418,6 +2419,7 @@</span> <span class="p_context"> void xhci_drop_ep_from_interval_table(struct xhci_hcd *xhci,</span>
 		interval_bw-&gt;overhead[HS_OVERHEAD_TYPE] -= 1;
 		break;
 	case USB_SPEED_SUPER:
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_UNKNOWN:
 	case USB_SPEED_WIRELESS:
 		/* Should never happen because only LS/FS/HS endpoints will get
<span class="p_chunk">@@ -2477,6 +2479,7 @@</span> <span class="p_context"> static void xhci_add_ep_to_interval_table(struct xhci_hcd *xhci,</span>
 		interval_bw-&gt;overhead[HS_OVERHEAD_TYPE] += 1;
 		break;
 	case USB_SPEED_SUPER:
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_UNKNOWN:
 	case USB_SPEED_WIRELESS:
 		/* Should never happen because only LS/FS/HS endpoints will get
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index fb3a832d86e3..6103727cd060 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -661,6 +661,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_TFD128_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_FM3RX_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS777_PID) },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_PALMSENS_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_IVIUM_XSTAT_PID) },</span>
 	{ USB_DEVICE(FTDI_VID, LINX_SDMUSBQSS_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_MASTERDEVEL2_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_FUTURE_0_PID) },
<span class="p_chunk">@@ -1021,6 +1023,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7560U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7561U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7563U_PID) },
<span class="p_add">+	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 334bc600282d..48db84f25cc9 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -406,6 +406,12 @@</span> <span class="p_context"></span>
 #define FTDI_4N_GALAXY_DE_3_PID	0xF3C2
 
 /*
<span class="p_add">+ * Ivium Technologies product IDs</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FTDI_PALMSENS_PID	0xf440</span>
<span class="p_add">+#define FTDI_IVIUM_XSTAT_PID	0xf441</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Linx Technologies product ids
  */
 #define LINX_SDMUSBQSS_PID	0xF448	/* Linx SDM-USB-QS-S */
<span class="p_chunk">@@ -673,6 +679,12 @@</span> <span class="p_context"></span>
 #define INTREPID_NEOVI_PID	0x0701
 
 /*
<span class="p_add">+ * WICED USB UART</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define WICED_VID		0x0A5C</span>
<span class="p_add">+#define WICED_USB20706V2_PID	0x6422</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Definitions for ID TECH (www.idt-net.com) devices
  */
 #define IDTECH_VID		0x0ACD	/* ID TECH Vendor ID */
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index 4eb277225a77..56bc36439146 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -1239,7 +1239,7 @@</span> <span class="p_context"> static int mos7720_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 
 	if (urb-&gt;transfer_buffer == NULL) {
 		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,
<span class="p_del">-					       GFP_KERNEL);</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 		if (!urb-&gt;transfer_buffer)
 			goto exit;
 	}
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index e9d967ff521b..92f1a3bc22a8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -1372,8 +1372,8 @@</span> <span class="p_context"> static int mos7840_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 	}
 
 	if (urb-&gt;transfer_buffer == NULL) {
<span class="p_del">-		urb-&gt;transfer_buffer =</span>
<span class="p_del">-		    kmalloc(URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);</span>
<span class="p_add">+		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 		if (!urb-&gt;transfer_buffer)
 			goto exit;
 	}
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 006a2a721edf..2bc169692965 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -275,6 +275,12 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
 #define TELIT_PRODUCT_LE910_USBCFG4		0x1206
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1207		0x1207</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1208		0x1208</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1211		0x1211</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1212		0x1212</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1213		0x1213</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1214		0x1214</span>
 
 /* ZTE PRODUCTS */
 #define ZTE_VENDOR_ID				0x19d2
<span class="p_chunk">@@ -636,6 +642,11 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_le920_blacklist = {</span>
 	.reserved = BIT(1) | BIT(5),
 };
 
<span class="p_add">+static const struct option_blacklist_info telit_le920a4_blacklist_1 = {</span>
<span class="p_add">+	.sendsetup = BIT(0),</span>
<span class="p_add">+	.reserved = BIT(1),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info telit_le922_blacklist_usbcfg0 = {
 	.sendsetup = BIT(2),
 	.reserved = BIT(0) | BIT(1) | BIT(3),
<span class="p_chunk">@@ -1211,6 +1222,16 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
 		.driver_info = (kernel_ulong_t)&amp;telit_le920_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1207) },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1208),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le920a4_blacklist_1 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1211),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1212),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le920a4_blacklist_1 },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1213, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1214),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff),
 		.driver_info = (kernel_ulong_t)&amp;net_intf1_blacklist },
<span class="p_chunk">@@ -1839,6 +1860,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x7e11, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/A3 */</span>
 	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">index 3d66e9c5a95d..a5308a97f65e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial.c</span>
<span class="p_chunk">@@ -1426,7 +1426,7 @@</span> <span class="p_context"> int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[]</span>
 
 	rc = usb_register(udriver);
 	if (rc)
<span class="p_del">-		return rc;</span>
<span class="p_add">+		goto failed_usb_register;</span>
 
 	for (sd = serial_drivers; *sd; ++sd) {
 		(*sd)-&gt;usb_driver = udriver;
<span class="p_chunk">@@ -1444,6 +1444,8 @@</span> <span class="p_context"> int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[]</span>
 	while (sd-- &gt; serial_drivers)
 		usb_serial_deregister(*sd);
 	usb_deregister(udriver);
<span class="p_add">+failed_usb_register:</span>
<span class="p_add">+	kfree(udriver);</span>
 	return rc;
 }
 EXPORT_SYMBOL_GPL(usb_serial_register_drivers);
<span class="p_header">diff --git a/fs/seq_file.c b/fs/seq_file.c</span>
<span class="p_header">index 1d641bb108d2..d88584c61c1e 100644</span>
<span class="p_header">--- a/fs/seq_file.c</span>
<span class="p_header">+++ b/fs/seq_file.c</span>
<span class="p_chunk">@@ -207,8 +207,10 @@</span> <span class="p_context"> ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)</span>
 		size -= n;
 		buf += n;
 		copied += n;
<span class="p_del">-		if (!m-&gt;count)</span>
<span class="p_add">+		if (!m-&gt;count) {</span>
<span class="p_add">+			m-&gt;from = 0;</span>
 			m-&gt;index++;
<span class="p_add">+		}</span>
 		if (!size)
 			goto Done;
 	}
<span class="p_header">diff --git a/include/linux/i8042.h b/include/linux/i8042.h</span>
<span class="p_header">index 0f9bafa17a02..d98780ca9604 100644</span>
<span class="p_header">--- a/include/linux/i8042.h</span>
<span class="p_header">+++ b/include/linux/i8042.h</span>
<span class="p_chunk">@@ -62,7 +62,6 @@</span> <span class="p_context"> struct serio;</span>
 void i8042_lock_chip(void);
 void i8042_unlock_chip(void);
 int i8042_command(unsigned char *param, int command);
<span class="p_del">-bool i8042_check_port_owner(const struct serio *);</span>
 int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio));
 int i8042_remove_filter(bool (*filter)(unsigned char data, unsigned char str,
<span class="p_chunk">@@ -83,11 +82,6 @@</span> <span class="p_context"> static inline int i8042_command(unsigned char *param, int command)</span>
 	return -ENODEV;
 }
 
<span class="p_del">-static inline bool i8042_check_port_owner(const struct serio *serio)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio))
 {
<span class="p_header">diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h</span>
<span class="p_header">index 057c1d8c77e5..b3bf527d211b 100644</span>
<span class="p_header">--- a/include/linux/pci_ids.h</span>
<span class="p_header">+++ b/include/linux/pci_ids.h</span>
<span class="p_chunk">@@ -2473,6 +2473,13 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_KORENIX_JETCARDF2	0x1700
 #define PCI_DEVICE_ID_KORENIX_JETCARDF3	0x17ff
 
<span class="p_add">+#define PCI_VENDOR_ID_NETRONOME		0x19ee</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP3200	0x3200</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP3240	0x3240</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP4000	0x4000</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP6000	0x6000</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP6000_VF	0x6003</span>
<span class="p_add">+</span>
 #define PCI_VENDOR_ID_QMI		0x1a32
 
 #define PCI_VENDOR_ID_AZWAVE		0x1a3b
<span class="p_header">diff --git a/include/linux/serio.h b/include/linux/serio.h</span>
<span class="p_header">index 9f779c7a2da4..27ae809edd70 100644</span>
<span class="p_header">--- a/include/linux/serio.h</span>
<span class="p_header">+++ b/include/linux/serio.h</span>
<span class="p_chunk">@@ -29,7 +29,8 @@</span> <span class="p_context"> struct serio {</span>
 
 	struct serio_device_id id;
 
<span class="p_del">-	spinlock_t lock;		/* protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	/* Protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	spinlock_t lock;</span>
 
 	int (*write)(struct serio *, unsigned char);
 	int (*open)(struct serio *);
<span class="p_chunk">@@ -38,16 +39,29 @@</span> <span class="p_context"> struct serio {</span>
 	void (*stop)(struct serio *);
 
 	struct serio *parent;
<span class="p_del">-	struct list_head child_node;	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	struct list_head child_node;</span>
 	struct list_head children;
<span class="p_del">-	unsigned int depth;		/* level of nesting in serio hierarchy */</span>
<span class="p_add">+	/* Level of nesting in serio hierarchy */</span>
<span class="p_add">+	unsigned int depth;</span>
 
<span class="p_del">-	struct serio_driver *drv;	/* accessed from interrupt, must be protected by serio-&gt;lock and serio-&gt;sem */</span>
<span class="p_del">-	struct mutex drv_mutex;		/* protects serio-&gt;drv so attributes can pin driver */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * serio-&gt;drv is accessed from interrupt handlers; when modifying</span>
<span class="p_add">+	 * caller should acquire serio-&gt;drv_mutex and serio-&gt;lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct serio_driver *drv;</span>
<span class="p_add">+	/* Protects serio-&gt;drv so attributes can pin current driver */</span>
<span class="p_add">+	struct mutex drv_mutex;</span>
 
 	struct device dev;
 
 	struct list_head node;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For use by PS/2 layer when several ports share hardware and</span>
<span class="p_add">+	 * may get indigestion when exposed to concurrent access (i8042).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct mutex *ps2_cmd_mutex;</span>
 };
 #define to_serio_port(d)	container_of(d, struct serio, dev)
 
<span class="p_header">diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">index aa33fd1b2d4f..bff03877a2c8 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch9.h</span>
<span class="p_chunk">@@ -913,6 +913,7 @@</span> <span class="p_context"> enum usb_device_speed {</span>
 	USB_SPEED_HIGH,				/* usb 2.0 */
 	USB_SPEED_WIRELESS,			/* wireless (usb 2.5) */
 	USB_SPEED_SUPER,			/* usb 3.0 */
<span class="p_add">+	USB_SPEED_SUPER_PLUS,			/* usb 3.1 */</span>
 };
 
 
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index 453e974287d1..ccaffd79dc6d 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -1126,7 +1126,7 @@</span> <span class="p_context"> static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)</span>
 
 	/* free all potentially still buffered bcast frames */
 	local-&gt;total_ps_buffered -= skb_queue_len(&amp;sdata-&gt;u.ap.ps.bc_buf);
<span class="p_del">-	skb_queue_purge(&amp;sdata-&gt;u.ap.ps.bc_buf);</span>
<span class="p_add">+	ieee80211_purge_tx_queue(&amp;local-&gt;hw, &amp;sdata-&gt;u.ap.ps.bc_buf);</span>
 
 	ieee80211_vif_copy_chanctx_to_vlans(sdata, true);
 	mutex_lock(&amp;local-&gt;mtx);
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index bc08a9ce3bd4..0f334c15ec9d 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -351,7 +351,7 @@</span> <span class="p_context"> static void purge_old_ps_buffers(struct ieee80211_local *local)</span>
 		skb = skb_dequeue(&amp;ps-&gt;bc_buf);
 		if (skb) {
 			purged++;
<span class="p_del">-			dev_kfree_skb(skb);</span>
<span class="p_add">+			ieee80211_free_txskb(&amp;local-&gt;hw, skb);</span>
 		}
 		total += skb_queue_len(&amp;ps-&gt;bc_buf);
 	}
<span class="p_chunk">@@ -434,7 +434,7 @@</span> <span class="p_context"> ieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)</span>
 	if (skb_queue_len(&amp;ps-&gt;bc_buf) &gt;= AP_MAX_BC_BUFFER) {
 		ps_dbg(tx-&gt;sdata,
 		       &quot;BC TX buffer full - dropping the oldest frame\n&quot;);
<span class="p_del">-		dev_kfree_skb(skb_dequeue(&amp;ps-&gt;bc_buf));</span>
<span class="p_add">+		ieee80211_free_txskb(&amp;tx-&gt;local-&gt;hw, skb_dequeue(&amp;ps-&gt;bc_buf));</span>
 	} else
 		tx-&gt;local-&gt;total_ps_buffered++;
 
<span class="p_chunk">@@ -2910,7 +2910,7 @@</span> <span class="p_context"> ieee80211_get_buffered_bc(struct ieee80211_hw *hw,</span>
 			sdata = IEEE80211_DEV_TO_SUB_IF(skb-&gt;dev);
 		if (!ieee80211_tx_prepare(sdata, &amp;tx, skb))
 			break;
<span class="p_del">-		dev_kfree_skb_any(skb);</span>
<span class="p_add">+		ieee80211_free_txskb(hw, skb);</span>
 	}
 
 	info = IEEE80211_SKB_CB(skb);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



