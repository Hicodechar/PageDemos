
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>powerpc/pseries: Fix stack corruption in htpe code - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    powerpc/pseries: Fix stack corruption in htpe code</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=89031">Laurent Dufour</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 6, 2016, 1:33 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1475760801-10592-1-git-send-email-ldufour@linux.vnet.ibm.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9364805/mbox/"
   >mbox</a>
|
   <a href="/patch/9364805/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9364805/">/patch/9364805/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	AABB0607D3 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  6 Oct 2016 13:33:40 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9C22329010
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  6 Oct 2016 13:33:40 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 9084F29012; Thu,  6 Oct 2016 13:33:40 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id F21E229010
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  6 Oct 2016 13:33:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755673AbcJFNdc (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 6 Oct 2016 09:33:32 -0400
Received: from mx0b-001b2d01.pphosted.com ([148.163.158.5]:36888 &quot;EHLO
	mx0a-001b2d01.pphosted.com&quot; rhost-flags-OK-OK-OK-FAIL)
	by vger.kernel.org with ESMTP id S1753924AbcJFNd2 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 6 Oct 2016 09:33:28 -0400
Received: from pps.filterd (m0098413.ppops.net [127.0.0.1])
	by mx0b-001b2d01.pphosted.com (8.16.0.17/8.16.0.17) with SMTP id
	u96DUGpC080883
	for &lt;linux-kernel@vger.kernel.org&gt;; Thu, 6 Oct 2016 09:33:28 -0400
Received: from e06smtp11.uk.ibm.com (e06smtp11.uk.ibm.com [195.75.94.107])
	by mx0b-001b2d01.pphosted.com with ESMTP id 25wjfbrbup-1
	(version=TLSv1.2 cipher=AES256-SHA bits=256 verify=NOT)
	for &lt;linux-kernel@vger.kernel.org&gt;; Thu, 06 Oct 2016 09:33:28 -0400
Received: from localhost
	by e06smtp11.uk.ibm.com with IBM ESMTP SMTP Gateway: Authorized Use
	Only! Violators will be prosecuted
	for &lt;linux-kernel@vger.kernel.org&gt; from &lt;ldufour@linux.vnet.ibm.com&gt;; 
	Thu, 6 Oct 2016 14:33:26 +0100
Received: from d06dlp01.portsmouth.uk.ibm.com (9.149.20.13)
	by e06smtp11.uk.ibm.com (192.168.101.141) with IBM ESMTP SMTP
	Gateway: Authorized Use Only! Violators will be prosecuted; 
	Thu, 6 Oct 2016 14:33:24 +0100
Received: from b06cxnps3075.portsmouth.uk.ibm.com
	(d06relay10.portsmouth.uk.ibm.com [9.149.109.195])
	by d06dlp01.portsmouth.uk.ibm.com (Postfix) with ESMTP id
	243C317D8024; Thu,  6 Oct 2016 14:35:29 +0100 (BST)
Received: from d06av04.portsmouth.uk.ibm.com (d06av04.portsmouth.uk.ibm.com
	[9.149.37.216])
	by b06cxnps3075.portsmouth.uk.ibm.com (8.14.9/8.14.9/NCO v10.0) with
	ESMTP id u96DXNmU6160718; Thu, 6 Oct 2016 13:33:23 GMT
Received: from d06av04.portsmouth.uk.ibm.com (localhost [127.0.0.1])
	by d06av04.portsmouth.uk.ibm.com (8.14.4/8.14.4/NCO v10.0 AVout) with
	ESMTP id u96DXM2U014405; Thu, 6 Oct 2016 07:33:23 -0600
Received: from nimbus.lab.toulouse-stg.fr.ibm.com
	(nimbus.lab.toulouse-stg.fr.ibm.com [9.101.4.33])
	by d06av04.portsmouth.uk.ibm.com (8.14.4/8.14.4/NCO v10.0 AVin) with
	ESMTP id u96DXLVW014390; Thu, 6 Oct 2016 07:33:21 -0600
From: Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt;
To: linuxppc-dev@lists.ozlabs.org, mpe@ellerman.id.au
Cc: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	&quot;Aneesh Kumar K . V&quot; &lt;aneesh.kumar@linux.vnet.ibm.com&gt;
Subject: [PATCH] powerpc/pseries: Fix stack corruption in htpe code
Date: Thu,  6 Oct 2016 15:33:21 +0200
X-Mailer: git-send-email 2.7.4
X-TM-AS-MML: disable
X-Content-Scanned: Fidelis XPS MAILER
x-cbid: 16100613-0040-0000-0000-000002E93338
X-IBM-AV-DETECTION: SAVI=unused REMOTE=unused XFE=unused
x-cbparentid: 16100613-0041-0000-0000-00001D5F5C6D
Message-Id: &lt;1475760801-10592-1-git-send-email-ldufour@linux.vnet.ibm.com&gt;
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10432:, ,
	definitions=2016-10-06_06:, , signatures=0
X-Proofpoint-Spam-Details: rule=outbound_notspam policy=outbound score=0
	spamscore=0 suspectscore=0
	malwarescore=0 phishscore=0 adultscore=0 bulkscore=0 classifier=spam
	adjust=0 reason=mlx scancount=1 engine=8.0.1-1609300000
	definitions=main-1610060239
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=89031">Laurent Dufour</a> - Oct. 6, 2016, 1:33 p.m.</div>
<pre class="content">
This commit fixes a stack corruption in the pseries specific code dealing
with the huge pages.

In __pSeries_lpar_hugepage_invalidate() the buffer used to pass arguments
to the hypervisor is not large enough. This leads to a stack corruption
where a previously saved register could be corrupted leading to unexpected
result in the caller, like the following panic:

Oops: Kernel access of bad area, sig: 11 [#1]
SMP NR_CPUS=2048 NUMA pSeries
Modules linked in: virtio_balloon ip_tables x_tables autofs4
virtio_blk 8139too virtio_pci virtio_ring 8139cp virtio
CPU: 11 PID: 1916 Comm: mmstress Not tainted 4.8.0 #76
task: c000000005394880 task.stack: c000000005570000
NIP: c00000000027bf6c LR: c00000000027bf64 CTR: 0000000000000000
REGS: c000000005573820 TRAP: 0300   Not tainted  (4.8.0)
MSR: 8000000000009033 &lt;SF,EE,ME,IR,DR,RI,LE&gt;  CR: 84822884  XER:
20000000
CFAR: c00000000010a924 DAR: 420000000014e5e0 DSISR: 40000000 SOFTE: 1
GPR00: c00000000027bf64 c000000005573aa0 c000000000e02800 c000000004447964
GPR04: c00000000404de18 c000000004d38810 00000000042100f5 00000000f5002104
GPR08: e0000000f5002104 0000000000000001 042100f5000000e0 00000000042100f5
GPR12: 0000000000002200 c00000000fe02c00 c00000000404de18 0000000000000000
GPR16: c1ffffffffffe7ff 00003fff62000000 420000000014e5e0 00003fff63000000
GPR20: 0008000000000000 c0000000f7014800 0405e600000000e0 0000000000010000
GPR24: c000000004d38810 c000000004447c10 c00000000404de18 c000000004447964
GPR28: c000000005573b10 c000000004d38810 00003fff62000000 420000000014e5e0
NIP [c00000000027bf6c] zap_huge_pmd+0x4c/0x470
LR [c00000000027bf64] zap_huge_pmd+0x44/0x470
Call Trace:
[c000000005573aa0] [c00000000027bf64] zap_huge_pmd+0x44/0x470 (unreliable)
[c000000005573af0] [c00000000022bbd8] unmap_page_range+0xcf8/0xed0
[c000000005573c30] [c00000000022c2d4] unmap_vmas+0x84/0x120
[c000000005573c80] [c000000000235448] unmap_region+0xd8/0x1b0
[c000000005573d80] [c0000000002378f0] do_munmap+0x2d0/0x4c0
[c000000005573df0] [c000000000237be4] SyS_munmap+0x64/0xb0
[c000000005573e30] [c000000000009560] system_call+0x38/0x108
Instruction dump:
fbe1fff8 fb81ffe0 7c7f1b78 7ca32b78 7cbd2b78 f8010010 7c9a2378 f821ffb1
7cde3378 4bfffea9 7c7b1b79 41820298 &lt;e87f0000&gt; 48000130 7fa5eb78 7fc4f378

Most of the time, the bug is surfacing in a caller up in the stack from
__pSeries_lpar_hugepage_invalidate() which is quite confusing.

This bug is pending since v3.11 but was hidden if a caller of the
caller of __pSeries_lpar_hugepage_invalidate() has pushed the corruped
register (r18 in this case) in the stack and is not using it until
restoring it. GCC 6.2.0 seems to raise it more frequently.

This commit also change the definition of the parameter buffer in
pSeries_lpar_flush_hash_range() to rely on the global define
PLPAR_HCALL9_BUFSIZE (no functional change here).

Fixes: 1a5272866f87 (&quot;powerpc: Optimize hugepage invalidate&quot;)
Cc: &lt;stable@vger.kernel.org&gt;
Cc: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;
<span class="signed-off-by">Signed-off-by: Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt;</span>
---
 arch/powerpc/platforms/pseries/lpar.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1141">Aneesh Kumar K.V</a> - Oct. 6, 2016, 3:02 p.m.</div>
<pre class="content">
Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt; writes:
<span class="quote">
&gt; This commit fixes a stack corruption in the pseries specific code dealing</span>
<span class="quote">&gt; with the huge pages.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; In __pSeries_lpar_hugepage_invalidate() the buffer used to pass arguments</span>
<span class="quote">&gt; to the hypervisor is not large enough. This leads to a stack corruption</span>
<span class="quote">&gt; where a previously saved register could be corrupted leading to unexpected</span>
<span class="quote">&gt; result in the caller, like the following panic:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Oops: Kernel access of bad area, sig: 11 [#1]</span>
<span class="quote">&gt; SMP NR_CPUS=2048 NUMA pSeries</span>
<span class="quote">&gt; Modules linked in: virtio_balloon ip_tables x_tables autofs4</span>
<span class="quote">&gt; virtio_blk 8139too virtio_pci virtio_ring 8139cp virtio</span>
<span class="quote">&gt; CPU: 11 PID: 1916 Comm: mmstress Not tainted 4.8.0 #76</span>
<span class="quote">&gt; task: c000000005394880 task.stack: c000000005570000</span>
<span class="quote">&gt; NIP: c00000000027bf6c LR: c00000000027bf64 CTR: 0000000000000000</span>
<span class="quote">&gt; REGS: c000000005573820 TRAP: 0300   Not tainted  (4.8.0)</span>
<span class="quote">&gt; MSR: 8000000000009033 &lt;SF,EE,ME,IR,DR,RI,LE&gt;  CR: 84822884  XER:</span>
<span class="quote">&gt; 20000000</span>
<span class="quote">&gt; CFAR: c00000000010a924 DAR: 420000000014e5e0 DSISR: 40000000 SOFTE: 1</span>
<span class="quote">&gt; GPR00: c00000000027bf64 c000000005573aa0 c000000000e02800 c000000004447964</span>
<span class="quote">&gt; GPR04: c00000000404de18 c000000004d38810 00000000042100f5 00000000f5002104</span>
<span class="quote">&gt; GPR08: e0000000f5002104 0000000000000001 042100f5000000e0 00000000042100f5</span>
<span class="quote">&gt; GPR12: 0000000000002200 c00000000fe02c00 c00000000404de18 0000000000000000</span>
<span class="quote">&gt; GPR16: c1ffffffffffe7ff 00003fff62000000 420000000014e5e0 00003fff63000000</span>
<span class="quote">&gt; GPR20: 0008000000000000 c0000000f7014800 0405e600000000e0 0000000000010000</span>
<span class="quote">&gt; GPR24: c000000004d38810 c000000004447c10 c00000000404de18 c000000004447964</span>
<span class="quote">&gt; GPR28: c000000005573b10 c000000004d38810 00003fff62000000 420000000014e5e0</span>
<span class="quote">&gt; NIP [c00000000027bf6c] zap_huge_pmd+0x4c/0x470</span>
<span class="quote">&gt; LR [c00000000027bf64] zap_huge_pmd+0x44/0x470</span>
<span class="quote">&gt; Call Trace:</span>
<span class="quote">&gt; [c000000005573aa0] [c00000000027bf64] zap_huge_pmd+0x44/0x470 (unreliable)</span>
<span class="quote">&gt; [c000000005573af0] [c00000000022bbd8] unmap_page_range+0xcf8/0xed0</span>
<span class="quote">&gt; [c000000005573c30] [c00000000022c2d4] unmap_vmas+0x84/0x120</span>
<span class="quote">&gt; [c000000005573c80] [c000000000235448] unmap_region+0xd8/0x1b0</span>
<span class="quote">&gt; [c000000005573d80] [c0000000002378f0] do_munmap+0x2d0/0x4c0</span>
<span class="quote">&gt; [c000000005573df0] [c000000000237be4] SyS_munmap+0x64/0xb0</span>
<span class="quote">&gt; [c000000005573e30] [c000000000009560] system_call+0x38/0x108</span>
<span class="quote">&gt; Instruction dump:</span>
<span class="quote">&gt; fbe1fff8 fb81ffe0 7c7f1b78 7ca32b78 7cbd2b78 f8010010 7c9a2378 f821ffb1</span>
<span class="quote">&gt; 7cde3378 4bfffea9 7c7b1b79 41820298 &lt;e87f0000&gt; 48000130 7fa5eb78 7fc4f378</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Most of the time, the bug is surfacing in a caller up in the stack from</span>
<span class="quote">&gt; __pSeries_lpar_hugepage_invalidate() which is quite confusing.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This bug is pending since v3.11 but was hidden if a caller of the</span>
<span class="quote">&gt; caller of __pSeries_lpar_hugepage_invalidate() has pushed the corruped</span>
<span class="quote">&gt; register (r18 in this case) in the stack and is not using it until</span>
<span class="quote">&gt; restoring it. GCC 6.2.0 seems to raise it more frequently.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This commit also change the definition of the parameter buffer in</span>
<span class="quote">&gt; pSeries_lpar_flush_hash_range() to rely on the global define</span>
<span class="quote">&gt; PLPAR_HCALL9_BUFSIZE (no functional change here).</span>
<span class="quote">&gt;</span>
<span class="reviewed-by">
Reviewed-by: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">
&gt; Fixes: 1a5272866f87 (&quot;powerpc: Optimize hugepage invalidate&quot;)</span>
<span class="quote">&gt; Cc: &lt;stable@vger.kernel.org&gt;</span>
<span class="quote">&gt; Cc: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/powerpc/platforms/pseries/lpar.c | 4 ++--</span>
<span class="quote">&gt;  1 file changed, 2 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/powerpc/platforms/pseries/lpar.c b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; index 86707e67843f..aa35245d8d6d 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; @@ -393,7 +393,7 @@ static void __pSeries_lpar_hugepage_invalidate(unsigned long *slot,</span>
<span class="quote">&gt;  					     unsigned long *vpn, int count,</span>
<span class="quote">&gt;  					     int psize, int ssize)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	unsigned long param[8];</span>
<span class="quote">&gt; +	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
<span class="quote">&gt;  	int i = 0, pix = 0, rc;</span>
<span class="quote">&gt;  	unsigned long flags = 0;</span>
<span class="quote">&gt;  	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);</span>
<span class="quote">&gt; @@ -522,7 +522,7 @@ static void pSeries_lpar_flush_hash_range(unsigned long number, int local)</span>
<span class="quote">&gt;  	unsigned long flags = 0;</span>
<span class="quote">&gt;  	struct ppc64_tlb_batch *batch = this_cpu_ptr(&amp;ppc64_tlb_batch);</span>
<span class="quote">&gt;  	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);</span>
<span class="quote">&gt; -	unsigned long param[9];</span>
<span class="quote">&gt; +	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
<span class="quote">&gt;  	unsigned long hash, index, shift, hidx, slot;</span>
<span class="quote">&gt;  	real_pte_t pte;</span>
<span class="quote">&gt;  	int psize, ssize;</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.7.4</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=245">Benjamin Herrenschmidt</a> - Oct. 6, 2016, 11:06 p.m.</div>
<pre class="content">
On Thu, 2016-10-06 at 15:33 +0200, Laurent Dufour wrote:
<span class="quote">&gt; This commit fixes a stack corruption in the pseries specific code</span>
<span class="quote">&gt; dealing</span>
<span class="quote">&gt; with the huge pages.</span>

Wow, nice catch !
<span class="quote">
&gt; In __pSeries_lpar_hugepage_invalidate() the buffer used to pass</span>
<span class="quote">&gt; arguments</span>
<span class="quote">&gt; to the hypervisor is not large enough. This leads to a stack</span>
<span class="quote">&gt; corruption</span>
<span class="quote">&gt; where a previously saved register could be corrupted leading to</span>
<span class="quote">&gt; unexpected</span>
<span class="quote">&gt; result in the caller, like the following panic:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Oops: Kernel access of bad area, sig: 11 [#1]</span>
<span class="quote">&gt; SMP NR_CPUS=2048 NUMA pSeries</span>
<span class="quote">&gt; Modules linked in: virtio_balloon ip_tables x_tables autofs4</span>
<span class="quote">&gt; virtio_blk 8139too virtio_pci virtio_ring 8139cp virtio</span>
<span class="quote">&gt; CPU: 11 PID: 1916 Comm: mmstress Not tainted 4.8.0 #76</span>
<span class="quote">&gt; task: c000000005394880 task.stack: c000000005570000</span>
<span class="quote">&gt; NIP: c00000000027bf6c LR: c00000000027bf64 CTR: 0000000000000000</span>
<span class="quote">&gt; REGS: c000000005573820 TRAP: 0300   Not tainted  (4.8.0)</span>
<span class="quote">&gt; MSR: 8000000000009033 &lt;SF,EE,ME,IR,DR,RI,LE&gt;  CR: 84822884  XER:</span>
<span class="quote">&gt; 20000000</span>
<span class="quote">&gt; CFAR: c00000000010a924 DAR: 420000000014e5e0 DSISR: 40000000 SOFTE: 1</span>
<span class="quote">&gt; GPR00: c00000000027bf64 c000000005573aa0 c000000000e02800</span>
<span class="quote">&gt; c000000004447964</span>
<span class="quote">&gt; GPR04: c00000000404de18 c000000004d38810 00000000042100f5</span>
<span class="quote">&gt; 00000000f5002104</span>
<span class="quote">&gt; GPR08: e0000000f5002104 0000000000000001 042100f5000000e0</span>
<span class="quote">&gt; 00000000042100f5</span>
<span class="quote">&gt; GPR12: 0000000000002200 c00000000fe02c00 c00000000404de18</span>
<span class="quote">&gt; 0000000000000000</span>
<span class="quote">&gt; GPR16: c1ffffffffffe7ff 00003fff62000000 420000000014e5e0</span>
<span class="quote">&gt; 00003fff63000000</span>
<span class="quote">&gt; GPR20: 0008000000000000 c0000000f7014800 0405e600000000e0</span>
<span class="quote">&gt; 0000000000010000</span>
<span class="quote">&gt; GPR24: c000000004d38810 c000000004447c10 c00000000404de18</span>
<span class="quote">&gt; c000000004447964</span>
<span class="quote">&gt; GPR28: c000000005573b10 c000000004d38810 00003fff62000000</span>
<span class="quote">&gt; 420000000014e5e0</span>
<span class="quote">&gt; NIP [c00000000027bf6c] zap_huge_pmd+0x4c/0x470</span>
<span class="quote">&gt; LR [c00000000027bf64] zap_huge_pmd+0x44/0x470</span>
<span class="quote">&gt; Call Trace:</span>
<span class="quote">&gt; [c000000005573aa0] [c00000000027bf64] zap_huge_pmd+0x44/0x470</span>
<span class="quote">&gt; (unreliable)</span>
<span class="quote">&gt; [c000000005573af0] [c00000000022bbd8] unmap_page_range+0xcf8/0xed0</span>
<span class="quote">&gt; [c000000005573c30] [c00000000022c2d4] unmap_vmas+0x84/0x120</span>
<span class="quote">&gt; [c000000005573c80] [c000000000235448] unmap_region+0xd8/0x1b0</span>
<span class="quote">&gt; [c000000005573d80] [c0000000002378f0] do_munmap+0x2d0/0x4c0</span>
<span class="quote">&gt; [c000000005573df0] [c000000000237be4] SyS_munmap+0x64/0xb0</span>
<span class="quote">&gt; [c000000005573e30] [c000000000009560] system_call+0x38/0x108</span>
<span class="quote">&gt; Instruction dump:</span>
<span class="quote">&gt; fbe1fff8 fb81ffe0 7c7f1b78 7ca32b78 7cbd2b78 f8010010 7c9a2378</span>
<span class="quote">&gt; f821ffb1</span>
<span class="quote">&gt; 7cde3378 4bfffea9 7c7b1b79 41820298 &lt;e87f0000&gt; 48000130 7fa5eb78</span>
<span class="quote">&gt; 7fc4f378</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Most of the time, the bug is surfacing in a caller up in the stack</span>
<span class="quote">&gt; from</span>
<span class="quote">&gt; __pSeries_lpar_hugepage_invalidate() which is quite confusing.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This bug is pending since v3.11 but was hidden if a caller of the</span>
<span class="quote">&gt; caller of __pSeries_lpar_hugepage_invalidate() has pushed the</span>
<span class="quote">&gt; corruped</span>
<span class="quote">&gt; register (r18 in this case) in the stack and is not using it until</span>
<span class="quote">&gt; restoring it. GCC 6.2.0 seems to raise it more frequently.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This commit also change the definition of the parameter buffer in</span>
<span class="quote">&gt; pSeries_lpar_flush_hash_range() to rely on the global define</span>
<span class="quote">&gt; PLPAR_HCALL9_BUFSIZE (no functional change here).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fixes: 1a5272866f87 (&quot;powerpc: Optimize hugepage invalidate&quot;)</span>
<span class="quote">&gt; Cc: &lt;stable@vger.kernel.org&gt;</span>
<span class="quote">&gt; Cc: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/powerpc/platforms/pseries/lpar.c | 4 ++--</span>
<span class="quote">&gt;  1 file changed, 2 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; index 86707e67843f..aa35245d8d6d 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; @@ -393,7 +393,7 @@ static void</span>
<span class="quote">&gt; __pSeries_lpar_hugepage_invalidate(unsigned long *slot,</span>
<span class="quote">&gt;  					     unsigned long *vpn, int</span>
<span class="quote">&gt; count,</span>
<span class="quote">&gt;  					     int psize, int ssize)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	unsigned long param[8];</span>
<span class="quote">&gt; +	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
<span class="quote">&gt;  	int i = 0, pix = 0, rc;</span>
<span class="quote">&gt;  	unsigned long flags = 0;</span>
<span class="quote">&gt;  	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);</span>
<span class="quote">&gt; @@ -522,7 +522,7 @@ static void</span>
<span class="quote">&gt; pSeries_lpar_flush_hash_range(unsigned long number, int local)</span>
<span class="quote">&gt;  	unsigned long flags = 0;</span>
<span class="quote">&gt;  	struct ppc64_tlb_batch *batch =</span>
<span class="quote">&gt; this_cpu_ptr(&amp;ppc64_tlb_batch);</span>
<span class="quote">&gt;  	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);</span>
<span class="quote">&gt; -	unsigned long param[9];</span>
<span class="quote">&gt; +	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
<span class="quote">&gt;  	unsigned long hash, index, shift, hidx, slot;</span>
<span class="quote">&gt;  	real_pte_t pte;</span>
<span class="quote">&gt;  	int psize, ssize;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=31482">Benjamin Herrenschmidt</a> - Oct. 6, 2016, 11:08 p.m.</div>
<pre class="content">
On Thu, 2016-10-06 at 20:32 +0530, Aneesh Kumar K.V wrote:
<span class="quote">&gt; Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt; writes:</span>
<span class="quote">&gt; </span>

(Off-list)

Did that bug make it to RHEL/CentOS/SLES ?

We also need to poke Ubuntu to get the fix ASAP.
<span class="quote">
&gt; &gt; This commit fixes a stack corruption in the pseries specific code</span>
<span class="quote">&gt; &gt; dealing</span>
<span class="quote">&gt; &gt; with the huge pages.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; In __pSeries_lpar_hugepage_invalidate() the buffer used to pass</span>
<span class="quote">&gt; &gt; arguments</span>
<span class="quote">&gt; &gt; to the hypervisor is not large enough. This leads to a stack</span>
<span class="quote">&gt; &gt; corruption</span>
<span class="quote">&gt; &gt; where a previously saved register could be corrupted leading to</span>
<span class="quote">&gt; &gt; unexpected</span>
<span class="quote">&gt; &gt; result in the caller, like the following panic:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Oops: Kernel access of bad area, sig: 11 [#1]</span>
<span class="quote">&gt; &gt; SMP NR_CPUS=2048 NUMA pSeries</span>
<span class="quote">&gt; &gt; Modules linked in: virtio_balloon ip_tables x_tables autofs4</span>
<span class="quote">&gt; &gt; virtio_blk 8139too virtio_pci virtio_ring 8139cp virtio</span>
<span class="quote">&gt; &gt; CPU: 11 PID: 1916 Comm: mmstress Not tainted 4.8.0 #76</span>
<span class="quote">&gt; &gt; task: c000000005394880 task.stack: c000000005570000</span>
<span class="quote">&gt; &gt; NIP: c00000000027bf6c LR: c00000000027bf64 CTR: 0000000000000000</span>
<span class="quote">&gt; &gt; REGS: c000000005573820 TRAP: 0300   Not tainted  (4.8.0)</span>
<span class="quote">&gt; &gt; MSR: 8000000000009033 &lt;SF,EE,ME,IR,DR,RI,LE&gt;  CR: 84822884  XER:</span>
<span class="quote">&gt; &gt; 20000000</span>
<span class="quote">&gt; &gt; CFAR: c00000000010a924 DAR: 420000000014e5e0 DSISR: 40000000 SOFTE:</span>
<span class="quote">&gt; &gt; 1</span>
<span class="quote">&gt; &gt; GPR00: c00000000027bf64 c000000005573aa0 c000000000e02800</span>
<span class="quote">&gt; &gt; c000000004447964</span>
<span class="quote">&gt; &gt; GPR04: c00000000404de18 c000000004d38810 00000000042100f5</span>
<span class="quote">&gt; &gt; 00000000f5002104</span>
<span class="quote">&gt; &gt; GPR08: e0000000f5002104 0000000000000001 042100f5000000e0</span>
<span class="quote">&gt; &gt; 00000000042100f5</span>
<span class="quote">&gt; &gt; GPR12: 0000000000002200 c00000000fe02c00 c00000000404de18</span>
<span class="quote">&gt; &gt; 0000000000000000</span>
<span class="quote">&gt; &gt; GPR16: c1ffffffffffe7ff 00003fff62000000 420000000014e5e0</span>
<span class="quote">&gt; &gt; 00003fff63000000</span>
<span class="quote">&gt; &gt; GPR20: 0008000000000000 c0000000f7014800 0405e600000000e0</span>
<span class="quote">&gt; &gt; 0000000000010000</span>
<span class="quote">&gt; &gt; GPR24: c000000004d38810 c000000004447c10 c00000000404de18</span>
<span class="quote">&gt; &gt; c000000004447964</span>
<span class="quote">&gt; &gt; GPR28: c000000005573b10 c000000004d38810 00003fff62000000</span>
<span class="quote">&gt; &gt; 420000000014e5e0</span>
<span class="quote">&gt; &gt; NIP [c00000000027bf6c] zap_huge_pmd+0x4c/0x470</span>
<span class="quote">&gt; &gt; LR [c00000000027bf64] zap_huge_pmd+0x44/0x470</span>
<span class="quote">&gt; &gt; Call Trace:</span>
<span class="quote">&gt; &gt; [c000000005573aa0] [c00000000027bf64] zap_huge_pmd+0x44/0x470</span>
<span class="quote">&gt; &gt; (unreliable)</span>
<span class="quote">&gt; &gt; [c000000005573af0] [c00000000022bbd8] unmap_page_range+0xcf8/0xed0</span>
<span class="quote">&gt; &gt; [c000000005573c30] [c00000000022c2d4] unmap_vmas+0x84/0x120</span>
<span class="quote">&gt; &gt; [c000000005573c80] [c000000000235448] unmap_region+0xd8/0x1b0</span>
<span class="quote">&gt; &gt; [c000000005573d80] [c0000000002378f0] do_munmap+0x2d0/0x4c0</span>
<span class="quote">&gt; &gt; [c000000005573df0] [c000000000237be4] SyS_munmap+0x64/0xb0</span>
<span class="quote">&gt; &gt; [c000000005573e30] [c000000000009560] system_call+0x38/0x108</span>
<span class="quote">&gt; &gt; Instruction dump:</span>
<span class="quote">&gt; &gt; fbe1fff8 fb81ffe0 7c7f1b78 7ca32b78 7cbd2b78 f8010010 7c9a2378</span>
<span class="quote">&gt; &gt; f821ffb1</span>
<span class="quote">&gt; &gt; 7cde3378 4bfffea9 7c7b1b79 41820298 &lt;e87f0000&gt; 48000130 7fa5eb78</span>
<span class="quote">&gt; &gt; 7fc4f378</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Most of the time, the bug is surfacing in a caller up in the stack</span>
<span class="quote">&gt; &gt; from</span>
<span class="quote">&gt; &gt; __pSeries_lpar_hugepage_invalidate() which is quite confusing.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This bug is pending since v3.11 but was hidden if a caller of the</span>
<span class="quote">&gt; &gt; caller of __pSeries_lpar_hugepage_invalidate() has pushed the</span>
<span class="quote">&gt; &gt; corruped</span>
<span class="quote">&gt; &gt; register (r18 in this case) in the stack and is not using it until</span>
<span class="quote">&gt; &gt; restoring it. GCC 6.2.0 seems to raise it more frequently.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This commit also change the definition of the parameter buffer in</span>
<span class="quote">&gt; &gt; pSeries_lpar_flush_hash_range() to rely on the global define</span>
<span class="quote">&gt; &gt; PLPAR_HCALL9_BUFSIZE (no functional change here).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Reviewed-by: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Fixes: 1a5272866f87 (&quot;powerpc: Optimize hugepage invalidate&quot;)</span>
<span class="quote">&gt; &gt; Cc: &lt;stable@vger.kernel.org&gt;</span>
<span class="quote">&gt; &gt; Cc: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  arch/powerpc/platforms/pseries/lpar.c | 4 ++--</span>
<span class="quote">&gt; &gt;  1 file changed, 2 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; &gt; b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; &gt; index 86707e67843f..aa35245d8d6d 100644</span>
<span class="quote">&gt; &gt; --- a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; &gt; +++ b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="quote">&gt; &gt; @@ -393,7 +393,7 @@ static void</span>
<span class="quote">&gt; &gt; __pSeries_lpar_hugepage_invalidate(unsigned long *slot,</span>
<span class="quote">&gt; &gt;  					     unsigned long *vpn,</span>
<span class="quote">&gt; &gt; int count,</span>
<span class="quote">&gt; &gt;  					     int psize, int ssize)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; -	unsigned long param[8];</span>
<span class="quote">&gt; &gt; +	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
<span class="quote">&gt; &gt;  	int i = 0, pix = 0, rc;</span>
<span class="quote">&gt; &gt;  	unsigned long flags = 0;</span>
<span class="quote">&gt; &gt;  	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);</span>
<span class="quote">&gt; &gt; @@ -522,7 +522,7 @@ static void</span>
<span class="quote">&gt; &gt; pSeries_lpar_flush_hash_range(unsigned long number, int local)</span>
<span class="quote">&gt; &gt;  	unsigned long flags = 0;</span>
<span class="quote">&gt; &gt;  	struct ppc64_tlb_batch *batch =</span>
<span class="quote">&gt; &gt; this_cpu_ptr(&amp;ppc64_tlb_batch);</span>
<span class="quote">&gt; &gt;  	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);</span>
<span class="quote">&gt; &gt; -	unsigned long param[9];</span>
<span class="quote">&gt; &gt; +	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
<span class="quote">&gt; &gt;  	unsigned long hash, index, shift, hidx, slot;</span>
<span class="quote">&gt; &gt;  	real_pte_t pte;</span>
<span class="quote">&gt; &gt;  	int psize, ssize;</span>
<span class="quote">&gt; &gt; -- </span>
<span class="quote">&gt; &gt; 2.7.4</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=4745">Balbir Singh</a> - Oct. 9, 2016, 10:05 p.m.</div>
<pre class="content">
On 07/10/16 02:02, Aneesh Kumar K.V wrote:
<span class="quote">&gt; Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt; writes:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; This commit fixes a stack corruption in the pseries specific code dealing</span>
<span class="quote">&gt;&gt; with the huge pages.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; In __pSeries_lpar_hugepage_invalidate() the buffer used to pass arguments</span>
<span class="quote">&gt;&gt; to the hypervisor is not large enough. This leads to a stack corruption</span>
<span class="quote">&gt;&gt; where a previously saved register could be corrupted leading to unexpected</span>
<span class="quote">&gt;&gt; result in the caller, like the following panic:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Oops: Kernel access of bad area, sig: 11 [#1]</span>
<span class="quote">&gt;&gt; SMP NR_CPUS=2048 NUMA pSeries</span>
<span class="quote">&gt;&gt; Modules linked in: virtio_balloon ip_tables x_tables autofs4</span>
<span class="quote">&gt;&gt; virtio_blk 8139too virtio_pci virtio_ring 8139cp virtio</span>
<span class="quote">&gt;&gt; CPU: 11 PID: 1916 Comm: mmstress Not tainted 4.8.0 #76</span>
<span class="quote">&gt;&gt; task: c000000005394880 task.stack: c000000005570000</span>
<span class="quote">&gt;&gt; NIP: c00000000027bf6c LR: c00000000027bf64 CTR: 0000000000000000</span>
<span class="quote">&gt;&gt; REGS: c000000005573820 TRAP: 0300   Not tainted  (4.8.0)</span>
<span class="quote">&gt;&gt; MSR: 8000000000009033 &lt;SF,EE,ME,IR,DR,RI,LE&gt;  CR: 84822884  XER:</span>
<span class="quote">&gt;&gt; 20000000</span>
<span class="quote">&gt;&gt; CFAR: c00000000010a924 DAR: 420000000014e5e0 DSISR: 40000000 SOFTE: 1</span>
<span class="quote">&gt;&gt; GPR00: c00000000027bf64 c000000005573aa0 c000000000e02800 c000000004447964</span>
<span class="quote">&gt;&gt; GPR04: c00000000404de18 c000000004d38810 00000000042100f5 00000000f5002104</span>
<span class="quote">&gt;&gt; GPR08: e0000000f5002104 0000000000000001 042100f5000000e0 00000000042100f5</span>
<span class="quote">&gt;&gt; GPR12: 0000000000002200 c00000000fe02c00 c00000000404de18 0000000000000000</span>
<span class="quote">&gt;&gt; GPR16: c1ffffffffffe7ff 00003fff62000000 420000000014e5e0 00003fff63000000</span>
<span class="quote">&gt;&gt; GPR20: 0008000000000000 c0000000f7014800 0405e600000000e0 0000000000010000</span>
<span class="quote">&gt;&gt; GPR24: c000000004d38810 c000000004447c10 c00000000404de18 c000000004447964</span>
<span class="quote">&gt;&gt; GPR28: c000000005573b10 c000000004d38810 00003fff62000000 420000000014e5e0</span>
<span class="quote">&gt;&gt; NIP [c00000000027bf6c] zap_huge_pmd+0x4c/0x470</span>
<span class="quote">&gt;&gt; LR [c00000000027bf64] zap_huge_pmd+0x44/0x470</span>
<span class="quote">&gt;&gt; Call Trace:</span>
<span class="quote">&gt;&gt; [c000000005573aa0] [c00000000027bf64] zap_huge_pmd+0x44/0x470 (unreliable)</span>
<span class="quote">&gt;&gt; [c000000005573af0] [c00000000022bbd8] unmap_page_range+0xcf8/0xed0</span>
<span class="quote">&gt;&gt; [c000000005573c30] [c00000000022c2d4] unmap_vmas+0x84/0x120</span>
<span class="quote">&gt;&gt; [c000000005573c80] [c000000000235448] unmap_region+0xd8/0x1b0</span>
<span class="quote">&gt;&gt; [c000000005573d80] [c0000000002378f0] do_munmap+0x2d0/0x4c0</span>
<span class="quote">&gt;&gt; [c000000005573df0] [c000000000237be4] SyS_munmap+0x64/0xb0</span>
<span class="quote">&gt;&gt; [c000000005573e30] [c000000000009560] system_call+0x38/0x108</span>
<span class="quote">&gt;&gt; Instruction dump:</span>
<span class="quote">&gt;&gt; fbe1fff8 fb81ffe0 7c7f1b78 7ca32b78 7cbd2b78 f8010010 7c9a2378 f821ffb1</span>
<span class="quote">&gt;&gt; 7cde3378 4bfffea9 7c7b1b79 41820298 &lt;e87f0000&gt; 48000130 7fa5eb78 7fc4f378</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Most of the time, the bug is surfacing in a caller up in the stack from</span>
<span class="quote">&gt;&gt; __pSeries_lpar_hugepage_invalidate() which is quite confusing.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This bug is pending since v3.11 but was hidden if a caller of the</span>
<span class="quote">&gt;&gt; caller of __pSeries_lpar_hugepage_invalidate() has pushed the corruped</span>
<span class="quote">&gt;&gt; register (r18 in this case) in the stack and is not using it until</span>
<span class="quote">&gt;&gt; restoring it. GCC 6.2.0 seems to raise it more frequently.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This commit also change the definition of the parameter buffer in</span>
<span class="quote">&gt;&gt; pSeries_lpar_flush_hash_range() to rely on the global define</span>
<span class="quote">&gt;&gt; PLPAR_HCALL9_BUFSIZE (no functional change here).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Reviewed-by: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; Fixes: 1a5272866f87 (&quot;powerpc: Optimize hugepage invalidate&quot;)</span>
<span class="quote">&gt;&gt; Cc: &lt;stable@vger.kernel.org&gt;</span>
<span class="quote">&gt;&gt; Cc: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="acked-by">
Acked-by: Balbir Singh &lt;bsingharora@gmail.com&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=89031">Laurent Dufour</a> - Oct. 10, 2016, 9:36 a.m.</div>
<pre class="content">
On 07/10/2016 01:08, Benjamin Herrenschmidt wrote:
<span class="quote">&gt; On Thu, 2016-10-06 at 20:32 +0530, Aneesh Kumar K.V wrote:</span>
<span class="quote">&gt;&gt; Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt; writes:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; (Off-list)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Did that bug make it to RHEL/CentOS/SLES ?</span>

Yes all of them are potentially impacted (I didn&#39;t check for centos).
<span class="quote">
&gt; We also need to poke Ubuntu to get the fix ASAP.</span>

The LTC bug 146511 has been mirrored to Ubuntu, this way they will be
aware of, but it should be mirrored for older Ubuntu release too.

This being said, it will be easier to poke them if the patch is accepted
upstream at least on the linuxpcc tree. Michael ?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=169345">Michael Ellerman</a> - Oct. 19, 2016, 2:17 a.m.</div>
<pre class="content">
On Thu, 2016-06-10 at 13:33:21 UTC, Laurent Dufour wrote:
<span class="quote">&gt; This commit fixes a stack corruption in the pseries specific code dealing</span>
<span class="quote">&gt; with the huge pages.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In __pSeries_lpar_hugepage_invalidate() the buffer used to pass arguments</span>
<span class="quote">&gt; to the hypervisor is not large enough. This leads to a stack corruption</span>
<span class="quote">&gt; where a previously saved register could be corrupted leading to unexpected</span>
<span class="quote">&gt; result in the caller, like the following panic:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Oops: Kernel access of bad area, sig: 11 [#1]</span>
<span class="quote">&gt; SMP NR_CPUS=2048 NUMA pSeries</span>
<span class="quote">&gt; Modules linked in: virtio_balloon ip_tables x_tables autofs4</span>
<span class="quote">&gt; virtio_blk 8139too virtio_pci virtio_ring 8139cp virtio</span>
<span class="quote">&gt; CPU: 11 PID: 1916 Comm: mmstress Not tainted 4.8.0 #76</span>
<span class="quote">&gt; task: c000000005394880 task.stack: c000000005570000</span>
<span class="quote">&gt; NIP: c00000000027bf6c LR: c00000000027bf64 CTR: 0000000000000000</span>
<span class="quote">&gt; REGS: c000000005573820 TRAP: 0300   Not tainted  (4.8.0)</span>
<span class="quote">&gt; MSR: 8000000000009033 &lt;SF,EE,ME,IR,DR,RI,LE&gt;  CR: 84822884  XER:</span>
<span class="quote">&gt; 20000000</span>
<span class="quote">&gt; CFAR: c00000000010a924 DAR: 420000000014e5e0 DSISR: 40000000 SOFTE: 1</span>
<span class="quote">&gt; GPR00: c00000000027bf64 c000000005573aa0 c000000000e02800 c000000004447964</span>
<span class="quote">&gt; GPR04: c00000000404de18 c000000004d38810 00000000042100f5 00000000f5002104</span>
<span class="quote">&gt; GPR08: e0000000f5002104 0000000000000001 042100f5000000e0 00000000042100f5</span>
<span class="quote">&gt; GPR12: 0000000000002200 c00000000fe02c00 c00000000404de18 0000000000000000</span>
<span class="quote">&gt; GPR16: c1ffffffffffe7ff 00003fff62000000 420000000014e5e0 00003fff63000000</span>
<span class="quote">&gt; GPR20: 0008000000000000 c0000000f7014800 0405e600000000e0 0000000000010000</span>
<span class="quote">&gt; GPR24: c000000004d38810 c000000004447c10 c00000000404de18 c000000004447964</span>
<span class="quote">&gt; GPR28: c000000005573b10 c000000004d38810 00003fff62000000 420000000014e5e0</span>
<span class="quote">&gt; NIP [c00000000027bf6c] zap_huge_pmd+0x4c/0x470</span>
<span class="quote">&gt; LR [c00000000027bf64] zap_huge_pmd+0x44/0x470</span>
<span class="quote">&gt; Call Trace:</span>
<span class="quote">&gt; [c000000005573aa0] [c00000000027bf64] zap_huge_pmd+0x44/0x470 (unreliable)</span>
<span class="quote">&gt; [c000000005573af0] [c00000000022bbd8] unmap_page_range+0xcf8/0xed0</span>
<span class="quote">&gt; [c000000005573c30] [c00000000022c2d4] unmap_vmas+0x84/0x120</span>
<span class="quote">&gt; [c000000005573c80] [c000000000235448] unmap_region+0xd8/0x1b0</span>
<span class="quote">&gt; [c000000005573d80] [c0000000002378f0] do_munmap+0x2d0/0x4c0</span>
<span class="quote">&gt; [c000000005573df0] [c000000000237be4] SyS_munmap+0x64/0xb0</span>
<span class="quote">&gt; [c000000005573e30] [c000000000009560] system_call+0x38/0x108</span>
<span class="quote">&gt; Instruction dump:</span>
<span class="quote">&gt; fbe1fff8 fb81ffe0 7c7f1b78 7ca32b78 7cbd2b78 f8010010 7c9a2378 f821ffb1</span>
<span class="quote">&gt; 7cde3378 4bfffea9 7c7b1b79 41820298 &lt;e87f0000&gt; 48000130 7fa5eb78 7fc4f378</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Most of the time, the bug is surfacing in a caller up in the stack from</span>
<span class="quote">&gt; __pSeries_lpar_hugepage_invalidate() which is quite confusing.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This bug is pending since v3.11 but was hidden if a caller of the</span>
<span class="quote">&gt; caller of __pSeries_lpar_hugepage_invalidate() has pushed the corruped</span>
<span class="quote">&gt; register (r18 in this case) in the stack and is not using it until</span>
<span class="quote">&gt; restoring it. GCC 6.2.0 seems to raise it more frequently.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This commit also change the definition of the parameter buffer in</span>
<span class="quote">&gt; pSeries_lpar_flush_hash_range() to rely on the global define</span>
<span class="quote">&gt; PLPAR_HCALL9_BUFSIZE (no functional change here).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fixes: 1a5272866f87 (&quot;powerpc: Optimize hugepage invalidate&quot;)</span>
<span class="quote">&gt; Cc: &lt;stable@vger.kernel.org&gt;</span>
<span class="quote">&gt; Cc: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Laurent Dufour &lt;ldufour@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Reviewed-by: Aneesh Kumar K.V &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Acked-by: Balbir Singh &lt;bsingharora@gmail.com&gt;</span>

Applied to powerpc next, thanks.

https://git.kernel.org/powerpc/c/05af40e885955065aee8bb7425058e

cheers
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/lpar.c b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">index 86707e67843f..aa35245d8d6d 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_chunk">@@ -393,7 +393,7 @@</span> <span class="p_context"> static void __pSeries_lpar_hugepage_invalidate(unsigned long *slot,</span>
 					     unsigned long *vpn, int count,
 					     int psize, int ssize)
 {
<span class="p_del">-	unsigned long param[8];</span>
<span class="p_add">+	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
 	int i = 0, pix = 0, rc;
 	unsigned long flags = 0;
 	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
<span class="p_chunk">@@ -522,7 +522,7 @@</span> <span class="p_context"> static void pSeries_lpar_flush_hash_range(unsigned long number, int local)</span>
 	unsigned long flags = 0;
 	struct ppc64_tlb_batch *batch = this_cpu_ptr(&amp;ppc64_tlb_batch);
 	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
<span class="p_del">-	unsigned long param[9];</span>
<span class="p_add">+	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
 	unsigned long hash, index, shift, hidx, slot;
 	real_pte_t pte;
 	int psize, ssize;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



