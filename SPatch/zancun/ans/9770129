
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[16/17] RISC-V: Add kernel subdirectory - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [16/17] RISC-V: Add kernel subdirectory</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 6, 2017, 11 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170606230007.19101-17-palmer@dabbelt.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9770129/mbox/"
   >mbox</a>
|
   <a href="/patch/9770129/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9770129/">/patch/9770129/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	B53846034B for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  6 Jun 2017 23:02:41 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8F557284E4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  6 Jun 2017 23:02:41 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 81E0F284F1; Tue,  6 Jun 2017 23:02:41 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id AAC23284E4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  6 Jun 2017 23:02:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751783AbdFFXC1 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 6 Jun 2017 19:02:27 -0400
Received: from mail-pf0-f194.google.com ([209.85.192.194]:35801 &quot;EHLO
	mail-pf0-f194.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751656AbdFFXBn (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 6 Jun 2017 19:01:43 -0400
Received: by mail-pf0-f194.google.com with SMTP id u26so25592736pfd.2
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Tue, 06 Jun 2017 16:01:43 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=dabbelt-com.20150623.gappssmtp.com; s=20150623;
	h=from:to:to:to:to:cc:cc:cc:subject:date:message-id:in-reply-to
	:references; bh=RjSMkkVYx2Ek9Pa0tCBRSuQEORh4CcucH1gmcd96CjI=;
	b=ZQWyoFxjtyEZhm08F9LE0SN96rUK/faC6yS0qke0o4+dK06WRx5HtjblKhv4kBbrGJ
	/HihEGO5jiowCbVAUJX1mZEvtFCY6ng1LEGWLii84utk1nc4LvvyamU/5MHCAHPTHrom
	tTCRthUcQWm2Ngd++jdHhobv72xq4bTlm4VQx1/3Pcj2Nv82f4nHTuC00HmYWe7tlZlG
	Rd4OFUL+GF1+4gARisaHk93H6GaG1YxUUEu5BAC0IIS7TNuPj3cZbTynshHTK1fnO089
	ePAHwbu1XdnlZzrgq76arpoQpI1BPOgGt0usKHAZ+/IvwRuBe/DaSX4htArmim4xrf/t
	CnZA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:to:to:to:cc:cc:cc:subject:date
	:message-id:in-reply-to:references;
	bh=RjSMkkVYx2Ek9Pa0tCBRSuQEORh4CcucH1gmcd96CjI=;
	b=RoA5UmKSj28UM9pJfDG6/l7L5LIeVW+7/ddAZ0s/phXbTFbjtMJu5fC6NuxD3pqevQ
	Ku58jYJgMjYV29RUxxOlUARKCy+3MbJ/nFu5rRDqYT+m0qvPqwdmitCqp4sZwtNXU602
	DDjNFIzjVJbdYPwA7S1JPQEgUZZXpY8ZlB633GCgNPBoxqKSGF3zNcWkbswyrqoewEc8
	fkE0L6v4Q2MWRrdO1d0CnFcl7gjOuJk+XLQQ543eYkoB4Q0CGl9WHLMxjuyNEuYTn1ze
	lnrHR5KbPN5l7+n9pPDLQFuSBjvIX2AveeP644BmKMBfEibXgJ2bv+7Onj4zsqPwtzSU
	/LaA==
X-Gm-Message-State: AODbwcCBmtNro5U7fM/gMUWf6m9eITgIDanggGMDW9oeIM9d+rLuN66l
	eGU6/NwzBxaYlQpV
X-Received: by 10.99.119.132 with SMTP id s126mr17621563pgc.52.1496790100723;
	Tue, 06 Jun 2017 16:01:40 -0700 (PDT)
Received: from localhost ([216.38.154.21]) by smtp.gmail.com with ESMTPSA id
	62sm6804318pfr.90.2017.06.06.16.01.39
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Tue, 06 Jun 2017 16:01:39 -0700 (PDT)
From: Palmer Dabbelt &lt;palmer@dabbelt.com&gt;
To: linux-arch@vger.kernel.org
To: linux-kernel@vger.kernel.org
To: Arnd Bergmann &lt;arnd@arndb.de&gt;
To: olof@lixom.net
Cc: albert@sifive.com
Cc: patches@groups.riscv.org
Cc: Palmer Dabbelt &lt;palmer@dabbelt.com&gt;
Subject: [PATCH 16/17] RISC-V: Add kernel subdirectory
Date: Tue,  6 Jun 2017 16:00:06 -0700
Message-Id: &lt;20170606230007.19101-17-palmer@dabbelt.com&gt;
X-Mailer: git-send-email 2.13.0
In-Reply-To: &lt;20170606230007.19101-1-palmer@dabbelt.com&gt;
References: &lt;20170523004107.536-1-palmer@dabbelt.com&gt;
	&lt;20170606230007.19101-1-palmer@dabbelt.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - June 6, 2017, 11 p.m.</div>
<pre class="content">
These files were mostly based on the score port, but many of them are
very ISA specific.
<span class="signed-off-by">
Signed-off-by: Palmer Dabbelt &lt;palmer@dabbelt.com&gt;</span>
---
 arch/riscv/kernel/.gitignore       |   1 +
 arch/riscv/kernel/Makefile         |  16 ++
 arch/riscv/kernel/asm-offsets.c    | 316 +++++++++++++++++++++++++++
 arch/riscv/kernel/cacheinfo.c      | 103 +++++++++
 arch/riscv/kernel/cpu.c            |  89 ++++++++
 arch/riscv/kernel/entry.S          | 437 +++++++++++++++++++++++++++++++++++++
 arch/riscv/kernel/head.S           | 147 +++++++++++++
 arch/riscv/kernel/irq.c            |  20 ++
 arch/riscv/kernel/module.c         | 215 ++++++++++++++++++
 arch/riscv/kernel/process.c        | 132 +++++++++++
 arch/riscv/kernel/ptrace.c         | 147 +++++++++++++
 arch/riscv/kernel/reset.c          |  36 +++
 arch/riscv/kernel/riscv_ksyms.c    |  16 ++
 arch/riscv/kernel/setup.c          | 240 ++++++++++++++++++++
 arch/riscv/kernel/signal.c         | 257 ++++++++++++++++++++++
 arch/riscv/kernel/smp.c            | 110 ++++++++++
 arch/riscv/kernel/smpboot.c        | 103 +++++++++
 arch/riscv/kernel/stacktrace.c     | 177 +++++++++++++++
 arch/riscv/kernel/sys_riscv.c      |  85 ++++++++
 arch/riscv/kernel/syscall_table.c  |  25 +++
 arch/riscv/kernel/traps.c          | 183 ++++++++++++++++
 arch/riscv/kernel/vdso.c           | 125 +++++++++++
 arch/riscv/kernel/vdso/.gitignore  |   1 +
 arch/riscv/kernel/vdso/Makefile    |  61 ++++++
 arch/riscv/kernel/vdso/sigreturn.S |  24 ++
 arch/riscv/kernel/vdso/vdso.S      |  27 +++
 arch/riscv/kernel/vdso/vdso.lds.S  |  76 +++++++
 arch/riscv/kernel/vmlinux.lds.S    |  92 ++++++++
 28 files changed, 3261 insertions(+)
 create mode 100644 arch/riscv/kernel/.gitignore
 create mode 100644 arch/riscv/kernel/Makefile
 create mode 100644 arch/riscv/kernel/asm-offsets.c
 create mode 100644 arch/riscv/kernel/cacheinfo.c
 create mode 100644 arch/riscv/kernel/cpu.c
 create mode 100644 arch/riscv/kernel/entry.S
 create mode 100644 arch/riscv/kernel/head.S
 create mode 100644 arch/riscv/kernel/irq.c
 create mode 100644 arch/riscv/kernel/module.c
 create mode 100644 arch/riscv/kernel/process.c
 create mode 100644 arch/riscv/kernel/ptrace.c
 create mode 100644 arch/riscv/kernel/reset.c
 create mode 100644 arch/riscv/kernel/riscv_ksyms.c
 create mode 100644 arch/riscv/kernel/setup.c
 create mode 100644 arch/riscv/kernel/signal.c
 create mode 100644 arch/riscv/kernel/smp.c
 create mode 100644 arch/riscv/kernel/smpboot.c
 create mode 100644 arch/riscv/kernel/stacktrace.c
 create mode 100644 arch/riscv/kernel/sys_riscv.c
 create mode 100644 arch/riscv/kernel/syscall_table.c
 create mode 100644 arch/riscv/kernel/traps.c
 create mode 100644 arch/riscv/kernel/vdso.c
 create mode 100644 arch/riscv/kernel/vdso/.gitignore
 create mode 100644 arch/riscv/kernel/vdso/Makefile
 create mode 100644 arch/riscv/kernel/vdso/sigreturn.S
 create mode 100644 arch/riscv/kernel/vdso/vdso.S
 create mode 100644 arch/riscv/kernel/vdso/vdso.lds.S
 create mode 100644 arch/riscv/kernel/vmlinux.lds.S
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/riscv/kernel/.gitignore b/arch/riscv/kernel/.gitignore</span>
new file mode 100644
<span class="p_header">index 000000000000..b51634f6a7cd</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/.gitignore</span>
<span class="p_chunk">@@ -0,0 +1 @@</span> <span class="p_context"></span>
<span class="p_add">+/vmlinux.lds</span>
<span class="p_header">diff --git a/arch/riscv/kernel/Makefile b/arch/riscv/kernel/Makefile</span>
new file mode 100644
<span class="p_header">index 000000000000..b6de129d4a23</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/Makefile</span>
<span class="p_chunk">@@ -0,0 +1,16 @@</span> <span class="p_context"></span>
<span class="p_add">+#</span>
<span class="p_add">+# Makefile for the RISC-V Linux kernel</span>
<span class="p_add">+#</span>
<span class="p_add">+</span>
<span class="p_add">+extra-y := head.o vmlinux.lds</span>
<span class="p_add">+</span>
<span class="p_add">+obj-y	:= cpu.o entry.o irq.o process.o ptrace.o reset.o setup.o \</span>
<span class="p_add">+	   signal.o syscall_table.o sys_riscv.o traps.o \</span>
<span class="p_add">+	   riscv_ksyms.o stacktrace.o vdso.o cacheinfo.o vdso/</span>
<span class="p_add">+</span>
<span class="p_add">+CFLAGS_setup.o := -mcmodel=medany</span>
<span class="p_add">+</span>
<span class="p_add">+obj-$(CONFIG_SMP)		+= smpboot.o smp.o</span>
<span class="p_add">+obj-$(CONFIG_MODULES)		+= module.o</span>
<span class="p_add">+</span>
<span class="p_add">+clean:</span>
<span class="p_header">diff --git a/arch/riscv/kernel/asm-offsets.c b/arch/riscv/kernel/asm-offsets.c</span>
new file mode 100644
<span class="p_header">index 000000000000..2ead5037528c</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -0,0 +1,316 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kbuild.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void asm_offsets(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	OFFSET(TASK_THREAD_RA, task_struct, thread.ra);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_SP, task_struct, thread.sp);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S0, task_struct, thread.s[0]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S1, task_struct, thread.s[1]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S2, task_struct, thread.s[2]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S3, task_struct, thread.s[3]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S4, task_struct, thread.s[4]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S5, task_struct, thread.s[5]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S6, task_struct, thread.s[6]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S7, task_struct, thread.s[7]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S8, task_struct, thread.s[8]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S9, task_struct, thread.s[9]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S10, task_struct, thread.s[10]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_S11, task_struct, thread.s[11]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_SP, task_struct, thread.sp);</span>
<span class="p_add">+	OFFSET(TASK_STACK, task_struct, stack);</span>
<span class="p_add">+	OFFSET(TASK_TI, task_struct, thread_info);</span>
<span class="p_add">+	OFFSET(TASK_TI_FLAGS, task_struct, thread_info.flags);</span>
<span class="p_add">+	OFFSET(TASK_TI_KERNEL_SP, task_struct, thread_info.kernel_sp);</span>
<span class="p_add">+	OFFSET(TASK_TI_USER_SP, task_struct, thread_info.user_sp);</span>
<span class="p_add">+</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F0,  task_struct, thread.fstate.f[0]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F1,  task_struct, thread.fstate.f[1]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F2,  task_struct, thread.fstate.f[2]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F3,  task_struct, thread.fstate.f[3]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F4,  task_struct, thread.fstate.f[4]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F5,  task_struct, thread.fstate.f[5]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F6,  task_struct, thread.fstate.f[6]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F7,  task_struct, thread.fstate.f[7]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F8,  task_struct, thread.fstate.f[8]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F9,  task_struct, thread.fstate.f[9]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F10, task_struct, thread.fstate.f[10]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F11, task_struct, thread.fstate.f[11]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F12, task_struct, thread.fstate.f[12]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F13, task_struct, thread.fstate.f[13]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F14, task_struct, thread.fstate.f[14]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F15, task_struct, thread.fstate.f[15]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F16, task_struct, thread.fstate.f[16]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F17, task_struct, thread.fstate.f[17]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F18, task_struct, thread.fstate.f[18]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F19, task_struct, thread.fstate.f[19]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F20, task_struct, thread.fstate.f[20]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F21, task_struct, thread.fstate.f[21]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F22, task_struct, thread.fstate.f[22]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F23, task_struct, thread.fstate.f[23]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F24, task_struct, thread.fstate.f[24]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F25, task_struct, thread.fstate.f[25]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F26, task_struct, thread.fstate.f[26]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F27, task_struct, thread.fstate.f[27]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F28, task_struct, thread.fstate.f[28]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F29, task_struct, thread.fstate.f[29]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F30, task_struct, thread.fstate.f[30]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_F31, task_struct, thread.fstate.f[31]);</span>
<span class="p_add">+	OFFSET(TASK_THREAD_FCSR, task_struct, thread.fstate.fcsr);</span>
<span class="p_add">+</span>
<span class="p_add">+	DEFINE(PT_SIZE, sizeof(struct pt_regs));</span>
<span class="p_add">+	OFFSET(PT_SEPC, pt_regs, sepc);</span>
<span class="p_add">+	OFFSET(PT_RA, pt_regs, ra);</span>
<span class="p_add">+	OFFSET(PT_FP, pt_regs, s0);</span>
<span class="p_add">+	OFFSET(PT_S0, pt_regs, s0);</span>
<span class="p_add">+	OFFSET(PT_S1, pt_regs, s1);</span>
<span class="p_add">+	OFFSET(PT_S2, pt_regs, s2);</span>
<span class="p_add">+	OFFSET(PT_S3, pt_regs, s3);</span>
<span class="p_add">+	OFFSET(PT_S4, pt_regs, s4);</span>
<span class="p_add">+	OFFSET(PT_S5, pt_regs, s5);</span>
<span class="p_add">+	OFFSET(PT_S6, pt_regs, s6);</span>
<span class="p_add">+	OFFSET(PT_S7, pt_regs, s7);</span>
<span class="p_add">+	OFFSET(PT_S8, pt_regs, s8);</span>
<span class="p_add">+	OFFSET(PT_S9, pt_regs, s9);</span>
<span class="p_add">+	OFFSET(PT_S10, pt_regs, s10);</span>
<span class="p_add">+	OFFSET(PT_S11, pt_regs, s11);</span>
<span class="p_add">+	OFFSET(PT_SP, pt_regs, sp);</span>
<span class="p_add">+	OFFSET(PT_TP, pt_regs, tp);</span>
<span class="p_add">+	OFFSET(PT_A0, pt_regs, a0);</span>
<span class="p_add">+	OFFSET(PT_A1, pt_regs, a1);</span>
<span class="p_add">+	OFFSET(PT_A2, pt_regs, a2);</span>
<span class="p_add">+	OFFSET(PT_A3, pt_regs, a3);</span>
<span class="p_add">+	OFFSET(PT_A4, pt_regs, a4);</span>
<span class="p_add">+	OFFSET(PT_A5, pt_regs, a5);</span>
<span class="p_add">+	OFFSET(PT_A6, pt_regs, a6);</span>
<span class="p_add">+	OFFSET(PT_A7, pt_regs, a7);</span>
<span class="p_add">+	OFFSET(PT_T0, pt_regs, t0);</span>
<span class="p_add">+	OFFSET(PT_T1, pt_regs, t1);</span>
<span class="p_add">+	OFFSET(PT_T2, pt_regs, t2);</span>
<span class="p_add">+	OFFSET(PT_T3, pt_regs, t3);</span>
<span class="p_add">+	OFFSET(PT_T4, pt_regs, t4);</span>
<span class="p_add">+	OFFSET(PT_T5, pt_regs, t5);</span>
<span class="p_add">+	OFFSET(PT_T6, pt_regs, t6);</span>
<span class="p_add">+	OFFSET(PT_GP, pt_regs, gp);</span>
<span class="p_add">+	OFFSET(PT_SSTATUS, pt_regs, sstatus);</span>
<span class="p_add">+	OFFSET(PT_SBADADDR, pt_regs, sbadaddr);</span>
<span class="p_add">+	OFFSET(PT_SCAUSE, pt_regs, scause);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* THREAD_{F,X}* might be larger than a S-type offset can handle, but</span>
<span class="p_add">+	 * these are used in performance-sensitive assembly so we can&#39;t resort</span>
<span class="p_add">+	 * to loading the long immediate every time.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	DEFINE(TASK_THREAD_RA_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_SP_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.sp)</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S0_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[0])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S1_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[1])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S2_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[2])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S3_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[3])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S4_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[4])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S5_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[5])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S6_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[6])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S7_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[7])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S8_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[8])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S9_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[9])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S10_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[10])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_S11_RA,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.s[11])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.ra)</span>
<span class="p_add">+	);</span>
<span class="p_add">+</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F0_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F1_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[1])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F2_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[2])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F3_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[3])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F4_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[4])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F5_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[5])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F6_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[6])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F7_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[7])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F8_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[8])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F9_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[9])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F10_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[10])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F11_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[11])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F12_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[12])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F13_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[13])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F14_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[14])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F15_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[15])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F16_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[16])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F17_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[17])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F18_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[18])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F19_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[19])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F20_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[20])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F21_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[21])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F22_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[22])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F23_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[23])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F24_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[24])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F25_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[25])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F26_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[26])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F27_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[27])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F28_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[28])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F29_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[29])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F30_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[30])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_F31_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.f[31])</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+	DEFINE(TASK_THREAD_FCSR_F0,</span>
<span class="p_add">+		  offsetof(struct task_struct, thread.fstate.fcsr)</span>
<span class="p_add">+		- offsetof(struct task_struct, thread.fstate.f[0])</span>
<span class="p_add">+	);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The assembler needs access to THREAD_SIZE as well. */</span>
<span class="p_add">+	DEFINE(ASM_THREAD_SIZE, THREAD_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We allocate a pt_regs on the stack when entering the kernel.  This</span>
<span class="p_add">+	 * ensures the alignment is sane.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	DEFINE(PT_SIZE_ON_STACK, ALIGN(sizeof(struct pt_regs), STACK_ALIGN));</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/cacheinfo.c b/arch/riscv/kernel/cacheinfo.c</span>
new file mode 100644
<span class="p_header">index 000000000000..76ed95850a22</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -0,0 +1,103 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cacheinfo.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_device.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void ci_leaf_init(struct cacheinfo *this_leaf,</span>
<span class="p_add">+			 struct device_node *node,</span>
<span class="p_add">+			 enum cache_type type, unsigned int level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	this_leaf-&gt;of_node = node;</span>
<span class="p_add">+	this_leaf-&gt;level = level;</span>
<span class="p_add">+	this_leaf-&gt;type = type;</span>
<span class="p_add">+	this_leaf-&gt;physical_line_partition = 1; // not a sector cache</span>
<span class="p_add">+	this_leaf-&gt;attributes =</span>
<span class="p_add">+		CACHE_WRITE_BACK</span>
<span class="p_add">+		| CACHE_READ_ALLOCATE</span>
<span class="p_add">+		| CACHE_WRITE_ALLOCATE; // TODO: add to DTS</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init_cache_level(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="p_add">+	struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="p_add">+	int levels = 0, leaves = 0, level;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+		++leaves;</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+		++leaves;</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+		++leaves;</span>
<span class="p_add">+	if (leaves &gt; 0)</span>
<span class="p_add">+		levels = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((np = of_find_next_cache_node(np))) {</span>
<span class="p_add">+		if (!of_device_is_compatible(np, &quot;cache&quot;))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (level &lt;= levels)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+			++leaves;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+			++leaves;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+			++leaves;</span>
<span class="p_add">+		levels = level;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	this_cpu_ci-&gt;num_levels = levels;</span>
<span class="p_add">+	this_cpu_ci-&gt;num_leaves = leaves;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __populate_cache_leaves(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="p_add">+	struct cacheinfo *this_leaf = this_cpu_ci-&gt;info_list;</span>
<span class="p_add">+	struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="p_add">+	int levels = 1, level = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+		ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+		ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+		ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((np = of_find_next_cache_node(np))) {</span>
<span class="p_add">+		if (!of_device_is_compatible(np, &quot;cache&quot;))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (level &lt;= levels)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+			ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+			ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+			ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="p_add">+		levels = level;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DEFINE_SMP_CALL_CACHE_FUNCTION(init_cache_level)</span>
<span class="p_add">+DEFINE_SMP_CALL_CACHE_FUNCTION(populate_cache_leaves)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/cpu.c b/arch/riscv/kernel/cpu.c</span>
new file mode 100644
<span class="p_header">index 000000000000..20004bd7a216</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/cpu.c</span>
<span class="p_chunk">@@ -0,0 +1,89 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Return -1 if not a valid hart */</span>
<span class="p_add">+int riscv_of_processor_hart(struct device_node *node)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const char *isa, *status;</span>
<span class="p_add">+	u32 hart;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!of_device_is_compatible(node, &quot;riscv&quot;))</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	if (of_property_read_u32(node, &quot;reg&quot;, &amp;hart)</span>
<span class="p_add">+	    || hart &gt;= NR_CPUS)</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	if (of_property_read_string(node, &quot;status&quot;, &amp;status)</span>
<span class="p_add">+	    || strcmp(status, &quot;okay&quot;))</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	if (of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa)</span>
<span class="p_add">+	    || isa[0] != &#39;r&#39;</span>
<span class="p_add">+	    || isa[1] != &#39;v&#39;)</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+</span>
<span class="p_add">+	return hart;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PROC_FS</span>
<span class="p_add">+</span>
<span class="p_add">+static void *c_start(struct seq_file *m, loff_t *pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*pos = cpumask_next(*pos - 1, cpu_online_mask);</span>
<span class="p_add">+	if ((*pos) &lt; nr_cpu_ids)</span>
<span class="p_add">+		return (void *)(uintptr_t)(1 + *pos);</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void *c_next(struct seq_file *m, void *v, loff_t *pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	(*pos)++;</span>
<span class="p_add">+	return c_start(m, pos);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void c_stop(struct seq_file *m, void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int c_show(struct seq_file *m, void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long hart_id = (unsigned long)v - 1;</span>
<span class="p_add">+	struct device_node *node = of_get_cpu_node(hart_id, NULL);</span>
<span class="p_add">+	const char *compat, *isa, *mmu;</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_printf(m, &quot;hart\t: %lu\n&quot;, hart_id);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa)</span>
<span class="p_add">+	    &amp;&amp; isa[0] == &#39;r&#39;</span>
<span class="p_add">+	    &amp;&amp; isa[1] == &#39;v&#39;)</span>
<span class="p_add">+		seq_printf(m, &quot;isa\t: %s\n&quot;, isa);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;mmu-type&quot;, &amp;mmu)</span>
<span class="p_add">+	    &amp;&amp; !strncmp(mmu, &quot;riscv,&quot;, 6))</span>
<span class="p_add">+		seq_printf(m, &quot;mmu\t: %s\n&quot;, mmu+6);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;compatible&quot;, &amp;compat)</span>
<span class="p_add">+	    &amp;&amp; strcmp(compat, &quot;riscv&quot;))</span>
<span class="p_add">+		seq_printf(m, &quot;uarch\t: %s\n&quot;, compat);</span>
<span class="p_add">+	seq_puts(m, &quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct seq_operations cpuinfo_op = {</span>
<span class="p_add">+	.start	= c_start,</span>
<span class="p_add">+	.next	= c_next,</span>
<span class="p_add">+	.stop	= c_stop,</span>
<span class="p_add">+	.show	= c_show</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_PROC_FS */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/entry.S b/arch/riscv/kernel/entry.S</span>
new file mode 100644
<span class="p_header">index 000000000000..0be9ca33e8fc</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/entry.S</span>
<span class="p_chunk">@@ -0,0 +1,437 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+	.altmacro</span>
<span class="p_add">+</span>
<span class="p_add">+/* Prepares to enter a system call or exception by saving all registers to the</span>
<span class="p_add">+ * stack.</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.macro SAVE_ALL</span>
<span class="p_add">+	LOCAL _restore_kernel_tpsp</span>
<span class="p_add">+	LOCAL _save_context</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If coming from userspace, preserve the user thread pointer and load</span>
<span class="p_add">+	   the kernel thread pointer.  If we came from the kernel, sscratch</span>
<span class="p_add">+	   will contain 0, and we should continue on the current TP. */</span>
<span class="p_add">+	csrrw tp, sscratch, tp</span>
<span class="p_add">+	bnez tp, _save_context</span>
<span class="p_add">+</span>
<span class="p_add">+_restore_kernel_tpsp:</span>
<span class="p_add">+	csrr tp, sscratch</span>
<span class="p_add">+	REG_S sp, TASK_TI_KERNEL_SP(tp)</span>
<span class="p_add">+_save_context:</span>
<span class="p_add">+	REG_S sp, TASK_TI_USER_SP(tp)</span>
<span class="p_add">+	REG_L sp, TASK_TI_KERNEL_SP(tp)</span>
<span class="p_add">+	addi sp, sp, -(PT_SIZE_ON_STACK)</span>
<span class="p_add">+	REG_S x1,  PT_RA(sp)</span>
<span class="p_add">+	REG_S x3,  PT_GP(sp)</span>
<span class="p_add">+	REG_S x5,  PT_T0(sp)</span>
<span class="p_add">+	REG_S x6,  PT_T1(sp)</span>
<span class="p_add">+	REG_S x7,  PT_T2(sp)</span>
<span class="p_add">+	REG_S x8,  PT_S0(sp)</span>
<span class="p_add">+	REG_S x9,  PT_S1(sp)</span>
<span class="p_add">+	REG_S x10, PT_A0(sp)</span>
<span class="p_add">+	REG_S x11, PT_A1(sp)</span>
<span class="p_add">+	REG_S x12, PT_A2(sp)</span>
<span class="p_add">+	REG_S x13, PT_A3(sp)</span>
<span class="p_add">+	REG_S x14, PT_A4(sp)</span>
<span class="p_add">+	REG_S x15, PT_A5(sp)</span>
<span class="p_add">+	REG_S x16, PT_A6(sp)</span>
<span class="p_add">+	REG_S x17, PT_A7(sp)</span>
<span class="p_add">+	REG_S x18, PT_S2(sp)</span>
<span class="p_add">+	REG_S x19, PT_S3(sp)</span>
<span class="p_add">+	REG_S x20, PT_S4(sp)</span>
<span class="p_add">+	REG_S x21, PT_S5(sp)</span>
<span class="p_add">+	REG_S x22, PT_S6(sp)</span>
<span class="p_add">+	REG_S x23, PT_S7(sp)</span>
<span class="p_add">+	REG_S x24, PT_S8(sp)</span>
<span class="p_add">+	REG_S x25, PT_S9(sp)</span>
<span class="p_add">+	REG_S x26, PT_S10(sp)</span>
<span class="p_add">+	REG_S x27, PT_S11(sp)</span>
<span class="p_add">+	REG_S x28, PT_T3(sp)</span>
<span class="p_add">+	REG_S x29, PT_T4(sp)</span>
<span class="p_add">+	REG_S x30, PT_T5(sp)</span>
<span class="p_add">+	REG_S x31, PT_T6(sp)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable FPU to detect illegal usage of</span>
<span class="p_add">+	   floating point in kernel space */</span>
<span class="p_add">+	li t0, SR_FS</span>
<span class="p_add">+</span>
<span class="p_add">+	REG_L s0, TASK_TI_USER_SP(tp)</span>
<span class="p_add">+	csrrc s1, sstatus, t0</span>
<span class="p_add">+	csrr s2, sepc</span>
<span class="p_add">+	csrr s3, sbadaddr</span>
<span class="p_add">+	csrr s4, scause</span>
<span class="p_add">+	csrr s5, sscratch</span>
<span class="p_add">+	REG_S s0, PT_SP(sp)</span>
<span class="p_add">+	REG_S s1, PT_SSTATUS(sp)</span>
<span class="p_add">+	REG_S s2, PT_SEPC(sp)</span>
<span class="p_add">+	REG_S s3, PT_SBADADDR(sp)</span>
<span class="p_add">+	REG_S s4, PT_SCAUSE(sp)</span>
<span class="p_add">+	REG_S s5, PT_TP(sp)</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+/* Prepares to return from a system call or exception by restoring all</span>
<span class="p_add">+ * registers from the stack.</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.macro RESTORE_ALL</span>
<span class="p_add">+	REG_L a0, PT_SSTATUS(sp)</span>
<span class="p_add">+	REG_L a2, PT_SEPC(sp)</span>
<span class="p_add">+	csrw sstatus, a0</span>
<span class="p_add">+	csrw sepc, a2</span>
<span class="p_add">+</span>
<span class="p_add">+	REG_L x1,  PT_RA(sp)</span>
<span class="p_add">+	REG_L x3,  PT_GP(sp)</span>
<span class="p_add">+	REG_L x4,  PT_TP(sp)</span>
<span class="p_add">+	REG_L x5,  PT_T0(sp)</span>
<span class="p_add">+	REG_L x6,  PT_T1(sp)</span>
<span class="p_add">+	REG_L x7,  PT_T2(sp)</span>
<span class="p_add">+	REG_L x8,  PT_S0(sp)</span>
<span class="p_add">+	REG_L x9,  PT_S1(sp)</span>
<span class="p_add">+	REG_L x10, PT_A0(sp)</span>
<span class="p_add">+	REG_L x11, PT_A1(sp)</span>
<span class="p_add">+	REG_L x12, PT_A2(sp)</span>
<span class="p_add">+	REG_L x13, PT_A3(sp)</span>
<span class="p_add">+	REG_L x14, PT_A4(sp)</span>
<span class="p_add">+	REG_L x15, PT_A5(sp)</span>
<span class="p_add">+	REG_L x16, PT_A6(sp)</span>
<span class="p_add">+	REG_L x17, PT_A7(sp)</span>
<span class="p_add">+	REG_L x18, PT_S2(sp)</span>
<span class="p_add">+	REG_L x19, PT_S3(sp)</span>
<span class="p_add">+	REG_L x20, PT_S4(sp)</span>
<span class="p_add">+	REG_L x21, PT_S5(sp)</span>
<span class="p_add">+	REG_L x22, PT_S6(sp)</span>
<span class="p_add">+	REG_L x23, PT_S7(sp)</span>
<span class="p_add">+	REG_L x24, PT_S8(sp)</span>
<span class="p_add">+	REG_L x25, PT_S9(sp)</span>
<span class="p_add">+	REG_L x26, PT_S10(sp)</span>
<span class="p_add">+	REG_L x27, PT_S11(sp)</span>
<span class="p_add">+	REG_L x28, PT_T3(sp)</span>
<span class="p_add">+	REG_L x29, PT_T4(sp)</span>
<span class="p_add">+	REG_L x30, PT_T5(sp)</span>
<span class="p_add">+	REG_L x31, PT_T6(sp)</span>
<span class="p_add">+</span>
<span class="p_add">+	REG_L x2,  PT_SP(sp)</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(handle_exception)</span>
<span class="p_add">+	SAVE_ALL</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set sscratch register to 0, so that if a recursive exception</span>
<span class="p_add">+	   occurs, the exception vector knows it came from the kernel */</span>
<span class="p_add">+	csrw sscratch, x0</span>
<span class="p_add">+</span>
<span class="p_add">+	la gp, __global_pointer$</span>
<span class="p_add">+</span>
<span class="p_add">+	la ra, ret_from_exception</span>
<span class="p_add">+	/* MSB of cause differentiates between</span>
<span class="p_add">+	   interrupts and exceptions */</span>
<span class="p_add">+	bge s4, zero, 1f</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Handle interrupts */</span>
<span class="p_add">+	slli a0, s4, 1</span>
<span class="p_add">+	srli a0, a0, 1</span>
<span class="p_add">+	move a1, sp /* pt_regs */</span>
<span class="p_add">+	tail do_IRQ</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/* Handle syscalls */</span>
<span class="p_add">+	li t0, EXC_SYSCALL</span>
<span class="p_add">+	beq s4, t0, handle_syscall</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Handle other exceptions */</span>
<span class="p_add">+	slli t0, s4, RISCV_LGPTR</span>
<span class="p_add">+	la t1, excp_vect_table</span>
<span class="p_add">+	la t2, excp_vect_table_end</span>
<span class="p_add">+	move a0, sp /* pt_regs */</span>
<span class="p_add">+	add t0, t1, t0</span>
<span class="p_add">+	/* Check if exception code lies within bounds */</span>
<span class="p_add">+	bgeu t0, t2, 1f</span>
<span class="p_add">+	REG_L t0, 0(t0)</span>
<span class="p_add">+	jr t0</span>
<span class="p_add">+1:</span>
<span class="p_add">+	tail do_trap_unknown</span>
<span class="p_add">+</span>
<span class="p_add">+handle_syscall:</span>
<span class="p_add">+	/* Advance SEPC to avoid executing the original</span>
<span class="p_add">+	   scall instruction on sret */</span>
<span class="p_add">+	addi s2, s2, 0x4</span>
<span class="p_add">+	REG_S s2, PT_SEPC(sp)</span>
<span class="p_add">+	/* System calls run with interrupts enabled */</span>
<span class="p_add">+	csrs sstatus, SR_IE</span>
<span class="p_add">+	/* Trace syscalls, but only if requested by the user. */</span>
<span class="p_add">+	REG_L t0, TASK_TI_FLAGS(tp)</span>
<span class="p_add">+	andi t0, t0, _TIF_SYSCALL_TRACE</span>
<span class="p_add">+	bnez t0, handle_syscall_trace_enter</span>
<span class="p_add">+check_syscall_nr:</span>
<span class="p_add">+	/* Check to make sure we don&#39;t jump to a bogus syscall number. */</span>
<span class="p_add">+	li t0, __NR_syscalls</span>
<span class="p_add">+	la s0, sys_ni_syscall</span>
<span class="p_add">+	/* Syscall number held in a7 */</span>
<span class="p_add">+	bgeu a7, t0, 1f</span>
<span class="p_add">+	la s0, sys_call_table</span>
<span class="p_add">+	slli t0, a7, RISCV_LGPTR</span>
<span class="p_add">+	add s0, s0, t0</span>
<span class="p_add">+	REG_L s0, 0(s0)</span>
<span class="p_add">+1:</span>
<span class="p_add">+	jalr s0</span>
<span class="p_add">+</span>
<span class="p_add">+ret_from_syscall:</span>
<span class="p_add">+	/* Set user a0 to kernel a0 */</span>
<span class="p_add">+	REG_S a0, PT_A0(sp)</span>
<span class="p_add">+	/* Trace syscalls, but only if requested by the user. */</span>
<span class="p_add">+	REG_L t0, TASK_TI_FLAGS(tp)</span>
<span class="p_add">+	andi t0, t0, _TIF_SYSCALL_TRACE</span>
<span class="p_add">+	bnez t0, handle_syscall_trace_exit</span>
<span class="p_add">+</span>
<span class="p_add">+ret_from_exception:</span>
<span class="p_add">+	REG_L s0, PT_SSTATUS(sp)</span>
<span class="p_add">+	csrc sstatus, SR_IE</span>
<span class="p_add">+	andi s0, s0, SR_PS</span>
<span class="p_add">+	bnez s0, restore_all</span>
<span class="p_add">+</span>
<span class="p_add">+resume_userspace:</span>
<span class="p_add">+	/* Interrupts must be disabled here so flags are checked atomically */</span>
<span class="p_add">+	REG_L s0, TASK_TI_FLAGS(tp) /* current_thread_info-&gt;flags */</span>
<span class="p_add">+	andi s1, s0, _TIF_WORK_MASK</span>
<span class="p_add">+	bnez s1, work_pending</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save unwound kernel stack pointer in thread_info */</span>
<span class="p_add">+	addi s0, sp, PT_SIZE_ON_STACK</span>
<span class="p_add">+	REG_S s0, TASK_TI_KERNEL_SP(tp)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save TP into sscratch, so we can find the kernel data structures</span>
<span class="p_add">+	 * again. */</span>
<span class="p_add">+	csrw sscratch, tp</span>
<span class="p_add">+</span>
<span class="p_add">+restore_all:</span>
<span class="p_add">+	RESTORE_ALL</span>
<span class="p_add">+	sret</span>
<span class="p_add">+</span>
<span class="p_add">+work_pending:</span>
<span class="p_add">+	/* Enter slow path for supplementary processing */</span>
<span class="p_add">+	la ra, ret_from_exception</span>
<span class="p_add">+	andi s1, s0, _TIF_NEED_RESCHED</span>
<span class="p_add">+	bnez s1, work_resched</span>
<span class="p_add">+work_notifysig:</span>
<span class="p_add">+	/* Handle pending signals and notify-resume requests */</span>
<span class="p_add">+	csrs sstatus, SR_IE /* Enable interrupts for do_notify_resume() */</span>
<span class="p_add">+	move a0, sp /* pt_regs */</span>
<span class="p_add">+	move a1, s0 /* current_thread_info-&gt;flags */</span>
<span class="p_add">+	tail do_notify_resume</span>
<span class="p_add">+work_resched:</span>
<span class="p_add">+	tail schedule</span>
<span class="p_add">+</span>
<span class="p_add">+/* Slow paths for ptrace. */</span>
<span class="p_add">+handle_syscall_trace_enter:</span>
<span class="p_add">+	move a0, sp</span>
<span class="p_add">+	call do_syscall_trace_enter</span>
<span class="p_add">+	REG_L a0, PT_A0(sp)</span>
<span class="p_add">+	REG_L a1, PT_A1(sp)</span>
<span class="p_add">+	REG_L a2, PT_A2(sp)</span>
<span class="p_add">+	REG_L a3, PT_A3(sp)</span>
<span class="p_add">+	REG_L a4, PT_A4(sp)</span>
<span class="p_add">+	REG_L a5, PT_A5(sp)</span>
<span class="p_add">+	REG_L a6, PT_A6(sp)</span>
<span class="p_add">+	REG_L a7, PT_A7(sp)</span>
<span class="p_add">+	j check_syscall_nr</span>
<span class="p_add">+handle_syscall_trace_exit:</span>
<span class="p_add">+	move a0, sp</span>
<span class="p_add">+	call do_syscall_trace_exit</span>
<span class="p_add">+	j ret_from_exception</span>
<span class="p_add">+</span>
<span class="p_add">+END(handle_exception)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ret_from_fork)</span>
<span class="p_add">+	la ra, ret_from_exception</span>
<span class="p_add">+	tail schedule_tail</span>
<span class="p_add">+ENDPROC(ret_from_fork)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ret_from_kernel_thread)</span>
<span class="p_add">+	call schedule_tail</span>
<span class="p_add">+	/* Call fn(arg) */</span>
<span class="p_add">+	la ra, ret_from_exception</span>
<span class="p_add">+	move a0, s1</span>
<span class="p_add">+	jr s0</span>
<span class="p_add">+ENDPROC(ret_from_kernel_thread)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Integer register context switch</span>
<span class="p_add">+ * The callee-saved registers must be saved and restored.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   a0: previous task_struct (must be preserved across the switch)</span>
<span class="p_add">+ *   a1: next task_struct</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(__switch_to)</span>
<span class="p_add">+	/* Save context into prev-&gt;thread */</span>
<span class="p_add">+	li    a2,  TASK_THREAD_RA</span>
<span class="p_add">+	add   a0, a0, a2</span>
<span class="p_add">+	add   a2, a1, a2</span>
<span class="p_add">+	REG_S ra,  TASK_THREAD_RA_RA(a0)</span>
<span class="p_add">+	REG_S sp,  TASK_THREAD_SP_RA(a0)</span>
<span class="p_add">+	REG_S s0,  TASK_THREAD_S0_RA(a0)</span>
<span class="p_add">+	REG_S s1,  TASK_THREAD_S1_RA(a0)</span>
<span class="p_add">+	REG_S s2,  TASK_THREAD_S2_RA(a0)</span>
<span class="p_add">+	REG_S s3,  TASK_THREAD_S3_RA(a0)</span>
<span class="p_add">+	REG_S s4,  TASK_THREAD_S4_RA(a0)</span>
<span class="p_add">+	REG_S s5,  TASK_THREAD_S5_RA(a0)</span>
<span class="p_add">+	REG_S s6,  TASK_THREAD_S6_RA(a0)</span>
<span class="p_add">+	REG_S s7,  TASK_THREAD_S7_RA(a0)</span>
<span class="p_add">+	REG_S s8,  TASK_THREAD_S8_RA(a0)</span>
<span class="p_add">+	REG_S s9,  TASK_THREAD_S9_RA(a0)</span>
<span class="p_add">+	REG_S s10, TASK_THREAD_S10_RA(a0)</span>
<span class="p_add">+	REG_S s11, TASK_THREAD_S11_RA(a0)</span>
<span class="p_add">+	/* Restore context from next-&gt;thread */</span>
<span class="p_add">+	REG_L ra,  TASK_THREAD_RA_RA(a2)</span>
<span class="p_add">+	REG_L sp,  TASK_THREAD_SP_RA(a2)</span>
<span class="p_add">+	REG_L s0,  TASK_THREAD_S0_RA(a2)</span>
<span class="p_add">+	REG_L s1,  TASK_THREAD_S1_RA(a2)</span>
<span class="p_add">+	REG_L s2,  TASK_THREAD_S2_RA(a2)</span>
<span class="p_add">+	REG_L s3,  TASK_THREAD_S3_RA(a2)</span>
<span class="p_add">+	REG_L s4,  TASK_THREAD_S4_RA(a2)</span>
<span class="p_add">+	REG_L s5,  TASK_THREAD_S5_RA(a2)</span>
<span class="p_add">+	REG_L s6,  TASK_THREAD_S6_RA(a2)</span>
<span class="p_add">+	REG_L s7,  TASK_THREAD_S7_RA(a2)</span>
<span class="p_add">+	REG_L s8,  TASK_THREAD_S8_RA(a2)</span>
<span class="p_add">+	REG_L s9,  TASK_THREAD_S9_RA(a2)</span>
<span class="p_add">+	REG_L s10, TASK_THREAD_S10_RA(a2)</span>
<span class="p_add">+	REG_L s11, TASK_THREAD_S11_RA(a2)</span>
<span class="p_add">+#if TASK_TI != 0</span>
<span class="p_add">+#error &quot;TASK_TI != 0: tp will contain a &#39;struct thread_info&#39;, not a &#39;struct task_struct&#39; so get_current() won&#39;t work.&quot;</span>
<span class="p_add">+	addi tp, a1, TASK_TI</span>
<span class="p_add">+#else</span>
<span class="p_add">+	move tp, a1</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(__switch_to)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__fstate_save)</span>
<span class="p_add">+	li  a2,  TASK_THREAD_F0</span>
<span class="p_add">+	add a0, a0, a2</span>
<span class="p_add">+	li t1, SR_FS</span>
<span class="p_add">+	csrs sstatus, t1</span>
<span class="p_add">+	frcsr t0</span>
<span class="p_add">+	fsd f0,  TASK_THREAD_F0_F0(a0)</span>
<span class="p_add">+	fsd f1,  TASK_THREAD_F1_F0(a0)</span>
<span class="p_add">+	fsd f2,  TASK_THREAD_F2_F0(a0)</span>
<span class="p_add">+	fsd f3,  TASK_THREAD_F3_F0(a0)</span>
<span class="p_add">+	fsd f4,  TASK_THREAD_F4_F0(a0)</span>
<span class="p_add">+	fsd f5,  TASK_THREAD_F5_F0(a0)</span>
<span class="p_add">+	fsd f6,  TASK_THREAD_F6_F0(a0)</span>
<span class="p_add">+	fsd f7,  TASK_THREAD_F7_F0(a0)</span>
<span class="p_add">+	fsd f8,  TASK_THREAD_F8_F0(a0)</span>
<span class="p_add">+	fsd f9,  TASK_THREAD_F9_F0(a0)</span>
<span class="p_add">+	fsd f10, TASK_THREAD_F10_F0(a0)</span>
<span class="p_add">+	fsd f11, TASK_THREAD_F11_F0(a0)</span>
<span class="p_add">+	fsd f12, TASK_THREAD_F12_F0(a0)</span>
<span class="p_add">+	fsd f13, TASK_THREAD_F13_F0(a0)</span>
<span class="p_add">+	fsd f14, TASK_THREAD_F14_F0(a0)</span>
<span class="p_add">+	fsd f15, TASK_THREAD_F15_F0(a0)</span>
<span class="p_add">+	fsd f16, TASK_THREAD_F16_F0(a0)</span>
<span class="p_add">+	fsd f17, TASK_THREAD_F17_F0(a0)</span>
<span class="p_add">+	fsd f18, TASK_THREAD_F18_F0(a0)</span>
<span class="p_add">+	fsd f19, TASK_THREAD_F19_F0(a0)</span>
<span class="p_add">+	fsd f20, TASK_THREAD_F20_F0(a0)</span>
<span class="p_add">+	fsd f21, TASK_THREAD_F21_F0(a0)</span>
<span class="p_add">+	fsd f22, TASK_THREAD_F22_F0(a0)</span>
<span class="p_add">+	fsd f23, TASK_THREAD_F23_F0(a0)</span>
<span class="p_add">+	fsd f24, TASK_THREAD_F24_F0(a0)</span>
<span class="p_add">+	fsd f25, TASK_THREAD_F25_F0(a0)</span>
<span class="p_add">+	fsd f26, TASK_THREAD_F26_F0(a0)</span>
<span class="p_add">+	fsd f27, TASK_THREAD_F27_F0(a0)</span>
<span class="p_add">+	fsd f28, TASK_THREAD_F28_F0(a0)</span>
<span class="p_add">+	fsd f29, TASK_THREAD_F29_F0(a0)</span>
<span class="p_add">+	fsd f30, TASK_THREAD_F30_F0(a0)</span>
<span class="p_add">+	fsd f31, TASK_THREAD_F31_F0(a0)</span>
<span class="p_add">+	sw t0, TASK_THREAD_FCSR_F0(a0)</span>
<span class="p_add">+	csrc sstatus, t1</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(__fstate_save)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__fstate_restore)</span>
<span class="p_add">+	li  a2,  TASK_THREAD_F0</span>
<span class="p_add">+	add a0, a0, a2</span>
<span class="p_add">+	li t1, SR_FS</span>
<span class="p_add">+	lw t0, TASK_THREAD_FCSR_F0(a0)</span>
<span class="p_add">+	csrs sstatus, t1</span>
<span class="p_add">+	fld f0,  TASK_THREAD_F0_F0(a0)</span>
<span class="p_add">+	fld f1,  TASK_THREAD_F1_F0(a0)</span>
<span class="p_add">+	fld f2,  TASK_THREAD_F2_F0(a0)</span>
<span class="p_add">+	fld f3,  TASK_THREAD_F3_F0(a0)</span>
<span class="p_add">+	fld f4,  TASK_THREAD_F4_F0(a0)</span>
<span class="p_add">+	fld f5,  TASK_THREAD_F5_F0(a0)</span>
<span class="p_add">+	fld f6,  TASK_THREAD_F6_F0(a0)</span>
<span class="p_add">+	fld f7,  TASK_THREAD_F7_F0(a0)</span>
<span class="p_add">+	fld f8,  TASK_THREAD_F8_F0(a0)</span>
<span class="p_add">+	fld f9,  TASK_THREAD_F9_F0(a0)</span>
<span class="p_add">+	fld f10, TASK_THREAD_F10_F0(a0)</span>
<span class="p_add">+	fld f11, TASK_THREAD_F11_F0(a0)</span>
<span class="p_add">+	fld f12, TASK_THREAD_F12_F0(a0)</span>
<span class="p_add">+	fld f13, TASK_THREAD_F13_F0(a0)</span>
<span class="p_add">+	fld f14, TASK_THREAD_F14_F0(a0)</span>
<span class="p_add">+	fld f15, TASK_THREAD_F15_F0(a0)</span>
<span class="p_add">+	fld f16, TASK_THREAD_F16_F0(a0)</span>
<span class="p_add">+	fld f17, TASK_THREAD_F17_F0(a0)</span>
<span class="p_add">+	fld f18, TASK_THREAD_F18_F0(a0)</span>
<span class="p_add">+	fld f19, TASK_THREAD_F19_F0(a0)</span>
<span class="p_add">+	fld f20, TASK_THREAD_F20_F0(a0)</span>
<span class="p_add">+	fld f21, TASK_THREAD_F21_F0(a0)</span>
<span class="p_add">+	fld f22, TASK_THREAD_F22_F0(a0)</span>
<span class="p_add">+	fld f23, TASK_THREAD_F23_F0(a0)</span>
<span class="p_add">+	fld f24, TASK_THREAD_F24_F0(a0)</span>
<span class="p_add">+	fld f25, TASK_THREAD_F25_F0(a0)</span>
<span class="p_add">+	fld f26, TASK_THREAD_F26_F0(a0)</span>
<span class="p_add">+	fld f27, TASK_THREAD_F27_F0(a0)</span>
<span class="p_add">+	fld f28, TASK_THREAD_F28_F0(a0)</span>
<span class="p_add">+	fld f29, TASK_THREAD_F29_F0(a0)</span>
<span class="p_add">+	fld f30, TASK_THREAD_F30_F0(a0)</span>
<span class="p_add">+	fld f31, TASK_THREAD_F31_F0(a0)</span>
<span class="p_add">+	fscsr t0</span>
<span class="p_add">+	csrc sstatus, t1</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(__fstate_restore)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.section &quot;.rodata&quot;</span>
<span class="p_add">+	/* Exception vector table */</span>
<span class="p_add">+ENTRY(excp_vect_table)</span>
<span class="p_add">+	RISCV_PTR do_trap_insn_misaligned</span>
<span class="p_add">+	RISCV_PTR do_trap_insn_fault</span>
<span class="p_add">+	RISCV_PTR do_trap_insn_illegal</span>
<span class="p_add">+	RISCV_PTR do_trap_break</span>
<span class="p_add">+	RISCV_PTR do_trap_load_misaligned</span>
<span class="p_add">+	RISCV_PTR do_trap_load_fault</span>
<span class="p_add">+	RISCV_PTR do_trap_store_misaligned</span>
<span class="p_add">+	RISCV_PTR do_trap_store_fault</span>
<span class="p_add">+	RISCV_PTR do_trap_ecall_u /* system call, gets intercepted */</span>
<span class="p_add">+	RISCV_PTR do_trap_ecall_s</span>
<span class="p_add">+	RISCV_PTR do_trap_unknown</span>
<span class="p_add">+	RISCV_PTR do_trap_ecall_m</span>
<span class="p_add">+	RISCV_PTR do_page_fault   /* instruction page fault */</span>
<span class="p_add">+	RISCV_PTR do_page_fault   /* load page fault */</span>
<span class="p_add">+	RISCV_PTR do_trap_unknown</span>
<span class="p_add">+	RISCV_PTR do_page_fault   /* store page fault */</span>
<span class="p_add">+excp_vect_table_end:</span>
<span class="p_add">+END(excp_vect_table)</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S</span>
new file mode 100644
<span class="p_header">index 000000000000..608e57d4531f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/head.S</span>
<span class="p_chunk">@@ -0,0 +1,147 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+__INIT</span>
<span class="p_add">+ENTRY(_start)</span>
<span class="p_add">+	/* Mask all interrupts */</span>
<span class="p_add">+	csrw sie, zero</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable FPU to detect illegal usage of</span>
<span class="p_add">+	   floating point in kernel space */</span>
<span class="p_add">+	li t0, SR_FS</span>
<span class="p_add">+	csrc sstatus, t0</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef CONFIG_RV_PUM</span>
<span class="p_add">+	/* Allow access to user memory */</span>
<span class="p_add">+	li t0, SR_SUM</span>
<span class="p_add">+	csrs sstatus, t0</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_ISA_A</span>
<span class="p_add">+	/* Pick one hart to run the main boot sequence */</span>
<span class="p_add">+	la a3, hart_lottery</span>
<span class="p_add">+	li a2, 1</span>
<span class="p_add">+	amoadd.w a3, a2, (a3)</span>
<span class="p_add">+	bnez a3, .Lsecondary_start</span>
<span class="p_add">+#else</span>
<span class="p_add">+	/* We don&#39;t have atomic support, so the boot hart must be picked</span>
<span class="p_add">+	 * staticly.  Hart 0 is the only sane choice.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	bnez a0, .Lsecondary_park</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save hart ID and DTB physical address */</span>
<span class="p_add">+	mv s0, a0</span>
<span class="p_add">+	mv s1, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize page tables and relocate to virtual addresses */</span>
<span class="p_add">+	la sp, init_thread_union + THREAD_SIZE</span>
<span class="p_add">+	call setup_vm</span>
<span class="p_add">+	call relocate</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore C environment */</span>
<span class="p_add">+	la tp, init_task</span>
<span class="p_add">+</span>
<span class="p_add">+	la sp, init_thread_union</span>
<span class="p_add">+	li a0, ASM_THREAD_SIZE</span>
<span class="p_add">+	add sp, sp, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start the kernel */</span>
<span class="p_add">+	mv a0, s0</span>
<span class="p_add">+	mv a1, s1</span>
<span class="p_add">+	call sbi_save</span>
<span class="p_add">+	tail start_kernel</span>
<span class="p_add">+</span>
<span class="p_add">+relocate:</span>
<span class="p_add">+	/* Relocate return address */</span>
<span class="p_add">+	li a1, PAGE_OFFSET</span>
<span class="p_add">+	la a0, _start</span>
<span class="p_add">+	sub a1, a1, a0</span>
<span class="p_add">+	add ra, ra, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Point stvec to virtual address of intruction after sptbr write */</span>
<span class="p_add">+	la a0, 1f</span>
<span class="p_add">+	add a0, a0, a1</span>
<span class="p_add">+	csrw stvec, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Compute sptbr for kernel page tables, but don&#39;t load it yet */</span>
<span class="p_add">+	la a2, swapper_pg_dir</span>
<span class="p_add">+	srl a2, a2, PAGE_SHIFT</span>
<span class="p_add">+	li a1, SPTBR_MODE</span>
<span class="p_add">+	or a2, a2, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load trampoline page directory, which will cause us to trap to</span>
<span class="p_add">+	   stvec if VA != PA, or simply fall through if VA == PA */</span>
<span class="p_add">+	la a0, trampoline_pg_dir</span>
<span class="p_add">+	srl a0, a0, PAGE_SHIFT</span>
<span class="p_add">+	or a0, a0, a1</span>
<span class="p_add">+	sfence.vma</span>
<span class="p_add">+	csrw sptbr, a0</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/* Set trap vector to spin forever to help debug */</span>
<span class="p_add">+	la a0, .Lsecondary_park</span>
<span class="p_add">+	csrw stvec, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load the global pointer */</span>
<span class="p_add">+	la gp, __global_pointer$</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Switch to kernel page tables */</span>
<span class="p_add">+	csrw sptbr, a2</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+</span>
<span class="p_add">+.Lsecondary_start:</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	li a1, CONFIG_NR_CPUS</span>
<span class="p_add">+	bgeu a0, a1, .Lsecondary_park</span>
<span class="p_add">+</span>
<span class="p_add">+	la a1, __cpu_up_stack_pointer</span>
<span class="p_add">+	slli a0, a0, LGREG</span>
<span class="p_add">+	add a0, a0, a1</span>
<span class="p_add">+</span>
<span class="p_add">+.Lwait_for_cpu_up:</span>
<span class="p_add">+	REG_L sp, (a0)</span>
<span class="p_add">+	beqz sp, .Lwait_for_cpu_up</span>
<span class="p_add">+	fence</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable virtual memory and relocate to virtual address */</span>
<span class="p_add">+	call relocate</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize task_struct pointer */</span>
<span class="p_add">+	li tp, -THREAD_SIZE</span>
<span class="p_add">+	add tp, tp, sp</span>
<span class="p_add">+</span>
<span class="p_add">+	tail smp_callin</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+.Lsecondary_park:</span>
<span class="p_add">+	/* We lack SMP support or have too many harts, so park this hart */</span>
<span class="p_add">+	wfi</span>
<span class="p_add">+	j .Lsecondary_park</span>
<span class="p_add">+END(_start)</span>
<span class="p_add">+</span>
<span class="p_add">+__PAGE_ALIGNED_BSS</span>
<span class="p_add">+	/* Empty zero page */</span>
<span class="p_add">+	.balign PAGE_SIZE</span>
<span class="p_add">+ENTRY(empty_zero_page)</span>
<span class="p_add">+	.fill (empty_zero_page + PAGE_SIZE) - ., 1, 0x00</span>
<span class="p_add">+END(empty_zero_page)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c</span>
new file mode 100644
<span class="p_header">index 000000000000..737d7cce2c6d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/irq.c</span>
<span class="p_chunk">@@ -0,0 +1,20 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/irqchip.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void __init init_IRQ(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	irqchip_init();</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/module.c b/arch/riscv/kernel/module.c</span>
new file mode 100644
<span class="p_header">index 000000000000..753cb9894feb</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/module.c</span>
<span class="p_chunk">@@ -0,0 +1,215 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ *  This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ *  it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ *  (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *  GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Copyright (C) 2017 Zihao Yu</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/elf.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/errno.h&gt;</span>
<span class="p_add">+#include &lt;linux/moduleloader.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_64_rela(struct module *me, u32 *location, Elf_Addr v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*(u64 *)location = v;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_branch_rela(struct module *me, u32 *location,</span>
<span class="p_add">+				     Elf_Addr v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	s64 offset = (void *)v - (void *)location;</span>
<span class="p_add">+	u32 imm12 = (offset &amp; 0x1000) &lt;&lt; (31 - 12);</span>
<span class="p_add">+	u32 imm11 = (offset &amp; 0x800) &gt;&gt; (11 - 7);</span>
<span class="p_add">+	u32 imm10_5 = (offset &amp; 0x7e0) &lt;&lt; (30 - 10);</span>
<span class="p_add">+	u32 imm4_1 = (offset &amp; 0x1e) &lt;&lt; (11 - 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	*location = (*location &amp; 0x1fff07f) | imm12 | imm11 | imm10_5 | imm4_1;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_jal_rela(struct module *me, u32 *location,</span>
<span class="p_add">+				  Elf_Addr v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	s64 offset = (void *)v - (void *)location;</span>
<span class="p_add">+	u32 imm20 = (offset &amp; 0x100000) &lt;&lt; (31 - 20);</span>
<span class="p_add">+	u32 imm19_12 = (offset &amp; 0xff000);</span>
<span class="p_add">+	u32 imm11 = (offset &amp; 0x800) &lt;&lt; (20 - 11);</span>
<span class="p_add">+	u32 imm10_1 = (offset &amp; 0x7fe) &lt;&lt; (30 - 10);</span>
<span class="p_add">+</span>
<span class="p_add">+	*location = (*location &amp; 0xfff) | imm20 | imm19_12 | imm11 | imm10_1;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_pcrel_hi20_rela(struct module *me, u32 *location,</span>
<span class="p_add">+					 Elf_Addr v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	s64 offset = (void *)v - (void *)location;</span>
<span class="p_add">+	s32 hi20;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (offset != (s32)offset) {</span>
<span class="p_add">+		pr_err(</span>
<span class="p_add">+		  &quot;%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n&quot;,</span>
<span class="p_add">+		  me-&gt;name, v, location);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hi20 = (offset + 0x800) &amp; 0xfffff000;</span>
<span class="p_add">+	*location = (*location &amp; 0xfff) | hi20;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_pcrel_lo12_i_rela(struct module *me, u32 *location,</span>
<span class="p_add">+					   Elf_Addr v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* v is the lo12 value to fill. It is calculated before calling this</span>
<span class="p_add">+	 * handler.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	*location = (*location &amp; 0xfffff) | ((v &amp; 0xfff) &lt;&lt; 20);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_pcrel_lo12_s_rela(struct module *me, u32 *location,</span>
<span class="p_add">+					   Elf_Addr v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* v is the lo12 value to fill. It is calculated before calling this</span>
<span class="p_add">+	 * handler.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	u32 imm11_5 = (v &amp; 0xfe0) &lt;&lt; (31 - 11);</span>
<span class="p_add">+	u32 imm4_0 = (v &amp; 0x1f) &lt;&lt; (11 - 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	*location = (*location &amp; 0x1fff07f) | imm11_5 | imm4_0;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_call_plt_rela(struct module *me, u32 *location,</span>
<span class="p_add">+				       Elf_Addr v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	s64 offset = (void *)v - (void *)location;</span>
<span class="p_add">+	s32 fill_v = offset;</span>
<span class="p_add">+	u32 hi20, lo12;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (offset != fill_v) {</span>
<span class="p_add">+		pr_err(</span>
<span class="p_add">+		  &quot;%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n&quot;,</span>
<span class="p_add">+		  me-&gt;name, v, location);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hi20 = (offset + 0x800) &amp; 0xfffff000;</span>
<span class="p_add">+	lo12 = (offset - hi20) &amp; 0xfff;</span>
<span class="p_add">+	*location = (*location &amp; 0xfff) | hi20;</span>
<span class="p_add">+	*(location + 1) = (*(location + 1) &amp; 0xfffff) | (lo12 &lt;&lt; 20);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_relax_rela(struct module *me, u32 *location,</span>
<span class="p_add">+				    Elf_Addr v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int (*reloc_handlers_rela[]) (struct module *me, u32 *location,</span>
<span class="p_add">+				Elf_Addr v) = {</span>
<span class="p_add">+	[R_RISCV_64]			= apply_r_riscv_64_rela,</span>
<span class="p_add">+	[R_RISCV_BRANCH]		= apply_r_riscv_branch_rela,</span>
<span class="p_add">+	[R_RISCV_JAL]			= apply_r_riscv_jal_rela,</span>
<span class="p_add">+	[R_RISCV_PCREL_HI20]		= apply_r_riscv_pcrel_hi20_rela,</span>
<span class="p_add">+	[R_RISCV_PCREL_LO12_I]		= apply_r_riscv_pcrel_lo12_i_rela,</span>
<span class="p_add">+	[R_RISCV_PCREL_LO12_S]		= apply_r_riscv_pcrel_lo12_s_rela,</span>
<span class="p_add">+	[R_RISCV_CALL_PLT]		= apply_r_riscv_call_plt_rela,</span>
<span class="p_add">+	[R_RISCV_RELAX]			= apply_r_riscv_relax_rela,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,</span>
<span class="p_add">+		       unsigned int symindex, unsigned int relsec,</span>
<span class="p_add">+		       struct module *me)</span>
<span class="p_add">+{</span>
<span class="p_add">+	Elf_Rela *rel = (void *) sechdrs[relsec].sh_addr;</span>
<span class="p_add">+	int (*handler)(struct module *me, u32 *location, Elf_Addr v);</span>
<span class="p_add">+	Elf_Sym *sym;</span>
<span class="p_add">+	u32 *location;</span>
<span class="p_add">+	unsigned int i, type;</span>
<span class="p_add">+	Elf_Addr v;</span>
<span class="p_add">+	int res;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Applying relocate section %u to %u\n&quot;, relsec,</span>
<span class="p_add">+	       sechdrs[relsec].sh_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {</span>
<span class="p_add">+		/* This is where to make the change */</span>
<span class="p_add">+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr</span>
<span class="p_add">+			+ rel[i].r_offset;</span>
<span class="p_add">+		/* This is the symbol it is referring to */</span>
<span class="p_add">+		sym = (Elf_Sym *)sechdrs[symindex].sh_addr</span>
<span class="p_add">+			+ ELF_RISCV_R_SYM(rel[i].r_info);</span>
<span class="p_add">+		if (IS_ERR_VALUE(sym-&gt;st_value)) {</span>
<span class="p_add">+			/* Ignore unresolved weak symbol */</span>
<span class="p_add">+			if (ELF_ST_BIND(sym-&gt;st_info) == STB_WEAK)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			printk(KERN_WARNING &quot;%s: Unknown symbol %s\n&quot;,</span>
<span class="p_add">+			       me-&gt;name, strtab + sym-&gt;st_name);</span>
<span class="p_add">+			return -ENOENT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		type = ELF_RISCV_R_TYPE(rel[i].r_info);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (type &lt; ARRAY_SIZE(reloc_handlers_rela))</span>
<span class="p_add">+			handler = reloc_handlers_rela[type];</span>
<span class="p_add">+		else</span>
<span class="p_add">+			handler = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!handler) {</span>
<span class="p_add">+			pr_err(&quot;%s: Unknown relocation type %u\n&quot;,</span>
<span class="p_add">+			       me-&gt;name, type);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		v = sym-&gt;st_value + rel[i].r_addend;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (type == R_RISCV_PCREL_LO12_I || type == R_RISCV_PCREL_LO12_S) {</span>
<span class="p_add">+			unsigned int j;</span>
<span class="p_add">+</span>
<span class="p_add">+			for (j = 0; j &lt; sechdrs[relsec].sh_size / sizeof(*rel); j++) {</span>
<span class="p_add">+				u64 hi20_loc =</span>
<span class="p_add">+					sechdrs[sechdrs[relsec].sh_info].sh_addr</span>
<span class="p_add">+					+ rel[j].r_offset;</span>
<span class="p_add">+				/* Find the corresponding HI20 PC-relative relocation entry */</span>
<span class="p_add">+				if (hi20_loc == sym-&gt;st_value) {</span>
<span class="p_add">+					Elf_Sym *hi20_sym =</span>
<span class="p_add">+						(Elf_Sym *)sechdrs[symindex].sh_addr</span>
<span class="p_add">+						+ ELF_RISCV_R_SYM(rel[j].r_info);</span>
<span class="p_add">+					u64 hi20_sym_val =</span>
<span class="p_add">+						hi20_sym-&gt;st_value</span>
<span class="p_add">+						+ rel[j].r_addend;</span>
<span class="p_add">+					/* Calculate lo12 */</span>
<span class="p_add">+					s64 offset = hi20_sym_val - hi20_loc;</span>
<span class="p_add">+					s32 hi20 = (offset + 0x800) &amp; 0xfffff000;</span>
<span class="p_add">+					s32 lo12 = offset - hi20;</span>
<span class="p_add">+					v = lo12;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+			if (j == sechdrs[relsec].sh_size / sizeof(*rel)) {</span>
<span class="p_add">+				pr_err(</span>
<span class="p_add">+				  &quot;%s: Can not find HI20 PC-relative relocation information\n&quot;,</span>
<span class="p_add">+				  me-&gt;name);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		res = handler(me, location, v);</span>
<span class="p_add">+		if (res)</span>
<span class="p_add">+			return res;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/process.c b/arch/riscv/kernel/process.c</span>
new file mode 100644
<span class="p_header">index 000000000000..c10146ae317d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/process.c</span>
<span class="p_chunk">@@ -0,0 +1,132 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Sunplus Core Technology Co., Ltd.</span>
<span class="p_add">+ *  Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ *  Lennox Wu &lt;lennox.wu@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, see the file COPYING, or write</span>
<span class="p_add">+ * to the Free Software Foundation, Inc.,</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;linux/tick.h&gt;</span>
<span class="p_add">+#include &lt;linux/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+#include &lt;asm/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+#include &lt;asm/string.h&gt;</span>
<span class="p_add">+#include &lt;asm/switch_to.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern asmlinkage void ret_from_fork(void);</span>
<span class="p_add">+extern asmlinkage void ret_from_kernel_thread(void);</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_cpu_idle(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	wait_for_interrupt();</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void show_regs(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	show_regs_print_info(KERN_DEFAULT);</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(KERN_CONT &quot;sepc: &quot; REG_FMT &quot; ra : &quot; REG_FMT &quot; sp : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;sepc, regs-&gt;ra, regs-&gt;sp);</span>
<span class="p_add">+	printk(KERN_CONT &quot; gp : &quot; REG_FMT &quot; tp : &quot; REG_FMT &quot; t0 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;gp, regs-&gt;tp, regs-&gt;t0);</span>
<span class="p_add">+	printk(KERN_CONT &quot; t1 : &quot; REG_FMT &quot; t2 : &quot; REG_FMT &quot; s0 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;t1, regs-&gt;t2, regs-&gt;s0);</span>
<span class="p_add">+	printk(KERN_CONT &quot; s1 : &quot; REG_FMT &quot; a0 : &quot; REG_FMT &quot; a1 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s1, regs-&gt;a0, regs-&gt;a1);</span>
<span class="p_add">+	printk(KERN_CONT &quot; a2 : &quot; REG_FMT &quot; a3 : &quot; REG_FMT &quot; a4 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;a2, regs-&gt;a3, regs-&gt;a4);</span>
<span class="p_add">+	printk(KERN_CONT &quot; a5 : &quot; REG_FMT &quot; a6 : &quot; REG_FMT &quot; a7 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;a5, regs-&gt;a6, regs-&gt;a7);</span>
<span class="p_add">+	printk(KERN_CONT &quot; s2 : &quot; REG_FMT &quot; s3 : &quot; REG_FMT &quot; s4 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s2, regs-&gt;s3, regs-&gt;s4);</span>
<span class="p_add">+	printk(KERN_CONT &quot; s5 : &quot; REG_FMT &quot; s6 : &quot; REG_FMT &quot; s7 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s5, regs-&gt;s6, regs-&gt;s7);</span>
<span class="p_add">+	printk(KERN_CONT &quot; s8 : &quot; REG_FMT &quot; s9 : &quot; REG_FMT &quot; s10: &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s8, regs-&gt;s9, regs-&gt;s10);</span>
<span class="p_add">+	printk(KERN_CONT &quot; s11: &quot; REG_FMT &quot; t3 : &quot; REG_FMT &quot; t4 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s11, regs-&gt;t3, regs-&gt;t4);</span>
<span class="p_add">+	printk(KERN_CONT &quot; t5 : &quot; REG_FMT &quot; t6 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;t5, regs-&gt;t6);</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(KERN_CONT &quot;sstatus: &quot; REG_FMT &quot; sbadaddr: &quot; REG_FMT &quot; scause: &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;sstatus, regs-&gt;sbadaddr, regs-&gt;scause);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void start_thread(struct pt_regs *regs, unsigned long pc,</span>
<span class="p_add">+	unsigned long sp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	regs-&gt;sstatus = SR_PIE /* User mode, irqs on */ | SR_FS_INITIAL;</span>
<span class="p_add">+#ifndef CONFIG_RV_PUM</span>
<span class="p_add">+	regs-&gt;sstatus |= SR_SUM</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	regs-&gt;sepc = pc;</span>
<span class="p_add">+	regs-&gt;sp = sp;</span>
<span class="p_add">+	set_fs(USER_DS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void flush_thread(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Reset FPU context</span>
<span class="p_add">+	 *	frm: round to nearest, ties to even (IEEE default)</span>
<span class="p_add">+	 *	fflags: accrued exceptions cleared</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memset(&amp;current-&gt;thread.fstate, 0,</span>
<span class="p_add">+		sizeof(struct user_fpregs_struct));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)</span>
<span class="p_add">+{</span>
<span class="p_add">+	fstate_save(src, task_pt_regs(src));</span>
<span class="p_add">+	*dst = *src;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int copy_thread(unsigned long clone_flags, unsigned long usp,</span>
<span class="p_add">+	unsigned long arg, struct task_struct *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs *childregs = task_pt_regs(p);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* p-&gt;thread holds context to be restored by __switch_to() */</span>
<span class="p_add">+	if (unlikely(p-&gt;flags &amp; PF_KTHREAD)) {</span>
<span class="p_add">+		/* Kernel thread */</span>
<span class="p_add">+		const register unsigned long gp __asm__ (&quot;gp&quot;);</span>
<span class="p_add">+		memset(childregs, 0, sizeof(struct pt_regs));</span>
<span class="p_add">+		childregs-&gt;gp = gp;</span>
<span class="p_add">+		childregs-&gt;sstatus = SR_PS | SR_PIE; /* Supervisor, irqs on */</span>
<span class="p_add">+</span>
<span class="p_add">+		p-&gt;thread.ra = (unsigned long)ret_from_kernel_thread;</span>
<span class="p_add">+		p-&gt;thread.s[0] = usp; /* fn */</span>
<span class="p_add">+		p-&gt;thread.s[1] = arg;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		*childregs = *(current_pt_regs());</span>
<span class="p_add">+		if (usp) /* User fork */</span>
<span class="p_add">+			childregs-&gt;sp = usp;</span>
<span class="p_add">+		if (clone_flags &amp; CLONE_SETTLS)</span>
<span class="p_add">+			childregs-&gt;tp = childregs-&gt;a5;</span>
<span class="p_add">+		childregs-&gt;a0 = 0; /* Return value of fork() */</span>
<span class="p_add">+		p-&gt;thread.ra = (unsigned long)ret_from_fork;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	p-&gt;thread.sp = (unsigned long)childregs; /* kernel sp */</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c</span>
new file mode 100644
<span class="p_header">index 000000000000..69b3b2d10664</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/ptrace.c</span>
<span class="p_chunk">@@ -0,0 +1,147 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="p_add">+ * Copyright 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copied from arch/tile/kernel/ptrace.c</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/syscall.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;linux/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;linux/elf.h&gt;</span>
<span class="p_add">+#include &lt;linux/regset.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;linux/tracehook.h&gt;</span>
<span class="p_add">+#include &lt;trace/events/syscalls.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+enum riscv_regset {</span>
<span class="p_add">+	REGSET_X,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Get registers from task and ready the result for userspace.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static char *getregs(struct task_struct *child, struct pt_regs *uregs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*uregs = *task_pt_regs(child);</span>
<span class="p_add">+	return (char *)uregs;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Put registers back to task. */</span>
<span class="p_add">+static void putregs(struct task_struct *child, struct pt_regs *uregs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs *regs = task_pt_regs(child);</span>
<span class="p_add">+	*regs = *uregs;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_gpr_get(struct task_struct *target,</span>
<span class="p_add">+			 const struct user_regset *regset,</span>
<span class="p_add">+			 unsigned int pos, unsigned int count,</span>
<span class="p_add">+			 void *kbuf, void __user *ubuf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs regs;</span>
<span class="p_add">+</span>
<span class="p_add">+	getregs(target, &amp;regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	return user_regset_copyout(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;regs, 0,</span>
<span class="p_add">+				   sizeof(regs));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_gpr_set(struct task_struct *target,</span>
<span class="p_add">+			 const struct user_regset *regset,</span>
<span class="p_add">+			 unsigned int pos, unsigned int count,</span>
<span class="p_add">+			 const void *kbuf, const void __user *ubuf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	struct pt_regs regs;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;regs, 0,</span>
<span class="p_add">+				 sizeof(regs));</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	putregs(target, &amp;regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct user_regset riscv_user_regset[] = {</span>
<span class="p_add">+	[REGSET_X] = {</span>
<span class="p_add">+		.core_note_type = NT_PRSTATUS,</span>
<span class="p_add">+		.n = ELF_NGREG,</span>
<span class="p_add">+		.size = sizeof(elf_greg_t),</span>
<span class="p_add">+		.align = sizeof(elf_greg_t),</span>
<span class="p_add">+		.get = &amp;riscv_gpr_get,</span>
<span class="p_add">+		.set = &amp;riscv_gpr_set,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct user_regset_view riscv_user_native_view = {</span>
<span class="p_add">+	.name = &quot;riscv&quot;,</span>
<span class="p_add">+	.e_machine = EM_RISCV,</span>
<span class="p_add">+	.regsets = riscv_user_regset,</span>
<span class="p_add">+	.n = ARRAY_SIZE(riscv_user_regset),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+const struct user_regset_view *task_user_regset_view(struct task_struct *task)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;riscv_user_native_view;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void ptrace_disable(struct task_struct *child)</span>
<span class="p_add">+{</span>
<span class="p_add">+	clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long arch_ptrace(struct task_struct *child, long request,</span>
<span class="p_add">+		 unsigned long addr, unsigned long data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long ret = -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (request) {</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		ret = ptrace_request(child, request, addr, data);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Allows PTRACE_SYSCALL to work.  These are called from entry.S in</span>
<span class="p_add">+ * {handle,ret_from}_syscall.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void do_syscall_trace_enter(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (test_thread_flag(TIF_SYSCALL_TRACE))</span>
<span class="p_add">+		if (tracehook_report_syscall_entry(regs))</span>
<span class="p_add">+			syscall_set_nr(current, regs, -1);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS</span>
<span class="p_add">+	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))</span>
<span class="p_add">+		trace_sys_enter(regs, syscall_get_nr(current, regs));</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_syscall_trace_exit(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (test_thread_flag(TIF_SYSCALL_TRACE))</span>
<span class="p_add">+		tracehook_report_syscall_exit(regs, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS</span>
<span class="p_add">+	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))</span>
<span class="p_add">+		trace_sys_exit(regs, regs-&gt;regs[0]);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/reset.c b/arch/riscv/kernel/reset.c</span>
new file mode 100644
<span class="p_header">index 000000000000..2a53d26ffdd6</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/reset.c</span>
<span class="p_chunk">@@ -0,0 +1,36 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/reboot.h&gt;</span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void (*pm_power_off)(void) = machine_power_off;</span>
<span class="p_add">+EXPORT_SYMBOL(pm_power_off);</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_restart(char *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	do_kernel_restart(cmd);</span>
<span class="p_add">+	while (1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_halt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	machine_power_off();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_power_off(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sbi_shutdown();</span>
<span class="p_add">+	while (1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/riscv_ksyms.c b/arch/riscv/kernel/riscv_ksyms.c</span>
new file mode 100644
<span class="p_header">index 000000000000..ab0db6d48101</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/riscv_ksyms.c</span>
<span class="p_chunk">@@ -0,0 +1,16 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 Zihao Yu</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Assembly functions that may be used (directly or indirectly) by modules</span>
<span class="p_add">+ */</span>
<span class="p_add">+EXPORT_SYMBOL(__copy_user);</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/riscv/kernel/setup.c b/arch/riscv/kernel/setup.c</span>
new file mode 100644
<span class="p_header">index 000000000000..9ed70e84d74e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/setup.c</span>
<span class="p_chunk">@@ -0,0 +1,240 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Sunplus Core Technology Co., Ltd.</span>
<span class="p_add">+ *  Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ *  Lennox Wu &lt;lennox.wu@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, see the file COPYING, or write</span>
<span class="p_add">+ * to the Free Software Foundation, Inc.,</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
<span class="p_add">+#include &lt;linux/console.h&gt;</span>
<span class="p_add">+#include &lt;linux/screen_info.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_fdt.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DUMMY_CONSOLE</span>
<span class="p_add">+struct screen_info screen_info = {</span>
<span class="p_add">+	.orig_video_lines	= 30,</span>
<span class="p_add">+	.orig_video_cols	= 80,</span>
<span class="p_add">+	.orig_video_mode	= 0,</span>
<span class="p_add">+	.orig_video_ega_bx	= 0,</span>
<span class="p_add">+	.orig_video_isVGA	= 1,</span>
<span class="p_add">+	.orig_video_points	= 8</span>
<span class="p_add">+};</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_BOOL</span>
<span class="p_add">+static char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_BOOL */</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long va_pa_offset;</span>
<span class="p_add">+unsigned long pfn_base;</span>
<span class="p_add">+</span>
<span class="p_add">+/* The lucky hart to first increment this variable will boot the other cores */</span>
<span class="p_add">+atomic_t hart_lottery;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+static void __init setup_initrd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern char __initramfs_start[];</span>
<span class="p_add">+	extern unsigned long __initramfs_size;</span>
<span class="p_add">+	unsigned long size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__initramfs_size &gt; 0) {</span>
<span class="p_add">+		initrd_start = (unsigned long)(&amp;__initramfs_start);</span>
<span class="p_add">+		initrd_end = initrd_start + __initramfs_size;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (initrd_start &gt;= initrd_end) {</span>
<span class="p_add">+		printk(KERN_INFO &quot;initrd not found or empty&quot;);</span>
<span class="p_add">+		goto disable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (__pa(initrd_end) &gt; PFN_PHYS(max_low_pfn)) {</span>
<span class="p_add">+		printk(KERN_ERR &quot;initrd extends beyond end of memory&quot;);</span>
<span class="p_add">+		goto disable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	size =  initrd_end - initrd_start;</span>
<span class="p_add">+	memblock_reserve(__pa(initrd_start), size);</span>
<span class="p_add">+	initrd_below_start_ok = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(KERN_INFO &quot;Initial ramdisk at: 0x%p (%lu bytes)\n&quot;,</span>
<span class="p_add">+		(void *)(initrd_start), size);</span>
<span class="p_add">+	return;</span>
<span class="p_add">+disable:</span>
<span class="p_add">+	printk(KERN_CONT &quot; - disabling initrd\n&quot;);</span>
<span class="p_add">+	initrd_start = 0;</span>
<span class="p_add">+	initrd_end = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+</span>
<span class="p_add">+pgd_t swapper_pg_dir[PTRS_PER_PGD] __page_aligned_bss;</span>
<span class="p_add">+pgd_t trampoline_pg_dir[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __PAGETABLE_PMD_FOLDED</span>
<span class="p_add">+#define NUM_SWAPPER_PMDS ((uintptr_t)-PAGE_OFFSET &gt;&gt; PGDIR_SHIFT)</span>
<span class="p_add">+pmd_t swapper_pmd[PTRS_PER_PMD*((-PAGE_OFFSET)/PGDIR_SIZE)] __page_aligned_bss;</span>
<span class="p_add">+pmd_t trampoline_pmd[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void __init setup_vm(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern char _start;</span>
<span class="p_add">+	uintptr_t i;</span>
<span class="p_add">+	uintptr_t pa = (uintptr_t) &amp;_start;</span>
<span class="p_add">+	pgprot_t prot = __pgprot(pgprot_val(PAGE_KERNEL) | _PAGE_EXEC);</span>
<span class="p_add">+</span>
<span class="p_add">+	va_pa_offset = PAGE_OFFSET - pa;</span>
<span class="p_add">+	pfn_base = PFN_DOWN(pa);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Sanity check alignment and size */</span>
<span class="p_add">+	BUG_ON((PAGE_OFFSET % PGDIR_SIZE) != 0);</span>
<span class="p_add">+	BUG_ON((pa % (PAGE_SIZE * PTRS_PER_PTE)) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __PAGETABLE_PMD_FOLDED</span>
<span class="p_add">+	trampoline_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD] =</span>
<span class="p_add">+		pfn_pgd(PFN_DOWN((uintptr_t)trampoline_pmd),</span>
<span class="p_add">+			__pgprot(_PAGE_TABLE));</span>
<span class="p_add">+	trampoline_pmd[0] = pfn_pmd(PFN_DOWN(pa), prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; (-PAGE_OFFSET)/PGDIR_SIZE; ++i) {</span>
<span class="p_add">+		size_t o = (PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD + i;</span>
<span class="p_add">+		swapper_pg_dir[o] =</span>
<span class="p_add">+			pfn_pgd(PFN_DOWN((uintptr_t)swapper_pmd) + i,</span>
<span class="p_add">+				__pgprot(_PAGE_TABLE));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(swapper_pmd); i++)</span>
<span class="p_add">+		swapper_pmd[i] = pfn_pmd(PFN_DOWN(pa + i * PMD_SIZE), prot);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	trampoline_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD] =</span>
<span class="p_add">+		pfn_pgd(PFN_DOWN(pa), prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; (-PAGE_OFFSET)/PGDIR_SIZE; ++i) {</span>
<span class="p_add">+		size_t o = (PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD + i;</span>
<span class="p_add">+		swapper_pg_dir[o] =</span>
<span class="p_add">+			pfn_pgd(PFN_DOWN(pa + i * PGDIR_SIZE), prot);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init sbi_save(unsigned int hartid, void *dtb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	early_init_dt_scan(__va(dtb));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Allow the user to manually add a memory region (in case DTS is broken); &quot;mem_end=nn[KkMmGg]&quot; */</span>
<span class="p_add">+static int __init mem_end_override(char *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	resource_size_t base, end;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!p)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	base = (uintptr_t) __pa(PAGE_OFFSET);</span>
<span class="p_add">+	end = memparse(p, &amp;p) &amp; PMD_MASK;</span>
<span class="p_add">+	if (end == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	memblock_add(base, end - base);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+early_param(&quot;mem_end&quot;, mem_end_override);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init setup_bootmem(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct memblock_region *reg;</span>
<span class="p_add">+	phys_addr_t mem_size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the memory region containing the kernel */</span>
<span class="p_add">+	for_each_memblock(memory, reg) {</span>
<span class="p_add">+		phys_addr_t vmlinux_end = __pa(_end);</span>
<span class="p_add">+		phys_addr_t end = reg-&gt;base + reg-&gt;size;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (reg-&gt;base &lt;= vmlinux_end &amp;&amp; vmlinux_end &lt;= end) {</span>
<span class="p_add">+			/* Reserve from the start of the region to the end of</span>
<span class="p_add">+			 * the kernel</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			memblock_reserve(reg-&gt;base, vmlinux_end - reg-&gt;base);</span>
<span class="p_add">+			mem_size = min(reg-&gt;size, (phys_addr_t)-PAGE_OFFSET);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	BUG_ON(mem_size == 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_max_mapnr(PFN_DOWN(mem_size));</span>
<span class="p_add">+	max_low_pfn = pfn_base + PFN_DOWN(mem_size);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+	setup_initrd();</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+</span>
<span class="p_add">+	early_init_fdt_reserve_self();</span>
<span class="p_add">+	early_init_fdt_scan_reserved_mem();</span>
<span class="p_add">+	memblock_allow_resize();</span>
<span class="p_add">+	memblock_dump_all();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_arch(char **cmdline_p)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_BOOL</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_OVERRIDE</span>
<span class="p_add">+	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	if (builtin_cmdline[0] != &#39;\0&#39;) {</span>
<span class="p_add">+		/* Append bootloader command line to built-in */</span>
<span class="p_add">+		strlcat(builtin_cmdline, &quot; &quot;, COMMAND_LINE_SIZE);</span>
<span class="p_add">+		strlcat(builtin_cmdline, boot_command_line, COMMAND_LINE_SIZE);</span>
<span class="p_add">+		strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_OVERRIDE */</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_BOOL */</span>
<span class="p_add">+	*cmdline_p = boot_command_line;</span>
<span class="p_add">+</span>
<span class="p_add">+	parse_early_param();</span>
<span class="p_add">+</span>
<span class="p_add">+	init_mm.start_code = (unsigned long) _stext;</span>
<span class="p_add">+	init_mm.end_code   = (unsigned long) _etext;</span>
<span class="p_add">+	init_mm.end_data   = (unsigned long) _edata;</span>
<span class="p_add">+	init_mm.brk        = (unsigned long) _end;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_bootmem();</span>
<span class="p_add">+	paging_init();</span>
<span class="p_add">+	unflatten_device_tree();</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	setup_smp();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DUMMY_CONSOLE</span>
<span class="p_add">+	conswitchp = &amp;dummy_con;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init riscv_device_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+subsys_initcall_sync(riscv_device_init);</span>
<span class="p_header">diff --git a/arch/riscv/kernel/signal.c b/arch/riscv/kernel/signal.c</span>
new file mode 100644
<span class="p_header">index 000000000000..ea14c47f28ac</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/signal.c</span>
<span class="p_chunk">@@ -0,0 +1,257 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Sunplus Core Technology Co., Ltd.</span>
<span class="p_add">+ *  Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ *  Lennox Wu &lt;lennox.wu@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, see the file COPYING, or write</span>
<span class="p_add">+ * to the Free Software Foundation, Inc.,</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/syscalls.h&gt;</span>
<span class="p_add">+#include &lt;linux/tracehook.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/ucontext.h&gt;</span>
<span class="p_add">+#include &lt;asm/vdso.h&gt;</span>
<span class="p_add">+#include &lt;asm/switch_to.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DEBUG_SIG 0</span>
<span class="p_add">+</span>
<span class="p_add">+struct rt_sigframe {</span>
<span class="p_add">+	struct siginfo info;</span>
<span class="p_add">+	struct ucontext uc;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static long restore_sigcontext(struct pt_regs *regs,</span>
<span class="p_add">+	struct sigcontext __user *sc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_struct *task = current;</span>
<span class="p_add">+	long err;</span>
<span class="p_add">+	/* sc_regs is structured the same as the start of pt_regs */</span>
<span class="p_add">+	err = __copy_from_user(regs, &amp;sc-&gt;sc_regs, sizeof(sc-&gt;sc_regs));</span>
<span class="p_add">+	err |= __copy_from_user(&amp;task-&gt;thread.fstate, &amp;sc-&gt;sc_fpregs,</span>
<span class="p_add">+		sizeof(sc-&gt;sc_fpregs));</span>
<span class="p_add">+	if (likely(!err))</span>
<span class="p_add">+		fstate_restore(task, regs);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+SYSCALL_DEFINE0(rt_sigreturn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs *regs = current_pt_regs();</span>
<span class="p_add">+	struct rt_sigframe __user *frame;</span>
<span class="p_add">+	struct task_struct *task;</span>
<span class="p_add">+	sigset_t set;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Always make any pending restarted system calls return -EINTR */</span>
<span class="p_add">+	current-&gt;restart_block.fn = do_no_restart_syscall;</span>
<span class="p_add">+</span>
<span class="p_add">+	frame = (struct rt_sigframe __user *)regs-&gt;sp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))</span>
<span class="p_add">+		goto badframe;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__copy_from_user(&amp;set, &amp;frame-&gt;uc.uc_sigmask, sizeof(set)))</span>
<span class="p_add">+		goto badframe;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_current_blocked(&amp;set);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (restore_sigcontext(regs, &amp;frame-&gt;uc.uc_mcontext))</span>
<span class="p_add">+		goto badframe;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (restore_altstack(&amp;frame-&gt;uc.uc_stack))</span>
<span class="p_add">+		goto badframe;</span>
<span class="p_add">+</span>
<span class="p_add">+	return regs-&gt;a0;</span>
<span class="p_add">+</span>
<span class="p_add">+badframe:</span>
<span class="p_add">+	task = current;</span>
<span class="p_add">+	if (show_unhandled_signals) {</span>
<span class="p_add">+		pr_info_ratelimited(</span>
<span class="p_add">+			&quot;%s[%d]: bad frame in %s: frame=%p pc=%p sp=%p\n&quot;,</span>
<span class="p_add">+			task-&gt;comm, task_pid_nr(task), __func__,</span>
<span class="p_add">+			frame, (void *)regs-&gt;sepc, (void *)regs-&gt;sp);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	force_sig(SIGSEGV, task);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static long setup_sigcontext(struct sigcontext __user *sc,</span>
<span class="p_add">+	struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_struct *task = current;</span>
<span class="p_add">+	long err;</span>
<span class="p_add">+	/* sc_regs is structured the same as the start of pt_regs */</span>
<span class="p_add">+	err = __copy_to_user(&amp;sc-&gt;sc_regs, regs, sizeof(sc-&gt;sc_regs));</span>
<span class="p_add">+	fstate_save(task, regs);</span>
<span class="p_add">+	err |= __copy_to_user(&amp;sc-&gt;sc_fpregs, &amp;task-&gt;thread.fstate,</span>
<span class="p_add">+		sizeof(sc-&gt;sc_fpregs));</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __user *get_sigframe(struct ksignal *ksig,</span>
<span class="p_add">+	struct pt_regs *regs, size_t framesize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long sp;</span>
<span class="p_add">+	/* Default to using normal stack */</span>
<span class="p_add">+	sp = regs-&gt;sp;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we are on the alternate signal stack and would overflow it, don&#39;t.</span>
<span class="p_add">+	 * Return an always-bogus address instead so we will die with SIGSEGV.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (on_sig_stack(sp) &amp;&amp; !likely(on_sig_stack(sp - framesize)))</span>
<span class="p_add">+		return (void __user __force *)(-1UL);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* This is the X/Open sanctioned signal stack switching. */</span>
<span class="p_add">+	sp = sigsp(sp, ksig) - framesize;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Align the stack frame. */</span>
<span class="p_add">+	sp &amp;= ~0xfUL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return (void __user *)sp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int setup_rt_frame(struct ksignal *ksig, sigset_t *set,</span>
<span class="p_add">+	struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rt_sigframe __user *frame;</span>
<span class="p_add">+	long err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	frame = get_sigframe(ksig, regs, sizeof(*frame));</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	err |= copy_siginfo_to_user(&amp;frame-&gt;info, &amp;ksig-&gt;info);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Create the ucontext. */</span>
<span class="p_add">+	err |= __put_user(0, &amp;frame-&gt;uc.uc_flags);</span>
<span class="p_add">+	err |= __put_user(NULL, &amp;frame-&gt;uc.uc_link);</span>
<span class="p_add">+	err |= __save_altstack(&amp;frame-&gt;uc.uc_stack, regs-&gt;sp);</span>
<span class="p_add">+	err |= setup_sigcontext(&amp;frame-&gt;uc.uc_mcontext, regs);</span>
<span class="p_add">+	err |= __copy_to_user(&amp;frame-&gt;uc.uc_sigmask, set, sizeof(*set));</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up to return from userspace. */</span>
<span class="p_add">+	regs-&gt;ra = (unsigned long)VDSO_SYMBOL(</span>
<span class="p_add">+		current-&gt;mm-&gt;context.vdso, rt_sigreturn);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set up registers for signal handler.</span>
<span class="p_add">+	 * Registers that we don&#39;t modify keep the value they had from</span>
<span class="p_add">+	 * user-space at the time we took the signal.</span>
<span class="p_add">+	 * We always pass siginfo and mcontext, regardless of SA_SIGINFO,</span>
<span class="p_add">+	 * since some things rely on this (e.g. glibc&#39;s debug/segfault.c).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regs-&gt;sepc = (unsigned long)ksig-&gt;ka.sa.sa_handler;</span>
<span class="p_add">+	regs-&gt;sp = (unsigned long)frame;</span>
<span class="p_add">+	regs-&gt;a0 = ksig-&gt;sig;                     /* a0: signal number */</span>
<span class="p_add">+	regs-&gt;a1 = (unsigned long)(&amp;frame-&gt;info); /* a1: siginfo pointer */</span>
<span class="p_add">+	regs-&gt;a2 = (unsigned long)(&amp;frame-&gt;uc);   /* a2: ucontext pointer */</span>
<span class="p_add">+</span>
<span class="p_add">+#if DEBUG_SIG</span>
<span class="p_add">+	pr_info(&quot;SIG deliver (%s:%d): sig=%d pc=%p ra=%p sp=%p\n&quot;,</span>
<span class="p_add">+		current-&gt;comm, task_pid_nr(current), ksig-&gt;sig,</span>
<span class="p_add">+		(void *)regs-&gt;sepc, (void *)regs-&gt;ra, frame);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sigset_t *oldset = sigmask_to_save();</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Are we from a system call? */</span>
<span class="p_add">+	if (regs-&gt;scause == EXC_SYSCALL) {</span>
<span class="p_add">+		/* If so, check system call restarting.. */</span>
<span class="p_add">+		switch (regs-&gt;a0) {</span>
<span class="p_add">+		case -ERESTART_RESTARTBLOCK:</span>
<span class="p_add">+		case -ERESTARTNOHAND:</span>
<span class="p_add">+			regs-&gt;a0 = -EINTR;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		case -ERESTARTSYS:</span>
<span class="p_add">+			if (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTART)) {</span>
<span class="p_add">+				regs-&gt;a0 = -EINTR;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/* fallthrough */</span>
<span class="p_add">+		case -ERESTARTNOINTR:</span>
<span class="p_add">+			regs-&gt;sepc -= 0x4;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up the stack frame */</span>
<span class="p_add">+	ret = setup_rt_frame(ksig, oldset, regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	signal_setup_done(ret, ksig, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void do_signal(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ksignal ksig;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_signal(&amp;ksig)) {</span>
<span class="p_add">+		/* Actually deliver the signal */</span>
<span class="p_add">+		handle_signal(&amp;ksig, regs);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Did we come from a system call? */</span>
<span class="p_add">+	if (regs-&gt;scause == EXC_SYSCALL) {</span>
<span class="p_add">+		/* Restart the system call - no handlers present */</span>
<span class="p_add">+		switch (regs-&gt;a0) {</span>
<span class="p_add">+		case -ERESTARTNOHAND:</span>
<span class="p_add">+		case -ERESTARTSYS:</span>
<span class="p_add">+		case -ERESTARTNOINTR:</span>
<span class="p_add">+			regs-&gt;sepc -= 0x4;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case -ERESTART_RESTARTBLOCK:</span>
<span class="p_add">+			regs-&gt;a7 = __NR_restart_syscall;</span>
<span class="p_add">+			regs-&gt;sepc -= 0x4;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If there is no signal to deliver, we just put the saved</span>
<span class="p_add">+	 * sigmask back.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	restore_saved_sigmask();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * notification of userspace execution resumption</span>
<span class="p_add">+ * - triggered by the _TIF_WORK_MASK flags</span>
<span class="p_add">+ */</span>
<span class="p_add">+asmlinkage void do_notify_resume(struct pt_regs *regs,</span>
<span class="p_add">+	unsigned long thread_info_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Handle pending signal delivery */</span>
<span class="p_add">+	if (thread_info_flags &amp; _TIF_SIGPENDING)</span>
<span class="p_add">+		do_signal(regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (thread_info_flags &amp; _TIF_NOTIFY_RESUME) {</span>
<span class="p_add">+		clear_thread_flag(TIF_NOTIFY_RESUME);</span>
<span class="p_add">+		tracehook_notify_resume(regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/smp.c b/arch/riscv/kernel/smp.c</span>
new file mode 100644
<span class="p_header">index 000000000000..b65c0e1020e3</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/smp.c</span>
<span class="p_chunk">@@ -0,0 +1,110 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SMP initialisation and IPI support</span>
<span class="p_add">+ * Based on arch/arm64/kernel/smp.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/smp.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* A collection of single bit ipi messages.  */</span>
<span class="p_add">+static struct {</span>
<span class="p_add">+	unsigned long bits ____cacheline_aligned;</span>
<span class="p_add">+} ipi_data[NR_CPUS] __cacheline_aligned;</span>
<span class="p_add">+</span>
<span class="p_add">+enum ipi_message_type {</span>
<span class="p_add">+	IPI_RESCHEDULE,</span>
<span class="p_add">+	IPI_CALL_FUNC,</span>
<span class="p_add">+	IPI_MAX</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+irqreturn_t handle_ipi(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *pending_ipis = &amp;ipi_data[smp_processor_id()].bits;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear pending IPI */</span>
<span class="p_add">+	csr_clear(sip, SIE_SSIE);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (true) {</span>
<span class="p_add">+		unsigned long ops;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Order bit clearing and data access. */</span>
<span class="p_add">+		mb(); // test</span>
<span class="p_add">+</span>
<span class="p_add">+		ops = xchg(pending_ipis, 0);</span>
<span class="p_add">+		if (ops == 0)</span>
<span class="p_add">+			return IRQ_HANDLED;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ops &amp; (1 &lt;&lt; IPI_RESCHEDULE))</span>
<span class="p_add">+			scheduler_ipi();</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ops &amp; (1 &lt;&lt; IPI_CALL_FUNC))</span>
<span class="p_add">+			generic_smp_call_function_interrupt();</span>
<span class="p_add">+</span>
<span class="p_add">+		BUG_ON((ops &gt;&gt; IPI_MAX) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Order data access and bit testing. */</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void</span>
<span class="p_add">+send_ipi_message(const struct cpumask *to_whom, enum ipi_message_type operation)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	for_each_cpu(i, to_whom)</span>
<span class="p_add">+		set_bit(operation, &amp;ipi_data[i].bits);</span>
<span class="p_add">+</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	sbi_send_ipi(cpumask_bits(to_whom));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_ipi_mask(struct cpumask *mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(mask, IPI_CALL_FUNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_single_ipi(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(cpumask_of(cpu), IPI_CALL_FUNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void ipi_stop(void *unused)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (1)</span>
<span class="p_add">+		wait_for_interrupt();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_stop(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu(ipi_stop, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_reschedule(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(cpumask_of(cpu), IPI_RESCHEDULE);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/smpboot.c b/arch/riscv/kernel/smpboot.c</span>
new file mode 100644
<span class="p_header">index 000000000000..7043bbbfbc1e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/smpboot.c</span>
<span class="p_chunk">@@ -0,0 +1,103 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SMP initialisation and IPI support</span>
<span class="p_add">+ * Based on arch/arm64/kernel/smp.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel_stat.h&gt;</span>
<span class="p_add">+#include &lt;linux/notifier.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/percpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void *__cpu_up_stack_pointer[NR_CPUS];</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_boot_cpu(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_cpus(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_smp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *dn = NULL;</span>
<span class="p_add">+	int hart, im_okay_therefore_i_am = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((dn = of_find_node_by_type(dn, &quot;cpu&quot;))) {</span>
<span class="p_add">+		hart = riscv_of_processor_hart(dn);</span>
<span class="p_add">+		if (hart &gt;= 0) {</span>
<span class="p_add">+			set_cpu_possible(hart, true);</span>
<span class="p_add">+			set_cpu_present(hart, true);</span>
<span class="p_add">+			if (hart == smp_processor_id()) {</span>
<span class="p_add">+				BUG_ON(im_okay_therefore_i_am);</span>
<span class="p_add">+				im_okay_therefore_i_am = 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!im_okay_therefore_i_am);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int __cpu_up(unsigned int cpu, struct task_struct *tidle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Signal cpu to start */</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	__cpu_up_stack_pointer[cpu] = task_stack_page(tidle) + THREAD_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!cpu_online(cpu))</span>
<span class="p_add">+		cpu_relax();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_cpus_done(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * C entry point for a secondary processor.</span>
<span class="p_add">+ */</span>
<span class="p_add">+asmlinkage void __init smp_callin(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = &amp;init_mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All kernel threads share the same mm context.  */</span>
<span class="p_add">+	atomic_inc(&amp;mm-&gt;mm_count);</span>
<span class="p_add">+	current-&gt;active_mm = mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	trap_init();</span>
<span class="p_add">+	init_clockevent();</span>
<span class="p_add">+	notify_cpu_starting(smp_processor_id());</span>
<span class="p_add">+	set_cpu_online(smp_processor_id(), 1);</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c</span>
new file mode 100644
<span class="p_header">index 000000000000..109f5120d5c7</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/stacktrace.c</span>
<span class="p_chunk">@@ -0,0 +1,177 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2008 ARM Limited</span>
<span class="p_add">+ * Copyright (C) 2014 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;linux/kallsyms.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/debug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;linux/stacktrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_FRAME_POINTER</span>
<span class="p_add">+</span>
<span class="p_add">+struct stackframe {</span>
<span class="p_add">+	unsigned long fp;</span>
<span class="p_add">+	unsigned long ra;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void notrace walk_stackframe(struct task_struct *task,</span>
<span class="p_add">+	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long fp, sp, pc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs) {</span>
<span class="p_add">+		fp = GET_FP(regs);</span>
<span class="p_add">+		sp = GET_USP(regs);</span>
<span class="p_add">+		pc = GET_IP(regs);</span>
<span class="p_add">+	} else if (task == NULL || task == current) {</span>
<span class="p_add">+		const register unsigned long current_sp __asm__ (&quot;sp&quot;);</span>
<span class="p_add">+		fp = (unsigned long)__builtin_frame_address(0);</span>
<span class="p_add">+		sp = current_sp;</span>
<span class="p_add">+		pc = (unsigned long)walk_stackframe;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* task blocked in __switch_to */</span>
<span class="p_add">+		fp = task-&gt;thread.s[0];</span>
<span class="p_add">+		sp = task-&gt;thread.sp;</span>
<span class="p_add">+		pc = task-&gt;thread.ra;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (;;) {</span>
<span class="p_add">+		unsigned long low, high;</span>
<span class="p_add">+		struct stackframe *frame;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (unlikely(!__kernel_text_address(pc) || fn(pc, arg)))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Validate frame pointer */</span>
<span class="p_add">+		low = sp + sizeof(struct stackframe);</span>
<span class="p_add">+		high = ALIGN(sp, THREAD_SIZE);</span>
<span class="p_add">+		if (unlikely(fp &lt; low || fp &gt; high || fp &amp; 0x7))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		/* Unwind stack frame */</span>
<span class="p_add">+		frame = (struct stackframe *)fp - 1;</span>
<span class="p_add">+		sp = fp;</span>
<span class="p_add">+		fp = frame-&gt;fp;</span>
<span class="p_add">+		pc = frame-&gt;ra - 0x4;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#else /* !CONFIG_FRAME_POINTER */</span>
<span class="p_add">+</span>
<span class="p_add">+static void notrace walk_stackframe(struct task_struct *task,</span>
<span class="p_add">+	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long sp, pc;</span>
<span class="p_add">+	unsigned long *ksp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs) {</span>
<span class="p_add">+		sp = GET_USP(regs);</span>
<span class="p_add">+		pc = GET_IP(regs);</span>
<span class="p_add">+	} else if (task == NULL || task == current) {</span>
<span class="p_add">+		const register unsigned long current_sp __asm__ (&quot;sp&quot;);</span>
<span class="p_add">+		sp = current_sp;</span>
<span class="p_add">+		pc = (unsigned long)walk_stackframe;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* task blocked in __switch_to */</span>
<span class="p_add">+		sp = task-&gt;thread.sp;</span>
<span class="p_add">+		pc = task-&gt;thread.ra;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(sp &amp; 0x7))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	ksp = (unsigned long *)sp;</span>
<span class="p_add">+	while (!kstack_end(ksp)) {</span>
<span class="p_add">+		if (__kernel_text_address(pc) &amp;&amp; unlikely(fn(pc, arg)))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		pc = (*ksp++) - 0x4;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_FRAME_POINTER */</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static bool print_trace_address(unsigned long pc, void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	print_ip_sym(pc);</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void show_stack(struct task_struct *task, unsigned long *sp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	printk(&quot;Call Trace:\n&quot;);</span>
<span class="p_add">+	walk_stackframe(task, NULL, print_trace_address, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static bool save_wchan(unsigned long pc, void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!in_sched_functions(pc)) {</span>
<span class="p_add">+		unsigned long *p = arg;</span>
<span class="p_add">+		*p = pc;</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long get_wchan(struct task_struct *task)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pc = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(task &amp;&amp; task != current &amp;&amp; task-&gt;state != TASK_RUNNING))</span>
<span class="p_add">+		walk_stackframe(task, NULL, save_wchan, &amp;pc);</span>
<span class="p_add">+	return pc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_STACKTRACE</span>
<span class="p_add">+</span>
<span class="p_add">+static bool __save_trace(unsigned long pc, void *arg, bool nosched)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct stack_trace *trace = arg;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(nosched &amp;&amp; in_sched_functions(pc)))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (unlikely(trace-&gt;skip &gt; 0)) {</span>
<span class="p_add">+		trace-&gt;skip--;</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	trace-&gt;entries[trace-&gt;nr_entries++] = pc;</span>
<span class="p_add">+	return (trace-&gt;nr_entries &gt;= trace-&gt;max_entries);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool save_trace(unsigned long pc, void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __save_trace(pc, arg, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Save stack-backtrace addresses into a stack_trace buffer.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)</span>
<span class="p_add">+{</span>
<span class="p_add">+	walk_stackframe(tsk, NULL, save_trace, trace);</span>
<span class="p_add">+	if (trace-&gt;nr_entries &lt; trace-&gt;max_entries)</span>
<span class="p_add">+		trace-&gt;entries[trace-&gt;nr_entries++] = ULONG_MAX;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(save_stack_trace_tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+void save_stack_trace(struct stack_trace *trace)</span>
<span class="p_add">+{</span>
<span class="p_add">+	save_stack_trace_tsk(NULL, trace);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(save_stack_trace);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_STACKTRACE */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/sys_riscv.c b/arch/riscv/kernel/sys_riscv.c</span>
new file mode 100644
<span class="p_header">index 000000000000..33d40a5da4a1</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/sys_riscv.c</span>
<span class="p_chunk">@@ -0,0 +1,85 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2014 Darius Rad &lt;darius@bluespec.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/syscalls.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_64BIT</span>
<span class="p_add">+SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,</span>
<span class="p_add">+	unsigned long, prot, unsigned long, flags,</span>
<span class="p_add">+	unsigned long, fd, off_t, offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(offset &amp; (~PAGE_MASK)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	return sys_mmap_pgoff(addr, len, prot, flags, fd, offset &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+SYSCALL_DEFINE6(mmap2, unsigned long, addr, unsigned long, len,</span>
<span class="p_add">+	unsigned long, prot, unsigned long, flags,</span>
<span class="p_add">+	unsigned long, fd, off_t, offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Note that the shift for mmap2 is constant (12),</span>
<span class="p_add">+	 * regardless of PAGE_SIZE</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(offset &amp; (~PAGE_MASK &gt;&gt; 12)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	return sys_mmap_pgoff(addr, len, prot, flags, fd,</span>
<span class="p_add">+		offset &gt;&gt; (PAGE_SHIFT - 12));</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* !CONFIG_64BIT */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SYSRISCV_ATOMIC</span>
<span class="p_add">+SYSCALL_DEFINE4(sysriscv, unsigned long, cmd, unsigned long, arg1,</span>
<span class="p_add">+	unsigned long, arg2, unsigned long, arg3)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	unsigned long prev;</span>
<span class="p_add">+	unsigned int *ptr;</span>
<span class="p_add">+	unsigned int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case RISCV_ATOMIC_CMPXCHG:</span>
<span class="p_add">+		ptr = (unsigned int *)arg1;</span>
<span class="p_add">+		if (!access_ok(VERIFY_WRITE, ptr, sizeof(unsigned int)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+		preempt_disable();</span>
<span class="p_add">+		raw_local_irq_save(flags);</span>
<span class="p_add">+		err = __get_user(prev, ptr);</span>
<span class="p_add">+		if (likely(!err &amp;&amp; prev == arg2))</span>
<span class="p_add">+			err = __put_user(arg3, ptr);</span>
<span class="p_add">+		raw_local_irq_restore(flags);</span>
<span class="p_add">+		preempt_enable();</span>
<span class="p_add">+</span>
<span class="p_add">+		return unlikely(err) ? err : prev;</span>
<span class="p_add">+</span>
<span class="p_add">+	case RISCV_ATOMIC_CMPXCHG64:</span>
<span class="p_add">+		ptr = (unsigned int *)arg1;</span>
<span class="p_add">+		if (!access_ok(VERIFY_WRITE, ptr, sizeof(unsigned long)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+		preempt_disable();</span>
<span class="p_add">+		raw_local_irq_save(flags);</span>
<span class="p_add">+		err = __get_user(prev, ptr);</span>
<span class="p_add">+		if (likely(!err &amp;&amp; prev == arg2))</span>
<span class="p_add">+			err = __put_user(arg3, ptr);</span>
<span class="p_add">+		raw_local_irq_restore(flags);</span>
<span class="p_add">+		preempt_enable();</span>
<span class="p_add">+</span>
<span class="p_add">+		return unlikely(err) ? err : prev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_SYSRISCV_ATOMIC */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/syscall_table.c b/arch/riscv/kernel/syscall_table.c</span>
new file mode 100644
<span class="p_header">index 000000000000..8fa239b67cbc</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/syscall_table.c</span>
<span class="p_chunk">@@ -0,0 +1,25 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/syscalls.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/syscalls.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#undef __SYSCALL</span>
<span class="p_add">+#define __SYSCALL(nr, call)	[nr] = (call),</span>
<span class="p_add">+</span>
<span class="p_add">+void *sys_call_table[__NR_syscalls] = {</span>
<span class="p_add">+	[0 ... __NR_syscalls - 1] = sys_ni_syscall,</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.c</span>
new file mode 100644
<span class="p_header">index 000000000000..3a4698199ecf</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/traps.c</span>
<span class="p_chunk">@@ -0,0 +1,183 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/debug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/kdebug.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+int show_unhandled_signals = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+extern asmlinkage void handle_exception(void);</span>
<span class="p_add">+</span>
<span class="p_add">+static DEFINE_SPINLOCK(die_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+void die(struct pt_regs *regs, const char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static int die_counter;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	oops_enter();</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;die_lock);</span>
<span class="p_add">+	console_verbose();</span>
<span class="p_add">+	bust_spinlocks(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;%s [#%d]\n&quot;, str, ++die_counter);</span>
<span class="p_add">+	print_modules();</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = notify_die(DIE_OOPS, str, regs, 0, regs-&gt;scause, SIGSEGV);</span>
<span class="p_add">+</span>
<span class="p_add">+	bust_spinlocks(0);</span>
<span class="p_add">+	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);</span>
<span class="p_add">+	spin_unlock_irq(&amp;die_lock);</span>
<span class="p_add">+	oops_exit();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (in_interrupt())</span>
<span class="p_add">+		panic(&quot;Fatal exception in interrupt&quot;);</span>
<span class="p_add">+	if (panic_on_oops)</span>
<span class="p_add">+		panic(&quot;Fatal exception&quot;);</span>
<span class="p_add">+	if (ret != NOTIFY_STOP)</span>
<span class="p_add">+		do_exit(SIGSEGV);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void do_trap_siginfo(int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	info.si_signo = signo;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = code;</span>
<span class="p_add">+	info.si_addr = (void __user *)addr;</span>
<span class="p_add">+	force_sig_info(signo, &amp;info, tsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_trap(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (show_unhandled_signals &amp;&amp; unhandled_signal(tsk, signo)</span>
<span class="p_add">+	    &amp;&amp; printk_ratelimit()) {</span>
<span class="p_add">+		pr_info(&quot;%s[%d]: unhandled signal %d code 0x%x at 0x&quot; REG_FMT,</span>
<span class="p_add">+			tsk-&gt;comm, task_pid_nr(tsk), signo, code, addr);</span>
<span class="p_add">+		print_vma_addr(KERN_CONT &quot; in &quot;, GET_IP(regs));</span>
<span class="p_add">+		pr_cont(&quot;\n&quot;);</span>
<span class="p_add">+		show_regs(regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	do_trap_siginfo(signo, code, addr, tsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void do_trap_error(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, const char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (user_mode(regs)) {</span>
<span class="p_add">+		do_trap(regs, signo, code, addr, current);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!fixup_exception(regs))</span>
<span class="p_add">+			die(regs, str);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define DO_ERROR_INFO(name, signo, code, str)				\</span>
<span class="p_add">+asmlinkage void name(struct pt_regs *regs)				\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	do_trap_error(regs, signo, code, regs-&gt;sepc, &quot;Oops - &quot; str);	\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_unknown,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;unknown exception&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;instruction address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_fault,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;instruction access fault&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_illegal,</span>
<span class="p_add">+	SIGILL, ILL_ILLOPC, &quot;illegal instruction&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_load_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;load address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_load_fault,</span>
<span class="p_add">+	SIGSEGV, SEGV_ACCERR, &quot;load access fault&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_store_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;store (or AMO) address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_store_fault,</span>
<span class="p_add">+	SIGSEGV, SEGV_ACCERR, &quot;store (or AMO) access fault&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_ecall_u,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;environment call from U-mode&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_ecall_s,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;environment call from S-mode&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_ecall_m,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;environment call from M-mode&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void do_trap_break(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+	if (!user_mode(regs)) {</span>
<span class="p_add">+		enum bug_trap_type type;</span>
<span class="p_add">+</span>
<span class="p_add">+		type = report_bug(regs-&gt;sepc, regs);</span>
<span class="p_add">+		switch (type) {</span>
<span class="p_add">+		case BUG_TRAP_TYPE_NONE:</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case BUG_TRAP_TYPE_WARN:</span>
<span class="p_add">+			regs-&gt;sepc += sizeof(bug_insn_t);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		case BUG_TRAP_TYPE_BUG:</span>
<span class="p_add">+			die(regs, &quot;Kernel BUG&quot;);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+	do_trap_siginfo(SIGTRAP, TRAP_BRKPT, regs-&gt;sepc, current);</span>
<span class="p_add">+	regs-&gt;sepc += 0x4;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+int is_valid_bugaddr(unsigned long pc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bug_insn_t insn;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pc &lt; PAGE_OFFSET)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (probe_kernel_address((bug_insn_t __user *)pc, insn))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return (insn == __BUG_INSN);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+void __init trap_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int hart = smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set sup0 scratch register to 0, indicating to exception vector</span>
<span class="p_add">+	 * that we are presently executing in the kernel</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	csr_write(sscratch, 0);</span>
<span class="p_add">+	/* Set the exception vector address */</span>
<span class="p_add">+	csr_write(stvec, &amp;handle_exception);</span>
<span class="p_add">+	/* Enable software interrupts and setup initial mask */</span>
<span class="p_add">+	csr_write(sie,</span>
<span class="p_add">+		  SIE_SSIE | atomic_long_read(&amp;per_cpu(riscv_early_sie, hart))</span>
<span class="p_add">+		);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso.c b/arch/riscv/kernel/vdso.c</span>
new file mode 100644
<span class="p_header">index 000000000000..e8a178df8144</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso.c</span>
<span class="p_chunk">@@ -0,0 +1,125 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2004 Benjamin Herrenschmidt, IBM Corp.</span>
<span class="p_add">+ *                    &lt;benh@kernel.crashing.org&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Limited</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/binfmts.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/vdso.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern char vdso_start[], vdso_end[];</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int vdso_pages;</span>
<span class="p_add">+static struct page **vdso_pagelist;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The vDSO data page.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static union {</span>
<span class="p_add">+	struct vdso_data	data;</span>
<span class="p_add">+	u8			page[PAGE_SIZE];</span>
<span class="p_add">+} vdso_data_store __page_aligned_data;</span>
<span class="p_add">+struct vdso_data *vdso_data = &amp;vdso_data_store.data;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init vdso_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdso_pages = (vdso_end - vdso_start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	vdso_pagelist =</span>
<span class="p_add">+		kcalloc(vdso_pages + 1, sizeof(struct page *), GFP_KERNEL);</span>
<span class="p_add">+	if (unlikely(vdso_pagelist == NULL)) {</span>
<span class="p_add">+		pr_err(&quot;vdso: pagelist allocation failed\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; vdso_pages; i++) {</span>
<span class="p_add">+		struct page *pg;</span>
<span class="p_add">+</span>
<span class="p_add">+		pg = virt_to_page(vdso_start + (i &lt;&lt; PAGE_SHIFT));</span>
<span class="p_add">+		ClearPageReserved(pg);</span>
<span class="p_add">+		vdso_pagelist[i] = pg;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	vdso_pagelist[i] = virt_to_page(vdso_data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+arch_initcall(vdso_init);</span>
<span class="p_add">+</span>
<span class="p_add">+int arch_setup_additional_pages(struct linux_binprm *bprm,</span>
<span class="p_add">+	int uses_interp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = current-&gt;mm;</span>
<span class="p_add">+	unsigned long vdso_base, vdso_len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdso_len = (vdso_pages + 1) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	down_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	vdso_base = get_unmapped_area(NULL, 0, vdso_len, 0, 0);</span>
<span class="p_add">+	if (unlikely(IS_ERR_VALUE(vdso_base))) {</span>
<span class="p_add">+		ret = vdso_base;</span>
<span class="p_add">+		goto end;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Put vDSO base into mm struct. We need to do this before calling</span>
<span class="p_add">+	 * install_special_mapping or the perf counter mmap tracking code</span>
<span class="p_add">+	 * will fail to recognise it as a vDSO (since arch_vma_name fails).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mm-&gt;context.vdso = (void *)vdso_base;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = install_special_mapping(mm, vdso_base, vdso_len,</span>
<span class="p_add">+		(VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC),</span>
<span class="p_add">+		vdso_pagelist);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(ret))</span>
<span class="p_add">+		mm-&gt;context.vdso = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+end:</span>
<span class="p_add">+	up_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const char *arch_vma_name(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (vma-&gt;vm_mm &amp;&amp; (vma-&gt;vm_start == (long)vma-&gt;vm_mm-&gt;context.vdso))</span>
<span class="p_add">+		return &quot;[vdso]&quot;;</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Function stubs to prevent linker errors when AT_SYSINFO_EHDR is defined</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+int in_gate_area_no_mm(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int in_gate_area(struct mm_struct *mm, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct vm_area_struct *get_gate_vma(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/.gitignore b/arch/riscv/kernel/vdso/.gitignore</span>
new file mode 100644
<span class="p_header">index 000000000000..f8b69d84238e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/.gitignore</span>
<span class="p_chunk">@@ -0,0 +1 @@</span> <span class="p_context"></span>
<span class="p_add">+vdso.lds</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/Makefile b/arch/riscv/kernel/vdso/Makefile</span>
new file mode 100644
<span class="p_header">index 000000000000..04f3ec75b217</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/Makefile</span>
<span class="p_chunk">@@ -0,0 +1,61 @@</span> <span class="p_context"></span>
<span class="p_add">+# Derived from arch/{arm64,tile}/kernel/vdso/Makefile</span>
<span class="p_add">+</span>
<span class="p_add">+obj-vdso := sigreturn.o</span>
<span class="p_add">+</span>
<span class="p_add">+# Build rules</span>
<span class="p_add">+targets := $(obj-vdso) vdso.so vdso.so.dbg</span>
<span class="p_add">+obj-vdso := $(addprefix $(obj)/, $(obj-vdso))</span>
<span class="p_add">+</span>
<span class="p_add">+#ccflags-y := -shared -fno-common -fno-builtin</span>
<span class="p_add">+#ccflags-y += -nostdlib -Wl,-soname=linux-vdso.so.1 \</span>
<span class="p_add">+		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)</span>
<span class="p_add">+</span>
<span class="p_add">+CFLAGS_vdso.so = $(c_flags)</span>
<span class="p_add">+CFLAGS_vdso.so.dbg = -shared -s -Wl,-soname=linux-vdso.so.1 \</span>
<span class="p_add">+	$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)</span>
<span class="p_add">+CFLAGS_vdso_syms.o = -r</span>
<span class="p_add">+</span>
<span class="p_add">+obj-y += vdso.o</span>
<span class="p_add">+</span>
<span class="p_add">+# We also create a special relocatable object that should mirror the symbol</span>
<span class="p_add">+# table and layout of the linked DSO.  With ld -R we can then refer to</span>
<span class="p_add">+# these symbols in the kernel code rather than hand-coded addresses.</span>
<span class="p_add">+extra-y += vdso.lds vdso-syms.o</span>
<span class="p_add">+$(obj)/built-in.o: $(obj)/vdso-syms.o</span>
<span class="p_add">+$(obj)/built-in.o: ld_flags += -R $(obj)/vdso-syms.o</span>
<span class="p_add">+</span>
<span class="p_add">+CPPFLAGS_vdso.lds += -P -C -U$(ARCH)</span>
<span class="p_add">+</span>
<span class="p_add">+# Force dependency</span>
<span class="p_add">+$(obj)/vdso.o : $(obj)/vdso.so</span>
<span class="p_add">+</span>
<span class="p_add">+# Link rule for the *.so file; *.lds must be first</span>
<span class="p_add">+$(obj)/vdso.so.dbg: $(src)/vdso.lds $(obj-vdso)</span>
<span class="p_add">+	$(call if_changed,vdsold)</span>
<span class="p_add">+$(obj)/vdso-syms.o: $(src)/vdso.lds $(obj-vdso)</span>
<span class="p_add">+	$(call if_changed,vdsold)</span>
<span class="p_add">+</span>
<span class="p_add">+# Strip rule for the *.so file</span>
<span class="p_add">+$(obj)/%.so: OBJCOPYFLAGS := -S</span>
<span class="p_add">+$(obj)/%.so: $(obj)/%.so.dbg FORCE</span>
<span class="p_add">+	$(call if_changed,objcopy)</span>
<span class="p_add">+</span>
<span class="p_add">+# Assembly rules for the *.S files</span>
<span class="p_add">+$(obj-vdso): %.o: %.S</span>
<span class="p_add">+	$(call if_changed_dep,vdsoas)</span>
<span class="p_add">+</span>
<span class="p_add">+# Actual build commands</span>
<span class="p_add">+quiet_cmd_vdsold = VDSOLD  $@</span>
<span class="p_add">+      cmd_vdsold = $(CC) $(c_flags) -nostdlib $(CFLAGS_$(@F)) -Wl,-n -Wl,-T $^ -o $@</span>
<span class="p_add">+quiet_cmd_vdsoas = VDSOAS  $@</span>
<span class="p_add">+      cmd_vdsoas = $(CC) $(a_flags) -c -o $@ $&lt;</span>
<span class="p_add">+</span>
<span class="p_add">+# Install commands for the unstripped file</span>
<span class="p_add">+quiet_cmd_vdso_install = INSTALL $@</span>
<span class="p_add">+      cmd_vdso_install = cp $(obj)/$@.dbg $(MODLIB)/vdso/$@</span>
<span class="p_add">+</span>
<span class="p_add">+vdso.so: $(obj)/vdso.so.dbg</span>
<span class="p_add">+	@mkdir -p $(MODLIB)/vdso</span>
<span class="p_add">+	$(call cmd,vdso_install)</span>
<span class="p_add">+</span>
<span class="p_add">+vdso_install: vdso.so</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/sigreturn.S b/arch/riscv/kernel/vdso/sigreturn.S</span>
new file mode 100644
<span class="p_header">index 000000000000..f5aa3d72acfb</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/sigreturn.S</span>
<span class="p_chunk">@@ -0,0 +1,24 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2014 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+ENTRY(__vdso_rt_sigreturn)</span>
<span class="p_add">+	.cfi_startproc</span>
<span class="p_add">+	.cfi_signal_frame</span>
<span class="p_add">+	li a7, __NR_rt_sigreturn</span>
<span class="p_add">+	scall</span>
<span class="p_add">+	.cfi_endproc</span>
<span class="p_add">+ENDPROC(__vdso_rt_sigreturn)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/vdso.S b/arch/riscv/kernel/vdso/vdso.S</span>
new file mode 100644
<span class="p_header">index 000000000000..7055de5f9174</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/vdso.S</span>
<span class="p_chunk">@@ -0,0 +1,27 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2014 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	__PAGE_ALIGNED_DATA</span>
<span class="p_add">+</span>
<span class="p_add">+	.globl vdso_start, vdso_end</span>
<span class="p_add">+	.balign PAGE_SIZE</span>
<span class="p_add">+vdso_start:</span>
<span class="p_add">+	.incbin &quot;arch/riscv/kernel/vdso/vdso.so&quot;</span>
<span class="p_add">+	.balign PAGE_SIZE</span>
<span class="p_add">+vdso_end:</span>
<span class="p_add">+</span>
<span class="p_add">+	.previous</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/vdso.lds.S b/arch/riscv/kernel/vdso/vdso.lds.S</span>
new file mode 100644
<span class="p_header">index 000000000000..24942cb25694</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/vdso.lds.S</span>
<span class="p_chunk">@@ -0,0 +1,76 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+OUTPUT_ARCH(riscv)</span>
<span class="p_add">+</span>
<span class="p_add">+SECTIONS</span>
<span class="p_add">+{</span>
<span class="p_add">+	. = SIZEOF_HEADERS;</span>
<span class="p_add">+</span>
<span class="p_add">+	.hash		: { *(.hash) }			:text</span>
<span class="p_add">+	.gnu.hash	: { *(.gnu.hash) }</span>
<span class="p_add">+	.dynsym		: { *(.dynsym) }</span>
<span class="p_add">+	.dynstr		: { *(.dynstr) }</span>
<span class="p_add">+	.gnu.version	: { *(.gnu.version) }</span>
<span class="p_add">+	.gnu.version_d	: { *(.gnu.version_d) }</span>
<span class="p_add">+	.gnu.version_r	: { *(.gnu.version_r) }</span>
<span class="p_add">+</span>
<span class="p_add">+	.note		: { *(.note.*) }		:text	:note</span>
<span class="p_add">+	.dynamic	: { *(.dynamic) }		:text	:dynamic</span>
<span class="p_add">+</span>
<span class="p_add">+	.eh_frame_hdr	: { *(.eh_frame_hdr) }		:text	:eh_frame_hdr</span>
<span class="p_add">+	.eh_frame	: { KEEP (*(.eh_frame)) }	:text</span>
<span class="p_add">+</span>
<span class="p_add">+	.rodata		: { *(.rodata .rodata.* .gnu.linkonce.r.*) }</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This linker script is used both with -r and with -shared.</span>
<span class="p_add">+	 * For the layouts to match, we need to skip more than enough</span>
<span class="p_add">+	 * space for the dynamic symbol table, etc. If this amount is</span>
<span class="p_add">+	 * insufficient, ld -shared will error; simply increase it here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	. = 0x800;</span>
<span class="p_add">+	.text		: { *(.text .text.*) }		:text</span>
<span class="p_add">+</span>
<span class="p_add">+	.data		: {</span>
<span class="p_add">+		*(.got.plt) *(.got)</span>
<span class="p_add">+		*(.data .data.* .gnu.linkonce.d.*)</span>
<span class="p_add">+		*(.dynbss)</span>
<span class="p_add">+		*(.bss .bss.* .gnu.linkonce.b.*)</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We must supply the ELF program headers explicitly to get just one</span>
<span class="p_add">+ * PT_LOAD segment, and set the flags explicitly to make segments read-only.</span>
<span class="p_add">+ */</span>
<span class="p_add">+PHDRS</span>
<span class="p_add">+{</span>
<span class="p_add">+	text		PT_LOAD		FLAGS(5) FILEHDR PHDRS; /* PF_R|PF_X */</span>
<span class="p_add">+	dynamic		PT_DYNAMIC	FLAGS(4);		/* PF_R */</span>
<span class="p_add">+	note		PT_NOTE		FLAGS(4);		/* PF_R */</span>
<span class="p_add">+	eh_frame_hdr	PT_GNU_EH_FRAME;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This controls what symbols we export from the DSO.</span>
<span class="p_add">+ */</span>
<span class="p_add">+VERSION</span>
<span class="p_add">+{</span>
<span class="p_add">+	LINUX_2.6 {</span>
<span class="p_add">+	global:</span>
<span class="p_add">+		__vdso_rt_sigreturn;</span>
<span class="p_add">+	local: *;</span>
<span class="p_add">+	};</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vmlinux.lds.S b/arch/riscv/kernel/vmlinux.lds.S</span>
new file mode 100644
<span class="p_header">index 000000000000..ece84991609c</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -0,0 +1,92 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define LOAD_OFFSET PAGE_OFFSET</span>
<span class="p_add">+#include &lt;asm/vmlinux.lds.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/cache.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+OUTPUT_ARCH(riscv)</span>
<span class="p_add">+ENTRY(_start)</span>
<span class="p_add">+</span>
<span class="p_add">+jiffies = jiffies_64;</span>
<span class="p_add">+</span>
<span class="p_add">+SECTIONS</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Beginning of code and text segment */</span>
<span class="p_add">+	. = LOAD_OFFSET;</span>
<span class="p_add">+	_start = .;</span>
<span class="p_add">+	__init_begin = .;</span>
<span class="p_add">+	HEAD_TEXT_SECTION</span>
<span class="p_add">+	INIT_TEXT_SECTION(PAGE_SIZE)</span>
<span class="p_add">+	INIT_DATA_SECTION(16)</span>
<span class="p_add">+	/* we have to discard exit text and such at runtime, not link time */</span>
<span class="p_add">+	.exit.text :</span>
<span class="p_add">+	{</span>
<span class="p_add">+		EXIT_TEXT</span>
<span class="p_add">+	}</span>
<span class="p_add">+	.exit.data :</span>
<span class="p_add">+	{</span>
<span class="p_add">+		EXIT_DATA</span>
<span class="p_add">+	}</span>
<span class="p_add">+	PERCPU_SECTION(L1_CACHE_BYTES)</span>
<span class="p_add">+	__init_end = .;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text : {</span>
<span class="p_add">+		_text = .;</span>
<span class="p_add">+		_stext = .;</span>
<span class="p_add">+		TEXT_TEXT</span>
<span class="p_add">+		SCHED_TEXT</span>
<span class="p_add">+		CPUIDLE_TEXT</span>
<span class="p_add">+		LOCK_TEXT</span>
<span class="p_add">+		KPROBES_TEXT</span>
<span class="p_add">+		ENTRY_TEXT</span>
<span class="p_add">+		IRQENTRY_TEXT</span>
<span class="p_add">+		*(.fixup)</span>
<span class="p_add">+		_etext = .;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start of data section */</span>
<span class="p_add">+	_sdata = .;</span>
<span class="p_add">+	RO_DATA_SECTION(L1_CACHE_BYTES)</span>
<span class="p_add">+	.srodata : {</span>
<span class="p_add">+		*(.srodata*)</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	RW_DATA_SECTION(L1_CACHE_BYTES, PAGE_SIZE, THREAD_SIZE)</span>
<span class="p_add">+	.sdata : {</span>
<span class="p_add">+		__global_pointer$ = . + 0x800;</span>
<span class="p_add">+		*(.sdata*)</span>
<span class="p_add">+		/* End of data section */</span>
<span class="p_add">+		_edata = .;</span>
<span class="p_add">+		*(.sbss*)</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	BSS_SECTION(0, 0, 0)</span>
<span class="p_add">+</span>
<span class="p_add">+	EXCEPTION_TABLE(0x10)</span>
<span class="p_add">+	NOTES</span>
<span class="p_add">+</span>
<span class="p_add">+	.rel.dyn : {</span>
<span class="p_add">+		*(.rel.dyn*)</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	_end = .;</span>
<span class="p_add">+</span>
<span class="p_add">+	STABS_DEBUG</span>
<span class="p_add">+	DWARF_DEBUG</span>
<span class="p_add">+</span>
<span class="p_add">+	DISCARDS</span>
<span class="p_add">+}</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



