
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3/3] dma-mapping: replace PCI_DMA_BUS_IS_PHYS with a flag in struct dma_map_ops - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3/3] dma-mapping: replace PCI_DMA_BUS_IS_PHYS with a flag in struct dma_map_ops</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=99">Christoph Hellwig</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 4, 2017, 4:36 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171204163601.3055-4-hch@lst.de&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10090945/mbox/"
   >mbox</a>
|
   <a href="/patch/10090945/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10090945/">/patch/10090945/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	776D160327 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  4 Dec 2017 16:36:32 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6848E27FA9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  4 Dec 2017 16:36:32 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 5D07E287B1; Mon,  4 Dec 2017 16:36:32 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.8 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 32F0227FA9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  4 Dec 2017 16:36:30 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752498AbdLDQgX (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 4 Dec 2017 11:36:23 -0500
Received: from bombadil.infradead.org ([65.50.211.133]:43004 &quot;EHLO
	bombadil.infradead.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752960AbdLDQgD (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 4 Dec 2017 11:36:03 -0500
DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
	d=infradead.org; s=bombadil.20170209;
	h=References:In-Reply-To:Message-Id:
	Date:Subject:Cc:To:From:Sender:Reply-To:MIME-Version:Content-Type:
	Content-Transfer-Encoding:Content-ID:Content-Description:Resent-Date:
	Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:List-Id:
	List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive;
	bh=X1tkq3X3rK1tQ8H36sfS8Od6OF+y3C4wIE0e9DMJkc0=;
	b=ecZa19SY4j+XsEkuryoKOODhE
	Tp8dCit2hnik+MTC5ZZiW0n+NLNWyG3EXxrxbBnINUUyhIa3iE4RcnpKXCfwgYD+Nr1A2EQDRk7Du
	tksOBFNynwCMEnLFkXfitKUEkyHFUozGRcPThYZp+VYGz1JowpKyO4XM0NoCB62fChRXigHrdst3D
	MG2dIK6n1LCp3jviEQy5gywsnmf+TqwWQgj9WyAvrDAd7XSzvJR+p0Ay9Nw1y4+BdxJ3uJJMGmM3y
	FRKjoWbdviLvq5IqEaR2YsuO7cwnnwCGsbAHTUx0u33CRL6mndw+bkdrWFYbcOd+perIooAgUbZF7
	vQPxcDGQw==;
Received: from rap-us.hgst.com ([199.255.44.250] helo=localhost)
	by bombadil.infradead.org with esmtpsa (Exim 4.87 #1 (Red Hat Linux))
	id 1eLtis-0004en-Pi; Mon, 04 Dec 2017 16:36:02 +0000
From: Christoph Hellwig &lt;hch@lst.de&gt;
To: iommu@lists.linux-foundation.org, linux-arch@vger.kernel.org,
	linux-block@vger.kernel.org, netdev@vger.kernel.org,
	linux-arm-kernel@lists.infradead.org
Cc: linux-kernel@vger.kernel.org
Subject: [PATCH 3/3] dma-mapping: replace PCI_DMA_BUS_IS_PHYS with a flag in
	struct dma_map_ops
Date: Mon,  4 Dec 2017 08:36:01 -0800
Message-Id: &lt;20171204163601.3055-4-hch@lst.de&gt;
X-Mailer: git-send-email 2.14.2
In-Reply-To: &lt;20171204163601.3055-1-hch@lst.de&gt;
References: &lt;20171204163601.3055-1-hch@lst.de&gt;
X-SRS-Rewrite: SMTP reverse-path rewritten from &lt;hch@infradead.org&gt; by
	bombadil.infradead.org. See http://www.infradead.org/rpr.html
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=99">Christoph Hellwig</a> - Dec. 4, 2017, 4:36 p.m.</div>
<pre class="content">
The current PCI_DMA_BUS_IS_PHYS decided if a dma implementation is bound
by the dma mask in the device because it directly maps to a physical
address range (modulo an offset in the device), or if it is virtualized
by an iommu and can map any address (that includes virtual iommus like
swiotlb).  The problem with this scheme is that it is per-architecture and
not per dma_ops instance, and we are growing more and more setups that
have multiple different dma operations in use on a single system, for
which this scheme can&#39;t provide a correct answer.  Depending on the
architecture that means we either get a false positive or false negative
at the moment.

This patch instead adds a new is_iommu flag in struct dma_map_ops that
tells if a dma_map_ops instance can map any possible physical address
to replace both the PCI_DMA_BUS_IS_PHYS macro and the is_phys field
in struct dma_map_ops used by it on a few architectures.

Note that this means that we now need a struct device parent in the
Scsi_Host or netdevice.  Every modern driver has these, but there might
still be a few outdated legacy drivers out there, which now won&#39;t make
an intelligent decision.
<span class="signed-off-by">
Signed-off-by: Christoph Hellwig &lt;hch@lst.de&gt;</span>
---
 arch/alpha/include/asm/pci.h             |  5 -----
 arch/alpha/kernel/pci_iommu.c            |  1 +
 arch/arc/include/asm/pci.h               |  6 ------
 arch/arm/include/asm/pci.h               |  7 -------
 arch/arm64/include/asm/pci.h             |  5 -----
 arch/arm64/mm/dma-mapping.c              |  2 ++
 arch/cris/include/asm/pci.h              |  6 ------
 arch/h8300/include/asm/pci.h             |  2 --
 arch/hexagon/kernel/dma.c                |  1 -
 arch/ia64/hp/common/sba_iommu.c          |  4 +---
 arch/ia64/include/asm/pci.h              | 17 -----------------
 arch/ia64/kernel/pci-swiotlb.c           |  1 +
 arch/ia64/kernel/setup.c                 | 12 ------------
 arch/ia64/sn/kernel/io_common.c          |  5 -----
 arch/ia64/sn/pci/pci_dma.c               |  1 +
 arch/m68k/include/asm/pci.h              |  6 ------
 arch/microblaze/include/asm/pci.h        |  6 ------
 arch/mips/include/asm/pci.h              |  7 -------
 arch/mn10300/include/asm/pci.h           |  6 ------
 arch/parisc/include/asm/pci.h            | 23 -----------------------
 arch/parisc/kernel/setup.c               |  5 -----
 arch/powerpc/include/asm/pci.h           | 18 ------------------
 arch/powerpc/kernel/dma-iommu.c          |  1 +
 arch/powerpc/kernel/dma-swiotlb.c        |  1 +
 arch/powerpc/platforms/cell/iommu.c      |  1 +
 arch/powerpc/platforms/ps3/system-bus.c  |  2 ++
 arch/powerpc/platforms/pseries/ibmebus.c |  1 +
 arch/powerpc/platforms/pseries/vio.c     |  1 +
 arch/riscv/include/asm/pci.h             |  3 ---
 arch/s390/include/asm/pci.h              |  2 --
 arch/s390/pci/pci_dma.c                  |  3 +--
 arch/sh/include/asm/pci.h                |  6 ------
 arch/sh/kernel/dma-nommu.c               |  1 -
 arch/sparc/include/asm/pci_32.h          |  4 ----
 arch/sparc/include/asm/pci_64.h          |  6 ------
 arch/sparc/kernel/iommu.c                |  1 +
 arch/sparc/kernel/ioport.c               |  1 +
 arch/sparc/kernel/pci_sun4v.c            |  1 +
 arch/tile/include/asm/pci.h              | 14 --------------
 arch/tile/kernel/pci-dma.c               |  2 ++
 arch/x86/include/asm/pci.h               |  2 --
 arch/x86/kernel/amd_gart_64.c            |  1 +
 arch/x86/kernel/pci-calgary_64.c         |  1 +
 arch/x86/kernel/pci-nommu.c              |  1 -
 arch/x86/kernel/pci-swiotlb.c            |  1 +
 arch/x86/mm/mem_encrypt.c                |  1 +
 arch/x86/pci/sta2x11-fixup.c             |  1 +
 arch/xtensa/include/asm/pci.h            |  7 -------
 drivers/ide/ide-lib.c                    |  5 ++---
 drivers/ide/ide-probe.c                  |  2 +-
 drivers/iommu/amd_iommu.c                |  1 +
 drivers/iommu/intel-iommu.c              |  1 +
 drivers/parisc/ccio-dma.c                |  3 +--
 drivers/parisc/sba_iommu.c               |  3 +--
 drivers/pci/host/vmd.c                   |  1 +
 drivers/scsi/scsi_lib.c                  | 14 ++++++--------
 drivers/xen/swiotlb-xen.c                |  1 +
 include/asm-generic/pci.h                |  8 --------
 include/linux/dma-mapping.h              | 16 +++++++++++++++-
 lib/dma-virt.c                           |  1 +
 net/core/dev.c                           | 18 ++++++++----------
 tools/virtio/linux/dma-mapping.h         |  2 --
 62 files changed, 63 insertions(+), 225 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/alpha/include/asm/pci.h b/arch/alpha/include/asm/pci.h</span>
<span class="p_header">index b9ec55351924..cf6bc1e64d66 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/pci.h</span>
<span class="p_chunk">@@ -56,11 +56,6 @@</span> <span class="p_context"> struct pci_controller {</span>
 
 /* IOMMU controls.  */
 
<span class="p_del">-/* The PCI address space does not equal the physical memory address space.</span>
<span class="p_del">-   The networking and block device layers use this boolean for bounce buffer</span>
<span class="p_del">-   decisions.  */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS  0</span>
<span class="p_del">-</span>
 /* TODO: integrate with include/asm-generic/pci.h ? */
 static inline int pci_get_legacy_ide_irq(struct pci_dev *dev, int channel)
 {
<span class="p_header">diff --git a/arch/alpha/kernel/pci_iommu.c b/arch/alpha/kernel/pci_iommu.c</span>
<span class="p_header">index 83b34b9188ea..bf83937d5368 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/pci_iommu.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/pci_iommu.c</span>
<span class="p_chunk">@@ -949,6 +949,7 @@</span> <span class="p_context"> const struct dma_map_ops alpha_pci_ops = {</span>
 	.unmap_sg		= alpha_pci_unmap_sg,
 	.mapping_error		= alpha_pci_mapping_error,
 	.dma_supported		= alpha_pci_supported,
<span class="p_add">+	.is_iommu		= true,</span>
 };
 
 const struct dma_map_ops *dma_ops = &amp;alpha_pci_ops;
<span class="p_header">diff --git a/arch/arc/include/asm/pci.h b/arch/arc/include/asm/pci.h</span>
<span class="p_header">index ba56c23c1b20..4ff53c041c64 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/pci.h</span>
<span class="p_chunk">@@ -16,12 +16,6 @@</span> <span class="p_context"></span>
 #define PCIBIOS_MIN_MEM 0x100000
 
 #define pcibios_assign_all_busses()	1
<span class="p_del">-/*</span>
<span class="p_del">- * The PCI address space does equal the physical memory address space.</span>
<span class="p_del">- * The networking and block device layers use this boolean for bounce</span>
<span class="p_del">- * buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	1</span>
 
 #endif /* __KERNEL__ */
 
<span class="p_header">diff --git a/arch/arm/include/asm/pci.h b/arch/arm/include/asm/pci.h</span>
<span class="p_header">index 960d9dc4f380..05b2eb2dc76f 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/pci.h</span>
<span class="p_chunk">@@ -22,13 +22,6 @@</span> <span class="p_context"> static inline int pci_proc_domain(struct pci_bus *bus)</span>
 }
 #endif /* CONFIG_PCI_DOMAINS */
 
<span class="p_del">-/*</span>
<span class="p_del">- * The PCI address space does equal the physical memory address space.</span>
<span class="p_del">- * The networking and block device layers use this boolean for bounce</span>
<span class="p_del">- * buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS     (1)</span>
<span class="p_del">-</span>
 #define HAVE_PCI_MMAP
 #define ARCH_GENERIC_PCI_MMAP_RESOURCE
 
<span class="p_header">diff --git a/arch/arm64/include/asm/pci.h b/arch/arm64/include/asm/pci.h</span>
<span class="p_header">index 8747f7c5e0e7..9e690686e8aa 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pci.h</span>
<span class="p_chunk">@@ -18,11 +18,6 @@</span> <span class="p_context"></span>
 #define pcibios_assign_all_busses() \
 	(pci_has_flag(PCI_REASSIGN_ALL_BUS))
 
<span class="p_del">-/*</span>
<span class="p_del">- * PCI address space differs from physical memory address space</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(0)</span>
<span class="p_del">-</span>
 #define ARCH_GENERIC_PCI_MMAP_RESOURCE	1
 
 extern int isa_dma_bridge_buggy;
<span class="p_header">diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">index b45c5bcaeccb..43190a914c95 100644</span>
<span class="p_header">--- a/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -383,6 +383,7 @@</span> <span class="p_context"> static const struct dma_map_ops swiotlb_dma_ops = {</span>
 	.sync_sg_for_device = __swiotlb_sync_sg_for_device,
 	.dma_supported = __swiotlb_dma_supported,
 	.mapping_error = __swiotlb_dma_mapping_error,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 static int __init atomic_pool_init(void)
<span class="p_chunk">@@ -867,6 +868,7 @@</span> <span class="p_context"> static const struct dma_map_ops iommu_dma_ops = {</span>
 	.map_resource = iommu_dma_map_resource,
 	.unmap_resource = iommu_dma_unmap_resource,
 	.mapping_error = iommu_dma_mapping_error,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 static int __init __iommu_dma_init(void)
<span class="p_header">diff --git a/arch/cris/include/asm/pci.h b/arch/cris/include/asm/pci.h</span>
<span class="p_header">index dcfef6407ae6..eb1f7f172f4b 100644</span>
<span class="p_header">--- a/arch/cris/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/cris/include/asm/pci.h</span>
<span class="p_chunk">@@ -27,12 +27,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/string.h&gt;
 #include &lt;asm/io.h&gt;
 
<span class="p_del">-/* The PCI address space does equal the physical memory</span>
<span class="p_del">- * address space.  The networking and block device layers use</span>
<span class="p_del">- * this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(1)</span>
<span class="p_del">-</span>
 #define HAVE_PCI_MMAP
 #define ARCH_GENERIC_PCI_MMAP_RESOURCE
 
<span class="p_header">diff --git a/arch/h8300/include/asm/pci.h b/arch/h8300/include/asm/pci.h</span>
<span class="p_header">index 7c9e55d62215..d4d345a52092 100644</span>
<span class="p_header">--- a/arch/h8300/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/h8300/include/asm/pci.h</span>
<span class="p_chunk">@@ -15,6 +15,4 @@</span> <span class="p_context"> static inline void pcibios_penalize_isa_irq(int irq, int active)</span>
 	/* We don&#39;t do dynamic PCI IRQ allocation */
 }
 
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(1)</span>
<span class="p_del">-</span>
 #endif /* _ASM_H8300_PCI_H */
<span class="p_header">diff --git a/arch/hexagon/kernel/dma.c b/arch/hexagon/kernel/dma.c</span>
<span class="p_header">index 546792d176a4..35aaab72ddd0 100644</span>
<span class="p_header">--- a/arch/hexagon/kernel/dma.c</span>
<span class="p_header">+++ b/arch/hexagon/kernel/dma.c</span>
<span class="p_chunk">@@ -207,7 +207,6 @@</span> <span class="p_context"> const struct dma_map_ops hexagon_dma_ops = {</span>
 	.sync_single_for_cpu = hexagon_sync_single_for_cpu,
 	.sync_single_for_device = hexagon_sync_single_for_device,
 	.mapping_error	= hexagon_mapping_error,
<span class="p_del">-	.is_phys	= 1,</span>
 };
 
 void __init hexagon_dma_init(void)
<span class="p_header">diff --git a/arch/ia64/hp/common/sba_iommu.c b/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_header">index aec4a3354abe..bc6daf7dace4 100644</span>
<span class="p_header">--- a/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_header">+++ b/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_chunk">@@ -1845,9 +1845,6 @@</span> <span class="p_context"> static void ioc_init(unsigned long hpa, struct ioc *ioc)</span>
 	ioc_resource_init(ioc);
 	ioc_sac_init(ioc);
 
<span class="p_del">-	if ((long) ~iovp_mask &gt; (long) ia64_max_iommu_merge_mask)</span>
<span class="p_del">-		ia64_max_iommu_merge_mask = ~iovp_mask;</span>
<span class="p_del">-</span>
 	printk(KERN_INFO PFX
 		&quot;%s %d.%d HPA 0x%lx IOVA space %dMb at 0x%lx\n&quot;,
 		ioc-&gt;name, (ioc-&gt;rev &gt;&gt; 4) &amp; 0xF, ioc-&gt;rev &amp; 0xF,
<span class="p_chunk">@@ -2229,6 +2226,7 @@</span> <span class="p_context"> const struct dma_map_ops sba_dma_ops = {</span>
 	.sync_sg_for_device	= machvec_dma_sync_sg,
 	.dma_supported		= sba_dma_supported,
 	.mapping_error		= sba_dma_mapping_error,
<span class="p_add">+	.is_iommu		= true,</span>
 };
 
 void sba_dma_init(void)
<span class="p_header">diff --git a/arch/ia64/include/asm/pci.h b/arch/ia64/include/asm/pci.h</span>
<span class="p_header">index b1d04e8bafc8..780e8744ba85 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/pci.h</span>
<span class="p_chunk">@@ -30,23 +30,6 @@</span> <span class="p_context"> struct pci_vector_struct {</span>
 #define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		0x10000000
 
<span class="p_del">-/*</span>
<span class="p_del">- * PCI_DMA_BUS_IS_PHYS should be set to 1 if there is _necessarily_ a direct</span>
<span class="p_del">- * correspondence between device bus addresses and CPU physical addresses.</span>
<span class="p_del">- * Platforms with a hardware I/O MMU _must_ turn this off to suppress the</span>
<span class="p_del">- * bounce buffer handling code in the block and network device layers.</span>
<span class="p_del">- * Platforms with separate bus address spaces _must_ turn this off and provide</span>
<span class="p_del">- * a device DMA mapping implementation that takes care of the necessary</span>
<span class="p_del">- * address translation.</span>
<span class="p_del">- *</span>
<span class="p_del">- * For now, the ia64 platforms which may have separate/multiple bus address</span>
<span class="p_del">- * spaces all have I/O MMUs which support the merging of physically</span>
<span class="p_del">- * discontiguous buffers, so we can use that as the sole factor to determine</span>
<span class="p_del">- * the setting of PCI_DMA_BUS_IS_PHYS.</span>
<span class="p_del">- */</span>
<span class="p_del">-extern unsigned long ia64_max_iommu_merge_mask;</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(ia64_max_iommu_merge_mask == ~0UL)</span>
<span class="p_del">-</span>
 #define HAVE_PCI_MMAP
 #define ARCH_GENERIC_PCI_MMAP_RESOURCE
 #define arch_can_pci_mmap_wc()	1
<span class="p_header">diff --git a/arch/ia64/kernel/pci-swiotlb.c b/arch/ia64/kernel/pci-swiotlb.c</span>
<span class="p_header">index 5e50939aa03e..497f7a02d1ae 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/pci-swiotlb.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/pci-swiotlb.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"> const struct dma_map_ops swiotlb_dma_ops = {</span>
 	.sync_sg_for_device = swiotlb_sync_sg_for_device,
 	.dma_supported = swiotlb_dma_supported,
 	.mapping_error = swiotlb_dma_mapping_error,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 void __init swiotlb_dma_init(void)
<span class="p_header">diff --git a/arch/ia64/kernel/setup.c b/arch/ia64/kernel/setup.c</span>
<span class="p_header">index dee56bcb993d..ad43cbf70628 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/setup.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/setup.c</span>
<span class="p_chunk">@@ -123,18 +123,6 @@</span> <span class="p_context"> unsigned long ia64_i_cache_stride_shift = ~0;</span>
 #define	CACHE_STRIDE_SHIFT	5
 unsigned long ia64_cache_stride_shift = ~0;
 
<span class="p_del">-/*</span>
<span class="p_del">- * The merge_mask variable needs to be set to (max(iommu_page_size(iommu)) - 1).  This</span>
<span class="p_del">- * mask specifies a mask of address bits that must be 0 in order for two buffers to be</span>
<span class="p_del">- * mergeable by the I/O MMU (i.e., the end address of the first buffer and the start</span>
<span class="p_del">- * address of the second buffer must be aligned to (merge_mask+1) in order to be</span>
<span class="p_del">- * mergeable).  By default, we assume there is no I/O MMU which can merge physically</span>
<span class="p_del">- * discontiguous buffers, so we set the merge_mask to ~0UL, which corresponds to a iommu</span>
<span class="p_del">- * page-size of 2^64.</span>
<span class="p_del">- */</span>
<span class="p_del">-unsigned long ia64_max_iommu_merge_mask = ~0UL;</span>
<span class="p_del">-EXPORT_SYMBOL(ia64_max_iommu_merge_mask);</span>
<span class="p_del">-</span>
 /*
  * We use a special marker for the end of memory and it uses the extra (+1) slot
  */
<span class="p_header">diff --git a/arch/ia64/sn/kernel/io_common.c b/arch/ia64/sn/kernel/io_common.c</span>
<span class="p_header">index 11f2275570fb..8479e9a7ce16 100644</span>
<span class="p_header">--- a/arch/ia64/sn/kernel/io_common.c</span>
<span class="p_header">+++ b/arch/ia64/sn/kernel/io_common.c</span>
<span class="p_chunk">@@ -480,11 +480,6 @@</span> <span class="p_context"> sn_io_early_init(void)</span>
 	tioca_init_provider();
 	tioce_init_provider();
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This is needed to avoid bounce limit checks in the blk layer</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ia64_max_iommu_merge_mask = ~PAGE_MASK;</span>
<span class="p_del">-</span>
 	sn_irq_lh_init();
 	INIT_LIST_HEAD(&amp;sn_sysdata_list);
 	sn_init_cpei_timer();
<span class="p_header">diff --git a/arch/ia64/sn/pci/pci_dma.c b/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_header">index 74c934a997bb..350533db030d 100644</span>
<span class="p_header">--- a/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_header">+++ b/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_chunk">@@ -473,6 +473,7 @@</span> <span class="p_context"> static struct dma_map_ops sn_dma_ops = {</span>
 	.sync_sg_for_device	= sn_dma_sync_sg_for_device,
 	.mapping_error		= sn_dma_mapping_error,
 	.dma_supported		= sn_dma_supported,
<span class="p_add">+	.is_iommu		= true,</span>
 };
 
 void sn_dma_init(void)
<span class="p_header">diff --git a/arch/m68k/include/asm/pci.h b/arch/m68k/include/asm/pci.h</span>
<span class="p_header">index ef26fae8cf0b..5a4bc223743b 100644</span>
<span class="p_header">--- a/arch/m68k/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/m68k/include/asm/pci.h</span>
<span class="p_chunk">@@ -4,12 +4,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm-generic/pci.h&gt;
 
<span class="p_del">-/* The PCI address space does equal the physical memory</span>
<span class="p_del">- * address space.  The networking and block device layers use</span>
<span class="p_del">- * this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(1)</span>
<span class="p_del">-</span>
 #define	pcibios_assign_all_busses()	1
 
 #define	PCIBIOS_MIN_IO		0x00000100
<span class="p_header">diff --git a/arch/microblaze/include/asm/pci.h b/arch/microblaze/include/asm/pci.h</span>
<span class="p_header">index 114b93488193..00478965f932 100644</span>
<span class="p_header">--- a/arch/microblaze/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/microblaze/include/asm/pci.h</span>
<span class="p_chunk">@@ -61,12 +61,6 @@</span> <span class="p_context"> extern int pci_mmap_legacy_page_range(struct pci_bus *bus,</span>
 
 #define HAVE_PCI_LEGACY	1
 
<span class="p_del">-/* The PCI address space does equal the physical memory</span>
<span class="p_del">- * address space (no IOMMU).  The IDE and SCSI device layers use</span>
<span class="p_del">- * this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS     (1)</span>
<span class="p_del">-</span>
 extern void pcibios_claim_one_bus(struct pci_bus *b);
 
 extern void pcibios_finish_adding_to_bus(struct pci_bus *bus);
<span class="p_header">diff --git a/arch/mips/include/asm/pci.h b/arch/mips/include/asm/pci.h</span>
<span class="p_header">index 2339f42f047a..436099883022 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pci.h</span>
<span class="p_chunk">@@ -121,13 +121,6 @@</span> <span class="p_context"> extern unsigned long PCIBIOS_MIN_MEM;</span>
 #include &lt;linux/string.h&gt;
 #include &lt;asm/io.h&gt;
 
<span class="p_del">-/*</span>
<span class="p_del">- * The PCI address space does equal the physical memory address space.</span>
<span class="p_del">- * The networking and block device layers use this boolean for bounce</span>
<span class="p_del">- * buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS     (1)</span>
<span class="p_del">-</span>
 #ifdef CONFIG_PCI_DOMAINS_GENERIC
 static inline int pci_proc_domain(struct pci_bus *bus)
 {
<span class="p_header">diff --git a/arch/mn10300/include/asm/pci.h b/arch/mn10300/include/asm/pci.h</span>
<span class="p_header">index 5b75a1b2c4f6..6132966bdf30 100644</span>
<span class="p_header">--- a/arch/mn10300/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/mn10300/include/asm/pci.h</span>
<span class="p_chunk">@@ -57,12 +57,6 @@</span> <span class="p_context"> extern void unit_pci_init(void);</span>
 #include &lt;linux/string.h&gt;
 #include &lt;asm/io.h&gt;
 
<span class="p_del">-/* The PCI address space does equal the physical memory</span>
<span class="p_del">- * address space.  The networking and block device layers use</span>
<span class="p_del">- * this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(1)</span>
<span class="p_del">-</span>
 /* Return the index of the PCI controller for device. */
 static inline int pci_controller_num(struct pci_dev *dev)
 {
<span class="p_header">diff --git a/arch/parisc/include/asm/pci.h b/arch/parisc/include/asm/pci.h</span>
<span class="p_header">index 96b7deec512d..3328fd17c19d 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pci.h</span>
<span class="p_chunk">@@ -87,29 +87,6 @@</span> <span class="p_context"> struct pci_hba_data {</span>
 #define PCI_F_EXTEND		0UL
 #endif /* !CONFIG_64BIT */
 
<span class="p_del">-/*</span>
<span class="p_del">- * If the PCI device&#39;s view of memory is the same as the CPU&#39;s view of memory,</span>
<span class="p_del">- * PCI_DMA_BUS_IS_PHYS is true.  The networking and block device layers use</span>
<span class="p_del">- * this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifdef CONFIG_PA20</span>
<span class="p_del">-/* All PA-2.0 machines have an IOMMU. */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	0</span>
<span class="p_del">-#define parisc_has_iommu()	do { } while (0)</span>
<span class="p_del">-#else</span>
<span class="p_del">-</span>
<span class="p_del">-#if defined(CONFIG_IOMMU_CCIO) || defined(CONFIG_IOMMU_SBA)</span>
<span class="p_del">-extern int parisc_bus_is_phys; 	/* in arch/parisc/kernel/setup.c */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	parisc_bus_is_phys</span>
<span class="p_del">-#define parisc_has_iommu()	do { parisc_bus_is_phys = 0; } while (0)</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	1</span>
<span class="p_del">-#define parisc_has_iommu()	do { } while (0)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-#endif	/* !CONFIG_PA20 */</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 /*
 ** Most PCI devices (eg Tulip, NCR720) also export the same registers
 ** to both MMIO and I/O port space.  Due to poor performance of I/O Port
<span class="p_header">diff --git a/arch/parisc/kernel/setup.c b/arch/parisc/kernel/setup.c</span>
<span class="p_header">index 0e9675f857a5..8d3a7b80ac42 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/setup.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/setup.c</span>
<span class="p_chunk">@@ -58,11 +58,6 @@</span> <span class="p_context"> struct proc_dir_entry * proc_runway_root __read_mostly = NULL;</span>
 struct proc_dir_entry * proc_gsc_root __read_mostly = NULL;
 struct proc_dir_entry * proc_mckinley_root __read_mostly = NULL;
 
<span class="p_del">-#if !defined(CONFIG_PA20) &amp;&amp; (defined(CONFIG_IOMMU_CCIO) || defined(CONFIG_IOMMU_SBA))</span>
<span class="p_del">-int parisc_bus_is_phys __read_mostly = 1;	/* Assume no IOMMU is present */</span>
<span class="p_del">-EXPORT_SYMBOL(parisc_bus_is_phys);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 void __init setup_cmdline(char **cmdline_p)
 {
 	extern unsigned int boot_args[];
<span class="p_header">diff --git a/arch/powerpc/include/asm/pci.h b/arch/powerpc/include/asm/pci.h</span>
<span class="p_header">index 8dc32eacc97c..04c1347e2c51 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/pci.h</span>
<span class="p_chunk">@@ -91,24 +91,6 @@</span> <span class="p_context"> extern int pci_mmap_legacy_page_range(struct pci_bus *bus,</span>
 
 #define HAVE_PCI_LEGACY	1
 
<span class="p_del">-#ifdef CONFIG_PPC64</span>
<span class="p_del">-</span>
<span class="p_del">-/* The PCI address space does not equal the physical memory address</span>
<span class="p_del">- * space (we have an IOMMU).  The IDE and SCSI device layers use</span>
<span class="p_del">- * this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(0)</span>
<span class="p_del">-</span>
<span class="p_del">-#else /* 32-bit */</span>
<span class="p_del">-</span>
<span class="p_del">-/* The PCI address space does equal the physical memory</span>
<span class="p_del">- * address space (no IOMMU).  The IDE and SCSI device layers use</span>
<span class="p_del">- * this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS     (1)</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* CONFIG_PPC64 */</span>
<span class="p_del">-</span>
 extern void pcibios_claim_one_bus(struct pci_bus *b);
 
 extern void pcibios_finish_adding_to_bus(struct pci_bus *bus);
<span class="p_header">diff --git a/arch/powerpc/kernel/dma-iommu.c b/arch/powerpc/kernel/dma-iommu.c</span>
<span class="p_header">index 66f33e7f8d40..77460f543156 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/dma-iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/dma-iommu.c</span>
<span class="p_chunk">@@ -122,5 +122,6 @@</span> <span class="p_context"> struct dma_map_ops dma_iommu_ops = {</span>
 	.unmap_page		= dma_iommu_unmap_page,
 	.get_required_mask	= dma_iommu_get_required_mask,
 	.mapping_error		= dma_iommu_mapping_error,
<span class="p_add">+	.is_iommu		= true,</span>
 };
 EXPORT_SYMBOL(dma_iommu_ops);
<span class="p_header">diff --git a/arch/powerpc/kernel/dma-swiotlb.c b/arch/powerpc/kernel/dma-swiotlb.c</span>
<span class="p_header">index d0ea7860e02b..1c6388e4c5f3 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/dma-swiotlb.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/dma-swiotlb.c</span>
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"> const struct dma_map_ops swiotlb_dma_ops = {</span>
 	.sync_sg_for_device = swiotlb_sync_sg_for_device,
 	.mapping_error = swiotlb_dma_mapping_error,
 	.get_required_mask = swiotlb_powerpc_get_required,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 void pci_dma_dev_setup_swiotlb(struct pci_dev *pdev)
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/iommu.c b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">index 4b91ad08eefd..821d302c73eb 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_chunk">@@ -655,6 +655,7 @@</span> <span class="p_context"> static const struct dma_map_ops dma_iommu_fixed_ops = {</span>
 	.map_page       = dma_fixed_map_page,
 	.unmap_page     = dma_fixed_unmap_page,
 	.mapping_error	= dma_iommu_mapping_error,
<span class="p_add">+	.is_iommu	= true,</span>
 };
 
 static void cell_dma_dev_setup(struct device *dev)
<span class="p_header">diff --git a/arch/powerpc/platforms/ps3/system-bus.c b/arch/powerpc/platforms/ps3/system-bus.c</span>
<span class="p_header">index 5cc35d6b94b6..1e5348ad50e4 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/ps3/system-bus.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/ps3/system-bus.c</span>
<span class="p_chunk">@@ -712,6 +712,7 @@</span> <span class="p_context"> static const struct dma_map_ops ps3_sb_dma_ops = {</span>
 	.get_required_mask = ps3_dma_get_required_mask,
 	.map_page = ps3_sb_map_page,
 	.unmap_page = ps3_unmap_page,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 static const struct dma_map_ops ps3_ioc0_dma_ops = {
<span class="p_chunk">@@ -723,6 +724,7 @@</span> <span class="p_context"> static const struct dma_map_ops ps3_ioc0_dma_ops = {</span>
 	.get_required_mask = ps3_dma_get_required_mask,
 	.map_page = ps3_ioc0_map_page,
 	.unmap_page = ps3_unmap_page,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 /**
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/ibmebus.c b/arch/powerpc/platforms/pseries/ibmebus.c</span>
<span class="p_header">index 408a86044133..d99b25f05220 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/ibmebus.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/ibmebus.c</span>
<span class="p_chunk">@@ -145,6 +145,7 @@</span> <span class="p_context"> static const struct dma_map_ops ibmebus_dma_ops = {</span>
 	.get_required_mask  = ibmebus_dma_get_required_mask,
 	.map_page           = ibmebus_map_page,
 	.unmap_page         = ibmebus_unmap_page,
<span class="p_add">+	.is_iommu           = true,</span>
 };
 
 static int ibmebus_match_path(struct device *dev, void *data)
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/vio.c b/arch/powerpc/platforms/pseries/vio.c</span>
<span class="p_header">index d86938260a86..9d65105c5d1a 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/vio.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/vio.c</span>
<span class="p_chunk">@@ -626,6 +626,7 @@</span> <span class="p_context"> static const struct dma_map_ops vio_dma_mapping_ops = {</span>
 	.dma_supported     = vio_dma_iommu_dma_supported,
 	.get_required_mask = vio_dma_get_required_mask,
 	.mapping_error	   = dma_iommu_mapping_error,
<span class="p_add">+	.is_iommu          = true,</span>
 };
 
 /**
<span class="p_header">diff --git a/arch/riscv/include/asm/pci.h b/arch/riscv/include/asm/pci.h</span>
<span class="p_header">index 0f2fc9ef20fc..b3638c505728 100644</span>
<span class="p_header">--- a/arch/riscv/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/riscv/include/asm/pci.h</span>
<span class="p_chunk">@@ -26,9 +26,6 @@</span> <span class="p_context"></span>
 /* RISC-V shim does not initialize PCI bus */
 #define pcibios_assign_all_busses() 1
 
<span class="p_del">-/* We do not have an IOMMU */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS 1</span>
<span class="p_del">-</span>
 extern int isa_dma_bridge_buggy;
 
 #ifdef CONFIG_PCI
<span class="p_header">diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.h</span>
<span class="p_header">index 12fe3591034f..94f8db468c9b 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pci.h</span>
<span class="p_chunk">@@ -2,8 +2,6 @@</span> <span class="p_context"></span>
 #ifndef __ASM_S390_PCI_H
 #define __ASM_S390_PCI_H
 
<span class="p_del">-/* must be set before including asm-generic/pci.h */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS (0)</span>
 /* must be set before including pci_clp.h */
 #define PCI_BAR_COUNT	6
 
<span class="p_header">diff --git a/arch/s390/pci/pci_dma.c b/arch/s390/pci/pci_dma.c</span>
<span class="p_header">index f7aa5a77827e..76ae7020ff21 100644</span>
<span class="p_header">--- a/arch/s390/pci/pci_dma.c</span>
<span class="p_header">+++ b/arch/s390/pci/pci_dma.c</span>
<span class="p_chunk">@@ -668,8 +668,7 @@</span> <span class="p_context"> const struct dma_map_ops s390_pci_dma_ops = {</span>
 	.map_page	= s390_dma_map_pages,
 	.unmap_page	= s390_dma_unmap_pages,
 	.mapping_error	= s390_mapping_error,
<span class="p_del">-	/* if we support direct DMA this must be conditional */</span>
<span class="p_del">-	.is_phys	= 0,</span>
<span class="p_add">+	.is_iommu	= true,</span>
 	/* dma_supported is unconditionally true without a callback */
 };
 EXPORT_SYMBOL_GPL(s390_pci_dma_ops);
<span class="p_header">diff --git a/arch/sh/include/asm/pci.h b/arch/sh/include/asm/pci.h</span>
<span class="p_header">index 0033f0df2b3b..10a36b1cf2ea 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/pci.h</span>
<span class="p_chunk">@@ -71,12 +71,6 @@</span> <span class="p_context"> extern unsigned long PCIBIOS_MIN_IO, PCIBIOS_MIN_MEM;</span>
  * SuperH has everything mapped statically like x86.
  */
 
<span class="p_del">-/* The PCI address space does equal the physical memory</span>
<span class="p_del">- * address space.  The networking and block device layers use</span>
<span class="p_del">- * this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(dma_ops-&gt;is_phys)</span>
<span class="p_del">-</span>
 #ifdef CONFIG_PCI
 /*
  * None of the SH PCI controllers support MWI, it is always treated as a
<span class="p_header">diff --git a/arch/sh/kernel/dma-nommu.c b/arch/sh/kernel/dma-nommu.c</span>
<span class="p_header">index 62b485107eae..2077cfe73cc6 100644</span>
<span class="p_header">--- a/arch/sh/kernel/dma-nommu.c</span>
<span class="p_header">+++ b/arch/sh/kernel/dma-nommu.c</span>
<span class="p_chunk">@@ -75,7 +75,6 @@</span> <span class="p_context"> const struct dma_map_ops nommu_dma_ops = {</span>
 	.sync_single_for_device	= nommu_sync_single_for_device,
 	.sync_sg_for_device	= nommu_sync_sg_for_device,
 #endif
<span class="p_del">-	.is_phys		= 1,</span>
 };
 
 void __init no_iommu_init(void)
<span class="p_header">diff --git a/arch/sparc/include/asm/pci_32.h b/arch/sparc/include/asm/pci_32.h</span>
<span class="p_header">index 98917e48727d..cfc0ee9476c6 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/pci_32.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/pci_32.h</span>
<span class="p_chunk">@@ -17,10 +17,6 @@</span> <span class="p_context"></span>
 
 #define PCI_IRQ_NONE		0xffffffff
 
<span class="p_del">-/* Dynamic DMA mapping stuff.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(0)</span>
<span class="p_del">-</span>
 #endif /* __KERNEL__ */
 
 #ifndef CONFIG_LEON_PCI
<span class="p_header">diff --git a/arch/sparc/include/asm/pci_64.h b/arch/sparc/include/asm/pci_64.h</span>
<span class="p_header">index 671274e36cfa..fac77813402c 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/pci_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/pci_64.h</span>
<span class="p_chunk">@@ -17,12 +17,6 @@</span> <span class="p_context"></span>
 
 #define PCI_IRQ_NONE		0xffffffff
 
<span class="p_del">-/* The PCI address space does not equal the physical memory</span>
<span class="p_del">- * address space.  The networking and block device layers use</span>
<span class="p_del">- * this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(0)</span>
<span class="p_del">-</span>
 /* PCI IOMMU mapping bypass support. */
 
 /* PCI 64-bit addressing works for all slots on all controller
<span class="p_header">diff --git a/arch/sparc/kernel/iommu.c b/arch/sparc/kernel/iommu.c</span>
<span class="p_header">index b08dc3416f06..a5115dc7545a 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/iommu.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/iommu.c</span>
<span class="p_chunk">@@ -773,6 +773,7 @@</span> <span class="p_context"> static const struct dma_map_ops sun4u_dma_ops = {</span>
 	.sync_sg_for_cpu	= dma_4u_sync_sg_for_cpu,
 	.dma_supported		= dma_4u_supported,
 	.mapping_error		= dma_4u_mapping_error,
<span class="p_add">+	.is_iommu		= true,</span>
 };
 
 const struct dma_map_ops *dma_ops = &amp;sun4u_dma_ops;
<span class="p_header">diff --git a/arch/sparc/kernel/ioport.c b/arch/sparc/kernel/ioport.c</span>
<span class="p_header">index 7eeef80c02f7..7d81281d3b5a 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ioport.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ioport.c</span>
<span class="p_chunk">@@ -417,6 +417,7 @@</span> <span class="p_context"> static const struct dma_map_ops sbus_dma_ops = {</span>
 	.sync_sg_for_cpu	= sbus_sync_sg_for_cpu,
 	.sync_sg_for_device	= sbus_sync_sg_for_device,
 	.dma_supported		= sbus_dma_supported,
<span class="p_add">+	.is_iommu		= true,</span>
 };
 
 static int __init sparc_register_ioport(void)
<span class="p_header">diff --git a/arch/sparc/kernel/pci_sun4v.c b/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_header">index 249367228c33..77b920580a9a 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_chunk">@@ -702,6 +702,7 @@</span> <span class="p_context"> static const struct dma_map_ops sun4v_dma_ops = {</span>
 	.unmap_sg			= dma_4v_unmap_sg,
 	.dma_supported			= dma_4v_supported,
 	.mapping_error			= dma_4v_mapping_error,
<span class="p_add">+	.is_iommu			= true,</span>
 };
 
 static void pci_sun4v_scan_bus(struct pci_pbm_info *pbm, struct device *parent)
<span class="p_header">diff --git a/arch/tile/include/asm/pci.h b/arch/tile/include/asm/pci.h</span>
<span class="p_header">index fe3de505b024..8b910e3f0620 100644</span>
<span class="p_header">--- a/arch/tile/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/tile/include/asm/pci.h</span>
<span class="p_chunk">@@ -52,13 +52,6 @@</span> <span class="p_context"> static inline void pci_iounmap(struct pci_dev *dev, void __iomem *addr) {}</span>
 
 #define	TILE_NUM_PCIE	2
 
<span class="p_del">-/*</span>
<span class="p_del">- * The hypervisor maps the entirety of CPA-space as bus addresses, so</span>
<span class="p_del">- * bus addresses are physical addresses.  The networking and block</span>
<span class="p_del">- * device layers use this boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS     1</span>
<span class="p_del">-</span>
 /* generic pci stuff */
 #include &lt;asm-generic/pci.h&gt;
 
<span class="p_chunk">@@ -185,13 +178,6 @@</span> <span class="p_context"> extern int num_trio_shims;</span>
 
 extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
 
<span class="p_del">-/*</span>
<span class="p_del">- * The PCI address space does not equal the physical memory address</span>
<span class="p_del">- * space (we have an IOMMU). The IDE and SCSI device layers use this</span>
<span class="p_del">- * boolean for bounce buffer decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS     0</span>
<span class="p_del">-</span>
 #endif /* __tilegx__ */
 
 int __init tile_pci_init(void);
<span class="p_header">diff --git a/arch/tile/kernel/pci-dma.c b/arch/tile/kernel/pci-dma.c</span>
<span class="p_header">index f2abedc8a080..81d0c2079fc8 100644</span>
<span class="p_header">--- a/arch/tile/kernel/pci-dma.c</span>
<span class="p_header">+++ b/arch/tile/kernel/pci-dma.c</span>
<span class="p_chunk">@@ -537,6 +537,7 @@</span> <span class="p_context"> static const struct dma_map_ops pci_swiotlb_dma_ops = {</span>
 	.sync_sg_for_device = swiotlb_sync_sg_for_device,
 	.dma_supported = swiotlb_dma_supported,
 	.mapping_error = swiotlb_dma_mapping_error,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 static const struct dma_map_ops pci_hybrid_dma_ops = {
<span class="p_chunk">@@ -550,6 +551,7 @@</span> <span class="p_context"> static const struct dma_map_ops pci_hybrid_dma_ops = {</span>
 	.sync_single_for_device = tile_pci_dma_sync_single_for_device,
 	.sync_sg_for_cpu = tile_pci_dma_sync_sg_for_cpu,
 	.sync_sg_for_device = tile_pci_dma_sync_sg_for_device,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 const struct dma_map_ops *gx_legacy_pci_dma_map_ops = &amp;pci_swiotlb_dma_ops;
<span class="p_header">diff --git a/arch/x86/include/asm/pci.h b/arch/x86/include/asm/pci.h</span>
<span class="p_header">index d32175e30259..fecde74ff549 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pci.h</span>
<span class="p_chunk">@@ -118,8 +118,6 @@</span> <span class="p_context"> void native_restore_msi_irqs(struct pci_dev *dev);</span>
 #define native_teardown_msi_irq		NULL
 #endif
 
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS (dma_ops-&gt;is_phys)</span>
<span class="p_del">-</span>
 #endif  /* __KERNEL__ */
 
 #ifdef CONFIG_X86_64
<span class="p_header">diff --git a/arch/x86/kernel/amd_gart_64.c b/arch/x86/kernel/amd_gart_64.c</span>
<span class="p_header">index cc0e8bc0ea3f..a837d24cbca3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/amd_gart_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/amd_gart_64.c</span>
<span class="p_chunk">@@ -705,6 +705,7 @@</span> <span class="p_context"> static const struct dma_map_ops gart_dma_ops = {</span>
 	.free				= gart_free_coherent,
 	.mapping_error			= gart_mapping_error,
 	.dma_supported			= x86_dma_supported,
<span class="p_add">+	.is_iommu			= true,</span>
 };
 
 static void gart_iommu_shutdown(void)
<span class="p_header">diff --git a/arch/x86/kernel/pci-calgary_64.c b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">index 35c461f21815..83f1e4feeede 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_chunk">@@ -494,6 +494,7 @@</span> <span class="p_context"> static const struct dma_map_ops calgary_dma_ops = {</span>
 	.unmap_page = calgary_unmap_page,
 	.mapping_error = calgary_mapping_error,
 	.dma_supported = x86_dma_supported,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 static inline void __iomem * busno_to_bbar(unsigned char num)
<span class="p_header">diff --git a/arch/x86/kernel/pci-nommu.c b/arch/x86/kernel/pci-nommu.c</span>
<span class="p_header">index b0caae27e1b7..0a2a8e629381 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-nommu.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-nommu.c</span>
<span class="p_chunk">@@ -103,7 +103,6 @@</span> <span class="p_context"> const struct dma_map_ops nommu_dma_ops = {</span>
 	.map_page		= nommu_map_page,
 	.sync_single_for_device = nommu_sync_single_for_device,
 	.sync_sg_for_device	= nommu_sync_sg_for_device,
<span class="p_del">-	.is_phys		= 1,</span>
 	.mapping_error		= nommu_mapping_error,
 	.dma_supported		= x86_dma_supported,
 };
<span class="p_header">diff --git a/arch/x86/kernel/pci-swiotlb.c b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">index 53bd05ea90d8..f08953617841 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"> static const struct dma_map_ops swiotlb_dma_ops = {</span>
 	.map_page = swiotlb_map_page,
 	.unmap_page = swiotlb_unmap_page,
 	.dma_supported = NULL,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 /*
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">index d9a9e9fc75dd..cccbd7bff0d6 100644</span>
<span class="p_header">--- a/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_chunk">@@ -425,6 +425,7 @@</span> <span class="p_context"> static const struct dma_map_ops sev_dma_ops = {</span>
 	.sync_sg_for_cpu        = swiotlb_sync_sg_for_cpu,
 	.sync_sg_for_device     = swiotlb_sync_sg_for_device,
 	.mapping_error          = swiotlb_dma_mapping_error,
<span class="p_add">+	.is_iommu		= true,</span>
 };
 
 /* Architecture __weak replacement functions */
<span class="p_header">diff --git a/arch/x86/pci/sta2x11-fixup.c b/arch/x86/pci/sta2x11-fixup.c</span>
<span class="p_header">index 53d600217973..a03e1c6a1aea 100644</span>
<span class="p_header">--- a/arch/x86/pci/sta2x11-fixup.c</span>
<span class="p_header">+++ b/arch/x86/pci/sta2x11-fixup.c</span>
<span class="p_chunk">@@ -193,6 +193,7 @@</span> <span class="p_context"> static const struct dma_map_ops sta2x11_dma_ops = {</span>
 	.sync_sg_for_device = swiotlb_sync_sg_for_device,
 	.mapping_error = swiotlb_dma_mapping_error,
 	.dma_supported = x86_dma_supported,
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 /* At setup time, we use our own ops if the device is a ConneXt one */
<span class="p_header">diff --git a/arch/xtensa/include/asm/pci.h b/arch/xtensa/include/asm/pci.h</span>
<span class="p_header">index 5c83798e3b2e..7949349294c7 100644</span>
<span class="p_header">--- a/arch/xtensa/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/xtensa/include/asm/pci.h</span>
<span class="p_chunk">@@ -37,13 +37,6 @@</span> <span class="p_context"> extern struct pci_controller* pcibios_alloc_controller(void);</span>
 #include &lt;linux/string.h&gt;
 #include &lt;asm/io.h&gt;
 
<span class="p_del">-/* The PCI address space does equal the physical memory address space.</span>
<span class="p_del">- * The networking and block device layers use this boolean for bounce buffer</span>
<span class="p_del">- * decisions.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(1)</span>
<span class="p_del">-</span>
 /* Tell drivers/pci/proc.c that we have pci_mmap_page_range() */
 #define HAVE_PCI_MMAP		1
 #define arch_can_pci_mmap_io()	1
<span class="p_header">diff --git a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c</span>
<span class="p_header">index e1180fa46196..dca9ac4a9376 100644</span>
<span class="p_header">--- a/drivers/ide/ide-lib.c</span>
<span class="p_header">+++ b/drivers/ide/ide-lib.c</span>
<span class="p_chunk">@@ -17,13 +17,12 @@</span> <span class="p_context"></span>
 
 void ide_toggle_bounce(ide_drive_t *drive, int on)
 {
<span class="p_add">+	struct device *dev = drive-&gt;hwif ? drive-&gt;hwif-&gt;dev : NULL;</span>
 	u64 addr = BLK_BOUNCE_HIGH;	/* dma64_addr_t */
 
<span class="p_del">-	if (!PCI_DMA_BUS_IS_PHYS) {</span>
<span class="p_add">+	if (dev &amp;&amp; dma_is_iommu(dev)) {</span>
 		addr = BLK_BOUNCE_ANY;
 	} else if (on &amp;&amp; drive-&gt;media == ide_disk) {
<span class="p_del">-		struct device *dev = drive-&gt;hwif-&gt;dev;</span>
<span class="p_del">-</span>
 		if (dev &amp;&amp; dev-&gt;dma_mask)
 			addr = *dev-&gt;dma_mask;
 	}
<span class="p_header">diff --git a/drivers/ide/ide-probe.c b/drivers/ide/ide-probe.c</span>
<span class="p_header">index 17fd55af4d92..33f5c8ec59b1 100644</span>
<span class="p_header">--- a/drivers/ide/ide-probe.c</span>
<span class="p_header">+++ b/drivers/ide/ide-probe.c</span>
<span class="p_chunk">@@ -796,7 +796,7 @@</span> <span class="p_context"> static int ide_init_queue(ide_drive_t *drive)</span>
 	 * This will be fixed once we teach pci_map_sg() about our boundary
 	 * requirements, hopefully soon. *FIXME*
 	 */
<span class="p_del">-	if (!PCI_DMA_BUS_IS_PHYS)</span>
<span class="p_add">+	if (hwif-&gt;dev &amp;&amp; dma_is_iommu(hwif-&gt;dev))</span>
 		max_sg_entries &gt;&gt;= 1;
 #endif /* CONFIG_PCI */
 
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 7d5eb004091d..84ec2ccfd6f7 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -2686,6 +2686,7 @@</span> <span class="p_context"> static const struct dma_map_ops amd_iommu_dma_ops = {</span>
 	.unmap_sg	= unmap_sg,
 	.dma_supported	= amd_iommu_dma_supported,
 	.mapping_error	= amd_iommu_mapping_error,
<span class="p_add">+	.is_iommu	= true,</span>
 };
 
 static int init_reserved_iova_ranges(void)
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index a0babdbf7146..568eb86c5bf4 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -3872,6 +3872,7 @@</span> <span class="p_context"> const struct dma_map_ops intel_dma_ops = {</span>
 #ifdef CONFIG_X86
 	.dma_supported = x86_dma_supported,
 #endif
<span class="p_add">+	.is_iommu = true,</span>
 };
 
 static inline int iommu_domain_cache_init(void)
<span class="p_header">diff --git a/drivers/parisc/ccio-dma.c b/drivers/parisc/ccio-dma.c</span>
<span class="p_header">index acba1f56af3e..3e7f3a14a1a2 100644</span>
<span class="p_header">--- a/drivers/parisc/ccio-dma.c</span>
<span class="p_header">+++ b/drivers/parisc/ccio-dma.c</span>
<span class="p_chunk">@@ -1039,6 +1039,7 @@</span> <span class="p_context"> static const struct dma_map_ops ccio_ops = {</span>
 	.map_sg = 		ccio_map_sg,
 	.unmap_sg = 		ccio_unmap_sg,
 	.mapping_error =	ccio_mapping_error,
<span class="p_add">+	.is_iommu =		true,</span>
 };
 
 #ifdef CONFIG_PROC_FS
<span class="p_chunk">@@ -1596,8 +1597,6 @@</span> <span class="p_context"> static int __init ccio_probe(struct parisc_device *dev)</span>
 	}
 #endif
 	ioc_count++;
<span class="p_del">-</span>
<span class="p_del">-	parisc_has_iommu();</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/parisc/sba_iommu.c b/drivers/parisc/sba_iommu.c</span>
<span class="p_header">index 0a9c762a70fa..f6e92a7a3607 100644</span>
<span class="p_header">--- a/drivers/parisc/sba_iommu.c</span>
<span class="p_header">+++ b/drivers/parisc/sba_iommu.c</span>
<span class="p_chunk">@@ -1099,6 +1099,7 @@</span> <span class="p_context"> static const struct dma_map_ops sba_ops = {</span>
 	.map_sg =		sba_map_sg,
 	.unmap_sg =		sba_unmap_sg,
 	.mapping_error =	sba_mapping_error,
<span class="p_add">+	.is_iommu =		true,</span>
 };
 
 
<span class="p_chunk">@@ -2017,8 +2018,6 @@</span> <span class="p_context"> static int __init sba_driver_callback(struct parisc_device *dev)</span>
 	proc_create(&quot;sba_iommu&quot;, 0, root, &amp;sba_proc_fops);
 	proc_create(&quot;sba_iommu-bitmap&quot;, 0, root, &amp;sba_proc_bitmap_fops);
 #endif
<span class="p_del">-</span>
<span class="p_del">-	parisc_has_iommu();</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/pci/host/vmd.c b/drivers/pci/host/vmd.c</span>
<span class="p_header">index 509893bc3e63..b9a750721211 100644</span>
<span class="p_header">--- a/drivers/pci/host/vmd.c</span>
<span class="p_header">+++ b/drivers/pci/host/vmd.c</span>
<span class="p_chunk">@@ -428,6 +428,7 @@</span> <span class="p_context"> static void vmd_setup_dma_ops(struct vmd_dev *vmd)</span>
 #ifdef ARCH_HAS_DMA_GET_REQUIRED_MASK
 	ASSIGN_VMD_DMA_OPS(source, dest, get_required_mask);
 #endif
<span class="p_add">+	ASSIGN_VMD_DMA_OPS(source, dest, is_iommu);</span>
 	add_dma_domain(domain);
 }
 #undef ASSIGN_VMD_DMA_OPS
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index 1cbc497e00bd..7d78f7bc1126 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -2103,16 +2103,14 @@</span> <span class="p_context"> static u64 scsi_calculate_bounce_limit(struct Scsi_Host *shost)</span>
 
 	if (shost-&gt;unchecked_isa_dma)
 		return BLK_BOUNCE_ISA;
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Platforms with virtual-DMA translation</span>
<span class="p_del">-	 * hardware have no practical limit.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!PCI_DMA_BUS_IS_PHYS)</span>
<span class="p_del">-		return BLK_BOUNCE_ANY;</span>
 
 	host_dev = scsi_get_device(shost);
<span class="p_del">-	if (host_dev &amp;&amp; host_dev-&gt;dma_mask)</span>
<span class="p_del">-		bounce_limit = (u64)dma_max_pfn(host_dev) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	if (host_dev) {</span>
<span class="p_add">+		if (dma_is_iommu(host_dev))</span>
<span class="p_add">+			return BLK_BOUNCE_ANY;</span>
<span class="p_add">+		if (host_dev-&gt;dma_mask)</span>
<span class="p_add">+			bounce_limit = (u64)dma_max_pfn(host_dev) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	}</span>
 
 	return bounce_limit;
 }
<span class="p_header">diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">index 82fc54f8eb77..ced9ac999d5a 100644</span>
<span class="p_header">--- a/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">+++ b/drivers/xen/swiotlb-xen.c</span>
<span class="p_chunk">@@ -726,4 +726,5 @@</span> <span class="p_context"> const struct dma_map_ops xen_swiotlb_dma_ops = {</span>
 	.mmap = xen_swiotlb_dma_mmap,
 	.get_sgtable = xen_swiotlb_get_sgtable,
 	.mapping_error	= xen_swiotlb_mapping_error,
<span class="p_add">+	.is_iommu = true,</span>
 };
<span class="p_header">diff --git a/include/asm-generic/pci.h b/include/asm-generic/pci.h</span>
<span class="p_header">index 830d7659289b..6bb3cd3d695a 100644</span>
<span class="p_header">--- a/include/asm-generic/pci.h</span>
<span class="p_header">+++ b/include/asm-generic/pci.h</span>
<span class="p_chunk">@@ -14,12 +14,4 @@</span> <span class="p_context"> static inline int pci_get_legacy_ide_irq(struct pci_dev *dev, int channel)</span>
 }
 #endif /* HAVE_ARCH_PCI_GET_LEGACY_IDE_IRQ */
 
<span class="p_del">-/*</span>
<span class="p_del">- * By default, assume that no iommu is in use and that the PCI</span>
<span class="p_del">- * space is mapped to address physical 0.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifndef PCI_DMA_BUS_IS_PHYS</span>
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS	(1)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 #endif /* _ASM_GENERIC_PCI_H */
<span class="p_header">diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h</span>
<span class="p_header">index 86beb9861618..7201849703cc 100644</span>
<span class="p_header">--- a/include/linux/dma-mapping.h</span>
<span class="p_header">+++ b/include/linux/dma-mapping.h</span>
<span class="p_chunk">@@ -133,7 +133,7 @@</span> <span class="p_context"> struct dma_map_ops {</span>
 #ifdef ARCH_HAS_DMA_GET_REQUIRED_MASK
 	u64 (*get_required_mask)(struct device *dev);
 #endif
<span class="p_del">-	int is_phys;</span>
<span class="p_add">+	bool is_iommu;	/* if true can map any physical address */</span>
 };
 
 extern const struct dma_map_ops dma_noop_ops;
<span class="p_chunk">@@ -689,6 +689,20 @@</span> <span class="p_context"> static inline int dma_set_seg_boundary(struct device *dev, unsigned long mask)</span>
 	return -EIO;
 }
 
<span class="p_add">+#ifdef CONFIG_HAS_DMA</span>
<span class="p_add">+static inline bool dma_is_iommu(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct dma_map_ops *ops = get_dma_ops(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ops &amp;&amp; ops-&gt;is_iommu;</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline bool dma_is_iommu(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #ifndef dma_max_pfn
 static inline unsigned long dma_max_pfn(struct device *dev)
 {
<span class="p_header">diff --git a/lib/dma-virt.c b/lib/dma-virt.c</span>
<span class="p_header">index 8e61a02ef9ca..b652ecb853fa 100644</span>
<span class="p_header">--- a/lib/dma-virt.c</span>
<span class="p_header">+++ b/lib/dma-virt.c</span>
<span class="p_chunk">@@ -57,5 +57,6 @@</span> <span class="p_context"> const struct dma_map_ops dma_virt_ops = {</span>
 	.free			= dma_virt_free,
 	.map_page		= dma_virt_map_page,
 	.map_sg			= dma_virt_map_sg,
<span class="p_add">+	.is_iommu		= true,</span>
 };
 EXPORT_SYMBOL(dma_virt_ops);
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 07ed21d64f92..5ccd7ba3fd55 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2830,6 +2830,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(netdev_rx_csum_fault);</span>
 static int illegal_highdma(struct net_device *dev, struct sk_buff *skb)
 {
 #ifdef CONFIG_HIGHMEM
<span class="p_add">+	struct device *pdev = dev-&gt;dev.parent;</span>
 	int i;
 
 	if (!(dev-&gt;features &amp; NETIF_F_HIGHDMA)) {
<span class="p_chunk">@@ -2841,18 +2842,15 @@</span> <span class="p_context"> static int illegal_highdma(struct net_device *dev, struct sk_buff *skb)</span>
 		}
 	}
 
<span class="p_del">-	if (PCI_DMA_BUS_IS_PHYS) {</span>
<span class="p_del">-		struct device *pdev = dev-&gt;dev.parent;</span>
<span class="p_add">+	if (!pdev || dma_is_iommu(pdev))</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-		if (!pdev)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		for (i = 0; i &lt; skb_shinfo(skb)-&gt;nr_frags; i++) {</span>
<span class="p_del">-			skb_frag_t *frag = &amp;skb_shinfo(skb)-&gt;frags[i];</span>
<span class="p_del">-			dma_addr_t addr = page_to_phys(skb_frag_page(frag));</span>
<span class="p_add">+	for (i = 0; i &lt; skb_shinfo(skb)-&gt;nr_frags; i++) {</span>
<span class="p_add">+		skb_frag_t *frag = &amp;skb_shinfo(skb)-&gt;frags[i];</span>
<span class="p_add">+		dma_addr_t addr = page_to_phys(skb_frag_page(frag));</span>
 
<span class="p_del">-			if (!pdev-&gt;dma_mask || addr + PAGE_SIZE - 1 &gt; *pdev-&gt;dma_mask)</span>
<span class="p_del">-				return 1;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!pdev-&gt;dma_mask || addr + PAGE_SIZE - 1 &gt; *pdev-&gt;dma_mask)</span>
<span class="p_add">+			return 1;</span>
 	}
 #endif
 	return 0;
<span class="p_header">diff --git a/tools/virtio/linux/dma-mapping.h b/tools/virtio/linux/dma-mapping.h</span>
<span class="p_header">index 1571e24e9494..f91aeb5fe571 100644</span>
<span class="p_header">--- a/tools/virtio/linux/dma-mapping.h</span>
<span class="p_header">+++ b/tools/virtio/linux/dma-mapping.h</span>
<span class="p_chunk">@@ -6,8 +6,6 @@</span> <span class="p_context"></span>
 # error Virtio userspace code does not support CONFIG_HAS_DMA
 #endif
 
<span class="p_del">-#define PCI_DMA_BUS_IS_PHYS 1</span>
<span class="p_del">-</span>
 enum dma_data_direction {
 	DMA_BIDIRECTIONAL = 0,
 	DMA_TO_DEVICE = 1,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



